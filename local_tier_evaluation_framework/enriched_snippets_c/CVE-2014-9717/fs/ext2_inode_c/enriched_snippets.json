[
  {
    "function_name": "ext2_setattr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext2/inode.c",
    "lines": "1549-1577",
    "snippet": "int ext2_setattr(struct dentry *dentry, struct iattr *iattr)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tint error;\n\n\terror = inode_change_ok(inode, iattr);\n\tif (error)\n\t\treturn error;\n\n\tif (is_quota_modification(inode, iattr))\n\t\tdquot_initialize(inode);\n\tif ((iattr->ia_valid & ATTR_UID && !uid_eq(iattr->ia_uid, inode->i_uid)) ||\n\t    (iattr->ia_valid & ATTR_GID && !gid_eq(iattr->ia_gid, inode->i_gid))) {\n\t\terror = dquot_transfer(inode, iattr);\n\t\tif (error)\n\t\t\treturn error;\n\t}\n\tif (iattr->ia_valid & ATTR_SIZE && iattr->ia_size != inode->i_size) {\n\t\terror = ext2_setsize(inode, iattr->ia_size);\n\t\tif (error)\n\t\t\treturn error;\n\t}\n\tsetattr_copy(inode, iattr);\n\tif (iattr->ia_valid & ATTR_MODE)\n\t\terror = posix_acl_chmod(inode, inode->i_mode);\n\tmark_inode_dirty(inode);\n\n\treturn error;\n}",
    "includes": [
      "#include \"xattr.h\"",
      "#include \"acl.h\"",
      "#include \"ext2.h\"",
      "#include <linux/aio.h>",
      "#include <linux/namei.h>",
      "#include <linux/fiemap.h>",
      "#include <linux/mpage.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/writeback.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/highuid.h>",
      "#include <linux/time.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mark_inode_dirty",
          "args": [
            "inode"
          ],
          "line": 1574
        },
        "resolved": true,
        "details": {
          "function_name": "block_dump___mark_inode_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fs-writeback.c",
          "lines": "1134-1154",
          "snippet": "static noinline void block_dump___mark_inode_dirty(struct inode *inode)\n{\n\tif (inode->i_ino || strcmp(inode->i_sb->s_id, \"bdev\")) {\n\t\tstruct dentry *dentry;\n\t\tconst char *name = \"?\";\n\n\t\tdentry = d_find_alias(inode);\n\t\tif (dentry) {\n\t\t\tspin_lock(&dentry->d_lock);\n\t\t\tname = (const char *) dentry->d_name.name;\n\t\t}\n\t\tprintk(KERN_DEBUG\n\t\t       \"%s(%d): dirtied inode %lu (%s) on %s\\n\",\n\t\t       current->comm, task_pid_nr(current), inode->i_ino,\n\t\t       name, inode->i_sb->s_id);\n\t\tif (dentry) {\n\t\t\tspin_unlock(&dentry->d_lock);\n\t\t\tdput(dentry);\n\t\t}\n\t}\n}",
          "includes": [
            "#include <trace/events/writeback.h>",
            "#include \"internal.h\"",
            "#include <linux/device.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/writeback.h>\n#include \"internal.h\"\n#include <linux/device.h>\n#include <linux/tracepoint.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nstatic noinline void block_dump___mark_inode_dirty(struct inode *inode)\n{\n\tif (inode->i_ino || strcmp(inode->i_sb->s_id, \"bdev\")) {\n\t\tstruct dentry *dentry;\n\t\tconst char *name = \"?\";\n\n\t\tdentry = d_find_alias(inode);\n\t\tif (dentry) {\n\t\t\tspin_lock(&dentry->d_lock);\n\t\t\tname = (const char *) dentry->d_name.name;\n\t\t}\n\t\tprintk(KERN_DEBUG\n\t\t       \"%s(%d): dirtied inode %lu (%s) on %s\\n\",\n\t\t       current->comm, task_pid_nr(current), inode->i_ino,\n\t\t       name, inode->i_sb->s_id);\n\t\tif (dentry) {\n\t\t\tspin_unlock(&dentry->d_lock);\n\t\t\tdput(dentry);\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "posix_acl_chmod",
          "args": [
            "inode",
            "inode->i_mode"
          ],
          "line": 1573
        },
        "resolved": true,
        "details": {
          "function_name": "posix_acl_chmod",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/posix_acl.c",
          "lines": "518-542",
          "snippet": "int\nposix_acl_chmod(struct inode *inode, umode_t mode)\n{\n\tstruct posix_acl *acl;\n\tint ret = 0;\n\n\tif (!IS_POSIXACL(inode))\n\t\treturn 0;\n\tif (!inode->i_op->set_acl)\n\t\treturn -EOPNOTSUPP;\n\n\tacl = get_acl(inode, ACL_TYPE_ACCESS);\n\tif (IS_ERR_OR_NULL(acl)) {\n\t\tif (acl == ERR_PTR(-EOPNOTSUPP))\n\t\t\treturn 0;\n\t\treturn PTR_ERR(acl);\n\t}\n\n\tret = __posix_acl_chmod(&acl, GFP_KERNEL, mode);\n\tif (ret)\n\t\treturn ret;\n\tret = inode->i_op->set_acl(inode, acl, ACL_TYPE_ACCESS);\n\tposix_acl_release(acl);\n\treturn ret;\n}",
          "includes": [
            "#include <linux/user_namespace.h>",
            "#include <linux/export.h>",
            "#include <linux/xattr.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/sched.h>",
            "#include <linux/fs.h>",
            "#include <linux/atomic.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/user_namespace.h>\n#include <linux/export.h>\n#include <linux/xattr.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/posix_acl.h>\n#include <linux/sched.h>\n#include <linux/fs.h>\n#include <linux/atomic.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nint\nposix_acl_chmod(struct inode *inode, umode_t mode)\n{\n\tstruct posix_acl *acl;\n\tint ret = 0;\n\n\tif (!IS_POSIXACL(inode))\n\t\treturn 0;\n\tif (!inode->i_op->set_acl)\n\t\treturn -EOPNOTSUPP;\n\n\tacl = get_acl(inode, ACL_TYPE_ACCESS);\n\tif (IS_ERR_OR_NULL(acl)) {\n\t\tif (acl == ERR_PTR(-EOPNOTSUPP))\n\t\t\treturn 0;\n\t\treturn PTR_ERR(acl);\n\t}\n\n\tret = __posix_acl_chmod(&acl, GFP_KERNEL, mode);\n\tif (ret)\n\t\treturn ret;\n\tret = inode->i_op->set_acl(inode, acl, ACL_TYPE_ACCESS);\n\tposix_acl_release(acl);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "setattr_copy",
          "args": [
            "inode",
            "iattr"
          ],
          "line": 1571
        },
        "resolved": true,
        "details": {
          "function_name": "setattr_copy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/attr.c",
          "lines": "142-167",
          "snippet": "void setattr_copy(struct inode *inode, const struct iattr *attr)\n{\n\tunsigned int ia_valid = attr->ia_valid;\n\n\tif (ia_valid & ATTR_UID)\n\t\tinode->i_uid = attr->ia_uid;\n\tif (ia_valid & ATTR_GID)\n\t\tinode->i_gid = attr->ia_gid;\n\tif (ia_valid & ATTR_ATIME)\n\t\tinode->i_atime = timespec_trunc(attr->ia_atime,\n\t\t\t\t\t\tinode->i_sb->s_time_gran);\n\tif (ia_valid & ATTR_MTIME)\n\t\tinode->i_mtime = timespec_trunc(attr->ia_mtime,\n\t\t\t\t\t\tinode->i_sb->s_time_gran);\n\tif (ia_valid & ATTR_CTIME)\n\t\tinode->i_ctime = timespec_trunc(attr->ia_ctime,\n\t\t\t\t\t\tinode->i_sb->s_time_gran);\n\tif (ia_valid & ATTR_MODE) {\n\t\tumode_t mode = attr->ia_mode;\n\n\t\tif (!in_group_p(inode->i_gid) &&\n\t\t    !capable_wrt_inode_uidgid(inode, CAP_FSETID))\n\t\t\tmode &= ~S_ISGID;\n\t\tinode->i_mode = mode;\n\t}\n}",
          "includes": [
            "#include <linux/ima.h>",
            "#include <linux/evm.h>",
            "#include <linux/security.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/capability.h>",
            "#include <linux/string.h>",
            "#include <linux/mm.h>",
            "#include <linux/time.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ima.h>\n#include <linux/evm.h>\n#include <linux/security.h>\n#include <linux/fcntl.h>\n#include <linux/fsnotify.h>\n#include <linux/capability.h>\n#include <linux/string.h>\n#include <linux/mm.h>\n#include <linux/time.h>\n#include <linux/export.h>\n\nvoid setattr_copy(struct inode *inode, const struct iattr *attr)\n{\n\tunsigned int ia_valid = attr->ia_valid;\n\n\tif (ia_valid & ATTR_UID)\n\t\tinode->i_uid = attr->ia_uid;\n\tif (ia_valid & ATTR_GID)\n\t\tinode->i_gid = attr->ia_gid;\n\tif (ia_valid & ATTR_ATIME)\n\t\tinode->i_atime = timespec_trunc(attr->ia_atime,\n\t\t\t\t\t\tinode->i_sb->s_time_gran);\n\tif (ia_valid & ATTR_MTIME)\n\t\tinode->i_mtime = timespec_trunc(attr->ia_mtime,\n\t\t\t\t\t\tinode->i_sb->s_time_gran);\n\tif (ia_valid & ATTR_CTIME)\n\t\tinode->i_ctime = timespec_trunc(attr->ia_ctime,\n\t\t\t\t\t\tinode->i_sb->s_time_gran);\n\tif (ia_valid & ATTR_MODE) {\n\t\tumode_t mode = attr->ia_mode;\n\n\t\tif (!in_group_p(inode->i_gid) &&\n\t\t    !capable_wrt_inode_uidgid(inode, CAP_FSETID))\n\t\t\tmode &= ~S_ISGID;\n\t\tinode->i_mode = mode;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext2_setsize",
          "args": [
            "inode",
            "iattr->ia_size"
          ],
          "line": 1567
        },
        "resolved": true,
        "details": {
          "function_name": "ext2_setsize",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext2/inode.c",
          "lines": "1191-1228",
          "snippet": "static int ext2_setsize(struct inode *inode, loff_t newsize)\n{\n\tint error;\n\n\tif (!(S_ISREG(inode->i_mode) || S_ISDIR(inode->i_mode) ||\n\t    S_ISLNK(inode->i_mode)))\n\t\treturn -EINVAL;\n\tif (ext2_inode_is_fast_symlink(inode))\n\t\treturn -EINVAL;\n\tif (IS_APPEND(inode) || IS_IMMUTABLE(inode))\n\t\treturn -EPERM;\n\n\tinode_dio_wait(inode);\n\n\tif (IS_DAX(inode))\n\t\terror = dax_truncate_page(inode, newsize, ext2_get_block);\n\telse if (test_opt(inode->i_sb, NOBH))\n\t\terror = nobh_truncate_page(inode->i_mapping,\n\t\t\t\tnewsize, ext2_get_block);\n\telse\n\t\terror = block_truncate_page(inode->i_mapping,\n\t\t\t\tnewsize, ext2_get_block);\n\tif (error)\n\t\treturn error;\n\n\ttruncate_setsize(inode, newsize);\n\t__ext2_truncate_blocks(inode, newsize);\n\n\tinode->i_mtime = inode->i_ctime = CURRENT_TIME_SEC;\n\tif (inode_needs_sync(inode)) {\n\t\tsync_mapping_buffers(inode->i_mapping);\n\t\tsync_inode_metadata(inode, 1);\n\t} else {\n\t\tmark_inode_dirty(inode);\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"xattr.h\"",
            "#include \"acl.h\"",
            "#include \"ext2.h\"",
            "#include <linux/aio.h>",
            "#include <linux/namei.h>",
            "#include <linux/fiemap.h>",
            "#include <linux/mpage.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/writeback.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highuid.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xattr.h\"\n#include \"acl.h\"\n#include \"ext2.h\"\n#include <linux/aio.h>\n#include <linux/namei.h>\n#include <linux/fiemap.h>\n#include <linux/mpage.h>\n#include <linux/buffer_head.h>\n#include <linux/writeback.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/highuid.h>\n#include <linux/time.h>\n\nstatic int ext2_setsize(struct inode *inode, loff_t newsize)\n{\n\tint error;\n\n\tif (!(S_ISREG(inode->i_mode) || S_ISDIR(inode->i_mode) ||\n\t    S_ISLNK(inode->i_mode)))\n\t\treturn -EINVAL;\n\tif (ext2_inode_is_fast_symlink(inode))\n\t\treturn -EINVAL;\n\tif (IS_APPEND(inode) || IS_IMMUTABLE(inode))\n\t\treturn -EPERM;\n\n\tinode_dio_wait(inode);\n\n\tif (IS_DAX(inode))\n\t\terror = dax_truncate_page(inode, newsize, ext2_get_block);\n\telse if (test_opt(inode->i_sb, NOBH))\n\t\terror = nobh_truncate_page(inode->i_mapping,\n\t\t\t\tnewsize, ext2_get_block);\n\telse\n\t\terror = block_truncate_page(inode->i_mapping,\n\t\t\t\tnewsize, ext2_get_block);\n\tif (error)\n\t\treturn error;\n\n\ttruncate_setsize(inode, newsize);\n\t__ext2_truncate_blocks(inode, newsize);\n\n\tinode->i_mtime = inode->i_ctime = CURRENT_TIME_SEC;\n\tif (inode_needs_sync(inode)) {\n\t\tsync_mapping_buffers(inode->i_mapping);\n\t\tsync_inode_metadata(inode, 1);\n\t} else {\n\t\tmark_inode_dirty(inode);\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dquot_transfer",
          "args": [
            "inode",
            "iattr"
          ],
          "line": 1562
        },
        "resolved": true,
        "details": {
          "function_name": "dquot_transfer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/quota/dquot.c",
          "lines": "1933-1950",
          "snippet": "int dquot_transfer(struct inode *inode, struct iattr *iattr)\n{\n\tstruct dquot *transfer_to[MAXQUOTAS] = {};\n\tstruct super_block *sb = inode->i_sb;\n\tint ret;\n\n\tif (!dquot_active(inode))\n\t\treturn 0;\n\n\tif (iattr->ia_valid & ATTR_UID && !uid_eq(iattr->ia_uid, inode->i_uid))\n\t\ttransfer_to[USRQUOTA] = dqget(sb, make_kqid_uid(iattr->ia_uid));\n\tif (iattr->ia_valid & ATTR_GID && !gid_eq(iattr->ia_gid, inode->i_gid))\n\t\ttransfer_to[GRPQUOTA] = dqget(sb, make_kqid_gid(iattr->ia_gid));\n\n\tret = __dquot_transfer(inode, transfer_to);\n\tdqput_all(transfer_to);\n\treturn ret;\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include \"../internal.h\" /* ugh */",
            "#include <linux/quotaops.h>",
            "#include <linux/capability.h>",
            "#include <linux/namei.h>",
            "#include <linux/kmod.h>",
            "#include <linux/sched.h>",
            "#include <linux/security.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>",
            "#include <linux/tty.h>",
            "#include <linux/stat.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/time.h>",
            "#include <linux/mm.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static qsize_t inode_get_rsv_space(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include \"../internal.h\" /* ugh */\n#include <linux/quotaops.h>\n#include <linux/capability.h>\n#include <linux/namei.h>\n#include <linux/kmod.h>\n#include <linux/sched.h>\n#include <linux/security.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/sysctl.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/tty.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/time.h>\n#include <linux/mm.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/kernel.h>\n#include <linux/errno.h>\n\nstatic qsize_t inode_get_rsv_space(struct inode *inode);\n\nint dquot_transfer(struct inode *inode, struct iattr *iattr)\n{\n\tstruct dquot *transfer_to[MAXQUOTAS] = {};\n\tstruct super_block *sb = inode->i_sb;\n\tint ret;\n\n\tif (!dquot_active(inode))\n\t\treturn 0;\n\n\tif (iattr->ia_valid & ATTR_UID && !uid_eq(iattr->ia_uid, inode->i_uid))\n\t\ttransfer_to[USRQUOTA] = dqget(sb, make_kqid_uid(iattr->ia_uid));\n\tif (iattr->ia_valid & ATTR_GID && !gid_eq(iattr->ia_gid, inode->i_gid))\n\t\ttransfer_to[GRPQUOTA] = dqget(sb, make_kqid_gid(iattr->ia_gid));\n\n\tret = __dquot_transfer(inode, transfer_to);\n\tdqput_all(transfer_to);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "gid_eq",
          "args": [
            "iattr->ia_gid",
            "inode->i_gid"
          ],
          "line": 1561
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "uid_eq",
          "args": [
            "iattr->ia_uid",
            "inode->i_uid"
          ],
          "line": 1560
        },
        "resolved": true,
        "details": {
          "function_name": "uuid_equal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/uuid.c",
          "lines": "59-63",
          "snippet": "int\nuuid_equal(uuid_t *uuid1, uuid_t *uuid2)\n{\n\treturn memcmp(uuid1, uuid2, sizeof(uuid_t)) ? 0 : 1;\n}",
          "includes": [
            "#include <xfs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <xfs.h>\n\nint\nuuid_equal(uuid_t *uuid1, uuid_t *uuid2)\n{\n\treturn memcmp(uuid1, uuid2, sizeof(uuid_t)) ? 0 : 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dquot_initialize",
          "args": [
            "inode"
          ],
          "line": 1559
        },
        "resolved": true,
        "details": {
          "function_name": "dquot_initialize",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/quota/dquot.c",
          "lines": "1459-1462",
          "snippet": "void dquot_initialize(struct inode *inode)\n{\n\t__dquot_initialize(inode, -1);\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include \"../internal.h\" /* ugh */",
            "#include <linux/quotaops.h>",
            "#include <linux/capability.h>",
            "#include <linux/namei.h>",
            "#include <linux/kmod.h>",
            "#include <linux/sched.h>",
            "#include <linux/security.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>",
            "#include <linux/tty.h>",
            "#include <linux/stat.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/time.h>",
            "#include <linux/mm.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static qsize_t inode_get_rsv_space(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include \"../internal.h\" /* ugh */\n#include <linux/quotaops.h>\n#include <linux/capability.h>\n#include <linux/namei.h>\n#include <linux/kmod.h>\n#include <linux/sched.h>\n#include <linux/security.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/sysctl.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/tty.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/time.h>\n#include <linux/mm.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/kernel.h>\n#include <linux/errno.h>\n\nstatic qsize_t inode_get_rsv_space(struct inode *inode);\n\nvoid dquot_initialize(struct inode *inode)\n{\n\t__dquot_initialize(inode, -1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "is_quota_modification",
          "args": [
            "inode",
            "iattr"
          ],
          "line": 1558
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "inode_change_ok",
          "args": [
            "inode",
            "iattr"
          ],
          "line": 1554
        },
        "resolved": true,
        "details": {
          "function_name": "inode_change_ok",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/attr.c",
          "lines": "31-81",
          "snippet": "int inode_change_ok(const struct inode *inode, struct iattr *attr)\n{\n\tunsigned int ia_valid = attr->ia_valid;\n\n\t/*\n\t * First check size constraints.  These can't be overriden using\n\t * ATTR_FORCE.\n\t */\n\tif (ia_valid & ATTR_SIZE) {\n\t\tint error = inode_newsize_ok(inode, attr->ia_size);\n\t\tif (error)\n\t\t\treturn error;\n\t}\n\n\t/* If force is set do it anyway. */\n\tif (ia_valid & ATTR_FORCE)\n\t\treturn 0;\n\n\t/* Make sure a caller can chown. */\n\tif ((ia_valid & ATTR_UID) &&\n\t    (!uid_eq(current_fsuid(), inode->i_uid) ||\n\t     !uid_eq(attr->ia_uid, inode->i_uid)) &&\n\t    !capable_wrt_inode_uidgid(inode, CAP_CHOWN))\n\t\treturn -EPERM;\n\n\t/* Make sure caller can chgrp. */\n\tif ((ia_valid & ATTR_GID) &&\n\t    (!uid_eq(current_fsuid(), inode->i_uid) ||\n\t    (!in_group_p(attr->ia_gid) && !gid_eq(attr->ia_gid, inode->i_gid))) &&\n\t    !capable_wrt_inode_uidgid(inode, CAP_CHOWN))\n\t\treturn -EPERM;\n\n\t/* Make sure a caller can chmod. */\n\tif (ia_valid & ATTR_MODE) {\n\t\tif (!inode_owner_or_capable(inode))\n\t\t\treturn -EPERM;\n\t\t/* Also check the setgid bit! */\n\t\tif (!in_group_p((ia_valid & ATTR_GID) ? attr->ia_gid :\n\t\t\t\tinode->i_gid) &&\n\t\t    !capable_wrt_inode_uidgid(inode, CAP_FSETID))\n\t\t\tattr->ia_mode &= ~S_ISGID;\n\t}\n\n\t/* Check for setting the inode time. */\n\tif (ia_valid & (ATTR_MTIME_SET | ATTR_ATIME_SET | ATTR_TIMES_SET)) {\n\t\tif (!inode_owner_or_capable(inode))\n\t\t\treturn -EPERM;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include <linux/ima.h>",
            "#include <linux/evm.h>",
            "#include <linux/security.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/capability.h>",
            "#include <linux/string.h>",
            "#include <linux/mm.h>",
            "#include <linux/time.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ima.h>\n#include <linux/evm.h>\n#include <linux/security.h>\n#include <linux/fcntl.h>\n#include <linux/fsnotify.h>\n#include <linux/capability.h>\n#include <linux/string.h>\n#include <linux/mm.h>\n#include <linux/time.h>\n#include <linux/export.h>\n\nint inode_change_ok(const struct inode *inode, struct iattr *attr)\n{\n\tunsigned int ia_valid = attr->ia_valid;\n\n\t/*\n\t * First check size constraints.  These can't be overriden using\n\t * ATTR_FORCE.\n\t */\n\tif (ia_valid & ATTR_SIZE) {\n\t\tint error = inode_newsize_ok(inode, attr->ia_size);\n\t\tif (error)\n\t\t\treturn error;\n\t}\n\n\t/* If force is set do it anyway. */\n\tif (ia_valid & ATTR_FORCE)\n\t\treturn 0;\n\n\t/* Make sure a caller can chown. */\n\tif ((ia_valid & ATTR_UID) &&\n\t    (!uid_eq(current_fsuid(), inode->i_uid) ||\n\t     !uid_eq(attr->ia_uid, inode->i_uid)) &&\n\t    !capable_wrt_inode_uidgid(inode, CAP_CHOWN))\n\t\treturn -EPERM;\n\n\t/* Make sure caller can chgrp. */\n\tif ((ia_valid & ATTR_GID) &&\n\t    (!uid_eq(current_fsuid(), inode->i_uid) ||\n\t    (!in_group_p(attr->ia_gid) && !gid_eq(attr->ia_gid, inode->i_gid))) &&\n\t    !capable_wrt_inode_uidgid(inode, CAP_CHOWN))\n\t\treturn -EPERM;\n\n\t/* Make sure a caller can chmod. */\n\tif (ia_valid & ATTR_MODE) {\n\t\tif (!inode_owner_or_capable(inode))\n\t\t\treturn -EPERM;\n\t\t/* Also check the setgid bit! */\n\t\tif (!in_group_p((ia_valid & ATTR_GID) ? attr->ia_gid :\n\t\t\t\tinode->i_gid) &&\n\t\t    !capable_wrt_inode_uidgid(inode, CAP_FSETID))\n\t\t\tattr->ia_mode &= ~S_ISGID;\n\t}\n\n\t/* Check for setting the inode time. */\n\tif (ia_valid & (ATTR_MTIME_SET | ATTR_ATIME_SET | ATTR_TIMES_SET)) {\n\t\tif (!inode_owner_or_capable(inode))\n\t\t\treturn -EPERM;\n\t}\n\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"xattr.h\"\n#include \"acl.h\"\n#include \"ext2.h\"\n#include <linux/aio.h>\n#include <linux/namei.h>\n#include <linux/fiemap.h>\n#include <linux/mpage.h>\n#include <linux/buffer_head.h>\n#include <linux/writeback.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/highuid.h>\n#include <linux/time.h>\n\nint ext2_setattr(struct dentry *dentry, struct iattr *iattr)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tint error;\n\n\terror = inode_change_ok(inode, iattr);\n\tif (error)\n\t\treturn error;\n\n\tif (is_quota_modification(inode, iattr))\n\t\tdquot_initialize(inode);\n\tif ((iattr->ia_valid & ATTR_UID && !uid_eq(iattr->ia_uid, inode->i_uid)) ||\n\t    (iattr->ia_valid & ATTR_GID && !gid_eq(iattr->ia_gid, inode->i_gid))) {\n\t\terror = dquot_transfer(inode, iattr);\n\t\tif (error)\n\t\t\treturn error;\n\t}\n\tif (iattr->ia_valid & ATTR_SIZE && iattr->ia_size != inode->i_size) {\n\t\terror = ext2_setsize(inode, iattr->ia_size);\n\t\tif (error)\n\t\t\treturn error;\n\t}\n\tsetattr_copy(inode, iattr);\n\tif (iattr->ia_valid & ATTR_MODE)\n\t\terror = posix_acl_chmod(inode, inode->i_mode);\n\tmark_inode_dirty(inode);\n\n\treturn error;\n}"
  },
  {
    "function_name": "ext2_write_inode",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext2/inode.c",
    "lines": "1544-1547",
    "snippet": "int ext2_write_inode(struct inode *inode, struct writeback_control *wbc)\n{\n\treturn __ext2_write_inode(inode, wbc->sync_mode == WB_SYNC_ALL);\n}",
    "includes": [
      "#include \"xattr.h\"",
      "#include \"acl.h\"",
      "#include \"ext2.h\"",
      "#include <linux/aio.h>",
      "#include <linux/namei.h>",
      "#include <linux/fiemap.h>",
      "#include <linux/mpage.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/writeback.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/highuid.h>",
      "#include <linux/time.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__ext2_write_inode",
          "args": [
            "inode",
            "wbc->sync_mode == WB_SYNC_ALL"
          ],
          "line": 1546
        },
        "resolved": true,
        "details": {
          "function_name": "__ext2_write_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext2/inode.c",
          "lines": "1439-1542",
          "snippet": "static int __ext2_write_inode(struct inode *inode, int do_sync)\n{\n\tstruct ext2_inode_info *ei = EXT2_I(inode);\n\tstruct super_block *sb = inode->i_sb;\n\tino_t ino = inode->i_ino;\n\tuid_t uid = i_uid_read(inode);\n\tgid_t gid = i_gid_read(inode);\n\tstruct buffer_head * bh;\n\tstruct ext2_inode * raw_inode = ext2_get_inode(sb, ino, &bh);\n\tint n;\n\tint err = 0;\n\n\tif (IS_ERR(raw_inode))\n \t\treturn -EIO;\n\n\t/* For fields not not tracking in the in-memory inode,\n\t * initialise them to zero for new inodes. */\n\tif (ei->i_state & EXT2_STATE_NEW)\n\t\tmemset(raw_inode, 0, EXT2_SB(sb)->s_inode_size);\n\n\text2_get_inode_flags(ei);\n\traw_inode->i_mode = cpu_to_le16(inode->i_mode);\n\tif (!(test_opt(sb, NO_UID32))) {\n\t\traw_inode->i_uid_low = cpu_to_le16(low_16_bits(uid));\n\t\traw_inode->i_gid_low = cpu_to_le16(low_16_bits(gid));\n/*\n * Fix up interoperability with old kernels. Otherwise, old inodes get\n * re-used with the upper 16 bits of the uid/gid intact\n */\n\t\tif (!ei->i_dtime) {\n\t\t\traw_inode->i_uid_high = cpu_to_le16(high_16_bits(uid));\n\t\t\traw_inode->i_gid_high = cpu_to_le16(high_16_bits(gid));\n\t\t} else {\n\t\t\traw_inode->i_uid_high = 0;\n\t\t\traw_inode->i_gid_high = 0;\n\t\t}\n\t} else {\n\t\traw_inode->i_uid_low = cpu_to_le16(fs_high2lowuid(uid));\n\t\traw_inode->i_gid_low = cpu_to_le16(fs_high2lowgid(gid));\n\t\traw_inode->i_uid_high = 0;\n\t\traw_inode->i_gid_high = 0;\n\t}\n\traw_inode->i_links_count = cpu_to_le16(inode->i_nlink);\n\traw_inode->i_size = cpu_to_le32(inode->i_size);\n\traw_inode->i_atime = cpu_to_le32(inode->i_atime.tv_sec);\n\traw_inode->i_ctime = cpu_to_le32(inode->i_ctime.tv_sec);\n\traw_inode->i_mtime = cpu_to_le32(inode->i_mtime.tv_sec);\n\n\traw_inode->i_blocks = cpu_to_le32(inode->i_blocks);\n\traw_inode->i_dtime = cpu_to_le32(ei->i_dtime);\n\traw_inode->i_flags = cpu_to_le32(ei->i_flags);\n\traw_inode->i_faddr = cpu_to_le32(ei->i_faddr);\n\traw_inode->i_frag = ei->i_frag_no;\n\traw_inode->i_fsize = ei->i_frag_size;\n\traw_inode->i_file_acl = cpu_to_le32(ei->i_file_acl);\n\tif (!S_ISREG(inode->i_mode))\n\t\traw_inode->i_dir_acl = cpu_to_le32(ei->i_dir_acl);\n\telse {\n\t\traw_inode->i_size_high = cpu_to_le32(inode->i_size >> 32);\n\t\tif (inode->i_size > 0x7fffffffULL) {\n\t\t\tif (!EXT2_HAS_RO_COMPAT_FEATURE(sb,\n\t\t\t\t\tEXT2_FEATURE_RO_COMPAT_LARGE_FILE) ||\n\t\t\t    EXT2_SB(sb)->s_es->s_rev_level ==\n\t\t\t\t\tcpu_to_le32(EXT2_GOOD_OLD_REV)) {\n\t\t\t       /* If this is the first large file\n\t\t\t\t* created, add a flag to the superblock.\n\t\t\t\t*/\n\t\t\t\tspin_lock(&EXT2_SB(sb)->s_lock);\n\t\t\t\text2_update_dynamic_rev(sb);\n\t\t\t\tEXT2_SET_RO_COMPAT_FEATURE(sb,\n\t\t\t\t\tEXT2_FEATURE_RO_COMPAT_LARGE_FILE);\n\t\t\t\tspin_unlock(&EXT2_SB(sb)->s_lock);\n\t\t\t\text2_write_super(sb);\n\t\t\t}\n\t\t}\n\t}\n\t\n\traw_inode->i_generation = cpu_to_le32(inode->i_generation);\n\tif (S_ISCHR(inode->i_mode) || S_ISBLK(inode->i_mode)) {\n\t\tif (old_valid_dev(inode->i_rdev)) {\n\t\t\traw_inode->i_block[0] =\n\t\t\t\tcpu_to_le32(old_encode_dev(inode->i_rdev));\n\t\t\traw_inode->i_block[1] = 0;\n\t\t} else {\n\t\t\traw_inode->i_block[0] = 0;\n\t\t\traw_inode->i_block[1] =\n\t\t\t\tcpu_to_le32(new_encode_dev(inode->i_rdev));\n\t\t\traw_inode->i_block[2] = 0;\n\t\t}\n\t} else for (n = 0; n < EXT2_N_BLOCKS; n++)\n\t\traw_inode->i_block[n] = ei->i_data[n];\n\tmark_buffer_dirty(bh);\n\tif (do_sync) {\n\t\tsync_dirty_buffer(bh);\n\t\tif (buffer_req(bh) && !buffer_uptodate(bh)) {\n\t\t\tprintk (\"IO error syncing ext2 inode [%s:%08lx]\\n\",\n\t\t\t\tsb->s_id, (unsigned long) ino);\n\t\t\terr = -EIO;\n\t\t}\n\t}\n\tei->i_state &= ~EXT2_STATE_NEW;\n\tbrelse (bh);\n\treturn err;\n}",
          "includes": [
            "#include \"xattr.h\"",
            "#include \"acl.h\"",
            "#include \"ext2.h\"",
            "#include <linux/aio.h>",
            "#include <linux/namei.h>",
            "#include <linux/fiemap.h>",
            "#include <linux/mpage.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/writeback.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highuid.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int __ext2_write_inode(struct inode *inode, int do_sync);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xattr.h\"\n#include \"acl.h\"\n#include \"ext2.h\"\n#include <linux/aio.h>\n#include <linux/namei.h>\n#include <linux/fiemap.h>\n#include <linux/mpage.h>\n#include <linux/buffer_head.h>\n#include <linux/writeback.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/highuid.h>\n#include <linux/time.h>\n\nstatic int __ext2_write_inode(struct inode *inode, int do_sync);\n\nstatic int __ext2_write_inode(struct inode *inode, int do_sync)\n{\n\tstruct ext2_inode_info *ei = EXT2_I(inode);\n\tstruct super_block *sb = inode->i_sb;\n\tino_t ino = inode->i_ino;\n\tuid_t uid = i_uid_read(inode);\n\tgid_t gid = i_gid_read(inode);\n\tstruct buffer_head * bh;\n\tstruct ext2_inode * raw_inode = ext2_get_inode(sb, ino, &bh);\n\tint n;\n\tint err = 0;\n\n\tif (IS_ERR(raw_inode))\n \t\treturn -EIO;\n\n\t/* For fields not not tracking in the in-memory inode,\n\t * initialise them to zero for new inodes. */\n\tif (ei->i_state & EXT2_STATE_NEW)\n\t\tmemset(raw_inode, 0, EXT2_SB(sb)->s_inode_size);\n\n\text2_get_inode_flags(ei);\n\traw_inode->i_mode = cpu_to_le16(inode->i_mode);\n\tif (!(test_opt(sb, NO_UID32))) {\n\t\traw_inode->i_uid_low = cpu_to_le16(low_16_bits(uid));\n\t\traw_inode->i_gid_low = cpu_to_le16(low_16_bits(gid));\n/*\n * Fix up interoperability with old kernels. Otherwise, old inodes get\n * re-used with the upper 16 bits of the uid/gid intact\n */\n\t\tif (!ei->i_dtime) {\n\t\t\traw_inode->i_uid_high = cpu_to_le16(high_16_bits(uid));\n\t\t\traw_inode->i_gid_high = cpu_to_le16(high_16_bits(gid));\n\t\t} else {\n\t\t\traw_inode->i_uid_high = 0;\n\t\t\traw_inode->i_gid_high = 0;\n\t\t}\n\t} else {\n\t\traw_inode->i_uid_low = cpu_to_le16(fs_high2lowuid(uid));\n\t\traw_inode->i_gid_low = cpu_to_le16(fs_high2lowgid(gid));\n\t\traw_inode->i_uid_high = 0;\n\t\traw_inode->i_gid_high = 0;\n\t}\n\traw_inode->i_links_count = cpu_to_le16(inode->i_nlink);\n\traw_inode->i_size = cpu_to_le32(inode->i_size);\n\traw_inode->i_atime = cpu_to_le32(inode->i_atime.tv_sec);\n\traw_inode->i_ctime = cpu_to_le32(inode->i_ctime.tv_sec);\n\traw_inode->i_mtime = cpu_to_le32(inode->i_mtime.tv_sec);\n\n\traw_inode->i_blocks = cpu_to_le32(inode->i_blocks);\n\traw_inode->i_dtime = cpu_to_le32(ei->i_dtime);\n\traw_inode->i_flags = cpu_to_le32(ei->i_flags);\n\traw_inode->i_faddr = cpu_to_le32(ei->i_faddr);\n\traw_inode->i_frag = ei->i_frag_no;\n\traw_inode->i_fsize = ei->i_frag_size;\n\traw_inode->i_file_acl = cpu_to_le32(ei->i_file_acl);\n\tif (!S_ISREG(inode->i_mode))\n\t\traw_inode->i_dir_acl = cpu_to_le32(ei->i_dir_acl);\n\telse {\n\t\traw_inode->i_size_high = cpu_to_le32(inode->i_size >> 32);\n\t\tif (inode->i_size > 0x7fffffffULL) {\n\t\t\tif (!EXT2_HAS_RO_COMPAT_FEATURE(sb,\n\t\t\t\t\tEXT2_FEATURE_RO_COMPAT_LARGE_FILE) ||\n\t\t\t    EXT2_SB(sb)->s_es->s_rev_level ==\n\t\t\t\t\tcpu_to_le32(EXT2_GOOD_OLD_REV)) {\n\t\t\t       /* If this is the first large file\n\t\t\t\t* created, add a flag to the superblock.\n\t\t\t\t*/\n\t\t\t\tspin_lock(&EXT2_SB(sb)->s_lock);\n\t\t\t\text2_update_dynamic_rev(sb);\n\t\t\t\tEXT2_SET_RO_COMPAT_FEATURE(sb,\n\t\t\t\t\tEXT2_FEATURE_RO_COMPAT_LARGE_FILE);\n\t\t\t\tspin_unlock(&EXT2_SB(sb)->s_lock);\n\t\t\t\text2_write_super(sb);\n\t\t\t}\n\t\t}\n\t}\n\t\n\traw_inode->i_generation = cpu_to_le32(inode->i_generation);\n\tif (S_ISCHR(inode->i_mode) || S_ISBLK(inode->i_mode)) {\n\t\tif (old_valid_dev(inode->i_rdev)) {\n\t\t\traw_inode->i_block[0] =\n\t\t\t\tcpu_to_le32(old_encode_dev(inode->i_rdev));\n\t\t\traw_inode->i_block[1] = 0;\n\t\t} else {\n\t\t\traw_inode->i_block[0] = 0;\n\t\t\traw_inode->i_block[1] =\n\t\t\t\tcpu_to_le32(new_encode_dev(inode->i_rdev));\n\t\t\traw_inode->i_block[2] = 0;\n\t\t}\n\t} else for (n = 0; n < EXT2_N_BLOCKS; n++)\n\t\traw_inode->i_block[n] = ei->i_data[n];\n\tmark_buffer_dirty(bh);\n\tif (do_sync) {\n\t\tsync_dirty_buffer(bh);\n\t\tif (buffer_req(bh) && !buffer_uptodate(bh)) {\n\t\t\tprintk (\"IO error syncing ext2 inode [%s:%08lx]\\n\",\n\t\t\t\tsb->s_id, (unsigned long) ino);\n\t\t\terr = -EIO;\n\t\t}\n\t}\n\tei->i_state &= ~EXT2_STATE_NEW;\n\tbrelse (bh);\n\treturn err;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"xattr.h\"\n#include \"acl.h\"\n#include \"ext2.h\"\n#include <linux/aio.h>\n#include <linux/namei.h>\n#include <linux/fiemap.h>\n#include <linux/mpage.h>\n#include <linux/buffer_head.h>\n#include <linux/writeback.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/highuid.h>\n#include <linux/time.h>\n\nint ext2_write_inode(struct inode *inode, struct writeback_control *wbc)\n{\n\treturn __ext2_write_inode(inode, wbc->sync_mode == WB_SYNC_ALL);\n}"
  },
  {
    "function_name": "__ext2_write_inode",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext2/inode.c",
    "lines": "1439-1542",
    "snippet": "static int __ext2_write_inode(struct inode *inode, int do_sync)\n{\n\tstruct ext2_inode_info *ei = EXT2_I(inode);\n\tstruct super_block *sb = inode->i_sb;\n\tino_t ino = inode->i_ino;\n\tuid_t uid = i_uid_read(inode);\n\tgid_t gid = i_gid_read(inode);\n\tstruct buffer_head * bh;\n\tstruct ext2_inode * raw_inode = ext2_get_inode(sb, ino, &bh);\n\tint n;\n\tint err = 0;\n\n\tif (IS_ERR(raw_inode))\n \t\treturn -EIO;\n\n\t/* For fields not not tracking in the in-memory inode,\n\t * initialise them to zero for new inodes. */\n\tif (ei->i_state & EXT2_STATE_NEW)\n\t\tmemset(raw_inode, 0, EXT2_SB(sb)->s_inode_size);\n\n\text2_get_inode_flags(ei);\n\traw_inode->i_mode = cpu_to_le16(inode->i_mode);\n\tif (!(test_opt(sb, NO_UID32))) {\n\t\traw_inode->i_uid_low = cpu_to_le16(low_16_bits(uid));\n\t\traw_inode->i_gid_low = cpu_to_le16(low_16_bits(gid));\n/*\n * Fix up interoperability with old kernels. Otherwise, old inodes get\n * re-used with the upper 16 bits of the uid/gid intact\n */\n\t\tif (!ei->i_dtime) {\n\t\t\traw_inode->i_uid_high = cpu_to_le16(high_16_bits(uid));\n\t\t\traw_inode->i_gid_high = cpu_to_le16(high_16_bits(gid));\n\t\t} else {\n\t\t\traw_inode->i_uid_high = 0;\n\t\t\traw_inode->i_gid_high = 0;\n\t\t}\n\t} else {\n\t\traw_inode->i_uid_low = cpu_to_le16(fs_high2lowuid(uid));\n\t\traw_inode->i_gid_low = cpu_to_le16(fs_high2lowgid(gid));\n\t\traw_inode->i_uid_high = 0;\n\t\traw_inode->i_gid_high = 0;\n\t}\n\traw_inode->i_links_count = cpu_to_le16(inode->i_nlink);\n\traw_inode->i_size = cpu_to_le32(inode->i_size);\n\traw_inode->i_atime = cpu_to_le32(inode->i_atime.tv_sec);\n\traw_inode->i_ctime = cpu_to_le32(inode->i_ctime.tv_sec);\n\traw_inode->i_mtime = cpu_to_le32(inode->i_mtime.tv_sec);\n\n\traw_inode->i_blocks = cpu_to_le32(inode->i_blocks);\n\traw_inode->i_dtime = cpu_to_le32(ei->i_dtime);\n\traw_inode->i_flags = cpu_to_le32(ei->i_flags);\n\traw_inode->i_faddr = cpu_to_le32(ei->i_faddr);\n\traw_inode->i_frag = ei->i_frag_no;\n\traw_inode->i_fsize = ei->i_frag_size;\n\traw_inode->i_file_acl = cpu_to_le32(ei->i_file_acl);\n\tif (!S_ISREG(inode->i_mode))\n\t\traw_inode->i_dir_acl = cpu_to_le32(ei->i_dir_acl);\n\telse {\n\t\traw_inode->i_size_high = cpu_to_le32(inode->i_size >> 32);\n\t\tif (inode->i_size > 0x7fffffffULL) {\n\t\t\tif (!EXT2_HAS_RO_COMPAT_FEATURE(sb,\n\t\t\t\t\tEXT2_FEATURE_RO_COMPAT_LARGE_FILE) ||\n\t\t\t    EXT2_SB(sb)->s_es->s_rev_level ==\n\t\t\t\t\tcpu_to_le32(EXT2_GOOD_OLD_REV)) {\n\t\t\t       /* If this is the first large file\n\t\t\t\t* created, add a flag to the superblock.\n\t\t\t\t*/\n\t\t\t\tspin_lock(&EXT2_SB(sb)->s_lock);\n\t\t\t\text2_update_dynamic_rev(sb);\n\t\t\t\tEXT2_SET_RO_COMPAT_FEATURE(sb,\n\t\t\t\t\tEXT2_FEATURE_RO_COMPAT_LARGE_FILE);\n\t\t\t\tspin_unlock(&EXT2_SB(sb)->s_lock);\n\t\t\t\text2_write_super(sb);\n\t\t\t}\n\t\t}\n\t}\n\t\n\traw_inode->i_generation = cpu_to_le32(inode->i_generation);\n\tif (S_ISCHR(inode->i_mode) || S_ISBLK(inode->i_mode)) {\n\t\tif (old_valid_dev(inode->i_rdev)) {\n\t\t\traw_inode->i_block[0] =\n\t\t\t\tcpu_to_le32(old_encode_dev(inode->i_rdev));\n\t\t\traw_inode->i_block[1] = 0;\n\t\t} else {\n\t\t\traw_inode->i_block[0] = 0;\n\t\t\traw_inode->i_block[1] =\n\t\t\t\tcpu_to_le32(new_encode_dev(inode->i_rdev));\n\t\t\traw_inode->i_block[2] = 0;\n\t\t}\n\t} else for (n = 0; n < EXT2_N_BLOCKS; n++)\n\t\traw_inode->i_block[n] = ei->i_data[n];\n\tmark_buffer_dirty(bh);\n\tif (do_sync) {\n\t\tsync_dirty_buffer(bh);\n\t\tif (buffer_req(bh) && !buffer_uptodate(bh)) {\n\t\t\tprintk (\"IO error syncing ext2 inode [%s:%08lx]\\n\",\n\t\t\t\tsb->s_id, (unsigned long) ino);\n\t\t\terr = -EIO;\n\t\t}\n\t}\n\tei->i_state &= ~EXT2_STATE_NEW;\n\tbrelse (bh);\n\treturn err;\n}",
    "includes": [
      "#include \"xattr.h\"",
      "#include \"acl.h\"",
      "#include \"ext2.h\"",
      "#include <linux/aio.h>",
      "#include <linux/namei.h>",
      "#include <linux/fiemap.h>",
      "#include <linux/mpage.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/writeback.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/highuid.h>",
      "#include <linux/time.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int __ext2_write_inode(struct inode *inode, int do_sync);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "brelse",
          "args": [
            "bh"
          ],
          "line": 1540
        },
        "resolved": true,
        "details": {
          "function_name": "__brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1177-1184",
          "snippet": "void __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "\"IO error syncing ext2 inode [%s:%08lx]\\n\"",
            "sb->s_id",
            "(unsigned long) ino"
          ],
          "line": 1534
        },
        "resolved": true,
        "details": {
          "function_name": "compat_printk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/compat.c",
          "lines": "59-69",
          "snippet": "int compat_printk(const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\tif (!compat_log)\n\t\treturn 0;\n\tva_start(ap, fmt);\n\tret = vprintk(fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/ioctls.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/aio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/mm.h>",
            "#include <linux/poll.h>",
            "#include <linux/signal.h>",
            "#include <linux/highmem.h>",
            "#include <linux/security.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/personality.h>",
            "#include <linux/highuid.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/dirent.h>",
            "#include <linux/ctype.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/nfs4_mount.h>",
            "#include <linux/ncp_mount.h>",
            "#include <linux/init.h>",
            "#include <linux/ioctl.h>",
            "#include <linux/vfs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/namei.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/errno.h>",
            "#include <linux/compat.h>",
            "#include <linux/linkage.h>",
            "#include <linux/kernel.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int compat_log = 1;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/ioctls.h>\n#include <asm/mmu_context.h>\n#include <asm/uaccess.h>\n#include <linux/aio.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/fs_struct.h>\n#include <linux/mm.h>\n#include <linux/poll.h>\n#include <linux/signal.h>\n#include <linux/highmem.h>\n#include <linux/security.h>\n#include <linux/tsacct_kern.h>\n#include <linux/rwsem.h>\n#include <linux/personality.h>\n#include <linux/highuid.h>\n#include <linux/fsnotify.h>\n#include <linux/dirent.h>\n#include <linux/ctype.h>\n#include <linux/syscalls.h>\n#include <linux/nfs4_mount.h>\n#include <linux/ncp_mount.h>\n#include <linux/init.h>\n#include <linux/ioctl.h>\n#include <linux/vfs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/namei.h>\n#include <linux/fcntl.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <linux/compat.h>\n#include <linux/linkage.h>\n#include <linux/kernel.h>\n#include <linux/stddef.h>\n\nint compat_log = 1;\n\nint compat_printk(const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\tif (!compat_log)\n\t\treturn 0;\n\tva_start(ap, fmt);\n\tret = vprintk(fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "buffer_uptodate",
          "args": [
            "bh"
          ],
          "line": 1533
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_set_buffer_uptodate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/disk-io.c",
          "lines": "3758-3761",
          "snippet": "int btrfs_set_buffer_uptodate(struct extent_buffer *buf)\n{\n\treturn set_extent_buffer_uptodate(buf);\n}",
          "includes": [
            "#include <asm/cpufeature.h>",
            "#include \"qgroup.h\"",
            "#include \"sysfs.h\"",
            "#include \"raid56.h\"",
            "#include \"dev-replace.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"inode-map.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"tree-log.h\"",
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"hash.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/uuid.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/migrate.h>",
            "#include <linux/slab.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/writeback.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/swap.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/cpufeature.h>\n#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"raid56.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <asm/unaligned.h>\n#include <linux/semaphore.h>\n#include <linux/uuid.h>\n#include <linux/ratelimit.h>\n#include <linux/migrate.h>\n#include <linux/slab.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/writeback.h>\n#include <linux/radix-tree.h>\n#include <linux/swap.h>\n#include <linux/scatterlist.h>\n#include <linux/blkdev.h>\n#include <linux/fs.h>\n\nint btrfs_set_buffer_uptodate(struct extent_buffer *buf)\n{\n\treturn set_extent_buffer_uptodate(buf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "buffer_req",
          "args": [
            "bh"
          ],
          "line": 1533
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sync_dirty_buffer",
          "args": [
            "bh"
          ],
          "line": 1532
        },
        "resolved": true,
        "details": {
          "function_name": "sync_dirty_buffer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "3153-3156",
          "snippet": "int sync_dirty_buffer(struct buffer_head *bh)\n{\n\treturn __sync_dirty_buffer(bh, WRITE_SYNC);\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nint sync_dirty_buffer(struct buffer_head *bh)\n{\n\treturn __sync_dirty_buffer(bh, WRITE_SYNC);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mark_buffer_dirty",
          "args": [
            "bh"
          ],
          "line": 1530
        },
        "resolved": true,
        "details": {
          "function_name": "mark_buffer_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1141-1167",
          "snippet": "void mark_buffer_dirty(struct buffer_head *bh)\n{\n\tWARN_ON_ONCE(!buffer_uptodate(bh));\n\n\ttrace_block_dirty_buffer(bh);\n\n\t/*\n\t * Very *carefully* optimize the it-is-already-dirty case.\n\t *\n\t * Don't let the final \"is it dirty\" escape to before we\n\t * perhaps modified the buffer.\n\t */\n\tif (buffer_dirty(bh)) {\n\t\tsmp_mb();\n\t\tif (buffer_dirty(bh))\n\t\t\treturn;\n\t}\n\n\tif (!test_set_buffer_dirty(bh)) {\n\t\tstruct page *page = bh->b_page;\n\t\tif (!TestSetPageDirty(page)) {\n\t\t\tstruct address_space *mapping = page_mapping(page);\n\t\t\tif (mapping)\n\t\t\t\t__set_page_dirty(page, mapping, 0);\n\t\t}\n\t}\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid mark_buffer_dirty(struct buffer_head *bh)\n{\n\tWARN_ON_ONCE(!buffer_uptodate(bh));\n\n\ttrace_block_dirty_buffer(bh);\n\n\t/*\n\t * Very *carefully* optimize the it-is-already-dirty case.\n\t *\n\t * Don't let the final \"is it dirty\" escape to before we\n\t * perhaps modified the buffer.\n\t */\n\tif (buffer_dirty(bh)) {\n\t\tsmp_mb();\n\t\tif (buffer_dirty(bh))\n\t\t\treturn;\n\t}\n\n\tif (!test_set_buffer_dirty(bh)) {\n\t\tstruct page *page = bh->b_page;\n\t\tif (!TestSetPageDirty(page)) {\n\t\t\tstruct address_space *mapping = page_mapping(page);\n\t\t\tif (mapping)\n\t\t\t\t__set_page_dirty(page, mapping, 0);\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "new_encode_dev(inode->i_rdev)"
          ],
          "line": 1525
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "new_encode_dev",
          "args": [
            "inode->i_rdev"
          ],
          "line": 1525
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "old_encode_dev(inode->i_rdev)"
          ],
          "line": 1520
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "old_encode_dev",
          "args": [
            "inode->i_rdev"
          ],
          "line": 1520
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "old_valid_dev",
          "args": [
            "inode->i_rdev"
          ],
          "line": 1518
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISBLK",
          "args": [
            "inode->i_mode"
          ],
          "line": 1517
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISCHR",
          "args": [
            "inode->i_mode"
          ],
          "line": 1517
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "inode->i_generation"
          ],
          "line": 1516
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext2_write_super",
          "args": [
            "sb"
          ],
          "line": 1511
        },
        "resolved": true,
        "details": {
          "function_name": "ext2_write_super",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext2/super.c",
          "lines": "1261-1265",
          "snippet": "void ext2_write_super(struct super_block *sb)\n{\n\tif (!(sb->s_flags & MS_RDONLY))\n\t\text2_sync_fs(sb, 1);\n}",
          "includes": [
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext2.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/log2.h>",
            "#include <linux/mount.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/vfs.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/random.h>",
            "#include <linux/parser.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/string.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ext2_freeze(struct super_block *sb);",
            "static int ext2_unfreeze(struct super_block *sb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext2.h\"\n#include <asm/uaccess.h>\n#include <linux/quotaops.h>\n#include <linux/log2.h>\n#include <linux/mount.h>\n#include <linux/seq_file.h>\n#include <linux/vfs.h>\n#include <linux/exportfs.h>\n#include <linux/buffer_head.h>\n#include <linux/random.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/string.h>\n#include <linux/module.h>\n\nstatic int ext2_freeze(struct super_block *sb);\nstatic int ext2_unfreeze(struct super_block *sb);\n\nvoid ext2_write_super(struct super_block *sb)\n{\n\tif (!(sb->s_flags & MS_RDONLY))\n\t\text2_sync_fs(sb, 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&EXT2_SB(sb)->s_lock"
          ],
          "line": 1510
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "EXT2_SB",
          "args": [
            "sb"
          ],
          "line": 1510
        },
        "resolved": true,
        "details": {
          "function_name": "EXT2_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext2/ext2.h",
          "lines": "164-167",
          "snippet": "static inline struct ext2_sb_info *EXT2_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include <linux/rbtree.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/ext2_fs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern unsigned long ext2_count_free_blocks (struct super_block *);",
            "extern unsigned long ext2_count_dirs (struct super_block *);",
            "extern void ext2_check_blocks_bitmap (struct super_block *);",
            "extern unsigned long ext2_count_free_inodes (struct super_block *);",
            "extern void ext2_check_inodes_bitmap (struct super_block *);",
            "extern struct inode *ext2_iget (struct super_block *, unsigned long);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rbtree.h>\n#include <linux/percpu_counter.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/ext2_fs.h>\n#include <linux/fs.h>\n\nextern unsigned long ext2_count_free_blocks (struct super_block *);\nextern unsigned long ext2_count_dirs (struct super_block *);\nextern void ext2_check_blocks_bitmap (struct super_block *);\nextern unsigned long ext2_count_free_inodes (struct super_block *);\nextern void ext2_check_inodes_bitmap (struct super_block *);\nextern struct inode *ext2_iget (struct super_block *, unsigned long);\n\nstatic inline struct ext2_sb_info *EXT2_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      },
      {
        "call_info": {
          "callee": "EXT2_SET_RO_COMPAT_FEATURE",
          "args": [
            "sb",
            "EXT2_FEATURE_RO_COMPAT_LARGE_FILE"
          ],
          "line": 1508
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext2_update_dynamic_rev",
          "args": [
            "sb"
          ],
          "line": 1507
        },
        "resolved": true,
        "details": {
          "function_name": "ext2_update_dynamic_rev",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext2/super.c",
          "lines": "101-124",
          "snippet": "void ext2_update_dynamic_rev(struct super_block *sb)\n{\n\tstruct ext2_super_block *es = EXT2_SB(sb)->s_es;\n\n\tif (le32_to_cpu(es->s_rev_level) > EXT2_GOOD_OLD_REV)\n\t\treturn;\n\n\text2_msg(sb, KERN_WARNING,\n\t\t     \"warning: updating to rev %d because of \"\n\t\t     \"new feature flag, running e2fsck is recommended\",\n\t\t     EXT2_DYNAMIC_REV);\n\n\tes->s_first_ino = cpu_to_le32(EXT2_GOOD_OLD_FIRST_INO);\n\tes->s_inode_size = cpu_to_le16(EXT2_GOOD_OLD_INODE_SIZE);\n\tes->s_rev_level = cpu_to_le32(EXT2_DYNAMIC_REV);\n\t/* leave es->s_feature_*compat flags alone */\n\t/* es->s_uuid will be set by e2fsck if empty */\n\n\t/*\n\t * The rest of the superblock fields should be zero, and if not it\n\t * means they are likely already in use, so leave them alone.  We\n\t * can leave it up to e2fsck to clean up any inconsistencies there.\n\t */\n}",
          "includes": [
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext2.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/log2.h>",
            "#include <linux/mount.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/vfs.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/random.h>",
            "#include <linux/parser.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/string.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ext2_freeze(struct super_block *sb);",
            "static int ext2_unfreeze(struct super_block *sb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext2.h\"\n#include <asm/uaccess.h>\n#include <linux/quotaops.h>\n#include <linux/log2.h>\n#include <linux/mount.h>\n#include <linux/seq_file.h>\n#include <linux/vfs.h>\n#include <linux/exportfs.h>\n#include <linux/buffer_head.h>\n#include <linux/random.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/string.h>\n#include <linux/module.h>\n\nstatic int ext2_freeze(struct super_block *sb);\nstatic int ext2_unfreeze(struct super_block *sb);\n\nvoid ext2_update_dynamic_rev(struct super_block *sb)\n{\n\tstruct ext2_super_block *es = EXT2_SB(sb)->s_es;\n\n\tif (le32_to_cpu(es->s_rev_level) > EXT2_GOOD_OLD_REV)\n\t\treturn;\n\n\text2_msg(sb, KERN_WARNING,\n\t\t     \"warning: updating to rev %d because of \"\n\t\t     \"new feature flag, running e2fsck is recommended\",\n\t\t     EXT2_DYNAMIC_REV);\n\n\tes->s_first_ino = cpu_to_le32(EXT2_GOOD_OLD_FIRST_INO);\n\tes->s_inode_size = cpu_to_le16(EXT2_GOOD_OLD_INODE_SIZE);\n\tes->s_rev_level = cpu_to_le32(EXT2_DYNAMIC_REV);\n\t/* leave es->s_feature_*compat flags alone */\n\t/* es->s_uuid will be set by e2fsck if empty */\n\n\t/*\n\t * The rest of the superblock fields should be zero, and if not it\n\t * means they are likely already in use, so leave them alone.  We\n\t * can leave it up to e2fsck to clean up any inconsistencies there.\n\t */\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&EXT2_SB(sb)->s_lock"
          ],
          "line": 1506
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "EXT2_GOOD_OLD_REV"
          ],
          "line": 1502
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXT2_HAS_RO_COMPAT_FEATURE",
          "args": [
            "sb",
            "EXT2_FEATURE_RO_COMPAT_LARGE_FILE"
          ],
          "line": 1499
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "inode->i_size >> 32"
          ],
          "line": 1497
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "ei->i_dir_acl"
          ],
          "line": 1495
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISREG",
          "args": [
            "inode->i_mode"
          ],
          "line": 1494
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "ei->i_file_acl"
          ],
          "line": 1493
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "ei->i_faddr"
          ],
          "line": 1490
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "ei->i_flags"
          ],
          "line": 1489
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "ei->i_dtime"
          ],
          "line": 1488
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "inode->i_blocks"
          ],
          "line": 1487
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "inode->i_mtime.tv_sec"
          ],
          "line": 1485
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "inode->i_ctime.tv_sec"
          ],
          "line": 1484
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "inode->i_atime.tv_sec"
          ],
          "line": 1483
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "inode->i_size"
          ],
          "line": 1482
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "inode->i_nlink"
          ],
          "line": 1481
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "fs_high2lowgid(gid)"
          ],
          "line": 1477
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fs_high2lowgid",
          "args": [
            "gid"
          ],
          "line": 1477
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "fs_high2lowuid(uid)"
          ],
          "line": 1476
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fs_high2lowuid",
          "args": [
            "uid"
          ],
          "line": 1476
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "high_16_bits(gid)"
          ],
          "line": 1470
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "high_16_bits",
          "args": [
            "gid"
          ],
          "line": 1470
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "high_16_bits(uid)"
          ],
          "line": 1469
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "high_16_bits",
          "args": [
            "uid"
          ],
          "line": 1469
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "low_16_bits(gid)"
          ],
          "line": 1463
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "low_16_bits",
          "args": [
            "gid"
          ],
          "line": 1463
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "low_16_bits(uid)"
          ],
          "line": 1462
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "low_16_bits",
          "args": [
            "uid"
          ],
          "line": 1462
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_opt",
          "args": [
            "sb",
            "NO_UID32"
          ],
          "line": 1461
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "inode->i_mode"
          ],
          "line": 1460
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext2_get_inode_flags",
          "args": [
            "ei"
          ],
          "line": 1459
        },
        "resolved": true,
        "details": {
          "function_name": "ext2_get_inode_flags",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext2/inode.c",
          "lines": "1294-1310",
          "snippet": "void ext2_get_inode_flags(struct ext2_inode_info *ei)\n{\n\tunsigned int flags = ei->vfs_inode.i_flags;\n\n\tei->i_flags &= ~(EXT2_SYNC_FL|EXT2_APPEND_FL|\n\t\t\tEXT2_IMMUTABLE_FL|EXT2_NOATIME_FL|EXT2_DIRSYNC_FL);\n\tif (flags & S_SYNC)\n\t\tei->i_flags |= EXT2_SYNC_FL;\n\tif (flags & S_APPEND)\n\t\tei->i_flags |= EXT2_APPEND_FL;\n\tif (flags & S_IMMUTABLE)\n\t\tei->i_flags |= EXT2_IMMUTABLE_FL;\n\tif (flags & S_NOATIME)\n\t\tei->i_flags |= EXT2_NOATIME_FL;\n\tif (flags & S_DIRSYNC)\n\t\tei->i_flags |= EXT2_DIRSYNC_FL;\n}",
          "includes": [
            "#include \"xattr.h\"",
            "#include \"acl.h\"",
            "#include \"ext2.h\"",
            "#include <linux/aio.h>",
            "#include <linux/namei.h>",
            "#include <linux/fiemap.h>",
            "#include <linux/mpage.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/writeback.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highuid.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xattr.h\"\n#include \"acl.h\"\n#include \"ext2.h\"\n#include <linux/aio.h>\n#include <linux/namei.h>\n#include <linux/fiemap.h>\n#include <linux/mpage.h>\n#include <linux/buffer_head.h>\n#include <linux/writeback.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/highuid.h>\n#include <linux/time.h>\n\nvoid ext2_get_inode_flags(struct ext2_inode_info *ei)\n{\n\tunsigned int flags = ei->vfs_inode.i_flags;\n\n\tei->i_flags &= ~(EXT2_SYNC_FL|EXT2_APPEND_FL|\n\t\t\tEXT2_IMMUTABLE_FL|EXT2_NOATIME_FL|EXT2_DIRSYNC_FL);\n\tif (flags & S_SYNC)\n\t\tei->i_flags |= EXT2_SYNC_FL;\n\tif (flags & S_APPEND)\n\t\tei->i_flags |= EXT2_APPEND_FL;\n\tif (flags & S_IMMUTABLE)\n\t\tei->i_flags |= EXT2_IMMUTABLE_FL;\n\tif (flags & S_NOATIME)\n\t\tei->i_flags |= EXT2_NOATIME_FL;\n\tif (flags & S_DIRSYNC)\n\t\tei->i_flags |= EXT2_DIRSYNC_FL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "raw_inode",
            "0",
            "EXT2_SB(sb)->s_inode_size"
          ],
          "line": 1457
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "raw_inode"
          ],
          "line": 1451
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext2_get_inode",
          "args": [
            "sb",
            "ino",
            "&bh"
          ],
          "line": 1447
        },
        "resolved": true,
        "details": {
          "function_name": "ext2_get_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext2/inode.c",
          "lines": "1230-1271",
          "snippet": "static struct ext2_inode *ext2_get_inode(struct super_block *sb, ino_t ino,\n\t\t\t\t\tstruct buffer_head **p)\n{\n\tstruct buffer_head * bh;\n\tunsigned long block_group;\n\tunsigned long block;\n\tunsigned long offset;\n\tstruct ext2_group_desc * gdp;\n\n\t*p = NULL;\n\tif ((ino != EXT2_ROOT_INO && ino < EXT2_FIRST_INO(sb)) ||\n\t    ino > le32_to_cpu(EXT2_SB(sb)->s_es->s_inodes_count))\n\t\tgoto Einval;\n\n\tblock_group = (ino - 1) / EXT2_INODES_PER_GROUP(sb);\n\tgdp = ext2_get_group_desc(sb, block_group, NULL);\n\tif (!gdp)\n\t\tgoto Egdp;\n\t/*\n\t * Figure out the offset within the block group inode table\n\t */\n\toffset = ((ino - 1) % EXT2_INODES_PER_GROUP(sb)) * EXT2_INODE_SIZE(sb);\n\tblock = le32_to_cpu(gdp->bg_inode_table) +\n\t\t(offset >> EXT2_BLOCK_SIZE_BITS(sb));\n\tif (!(bh = sb_bread(sb, block)))\n\t\tgoto Eio;\n\n\t*p = bh;\n\toffset &= (EXT2_BLOCK_SIZE(sb) - 1);\n\treturn (struct ext2_inode *) (bh->b_data + offset);\n\nEinval:\n\text2_error(sb, \"ext2_get_inode\", \"bad inode number: %lu\",\n\t\t   (unsigned long) ino);\n\treturn ERR_PTR(-EINVAL);\nEio:\n\text2_error(sb, \"ext2_get_inode\",\n\t\t   \"unable to read inode block - inode=%lu, block=%lu\",\n\t\t   (unsigned long) ino, block);\nEgdp:\n\treturn ERR_PTR(-EIO);\n}",
          "includes": [
            "#include \"xattr.h\"",
            "#include \"acl.h\"",
            "#include \"ext2.h\"",
            "#include <linux/aio.h>",
            "#include <linux/namei.h>",
            "#include <linux/fiemap.h>",
            "#include <linux/mpage.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/writeback.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highuid.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void ext2_truncate_blocks(struct inode *inode, loff_t offset);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xattr.h\"\n#include \"acl.h\"\n#include \"ext2.h\"\n#include <linux/aio.h>\n#include <linux/namei.h>\n#include <linux/fiemap.h>\n#include <linux/mpage.h>\n#include <linux/buffer_head.h>\n#include <linux/writeback.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/highuid.h>\n#include <linux/time.h>\n\nstatic void ext2_truncate_blocks(struct inode *inode, loff_t offset);\n\nstatic struct ext2_inode *ext2_get_inode(struct super_block *sb, ino_t ino,\n\t\t\t\t\tstruct buffer_head **p)\n{\n\tstruct buffer_head * bh;\n\tunsigned long block_group;\n\tunsigned long block;\n\tunsigned long offset;\n\tstruct ext2_group_desc * gdp;\n\n\t*p = NULL;\n\tif ((ino != EXT2_ROOT_INO && ino < EXT2_FIRST_INO(sb)) ||\n\t    ino > le32_to_cpu(EXT2_SB(sb)->s_es->s_inodes_count))\n\t\tgoto Einval;\n\n\tblock_group = (ino - 1) / EXT2_INODES_PER_GROUP(sb);\n\tgdp = ext2_get_group_desc(sb, block_group, NULL);\n\tif (!gdp)\n\t\tgoto Egdp;\n\t/*\n\t * Figure out the offset within the block group inode table\n\t */\n\toffset = ((ino - 1) % EXT2_INODES_PER_GROUP(sb)) * EXT2_INODE_SIZE(sb);\n\tblock = le32_to_cpu(gdp->bg_inode_table) +\n\t\t(offset >> EXT2_BLOCK_SIZE_BITS(sb));\n\tif (!(bh = sb_bread(sb, block)))\n\t\tgoto Eio;\n\n\t*p = bh;\n\toffset &= (EXT2_BLOCK_SIZE(sb) - 1);\n\treturn (struct ext2_inode *) (bh->b_data + offset);\n\nEinval:\n\text2_error(sb, \"ext2_get_inode\", \"bad inode number: %lu\",\n\t\t   (unsigned long) ino);\n\treturn ERR_PTR(-EINVAL);\nEio:\n\text2_error(sb, \"ext2_get_inode\",\n\t\t   \"unable to read inode block - inode=%lu, block=%lu\",\n\t\t   (unsigned long) ino, block);\nEgdp:\n\treturn ERR_PTR(-EIO);\n}"
        }
      },
      {
        "call_info": {
          "callee": "i_gid_read",
          "args": [
            "inode"
          ],
          "line": 1445
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "i_uid_read",
          "args": [
            "inode"
          ],
          "line": 1444
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXT2_I",
          "args": [
            "inode"
          ],
          "line": 1441
        },
        "resolved": true,
        "details": {
          "function_name": "EXT2_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext2/ext2.h",
          "lines": "717-720",
          "snippet": "static inline struct ext2_inode_info *EXT2_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ext2_inode_info, vfs_inode);\n}",
          "includes": [
            "#include <linux/rbtree.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/ext2_fs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern ext2_fsblk_t ext2_new_block(struct inode *, unsigned long, int *);",
            "extern ext2_fsblk_t ext2_new_blocks(struct inode *, unsigned long,\n\t\t\t\tunsigned long *, int *);",
            "extern void ext2_free_blocks (struct inode *, unsigned long,\n\t\t\t      unsigned long);",
            "extern void ext2_discard_reservation (struct inode *);",
            "extern void ext2_init_block_alloc_info(struct inode *);",
            "extern int ext2_add_link (struct dentry *, struct inode *);",
            "extern int ext2_make_empty(struct inode *, struct inode *);",
            "extern int ext2_empty_dir (struct inode *);",
            "extern void ext2_set_link(struct inode *, struct ext2_dir_entry_2 *, struct page *, struct inode *, int);",
            "extern void ext2_free_inode (struct inode *);",
            "extern void ext2_evict_inode(struct inode *);",
            "extern void ext2_set_inode_flags(struct inode *inode);",
            "extern void ext2_get_inode_flags(struct ext2_inode_info *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rbtree.h>\n#include <linux/percpu_counter.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/ext2_fs.h>\n#include <linux/fs.h>\n\nextern ext2_fsblk_t ext2_new_block(struct inode *, unsigned long, int *);\nextern ext2_fsblk_t ext2_new_blocks(struct inode *, unsigned long,\n\t\t\t\tunsigned long *, int *);\nextern void ext2_free_blocks (struct inode *, unsigned long,\n\t\t\t      unsigned long);\nextern void ext2_discard_reservation (struct inode *);\nextern void ext2_init_block_alloc_info(struct inode *);\nextern int ext2_add_link (struct dentry *, struct inode *);\nextern int ext2_make_empty(struct inode *, struct inode *);\nextern int ext2_empty_dir (struct inode *);\nextern void ext2_set_link(struct inode *, struct ext2_dir_entry_2 *, struct page *, struct inode *, int);\nextern void ext2_free_inode (struct inode *);\nextern void ext2_evict_inode(struct inode *);\nextern void ext2_set_inode_flags(struct inode *inode);\nextern void ext2_get_inode_flags(struct ext2_inode_info *);\n\nstatic inline struct ext2_inode_info *EXT2_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ext2_inode_info, vfs_inode);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"xattr.h\"\n#include \"acl.h\"\n#include \"ext2.h\"\n#include <linux/aio.h>\n#include <linux/namei.h>\n#include <linux/fiemap.h>\n#include <linux/mpage.h>\n#include <linux/buffer_head.h>\n#include <linux/writeback.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/highuid.h>\n#include <linux/time.h>\n\nstatic int __ext2_write_inode(struct inode *inode, int do_sync);\n\nstatic int __ext2_write_inode(struct inode *inode, int do_sync)\n{\n\tstruct ext2_inode_info *ei = EXT2_I(inode);\n\tstruct super_block *sb = inode->i_sb;\n\tino_t ino = inode->i_ino;\n\tuid_t uid = i_uid_read(inode);\n\tgid_t gid = i_gid_read(inode);\n\tstruct buffer_head * bh;\n\tstruct ext2_inode * raw_inode = ext2_get_inode(sb, ino, &bh);\n\tint n;\n\tint err = 0;\n\n\tif (IS_ERR(raw_inode))\n \t\treturn -EIO;\n\n\t/* For fields not not tracking in the in-memory inode,\n\t * initialise them to zero for new inodes. */\n\tif (ei->i_state & EXT2_STATE_NEW)\n\t\tmemset(raw_inode, 0, EXT2_SB(sb)->s_inode_size);\n\n\text2_get_inode_flags(ei);\n\traw_inode->i_mode = cpu_to_le16(inode->i_mode);\n\tif (!(test_opt(sb, NO_UID32))) {\n\t\traw_inode->i_uid_low = cpu_to_le16(low_16_bits(uid));\n\t\traw_inode->i_gid_low = cpu_to_le16(low_16_bits(gid));\n/*\n * Fix up interoperability with old kernels. Otherwise, old inodes get\n * re-used with the upper 16 bits of the uid/gid intact\n */\n\t\tif (!ei->i_dtime) {\n\t\t\traw_inode->i_uid_high = cpu_to_le16(high_16_bits(uid));\n\t\t\traw_inode->i_gid_high = cpu_to_le16(high_16_bits(gid));\n\t\t} else {\n\t\t\traw_inode->i_uid_high = 0;\n\t\t\traw_inode->i_gid_high = 0;\n\t\t}\n\t} else {\n\t\traw_inode->i_uid_low = cpu_to_le16(fs_high2lowuid(uid));\n\t\traw_inode->i_gid_low = cpu_to_le16(fs_high2lowgid(gid));\n\t\traw_inode->i_uid_high = 0;\n\t\traw_inode->i_gid_high = 0;\n\t}\n\traw_inode->i_links_count = cpu_to_le16(inode->i_nlink);\n\traw_inode->i_size = cpu_to_le32(inode->i_size);\n\traw_inode->i_atime = cpu_to_le32(inode->i_atime.tv_sec);\n\traw_inode->i_ctime = cpu_to_le32(inode->i_ctime.tv_sec);\n\traw_inode->i_mtime = cpu_to_le32(inode->i_mtime.tv_sec);\n\n\traw_inode->i_blocks = cpu_to_le32(inode->i_blocks);\n\traw_inode->i_dtime = cpu_to_le32(ei->i_dtime);\n\traw_inode->i_flags = cpu_to_le32(ei->i_flags);\n\traw_inode->i_faddr = cpu_to_le32(ei->i_faddr);\n\traw_inode->i_frag = ei->i_frag_no;\n\traw_inode->i_fsize = ei->i_frag_size;\n\traw_inode->i_file_acl = cpu_to_le32(ei->i_file_acl);\n\tif (!S_ISREG(inode->i_mode))\n\t\traw_inode->i_dir_acl = cpu_to_le32(ei->i_dir_acl);\n\telse {\n\t\traw_inode->i_size_high = cpu_to_le32(inode->i_size >> 32);\n\t\tif (inode->i_size > 0x7fffffffULL) {\n\t\t\tif (!EXT2_HAS_RO_COMPAT_FEATURE(sb,\n\t\t\t\t\tEXT2_FEATURE_RO_COMPAT_LARGE_FILE) ||\n\t\t\t    EXT2_SB(sb)->s_es->s_rev_level ==\n\t\t\t\t\tcpu_to_le32(EXT2_GOOD_OLD_REV)) {\n\t\t\t       /* If this is the first large file\n\t\t\t\t* created, add a flag to the superblock.\n\t\t\t\t*/\n\t\t\t\tspin_lock(&EXT2_SB(sb)->s_lock);\n\t\t\t\text2_update_dynamic_rev(sb);\n\t\t\t\tEXT2_SET_RO_COMPAT_FEATURE(sb,\n\t\t\t\t\tEXT2_FEATURE_RO_COMPAT_LARGE_FILE);\n\t\t\t\tspin_unlock(&EXT2_SB(sb)->s_lock);\n\t\t\t\text2_write_super(sb);\n\t\t\t}\n\t\t}\n\t}\n\t\n\traw_inode->i_generation = cpu_to_le32(inode->i_generation);\n\tif (S_ISCHR(inode->i_mode) || S_ISBLK(inode->i_mode)) {\n\t\tif (old_valid_dev(inode->i_rdev)) {\n\t\t\traw_inode->i_block[0] =\n\t\t\t\tcpu_to_le32(old_encode_dev(inode->i_rdev));\n\t\t\traw_inode->i_block[1] = 0;\n\t\t} else {\n\t\t\traw_inode->i_block[0] = 0;\n\t\t\traw_inode->i_block[1] =\n\t\t\t\tcpu_to_le32(new_encode_dev(inode->i_rdev));\n\t\t\traw_inode->i_block[2] = 0;\n\t\t}\n\t} else for (n = 0; n < EXT2_N_BLOCKS; n++)\n\t\traw_inode->i_block[n] = ei->i_data[n];\n\tmark_buffer_dirty(bh);\n\tif (do_sync) {\n\t\tsync_dirty_buffer(bh);\n\t\tif (buffer_req(bh) && !buffer_uptodate(bh)) {\n\t\t\tprintk (\"IO error syncing ext2 inode [%s:%08lx]\\n\",\n\t\t\t\tsb->s_id, (unsigned long) ino);\n\t\t\terr = -EIO;\n\t\t}\n\t}\n\tei->i_state &= ~EXT2_STATE_NEW;\n\tbrelse (bh);\n\treturn err;\n}"
  },
  {
    "function_name": "ext2_iget",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext2/inode.c",
    "lines": "1312-1437",
    "snippet": "struct inode *ext2_iget (struct super_block *sb, unsigned long ino)\n{\n\tstruct ext2_inode_info *ei;\n\tstruct buffer_head * bh;\n\tstruct ext2_inode *raw_inode;\n\tstruct inode *inode;\n\tlong ret = -EIO;\n\tint n;\n\tuid_t i_uid;\n\tgid_t i_gid;\n\n\tinode = iget_locked(sb, ino);\n\tif (!inode)\n\t\treturn ERR_PTR(-ENOMEM);\n\tif (!(inode->i_state & I_NEW))\n\t\treturn inode;\n\n\tei = EXT2_I(inode);\n\tei->i_block_alloc_info = NULL;\n\n\traw_inode = ext2_get_inode(inode->i_sb, ino, &bh);\n\tif (IS_ERR(raw_inode)) {\n\t\tret = PTR_ERR(raw_inode);\n \t\tgoto bad_inode;\n\t}\n\n\tinode->i_mode = le16_to_cpu(raw_inode->i_mode);\n\ti_uid = (uid_t)le16_to_cpu(raw_inode->i_uid_low);\n\ti_gid = (gid_t)le16_to_cpu(raw_inode->i_gid_low);\n\tif (!(test_opt (inode->i_sb, NO_UID32))) {\n\t\ti_uid |= le16_to_cpu(raw_inode->i_uid_high) << 16;\n\t\ti_gid |= le16_to_cpu(raw_inode->i_gid_high) << 16;\n\t}\n\ti_uid_write(inode, i_uid);\n\ti_gid_write(inode, i_gid);\n\tset_nlink(inode, le16_to_cpu(raw_inode->i_links_count));\n\tinode->i_size = le32_to_cpu(raw_inode->i_size);\n\tinode->i_atime.tv_sec = (signed)le32_to_cpu(raw_inode->i_atime);\n\tinode->i_ctime.tv_sec = (signed)le32_to_cpu(raw_inode->i_ctime);\n\tinode->i_mtime.tv_sec = (signed)le32_to_cpu(raw_inode->i_mtime);\n\tinode->i_atime.tv_nsec = inode->i_mtime.tv_nsec = inode->i_ctime.tv_nsec = 0;\n\tei->i_dtime = le32_to_cpu(raw_inode->i_dtime);\n\t/* We now have enough fields to check if the inode was active or not.\n\t * This is needed because nfsd might try to access dead inodes\n\t * the test is that same one that e2fsck uses\n\t * NeilBrown 1999oct15\n\t */\n\tif (inode->i_nlink == 0 && (inode->i_mode == 0 || ei->i_dtime)) {\n\t\t/* this inode is deleted */\n\t\tbrelse (bh);\n\t\tret = -ESTALE;\n\t\tgoto bad_inode;\n\t}\n\tinode->i_blocks = le32_to_cpu(raw_inode->i_blocks);\n\tei->i_flags = le32_to_cpu(raw_inode->i_flags);\n\tei->i_faddr = le32_to_cpu(raw_inode->i_faddr);\n\tei->i_frag_no = raw_inode->i_frag;\n\tei->i_frag_size = raw_inode->i_fsize;\n\tei->i_file_acl = le32_to_cpu(raw_inode->i_file_acl);\n\tei->i_dir_acl = 0;\n\tif (S_ISREG(inode->i_mode))\n\t\tinode->i_size |= ((__u64)le32_to_cpu(raw_inode->i_size_high)) << 32;\n\telse\n\t\tei->i_dir_acl = le32_to_cpu(raw_inode->i_dir_acl);\n\tei->i_dtime = 0;\n\tinode->i_generation = le32_to_cpu(raw_inode->i_generation);\n\tei->i_state = 0;\n\tei->i_block_group = (ino - 1) / EXT2_INODES_PER_GROUP(inode->i_sb);\n\tei->i_dir_start_lookup = 0;\n\n\t/*\n\t * NOTE! The in-memory inode i_data array is in little-endian order\n\t * even on big-endian machines: we do NOT byteswap the block numbers!\n\t */\n\tfor (n = 0; n < EXT2_N_BLOCKS; n++)\n\t\tei->i_data[n] = raw_inode->i_block[n];\n\n\tif (S_ISREG(inode->i_mode)) {\n\t\tinode->i_op = &ext2_file_inode_operations;\n\t\tif (test_opt(inode->i_sb, DAX)) {\n\t\t\tinode->i_mapping->a_ops = &ext2_aops;\n\t\t\tinode->i_fop = &ext2_dax_file_operations;\n\t\t} else if (test_opt(inode->i_sb, NOBH)) {\n\t\t\tinode->i_mapping->a_ops = &ext2_nobh_aops;\n\t\t\tinode->i_fop = &ext2_file_operations;\n\t\t} else {\n\t\t\tinode->i_mapping->a_ops = &ext2_aops;\n\t\t\tinode->i_fop = &ext2_file_operations;\n\t\t}\n\t} else if (S_ISDIR(inode->i_mode)) {\n\t\tinode->i_op = &ext2_dir_inode_operations;\n\t\tinode->i_fop = &ext2_dir_operations;\n\t\tif (test_opt(inode->i_sb, NOBH))\n\t\t\tinode->i_mapping->a_ops = &ext2_nobh_aops;\n\t\telse\n\t\t\tinode->i_mapping->a_ops = &ext2_aops;\n\t} else if (S_ISLNK(inode->i_mode)) {\n\t\tif (ext2_inode_is_fast_symlink(inode)) {\n\t\t\tinode->i_op = &ext2_fast_symlink_inode_operations;\n\t\t\tnd_terminate_link(ei->i_data, inode->i_size,\n\t\t\t\tsizeof(ei->i_data) - 1);\n\t\t} else {\n\t\t\tinode->i_op = &ext2_symlink_inode_operations;\n\t\t\tif (test_opt(inode->i_sb, NOBH))\n\t\t\t\tinode->i_mapping->a_ops = &ext2_nobh_aops;\n\t\t\telse\n\t\t\t\tinode->i_mapping->a_ops = &ext2_aops;\n\t\t}\n\t} else {\n\t\tinode->i_op = &ext2_special_inode_operations;\n\t\tif (raw_inode->i_block[0])\n\t\t\tinit_special_inode(inode, inode->i_mode,\n\t\t\t   old_decode_dev(le32_to_cpu(raw_inode->i_block[0])));\n\t\telse \n\t\t\tinit_special_inode(inode, inode->i_mode,\n\t\t\t   new_decode_dev(le32_to_cpu(raw_inode->i_block[1])));\n\t}\n\tbrelse (bh);\n\text2_set_inode_flags(inode);\n\tunlock_new_inode(inode);\n\treturn inode;\n\t\nbad_inode:\n\tiget_failed(inode);\n\treturn ERR_PTR(ret);\n}",
    "includes": [
      "#include \"xattr.h\"",
      "#include \"acl.h\"",
      "#include \"ext2.h\"",
      "#include <linux/aio.h>",
      "#include <linux/namei.h>",
      "#include <linux/fiemap.h>",
      "#include <linux/mpage.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/writeback.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/highuid.h>",
      "#include <linux/time.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "const struct address_space_operations ext2_aops = {\n\t.readpage\t\t= ext2_readpage,\n\t.readpages\t\t= ext2_readpages,\n\t.writepage\t\t= ext2_writepage,\n\t.write_begin\t\t= ext2_write_begin,\n\t.write_end\t\t= ext2_write_end,\n\t.bmap\t\t\t= ext2_bmap,\n\t.direct_IO\t\t= ext2_direct_IO,\n\t.writepages\t\t= ext2_writepages,\n\t.migratepage\t\t= buffer_migrate_page,\n\t.is_partially_uptodate\t= block_is_partially_uptodate,\n\t.error_remove_page\t= generic_error_remove_page,\n};",
      "const struct address_space_operations ext2_nobh_aops = {\n\t.readpage\t\t= ext2_readpage,\n\t.readpages\t\t= ext2_readpages,\n\t.writepage\t\t= ext2_nobh_writepage,\n\t.write_begin\t\t= ext2_nobh_write_begin,\n\t.write_end\t\t= nobh_write_end,\n\t.bmap\t\t\t= ext2_bmap,\n\t.direct_IO\t\t= ext2_direct_IO,\n\t.writepages\t\t= ext2_writepages,\n\t.migratepage\t\t= buffer_migrate_page,\n\t.error_remove_page\t= generic_error_remove_page,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "ret"
          ],
          "line": 1436
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "iget_failed",
          "args": [
            "inode"
          ],
          "line": 1435
        },
        "resolved": true,
        "details": {
          "function_name": "iget_failed",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/bad_inode.c",
          "lines": "208-213",
          "snippet": "void iget_failed(struct inode *inode)\n{\n\tmake_bad_inode(inode);\n\tunlock_new_inode(inode);\n\tiput(inode);\n}",
          "includes": [
            "#include <linux/poll.h>",
            "#include <linux/namei.h>",
            "#include <linux/time.h>",
            "#include <linux/stat.h>",
            "#include <linux/export.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/poll.h>\n#include <linux/namei.h>\n#include <linux/time.h>\n#include <linux/stat.h>\n#include <linux/export.h>\n#include <linux/fs.h>\n\nvoid iget_failed(struct inode *inode)\n{\n\tmake_bad_inode(inode);\n\tunlock_new_inode(inode);\n\tiput(inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlock_new_inode",
          "args": [
            "inode"
          ],
          "line": 1431
        },
        "resolved": true,
        "details": {
          "function_name": "unlock_new_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "924-933",
          "snippet": "void unlock_new_inode(struct inode *inode)\n{\n\tlockdep_annotate_inode_mutex_key(inode);\n\tspin_lock(&inode->i_lock);\n\tWARN_ON(!(inode->i_state & I_NEW));\n\tinode->i_state &= ~I_NEW;\n\tsmp_mb();\n\twake_up_bit(&inode->i_state, __I_NEW);\n\tspin_unlock(&inode->i_lock);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid unlock_new_inode(struct inode *inode)\n{\n\tlockdep_annotate_inode_mutex_key(inode);\n\tspin_lock(&inode->i_lock);\n\tWARN_ON(!(inode->i_state & I_NEW));\n\tinode->i_state &= ~I_NEW;\n\tsmp_mb();\n\twake_up_bit(&inode->i_state, __I_NEW);\n\tspin_unlock(&inode->i_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext2_set_inode_flags",
          "args": [
            "inode"
          ],
          "line": 1430
        },
        "resolved": true,
        "details": {
          "function_name": "ext2_set_inode_flags",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext2/inode.c",
          "lines": "1273-1291",
          "snippet": "void ext2_set_inode_flags(struct inode *inode)\n{\n\tunsigned int flags = EXT2_I(inode)->i_flags;\n\n\tinode->i_flags &= ~(S_SYNC | S_APPEND | S_IMMUTABLE | S_NOATIME |\n\t\t\t\tS_DIRSYNC | S_DAX);\n\tif (flags & EXT2_SYNC_FL)\n\t\tinode->i_flags |= S_SYNC;\n\tif (flags & EXT2_APPEND_FL)\n\t\tinode->i_flags |= S_APPEND;\n\tif (flags & EXT2_IMMUTABLE_FL)\n\t\tinode->i_flags |= S_IMMUTABLE;\n\tif (flags & EXT2_NOATIME_FL)\n\t\tinode->i_flags |= S_NOATIME;\n\tif (flags & EXT2_DIRSYNC_FL)\n\t\tinode->i_flags |= S_DIRSYNC;\n\tif (test_opt(inode->i_sb, DAX))\n\t\tinode->i_flags |= S_DAX;\n}",
          "includes": [
            "#include \"xattr.h\"",
            "#include \"acl.h\"",
            "#include \"ext2.h\"",
            "#include <linux/aio.h>",
            "#include <linux/namei.h>",
            "#include <linux/fiemap.h>",
            "#include <linux/mpage.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/writeback.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highuid.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xattr.h\"\n#include \"acl.h\"\n#include \"ext2.h\"\n#include <linux/aio.h>\n#include <linux/namei.h>\n#include <linux/fiemap.h>\n#include <linux/mpage.h>\n#include <linux/buffer_head.h>\n#include <linux/writeback.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/highuid.h>\n#include <linux/time.h>\n\nvoid ext2_set_inode_flags(struct inode *inode)\n{\n\tunsigned int flags = EXT2_I(inode)->i_flags;\n\n\tinode->i_flags &= ~(S_SYNC | S_APPEND | S_IMMUTABLE | S_NOATIME |\n\t\t\t\tS_DIRSYNC | S_DAX);\n\tif (flags & EXT2_SYNC_FL)\n\t\tinode->i_flags |= S_SYNC;\n\tif (flags & EXT2_APPEND_FL)\n\t\tinode->i_flags |= S_APPEND;\n\tif (flags & EXT2_IMMUTABLE_FL)\n\t\tinode->i_flags |= S_IMMUTABLE;\n\tif (flags & EXT2_NOATIME_FL)\n\t\tinode->i_flags |= S_NOATIME;\n\tif (flags & EXT2_DIRSYNC_FL)\n\t\tinode->i_flags |= S_DIRSYNC;\n\tif (test_opt(inode->i_sb, DAX))\n\t\tinode->i_flags |= S_DAX;\n}"
        }
      },
      {
        "call_info": {
          "callee": "brelse",
          "args": [
            "bh"
          ],
          "line": 1429
        },
        "resolved": true,
        "details": {
          "function_name": "__brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1177-1184",
          "snippet": "void __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "init_special_inode",
          "args": [
            "inode",
            "inode->i_mode",
            "new_decode_dev(le32_to_cpu(raw_inode->i_block[1]))"
          ],
          "line": 1426
        },
        "resolved": true,
        "details": {
          "function_name": "init_special_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "1854-1871",
          "snippet": "void init_special_inode(struct inode *inode, umode_t mode, dev_t rdev)\n{\n\tinode->i_mode = mode;\n\tif (S_ISCHR(mode)) {\n\t\tinode->i_fop = &def_chr_fops;\n\t\tinode->i_rdev = rdev;\n\t} else if (S_ISBLK(mode)) {\n\t\tinode->i_fop = &def_blk_fops;\n\t\tinode->i_rdev = rdev;\n\t} else if (S_ISFIFO(mode))\n\t\tinode->i_fop = &pipefifo_fops;\n\telse if (S_ISSOCK(mode))\n\t\t;\t/* leave it no_open_fops */\n\telse\n\t\tprintk(KERN_DEBUG \"init_special_inode: bogus i_mode (%o) for\"\n\t\t\t\t  \" inode %s:%lu\\n\", mode, inode->i_sb->s_id,\n\t\t\t\t  inode->i_ino);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid init_special_inode(struct inode *inode, umode_t mode, dev_t rdev)\n{\n\tinode->i_mode = mode;\n\tif (S_ISCHR(mode)) {\n\t\tinode->i_fop = &def_chr_fops;\n\t\tinode->i_rdev = rdev;\n\t} else if (S_ISBLK(mode)) {\n\t\tinode->i_fop = &def_blk_fops;\n\t\tinode->i_rdev = rdev;\n\t} else if (S_ISFIFO(mode))\n\t\tinode->i_fop = &pipefifo_fops;\n\telse if (S_ISSOCK(mode))\n\t\t;\t/* leave it no_open_fops */\n\telse\n\t\tprintk(KERN_DEBUG \"init_special_inode: bogus i_mode (%o) for\"\n\t\t\t\t  \" inode %s:%lu\\n\", mode, inode->i_sb->s_id,\n\t\t\t\t  inode->i_ino);\n}"
        }
      },
      {
        "call_info": {
          "callee": "new_decode_dev",
          "args": [
            "le32_to_cpu(raw_inode->i_block[1])"
          ],
          "line": 1427
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "raw_inode->i_block[1]"
          ],
          "line": 1427
        },
        "resolved": true,
        "details": {
          "function_name": "sle32_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "53-56",
          "snippet": "static inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "old_decode_dev",
          "args": [
            "le32_to_cpu(raw_inode->i_block[0])"
          ],
          "line": 1424
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_opt",
          "args": [
            "inode->i_sb",
            "NOBH"
          ],
          "line": 1415
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nd_terminate_link",
          "args": [
            "ei->i_data",
            "inode->i_size",
            "sizeof(ei->i_data) - 1"
          ],
          "line": 1411
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext2_inode_is_fast_symlink",
          "args": [
            "inode"
          ],
          "line": 1409
        },
        "resolved": true,
        "details": {
          "function_name": "ext2_inode_is_fast_symlink",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext2/inode.c",
          "lines": "44-51",
          "snippet": "static inline int ext2_inode_is_fast_symlink(struct inode *inode)\n{\n\tint ea_blocks = EXT2_I(inode)->i_file_acl ?\n\t\t(inode->i_sb->s_blocksize >> 9) : 0;\n\n\treturn (S_ISLNK(inode->i_mode) &&\n\t\tinode->i_blocks - ea_blocks == 0);\n}",
          "includes": [
            "#include \"xattr.h\"",
            "#include \"acl.h\"",
            "#include \"ext2.h\"",
            "#include <linux/aio.h>",
            "#include <linux/namei.h>",
            "#include <linux/fiemap.h>",
            "#include <linux/mpage.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/writeback.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highuid.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xattr.h\"\n#include \"acl.h\"\n#include \"ext2.h\"\n#include <linux/aio.h>\n#include <linux/namei.h>\n#include <linux/fiemap.h>\n#include <linux/mpage.h>\n#include <linux/buffer_head.h>\n#include <linux/writeback.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/highuid.h>\n#include <linux/time.h>\n\nstatic inline int ext2_inode_is_fast_symlink(struct inode *inode)\n{\n\tint ea_blocks = EXT2_I(inode)->i_file_acl ?\n\t\t(inode->i_sb->s_blocksize >> 9) : 0;\n\n\treturn (S_ISLNK(inode->i_mode) &&\n\t\tinode->i_blocks - ea_blocks == 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "S_ISLNK",
          "args": [
            "inode->i_mode"
          ],
          "line": 1408
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_opt",
          "args": [
            "inode->i_sb",
            "NOBH"
          ],
          "line": 1404
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISDIR",
          "args": [
            "inode->i_mode"
          ],
          "line": 1401
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_opt",
          "args": [
            "inode->i_sb",
            "NOBH"
          ],
          "line": 1394
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_opt",
          "args": [
            "inode->i_sb",
            "DAX"
          ],
          "line": 1391
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISREG",
          "args": [
            "inode->i_mode"
          ],
          "line": 1389
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXT2_INODES_PER_GROUP",
          "args": [
            "inode->i_sb"
          ],
          "line": 1379
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISREG",
          "args": [
            "inode->i_mode"
          ],
          "line": 1372
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_nlink",
          "args": [
            "inode",
            "le16_to_cpu(raw_inode->i_links_count)"
          ],
          "line": 1347
        },
        "resolved": true,
        "details": {
          "function_name": "set_nlink",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "305-316",
          "snippet": "void set_nlink(struct inode *inode, unsigned int nlink)\n{\n\tif (!nlink) {\n\t\tclear_nlink(inode);\n\t} else {\n\t\t/* Yes, some filesystems do change nlink from zero to one */\n\t\tif (inode->i_nlink == 0)\n\t\t\tatomic_long_dec(&inode->i_sb->s_remove_count);\n\n\t\tinode->__i_nlink = nlink;\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid set_nlink(struct inode *inode, unsigned int nlink)\n{\n\tif (!nlink) {\n\t\tclear_nlink(inode);\n\t} else {\n\t\t/* Yes, some filesystems do change nlink from zero to one */\n\t\tif (inode->i_nlink == 0)\n\t\t\tatomic_long_dec(&inode->i_sb->s_remove_count);\n\n\t\tinode->__i_nlink = nlink;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "le16_to_cpu",
          "args": [
            "raw_inode->i_links_count"
          ],
          "line": 1347
        },
        "resolved": true,
        "details": {
          "function_name": "sle16_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "48-51",
          "snippet": "static inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "i_gid_write",
          "args": [
            "inode",
            "i_gid"
          ],
          "line": 1346
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "i_uid_write",
          "args": [
            "inode",
            "i_uid"
          ],
          "line": 1345
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_opt",
          "args": [
            "inode->i_sb",
            "NO_UID32"
          ],
          "line": 1341
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "raw_inode"
          ],
          "line": 1334
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "raw_inode"
          ],
          "line": 1333
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext2_get_inode",
          "args": [
            "inode->i_sb",
            "ino",
            "&bh"
          ],
          "line": 1332
        },
        "resolved": true,
        "details": {
          "function_name": "ext2_get_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext2/inode.c",
          "lines": "1230-1271",
          "snippet": "static struct ext2_inode *ext2_get_inode(struct super_block *sb, ino_t ino,\n\t\t\t\t\tstruct buffer_head **p)\n{\n\tstruct buffer_head * bh;\n\tunsigned long block_group;\n\tunsigned long block;\n\tunsigned long offset;\n\tstruct ext2_group_desc * gdp;\n\n\t*p = NULL;\n\tif ((ino != EXT2_ROOT_INO && ino < EXT2_FIRST_INO(sb)) ||\n\t    ino > le32_to_cpu(EXT2_SB(sb)->s_es->s_inodes_count))\n\t\tgoto Einval;\n\n\tblock_group = (ino - 1) / EXT2_INODES_PER_GROUP(sb);\n\tgdp = ext2_get_group_desc(sb, block_group, NULL);\n\tif (!gdp)\n\t\tgoto Egdp;\n\t/*\n\t * Figure out the offset within the block group inode table\n\t */\n\toffset = ((ino - 1) % EXT2_INODES_PER_GROUP(sb)) * EXT2_INODE_SIZE(sb);\n\tblock = le32_to_cpu(gdp->bg_inode_table) +\n\t\t(offset >> EXT2_BLOCK_SIZE_BITS(sb));\n\tif (!(bh = sb_bread(sb, block)))\n\t\tgoto Eio;\n\n\t*p = bh;\n\toffset &= (EXT2_BLOCK_SIZE(sb) - 1);\n\treturn (struct ext2_inode *) (bh->b_data + offset);\n\nEinval:\n\text2_error(sb, \"ext2_get_inode\", \"bad inode number: %lu\",\n\t\t   (unsigned long) ino);\n\treturn ERR_PTR(-EINVAL);\nEio:\n\text2_error(sb, \"ext2_get_inode\",\n\t\t   \"unable to read inode block - inode=%lu, block=%lu\",\n\t\t   (unsigned long) ino, block);\nEgdp:\n\treturn ERR_PTR(-EIO);\n}",
          "includes": [
            "#include \"xattr.h\"",
            "#include \"acl.h\"",
            "#include \"ext2.h\"",
            "#include <linux/aio.h>",
            "#include <linux/namei.h>",
            "#include <linux/fiemap.h>",
            "#include <linux/mpage.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/writeback.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highuid.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void ext2_truncate_blocks(struct inode *inode, loff_t offset);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xattr.h\"\n#include \"acl.h\"\n#include \"ext2.h\"\n#include <linux/aio.h>\n#include <linux/namei.h>\n#include <linux/fiemap.h>\n#include <linux/mpage.h>\n#include <linux/buffer_head.h>\n#include <linux/writeback.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/highuid.h>\n#include <linux/time.h>\n\nstatic void ext2_truncate_blocks(struct inode *inode, loff_t offset);\n\nstatic struct ext2_inode *ext2_get_inode(struct super_block *sb, ino_t ino,\n\t\t\t\t\tstruct buffer_head **p)\n{\n\tstruct buffer_head * bh;\n\tunsigned long block_group;\n\tunsigned long block;\n\tunsigned long offset;\n\tstruct ext2_group_desc * gdp;\n\n\t*p = NULL;\n\tif ((ino != EXT2_ROOT_INO && ino < EXT2_FIRST_INO(sb)) ||\n\t    ino > le32_to_cpu(EXT2_SB(sb)->s_es->s_inodes_count))\n\t\tgoto Einval;\n\n\tblock_group = (ino - 1) / EXT2_INODES_PER_GROUP(sb);\n\tgdp = ext2_get_group_desc(sb, block_group, NULL);\n\tif (!gdp)\n\t\tgoto Egdp;\n\t/*\n\t * Figure out the offset within the block group inode table\n\t */\n\toffset = ((ino - 1) % EXT2_INODES_PER_GROUP(sb)) * EXT2_INODE_SIZE(sb);\n\tblock = le32_to_cpu(gdp->bg_inode_table) +\n\t\t(offset >> EXT2_BLOCK_SIZE_BITS(sb));\n\tif (!(bh = sb_bread(sb, block)))\n\t\tgoto Eio;\n\n\t*p = bh;\n\toffset &= (EXT2_BLOCK_SIZE(sb) - 1);\n\treturn (struct ext2_inode *) (bh->b_data + offset);\n\nEinval:\n\text2_error(sb, \"ext2_get_inode\", \"bad inode number: %lu\",\n\t\t   (unsigned long) ino);\n\treturn ERR_PTR(-EINVAL);\nEio:\n\text2_error(sb, \"ext2_get_inode\",\n\t\t   \"unable to read inode block - inode=%lu, block=%lu\",\n\t\t   (unsigned long) ino, block);\nEgdp:\n\treturn ERR_PTR(-EIO);\n}"
        }
      },
      {
        "call_info": {
          "callee": "EXT2_I",
          "args": [
            "inode"
          ],
          "line": 1329
        },
        "resolved": true,
        "details": {
          "function_name": "EXT2_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext2/ext2.h",
          "lines": "717-720",
          "snippet": "static inline struct ext2_inode_info *EXT2_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ext2_inode_info, vfs_inode);\n}",
          "includes": [
            "#include <linux/rbtree.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/ext2_fs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern ext2_fsblk_t ext2_new_block(struct inode *, unsigned long, int *);",
            "extern ext2_fsblk_t ext2_new_blocks(struct inode *, unsigned long,\n\t\t\t\tunsigned long *, int *);",
            "extern void ext2_free_blocks (struct inode *, unsigned long,\n\t\t\t      unsigned long);",
            "extern void ext2_discard_reservation (struct inode *);",
            "extern void ext2_init_block_alloc_info(struct inode *);",
            "extern int ext2_add_link (struct dentry *, struct inode *);",
            "extern int ext2_make_empty(struct inode *, struct inode *);",
            "extern int ext2_empty_dir (struct inode *);",
            "extern void ext2_set_link(struct inode *, struct ext2_dir_entry_2 *, struct page *, struct inode *, int);",
            "extern void ext2_free_inode (struct inode *);",
            "extern void ext2_evict_inode(struct inode *);",
            "extern void ext2_set_inode_flags(struct inode *inode);",
            "extern void ext2_get_inode_flags(struct ext2_inode_info *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rbtree.h>\n#include <linux/percpu_counter.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/ext2_fs.h>\n#include <linux/fs.h>\n\nextern ext2_fsblk_t ext2_new_block(struct inode *, unsigned long, int *);\nextern ext2_fsblk_t ext2_new_blocks(struct inode *, unsigned long,\n\t\t\t\tunsigned long *, int *);\nextern void ext2_free_blocks (struct inode *, unsigned long,\n\t\t\t      unsigned long);\nextern void ext2_discard_reservation (struct inode *);\nextern void ext2_init_block_alloc_info(struct inode *);\nextern int ext2_add_link (struct dentry *, struct inode *);\nextern int ext2_make_empty(struct inode *, struct inode *);\nextern int ext2_empty_dir (struct inode *);\nextern void ext2_set_link(struct inode *, struct ext2_dir_entry_2 *, struct page *, struct inode *, int);\nextern void ext2_free_inode (struct inode *);\nextern void ext2_evict_inode(struct inode *);\nextern void ext2_set_inode_flags(struct inode *inode);\nextern void ext2_get_inode_flags(struct ext2_inode_info *);\n\nstatic inline struct ext2_inode_info *EXT2_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ext2_inode_info, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-ENOMEM"
          ],
          "line": 1325
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "iget_locked",
          "args": [
            "sb",
            "ino"
          ],
          "line": 1323
        },
        "resolved": true,
        "details": {
          "function_name": "iget_locked",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "1063-1109",
          "snippet": "struct inode *iget_locked(struct super_block *sb, unsigned long ino)\n{\n\tstruct hlist_head *head = inode_hashtable + hash(sb, ino);\n\tstruct inode *inode;\n\n\tspin_lock(&inode_hash_lock);\n\tinode = find_inode_fast(sb, head, ino);\n\tspin_unlock(&inode_hash_lock);\n\tif (inode) {\n\t\twait_on_inode(inode);\n\t\treturn inode;\n\t}\n\n\tinode = alloc_inode(sb);\n\tif (inode) {\n\t\tstruct inode *old;\n\n\t\tspin_lock(&inode_hash_lock);\n\t\t/* We released the lock, so.. */\n\t\told = find_inode_fast(sb, head, ino);\n\t\tif (!old) {\n\t\t\tinode->i_ino = ino;\n\t\t\tspin_lock(&inode->i_lock);\n\t\t\tinode->i_state = I_NEW;\n\t\t\thlist_add_head(&inode->i_hash, head);\n\t\t\tspin_unlock(&inode->i_lock);\n\t\t\tinode_sb_list_add(inode);\n\t\t\tspin_unlock(&inode_hash_lock);\n\n\t\t\t/* Return the locked inode with I_NEW set, the\n\t\t\t * caller is responsible for filling in the contents\n\t\t\t */\n\t\t\treturn inode;\n\t\t}\n\n\t\t/*\n\t\t * Uhhuh, somebody else created the same inode under\n\t\t * us. Use the old inode instead of the one we just\n\t\t * allocated.\n\t\t */\n\t\tspin_unlock(&inode_hash_lock);\n\t\tdestroy_inode(inode);\n\t\tinode = old;\n\t\twait_on_inode(inode);\n\t}\n\treturn inode;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct hlist_head *inode_hashtable",
            "static __cacheline_aligned_in_smp DEFINE_SPINLOCK(inode_hash_lock);",
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic struct hlist_head *inode_hashtable;\nstatic __cacheline_aligned_in_smp DEFINE_SPINLOCK(inode_hash_lock);\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nstruct inode *iget_locked(struct super_block *sb, unsigned long ino)\n{\n\tstruct hlist_head *head = inode_hashtable + hash(sb, ino);\n\tstruct inode *inode;\n\n\tspin_lock(&inode_hash_lock);\n\tinode = find_inode_fast(sb, head, ino);\n\tspin_unlock(&inode_hash_lock);\n\tif (inode) {\n\t\twait_on_inode(inode);\n\t\treturn inode;\n\t}\n\n\tinode = alloc_inode(sb);\n\tif (inode) {\n\t\tstruct inode *old;\n\n\t\tspin_lock(&inode_hash_lock);\n\t\t/* We released the lock, so.. */\n\t\told = find_inode_fast(sb, head, ino);\n\t\tif (!old) {\n\t\t\tinode->i_ino = ino;\n\t\t\tspin_lock(&inode->i_lock);\n\t\t\tinode->i_state = I_NEW;\n\t\t\thlist_add_head(&inode->i_hash, head);\n\t\t\tspin_unlock(&inode->i_lock);\n\t\t\tinode_sb_list_add(inode);\n\t\t\tspin_unlock(&inode_hash_lock);\n\n\t\t\t/* Return the locked inode with I_NEW set, the\n\t\t\t * caller is responsible for filling in the contents\n\t\t\t */\n\t\t\treturn inode;\n\t\t}\n\n\t\t/*\n\t\t * Uhhuh, somebody else created the same inode under\n\t\t * us. Use the old inode instead of the one we just\n\t\t * allocated.\n\t\t */\n\t\tspin_unlock(&inode_hash_lock);\n\t\tdestroy_inode(inode);\n\t\tinode = old;\n\t\twait_on_inode(inode);\n\t}\n\treturn inode;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"xattr.h\"\n#include \"acl.h\"\n#include \"ext2.h\"\n#include <linux/aio.h>\n#include <linux/namei.h>\n#include <linux/fiemap.h>\n#include <linux/mpage.h>\n#include <linux/buffer_head.h>\n#include <linux/writeback.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/highuid.h>\n#include <linux/time.h>\n\nconst struct address_space_operations ext2_aops = {\n\t.readpage\t\t= ext2_readpage,\n\t.readpages\t\t= ext2_readpages,\n\t.writepage\t\t= ext2_writepage,\n\t.write_begin\t\t= ext2_write_begin,\n\t.write_end\t\t= ext2_write_end,\n\t.bmap\t\t\t= ext2_bmap,\n\t.direct_IO\t\t= ext2_direct_IO,\n\t.writepages\t\t= ext2_writepages,\n\t.migratepage\t\t= buffer_migrate_page,\n\t.is_partially_uptodate\t= block_is_partially_uptodate,\n\t.error_remove_page\t= generic_error_remove_page,\n};\nconst struct address_space_operations ext2_nobh_aops = {\n\t.readpage\t\t= ext2_readpage,\n\t.readpages\t\t= ext2_readpages,\n\t.writepage\t\t= ext2_nobh_writepage,\n\t.write_begin\t\t= ext2_nobh_write_begin,\n\t.write_end\t\t= nobh_write_end,\n\t.bmap\t\t\t= ext2_bmap,\n\t.direct_IO\t\t= ext2_direct_IO,\n\t.writepages\t\t= ext2_writepages,\n\t.migratepage\t\t= buffer_migrate_page,\n\t.error_remove_page\t= generic_error_remove_page,\n};\n\nstruct inode *ext2_iget (struct super_block *sb, unsigned long ino)\n{\n\tstruct ext2_inode_info *ei;\n\tstruct buffer_head * bh;\n\tstruct ext2_inode *raw_inode;\n\tstruct inode *inode;\n\tlong ret = -EIO;\n\tint n;\n\tuid_t i_uid;\n\tgid_t i_gid;\n\n\tinode = iget_locked(sb, ino);\n\tif (!inode)\n\t\treturn ERR_PTR(-ENOMEM);\n\tif (!(inode->i_state & I_NEW))\n\t\treturn inode;\n\n\tei = EXT2_I(inode);\n\tei->i_block_alloc_info = NULL;\n\n\traw_inode = ext2_get_inode(inode->i_sb, ino, &bh);\n\tif (IS_ERR(raw_inode)) {\n\t\tret = PTR_ERR(raw_inode);\n \t\tgoto bad_inode;\n\t}\n\n\tinode->i_mode = le16_to_cpu(raw_inode->i_mode);\n\ti_uid = (uid_t)le16_to_cpu(raw_inode->i_uid_low);\n\ti_gid = (gid_t)le16_to_cpu(raw_inode->i_gid_low);\n\tif (!(test_opt (inode->i_sb, NO_UID32))) {\n\t\ti_uid |= le16_to_cpu(raw_inode->i_uid_high) << 16;\n\t\ti_gid |= le16_to_cpu(raw_inode->i_gid_high) << 16;\n\t}\n\ti_uid_write(inode, i_uid);\n\ti_gid_write(inode, i_gid);\n\tset_nlink(inode, le16_to_cpu(raw_inode->i_links_count));\n\tinode->i_size = le32_to_cpu(raw_inode->i_size);\n\tinode->i_atime.tv_sec = (signed)le32_to_cpu(raw_inode->i_atime);\n\tinode->i_ctime.tv_sec = (signed)le32_to_cpu(raw_inode->i_ctime);\n\tinode->i_mtime.tv_sec = (signed)le32_to_cpu(raw_inode->i_mtime);\n\tinode->i_atime.tv_nsec = inode->i_mtime.tv_nsec = inode->i_ctime.tv_nsec = 0;\n\tei->i_dtime = le32_to_cpu(raw_inode->i_dtime);\n\t/* We now have enough fields to check if the inode was active or not.\n\t * This is needed because nfsd might try to access dead inodes\n\t * the test is that same one that e2fsck uses\n\t * NeilBrown 1999oct15\n\t */\n\tif (inode->i_nlink == 0 && (inode->i_mode == 0 || ei->i_dtime)) {\n\t\t/* this inode is deleted */\n\t\tbrelse (bh);\n\t\tret = -ESTALE;\n\t\tgoto bad_inode;\n\t}\n\tinode->i_blocks = le32_to_cpu(raw_inode->i_blocks);\n\tei->i_flags = le32_to_cpu(raw_inode->i_flags);\n\tei->i_faddr = le32_to_cpu(raw_inode->i_faddr);\n\tei->i_frag_no = raw_inode->i_frag;\n\tei->i_frag_size = raw_inode->i_fsize;\n\tei->i_file_acl = le32_to_cpu(raw_inode->i_file_acl);\n\tei->i_dir_acl = 0;\n\tif (S_ISREG(inode->i_mode))\n\t\tinode->i_size |= ((__u64)le32_to_cpu(raw_inode->i_size_high)) << 32;\n\telse\n\t\tei->i_dir_acl = le32_to_cpu(raw_inode->i_dir_acl);\n\tei->i_dtime = 0;\n\tinode->i_generation = le32_to_cpu(raw_inode->i_generation);\n\tei->i_state = 0;\n\tei->i_block_group = (ino - 1) / EXT2_INODES_PER_GROUP(inode->i_sb);\n\tei->i_dir_start_lookup = 0;\n\n\t/*\n\t * NOTE! The in-memory inode i_data array is in little-endian order\n\t * even on big-endian machines: we do NOT byteswap the block numbers!\n\t */\n\tfor (n = 0; n < EXT2_N_BLOCKS; n++)\n\t\tei->i_data[n] = raw_inode->i_block[n];\n\n\tif (S_ISREG(inode->i_mode)) {\n\t\tinode->i_op = &ext2_file_inode_operations;\n\t\tif (test_opt(inode->i_sb, DAX)) {\n\t\t\tinode->i_mapping->a_ops = &ext2_aops;\n\t\t\tinode->i_fop = &ext2_dax_file_operations;\n\t\t} else if (test_opt(inode->i_sb, NOBH)) {\n\t\t\tinode->i_mapping->a_ops = &ext2_nobh_aops;\n\t\t\tinode->i_fop = &ext2_file_operations;\n\t\t} else {\n\t\t\tinode->i_mapping->a_ops = &ext2_aops;\n\t\t\tinode->i_fop = &ext2_file_operations;\n\t\t}\n\t} else if (S_ISDIR(inode->i_mode)) {\n\t\tinode->i_op = &ext2_dir_inode_operations;\n\t\tinode->i_fop = &ext2_dir_operations;\n\t\tif (test_opt(inode->i_sb, NOBH))\n\t\t\tinode->i_mapping->a_ops = &ext2_nobh_aops;\n\t\telse\n\t\t\tinode->i_mapping->a_ops = &ext2_aops;\n\t} else if (S_ISLNK(inode->i_mode)) {\n\t\tif (ext2_inode_is_fast_symlink(inode)) {\n\t\t\tinode->i_op = &ext2_fast_symlink_inode_operations;\n\t\t\tnd_terminate_link(ei->i_data, inode->i_size,\n\t\t\t\tsizeof(ei->i_data) - 1);\n\t\t} else {\n\t\t\tinode->i_op = &ext2_symlink_inode_operations;\n\t\t\tif (test_opt(inode->i_sb, NOBH))\n\t\t\t\tinode->i_mapping->a_ops = &ext2_nobh_aops;\n\t\t\telse\n\t\t\t\tinode->i_mapping->a_ops = &ext2_aops;\n\t\t}\n\t} else {\n\t\tinode->i_op = &ext2_special_inode_operations;\n\t\tif (raw_inode->i_block[0])\n\t\t\tinit_special_inode(inode, inode->i_mode,\n\t\t\t   old_decode_dev(le32_to_cpu(raw_inode->i_block[0])));\n\t\telse \n\t\t\tinit_special_inode(inode, inode->i_mode,\n\t\t\t   new_decode_dev(le32_to_cpu(raw_inode->i_block[1])));\n\t}\n\tbrelse (bh);\n\text2_set_inode_flags(inode);\n\tunlock_new_inode(inode);\n\treturn inode;\n\t\nbad_inode:\n\tiget_failed(inode);\n\treturn ERR_PTR(ret);\n}"
  },
  {
    "function_name": "ext2_get_inode_flags",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext2/inode.c",
    "lines": "1294-1310",
    "snippet": "void ext2_get_inode_flags(struct ext2_inode_info *ei)\n{\n\tunsigned int flags = ei->vfs_inode.i_flags;\n\n\tei->i_flags &= ~(EXT2_SYNC_FL|EXT2_APPEND_FL|\n\t\t\tEXT2_IMMUTABLE_FL|EXT2_NOATIME_FL|EXT2_DIRSYNC_FL);\n\tif (flags & S_SYNC)\n\t\tei->i_flags |= EXT2_SYNC_FL;\n\tif (flags & S_APPEND)\n\t\tei->i_flags |= EXT2_APPEND_FL;\n\tif (flags & S_IMMUTABLE)\n\t\tei->i_flags |= EXT2_IMMUTABLE_FL;\n\tif (flags & S_NOATIME)\n\t\tei->i_flags |= EXT2_NOATIME_FL;\n\tif (flags & S_DIRSYNC)\n\t\tei->i_flags |= EXT2_DIRSYNC_FL;\n}",
    "includes": [
      "#include \"xattr.h\"",
      "#include \"acl.h\"",
      "#include \"ext2.h\"",
      "#include <linux/aio.h>",
      "#include <linux/namei.h>",
      "#include <linux/fiemap.h>",
      "#include <linux/mpage.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/writeback.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/highuid.h>",
      "#include <linux/time.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"xattr.h\"\n#include \"acl.h\"\n#include \"ext2.h\"\n#include <linux/aio.h>\n#include <linux/namei.h>\n#include <linux/fiemap.h>\n#include <linux/mpage.h>\n#include <linux/buffer_head.h>\n#include <linux/writeback.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/highuid.h>\n#include <linux/time.h>\n\nvoid ext2_get_inode_flags(struct ext2_inode_info *ei)\n{\n\tunsigned int flags = ei->vfs_inode.i_flags;\n\n\tei->i_flags &= ~(EXT2_SYNC_FL|EXT2_APPEND_FL|\n\t\t\tEXT2_IMMUTABLE_FL|EXT2_NOATIME_FL|EXT2_DIRSYNC_FL);\n\tif (flags & S_SYNC)\n\t\tei->i_flags |= EXT2_SYNC_FL;\n\tif (flags & S_APPEND)\n\t\tei->i_flags |= EXT2_APPEND_FL;\n\tif (flags & S_IMMUTABLE)\n\t\tei->i_flags |= EXT2_IMMUTABLE_FL;\n\tif (flags & S_NOATIME)\n\t\tei->i_flags |= EXT2_NOATIME_FL;\n\tif (flags & S_DIRSYNC)\n\t\tei->i_flags |= EXT2_DIRSYNC_FL;\n}"
  },
  {
    "function_name": "ext2_set_inode_flags",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext2/inode.c",
    "lines": "1273-1291",
    "snippet": "void ext2_set_inode_flags(struct inode *inode)\n{\n\tunsigned int flags = EXT2_I(inode)->i_flags;\n\n\tinode->i_flags &= ~(S_SYNC | S_APPEND | S_IMMUTABLE | S_NOATIME |\n\t\t\t\tS_DIRSYNC | S_DAX);\n\tif (flags & EXT2_SYNC_FL)\n\t\tinode->i_flags |= S_SYNC;\n\tif (flags & EXT2_APPEND_FL)\n\t\tinode->i_flags |= S_APPEND;\n\tif (flags & EXT2_IMMUTABLE_FL)\n\t\tinode->i_flags |= S_IMMUTABLE;\n\tif (flags & EXT2_NOATIME_FL)\n\t\tinode->i_flags |= S_NOATIME;\n\tif (flags & EXT2_DIRSYNC_FL)\n\t\tinode->i_flags |= S_DIRSYNC;\n\tif (test_opt(inode->i_sb, DAX))\n\t\tinode->i_flags |= S_DAX;\n}",
    "includes": [
      "#include \"xattr.h\"",
      "#include \"acl.h\"",
      "#include \"ext2.h\"",
      "#include <linux/aio.h>",
      "#include <linux/namei.h>",
      "#include <linux/fiemap.h>",
      "#include <linux/mpage.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/writeback.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/highuid.h>",
      "#include <linux/time.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "test_opt",
          "args": [
            "inode->i_sb",
            "DAX"
          ],
          "line": 1289
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXT2_I",
          "args": [
            "inode"
          ],
          "line": 1275
        },
        "resolved": true,
        "details": {
          "function_name": "EXT2_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext2/ext2.h",
          "lines": "717-720",
          "snippet": "static inline struct ext2_inode_info *EXT2_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ext2_inode_info, vfs_inode);\n}",
          "includes": [
            "#include <linux/rbtree.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/ext2_fs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern ext2_fsblk_t ext2_new_block(struct inode *, unsigned long, int *);",
            "extern ext2_fsblk_t ext2_new_blocks(struct inode *, unsigned long,\n\t\t\t\tunsigned long *, int *);",
            "extern void ext2_free_blocks (struct inode *, unsigned long,\n\t\t\t      unsigned long);",
            "extern void ext2_discard_reservation (struct inode *);",
            "extern void ext2_init_block_alloc_info(struct inode *);",
            "extern int ext2_add_link (struct dentry *, struct inode *);",
            "extern int ext2_make_empty(struct inode *, struct inode *);",
            "extern int ext2_empty_dir (struct inode *);",
            "extern void ext2_set_link(struct inode *, struct ext2_dir_entry_2 *, struct page *, struct inode *, int);",
            "extern void ext2_free_inode (struct inode *);",
            "extern void ext2_evict_inode(struct inode *);",
            "extern void ext2_set_inode_flags(struct inode *inode);",
            "extern void ext2_get_inode_flags(struct ext2_inode_info *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rbtree.h>\n#include <linux/percpu_counter.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/ext2_fs.h>\n#include <linux/fs.h>\n\nextern ext2_fsblk_t ext2_new_block(struct inode *, unsigned long, int *);\nextern ext2_fsblk_t ext2_new_blocks(struct inode *, unsigned long,\n\t\t\t\tunsigned long *, int *);\nextern void ext2_free_blocks (struct inode *, unsigned long,\n\t\t\t      unsigned long);\nextern void ext2_discard_reservation (struct inode *);\nextern void ext2_init_block_alloc_info(struct inode *);\nextern int ext2_add_link (struct dentry *, struct inode *);\nextern int ext2_make_empty(struct inode *, struct inode *);\nextern int ext2_empty_dir (struct inode *);\nextern void ext2_set_link(struct inode *, struct ext2_dir_entry_2 *, struct page *, struct inode *, int);\nextern void ext2_free_inode (struct inode *);\nextern void ext2_evict_inode(struct inode *);\nextern void ext2_set_inode_flags(struct inode *inode);\nextern void ext2_get_inode_flags(struct ext2_inode_info *);\n\nstatic inline struct ext2_inode_info *EXT2_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ext2_inode_info, vfs_inode);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"xattr.h\"\n#include \"acl.h\"\n#include \"ext2.h\"\n#include <linux/aio.h>\n#include <linux/namei.h>\n#include <linux/fiemap.h>\n#include <linux/mpage.h>\n#include <linux/buffer_head.h>\n#include <linux/writeback.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/highuid.h>\n#include <linux/time.h>\n\nvoid ext2_set_inode_flags(struct inode *inode)\n{\n\tunsigned int flags = EXT2_I(inode)->i_flags;\n\n\tinode->i_flags &= ~(S_SYNC | S_APPEND | S_IMMUTABLE | S_NOATIME |\n\t\t\t\tS_DIRSYNC | S_DAX);\n\tif (flags & EXT2_SYNC_FL)\n\t\tinode->i_flags |= S_SYNC;\n\tif (flags & EXT2_APPEND_FL)\n\t\tinode->i_flags |= S_APPEND;\n\tif (flags & EXT2_IMMUTABLE_FL)\n\t\tinode->i_flags |= S_IMMUTABLE;\n\tif (flags & EXT2_NOATIME_FL)\n\t\tinode->i_flags |= S_NOATIME;\n\tif (flags & EXT2_DIRSYNC_FL)\n\t\tinode->i_flags |= S_DIRSYNC;\n\tif (test_opt(inode->i_sb, DAX))\n\t\tinode->i_flags |= S_DAX;\n}"
  },
  {
    "function_name": "ext2_get_inode",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext2/inode.c",
    "lines": "1230-1271",
    "snippet": "static struct ext2_inode *ext2_get_inode(struct super_block *sb, ino_t ino,\n\t\t\t\t\tstruct buffer_head **p)\n{\n\tstruct buffer_head * bh;\n\tunsigned long block_group;\n\tunsigned long block;\n\tunsigned long offset;\n\tstruct ext2_group_desc * gdp;\n\n\t*p = NULL;\n\tif ((ino != EXT2_ROOT_INO && ino < EXT2_FIRST_INO(sb)) ||\n\t    ino > le32_to_cpu(EXT2_SB(sb)->s_es->s_inodes_count))\n\t\tgoto Einval;\n\n\tblock_group = (ino - 1) / EXT2_INODES_PER_GROUP(sb);\n\tgdp = ext2_get_group_desc(sb, block_group, NULL);\n\tif (!gdp)\n\t\tgoto Egdp;\n\t/*\n\t * Figure out the offset within the block group inode table\n\t */\n\toffset = ((ino - 1) % EXT2_INODES_PER_GROUP(sb)) * EXT2_INODE_SIZE(sb);\n\tblock = le32_to_cpu(gdp->bg_inode_table) +\n\t\t(offset >> EXT2_BLOCK_SIZE_BITS(sb));\n\tif (!(bh = sb_bread(sb, block)))\n\t\tgoto Eio;\n\n\t*p = bh;\n\toffset &= (EXT2_BLOCK_SIZE(sb) - 1);\n\treturn (struct ext2_inode *) (bh->b_data + offset);\n\nEinval:\n\text2_error(sb, \"ext2_get_inode\", \"bad inode number: %lu\",\n\t\t   (unsigned long) ino);\n\treturn ERR_PTR(-EINVAL);\nEio:\n\text2_error(sb, \"ext2_get_inode\",\n\t\t   \"unable to read inode block - inode=%lu, block=%lu\",\n\t\t   (unsigned long) ino, block);\nEgdp:\n\treturn ERR_PTR(-EIO);\n}",
    "includes": [
      "#include \"xattr.h\"",
      "#include \"acl.h\"",
      "#include \"ext2.h\"",
      "#include <linux/aio.h>",
      "#include <linux/namei.h>",
      "#include <linux/fiemap.h>",
      "#include <linux/mpage.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/writeback.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/highuid.h>",
      "#include <linux/time.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void ext2_truncate_blocks(struct inode *inode, loff_t offset);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-EIO"
          ],
          "line": 1270
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext2_error",
          "args": [
            "sb",
            "\"ext2_get_inode\"",
            "\"unable to read inode block - inode=%lu, block=%lu\"",
            "(unsigned long) ino",
            "block"
          ],
          "line": 1266
        },
        "resolved": true,
        "details": {
          "function_name": "ext2_error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext2/super.c",
          "lines": "47-80",
          "snippet": "void ext2_error(struct super_block *sb, const char *function,\n\t\tconst char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\tstruct ext2_sb_info *sbi = EXT2_SB(sb);\n\tstruct ext2_super_block *es = sbi->s_es;\n\n\tif (!(sb->s_flags & MS_RDONLY)) {\n\t\tspin_lock(&sbi->s_lock);\n\t\tsbi->s_mount_state |= EXT2_ERROR_FS;\n\t\tes->s_state |= cpu_to_le16(EXT2_ERROR_FS);\n\t\tspin_unlock(&sbi->s_lock);\n\t\text2_sync_super(sb, es, 1);\n\t}\n\n\tva_start(args, fmt);\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\tprintk(KERN_CRIT \"EXT2-fs (%s): error: %s: %pV\\n\",\n\t       sb->s_id, function, &vaf);\n\n\tva_end(args);\n\n\tif (test_opt(sb, ERRORS_PANIC))\n\t\tpanic(\"EXT2-fs: panic from previous error\\n\");\n\tif (test_opt(sb, ERRORS_RO)) {\n\t\text2_msg(sb, KERN_CRIT,\n\t\t\t     \"error: remounting filesystem read-only\");\n\t\tsb->s_flags |= MS_RDONLY;\n\t}\n}",
          "includes": [
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext2.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/log2.h>",
            "#include <linux/mount.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/vfs.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/random.h>",
            "#include <linux/parser.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/string.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ext2_freeze(struct super_block *sb);",
            "static int ext2_unfreeze(struct super_block *sb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext2.h\"\n#include <asm/uaccess.h>\n#include <linux/quotaops.h>\n#include <linux/log2.h>\n#include <linux/mount.h>\n#include <linux/seq_file.h>\n#include <linux/vfs.h>\n#include <linux/exportfs.h>\n#include <linux/buffer_head.h>\n#include <linux/random.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/string.h>\n#include <linux/module.h>\n\nstatic int ext2_freeze(struct super_block *sb);\nstatic int ext2_unfreeze(struct super_block *sb);\n\nvoid ext2_error(struct super_block *sb, const char *function,\n\t\tconst char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\tstruct ext2_sb_info *sbi = EXT2_SB(sb);\n\tstruct ext2_super_block *es = sbi->s_es;\n\n\tif (!(sb->s_flags & MS_RDONLY)) {\n\t\tspin_lock(&sbi->s_lock);\n\t\tsbi->s_mount_state |= EXT2_ERROR_FS;\n\t\tes->s_state |= cpu_to_le16(EXT2_ERROR_FS);\n\t\tspin_unlock(&sbi->s_lock);\n\t\text2_sync_super(sb, es, 1);\n\t}\n\n\tva_start(args, fmt);\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\tprintk(KERN_CRIT \"EXT2-fs (%s): error: %s: %pV\\n\",\n\t       sb->s_id, function, &vaf);\n\n\tva_end(args);\n\n\tif (test_opt(sb, ERRORS_PANIC))\n\t\tpanic(\"EXT2-fs: panic from previous error\\n\");\n\tif (test_opt(sb, ERRORS_RO)) {\n\t\text2_msg(sb, KERN_CRIT,\n\t\t\t     \"error: remounting filesystem read-only\");\n\t\tsb->s_flags |= MS_RDONLY;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-EINVAL"
          ],
          "line": 1264
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXT2_BLOCK_SIZE",
          "args": [
            "sb"
          ],
          "line": 1258
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sb_bread",
          "args": [
            "sb",
            "block"
          ],
          "line": 1254
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXT2_BLOCK_SIZE_BITS",
          "args": [
            "sb"
          ],
          "line": 1253
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "gdp->bg_inode_table"
          ],
          "line": 1252
        },
        "resolved": true,
        "details": {
          "function_name": "sle32_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "53-56",
          "snippet": "static inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "EXT2_INODE_SIZE",
          "args": [
            "sb"
          ],
          "line": 1251
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXT2_INODES_PER_GROUP",
          "args": [
            "sb"
          ],
          "line": 1251
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext2_get_group_desc",
          "args": [
            "sb",
            "block_group",
            "NULL"
          ],
          "line": 1245
        },
        "resolved": true,
        "details": {
          "function_name": "ext2_get_group_desc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext2/balloc.c",
          "lines": "39-71",
          "snippet": "struct ext2_group_desc * ext2_get_group_desc(struct super_block * sb,\n\t\t\t\t\t     unsigned int block_group,\n\t\t\t\t\t     struct buffer_head ** bh)\n{\n\tunsigned long group_desc;\n\tunsigned long offset;\n\tstruct ext2_group_desc * desc;\n\tstruct ext2_sb_info *sbi = EXT2_SB(sb);\n\n\tif (block_group >= sbi->s_groups_count) {\n\t\text2_error (sb, \"ext2_get_group_desc\",\n\t\t\t    \"block_group >= groups_count - \"\n\t\t\t    \"block_group = %d, groups_count = %lu\",\n\t\t\t    block_group, sbi->s_groups_count);\n\n\t\treturn NULL;\n\t}\n\n\tgroup_desc = block_group >> EXT2_DESC_PER_BLOCK_BITS(sb);\n\toffset = block_group & (EXT2_DESC_PER_BLOCK(sb) - 1);\n\tif (!sbi->s_group_desc[group_desc]) {\n\t\text2_error (sb, \"ext2_get_group_desc\",\n\t\t\t    \"Group descriptor not loaded - \"\n\t\t\t    \"block_group = %d, group_desc = %lu, desc = %lu\",\n\t\t\t     block_group, group_desc, offset);\n\t\treturn NULL;\n\t}\n\n\tdesc = (struct ext2_group_desc *) sbi->s_group_desc[group_desc]->b_data;\n\tif (bh)\n\t\t*bh = sbi->s_group_desc[group_desc];\n\treturn desc + offset;\n}",
          "includes": [
            "#include <linux/capability.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/quotaops.h>",
            "#include \"ext2.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/capability.h>\n#include <linux/buffer_head.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/quotaops.h>\n#include \"ext2.h\"\n\nstruct ext2_group_desc * ext2_get_group_desc(struct super_block * sb,\n\t\t\t\t\t     unsigned int block_group,\n\t\t\t\t\t     struct buffer_head ** bh)\n{\n\tunsigned long group_desc;\n\tunsigned long offset;\n\tstruct ext2_group_desc * desc;\n\tstruct ext2_sb_info *sbi = EXT2_SB(sb);\n\n\tif (block_group >= sbi->s_groups_count) {\n\t\text2_error (sb, \"ext2_get_group_desc\",\n\t\t\t    \"block_group >= groups_count - \"\n\t\t\t    \"block_group = %d, groups_count = %lu\",\n\t\t\t    block_group, sbi->s_groups_count);\n\n\t\treturn NULL;\n\t}\n\n\tgroup_desc = block_group >> EXT2_DESC_PER_BLOCK_BITS(sb);\n\toffset = block_group & (EXT2_DESC_PER_BLOCK(sb) - 1);\n\tif (!sbi->s_group_desc[group_desc]) {\n\t\text2_error (sb, \"ext2_get_group_desc\",\n\t\t\t    \"Group descriptor not loaded - \"\n\t\t\t    \"block_group = %d, group_desc = %lu, desc = %lu\",\n\t\t\t     block_group, group_desc, offset);\n\t\treturn NULL;\n\t}\n\n\tdesc = (struct ext2_group_desc *) sbi->s_group_desc[group_desc]->b_data;\n\tif (bh)\n\t\t*bh = sbi->s_group_desc[group_desc];\n\treturn desc + offset;\n}"
        }
      },
      {
        "call_info": {
          "callee": "EXT2_INODES_PER_GROUP",
          "args": [
            "sb"
          ],
          "line": 1244
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXT2_SB",
          "args": [
            "sb"
          ],
          "line": 1241
        },
        "resolved": true,
        "details": {
          "function_name": "EXT2_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext2/ext2.h",
          "lines": "164-167",
          "snippet": "static inline struct ext2_sb_info *EXT2_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include <linux/rbtree.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/ext2_fs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern unsigned long ext2_count_free_blocks (struct super_block *);",
            "extern unsigned long ext2_count_dirs (struct super_block *);",
            "extern void ext2_check_blocks_bitmap (struct super_block *);",
            "extern unsigned long ext2_count_free_inodes (struct super_block *);",
            "extern void ext2_check_inodes_bitmap (struct super_block *);",
            "extern struct inode *ext2_iget (struct super_block *, unsigned long);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rbtree.h>\n#include <linux/percpu_counter.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/ext2_fs.h>\n#include <linux/fs.h>\n\nextern unsigned long ext2_count_free_blocks (struct super_block *);\nextern unsigned long ext2_count_dirs (struct super_block *);\nextern void ext2_check_blocks_bitmap (struct super_block *);\nextern unsigned long ext2_count_free_inodes (struct super_block *);\nextern void ext2_check_inodes_bitmap (struct super_block *);\nextern struct inode *ext2_iget (struct super_block *, unsigned long);\n\nstatic inline struct ext2_sb_info *EXT2_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      },
      {
        "call_info": {
          "callee": "EXT2_FIRST_INO",
          "args": [
            "sb"
          ],
          "line": 1240
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xattr.h\"\n#include \"acl.h\"\n#include \"ext2.h\"\n#include <linux/aio.h>\n#include <linux/namei.h>\n#include <linux/fiemap.h>\n#include <linux/mpage.h>\n#include <linux/buffer_head.h>\n#include <linux/writeback.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/highuid.h>\n#include <linux/time.h>\n\nstatic void ext2_truncate_blocks(struct inode *inode, loff_t offset);\n\nstatic struct ext2_inode *ext2_get_inode(struct super_block *sb, ino_t ino,\n\t\t\t\t\tstruct buffer_head **p)\n{\n\tstruct buffer_head * bh;\n\tunsigned long block_group;\n\tunsigned long block;\n\tunsigned long offset;\n\tstruct ext2_group_desc * gdp;\n\n\t*p = NULL;\n\tif ((ino != EXT2_ROOT_INO && ino < EXT2_FIRST_INO(sb)) ||\n\t    ino > le32_to_cpu(EXT2_SB(sb)->s_es->s_inodes_count))\n\t\tgoto Einval;\n\n\tblock_group = (ino - 1) / EXT2_INODES_PER_GROUP(sb);\n\tgdp = ext2_get_group_desc(sb, block_group, NULL);\n\tif (!gdp)\n\t\tgoto Egdp;\n\t/*\n\t * Figure out the offset within the block group inode table\n\t */\n\toffset = ((ino - 1) % EXT2_INODES_PER_GROUP(sb)) * EXT2_INODE_SIZE(sb);\n\tblock = le32_to_cpu(gdp->bg_inode_table) +\n\t\t(offset >> EXT2_BLOCK_SIZE_BITS(sb));\n\tif (!(bh = sb_bread(sb, block)))\n\t\tgoto Eio;\n\n\t*p = bh;\n\toffset &= (EXT2_BLOCK_SIZE(sb) - 1);\n\treturn (struct ext2_inode *) (bh->b_data + offset);\n\nEinval:\n\text2_error(sb, \"ext2_get_inode\", \"bad inode number: %lu\",\n\t\t   (unsigned long) ino);\n\treturn ERR_PTR(-EINVAL);\nEio:\n\text2_error(sb, \"ext2_get_inode\",\n\t\t   \"unable to read inode block - inode=%lu, block=%lu\",\n\t\t   (unsigned long) ino, block);\nEgdp:\n\treturn ERR_PTR(-EIO);\n}"
  },
  {
    "function_name": "ext2_setsize",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext2/inode.c",
    "lines": "1191-1228",
    "snippet": "static int ext2_setsize(struct inode *inode, loff_t newsize)\n{\n\tint error;\n\n\tif (!(S_ISREG(inode->i_mode) || S_ISDIR(inode->i_mode) ||\n\t    S_ISLNK(inode->i_mode)))\n\t\treturn -EINVAL;\n\tif (ext2_inode_is_fast_symlink(inode))\n\t\treturn -EINVAL;\n\tif (IS_APPEND(inode) || IS_IMMUTABLE(inode))\n\t\treturn -EPERM;\n\n\tinode_dio_wait(inode);\n\n\tif (IS_DAX(inode))\n\t\terror = dax_truncate_page(inode, newsize, ext2_get_block);\n\telse if (test_opt(inode->i_sb, NOBH))\n\t\terror = nobh_truncate_page(inode->i_mapping,\n\t\t\t\tnewsize, ext2_get_block);\n\telse\n\t\terror = block_truncate_page(inode->i_mapping,\n\t\t\t\tnewsize, ext2_get_block);\n\tif (error)\n\t\treturn error;\n\n\ttruncate_setsize(inode, newsize);\n\t__ext2_truncate_blocks(inode, newsize);\n\n\tinode->i_mtime = inode->i_ctime = CURRENT_TIME_SEC;\n\tif (inode_needs_sync(inode)) {\n\t\tsync_mapping_buffers(inode->i_mapping);\n\t\tsync_inode_metadata(inode, 1);\n\t} else {\n\t\tmark_inode_dirty(inode);\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include \"xattr.h\"",
      "#include \"acl.h\"",
      "#include \"ext2.h\"",
      "#include <linux/aio.h>",
      "#include <linux/namei.h>",
      "#include <linux/fiemap.h>",
      "#include <linux/mpage.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/writeback.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/highuid.h>",
      "#include <linux/time.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mark_inode_dirty",
          "args": [
            "inode"
          ],
          "line": 1224
        },
        "resolved": true,
        "details": {
          "function_name": "block_dump___mark_inode_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fs-writeback.c",
          "lines": "1134-1154",
          "snippet": "static noinline void block_dump___mark_inode_dirty(struct inode *inode)\n{\n\tif (inode->i_ino || strcmp(inode->i_sb->s_id, \"bdev\")) {\n\t\tstruct dentry *dentry;\n\t\tconst char *name = \"?\";\n\n\t\tdentry = d_find_alias(inode);\n\t\tif (dentry) {\n\t\t\tspin_lock(&dentry->d_lock);\n\t\t\tname = (const char *) dentry->d_name.name;\n\t\t}\n\t\tprintk(KERN_DEBUG\n\t\t       \"%s(%d): dirtied inode %lu (%s) on %s\\n\",\n\t\t       current->comm, task_pid_nr(current), inode->i_ino,\n\t\t       name, inode->i_sb->s_id);\n\t\tif (dentry) {\n\t\t\tspin_unlock(&dentry->d_lock);\n\t\t\tdput(dentry);\n\t\t}\n\t}\n}",
          "includes": [
            "#include <trace/events/writeback.h>",
            "#include \"internal.h\"",
            "#include <linux/device.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/writeback.h>\n#include \"internal.h\"\n#include <linux/device.h>\n#include <linux/tracepoint.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nstatic noinline void block_dump___mark_inode_dirty(struct inode *inode)\n{\n\tif (inode->i_ino || strcmp(inode->i_sb->s_id, \"bdev\")) {\n\t\tstruct dentry *dentry;\n\t\tconst char *name = \"?\";\n\n\t\tdentry = d_find_alias(inode);\n\t\tif (dentry) {\n\t\t\tspin_lock(&dentry->d_lock);\n\t\t\tname = (const char *) dentry->d_name.name;\n\t\t}\n\t\tprintk(KERN_DEBUG\n\t\t       \"%s(%d): dirtied inode %lu (%s) on %s\\n\",\n\t\t       current->comm, task_pid_nr(current), inode->i_ino,\n\t\t       name, inode->i_sb->s_id);\n\t\tif (dentry) {\n\t\t\tspin_unlock(&dentry->d_lock);\n\t\t\tdput(dentry);\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "sync_inode_metadata",
          "args": [
            "inode",
            "1"
          ],
          "line": 1222
        },
        "resolved": true,
        "details": {
          "function_name": "sync_inode_metadata",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fs-writeback.c",
          "lines": "1513-1521",
          "snippet": "int sync_inode_metadata(struct inode *inode, int wait)\n{\n\tstruct writeback_control wbc = {\n\t\t.sync_mode = wait ? WB_SYNC_ALL : WB_SYNC_NONE,\n\t\t.nr_to_write = 0, /* metadata-only */\n\t};\n\n\treturn sync_inode(inode, &wbc);\n}",
          "includes": [
            "#include <trace/events/writeback.h>",
            "#include \"internal.h\"",
            "#include <linux/device.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/writeback.h>\n#include \"internal.h\"\n#include <linux/device.h>\n#include <linux/tracepoint.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nint sync_inode_metadata(struct inode *inode, int wait)\n{\n\tstruct writeback_control wbc = {\n\t\t.sync_mode = wait ? WB_SYNC_ALL : WB_SYNC_NONE,\n\t\t.nr_to_write = 0, /* metadata-only */\n\t};\n\n\treturn sync_inode(inode, &wbc);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sync_mapping_buffers",
          "args": [
            "inode->i_mapping"
          ],
          "line": 1221
        },
        "resolved": true,
        "details": {
          "function_name": "sync_mapping_buffers",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "570-579",
          "snippet": "int sync_mapping_buffers(struct address_space *mapping)\n{\n\tstruct address_space *buffer_mapping = mapping->private_data;\n\n\tif (buffer_mapping == NULL || list_empty(&mapping->private_list))\n\t\treturn 0;\n\n\treturn fsync_buffers_list(&buffer_mapping->private_lock,\n\t\t\t\t\t&mapping->private_list);\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nint sync_mapping_buffers(struct address_space *mapping)\n{\n\tstruct address_space *buffer_mapping = mapping->private_data;\n\n\tif (buffer_mapping == NULL || list_empty(&mapping->private_list))\n\t\treturn 0;\n\n\treturn fsync_buffers_list(&buffer_mapping->private_lock,\n\t\t\t\t\t&mapping->private_list);\n}"
        }
      },
      {
        "call_info": {
          "callee": "inode_needs_sync",
          "args": [
            "inode"
          ],
          "line": 1220
        },
        "resolved": true,
        "details": {
          "function_name": "inode_needs_sync",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "1751-1758",
          "snippet": "int inode_needs_sync(struct inode *inode)\n{\n\tif (IS_SYNC(inode))\n\t\treturn 1;\n\tif (S_ISDIR(inode->i_mode) && IS_DIRSYNC(inode))\n\t\treturn 1;\n\treturn 0;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nint inode_needs_sync(struct inode *inode)\n{\n\tif (IS_SYNC(inode))\n\t\treturn 1;\n\tif (S_ISDIR(inode->i_mode) && IS_DIRSYNC(inode))\n\t\treturn 1;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "__ext2_truncate_blocks",
          "args": [
            "inode",
            "newsize"
          ],
          "line": 1217
        },
        "resolved": true,
        "details": {
          "function_name": "__ext2_truncate_blocks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext2/inode.c",
          "lines": "1088-1169",
          "snippet": "static void __ext2_truncate_blocks(struct inode *inode, loff_t offset)\n{\n\t__le32 *i_data = EXT2_I(inode)->i_data;\n\tstruct ext2_inode_info *ei = EXT2_I(inode);\n\tint addr_per_block = EXT2_ADDR_PER_BLOCK(inode->i_sb);\n\tint offsets[4];\n\tIndirect chain[4];\n\tIndirect *partial;\n\t__le32 nr = 0;\n\tint n;\n\tlong iblock;\n\tunsigned blocksize;\n\tblocksize = inode->i_sb->s_blocksize;\n\tiblock = (offset + blocksize-1) >> EXT2_BLOCK_SIZE_BITS(inode->i_sb);\n\n\tn = ext2_block_to_path(inode, iblock, offsets, NULL);\n\tif (n == 0)\n\t\treturn;\n\n\t/*\n\t * From here we block out all ext2_get_block() callers who want to\n\t * modify the block allocation tree.\n\t */\n\tmutex_lock(&ei->truncate_mutex);\n\n\tif (n == 1) {\n\t\text2_free_data(inode, i_data+offsets[0],\n\t\t\t\t\ti_data + EXT2_NDIR_BLOCKS);\n\t\tgoto do_indirects;\n\t}\n\n\tpartial = ext2_find_shared(inode, n, offsets, chain, &nr);\n\t/* Kill the top of shared branch (already detached) */\n\tif (nr) {\n\t\tif (partial == chain)\n\t\t\tmark_inode_dirty(inode);\n\t\telse\n\t\t\tmark_buffer_dirty_inode(partial->bh, inode);\n\t\text2_free_branches(inode, &nr, &nr+1, (chain+n-1) - partial);\n\t}\n\t/* Clear the ends of indirect blocks on the shared branch */\n\twhile (partial > chain) {\n\t\text2_free_branches(inode,\n\t\t\t\t   partial->p + 1,\n\t\t\t\t   (__le32*)partial->bh->b_data+addr_per_block,\n\t\t\t\t   (chain+n-1) - partial);\n\t\tmark_buffer_dirty_inode(partial->bh, inode);\n\t\tbrelse (partial->bh);\n\t\tpartial--;\n\t}\ndo_indirects:\n\t/* Kill the remaining (whole) subtrees */\n\tswitch (offsets[0]) {\n\t\tdefault:\n\t\t\tnr = i_data[EXT2_IND_BLOCK];\n\t\t\tif (nr) {\n\t\t\t\ti_data[EXT2_IND_BLOCK] = 0;\n\t\t\t\tmark_inode_dirty(inode);\n\t\t\t\text2_free_branches(inode, &nr, &nr+1, 1);\n\t\t\t}\n\t\tcase EXT2_IND_BLOCK:\n\t\t\tnr = i_data[EXT2_DIND_BLOCK];\n\t\t\tif (nr) {\n\t\t\t\ti_data[EXT2_DIND_BLOCK] = 0;\n\t\t\t\tmark_inode_dirty(inode);\n\t\t\t\text2_free_branches(inode, &nr, &nr+1, 2);\n\t\t\t}\n\t\tcase EXT2_DIND_BLOCK:\n\t\t\tnr = i_data[EXT2_TIND_BLOCK];\n\t\t\tif (nr) {\n\t\t\t\ti_data[EXT2_TIND_BLOCK] = 0;\n\t\t\t\tmark_inode_dirty(inode);\n\t\t\t\text2_free_branches(inode, &nr, &nr+1, 3);\n\t\t\t}\n\t\tcase EXT2_TIND_BLOCK:\n\t\t\t;\n\t}\n\n\text2_discard_reservation(inode);\n\n\tmutex_unlock(&ei->truncate_mutex);\n}",
          "includes": [
            "#include \"xattr.h\"",
            "#include \"acl.h\"",
            "#include \"ext2.h\"",
            "#include <linux/aio.h>",
            "#include <linux/namei.h>",
            "#include <linux/fiemap.h>",
            "#include <linux/mpage.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/writeback.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highuid.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void ext2_truncate_blocks(struct inode *inode, loff_t offset);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xattr.h\"\n#include \"acl.h\"\n#include \"ext2.h\"\n#include <linux/aio.h>\n#include <linux/namei.h>\n#include <linux/fiemap.h>\n#include <linux/mpage.h>\n#include <linux/buffer_head.h>\n#include <linux/writeback.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/highuid.h>\n#include <linux/time.h>\n\nstatic void ext2_truncate_blocks(struct inode *inode, loff_t offset);\n\nstatic void __ext2_truncate_blocks(struct inode *inode, loff_t offset)\n{\n\t__le32 *i_data = EXT2_I(inode)->i_data;\n\tstruct ext2_inode_info *ei = EXT2_I(inode);\n\tint addr_per_block = EXT2_ADDR_PER_BLOCK(inode->i_sb);\n\tint offsets[4];\n\tIndirect chain[4];\n\tIndirect *partial;\n\t__le32 nr = 0;\n\tint n;\n\tlong iblock;\n\tunsigned blocksize;\n\tblocksize = inode->i_sb->s_blocksize;\n\tiblock = (offset + blocksize-1) >> EXT2_BLOCK_SIZE_BITS(inode->i_sb);\n\n\tn = ext2_block_to_path(inode, iblock, offsets, NULL);\n\tif (n == 0)\n\t\treturn;\n\n\t/*\n\t * From here we block out all ext2_get_block() callers who want to\n\t * modify the block allocation tree.\n\t */\n\tmutex_lock(&ei->truncate_mutex);\n\n\tif (n == 1) {\n\t\text2_free_data(inode, i_data+offsets[0],\n\t\t\t\t\ti_data + EXT2_NDIR_BLOCKS);\n\t\tgoto do_indirects;\n\t}\n\n\tpartial = ext2_find_shared(inode, n, offsets, chain, &nr);\n\t/* Kill the top of shared branch (already detached) */\n\tif (nr) {\n\t\tif (partial == chain)\n\t\t\tmark_inode_dirty(inode);\n\t\telse\n\t\t\tmark_buffer_dirty_inode(partial->bh, inode);\n\t\text2_free_branches(inode, &nr, &nr+1, (chain+n-1) - partial);\n\t}\n\t/* Clear the ends of indirect blocks on the shared branch */\n\twhile (partial > chain) {\n\t\text2_free_branches(inode,\n\t\t\t\t   partial->p + 1,\n\t\t\t\t   (__le32*)partial->bh->b_data+addr_per_block,\n\t\t\t\t   (chain+n-1) - partial);\n\t\tmark_buffer_dirty_inode(partial->bh, inode);\n\t\tbrelse (partial->bh);\n\t\tpartial--;\n\t}\ndo_indirects:\n\t/* Kill the remaining (whole) subtrees */\n\tswitch (offsets[0]) {\n\t\tdefault:\n\t\t\tnr = i_data[EXT2_IND_BLOCK];\n\t\t\tif (nr) {\n\t\t\t\ti_data[EXT2_IND_BLOCK] = 0;\n\t\t\t\tmark_inode_dirty(inode);\n\t\t\t\text2_free_branches(inode, &nr, &nr+1, 1);\n\t\t\t}\n\t\tcase EXT2_IND_BLOCK:\n\t\t\tnr = i_data[EXT2_DIND_BLOCK];\n\t\t\tif (nr) {\n\t\t\t\ti_data[EXT2_DIND_BLOCK] = 0;\n\t\t\t\tmark_inode_dirty(inode);\n\t\t\t\text2_free_branches(inode, &nr, &nr+1, 2);\n\t\t\t}\n\t\tcase EXT2_DIND_BLOCK:\n\t\t\tnr = i_data[EXT2_TIND_BLOCK];\n\t\t\tif (nr) {\n\t\t\t\ti_data[EXT2_TIND_BLOCK] = 0;\n\t\t\t\tmark_inode_dirty(inode);\n\t\t\t\text2_free_branches(inode, &nr, &nr+1, 3);\n\t\t\t}\n\t\tcase EXT2_TIND_BLOCK:\n\t\t\t;\n\t}\n\n\text2_discard_reservation(inode);\n\n\tmutex_unlock(&ei->truncate_mutex);\n}"
        }
      },
      {
        "call_info": {
          "callee": "truncate_setsize",
          "args": [
            "inode",
            "newsize"
          ],
          "line": 1216
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "block_truncate_page",
          "args": [
            "inode->i_mapping",
            "newsize",
            "ext2_get_block"
          ],
          "line": 1211
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_block_truncate_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/inode.c",
          "lines": "3323-3335",
          "snippet": "static int ext4_block_truncate_page(handle_t *handle,\n\t\tstruct address_space *mapping, loff_t from)\n{\n\tunsigned offset = from & (PAGE_CACHE_SIZE-1);\n\tunsigned length;\n\tunsigned blocksize;\n\tstruct inode *inode = mapping->host;\n\n\tblocksize = inode->i_sb->s_blocksize;\n\tlength = blocksize - (offset & (blocksize - 1));\n\n\treturn ext4_block_zero_page_range(handle, mapping, from, length);\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"truncate.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include <linux/bitops.h>",
            "#include <linux/aio.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/printk.h>",
            "#include <linux/kernel.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/bio.h>",
            "#include <linux/uio.h>",
            "#include <linux/namei.h>",
            "#include <linux/mpage.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highuid.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/time.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void ext4_invalidatepage(struct page *page, unsigned int offset,\n\t\t\t\tunsigned int length);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"truncate.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include <linux/bitops.h>\n#include <linux/aio.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/printk.h>\n#include <linux/kernel.h>\n#include <linux/workqueue.h>\n#include <linux/bio.h>\n#include <linux/uio.h>\n#include <linux/namei.h>\n#include <linux/mpage.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/highuid.h>\n#include <linux/jbd2.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n\nstatic void ext4_invalidatepage(struct page *page, unsigned int offset,\n\t\t\t\tunsigned int length);\n\nstatic int ext4_block_truncate_page(handle_t *handle,\n\t\tstruct address_space *mapping, loff_t from)\n{\n\tunsigned offset = from & (PAGE_CACHE_SIZE-1);\n\tunsigned length;\n\tunsigned blocksize;\n\tstruct inode *inode = mapping->host;\n\n\tblocksize = inode->i_sb->s_blocksize;\n\tlength = blocksize - (offset & (blocksize - 1));\n\n\treturn ext4_block_zero_page_range(handle, mapping, from, length);\n}"
        }
      },
      {
        "call_info": {
          "callee": "nobh_truncate_page",
          "args": [
            "inode->i_mapping",
            "newsize",
            "ext2_get_block"
          ],
          "line": 1208
        },
        "resolved": true,
        "details": {
          "function_name": "nobh_truncate_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "2728-2803",
          "snippet": "int nobh_truncate_page(struct address_space *mapping,\n\t\t\tloff_t from, get_block_t *get_block)\n{\n\tpgoff_t index = from >> PAGE_CACHE_SHIFT;\n\tunsigned offset = from & (PAGE_CACHE_SIZE-1);\n\tunsigned blocksize;\n\tsector_t iblock;\n\tunsigned length, pos;\n\tstruct inode *inode = mapping->host;\n\tstruct page *page;\n\tstruct buffer_head map_bh;\n\tint err;\n\n\tblocksize = 1 << inode->i_blkbits;\n\tlength = offset & (blocksize - 1);\n\n\t/* Block boundary? Nothing to do */\n\tif (!length)\n\t\treturn 0;\n\n\tlength = blocksize - length;\n\tiblock = (sector_t)index << (PAGE_CACHE_SHIFT - inode->i_blkbits);\n\n\tpage = grab_cache_page(mapping, index);\n\terr = -ENOMEM;\n\tif (!page)\n\t\tgoto out;\n\n\tif (page_has_buffers(page)) {\nhas_buffers:\n\t\tunlock_page(page);\n\t\tpage_cache_release(page);\n\t\treturn block_truncate_page(mapping, from, get_block);\n\t}\n\n\t/* Find the buffer that contains \"offset\" */\n\tpos = blocksize;\n\twhile (offset >= pos) {\n\t\tiblock++;\n\t\tpos += blocksize;\n\t}\n\n\tmap_bh.b_size = blocksize;\n\tmap_bh.b_state = 0;\n\terr = get_block(inode, iblock, &map_bh, 0);\n\tif (err)\n\t\tgoto unlock;\n\t/* unmapped? It's a hole - nothing to do */\n\tif (!buffer_mapped(&map_bh))\n\t\tgoto unlock;\n\n\t/* Ok, it's mapped. Make sure it's up-to-date */\n\tif (!PageUptodate(page)) {\n\t\terr = mapping->a_ops->readpage(NULL, page);\n\t\tif (err) {\n\t\t\tpage_cache_release(page);\n\t\t\tgoto out;\n\t\t}\n\t\tlock_page(page);\n\t\tif (!PageUptodate(page)) {\n\t\t\terr = -EIO;\n\t\t\tgoto unlock;\n\t\t}\n\t\tif (page_has_buffers(page))\n\t\t\tgoto has_buffers;\n\t}\n\tzero_user(page, offset, length);\n\tset_page_dirty(page);\n\terr = 0;\n\nunlock:\n\tunlock_page(page);\n\tpage_cache_release(page);\nout:\n\treturn err;\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nint nobh_truncate_page(struct address_space *mapping,\n\t\t\tloff_t from, get_block_t *get_block)\n{\n\tpgoff_t index = from >> PAGE_CACHE_SHIFT;\n\tunsigned offset = from & (PAGE_CACHE_SIZE-1);\n\tunsigned blocksize;\n\tsector_t iblock;\n\tunsigned length, pos;\n\tstruct inode *inode = mapping->host;\n\tstruct page *page;\n\tstruct buffer_head map_bh;\n\tint err;\n\n\tblocksize = 1 << inode->i_blkbits;\n\tlength = offset & (blocksize - 1);\n\n\t/* Block boundary? Nothing to do */\n\tif (!length)\n\t\treturn 0;\n\n\tlength = blocksize - length;\n\tiblock = (sector_t)index << (PAGE_CACHE_SHIFT - inode->i_blkbits);\n\n\tpage = grab_cache_page(mapping, index);\n\terr = -ENOMEM;\n\tif (!page)\n\t\tgoto out;\n\n\tif (page_has_buffers(page)) {\nhas_buffers:\n\t\tunlock_page(page);\n\t\tpage_cache_release(page);\n\t\treturn block_truncate_page(mapping, from, get_block);\n\t}\n\n\t/* Find the buffer that contains \"offset\" */\n\tpos = blocksize;\n\twhile (offset >= pos) {\n\t\tiblock++;\n\t\tpos += blocksize;\n\t}\n\n\tmap_bh.b_size = blocksize;\n\tmap_bh.b_state = 0;\n\terr = get_block(inode, iblock, &map_bh, 0);\n\tif (err)\n\t\tgoto unlock;\n\t/* unmapped? It's a hole - nothing to do */\n\tif (!buffer_mapped(&map_bh))\n\t\tgoto unlock;\n\n\t/* Ok, it's mapped. Make sure it's up-to-date */\n\tif (!PageUptodate(page)) {\n\t\terr = mapping->a_ops->readpage(NULL, page);\n\t\tif (err) {\n\t\t\tpage_cache_release(page);\n\t\t\tgoto out;\n\t\t}\n\t\tlock_page(page);\n\t\tif (!PageUptodate(page)) {\n\t\t\terr = -EIO;\n\t\t\tgoto unlock;\n\t\t}\n\t\tif (page_has_buffers(page))\n\t\t\tgoto has_buffers;\n\t}\n\tzero_user(page, offset, length);\n\tset_page_dirty(page);\n\terr = 0;\n\nunlock:\n\tunlock_page(page);\n\tpage_cache_release(page);\nout:\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "test_opt",
          "args": [
            "inode->i_sb",
            "NOBH"
          ],
          "line": 1207
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dax_truncate_page",
          "args": [
            "inode",
            "newsize",
            "ext2_get_block"
          ],
          "line": 1206
        },
        "resolved": true,
        "details": {
          "function_name": "dax_truncate_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dax.c",
          "lines": "529-533",
          "snippet": "int dax_truncate_page(struct inode *inode, loff_t from, get_block_t get_block)\n{\n\tunsigned length = PAGE_CACHE_ALIGN(from) - from;\n\treturn dax_zero_page_range(inode, from, length, get_block);\n}",
          "includes": [
            "#include <linux/vmstat.h>",
            "#include <linux/uio.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>",
            "#include <linux/mm.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/highmem.h>",
            "#include <linux/genhd.h>",
            "#include <linux/fs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/atomic.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/vmstat.h>\n#include <linux/uio.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n#include <linux/mm.h>\n#include <linux/memcontrol.h>\n#include <linux/highmem.h>\n#include <linux/genhd.h>\n#include <linux/fs.h>\n#include <linux/buffer_head.h>\n#include <linux/blkdev.h>\n#include <linux/atomic.h>\n\nint dax_truncate_page(struct inode *inode, loff_t from, get_block_t get_block)\n{\n\tunsigned length = PAGE_CACHE_ALIGN(from) - from;\n\treturn dax_zero_page_range(inode, from, length, get_block);\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_DAX",
          "args": [
            "inode"
          ],
          "line": 1205
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "inode_dio_wait",
          "args": [
            "inode"
          ],
          "line": 1203
        },
        "resolved": true,
        "details": {
          "function_name": "inode_dio_wait",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "1941-1945",
          "snippet": "void inode_dio_wait(struct inode *inode)\n{\n\tif (atomic_read(&inode->i_dio_count))\n\t\t__inode_dio_wait(inode);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid inode_dio_wait(struct inode *inode)\n{\n\tif (atomic_read(&inode->i_dio_count))\n\t\t__inode_dio_wait(inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_IMMUTABLE",
          "args": [
            "inode"
          ],
          "line": 1200
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_APPEND",
          "args": [
            "inode"
          ],
          "line": 1200
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext2_inode_is_fast_symlink",
          "args": [
            "inode"
          ],
          "line": 1198
        },
        "resolved": true,
        "details": {
          "function_name": "ext2_inode_is_fast_symlink",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext2/inode.c",
          "lines": "44-51",
          "snippet": "static inline int ext2_inode_is_fast_symlink(struct inode *inode)\n{\n\tint ea_blocks = EXT2_I(inode)->i_file_acl ?\n\t\t(inode->i_sb->s_blocksize >> 9) : 0;\n\n\treturn (S_ISLNK(inode->i_mode) &&\n\t\tinode->i_blocks - ea_blocks == 0);\n}",
          "includes": [
            "#include \"xattr.h\"",
            "#include \"acl.h\"",
            "#include \"ext2.h\"",
            "#include <linux/aio.h>",
            "#include <linux/namei.h>",
            "#include <linux/fiemap.h>",
            "#include <linux/mpage.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/writeback.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highuid.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xattr.h\"\n#include \"acl.h\"\n#include \"ext2.h\"\n#include <linux/aio.h>\n#include <linux/namei.h>\n#include <linux/fiemap.h>\n#include <linux/mpage.h>\n#include <linux/buffer_head.h>\n#include <linux/writeback.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/highuid.h>\n#include <linux/time.h>\n\nstatic inline int ext2_inode_is_fast_symlink(struct inode *inode)\n{\n\tint ea_blocks = EXT2_I(inode)->i_file_acl ?\n\t\t(inode->i_sb->s_blocksize >> 9) : 0;\n\n\treturn (S_ISLNK(inode->i_mode) &&\n\t\tinode->i_blocks - ea_blocks == 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "S_ISLNK",
          "args": [
            "inode->i_mode"
          ],
          "line": 1196
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISDIR",
          "args": [
            "inode->i_mode"
          ],
          "line": 1195
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISREG",
          "args": [
            "inode->i_mode"
          ],
          "line": 1195
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xattr.h\"\n#include \"acl.h\"\n#include \"ext2.h\"\n#include <linux/aio.h>\n#include <linux/namei.h>\n#include <linux/fiemap.h>\n#include <linux/mpage.h>\n#include <linux/buffer_head.h>\n#include <linux/writeback.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/highuid.h>\n#include <linux/time.h>\n\nstatic int ext2_setsize(struct inode *inode, loff_t newsize)\n{\n\tint error;\n\n\tif (!(S_ISREG(inode->i_mode) || S_ISDIR(inode->i_mode) ||\n\t    S_ISLNK(inode->i_mode)))\n\t\treturn -EINVAL;\n\tif (ext2_inode_is_fast_symlink(inode))\n\t\treturn -EINVAL;\n\tif (IS_APPEND(inode) || IS_IMMUTABLE(inode))\n\t\treturn -EPERM;\n\n\tinode_dio_wait(inode);\n\n\tif (IS_DAX(inode))\n\t\terror = dax_truncate_page(inode, newsize, ext2_get_block);\n\telse if (test_opt(inode->i_sb, NOBH))\n\t\terror = nobh_truncate_page(inode->i_mapping,\n\t\t\t\tnewsize, ext2_get_block);\n\telse\n\t\terror = block_truncate_page(inode->i_mapping,\n\t\t\t\tnewsize, ext2_get_block);\n\tif (error)\n\t\treturn error;\n\n\ttruncate_setsize(inode, newsize);\n\t__ext2_truncate_blocks(inode, newsize);\n\n\tinode->i_mtime = inode->i_ctime = CURRENT_TIME_SEC;\n\tif (inode_needs_sync(inode)) {\n\t\tsync_mapping_buffers(inode->i_mapping);\n\t\tsync_inode_metadata(inode, 1);\n\t} else {\n\t\tmark_inode_dirty(inode);\n\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "ext2_truncate_blocks",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext2/inode.c",
    "lines": "1171-1189",
    "snippet": "static void ext2_truncate_blocks(struct inode *inode, loff_t offset)\n{\n\t/*\n\t * XXX: it seems like a bug here that we don't allow\n\t * IS_APPEND inode to have blocks-past-i_size trimmed off.\n\t * review and fix this.\n\t *\n\t * Also would be nice to be able to handle IO errors and such,\n\t * but that's probably too much to ask.\n\t */\n\tif (!(S_ISREG(inode->i_mode) || S_ISDIR(inode->i_mode) ||\n\t    S_ISLNK(inode->i_mode)))\n\t\treturn;\n\tif (ext2_inode_is_fast_symlink(inode))\n\t\treturn;\n\tif (IS_APPEND(inode) || IS_IMMUTABLE(inode))\n\t\treturn;\n\t__ext2_truncate_blocks(inode, offset);\n}",
    "includes": [
      "#include \"xattr.h\"",
      "#include \"acl.h\"",
      "#include \"ext2.h\"",
      "#include <linux/aio.h>",
      "#include <linux/namei.h>",
      "#include <linux/fiemap.h>",
      "#include <linux/mpage.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/writeback.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/highuid.h>",
      "#include <linux/time.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void ext2_truncate_blocks(struct inode *inode, loff_t offset);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "__ext2_truncate_blocks",
          "args": [
            "inode",
            "offset"
          ],
          "line": 1188
        },
        "resolved": true,
        "details": {
          "function_name": "__ext2_truncate_blocks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext2/inode.c",
          "lines": "1088-1169",
          "snippet": "static void __ext2_truncate_blocks(struct inode *inode, loff_t offset)\n{\n\t__le32 *i_data = EXT2_I(inode)->i_data;\n\tstruct ext2_inode_info *ei = EXT2_I(inode);\n\tint addr_per_block = EXT2_ADDR_PER_BLOCK(inode->i_sb);\n\tint offsets[4];\n\tIndirect chain[4];\n\tIndirect *partial;\n\t__le32 nr = 0;\n\tint n;\n\tlong iblock;\n\tunsigned blocksize;\n\tblocksize = inode->i_sb->s_blocksize;\n\tiblock = (offset + blocksize-1) >> EXT2_BLOCK_SIZE_BITS(inode->i_sb);\n\n\tn = ext2_block_to_path(inode, iblock, offsets, NULL);\n\tif (n == 0)\n\t\treturn;\n\n\t/*\n\t * From here we block out all ext2_get_block() callers who want to\n\t * modify the block allocation tree.\n\t */\n\tmutex_lock(&ei->truncate_mutex);\n\n\tif (n == 1) {\n\t\text2_free_data(inode, i_data+offsets[0],\n\t\t\t\t\ti_data + EXT2_NDIR_BLOCKS);\n\t\tgoto do_indirects;\n\t}\n\n\tpartial = ext2_find_shared(inode, n, offsets, chain, &nr);\n\t/* Kill the top of shared branch (already detached) */\n\tif (nr) {\n\t\tif (partial == chain)\n\t\t\tmark_inode_dirty(inode);\n\t\telse\n\t\t\tmark_buffer_dirty_inode(partial->bh, inode);\n\t\text2_free_branches(inode, &nr, &nr+1, (chain+n-1) - partial);\n\t}\n\t/* Clear the ends of indirect blocks on the shared branch */\n\twhile (partial > chain) {\n\t\text2_free_branches(inode,\n\t\t\t\t   partial->p + 1,\n\t\t\t\t   (__le32*)partial->bh->b_data+addr_per_block,\n\t\t\t\t   (chain+n-1) - partial);\n\t\tmark_buffer_dirty_inode(partial->bh, inode);\n\t\tbrelse (partial->bh);\n\t\tpartial--;\n\t}\ndo_indirects:\n\t/* Kill the remaining (whole) subtrees */\n\tswitch (offsets[0]) {\n\t\tdefault:\n\t\t\tnr = i_data[EXT2_IND_BLOCK];\n\t\t\tif (nr) {\n\t\t\t\ti_data[EXT2_IND_BLOCK] = 0;\n\t\t\t\tmark_inode_dirty(inode);\n\t\t\t\text2_free_branches(inode, &nr, &nr+1, 1);\n\t\t\t}\n\t\tcase EXT2_IND_BLOCK:\n\t\t\tnr = i_data[EXT2_DIND_BLOCK];\n\t\t\tif (nr) {\n\t\t\t\ti_data[EXT2_DIND_BLOCK] = 0;\n\t\t\t\tmark_inode_dirty(inode);\n\t\t\t\text2_free_branches(inode, &nr, &nr+1, 2);\n\t\t\t}\n\t\tcase EXT2_DIND_BLOCK:\n\t\t\tnr = i_data[EXT2_TIND_BLOCK];\n\t\t\tif (nr) {\n\t\t\t\ti_data[EXT2_TIND_BLOCK] = 0;\n\t\t\t\tmark_inode_dirty(inode);\n\t\t\t\text2_free_branches(inode, &nr, &nr+1, 3);\n\t\t\t}\n\t\tcase EXT2_TIND_BLOCK:\n\t\t\t;\n\t}\n\n\text2_discard_reservation(inode);\n\n\tmutex_unlock(&ei->truncate_mutex);\n}",
          "includes": [
            "#include \"xattr.h\"",
            "#include \"acl.h\"",
            "#include \"ext2.h\"",
            "#include <linux/aio.h>",
            "#include <linux/namei.h>",
            "#include <linux/fiemap.h>",
            "#include <linux/mpage.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/writeback.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highuid.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void ext2_truncate_blocks(struct inode *inode, loff_t offset);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xattr.h\"\n#include \"acl.h\"\n#include \"ext2.h\"\n#include <linux/aio.h>\n#include <linux/namei.h>\n#include <linux/fiemap.h>\n#include <linux/mpage.h>\n#include <linux/buffer_head.h>\n#include <linux/writeback.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/highuid.h>\n#include <linux/time.h>\n\nstatic void ext2_truncate_blocks(struct inode *inode, loff_t offset);\n\nstatic void __ext2_truncate_blocks(struct inode *inode, loff_t offset)\n{\n\t__le32 *i_data = EXT2_I(inode)->i_data;\n\tstruct ext2_inode_info *ei = EXT2_I(inode);\n\tint addr_per_block = EXT2_ADDR_PER_BLOCK(inode->i_sb);\n\tint offsets[4];\n\tIndirect chain[4];\n\tIndirect *partial;\n\t__le32 nr = 0;\n\tint n;\n\tlong iblock;\n\tunsigned blocksize;\n\tblocksize = inode->i_sb->s_blocksize;\n\tiblock = (offset + blocksize-1) >> EXT2_BLOCK_SIZE_BITS(inode->i_sb);\n\n\tn = ext2_block_to_path(inode, iblock, offsets, NULL);\n\tif (n == 0)\n\t\treturn;\n\n\t/*\n\t * From here we block out all ext2_get_block() callers who want to\n\t * modify the block allocation tree.\n\t */\n\tmutex_lock(&ei->truncate_mutex);\n\n\tif (n == 1) {\n\t\text2_free_data(inode, i_data+offsets[0],\n\t\t\t\t\ti_data + EXT2_NDIR_BLOCKS);\n\t\tgoto do_indirects;\n\t}\n\n\tpartial = ext2_find_shared(inode, n, offsets, chain, &nr);\n\t/* Kill the top of shared branch (already detached) */\n\tif (nr) {\n\t\tif (partial == chain)\n\t\t\tmark_inode_dirty(inode);\n\t\telse\n\t\t\tmark_buffer_dirty_inode(partial->bh, inode);\n\t\text2_free_branches(inode, &nr, &nr+1, (chain+n-1) - partial);\n\t}\n\t/* Clear the ends of indirect blocks on the shared branch */\n\twhile (partial > chain) {\n\t\text2_free_branches(inode,\n\t\t\t\t   partial->p + 1,\n\t\t\t\t   (__le32*)partial->bh->b_data+addr_per_block,\n\t\t\t\t   (chain+n-1) - partial);\n\t\tmark_buffer_dirty_inode(partial->bh, inode);\n\t\tbrelse (partial->bh);\n\t\tpartial--;\n\t}\ndo_indirects:\n\t/* Kill the remaining (whole) subtrees */\n\tswitch (offsets[0]) {\n\t\tdefault:\n\t\t\tnr = i_data[EXT2_IND_BLOCK];\n\t\t\tif (nr) {\n\t\t\t\ti_data[EXT2_IND_BLOCK] = 0;\n\t\t\t\tmark_inode_dirty(inode);\n\t\t\t\text2_free_branches(inode, &nr, &nr+1, 1);\n\t\t\t}\n\t\tcase EXT2_IND_BLOCK:\n\t\t\tnr = i_data[EXT2_DIND_BLOCK];\n\t\t\tif (nr) {\n\t\t\t\ti_data[EXT2_DIND_BLOCK] = 0;\n\t\t\t\tmark_inode_dirty(inode);\n\t\t\t\text2_free_branches(inode, &nr, &nr+1, 2);\n\t\t\t}\n\t\tcase EXT2_DIND_BLOCK:\n\t\t\tnr = i_data[EXT2_TIND_BLOCK];\n\t\t\tif (nr) {\n\t\t\t\ti_data[EXT2_TIND_BLOCK] = 0;\n\t\t\t\tmark_inode_dirty(inode);\n\t\t\t\text2_free_branches(inode, &nr, &nr+1, 3);\n\t\t\t}\n\t\tcase EXT2_TIND_BLOCK:\n\t\t\t;\n\t}\n\n\text2_discard_reservation(inode);\n\n\tmutex_unlock(&ei->truncate_mutex);\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_IMMUTABLE",
          "args": [
            "inode"
          ],
          "line": 1186
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_APPEND",
          "args": [
            "inode"
          ],
          "line": 1186
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext2_inode_is_fast_symlink",
          "args": [
            "inode"
          ],
          "line": 1184
        },
        "resolved": true,
        "details": {
          "function_name": "ext2_inode_is_fast_symlink",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext2/inode.c",
          "lines": "44-51",
          "snippet": "static inline int ext2_inode_is_fast_symlink(struct inode *inode)\n{\n\tint ea_blocks = EXT2_I(inode)->i_file_acl ?\n\t\t(inode->i_sb->s_blocksize >> 9) : 0;\n\n\treturn (S_ISLNK(inode->i_mode) &&\n\t\tinode->i_blocks - ea_blocks == 0);\n}",
          "includes": [
            "#include \"xattr.h\"",
            "#include \"acl.h\"",
            "#include \"ext2.h\"",
            "#include <linux/aio.h>",
            "#include <linux/namei.h>",
            "#include <linux/fiemap.h>",
            "#include <linux/mpage.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/writeback.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highuid.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xattr.h\"\n#include \"acl.h\"\n#include \"ext2.h\"\n#include <linux/aio.h>\n#include <linux/namei.h>\n#include <linux/fiemap.h>\n#include <linux/mpage.h>\n#include <linux/buffer_head.h>\n#include <linux/writeback.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/highuid.h>\n#include <linux/time.h>\n\nstatic inline int ext2_inode_is_fast_symlink(struct inode *inode)\n{\n\tint ea_blocks = EXT2_I(inode)->i_file_acl ?\n\t\t(inode->i_sb->s_blocksize >> 9) : 0;\n\n\treturn (S_ISLNK(inode->i_mode) &&\n\t\tinode->i_blocks - ea_blocks == 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "S_ISLNK",
          "args": [
            "inode->i_mode"
          ],
          "line": 1182
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISDIR",
          "args": [
            "inode->i_mode"
          ],
          "line": 1181
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISREG",
          "args": [
            "inode->i_mode"
          ],
          "line": 1181
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xattr.h\"\n#include \"acl.h\"\n#include \"ext2.h\"\n#include <linux/aio.h>\n#include <linux/namei.h>\n#include <linux/fiemap.h>\n#include <linux/mpage.h>\n#include <linux/buffer_head.h>\n#include <linux/writeback.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/highuid.h>\n#include <linux/time.h>\n\nstatic void ext2_truncate_blocks(struct inode *inode, loff_t offset);\n\nstatic void ext2_truncate_blocks(struct inode *inode, loff_t offset)\n{\n\t/*\n\t * XXX: it seems like a bug here that we don't allow\n\t * IS_APPEND inode to have blocks-past-i_size trimmed off.\n\t * review and fix this.\n\t *\n\t * Also would be nice to be able to handle IO errors and such,\n\t * but that's probably too much to ask.\n\t */\n\tif (!(S_ISREG(inode->i_mode) || S_ISDIR(inode->i_mode) ||\n\t    S_ISLNK(inode->i_mode)))\n\t\treturn;\n\tif (ext2_inode_is_fast_symlink(inode))\n\t\treturn;\n\tif (IS_APPEND(inode) || IS_IMMUTABLE(inode))\n\t\treturn;\n\t__ext2_truncate_blocks(inode, offset);\n}"
  },
  {
    "function_name": "__ext2_truncate_blocks",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext2/inode.c",
    "lines": "1088-1169",
    "snippet": "static void __ext2_truncate_blocks(struct inode *inode, loff_t offset)\n{\n\t__le32 *i_data = EXT2_I(inode)->i_data;\n\tstruct ext2_inode_info *ei = EXT2_I(inode);\n\tint addr_per_block = EXT2_ADDR_PER_BLOCK(inode->i_sb);\n\tint offsets[4];\n\tIndirect chain[4];\n\tIndirect *partial;\n\t__le32 nr = 0;\n\tint n;\n\tlong iblock;\n\tunsigned blocksize;\n\tblocksize = inode->i_sb->s_blocksize;\n\tiblock = (offset + blocksize-1) >> EXT2_BLOCK_SIZE_BITS(inode->i_sb);\n\n\tn = ext2_block_to_path(inode, iblock, offsets, NULL);\n\tif (n == 0)\n\t\treturn;\n\n\t/*\n\t * From here we block out all ext2_get_block() callers who want to\n\t * modify the block allocation tree.\n\t */\n\tmutex_lock(&ei->truncate_mutex);\n\n\tif (n == 1) {\n\t\text2_free_data(inode, i_data+offsets[0],\n\t\t\t\t\ti_data + EXT2_NDIR_BLOCKS);\n\t\tgoto do_indirects;\n\t}\n\n\tpartial = ext2_find_shared(inode, n, offsets, chain, &nr);\n\t/* Kill the top of shared branch (already detached) */\n\tif (nr) {\n\t\tif (partial == chain)\n\t\t\tmark_inode_dirty(inode);\n\t\telse\n\t\t\tmark_buffer_dirty_inode(partial->bh, inode);\n\t\text2_free_branches(inode, &nr, &nr+1, (chain+n-1) - partial);\n\t}\n\t/* Clear the ends of indirect blocks on the shared branch */\n\twhile (partial > chain) {\n\t\text2_free_branches(inode,\n\t\t\t\t   partial->p + 1,\n\t\t\t\t   (__le32*)partial->bh->b_data+addr_per_block,\n\t\t\t\t   (chain+n-1) - partial);\n\t\tmark_buffer_dirty_inode(partial->bh, inode);\n\t\tbrelse (partial->bh);\n\t\tpartial--;\n\t}\ndo_indirects:\n\t/* Kill the remaining (whole) subtrees */\n\tswitch (offsets[0]) {\n\t\tdefault:\n\t\t\tnr = i_data[EXT2_IND_BLOCK];\n\t\t\tif (nr) {\n\t\t\t\ti_data[EXT2_IND_BLOCK] = 0;\n\t\t\t\tmark_inode_dirty(inode);\n\t\t\t\text2_free_branches(inode, &nr, &nr+1, 1);\n\t\t\t}\n\t\tcase EXT2_IND_BLOCK:\n\t\t\tnr = i_data[EXT2_DIND_BLOCK];\n\t\t\tif (nr) {\n\t\t\t\ti_data[EXT2_DIND_BLOCK] = 0;\n\t\t\t\tmark_inode_dirty(inode);\n\t\t\t\text2_free_branches(inode, &nr, &nr+1, 2);\n\t\t\t}\n\t\tcase EXT2_DIND_BLOCK:\n\t\t\tnr = i_data[EXT2_TIND_BLOCK];\n\t\t\tif (nr) {\n\t\t\t\ti_data[EXT2_TIND_BLOCK] = 0;\n\t\t\t\tmark_inode_dirty(inode);\n\t\t\t\text2_free_branches(inode, &nr, &nr+1, 3);\n\t\t\t}\n\t\tcase EXT2_TIND_BLOCK:\n\t\t\t;\n\t}\n\n\text2_discard_reservation(inode);\n\n\tmutex_unlock(&ei->truncate_mutex);\n}",
    "includes": [
      "#include \"xattr.h\"",
      "#include \"acl.h\"",
      "#include \"ext2.h\"",
      "#include <linux/aio.h>",
      "#include <linux/namei.h>",
      "#include <linux/fiemap.h>",
      "#include <linux/mpage.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/writeback.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/highuid.h>",
      "#include <linux/time.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void ext2_truncate_blocks(struct inode *inode, loff_t offset);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&ei->truncate_mutex"
          ],
          "line": 1168
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext2_discard_reservation",
          "args": [
            "inode"
          ],
          "line": 1166
        },
        "resolved": true,
        "details": {
          "function_name": "ext2_discard_reservation",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext2/balloc.c",
          "lines": "451-468",
          "snippet": "void ext2_discard_reservation(struct inode *inode)\n{\n\tstruct ext2_inode_info *ei = EXT2_I(inode);\n\tstruct ext2_block_alloc_info *block_i = ei->i_block_alloc_info;\n\tstruct ext2_reserve_window_node *rsv;\n\tspinlock_t *rsv_lock = &EXT2_SB(inode->i_sb)->s_rsv_window_lock;\n\n\tif (!block_i)\n\t\treturn;\n\n\trsv = &block_i->rsv_window_node;\n\tif (!rsv_is_empty(&rsv->rsv_window)) {\n\t\tspin_lock(rsv_lock);\n\t\tif (!rsv_is_empty(&rsv->rsv_window))\n\t\t\trsv_window_remove(inode->i_sb, rsv);\n\t\tspin_unlock(rsv_lock);\n\t}\n}",
          "includes": [
            "#include <linux/capability.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/quotaops.h>",
            "#include \"ext2.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/capability.h>\n#include <linux/buffer_head.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/quotaops.h>\n#include \"ext2.h\"\n\nvoid ext2_discard_reservation(struct inode *inode)\n{\n\tstruct ext2_inode_info *ei = EXT2_I(inode);\n\tstruct ext2_block_alloc_info *block_i = ei->i_block_alloc_info;\n\tstruct ext2_reserve_window_node *rsv;\n\tspinlock_t *rsv_lock = &EXT2_SB(inode->i_sb)->s_rsv_window_lock;\n\n\tif (!block_i)\n\t\treturn;\n\n\trsv = &block_i->rsv_window_node;\n\tif (!rsv_is_empty(&rsv->rsv_window)) {\n\t\tspin_lock(rsv_lock);\n\t\tif (!rsv_is_empty(&rsv->rsv_window))\n\t\t\trsv_window_remove(inode->i_sb, rsv);\n\t\tspin_unlock(rsv_lock);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext2_free_branches",
          "args": [
            "inode",
            "&nr",
            "&nr+1",
            "3"
          ],
          "line": 1160
        },
        "resolved": true,
        "details": {
          "function_name": "ext2_free_branches",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext2/inode.c",
          "lines": "1053-1086",
          "snippet": "static void ext2_free_branches(struct inode *inode, __le32 *p, __le32 *q, int depth)\n{\n\tstruct buffer_head * bh;\n\tunsigned long nr;\n\n\tif (depth--) {\n\t\tint addr_per_block = EXT2_ADDR_PER_BLOCK(inode->i_sb);\n\t\tfor ( ; p < q ; p++) {\n\t\t\tnr = le32_to_cpu(*p);\n\t\t\tif (!nr)\n\t\t\t\tcontinue;\n\t\t\t*p = 0;\n\t\t\tbh = sb_bread(inode->i_sb, nr);\n\t\t\t/*\n\t\t\t * A read failure? Report error and clear slot\n\t\t\t * (should be rare).\n\t\t\t */ \n\t\t\tif (!bh) {\n\t\t\t\text2_error(inode->i_sb, \"ext2_free_branches\",\n\t\t\t\t\t\"Read failure, inode=%ld, block=%ld\",\n\t\t\t\t\tinode->i_ino, nr);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\text2_free_branches(inode,\n\t\t\t\t\t   (__le32*)bh->b_data,\n\t\t\t\t\t   (__le32*)bh->b_data + addr_per_block,\n\t\t\t\t\t   depth);\n\t\t\tbforget(bh);\n\t\t\text2_free_blocks(inode, nr, 1);\n\t\t\tmark_inode_dirty(inode);\n\t\t}\n\t} else\n\t\text2_free_data(inode, p, q);\n}",
          "includes": [
            "#include \"xattr.h\"",
            "#include \"acl.h\"",
            "#include \"ext2.h\"",
            "#include <linux/aio.h>",
            "#include <linux/namei.h>",
            "#include <linux/fiemap.h>",
            "#include <linux/mpage.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/writeback.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highuid.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xattr.h\"\n#include \"acl.h\"\n#include \"ext2.h\"\n#include <linux/aio.h>\n#include <linux/namei.h>\n#include <linux/fiemap.h>\n#include <linux/mpage.h>\n#include <linux/buffer_head.h>\n#include <linux/writeback.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/highuid.h>\n#include <linux/time.h>\n\nstatic void ext2_free_branches(struct inode *inode, __le32 *p, __le32 *q, int depth)\n{\n\tstruct buffer_head * bh;\n\tunsigned long nr;\n\n\tif (depth--) {\n\t\tint addr_per_block = EXT2_ADDR_PER_BLOCK(inode->i_sb);\n\t\tfor ( ; p < q ; p++) {\n\t\t\tnr = le32_to_cpu(*p);\n\t\t\tif (!nr)\n\t\t\t\tcontinue;\n\t\t\t*p = 0;\n\t\t\tbh = sb_bread(inode->i_sb, nr);\n\t\t\t/*\n\t\t\t * A read failure? Report error and clear slot\n\t\t\t * (should be rare).\n\t\t\t */ \n\t\t\tif (!bh) {\n\t\t\t\text2_error(inode->i_sb, \"ext2_free_branches\",\n\t\t\t\t\t\"Read failure, inode=%ld, block=%ld\",\n\t\t\t\t\tinode->i_ino, nr);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\text2_free_branches(inode,\n\t\t\t\t\t   (__le32*)bh->b_data,\n\t\t\t\t\t   (__le32*)bh->b_data + addr_per_block,\n\t\t\t\t\t   depth);\n\t\t\tbforget(bh);\n\t\t\text2_free_blocks(inode, nr, 1);\n\t\t\tmark_inode_dirty(inode);\n\t\t}\n\t} else\n\t\text2_free_data(inode, p, q);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mark_inode_dirty",
          "args": [
            "inode"
          ],
          "line": 1159
        },
        "resolved": true,
        "details": {
          "function_name": "block_dump___mark_inode_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fs-writeback.c",
          "lines": "1134-1154",
          "snippet": "static noinline void block_dump___mark_inode_dirty(struct inode *inode)\n{\n\tif (inode->i_ino || strcmp(inode->i_sb->s_id, \"bdev\")) {\n\t\tstruct dentry *dentry;\n\t\tconst char *name = \"?\";\n\n\t\tdentry = d_find_alias(inode);\n\t\tif (dentry) {\n\t\t\tspin_lock(&dentry->d_lock);\n\t\t\tname = (const char *) dentry->d_name.name;\n\t\t}\n\t\tprintk(KERN_DEBUG\n\t\t       \"%s(%d): dirtied inode %lu (%s) on %s\\n\",\n\t\t       current->comm, task_pid_nr(current), inode->i_ino,\n\t\t       name, inode->i_sb->s_id);\n\t\tif (dentry) {\n\t\t\tspin_unlock(&dentry->d_lock);\n\t\t\tdput(dentry);\n\t\t}\n\t}\n}",
          "includes": [
            "#include <trace/events/writeback.h>",
            "#include \"internal.h\"",
            "#include <linux/device.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/writeback.h>\n#include \"internal.h\"\n#include <linux/device.h>\n#include <linux/tracepoint.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nstatic noinline void block_dump___mark_inode_dirty(struct inode *inode)\n{\n\tif (inode->i_ino || strcmp(inode->i_sb->s_id, \"bdev\")) {\n\t\tstruct dentry *dentry;\n\t\tconst char *name = \"?\";\n\n\t\tdentry = d_find_alias(inode);\n\t\tif (dentry) {\n\t\t\tspin_lock(&dentry->d_lock);\n\t\t\tname = (const char *) dentry->d_name.name;\n\t\t}\n\t\tprintk(KERN_DEBUG\n\t\t       \"%s(%d): dirtied inode %lu (%s) on %s\\n\",\n\t\t       current->comm, task_pid_nr(current), inode->i_ino,\n\t\t       name, inode->i_sb->s_id);\n\t\tif (dentry) {\n\t\t\tspin_unlock(&dentry->d_lock);\n\t\t\tdput(dentry);\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "brelse",
          "args": [
            "partial->bh"
          ],
          "line": 1135
        },
        "resolved": true,
        "details": {
          "function_name": "__brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1177-1184",
          "snippet": "void __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "mark_buffer_dirty_inode",
          "args": [
            "partial->bh",
            "inode"
          ],
          "line": 1134
        },
        "resolved": true,
        "details": {
          "function_name": "mark_buffer_dirty_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "599-617",
          "snippet": "void mark_buffer_dirty_inode(struct buffer_head *bh, struct inode *inode)\n{\n\tstruct address_space *mapping = inode->i_mapping;\n\tstruct address_space *buffer_mapping = bh->b_page->mapping;\n\n\tmark_buffer_dirty(bh);\n\tif (!mapping->private_data) {\n\t\tmapping->private_data = buffer_mapping;\n\t} else {\n\t\tBUG_ON(mapping->private_data != buffer_mapping);\n\t}\n\tif (!bh->b_assoc_map) {\n\t\tspin_lock(&buffer_mapping->private_lock);\n\t\tlist_move_tail(&bh->b_assoc_buffers,\n\t\t\t\t&mapping->private_list);\n\t\tbh->b_assoc_map = mapping;\n\t\tspin_unlock(&buffer_mapping->private_lock);\n\t}\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid mark_buffer_dirty_inode(struct buffer_head *bh, struct inode *inode)\n{\n\tstruct address_space *mapping = inode->i_mapping;\n\tstruct address_space *buffer_mapping = bh->b_page->mapping;\n\n\tmark_buffer_dirty(bh);\n\tif (!mapping->private_data) {\n\t\tmapping->private_data = buffer_mapping;\n\t} else {\n\t\tBUG_ON(mapping->private_data != buffer_mapping);\n\t}\n\tif (!bh->b_assoc_map) {\n\t\tspin_lock(&buffer_mapping->private_lock);\n\t\tlist_move_tail(&bh->b_assoc_buffers,\n\t\t\t\t&mapping->private_list);\n\t\tbh->b_assoc_map = mapping;\n\t\tspin_unlock(&buffer_mapping->private_lock);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext2_find_shared",
          "args": [
            "inode",
            "n",
            "offsets",
            "chain",
            "&nr"
          ],
          "line": 1119
        },
        "resolved": true,
        "details": {
          "function_name": "ext2_find_shared",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext2/inode.c",
          "lines": "954-1001",
          "snippet": "static Indirect *ext2_find_shared(struct inode *inode,\n\t\t\t\tint depth,\n\t\t\t\tint offsets[4],\n\t\t\t\tIndirect chain[4],\n\t\t\t\t__le32 *top)\n{\n\tIndirect *partial, *p;\n\tint k, err;\n\n\t*top = 0;\n\tfor (k = depth; k > 1 && !offsets[k-1]; k--)\n\t\t;\n\tpartial = ext2_get_branch(inode, k, offsets, chain, &err);\n\tif (!partial)\n\t\tpartial = chain + k-1;\n\t/*\n\t * If the branch acquired continuation since we've looked at it -\n\t * fine, it should all survive and (new) top doesn't belong to us.\n\t */\n\twrite_lock(&EXT2_I(inode)->i_meta_lock);\n\tif (!partial->key && *partial->p) {\n\t\twrite_unlock(&EXT2_I(inode)->i_meta_lock);\n\t\tgoto no_top;\n\t}\n\tfor (p=partial; p>chain && all_zeroes((__le32*)p->bh->b_data,p->p); p--)\n\t\t;\n\t/*\n\t * OK, we've found the last block that must survive. The rest of our\n\t * branch should be detached before unlocking. However, if that rest\n\t * of branch is all ours and does not grow immediately from the inode\n\t * it's easier to cheat and just decrement partial->p.\n\t */\n\tif (p == chain + k - 1 && p > chain) {\n\t\tp->p--;\n\t} else {\n\t\t*top = *p->p;\n\t\t*p->p = 0;\n\t}\n\twrite_unlock(&EXT2_I(inode)->i_meta_lock);\n\n\twhile(partial > p)\n\t{\n\t\tbrelse(partial->bh);\n\t\tpartial--;\n\t}\nno_top:\n\treturn partial;\n}",
          "includes": [
            "#include \"xattr.h\"",
            "#include \"acl.h\"",
            "#include \"ext2.h\"",
            "#include <linux/aio.h>",
            "#include <linux/namei.h>",
            "#include <linux/fiemap.h>",
            "#include <linux/mpage.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/writeback.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highuid.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xattr.h\"\n#include \"acl.h\"\n#include \"ext2.h\"\n#include <linux/aio.h>\n#include <linux/namei.h>\n#include <linux/fiemap.h>\n#include <linux/mpage.h>\n#include <linux/buffer_head.h>\n#include <linux/writeback.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/highuid.h>\n#include <linux/time.h>\n\nstatic Indirect *ext2_find_shared(struct inode *inode,\n\t\t\t\tint depth,\n\t\t\t\tint offsets[4],\n\t\t\t\tIndirect chain[4],\n\t\t\t\t__le32 *top)\n{\n\tIndirect *partial, *p;\n\tint k, err;\n\n\t*top = 0;\n\tfor (k = depth; k > 1 && !offsets[k-1]; k--)\n\t\t;\n\tpartial = ext2_get_branch(inode, k, offsets, chain, &err);\n\tif (!partial)\n\t\tpartial = chain + k-1;\n\t/*\n\t * If the branch acquired continuation since we've looked at it -\n\t * fine, it should all survive and (new) top doesn't belong to us.\n\t */\n\twrite_lock(&EXT2_I(inode)->i_meta_lock);\n\tif (!partial->key && *partial->p) {\n\t\twrite_unlock(&EXT2_I(inode)->i_meta_lock);\n\t\tgoto no_top;\n\t}\n\tfor (p=partial; p>chain && all_zeroes((__le32*)p->bh->b_data,p->p); p--)\n\t\t;\n\t/*\n\t * OK, we've found the last block that must survive. The rest of our\n\t * branch should be detached before unlocking. However, if that rest\n\t * of branch is all ours and does not grow immediately from the inode\n\t * it's easier to cheat and just decrement partial->p.\n\t */\n\tif (p == chain + k - 1 && p > chain) {\n\t\tp->p--;\n\t} else {\n\t\t*top = *p->p;\n\t\t*p->p = 0;\n\t}\n\twrite_unlock(&EXT2_I(inode)->i_meta_lock);\n\n\twhile(partial > p)\n\t{\n\t\tbrelse(partial->bh);\n\t\tpartial--;\n\t}\nno_top:\n\treturn partial;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext2_free_data",
          "args": [
            "inode",
            "i_data+offsets[0]",
            "i_data + EXT2_NDIR_BLOCKS"
          ],
          "line": 1114
        },
        "resolved": true,
        "details": {
          "function_name": "ext2_free_data",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext2/inode.c",
          "lines": "1013-1040",
          "snippet": "static inline void ext2_free_data(struct inode *inode, __le32 *p, __le32 *q)\n{\n\tunsigned long block_to_free = 0, count = 0;\n\tunsigned long nr;\n\n\tfor ( ; p < q ; p++) {\n\t\tnr = le32_to_cpu(*p);\n\t\tif (nr) {\n\t\t\t*p = 0;\n\t\t\t/* accumulate blocks to free if they're contiguous */\n\t\t\tif (count == 0)\n\t\t\t\tgoto free_this;\n\t\t\telse if (block_to_free == nr - count)\n\t\t\t\tcount++;\n\t\t\telse {\n\t\t\t\text2_free_blocks (inode, block_to_free, count);\n\t\t\t\tmark_inode_dirty(inode);\n\t\t\tfree_this:\n\t\t\t\tblock_to_free = nr;\n\t\t\t\tcount = 1;\n\t\t\t}\n\t\t}\n\t}\n\tif (count > 0) {\n\t\text2_free_blocks (inode, block_to_free, count);\n\t\tmark_inode_dirty(inode);\n\t}\n}",
          "includes": [
            "#include \"xattr.h\"",
            "#include \"acl.h\"",
            "#include \"ext2.h\"",
            "#include <linux/aio.h>",
            "#include <linux/namei.h>",
            "#include <linux/fiemap.h>",
            "#include <linux/mpage.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/writeback.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highuid.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xattr.h\"\n#include \"acl.h\"\n#include \"ext2.h\"\n#include <linux/aio.h>\n#include <linux/namei.h>\n#include <linux/fiemap.h>\n#include <linux/mpage.h>\n#include <linux/buffer_head.h>\n#include <linux/writeback.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/highuid.h>\n#include <linux/time.h>\n\nstatic inline void ext2_free_data(struct inode *inode, __le32 *p, __le32 *q)\n{\n\tunsigned long block_to_free = 0, count = 0;\n\tunsigned long nr;\n\n\tfor ( ; p < q ; p++) {\n\t\tnr = le32_to_cpu(*p);\n\t\tif (nr) {\n\t\t\t*p = 0;\n\t\t\t/* accumulate blocks to free if they're contiguous */\n\t\t\tif (count == 0)\n\t\t\t\tgoto free_this;\n\t\t\telse if (block_to_free == nr - count)\n\t\t\t\tcount++;\n\t\t\telse {\n\t\t\t\text2_free_blocks (inode, block_to_free, count);\n\t\t\t\tmark_inode_dirty(inode);\n\t\t\tfree_this:\n\t\t\t\tblock_to_free = nr;\n\t\t\t\tcount = 1;\n\t\t\t}\n\t\t}\n\t}\n\tif (count > 0) {\n\t\text2_free_blocks (inode, block_to_free, count);\n\t\tmark_inode_dirty(inode);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&ei->truncate_mutex"
          ],
          "line": 1111
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext2_block_to_path",
          "args": [
            "inode",
            "iblock",
            "offsets",
            "NULL"
          ],
          "line": 1103
        },
        "resolved": true,
        "details": {
          "function_name": "ext2_block_to_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext2/inode.c",
          "lines": "159-199",
          "snippet": "static int ext2_block_to_path(struct inode *inode,\n\t\t\tlong i_block, int offsets[4], int *boundary)\n{\n\tint ptrs = EXT2_ADDR_PER_BLOCK(inode->i_sb);\n\tint ptrs_bits = EXT2_ADDR_PER_BLOCK_BITS(inode->i_sb);\n\tconst long direct_blocks = EXT2_NDIR_BLOCKS,\n\t\tindirect_blocks = ptrs,\n\t\tdouble_blocks = (1 << (ptrs_bits * 2));\n\tint n = 0;\n\tint final = 0;\n\n\tif (i_block < 0) {\n\t\text2_msg(inode->i_sb, KERN_WARNING,\n\t\t\t\"warning: %s: block < 0\", __func__);\n\t} else if (i_block < direct_blocks) {\n\t\toffsets[n++] = i_block;\n\t\tfinal = direct_blocks;\n\t} else if ( (i_block -= direct_blocks) < indirect_blocks) {\n\t\toffsets[n++] = EXT2_IND_BLOCK;\n\t\toffsets[n++] = i_block;\n\t\tfinal = ptrs;\n\t} else if ((i_block -= indirect_blocks) < double_blocks) {\n\t\toffsets[n++] = EXT2_DIND_BLOCK;\n\t\toffsets[n++] = i_block >> ptrs_bits;\n\t\toffsets[n++] = i_block & (ptrs - 1);\n\t\tfinal = ptrs;\n\t} else if (((i_block -= double_blocks) >> (ptrs_bits * 2)) < ptrs) {\n\t\toffsets[n++] = EXT2_TIND_BLOCK;\n\t\toffsets[n++] = i_block >> (ptrs_bits * 2);\n\t\toffsets[n++] = (i_block >> ptrs_bits) & (ptrs - 1);\n\t\toffsets[n++] = i_block & (ptrs - 1);\n\t\tfinal = ptrs;\n\t} else {\n\t\text2_msg(inode->i_sb, KERN_WARNING,\n\t\t\t\"warning: %s: block is too big\", __func__);\n\t}\n\tif (boundary)\n\t\t*boundary = final - 1 - (i_block & (ptrs - 1));\n\n\treturn n;\n}",
          "includes": [
            "#include \"xattr.h\"",
            "#include \"acl.h\"",
            "#include \"ext2.h\"",
            "#include <linux/aio.h>",
            "#include <linux/namei.h>",
            "#include <linux/fiemap.h>",
            "#include <linux/mpage.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/writeback.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highuid.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xattr.h\"\n#include \"acl.h\"\n#include \"ext2.h\"\n#include <linux/aio.h>\n#include <linux/namei.h>\n#include <linux/fiemap.h>\n#include <linux/mpage.h>\n#include <linux/buffer_head.h>\n#include <linux/writeback.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/highuid.h>\n#include <linux/time.h>\n\nstatic int ext2_block_to_path(struct inode *inode,\n\t\t\tlong i_block, int offsets[4], int *boundary)\n{\n\tint ptrs = EXT2_ADDR_PER_BLOCK(inode->i_sb);\n\tint ptrs_bits = EXT2_ADDR_PER_BLOCK_BITS(inode->i_sb);\n\tconst long direct_blocks = EXT2_NDIR_BLOCKS,\n\t\tindirect_blocks = ptrs,\n\t\tdouble_blocks = (1 << (ptrs_bits * 2));\n\tint n = 0;\n\tint final = 0;\n\n\tif (i_block < 0) {\n\t\text2_msg(inode->i_sb, KERN_WARNING,\n\t\t\t\"warning: %s: block < 0\", __func__);\n\t} else if (i_block < direct_blocks) {\n\t\toffsets[n++] = i_block;\n\t\tfinal = direct_blocks;\n\t} else if ( (i_block -= direct_blocks) < indirect_blocks) {\n\t\toffsets[n++] = EXT2_IND_BLOCK;\n\t\toffsets[n++] = i_block;\n\t\tfinal = ptrs;\n\t} else if ((i_block -= indirect_blocks) < double_blocks) {\n\t\toffsets[n++] = EXT2_DIND_BLOCK;\n\t\toffsets[n++] = i_block >> ptrs_bits;\n\t\toffsets[n++] = i_block & (ptrs - 1);\n\t\tfinal = ptrs;\n\t} else if (((i_block -= double_blocks) >> (ptrs_bits * 2)) < ptrs) {\n\t\toffsets[n++] = EXT2_TIND_BLOCK;\n\t\toffsets[n++] = i_block >> (ptrs_bits * 2);\n\t\toffsets[n++] = (i_block >> ptrs_bits) & (ptrs - 1);\n\t\toffsets[n++] = i_block & (ptrs - 1);\n\t\tfinal = ptrs;\n\t} else {\n\t\text2_msg(inode->i_sb, KERN_WARNING,\n\t\t\t\"warning: %s: block is too big\", __func__);\n\t}\n\tif (boundary)\n\t\t*boundary = final - 1 - (i_block & (ptrs - 1));\n\n\treturn n;\n}"
        }
      },
      {
        "call_info": {
          "callee": "EXT2_BLOCK_SIZE_BITS",
          "args": [
            "inode->i_sb"
          ],
          "line": 1101
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXT2_ADDR_PER_BLOCK",
          "args": [
            "inode->i_sb"
          ],
          "line": 1092
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXT2_I",
          "args": [
            "inode"
          ],
          "line": 1091
        },
        "resolved": true,
        "details": {
          "function_name": "EXT2_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext2/ext2.h",
          "lines": "717-720",
          "snippet": "static inline struct ext2_inode_info *EXT2_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ext2_inode_info, vfs_inode);\n}",
          "includes": [
            "#include <linux/rbtree.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/ext2_fs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern ext2_fsblk_t ext2_new_block(struct inode *, unsigned long, int *);",
            "extern ext2_fsblk_t ext2_new_blocks(struct inode *, unsigned long,\n\t\t\t\tunsigned long *, int *);",
            "extern void ext2_free_blocks (struct inode *, unsigned long,\n\t\t\t      unsigned long);",
            "extern void ext2_discard_reservation (struct inode *);",
            "extern void ext2_init_block_alloc_info(struct inode *);",
            "extern int ext2_add_link (struct dentry *, struct inode *);",
            "extern int ext2_make_empty(struct inode *, struct inode *);",
            "extern int ext2_empty_dir (struct inode *);",
            "extern void ext2_set_link(struct inode *, struct ext2_dir_entry_2 *, struct page *, struct inode *, int);",
            "extern void ext2_free_inode (struct inode *);",
            "extern void ext2_evict_inode(struct inode *);",
            "extern void ext2_set_inode_flags(struct inode *inode);",
            "extern void ext2_get_inode_flags(struct ext2_inode_info *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rbtree.h>\n#include <linux/percpu_counter.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/ext2_fs.h>\n#include <linux/fs.h>\n\nextern ext2_fsblk_t ext2_new_block(struct inode *, unsigned long, int *);\nextern ext2_fsblk_t ext2_new_blocks(struct inode *, unsigned long,\n\t\t\t\tunsigned long *, int *);\nextern void ext2_free_blocks (struct inode *, unsigned long,\n\t\t\t      unsigned long);\nextern void ext2_discard_reservation (struct inode *);\nextern void ext2_init_block_alloc_info(struct inode *);\nextern int ext2_add_link (struct dentry *, struct inode *);\nextern int ext2_make_empty(struct inode *, struct inode *);\nextern int ext2_empty_dir (struct inode *);\nextern void ext2_set_link(struct inode *, struct ext2_dir_entry_2 *, struct page *, struct inode *, int);\nextern void ext2_free_inode (struct inode *);\nextern void ext2_evict_inode(struct inode *);\nextern void ext2_set_inode_flags(struct inode *inode);\nextern void ext2_get_inode_flags(struct ext2_inode_info *);\n\nstatic inline struct ext2_inode_info *EXT2_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ext2_inode_info, vfs_inode);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"xattr.h\"\n#include \"acl.h\"\n#include \"ext2.h\"\n#include <linux/aio.h>\n#include <linux/namei.h>\n#include <linux/fiemap.h>\n#include <linux/mpage.h>\n#include <linux/buffer_head.h>\n#include <linux/writeback.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/highuid.h>\n#include <linux/time.h>\n\nstatic void ext2_truncate_blocks(struct inode *inode, loff_t offset);\n\nstatic void __ext2_truncate_blocks(struct inode *inode, loff_t offset)\n{\n\t__le32 *i_data = EXT2_I(inode)->i_data;\n\tstruct ext2_inode_info *ei = EXT2_I(inode);\n\tint addr_per_block = EXT2_ADDR_PER_BLOCK(inode->i_sb);\n\tint offsets[4];\n\tIndirect chain[4];\n\tIndirect *partial;\n\t__le32 nr = 0;\n\tint n;\n\tlong iblock;\n\tunsigned blocksize;\n\tblocksize = inode->i_sb->s_blocksize;\n\tiblock = (offset + blocksize-1) >> EXT2_BLOCK_SIZE_BITS(inode->i_sb);\n\n\tn = ext2_block_to_path(inode, iblock, offsets, NULL);\n\tif (n == 0)\n\t\treturn;\n\n\t/*\n\t * From here we block out all ext2_get_block() callers who want to\n\t * modify the block allocation tree.\n\t */\n\tmutex_lock(&ei->truncate_mutex);\n\n\tif (n == 1) {\n\t\text2_free_data(inode, i_data+offsets[0],\n\t\t\t\t\ti_data + EXT2_NDIR_BLOCKS);\n\t\tgoto do_indirects;\n\t}\n\n\tpartial = ext2_find_shared(inode, n, offsets, chain, &nr);\n\t/* Kill the top of shared branch (already detached) */\n\tif (nr) {\n\t\tif (partial == chain)\n\t\t\tmark_inode_dirty(inode);\n\t\telse\n\t\t\tmark_buffer_dirty_inode(partial->bh, inode);\n\t\text2_free_branches(inode, &nr, &nr+1, (chain+n-1) - partial);\n\t}\n\t/* Clear the ends of indirect blocks on the shared branch */\n\twhile (partial > chain) {\n\t\text2_free_branches(inode,\n\t\t\t\t   partial->p + 1,\n\t\t\t\t   (__le32*)partial->bh->b_data+addr_per_block,\n\t\t\t\t   (chain+n-1) - partial);\n\t\tmark_buffer_dirty_inode(partial->bh, inode);\n\t\tbrelse (partial->bh);\n\t\tpartial--;\n\t}\ndo_indirects:\n\t/* Kill the remaining (whole) subtrees */\n\tswitch (offsets[0]) {\n\t\tdefault:\n\t\t\tnr = i_data[EXT2_IND_BLOCK];\n\t\t\tif (nr) {\n\t\t\t\ti_data[EXT2_IND_BLOCK] = 0;\n\t\t\t\tmark_inode_dirty(inode);\n\t\t\t\text2_free_branches(inode, &nr, &nr+1, 1);\n\t\t\t}\n\t\tcase EXT2_IND_BLOCK:\n\t\t\tnr = i_data[EXT2_DIND_BLOCK];\n\t\t\tif (nr) {\n\t\t\t\ti_data[EXT2_DIND_BLOCK] = 0;\n\t\t\t\tmark_inode_dirty(inode);\n\t\t\t\text2_free_branches(inode, &nr, &nr+1, 2);\n\t\t\t}\n\t\tcase EXT2_DIND_BLOCK:\n\t\t\tnr = i_data[EXT2_TIND_BLOCK];\n\t\t\tif (nr) {\n\t\t\t\ti_data[EXT2_TIND_BLOCK] = 0;\n\t\t\t\tmark_inode_dirty(inode);\n\t\t\t\text2_free_branches(inode, &nr, &nr+1, 3);\n\t\t\t}\n\t\tcase EXT2_TIND_BLOCK:\n\t\t\t;\n\t}\n\n\text2_discard_reservation(inode);\n\n\tmutex_unlock(&ei->truncate_mutex);\n}"
  },
  {
    "function_name": "ext2_free_branches",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext2/inode.c",
    "lines": "1053-1086",
    "snippet": "static void ext2_free_branches(struct inode *inode, __le32 *p, __le32 *q, int depth)\n{\n\tstruct buffer_head * bh;\n\tunsigned long nr;\n\n\tif (depth--) {\n\t\tint addr_per_block = EXT2_ADDR_PER_BLOCK(inode->i_sb);\n\t\tfor ( ; p < q ; p++) {\n\t\t\tnr = le32_to_cpu(*p);\n\t\t\tif (!nr)\n\t\t\t\tcontinue;\n\t\t\t*p = 0;\n\t\t\tbh = sb_bread(inode->i_sb, nr);\n\t\t\t/*\n\t\t\t * A read failure? Report error and clear slot\n\t\t\t * (should be rare).\n\t\t\t */ \n\t\t\tif (!bh) {\n\t\t\t\text2_error(inode->i_sb, \"ext2_free_branches\",\n\t\t\t\t\t\"Read failure, inode=%ld, block=%ld\",\n\t\t\t\t\tinode->i_ino, nr);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\text2_free_branches(inode,\n\t\t\t\t\t   (__le32*)bh->b_data,\n\t\t\t\t\t   (__le32*)bh->b_data + addr_per_block,\n\t\t\t\t\t   depth);\n\t\t\tbforget(bh);\n\t\t\text2_free_blocks(inode, nr, 1);\n\t\t\tmark_inode_dirty(inode);\n\t\t}\n\t} else\n\t\text2_free_data(inode, p, q);\n}",
    "includes": [
      "#include \"xattr.h\"",
      "#include \"acl.h\"",
      "#include \"ext2.h\"",
      "#include <linux/aio.h>",
      "#include <linux/namei.h>",
      "#include <linux/fiemap.h>",
      "#include <linux/mpage.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/writeback.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/highuid.h>",
      "#include <linux/time.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ext2_free_data",
          "args": [
            "inode",
            "p",
            "q"
          ],
          "line": 1085
        },
        "resolved": true,
        "details": {
          "function_name": "ext2_free_data",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext2/inode.c",
          "lines": "1013-1040",
          "snippet": "static inline void ext2_free_data(struct inode *inode, __le32 *p, __le32 *q)\n{\n\tunsigned long block_to_free = 0, count = 0;\n\tunsigned long nr;\n\n\tfor ( ; p < q ; p++) {\n\t\tnr = le32_to_cpu(*p);\n\t\tif (nr) {\n\t\t\t*p = 0;\n\t\t\t/* accumulate blocks to free if they're contiguous */\n\t\t\tif (count == 0)\n\t\t\t\tgoto free_this;\n\t\t\telse if (block_to_free == nr - count)\n\t\t\t\tcount++;\n\t\t\telse {\n\t\t\t\text2_free_blocks (inode, block_to_free, count);\n\t\t\t\tmark_inode_dirty(inode);\n\t\t\tfree_this:\n\t\t\t\tblock_to_free = nr;\n\t\t\t\tcount = 1;\n\t\t\t}\n\t\t}\n\t}\n\tif (count > 0) {\n\t\text2_free_blocks (inode, block_to_free, count);\n\t\tmark_inode_dirty(inode);\n\t}\n}",
          "includes": [
            "#include \"xattr.h\"",
            "#include \"acl.h\"",
            "#include \"ext2.h\"",
            "#include <linux/aio.h>",
            "#include <linux/namei.h>",
            "#include <linux/fiemap.h>",
            "#include <linux/mpage.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/writeback.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highuid.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xattr.h\"\n#include \"acl.h\"\n#include \"ext2.h\"\n#include <linux/aio.h>\n#include <linux/namei.h>\n#include <linux/fiemap.h>\n#include <linux/mpage.h>\n#include <linux/buffer_head.h>\n#include <linux/writeback.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/highuid.h>\n#include <linux/time.h>\n\nstatic inline void ext2_free_data(struct inode *inode, __le32 *p, __le32 *q)\n{\n\tunsigned long block_to_free = 0, count = 0;\n\tunsigned long nr;\n\n\tfor ( ; p < q ; p++) {\n\t\tnr = le32_to_cpu(*p);\n\t\tif (nr) {\n\t\t\t*p = 0;\n\t\t\t/* accumulate blocks to free if they're contiguous */\n\t\t\tif (count == 0)\n\t\t\t\tgoto free_this;\n\t\t\telse if (block_to_free == nr - count)\n\t\t\t\tcount++;\n\t\t\telse {\n\t\t\t\text2_free_blocks (inode, block_to_free, count);\n\t\t\t\tmark_inode_dirty(inode);\n\t\t\tfree_this:\n\t\t\t\tblock_to_free = nr;\n\t\t\t\tcount = 1;\n\t\t\t}\n\t\t}\n\t}\n\tif (count > 0) {\n\t\text2_free_blocks (inode, block_to_free, count);\n\t\tmark_inode_dirty(inode);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "mark_inode_dirty",
          "args": [
            "inode"
          ],
          "line": 1082
        },
        "resolved": true,
        "details": {
          "function_name": "block_dump___mark_inode_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fs-writeback.c",
          "lines": "1134-1154",
          "snippet": "static noinline void block_dump___mark_inode_dirty(struct inode *inode)\n{\n\tif (inode->i_ino || strcmp(inode->i_sb->s_id, \"bdev\")) {\n\t\tstruct dentry *dentry;\n\t\tconst char *name = \"?\";\n\n\t\tdentry = d_find_alias(inode);\n\t\tif (dentry) {\n\t\t\tspin_lock(&dentry->d_lock);\n\t\t\tname = (const char *) dentry->d_name.name;\n\t\t}\n\t\tprintk(KERN_DEBUG\n\t\t       \"%s(%d): dirtied inode %lu (%s) on %s\\n\",\n\t\t       current->comm, task_pid_nr(current), inode->i_ino,\n\t\t       name, inode->i_sb->s_id);\n\t\tif (dentry) {\n\t\t\tspin_unlock(&dentry->d_lock);\n\t\t\tdput(dentry);\n\t\t}\n\t}\n}",
          "includes": [
            "#include <trace/events/writeback.h>",
            "#include \"internal.h\"",
            "#include <linux/device.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/writeback.h>\n#include \"internal.h\"\n#include <linux/device.h>\n#include <linux/tracepoint.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nstatic noinline void block_dump___mark_inode_dirty(struct inode *inode)\n{\n\tif (inode->i_ino || strcmp(inode->i_sb->s_id, \"bdev\")) {\n\t\tstruct dentry *dentry;\n\t\tconst char *name = \"?\";\n\n\t\tdentry = d_find_alias(inode);\n\t\tif (dentry) {\n\t\t\tspin_lock(&dentry->d_lock);\n\t\t\tname = (const char *) dentry->d_name.name;\n\t\t}\n\t\tprintk(KERN_DEBUG\n\t\t       \"%s(%d): dirtied inode %lu (%s) on %s\\n\",\n\t\t       current->comm, task_pid_nr(current), inode->i_ino,\n\t\t       name, inode->i_sb->s_id);\n\t\tif (dentry) {\n\t\t\tspin_unlock(&dentry->d_lock);\n\t\t\tdput(dentry);\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext2_free_blocks",
          "args": [
            "inode",
            "nr",
            "1"
          ],
          "line": 1081
        },
        "resolved": true,
        "details": {
          "function_name": "ext2_free_blocks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext2/balloc.c",
          "lines": "476-567",
          "snippet": "void ext2_free_blocks (struct inode * inode, unsigned long block,\n\t\t       unsigned long count)\n{\n\tstruct buffer_head *bitmap_bh = NULL;\n\tstruct buffer_head * bh2;\n\tunsigned long block_group;\n\tunsigned long bit;\n\tunsigned long i;\n\tunsigned long overflow;\n\tstruct super_block * sb = inode->i_sb;\n\tstruct ext2_sb_info * sbi = EXT2_SB(sb);\n\tstruct ext2_group_desc * desc;\n\tstruct ext2_super_block * es = sbi->s_es;\n\tunsigned freed = 0, group_freed;\n\n\tif (block < le32_to_cpu(es->s_first_data_block) ||\n\t    block + count < block ||\n\t    block + count > le32_to_cpu(es->s_blocks_count)) {\n\t\text2_error (sb, \"ext2_free_blocks\",\n\t\t\t    \"Freeing blocks not in datazone - \"\n\t\t\t    \"block = %lu, count = %lu\", block, count);\n\t\tgoto error_return;\n\t}\n\n\text2_debug (\"freeing block(s) %lu-%lu\\n\", block, block + count - 1);\n\ndo_more:\n\toverflow = 0;\n\tblock_group = (block - le32_to_cpu(es->s_first_data_block)) /\n\t\t      EXT2_BLOCKS_PER_GROUP(sb);\n\tbit = (block - le32_to_cpu(es->s_first_data_block)) %\n\t\t      EXT2_BLOCKS_PER_GROUP(sb);\n\t/*\n\t * Check to see if we are freeing blocks across a group\n\t * boundary.\n\t */\n\tif (bit + count > EXT2_BLOCKS_PER_GROUP(sb)) {\n\t\toverflow = bit + count - EXT2_BLOCKS_PER_GROUP(sb);\n\t\tcount -= overflow;\n\t}\n\tbrelse(bitmap_bh);\n\tbitmap_bh = read_block_bitmap(sb, block_group);\n\tif (!bitmap_bh)\n\t\tgoto error_return;\n\n\tdesc = ext2_get_group_desc (sb, block_group, &bh2);\n\tif (!desc)\n\t\tgoto error_return;\n\n\tif (in_range (le32_to_cpu(desc->bg_block_bitmap), block, count) ||\n\t    in_range (le32_to_cpu(desc->bg_inode_bitmap), block, count) ||\n\t    in_range (block, le32_to_cpu(desc->bg_inode_table),\n\t\t      sbi->s_itb_per_group) ||\n\t    in_range (block + count - 1, le32_to_cpu(desc->bg_inode_table),\n\t\t      sbi->s_itb_per_group)) {\n\t\text2_error (sb, \"ext2_free_blocks\",\n\t\t\t    \"Freeing blocks in system zones - \"\n\t\t\t    \"Block = %lu, count = %lu\",\n\t\t\t    block, count);\n\t\tgoto error_return;\n\t}\n\n\tfor (i = 0, group_freed = 0; i < count; i++) {\n\t\tif (!ext2_clear_bit_atomic(sb_bgl_lock(sbi, block_group),\n\t\t\t\t\t\tbit + i, bitmap_bh->b_data)) {\n\t\t\text2_error(sb, __func__,\n\t\t\t\t\"bit already cleared for block %lu\", block + i);\n\t\t} else {\n\t\t\tgroup_freed++;\n\t\t}\n\t}\n\n\tmark_buffer_dirty(bitmap_bh);\n\tif (sb->s_flags & MS_SYNCHRONOUS)\n\t\tsync_dirty_buffer(bitmap_bh);\n\n\tgroup_adjust_blocks(sb, block_group, desc, bh2, group_freed);\n\tfreed += group_freed;\n\n\tif (overflow) {\n\t\tblock += count;\n\t\tcount = overflow;\n\t\tgoto do_more;\n\t}\nerror_return:\n\tbrelse(bitmap_bh);\n\tif (freed) {\n\t\tpercpu_counter_add(&sbi->s_freeblocks_counter, freed);\n\t\tdquot_free_block_nodirty(inode, freed);\n\t\tmark_inode_dirty(inode);\n\t}\n}",
          "includes": [
            "#include <linux/capability.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/quotaops.h>",
            "#include \"ext2.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/capability.h>\n#include <linux/buffer_head.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/quotaops.h>\n#include \"ext2.h\"\n\nvoid ext2_free_blocks (struct inode * inode, unsigned long block,\n\t\t       unsigned long count)\n{\n\tstruct buffer_head *bitmap_bh = NULL;\n\tstruct buffer_head * bh2;\n\tunsigned long block_group;\n\tunsigned long bit;\n\tunsigned long i;\n\tunsigned long overflow;\n\tstruct super_block * sb = inode->i_sb;\n\tstruct ext2_sb_info * sbi = EXT2_SB(sb);\n\tstruct ext2_group_desc * desc;\n\tstruct ext2_super_block * es = sbi->s_es;\n\tunsigned freed = 0, group_freed;\n\n\tif (block < le32_to_cpu(es->s_first_data_block) ||\n\t    block + count < block ||\n\t    block + count > le32_to_cpu(es->s_blocks_count)) {\n\t\text2_error (sb, \"ext2_free_blocks\",\n\t\t\t    \"Freeing blocks not in datazone - \"\n\t\t\t    \"block = %lu, count = %lu\", block, count);\n\t\tgoto error_return;\n\t}\n\n\text2_debug (\"freeing block(s) %lu-%lu\\n\", block, block + count - 1);\n\ndo_more:\n\toverflow = 0;\n\tblock_group = (block - le32_to_cpu(es->s_first_data_block)) /\n\t\t      EXT2_BLOCKS_PER_GROUP(sb);\n\tbit = (block - le32_to_cpu(es->s_first_data_block)) %\n\t\t      EXT2_BLOCKS_PER_GROUP(sb);\n\t/*\n\t * Check to see if we are freeing blocks across a group\n\t * boundary.\n\t */\n\tif (bit + count > EXT2_BLOCKS_PER_GROUP(sb)) {\n\t\toverflow = bit + count - EXT2_BLOCKS_PER_GROUP(sb);\n\t\tcount -= overflow;\n\t}\n\tbrelse(bitmap_bh);\n\tbitmap_bh = read_block_bitmap(sb, block_group);\n\tif (!bitmap_bh)\n\t\tgoto error_return;\n\n\tdesc = ext2_get_group_desc (sb, block_group, &bh2);\n\tif (!desc)\n\t\tgoto error_return;\n\n\tif (in_range (le32_to_cpu(desc->bg_block_bitmap), block, count) ||\n\t    in_range (le32_to_cpu(desc->bg_inode_bitmap), block, count) ||\n\t    in_range (block, le32_to_cpu(desc->bg_inode_table),\n\t\t      sbi->s_itb_per_group) ||\n\t    in_range (block + count - 1, le32_to_cpu(desc->bg_inode_table),\n\t\t      sbi->s_itb_per_group)) {\n\t\text2_error (sb, \"ext2_free_blocks\",\n\t\t\t    \"Freeing blocks in system zones - \"\n\t\t\t    \"Block = %lu, count = %lu\",\n\t\t\t    block, count);\n\t\tgoto error_return;\n\t}\n\n\tfor (i = 0, group_freed = 0; i < count; i++) {\n\t\tif (!ext2_clear_bit_atomic(sb_bgl_lock(sbi, block_group),\n\t\t\t\t\t\tbit + i, bitmap_bh->b_data)) {\n\t\t\text2_error(sb, __func__,\n\t\t\t\t\"bit already cleared for block %lu\", block + i);\n\t\t} else {\n\t\t\tgroup_freed++;\n\t\t}\n\t}\n\n\tmark_buffer_dirty(bitmap_bh);\n\tif (sb->s_flags & MS_SYNCHRONOUS)\n\t\tsync_dirty_buffer(bitmap_bh);\n\n\tgroup_adjust_blocks(sb, block_group, desc, bh2, group_freed);\n\tfreed += group_freed;\n\n\tif (overflow) {\n\t\tblock += count;\n\t\tcount = overflow;\n\t\tgoto do_more;\n\t}\nerror_return:\n\tbrelse(bitmap_bh);\n\tif (freed) {\n\t\tpercpu_counter_add(&sbi->s_freeblocks_counter, freed);\n\t\tdquot_free_block_nodirty(inode, freed);\n\t\tmark_inode_dirty(inode);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "bforget",
          "args": [
            "bh"
          ],
          "line": 1080
        },
        "resolved": true,
        "details": {
          "function_name": "__bforget",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1191-1203",
          "snippet": "void __bforget(struct buffer_head *bh)\n{\n\tclear_buffer_dirty(bh);\n\tif (bh->b_assoc_map) {\n\t\tstruct address_space *buffer_mapping = bh->b_page->mapping;\n\n\t\tspin_lock(&buffer_mapping->private_lock);\n\t\tlist_del_init(&bh->b_assoc_buffers);\n\t\tbh->b_assoc_map = NULL;\n\t\tspin_unlock(&buffer_mapping->private_lock);\n\t}\n\t__brelse(bh);\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid __bforget(struct buffer_head *bh)\n{\n\tclear_buffer_dirty(bh);\n\tif (bh->b_assoc_map) {\n\t\tstruct address_space *buffer_mapping = bh->b_page->mapping;\n\n\t\tspin_lock(&buffer_mapping->private_lock);\n\t\tlist_del_init(&bh->b_assoc_buffers);\n\t\tbh->b_assoc_map = NULL;\n\t\tspin_unlock(&buffer_mapping->private_lock);\n\t}\n\t__brelse(bh);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext2_free_branches",
          "args": [
            "inode",
            "(__le32*)bh->b_data",
            "(__le32*)bh->b_data + addr_per_block",
            "depth"
          ],
          "line": 1076
        },
        "resolved": true,
        "details": {
          "function_name": "ext2_free_branches",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext2/inode.c",
          "lines": "1053-1086",
          "snippet": "static void ext2_free_branches(struct inode *inode, __le32 *p, __le32 *q, int depth)\n{\n\tstruct buffer_head * bh;\n\tunsigned long nr;\n\n\tif (depth--) {\n\t\tint addr_per_block = EXT2_ADDR_PER_BLOCK(inode->i_sb);\n\t\tfor ( ; p < q ; p++) {\n\t\t\tnr = le32_to_cpu(*p);\n\t\t\tif (!nr)\n\t\t\t\tcontinue;\n\t\t\t*p = 0;\n\t\t\tbh = sb_bread(inode->i_sb, nr);\n\t\t\t/*\n\t\t\t * A read failure? Report error and clear slot\n\t\t\t * (should be rare).\n\t\t\t */ \n\t\t\tif (!bh) {\n\t\t\t\text2_error(inode->i_sb, \"ext2_free_branches\",\n\t\t\t\t\t\"Read failure, inode=%ld, block=%ld\",\n\t\t\t\t\tinode->i_ino, nr);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\text2_free_branches(inode,\n\t\t\t\t\t   (__le32*)bh->b_data,\n\t\t\t\t\t   (__le32*)bh->b_data + addr_per_block,\n\t\t\t\t\t   depth);\n\t\t\tbforget(bh);\n\t\t\text2_free_blocks(inode, nr, 1);\n\t\t\tmark_inode_dirty(inode);\n\t\t}\n\t} else\n\t\text2_free_data(inode, p, q);\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "ext2_error",
          "args": [
            "inode->i_sb",
            "\"ext2_free_branches\"",
            "\"Read failure, inode=%ld, block=%ld\"",
            "inode->i_ino",
            "nr"
          ],
          "line": 1071
        },
        "resolved": true,
        "details": {
          "function_name": "ext2_error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext2/super.c",
          "lines": "47-80",
          "snippet": "void ext2_error(struct super_block *sb, const char *function,\n\t\tconst char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\tstruct ext2_sb_info *sbi = EXT2_SB(sb);\n\tstruct ext2_super_block *es = sbi->s_es;\n\n\tif (!(sb->s_flags & MS_RDONLY)) {\n\t\tspin_lock(&sbi->s_lock);\n\t\tsbi->s_mount_state |= EXT2_ERROR_FS;\n\t\tes->s_state |= cpu_to_le16(EXT2_ERROR_FS);\n\t\tspin_unlock(&sbi->s_lock);\n\t\text2_sync_super(sb, es, 1);\n\t}\n\n\tva_start(args, fmt);\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\tprintk(KERN_CRIT \"EXT2-fs (%s): error: %s: %pV\\n\",\n\t       sb->s_id, function, &vaf);\n\n\tva_end(args);\n\n\tif (test_opt(sb, ERRORS_PANIC))\n\t\tpanic(\"EXT2-fs: panic from previous error\\n\");\n\tif (test_opt(sb, ERRORS_RO)) {\n\t\text2_msg(sb, KERN_CRIT,\n\t\t\t     \"error: remounting filesystem read-only\");\n\t\tsb->s_flags |= MS_RDONLY;\n\t}\n}",
          "includes": [
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext2.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/log2.h>",
            "#include <linux/mount.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/vfs.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/random.h>",
            "#include <linux/parser.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/string.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ext2_freeze(struct super_block *sb);",
            "static int ext2_unfreeze(struct super_block *sb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext2.h\"\n#include <asm/uaccess.h>\n#include <linux/quotaops.h>\n#include <linux/log2.h>\n#include <linux/mount.h>\n#include <linux/seq_file.h>\n#include <linux/vfs.h>\n#include <linux/exportfs.h>\n#include <linux/buffer_head.h>\n#include <linux/random.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/string.h>\n#include <linux/module.h>\n\nstatic int ext2_freeze(struct super_block *sb);\nstatic int ext2_unfreeze(struct super_block *sb);\n\nvoid ext2_error(struct super_block *sb, const char *function,\n\t\tconst char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\tstruct ext2_sb_info *sbi = EXT2_SB(sb);\n\tstruct ext2_super_block *es = sbi->s_es;\n\n\tif (!(sb->s_flags & MS_RDONLY)) {\n\t\tspin_lock(&sbi->s_lock);\n\t\tsbi->s_mount_state |= EXT2_ERROR_FS;\n\t\tes->s_state |= cpu_to_le16(EXT2_ERROR_FS);\n\t\tspin_unlock(&sbi->s_lock);\n\t\text2_sync_super(sb, es, 1);\n\t}\n\n\tva_start(args, fmt);\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\tprintk(KERN_CRIT \"EXT2-fs (%s): error: %s: %pV\\n\",\n\t       sb->s_id, function, &vaf);\n\n\tva_end(args);\n\n\tif (test_opt(sb, ERRORS_PANIC))\n\t\tpanic(\"EXT2-fs: panic from previous error\\n\");\n\tif (test_opt(sb, ERRORS_RO)) {\n\t\text2_msg(sb, KERN_CRIT,\n\t\t\t     \"error: remounting filesystem read-only\");\n\t\tsb->s_flags |= MS_RDONLY;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "sb_bread",
          "args": [
            "inode->i_sb",
            "nr"
          ],
          "line": 1065
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "*p"
          ],
          "line": 1061
        },
        "resolved": true,
        "details": {
          "function_name": "sle32_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "53-56",
          "snippet": "static inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "EXT2_ADDR_PER_BLOCK",
          "args": [
            "inode->i_sb"
          ],
          "line": 1059
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xattr.h\"\n#include \"acl.h\"\n#include \"ext2.h\"\n#include <linux/aio.h>\n#include <linux/namei.h>\n#include <linux/fiemap.h>\n#include <linux/mpage.h>\n#include <linux/buffer_head.h>\n#include <linux/writeback.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/highuid.h>\n#include <linux/time.h>\n\nstatic void ext2_free_branches(struct inode *inode, __le32 *p, __le32 *q, int depth)\n{\n\tstruct buffer_head * bh;\n\tunsigned long nr;\n\n\tif (depth--) {\n\t\tint addr_per_block = EXT2_ADDR_PER_BLOCK(inode->i_sb);\n\t\tfor ( ; p < q ; p++) {\n\t\t\tnr = le32_to_cpu(*p);\n\t\t\tif (!nr)\n\t\t\t\tcontinue;\n\t\t\t*p = 0;\n\t\t\tbh = sb_bread(inode->i_sb, nr);\n\t\t\t/*\n\t\t\t * A read failure? Report error and clear slot\n\t\t\t * (should be rare).\n\t\t\t */ \n\t\t\tif (!bh) {\n\t\t\t\text2_error(inode->i_sb, \"ext2_free_branches\",\n\t\t\t\t\t\"Read failure, inode=%ld, block=%ld\",\n\t\t\t\t\tinode->i_ino, nr);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\text2_free_branches(inode,\n\t\t\t\t\t   (__le32*)bh->b_data,\n\t\t\t\t\t   (__le32*)bh->b_data + addr_per_block,\n\t\t\t\t\t   depth);\n\t\t\tbforget(bh);\n\t\t\text2_free_blocks(inode, nr, 1);\n\t\t\tmark_inode_dirty(inode);\n\t\t}\n\t} else\n\t\text2_free_data(inode, p, q);\n}"
  },
  {
    "function_name": "ext2_free_data",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext2/inode.c",
    "lines": "1013-1040",
    "snippet": "static inline void ext2_free_data(struct inode *inode, __le32 *p, __le32 *q)\n{\n\tunsigned long block_to_free = 0, count = 0;\n\tunsigned long nr;\n\n\tfor ( ; p < q ; p++) {\n\t\tnr = le32_to_cpu(*p);\n\t\tif (nr) {\n\t\t\t*p = 0;\n\t\t\t/* accumulate blocks to free if they're contiguous */\n\t\t\tif (count == 0)\n\t\t\t\tgoto free_this;\n\t\t\telse if (block_to_free == nr - count)\n\t\t\t\tcount++;\n\t\t\telse {\n\t\t\t\text2_free_blocks (inode, block_to_free, count);\n\t\t\t\tmark_inode_dirty(inode);\n\t\t\tfree_this:\n\t\t\t\tblock_to_free = nr;\n\t\t\t\tcount = 1;\n\t\t\t}\n\t\t}\n\t}\n\tif (count > 0) {\n\t\text2_free_blocks (inode, block_to_free, count);\n\t\tmark_inode_dirty(inode);\n\t}\n}",
    "includes": [
      "#include \"xattr.h\"",
      "#include \"acl.h\"",
      "#include \"ext2.h\"",
      "#include <linux/aio.h>",
      "#include <linux/namei.h>",
      "#include <linux/fiemap.h>",
      "#include <linux/mpage.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/writeback.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/highuid.h>",
      "#include <linux/time.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mark_inode_dirty",
          "args": [
            "inode"
          ],
          "line": 1038
        },
        "resolved": true,
        "details": {
          "function_name": "block_dump___mark_inode_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fs-writeback.c",
          "lines": "1134-1154",
          "snippet": "static noinline void block_dump___mark_inode_dirty(struct inode *inode)\n{\n\tif (inode->i_ino || strcmp(inode->i_sb->s_id, \"bdev\")) {\n\t\tstruct dentry *dentry;\n\t\tconst char *name = \"?\";\n\n\t\tdentry = d_find_alias(inode);\n\t\tif (dentry) {\n\t\t\tspin_lock(&dentry->d_lock);\n\t\t\tname = (const char *) dentry->d_name.name;\n\t\t}\n\t\tprintk(KERN_DEBUG\n\t\t       \"%s(%d): dirtied inode %lu (%s) on %s\\n\",\n\t\t       current->comm, task_pid_nr(current), inode->i_ino,\n\t\t       name, inode->i_sb->s_id);\n\t\tif (dentry) {\n\t\t\tspin_unlock(&dentry->d_lock);\n\t\t\tdput(dentry);\n\t\t}\n\t}\n}",
          "includes": [
            "#include <trace/events/writeback.h>",
            "#include \"internal.h\"",
            "#include <linux/device.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/writeback.h>\n#include \"internal.h\"\n#include <linux/device.h>\n#include <linux/tracepoint.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nstatic noinline void block_dump___mark_inode_dirty(struct inode *inode)\n{\n\tif (inode->i_ino || strcmp(inode->i_sb->s_id, \"bdev\")) {\n\t\tstruct dentry *dentry;\n\t\tconst char *name = \"?\";\n\n\t\tdentry = d_find_alias(inode);\n\t\tif (dentry) {\n\t\t\tspin_lock(&dentry->d_lock);\n\t\t\tname = (const char *) dentry->d_name.name;\n\t\t}\n\t\tprintk(KERN_DEBUG\n\t\t       \"%s(%d): dirtied inode %lu (%s) on %s\\n\",\n\t\t       current->comm, task_pid_nr(current), inode->i_ino,\n\t\t       name, inode->i_sb->s_id);\n\t\tif (dentry) {\n\t\t\tspin_unlock(&dentry->d_lock);\n\t\t\tdput(dentry);\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext2_free_blocks",
          "args": [
            "inode",
            "block_to_free",
            "count"
          ],
          "line": 1037
        },
        "resolved": true,
        "details": {
          "function_name": "ext2_free_blocks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext2/balloc.c",
          "lines": "476-567",
          "snippet": "void ext2_free_blocks (struct inode * inode, unsigned long block,\n\t\t       unsigned long count)\n{\n\tstruct buffer_head *bitmap_bh = NULL;\n\tstruct buffer_head * bh2;\n\tunsigned long block_group;\n\tunsigned long bit;\n\tunsigned long i;\n\tunsigned long overflow;\n\tstruct super_block * sb = inode->i_sb;\n\tstruct ext2_sb_info * sbi = EXT2_SB(sb);\n\tstruct ext2_group_desc * desc;\n\tstruct ext2_super_block * es = sbi->s_es;\n\tunsigned freed = 0, group_freed;\n\n\tif (block < le32_to_cpu(es->s_first_data_block) ||\n\t    block + count < block ||\n\t    block + count > le32_to_cpu(es->s_blocks_count)) {\n\t\text2_error (sb, \"ext2_free_blocks\",\n\t\t\t    \"Freeing blocks not in datazone - \"\n\t\t\t    \"block = %lu, count = %lu\", block, count);\n\t\tgoto error_return;\n\t}\n\n\text2_debug (\"freeing block(s) %lu-%lu\\n\", block, block + count - 1);\n\ndo_more:\n\toverflow = 0;\n\tblock_group = (block - le32_to_cpu(es->s_first_data_block)) /\n\t\t      EXT2_BLOCKS_PER_GROUP(sb);\n\tbit = (block - le32_to_cpu(es->s_first_data_block)) %\n\t\t      EXT2_BLOCKS_PER_GROUP(sb);\n\t/*\n\t * Check to see if we are freeing blocks across a group\n\t * boundary.\n\t */\n\tif (bit + count > EXT2_BLOCKS_PER_GROUP(sb)) {\n\t\toverflow = bit + count - EXT2_BLOCKS_PER_GROUP(sb);\n\t\tcount -= overflow;\n\t}\n\tbrelse(bitmap_bh);\n\tbitmap_bh = read_block_bitmap(sb, block_group);\n\tif (!bitmap_bh)\n\t\tgoto error_return;\n\n\tdesc = ext2_get_group_desc (sb, block_group, &bh2);\n\tif (!desc)\n\t\tgoto error_return;\n\n\tif (in_range (le32_to_cpu(desc->bg_block_bitmap), block, count) ||\n\t    in_range (le32_to_cpu(desc->bg_inode_bitmap), block, count) ||\n\t    in_range (block, le32_to_cpu(desc->bg_inode_table),\n\t\t      sbi->s_itb_per_group) ||\n\t    in_range (block + count - 1, le32_to_cpu(desc->bg_inode_table),\n\t\t      sbi->s_itb_per_group)) {\n\t\text2_error (sb, \"ext2_free_blocks\",\n\t\t\t    \"Freeing blocks in system zones - \"\n\t\t\t    \"Block = %lu, count = %lu\",\n\t\t\t    block, count);\n\t\tgoto error_return;\n\t}\n\n\tfor (i = 0, group_freed = 0; i < count; i++) {\n\t\tif (!ext2_clear_bit_atomic(sb_bgl_lock(sbi, block_group),\n\t\t\t\t\t\tbit + i, bitmap_bh->b_data)) {\n\t\t\text2_error(sb, __func__,\n\t\t\t\t\"bit already cleared for block %lu\", block + i);\n\t\t} else {\n\t\t\tgroup_freed++;\n\t\t}\n\t}\n\n\tmark_buffer_dirty(bitmap_bh);\n\tif (sb->s_flags & MS_SYNCHRONOUS)\n\t\tsync_dirty_buffer(bitmap_bh);\n\n\tgroup_adjust_blocks(sb, block_group, desc, bh2, group_freed);\n\tfreed += group_freed;\n\n\tif (overflow) {\n\t\tblock += count;\n\t\tcount = overflow;\n\t\tgoto do_more;\n\t}\nerror_return:\n\tbrelse(bitmap_bh);\n\tif (freed) {\n\t\tpercpu_counter_add(&sbi->s_freeblocks_counter, freed);\n\t\tdquot_free_block_nodirty(inode, freed);\n\t\tmark_inode_dirty(inode);\n\t}\n}",
          "includes": [
            "#include <linux/capability.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/quotaops.h>",
            "#include \"ext2.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/capability.h>\n#include <linux/buffer_head.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/quotaops.h>\n#include \"ext2.h\"\n\nvoid ext2_free_blocks (struct inode * inode, unsigned long block,\n\t\t       unsigned long count)\n{\n\tstruct buffer_head *bitmap_bh = NULL;\n\tstruct buffer_head * bh2;\n\tunsigned long block_group;\n\tunsigned long bit;\n\tunsigned long i;\n\tunsigned long overflow;\n\tstruct super_block * sb = inode->i_sb;\n\tstruct ext2_sb_info * sbi = EXT2_SB(sb);\n\tstruct ext2_group_desc * desc;\n\tstruct ext2_super_block * es = sbi->s_es;\n\tunsigned freed = 0, group_freed;\n\n\tif (block < le32_to_cpu(es->s_first_data_block) ||\n\t    block + count < block ||\n\t    block + count > le32_to_cpu(es->s_blocks_count)) {\n\t\text2_error (sb, \"ext2_free_blocks\",\n\t\t\t    \"Freeing blocks not in datazone - \"\n\t\t\t    \"block = %lu, count = %lu\", block, count);\n\t\tgoto error_return;\n\t}\n\n\text2_debug (\"freeing block(s) %lu-%lu\\n\", block, block + count - 1);\n\ndo_more:\n\toverflow = 0;\n\tblock_group = (block - le32_to_cpu(es->s_first_data_block)) /\n\t\t      EXT2_BLOCKS_PER_GROUP(sb);\n\tbit = (block - le32_to_cpu(es->s_first_data_block)) %\n\t\t      EXT2_BLOCKS_PER_GROUP(sb);\n\t/*\n\t * Check to see if we are freeing blocks across a group\n\t * boundary.\n\t */\n\tif (bit + count > EXT2_BLOCKS_PER_GROUP(sb)) {\n\t\toverflow = bit + count - EXT2_BLOCKS_PER_GROUP(sb);\n\t\tcount -= overflow;\n\t}\n\tbrelse(bitmap_bh);\n\tbitmap_bh = read_block_bitmap(sb, block_group);\n\tif (!bitmap_bh)\n\t\tgoto error_return;\n\n\tdesc = ext2_get_group_desc (sb, block_group, &bh2);\n\tif (!desc)\n\t\tgoto error_return;\n\n\tif (in_range (le32_to_cpu(desc->bg_block_bitmap), block, count) ||\n\t    in_range (le32_to_cpu(desc->bg_inode_bitmap), block, count) ||\n\t    in_range (block, le32_to_cpu(desc->bg_inode_table),\n\t\t      sbi->s_itb_per_group) ||\n\t    in_range (block + count - 1, le32_to_cpu(desc->bg_inode_table),\n\t\t      sbi->s_itb_per_group)) {\n\t\text2_error (sb, \"ext2_free_blocks\",\n\t\t\t    \"Freeing blocks in system zones - \"\n\t\t\t    \"Block = %lu, count = %lu\",\n\t\t\t    block, count);\n\t\tgoto error_return;\n\t}\n\n\tfor (i = 0, group_freed = 0; i < count; i++) {\n\t\tif (!ext2_clear_bit_atomic(sb_bgl_lock(sbi, block_group),\n\t\t\t\t\t\tbit + i, bitmap_bh->b_data)) {\n\t\t\text2_error(sb, __func__,\n\t\t\t\t\"bit already cleared for block %lu\", block + i);\n\t\t} else {\n\t\t\tgroup_freed++;\n\t\t}\n\t}\n\n\tmark_buffer_dirty(bitmap_bh);\n\tif (sb->s_flags & MS_SYNCHRONOUS)\n\t\tsync_dirty_buffer(bitmap_bh);\n\n\tgroup_adjust_blocks(sb, block_group, desc, bh2, group_freed);\n\tfreed += group_freed;\n\n\tif (overflow) {\n\t\tblock += count;\n\t\tcount = overflow;\n\t\tgoto do_more;\n\t}\nerror_return:\n\tbrelse(bitmap_bh);\n\tif (freed) {\n\t\tpercpu_counter_add(&sbi->s_freeblocks_counter, freed);\n\t\tdquot_free_block_nodirty(inode, freed);\n\t\tmark_inode_dirty(inode);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "*p"
          ],
          "line": 1019
        },
        "resolved": true,
        "details": {
          "function_name": "sle32_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "53-56",
          "snippet": "static inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"xattr.h\"\n#include \"acl.h\"\n#include \"ext2.h\"\n#include <linux/aio.h>\n#include <linux/namei.h>\n#include <linux/fiemap.h>\n#include <linux/mpage.h>\n#include <linux/buffer_head.h>\n#include <linux/writeback.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/highuid.h>\n#include <linux/time.h>\n\nstatic inline void ext2_free_data(struct inode *inode, __le32 *p, __le32 *q)\n{\n\tunsigned long block_to_free = 0, count = 0;\n\tunsigned long nr;\n\n\tfor ( ; p < q ; p++) {\n\t\tnr = le32_to_cpu(*p);\n\t\tif (nr) {\n\t\t\t*p = 0;\n\t\t\t/* accumulate blocks to free if they're contiguous */\n\t\t\tif (count == 0)\n\t\t\t\tgoto free_this;\n\t\t\telse if (block_to_free == nr - count)\n\t\t\t\tcount++;\n\t\t\telse {\n\t\t\t\text2_free_blocks (inode, block_to_free, count);\n\t\t\t\tmark_inode_dirty(inode);\n\t\t\tfree_this:\n\t\t\t\tblock_to_free = nr;\n\t\t\t\tcount = 1;\n\t\t\t}\n\t\t}\n\t}\n\tif (count > 0) {\n\t\text2_free_blocks (inode, block_to_free, count);\n\t\tmark_inode_dirty(inode);\n\t}\n}"
  },
  {
    "function_name": "ext2_find_shared",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext2/inode.c",
    "lines": "954-1001",
    "snippet": "static Indirect *ext2_find_shared(struct inode *inode,\n\t\t\t\tint depth,\n\t\t\t\tint offsets[4],\n\t\t\t\tIndirect chain[4],\n\t\t\t\t__le32 *top)\n{\n\tIndirect *partial, *p;\n\tint k, err;\n\n\t*top = 0;\n\tfor (k = depth; k > 1 && !offsets[k-1]; k--)\n\t\t;\n\tpartial = ext2_get_branch(inode, k, offsets, chain, &err);\n\tif (!partial)\n\t\tpartial = chain + k-1;\n\t/*\n\t * If the branch acquired continuation since we've looked at it -\n\t * fine, it should all survive and (new) top doesn't belong to us.\n\t */\n\twrite_lock(&EXT2_I(inode)->i_meta_lock);\n\tif (!partial->key && *partial->p) {\n\t\twrite_unlock(&EXT2_I(inode)->i_meta_lock);\n\t\tgoto no_top;\n\t}\n\tfor (p=partial; p>chain && all_zeroes((__le32*)p->bh->b_data,p->p); p--)\n\t\t;\n\t/*\n\t * OK, we've found the last block that must survive. The rest of our\n\t * branch should be detached before unlocking. However, if that rest\n\t * of branch is all ours and does not grow immediately from the inode\n\t * it's easier to cheat and just decrement partial->p.\n\t */\n\tif (p == chain + k - 1 && p > chain) {\n\t\tp->p--;\n\t} else {\n\t\t*top = *p->p;\n\t\t*p->p = 0;\n\t}\n\twrite_unlock(&EXT2_I(inode)->i_meta_lock);\n\n\twhile(partial > p)\n\t{\n\t\tbrelse(partial->bh);\n\t\tpartial--;\n\t}\nno_top:\n\treturn partial;\n}",
    "includes": [
      "#include \"xattr.h\"",
      "#include \"acl.h\"",
      "#include \"ext2.h\"",
      "#include <linux/aio.h>",
      "#include <linux/namei.h>",
      "#include <linux/fiemap.h>",
      "#include <linux/mpage.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/writeback.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/highuid.h>",
      "#include <linux/time.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "brelse",
          "args": [
            "partial->bh"
          ],
          "line": 996
        },
        "resolved": true,
        "details": {
          "function_name": "__brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1177-1184",
          "snippet": "void __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "write_unlock",
          "args": [
            "&EXT2_I(inode)->i_meta_lock"
          ],
          "line": 992
        },
        "resolved": true,
        "details": {
          "function_name": "reiserfs_write_unlock_nested",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/lock.c",
          "lines": "51-67",
          "snippet": "int __must_check reiserfs_write_unlock_nested(struct super_block *s)\n{\n\tstruct reiserfs_sb_info *sb_i = REISERFS_SB(s);\n\tint depth;\n\n\t/* this can happen when the lock isn't always held */\n\tif (sb_i->lock_owner != current)\n\t\treturn -1;\n\n\tdepth = sb_i->lock_depth;\n\n\tsb_i->lock_depth = -1;\n\tsb_i->lock_owner = NULL;\n\tmutex_unlock(&sb_i->lock);\n\n\treturn depth;\n}",
          "includes": [
            "#include <linux/mutex.h>",
            "#include \"reiserfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/mutex.h>\n#include \"reiserfs.h\"\n\nint __must_check reiserfs_write_unlock_nested(struct super_block *s)\n{\n\tstruct reiserfs_sb_info *sb_i = REISERFS_SB(s);\n\tint depth;\n\n\t/* this can happen when the lock isn't always held */\n\tif (sb_i->lock_owner != current)\n\t\treturn -1;\n\n\tdepth = sb_i->lock_depth;\n\n\tsb_i->lock_depth = -1;\n\tsb_i->lock_owner = NULL;\n\tmutex_unlock(&sb_i->lock);\n\n\treturn depth;\n}"
        }
      },
      {
        "call_info": {
          "callee": "EXT2_I",
          "args": [
            "inode"
          ],
          "line": 992
        },
        "resolved": true,
        "details": {
          "function_name": "EXT2_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext2/ext2.h",
          "lines": "717-720",
          "snippet": "static inline struct ext2_inode_info *EXT2_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ext2_inode_info, vfs_inode);\n}",
          "includes": [
            "#include <linux/rbtree.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/ext2_fs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern ext2_fsblk_t ext2_new_block(struct inode *, unsigned long, int *);",
            "extern ext2_fsblk_t ext2_new_blocks(struct inode *, unsigned long,\n\t\t\t\tunsigned long *, int *);",
            "extern void ext2_free_blocks (struct inode *, unsigned long,\n\t\t\t      unsigned long);",
            "extern void ext2_discard_reservation (struct inode *);",
            "extern void ext2_init_block_alloc_info(struct inode *);",
            "extern int ext2_add_link (struct dentry *, struct inode *);",
            "extern int ext2_make_empty(struct inode *, struct inode *);",
            "extern int ext2_empty_dir (struct inode *);",
            "extern void ext2_set_link(struct inode *, struct ext2_dir_entry_2 *, struct page *, struct inode *, int);",
            "extern void ext2_free_inode (struct inode *);",
            "extern void ext2_evict_inode(struct inode *);",
            "extern void ext2_set_inode_flags(struct inode *inode);",
            "extern void ext2_get_inode_flags(struct ext2_inode_info *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rbtree.h>\n#include <linux/percpu_counter.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/ext2_fs.h>\n#include <linux/fs.h>\n\nextern ext2_fsblk_t ext2_new_block(struct inode *, unsigned long, int *);\nextern ext2_fsblk_t ext2_new_blocks(struct inode *, unsigned long,\n\t\t\t\tunsigned long *, int *);\nextern void ext2_free_blocks (struct inode *, unsigned long,\n\t\t\t      unsigned long);\nextern void ext2_discard_reservation (struct inode *);\nextern void ext2_init_block_alloc_info(struct inode *);\nextern int ext2_add_link (struct dentry *, struct inode *);\nextern int ext2_make_empty(struct inode *, struct inode *);\nextern int ext2_empty_dir (struct inode *);\nextern void ext2_set_link(struct inode *, struct ext2_dir_entry_2 *, struct page *, struct inode *, int);\nextern void ext2_free_inode (struct inode *);\nextern void ext2_evict_inode(struct inode *);\nextern void ext2_set_inode_flags(struct inode *inode);\nextern void ext2_get_inode_flags(struct ext2_inode_info *);\n\nstatic inline struct ext2_inode_info *EXT2_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ext2_inode_info, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "all_zeroes",
          "args": [
            "(__le32*)p->bh->b_data",
            "p->p"
          ],
          "line": 978
        },
        "resolved": true,
        "details": {
          "function_name": "all_zeroes",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext2/inode.c",
          "lines": "912-918",
          "snippet": "static inline int all_zeroes(__le32 *p, __le32 *q)\n{\n\twhile (p < q)\n\t\tif (*p++)\n\t\t\treturn 0;\n\treturn 1;\n}",
          "includes": [
            "#include \"xattr.h\"",
            "#include \"acl.h\"",
            "#include \"ext2.h\"",
            "#include <linux/aio.h>",
            "#include <linux/namei.h>",
            "#include <linux/fiemap.h>",
            "#include <linux/mpage.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/writeback.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highuid.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xattr.h\"\n#include \"acl.h\"\n#include \"ext2.h\"\n#include <linux/aio.h>\n#include <linux/namei.h>\n#include <linux/fiemap.h>\n#include <linux/mpage.h>\n#include <linux/buffer_head.h>\n#include <linux/writeback.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/highuid.h>\n#include <linux/time.h>\n\nstatic inline int all_zeroes(__le32 *p, __le32 *q)\n{\n\twhile (p < q)\n\t\tif (*p++)\n\t\t\treturn 0;\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "write_lock",
          "args": [
            "&EXT2_I(inode)->i_meta_lock"
          ],
          "line": 973
        },
        "resolved": true,
        "details": {
          "function_name": "reiserfs_write_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/lock.c",
          "lines": "21-32",
          "snippet": "void reiserfs_write_lock(struct super_block *s)\n{\n\tstruct reiserfs_sb_info *sb_i = REISERFS_SB(s);\n\n\tif (sb_i->lock_owner != current) {\n\t\tmutex_lock(&sb_i->lock);\n\t\tsb_i->lock_owner = current;\n\t}\n\n\t/* No need to protect it, only the current task touches it */\n\tsb_i->lock_depth++;\n}",
          "includes": [
            "#include <linux/mutex.h>",
            "#include \"reiserfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/mutex.h>\n#include \"reiserfs.h\"\n\nvoid reiserfs_write_lock(struct super_block *s)\n{\n\tstruct reiserfs_sb_info *sb_i = REISERFS_SB(s);\n\n\tif (sb_i->lock_owner != current) {\n\t\tmutex_lock(&sb_i->lock);\n\t\tsb_i->lock_owner = current;\n\t}\n\n\t/* No need to protect it, only the current task touches it */\n\tsb_i->lock_depth++;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext2_get_branch",
          "args": [
            "inode",
            "k",
            "offsets",
            "chain",
            "&err"
          ],
          "line": 966
        },
        "resolved": true,
        "details": {
          "function_name": "ext2_get_branch",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext2/inode.c",
          "lines": "230-268",
          "snippet": "static Indirect *ext2_get_branch(struct inode *inode,\n\t\t\t\t int depth,\n\t\t\t\t int *offsets,\n\t\t\t\t Indirect chain[4],\n\t\t\t\t int *err)\n{\n\tstruct super_block *sb = inode->i_sb;\n\tIndirect *p = chain;\n\tstruct buffer_head *bh;\n\n\t*err = 0;\n\t/* i_data is not going away, no lock needed */\n\tadd_chain (chain, NULL, EXT2_I(inode)->i_data + *offsets);\n\tif (!p->key)\n\t\tgoto no_block;\n\twhile (--depth) {\n\t\tbh = sb_bread(sb, le32_to_cpu(p->key));\n\t\tif (!bh)\n\t\t\tgoto failure;\n\t\tread_lock(&EXT2_I(inode)->i_meta_lock);\n\t\tif (!verify_chain(chain, p))\n\t\t\tgoto changed;\n\t\tadd_chain(++p, bh, (__le32*)bh->b_data + *++offsets);\n\t\tread_unlock(&EXT2_I(inode)->i_meta_lock);\n\t\tif (!p->key)\n\t\t\tgoto no_block;\n\t}\n\treturn NULL;\n\nchanged:\n\tread_unlock(&EXT2_I(inode)->i_meta_lock);\n\tbrelse(bh);\n\t*err = -EAGAIN;\n\tgoto no_block;\nfailure:\n\t*err = -EIO;\nno_block:\n\treturn p;\n}",
          "includes": [
            "#include \"xattr.h\"",
            "#include \"acl.h\"",
            "#include \"ext2.h\"",
            "#include <linux/aio.h>",
            "#include <linux/namei.h>",
            "#include <linux/fiemap.h>",
            "#include <linux/mpage.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/writeback.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highuid.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xattr.h\"\n#include \"acl.h\"\n#include \"ext2.h\"\n#include <linux/aio.h>\n#include <linux/namei.h>\n#include <linux/fiemap.h>\n#include <linux/mpage.h>\n#include <linux/buffer_head.h>\n#include <linux/writeback.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/highuid.h>\n#include <linux/time.h>\n\nstatic Indirect *ext2_get_branch(struct inode *inode,\n\t\t\t\t int depth,\n\t\t\t\t int *offsets,\n\t\t\t\t Indirect chain[4],\n\t\t\t\t int *err)\n{\n\tstruct super_block *sb = inode->i_sb;\n\tIndirect *p = chain;\n\tstruct buffer_head *bh;\n\n\t*err = 0;\n\t/* i_data is not going away, no lock needed */\n\tadd_chain (chain, NULL, EXT2_I(inode)->i_data + *offsets);\n\tif (!p->key)\n\t\tgoto no_block;\n\twhile (--depth) {\n\t\tbh = sb_bread(sb, le32_to_cpu(p->key));\n\t\tif (!bh)\n\t\t\tgoto failure;\n\t\tread_lock(&EXT2_I(inode)->i_meta_lock);\n\t\tif (!verify_chain(chain, p))\n\t\t\tgoto changed;\n\t\tadd_chain(++p, bh, (__le32*)bh->b_data + *++offsets);\n\t\tread_unlock(&EXT2_I(inode)->i_meta_lock);\n\t\tif (!p->key)\n\t\t\tgoto no_block;\n\t}\n\treturn NULL;\n\nchanged:\n\tread_unlock(&EXT2_I(inode)->i_meta_lock);\n\tbrelse(bh);\n\t*err = -EAGAIN;\n\tgoto no_block;\nfailure:\n\t*err = -EIO;\nno_block:\n\treturn p;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"xattr.h\"\n#include \"acl.h\"\n#include \"ext2.h\"\n#include <linux/aio.h>\n#include <linux/namei.h>\n#include <linux/fiemap.h>\n#include <linux/mpage.h>\n#include <linux/buffer_head.h>\n#include <linux/writeback.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/highuid.h>\n#include <linux/time.h>\n\nstatic Indirect *ext2_find_shared(struct inode *inode,\n\t\t\t\tint depth,\n\t\t\t\tint offsets[4],\n\t\t\t\tIndirect chain[4],\n\t\t\t\t__le32 *top)\n{\n\tIndirect *partial, *p;\n\tint k, err;\n\n\t*top = 0;\n\tfor (k = depth; k > 1 && !offsets[k-1]; k--)\n\t\t;\n\tpartial = ext2_get_branch(inode, k, offsets, chain, &err);\n\tif (!partial)\n\t\tpartial = chain + k-1;\n\t/*\n\t * If the branch acquired continuation since we've looked at it -\n\t * fine, it should all survive and (new) top doesn't belong to us.\n\t */\n\twrite_lock(&EXT2_I(inode)->i_meta_lock);\n\tif (!partial->key && *partial->p) {\n\t\twrite_unlock(&EXT2_I(inode)->i_meta_lock);\n\t\tgoto no_top;\n\t}\n\tfor (p=partial; p>chain && all_zeroes((__le32*)p->bh->b_data,p->p); p--)\n\t\t;\n\t/*\n\t * OK, we've found the last block that must survive. The rest of our\n\t * branch should be detached before unlocking. However, if that rest\n\t * of branch is all ours and does not grow immediately from the inode\n\t * it's easier to cheat and just decrement partial->p.\n\t */\n\tif (p == chain + k - 1 && p > chain) {\n\t\tp->p--;\n\t} else {\n\t\t*top = *p->p;\n\t\t*p->p = 0;\n\t}\n\twrite_unlock(&EXT2_I(inode)->i_meta_lock);\n\n\twhile(partial > p)\n\t{\n\t\tbrelse(partial->bh);\n\t\tpartial--;\n\t}\nno_top:\n\treturn partial;\n}"
  },
  {
    "function_name": "all_zeroes",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext2/inode.c",
    "lines": "912-918",
    "snippet": "static inline int all_zeroes(__le32 *p, __le32 *q)\n{\n\twhile (p < q)\n\t\tif (*p++)\n\t\t\treturn 0;\n\treturn 1;\n}",
    "includes": [
      "#include \"xattr.h\"",
      "#include \"acl.h\"",
      "#include \"ext2.h\"",
      "#include <linux/aio.h>",
      "#include <linux/namei.h>",
      "#include <linux/fiemap.h>",
      "#include <linux/mpage.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/writeback.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/highuid.h>",
      "#include <linux/time.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"xattr.h\"\n#include \"acl.h\"\n#include \"ext2.h\"\n#include <linux/aio.h>\n#include <linux/namei.h>\n#include <linux/fiemap.h>\n#include <linux/mpage.h>\n#include <linux/buffer_head.h>\n#include <linux/writeback.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/highuid.h>\n#include <linux/time.h>\n\nstatic inline int all_zeroes(__le32 *p, __le32 *q)\n{\n\twhile (p < q)\n\t\tif (*p++)\n\t\t\treturn 0;\n\treturn 1;\n}"
  },
  {
    "function_name": "ext2_writepages",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext2/inode.c",
    "lines": "874-878",
    "snippet": "static int\next2_writepages(struct address_space *mapping, struct writeback_control *wbc)\n{\n\treturn mpage_writepages(mapping, wbc, ext2_get_block);\n}",
    "includes": [
      "#include \"xattr.h\"",
      "#include \"acl.h\"",
      "#include \"ext2.h\"",
      "#include <linux/aio.h>",
      "#include <linux/namei.h>",
      "#include <linux/fiemap.h>",
      "#include <linux/mpage.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/writeback.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/highuid.h>",
      "#include <linux/time.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mpage_writepages",
          "args": [
            "mapping",
            "wbc",
            "ext2_get_block"
          ],
          "line": 877
        },
        "resolved": true,
        "details": {
          "function_name": "mpage_writepages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mpage.c",
          "lines": "675-700",
          "snippet": "int\nmpage_writepages(struct address_space *mapping,\n\t\tstruct writeback_control *wbc, get_block_t get_block)\n{\n\tstruct blk_plug plug;\n\tint ret;\n\n\tblk_start_plug(&plug);\n\n\tif (!get_block)\n\t\tret = generic_writepages(mapping, wbc);\n\telse {\n\t\tstruct mpage_data mpd = {\n\t\t\t.bio = NULL,\n\t\t\t.last_block_in_bio = 0,\n\t\t\t.get_block = get_block,\n\t\t\t.use_writepage = 1,\n\t\t};\n\n\t\tret = write_cache_pages(mapping, wbc, __mpage_writepage, &mpd);\n\t\tif (mpd.bio)\n\t\t\tmpage_bio_submit(WRITE, mpd.bio);\n\t}\n\tblk_finish_plug(&plug);\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/cleancache.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/mpage.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/highmem.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/fs.h>",
            "#include <linux/bio.h>",
            "#include <linux/gfp.h>",
            "#include <linux/kdev_t.h>",
            "#include <linux/mm.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/cleancache.h>\n#include <linux/pagevec.h>\n#include <linux/backing-dev.h>\n#include <linux/writeback.h>\n#include <linux/mpage.h>\n#include <linux/prefetch.h>\n#include <linux/highmem.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/fs.h>\n#include <linux/bio.h>\n#include <linux/gfp.h>\n#include <linux/kdev_t.h>\n#include <linux/mm.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nint\nmpage_writepages(struct address_space *mapping,\n\t\tstruct writeback_control *wbc, get_block_t get_block)\n{\n\tstruct blk_plug plug;\n\tint ret;\n\n\tblk_start_plug(&plug);\n\n\tif (!get_block)\n\t\tret = generic_writepages(mapping, wbc);\n\telse {\n\t\tstruct mpage_data mpd = {\n\t\t\t.bio = NULL,\n\t\t\t.last_block_in_bio = 0,\n\t\t\t.get_block = get_block,\n\t\t\t.use_writepage = 1,\n\t\t};\n\n\t\tret = write_cache_pages(mapping, wbc, __mpage_writepage, &mpd);\n\t\tif (mpd.bio)\n\t\t\tmpage_bio_submit(WRITE, mpd.bio);\n\t}\n\tblk_finish_plug(&plug);\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"xattr.h\"\n#include \"acl.h\"\n#include \"ext2.h\"\n#include <linux/aio.h>\n#include <linux/namei.h>\n#include <linux/fiemap.h>\n#include <linux/mpage.h>\n#include <linux/buffer_head.h>\n#include <linux/writeback.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/highuid.h>\n#include <linux/time.h>\n\nstatic int\next2_writepages(struct address_space *mapping, struct writeback_control *wbc)\n{\n\treturn mpage_writepages(mapping, wbc, ext2_get_block);\n}"
  },
  {
    "function_name": "ext2_direct_IO",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext2/inode.c",
    "lines": "853-872",
    "snippet": "static ssize_t\next2_direct_IO(int rw, struct kiocb *iocb, struct iov_iter *iter,\n\t\t\tloff_t offset)\n{\n\tstruct file *file = iocb->ki_filp;\n\tstruct address_space *mapping = file->f_mapping;\n\tstruct inode *inode = mapping->host;\n\tsize_t count = iov_iter_count(iter);\n\tssize_t ret;\n\n\tif (IS_DAX(inode))\n\t\tret = dax_do_io(rw, iocb, inode, iter, offset, ext2_get_block,\n\t\t\t\tNULL, DIO_LOCKING);\n\telse\n\t\tret = blockdev_direct_IO(rw, iocb, inode, iter, offset,\n\t\t\t\t\t ext2_get_block);\n\tif (ret < 0 && (rw & WRITE))\n\t\text2_write_failed(mapping, offset + count);\n\treturn ret;\n}",
    "includes": [
      "#include \"xattr.h\"",
      "#include \"acl.h\"",
      "#include \"ext2.h\"",
      "#include <linux/aio.h>",
      "#include <linux/namei.h>",
      "#include <linux/fiemap.h>",
      "#include <linux/mpage.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/writeback.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/highuid.h>",
      "#include <linux/time.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void ext2_truncate_blocks(struct inode *inode, loff_t offset);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ext2_write_failed",
          "args": [
            "mapping",
            "offset + count"
          ],
          "line": 870
        },
        "resolved": true,
        "details": {
          "function_name": "ext2_write_failed",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext2/inode.c",
          "lines": "55-63",
          "snippet": "static void ext2_write_failed(struct address_space *mapping, loff_t to)\n{\n\tstruct inode *inode = mapping->host;\n\n\tif (to > inode->i_size) {\n\t\ttruncate_pagecache(inode, inode->i_size);\n\t\text2_truncate_blocks(inode, inode->i_size);\n\t}\n}",
          "includes": [
            "#include \"xattr.h\"",
            "#include \"acl.h\"",
            "#include \"ext2.h\"",
            "#include <linux/aio.h>",
            "#include <linux/namei.h>",
            "#include <linux/fiemap.h>",
            "#include <linux/mpage.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/writeback.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highuid.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xattr.h\"\n#include \"acl.h\"\n#include \"ext2.h\"\n#include <linux/aio.h>\n#include <linux/namei.h>\n#include <linux/fiemap.h>\n#include <linux/mpage.h>\n#include <linux/buffer_head.h>\n#include <linux/writeback.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/highuid.h>\n#include <linux/time.h>\n\nstatic void ext2_write_failed(struct address_space *mapping, loff_t to)\n{\n\tstruct inode *inode = mapping->host;\n\n\tif (to > inode->i_size) {\n\t\ttruncate_pagecache(inode, inode->i_size);\n\t\text2_truncate_blocks(inode, inode->i_size);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "blockdev_direct_IO",
          "args": [
            "rw",
            "iocb",
            "inode",
            "iter",
            "offset",
            "ext2_get_block"
          ],
          "line": 867
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dax_do_io",
          "args": [
            "rw",
            "iocb",
            "inode",
            "iter",
            "offset",
            "ext2_get_block",
            "NULL",
            "DIO_LOCKING"
          ],
          "line": 864
        },
        "resolved": true,
        "details": {
          "function_name": "dax_do_io",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dax.c",
          "lines": "192-226",
          "snippet": "ssize_t dax_do_io(int rw, struct kiocb *iocb, struct inode *inode,\n\t\t\tstruct iov_iter *iter, loff_t pos,\n\t\t\tget_block_t get_block, dio_iodone_t end_io, int flags)\n{\n\tstruct buffer_head bh;\n\tssize_t retval = -EINVAL;\n\tloff_t end = pos + iov_iter_count(iter);\n\n\tmemset(&bh, 0, sizeof(bh));\n\n\tif ((flags & DIO_LOCKING) && (rw == READ)) {\n\t\tstruct address_space *mapping = inode->i_mapping;\n\t\tmutex_lock(&inode->i_mutex);\n\t\tretval = filemap_write_and_wait_range(mapping, pos, end - 1);\n\t\tif (retval) {\n\t\t\tmutex_unlock(&inode->i_mutex);\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\t/* Protects against truncate */\n\tatomic_inc(&inode->i_dio_count);\n\n\tretval = dax_io(rw, inode, iter, pos, end, get_block, &bh);\n\n\tif ((flags & DIO_LOCKING) && (rw == READ))\n\t\tmutex_unlock(&inode->i_mutex);\n\n\tif ((retval > 0) && end_io)\n\t\tend_io(iocb, pos, retval, bh.b_private);\n\n\tinode_dio_done(inode);\n out:\n\treturn retval;\n}",
          "includes": [
            "#include <linux/vmstat.h>",
            "#include <linux/uio.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>",
            "#include <linux/mm.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/highmem.h>",
            "#include <linux/genhd.h>",
            "#include <linux/fs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/atomic.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/vmstat.h>\n#include <linux/uio.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n#include <linux/mm.h>\n#include <linux/memcontrol.h>\n#include <linux/highmem.h>\n#include <linux/genhd.h>\n#include <linux/fs.h>\n#include <linux/buffer_head.h>\n#include <linux/blkdev.h>\n#include <linux/atomic.h>\n\nssize_t dax_do_io(int rw, struct kiocb *iocb, struct inode *inode,\n\t\t\tstruct iov_iter *iter, loff_t pos,\n\t\t\tget_block_t get_block, dio_iodone_t end_io, int flags)\n{\n\tstruct buffer_head bh;\n\tssize_t retval = -EINVAL;\n\tloff_t end = pos + iov_iter_count(iter);\n\n\tmemset(&bh, 0, sizeof(bh));\n\n\tif ((flags & DIO_LOCKING) && (rw == READ)) {\n\t\tstruct address_space *mapping = inode->i_mapping;\n\t\tmutex_lock(&inode->i_mutex);\n\t\tretval = filemap_write_and_wait_range(mapping, pos, end - 1);\n\t\tif (retval) {\n\t\t\tmutex_unlock(&inode->i_mutex);\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\t/* Protects against truncate */\n\tatomic_inc(&inode->i_dio_count);\n\n\tretval = dax_io(rw, inode, iter, pos, end, get_block, &bh);\n\n\tif ((flags & DIO_LOCKING) && (rw == READ))\n\t\tmutex_unlock(&inode->i_mutex);\n\n\tif ((retval > 0) && end_io)\n\t\tend_io(iocb, pos, retval, bh.b_private);\n\n\tinode_dio_done(inode);\n out:\n\treturn retval;\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_DAX",
          "args": [
            "inode"
          ],
          "line": 863
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "iov_iter_count",
          "args": [
            "iter"
          ],
          "line": 860
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xattr.h\"\n#include \"acl.h\"\n#include \"ext2.h\"\n#include <linux/aio.h>\n#include <linux/namei.h>\n#include <linux/fiemap.h>\n#include <linux/mpage.h>\n#include <linux/buffer_head.h>\n#include <linux/writeback.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/highuid.h>\n#include <linux/time.h>\n\nstatic void ext2_truncate_blocks(struct inode *inode, loff_t offset);\n\nstatic ssize_t\next2_direct_IO(int rw, struct kiocb *iocb, struct iov_iter *iter,\n\t\t\tloff_t offset)\n{\n\tstruct file *file = iocb->ki_filp;\n\tstruct address_space *mapping = file->f_mapping;\n\tstruct inode *inode = mapping->host;\n\tsize_t count = iov_iter_count(iter);\n\tssize_t ret;\n\n\tif (IS_DAX(inode))\n\t\tret = dax_do_io(rw, iocb, inode, iter, offset, ext2_get_block,\n\t\t\t\tNULL, DIO_LOCKING);\n\telse\n\t\tret = blockdev_direct_IO(rw, iocb, inode, iter, offset,\n\t\t\t\t\t ext2_get_block);\n\tif (ret < 0 && (rw & WRITE))\n\t\text2_write_failed(mapping, offset + count);\n\treturn ret;\n}"
  },
  {
    "function_name": "ext2_bmap",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext2/inode.c",
    "lines": "848-851",
    "snippet": "static sector_t ext2_bmap(struct address_space *mapping, sector_t block)\n{\n\treturn generic_block_bmap(mapping,block,ext2_get_block);\n}",
    "includes": [
      "#include \"xattr.h\"",
      "#include \"acl.h\"",
      "#include \"ext2.h\"",
      "#include <linux/aio.h>",
      "#include <linux/namei.h>",
      "#include <linux/fiemap.h>",
      "#include <linux/mpage.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/writeback.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/highuid.h>",
      "#include <linux/time.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "generic_block_bmap",
          "args": [
            "mapping",
            "block",
            "ext2_get_block"
          ],
          "line": 850
        },
        "resolved": true,
        "details": {
          "function_name": "generic_block_bmap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "2924-2934",
          "snippet": "sector_t generic_block_bmap(struct address_space *mapping, sector_t block,\n\t\t\t    get_block_t *get_block)\n{\n\tstruct buffer_head tmp;\n\tstruct inode *inode = mapping->host;\n\ttmp.b_state = 0;\n\ttmp.b_blocknr = 0;\n\ttmp.b_size = 1 << inode->i_blkbits;\n\tget_block(inode, block, &tmp, 0);\n\treturn tmp.b_blocknr;\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nsector_t generic_block_bmap(struct address_space *mapping, sector_t block,\n\t\t\t    get_block_t *get_block)\n{\n\tstruct buffer_head tmp;\n\tstruct inode *inode = mapping->host;\n\ttmp.b_state = 0;\n\ttmp.b_blocknr = 0;\n\ttmp.b_size = 1 << inode->i_blkbits;\n\tget_block(inode, block, &tmp, 0);\n\treturn tmp.b_blocknr;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"xattr.h\"\n#include \"acl.h\"\n#include \"ext2.h\"\n#include <linux/aio.h>\n#include <linux/namei.h>\n#include <linux/fiemap.h>\n#include <linux/mpage.h>\n#include <linux/buffer_head.h>\n#include <linux/writeback.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/highuid.h>\n#include <linux/time.h>\n\nstatic sector_t ext2_bmap(struct address_space *mapping, sector_t block)\n{\n\treturn generic_block_bmap(mapping,block,ext2_get_block);\n}"
  },
  {
    "function_name": "ext2_nobh_writepage",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext2/inode.c",
    "lines": "842-846",
    "snippet": "static int ext2_nobh_writepage(struct page *page,\n\t\t\tstruct writeback_control *wbc)\n{\n\treturn nobh_writepage(page, ext2_get_block, wbc);\n}",
    "includes": [
      "#include \"xattr.h\"",
      "#include \"acl.h\"",
      "#include \"ext2.h\"",
      "#include <linux/aio.h>",
      "#include <linux/namei.h>",
      "#include <linux/fiemap.h>",
      "#include <linux/mpage.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/writeback.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/highuid.h>",
      "#include <linux/time.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "nobh_writepage",
          "args": [
            "page",
            "ext2_get_block",
            "wbc"
          ],
          "line": 845
        },
        "resolved": true,
        "details": {
          "function_name": "nobh_writepage",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "2681-2725",
          "snippet": "int nobh_writepage(struct page *page, get_block_t *get_block,\n\t\t\tstruct writeback_control *wbc)\n{\n\tstruct inode * const inode = page->mapping->host;\n\tloff_t i_size = i_size_read(inode);\n\tconst pgoff_t end_index = i_size >> PAGE_CACHE_SHIFT;\n\tunsigned offset;\n\tint ret;\n\n\t/* Is the page fully inside i_size? */\n\tif (page->index < end_index)\n\t\tgoto out;\n\n\t/* Is the page fully outside i_size? (truncate in progress) */\n\toffset = i_size & (PAGE_CACHE_SIZE-1);\n\tif (page->index >= end_index+1 || !offset) {\n\t\t/*\n\t\t * The page may have dirty, unmapped buffers.  For example,\n\t\t * they may have been added in ext3_writepage().  Make them\n\t\t * freeable here, so the page does not leak.\n\t\t */\n#if 0\n\t\t/* Not really sure about this  - do we need this ? */\n\t\tif (page->mapping->a_ops->invalidatepage)\n\t\t\tpage->mapping->a_ops->invalidatepage(page, offset);\n#endif\n\t\tunlock_page(page);\n\t\treturn 0; /* don't care */\n\t}\n\n\t/*\n\t * The page straddles i_size.  It must be zeroed out on each and every\n\t * writepage invocation because it may be mmapped.  \"A file is mapped\n\t * in multiples of the page size.  For a file that is not a multiple of\n\t * the  page size, the remaining memory is zeroed when mapped, and\n\t * writes to that region are not written out to the file.\"\n\t */\n\tzero_user_segment(page, offset, PAGE_CACHE_SIZE);\nout:\n\tret = mpage_writepage(page, get_block, wbc);\n\tif (ret == -EAGAIN)\n\t\tret = __block_write_full_page(inode, page, get_block, wbc,\n\t\t\t\t\t      end_buffer_async_write);\n\treturn ret;\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nint nobh_writepage(struct page *page, get_block_t *get_block,\n\t\t\tstruct writeback_control *wbc)\n{\n\tstruct inode * const inode = page->mapping->host;\n\tloff_t i_size = i_size_read(inode);\n\tconst pgoff_t end_index = i_size >> PAGE_CACHE_SHIFT;\n\tunsigned offset;\n\tint ret;\n\n\t/* Is the page fully inside i_size? */\n\tif (page->index < end_index)\n\t\tgoto out;\n\n\t/* Is the page fully outside i_size? (truncate in progress) */\n\toffset = i_size & (PAGE_CACHE_SIZE-1);\n\tif (page->index >= end_index+1 || !offset) {\n\t\t/*\n\t\t * The page may have dirty, unmapped buffers.  For example,\n\t\t * they may have been added in ext3_writepage().  Make them\n\t\t * freeable here, so the page does not leak.\n\t\t */\n#if 0\n\t\t/* Not really sure about this  - do we need this ? */\n\t\tif (page->mapping->a_ops->invalidatepage)\n\t\t\tpage->mapping->a_ops->invalidatepage(page, offset);\n#endif\n\t\tunlock_page(page);\n\t\treturn 0; /* don't care */\n\t}\n\n\t/*\n\t * The page straddles i_size.  It must be zeroed out on each and every\n\t * writepage invocation because it may be mmapped.  \"A file is mapped\n\t * in multiples of the page size.  For a file that is not a multiple of\n\t * the  page size, the remaining memory is zeroed when mapped, and\n\t * writes to that region are not written out to the file.\"\n\t */\n\tzero_user_segment(page, offset, PAGE_CACHE_SIZE);\nout:\n\tret = mpage_writepage(page, get_block, wbc);\n\tif (ret == -EAGAIN)\n\t\tret = __block_write_full_page(inode, page, get_block, wbc,\n\t\t\t\t\t      end_buffer_async_write);\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"xattr.h\"\n#include \"acl.h\"\n#include \"ext2.h\"\n#include <linux/aio.h>\n#include <linux/namei.h>\n#include <linux/fiemap.h>\n#include <linux/mpage.h>\n#include <linux/buffer_head.h>\n#include <linux/writeback.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/highuid.h>\n#include <linux/time.h>\n\nstatic int ext2_nobh_writepage(struct page *page,\n\t\t\tstruct writeback_control *wbc)\n{\n\treturn nobh_writepage(page, ext2_get_block, wbc);\n}"
  },
  {
    "function_name": "ext2_nobh_write_begin",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext2/inode.c",
    "lines": "828-840",
    "snippet": "static int\next2_nobh_write_begin(struct file *file, struct address_space *mapping,\n\t\tloff_t pos, unsigned len, unsigned flags,\n\t\tstruct page **pagep, void **fsdata)\n{\n\tint ret;\n\n\tret = nobh_write_begin(mapping, pos, len, flags, pagep, fsdata,\n\t\t\t       ext2_get_block);\n\tif (ret < 0)\n\t\text2_write_failed(mapping, pos + len);\n\treturn ret;\n}",
    "includes": [
      "#include \"xattr.h\"",
      "#include \"acl.h\"",
      "#include \"ext2.h\"",
      "#include <linux/aio.h>",
      "#include <linux/namei.h>",
      "#include <linux/fiemap.h>",
      "#include <linux/mpage.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/writeback.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/highuid.h>",
      "#include <linux/time.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ext2_write_failed",
          "args": [
            "mapping",
            "pos + len"
          ],
          "line": 838
        },
        "resolved": true,
        "details": {
          "function_name": "ext2_write_failed",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext2/inode.c",
          "lines": "55-63",
          "snippet": "static void ext2_write_failed(struct address_space *mapping, loff_t to)\n{\n\tstruct inode *inode = mapping->host;\n\n\tif (to > inode->i_size) {\n\t\ttruncate_pagecache(inode, inode->i_size);\n\t\text2_truncate_blocks(inode, inode->i_size);\n\t}\n}",
          "includes": [
            "#include \"xattr.h\"",
            "#include \"acl.h\"",
            "#include \"ext2.h\"",
            "#include <linux/aio.h>",
            "#include <linux/namei.h>",
            "#include <linux/fiemap.h>",
            "#include <linux/mpage.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/writeback.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highuid.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xattr.h\"\n#include \"acl.h\"\n#include \"ext2.h\"\n#include <linux/aio.h>\n#include <linux/namei.h>\n#include <linux/fiemap.h>\n#include <linux/mpage.h>\n#include <linux/buffer_head.h>\n#include <linux/writeback.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/highuid.h>\n#include <linux/time.h>\n\nstatic void ext2_write_failed(struct address_space *mapping, loff_t to)\n{\n\tstruct inode *inode = mapping->host;\n\n\tif (to > inode->i_size) {\n\t\ttruncate_pagecache(inode, inode->i_size);\n\t\text2_truncate_blocks(inode, inode->i_size);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "nobh_write_begin",
          "args": [
            "mapping",
            "pos",
            "len",
            "flags",
            "pagep",
            "fsdata",
            "ext2_get_block"
          ],
          "line": 835
        },
        "resolved": true,
        "details": {
          "function_name": "ext2_nobh_write_begin",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext2/inode.c",
          "lines": "828-840",
          "snippet": "static int\next2_nobh_write_begin(struct file *file, struct address_space *mapping,\n\t\tloff_t pos, unsigned len, unsigned flags,\n\t\tstruct page **pagep, void **fsdata)\n{\n\tint ret;\n\n\tret = nobh_write_begin(mapping, pos, len, flags, pagep, fsdata,\n\t\t\t       ext2_get_block);\n\tif (ret < 0)\n\t\text2_write_failed(mapping, pos + len);\n\treturn ret;\n}",
          "note": "cyclic_reference_detected"
        }
      }
    ],
    "contextual_snippet": "#include \"xattr.h\"\n#include \"acl.h\"\n#include \"ext2.h\"\n#include <linux/aio.h>\n#include <linux/namei.h>\n#include <linux/fiemap.h>\n#include <linux/mpage.h>\n#include <linux/buffer_head.h>\n#include <linux/writeback.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/highuid.h>\n#include <linux/time.h>\n\nstatic int\next2_nobh_write_begin(struct file *file, struct address_space *mapping,\n\t\tloff_t pos, unsigned len, unsigned flags,\n\t\tstruct page **pagep, void **fsdata)\n{\n\tint ret;\n\n\tret = nobh_write_begin(mapping, pos, len, flags, pagep, fsdata,\n\t\t\t       ext2_get_block);\n\tif (ret < 0)\n\t\text2_write_failed(mapping, pos + len);\n\treturn ret;\n}"
  },
  {
    "function_name": "ext2_write_end",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext2/inode.c",
    "lines": "816-826",
    "snippet": "static int ext2_write_end(struct file *file, struct address_space *mapping,\n\t\t\tloff_t pos, unsigned len, unsigned copied,\n\t\t\tstruct page *page, void *fsdata)\n{\n\tint ret;\n\n\tret = generic_write_end(file, mapping, pos, len, copied, page, fsdata);\n\tif (ret < len)\n\t\text2_write_failed(mapping, pos + len);\n\treturn ret;\n}",
    "includes": [
      "#include \"xattr.h\"",
      "#include \"acl.h\"",
      "#include \"ext2.h\"",
      "#include <linux/aio.h>",
      "#include <linux/namei.h>",
      "#include <linux/fiemap.h>",
      "#include <linux/mpage.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/writeback.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/highuid.h>",
      "#include <linux/time.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ext2_write_failed",
          "args": [
            "mapping",
            "pos + len"
          ],
          "line": 824
        },
        "resolved": true,
        "details": {
          "function_name": "ext2_write_failed",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext2/inode.c",
          "lines": "55-63",
          "snippet": "static void ext2_write_failed(struct address_space *mapping, loff_t to)\n{\n\tstruct inode *inode = mapping->host;\n\n\tif (to > inode->i_size) {\n\t\ttruncate_pagecache(inode, inode->i_size);\n\t\text2_truncate_blocks(inode, inode->i_size);\n\t}\n}",
          "includes": [
            "#include \"xattr.h\"",
            "#include \"acl.h\"",
            "#include \"ext2.h\"",
            "#include <linux/aio.h>",
            "#include <linux/namei.h>",
            "#include <linux/fiemap.h>",
            "#include <linux/mpage.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/writeback.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highuid.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xattr.h\"\n#include \"acl.h\"\n#include \"ext2.h\"\n#include <linux/aio.h>\n#include <linux/namei.h>\n#include <linux/fiemap.h>\n#include <linux/mpage.h>\n#include <linux/buffer_head.h>\n#include <linux/writeback.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/highuid.h>\n#include <linux/time.h>\n\nstatic void ext2_write_failed(struct address_space *mapping, loff_t to)\n{\n\tstruct inode *inode = mapping->host;\n\n\tif (to > inode->i_size) {\n\t\ttruncate_pagecache(inode, inode->i_size);\n\t\text2_truncate_blocks(inode, inode->i_size);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "generic_write_end",
          "args": [
            "file",
            "mapping",
            "pos",
            "len",
            "copied",
            "page",
            "fsdata"
          ],
          "line": 822
        },
        "resolved": true,
        "details": {
          "function_name": "generic_write_end",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "2067-2104",
          "snippet": "int generic_write_end(struct file *file, struct address_space *mapping,\n\t\t\tloff_t pos, unsigned len, unsigned copied,\n\t\t\tstruct page *page, void *fsdata)\n{\n\tstruct inode *inode = mapping->host;\n\tloff_t old_size = inode->i_size;\n\tint i_size_changed = 0;\n\n\tcopied = block_write_end(file, mapping, pos, len, copied, page, fsdata);\n\n\t/*\n\t * No need to use i_size_read() here, the i_size\n\t * cannot change under us because we hold i_mutex.\n\t *\n\t * But it's important to update i_size while still holding page lock:\n\t * page writeout could otherwise come in and zero beyond i_size.\n\t */\n\tif (pos+copied > inode->i_size) {\n\t\ti_size_write(inode, pos+copied);\n\t\ti_size_changed = 1;\n\t}\n\n\tunlock_page(page);\n\tpage_cache_release(page);\n\n\tif (old_size < pos)\n\t\tpagecache_isize_extended(inode, old_size, pos);\n\t/*\n\t * Don't mark the inode dirty under page lock. First, it unnecessarily\n\t * makes the holding time of page lock longer. Second, it forces lock\n\t * ordering of page lock and transaction start for journaling\n\t * filesystems.\n\t */\n\tif (i_size_changed)\n\t\tmark_inode_dirty(inode);\n\n\treturn copied;\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nint generic_write_end(struct file *file, struct address_space *mapping,\n\t\t\tloff_t pos, unsigned len, unsigned copied,\n\t\t\tstruct page *page, void *fsdata)\n{\n\tstruct inode *inode = mapping->host;\n\tloff_t old_size = inode->i_size;\n\tint i_size_changed = 0;\n\n\tcopied = block_write_end(file, mapping, pos, len, copied, page, fsdata);\n\n\t/*\n\t * No need to use i_size_read() here, the i_size\n\t * cannot change under us because we hold i_mutex.\n\t *\n\t * But it's important to update i_size while still holding page lock:\n\t * page writeout could otherwise come in and zero beyond i_size.\n\t */\n\tif (pos+copied > inode->i_size) {\n\t\ti_size_write(inode, pos+copied);\n\t\ti_size_changed = 1;\n\t}\n\n\tunlock_page(page);\n\tpage_cache_release(page);\n\n\tif (old_size < pos)\n\t\tpagecache_isize_extended(inode, old_size, pos);\n\t/*\n\t * Don't mark the inode dirty under page lock. First, it unnecessarily\n\t * makes the holding time of page lock longer. Second, it forces lock\n\t * ordering of page lock and transaction start for journaling\n\t * filesystems.\n\t */\n\tif (i_size_changed)\n\t\tmark_inode_dirty(inode);\n\n\treturn copied;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"xattr.h\"\n#include \"acl.h\"\n#include \"ext2.h\"\n#include <linux/aio.h>\n#include <linux/namei.h>\n#include <linux/fiemap.h>\n#include <linux/mpage.h>\n#include <linux/buffer_head.h>\n#include <linux/writeback.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/highuid.h>\n#include <linux/time.h>\n\nstatic int ext2_write_end(struct file *file, struct address_space *mapping,\n\t\t\tloff_t pos, unsigned len, unsigned copied,\n\t\t\tstruct page *page, void *fsdata)\n{\n\tint ret;\n\n\tret = generic_write_end(file, mapping, pos, len, copied, page, fsdata);\n\tif (ret < len)\n\t\text2_write_failed(mapping, pos + len);\n\treturn ret;\n}"
  },
  {
    "function_name": "ext2_write_begin",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext2/inode.c",
    "lines": "802-814",
    "snippet": "static int\next2_write_begin(struct file *file, struct address_space *mapping,\n\t\tloff_t pos, unsigned len, unsigned flags,\n\t\tstruct page **pagep, void **fsdata)\n{\n\tint ret;\n\n\tret = block_write_begin(mapping, pos, len, flags, pagep,\n\t\t\t\text2_get_block);\n\tif (ret < 0)\n\t\text2_write_failed(mapping, pos + len);\n\treturn ret;\n}",
    "includes": [
      "#include \"xattr.h\"",
      "#include \"acl.h\"",
      "#include \"ext2.h\"",
      "#include <linux/aio.h>",
      "#include <linux/namei.h>",
      "#include <linux/fiemap.h>",
      "#include <linux/mpage.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/writeback.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/highuid.h>",
      "#include <linux/time.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ext2_write_failed",
          "args": [
            "mapping",
            "pos + len"
          ],
          "line": 812
        },
        "resolved": true,
        "details": {
          "function_name": "ext2_write_failed",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext2/inode.c",
          "lines": "55-63",
          "snippet": "static void ext2_write_failed(struct address_space *mapping, loff_t to)\n{\n\tstruct inode *inode = mapping->host;\n\n\tif (to > inode->i_size) {\n\t\ttruncate_pagecache(inode, inode->i_size);\n\t\text2_truncate_blocks(inode, inode->i_size);\n\t}\n}",
          "includes": [
            "#include \"xattr.h\"",
            "#include \"acl.h\"",
            "#include \"ext2.h\"",
            "#include <linux/aio.h>",
            "#include <linux/namei.h>",
            "#include <linux/fiemap.h>",
            "#include <linux/mpage.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/writeback.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highuid.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xattr.h\"\n#include \"acl.h\"\n#include \"ext2.h\"\n#include <linux/aio.h>\n#include <linux/namei.h>\n#include <linux/fiemap.h>\n#include <linux/mpage.h>\n#include <linux/buffer_head.h>\n#include <linux/writeback.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/highuid.h>\n#include <linux/time.h>\n\nstatic void ext2_write_failed(struct address_space *mapping, loff_t to)\n{\n\tstruct inode *inode = mapping->host;\n\n\tif (to > inode->i_size) {\n\t\ttruncate_pagecache(inode, inode->i_size);\n\t\text2_truncate_blocks(inode, inode->i_size);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "block_write_begin",
          "args": [
            "mapping",
            "pos",
            "len",
            "flags",
            "pagep",
            "ext2_get_block"
          ],
          "line": 809
        },
        "resolved": true,
        "details": {
          "function_name": "block_write_begin",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "2008-2028",
          "snippet": "int block_write_begin(struct address_space *mapping, loff_t pos, unsigned len,\n\t\tunsigned flags, struct page **pagep, get_block_t *get_block)\n{\n\tpgoff_t index = pos >> PAGE_CACHE_SHIFT;\n\tstruct page *page;\n\tint status;\n\n\tpage = grab_cache_page_write_begin(mapping, index, flags);\n\tif (!page)\n\t\treturn -ENOMEM;\n\n\tstatus = __block_write_begin(page, pos, len, get_block);\n\tif (unlikely(status)) {\n\t\tunlock_page(page);\n\t\tpage_cache_release(page);\n\t\tpage = NULL;\n\t}\n\n\t*pagep = page;\n\treturn status;\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nint block_write_begin(struct address_space *mapping, loff_t pos, unsigned len,\n\t\tunsigned flags, struct page **pagep, get_block_t *get_block)\n{\n\tpgoff_t index = pos >> PAGE_CACHE_SHIFT;\n\tstruct page *page;\n\tint status;\n\n\tpage = grab_cache_page_write_begin(mapping, index, flags);\n\tif (!page)\n\t\treturn -ENOMEM;\n\n\tstatus = __block_write_begin(page, pos, len, get_block);\n\tif (unlikely(status)) {\n\t\tunlock_page(page);\n\t\tpage_cache_release(page);\n\t\tpage = NULL;\n\t}\n\n\t*pagep = page;\n\treturn status;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"xattr.h\"\n#include \"acl.h\"\n#include \"ext2.h\"\n#include <linux/aio.h>\n#include <linux/namei.h>\n#include <linux/fiemap.h>\n#include <linux/mpage.h>\n#include <linux/buffer_head.h>\n#include <linux/writeback.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/highuid.h>\n#include <linux/time.h>\n\nstatic int\next2_write_begin(struct file *file, struct address_space *mapping,\n\t\tloff_t pos, unsigned len, unsigned flags,\n\t\tstruct page **pagep, void **fsdata)\n{\n\tint ret;\n\n\tret = block_write_begin(mapping, pos, len, flags, pagep,\n\t\t\t\text2_get_block);\n\tif (ret < 0)\n\t\text2_write_failed(mapping, pos + len);\n\treturn ret;\n}"
  },
  {
    "function_name": "ext2_readpages",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext2/inode.c",
    "lines": "795-800",
    "snippet": "static int\next2_readpages(struct file *file, struct address_space *mapping,\n\t\tstruct list_head *pages, unsigned nr_pages)\n{\n\treturn mpage_readpages(mapping, pages, nr_pages, ext2_get_block);\n}",
    "includes": [
      "#include \"xattr.h\"",
      "#include \"acl.h\"",
      "#include \"ext2.h\"",
      "#include <linux/aio.h>",
      "#include <linux/namei.h>",
      "#include <linux/fiemap.h>",
      "#include <linux/mpage.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/writeback.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/highuid.h>",
      "#include <linux/time.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mpage_readpages",
          "args": [
            "mapping",
            "pages",
            "nr_pages",
            "ext2_get_block"
          ],
          "line": 799
        },
        "resolved": true,
        "details": {
          "function_name": "mpage_readpages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mpage.c",
          "lines": "355-386",
          "snippet": "int\nmpage_readpages(struct address_space *mapping, struct list_head *pages,\n\t\t\t\tunsigned nr_pages, get_block_t get_block)\n{\n\tstruct bio *bio = NULL;\n\tunsigned page_idx;\n\tsector_t last_block_in_bio = 0;\n\tstruct buffer_head map_bh;\n\tunsigned long first_logical_block = 0;\n\n\tmap_bh.b_state = 0;\n\tmap_bh.b_size = 0;\n\tfor (page_idx = 0; page_idx < nr_pages; page_idx++) {\n\t\tstruct page *page = list_entry(pages->prev, struct page, lru);\n\n\t\tprefetchw(&page->flags);\n\t\tlist_del(&page->lru);\n\t\tif (!add_to_page_cache_lru(page, mapping,\n\t\t\t\t\tpage->index, GFP_KERNEL)) {\n\t\t\tbio = do_mpage_readpage(bio, page,\n\t\t\t\t\tnr_pages - page_idx,\n\t\t\t\t\t&last_block_in_bio, &map_bh,\n\t\t\t\t\t&first_logical_block,\n\t\t\t\t\tget_block);\n\t\t}\n\t\tpage_cache_release(page);\n\t}\n\tBUG_ON(!list_empty(pages));\n\tif (bio)\n\t\tmpage_bio_submit(READ, bio);\n\treturn 0;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/cleancache.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/mpage.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/highmem.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/fs.h>",
            "#include <linux/bio.h>",
            "#include <linux/gfp.h>",
            "#include <linux/kdev_t.h>",
            "#include <linux/mm.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/cleancache.h>\n#include <linux/pagevec.h>\n#include <linux/backing-dev.h>\n#include <linux/writeback.h>\n#include <linux/mpage.h>\n#include <linux/prefetch.h>\n#include <linux/highmem.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/fs.h>\n#include <linux/bio.h>\n#include <linux/gfp.h>\n#include <linux/kdev_t.h>\n#include <linux/mm.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nint\nmpage_readpages(struct address_space *mapping, struct list_head *pages,\n\t\t\t\tunsigned nr_pages, get_block_t get_block)\n{\n\tstruct bio *bio = NULL;\n\tunsigned page_idx;\n\tsector_t last_block_in_bio = 0;\n\tstruct buffer_head map_bh;\n\tunsigned long first_logical_block = 0;\n\n\tmap_bh.b_state = 0;\n\tmap_bh.b_size = 0;\n\tfor (page_idx = 0; page_idx < nr_pages; page_idx++) {\n\t\tstruct page *page = list_entry(pages->prev, struct page, lru);\n\n\t\tprefetchw(&page->flags);\n\t\tlist_del(&page->lru);\n\t\tif (!add_to_page_cache_lru(page, mapping,\n\t\t\t\t\tpage->index, GFP_KERNEL)) {\n\t\t\tbio = do_mpage_readpage(bio, page,\n\t\t\t\t\tnr_pages - page_idx,\n\t\t\t\t\t&last_block_in_bio, &map_bh,\n\t\t\t\t\t&first_logical_block,\n\t\t\t\t\tget_block);\n\t\t}\n\t\tpage_cache_release(page);\n\t}\n\tBUG_ON(!list_empty(pages));\n\tif (bio)\n\t\tmpage_bio_submit(READ, bio);\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"xattr.h\"\n#include \"acl.h\"\n#include \"ext2.h\"\n#include <linux/aio.h>\n#include <linux/namei.h>\n#include <linux/fiemap.h>\n#include <linux/mpage.h>\n#include <linux/buffer_head.h>\n#include <linux/writeback.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/highuid.h>\n#include <linux/time.h>\n\nstatic int\next2_readpages(struct file *file, struct address_space *mapping,\n\t\tstruct list_head *pages, unsigned nr_pages)\n{\n\treturn mpage_readpages(mapping, pages, nr_pages, ext2_get_block);\n}"
  },
  {
    "function_name": "ext2_readpage",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext2/inode.c",
    "lines": "790-793",
    "snippet": "static int ext2_readpage(struct file *file, struct page *page)\n{\n\treturn mpage_readpage(page, ext2_get_block);\n}",
    "includes": [
      "#include \"xattr.h\"",
      "#include \"acl.h\"",
      "#include \"ext2.h\"",
      "#include <linux/aio.h>",
      "#include <linux/namei.h>",
      "#include <linux/fiemap.h>",
      "#include <linux/mpage.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/writeback.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/highuid.h>",
      "#include <linux/time.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mpage_readpage",
          "args": [
            "page",
            "ext2_get_block"
          ],
          "line": 792
        },
        "resolved": true,
        "details": {
          "function_name": "mpage_readpage",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mpage.c",
          "lines": "392-406",
          "snippet": "int mpage_readpage(struct page *page, get_block_t get_block)\n{\n\tstruct bio *bio = NULL;\n\tsector_t last_block_in_bio = 0;\n\tstruct buffer_head map_bh;\n\tunsigned long first_logical_block = 0;\n\n\tmap_bh.b_state = 0;\n\tmap_bh.b_size = 0;\n\tbio = do_mpage_readpage(bio, page, 1, &last_block_in_bio,\n\t\t\t&map_bh, &first_logical_block, get_block);\n\tif (bio)\n\t\tmpage_bio_submit(READ, bio);\n\treturn 0;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/cleancache.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/mpage.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/highmem.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/fs.h>",
            "#include <linux/bio.h>",
            "#include <linux/gfp.h>",
            "#include <linux/kdev_t.h>",
            "#include <linux/mm.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/cleancache.h>\n#include <linux/pagevec.h>\n#include <linux/backing-dev.h>\n#include <linux/writeback.h>\n#include <linux/mpage.h>\n#include <linux/prefetch.h>\n#include <linux/highmem.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/fs.h>\n#include <linux/bio.h>\n#include <linux/gfp.h>\n#include <linux/kdev_t.h>\n#include <linux/mm.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nint mpage_readpage(struct page *page, get_block_t get_block)\n{\n\tstruct bio *bio = NULL;\n\tsector_t last_block_in_bio = 0;\n\tstruct buffer_head map_bh;\n\tunsigned long first_logical_block = 0;\n\n\tmap_bh.b_state = 0;\n\tmap_bh.b_size = 0;\n\tbio = do_mpage_readpage(bio, page, 1, &last_block_in_bio,\n\t\t\t&map_bh, &first_logical_block, get_block);\n\tif (bio)\n\t\tmpage_bio_submit(READ, bio);\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"xattr.h\"\n#include \"acl.h\"\n#include \"ext2.h\"\n#include <linux/aio.h>\n#include <linux/namei.h>\n#include <linux/fiemap.h>\n#include <linux/mpage.h>\n#include <linux/buffer_head.h>\n#include <linux/writeback.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/highuid.h>\n#include <linux/time.h>\n\nstatic int ext2_readpage(struct file *file, struct page *page)\n{\n\treturn mpage_readpage(page, ext2_get_block);\n}"
  },
  {
    "function_name": "ext2_writepage",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext2/inode.c",
    "lines": "785-788",
    "snippet": "static int ext2_writepage(struct page *page, struct writeback_control *wbc)\n{\n\treturn block_write_full_page(page, ext2_get_block, wbc);\n}",
    "includes": [
      "#include \"xattr.h\"",
      "#include \"acl.h\"",
      "#include \"ext2.h\"",
      "#include <linux/aio.h>",
      "#include <linux/namei.h>",
      "#include <linux/fiemap.h>",
      "#include <linux/mpage.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/writeback.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/highuid.h>",
      "#include <linux/time.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "block_write_full_page",
          "args": [
            "page",
            "ext2_get_block",
            "wbc"
          ],
          "line": 787
        },
        "resolved": true,
        "details": {
          "function_name": "block_write_full_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "2885-2921",
          "snippet": "int block_write_full_page(struct page *page, get_block_t *get_block,\n\t\t\tstruct writeback_control *wbc)\n{\n\tstruct inode * const inode = page->mapping->host;\n\tloff_t i_size = i_size_read(inode);\n\tconst pgoff_t end_index = i_size >> PAGE_CACHE_SHIFT;\n\tunsigned offset;\n\n\t/* Is the page fully inside i_size? */\n\tif (page->index < end_index)\n\t\treturn __block_write_full_page(inode, page, get_block, wbc,\n\t\t\t\t\t       end_buffer_async_write);\n\n\t/* Is the page fully outside i_size? (truncate in progress) */\n\toffset = i_size & (PAGE_CACHE_SIZE-1);\n\tif (page->index >= end_index+1 || !offset) {\n\t\t/*\n\t\t * The page may have dirty, unmapped buffers.  For example,\n\t\t * they may have been added in ext3_writepage().  Make them\n\t\t * freeable here, so the page does not leak.\n\t\t */\n\t\tdo_invalidatepage(page, 0, PAGE_CACHE_SIZE);\n\t\tunlock_page(page);\n\t\treturn 0; /* don't care */\n\t}\n\n\t/*\n\t * The page straddles i_size.  It must be zeroed out on each and every\n\t * writepage invocation because it may be mmapped.  \"A file is mapped\n\t * in multiples of the page size.  For a file that is not a multiple of\n\t * the  page size, the remaining memory is zeroed when mapped, and\n\t * writes to that region are not written out to the file.\"\n\t */\n\tzero_user_segment(page, offset, PAGE_CACHE_SIZE);\n\treturn __block_write_full_page(inode, page, get_block, wbc,\n\t\t\t\t\t\t\tend_buffer_async_write);\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nint block_write_full_page(struct page *page, get_block_t *get_block,\n\t\t\tstruct writeback_control *wbc)\n{\n\tstruct inode * const inode = page->mapping->host;\n\tloff_t i_size = i_size_read(inode);\n\tconst pgoff_t end_index = i_size >> PAGE_CACHE_SHIFT;\n\tunsigned offset;\n\n\t/* Is the page fully inside i_size? */\n\tif (page->index < end_index)\n\t\treturn __block_write_full_page(inode, page, get_block, wbc,\n\t\t\t\t\t       end_buffer_async_write);\n\n\t/* Is the page fully outside i_size? (truncate in progress) */\n\toffset = i_size & (PAGE_CACHE_SIZE-1);\n\tif (page->index >= end_index+1 || !offset) {\n\t\t/*\n\t\t * The page may have dirty, unmapped buffers.  For example,\n\t\t * they may have been added in ext3_writepage().  Make them\n\t\t * freeable here, so the page does not leak.\n\t\t */\n\t\tdo_invalidatepage(page, 0, PAGE_CACHE_SIZE);\n\t\tunlock_page(page);\n\t\treturn 0; /* don't care */\n\t}\n\n\t/*\n\t * The page straddles i_size.  It must be zeroed out on each and every\n\t * writepage invocation because it may be mmapped.  \"A file is mapped\n\t * in multiples of the page size.  For a file that is not a multiple of\n\t * the  page size, the remaining memory is zeroed when mapped, and\n\t * writes to that region are not written out to the file.\"\n\t */\n\tzero_user_segment(page, offset, PAGE_CACHE_SIZE);\n\treturn __block_write_full_page(inode, page, get_block, wbc,\n\t\t\t\t\t\t\tend_buffer_async_write);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"xattr.h\"\n#include \"acl.h\"\n#include \"ext2.h\"\n#include <linux/aio.h>\n#include <linux/namei.h>\n#include <linux/fiemap.h>\n#include <linux/mpage.h>\n#include <linux/buffer_head.h>\n#include <linux/writeback.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/highuid.h>\n#include <linux/time.h>\n\nstatic int ext2_writepage(struct page *page, struct writeback_control *wbc)\n{\n\treturn block_write_full_page(page, ext2_get_block, wbc);\n}"
  },
  {
    "function_name": "ext2_fiemap",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext2/inode.c",
    "lines": "778-783",
    "snippet": "int ext2_fiemap(struct inode *inode, struct fiemap_extent_info *fieinfo,\n\t\tu64 start, u64 len)\n{\n\treturn generic_block_fiemap(inode, fieinfo, start, len,\n\t\t\t\t    ext2_get_block);\n}",
    "includes": [
      "#include \"xattr.h\"",
      "#include \"acl.h\"",
      "#include \"ext2.h\"",
      "#include <linux/aio.h>",
      "#include <linux/namei.h>",
      "#include <linux/fiemap.h>",
      "#include <linux/mpage.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/writeback.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/highuid.h>",
      "#include <linux/time.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "generic_block_fiemap",
          "args": [
            "inode",
            "fieinfo",
            "start",
            "len",
            "ext2_get_block"
          ],
          "line": 781
        },
        "resolved": true,
        "details": {
          "function_name": "generic_block_fiemap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ioctl.c",
          "lines": "409-418",
          "snippet": "int generic_block_fiemap(struct inode *inode,\n\t\t\t struct fiemap_extent_info *fieinfo, u64 start,\n\t\t\t u64 len, get_block_t *get_block)\n{\n\tint ret;\n\tmutex_lock(&inode->i_mutex);\n\tret = __generic_block_fiemap(inode, fieinfo, start, len, get_block);\n\tmutex_unlock(&inode->i_mutex);\n\treturn ret;\n}",
          "includes": [
            "#include <asm/ioctls.h>",
            "#include <linux/falloc.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/writeback.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/export.h>",
            "#include <linux/security.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>",
            "#include <linux/mm.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/ioctls.h>\n#include <linux/falloc.h>\n#include <linux/buffer_head.h>\n#include <linux/writeback.h>\n#include <linux/uaccess.h>\n#include <linux/export.h>\n#include <linux/security.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n#include <linux/mm.h>\n#include <linux/syscalls.h>\n\nint generic_block_fiemap(struct inode *inode,\n\t\t\t struct fiemap_extent_info *fieinfo, u64 start,\n\t\t\t u64 len, get_block_t *get_block)\n{\n\tint ret;\n\tmutex_lock(&inode->i_mutex);\n\tret = __generic_block_fiemap(inode, fieinfo, start, len, get_block);\n\tmutex_unlock(&inode->i_mutex);\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"xattr.h\"\n#include \"acl.h\"\n#include \"ext2.h\"\n#include <linux/aio.h>\n#include <linux/namei.h>\n#include <linux/fiemap.h>\n#include <linux/mpage.h>\n#include <linux/buffer_head.h>\n#include <linux/writeback.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/highuid.h>\n#include <linux/time.h>\n\nint ext2_fiemap(struct inode *inode, struct fiemap_extent_info *fieinfo,\n\t\tu64 start, u64 len)\n{\n\treturn generic_block_fiemap(inode, fieinfo, start, len,\n\t\t\t\t    ext2_get_block);\n}"
  },
  {
    "function_name": "ext2_get_block",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext2/inode.c",
    "lines": "765-776",
    "snippet": "int ext2_get_block(struct inode *inode, sector_t iblock, struct buffer_head *bh_result, int create)\n{\n\tunsigned max_blocks = bh_result->b_size >> inode->i_blkbits;\n\tint ret = ext2_get_blocks(inode, iblock, max_blocks,\n\t\t\t      bh_result, create);\n\tif (ret > 0) {\n\t\tbh_result->b_size = (ret << inode->i_blkbits);\n\t\tret = 0;\n\t}\n\treturn ret;\n\n}",
    "includes": [
      "#include \"xattr.h\"",
      "#include \"acl.h\"",
      "#include \"ext2.h\"",
      "#include <linux/aio.h>",
      "#include <linux/namei.h>",
      "#include <linux/fiemap.h>",
      "#include <linux/mpage.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/writeback.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/highuid.h>",
      "#include <linux/time.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ext2_get_blocks",
          "args": [
            "inode",
            "iblock",
            "max_blocks",
            "bh_result",
            "create"
          ],
          "line": 768
        },
        "resolved": true,
        "details": {
          "function_name": "ext2_get_blocks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext2/inode.c",
          "lines": "617-763",
          "snippet": "static int ext2_get_blocks(struct inode *inode,\n\t\t\t   sector_t iblock, unsigned long maxblocks,\n\t\t\t   struct buffer_head *bh_result,\n\t\t\t   int create)\n{\n\tint err = -EIO;\n\tint offsets[4];\n\tIndirect chain[4];\n\tIndirect *partial;\n\text2_fsblk_t goal;\n\tint indirect_blks;\n\tint blocks_to_boundary = 0;\n\tint depth;\n\tstruct ext2_inode_info *ei = EXT2_I(inode);\n\tint count = 0;\n\text2_fsblk_t first_block = 0;\n\n\tBUG_ON(maxblocks == 0);\n\n\tdepth = ext2_block_to_path(inode,iblock,offsets,&blocks_to_boundary);\n\n\tif (depth == 0)\n\t\treturn (err);\n\n\tpartial = ext2_get_branch(inode, depth, offsets, chain, &err);\n\t/* Simplest case - block found, no allocation needed */\n\tif (!partial) {\n\t\tfirst_block = le32_to_cpu(chain[depth - 1].key);\n\t\tclear_buffer_new(bh_result); /* What's this do? */\n\t\tcount++;\n\t\t/*map more blocks*/\n\t\twhile (count < maxblocks && count <= blocks_to_boundary) {\n\t\t\text2_fsblk_t blk;\n\n\t\t\tif (!verify_chain(chain, chain + depth - 1)) {\n\t\t\t\t/*\n\t\t\t\t * Indirect block might be removed by\n\t\t\t\t * truncate while we were reading it.\n\t\t\t\t * Handling of that case: forget what we've\n\t\t\t\t * got now, go to reread.\n\t\t\t\t */\n\t\t\t\terr = -EAGAIN;\n\t\t\t\tcount = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tblk = le32_to_cpu(*(chain[depth-1].p + count));\n\t\t\tif (blk == first_block + count)\n\t\t\t\tcount++;\n\t\t\telse\n\t\t\t\tbreak;\n\t\t}\n\t\tif (err != -EAGAIN)\n\t\t\tgoto got_it;\n\t}\n\n\t/* Next simple case - plain lookup or failed read of indirect block */\n\tif (!create || err == -EIO)\n\t\tgoto cleanup;\n\n\tmutex_lock(&ei->truncate_mutex);\n\t/*\n\t * If the indirect block is missing while we are reading\n\t * the chain(ext2_get_branch() returns -EAGAIN err), or\n\t * if the chain has been changed after we grab the semaphore,\n\t * (either because another process truncated this branch, or\n\t * another get_block allocated this branch) re-grab the chain to see if\n\t * the request block has been allocated or not.\n\t *\n\t * Since we already block the truncate/other get_block\n\t * at this point, we will have the current copy of the chain when we\n\t * splice the branch into the tree.\n\t */\n\tif (err == -EAGAIN || !verify_chain(chain, partial)) {\n\t\twhile (partial > chain) {\n\t\t\tbrelse(partial->bh);\n\t\t\tpartial--;\n\t\t}\n\t\tpartial = ext2_get_branch(inode, depth, offsets, chain, &err);\n\t\tif (!partial) {\n\t\t\tcount++;\n\t\t\tmutex_unlock(&ei->truncate_mutex);\n\t\t\tif (err)\n\t\t\t\tgoto cleanup;\n\t\t\tclear_buffer_new(bh_result);\n\t\t\tgoto got_it;\n\t\t}\n\t}\n\n\t/*\n\t * Okay, we need to do block allocation.  Lazily initialize the block\n\t * allocation info here if necessary\n\t*/\n\tif (S_ISREG(inode->i_mode) && (!ei->i_block_alloc_info))\n\t\text2_init_block_alloc_info(inode);\n\n\tgoal = ext2_find_goal(inode, iblock, partial);\n\n\t/* the number of blocks need to allocate for [d,t]indirect blocks */\n\tindirect_blks = (chain + depth) - partial - 1;\n\t/*\n\t * Next look up the indirect map to count the totoal number of\n\t * direct blocks to allocate for this branch.\n\t */\n\tcount = ext2_blks_to_allocate(partial, indirect_blks,\n\t\t\t\t\tmaxblocks, blocks_to_boundary);\n\t/*\n\t * XXX ???? Block out ext2_truncate while we alter the tree\n\t */\n\terr = ext2_alloc_branch(inode, indirect_blks, &count, goal,\n\t\t\t\toffsets + (partial - chain), partial);\n\n\tif (err) {\n\t\tmutex_unlock(&ei->truncate_mutex);\n\t\tgoto cleanup;\n\t}\n\n\tif (IS_DAX(inode)) {\n\t\t/*\n\t\t * block must be initialised before we put it in the tree\n\t\t * so that it's not found by another thread before it's\n\t\t * initialised\n\t\t */\n\t\terr = dax_clear_blocks(inode, le32_to_cpu(chain[depth-1].key),\n\t\t\t\t\t\t1 << inode->i_blkbits);\n\t\tif (err) {\n\t\t\tmutex_unlock(&ei->truncate_mutex);\n\t\t\tgoto cleanup;\n\t\t}\n\t}\n\n\text2_splice_branch(inode, iblock, partial, indirect_blks, count);\n\tmutex_unlock(&ei->truncate_mutex);\n\tset_buffer_new(bh_result);\ngot_it:\n\tmap_bh(bh_result, inode->i_sb, le32_to_cpu(chain[depth-1].key));\n\tif (count > blocks_to_boundary)\n\t\tset_buffer_boundary(bh_result);\n\terr = count;\n\t/* Clean up and exit */\n\tpartial = chain + depth - 1;\t/* the whole chain */\ncleanup:\n\twhile (partial > chain) {\n\t\tbrelse(partial->bh);\n\t\tpartial--;\n\t}\n\treturn err;\n}",
          "includes": [
            "#include \"xattr.h\"",
            "#include \"acl.h\"",
            "#include \"ext2.h\"",
            "#include <linux/aio.h>",
            "#include <linux/namei.h>",
            "#include <linux/fiemap.h>",
            "#include <linux/mpage.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/writeback.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highuid.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xattr.h\"\n#include \"acl.h\"\n#include \"ext2.h\"\n#include <linux/aio.h>\n#include <linux/namei.h>\n#include <linux/fiemap.h>\n#include <linux/mpage.h>\n#include <linux/buffer_head.h>\n#include <linux/writeback.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/highuid.h>\n#include <linux/time.h>\n\nstatic int ext2_get_blocks(struct inode *inode,\n\t\t\t   sector_t iblock, unsigned long maxblocks,\n\t\t\t   struct buffer_head *bh_result,\n\t\t\t   int create)\n{\n\tint err = -EIO;\n\tint offsets[4];\n\tIndirect chain[4];\n\tIndirect *partial;\n\text2_fsblk_t goal;\n\tint indirect_blks;\n\tint blocks_to_boundary = 0;\n\tint depth;\n\tstruct ext2_inode_info *ei = EXT2_I(inode);\n\tint count = 0;\n\text2_fsblk_t first_block = 0;\n\n\tBUG_ON(maxblocks == 0);\n\n\tdepth = ext2_block_to_path(inode,iblock,offsets,&blocks_to_boundary);\n\n\tif (depth == 0)\n\t\treturn (err);\n\n\tpartial = ext2_get_branch(inode, depth, offsets, chain, &err);\n\t/* Simplest case - block found, no allocation needed */\n\tif (!partial) {\n\t\tfirst_block = le32_to_cpu(chain[depth - 1].key);\n\t\tclear_buffer_new(bh_result); /* What's this do? */\n\t\tcount++;\n\t\t/*map more blocks*/\n\t\twhile (count < maxblocks && count <= blocks_to_boundary) {\n\t\t\text2_fsblk_t blk;\n\n\t\t\tif (!verify_chain(chain, chain + depth - 1)) {\n\t\t\t\t/*\n\t\t\t\t * Indirect block might be removed by\n\t\t\t\t * truncate while we were reading it.\n\t\t\t\t * Handling of that case: forget what we've\n\t\t\t\t * got now, go to reread.\n\t\t\t\t */\n\t\t\t\terr = -EAGAIN;\n\t\t\t\tcount = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tblk = le32_to_cpu(*(chain[depth-1].p + count));\n\t\t\tif (blk == first_block + count)\n\t\t\t\tcount++;\n\t\t\telse\n\t\t\t\tbreak;\n\t\t}\n\t\tif (err != -EAGAIN)\n\t\t\tgoto got_it;\n\t}\n\n\t/* Next simple case - plain lookup or failed read of indirect block */\n\tif (!create || err == -EIO)\n\t\tgoto cleanup;\n\n\tmutex_lock(&ei->truncate_mutex);\n\t/*\n\t * If the indirect block is missing while we are reading\n\t * the chain(ext2_get_branch() returns -EAGAIN err), or\n\t * if the chain has been changed after we grab the semaphore,\n\t * (either because another process truncated this branch, or\n\t * another get_block allocated this branch) re-grab the chain to see if\n\t * the request block has been allocated or not.\n\t *\n\t * Since we already block the truncate/other get_block\n\t * at this point, we will have the current copy of the chain when we\n\t * splice the branch into the tree.\n\t */\n\tif (err == -EAGAIN || !verify_chain(chain, partial)) {\n\t\twhile (partial > chain) {\n\t\t\tbrelse(partial->bh);\n\t\t\tpartial--;\n\t\t}\n\t\tpartial = ext2_get_branch(inode, depth, offsets, chain, &err);\n\t\tif (!partial) {\n\t\t\tcount++;\n\t\t\tmutex_unlock(&ei->truncate_mutex);\n\t\t\tif (err)\n\t\t\t\tgoto cleanup;\n\t\t\tclear_buffer_new(bh_result);\n\t\t\tgoto got_it;\n\t\t}\n\t}\n\n\t/*\n\t * Okay, we need to do block allocation.  Lazily initialize the block\n\t * allocation info here if necessary\n\t*/\n\tif (S_ISREG(inode->i_mode) && (!ei->i_block_alloc_info))\n\t\text2_init_block_alloc_info(inode);\n\n\tgoal = ext2_find_goal(inode, iblock, partial);\n\n\t/* the number of blocks need to allocate for [d,t]indirect blocks */\n\tindirect_blks = (chain + depth) - partial - 1;\n\t/*\n\t * Next look up the indirect map to count the totoal number of\n\t * direct blocks to allocate for this branch.\n\t */\n\tcount = ext2_blks_to_allocate(partial, indirect_blks,\n\t\t\t\t\tmaxblocks, blocks_to_boundary);\n\t/*\n\t * XXX ???? Block out ext2_truncate while we alter the tree\n\t */\n\terr = ext2_alloc_branch(inode, indirect_blks, &count, goal,\n\t\t\t\toffsets + (partial - chain), partial);\n\n\tif (err) {\n\t\tmutex_unlock(&ei->truncate_mutex);\n\t\tgoto cleanup;\n\t}\n\n\tif (IS_DAX(inode)) {\n\t\t/*\n\t\t * block must be initialised before we put it in the tree\n\t\t * so that it's not found by another thread before it's\n\t\t * initialised\n\t\t */\n\t\terr = dax_clear_blocks(inode, le32_to_cpu(chain[depth-1].key),\n\t\t\t\t\t\t1 << inode->i_blkbits);\n\t\tif (err) {\n\t\t\tmutex_unlock(&ei->truncate_mutex);\n\t\t\tgoto cleanup;\n\t\t}\n\t}\n\n\text2_splice_branch(inode, iblock, partial, indirect_blks, count);\n\tmutex_unlock(&ei->truncate_mutex);\n\tset_buffer_new(bh_result);\ngot_it:\n\tmap_bh(bh_result, inode->i_sb, le32_to_cpu(chain[depth-1].key));\n\tif (count > blocks_to_boundary)\n\t\tset_buffer_boundary(bh_result);\n\terr = count;\n\t/* Clean up and exit */\n\tpartial = chain + depth - 1;\t/* the whole chain */\ncleanup:\n\twhile (partial > chain) {\n\t\tbrelse(partial->bh);\n\t\tpartial--;\n\t}\n\treturn err;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"xattr.h\"\n#include \"acl.h\"\n#include \"ext2.h\"\n#include <linux/aio.h>\n#include <linux/namei.h>\n#include <linux/fiemap.h>\n#include <linux/mpage.h>\n#include <linux/buffer_head.h>\n#include <linux/writeback.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/highuid.h>\n#include <linux/time.h>\n\nint ext2_get_block(struct inode *inode, sector_t iblock, struct buffer_head *bh_result, int create)\n{\n\tunsigned max_blocks = bh_result->b_size >> inode->i_blkbits;\n\tint ret = ext2_get_blocks(inode, iblock, max_blocks,\n\t\t\t      bh_result, create);\n\tif (ret > 0) {\n\t\tbh_result->b_size = (ret << inode->i_blkbits);\n\t\tret = 0;\n\t}\n\treturn ret;\n\n}"
  },
  {
    "function_name": "ext2_get_blocks",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext2/inode.c",
    "lines": "617-763",
    "snippet": "static int ext2_get_blocks(struct inode *inode,\n\t\t\t   sector_t iblock, unsigned long maxblocks,\n\t\t\t   struct buffer_head *bh_result,\n\t\t\t   int create)\n{\n\tint err = -EIO;\n\tint offsets[4];\n\tIndirect chain[4];\n\tIndirect *partial;\n\text2_fsblk_t goal;\n\tint indirect_blks;\n\tint blocks_to_boundary = 0;\n\tint depth;\n\tstruct ext2_inode_info *ei = EXT2_I(inode);\n\tint count = 0;\n\text2_fsblk_t first_block = 0;\n\n\tBUG_ON(maxblocks == 0);\n\n\tdepth = ext2_block_to_path(inode,iblock,offsets,&blocks_to_boundary);\n\n\tif (depth == 0)\n\t\treturn (err);\n\n\tpartial = ext2_get_branch(inode, depth, offsets, chain, &err);\n\t/* Simplest case - block found, no allocation needed */\n\tif (!partial) {\n\t\tfirst_block = le32_to_cpu(chain[depth - 1].key);\n\t\tclear_buffer_new(bh_result); /* What's this do? */\n\t\tcount++;\n\t\t/*map more blocks*/\n\t\twhile (count < maxblocks && count <= blocks_to_boundary) {\n\t\t\text2_fsblk_t blk;\n\n\t\t\tif (!verify_chain(chain, chain + depth - 1)) {\n\t\t\t\t/*\n\t\t\t\t * Indirect block might be removed by\n\t\t\t\t * truncate while we were reading it.\n\t\t\t\t * Handling of that case: forget what we've\n\t\t\t\t * got now, go to reread.\n\t\t\t\t */\n\t\t\t\terr = -EAGAIN;\n\t\t\t\tcount = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tblk = le32_to_cpu(*(chain[depth-1].p + count));\n\t\t\tif (blk == first_block + count)\n\t\t\t\tcount++;\n\t\t\telse\n\t\t\t\tbreak;\n\t\t}\n\t\tif (err != -EAGAIN)\n\t\t\tgoto got_it;\n\t}\n\n\t/* Next simple case - plain lookup or failed read of indirect block */\n\tif (!create || err == -EIO)\n\t\tgoto cleanup;\n\n\tmutex_lock(&ei->truncate_mutex);\n\t/*\n\t * If the indirect block is missing while we are reading\n\t * the chain(ext2_get_branch() returns -EAGAIN err), or\n\t * if the chain has been changed after we grab the semaphore,\n\t * (either because another process truncated this branch, or\n\t * another get_block allocated this branch) re-grab the chain to see if\n\t * the request block has been allocated or not.\n\t *\n\t * Since we already block the truncate/other get_block\n\t * at this point, we will have the current copy of the chain when we\n\t * splice the branch into the tree.\n\t */\n\tif (err == -EAGAIN || !verify_chain(chain, partial)) {\n\t\twhile (partial > chain) {\n\t\t\tbrelse(partial->bh);\n\t\t\tpartial--;\n\t\t}\n\t\tpartial = ext2_get_branch(inode, depth, offsets, chain, &err);\n\t\tif (!partial) {\n\t\t\tcount++;\n\t\t\tmutex_unlock(&ei->truncate_mutex);\n\t\t\tif (err)\n\t\t\t\tgoto cleanup;\n\t\t\tclear_buffer_new(bh_result);\n\t\t\tgoto got_it;\n\t\t}\n\t}\n\n\t/*\n\t * Okay, we need to do block allocation.  Lazily initialize the block\n\t * allocation info here if necessary\n\t*/\n\tif (S_ISREG(inode->i_mode) && (!ei->i_block_alloc_info))\n\t\text2_init_block_alloc_info(inode);\n\n\tgoal = ext2_find_goal(inode, iblock, partial);\n\n\t/* the number of blocks need to allocate for [d,t]indirect blocks */\n\tindirect_blks = (chain + depth) - partial - 1;\n\t/*\n\t * Next look up the indirect map to count the totoal number of\n\t * direct blocks to allocate for this branch.\n\t */\n\tcount = ext2_blks_to_allocate(partial, indirect_blks,\n\t\t\t\t\tmaxblocks, blocks_to_boundary);\n\t/*\n\t * XXX ???? Block out ext2_truncate while we alter the tree\n\t */\n\terr = ext2_alloc_branch(inode, indirect_blks, &count, goal,\n\t\t\t\toffsets + (partial - chain), partial);\n\n\tif (err) {\n\t\tmutex_unlock(&ei->truncate_mutex);\n\t\tgoto cleanup;\n\t}\n\n\tif (IS_DAX(inode)) {\n\t\t/*\n\t\t * block must be initialised before we put it in the tree\n\t\t * so that it's not found by another thread before it's\n\t\t * initialised\n\t\t */\n\t\terr = dax_clear_blocks(inode, le32_to_cpu(chain[depth-1].key),\n\t\t\t\t\t\t1 << inode->i_blkbits);\n\t\tif (err) {\n\t\t\tmutex_unlock(&ei->truncate_mutex);\n\t\t\tgoto cleanup;\n\t\t}\n\t}\n\n\text2_splice_branch(inode, iblock, partial, indirect_blks, count);\n\tmutex_unlock(&ei->truncate_mutex);\n\tset_buffer_new(bh_result);\ngot_it:\n\tmap_bh(bh_result, inode->i_sb, le32_to_cpu(chain[depth-1].key));\n\tif (count > blocks_to_boundary)\n\t\tset_buffer_boundary(bh_result);\n\terr = count;\n\t/* Clean up and exit */\n\tpartial = chain + depth - 1;\t/* the whole chain */\ncleanup:\n\twhile (partial > chain) {\n\t\tbrelse(partial->bh);\n\t\tpartial--;\n\t}\n\treturn err;\n}",
    "includes": [
      "#include \"xattr.h\"",
      "#include \"acl.h\"",
      "#include \"ext2.h\"",
      "#include <linux/aio.h>",
      "#include <linux/namei.h>",
      "#include <linux/fiemap.h>",
      "#include <linux/mpage.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/writeback.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/highuid.h>",
      "#include <linux/time.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "brelse",
          "args": [
            "partial->bh"
          ],
          "line": 759
        },
        "resolved": true,
        "details": {
          "function_name": "__brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1177-1184",
          "snippet": "void __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_buffer_boundary",
          "args": [
            "bh_result"
          ],
          "line": 753
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "map_bh",
          "args": [
            "bh_result",
            "inode->i_sb",
            "le32_to_cpu(chain[depth-1].key)"
          ],
          "line": 751
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "chain[depth-1].key"
          ],
          "line": 751
        },
        "resolved": true,
        "details": {
          "function_name": "sle32_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "53-56",
          "snippet": "static inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_buffer_new",
          "args": [
            "bh_result"
          ],
          "line": 749
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&ei->truncate_mutex"
          ],
          "line": 748
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext2_splice_branch",
          "args": [
            "inode",
            "iblock",
            "partial",
            "indirect_blks",
            "count"
          ],
          "line": 747
        },
        "resolved": true,
        "details": {
          "function_name": "ext2_splice_branch",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext2/inode.c",
          "lines": "554-597",
          "snippet": "static void ext2_splice_branch(struct inode *inode,\n\t\t\tlong block, Indirect *where, int num, int blks)\n{\n\tint i;\n\tstruct ext2_block_alloc_info *block_i;\n\text2_fsblk_t current_block;\n\n\tblock_i = EXT2_I(inode)->i_block_alloc_info;\n\n\t/* XXX LOCKING probably should have i_meta_lock ?*/\n\t/* That's it */\n\n\t*where->p = where->key;\n\n\t/*\n\t * Update the host buffer_head or inode to point to more just allocated\n\t * direct blocks blocks\n\t */\n\tif (num == 0 && blks > 1) {\n\t\tcurrent_block = le32_to_cpu(where->key) + 1;\n\t\tfor (i = 1; i < blks; i++)\n\t\t\t*(where->p + i ) = cpu_to_le32(current_block++);\n\t}\n\n\t/*\n\t * update the most recently allocated logical & physical block\n\t * in i_block_alloc_info, to assist find the proper goal block for next\n\t * allocation\n\t */\n\tif (block_i) {\n\t\tblock_i->last_alloc_logical_block = block + blks - 1;\n\t\tblock_i->last_alloc_physical_block =\n\t\t\t\tle32_to_cpu(where[num].key) + blks - 1;\n\t}\n\n\t/* We are done with atomic stuff, now do the rest of housekeeping */\n\n\t/* had we spliced it onto indirect block? */\n\tif (where->bh)\n\t\tmark_buffer_dirty_inode(where->bh, inode);\n\n\tinode->i_ctime = CURRENT_TIME_SEC;\n\tmark_inode_dirty(inode);\n}",
          "includes": [
            "#include \"xattr.h\"",
            "#include \"acl.h\"",
            "#include \"ext2.h\"",
            "#include <linux/aio.h>",
            "#include <linux/namei.h>",
            "#include <linux/fiemap.h>",
            "#include <linux/mpage.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/writeback.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highuid.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xattr.h\"\n#include \"acl.h\"\n#include \"ext2.h\"\n#include <linux/aio.h>\n#include <linux/namei.h>\n#include <linux/fiemap.h>\n#include <linux/mpage.h>\n#include <linux/buffer_head.h>\n#include <linux/writeback.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/highuid.h>\n#include <linux/time.h>\n\nstatic void ext2_splice_branch(struct inode *inode,\n\t\t\tlong block, Indirect *where, int num, int blks)\n{\n\tint i;\n\tstruct ext2_block_alloc_info *block_i;\n\text2_fsblk_t current_block;\n\n\tblock_i = EXT2_I(inode)->i_block_alloc_info;\n\n\t/* XXX LOCKING probably should have i_meta_lock ?*/\n\t/* That's it */\n\n\t*where->p = where->key;\n\n\t/*\n\t * Update the host buffer_head or inode to point to more just allocated\n\t * direct blocks blocks\n\t */\n\tif (num == 0 && blks > 1) {\n\t\tcurrent_block = le32_to_cpu(where->key) + 1;\n\t\tfor (i = 1; i < blks; i++)\n\t\t\t*(where->p + i ) = cpu_to_le32(current_block++);\n\t}\n\n\t/*\n\t * update the most recently allocated logical & physical block\n\t * in i_block_alloc_info, to assist find the proper goal block for next\n\t * allocation\n\t */\n\tif (block_i) {\n\t\tblock_i->last_alloc_logical_block = block + blks - 1;\n\t\tblock_i->last_alloc_physical_block =\n\t\t\t\tle32_to_cpu(where[num].key) + blks - 1;\n\t}\n\n\t/* We are done with atomic stuff, now do the rest of housekeeping */\n\n\t/* had we spliced it onto indirect block? */\n\tif (where->bh)\n\t\tmark_buffer_dirty_inode(where->bh, inode);\n\n\tinode->i_ctime = CURRENT_TIME_SEC;\n\tmark_inode_dirty(inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&ei->truncate_mutex"
          ],
          "line": 742
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dax_clear_blocks",
          "args": [
            "inode",
            "le32_to_cpu(chain[depth-1].key)",
            "1 << inode->i_blkbits"
          ],
          "line": 739
        },
        "resolved": true,
        "details": {
          "function_name": "dax_clear_blocks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dax.c",
          "lines": "30-63",
          "snippet": "int dax_clear_blocks(struct inode *inode, sector_t block, long size)\n{\n\tstruct block_device *bdev = inode->i_sb->s_bdev;\n\tsector_t sector = block << (inode->i_blkbits - 9);\n\n\tmight_sleep();\n\tdo {\n\t\tvoid *addr;\n\t\tunsigned long pfn;\n\t\tlong count;\n\n\t\tcount = bdev_direct_access(bdev, sector, &addr, &pfn, size);\n\t\tif (count < 0)\n\t\t\treturn count;\n\t\tBUG_ON(size < count);\n\t\twhile (count > 0) {\n\t\t\tunsigned pgsz = PAGE_SIZE - offset_in_page(addr);\n\t\t\tif (pgsz > count)\n\t\t\t\tpgsz = count;\n\t\t\tif (pgsz < PAGE_SIZE)\n\t\t\t\tmemset(addr, 0, pgsz);\n\t\t\telse\n\t\t\t\tclear_page(addr);\n\t\t\taddr += pgsz;\n\t\t\tsize -= pgsz;\n\t\t\tcount -= pgsz;\n\t\t\tBUG_ON(pgsz & 511);\n\t\t\tsector += pgsz / 512;\n\t\t\tcond_resched();\n\t\t}\n\t} while (size);\n\n\treturn 0;\n}",
          "includes": [
            "#include <linux/vmstat.h>",
            "#include <linux/uio.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>",
            "#include <linux/mm.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/highmem.h>",
            "#include <linux/genhd.h>",
            "#include <linux/fs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/atomic.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/vmstat.h>\n#include <linux/uio.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n#include <linux/mm.h>\n#include <linux/memcontrol.h>\n#include <linux/highmem.h>\n#include <linux/genhd.h>\n#include <linux/fs.h>\n#include <linux/buffer_head.h>\n#include <linux/blkdev.h>\n#include <linux/atomic.h>\n\nint dax_clear_blocks(struct inode *inode, sector_t block, long size)\n{\n\tstruct block_device *bdev = inode->i_sb->s_bdev;\n\tsector_t sector = block << (inode->i_blkbits - 9);\n\n\tmight_sleep();\n\tdo {\n\t\tvoid *addr;\n\t\tunsigned long pfn;\n\t\tlong count;\n\n\t\tcount = bdev_direct_access(bdev, sector, &addr, &pfn, size);\n\t\tif (count < 0)\n\t\t\treturn count;\n\t\tBUG_ON(size < count);\n\t\twhile (count > 0) {\n\t\t\tunsigned pgsz = PAGE_SIZE - offset_in_page(addr);\n\t\t\tif (pgsz > count)\n\t\t\t\tpgsz = count;\n\t\t\tif (pgsz < PAGE_SIZE)\n\t\t\t\tmemset(addr, 0, pgsz);\n\t\t\telse\n\t\t\t\tclear_page(addr);\n\t\t\taddr += pgsz;\n\t\t\tsize -= pgsz;\n\t\t\tcount -= pgsz;\n\t\t\tBUG_ON(pgsz & 511);\n\t\t\tsector += pgsz / 512;\n\t\t\tcond_resched();\n\t\t}\n\t} while (size);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_DAX",
          "args": [
            "inode"
          ],
          "line": 733
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&ei->truncate_mutex"
          ],
          "line": 729
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext2_alloc_branch",
          "args": [
            "inode",
            "indirect_blks",
            "&count",
            "goal",
            "offsets + (partial - chain)",
            "partial"
          ],
          "line": 725
        },
        "resolved": true,
        "details": {
          "function_name": "ext2_alloc_branch",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext2/inode.c",
          "lines": "472-540",
          "snippet": "static int ext2_alloc_branch(struct inode *inode,\n\t\t\tint indirect_blks, int *blks, ext2_fsblk_t goal,\n\t\t\tint *offsets, Indirect *branch)\n{\n\tint blocksize = inode->i_sb->s_blocksize;\n\tint i, n = 0;\n\tint err = 0;\n\tstruct buffer_head *bh;\n\tint num;\n\text2_fsblk_t new_blocks[4];\n\text2_fsblk_t current_block;\n\n\tnum = ext2_alloc_blocks(inode, goal, indirect_blks,\n\t\t\t\t*blks, new_blocks, &err);\n\tif (err)\n\t\treturn err;\n\n\tbranch[0].key = cpu_to_le32(new_blocks[0]);\n\t/*\n\t * metadata blocks and data blocks are allocated.\n\t */\n\tfor (n = 1; n <= indirect_blks;  n++) {\n\t\t/*\n\t\t * Get buffer_head for parent block, zero it out\n\t\t * and set the pointer to new one, then send\n\t\t * parent to disk.\n\t\t */\n\t\tbh = sb_getblk(inode->i_sb, new_blocks[n-1]);\n\t\tif (unlikely(!bh)) {\n\t\t\terr = -ENOMEM;\n\t\t\tgoto failed;\n\t\t}\n\t\tbranch[n].bh = bh;\n\t\tlock_buffer(bh);\n\t\tmemset(bh->b_data, 0, blocksize);\n\t\tbranch[n].p = (__le32 *) bh->b_data + offsets[n];\n\t\tbranch[n].key = cpu_to_le32(new_blocks[n]);\n\t\t*branch[n].p = branch[n].key;\n\t\tif ( n == indirect_blks) {\n\t\t\tcurrent_block = new_blocks[n];\n\t\t\t/*\n\t\t\t * End of chain, update the last new metablock of\n\t\t\t * the chain to point to the new allocated\n\t\t\t * data blocks numbers\n\t\t\t */\n\t\t\tfor (i=1; i < num; i++)\n\t\t\t\t*(branch[n].p + i) = cpu_to_le32(++current_block);\n\t\t}\n\t\tset_buffer_uptodate(bh);\n\t\tunlock_buffer(bh);\n\t\tmark_buffer_dirty_inode(bh, inode);\n\t\t/* We used to sync bh here if IS_SYNC(inode).\n\t\t * But we now rely upon generic_write_sync()\n\t\t * and b_inode_buffers.  But not for directories.\n\t\t */\n\t\tif (S_ISDIR(inode->i_mode) && IS_DIRSYNC(inode))\n\t\t\tsync_dirty_buffer(bh);\n\t}\n\t*blks = num;\n\treturn err;\n\nfailed:\n\tfor (i = 1; i < n; i++)\n\t\tbforget(branch[i].bh);\n\tfor (i = 0; i < indirect_blks; i++)\n\t\text2_free_blocks(inode, new_blocks[i], 1);\n\text2_free_blocks(inode, new_blocks[i], num);\n\treturn err;\n}",
          "includes": [
            "#include \"xattr.h\"",
            "#include \"acl.h\"",
            "#include \"ext2.h\"",
            "#include <linux/aio.h>",
            "#include <linux/namei.h>",
            "#include <linux/fiemap.h>",
            "#include <linux/mpage.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/writeback.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highuid.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xattr.h\"\n#include \"acl.h\"\n#include \"ext2.h\"\n#include <linux/aio.h>\n#include <linux/namei.h>\n#include <linux/fiemap.h>\n#include <linux/mpage.h>\n#include <linux/buffer_head.h>\n#include <linux/writeback.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/highuid.h>\n#include <linux/time.h>\n\nstatic int ext2_alloc_branch(struct inode *inode,\n\t\t\tint indirect_blks, int *blks, ext2_fsblk_t goal,\n\t\t\tint *offsets, Indirect *branch)\n{\n\tint blocksize = inode->i_sb->s_blocksize;\n\tint i, n = 0;\n\tint err = 0;\n\tstruct buffer_head *bh;\n\tint num;\n\text2_fsblk_t new_blocks[4];\n\text2_fsblk_t current_block;\n\n\tnum = ext2_alloc_blocks(inode, goal, indirect_blks,\n\t\t\t\t*blks, new_blocks, &err);\n\tif (err)\n\t\treturn err;\n\n\tbranch[0].key = cpu_to_le32(new_blocks[0]);\n\t/*\n\t * metadata blocks and data blocks are allocated.\n\t */\n\tfor (n = 1; n <= indirect_blks;  n++) {\n\t\t/*\n\t\t * Get buffer_head for parent block, zero it out\n\t\t * and set the pointer to new one, then send\n\t\t * parent to disk.\n\t\t */\n\t\tbh = sb_getblk(inode->i_sb, new_blocks[n-1]);\n\t\tif (unlikely(!bh)) {\n\t\t\terr = -ENOMEM;\n\t\t\tgoto failed;\n\t\t}\n\t\tbranch[n].bh = bh;\n\t\tlock_buffer(bh);\n\t\tmemset(bh->b_data, 0, blocksize);\n\t\tbranch[n].p = (__le32 *) bh->b_data + offsets[n];\n\t\tbranch[n].key = cpu_to_le32(new_blocks[n]);\n\t\t*branch[n].p = branch[n].key;\n\t\tif ( n == indirect_blks) {\n\t\t\tcurrent_block = new_blocks[n];\n\t\t\t/*\n\t\t\t * End of chain, update the last new metablock of\n\t\t\t * the chain to point to the new allocated\n\t\t\t * data blocks numbers\n\t\t\t */\n\t\t\tfor (i=1; i < num; i++)\n\t\t\t\t*(branch[n].p + i) = cpu_to_le32(++current_block);\n\t\t}\n\t\tset_buffer_uptodate(bh);\n\t\tunlock_buffer(bh);\n\t\tmark_buffer_dirty_inode(bh, inode);\n\t\t/* We used to sync bh here if IS_SYNC(inode).\n\t\t * But we now rely upon generic_write_sync()\n\t\t * and b_inode_buffers.  But not for directories.\n\t\t */\n\t\tif (S_ISDIR(inode->i_mode) && IS_DIRSYNC(inode))\n\t\t\tsync_dirty_buffer(bh);\n\t}\n\t*blks = num;\n\treturn err;\n\nfailed:\n\tfor (i = 1; i < n; i++)\n\t\tbforget(branch[i].bh);\n\tfor (i = 0; i < indirect_blks; i++)\n\t\text2_free_blocks(inode, new_blocks[i], 1);\n\text2_free_blocks(inode, new_blocks[i], num);\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext2_blks_to_allocate",
          "args": [
            "partial",
            "indirect_blks",
            "maxblocks",
            "blocks_to_boundary"
          ],
          "line": 720
        },
        "resolved": true,
        "details": {
          "function_name": "ext2_blks_to_allocate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext2/inode.c",
          "lines": "357-382",
          "snippet": "static int\next2_blks_to_allocate(Indirect * branch, int k, unsigned long blks,\n\t\tint blocks_to_boundary)\n{\n\tunsigned long count = 0;\n\n\t/*\n\t * Simple case, [t,d]Indirect block(s) has not allocated yet\n\t * then it's clear blocks on that path have not allocated\n\t */\n\tif (k > 0) {\n\t\t/* right now don't hanel cross boundary allocation */\n\t\tif (blks < blocks_to_boundary + 1)\n\t\t\tcount += blks;\n\t\telse\n\t\t\tcount += blocks_to_boundary + 1;\n\t\treturn count;\n\t}\n\n\tcount++;\n\twhile (count < blks && count <= blocks_to_boundary\n\t\t&& le32_to_cpu(*(branch[0].p + count)) == 0) {\n\t\tcount++;\n\t}\n\treturn count;\n}",
          "includes": [
            "#include \"xattr.h\"",
            "#include \"acl.h\"",
            "#include \"ext2.h\"",
            "#include <linux/aio.h>",
            "#include <linux/namei.h>",
            "#include <linux/fiemap.h>",
            "#include <linux/mpage.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/writeback.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highuid.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xattr.h\"\n#include \"acl.h\"\n#include \"ext2.h\"\n#include <linux/aio.h>\n#include <linux/namei.h>\n#include <linux/fiemap.h>\n#include <linux/mpage.h>\n#include <linux/buffer_head.h>\n#include <linux/writeback.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/highuid.h>\n#include <linux/time.h>\n\nstatic int\next2_blks_to_allocate(Indirect * branch, int k, unsigned long blks,\n\t\tint blocks_to_boundary)\n{\n\tunsigned long count = 0;\n\n\t/*\n\t * Simple case, [t,d]Indirect block(s) has not allocated yet\n\t * then it's clear blocks on that path have not allocated\n\t */\n\tif (k > 0) {\n\t\t/* right now don't hanel cross boundary allocation */\n\t\tif (blks < blocks_to_boundary + 1)\n\t\t\tcount += blks;\n\t\telse\n\t\t\tcount += blocks_to_boundary + 1;\n\t\treturn count;\n\t}\n\n\tcount++;\n\twhile (count < blks && count <= blocks_to_boundary\n\t\t&& le32_to_cpu(*(branch[0].p + count)) == 0) {\n\t\tcount++;\n\t}\n\treturn count;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext2_find_goal",
          "args": [
            "inode",
            "iblock",
            "partial"
          ],
          "line": 712
        },
        "resolved": true,
        "details": {
          "function_name": "ext2_find_goal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext2/inode.c",
          "lines": "326-343",
          "snippet": "static inline ext2_fsblk_t ext2_find_goal(struct inode *inode, long block,\n\t\t\t\t\t  Indirect *partial)\n{\n\tstruct ext2_block_alloc_info *block_i;\n\n\tblock_i = EXT2_I(inode)->i_block_alloc_info;\n\n\t/*\n\t * try the heuristic for sequential allocation,\n\t * failing that at least try to get decent locality.\n\t */\n\tif (block_i && (block == block_i->last_alloc_logical_block + 1)\n\t\t&& (block_i->last_alloc_physical_block != 0)) {\n\t\treturn block_i->last_alloc_physical_block + 1;\n\t}\n\n\treturn ext2_find_near(inode, partial);\n}",
          "includes": [
            "#include \"xattr.h\"",
            "#include \"acl.h\"",
            "#include \"ext2.h\"",
            "#include <linux/aio.h>",
            "#include <linux/namei.h>",
            "#include <linux/fiemap.h>",
            "#include <linux/mpage.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/writeback.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highuid.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xattr.h\"\n#include \"acl.h\"\n#include \"ext2.h\"\n#include <linux/aio.h>\n#include <linux/namei.h>\n#include <linux/fiemap.h>\n#include <linux/mpage.h>\n#include <linux/buffer_head.h>\n#include <linux/writeback.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/highuid.h>\n#include <linux/time.h>\n\nstatic inline ext2_fsblk_t ext2_find_goal(struct inode *inode, long block,\n\t\t\t\t\t  Indirect *partial)\n{\n\tstruct ext2_block_alloc_info *block_i;\n\n\tblock_i = EXT2_I(inode)->i_block_alloc_info;\n\n\t/*\n\t * try the heuristic for sequential allocation,\n\t * failing that at least try to get decent locality.\n\t */\n\tif (block_i && (block == block_i->last_alloc_logical_block + 1)\n\t\t&& (block_i->last_alloc_physical_block != 0)) {\n\t\treturn block_i->last_alloc_physical_block + 1;\n\t}\n\n\treturn ext2_find_near(inode, partial);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext2_init_block_alloc_info",
          "args": [
            "inode"
          ],
          "line": 710
        },
        "resolved": true,
        "details": {
          "function_name": "ext2_init_block_alloc_info",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext2/balloc.c",
          "lines": "410-437",
          "snippet": "void ext2_init_block_alloc_info(struct inode *inode)\n{\n\tstruct ext2_inode_info *ei = EXT2_I(inode);\n\tstruct ext2_block_alloc_info *block_i;\n\tstruct super_block *sb = inode->i_sb;\n\n\tblock_i = kmalloc(sizeof(*block_i), GFP_NOFS);\n\tif (block_i) {\n\t\tstruct ext2_reserve_window_node *rsv = &block_i->rsv_window_node;\n\n\t\trsv->rsv_start = EXT2_RESERVE_WINDOW_NOT_ALLOCATED;\n\t\trsv->rsv_end = EXT2_RESERVE_WINDOW_NOT_ALLOCATED;\n\n\t \t/*\n\t\t * if filesystem is mounted with NORESERVATION, the goal\n\t\t * reservation window size is set to zero to indicate\n\t\t * block reservation is off\n\t\t */\n\t\tif (!test_opt(sb, RESERVATION))\n\t\t\trsv->rsv_goal_size = 0;\n\t\telse\n\t\t\trsv->rsv_goal_size = EXT2_DEFAULT_RESERVE_BLOCKS;\n\t\trsv->rsv_alloc_hit = 0;\n\t\tblock_i->last_alloc_logical_block = 0;\n\t\tblock_i->last_alloc_physical_block = 0;\n\t}\n\tei->i_block_alloc_info = block_i;\n}",
          "includes": [
            "#include <linux/capability.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/quotaops.h>",
            "#include \"ext2.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/capability.h>\n#include <linux/buffer_head.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/quotaops.h>\n#include \"ext2.h\"\n\nvoid ext2_init_block_alloc_info(struct inode *inode)\n{\n\tstruct ext2_inode_info *ei = EXT2_I(inode);\n\tstruct ext2_block_alloc_info *block_i;\n\tstruct super_block *sb = inode->i_sb;\n\n\tblock_i = kmalloc(sizeof(*block_i), GFP_NOFS);\n\tif (block_i) {\n\t\tstruct ext2_reserve_window_node *rsv = &block_i->rsv_window_node;\n\n\t\trsv->rsv_start = EXT2_RESERVE_WINDOW_NOT_ALLOCATED;\n\t\trsv->rsv_end = EXT2_RESERVE_WINDOW_NOT_ALLOCATED;\n\n\t \t/*\n\t\t * if filesystem is mounted with NORESERVATION, the goal\n\t\t * reservation window size is set to zero to indicate\n\t\t * block reservation is off\n\t\t */\n\t\tif (!test_opt(sb, RESERVATION))\n\t\t\trsv->rsv_goal_size = 0;\n\t\telse\n\t\t\trsv->rsv_goal_size = EXT2_DEFAULT_RESERVE_BLOCKS;\n\t\trsv->rsv_alloc_hit = 0;\n\t\tblock_i->last_alloc_logical_block = 0;\n\t\tblock_i->last_alloc_physical_block = 0;\n\t}\n\tei->i_block_alloc_info = block_i;\n}"
        }
      },
      {
        "call_info": {
          "callee": "S_ISREG",
          "args": [
            "inode->i_mode"
          ],
          "line": 709
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "clear_buffer_new",
          "args": [
            "bh_result"
          ],
          "line": 700
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&ei->truncate_mutex"
          ],
          "line": 697
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext2_get_branch",
          "args": [
            "inode",
            "depth",
            "offsets",
            "chain",
            "&err"
          ],
          "line": 694
        },
        "resolved": true,
        "details": {
          "function_name": "ext2_get_branch",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext2/inode.c",
          "lines": "230-268",
          "snippet": "static Indirect *ext2_get_branch(struct inode *inode,\n\t\t\t\t int depth,\n\t\t\t\t int *offsets,\n\t\t\t\t Indirect chain[4],\n\t\t\t\t int *err)\n{\n\tstruct super_block *sb = inode->i_sb;\n\tIndirect *p = chain;\n\tstruct buffer_head *bh;\n\n\t*err = 0;\n\t/* i_data is not going away, no lock needed */\n\tadd_chain (chain, NULL, EXT2_I(inode)->i_data + *offsets);\n\tif (!p->key)\n\t\tgoto no_block;\n\twhile (--depth) {\n\t\tbh = sb_bread(sb, le32_to_cpu(p->key));\n\t\tif (!bh)\n\t\t\tgoto failure;\n\t\tread_lock(&EXT2_I(inode)->i_meta_lock);\n\t\tif (!verify_chain(chain, p))\n\t\t\tgoto changed;\n\t\tadd_chain(++p, bh, (__le32*)bh->b_data + *++offsets);\n\t\tread_unlock(&EXT2_I(inode)->i_meta_lock);\n\t\tif (!p->key)\n\t\t\tgoto no_block;\n\t}\n\treturn NULL;\n\nchanged:\n\tread_unlock(&EXT2_I(inode)->i_meta_lock);\n\tbrelse(bh);\n\t*err = -EAGAIN;\n\tgoto no_block;\nfailure:\n\t*err = -EIO;\nno_block:\n\treturn p;\n}",
          "includes": [
            "#include \"xattr.h\"",
            "#include \"acl.h\"",
            "#include \"ext2.h\"",
            "#include <linux/aio.h>",
            "#include <linux/namei.h>",
            "#include <linux/fiemap.h>",
            "#include <linux/mpage.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/writeback.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highuid.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xattr.h\"\n#include \"acl.h\"\n#include \"ext2.h\"\n#include <linux/aio.h>\n#include <linux/namei.h>\n#include <linux/fiemap.h>\n#include <linux/mpage.h>\n#include <linux/buffer_head.h>\n#include <linux/writeback.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/highuid.h>\n#include <linux/time.h>\n\nstatic Indirect *ext2_get_branch(struct inode *inode,\n\t\t\t\t int depth,\n\t\t\t\t int *offsets,\n\t\t\t\t Indirect chain[4],\n\t\t\t\t int *err)\n{\n\tstruct super_block *sb = inode->i_sb;\n\tIndirect *p = chain;\n\tstruct buffer_head *bh;\n\n\t*err = 0;\n\t/* i_data is not going away, no lock needed */\n\tadd_chain (chain, NULL, EXT2_I(inode)->i_data + *offsets);\n\tif (!p->key)\n\t\tgoto no_block;\n\twhile (--depth) {\n\t\tbh = sb_bread(sb, le32_to_cpu(p->key));\n\t\tif (!bh)\n\t\t\tgoto failure;\n\t\tread_lock(&EXT2_I(inode)->i_meta_lock);\n\t\tif (!verify_chain(chain, p))\n\t\t\tgoto changed;\n\t\tadd_chain(++p, bh, (__le32*)bh->b_data + *++offsets);\n\t\tread_unlock(&EXT2_I(inode)->i_meta_lock);\n\t\tif (!p->key)\n\t\t\tgoto no_block;\n\t}\n\treturn NULL;\n\nchanged:\n\tread_unlock(&EXT2_I(inode)->i_meta_lock);\n\tbrelse(bh);\n\t*err = -EAGAIN;\n\tgoto no_block;\nfailure:\n\t*err = -EIO;\nno_block:\n\treturn p;\n}"
        }
      },
      {
        "call_info": {
          "callee": "verify_chain",
          "args": [
            "chain",
            "partial"
          ],
          "line": 689
        },
        "resolved": true,
        "details": {
          "function_name": "verify_chain",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext2/inode.c",
          "lines": "122-127",
          "snippet": "static inline int verify_chain(Indirect *from, Indirect *to)\n{\n\twhile (from <= to && from->key == *from->p)\n\t\tfrom++;\n\treturn (from > to);\n}",
          "includes": [
            "#include \"xattr.h\"",
            "#include \"acl.h\"",
            "#include \"ext2.h\"",
            "#include <linux/aio.h>",
            "#include <linux/namei.h>",
            "#include <linux/fiemap.h>",
            "#include <linux/mpage.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/writeback.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highuid.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xattr.h\"\n#include \"acl.h\"\n#include \"ext2.h\"\n#include <linux/aio.h>\n#include <linux/namei.h>\n#include <linux/fiemap.h>\n#include <linux/mpage.h>\n#include <linux/buffer_head.h>\n#include <linux/writeback.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/highuid.h>\n#include <linux/time.h>\n\nstatic inline int verify_chain(Indirect *from, Indirect *to)\n{\n\twhile (from <= to && from->key == *from->p)\n\t\tfrom++;\n\treturn (from > to);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&ei->truncate_mutex"
          ],
          "line": 676
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "clear_buffer_new",
          "args": [
            "bh_result"
          ],
          "line": 645
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext2_block_to_path",
          "args": [
            "inode",
            "iblock",
            "offsets",
            "&blocks_to_boundary"
          ],
          "line": 636
        },
        "resolved": true,
        "details": {
          "function_name": "ext2_block_to_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext2/inode.c",
          "lines": "159-199",
          "snippet": "static int ext2_block_to_path(struct inode *inode,\n\t\t\tlong i_block, int offsets[4], int *boundary)\n{\n\tint ptrs = EXT2_ADDR_PER_BLOCK(inode->i_sb);\n\tint ptrs_bits = EXT2_ADDR_PER_BLOCK_BITS(inode->i_sb);\n\tconst long direct_blocks = EXT2_NDIR_BLOCKS,\n\t\tindirect_blocks = ptrs,\n\t\tdouble_blocks = (1 << (ptrs_bits * 2));\n\tint n = 0;\n\tint final = 0;\n\n\tif (i_block < 0) {\n\t\text2_msg(inode->i_sb, KERN_WARNING,\n\t\t\t\"warning: %s: block < 0\", __func__);\n\t} else if (i_block < direct_blocks) {\n\t\toffsets[n++] = i_block;\n\t\tfinal = direct_blocks;\n\t} else if ( (i_block -= direct_blocks) < indirect_blocks) {\n\t\toffsets[n++] = EXT2_IND_BLOCK;\n\t\toffsets[n++] = i_block;\n\t\tfinal = ptrs;\n\t} else if ((i_block -= indirect_blocks) < double_blocks) {\n\t\toffsets[n++] = EXT2_DIND_BLOCK;\n\t\toffsets[n++] = i_block >> ptrs_bits;\n\t\toffsets[n++] = i_block & (ptrs - 1);\n\t\tfinal = ptrs;\n\t} else if (((i_block -= double_blocks) >> (ptrs_bits * 2)) < ptrs) {\n\t\toffsets[n++] = EXT2_TIND_BLOCK;\n\t\toffsets[n++] = i_block >> (ptrs_bits * 2);\n\t\toffsets[n++] = (i_block >> ptrs_bits) & (ptrs - 1);\n\t\toffsets[n++] = i_block & (ptrs - 1);\n\t\tfinal = ptrs;\n\t} else {\n\t\text2_msg(inode->i_sb, KERN_WARNING,\n\t\t\t\"warning: %s: block is too big\", __func__);\n\t}\n\tif (boundary)\n\t\t*boundary = final - 1 - (i_block & (ptrs - 1));\n\n\treturn n;\n}",
          "includes": [
            "#include \"xattr.h\"",
            "#include \"acl.h\"",
            "#include \"ext2.h\"",
            "#include <linux/aio.h>",
            "#include <linux/namei.h>",
            "#include <linux/fiemap.h>",
            "#include <linux/mpage.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/writeback.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highuid.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xattr.h\"\n#include \"acl.h\"\n#include \"ext2.h\"\n#include <linux/aio.h>\n#include <linux/namei.h>\n#include <linux/fiemap.h>\n#include <linux/mpage.h>\n#include <linux/buffer_head.h>\n#include <linux/writeback.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/highuid.h>\n#include <linux/time.h>\n\nstatic int ext2_block_to_path(struct inode *inode,\n\t\t\tlong i_block, int offsets[4], int *boundary)\n{\n\tint ptrs = EXT2_ADDR_PER_BLOCK(inode->i_sb);\n\tint ptrs_bits = EXT2_ADDR_PER_BLOCK_BITS(inode->i_sb);\n\tconst long direct_blocks = EXT2_NDIR_BLOCKS,\n\t\tindirect_blocks = ptrs,\n\t\tdouble_blocks = (1 << (ptrs_bits * 2));\n\tint n = 0;\n\tint final = 0;\n\n\tif (i_block < 0) {\n\t\text2_msg(inode->i_sb, KERN_WARNING,\n\t\t\t\"warning: %s: block < 0\", __func__);\n\t} else if (i_block < direct_blocks) {\n\t\toffsets[n++] = i_block;\n\t\tfinal = direct_blocks;\n\t} else if ( (i_block -= direct_blocks) < indirect_blocks) {\n\t\toffsets[n++] = EXT2_IND_BLOCK;\n\t\toffsets[n++] = i_block;\n\t\tfinal = ptrs;\n\t} else if ((i_block -= indirect_blocks) < double_blocks) {\n\t\toffsets[n++] = EXT2_DIND_BLOCK;\n\t\toffsets[n++] = i_block >> ptrs_bits;\n\t\toffsets[n++] = i_block & (ptrs - 1);\n\t\tfinal = ptrs;\n\t} else if (((i_block -= double_blocks) >> (ptrs_bits * 2)) < ptrs) {\n\t\toffsets[n++] = EXT2_TIND_BLOCK;\n\t\toffsets[n++] = i_block >> (ptrs_bits * 2);\n\t\toffsets[n++] = (i_block >> ptrs_bits) & (ptrs - 1);\n\t\toffsets[n++] = i_block & (ptrs - 1);\n\t\tfinal = ptrs;\n\t} else {\n\t\text2_msg(inode->i_sb, KERN_WARNING,\n\t\t\t\"warning: %s: block is too big\", __func__);\n\t}\n\tif (boundary)\n\t\t*boundary = final - 1 - (i_block & (ptrs - 1));\n\n\treturn n;\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "maxblocks == 0"
          ],
          "line": 634
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXT2_I",
          "args": [
            "inode"
          ],
          "line": 630
        },
        "resolved": true,
        "details": {
          "function_name": "EXT2_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext2/ext2.h",
          "lines": "717-720",
          "snippet": "static inline struct ext2_inode_info *EXT2_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ext2_inode_info, vfs_inode);\n}",
          "includes": [
            "#include <linux/rbtree.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/ext2_fs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern ext2_fsblk_t ext2_new_block(struct inode *, unsigned long, int *);",
            "extern ext2_fsblk_t ext2_new_blocks(struct inode *, unsigned long,\n\t\t\t\tunsigned long *, int *);",
            "extern void ext2_free_blocks (struct inode *, unsigned long,\n\t\t\t      unsigned long);",
            "extern void ext2_discard_reservation (struct inode *);",
            "extern void ext2_init_block_alloc_info(struct inode *);",
            "extern int ext2_add_link (struct dentry *, struct inode *);",
            "extern int ext2_make_empty(struct inode *, struct inode *);",
            "extern int ext2_empty_dir (struct inode *);",
            "extern void ext2_set_link(struct inode *, struct ext2_dir_entry_2 *, struct page *, struct inode *, int);",
            "extern void ext2_free_inode (struct inode *);",
            "extern void ext2_evict_inode(struct inode *);",
            "extern void ext2_set_inode_flags(struct inode *inode);",
            "extern void ext2_get_inode_flags(struct ext2_inode_info *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rbtree.h>\n#include <linux/percpu_counter.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/ext2_fs.h>\n#include <linux/fs.h>\n\nextern ext2_fsblk_t ext2_new_block(struct inode *, unsigned long, int *);\nextern ext2_fsblk_t ext2_new_blocks(struct inode *, unsigned long,\n\t\t\t\tunsigned long *, int *);\nextern void ext2_free_blocks (struct inode *, unsigned long,\n\t\t\t      unsigned long);\nextern void ext2_discard_reservation (struct inode *);\nextern void ext2_init_block_alloc_info(struct inode *);\nextern int ext2_add_link (struct dentry *, struct inode *);\nextern int ext2_make_empty(struct inode *, struct inode *);\nextern int ext2_empty_dir (struct inode *);\nextern void ext2_set_link(struct inode *, struct ext2_dir_entry_2 *, struct page *, struct inode *, int);\nextern void ext2_free_inode (struct inode *);\nextern void ext2_evict_inode(struct inode *);\nextern void ext2_set_inode_flags(struct inode *inode);\nextern void ext2_get_inode_flags(struct ext2_inode_info *);\n\nstatic inline struct ext2_inode_info *EXT2_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ext2_inode_info, vfs_inode);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"xattr.h\"\n#include \"acl.h\"\n#include \"ext2.h\"\n#include <linux/aio.h>\n#include <linux/namei.h>\n#include <linux/fiemap.h>\n#include <linux/mpage.h>\n#include <linux/buffer_head.h>\n#include <linux/writeback.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/highuid.h>\n#include <linux/time.h>\n\nstatic int ext2_get_blocks(struct inode *inode,\n\t\t\t   sector_t iblock, unsigned long maxblocks,\n\t\t\t   struct buffer_head *bh_result,\n\t\t\t   int create)\n{\n\tint err = -EIO;\n\tint offsets[4];\n\tIndirect chain[4];\n\tIndirect *partial;\n\text2_fsblk_t goal;\n\tint indirect_blks;\n\tint blocks_to_boundary = 0;\n\tint depth;\n\tstruct ext2_inode_info *ei = EXT2_I(inode);\n\tint count = 0;\n\text2_fsblk_t first_block = 0;\n\n\tBUG_ON(maxblocks == 0);\n\n\tdepth = ext2_block_to_path(inode,iblock,offsets,&blocks_to_boundary);\n\n\tif (depth == 0)\n\t\treturn (err);\n\n\tpartial = ext2_get_branch(inode, depth, offsets, chain, &err);\n\t/* Simplest case - block found, no allocation needed */\n\tif (!partial) {\n\t\tfirst_block = le32_to_cpu(chain[depth - 1].key);\n\t\tclear_buffer_new(bh_result); /* What's this do? */\n\t\tcount++;\n\t\t/*map more blocks*/\n\t\twhile (count < maxblocks && count <= blocks_to_boundary) {\n\t\t\text2_fsblk_t blk;\n\n\t\t\tif (!verify_chain(chain, chain + depth - 1)) {\n\t\t\t\t/*\n\t\t\t\t * Indirect block might be removed by\n\t\t\t\t * truncate while we were reading it.\n\t\t\t\t * Handling of that case: forget what we've\n\t\t\t\t * got now, go to reread.\n\t\t\t\t */\n\t\t\t\terr = -EAGAIN;\n\t\t\t\tcount = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tblk = le32_to_cpu(*(chain[depth-1].p + count));\n\t\t\tif (blk == first_block + count)\n\t\t\t\tcount++;\n\t\t\telse\n\t\t\t\tbreak;\n\t\t}\n\t\tif (err != -EAGAIN)\n\t\t\tgoto got_it;\n\t}\n\n\t/* Next simple case - plain lookup or failed read of indirect block */\n\tif (!create || err == -EIO)\n\t\tgoto cleanup;\n\n\tmutex_lock(&ei->truncate_mutex);\n\t/*\n\t * If the indirect block is missing while we are reading\n\t * the chain(ext2_get_branch() returns -EAGAIN err), or\n\t * if the chain has been changed after we grab the semaphore,\n\t * (either because another process truncated this branch, or\n\t * another get_block allocated this branch) re-grab the chain to see if\n\t * the request block has been allocated or not.\n\t *\n\t * Since we already block the truncate/other get_block\n\t * at this point, we will have the current copy of the chain when we\n\t * splice the branch into the tree.\n\t */\n\tif (err == -EAGAIN || !verify_chain(chain, partial)) {\n\t\twhile (partial > chain) {\n\t\t\tbrelse(partial->bh);\n\t\t\tpartial--;\n\t\t}\n\t\tpartial = ext2_get_branch(inode, depth, offsets, chain, &err);\n\t\tif (!partial) {\n\t\t\tcount++;\n\t\t\tmutex_unlock(&ei->truncate_mutex);\n\t\t\tif (err)\n\t\t\t\tgoto cleanup;\n\t\t\tclear_buffer_new(bh_result);\n\t\t\tgoto got_it;\n\t\t}\n\t}\n\n\t/*\n\t * Okay, we need to do block allocation.  Lazily initialize the block\n\t * allocation info here if necessary\n\t*/\n\tif (S_ISREG(inode->i_mode) && (!ei->i_block_alloc_info))\n\t\text2_init_block_alloc_info(inode);\n\n\tgoal = ext2_find_goal(inode, iblock, partial);\n\n\t/* the number of blocks need to allocate for [d,t]indirect blocks */\n\tindirect_blks = (chain + depth) - partial - 1;\n\t/*\n\t * Next look up the indirect map to count the totoal number of\n\t * direct blocks to allocate for this branch.\n\t */\n\tcount = ext2_blks_to_allocate(partial, indirect_blks,\n\t\t\t\t\tmaxblocks, blocks_to_boundary);\n\t/*\n\t * XXX ???? Block out ext2_truncate while we alter the tree\n\t */\n\terr = ext2_alloc_branch(inode, indirect_blks, &count, goal,\n\t\t\t\toffsets + (partial - chain), partial);\n\n\tif (err) {\n\t\tmutex_unlock(&ei->truncate_mutex);\n\t\tgoto cleanup;\n\t}\n\n\tif (IS_DAX(inode)) {\n\t\t/*\n\t\t * block must be initialised before we put it in the tree\n\t\t * so that it's not found by another thread before it's\n\t\t * initialised\n\t\t */\n\t\terr = dax_clear_blocks(inode, le32_to_cpu(chain[depth-1].key),\n\t\t\t\t\t\t1 << inode->i_blkbits);\n\t\tif (err) {\n\t\t\tmutex_unlock(&ei->truncate_mutex);\n\t\t\tgoto cleanup;\n\t\t}\n\t}\n\n\text2_splice_branch(inode, iblock, partial, indirect_blks, count);\n\tmutex_unlock(&ei->truncate_mutex);\n\tset_buffer_new(bh_result);\ngot_it:\n\tmap_bh(bh_result, inode->i_sb, le32_to_cpu(chain[depth-1].key));\n\tif (count > blocks_to_boundary)\n\t\tset_buffer_boundary(bh_result);\n\terr = count;\n\t/* Clean up and exit */\n\tpartial = chain + depth - 1;\t/* the whole chain */\ncleanup:\n\twhile (partial > chain) {\n\t\tbrelse(partial->bh);\n\t\tpartial--;\n\t}\n\treturn err;\n}"
  },
  {
    "function_name": "ext2_splice_branch",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext2/inode.c",
    "lines": "554-597",
    "snippet": "static void ext2_splice_branch(struct inode *inode,\n\t\t\tlong block, Indirect *where, int num, int blks)\n{\n\tint i;\n\tstruct ext2_block_alloc_info *block_i;\n\text2_fsblk_t current_block;\n\n\tblock_i = EXT2_I(inode)->i_block_alloc_info;\n\n\t/* XXX LOCKING probably should have i_meta_lock ?*/\n\t/* That's it */\n\n\t*where->p = where->key;\n\n\t/*\n\t * Update the host buffer_head or inode to point to more just allocated\n\t * direct blocks blocks\n\t */\n\tif (num == 0 && blks > 1) {\n\t\tcurrent_block = le32_to_cpu(where->key) + 1;\n\t\tfor (i = 1; i < blks; i++)\n\t\t\t*(where->p + i ) = cpu_to_le32(current_block++);\n\t}\n\n\t/*\n\t * update the most recently allocated logical & physical block\n\t * in i_block_alloc_info, to assist find the proper goal block for next\n\t * allocation\n\t */\n\tif (block_i) {\n\t\tblock_i->last_alloc_logical_block = block + blks - 1;\n\t\tblock_i->last_alloc_physical_block =\n\t\t\t\tle32_to_cpu(where[num].key) + blks - 1;\n\t}\n\n\t/* We are done with atomic stuff, now do the rest of housekeeping */\n\n\t/* had we spliced it onto indirect block? */\n\tif (where->bh)\n\t\tmark_buffer_dirty_inode(where->bh, inode);\n\n\tinode->i_ctime = CURRENT_TIME_SEC;\n\tmark_inode_dirty(inode);\n}",
    "includes": [
      "#include \"xattr.h\"",
      "#include \"acl.h\"",
      "#include \"ext2.h\"",
      "#include <linux/aio.h>",
      "#include <linux/namei.h>",
      "#include <linux/fiemap.h>",
      "#include <linux/mpage.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/writeback.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/highuid.h>",
      "#include <linux/time.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mark_inode_dirty",
          "args": [
            "inode"
          ],
          "line": 596
        },
        "resolved": true,
        "details": {
          "function_name": "block_dump___mark_inode_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fs-writeback.c",
          "lines": "1134-1154",
          "snippet": "static noinline void block_dump___mark_inode_dirty(struct inode *inode)\n{\n\tif (inode->i_ino || strcmp(inode->i_sb->s_id, \"bdev\")) {\n\t\tstruct dentry *dentry;\n\t\tconst char *name = \"?\";\n\n\t\tdentry = d_find_alias(inode);\n\t\tif (dentry) {\n\t\t\tspin_lock(&dentry->d_lock);\n\t\t\tname = (const char *) dentry->d_name.name;\n\t\t}\n\t\tprintk(KERN_DEBUG\n\t\t       \"%s(%d): dirtied inode %lu (%s) on %s\\n\",\n\t\t       current->comm, task_pid_nr(current), inode->i_ino,\n\t\t       name, inode->i_sb->s_id);\n\t\tif (dentry) {\n\t\t\tspin_unlock(&dentry->d_lock);\n\t\t\tdput(dentry);\n\t\t}\n\t}\n}",
          "includes": [
            "#include <trace/events/writeback.h>",
            "#include \"internal.h\"",
            "#include <linux/device.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/writeback.h>\n#include \"internal.h\"\n#include <linux/device.h>\n#include <linux/tracepoint.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nstatic noinline void block_dump___mark_inode_dirty(struct inode *inode)\n{\n\tif (inode->i_ino || strcmp(inode->i_sb->s_id, \"bdev\")) {\n\t\tstruct dentry *dentry;\n\t\tconst char *name = \"?\";\n\n\t\tdentry = d_find_alias(inode);\n\t\tif (dentry) {\n\t\t\tspin_lock(&dentry->d_lock);\n\t\t\tname = (const char *) dentry->d_name.name;\n\t\t}\n\t\tprintk(KERN_DEBUG\n\t\t       \"%s(%d): dirtied inode %lu (%s) on %s\\n\",\n\t\t       current->comm, task_pid_nr(current), inode->i_ino,\n\t\t       name, inode->i_sb->s_id);\n\t\tif (dentry) {\n\t\t\tspin_unlock(&dentry->d_lock);\n\t\t\tdput(dentry);\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "mark_buffer_dirty_inode",
          "args": [
            "where->bh",
            "inode"
          ],
          "line": 593
        },
        "resolved": true,
        "details": {
          "function_name": "mark_buffer_dirty_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "599-617",
          "snippet": "void mark_buffer_dirty_inode(struct buffer_head *bh, struct inode *inode)\n{\n\tstruct address_space *mapping = inode->i_mapping;\n\tstruct address_space *buffer_mapping = bh->b_page->mapping;\n\n\tmark_buffer_dirty(bh);\n\tif (!mapping->private_data) {\n\t\tmapping->private_data = buffer_mapping;\n\t} else {\n\t\tBUG_ON(mapping->private_data != buffer_mapping);\n\t}\n\tif (!bh->b_assoc_map) {\n\t\tspin_lock(&buffer_mapping->private_lock);\n\t\tlist_move_tail(&bh->b_assoc_buffers,\n\t\t\t\t&mapping->private_list);\n\t\tbh->b_assoc_map = mapping;\n\t\tspin_unlock(&buffer_mapping->private_lock);\n\t}\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid mark_buffer_dirty_inode(struct buffer_head *bh, struct inode *inode)\n{\n\tstruct address_space *mapping = inode->i_mapping;\n\tstruct address_space *buffer_mapping = bh->b_page->mapping;\n\n\tmark_buffer_dirty(bh);\n\tif (!mapping->private_data) {\n\t\tmapping->private_data = buffer_mapping;\n\t} else {\n\t\tBUG_ON(mapping->private_data != buffer_mapping);\n\t}\n\tif (!bh->b_assoc_map) {\n\t\tspin_lock(&buffer_mapping->private_lock);\n\t\tlist_move_tail(&bh->b_assoc_buffers,\n\t\t\t\t&mapping->private_list);\n\t\tbh->b_assoc_map = mapping;\n\t\tspin_unlock(&buffer_mapping->private_lock);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "where[num].key"
          ],
          "line": 586
        },
        "resolved": true,
        "details": {
          "function_name": "sle32_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "53-56",
          "snippet": "static inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "current_block++"
          ],
          "line": 575
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXT2_I",
          "args": [
            "inode"
          ],
          "line": 561
        },
        "resolved": true,
        "details": {
          "function_name": "EXT2_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext2/ext2.h",
          "lines": "717-720",
          "snippet": "static inline struct ext2_inode_info *EXT2_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ext2_inode_info, vfs_inode);\n}",
          "includes": [
            "#include <linux/rbtree.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/ext2_fs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern ext2_fsblk_t ext2_new_block(struct inode *, unsigned long, int *);",
            "extern ext2_fsblk_t ext2_new_blocks(struct inode *, unsigned long,\n\t\t\t\tunsigned long *, int *);",
            "extern void ext2_free_blocks (struct inode *, unsigned long,\n\t\t\t      unsigned long);",
            "extern void ext2_discard_reservation (struct inode *);",
            "extern void ext2_init_block_alloc_info(struct inode *);",
            "extern int ext2_add_link (struct dentry *, struct inode *);",
            "extern int ext2_make_empty(struct inode *, struct inode *);",
            "extern int ext2_empty_dir (struct inode *);",
            "extern void ext2_set_link(struct inode *, struct ext2_dir_entry_2 *, struct page *, struct inode *, int);",
            "extern void ext2_free_inode (struct inode *);",
            "extern void ext2_evict_inode(struct inode *);",
            "extern void ext2_set_inode_flags(struct inode *inode);",
            "extern void ext2_get_inode_flags(struct ext2_inode_info *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rbtree.h>\n#include <linux/percpu_counter.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/ext2_fs.h>\n#include <linux/fs.h>\n\nextern ext2_fsblk_t ext2_new_block(struct inode *, unsigned long, int *);\nextern ext2_fsblk_t ext2_new_blocks(struct inode *, unsigned long,\n\t\t\t\tunsigned long *, int *);\nextern void ext2_free_blocks (struct inode *, unsigned long,\n\t\t\t      unsigned long);\nextern void ext2_discard_reservation (struct inode *);\nextern void ext2_init_block_alloc_info(struct inode *);\nextern int ext2_add_link (struct dentry *, struct inode *);\nextern int ext2_make_empty(struct inode *, struct inode *);\nextern int ext2_empty_dir (struct inode *);\nextern void ext2_set_link(struct inode *, struct ext2_dir_entry_2 *, struct page *, struct inode *, int);\nextern void ext2_free_inode (struct inode *);\nextern void ext2_evict_inode(struct inode *);\nextern void ext2_set_inode_flags(struct inode *inode);\nextern void ext2_get_inode_flags(struct ext2_inode_info *);\n\nstatic inline struct ext2_inode_info *EXT2_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ext2_inode_info, vfs_inode);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"xattr.h\"\n#include \"acl.h\"\n#include \"ext2.h\"\n#include <linux/aio.h>\n#include <linux/namei.h>\n#include <linux/fiemap.h>\n#include <linux/mpage.h>\n#include <linux/buffer_head.h>\n#include <linux/writeback.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/highuid.h>\n#include <linux/time.h>\n\nstatic void ext2_splice_branch(struct inode *inode,\n\t\t\tlong block, Indirect *where, int num, int blks)\n{\n\tint i;\n\tstruct ext2_block_alloc_info *block_i;\n\text2_fsblk_t current_block;\n\n\tblock_i = EXT2_I(inode)->i_block_alloc_info;\n\n\t/* XXX LOCKING probably should have i_meta_lock ?*/\n\t/* That's it */\n\n\t*where->p = where->key;\n\n\t/*\n\t * Update the host buffer_head or inode to point to more just allocated\n\t * direct blocks blocks\n\t */\n\tif (num == 0 && blks > 1) {\n\t\tcurrent_block = le32_to_cpu(where->key) + 1;\n\t\tfor (i = 1; i < blks; i++)\n\t\t\t*(where->p + i ) = cpu_to_le32(current_block++);\n\t}\n\n\t/*\n\t * update the most recently allocated logical & physical block\n\t * in i_block_alloc_info, to assist find the proper goal block for next\n\t * allocation\n\t */\n\tif (block_i) {\n\t\tblock_i->last_alloc_logical_block = block + blks - 1;\n\t\tblock_i->last_alloc_physical_block =\n\t\t\t\tle32_to_cpu(where[num].key) + blks - 1;\n\t}\n\n\t/* We are done with atomic stuff, now do the rest of housekeeping */\n\n\t/* had we spliced it onto indirect block? */\n\tif (where->bh)\n\t\tmark_buffer_dirty_inode(where->bh, inode);\n\n\tinode->i_ctime = CURRENT_TIME_SEC;\n\tmark_inode_dirty(inode);\n}"
  },
  {
    "function_name": "ext2_alloc_branch",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext2/inode.c",
    "lines": "472-540",
    "snippet": "static int ext2_alloc_branch(struct inode *inode,\n\t\t\tint indirect_blks, int *blks, ext2_fsblk_t goal,\n\t\t\tint *offsets, Indirect *branch)\n{\n\tint blocksize = inode->i_sb->s_blocksize;\n\tint i, n = 0;\n\tint err = 0;\n\tstruct buffer_head *bh;\n\tint num;\n\text2_fsblk_t new_blocks[4];\n\text2_fsblk_t current_block;\n\n\tnum = ext2_alloc_blocks(inode, goal, indirect_blks,\n\t\t\t\t*blks, new_blocks, &err);\n\tif (err)\n\t\treturn err;\n\n\tbranch[0].key = cpu_to_le32(new_blocks[0]);\n\t/*\n\t * metadata blocks and data blocks are allocated.\n\t */\n\tfor (n = 1; n <= indirect_blks;  n++) {\n\t\t/*\n\t\t * Get buffer_head for parent block, zero it out\n\t\t * and set the pointer to new one, then send\n\t\t * parent to disk.\n\t\t */\n\t\tbh = sb_getblk(inode->i_sb, new_blocks[n-1]);\n\t\tif (unlikely(!bh)) {\n\t\t\terr = -ENOMEM;\n\t\t\tgoto failed;\n\t\t}\n\t\tbranch[n].bh = bh;\n\t\tlock_buffer(bh);\n\t\tmemset(bh->b_data, 0, blocksize);\n\t\tbranch[n].p = (__le32 *) bh->b_data + offsets[n];\n\t\tbranch[n].key = cpu_to_le32(new_blocks[n]);\n\t\t*branch[n].p = branch[n].key;\n\t\tif ( n == indirect_blks) {\n\t\t\tcurrent_block = new_blocks[n];\n\t\t\t/*\n\t\t\t * End of chain, update the last new metablock of\n\t\t\t * the chain to point to the new allocated\n\t\t\t * data blocks numbers\n\t\t\t */\n\t\t\tfor (i=1; i < num; i++)\n\t\t\t\t*(branch[n].p + i) = cpu_to_le32(++current_block);\n\t\t}\n\t\tset_buffer_uptodate(bh);\n\t\tunlock_buffer(bh);\n\t\tmark_buffer_dirty_inode(bh, inode);\n\t\t/* We used to sync bh here if IS_SYNC(inode).\n\t\t * But we now rely upon generic_write_sync()\n\t\t * and b_inode_buffers.  But not for directories.\n\t\t */\n\t\tif (S_ISDIR(inode->i_mode) && IS_DIRSYNC(inode))\n\t\t\tsync_dirty_buffer(bh);\n\t}\n\t*blks = num;\n\treturn err;\n\nfailed:\n\tfor (i = 1; i < n; i++)\n\t\tbforget(branch[i].bh);\n\tfor (i = 0; i < indirect_blks; i++)\n\t\text2_free_blocks(inode, new_blocks[i], 1);\n\text2_free_blocks(inode, new_blocks[i], num);\n\treturn err;\n}",
    "includes": [
      "#include \"xattr.h\"",
      "#include \"acl.h\"",
      "#include \"ext2.h\"",
      "#include <linux/aio.h>",
      "#include <linux/namei.h>",
      "#include <linux/fiemap.h>",
      "#include <linux/mpage.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/writeback.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/highuid.h>",
      "#include <linux/time.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ext2_free_blocks",
          "args": [
            "inode",
            "new_blocks[i]",
            "num"
          ],
          "line": 538
        },
        "resolved": true,
        "details": {
          "function_name": "ext2_free_blocks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext2/balloc.c",
          "lines": "476-567",
          "snippet": "void ext2_free_blocks (struct inode * inode, unsigned long block,\n\t\t       unsigned long count)\n{\n\tstruct buffer_head *bitmap_bh = NULL;\n\tstruct buffer_head * bh2;\n\tunsigned long block_group;\n\tunsigned long bit;\n\tunsigned long i;\n\tunsigned long overflow;\n\tstruct super_block * sb = inode->i_sb;\n\tstruct ext2_sb_info * sbi = EXT2_SB(sb);\n\tstruct ext2_group_desc * desc;\n\tstruct ext2_super_block * es = sbi->s_es;\n\tunsigned freed = 0, group_freed;\n\n\tif (block < le32_to_cpu(es->s_first_data_block) ||\n\t    block + count < block ||\n\t    block + count > le32_to_cpu(es->s_blocks_count)) {\n\t\text2_error (sb, \"ext2_free_blocks\",\n\t\t\t    \"Freeing blocks not in datazone - \"\n\t\t\t    \"block = %lu, count = %lu\", block, count);\n\t\tgoto error_return;\n\t}\n\n\text2_debug (\"freeing block(s) %lu-%lu\\n\", block, block + count - 1);\n\ndo_more:\n\toverflow = 0;\n\tblock_group = (block - le32_to_cpu(es->s_first_data_block)) /\n\t\t      EXT2_BLOCKS_PER_GROUP(sb);\n\tbit = (block - le32_to_cpu(es->s_first_data_block)) %\n\t\t      EXT2_BLOCKS_PER_GROUP(sb);\n\t/*\n\t * Check to see if we are freeing blocks across a group\n\t * boundary.\n\t */\n\tif (bit + count > EXT2_BLOCKS_PER_GROUP(sb)) {\n\t\toverflow = bit + count - EXT2_BLOCKS_PER_GROUP(sb);\n\t\tcount -= overflow;\n\t}\n\tbrelse(bitmap_bh);\n\tbitmap_bh = read_block_bitmap(sb, block_group);\n\tif (!bitmap_bh)\n\t\tgoto error_return;\n\n\tdesc = ext2_get_group_desc (sb, block_group, &bh2);\n\tif (!desc)\n\t\tgoto error_return;\n\n\tif (in_range (le32_to_cpu(desc->bg_block_bitmap), block, count) ||\n\t    in_range (le32_to_cpu(desc->bg_inode_bitmap), block, count) ||\n\t    in_range (block, le32_to_cpu(desc->bg_inode_table),\n\t\t      sbi->s_itb_per_group) ||\n\t    in_range (block + count - 1, le32_to_cpu(desc->bg_inode_table),\n\t\t      sbi->s_itb_per_group)) {\n\t\text2_error (sb, \"ext2_free_blocks\",\n\t\t\t    \"Freeing blocks in system zones - \"\n\t\t\t    \"Block = %lu, count = %lu\",\n\t\t\t    block, count);\n\t\tgoto error_return;\n\t}\n\n\tfor (i = 0, group_freed = 0; i < count; i++) {\n\t\tif (!ext2_clear_bit_atomic(sb_bgl_lock(sbi, block_group),\n\t\t\t\t\t\tbit + i, bitmap_bh->b_data)) {\n\t\t\text2_error(sb, __func__,\n\t\t\t\t\"bit already cleared for block %lu\", block + i);\n\t\t} else {\n\t\t\tgroup_freed++;\n\t\t}\n\t}\n\n\tmark_buffer_dirty(bitmap_bh);\n\tif (sb->s_flags & MS_SYNCHRONOUS)\n\t\tsync_dirty_buffer(bitmap_bh);\n\n\tgroup_adjust_blocks(sb, block_group, desc, bh2, group_freed);\n\tfreed += group_freed;\n\n\tif (overflow) {\n\t\tblock += count;\n\t\tcount = overflow;\n\t\tgoto do_more;\n\t}\nerror_return:\n\tbrelse(bitmap_bh);\n\tif (freed) {\n\t\tpercpu_counter_add(&sbi->s_freeblocks_counter, freed);\n\t\tdquot_free_block_nodirty(inode, freed);\n\t\tmark_inode_dirty(inode);\n\t}\n}",
          "includes": [
            "#include <linux/capability.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/quotaops.h>",
            "#include \"ext2.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/capability.h>\n#include <linux/buffer_head.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/quotaops.h>\n#include \"ext2.h\"\n\nvoid ext2_free_blocks (struct inode * inode, unsigned long block,\n\t\t       unsigned long count)\n{\n\tstruct buffer_head *bitmap_bh = NULL;\n\tstruct buffer_head * bh2;\n\tunsigned long block_group;\n\tunsigned long bit;\n\tunsigned long i;\n\tunsigned long overflow;\n\tstruct super_block * sb = inode->i_sb;\n\tstruct ext2_sb_info * sbi = EXT2_SB(sb);\n\tstruct ext2_group_desc * desc;\n\tstruct ext2_super_block * es = sbi->s_es;\n\tunsigned freed = 0, group_freed;\n\n\tif (block < le32_to_cpu(es->s_first_data_block) ||\n\t    block + count < block ||\n\t    block + count > le32_to_cpu(es->s_blocks_count)) {\n\t\text2_error (sb, \"ext2_free_blocks\",\n\t\t\t    \"Freeing blocks not in datazone - \"\n\t\t\t    \"block = %lu, count = %lu\", block, count);\n\t\tgoto error_return;\n\t}\n\n\text2_debug (\"freeing block(s) %lu-%lu\\n\", block, block + count - 1);\n\ndo_more:\n\toverflow = 0;\n\tblock_group = (block - le32_to_cpu(es->s_first_data_block)) /\n\t\t      EXT2_BLOCKS_PER_GROUP(sb);\n\tbit = (block - le32_to_cpu(es->s_first_data_block)) %\n\t\t      EXT2_BLOCKS_PER_GROUP(sb);\n\t/*\n\t * Check to see if we are freeing blocks across a group\n\t * boundary.\n\t */\n\tif (bit + count > EXT2_BLOCKS_PER_GROUP(sb)) {\n\t\toverflow = bit + count - EXT2_BLOCKS_PER_GROUP(sb);\n\t\tcount -= overflow;\n\t}\n\tbrelse(bitmap_bh);\n\tbitmap_bh = read_block_bitmap(sb, block_group);\n\tif (!bitmap_bh)\n\t\tgoto error_return;\n\n\tdesc = ext2_get_group_desc (sb, block_group, &bh2);\n\tif (!desc)\n\t\tgoto error_return;\n\n\tif (in_range (le32_to_cpu(desc->bg_block_bitmap), block, count) ||\n\t    in_range (le32_to_cpu(desc->bg_inode_bitmap), block, count) ||\n\t    in_range (block, le32_to_cpu(desc->bg_inode_table),\n\t\t      sbi->s_itb_per_group) ||\n\t    in_range (block + count - 1, le32_to_cpu(desc->bg_inode_table),\n\t\t      sbi->s_itb_per_group)) {\n\t\text2_error (sb, \"ext2_free_blocks\",\n\t\t\t    \"Freeing blocks in system zones - \"\n\t\t\t    \"Block = %lu, count = %lu\",\n\t\t\t    block, count);\n\t\tgoto error_return;\n\t}\n\n\tfor (i = 0, group_freed = 0; i < count; i++) {\n\t\tif (!ext2_clear_bit_atomic(sb_bgl_lock(sbi, block_group),\n\t\t\t\t\t\tbit + i, bitmap_bh->b_data)) {\n\t\t\text2_error(sb, __func__,\n\t\t\t\t\"bit already cleared for block %lu\", block + i);\n\t\t} else {\n\t\t\tgroup_freed++;\n\t\t}\n\t}\n\n\tmark_buffer_dirty(bitmap_bh);\n\tif (sb->s_flags & MS_SYNCHRONOUS)\n\t\tsync_dirty_buffer(bitmap_bh);\n\n\tgroup_adjust_blocks(sb, block_group, desc, bh2, group_freed);\n\tfreed += group_freed;\n\n\tif (overflow) {\n\t\tblock += count;\n\t\tcount = overflow;\n\t\tgoto do_more;\n\t}\nerror_return:\n\tbrelse(bitmap_bh);\n\tif (freed) {\n\t\tpercpu_counter_add(&sbi->s_freeblocks_counter, freed);\n\t\tdquot_free_block_nodirty(inode, freed);\n\t\tmark_inode_dirty(inode);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "bforget",
          "args": [
            "branch[i].bh"
          ],
          "line": 535
        },
        "resolved": true,
        "details": {
          "function_name": "__bforget",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1191-1203",
          "snippet": "void __bforget(struct buffer_head *bh)\n{\n\tclear_buffer_dirty(bh);\n\tif (bh->b_assoc_map) {\n\t\tstruct address_space *buffer_mapping = bh->b_page->mapping;\n\n\t\tspin_lock(&buffer_mapping->private_lock);\n\t\tlist_del_init(&bh->b_assoc_buffers);\n\t\tbh->b_assoc_map = NULL;\n\t\tspin_unlock(&buffer_mapping->private_lock);\n\t}\n\t__brelse(bh);\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid __bforget(struct buffer_head *bh)\n{\n\tclear_buffer_dirty(bh);\n\tif (bh->b_assoc_map) {\n\t\tstruct address_space *buffer_mapping = bh->b_page->mapping;\n\n\t\tspin_lock(&buffer_mapping->private_lock);\n\t\tlist_del_init(&bh->b_assoc_buffers);\n\t\tbh->b_assoc_map = NULL;\n\t\tspin_unlock(&buffer_mapping->private_lock);\n\t}\n\t__brelse(bh);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sync_dirty_buffer",
          "args": [
            "bh"
          ],
          "line": 528
        },
        "resolved": true,
        "details": {
          "function_name": "sync_dirty_buffer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "3153-3156",
          "snippet": "int sync_dirty_buffer(struct buffer_head *bh)\n{\n\treturn __sync_dirty_buffer(bh, WRITE_SYNC);\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nint sync_dirty_buffer(struct buffer_head *bh)\n{\n\treturn __sync_dirty_buffer(bh, WRITE_SYNC);\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_DIRSYNC",
          "args": [
            "inode"
          ],
          "line": 527
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISDIR",
          "args": [
            "inode->i_mode"
          ],
          "line": 527
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mark_buffer_dirty_inode",
          "args": [
            "bh",
            "inode"
          ],
          "line": 522
        },
        "resolved": true,
        "details": {
          "function_name": "mark_buffer_dirty_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "599-617",
          "snippet": "void mark_buffer_dirty_inode(struct buffer_head *bh, struct inode *inode)\n{\n\tstruct address_space *mapping = inode->i_mapping;\n\tstruct address_space *buffer_mapping = bh->b_page->mapping;\n\n\tmark_buffer_dirty(bh);\n\tif (!mapping->private_data) {\n\t\tmapping->private_data = buffer_mapping;\n\t} else {\n\t\tBUG_ON(mapping->private_data != buffer_mapping);\n\t}\n\tif (!bh->b_assoc_map) {\n\t\tspin_lock(&buffer_mapping->private_lock);\n\t\tlist_move_tail(&bh->b_assoc_buffers,\n\t\t\t\t&mapping->private_list);\n\t\tbh->b_assoc_map = mapping;\n\t\tspin_unlock(&buffer_mapping->private_lock);\n\t}\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid mark_buffer_dirty_inode(struct buffer_head *bh, struct inode *inode)\n{\n\tstruct address_space *mapping = inode->i_mapping;\n\tstruct address_space *buffer_mapping = bh->b_page->mapping;\n\n\tmark_buffer_dirty(bh);\n\tif (!mapping->private_data) {\n\t\tmapping->private_data = buffer_mapping;\n\t} else {\n\t\tBUG_ON(mapping->private_data != buffer_mapping);\n\t}\n\tif (!bh->b_assoc_map) {\n\t\tspin_lock(&buffer_mapping->private_lock);\n\t\tlist_move_tail(&bh->b_assoc_buffers,\n\t\t\t\t&mapping->private_list);\n\t\tbh->b_assoc_map = mapping;\n\t\tspin_unlock(&buffer_mapping->private_lock);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlock_buffer",
          "args": [
            "bh"
          ],
          "line": 521
        },
        "resolved": true,
        "details": {
          "function_name": "unlock_buffer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "70-75",
          "snippet": "void unlock_buffer(struct buffer_head *bh)\n{\n\tclear_bit_unlock(BH_Lock, &bh->b_state);\n\tsmp_mb__after_atomic();\n\twake_up_bit(&bh->b_state, BH_Lock);\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid unlock_buffer(struct buffer_head *bh)\n{\n\tclear_bit_unlock(BH_Lock, &bh->b_state);\n\tsmp_mb__after_atomic();\n\twake_up_bit(&bh->b_state, BH_Lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_buffer_uptodate",
          "args": [
            "bh"
          ],
          "line": 520
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_set_buffer_uptodate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/disk-io.c",
          "lines": "3758-3761",
          "snippet": "int btrfs_set_buffer_uptodate(struct extent_buffer *buf)\n{\n\treturn set_extent_buffer_uptodate(buf);\n}",
          "includes": [
            "#include <asm/cpufeature.h>",
            "#include \"qgroup.h\"",
            "#include \"sysfs.h\"",
            "#include \"raid56.h\"",
            "#include \"dev-replace.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"inode-map.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"tree-log.h\"",
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"hash.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/uuid.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/migrate.h>",
            "#include <linux/slab.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/writeback.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/swap.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/cpufeature.h>\n#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"raid56.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <asm/unaligned.h>\n#include <linux/semaphore.h>\n#include <linux/uuid.h>\n#include <linux/ratelimit.h>\n#include <linux/migrate.h>\n#include <linux/slab.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/writeback.h>\n#include <linux/radix-tree.h>\n#include <linux/swap.h>\n#include <linux/scatterlist.h>\n#include <linux/blkdev.h>\n#include <linux/fs.h>\n\nint btrfs_set_buffer_uptodate(struct extent_buffer *buf)\n{\n\treturn set_extent_buffer_uptodate(buf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "++current_block"
          ],
          "line": 518
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "new_blocks[n]"
          ],
          "line": 508
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "bh->b_data",
            "0",
            "blocksize"
          ],
          "line": 506
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!bh"
          ],
          "line": 500
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sb_getblk",
          "args": [
            "inode->i_sb",
            "new_blocks[n-1]"
          ],
          "line": 499
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "new_blocks[0]"
          ],
          "line": 489
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext2_alloc_blocks",
          "args": [
            "inode",
            "goal",
            "indirect_blks",
            "*blks",
            "new_blocks",
            "&err"
          ],
          "line": 484
        },
        "resolved": true,
        "details": {
          "function_name": "ext2_alloc_blocks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext2/inode.c",
          "lines": "394-445",
          "snippet": "static int ext2_alloc_blocks(struct inode *inode,\n\t\t\text2_fsblk_t goal, int indirect_blks, int blks,\n\t\t\text2_fsblk_t new_blocks[4], int *err)\n{\n\tint target, i;\n\tunsigned long count = 0;\n\tint index = 0;\n\text2_fsblk_t current_block = 0;\n\tint ret = 0;\n\n\t/*\n\t * Here we try to allocate the requested multiple blocks at once,\n\t * on a best-effort basis.\n\t * To build a branch, we should allocate blocks for\n\t * the indirect blocks(if not allocated yet), and at least\n\t * the first direct block of this branch.  That's the\n\t * minimum number of blocks need to allocate(required)\n\t */\n\ttarget = blks + indirect_blks;\n\n\twhile (1) {\n\t\tcount = target;\n\t\t/* allocating blocks for indirect blocks and direct blocks */\n\t\tcurrent_block = ext2_new_blocks(inode,goal,&count,err);\n\t\tif (*err)\n\t\t\tgoto failed_out;\n\n\t\ttarget -= count;\n\t\t/* allocate blocks for indirect blocks */\n\t\twhile (index < indirect_blks && count) {\n\t\t\tnew_blocks[index++] = current_block++;\n\t\t\tcount--;\n\t\t}\n\n\t\tif (count > 0)\n\t\t\tbreak;\n\t}\n\n\t/* save the new block number for the first direct block */\n\tnew_blocks[index] = current_block;\n\n\t/* total number of blocks allocated for direct blocks */\n\tret = count;\n\t*err = 0;\n\treturn ret;\nfailed_out:\n\tfor (i = 0; i <index; i++)\n\t\text2_free_blocks(inode, new_blocks[i], 1);\n\tif (index)\n\t\tmark_inode_dirty(inode);\n\treturn ret;\n}",
          "includes": [
            "#include \"xattr.h\"",
            "#include \"acl.h\"",
            "#include \"ext2.h\"",
            "#include <linux/aio.h>",
            "#include <linux/namei.h>",
            "#include <linux/fiemap.h>",
            "#include <linux/mpage.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/writeback.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highuid.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xattr.h\"\n#include \"acl.h\"\n#include \"ext2.h\"\n#include <linux/aio.h>\n#include <linux/namei.h>\n#include <linux/fiemap.h>\n#include <linux/mpage.h>\n#include <linux/buffer_head.h>\n#include <linux/writeback.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/highuid.h>\n#include <linux/time.h>\n\nstatic int ext2_alloc_blocks(struct inode *inode,\n\t\t\text2_fsblk_t goal, int indirect_blks, int blks,\n\t\t\text2_fsblk_t new_blocks[4], int *err)\n{\n\tint target, i;\n\tunsigned long count = 0;\n\tint index = 0;\n\text2_fsblk_t current_block = 0;\n\tint ret = 0;\n\n\t/*\n\t * Here we try to allocate the requested multiple blocks at once,\n\t * on a best-effort basis.\n\t * To build a branch, we should allocate blocks for\n\t * the indirect blocks(if not allocated yet), and at least\n\t * the first direct block of this branch.  That's the\n\t * minimum number of blocks need to allocate(required)\n\t */\n\ttarget = blks + indirect_blks;\n\n\twhile (1) {\n\t\tcount = target;\n\t\t/* allocating blocks for indirect blocks and direct blocks */\n\t\tcurrent_block = ext2_new_blocks(inode,goal,&count,err);\n\t\tif (*err)\n\t\t\tgoto failed_out;\n\n\t\ttarget -= count;\n\t\t/* allocate blocks for indirect blocks */\n\t\twhile (index < indirect_blks && count) {\n\t\t\tnew_blocks[index++] = current_block++;\n\t\t\tcount--;\n\t\t}\n\n\t\tif (count > 0)\n\t\t\tbreak;\n\t}\n\n\t/* save the new block number for the first direct block */\n\tnew_blocks[index] = current_block;\n\n\t/* total number of blocks allocated for direct blocks */\n\tret = count;\n\t*err = 0;\n\treturn ret;\nfailed_out:\n\tfor (i = 0; i <index; i++)\n\t\text2_free_blocks(inode, new_blocks[i], 1);\n\tif (index)\n\t\tmark_inode_dirty(inode);\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"xattr.h\"\n#include \"acl.h\"\n#include \"ext2.h\"\n#include <linux/aio.h>\n#include <linux/namei.h>\n#include <linux/fiemap.h>\n#include <linux/mpage.h>\n#include <linux/buffer_head.h>\n#include <linux/writeback.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/highuid.h>\n#include <linux/time.h>\n\nstatic int ext2_alloc_branch(struct inode *inode,\n\t\t\tint indirect_blks, int *blks, ext2_fsblk_t goal,\n\t\t\tint *offsets, Indirect *branch)\n{\n\tint blocksize = inode->i_sb->s_blocksize;\n\tint i, n = 0;\n\tint err = 0;\n\tstruct buffer_head *bh;\n\tint num;\n\text2_fsblk_t new_blocks[4];\n\text2_fsblk_t current_block;\n\n\tnum = ext2_alloc_blocks(inode, goal, indirect_blks,\n\t\t\t\t*blks, new_blocks, &err);\n\tif (err)\n\t\treturn err;\n\n\tbranch[0].key = cpu_to_le32(new_blocks[0]);\n\t/*\n\t * metadata blocks and data blocks are allocated.\n\t */\n\tfor (n = 1; n <= indirect_blks;  n++) {\n\t\t/*\n\t\t * Get buffer_head for parent block, zero it out\n\t\t * and set the pointer to new one, then send\n\t\t * parent to disk.\n\t\t */\n\t\tbh = sb_getblk(inode->i_sb, new_blocks[n-1]);\n\t\tif (unlikely(!bh)) {\n\t\t\terr = -ENOMEM;\n\t\t\tgoto failed;\n\t\t}\n\t\tbranch[n].bh = bh;\n\t\tlock_buffer(bh);\n\t\tmemset(bh->b_data, 0, blocksize);\n\t\tbranch[n].p = (__le32 *) bh->b_data + offsets[n];\n\t\tbranch[n].key = cpu_to_le32(new_blocks[n]);\n\t\t*branch[n].p = branch[n].key;\n\t\tif ( n == indirect_blks) {\n\t\t\tcurrent_block = new_blocks[n];\n\t\t\t/*\n\t\t\t * End of chain, update the last new metablock of\n\t\t\t * the chain to point to the new allocated\n\t\t\t * data blocks numbers\n\t\t\t */\n\t\t\tfor (i=1; i < num; i++)\n\t\t\t\t*(branch[n].p + i) = cpu_to_le32(++current_block);\n\t\t}\n\t\tset_buffer_uptodate(bh);\n\t\tunlock_buffer(bh);\n\t\tmark_buffer_dirty_inode(bh, inode);\n\t\t/* We used to sync bh here if IS_SYNC(inode).\n\t\t * But we now rely upon generic_write_sync()\n\t\t * and b_inode_buffers.  But not for directories.\n\t\t */\n\t\tif (S_ISDIR(inode->i_mode) && IS_DIRSYNC(inode))\n\t\t\tsync_dirty_buffer(bh);\n\t}\n\t*blks = num;\n\treturn err;\n\nfailed:\n\tfor (i = 1; i < n; i++)\n\t\tbforget(branch[i].bh);\n\tfor (i = 0; i < indirect_blks; i++)\n\t\text2_free_blocks(inode, new_blocks[i], 1);\n\text2_free_blocks(inode, new_blocks[i], num);\n\treturn err;\n}"
  },
  {
    "function_name": "ext2_alloc_blocks",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext2/inode.c",
    "lines": "394-445",
    "snippet": "static int ext2_alloc_blocks(struct inode *inode,\n\t\t\text2_fsblk_t goal, int indirect_blks, int blks,\n\t\t\text2_fsblk_t new_blocks[4], int *err)\n{\n\tint target, i;\n\tunsigned long count = 0;\n\tint index = 0;\n\text2_fsblk_t current_block = 0;\n\tint ret = 0;\n\n\t/*\n\t * Here we try to allocate the requested multiple blocks at once,\n\t * on a best-effort basis.\n\t * To build a branch, we should allocate blocks for\n\t * the indirect blocks(if not allocated yet), and at least\n\t * the first direct block of this branch.  That's the\n\t * minimum number of blocks need to allocate(required)\n\t */\n\ttarget = blks + indirect_blks;\n\n\twhile (1) {\n\t\tcount = target;\n\t\t/* allocating blocks for indirect blocks and direct blocks */\n\t\tcurrent_block = ext2_new_blocks(inode,goal,&count,err);\n\t\tif (*err)\n\t\t\tgoto failed_out;\n\n\t\ttarget -= count;\n\t\t/* allocate blocks for indirect blocks */\n\t\twhile (index < indirect_blks && count) {\n\t\t\tnew_blocks[index++] = current_block++;\n\t\t\tcount--;\n\t\t}\n\n\t\tif (count > 0)\n\t\t\tbreak;\n\t}\n\n\t/* save the new block number for the first direct block */\n\tnew_blocks[index] = current_block;\n\n\t/* total number of blocks allocated for direct blocks */\n\tret = count;\n\t*err = 0;\n\treturn ret;\nfailed_out:\n\tfor (i = 0; i <index; i++)\n\t\text2_free_blocks(inode, new_blocks[i], 1);\n\tif (index)\n\t\tmark_inode_dirty(inode);\n\treturn ret;\n}",
    "includes": [
      "#include \"xattr.h\"",
      "#include \"acl.h\"",
      "#include \"ext2.h\"",
      "#include <linux/aio.h>",
      "#include <linux/namei.h>",
      "#include <linux/fiemap.h>",
      "#include <linux/mpage.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/writeback.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/highuid.h>",
      "#include <linux/time.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mark_inode_dirty",
          "args": [
            "inode"
          ],
          "line": 443
        },
        "resolved": true,
        "details": {
          "function_name": "block_dump___mark_inode_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fs-writeback.c",
          "lines": "1134-1154",
          "snippet": "static noinline void block_dump___mark_inode_dirty(struct inode *inode)\n{\n\tif (inode->i_ino || strcmp(inode->i_sb->s_id, \"bdev\")) {\n\t\tstruct dentry *dentry;\n\t\tconst char *name = \"?\";\n\n\t\tdentry = d_find_alias(inode);\n\t\tif (dentry) {\n\t\t\tspin_lock(&dentry->d_lock);\n\t\t\tname = (const char *) dentry->d_name.name;\n\t\t}\n\t\tprintk(KERN_DEBUG\n\t\t       \"%s(%d): dirtied inode %lu (%s) on %s\\n\",\n\t\t       current->comm, task_pid_nr(current), inode->i_ino,\n\t\t       name, inode->i_sb->s_id);\n\t\tif (dentry) {\n\t\t\tspin_unlock(&dentry->d_lock);\n\t\t\tdput(dentry);\n\t\t}\n\t}\n}",
          "includes": [
            "#include <trace/events/writeback.h>",
            "#include \"internal.h\"",
            "#include <linux/device.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/writeback.h>\n#include \"internal.h\"\n#include <linux/device.h>\n#include <linux/tracepoint.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nstatic noinline void block_dump___mark_inode_dirty(struct inode *inode)\n{\n\tif (inode->i_ino || strcmp(inode->i_sb->s_id, \"bdev\")) {\n\t\tstruct dentry *dentry;\n\t\tconst char *name = \"?\";\n\n\t\tdentry = d_find_alias(inode);\n\t\tif (dentry) {\n\t\t\tspin_lock(&dentry->d_lock);\n\t\t\tname = (const char *) dentry->d_name.name;\n\t\t}\n\t\tprintk(KERN_DEBUG\n\t\t       \"%s(%d): dirtied inode %lu (%s) on %s\\n\",\n\t\t       current->comm, task_pid_nr(current), inode->i_ino,\n\t\t       name, inode->i_sb->s_id);\n\t\tif (dentry) {\n\t\t\tspin_unlock(&dentry->d_lock);\n\t\t\tdput(dentry);\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext2_free_blocks",
          "args": [
            "inode",
            "new_blocks[i]",
            "1"
          ],
          "line": 441
        },
        "resolved": true,
        "details": {
          "function_name": "ext2_free_blocks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext2/balloc.c",
          "lines": "476-567",
          "snippet": "void ext2_free_blocks (struct inode * inode, unsigned long block,\n\t\t       unsigned long count)\n{\n\tstruct buffer_head *bitmap_bh = NULL;\n\tstruct buffer_head * bh2;\n\tunsigned long block_group;\n\tunsigned long bit;\n\tunsigned long i;\n\tunsigned long overflow;\n\tstruct super_block * sb = inode->i_sb;\n\tstruct ext2_sb_info * sbi = EXT2_SB(sb);\n\tstruct ext2_group_desc * desc;\n\tstruct ext2_super_block * es = sbi->s_es;\n\tunsigned freed = 0, group_freed;\n\n\tif (block < le32_to_cpu(es->s_first_data_block) ||\n\t    block + count < block ||\n\t    block + count > le32_to_cpu(es->s_blocks_count)) {\n\t\text2_error (sb, \"ext2_free_blocks\",\n\t\t\t    \"Freeing blocks not in datazone - \"\n\t\t\t    \"block = %lu, count = %lu\", block, count);\n\t\tgoto error_return;\n\t}\n\n\text2_debug (\"freeing block(s) %lu-%lu\\n\", block, block + count - 1);\n\ndo_more:\n\toverflow = 0;\n\tblock_group = (block - le32_to_cpu(es->s_first_data_block)) /\n\t\t      EXT2_BLOCKS_PER_GROUP(sb);\n\tbit = (block - le32_to_cpu(es->s_first_data_block)) %\n\t\t      EXT2_BLOCKS_PER_GROUP(sb);\n\t/*\n\t * Check to see if we are freeing blocks across a group\n\t * boundary.\n\t */\n\tif (bit + count > EXT2_BLOCKS_PER_GROUP(sb)) {\n\t\toverflow = bit + count - EXT2_BLOCKS_PER_GROUP(sb);\n\t\tcount -= overflow;\n\t}\n\tbrelse(bitmap_bh);\n\tbitmap_bh = read_block_bitmap(sb, block_group);\n\tif (!bitmap_bh)\n\t\tgoto error_return;\n\n\tdesc = ext2_get_group_desc (sb, block_group, &bh2);\n\tif (!desc)\n\t\tgoto error_return;\n\n\tif (in_range (le32_to_cpu(desc->bg_block_bitmap), block, count) ||\n\t    in_range (le32_to_cpu(desc->bg_inode_bitmap), block, count) ||\n\t    in_range (block, le32_to_cpu(desc->bg_inode_table),\n\t\t      sbi->s_itb_per_group) ||\n\t    in_range (block + count - 1, le32_to_cpu(desc->bg_inode_table),\n\t\t      sbi->s_itb_per_group)) {\n\t\text2_error (sb, \"ext2_free_blocks\",\n\t\t\t    \"Freeing blocks in system zones - \"\n\t\t\t    \"Block = %lu, count = %lu\",\n\t\t\t    block, count);\n\t\tgoto error_return;\n\t}\n\n\tfor (i = 0, group_freed = 0; i < count; i++) {\n\t\tif (!ext2_clear_bit_atomic(sb_bgl_lock(sbi, block_group),\n\t\t\t\t\t\tbit + i, bitmap_bh->b_data)) {\n\t\t\text2_error(sb, __func__,\n\t\t\t\t\"bit already cleared for block %lu\", block + i);\n\t\t} else {\n\t\t\tgroup_freed++;\n\t\t}\n\t}\n\n\tmark_buffer_dirty(bitmap_bh);\n\tif (sb->s_flags & MS_SYNCHRONOUS)\n\t\tsync_dirty_buffer(bitmap_bh);\n\n\tgroup_adjust_blocks(sb, block_group, desc, bh2, group_freed);\n\tfreed += group_freed;\n\n\tif (overflow) {\n\t\tblock += count;\n\t\tcount = overflow;\n\t\tgoto do_more;\n\t}\nerror_return:\n\tbrelse(bitmap_bh);\n\tif (freed) {\n\t\tpercpu_counter_add(&sbi->s_freeblocks_counter, freed);\n\t\tdquot_free_block_nodirty(inode, freed);\n\t\tmark_inode_dirty(inode);\n\t}\n}",
          "includes": [
            "#include <linux/capability.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/quotaops.h>",
            "#include \"ext2.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/capability.h>\n#include <linux/buffer_head.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/quotaops.h>\n#include \"ext2.h\"\n\nvoid ext2_free_blocks (struct inode * inode, unsigned long block,\n\t\t       unsigned long count)\n{\n\tstruct buffer_head *bitmap_bh = NULL;\n\tstruct buffer_head * bh2;\n\tunsigned long block_group;\n\tunsigned long bit;\n\tunsigned long i;\n\tunsigned long overflow;\n\tstruct super_block * sb = inode->i_sb;\n\tstruct ext2_sb_info * sbi = EXT2_SB(sb);\n\tstruct ext2_group_desc * desc;\n\tstruct ext2_super_block * es = sbi->s_es;\n\tunsigned freed = 0, group_freed;\n\n\tif (block < le32_to_cpu(es->s_first_data_block) ||\n\t    block + count < block ||\n\t    block + count > le32_to_cpu(es->s_blocks_count)) {\n\t\text2_error (sb, \"ext2_free_blocks\",\n\t\t\t    \"Freeing blocks not in datazone - \"\n\t\t\t    \"block = %lu, count = %lu\", block, count);\n\t\tgoto error_return;\n\t}\n\n\text2_debug (\"freeing block(s) %lu-%lu\\n\", block, block + count - 1);\n\ndo_more:\n\toverflow = 0;\n\tblock_group = (block - le32_to_cpu(es->s_first_data_block)) /\n\t\t      EXT2_BLOCKS_PER_GROUP(sb);\n\tbit = (block - le32_to_cpu(es->s_first_data_block)) %\n\t\t      EXT2_BLOCKS_PER_GROUP(sb);\n\t/*\n\t * Check to see if we are freeing blocks across a group\n\t * boundary.\n\t */\n\tif (bit + count > EXT2_BLOCKS_PER_GROUP(sb)) {\n\t\toverflow = bit + count - EXT2_BLOCKS_PER_GROUP(sb);\n\t\tcount -= overflow;\n\t}\n\tbrelse(bitmap_bh);\n\tbitmap_bh = read_block_bitmap(sb, block_group);\n\tif (!bitmap_bh)\n\t\tgoto error_return;\n\n\tdesc = ext2_get_group_desc (sb, block_group, &bh2);\n\tif (!desc)\n\t\tgoto error_return;\n\n\tif (in_range (le32_to_cpu(desc->bg_block_bitmap), block, count) ||\n\t    in_range (le32_to_cpu(desc->bg_inode_bitmap), block, count) ||\n\t    in_range (block, le32_to_cpu(desc->bg_inode_table),\n\t\t      sbi->s_itb_per_group) ||\n\t    in_range (block + count - 1, le32_to_cpu(desc->bg_inode_table),\n\t\t      sbi->s_itb_per_group)) {\n\t\text2_error (sb, \"ext2_free_blocks\",\n\t\t\t    \"Freeing blocks in system zones - \"\n\t\t\t    \"Block = %lu, count = %lu\",\n\t\t\t    block, count);\n\t\tgoto error_return;\n\t}\n\n\tfor (i = 0, group_freed = 0; i < count; i++) {\n\t\tif (!ext2_clear_bit_atomic(sb_bgl_lock(sbi, block_group),\n\t\t\t\t\t\tbit + i, bitmap_bh->b_data)) {\n\t\t\text2_error(sb, __func__,\n\t\t\t\t\"bit already cleared for block %lu\", block + i);\n\t\t} else {\n\t\t\tgroup_freed++;\n\t\t}\n\t}\n\n\tmark_buffer_dirty(bitmap_bh);\n\tif (sb->s_flags & MS_SYNCHRONOUS)\n\t\tsync_dirty_buffer(bitmap_bh);\n\n\tgroup_adjust_blocks(sb, block_group, desc, bh2, group_freed);\n\tfreed += group_freed;\n\n\tif (overflow) {\n\t\tblock += count;\n\t\tcount = overflow;\n\t\tgoto do_more;\n\t}\nerror_return:\n\tbrelse(bitmap_bh);\n\tif (freed) {\n\t\tpercpu_counter_add(&sbi->s_freeblocks_counter, freed);\n\t\tdquot_free_block_nodirty(inode, freed);\n\t\tmark_inode_dirty(inode);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext2_new_blocks",
          "args": [
            "inode",
            "goal",
            "&count",
            "err"
          ],
          "line": 417
        },
        "resolved": true,
        "details": {
          "function_name": "ext2_new_blocks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext2/balloc.c",
          "lines": "1210-1428",
          "snippet": "ext2_fsblk_t ext2_new_blocks(struct inode *inode, ext2_fsblk_t goal,\n\t\t    unsigned long *count, int *errp)\n{\n\tstruct buffer_head *bitmap_bh = NULL;\n\tstruct buffer_head *gdp_bh;\n\tint group_no;\n\tint goal_group;\n\text2_grpblk_t grp_target_blk;\t/* blockgroup relative goal block */\n\text2_grpblk_t grp_alloc_blk;\t/* blockgroup-relative allocated block*/\n\text2_fsblk_t ret_block;\t\t/* filesyetem-wide allocated block */\n\tint bgi;\t\t\t/* blockgroup iteration index */\n\tint performed_allocation = 0;\n\text2_grpblk_t free_blocks;\t/* number of free blocks in a group */\n\tstruct super_block *sb;\n\tstruct ext2_group_desc *gdp;\n\tstruct ext2_super_block *es;\n\tstruct ext2_sb_info *sbi;\n\tstruct ext2_reserve_window_node *my_rsv = NULL;\n\tstruct ext2_block_alloc_info *block_i;\n\tunsigned short windowsz = 0;\n\tunsigned long ngroups;\n\tunsigned long num = *count;\n\tint ret;\n\n\t*errp = -ENOSPC;\n\tsb = inode->i_sb;\n\n\t/*\n\t * Check quota for allocation of this block.\n\t */\n\tret = dquot_alloc_block(inode, num);\n\tif (ret) {\n\t\t*errp = ret;\n\t\treturn 0;\n\t}\n\n\tsbi = EXT2_SB(sb);\n\tes = EXT2_SB(sb)->s_es;\n\text2_debug(\"goal=%lu.\\n\", goal);\n\t/*\n\t * Allocate a block from reservation only when\n\t * filesystem is mounted with reservation(default,-o reservation), and\n\t * it's a regular file, and\n\t * the desired window size is greater than 0 (One could use ioctl\n\t * command EXT2_IOC_SETRSVSZ to set the window size to 0 to turn off\n\t * reservation on that particular file)\n\t */\n\tblock_i = EXT2_I(inode)->i_block_alloc_info;\n\tif (block_i) {\n\t\twindowsz = block_i->rsv_window_node.rsv_goal_size;\n\t\tif (windowsz > 0)\n\t\t\tmy_rsv = &block_i->rsv_window_node;\n\t}\n\n\tif (!ext2_has_free_blocks(sbi)) {\n\t\t*errp = -ENOSPC;\n\t\tgoto out;\n\t}\n\n\t/*\n\t * First, test whether the goal block is free.\n\t */\n\tif (goal < le32_to_cpu(es->s_first_data_block) ||\n\t    goal >= le32_to_cpu(es->s_blocks_count))\n\t\tgoal = le32_to_cpu(es->s_first_data_block);\n\tgroup_no = (goal - le32_to_cpu(es->s_first_data_block)) /\n\t\t\tEXT2_BLOCKS_PER_GROUP(sb);\n\tgoal_group = group_no;\nretry_alloc:\n\tgdp = ext2_get_group_desc(sb, group_no, &gdp_bh);\n\tif (!gdp)\n\t\tgoto io_error;\n\n\tfree_blocks = le16_to_cpu(gdp->bg_free_blocks_count);\n\t/*\n\t * if there is not enough free blocks to make a new resevation\n\t * turn off reservation for this allocation\n\t */\n\tif (my_rsv && (free_blocks < windowsz)\n\t\t&& (free_blocks > 0)\n\t\t&& (rsv_is_empty(&my_rsv->rsv_window)))\n\t\tmy_rsv = NULL;\n\n\tif (free_blocks > 0) {\n\t\tgrp_target_blk = ((goal - le32_to_cpu(es->s_first_data_block)) %\n\t\t\t\tEXT2_BLOCKS_PER_GROUP(sb));\n\t\tbitmap_bh = read_block_bitmap(sb, group_no);\n\t\tif (!bitmap_bh)\n\t\t\tgoto io_error;\n\t\tgrp_alloc_blk = ext2_try_to_allocate_with_rsv(sb, group_no,\n\t\t\t\t\tbitmap_bh, grp_target_blk,\n\t\t\t\t\tmy_rsv, &num);\n\t\tif (grp_alloc_blk >= 0)\n\t\t\tgoto allocated;\n\t}\n\n\tngroups = EXT2_SB(sb)->s_groups_count;\n\tsmp_rmb();\n\n\t/*\n\t * Now search the rest of the groups.  We assume that\n\t * group_no and gdp correctly point to the last group visited.\n\t */\n\tfor (bgi = 0; bgi < ngroups; bgi++) {\n\t\tgroup_no++;\n\t\tif (group_no >= ngroups)\n\t\t\tgroup_no = 0;\n\t\tgdp = ext2_get_group_desc(sb, group_no, &gdp_bh);\n\t\tif (!gdp)\n\t\t\tgoto io_error;\n\n\t\tfree_blocks = le16_to_cpu(gdp->bg_free_blocks_count);\n\t\t/*\n\t\t * skip this group (and avoid loading bitmap) if there\n\t\t * are no free blocks\n\t\t */\n\t\tif (!free_blocks)\n\t\t\tcontinue;\n\t\t/*\n\t\t * skip this group if the number of\n\t\t * free blocks is less than half of the reservation\n\t\t * window size.\n\t\t */\n\t\tif (my_rsv && (free_blocks <= (windowsz/2)))\n\t\t\tcontinue;\n\n\t\tbrelse(bitmap_bh);\n\t\tbitmap_bh = read_block_bitmap(sb, group_no);\n\t\tif (!bitmap_bh)\n\t\t\tgoto io_error;\n\t\t/*\n\t\t * try to allocate block(s) from this group, without a goal(-1).\n\t\t */\n\t\tgrp_alloc_blk = ext2_try_to_allocate_with_rsv(sb, group_no,\n\t\t\t\t\tbitmap_bh, -1, my_rsv, &num);\n\t\tif (grp_alloc_blk >= 0)\n\t\t\tgoto allocated;\n\t}\n\t/*\n\t * We may end up a bogus earlier ENOSPC error due to\n\t * filesystem is \"full\" of reservations, but\n\t * there maybe indeed free blocks available on disk\n\t * In this case, we just forget about the reservations\n\t * just do block allocation as without reservations.\n\t */\n\tif (my_rsv) {\n\t\tmy_rsv = NULL;\n\t\twindowsz = 0;\n\t\tgroup_no = goal_group;\n\t\tgoto retry_alloc;\n\t}\n\t/* No space left on the device */\n\t*errp = -ENOSPC;\n\tgoto out;\n\nallocated:\n\n\text2_debug(\"using block group %d(%d)\\n\",\n\t\t\tgroup_no, gdp->bg_free_blocks_count);\n\n\tret_block = grp_alloc_blk + ext2_group_first_block_no(sb, group_no);\n\n\tif (in_range(le32_to_cpu(gdp->bg_block_bitmap), ret_block, num) ||\n\t    in_range(le32_to_cpu(gdp->bg_inode_bitmap), ret_block, num) ||\n\t    in_range(ret_block, le32_to_cpu(gdp->bg_inode_table),\n\t\t      EXT2_SB(sb)->s_itb_per_group) ||\n\t    in_range(ret_block + num - 1, le32_to_cpu(gdp->bg_inode_table),\n\t\t      EXT2_SB(sb)->s_itb_per_group)) {\n\t\text2_error(sb, \"ext2_new_blocks\",\n\t\t\t    \"Allocating block in system zone - \"\n\t\t\t    \"blocks from \"E2FSBLK\", length %lu\",\n\t\t\t    ret_block, num);\n\t\t/*\n\t\t * ext2_try_to_allocate marked the blocks we allocated as in\n\t\t * use.  So we may want to selectively mark some of the blocks\n\t\t * as free\n\t\t */\n\t\tgoto retry_alloc;\n\t}\n\n\tperformed_allocation = 1;\n\n\tif (ret_block + num - 1 >= le32_to_cpu(es->s_blocks_count)) {\n\t\text2_error(sb, \"ext2_new_blocks\",\n\t\t\t    \"block(\"E2FSBLK\") >= blocks count(%d) - \"\n\t\t\t    \"block_group = %d, es == %p \", ret_block,\n\t\t\tle32_to_cpu(es->s_blocks_count), group_no, es);\n\t\tgoto out;\n\t}\n\n\tgroup_adjust_blocks(sb, group_no, gdp, gdp_bh, -num);\n\tpercpu_counter_sub(&sbi->s_freeblocks_counter, num);\n\n\tmark_buffer_dirty(bitmap_bh);\n\tif (sb->s_flags & MS_SYNCHRONOUS)\n\t\tsync_dirty_buffer(bitmap_bh);\n\n\t*errp = 0;\n\tbrelse(bitmap_bh);\n\tif (num < *count) {\n\t\tdquot_free_block_nodirty(inode, *count-num);\n\t\tmark_inode_dirty(inode);\n\t\t*count = num;\n\t}\n\treturn ret_block;\n\nio_error:\n\t*errp = -EIO;\nout:\n\t/*\n\t * Undo the block allocation\n\t */\n\tif (!performed_allocation) {\n\t\tdquot_free_block_nodirty(inode, *count);\n\t\tmark_inode_dirty(inode);\n\t}\n\tbrelse(bitmap_bh);\n\treturn 0;\n}",
          "includes": [
            "#include <linux/capability.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/quotaops.h>",
            "#include \"ext2.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/capability.h>\n#include <linux/buffer_head.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/quotaops.h>\n#include \"ext2.h\"\n\next2_fsblk_t ext2_new_blocks(struct inode *inode, ext2_fsblk_t goal,\n\t\t    unsigned long *count, int *errp)\n{\n\tstruct buffer_head *bitmap_bh = NULL;\n\tstruct buffer_head *gdp_bh;\n\tint group_no;\n\tint goal_group;\n\text2_grpblk_t grp_target_blk;\t/* blockgroup relative goal block */\n\text2_grpblk_t grp_alloc_blk;\t/* blockgroup-relative allocated block*/\n\text2_fsblk_t ret_block;\t\t/* filesyetem-wide allocated block */\n\tint bgi;\t\t\t/* blockgroup iteration index */\n\tint performed_allocation = 0;\n\text2_grpblk_t free_blocks;\t/* number of free blocks in a group */\n\tstruct super_block *sb;\n\tstruct ext2_group_desc *gdp;\n\tstruct ext2_super_block *es;\n\tstruct ext2_sb_info *sbi;\n\tstruct ext2_reserve_window_node *my_rsv = NULL;\n\tstruct ext2_block_alloc_info *block_i;\n\tunsigned short windowsz = 0;\n\tunsigned long ngroups;\n\tunsigned long num = *count;\n\tint ret;\n\n\t*errp = -ENOSPC;\n\tsb = inode->i_sb;\n\n\t/*\n\t * Check quota for allocation of this block.\n\t */\n\tret = dquot_alloc_block(inode, num);\n\tif (ret) {\n\t\t*errp = ret;\n\t\treturn 0;\n\t}\n\n\tsbi = EXT2_SB(sb);\n\tes = EXT2_SB(sb)->s_es;\n\text2_debug(\"goal=%lu.\\n\", goal);\n\t/*\n\t * Allocate a block from reservation only when\n\t * filesystem is mounted with reservation(default,-o reservation), and\n\t * it's a regular file, and\n\t * the desired window size is greater than 0 (One could use ioctl\n\t * command EXT2_IOC_SETRSVSZ to set the window size to 0 to turn off\n\t * reservation on that particular file)\n\t */\n\tblock_i = EXT2_I(inode)->i_block_alloc_info;\n\tif (block_i) {\n\t\twindowsz = block_i->rsv_window_node.rsv_goal_size;\n\t\tif (windowsz > 0)\n\t\t\tmy_rsv = &block_i->rsv_window_node;\n\t}\n\n\tif (!ext2_has_free_blocks(sbi)) {\n\t\t*errp = -ENOSPC;\n\t\tgoto out;\n\t}\n\n\t/*\n\t * First, test whether the goal block is free.\n\t */\n\tif (goal < le32_to_cpu(es->s_first_data_block) ||\n\t    goal >= le32_to_cpu(es->s_blocks_count))\n\t\tgoal = le32_to_cpu(es->s_first_data_block);\n\tgroup_no = (goal - le32_to_cpu(es->s_first_data_block)) /\n\t\t\tEXT2_BLOCKS_PER_GROUP(sb);\n\tgoal_group = group_no;\nretry_alloc:\n\tgdp = ext2_get_group_desc(sb, group_no, &gdp_bh);\n\tif (!gdp)\n\t\tgoto io_error;\n\n\tfree_blocks = le16_to_cpu(gdp->bg_free_blocks_count);\n\t/*\n\t * if there is not enough free blocks to make a new resevation\n\t * turn off reservation for this allocation\n\t */\n\tif (my_rsv && (free_blocks < windowsz)\n\t\t&& (free_blocks > 0)\n\t\t&& (rsv_is_empty(&my_rsv->rsv_window)))\n\t\tmy_rsv = NULL;\n\n\tif (free_blocks > 0) {\n\t\tgrp_target_blk = ((goal - le32_to_cpu(es->s_first_data_block)) %\n\t\t\t\tEXT2_BLOCKS_PER_GROUP(sb));\n\t\tbitmap_bh = read_block_bitmap(sb, group_no);\n\t\tif (!bitmap_bh)\n\t\t\tgoto io_error;\n\t\tgrp_alloc_blk = ext2_try_to_allocate_with_rsv(sb, group_no,\n\t\t\t\t\tbitmap_bh, grp_target_blk,\n\t\t\t\t\tmy_rsv, &num);\n\t\tif (grp_alloc_blk >= 0)\n\t\t\tgoto allocated;\n\t}\n\n\tngroups = EXT2_SB(sb)->s_groups_count;\n\tsmp_rmb();\n\n\t/*\n\t * Now search the rest of the groups.  We assume that\n\t * group_no and gdp correctly point to the last group visited.\n\t */\n\tfor (bgi = 0; bgi < ngroups; bgi++) {\n\t\tgroup_no++;\n\t\tif (group_no >= ngroups)\n\t\t\tgroup_no = 0;\n\t\tgdp = ext2_get_group_desc(sb, group_no, &gdp_bh);\n\t\tif (!gdp)\n\t\t\tgoto io_error;\n\n\t\tfree_blocks = le16_to_cpu(gdp->bg_free_blocks_count);\n\t\t/*\n\t\t * skip this group (and avoid loading bitmap) if there\n\t\t * are no free blocks\n\t\t */\n\t\tif (!free_blocks)\n\t\t\tcontinue;\n\t\t/*\n\t\t * skip this group if the number of\n\t\t * free blocks is less than half of the reservation\n\t\t * window size.\n\t\t */\n\t\tif (my_rsv && (free_blocks <= (windowsz/2)))\n\t\t\tcontinue;\n\n\t\tbrelse(bitmap_bh);\n\t\tbitmap_bh = read_block_bitmap(sb, group_no);\n\t\tif (!bitmap_bh)\n\t\t\tgoto io_error;\n\t\t/*\n\t\t * try to allocate block(s) from this group, without a goal(-1).\n\t\t */\n\t\tgrp_alloc_blk = ext2_try_to_allocate_with_rsv(sb, group_no,\n\t\t\t\t\tbitmap_bh, -1, my_rsv, &num);\n\t\tif (grp_alloc_blk >= 0)\n\t\t\tgoto allocated;\n\t}\n\t/*\n\t * We may end up a bogus earlier ENOSPC error due to\n\t * filesystem is \"full\" of reservations, but\n\t * there maybe indeed free blocks available on disk\n\t * In this case, we just forget about the reservations\n\t * just do block allocation as without reservations.\n\t */\n\tif (my_rsv) {\n\t\tmy_rsv = NULL;\n\t\twindowsz = 0;\n\t\tgroup_no = goal_group;\n\t\tgoto retry_alloc;\n\t}\n\t/* No space left on the device */\n\t*errp = -ENOSPC;\n\tgoto out;\n\nallocated:\n\n\text2_debug(\"using block group %d(%d)\\n\",\n\t\t\tgroup_no, gdp->bg_free_blocks_count);\n\n\tret_block = grp_alloc_blk + ext2_group_first_block_no(sb, group_no);\n\n\tif (in_range(le32_to_cpu(gdp->bg_block_bitmap), ret_block, num) ||\n\t    in_range(le32_to_cpu(gdp->bg_inode_bitmap), ret_block, num) ||\n\t    in_range(ret_block, le32_to_cpu(gdp->bg_inode_table),\n\t\t      EXT2_SB(sb)->s_itb_per_group) ||\n\t    in_range(ret_block + num - 1, le32_to_cpu(gdp->bg_inode_table),\n\t\t      EXT2_SB(sb)->s_itb_per_group)) {\n\t\text2_error(sb, \"ext2_new_blocks\",\n\t\t\t    \"Allocating block in system zone - \"\n\t\t\t    \"blocks from \"E2FSBLK\", length %lu\",\n\t\t\t    ret_block, num);\n\t\t/*\n\t\t * ext2_try_to_allocate marked the blocks we allocated as in\n\t\t * use.  So we may want to selectively mark some of the blocks\n\t\t * as free\n\t\t */\n\t\tgoto retry_alloc;\n\t}\n\n\tperformed_allocation = 1;\n\n\tif (ret_block + num - 1 >= le32_to_cpu(es->s_blocks_count)) {\n\t\text2_error(sb, \"ext2_new_blocks\",\n\t\t\t    \"block(\"E2FSBLK\") >= blocks count(%d) - \"\n\t\t\t    \"block_group = %d, es == %p \", ret_block,\n\t\t\tle32_to_cpu(es->s_blocks_count), group_no, es);\n\t\tgoto out;\n\t}\n\n\tgroup_adjust_blocks(sb, group_no, gdp, gdp_bh, -num);\n\tpercpu_counter_sub(&sbi->s_freeblocks_counter, num);\n\n\tmark_buffer_dirty(bitmap_bh);\n\tif (sb->s_flags & MS_SYNCHRONOUS)\n\t\tsync_dirty_buffer(bitmap_bh);\n\n\t*errp = 0;\n\tbrelse(bitmap_bh);\n\tif (num < *count) {\n\t\tdquot_free_block_nodirty(inode, *count-num);\n\t\tmark_inode_dirty(inode);\n\t\t*count = num;\n\t}\n\treturn ret_block;\n\nio_error:\n\t*errp = -EIO;\nout:\n\t/*\n\t * Undo the block allocation\n\t */\n\tif (!performed_allocation) {\n\t\tdquot_free_block_nodirty(inode, *count);\n\t\tmark_inode_dirty(inode);\n\t}\n\tbrelse(bitmap_bh);\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"xattr.h\"\n#include \"acl.h\"\n#include \"ext2.h\"\n#include <linux/aio.h>\n#include <linux/namei.h>\n#include <linux/fiemap.h>\n#include <linux/mpage.h>\n#include <linux/buffer_head.h>\n#include <linux/writeback.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/highuid.h>\n#include <linux/time.h>\n\nstatic int ext2_alloc_blocks(struct inode *inode,\n\t\t\text2_fsblk_t goal, int indirect_blks, int blks,\n\t\t\text2_fsblk_t new_blocks[4], int *err)\n{\n\tint target, i;\n\tunsigned long count = 0;\n\tint index = 0;\n\text2_fsblk_t current_block = 0;\n\tint ret = 0;\n\n\t/*\n\t * Here we try to allocate the requested multiple blocks at once,\n\t * on a best-effort basis.\n\t * To build a branch, we should allocate blocks for\n\t * the indirect blocks(if not allocated yet), and at least\n\t * the first direct block of this branch.  That's the\n\t * minimum number of blocks need to allocate(required)\n\t */\n\ttarget = blks + indirect_blks;\n\n\twhile (1) {\n\t\tcount = target;\n\t\t/* allocating blocks for indirect blocks and direct blocks */\n\t\tcurrent_block = ext2_new_blocks(inode,goal,&count,err);\n\t\tif (*err)\n\t\t\tgoto failed_out;\n\n\t\ttarget -= count;\n\t\t/* allocate blocks for indirect blocks */\n\t\twhile (index < indirect_blks && count) {\n\t\t\tnew_blocks[index++] = current_block++;\n\t\t\tcount--;\n\t\t}\n\n\t\tif (count > 0)\n\t\t\tbreak;\n\t}\n\n\t/* save the new block number for the first direct block */\n\tnew_blocks[index] = current_block;\n\n\t/* total number of blocks allocated for direct blocks */\n\tret = count;\n\t*err = 0;\n\treturn ret;\nfailed_out:\n\tfor (i = 0; i <index; i++)\n\t\text2_free_blocks(inode, new_blocks[i], 1);\n\tif (index)\n\t\tmark_inode_dirty(inode);\n\treturn ret;\n}"
  },
  {
    "function_name": "ext2_blks_to_allocate",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext2/inode.c",
    "lines": "357-382",
    "snippet": "static int\next2_blks_to_allocate(Indirect * branch, int k, unsigned long blks,\n\t\tint blocks_to_boundary)\n{\n\tunsigned long count = 0;\n\n\t/*\n\t * Simple case, [t,d]Indirect block(s) has not allocated yet\n\t * then it's clear blocks on that path have not allocated\n\t */\n\tif (k > 0) {\n\t\t/* right now don't hanel cross boundary allocation */\n\t\tif (blks < blocks_to_boundary + 1)\n\t\t\tcount += blks;\n\t\telse\n\t\t\tcount += blocks_to_boundary + 1;\n\t\treturn count;\n\t}\n\n\tcount++;\n\twhile (count < blks && count <= blocks_to_boundary\n\t\t&& le32_to_cpu(*(branch[0].p + count)) == 0) {\n\t\tcount++;\n\t}\n\treturn count;\n}",
    "includes": [
      "#include \"xattr.h\"",
      "#include \"acl.h\"",
      "#include \"ext2.h\"",
      "#include <linux/aio.h>",
      "#include <linux/namei.h>",
      "#include <linux/fiemap.h>",
      "#include <linux/mpage.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/writeback.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/highuid.h>",
      "#include <linux/time.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "*(branch[0].p + count)"
          ],
          "line": 378
        },
        "resolved": true,
        "details": {
          "function_name": "sle32_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "53-56",
          "snippet": "static inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"xattr.h\"\n#include \"acl.h\"\n#include \"ext2.h\"\n#include <linux/aio.h>\n#include <linux/namei.h>\n#include <linux/fiemap.h>\n#include <linux/mpage.h>\n#include <linux/buffer_head.h>\n#include <linux/writeback.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/highuid.h>\n#include <linux/time.h>\n\nstatic int\next2_blks_to_allocate(Indirect * branch, int k, unsigned long blks,\n\t\tint blocks_to_boundary)\n{\n\tunsigned long count = 0;\n\n\t/*\n\t * Simple case, [t,d]Indirect block(s) has not allocated yet\n\t * then it's clear blocks on that path have not allocated\n\t */\n\tif (k > 0) {\n\t\t/* right now don't hanel cross boundary allocation */\n\t\tif (blks < blocks_to_boundary + 1)\n\t\t\tcount += blks;\n\t\telse\n\t\t\tcount += blocks_to_boundary + 1;\n\t\treturn count;\n\t}\n\n\tcount++;\n\twhile (count < blks && count <= blocks_to_boundary\n\t\t&& le32_to_cpu(*(branch[0].p + count)) == 0) {\n\t\tcount++;\n\t}\n\treturn count;\n}"
  },
  {
    "function_name": "ext2_find_goal",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext2/inode.c",
    "lines": "326-343",
    "snippet": "static inline ext2_fsblk_t ext2_find_goal(struct inode *inode, long block,\n\t\t\t\t\t  Indirect *partial)\n{\n\tstruct ext2_block_alloc_info *block_i;\n\n\tblock_i = EXT2_I(inode)->i_block_alloc_info;\n\n\t/*\n\t * try the heuristic for sequential allocation,\n\t * failing that at least try to get decent locality.\n\t */\n\tif (block_i && (block == block_i->last_alloc_logical_block + 1)\n\t\t&& (block_i->last_alloc_physical_block != 0)) {\n\t\treturn block_i->last_alloc_physical_block + 1;\n\t}\n\n\treturn ext2_find_near(inode, partial);\n}",
    "includes": [
      "#include \"xattr.h\"",
      "#include \"acl.h\"",
      "#include \"ext2.h\"",
      "#include <linux/aio.h>",
      "#include <linux/namei.h>",
      "#include <linux/fiemap.h>",
      "#include <linux/mpage.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/writeback.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/highuid.h>",
      "#include <linux/time.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ext2_find_near",
          "args": [
            "inode",
            "partial"
          ],
          "line": 342
        },
        "resolved": true,
        "details": {
          "function_name": "ext2_find_near",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext2/inode.c",
          "lines": "290-315",
          "snippet": "static ext2_fsblk_t ext2_find_near(struct inode *inode, Indirect *ind)\n{\n\tstruct ext2_inode_info *ei = EXT2_I(inode);\n\t__le32 *start = ind->bh ? (__le32 *) ind->bh->b_data : ei->i_data;\n\t__le32 *p;\n\text2_fsblk_t bg_start;\n\text2_fsblk_t colour;\n\n\t/* Try to find previous block */\n\tfor (p = ind->p - 1; p >= start; p--)\n\t\tif (*p)\n\t\t\treturn le32_to_cpu(*p);\n\n\t/* No such thing, so let's try location of indirect block */\n\tif (ind->bh)\n\t\treturn ind->bh->b_blocknr;\n\n\t/*\n\t * It is going to be referred from inode itself? OK, just put it into\n\t * the same cylinder group then.\n\t */\n\tbg_start = ext2_group_first_block_no(inode->i_sb, ei->i_block_group);\n\tcolour = (current->pid % 16) *\n\t\t\t(EXT2_BLOCKS_PER_GROUP(inode->i_sb) / 16);\n\treturn bg_start + colour;\n}",
          "includes": [
            "#include \"xattr.h\"",
            "#include \"acl.h\"",
            "#include \"ext2.h\"",
            "#include <linux/aio.h>",
            "#include <linux/namei.h>",
            "#include <linux/fiemap.h>",
            "#include <linux/mpage.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/writeback.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highuid.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xattr.h\"\n#include \"acl.h\"\n#include \"ext2.h\"\n#include <linux/aio.h>\n#include <linux/namei.h>\n#include <linux/fiemap.h>\n#include <linux/mpage.h>\n#include <linux/buffer_head.h>\n#include <linux/writeback.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/highuid.h>\n#include <linux/time.h>\n\nstatic ext2_fsblk_t ext2_find_near(struct inode *inode, Indirect *ind)\n{\n\tstruct ext2_inode_info *ei = EXT2_I(inode);\n\t__le32 *start = ind->bh ? (__le32 *) ind->bh->b_data : ei->i_data;\n\t__le32 *p;\n\text2_fsblk_t bg_start;\n\text2_fsblk_t colour;\n\n\t/* Try to find previous block */\n\tfor (p = ind->p - 1; p >= start; p--)\n\t\tif (*p)\n\t\t\treturn le32_to_cpu(*p);\n\n\t/* No such thing, so let's try location of indirect block */\n\tif (ind->bh)\n\t\treturn ind->bh->b_blocknr;\n\n\t/*\n\t * It is going to be referred from inode itself? OK, just put it into\n\t * the same cylinder group then.\n\t */\n\tbg_start = ext2_group_first_block_no(inode->i_sb, ei->i_block_group);\n\tcolour = (current->pid % 16) *\n\t\t\t(EXT2_BLOCKS_PER_GROUP(inode->i_sb) / 16);\n\treturn bg_start + colour;\n}"
        }
      },
      {
        "call_info": {
          "callee": "EXT2_I",
          "args": [
            "inode"
          ],
          "line": 331
        },
        "resolved": true,
        "details": {
          "function_name": "EXT2_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext2/ext2.h",
          "lines": "717-720",
          "snippet": "static inline struct ext2_inode_info *EXT2_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ext2_inode_info, vfs_inode);\n}",
          "includes": [
            "#include <linux/rbtree.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/ext2_fs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern ext2_fsblk_t ext2_new_block(struct inode *, unsigned long, int *);",
            "extern ext2_fsblk_t ext2_new_blocks(struct inode *, unsigned long,\n\t\t\t\tunsigned long *, int *);",
            "extern void ext2_free_blocks (struct inode *, unsigned long,\n\t\t\t      unsigned long);",
            "extern void ext2_discard_reservation (struct inode *);",
            "extern void ext2_init_block_alloc_info(struct inode *);",
            "extern int ext2_add_link (struct dentry *, struct inode *);",
            "extern int ext2_make_empty(struct inode *, struct inode *);",
            "extern int ext2_empty_dir (struct inode *);",
            "extern void ext2_set_link(struct inode *, struct ext2_dir_entry_2 *, struct page *, struct inode *, int);",
            "extern void ext2_free_inode (struct inode *);",
            "extern void ext2_evict_inode(struct inode *);",
            "extern void ext2_set_inode_flags(struct inode *inode);",
            "extern void ext2_get_inode_flags(struct ext2_inode_info *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rbtree.h>\n#include <linux/percpu_counter.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/ext2_fs.h>\n#include <linux/fs.h>\n\nextern ext2_fsblk_t ext2_new_block(struct inode *, unsigned long, int *);\nextern ext2_fsblk_t ext2_new_blocks(struct inode *, unsigned long,\n\t\t\t\tunsigned long *, int *);\nextern void ext2_free_blocks (struct inode *, unsigned long,\n\t\t\t      unsigned long);\nextern void ext2_discard_reservation (struct inode *);\nextern void ext2_init_block_alloc_info(struct inode *);\nextern int ext2_add_link (struct dentry *, struct inode *);\nextern int ext2_make_empty(struct inode *, struct inode *);\nextern int ext2_empty_dir (struct inode *);\nextern void ext2_set_link(struct inode *, struct ext2_dir_entry_2 *, struct page *, struct inode *, int);\nextern void ext2_free_inode (struct inode *);\nextern void ext2_evict_inode(struct inode *);\nextern void ext2_set_inode_flags(struct inode *inode);\nextern void ext2_get_inode_flags(struct ext2_inode_info *);\n\nstatic inline struct ext2_inode_info *EXT2_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ext2_inode_info, vfs_inode);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"xattr.h\"\n#include \"acl.h\"\n#include \"ext2.h\"\n#include <linux/aio.h>\n#include <linux/namei.h>\n#include <linux/fiemap.h>\n#include <linux/mpage.h>\n#include <linux/buffer_head.h>\n#include <linux/writeback.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/highuid.h>\n#include <linux/time.h>\n\nstatic inline ext2_fsblk_t ext2_find_goal(struct inode *inode, long block,\n\t\t\t\t\t  Indirect *partial)\n{\n\tstruct ext2_block_alloc_info *block_i;\n\n\tblock_i = EXT2_I(inode)->i_block_alloc_info;\n\n\t/*\n\t * try the heuristic for sequential allocation,\n\t * failing that at least try to get decent locality.\n\t */\n\tif (block_i && (block == block_i->last_alloc_logical_block + 1)\n\t\t&& (block_i->last_alloc_physical_block != 0)) {\n\t\treturn block_i->last_alloc_physical_block + 1;\n\t}\n\n\treturn ext2_find_near(inode, partial);\n}"
  },
  {
    "function_name": "ext2_find_near",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext2/inode.c",
    "lines": "290-315",
    "snippet": "static ext2_fsblk_t ext2_find_near(struct inode *inode, Indirect *ind)\n{\n\tstruct ext2_inode_info *ei = EXT2_I(inode);\n\t__le32 *start = ind->bh ? (__le32 *) ind->bh->b_data : ei->i_data;\n\t__le32 *p;\n\text2_fsblk_t bg_start;\n\text2_fsblk_t colour;\n\n\t/* Try to find previous block */\n\tfor (p = ind->p - 1; p >= start; p--)\n\t\tif (*p)\n\t\t\treturn le32_to_cpu(*p);\n\n\t/* No such thing, so let's try location of indirect block */\n\tif (ind->bh)\n\t\treturn ind->bh->b_blocknr;\n\n\t/*\n\t * It is going to be referred from inode itself? OK, just put it into\n\t * the same cylinder group then.\n\t */\n\tbg_start = ext2_group_first_block_no(inode->i_sb, ei->i_block_group);\n\tcolour = (current->pid % 16) *\n\t\t\t(EXT2_BLOCKS_PER_GROUP(inode->i_sb) / 16);\n\treturn bg_start + colour;\n}",
    "includes": [
      "#include \"xattr.h\"",
      "#include \"acl.h\"",
      "#include \"ext2.h\"",
      "#include <linux/aio.h>",
      "#include <linux/namei.h>",
      "#include <linux/fiemap.h>",
      "#include <linux/mpage.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/writeback.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/highuid.h>",
      "#include <linux/time.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "EXT2_BLOCKS_PER_GROUP",
          "args": [
            "inode->i_sb"
          ],
          "line": 313
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext2_group_first_block_no",
          "args": [
            "inode->i_sb",
            "ei->i_block_group"
          ],
          "line": 311
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "*p"
          ],
          "line": 301
        },
        "resolved": true,
        "details": {
          "function_name": "sle32_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "53-56",
          "snippet": "static inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "EXT2_I",
          "args": [
            "inode"
          ],
          "line": 292
        },
        "resolved": true,
        "details": {
          "function_name": "EXT2_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext2/ext2.h",
          "lines": "717-720",
          "snippet": "static inline struct ext2_inode_info *EXT2_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ext2_inode_info, vfs_inode);\n}",
          "includes": [
            "#include <linux/rbtree.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/ext2_fs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern ext2_fsblk_t ext2_new_block(struct inode *, unsigned long, int *);",
            "extern ext2_fsblk_t ext2_new_blocks(struct inode *, unsigned long,\n\t\t\t\tunsigned long *, int *);",
            "extern void ext2_free_blocks (struct inode *, unsigned long,\n\t\t\t      unsigned long);",
            "extern void ext2_discard_reservation (struct inode *);",
            "extern void ext2_init_block_alloc_info(struct inode *);",
            "extern int ext2_add_link (struct dentry *, struct inode *);",
            "extern int ext2_make_empty(struct inode *, struct inode *);",
            "extern int ext2_empty_dir (struct inode *);",
            "extern void ext2_set_link(struct inode *, struct ext2_dir_entry_2 *, struct page *, struct inode *, int);",
            "extern void ext2_free_inode (struct inode *);",
            "extern void ext2_evict_inode(struct inode *);",
            "extern void ext2_set_inode_flags(struct inode *inode);",
            "extern void ext2_get_inode_flags(struct ext2_inode_info *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rbtree.h>\n#include <linux/percpu_counter.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/ext2_fs.h>\n#include <linux/fs.h>\n\nextern ext2_fsblk_t ext2_new_block(struct inode *, unsigned long, int *);\nextern ext2_fsblk_t ext2_new_blocks(struct inode *, unsigned long,\n\t\t\t\tunsigned long *, int *);\nextern void ext2_free_blocks (struct inode *, unsigned long,\n\t\t\t      unsigned long);\nextern void ext2_discard_reservation (struct inode *);\nextern void ext2_init_block_alloc_info(struct inode *);\nextern int ext2_add_link (struct dentry *, struct inode *);\nextern int ext2_make_empty(struct inode *, struct inode *);\nextern int ext2_empty_dir (struct inode *);\nextern void ext2_set_link(struct inode *, struct ext2_dir_entry_2 *, struct page *, struct inode *, int);\nextern void ext2_free_inode (struct inode *);\nextern void ext2_evict_inode(struct inode *);\nextern void ext2_set_inode_flags(struct inode *inode);\nextern void ext2_get_inode_flags(struct ext2_inode_info *);\n\nstatic inline struct ext2_inode_info *EXT2_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ext2_inode_info, vfs_inode);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"xattr.h\"\n#include \"acl.h\"\n#include \"ext2.h\"\n#include <linux/aio.h>\n#include <linux/namei.h>\n#include <linux/fiemap.h>\n#include <linux/mpage.h>\n#include <linux/buffer_head.h>\n#include <linux/writeback.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/highuid.h>\n#include <linux/time.h>\n\nstatic ext2_fsblk_t ext2_find_near(struct inode *inode, Indirect *ind)\n{\n\tstruct ext2_inode_info *ei = EXT2_I(inode);\n\t__le32 *start = ind->bh ? (__le32 *) ind->bh->b_data : ei->i_data;\n\t__le32 *p;\n\text2_fsblk_t bg_start;\n\text2_fsblk_t colour;\n\n\t/* Try to find previous block */\n\tfor (p = ind->p - 1; p >= start; p--)\n\t\tif (*p)\n\t\t\treturn le32_to_cpu(*p);\n\n\t/* No such thing, so let's try location of indirect block */\n\tif (ind->bh)\n\t\treturn ind->bh->b_blocknr;\n\n\t/*\n\t * It is going to be referred from inode itself? OK, just put it into\n\t * the same cylinder group then.\n\t */\n\tbg_start = ext2_group_first_block_no(inode->i_sb, ei->i_block_group);\n\tcolour = (current->pid % 16) *\n\t\t\t(EXT2_BLOCKS_PER_GROUP(inode->i_sb) / 16);\n\treturn bg_start + colour;\n}"
  },
  {
    "function_name": "ext2_get_branch",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext2/inode.c",
    "lines": "230-268",
    "snippet": "static Indirect *ext2_get_branch(struct inode *inode,\n\t\t\t\t int depth,\n\t\t\t\t int *offsets,\n\t\t\t\t Indirect chain[4],\n\t\t\t\t int *err)\n{\n\tstruct super_block *sb = inode->i_sb;\n\tIndirect *p = chain;\n\tstruct buffer_head *bh;\n\n\t*err = 0;\n\t/* i_data is not going away, no lock needed */\n\tadd_chain (chain, NULL, EXT2_I(inode)->i_data + *offsets);\n\tif (!p->key)\n\t\tgoto no_block;\n\twhile (--depth) {\n\t\tbh = sb_bread(sb, le32_to_cpu(p->key));\n\t\tif (!bh)\n\t\t\tgoto failure;\n\t\tread_lock(&EXT2_I(inode)->i_meta_lock);\n\t\tif (!verify_chain(chain, p))\n\t\t\tgoto changed;\n\t\tadd_chain(++p, bh, (__le32*)bh->b_data + *++offsets);\n\t\tread_unlock(&EXT2_I(inode)->i_meta_lock);\n\t\tif (!p->key)\n\t\t\tgoto no_block;\n\t}\n\treturn NULL;\n\nchanged:\n\tread_unlock(&EXT2_I(inode)->i_meta_lock);\n\tbrelse(bh);\n\t*err = -EAGAIN;\n\tgoto no_block;\nfailure:\n\t*err = -EIO;\nno_block:\n\treturn p;\n}",
    "includes": [
      "#include \"xattr.h\"",
      "#include \"acl.h\"",
      "#include \"ext2.h\"",
      "#include <linux/aio.h>",
      "#include <linux/namei.h>",
      "#include <linux/fiemap.h>",
      "#include <linux/mpage.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/writeback.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/highuid.h>",
      "#include <linux/time.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "brelse",
          "args": [
            "bh"
          ],
          "line": 261
        },
        "resolved": true,
        "details": {
          "function_name": "__brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1177-1184",
          "snippet": "void __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "read_unlock",
          "args": [
            "&EXT2_I(inode)->i_meta_lock"
          ],
          "line": 260
        },
        "resolved": true,
        "details": {
          "function_name": "tree_mod_log_read_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "340-343",
          "snippet": "static inline void tree_mod_log_read_unlock(struct btrfs_fs_info *fs_info)\n{\n\tread_unlock(&fs_info->tree_mod_log_lock);\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nstatic inline void tree_mod_log_read_unlock(struct btrfs_fs_info *fs_info)\n{\n\tread_unlock(&fs_info->tree_mod_log_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "EXT2_I",
          "args": [
            "inode"
          ],
          "line": 260
        },
        "resolved": true,
        "details": {
          "function_name": "EXT2_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext2/ext2.h",
          "lines": "717-720",
          "snippet": "static inline struct ext2_inode_info *EXT2_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ext2_inode_info, vfs_inode);\n}",
          "includes": [
            "#include <linux/rbtree.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/ext2_fs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern ext2_fsblk_t ext2_new_block(struct inode *, unsigned long, int *);",
            "extern ext2_fsblk_t ext2_new_blocks(struct inode *, unsigned long,\n\t\t\t\tunsigned long *, int *);",
            "extern void ext2_free_blocks (struct inode *, unsigned long,\n\t\t\t      unsigned long);",
            "extern void ext2_discard_reservation (struct inode *);",
            "extern void ext2_init_block_alloc_info(struct inode *);",
            "extern int ext2_add_link (struct dentry *, struct inode *);",
            "extern int ext2_make_empty(struct inode *, struct inode *);",
            "extern int ext2_empty_dir (struct inode *);",
            "extern void ext2_set_link(struct inode *, struct ext2_dir_entry_2 *, struct page *, struct inode *, int);",
            "extern void ext2_free_inode (struct inode *);",
            "extern void ext2_evict_inode(struct inode *);",
            "extern void ext2_set_inode_flags(struct inode *inode);",
            "extern void ext2_get_inode_flags(struct ext2_inode_info *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rbtree.h>\n#include <linux/percpu_counter.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/ext2_fs.h>\n#include <linux/fs.h>\n\nextern ext2_fsblk_t ext2_new_block(struct inode *, unsigned long, int *);\nextern ext2_fsblk_t ext2_new_blocks(struct inode *, unsigned long,\n\t\t\t\tunsigned long *, int *);\nextern void ext2_free_blocks (struct inode *, unsigned long,\n\t\t\t      unsigned long);\nextern void ext2_discard_reservation (struct inode *);\nextern void ext2_init_block_alloc_info(struct inode *);\nextern int ext2_add_link (struct dentry *, struct inode *);\nextern int ext2_make_empty(struct inode *, struct inode *);\nextern int ext2_empty_dir (struct inode *);\nextern void ext2_set_link(struct inode *, struct ext2_dir_entry_2 *, struct page *, struct inode *, int);\nextern void ext2_free_inode (struct inode *);\nextern void ext2_evict_inode(struct inode *);\nextern void ext2_set_inode_flags(struct inode *inode);\nextern void ext2_get_inode_flags(struct ext2_inode_info *);\n\nstatic inline struct ext2_inode_info *EXT2_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ext2_inode_info, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "add_chain",
          "args": [
            "++p",
            "bh",
            "(__le32*)bh->b_data + *++offsets"
          ],
          "line": 252
        },
        "resolved": true,
        "details": {
          "function_name": "add_chain",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext2/inode.c",
          "lines": "116-120",
          "snippet": "static inline void add_chain(Indirect *p, struct buffer_head *bh, __le32 *v)\n{\n\tp->key = *(p->p = v);\n\tp->bh = bh;\n}",
          "includes": [
            "#include \"xattr.h\"",
            "#include \"acl.h\"",
            "#include \"ext2.h\"",
            "#include <linux/aio.h>",
            "#include <linux/namei.h>",
            "#include <linux/fiemap.h>",
            "#include <linux/mpage.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/writeback.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highuid.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xattr.h\"\n#include \"acl.h\"\n#include \"ext2.h\"\n#include <linux/aio.h>\n#include <linux/namei.h>\n#include <linux/fiemap.h>\n#include <linux/mpage.h>\n#include <linux/buffer_head.h>\n#include <linux/writeback.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/highuid.h>\n#include <linux/time.h>\n\nstatic inline void add_chain(Indirect *p, struct buffer_head *bh, __le32 *v)\n{\n\tp->key = *(p->p = v);\n\tp->bh = bh;\n}"
        }
      },
      {
        "call_info": {
          "callee": "verify_chain",
          "args": [
            "chain",
            "p"
          ],
          "line": 250
        },
        "resolved": true,
        "details": {
          "function_name": "verify_chain",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext2/inode.c",
          "lines": "122-127",
          "snippet": "static inline int verify_chain(Indirect *from, Indirect *to)\n{\n\twhile (from <= to && from->key == *from->p)\n\t\tfrom++;\n\treturn (from > to);\n}",
          "includes": [
            "#include \"xattr.h\"",
            "#include \"acl.h\"",
            "#include \"ext2.h\"",
            "#include <linux/aio.h>",
            "#include <linux/namei.h>",
            "#include <linux/fiemap.h>",
            "#include <linux/mpage.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/writeback.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highuid.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xattr.h\"\n#include \"acl.h\"\n#include \"ext2.h\"\n#include <linux/aio.h>\n#include <linux/namei.h>\n#include <linux/fiemap.h>\n#include <linux/mpage.h>\n#include <linux/buffer_head.h>\n#include <linux/writeback.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/highuid.h>\n#include <linux/time.h>\n\nstatic inline int verify_chain(Indirect *from, Indirect *to)\n{\n\twhile (from <= to && from->key == *from->p)\n\t\tfrom++;\n\treturn (from > to);\n}"
        }
      },
      {
        "call_info": {
          "callee": "read_lock",
          "args": [
            "&EXT2_I(inode)->i_meta_lock"
          ],
          "line": 249
        },
        "resolved": true,
        "details": {
          "function_name": "ntfs_read_locked_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/inode.c",
          "lines": "550-1203",
          "snippet": "static int ntfs_read_locked_inode(struct inode *vi)\n{\n\tntfs_volume *vol = NTFS_SB(vi->i_sb);\n\tntfs_inode *ni;\n\tstruct inode *bvi;\n\tMFT_RECORD *m;\n\tATTR_RECORD *a;\n\tSTANDARD_INFORMATION *si;\n\tntfs_attr_search_ctx *ctx;\n\tint err = 0;\n\n\tntfs_debug(\"Entering for i_ino 0x%lx.\", vi->i_ino);\n\n\t/* Setup the generic vfs inode parts now. */\n\n\t/*\n\t * This is for checking whether an inode has changed w.r.t. a file so\n\t * that the file can be updated if necessary (compare with f_version).\n\t */\n\tvi->i_version = 1;\n\n\tvi->i_uid = vol->uid;\n\tvi->i_gid = vol->gid;\n\tvi->i_mode = 0;\n\n\t/*\n\t * Initialize the ntfs specific part of @vi special casing\n\t * FILE_MFT which we need to do at mount time.\n\t */\n\tif (vi->i_ino != FILE_MFT)\n\t\tntfs_init_big_inode(vi);\n\tni = NTFS_I(vi);\n\n\tm = map_mft_record(ni);\n\tif (IS_ERR(m)) {\n\t\terr = PTR_ERR(m);\n\t\tgoto err_out;\n\t}\n\tctx = ntfs_attr_get_search_ctx(ni, m);\n\tif (!ctx) {\n\t\terr = -ENOMEM;\n\t\tgoto unm_err_out;\n\t}\n\n\tif (!(m->flags & MFT_RECORD_IN_USE)) {\n\t\tntfs_error(vi->i_sb, \"Inode is not in use!\");\n\t\tgoto unm_err_out;\n\t}\n\tif (m->base_mft_record) {\n\t\tntfs_error(vi->i_sb, \"Inode is an extent inode!\");\n\t\tgoto unm_err_out;\n\t}\n\n\t/* Transfer information from mft record into vfs and ntfs inodes. */\n\tvi->i_generation = ni->seq_no = le16_to_cpu(m->sequence_number);\n\n\t/*\n\t * FIXME: Keep in mind that link_count is two for files which have both\n\t * a long file name and a short file name as separate entries, so if\n\t * we are hiding short file names this will be too high. Either we need\n\t * to account for the short file names by subtracting them or we need\n\t * to make sure we delete files even though i_nlink is not zero which\n\t * might be tricky due to vfs interactions. Need to think about this\n\t * some more when implementing the unlink command.\n\t */\n\tset_nlink(vi, le16_to_cpu(m->link_count));\n\t/*\n\t * FIXME: Reparse points can have the directory bit set even though\n\t * they would be S_IFLNK. Need to deal with this further below when we\n\t * implement reparse points / symbolic links but it will do for now.\n\t * Also if not a directory, it could be something else, rather than\n\t * a regular file. But again, will do for now.\n\t */\n\t/* Everyone gets all permissions. */\n\tvi->i_mode |= S_IRWXUGO;\n\t/* If read-only, no one gets write permissions. */\n\tif (IS_RDONLY(vi))\n\t\tvi->i_mode &= ~S_IWUGO;\n\tif (m->flags & MFT_RECORD_IS_DIRECTORY) {\n\t\tvi->i_mode |= S_IFDIR;\n\t\t/*\n\t\t * Apply the directory permissions mask set in the mount\n\t\t * options.\n\t\t */\n\t\tvi->i_mode &= ~vol->dmask;\n\t\t/* Things break without this kludge! */\n\t\tif (vi->i_nlink > 1)\n\t\t\tset_nlink(vi, 1);\n\t} else {\n\t\tvi->i_mode |= S_IFREG;\n\t\t/* Apply the file permissions mask set in the mount options. */\n\t\tvi->i_mode &= ~vol->fmask;\n\t}\n\t/*\n\t * Find the standard information attribute in the mft record. At this\n\t * stage we haven't setup the attribute list stuff yet, so this could\n\t * in fact fail if the standard information is in an extent record, but\n\t * I don't think this actually ever happens.\n\t */\n\terr = ntfs_attr_lookup(AT_STANDARD_INFORMATION, NULL, 0, 0, 0, NULL, 0,\n\t\t\tctx);\n\tif (unlikely(err)) {\n\t\tif (err == -ENOENT) {\n\t\t\t/*\n\t\t\t * TODO: We should be performing a hot fix here (if the\n\t\t\t * recover mount option is set) by creating a new\n\t\t\t * attribute.\n\t\t\t */\n\t\t\tntfs_error(vi->i_sb, \"$STANDARD_INFORMATION attribute \"\n\t\t\t\t\t\"is missing.\");\n\t\t}\n\t\tgoto unm_err_out;\n\t}\n\ta = ctx->attr;\n\t/* Get the standard information attribute value. */\n\tsi = (STANDARD_INFORMATION*)((u8*)a +\n\t\t\tle16_to_cpu(a->data.resident.value_offset));\n\n\t/* Transfer information from the standard information into vi. */\n\t/*\n\t * Note: The i_?times do not quite map perfectly onto the NTFS times,\n\t * but they are close enough, and in the end it doesn't really matter\n\t * that much...\n\t */\n\t/*\n\t * mtime is the last change of the data within the file. Not changed\n\t * when only metadata is changed, e.g. a rename doesn't affect mtime.\n\t */\n\tvi->i_mtime = ntfs2utc(si->last_data_change_time);\n\t/*\n\t * ctime is the last change of the metadata of the file. This obviously\n\t * always changes, when mtime is changed. ctime can be changed on its\n\t * own, mtime is then not changed, e.g. when a file is renamed.\n\t */\n\tvi->i_ctime = ntfs2utc(si->last_mft_change_time);\n\t/*\n\t * Last access to the data within the file. Not changed during a rename\n\t * for example but changed whenever the file is written to.\n\t */\n\tvi->i_atime = ntfs2utc(si->last_access_time);\n\n\t/* Find the attribute list attribute if present. */\n\tntfs_attr_reinit_search_ctx(ctx);\n\terr = ntfs_attr_lookup(AT_ATTRIBUTE_LIST, NULL, 0, 0, 0, NULL, 0, ctx);\n\tif (err) {\n\t\tif (unlikely(err != -ENOENT)) {\n\t\t\tntfs_error(vi->i_sb, \"Failed to lookup attribute list \"\n\t\t\t\t\t\"attribute.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t} else /* if (!err) */ {\n\t\tif (vi->i_ino == FILE_MFT)\n\t\t\tgoto skip_attr_list_load;\n\t\tntfs_debug(\"Attribute list found in inode 0x%lx.\", vi->i_ino);\n\t\tNInoSetAttrList(ni);\n\t\ta = ctx->attr;\n\t\tif (a->flags & ATTR_COMPRESSION_MASK) {\n\t\t\tntfs_error(vi->i_sb, \"Attribute list attribute is \"\n\t\t\t\t\t\"compressed.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tif (a->flags & ATTR_IS_ENCRYPTED ||\n\t\t\t\ta->flags & ATTR_IS_SPARSE) {\n\t\t\tif (a->non_resident) {\n\t\t\t\tntfs_error(vi->i_sb, \"Non-resident attribute \"\n\t\t\t\t\t\t\"list attribute is encrypted/\"\n\t\t\t\t\t\t\"sparse.\");\n\t\t\t\tgoto unm_err_out;\n\t\t\t}\n\t\t\tntfs_warning(vi->i_sb, \"Resident attribute list \"\n\t\t\t\t\t\"attribute in inode 0x%lx is marked \"\n\t\t\t\t\t\"encrypted/sparse which is not true.  \"\n\t\t\t\t\t\"However, Windows allows this and \"\n\t\t\t\t\t\"chkdsk does not detect or correct it \"\n\t\t\t\t\t\"so we will just ignore the invalid \"\n\t\t\t\t\t\"flags and pretend they are not set.\",\n\t\t\t\t\tvi->i_ino);\n\t\t}\n\t\t/* Now allocate memory for the attribute list. */\n\t\tni->attr_list_size = (u32)ntfs_attr_size(a);\n\t\tni->attr_list = ntfs_malloc_nofs(ni->attr_list_size);\n\t\tif (!ni->attr_list) {\n\t\t\tntfs_error(vi->i_sb, \"Not enough memory to allocate \"\n\t\t\t\t\t\"buffer for attribute list.\");\n\t\t\terr = -ENOMEM;\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tif (a->non_resident) {\n\t\t\tNInoSetAttrListNonResident(ni);\n\t\t\tif (a->data.non_resident.lowest_vcn) {\n\t\t\t\tntfs_error(vi->i_sb, \"Attribute list has non \"\n\t\t\t\t\t\t\"zero lowest_vcn.\");\n\t\t\t\tgoto unm_err_out;\n\t\t\t}\n\t\t\t/*\n\t\t\t * Setup the runlist. No need for locking as we have\n\t\t\t * exclusive access to the inode at this time.\n\t\t\t */\n\t\t\tni->attr_list_rl.rl = ntfs_mapping_pairs_decompress(vol,\n\t\t\t\t\ta, NULL);\n\t\t\tif (IS_ERR(ni->attr_list_rl.rl)) {\n\t\t\t\terr = PTR_ERR(ni->attr_list_rl.rl);\n\t\t\t\tni->attr_list_rl.rl = NULL;\n\t\t\t\tntfs_error(vi->i_sb, \"Mapping pairs \"\n\t\t\t\t\t\t\"decompression failed.\");\n\t\t\t\tgoto unm_err_out;\n\t\t\t}\n\t\t\t/* Now load the attribute list. */\n\t\t\tif ((err = load_attribute_list(vol, &ni->attr_list_rl,\n\t\t\t\t\tni->attr_list, ni->attr_list_size,\n\t\t\t\t\tsle64_to_cpu(a->data.non_resident.\n\t\t\t\t\tinitialized_size)))) {\n\t\t\t\tntfs_error(vi->i_sb, \"Failed to load \"\n\t\t\t\t\t\t\"attribute list attribute.\");\n\t\t\t\tgoto unm_err_out;\n\t\t\t}\n\t\t} else /* if (!a->non_resident) */ {\n\t\t\tif ((u8*)a + le16_to_cpu(a->data.resident.value_offset)\n\t\t\t\t\t+ le32_to_cpu(\n\t\t\t\t\ta->data.resident.value_length) >\n\t\t\t\t\t(u8*)ctx->mrec + vol->mft_record_size) {\n\t\t\t\tntfs_error(vi->i_sb, \"Corrupt attribute list \"\n\t\t\t\t\t\t\"in inode.\");\n\t\t\t\tgoto unm_err_out;\n\t\t\t}\n\t\t\t/* Now copy the attribute list. */\n\t\t\tmemcpy(ni->attr_list, (u8*)a + le16_to_cpu(\n\t\t\t\t\ta->data.resident.value_offset),\n\t\t\t\t\tle32_to_cpu(\n\t\t\t\t\ta->data.resident.value_length));\n\t\t}\n\t}\nskip_attr_list_load:\n\t/*\n\t * If an attribute list is present we now have the attribute list value\n\t * in ntfs_ino->attr_list and it is ntfs_ino->attr_list_size bytes.\n\t */\n\tif (S_ISDIR(vi->i_mode)) {\n\t\tloff_t bvi_size;\n\t\tntfs_inode *bni;\n\t\tINDEX_ROOT *ir;\n\t\tu8 *ir_end, *index_end;\n\n\t\t/* It is a directory, find index root attribute. */\n\t\tntfs_attr_reinit_search_ctx(ctx);\n\t\terr = ntfs_attr_lookup(AT_INDEX_ROOT, I30, 4, CASE_SENSITIVE,\n\t\t\t\t0, NULL, 0, ctx);\n\t\tif (unlikely(err)) {\n\t\t\tif (err == -ENOENT) {\n\t\t\t\t// FIXME: File is corrupt! Hot-fix with empty\n\t\t\t\t// index root attribute if recovery option is\n\t\t\t\t// set.\n\t\t\t\tntfs_error(vi->i_sb, \"$INDEX_ROOT attribute \"\n\t\t\t\t\t\t\"is missing.\");\n\t\t\t}\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\ta = ctx->attr;\n\t\t/* Set up the state. */\n\t\tif (unlikely(a->non_resident)) {\n\t\t\tntfs_error(vol->sb, \"$INDEX_ROOT attribute is not \"\n\t\t\t\t\t\"resident.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\t/* Ensure the attribute name is placed before the value. */\n\t\tif (unlikely(a->name_length && (le16_to_cpu(a->name_offset) >=\n\t\t\t\tle16_to_cpu(a->data.resident.value_offset)))) {\n\t\t\tntfs_error(vol->sb, \"$INDEX_ROOT attribute name is \"\n\t\t\t\t\t\"placed after the attribute value.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\t/*\n\t\t * Compressed/encrypted index root just means that the newly\n\t\t * created files in that directory should be created compressed/\n\t\t * encrypted. However index root cannot be both compressed and\n\t\t * encrypted.\n\t\t */\n\t\tif (a->flags & ATTR_COMPRESSION_MASK)\n\t\t\tNInoSetCompressed(ni);\n\t\tif (a->flags & ATTR_IS_ENCRYPTED) {\n\t\t\tif (a->flags & ATTR_COMPRESSION_MASK) {\n\t\t\t\tntfs_error(vi->i_sb, \"Found encrypted and \"\n\t\t\t\t\t\t\"compressed attribute.\");\n\t\t\t\tgoto unm_err_out;\n\t\t\t}\n\t\t\tNInoSetEncrypted(ni);\n\t\t}\n\t\tif (a->flags & ATTR_IS_SPARSE)\n\t\t\tNInoSetSparse(ni);\n\t\tir = (INDEX_ROOT*)((u8*)a +\n\t\t\t\tle16_to_cpu(a->data.resident.value_offset));\n\t\tir_end = (u8*)ir + le32_to_cpu(a->data.resident.value_length);\n\t\tif (ir_end > (u8*)ctx->mrec + vol->mft_record_size) {\n\t\t\tntfs_error(vi->i_sb, \"$INDEX_ROOT attribute is \"\n\t\t\t\t\t\"corrupt.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tindex_end = (u8*)&ir->index +\n\t\t\t\tle32_to_cpu(ir->index.index_length);\n\t\tif (index_end > ir_end) {\n\t\t\tntfs_error(vi->i_sb, \"Directory index is corrupt.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tif (ir->type != AT_FILE_NAME) {\n\t\t\tntfs_error(vi->i_sb, \"Indexed attribute is not \"\n\t\t\t\t\t\"$FILE_NAME.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tif (ir->collation_rule != COLLATION_FILE_NAME) {\n\t\t\tntfs_error(vi->i_sb, \"Index collation rule is not \"\n\t\t\t\t\t\"COLLATION_FILE_NAME.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tni->itype.index.collation_rule = ir->collation_rule;\n\t\tni->itype.index.block_size = le32_to_cpu(ir->index_block_size);\n\t\tif (ni->itype.index.block_size &\n\t\t\t\t(ni->itype.index.block_size - 1)) {\n\t\t\tntfs_error(vi->i_sb, \"Index block size (%u) is not a \"\n\t\t\t\t\t\"power of two.\",\n\t\t\t\t\tni->itype.index.block_size);\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tif (ni->itype.index.block_size > PAGE_CACHE_SIZE) {\n\t\t\tntfs_error(vi->i_sb, \"Index block size (%u) > \"\n\t\t\t\t\t\"PAGE_CACHE_SIZE (%ld) is not \"\n\t\t\t\t\t\"supported.  Sorry.\",\n\t\t\t\t\tni->itype.index.block_size,\n\t\t\t\t\tPAGE_CACHE_SIZE);\n\t\t\terr = -EOPNOTSUPP;\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tif (ni->itype.index.block_size < NTFS_BLOCK_SIZE) {\n\t\t\tntfs_error(vi->i_sb, \"Index block size (%u) < \"\n\t\t\t\t\t\"NTFS_BLOCK_SIZE (%i) is not \"\n\t\t\t\t\t\"supported.  Sorry.\",\n\t\t\t\t\tni->itype.index.block_size,\n\t\t\t\t\tNTFS_BLOCK_SIZE);\n\t\t\terr = -EOPNOTSUPP;\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tni->itype.index.block_size_bits =\n\t\t\t\tffs(ni->itype.index.block_size) - 1;\n\t\t/* Determine the size of a vcn in the directory index. */\n\t\tif (vol->cluster_size <= ni->itype.index.block_size) {\n\t\t\tni->itype.index.vcn_size = vol->cluster_size;\n\t\t\tni->itype.index.vcn_size_bits = vol->cluster_size_bits;\n\t\t} else {\n\t\t\tni->itype.index.vcn_size = vol->sector_size;\n\t\t\tni->itype.index.vcn_size_bits = vol->sector_size_bits;\n\t\t}\n\n\t\t/* Setup the index allocation attribute, even if not present. */\n\t\tNInoSetMstProtected(ni);\n\t\tni->type = AT_INDEX_ALLOCATION;\n\t\tni->name = I30;\n\t\tni->name_len = 4;\n\n\t\tif (!(ir->index.flags & LARGE_INDEX)) {\n\t\t\t/* No index allocation. */\n\t\t\tvi->i_size = ni->initialized_size =\n\t\t\t\t\tni->allocated_size = 0;\n\t\t\t/* We are done with the mft record, so we release it. */\n\t\t\tntfs_attr_put_search_ctx(ctx);\n\t\t\tunmap_mft_record(ni);\n\t\t\tm = NULL;\n\t\t\tctx = NULL;\n\t\t\tgoto skip_large_dir_stuff;\n\t\t} /* LARGE_INDEX: Index allocation present. Setup state. */\n\t\tNInoSetIndexAllocPresent(ni);\n\t\t/* Find index allocation attribute. */\n\t\tntfs_attr_reinit_search_ctx(ctx);\n\t\terr = ntfs_attr_lookup(AT_INDEX_ALLOCATION, I30, 4,\n\t\t\t\tCASE_SENSITIVE, 0, NULL, 0, ctx);\n\t\tif (unlikely(err)) {\n\t\t\tif (err == -ENOENT)\n\t\t\t\tntfs_error(vi->i_sb, \"$INDEX_ALLOCATION \"\n\t\t\t\t\t\t\"attribute is not present but \"\n\t\t\t\t\t\t\"$INDEX_ROOT indicated it is.\");\n\t\t\telse\n\t\t\t\tntfs_error(vi->i_sb, \"Failed to lookup \"\n\t\t\t\t\t\t\"$INDEX_ALLOCATION \"\n\t\t\t\t\t\t\"attribute.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\ta = ctx->attr;\n\t\tif (!a->non_resident) {\n\t\t\tntfs_error(vi->i_sb, \"$INDEX_ALLOCATION attribute \"\n\t\t\t\t\t\"is resident.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\t/*\n\t\t * Ensure the attribute name is placed before the mapping pairs\n\t\t * array.\n\t\t */\n\t\tif (unlikely(a->name_length && (le16_to_cpu(a->name_offset) >=\n\t\t\t\tle16_to_cpu(\n\t\t\t\ta->data.non_resident.mapping_pairs_offset)))) {\n\t\t\tntfs_error(vol->sb, \"$INDEX_ALLOCATION attribute name \"\n\t\t\t\t\t\"is placed after the mapping pairs \"\n\t\t\t\t\t\"array.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tif (a->flags & ATTR_IS_ENCRYPTED) {\n\t\t\tntfs_error(vi->i_sb, \"$INDEX_ALLOCATION attribute \"\n\t\t\t\t\t\"is encrypted.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tif (a->flags & ATTR_IS_SPARSE) {\n\t\t\tntfs_error(vi->i_sb, \"$INDEX_ALLOCATION attribute \"\n\t\t\t\t\t\"is sparse.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tif (a->flags & ATTR_COMPRESSION_MASK) {\n\t\t\tntfs_error(vi->i_sb, \"$INDEX_ALLOCATION attribute \"\n\t\t\t\t\t\"is compressed.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tif (a->data.non_resident.lowest_vcn) {\n\t\t\tntfs_error(vi->i_sb, \"First extent of \"\n\t\t\t\t\t\"$INDEX_ALLOCATION attribute has non \"\n\t\t\t\t\t\"zero lowest_vcn.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tvi->i_size = sle64_to_cpu(a->data.non_resident.data_size);\n\t\tni->initialized_size = sle64_to_cpu(\n\t\t\t\ta->data.non_resident.initialized_size);\n\t\tni->allocated_size = sle64_to_cpu(\n\t\t\t\ta->data.non_resident.allocated_size);\n\t\t/*\n\t\t * We are done with the mft record, so we release it. Otherwise\n\t\t * we would deadlock in ntfs_attr_iget().\n\t\t */\n\t\tntfs_attr_put_search_ctx(ctx);\n\t\tunmap_mft_record(ni);\n\t\tm = NULL;\n\t\tctx = NULL;\n\t\t/* Get the index bitmap attribute inode. */\n\t\tbvi = ntfs_attr_iget(vi, AT_BITMAP, I30, 4);\n\t\tif (IS_ERR(bvi)) {\n\t\t\tntfs_error(vi->i_sb, \"Failed to get bitmap attribute.\");\n\t\t\terr = PTR_ERR(bvi);\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tbni = NTFS_I(bvi);\n\t\tif (NInoCompressed(bni) || NInoEncrypted(bni) ||\n\t\t\t\tNInoSparse(bni)) {\n\t\t\tntfs_error(vi->i_sb, \"$BITMAP attribute is compressed \"\n\t\t\t\t\t\"and/or encrypted and/or sparse.\");\n\t\t\tgoto iput_unm_err_out;\n\t\t}\n\t\t/* Consistency check bitmap size vs. index allocation size. */\n\t\tbvi_size = i_size_read(bvi);\n\t\tif ((bvi_size << 3) < (vi->i_size >>\n\t\t\t\tni->itype.index.block_size_bits)) {\n\t\t\tntfs_error(vi->i_sb, \"Index bitmap too small (0x%llx) \"\n\t\t\t\t\t\"for index allocation (0x%llx).\",\n\t\t\t\t\tbvi_size << 3, vi->i_size);\n\t\t\tgoto iput_unm_err_out;\n\t\t}\n\t\t/* No longer need the bitmap attribute inode. */\n\t\tiput(bvi);\nskip_large_dir_stuff:\n\t\t/* Setup the operations for this inode. */\n\t\tvi->i_op = &ntfs_dir_inode_ops;\n\t\tvi->i_fop = &ntfs_dir_ops;\n\t\tvi->i_mapping->a_ops = &ntfs_mst_aops;\n\t} else {\n\t\t/* It is a file. */\n\t\tntfs_attr_reinit_search_ctx(ctx);\n\n\t\t/* Setup the data attribute, even if not present. */\n\t\tni->type = AT_DATA;\n\t\tni->name = NULL;\n\t\tni->name_len = 0;\n\n\t\t/* Find first extent of the unnamed data attribute. */\n\t\terr = ntfs_attr_lookup(AT_DATA, NULL, 0, 0, 0, NULL, 0, ctx);\n\t\tif (unlikely(err)) {\n\t\t\tvi->i_size = ni->initialized_size =\n\t\t\t\t\tni->allocated_size = 0;\n\t\t\tif (err != -ENOENT) {\n\t\t\t\tntfs_error(vi->i_sb, \"Failed to lookup $DATA \"\n\t\t\t\t\t\t\"attribute.\");\n\t\t\t\tgoto unm_err_out;\n\t\t\t}\n\t\t\t/*\n\t\t\t * FILE_Secure does not have an unnamed $DATA\n\t\t\t * attribute, so we special case it here.\n\t\t\t */\n\t\t\tif (vi->i_ino == FILE_Secure)\n\t\t\t\tgoto no_data_attr_special_case;\n\t\t\t/*\n\t\t\t * Most if not all the system files in the $Extend\n\t\t\t * system directory do not have unnamed data\n\t\t\t * attributes so we need to check if the parent\n\t\t\t * directory of the file is FILE_Extend and if it is\n\t\t\t * ignore this error. To do this we need to get the\n\t\t\t * name of this inode from the mft record as the name\n\t\t\t * contains the back reference to the parent directory.\n\t\t\t */\n\t\t\tif (ntfs_is_extended_system_file(ctx) > 0)\n\t\t\t\tgoto no_data_attr_special_case;\n\t\t\t// FIXME: File is corrupt! Hot-fix with empty data\n\t\t\t// attribute if recovery option is set.\n\t\t\tntfs_error(vi->i_sb, \"$DATA attribute is missing.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\ta = ctx->attr;\n\t\t/* Setup the state. */\n\t\tif (a->flags & (ATTR_COMPRESSION_MASK | ATTR_IS_SPARSE)) {\n\t\t\tif (a->flags & ATTR_COMPRESSION_MASK) {\n\t\t\t\tNInoSetCompressed(ni);\n\t\t\t\tif (vol->cluster_size > 4096) {\n\t\t\t\t\tntfs_error(vi->i_sb, \"Found \"\n\t\t\t\t\t\t\t\"compressed data but \"\n\t\t\t\t\t\t\t\"compression is \"\n\t\t\t\t\t\t\t\"disabled due to \"\n\t\t\t\t\t\t\t\"cluster size (%i) > \"\n\t\t\t\t\t\t\t\"4kiB.\",\n\t\t\t\t\t\t\tvol->cluster_size);\n\t\t\t\t\tgoto unm_err_out;\n\t\t\t\t}\n\t\t\t\tif ((a->flags & ATTR_COMPRESSION_MASK)\n\t\t\t\t\t\t!= ATTR_IS_COMPRESSED) {\n\t\t\t\t\tntfs_error(vi->i_sb, \"Found unknown \"\n\t\t\t\t\t\t\t\"compression method \"\n\t\t\t\t\t\t\t\"or corrupt file.\");\n\t\t\t\t\tgoto unm_err_out;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (a->flags & ATTR_IS_SPARSE)\n\t\t\t\tNInoSetSparse(ni);\n\t\t}\n\t\tif (a->flags & ATTR_IS_ENCRYPTED) {\n\t\t\tif (NInoCompressed(ni)) {\n\t\t\t\tntfs_error(vi->i_sb, \"Found encrypted and \"\n\t\t\t\t\t\t\"compressed data.\");\n\t\t\t\tgoto unm_err_out;\n\t\t\t}\n\t\t\tNInoSetEncrypted(ni);\n\t\t}\n\t\tif (a->non_resident) {\n\t\t\tNInoSetNonResident(ni);\n\t\t\tif (NInoCompressed(ni) || NInoSparse(ni)) {\n\t\t\t\tif (NInoCompressed(ni) && a->data.non_resident.\n\t\t\t\t\t\tcompression_unit != 4) {\n\t\t\t\t\tntfs_error(vi->i_sb, \"Found \"\n\t\t\t\t\t\t\t\"non-standard \"\n\t\t\t\t\t\t\t\"compression unit (%u \"\n\t\t\t\t\t\t\t\"instead of 4).  \"\n\t\t\t\t\t\t\t\"Cannot handle this.\",\n\t\t\t\t\t\t\ta->data.non_resident.\n\t\t\t\t\t\t\tcompression_unit);\n\t\t\t\t\terr = -EOPNOTSUPP;\n\t\t\t\t\tgoto unm_err_out;\n\t\t\t\t}\n\t\t\t\tif (a->data.non_resident.compression_unit) {\n\t\t\t\t\tni->itype.compressed.block_size = 1U <<\n\t\t\t\t\t\t\t(a->data.non_resident.\n\t\t\t\t\t\t\tcompression_unit +\n\t\t\t\t\t\t\tvol->cluster_size_bits);\n\t\t\t\t\tni->itype.compressed.block_size_bits =\n\t\t\t\t\t\t\tffs(ni->itype.\n\t\t\t\t\t\t\tcompressed.\n\t\t\t\t\t\t\tblock_size) - 1;\n\t\t\t\t\tni->itype.compressed.block_clusters =\n\t\t\t\t\t\t\t1U << a->data.\n\t\t\t\t\t\t\tnon_resident.\n\t\t\t\t\t\t\tcompression_unit;\n\t\t\t\t} else {\n\t\t\t\t\tni->itype.compressed.block_size = 0;\n\t\t\t\t\tni->itype.compressed.block_size_bits =\n\t\t\t\t\t\t\t0;\n\t\t\t\t\tni->itype.compressed.block_clusters =\n\t\t\t\t\t\t\t0;\n\t\t\t\t}\n\t\t\t\tni->itype.compressed.size = sle64_to_cpu(\n\t\t\t\t\t\ta->data.non_resident.\n\t\t\t\t\t\tcompressed_size);\n\t\t\t}\n\t\t\tif (a->data.non_resident.lowest_vcn) {\n\t\t\t\tntfs_error(vi->i_sb, \"First extent of $DATA \"\n\t\t\t\t\t\t\"attribute has non zero \"\n\t\t\t\t\t\t\"lowest_vcn.\");\n\t\t\t\tgoto unm_err_out;\n\t\t\t}\n\t\t\tvi->i_size = sle64_to_cpu(\n\t\t\t\t\ta->data.non_resident.data_size);\n\t\t\tni->initialized_size = sle64_to_cpu(\n\t\t\t\t\ta->data.non_resident.initialized_size);\n\t\t\tni->allocated_size = sle64_to_cpu(\n\t\t\t\t\ta->data.non_resident.allocated_size);\n\t\t} else { /* Resident attribute. */\n\t\t\tvi->i_size = ni->initialized_size = le32_to_cpu(\n\t\t\t\t\ta->data.resident.value_length);\n\t\t\tni->allocated_size = le32_to_cpu(a->length) -\n\t\t\t\t\tle16_to_cpu(\n\t\t\t\t\ta->data.resident.value_offset);\n\t\t\tif (vi->i_size > ni->allocated_size) {\n\t\t\t\tntfs_error(vi->i_sb, \"Resident data attribute \"\n\t\t\t\t\t\t\"is corrupt (size exceeds \"\n\t\t\t\t\t\t\"allocation).\");\n\t\t\t\tgoto unm_err_out;\n\t\t\t}\n\t\t}\nno_data_attr_special_case:\n\t\t/* We are done with the mft record, so we release it. */\n\t\tntfs_attr_put_search_ctx(ctx);\n\t\tunmap_mft_record(ni);\n\t\tm = NULL;\n\t\tctx = NULL;\n\t\t/* Setup the operations for this inode. */\n\t\tvi->i_op = &ntfs_file_inode_ops;\n\t\tvi->i_fop = &ntfs_file_ops;\n\t\tvi->i_mapping->a_ops = &ntfs_normal_aops;\n\t\tif (NInoMstProtected(ni))\n\t\t\tvi->i_mapping->a_ops = &ntfs_mst_aops;\n\t\telse if (NInoCompressed(ni))\n\t\t\tvi->i_mapping->a_ops = &ntfs_compressed_aops;\n\t}\n\t/*\n\t * The number of 512-byte blocks used on disk (for stat). This is in so\n\t * far inaccurate as it doesn't account for any named streams or other\n\t * special non-resident attributes, but that is how Windows works, too,\n\t * so we are at least consistent with Windows, if not entirely\n\t * consistent with the Linux Way. Doing it the Linux Way would cause a\n\t * significant slowdown as it would involve iterating over all\n\t * attributes in the mft record and adding the allocated/compressed\n\t * sizes of all non-resident attributes present to give us the Linux\n\t * correct size that should go into i_blocks (after division by 512).\n\t */\n\tif (S_ISREG(vi->i_mode) && (NInoCompressed(ni) || NInoSparse(ni)))\n\t\tvi->i_blocks = ni->itype.compressed.size >> 9;\n\telse\n\t\tvi->i_blocks = ni->allocated_size >> 9;\n\tntfs_debug(\"Done.\");\n\treturn 0;\niput_unm_err_out:\n\tiput(bvi);\nunm_err_out:\n\tif (!err)\n\t\terr = -EIO;\n\tif (ctx)\n\t\tntfs_attr_put_search_ctx(ctx);\n\tif (m)\n\t\tunmap_mft_record(ni);\nerr_out:\n\tntfs_error(vol->sb, \"Failed with error code %i.  Marking corrupt \"\n\t\t\t\"inode 0x%lx as bad.  Run chkdsk.\", err, vi->i_ino);\n\tmake_bad_inode(vi);\n\tif (err != -EOPNOTSUPP && err != -ENOMEM)\n\t\tNVolSetErrors(vol);\n\treturn err;\n}",
          "includes": [
            "#include \"ntfs.h\"",
            "#include \"time.h\"",
            "#include \"mft.h\"",
            "#include \"malloc.h\"",
            "#include \"lcnalloc.h\"",
            "#include \"inode.h\"",
            "#include \"debug.h\"",
            "#include \"dir.h\"",
            "#include \"bitmap.h\"",
            "#include \"attrib.h\"",
            "#include \"aops.h\"",
            "#include <linux/aio.h>",
            "#include <linux/log2.h>",
            "#include <linux/slab.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mutex.h>",
            "#include <linux/mount.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ntfs_read_locked_inode(struct inode *vi);",
            "static int ntfs_read_locked_attr_inode(struct inode *base_vi, struct inode *vi);",
            "static int ntfs_read_locked_index_inode(struct inode *base_vi,\n\t\tstruct inode *vi);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ntfs.h\"\n#include \"time.h\"\n#include \"mft.h\"\n#include \"malloc.h\"\n#include \"lcnalloc.h\"\n#include \"inode.h\"\n#include \"debug.h\"\n#include \"dir.h\"\n#include \"bitmap.h\"\n#include \"attrib.h\"\n#include \"aops.h\"\n#include <linux/aio.h>\n#include <linux/log2.h>\n#include <linux/slab.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/mutex.h>\n#include <linux/mount.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/buffer_head.h>\n\nstatic int ntfs_read_locked_inode(struct inode *vi);\nstatic int ntfs_read_locked_attr_inode(struct inode *base_vi, struct inode *vi);\nstatic int ntfs_read_locked_index_inode(struct inode *base_vi,\n\t\tstruct inode *vi);\n\nstatic int ntfs_read_locked_inode(struct inode *vi)\n{\n\tntfs_volume *vol = NTFS_SB(vi->i_sb);\n\tntfs_inode *ni;\n\tstruct inode *bvi;\n\tMFT_RECORD *m;\n\tATTR_RECORD *a;\n\tSTANDARD_INFORMATION *si;\n\tntfs_attr_search_ctx *ctx;\n\tint err = 0;\n\n\tntfs_debug(\"Entering for i_ino 0x%lx.\", vi->i_ino);\n\n\t/* Setup the generic vfs inode parts now. */\n\n\t/*\n\t * This is for checking whether an inode has changed w.r.t. a file so\n\t * that the file can be updated if necessary (compare with f_version).\n\t */\n\tvi->i_version = 1;\n\n\tvi->i_uid = vol->uid;\n\tvi->i_gid = vol->gid;\n\tvi->i_mode = 0;\n\n\t/*\n\t * Initialize the ntfs specific part of @vi special casing\n\t * FILE_MFT which we need to do at mount time.\n\t */\n\tif (vi->i_ino != FILE_MFT)\n\t\tntfs_init_big_inode(vi);\n\tni = NTFS_I(vi);\n\n\tm = map_mft_record(ni);\n\tif (IS_ERR(m)) {\n\t\terr = PTR_ERR(m);\n\t\tgoto err_out;\n\t}\n\tctx = ntfs_attr_get_search_ctx(ni, m);\n\tif (!ctx) {\n\t\terr = -ENOMEM;\n\t\tgoto unm_err_out;\n\t}\n\n\tif (!(m->flags & MFT_RECORD_IN_USE)) {\n\t\tntfs_error(vi->i_sb, \"Inode is not in use!\");\n\t\tgoto unm_err_out;\n\t}\n\tif (m->base_mft_record) {\n\t\tntfs_error(vi->i_sb, \"Inode is an extent inode!\");\n\t\tgoto unm_err_out;\n\t}\n\n\t/* Transfer information from mft record into vfs and ntfs inodes. */\n\tvi->i_generation = ni->seq_no = le16_to_cpu(m->sequence_number);\n\n\t/*\n\t * FIXME: Keep in mind that link_count is two for files which have both\n\t * a long file name and a short file name as separate entries, so if\n\t * we are hiding short file names this will be too high. Either we need\n\t * to account for the short file names by subtracting them or we need\n\t * to make sure we delete files even though i_nlink is not zero which\n\t * might be tricky due to vfs interactions. Need to think about this\n\t * some more when implementing the unlink command.\n\t */\n\tset_nlink(vi, le16_to_cpu(m->link_count));\n\t/*\n\t * FIXME: Reparse points can have the directory bit set even though\n\t * they would be S_IFLNK. Need to deal with this further below when we\n\t * implement reparse points / symbolic links but it will do for now.\n\t * Also if not a directory, it could be something else, rather than\n\t * a regular file. But again, will do for now.\n\t */\n\t/* Everyone gets all permissions. */\n\tvi->i_mode |= S_IRWXUGO;\n\t/* If read-only, no one gets write permissions. */\n\tif (IS_RDONLY(vi))\n\t\tvi->i_mode &= ~S_IWUGO;\n\tif (m->flags & MFT_RECORD_IS_DIRECTORY) {\n\t\tvi->i_mode |= S_IFDIR;\n\t\t/*\n\t\t * Apply the directory permissions mask set in the mount\n\t\t * options.\n\t\t */\n\t\tvi->i_mode &= ~vol->dmask;\n\t\t/* Things break without this kludge! */\n\t\tif (vi->i_nlink > 1)\n\t\t\tset_nlink(vi, 1);\n\t} else {\n\t\tvi->i_mode |= S_IFREG;\n\t\t/* Apply the file permissions mask set in the mount options. */\n\t\tvi->i_mode &= ~vol->fmask;\n\t}\n\t/*\n\t * Find the standard information attribute in the mft record. At this\n\t * stage we haven't setup the attribute list stuff yet, so this could\n\t * in fact fail if the standard information is in an extent record, but\n\t * I don't think this actually ever happens.\n\t */\n\terr = ntfs_attr_lookup(AT_STANDARD_INFORMATION, NULL, 0, 0, 0, NULL, 0,\n\t\t\tctx);\n\tif (unlikely(err)) {\n\t\tif (err == -ENOENT) {\n\t\t\t/*\n\t\t\t * TODO: We should be performing a hot fix here (if the\n\t\t\t * recover mount option is set) by creating a new\n\t\t\t * attribute.\n\t\t\t */\n\t\t\tntfs_error(vi->i_sb, \"$STANDARD_INFORMATION attribute \"\n\t\t\t\t\t\"is missing.\");\n\t\t}\n\t\tgoto unm_err_out;\n\t}\n\ta = ctx->attr;\n\t/* Get the standard information attribute value. */\n\tsi = (STANDARD_INFORMATION*)((u8*)a +\n\t\t\tle16_to_cpu(a->data.resident.value_offset));\n\n\t/* Transfer information from the standard information into vi. */\n\t/*\n\t * Note: The i_?times do not quite map perfectly onto the NTFS times,\n\t * but they are close enough, and in the end it doesn't really matter\n\t * that much...\n\t */\n\t/*\n\t * mtime is the last change of the data within the file. Not changed\n\t * when only metadata is changed, e.g. a rename doesn't affect mtime.\n\t */\n\tvi->i_mtime = ntfs2utc(si->last_data_change_time);\n\t/*\n\t * ctime is the last change of the metadata of the file. This obviously\n\t * always changes, when mtime is changed. ctime can be changed on its\n\t * own, mtime is then not changed, e.g. when a file is renamed.\n\t */\n\tvi->i_ctime = ntfs2utc(si->last_mft_change_time);\n\t/*\n\t * Last access to the data within the file. Not changed during a rename\n\t * for example but changed whenever the file is written to.\n\t */\n\tvi->i_atime = ntfs2utc(si->last_access_time);\n\n\t/* Find the attribute list attribute if present. */\n\tntfs_attr_reinit_search_ctx(ctx);\n\terr = ntfs_attr_lookup(AT_ATTRIBUTE_LIST, NULL, 0, 0, 0, NULL, 0, ctx);\n\tif (err) {\n\t\tif (unlikely(err != -ENOENT)) {\n\t\t\tntfs_error(vi->i_sb, \"Failed to lookup attribute list \"\n\t\t\t\t\t\"attribute.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t} else /* if (!err) */ {\n\t\tif (vi->i_ino == FILE_MFT)\n\t\t\tgoto skip_attr_list_load;\n\t\tntfs_debug(\"Attribute list found in inode 0x%lx.\", vi->i_ino);\n\t\tNInoSetAttrList(ni);\n\t\ta = ctx->attr;\n\t\tif (a->flags & ATTR_COMPRESSION_MASK) {\n\t\t\tntfs_error(vi->i_sb, \"Attribute list attribute is \"\n\t\t\t\t\t\"compressed.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tif (a->flags & ATTR_IS_ENCRYPTED ||\n\t\t\t\ta->flags & ATTR_IS_SPARSE) {\n\t\t\tif (a->non_resident) {\n\t\t\t\tntfs_error(vi->i_sb, \"Non-resident attribute \"\n\t\t\t\t\t\t\"list attribute is encrypted/\"\n\t\t\t\t\t\t\"sparse.\");\n\t\t\t\tgoto unm_err_out;\n\t\t\t}\n\t\t\tntfs_warning(vi->i_sb, \"Resident attribute list \"\n\t\t\t\t\t\"attribute in inode 0x%lx is marked \"\n\t\t\t\t\t\"encrypted/sparse which is not true.  \"\n\t\t\t\t\t\"However, Windows allows this and \"\n\t\t\t\t\t\"chkdsk does not detect or correct it \"\n\t\t\t\t\t\"so we will just ignore the invalid \"\n\t\t\t\t\t\"flags and pretend they are not set.\",\n\t\t\t\t\tvi->i_ino);\n\t\t}\n\t\t/* Now allocate memory for the attribute list. */\n\t\tni->attr_list_size = (u32)ntfs_attr_size(a);\n\t\tni->attr_list = ntfs_malloc_nofs(ni->attr_list_size);\n\t\tif (!ni->attr_list) {\n\t\t\tntfs_error(vi->i_sb, \"Not enough memory to allocate \"\n\t\t\t\t\t\"buffer for attribute list.\");\n\t\t\terr = -ENOMEM;\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tif (a->non_resident) {\n\t\t\tNInoSetAttrListNonResident(ni);\n\t\t\tif (a->data.non_resident.lowest_vcn) {\n\t\t\t\tntfs_error(vi->i_sb, \"Attribute list has non \"\n\t\t\t\t\t\t\"zero lowest_vcn.\");\n\t\t\t\tgoto unm_err_out;\n\t\t\t}\n\t\t\t/*\n\t\t\t * Setup the runlist. No need for locking as we have\n\t\t\t * exclusive access to the inode at this time.\n\t\t\t */\n\t\t\tni->attr_list_rl.rl = ntfs_mapping_pairs_decompress(vol,\n\t\t\t\t\ta, NULL);\n\t\t\tif (IS_ERR(ni->attr_list_rl.rl)) {\n\t\t\t\terr = PTR_ERR(ni->attr_list_rl.rl);\n\t\t\t\tni->attr_list_rl.rl = NULL;\n\t\t\t\tntfs_error(vi->i_sb, \"Mapping pairs \"\n\t\t\t\t\t\t\"decompression failed.\");\n\t\t\t\tgoto unm_err_out;\n\t\t\t}\n\t\t\t/* Now load the attribute list. */\n\t\t\tif ((err = load_attribute_list(vol, &ni->attr_list_rl,\n\t\t\t\t\tni->attr_list, ni->attr_list_size,\n\t\t\t\t\tsle64_to_cpu(a->data.non_resident.\n\t\t\t\t\tinitialized_size)))) {\n\t\t\t\tntfs_error(vi->i_sb, \"Failed to load \"\n\t\t\t\t\t\t\"attribute list attribute.\");\n\t\t\t\tgoto unm_err_out;\n\t\t\t}\n\t\t} else /* if (!a->non_resident) */ {\n\t\t\tif ((u8*)a + le16_to_cpu(a->data.resident.value_offset)\n\t\t\t\t\t+ le32_to_cpu(\n\t\t\t\t\ta->data.resident.value_length) >\n\t\t\t\t\t(u8*)ctx->mrec + vol->mft_record_size) {\n\t\t\t\tntfs_error(vi->i_sb, \"Corrupt attribute list \"\n\t\t\t\t\t\t\"in inode.\");\n\t\t\t\tgoto unm_err_out;\n\t\t\t}\n\t\t\t/* Now copy the attribute list. */\n\t\t\tmemcpy(ni->attr_list, (u8*)a + le16_to_cpu(\n\t\t\t\t\ta->data.resident.value_offset),\n\t\t\t\t\tle32_to_cpu(\n\t\t\t\t\ta->data.resident.value_length));\n\t\t}\n\t}\nskip_attr_list_load:\n\t/*\n\t * If an attribute list is present we now have the attribute list value\n\t * in ntfs_ino->attr_list and it is ntfs_ino->attr_list_size bytes.\n\t */\n\tif (S_ISDIR(vi->i_mode)) {\n\t\tloff_t bvi_size;\n\t\tntfs_inode *bni;\n\t\tINDEX_ROOT *ir;\n\t\tu8 *ir_end, *index_end;\n\n\t\t/* It is a directory, find index root attribute. */\n\t\tntfs_attr_reinit_search_ctx(ctx);\n\t\terr = ntfs_attr_lookup(AT_INDEX_ROOT, I30, 4, CASE_SENSITIVE,\n\t\t\t\t0, NULL, 0, ctx);\n\t\tif (unlikely(err)) {\n\t\t\tif (err == -ENOENT) {\n\t\t\t\t// FIXME: File is corrupt! Hot-fix with empty\n\t\t\t\t// index root attribute if recovery option is\n\t\t\t\t// set.\n\t\t\t\tntfs_error(vi->i_sb, \"$INDEX_ROOT attribute \"\n\t\t\t\t\t\t\"is missing.\");\n\t\t\t}\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\ta = ctx->attr;\n\t\t/* Set up the state. */\n\t\tif (unlikely(a->non_resident)) {\n\t\t\tntfs_error(vol->sb, \"$INDEX_ROOT attribute is not \"\n\t\t\t\t\t\"resident.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\t/* Ensure the attribute name is placed before the value. */\n\t\tif (unlikely(a->name_length && (le16_to_cpu(a->name_offset) >=\n\t\t\t\tle16_to_cpu(a->data.resident.value_offset)))) {\n\t\t\tntfs_error(vol->sb, \"$INDEX_ROOT attribute name is \"\n\t\t\t\t\t\"placed after the attribute value.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\t/*\n\t\t * Compressed/encrypted index root just means that the newly\n\t\t * created files in that directory should be created compressed/\n\t\t * encrypted. However index root cannot be both compressed and\n\t\t * encrypted.\n\t\t */\n\t\tif (a->flags & ATTR_COMPRESSION_MASK)\n\t\t\tNInoSetCompressed(ni);\n\t\tif (a->flags & ATTR_IS_ENCRYPTED) {\n\t\t\tif (a->flags & ATTR_COMPRESSION_MASK) {\n\t\t\t\tntfs_error(vi->i_sb, \"Found encrypted and \"\n\t\t\t\t\t\t\"compressed attribute.\");\n\t\t\t\tgoto unm_err_out;\n\t\t\t}\n\t\t\tNInoSetEncrypted(ni);\n\t\t}\n\t\tif (a->flags & ATTR_IS_SPARSE)\n\t\t\tNInoSetSparse(ni);\n\t\tir = (INDEX_ROOT*)((u8*)a +\n\t\t\t\tle16_to_cpu(a->data.resident.value_offset));\n\t\tir_end = (u8*)ir + le32_to_cpu(a->data.resident.value_length);\n\t\tif (ir_end > (u8*)ctx->mrec + vol->mft_record_size) {\n\t\t\tntfs_error(vi->i_sb, \"$INDEX_ROOT attribute is \"\n\t\t\t\t\t\"corrupt.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tindex_end = (u8*)&ir->index +\n\t\t\t\tle32_to_cpu(ir->index.index_length);\n\t\tif (index_end > ir_end) {\n\t\t\tntfs_error(vi->i_sb, \"Directory index is corrupt.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tif (ir->type != AT_FILE_NAME) {\n\t\t\tntfs_error(vi->i_sb, \"Indexed attribute is not \"\n\t\t\t\t\t\"$FILE_NAME.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tif (ir->collation_rule != COLLATION_FILE_NAME) {\n\t\t\tntfs_error(vi->i_sb, \"Index collation rule is not \"\n\t\t\t\t\t\"COLLATION_FILE_NAME.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tni->itype.index.collation_rule = ir->collation_rule;\n\t\tni->itype.index.block_size = le32_to_cpu(ir->index_block_size);\n\t\tif (ni->itype.index.block_size &\n\t\t\t\t(ni->itype.index.block_size - 1)) {\n\t\t\tntfs_error(vi->i_sb, \"Index block size (%u) is not a \"\n\t\t\t\t\t\"power of two.\",\n\t\t\t\t\tni->itype.index.block_size);\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tif (ni->itype.index.block_size > PAGE_CACHE_SIZE) {\n\t\t\tntfs_error(vi->i_sb, \"Index block size (%u) > \"\n\t\t\t\t\t\"PAGE_CACHE_SIZE (%ld) is not \"\n\t\t\t\t\t\"supported.  Sorry.\",\n\t\t\t\t\tni->itype.index.block_size,\n\t\t\t\t\tPAGE_CACHE_SIZE);\n\t\t\terr = -EOPNOTSUPP;\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tif (ni->itype.index.block_size < NTFS_BLOCK_SIZE) {\n\t\t\tntfs_error(vi->i_sb, \"Index block size (%u) < \"\n\t\t\t\t\t\"NTFS_BLOCK_SIZE (%i) is not \"\n\t\t\t\t\t\"supported.  Sorry.\",\n\t\t\t\t\tni->itype.index.block_size,\n\t\t\t\t\tNTFS_BLOCK_SIZE);\n\t\t\terr = -EOPNOTSUPP;\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tni->itype.index.block_size_bits =\n\t\t\t\tffs(ni->itype.index.block_size) - 1;\n\t\t/* Determine the size of a vcn in the directory index. */\n\t\tif (vol->cluster_size <= ni->itype.index.block_size) {\n\t\t\tni->itype.index.vcn_size = vol->cluster_size;\n\t\t\tni->itype.index.vcn_size_bits = vol->cluster_size_bits;\n\t\t} else {\n\t\t\tni->itype.index.vcn_size = vol->sector_size;\n\t\t\tni->itype.index.vcn_size_bits = vol->sector_size_bits;\n\t\t}\n\n\t\t/* Setup the index allocation attribute, even if not present. */\n\t\tNInoSetMstProtected(ni);\n\t\tni->type = AT_INDEX_ALLOCATION;\n\t\tni->name = I30;\n\t\tni->name_len = 4;\n\n\t\tif (!(ir->index.flags & LARGE_INDEX)) {\n\t\t\t/* No index allocation. */\n\t\t\tvi->i_size = ni->initialized_size =\n\t\t\t\t\tni->allocated_size = 0;\n\t\t\t/* We are done with the mft record, so we release it. */\n\t\t\tntfs_attr_put_search_ctx(ctx);\n\t\t\tunmap_mft_record(ni);\n\t\t\tm = NULL;\n\t\t\tctx = NULL;\n\t\t\tgoto skip_large_dir_stuff;\n\t\t} /* LARGE_INDEX: Index allocation present. Setup state. */\n\t\tNInoSetIndexAllocPresent(ni);\n\t\t/* Find index allocation attribute. */\n\t\tntfs_attr_reinit_search_ctx(ctx);\n\t\terr = ntfs_attr_lookup(AT_INDEX_ALLOCATION, I30, 4,\n\t\t\t\tCASE_SENSITIVE, 0, NULL, 0, ctx);\n\t\tif (unlikely(err)) {\n\t\t\tif (err == -ENOENT)\n\t\t\t\tntfs_error(vi->i_sb, \"$INDEX_ALLOCATION \"\n\t\t\t\t\t\t\"attribute is not present but \"\n\t\t\t\t\t\t\"$INDEX_ROOT indicated it is.\");\n\t\t\telse\n\t\t\t\tntfs_error(vi->i_sb, \"Failed to lookup \"\n\t\t\t\t\t\t\"$INDEX_ALLOCATION \"\n\t\t\t\t\t\t\"attribute.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\ta = ctx->attr;\n\t\tif (!a->non_resident) {\n\t\t\tntfs_error(vi->i_sb, \"$INDEX_ALLOCATION attribute \"\n\t\t\t\t\t\"is resident.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\t/*\n\t\t * Ensure the attribute name is placed before the mapping pairs\n\t\t * array.\n\t\t */\n\t\tif (unlikely(a->name_length && (le16_to_cpu(a->name_offset) >=\n\t\t\t\tle16_to_cpu(\n\t\t\t\ta->data.non_resident.mapping_pairs_offset)))) {\n\t\t\tntfs_error(vol->sb, \"$INDEX_ALLOCATION attribute name \"\n\t\t\t\t\t\"is placed after the mapping pairs \"\n\t\t\t\t\t\"array.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tif (a->flags & ATTR_IS_ENCRYPTED) {\n\t\t\tntfs_error(vi->i_sb, \"$INDEX_ALLOCATION attribute \"\n\t\t\t\t\t\"is encrypted.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tif (a->flags & ATTR_IS_SPARSE) {\n\t\t\tntfs_error(vi->i_sb, \"$INDEX_ALLOCATION attribute \"\n\t\t\t\t\t\"is sparse.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tif (a->flags & ATTR_COMPRESSION_MASK) {\n\t\t\tntfs_error(vi->i_sb, \"$INDEX_ALLOCATION attribute \"\n\t\t\t\t\t\"is compressed.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tif (a->data.non_resident.lowest_vcn) {\n\t\t\tntfs_error(vi->i_sb, \"First extent of \"\n\t\t\t\t\t\"$INDEX_ALLOCATION attribute has non \"\n\t\t\t\t\t\"zero lowest_vcn.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tvi->i_size = sle64_to_cpu(a->data.non_resident.data_size);\n\t\tni->initialized_size = sle64_to_cpu(\n\t\t\t\ta->data.non_resident.initialized_size);\n\t\tni->allocated_size = sle64_to_cpu(\n\t\t\t\ta->data.non_resident.allocated_size);\n\t\t/*\n\t\t * We are done with the mft record, so we release it. Otherwise\n\t\t * we would deadlock in ntfs_attr_iget().\n\t\t */\n\t\tntfs_attr_put_search_ctx(ctx);\n\t\tunmap_mft_record(ni);\n\t\tm = NULL;\n\t\tctx = NULL;\n\t\t/* Get the index bitmap attribute inode. */\n\t\tbvi = ntfs_attr_iget(vi, AT_BITMAP, I30, 4);\n\t\tif (IS_ERR(bvi)) {\n\t\t\tntfs_error(vi->i_sb, \"Failed to get bitmap attribute.\");\n\t\t\terr = PTR_ERR(bvi);\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tbni = NTFS_I(bvi);\n\t\tif (NInoCompressed(bni) || NInoEncrypted(bni) ||\n\t\t\t\tNInoSparse(bni)) {\n\t\t\tntfs_error(vi->i_sb, \"$BITMAP attribute is compressed \"\n\t\t\t\t\t\"and/or encrypted and/or sparse.\");\n\t\t\tgoto iput_unm_err_out;\n\t\t}\n\t\t/* Consistency check bitmap size vs. index allocation size. */\n\t\tbvi_size = i_size_read(bvi);\n\t\tif ((bvi_size << 3) < (vi->i_size >>\n\t\t\t\tni->itype.index.block_size_bits)) {\n\t\t\tntfs_error(vi->i_sb, \"Index bitmap too small (0x%llx) \"\n\t\t\t\t\t\"for index allocation (0x%llx).\",\n\t\t\t\t\tbvi_size << 3, vi->i_size);\n\t\t\tgoto iput_unm_err_out;\n\t\t}\n\t\t/* No longer need the bitmap attribute inode. */\n\t\tiput(bvi);\nskip_large_dir_stuff:\n\t\t/* Setup the operations for this inode. */\n\t\tvi->i_op = &ntfs_dir_inode_ops;\n\t\tvi->i_fop = &ntfs_dir_ops;\n\t\tvi->i_mapping->a_ops = &ntfs_mst_aops;\n\t} else {\n\t\t/* It is a file. */\n\t\tntfs_attr_reinit_search_ctx(ctx);\n\n\t\t/* Setup the data attribute, even if not present. */\n\t\tni->type = AT_DATA;\n\t\tni->name = NULL;\n\t\tni->name_len = 0;\n\n\t\t/* Find first extent of the unnamed data attribute. */\n\t\terr = ntfs_attr_lookup(AT_DATA, NULL, 0, 0, 0, NULL, 0, ctx);\n\t\tif (unlikely(err)) {\n\t\t\tvi->i_size = ni->initialized_size =\n\t\t\t\t\tni->allocated_size = 0;\n\t\t\tif (err != -ENOENT) {\n\t\t\t\tntfs_error(vi->i_sb, \"Failed to lookup $DATA \"\n\t\t\t\t\t\t\"attribute.\");\n\t\t\t\tgoto unm_err_out;\n\t\t\t}\n\t\t\t/*\n\t\t\t * FILE_Secure does not have an unnamed $DATA\n\t\t\t * attribute, so we special case it here.\n\t\t\t */\n\t\t\tif (vi->i_ino == FILE_Secure)\n\t\t\t\tgoto no_data_attr_special_case;\n\t\t\t/*\n\t\t\t * Most if not all the system files in the $Extend\n\t\t\t * system directory do not have unnamed data\n\t\t\t * attributes so we need to check if the parent\n\t\t\t * directory of the file is FILE_Extend and if it is\n\t\t\t * ignore this error. To do this we need to get the\n\t\t\t * name of this inode from the mft record as the name\n\t\t\t * contains the back reference to the parent directory.\n\t\t\t */\n\t\t\tif (ntfs_is_extended_system_file(ctx) > 0)\n\t\t\t\tgoto no_data_attr_special_case;\n\t\t\t// FIXME: File is corrupt! Hot-fix with empty data\n\t\t\t// attribute if recovery option is set.\n\t\t\tntfs_error(vi->i_sb, \"$DATA attribute is missing.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\ta = ctx->attr;\n\t\t/* Setup the state. */\n\t\tif (a->flags & (ATTR_COMPRESSION_MASK | ATTR_IS_SPARSE)) {\n\t\t\tif (a->flags & ATTR_COMPRESSION_MASK) {\n\t\t\t\tNInoSetCompressed(ni);\n\t\t\t\tif (vol->cluster_size > 4096) {\n\t\t\t\t\tntfs_error(vi->i_sb, \"Found \"\n\t\t\t\t\t\t\t\"compressed data but \"\n\t\t\t\t\t\t\t\"compression is \"\n\t\t\t\t\t\t\t\"disabled due to \"\n\t\t\t\t\t\t\t\"cluster size (%i) > \"\n\t\t\t\t\t\t\t\"4kiB.\",\n\t\t\t\t\t\t\tvol->cluster_size);\n\t\t\t\t\tgoto unm_err_out;\n\t\t\t\t}\n\t\t\t\tif ((a->flags & ATTR_COMPRESSION_MASK)\n\t\t\t\t\t\t!= ATTR_IS_COMPRESSED) {\n\t\t\t\t\tntfs_error(vi->i_sb, \"Found unknown \"\n\t\t\t\t\t\t\t\"compression method \"\n\t\t\t\t\t\t\t\"or corrupt file.\");\n\t\t\t\t\tgoto unm_err_out;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (a->flags & ATTR_IS_SPARSE)\n\t\t\t\tNInoSetSparse(ni);\n\t\t}\n\t\tif (a->flags & ATTR_IS_ENCRYPTED) {\n\t\t\tif (NInoCompressed(ni)) {\n\t\t\t\tntfs_error(vi->i_sb, \"Found encrypted and \"\n\t\t\t\t\t\t\"compressed data.\");\n\t\t\t\tgoto unm_err_out;\n\t\t\t}\n\t\t\tNInoSetEncrypted(ni);\n\t\t}\n\t\tif (a->non_resident) {\n\t\t\tNInoSetNonResident(ni);\n\t\t\tif (NInoCompressed(ni) || NInoSparse(ni)) {\n\t\t\t\tif (NInoCompressed(ni) && a->data.non_resident.\n\t\t\t\t\t\tcompression_unit != 4) {\n\t\t\t\t\tntfs_error(vi->i_sb, \"Found \"\n\t\t\t\t\t\t\t\"non-standard \"\n\t\t\t\t\t\t\t\"compression unit (%u \"\n\t\t\t\t\t\t\t\"instead of 4).  \"\n\t\t\t\t\t\t\t\"Cannot handle this.\",\n\t\t\t\t\t\t\ta->data.non_resident.\n\t\t\t\t\t\t\tcompression_unit);\n\t\t\t\t\terr = -EOPNOTSUPP;\n\t\t\t\t\tgoto unm_err_out;\n\t\t\t\t}\n\t\t\t\tif (a->data.non_resident.compression_unit) {\n\t\t\t\t\tni->itype.compressed.block_size = 1U <<\n\t\t\t\t\t\t\t(a->data.non_resident.\n\t\t\t\t\t\t\tcompression_unit +\n\t\t\t\t\t\t\tvol->cluster_size_bits);\n\t\t\t\t\tni->itype.compressed.block_size_bits =\n\t\t\t\t\t\t\tffs(ni->itype.\n\t\t\t\t\t\t\tcompressed.\n\t\t\t\t\t\t\tblock_size) - 1;\n\t\t\t\t\tni->itype.compressed.block_clusters =\n\t\t\t\t\t\t\t1U << a->data.\n\t\t\t\t\t\t\tnon_resident.\n\t\t\t\t\t\t\tcompression_unit;\n\t\t\t\t} else {\n\t\t\t\t\tni->itype.compressed.block_size = 0;\n\t\t\t\t\tni->itype.compressed.block_size_bits =\n\t\t\t\t\t\t\t0;\n\t\t\t\t\tni->itype.compressed.block_clusters =\n\t\t\t\t\t\t\t0;\n\t\t\t\t}\n\t\t\t\tni->itype.compressed.size = sle64_to_cpu(\n\t\t\t\t\t\ta->data.non_resident.\n\t\t\t\t\t\tcompressed_size);\n\t\t\t}\n\t\t\tif (a->data.non_resident.lowest_vcn) {\n\t\t\t\tntfs_error(vi->i_sb, \"First extent of $DATA \"\n\t\t\t\t\t\t\"attribute has non zero \"\n\t\t\t\t\t\t\"lowest_vcn.\");\n\t\t\t\tgoto unm_err_out;\n\t\t\t}\n\t\t\tvi->i_size = sle64_to_cpu(\n\t\t\t\t\ta->data.non_resident.data_size);\n\t\t\tni->initialized_size = sle64_to_cpu(\n\t\t\t\t\ta->data.non_resident.initialized_size);\n\t\t\tni->allocated_size = sle64_to_cpu(\n\t\t\t\t\ta->data.non_resident.allocated_size);\n\t\t} else { /* Resident attribute. */\n\t\t\tvi->i_size = ni->initialized_size = le32_to_cpu(\n\t\t\t\t\ta->data.resident.value_length);\n\t\t\tni->allocated_size = le32_to_cpu(a->length) -\n\t\t\t\t\tle16_to_cpu(\n\t\t\t\t\ta->data.resident.value_offset);\n\t\t\tif (vi->i_size > ni->allocated_size) {\n\t\t\t\tntfs_error(vi->i_sb, \"Resident data attribute \"\n\t\t\t\t\t\t\"is corrupt (size exceeds \"\n\t\t\t\t\t\t\"allocation).\");\n\t\t\t\tgoto unm_err_out;\n\t\t\t}\n\t\t}\nno_data_attr_special_case:\n\t\t/* We are done with the mft record, so we release it. */\n\t\tntfs_attr_put_search_ctx(ctx);\n\t\tunmap_mft_record(ni);\n\t\tm = NULL;\n\t\tctx = NULL;\n\t\t/* Setup the operations for this inode. */\n\t\tvi->i_op = &ntfs_file_inode_ops;\n\t\tvi->i_fop = &ntfs_file_ops;\n\t\tvi->i_mapping->a_ops = &ntfs_normal_aops;\n\t\tif (NInoMstProtected(ni))\n\t\t\tvi->i_mapping->a_ops = &ntfs_mst_aops;\n\t\telse if (NInoCompressed(ni))\n\t\t\tvi->i_mapping->a_ops = &ntfs_compressed_aops;\n\t}\n\t/*\n\t * The number of 512-byte blocks used on disk (for stat). This is in so\n\t * far inaccurate as it doesn't account for any named streams or other\n\t * special non-resident attributes, but that is how Windows works, too,\n\t * so we are at least consistent with Windows, if not entirely\n\t * consistent with the Linux Way. Doing it the Linux Way would cause a\n\t * significant slowdown as it would involve iterating over all\n\t * attributes in the mft record and adding the allocated/compressed\n\t * sizes of all non-resident attributes present to give us the Linux\n\t * correct size that should go into i_blocks (after division by 512).\n\t */\n\tif (S_ISREG(vi->i_mode) && (NInoCompressed(ni) || NInoSparse(ni)))\n\t\tvi->i_blocks = ni->itype.compressed.size >> 9;\n\telse\n\t\tvi->i_blocks = ni->allocated_size >> 9;\n\tntfs_debug(\"Done.\");\n\treturn 0;\niput_unm_err_out:\n\tiput(bvi);\nunm_err_out:\n\tif (!err)\n\t\terr = -EIO;\n\tif (ctx)\n\t\tntfs_attr_put_search_ctx(ctx);\n\tif (m)\n\t\tunmap_mft_record(ni);\nerr_out:\n\tntfs_error(vol->sb, \"Failed with error code %i.  Marking corrupt \"\n\t\t\t\"inode 0x%lx as bad.  Run chkdsk.\", err, vi->i_ino);\n\tmake_bad_inode(vi);\n\tif (err != -EOPNOTSUPP && err != -ENOMEM)\n\t\tNVolSetErrors(vol);\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sb_bread",
          "args": [
            "sb",
            "le32_to_cpu(p->key)"
          ],
          "line": 246
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "p->key"
          ],
          "line": 246
        },
        "resolved": true,
        "details": {
          "function_name": "sle32_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "53-56",
          "snippet": "static inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"xattr.h\"\n#include \"acl.h\"\n#include \"ext2.h\"\n#include <linux/aio.h>\n#include <linux/namei.h>\n#include <linux/fiemap.h>\n#include <linux/mpage.h>\n#include <linux/buffer_head.h>\n#include <linux/writeback.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/highuid.h>\n#include <linux/time.h>\n\nstatic Indirect *ext2_get_branch(struct inode *inode,\n\t\t\t\t int depth,\n\t\t\t\t int *offsets,\n\t\t\t\t Indirect chain[4],\n\t\t\t\t int *err)\n{\n\tstruct super_block *sb = inode->i_sb;\n\tIndirect *p = chain;\n\tstruct buffer_head *bh;\n\n\t*err = 0;\n\t/* i_data is not going away, no lock needed */\n\tadd_chain (chain, NULL, EXT2_I(inode)->i_data + *offsets);\n\tif (!p->key)\n\t\tgoto no_block;\n\twhile (--depth) {\n\t\tbh = sb_bread(sb, le32_to_cpu(p->key));\n\t\tif (!bh)\n\t\t\tgoto failure;\n\t\tread_lock(&EXT2_I(inode)->i_meta_lock);\n\t\tif (!verify_chain(chain, p))\n\t\t\tgoto changed;\n\t\tadd_chain(++p, bh, (__le32*)bh->b_data + *++offsets);\n\t\tread_unlock(&EXT2_I(inode)->i_meta_lock);\n\t\tif (!p->key)\n\t\t\tgoto no_block;\n\t}\n\treturn NULL;\n\nchanged:\n\tread_unlock(&EXT2_I(inode)->i_meta_lock);\n\tbrelse(bh);\n\t*err = -EAGAIN;\n\tgoto no_block;\nfailure:\n\t*err = -EIO;\nno_block:\n\treturn p;\n}"
  },
  {
    "function_name": "ext2_block_to_path",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext2/inode.c",
    "lines": "159-199",
    "snippet": "static int ext2_block_to_path(struct inode *inode,\n\t\t\tlong i_block, int offsets[4], int *boundary)\n{\n\tint ptrs = EXT2_ADDR_PER_BLOCK(inode->i_sb);\n\tint ptrs_bits = EXT2_ADDR_PER_BLOCK_BITS(inode->i_sb);\n\tconst long direct_blocks = EXT2_NDIR_BLOCKS,\n\t\tindirect_blocks = ptrs,\n\t\tdouble_blocks = (1 << (ptrs_bits * 2));\n\tint n = 0;\n\tint final = 0;\n\n\tif (i_block < 0) {\n\t\text2_msg(inode->i_sb, KERN_WARNING,\n\t\t\t\"warning: %s: block < 0\", __func__);\n\t} else if (i_block < direct_blocks) {\n\t\toffsets[n++] = i_block;\n\t\tfinal = direct_blocks;\n\t} else if ( (i_block -= direct_blocks) < indirect_blocks) {\n\t\toffsets[n++] = EXT2_IND_BLOCK;\n\t\toffsets[n++] = i_block;\n\t\tfinal = ptrs;\n\t} else if ((i_block -= indirect_blocks) < double_blocks) {\n\t\toffsets[n++] = EXT2_DIND_BLOCK;\n\t\toffsets[n++] = i_block >> ptrs_bits;\n\t\toffsets[n++] = i_block & (ptrs - 1);\n\t\tfinal = ptrs;\n\t} else if (((i_block -= double_blocks) >> (ptrs_bits * 2)) < ptrs) {\n\t\toffsets[n++] = EXT2_TIND_BLOCK;\n\t\toffsets[n++] = i_block >> (ptrs_bits * 2);\n\t\toffsets[n++] = (i_block >> ptrs_bits) & (ptrs - 1);\n\t\toffsets[n++] = i_block & (ptrs - 1);\n\t\tfinal = ptrs;\n\t} else {\n\t\text2_msg(inode->i_sb, KERN_WARNING,\n\t\t\t\"warning: %s: block is too big\", __func__);\n\t}\n\tif (boundary)\n\t\t*boundary = final - 1 - (i_block & (ptrs - 1));\n\n\treturn n;\n}",
    "includes": [
      "#include \"xattr.h\"",
      "#include \"acl.h\"",
      "#include \"ext2.h\"",
      "#include <linux/aio.h>",
      "#include <linux/namei.h>",
      "#include <linux/fiemap.h>",
      "#include <linux/mpage.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/writeback.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/highuid.h>",
      "#include <linux/time.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ext2_msg",
          "args": [
            "inode->i_sb",
            "KERN_WARNING",
            "\"warning: %s: block is too big\"",
            "__func__"
          ],
          "line": 192
        },
        "resolved": true,
        "details": {
          "function_name": "ext2_msg",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext2/super.c",
          "lines": "82-96",
          "snippet": "void ext2_msg(struct super_block *sb, const char *prefix,\n\t\tconst char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tva_start(args, fmt);\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\tprintk(\"%sEXT2-fs (%s): %pV\\n\", prefix, sb->s_id, &vaf);\n\n\tva_end(args);\n}",
          "includes": [
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext2.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/log2.h>",
            "#include <linux/mount.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/vfs.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/random.h>",
            "#include <linux/parser.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/string.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ext2_freeze(struct super_block *sb);",
            "static int ext2_unfreeze(struct super_block *sb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext2.h\"\n#include <asm/uaccess.h>\n#include <linux/quotaops.h>\n#include <linux/log2.h>\n#include <linux/mount.h>\n#include <linux/seq_file.h>\n#include <linux/vfs.h>\n#include <linux/exportfs.h>\n#include <linux/buffer_head.h>\n#include <linux/random.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/string.h>\n#include <linux/module.h>\n\nstatic int ext2_freeze(struct super_block *sb);\nstatic int ext2_unfreeze(struct super_block *sb);\n\nvoid ext2_msg(struct super_block *sb, const char *prefix,\n\t\tconst char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tva_start(args, fmt);\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\tprintk(\"%sEXT2-fs (%s): %pV\\n\", prefix, sb->s_id, &vaf);\n\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "EXT2_ADDR_PER_BLOCK_BITS",
          "args": [
            "inode->i_sb"
          ],
          "line": 163
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXT2_ADDR_PER_BLOCK",
          "args": [
            "inode->i_sb"
          ],
          "line": 162
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xattr.h\"\n#include \"acl.h\"\n#include \"ext2.h\"\n#include <linux/aio.h>\n#include <linux/namei.h>\n#include <linux/fiemap.h>\n#include <linux/mpage.h>\n#include <linux/buffer_head.h>\n#include <linux/writeback.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/highuid.h>\n#include <linux/time.h>\n\nstatic int ext2_block_to_path(struct inode *inode,\n\t\t\tlong i_block, int offsets[4], int *boundary)\n{\n\tint ptrs = EXT2_ADDR_PER_BLOCK(inode->i_sb);\n\tint ptrs_bits = EXT2_ADDR_PER_BLOCK_BITS(inode->i_sb);\n\tconst long direct_blocks = EXT2_NDIR_BLOCKS,\n\t\tindirect_blocks = ptrs,\n\t\tdouble_blocks = (1 << (ptrs_bits * 2));\n\tint n = 0;\n\tint final = 0;\n\n\tif (i_block < 0) {\n\t\text2_msg(inode->i_sb, KERN_WARNING,\n\t\t\t\"warning: %s: block < 0\", __func__);\n\t} else if (i_block < direct_blocks) {\n\t\toffsets[n++] = i_block;\n\t\tfinal = direct_blocks;\n\t} else if ( (i_block -= direct_blocks) < indirect_blocks) {\n\t\toffsets[n++] = EXT2_IND_BLOCK;\n\t\toffsets[n++] = i_block;\n\t\tfinal = ptrs;\n\t} else if ((i_block -= indirect_blocks) < double_blocks) {\n\t\toffsets[n++] = EXT2_DIND_BLOCK;\n\t\toffsets[n++] = i_block >> ptrs_bits;\n\t\toffsets[n++] = i_block & (ptrs - 1);\n\t\tfinal = ptrs;\n\t} else if (((i_block -= double_blocks) >> (ptrs_bits * 2)) < ptrs) {\n\t\toffsets[n++] = EXT2_TIND_BLOCK;\n\t\toffsets[n++] = i_block >> (ptrs_bits * 2);\n\t\toffsets[n++] = (i_block >> ptrs_bits) & (ptrs - 1);\n\t\toffsets[n++] = i_block & (ptrs - 1);\n\t\tfinal = ptrs;\n\t} else {\n\t\text2_msg(inode->i_sb, KERN_WARNING,\n\t\t\t\"warning: %s: block is too big\", __func__);\n\t}\n\tif (boundary)\n\t\t*boundary = final - 1 - (i_block & (ptrs - 1));\n\n\treturn n;\n}"
  },
  {
    "function_name": "verify_chain",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext2/inode.c",
    "lines": "122-127",
    "snippet": "static inline int verify_chain(Indirect *from, Indirect *to)\n{\n\twhile (from <= to && from->key == *from->p)\n\t\tfrom++;\n\treturn (from > to);\n}",
    "includes": [
      "#include \"xattr.h\"",
      "#include \"acl.h\"",
      "#include \"ext2.h\"",
      "#include <linux/aio.h>",
      "#include <linux/namei.h>",
      "#include <linux/fiemap.h>",
      "#include <linux/mpage.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/writeback.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/highuid.h>",
      "#include <linux/time.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"xattr.h\"\n#include \"acl.h\"\n#include \"ext2.h\"\n#include <linux/aio.h>\n#include <linux/namei.h>\n#include <linux/fiemap.h>\n#include <linux/mpage.h>\n#include <linux/buffer_head.h>\n#include <linux/writeback.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/highuid.h>\n#include <linux/time.h>\n\nstatic inline int verify_chain(Indirect *from, Indirect *to)\n{\n\twhile (from <= to && from->key == *from->p)\n\t\tfrom++;\n\treturn (from > to);\n}"
  },
  {
    "function_name": "add_chain",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext2/inode.c",
    "lines": "116-120",
    "snippet": "static inline void add_chain(Indirect *p, struct buffer_head *bh, __le32 *v)\n{\n\tp->key = *(p->p = v);\n\tp->bh = bh;\n}",
    "includes": [
      "#include \"xattr.h\"",
      "#include \"acl.h\"",
      "#include \"ext2.h\"",
      "#include <linux/aio.h>",
      "#include <linux/namei.h>",
      "#include <linux/fiemap.h>",
      "#include <linux/mpage.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/writeback.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/highuid.h>",
      "#include <linux/time.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"xattr.h\"\n#include \"acl.h\"\n#include \"ext2.h\"\n#include <linux/aio.h>\n#include <linux/namei.h>\n#include <linux/fiemap.h>\n#include <linux/mpage.h>\n#include <linux/buffer_head.h>\n#include <linux/writeback.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/highuid.h>\n#include <linux/time.h>\n\nstatic inline void add_chain(Indirect *p, struct buffer_head *bh, __le32 *v)\n{\n\tp->key = *(p->p = v);\n\tp->bh = bh;\n}"
  },
  {
    "function_name": "ext2_evict_inode",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext2/inode.c",
    "lines": "68-108",
    "snippet": "void ext2_evict_inode(struct inode * inode)\n{\n\tstruct ext2_block_alloc_info *rsv;\n\tint want_delete = 0;\n\n\tif (!inode->i_nlink && !is_bad_inode(inode)) {\n\t\twant_delete = 1;\n\t\tdquot_initialize(inode);\n\t} else {\n\t\tdquot_drop(inode);\n\t}\n\n\ttruncate_inode_pages_final(&inode->i_data);\n\n\tif (want_delete) {\n\t\tsb_start_intwrite(inode->i_sb);\n\t\t/* set dtime */\n\t\tEXT2_I(inode)->i_dtime\t= get_seconds();\n\t\tmark_inode_dirty(inode);\n\t\t__ext2_write_inode(inode, inode_needs_sync(inode));\n\t\t/* truncate to 0 */\n\t\tinode->i_size = 0;\n\t\tif (inode->i_blocks)\n\t\t\text2_truncate_blocks(inode, 0);\n\t\text2_xattr_delete_inode(inode);\n\t}\n\n\tinvalidate_inode_buffers(inode);\n\tclear_inode(inode);\n\n\text2_discard_reservation(inode);\n\trsv = EXT2_I(inode)->i_block_alloc_info;\n\tEXT2_I(inode)->i_block_alloc_info = NULL;\n\tif (unlikely(rsv))\n\t\tkfree(rsv);\n\n\tif (want_delete) {\n\t\text2_free_inode(inode);\n\t\tsb_end_intwrite(inode->i_sb);\n\t}\n}",
    "includes": [
      "#include \"xattr.h\"",
      "#include \"acl.h\"",
      "#include \"ext2.h\"",
      "#include <linux/aio.h>",
      "#include <linux/namei.h>",
      "#include <linux/fiemap.h>",
      "#include <linux/mpage.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/writeback.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/highuid.h>",
      "#include <linux/time.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "sb_end_intwrite",
          "args": [
            "inode->i_sb"
          ],
          "line": 106
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext2_free_inode",
          "args": [
            "inode"
          ],
          "line": 105
        },
        "resolved": true,
        "details": {
          "function_name": "ext2_free_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext2/ialloc.c",
          "lines": "103-151",
          "snippet": "void ext2_free_inode (struct inode * inode)\n{\n\tstruct super_block * sb = inode->i_sb;\n\tint is_directory;\n\tunsigned long ino;\n\tstruct buffer_head *bitmap_bh;\n\tunsigned long block_group;\n\tunsigned long bit;\n\tstruct ext2_super_block * es;\n\n\tino = inode->i_ino;\n\text2_debug (\"freeing inode %lu\\n\", ino);\n\n\t/*\n\t * Note: we must free any quota before locking the superblock,\n\t * as writing the quota to disk may need the lock as well.\n\t */\n\t/* Quota is already initialized in iput() */\n\tdquot_free_inode(inode);\n\tdquot_drop(inode);\n\n\tes = EXT2_SB(sb)->s_es;\n\tis_directory = S_ISDIR(inode->i_mode);\n\n\tif (ino < EXT2_FIRST_INO(sb) ||\n\t    ino > le32_to_cpu(es->s_inodes_count)) {\n\t\text2_error (sb, \"ext2_free_inode\",\n\t\t\t    \"reserved or nonexistent inode %lu\", ino);\n\t\treturn;\n\t}\n\tblock_group = (ino - 1) / EXT2_INODES_PER_GROUP(sb);\n\tbit = (ino - 1) % EXT2_INODES_PER_GROUP(sb);\n\tbitmap_bh = read_inode_bitmap(sb, block_group);\n\tif (!bitmap_bh)\n\t\treturn;\n\n\t/* Ok, now we can actually update the inode bitmaps.. */\n\tif (!ext2_clear_bit_atomic(sb_bgl_lock(EXT2_SB(sb), block_group),\n\t\t\t\tbit, (void *) bitmap_bh->b_data))\n\t\text2_error (sb, \"ext2_free_inode\",\n\t\t\t      \"bit already cleared for inode %lu\", ino);\n\telse\n\t\text2_release_inode(sb, block_group, is_directory);\n\tmark_buffer_dirty(bitmap_bh);\n\tif (sb->s_flags & MS_SYNCHRONOUS)\n\t\tsync_dirty_buffer(bitmap_bh);\n\n\tbrelse(bitmap_bh);\n}",
          "includes": [
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext2.h\"",
            "#include <linux/random.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/sched.h>",
            "#include <linux/quotaops.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext2.h\"\n#include <linux/random.h>\n#include <linux/buffer_head.h>\n#include <linux/backing-dev.h>\n#include <linux/sched.h>\n#include <linux/quotaops.h>\n\nvoid ext2_free_inode (struct inode * inode)\n{\n\tstruct super_block * sb = inode->i_sb;\n\tint is_directory;\n\tunsigned long ino;\n\tstruct buffer_head *bitmap_bh;\n\tunsigned long block_group;\n\tunsigned long bit;\n\tstruct ext2_super_block * es;\n\n\tino = inode->i_ino;\n\text2_debug (\"freeing inode %lu\\n\", ino);\n\n\t/*\n\t * Note: we must free any quota before locking the superblock,\n\t * as writing the quota to disk may need the lock as well.\n\t */\n\t/* Quota is already initialized in iput() */\n\tdquot_free_inode(inode);\n\tdquot_drop(inode);\n\n\tes = EXT2_SB(sb)->s_es;\n\tis_directory = S_ISDIR(inode->i_mode);\n\n\tif (ino < EXT2_FIRST_INO(sb) ||\n\t    ino > le32_to_cpu(es->s_inodes_count)) {\n\t\text2_error (sb, \"ext2_free_inode\",\n\t\t\t    \"reserved or nonexistent inode %lu\", ino);\n\t\treturn;\n\t}\n\tblock_group = (ino - 1) / EXT2_INODES_PER_GROUP(sb);\n\tbit = (ino - 1) % EXT2_INODES_PER_GROUP(sb);\n\tbitmap_bh = read_inode_bitmap(sb, block_group);\n\tif (!bitmap_bh)\n\t\treturn;\n\n\t/* Ok, now we can actually update the inode bitmaps.. */\n\tif (!ext2_clear_bit_atomic(sb_bgl_lock(EXT2_SB(sb), block_group),\n\t\t\t\tbit, (void *) bitmap_bh->b_data))\n\t\text2_error (sb, \"ext2_free_inode\",\n\t\t\t      \"bit already cleared for inode %lu\", ino);\n\telse\n\t\text2_release_inode(sb, block_group, is_directory);\n\tmark_buffer_dirty(bitmap_bh);\n\tif (sb->s_flags & MS_SYNCHRONOUS)\n\t\tsync_dirty_buffer(bitmap_bh);\n\n\tbrelse(bitmap_bh);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "rsv"
          ],
          "line": 102
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "rsv"
          ],
          "line": 101
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXT2_I",
          "args": [
            "inode"
          ],
          "line": 100
        },
        "resolved": true,
        "details": {
          "function_name": "EXT2_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext2/ext2.h",
          "lines": "717-720",
          "snippet": "static inline struct ext2_inode_info *EXT2_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ext2_inode_info, vfs_inode);\n}",
          "includes": [
            "#include <linux/rbtree.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/ext2_fs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern ext2_fsblk_t ext2_new_block(struct inode *, unsigned long, int *);",
            "extern ext2_fsblk_t ext2_new_blocks(struct inode *, unsigned long,\n\t\t\t\tunsigned long *, int *);",
            "extern void ext2_free_blocks (struct inode *, unsigned long,\n\t\t\t      unsigned long);",
            "extern void ext2_discard_reservation (struct inode *);",
            "extern void ext2_init_block_alloc_info(struct inode *);",
            "extern int ext2_add_link (struct dentry *, struct inode *);",
            "extern int ext2_make_empty(struct inode *, struct inode *);",
            "extern int ext2_empty_dir (struct inode *);",
            "extern void ext2_set_link(struct inode *, struct ext2_dir_entry_2 *, struct page *, struct inode *, int);",
            "extern void ext2_free_inode (struct inode *);",
            "extern void ext2_evict_inode(struct inode *);",
            "extern void ext2_set_inode_flags(struct inode *inode);",
            "extern void ext2_get_inode_flags(struct ext2_inode_info *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rbtree.h>\n#include <linux/percpu_counter.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/ext2_fs.h>\n#include <linux/fs.h>\n\nextern ext2_fsblk_t ext2_new_block(struct inode *, unsigned long, int *);\nextern ext2_fsblk_t ext2_new_blocks(struct inode *, unsigned long,\n\t\t\t\tunsigned long *, int *);\nextern void ext2_free_blocks (struct inode *, unsigned long,\n\t\t\t      unsigned long);\nextern void ext2_discard_reservation (struct inode *);\nextern void ext2_init_block_alloc_info(struct inode *);\nextern int ext2_add_link (struct dentry *, struct inode *);\nextern int ext2_make_empty(struct inode *, struct inode *);\nextern int ext2_empty_dir (struct inode *);\nextern void ext2_set_link(struct inode *, struct ext2_dir_entry_2 *, struct page *, struct inode *, int);\nextern void ext2_free_inode (struct inode *);\nextern void ext2_evict_inode(struct inode *);\nextern void ext2_set_inode_flags(struct inode *inode);\nextern void ext2_get_inode_flags(struct ext2_inode_info *);\n\nstatic inline struct ext2_inode_info *EXT2_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ext2_inode_info, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext2_discard_reservation",
          "args": [
            "inode"
          ],
          "line": 98
        },
        "resolved": true,
        "details": {
          "function_name": "ext2_discard_reservation",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext2/balloc.c",
          "lines": "451-468",
          "snippet": "void ext2_discard_reservation(struct inode *inode)\n{\n\tstruct ext2_inode_info *ei = EXT2_I(inode);\n\tstruct ext2_block_alloc_info *block_i = ei->i_block_alloc_info;\n\tstruct ext2_reserve_window_node *rsv;\n\tspinlock_t *rsv_lock = &EXT2_SB(inode->i_sb)->s_rsv_window_lock;\n\n\tif (!block_i)\n\t\treturn;\n\n\trsv = &block_i->rsv_window_node;\n\tif (!rsv_is_empty(&rsv->rsv_window)) {\n\t\tspin_lock(rsv_lock);\n\t\tif (!rsv_is_empty(&rsv->rsv_window))\n\t\t\trsv_window_remove(inode->i_sb, rsv);\n\t\tspin_unlock(rsv_lock);\n\t}\n}",
          "includes": [
            "#include <linux/capability.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/quotaops.h>",
            "#include \"ext2.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/capability.h>\n#include <linux/buffer_head.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/quotaops.h>\n#include \"ext2.h\"\n\nvoid ext2_discard_reservation(struct inode *inode)\n{\n\tstruct ext2_inode_info *ei = EXT2_I(inode);\n\tstruct ext2_block_alloc_info *block_i = ei->i_block_alloc_info;\n\tstruct ext2_reserve_window_node *rsv;\n\tspinlock_t *rsv_lock = &EXT2_SB(inode->i_sb)->s_rsv_window_lock;\n\n\tif (!block_i)\n\t\treturn;\n\n\trsv = &block_i->rsv_window_node;\n\tif (!rsv_is_empty(&rsv->rsv_window)) {\n\t\tspin_lock(rsv_lock);\n\t\tif (!rsv_is_empty(&rsv->rsv_window))\n\t\t\trsv_window_remove(inode->i_sb, rsv);\n\t\tspin_unlock(rsv_lock);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "clear_inode",
          "args": [
            "inode"
          ],
          "line": 96
        },
        "resolved": true,
        "details": {
          "function_name": "clear_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "488-505",
          "snippet": "void clear_inode(struct inode *inode)\n{\n\tmight_sleep();\n\t/*\n\t * We have to cycle tree_lock here because reclaim can be still in the\n\t * process of removing the last page (in __delete_from_page_cache())\n\t * and we must not free mapping under it.\n\t */\n\tspin_lock_irq(&inode->i_data.tree_lock);\n\tBUG_ON(inode->i_data.nrpages);\n\tBUG_ON(inode->i_data.nrshadows);\n\tspin_unlock_irq(&inode->i_data.tree_lock);\n\tBUG_ON(!list_empty(&inode->i_data.private_list));\n\tBUG_ON(!(inode->i_state & I_FREEING));\n\tBUG_ON(inode->i_state & I_CLEAR);\n\t/* don't need i_lock here, no concurrent mods to i_state */\n\tinode->i_state = I_FREEING | I_CLEAR;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid clear_inode(struct inode *inode)\n{\n\tmight_sleep();\n\t/*\n\t * We have to cycle tree_lock here because reclaim can be still in the\n\t * process of removing the last page (in __delete_from_page_cache())\n\t * and we must not free mapping under it.\n\t */\n\tspin_lock_irq(&inode->i_data.tree_lock);\n\tBUG_ON(inode->i_data.nrpages);\n\tBUG_ON(inode->i_data.nrshadows);\n\tspin_unlock_irq(&inode->i_data.tree_lock);\n\tBUG_ON(!list_empty(&inode->i_data.private_list));\n\tBUG_ON(!(inode->i_state & I_FREEING));\n\tBUG_ON(inode->i_state & I_CLEAR);\n\t/* don't need i_lock here, no concurrent mods to i_state */\n\tinode->i_state = I_FREEING | I_CLEAR;\n}"
        }
      },
      {
        "call_info": {
          "callee": "invalidate_inode_buffers",
          "args": [
            "inode"
          ],
          "line": 95
        },
        "resolved": true,
        "details": {
          "function_name": "invalidate_inode_buffers",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "802-814",
          "snippet": "void invalidate_inode_buffers(struct inode *inode)\n{\n\tif (inode_has_buffers(inode)) {\n\t\tstruct address_space *mapping = &inode->i_data;\n\t\tstruct list_head *list = &mapping->private_list;\n\t\tstruct address_space *buffer_mapping = mapping->private_data;\n\n\t\tspin_lock(&buffer_mapping->private_lock);\n\t\twhile (!list_empty(list))\n\t\t\t__remove_assoc_queue(BH_ENTRY(list->next));\n\t\tspin_unlock(&buffer_mapping->private_lock);\n\t}\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int fsync_buffers_list(spinlock_t *lock, struct list_head *list);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nstatic int fsync_buffers_list(spinlock_t *lock, struct list_head *list);\n\nvoid invalidate_inode_buffers(struct inode *inode)\n{\n\tif (inode_has_buffers(inode)) {\n\t\tstruct address_space *mapping = &inode->i_data;\n\t\tstruct list_head *list = &mapping->private_list;\n\t\tstruct address_space *buffer_mapping = mapping->private_data;\n\n\t\tspin_lock(&buffer_mapping->private_lock);\n\t\twhile (!list_empty(list))\n\t\t\t__remove_assoc_queue(BH_ENTRY(list->next));\n\t\tspin_unlock(&buffer_mapping->private_lock);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext2_xattr_delete_inode",
          "args": [
            "inode"
          ],
          "line": 92
        },
        "resolved": true,
        "details": {
          "function_name": "ext2_xattr_delete_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext2/xattr.h",
          "lines": "91-94",
          "snippet": "static inline void\next2_xattr_delete_inode(struct inode *inode)\n{\n}",
          "includes": [
            "#include <linux/xattr.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/xattr.h>\n#include <linux/init.h>\n\nstatic inline void\next2_xattr_delete_inode(struct inode *inode)\n{\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext2_truncate_blocks",
          "args": [
            "inode",
            "0"
          ],
          "line": 91
        },
        "resolved": true,
        "details": {
          "function_name": "ext2_truncate_blocks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext2/inode.c",
          "lines": "1171-1189",
          "snippet": "static void ext2_truncate_blocks(struct inode *inode, loff_t offset)\n{\n\t/*\n\t * XXX: it seems like a bug here that we don't allow\n\t * IS_APPEND inode to have blocks-past-i_size trimmed off.\n\t * review and fix this.\n\t *\n\t * Also would be nice to be able to handle IO errors and such,\n\t * but that's probably too much to ask.\n\t */\n\tif (!(S_ISREG(inode->i_mode) || S_ISDIR(inode->i_mode) ||\n\t    S_ISLNK(inode->i_mode)))\n\t\treturn;\n\tif (ext2_inode_is_fast_symlink(inode))\n\t\treturn;\n\tif (IS_APPEND(inode) || IS_IMMUTABLE(inode))\n\t\treturn;\n\t__ext2_truncate_blocks(inode, offset);\n}",
          "includes": [
            "#include \"xattr.h\"",
            "#include \"acl.h\"",
            "#include \"ext2.h\"",
            "#include <linux/aio.h>",
            "#include <linux/namei.h>",
            "#include <linux/fiemap.h>",
            "#include <linux/mpage.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/writeback.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highuid.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void ext2_truncate_blocks(struct inode *inode, loff_t offset);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xattr.h\"\n#include \"acl.h\"\n#include \"ext2.h\"\n#include <linux/aio.h>\n#include <linux/namei.h>\n#include <linux/fiemap.h>\n#include <linux/mpage.h>\n#include <linux/buffer_head.h>\n#include <linux/writeback.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/highuid.h>\n#include <linux/time.h>\n\nstatic void ext2_truncate_blocks(struct inode *inode, loff_t offset);\n\nstatic void ext2_truncate_blocks(struct inode *inode, loff_t offset)\n{\n\t/*\n\t * XXX: it seems like a bug here that we don't allow\n\t * IS_APPEND inode to have blocks-past-i_size trimmed off.\n\t * review and fix this.\n\t *\n\t * Also would be nice to be able to handle IO errors and such,\n\t * but that's probably too much to ask.\n\t */\n\tif (!(S_ISREG(inode->i_mode) || S_ISDIR(inode->i_mode) ||\n\t    S_ISLNK(inode->i_mode)))\n\t\treturn;\n\tif (ext2_inode_is_fast_symlink(inode))\n\t\treturn;\n\tif (IS_APPEND(inode) || IS_IMMUTABLE(inode))\n\t\treturn;\n\t__ext2_truncate_blocks(inode, offset);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__ext2_write_inode",
          "args": [
            "inode",
            "inode_needs_sync(inode)"
          ],
          "line": 87
        },
        "resolved": true,
        "details": {
          "function_name": "__ext2_write_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext2/inode.c",
          "lines": "1439-1542",
          "snippet": "static int __ext2_write_inode(struct inode *inode, int do_sync)\n{\n\tstruct ext2_inode_info *ei = EXT2_I(inode);\n\tstruct super_block *sb = inode->i_sb;\n\tino_t ino = inode->i_ino;\n\tuid_t uid = i_uid_read(inode);\n\tgid_t gid = i_gid_read(inode);\n\tstruct buffer_head * bh;\n\tstruct ext2_inode * raw_inode = ext2_get_inode(sb, ino, &bh);\n\tint n;\n\tint err = 0;\n\n\tif (IS_ERR(raw_inode))\n \t\treturn -EIO;\n\n\t/* For fields not not tracking in the in-memory inode,\n\t * initialise them to zero for new inodes. */\n\tif (ei->i_state & EXT2_STATE_NEW)\n\t\tmemset(raw_inode, 0, EXT2_SB(sb)->s_inode_size);\n\n\text2_get_inode_flags(ei);\n\traw_inode->i_mode = cpu_to_le16(inode->i_mode);\n\tif (!(test_opt(sb, NO_UID32))) {\n\t\traw_inode->i_uid_low = cpu_to_le16(low_16_bits(uid));\n\t\traw_inode->i_gid_low = cpu_to_le16(low_16_bits(gid));\n/*\n * Fix up interoperability with old kernels. Otherwise, old inodes get\n * re-used with the upper 16 bits of the uid/gid intact\n */\n\t\tif (!ei->i_dtime) {\n\t\t\traw_inode->i_uid_high = cpu_to_le16(high_16_bits(uid));\n\t\t\traw_inode->i_gid_high = cpu_to_le16(high_16_bits(gid));\n\t\t} else {\n\t\t\traw_inode->i_uid_high = 0;\n\t\t\traw_inode->i_gid_high = 0;\n\t\t}\n\t} else {\n\t\traw_inode->i_uid_low = cpu_to_le16(fs_high2lowuid(uid));\n\t\traw_inode->i_gid_low = cpu_to_le16(fs_high2lowgid(gid));\n\t\traw_inode->i_uid_high = 0;\n\t\traw_inode->i_gid_high = 0;\n\t}\n\traw_inode->i_links_count = cpu_to_le16(inode->i_nlink);\n\traw_inode->i_size = cpu_to_le32(inode->i_size);\n\traw_inode->i_atime = cpu_to_le32(inode->i_atime.tv_sec);\n\traw_inode->i_ctime = cpu_to_le32(inode->i_ctime.tv_sec);\n\traw_inode->i_mtime = cpu_to_le32(inode->i_mtime.tv_sec);\n\n\traw_inode->i_blocks = cpu_to_le32(inode->i_blocks);\n\traw_inode->i_dtime = cpu_to_le32(ei->i_dtime);\n\traw_inode->i_flags = cpu_to_le32(ei->i_flags);\n\traw_inode->i_faddr = cpu_to_le32(ei->i_faddr);\n\traw_inode->i_frag = ei->i_frag_no;\n\traw_inode->i_fsize = ei->i_frag_size;\n\traw_inode->i_file_acl = cpu_to_le32(ei->i_file_acl);\n\tif (!S_ISREG(inode->i_mode))\n\t\traw_inode->i_dir_acl = cpu_to_le32(ei->i_dir_acl);\n\telse {\n\t\traw_inode->i_size_high = cpu_to_le32(inode->i_size >> 32);\n\t\tif (inode->i_size > 0x7fffffffULL) {\n\t\t\tif (!EXT2_HAS_RO_COMPAT_FEATURE(sb,\n\t\t\t\t\tEXT2_FEATURE_RO_COMPAT_LARGE_FILE) ||\n\t\t\t    EXT2_SB(sb)->s_es->s_rev_level ==\n\t\t\t\t\tcpu_to_le32(EXT2_GOOD_OLD_REV)) {\n\t\t\t       /* If this is the first large file\n\t\t\t\t* created, add a flag to the superblock.\n\t\t\t\t*/\n\t\t\t\tspin_lock(&EXT2_SB(sb)->s_lock);\n\t\t\t\text2_update_dynamic_rev(sb);\n\t\t\t\tEXT2_SET_RO_COMPAT_FEATURE(sb,\n\t\t\t\t\tEXT2_FEATURE_RO_COMPAT_LARGE_FILE);\n\t\t\t\tspin_unlock(&EXT2_SB(sb)->s_lock);\n\t\t\t\text2_write_super(sb);\n\t\t\t}\n\t\t}\n\t}\n\t\n\traw_inode->i_generation = cpu_to_le32(inode->i_generation);\n\tif (S_ISCHR(inode->i_mode) || S_ISBLK(inode->i_mode)) {\n\t\tif (old_valid_dev(inode->i_rdev)) {\n\t\t\traw_inode->i_block[0] =\n\t\t\t\tcpu_to_le32(old_encode_dev(inode->i_rdev));\n\t\t\traw_inode->i_block[1] = 0;\n\t\t} else {\n\t\t\traw_inode->i_block[0] = 0;\n\t\t\traw_inode->i_block[1] =\n\t\t\t\tcpu_to_le32(new_encode_dev(inode->i_rdev));\n\t\t\traw_inode->i_block[2] = 0;\n\t\t}\n\t} else for (n = 0; n < EXT2_N_BLOCKS; n++)\n\t\traw_inode->i_block[n] = ei->i_data[n];\n\tmark_buffer_dirty(bh);\n\tif (do_sync) {\n\t\tsync_dirty_buffer(bh);\n\t\tif (buffer_req(bh) && !buffer_uptodate(bh)) {\n\t\t\tprintk (\"IO error syncing ext2 inode [%s:%08lx]\\n\",\n\t\t\t\tsb->s_id, (unsigned long) ino);\n\t\t\terr = -EIO;\n\t\t}\n\t}\n\tei->i_state &= ~EXT2_STATE_NEW;\n\tbrelse (bh);\n\treturn err;\n}",
          "includes": [
            "#include \"xattr.h\"",
            "#include \"acl.h\"",
            "#include \"ext2.h\"",
            "#include <linux/aio.h>",
            "#include <linux/namei.h>",
            "#include <linux/fiemap.h>",
            "#include <linux/mpage.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/writeback.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highuid.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int __ext2_write_inode(struct inode *inode, int do_sync);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xattr.h\"\n#include \"acl.h\"\n#include \"ext2.h\"\n#include <linux/aio.h>\n#include <linux/namei.h>\n#include <linux/fiemap.h>\n#include <linux/mpage.h>\n#include <linux/buffer_head.h>\n#include <linux/writeback.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/highuid.h>\n#include <linux/time.h>\n\nstatic int __ext2_write_inode(struct inode *inode, int do_sync);\n\nstatic int __ext2_write_inode(struct inode *inode, int do_sync)\n{\n\tstruct ext2_inode_info *ei = EXT2_I(inode);\n\tstruct super_block *sb = inode->i_sb;\n\tino_t ino = inode->i_ino;\n\tuid_t uid = i_uid_read(inode);\n\tgid_t gid = i_gid_read(inode);\n\tstruct buffer_head * bh;\n\tstruct ext2_inode * raw_inode = ext2_get_inode(sb, ino, &bh);\n\tint n;\n\tint err = 0;\n\n\tif (IS_ERR(raw_inode))\n \t\treturn -EIO;\n\n\t/* For fields not not tracking in the in-memory inode,\n\t * initialise them to zero for new inodes. */\n\tif (ei->i_state & EXT2_STATE_NEW)\n\t\tmemset(raw_inode, 0, EXT2_SB(sb)->s_inode_size);\n\n\text2_get_inode_flags(ei);\n\traw_inode->i_mode = cpu_to_le16(inode->i_mode);\n\tif (!(test_opt(sb, NO_UID32))) {\n\t\traw_inode->i_uid_low = cpu_to_le16(low_16_bits(uid));\n\t\traw_inode->i_gid_low = cpu_to_le16(low_16_bits(gid));\n/*\n * Fix up interoperability with old kernels. Otherwise, old inodes get\n * re-used with the upper 16 bits of the uid/gid intact\n */\n\t\tif (!ei->i_dtime) {\n\t\t\traw_inode->i_uid_high = cpu_to_le16(high_16_bits(uid));\n\t\t\traw_inode->i_gid_high = cpu_to_le16(high_16_bits(gid));\n\t\t} else {\n\t\t\traw_inode->i_uid_high = 0;\n\t\t\traw_inode->i_gid_high = 0;\n\t\t}\n\t} else {\n\t\traw_inode->i_uid_low = cpu_to_le16(fs_high2lowuid(uid));\n\t\traw_inode->i_gid_low = cpu_to_le16(fs_high2lowgid(gid));\n\t\traw_inode->i_uid_high = 0;\n\t\traw_inode->i_gid_high = 0;\n\t}\n\traw_inode->i_links_count = cpu_to_le16(inode->i_nlink);\n\traw_inode->i_size = cpu_to_le32(inode->i_size);\n\traw_inode->i_atime = cpu_to_le32(inode->i_atime.tv_sec);\n\traw_inode->i_ctime = cpu_to_le32(inode->i_ctime.tv_sec);\n\traw_inode->i_mtime = cpu_to_le32(inode->i_mtime.tv_sec);\n\n\traw_inode->i_blocks = cpu_to_le32(inode->i_blocks);\n\traw_inode->i_dtime = cpu_to_le32(ei->i_dtime);\n\traw_inode->i_flags = cpu_to_le32(ei->i_flags);\n\traw_inode->i_faddr = cpu_to_le32(ei->i_faddr);\n\traw_inode->i_frag = ei->i_frag_no;\n\traw_inode->i_fsize = ei->i_frag_size;\n\traw_inode->i_file_acl = cpu_to_le32(ei->i_file_acl);\n\tif (!S_ISREG(inode->i_mode))\n\t\traw_inode->i_dir_acl = cpu_to_le32(ei->i_dir_acl);\n\telse {\n\t\traw_inode->i_size_high = cpu_to_le32(inode->i_size >> 32);\n\t\tif (inode->i_size > 0x7fffffffULL) {\n\t\t\tif (!EXT2_HAS_RO_COMPAT_FEATURE(sb,\n\t\t\t\t\tEXT2_FEATURE_RO_COMPAT_LARGE_FILE) ||\n\t\t\t    EXT2_SB(sb)->s_es->s_rev_level ==\n\t\t\t\t\tcpu_to_le32(EXT2_GOOD_OLD_REV)) {\n\t\t\t       /* If this is the first large file\n\t\t\t\t* created, add a flag to the superblock.\n\t\t\t\t*/\n\t\t\t\tspin_lock(&EXT2_SB(sb)->s_lock);\n\t\t\t\text2_update_dynamic_rev(sb);\n\t\t\t\tEXT2_SET_RO_COMPAT_FEATURE(sb,\n\t\t\t\t\tEXT2_FEATURE_RO_COMPAT_LARGE_FILE);\n\t\t\t\tspin_unlock(&EXT2_SB(sb)->s_lock);\n\t\t\t\text2_write_super(sb);\n\t\t\t}\n\t\t}\n\t}\n\t\n\traw_inode->i_generation = cpu_to_le32(inode->i_generation);\n\tif (S_ISCHR(inode->i_mode) || S_ISBLK(inode->i_mode)) {\n\t\tif (old_valid_dev(inode->i_rdev)) {\n\t\t\traw_inode->i_block[0] =\n\t\t\t\tcpu_to_le32(old_encode_dev(inode->i_rdev));\n\t\t\traw_inode->i_block[1] = 0;\n\t\t} else {\n\t\t\traw_inode->i_block[0] = 0;\n\t\t\traw_inode->i_block[1] =\n\t\t\t\tcpu_to_le32(new_encode_dev(inode->i_rdev));\n\t\t\traw_inode->i_block[2] = 0;\n\t\t}\n\t} else for (n = 0; n < EXT2_N_BLOCKS; n++)\n\t\traw_inode->i_block[n] = ei->i_data[n];\n\tmark_buffer_dirty(bh);\n\tif (do_sync) {\n\t\tsync_dirty_buffer(bh);\n\t\tif (buffer_req(bh) && !buffer_uptodate(bh)) {\n\t\t\tprintk (\"IO error syncing ext2 inode [%s:%08lx]\\n\",\n\t\t\t\tsb->s_id, (unsigned long) ino);\n\t\t\terr = -EIO;\n\t\t}\n\t}\n\tei->i_state &= ~EXT2_STATE_NEW;\n\tbrelse (bh);\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "inode_needs_sync",
          "args": [
            "inode"
          ],
          "line": 87
        },
        "resolved": true,
        "details": {
          "function_name": "inode_needs_sync",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "1751-1758",
          "snippet": "int inode_needs_sync(struct inode *inode)\n{\n\tif (IS_SYNC(inode))\n\t\treturn 1;\n\tif (S_ISDIR(inode->i_mode) && IS_DIRSYNC(inode))\n\t\treturn 1;\n\treturn 0;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nint inode_needs_sync(struct inode *inode)\n{\n\tif (IS_SYNC(inode))\n\t\treturn 1;\n\tif (S_ISDIR(inode->i_mode) && IS_DIRSYNC(inode))\n\t\treturn 1;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mark_inode_dirty",
          "args": [
            "inode"
          ],
          "line": 86
        },
        "resolved": true,
        "details": {
          "function_name": "block_dump___mark_inode_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fs-writeback.c",
          "lines": "1134-1154",
          "snippet": "static noinline void block_dump___mark_inode_dirty(struct inode *inode)\n{\n\tif (inode->i_ino || strcmp(inode->i_sb->s_id, \"bdev\")) {\n\t\tstruct dentry *dentry;\n\t\tconst char *name = \"?\";\n\n\t\tdentry = d_find_alias(inode);\n\t\tif (dentry) {\n\t\t\tspin_lock(&dentry->d_lock);\n\t\t\tname = (const char *) dentry->d_name.name;\n\t\t}\n\t\tprintk(KERN_DEBUG\n\t\t       \"%s(%d): dirtied inode %lu (%s) on %s\\n\",\n\t\t       current->comm, task_pid_nr(current), inode->i_ino,\n\t\t       name, inode->i_sb->s_id);\n\t\tif (dentry) {\n\t\t\tspin_unlock(&dentry->d_lock);\n\t\t\tdput(dentry);\n\t\t}\n\t}\n}",
          "includes": [
            "#include <trace/events/writeback.h>",
            "#include \"internal.h\"",
            "#include <linux/device.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/writeback.h>\n#include \"internal.h\"\n#include <linux/device.h>\n#include <linux/tracepoint.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nstatic noinline void block_dump___mark_inode_dirty(struct inode *inode)\n{\n\tif (inode->i_ino || strcmp(inode->i_sb->s_id, \"bdev\")) {\n\t\tstruct dentry *dentry;\n\t\tconst char *name = \"?\";\n\n\t\tdentry = d_find_alias(inode);\n\t\tif (dentry) {\n\t\t\tspin_lock(&dentry->d_lock);\n\t\t\tname = (const char *) dentry->d_name.name;\n\t\t}\n\t\tprintk(KERN_DEBUG\n\t\t       \"%s(%d): dirtied inode %lu (%s) on %s\\n\",\n\t\t       current->comm, task_pid_nr(current), inode->i_ino,\n\t\t       name, inode->i_sb->s_id);\n\t\tif (dentry) {\n\t\t\tspin_unlock(&dentry->d_lock);\n\t\t\tdput(dentry);\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_seconds",
          "args": [],
          "line": 85
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sb_start_intwrite",
          "args": [
            "inode->i_sb"
          ],
          "line": 83
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "truncate_inode_pages_final",
          "args": [
            "&inode->i_data"
          ],
          "line": 80
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dquot_drop",
          "args": [
            "inode"
          ],
          "line": 77
        },
        "resolved": true,
        "details": {
          "function_name": "dquot_drop",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/quota/dquot.c",
          "lines": "1487-1508",
          "snippet": "void dquot_drop(struct inode *inode)\n{\n\tint cnt;\n\n\tif (IS_NOQUOTA(inode))\n\t\treturn;\n\n\t/*\n\t * Test before calling to rule out calls from proc and such\n\t * where we are not allowed to block. Note that this is\n\t * actually reliable test even without the lock - the caller\n\t * must assure that nobody can come after the DQUOT_DROP and\n\t * add quota pointers back anyway.\n\t */\n\tfor (cnt = 0; cnt < MAXQUOTAS; cnt++) {\n\t\tif (i_dquot(inode)[cnt])\n\t\t\tbreak;\n\t}\n\n\tif (cnt < MAXQUOTAS)\n\t\t__dquot_drop(inode);\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include \"../internal.h\" /* ugh */",
            "#include <linux/quotaops.h>",
            "#include <linux/capability.h>",
            "#include <linux/namei.h>",
            "#include <linux/kmod.h>",
            "#include <linux/sched.h>",
            "#include <linux/security.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>",
            "#include <linux/tty.h>",
            "#include <linux/stat.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/time.h>",
            "#include <linux/mm.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static qsize_t inode_get_rsv_space(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include \"../internal.h\" /* ugh */\n#include <linux/quotaops.h>\n#include <linux/capability.h>\n#include <linux/namei.h>\n#include <linux/kmod.h>\n#include <linux/sched.h>\n#include <linux/security.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/sysctl.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/tty.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/time.h>\n#include <linux/mm.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/kernel.h>\n#include <linux/errno.h>\n\nstatic qsize_t inode_get_rsv_space(struct inode *inode);\n\nvoid dquot_drop(struct inode *inode)\n{\n\tint cnt;\n\n\tif (IS_NOQUOTA(inode))\n\t\treturn;\n\n\t/*\n\t * Test before calling to rule out calls from proc and such\n\t * where we are not allowed to block. Note that this is\n\t * actually reliable test even without the lock - the caller\n\t * must assure that nobody can come after the DQUOT_DROP and\n\t * add quota pointers back anyway.\n\t */\n\tfor (cnt = 0; cnt < MAXQUOTAS; cnt++) {\n\t\tif (i_dquot(inode)[cnt])\n\t\t\tbreak;\n\t}\n\n\tif (cnt < MAXQUOTAS)\n\t\t__dquot_drop(inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dquot_initialize",
          "args": [
            "inode"
          ],
          "line": 75
        },
        "resolved": true,
        "details": {
          "function_name": "dquot_initialize",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/quota/dquot.c",
          "lines": "1459-1462",
          "snippet": "void dquot_initialize(struct inode *inode)\n{\n\t__dquot_initialize(inode, -1);\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include \"../internal.h\" /* ugh */",
            "#include <linux/quotaops.h>",
            "#include <linux/capability.h>",
            "#include <linux/namei.h>",
            "#include <linux/kmod.h>",
            "#include <linux/sched.h>",
            "#include <linux/security.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>",
            "#include <linux/tty.h>",
            "#include <linux/stat.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/time.h>",
            "#include <linux/mm.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static qsize_t inode_get_rsv_space(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include \"../internal.h\" /* ugh */\n#include <linux/quotaops.h>\n#include <linux/capability.h>\n#include <linux/namei.h>\n#include <linux/kmod.h>\n#include <linux/sched.h>\n#include <linux/security.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/sysctl.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/tty.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/time.h>\n#include <linux/mm.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/kernel.h>\n#include <linux/errno.h>\n\nstatic qsize_t inode_get_rsv_space(struct inode *inode);\n\nvoid dquot_initialize(struct inode *inode)\n{\n\t__dquot_initialize(inode, -1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "is_bad_inode",
          "args": [
            "inode"
          ],
          "line": 73
        },
        "resolved": true,
        "details": {
          "function_name": "is_bad_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/bad_inode.c",
          "lines": "195-198",
          "snippet": "int is_bad_inode(struct inode *inode)\n{\n\treturn (inode->i_op == &bad_inode_ops);\t\n}",
          "includes": [
            "#include <linux/poll.h>",
            "#include <linux/namei.h>",
            "#include <linux/time.h>",
            "#include <linux/stat.h>",
            "#include <linux/export.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct inode_operations bad_inode_ops =\n{\n\t.create\t\t= bad_inode_create,\n\t.lookup\t\t= bad_inode_lookup,\n\t.link\t\t= bad_inode_link,\n\t.unlink\t\t= bad_inode_unlink,\n\t.symlink\t= bad_inode_symlink,\n\t.mkdir\t\t= bad_inode_mkdir,\n\t.rmdir\t\t= bad_inode_rmdir,\n\t.mknod\t\t= bad_inode_mknod,\n\t.rename2\t= bad_inode_rename2,\n\t.readlink\t= bad_inode_readlink,\n\t/* follow_link must be no-op, otherwise unmounting this inode\n\t   won't work */\n\t/* put_link returns void */\n\t/* truncate returns void */\n\t.permission\t= bad_inode_permission,\n\t.getattr\t= bad_inode_getattr,\n\t.setattr\t= bad_inode_setattr,\n\t.setxattr\t= bad_inode_setxattr,\n\t.getxattr\t= bad_inode_getxattr,\n\t.listxattr\t= bad_inode_listxattr,\n\t.removexattr\t= bad_inode_removexattr,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/poll.h>\n#include <linux/namei.h>\n#include <linux/time.h>\n#include <linux/stat.h>\n#include <linux/export.h>\n#include <linux/fs.h>\n\nstatic const struct inode_operations bad_inode_ops =\n{\n\t.create\t\t= bad_inode_create,\n\t.lookup\t\t= bad_inode_lookup,\n\t.link\t\t= bad_inode_link,\n\t.unlink\t\t= bad_inode_unlink,\n\t.symlink\t= bad_inode_symlink,\n\t.mkdir\t\t= bad_inode_mkdir,\n\t.rmdir\t\t= bad_inode_rmdir,\n\t.mknod\t\t= bad_inode_mknod,\n\t.rename2\t= bad_inode_rename2,\n\t.readlink\t= bad_inode_readlink,\n\t/* follow_link must be no-op, otherwise unmounting this inode\n\t   won't work */\n\t/* put_link returns void */\n\t/* truncate returns void */\n\t.permission\t= bad_inode_permission,\n\t.getattr\t= bad_inode_getattr,\n\t.setattr\t= bad_inode_setattr,\n\t.setxattr\t= bad_inode_setxattr,\n\t.getxattr\t= bad_inode_getxattr,\n\t.listxattr\t= bad_inode_listxattr,\n\t.removexattr\t= bad_inode_removexattr,\n};\n\nint is_bad_inode(struct inode *inode)\n{\n\treturn (inode->i_op == &bad_inode_ops);\t\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"xattr.h\"\n#include \"acl.h\"\n#include \"ext2.h\"\n#include <linux/aio.h>\n#include <linux/namei.h>\n#include <linux/fiemap.h>\n#include <linux/mpage.h>\n#include <linux/buffer_head.h>\n#include <linux/writeback.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/highuid.h>\n#include <linux/time.h>\n\nvoid ext2_evict_inode(struct inode * inode)\n{\n\tstruct ext2_block_alloc_info *rsv;\n\tint want_delete = 0;\n\n\tif (!inode->i_nlink && !is_bad_inode(inode)) {\n\t\twant_delete = 1;\n\t\tdquot_initialize(inode);\n\t} else {\n\t\tdquot_drop(inode);\n\t}\n\n\ttruncate_inode_pages_final(&inode->i_data);\n\n\tif (want_delete) {\n\t\tsb_start_intwrite(inode->i_sb);\n\t\t/* set dtime */\n\t\tEXT2_I(inode)->i_dtime\t= get_seconds();\n\t\tmark_inode_dirty(inode);\n\t\t__ext2_write_inode(inode, inode_needs_sync(inode));\n\t\t/* truncate to 0 */\n\t\tinode->i_size = 0;\n\t\tif (inode->i_blocks)\n\t\t\text2_truncate_blocks(inode, 0);\n\t\text2_xattr_delete_inode(inode);\n\t}\n\n\tinvalidate_inode_buffers(inode);\n\tclear_inode(inode);\n\n\text2_discard_reservation(inode);\n\trsv = EXT2_I(inode)->i_block_alloc_info;\n\tEXT2_I(inode)->i_block_alloc_info = NULL;\n\tif (unlikely(rsv))\n\t\tkfree(rsv);\n\n\tif (want_delete) {\n\t\text2_free_inode(inode);\n\t\tsb_end_intwrite(inode->i_sb);\n\t}\n}"
  },
  {
    "function_name": "ext2_write_failed",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext2/inode.c",
    "lines": "55-63",
    "snippet": "static void ext2_write_failed(struct address_space *mapping, loff_t to)\n{\n\tstruct inode *inode = mapping->host;\n\n\tif (to > inode->i_size) {\n\t\ttruncate_pagecache(inode, inode->i_size);\n\t\text2_truncate_blocks(inode, inode->i_size);\n\t}\n}",
    "includes": [
      "#include \"xattr.h\"",
      "#include \"acl.h\"",
      "#include \"ext2.h\"",
      "#include <linux/aio.h>",
      "#include <linux/namei.h>",
      "#include <linux/fiemap.h>",
      "#include <linux/mpage.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/writeback.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/highuid.h>",
      "#include <linux/time.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ext2_truncate_blocks",
          "args": [
            "inode",
            "inode->i_size"
          ],
          "line": 61
        },
        "resolved": true,
        "details": {
          "function_name": "ext2_truncate_blocks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext2/inode.c",
          "lines": "1171-1189",
          "snippet": "static void ext2_truncate_blocks(struct inode *inode, loff_t offset)\n{\n\t/*\n\t * XXX: it seems like a bug here that we don't allow\n\t * IS_APPEND inode to have blocks-past-i_size trimmed off.\n\t * review and fix this.\n\t *\n\t * Also would be nice to be able to handle IO errors and such,\n\t * but that's probably too much to ask.\n\t */\n\tif (!(S_ISREG(inode->i_mode) || S_ISDIR(inode->i_mode) ||\n\t    S_ISLNK(inode->i_mode)))\n\t\treturn;\n\tif (ext2_inode_is_fast_symlink(inode))\n\t\treturn;\n\tif (IS_APPEND(inode) || IS_IMMUTABLE(inode))\n\t\treturn;\n\t__ext2_truncate_blocks(inode, offset);\n}",
          "includes": [
            "#include \"xattr.h\"",
            "#include \"acl.h\"",
            "#include \"ext2.h\"",
            "#include <linux/aio.h>",
            "#include <linux/namei.h>",
            "#include <linux/fiemap.h>",
            "#include <linux/mpage.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/writeback.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highuid.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void ext2_truncate_blocks(struct inode *inode, loff_t offset);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xattr.h\"\n#include \"acl.h\"\n#include \"ext2.h\"\n#include <linux/aio.h>\n#include <linux/namei.h>\n#include <linux/fiemap.h>\n#include <linux/mpage.h>\n#include <linux/buffer_head.h>\n#include <linux/writeback.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/highuid.h>\n#include <linux/time.h>\n\nstatic void ext2_truncate_blocks(struct inode *inode, loff_t offset);\n\nstatic void ext2_truncate_blocks(struct inode *inode, loff_t offset)\n{\n\t/*\n\t * XXX: it seems like a bug here that we don't allow\n\t * IS_APPEND inode to have blocks-past-i_size trimmed off.\n\t * review and fix this.\n\t *\n\t * Also would be nice to be able to handle IO errors and such,\n\t * but that's probably too much to ask.\n\t */\n\tif (!(S_ISREG(inode->i_mode) || S_ISDIR(inode->i_mode) ||\n\t    S_ISLNK(inode->i_mode)))\n\t\treturn;\n\tif (ext2_inode_is_fast_symlink(inode))\n\t\treturn;\n\tif (IS_APPEND(inode) || IS_IMMUTABLE(inode))\n\t\treturn;\n\t__ext2_truncate_blocks(inode, offset);\n}"
        }
      },
      {
        "call_info": {
          "callee": "truncate_pagecache",
          "args": [
            "inode",
            "inode->i_size"
          ],
          "line": 60
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xattr.h\"\n#include \"acl.h\"\n#include \"ext2.h\"\n#include <linux/aio.h>\n#include <linux/namei.h>\n#include <linux/fiemap.h>\n#include <linux/mpage.h>\n#include <linux/buffer_head.h>\n#include <linux/writeback.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/highuid.h>\n#include <linux/time.h>\n\nstatic void ext2_write_failed(struct address_space *mapping, loff_t to)\n{\n\tstruct inode *inode = mapping->host;\n\n\tif (to > inode->i_size) {\n\t\ttruncate_pagecache(inode, inode->i_size);\n\t\text2_truncate_blocks(inode, inode->i_size);\n\t}\n}"
  },
  {
    "function_name": "ext2_inode_is_fast_symlink",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext2/inode.c",
    "lines": "44-51",
    "snippet": "static inline int ext2_inode_is_fast_symlink(struct inode *inode)\n{\n\tint ea_blocks = EXT2_I(inode)->i_file_acl ?\n\t\t(inode->i_sb->s_blocksize >> 9) : 0;\n\n\treturn (S_ISLNK(inode->i_mode) &&\n\t\tinode->i_blocks - ea_blocks == 0);\n}",
    "includes": [
      "#include \"xattr.h\"",
      "#include \"acl.h\"",
      "#include \"ext2.h\"",
      "#include <linux/aio.h>",
      "#include <linux/namei.h>",
      "#include <linux/fiemap.h>",
      "#include <linux/mpage.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/writeback.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/highuid.h>",
      "#include <linux/time.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "S_ISLNK",
          "args": [
            "inode->i_mode"
          ],
          "line": 49
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXT2_I",
          "args": [
            "inode"
          ],
          "line": 46
        },
        "resolved": true,
        "details": {
          "function_name": "EXT2_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext2/ext2.h",
          "lines": "717-720",
          "snippet": "static inline struct ext2_inode_info *EXT2_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ext2_inode_info, vfs_inode);\n}",
          "includes": [
            "#include <linux/rbtree.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/ext2_fs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern ext2_fsblk_t ext2_new_block(struct inode *, unsigned long, int *);",
            "extern ext2_fsblk_t ext2_new_blocks(struct inode *, unsigned long,\n\t\t\t\tunsigned long *, int *);",
            "extern void ext2_free_blocks (struct inode *, unsigned long,\n\t\t\t      unsigned long);",
            "extern void ext2_discard_reservation (struct inode *);",
            "extern void ext2_init_block_alloc_info(struct inode *);",
            "extern int ext2_add_link (struct dentry *, struct inode *);",
            "extern int ext2_make_empty(struct inode *, struct inode *);",
            "extern int ext2_empty_dir (struct inode *);",
            "extern void ext2_set_link(struct inode *, struct ext2_dir_entry_2 *, struct page *, struct inode *, int);",
            "extern void ext2_free_inode (struct inode *);",
            "extern void ext2_evict_inode(struct inode *);",
            "extern void ext2_set_inode_flags(struct inode *inode);",
            "extern void ext2_get_inode_flags(struct ext2_inode_info *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rbtree.h>\n#include <linux/percpu_counter.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/ext2_fs.h>\n#include <linux/fs.h>\n\nextern ext2_fsblk_t ext2_new_block(struct inode *, unsigned long, int *);\nextern ext2_fsblk_t ext2_new_blocks(struct inode *, unsigned long,\n\t\t\t\tunsigned long *, int *);\nextern void ext2_free_blocks (struct inode *, unsigned long,\n\t\t\t      unsigned long);\nextern void ext2_discard_reservation (struct inode *);\nextern void ext2_init_block_alloc_info(struct inode *);\nextern int ext2_add_link (struct dentry *, struct inode *);\nextern int ext2_make_empty(struct inode *, struct inode *);\nextern int ext2_empty_dir (struct inode *);\nextern void ext2_set_link(struct inode *, struct ext2_dir_entry_2 *, struct page *, struct inode *, int);\nextern void ext2_free_inode (struct inode *);\nextern void ext2_evict_inode(struct inode *);\nextern void ext2_set_inode_flags(struct inode *inode);\nextern void ext2_get_inode_flags(struct ext2_inode_info *);\n\nstatic inline struct ext2_inode_info *EXT2_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ext2_inode_info, vfs_inode);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"xattr.h\"\n#include \"acl.h\"\n#include \"ext2.h\"\n#include <linux/aio.h>\n#include <linux/namei.h>\n#include <linux/fiemap.h>\n#include <linux/mpage.h>\n#include <linux/buffer_head.h>\n#include <linux/writeback.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/highuid.h>\n#include <linux/time.h>\n\nstatic inline int ext2_inode_is_fast_symlink(struct inode *inode)\n{\n\tint ea_blocks = EXT2_I(inode)->i_file_acl ?\n\t\t(inode->i_sb->s_blocksize >> 9) : 0;\n\n\treturn (S_ISLNK(inode->i_mode) &&\n\t\tinode->i_blocks - ea_blocks == 0);\n}"
  }
]