[
  {
    "function_name": "xfs_rtfree_extent",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_rtbitmap.c",
    "lines": "947-990",
    "snippet": "int\t\t\t\t\t/* error */\nxfs_rtfree_extent(\n\txfs_trans_t\t*tp,\t\t/* transaction pointer */\n\txfs_rtblock_t\tbno,\t\t/* starting block number to free */\n\txfs_extlen_t\tlen)\t\t/* length of extent freed */\n{\n\tint\t\terror;\t\t/* error value */\n\txfs_mount_t\t*mp;\t\t/* file system mount structure */\n\txfs_fsblock_t\tsb;\t\t/* summary file block number */\n\txfs_buf_t\t*sumbp = NULL;\t/* summary file block buffer */\n\n\tmp = tp->t_mountp;\n\n\tASSERT(mp->m_rbmip->i_itemp != NULL);\n\tASSERT(xfs_isilocked(mp->m_rbmip, XFS_ILOCK_EXCL));\n\n\terror = xfs_rtcheck_alloc_range(mp, tp, bno, len);\n\tif (error)\n\t\treturn error;\n\n\t/*\n\t * Free the range of realtime blocks.\n\t */\n\terror = xfs_rtfree_range(mp, tp, bno, len, &sumbp, &sb);\n\tif (error) {\n\t\treturn error;\n\t}\n\t/*\n\t * Mark more blocks free in the superblock.\n\t */\n\txfs_trans_mod_sb(tp, XFS_TRANS_SB_FREXTENTS, (long)len);\n\t/*\n\t * If we've now freed all the blocks, reset the file sequence\n\t * number to 0.\n\t */\n\tif (tp->t_frextents_delta + mp->m_sb.sb_frextents ==\n\t    mp->m_sb.sb_rextents) {\n\t\tif (!(mp->m_rbmip->i_d.di_flags & XFS_DIFLAG_NEWRTBM))\n\t\t\tmp->m_rbmip->i_d.di_flags |= XFS_DIFLAG_NEWRTBM;\n\t\t*(__uint64_t *)&mp->m_rbmip->i_d.di_atime = 0;\n\t\txfs_trans_log_inode(tp, mp->m_rbmip, XFS_ILOG_CORE);\n\t}\n\treturn 0;\n}",
    "includes": [
      "#include \"xfs_rtalloc.h\"",
      "#include \"xfs_icache.h\"",
      "#include \"xfs_buf.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_trans_space.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_alloc.h\"",
      "#include \"xfs_bmap_btree.h\"",
      "#include \"xfs_bmap_util.h\"",
      "#include \"xfs_bmap.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_bit.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "xfs_trans_log_inode",
          "args": [
            "tp",
            "mp->m_rbmip",
            "XFS_ILOG_CORE"
          ],
          "line": 987
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_trans_log_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_trans_inode.c",
          "lines": "101-135",
          "snippet": "void\nxfs_trans_log_inode(\n\txfs_trans_t\t*tp,\n\txfs_inode_t\t*ip,\n\tuint\t\tflags)\n{\n\tASSERT(ip->i_itemp != NULL);\n\tASSERT(xfs_isilocked(ip, XFS_ILOCK_EXCL));\n\n\t/*\n\t * First time we log the inode in a transaction, bump the inode change\n\t * counter if it is configured for this to occur. We don't use\n\t * inode_inc_version() because there is no need for extra locking around\n\t * i_version as we already hold the inode locked exclusively for\n\t * metadata modification.\n\t */\n\tif (!(ip->i_itemp->ili_item.li_desc->lid_flags & XFS_LID_DIRTY) &&\n\t    IS_I_VERSION(VFS_I(ip))) {\n\t\tip->i_d.di_changecount = ++VFS_I(ip)->i_version;\n\t\tflags |= XFS_ILOG_CORE;\n\t}\n\n\ttp->t_flags |= XFS_TRANS_DIRTY;\n\tip->i_itemp->ili_item.li_desc->lid_flags |= XFS_LID_DIRTY;\n\n\t/*\n\t * Always OR in the bits from the ili_last_fields field.\n\t * This is to coordinate with the xfs_iflush() and xfs_iflush_done()\n\t * routines in the eventual clearing of the ili_fields bits.\n\t * See the big comment in xfs_iflush() for an explanation of\n\t * this coordination mechanism.\n\t */\n\tflags |= ip->i_itemp->ili_last_fields;\n\tip->i_itemp->ili_fields |= flags;\n}",
          "includes": [
            "#include \"xfs_trace.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_trace.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nvoid\nxfs_trans_log_inode(\n\txfs_trans_t\t*tp,\n\txfs_inode_t\t*ip,\n\tuint\t\tflags)\n{\n\tASSERT(ip->i_itemp != NULL);\n\tASSERT(xfs_isilocked(ip, XFS_ILOCK_EXCL));\n\n\t/*\n\t * First time we log the inode in a transaction, bump the inode change\n\t * counter if it is configured for this to occur. We don't use\n\t * inode_inc_version() because there is no need for extra locking around\n\t * i_version as we already hold the inode locked exclusively for\n\t * metadata modification.\n\t */\n\tif (!(ip->i_itemp->ili_item.li_desc->lid_flags & XFS_LID_DIRTY) &&\n\t    IS_I_VERSION(VFS_I(ip))) {\n\t\tip->i_d.di_changecount = ++VFS_I(ip)->i_version;\n\t\tflags |= XFS_ILOG_CORE;\n\t}\n\n\ttp->t_flags |= XFS_TRANS_DIRTY;\n\tip->i_itemp->ili_item.li_desc->lid_flags |= XFS_LID_DIRTY;\n\n\t/*\n\t * Always OR in the bits from the ili_last_fields field.\n\t * This is to coordinate with the xfs_iflush() and xfs_iflush_done()\n\t * routines in the eventual clearing of the ili_fields bits.\n\t * See the big comment in xfs_iflush() for an explanation of\n\t * this coordination mechanism.\n\t */\n\tflags |= ip->i_itemp->ili_last_fields;\n\tip->i_itemp->ili_fields |= flags;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_trans_mod_sb",
          "args": [
            "tp",
            "XFS_TRANS_SB_FREXTENTS",
            "(long)len"
          ],
          "line": 977
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_trans_mod_sb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_trans.c",
          "lines": "297-395",
          "snippet": "void\nxfs_trans_mod_sb(\n\txfs_trans_t\t*tp,\n\tuint\t\tfield,\n\tint64_t\t\tdelta)\n{\n\tuint32_t\tflags = (XFS_TRANS_DIRTY|XFS_TRANS_SB_DIRTY);\n\txfs_mount_t\t*mp = tp->t_mountp;\n\n\tswitch (field) {\n\tcase XFS_TRANS_SB_ICOUNT:\n\t\ttp->t_icount_delta += delta;\n\t\tif (xfs_sb_version_haslazysbcount(&mp->m_sb))\n\t\t\tflags &= ~XFS_TRANS_SB_DIRTY;\n\t\tbreak;\n\tcase XFS_TRANS_SB_IFREE:\n\t\ttp->t_ifree_delta += delta;\n\t\tif (xfs_sb_version_haslazysbcount(&mp->m_sb))\n\t\t\tflags &= ~XFS_TRANS_SB_DIRTY;\n\t\tbreak;\n\tcase XFS_TRANS_SB_FDBLOCKS:\n\t\t/*\n\t\t * Track the number of blocks allocated in the\n\t\t * transaction.  Make sure it does not exceed the\n\t\t * number reserved.\n\t\t */\n\t\tif (delta < 0) {\n\t\t\ttp->t_blk_res_used += (uint)-delta;\n\t\t\tASSERT(tp->t_blk_res_used <= tp->t_blk_res);\n\t\t}\n\t\ttp->t_fdblocks_delta += delta;\n\t\tif (xfs_sb_version_haslazysbcount(&mp->m_sb))\n\t\t\tflags &= ~XFS_TRANS_SB_DIRTY;\n\t\tbreak;\n\tcase XFS_TRANS_SB_RES_FDBLOCKS:\n\t\t/*\n\t\t * The allocation has already been applied to the\n\t\t * in-core superblock's counter.  This should only\n\t\t * be applied to the on-disk superblock.\n\t\t */\n\t\tASSERT(delta < 0);\n\t\ttp->t_res_fdblocks_delta += delta;\n\t\tif (xfs_sb_version_haslazysbcount(&mp->m_sb))\n\t\t\tflags &= ~XFS_TRANS_SB_DIRTY;\n\t\tbreak;\n\tcase XFS_TRANS_SB_FREXTENTS:\n\t\t/*\n\t\t * Track the number of blocks allocated in the\n\t\t * transaction.  Make sure it does not exceed the\n\t\t * number reserved.\n\t\t */\n\t\tif (delta < 0) {\n\t\t\ttp->t_rtx_res_used += (uint)-delta;\n\t\t\tASSERT(tp->t_rtx_res_used <= tp->t_rtx_res);\n\t\t}\n\t\ttp->t_frextents_delta += delta;\n\t\tbreak;\n\tcase XFS_TRANS_SB_RES_FREXTENTS:\n\t\t/*\n\t\t * The allocation has already been applied to the\n\t\t * in-core superblock's counter.  This should only\n\t\t * be applied to the on-disk superblock.\n\t\t */\n\t\tASSERT(delta < 0);\n\t\ttp->t_res_frextents_delta += delta;\n\t\tbreak;\n\tcase XFS_TRANS_SB_DBLOCKS:\n\t\tASSERT(delta > 0);\n\t\ttp->t_dblocks_delta += delta;\n\t\tbreak;\n\tcase XFS_TRANS_SB_AGCOUNT:\n\t\tASSERT(delta > 0);\n\t\ttp->t_agcount_delta += delta;\n\t\tbreak;\n\tcase XFS_TRANS_SB_IMAXPCT:\n\t\ttp->t_imaxpct_delta += delta;\n\t\tbreak;\n\tcase XFS_TRANS_SB_REXTSIZE:\n\t\ttp->t_rextsize_delta += delta;\n\t\tbreak;\n\tcase XFS_TRANS_SB_RBMBLOCKS:\n\t\ttp->t_rbmblocks_delta += delta;\n\t\tbreak;\n\tcase XFS_TRANS_SB_RBLOCKS:\n\t\ttp->t_rblocks_delta += delta;\n\t\tbreak;\n\tcase XFS_TRANS_SB_REXTENTS:\n\t\ttp->t_rextents_delta += delta;\n\t\tbreak;\n\tcase XFS_TRANS_SB_REXTSLOG:\n\t\ttp->t_rextslog_delta += delta;\n\t\tbreak;\n\tdefault:\n\t\tASSERT(0);\n\t\treturn;\n\t}\n\n\ttp->t_flags |= flags;\n}",
          "includes": [
            "#include \"xfs_error.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_extent_busy.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_error.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_extent_busy.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nvoid\nxfs_trans_mod_sb(\n\txfs_trans_t\t*tp,\n\tuint\t\tfield,\n\tint64_t\t\tdelta)\n{\n\tuint32_t\tflags = (XFS_TRANS_DIRTY|XFS_TRANS_SB_DIRTY);\n\txfs_mount_t\t*mp = tp->t_mountp;\n\n\tswitch (field) {\n\tcase XFS_TRANS_SB_ICOUNT:\n\t\ttp->t_icount_delta += delta;\n\t\tif (xfs_sb_version_haslazysbcount(&mp->m_sb))\n\t\t\tflags &= ~XFS_TRANS_SB_DIRTY;\n\t\tbreak;\n\tcase XFS_TRANS_SB_IFREE:\n\t\ttp->t_ifree_delta += delta;\n\t\tif (xfs_sb_version_haslazysbcount(&mp->m_sb))\n\t\t\tflags &= ~XFS_TRANS_SB_DIRTY;\n\t\tbreak;\n\tcase XFS_TRANS_SB_FDBLOCKS:\n\t\t/*\n\t\t * Track the number of blocks allocated in the\n\t\t * transaction.  Make sure it does not exceed the\n\t\t * number reserved.\n\t\t */\n\t\tif (delta < 0) {\n\t\t\ttp->t_blk_res_used += (uint)-delta;\n\t\t\tASSERT(tp->t_blk_res_used <= tp->t_blk_res);\n\t\t}\n\t\ttp->t_fdblocks_delta += delta;\n\t\tif (xfs_sb_version_haslazysbcount(&mp->m_sb))\n\t\t\tflags &= ~XFS_TRANS_SB_DIRTY;\n\t\tbreak;\n\tcase XFS_TRANS_SB_RES_FDBLOCKS:\n\t\t/*\n\t\t * The allocation has already been applied to the\n\t\t * in-core superblock's counter.  This should only\n\t\t * be applied to the on-disk superblock.\n\t\t */\n\t\tASSERT(delta < 0);\n\t\ttp->t_res_fdblocks_delta += delta;\n\t\tif (xfs_sb_version_haslazysbcount(&mp->m_sb))\n\t\t\tflags &= ~XFS_TRANS_SB_DIRTY;\n\t\tbreak;\n\tcase XFS_TRANS_SB_FREXTENTS:\n\t\t/*\n\t\t * Track the number of blocks allocated in the\n\t\t * transaction.  Make sure it does not exceed the\n\t\t * number reserved.\n\t\t */\n\t\tif (delta < 0) {\n\t\t\ttp->t_rtx_res_used += (uint)-delta;\n\t\t\tASSERT(tp->t_rtx_res_used <= tp->t_rtx_res);\n\t\t}\n\t\ttp->t_frextents_delta += delta;\n\t\tbreak;\n\tcase XFS_TRANS_SB_RES_FREXTENTS:\n\t\t/*\n\t\t * The allocation has already been applied to the\n\t\t * in-core superblock's counter.  This should only\n\t\t * be applied to the on-disk superblock.\n\t\t */\n\t\tASSERT(delta < 0);\n\t\ttp->t_res_frextents_delta += delta;\n\t\tbreak;\n\tcase XFS_TRANS_SB_DBLOCKS:\n\t\tASSERT(delta > 0);\n\t\ttp->t_dblocks_delta += delta;\n\t\tbreak;\n\tcase XFS_TRANS_SB_AGCOUNT:\n\t\tASSERT(delta > 0);\n\t\ttp->t_agcount_delta += delta;\n\t\tbreak;\n\tcase XFS_TRANS_SB_IMAXPCT:\n\t\ttp->t_imaxpct_delta += delta;\n\t\tbreak;\n\tcase XFS_TRANS_SB_REXTSIZE:\n\t\ttp->t_rextsize_delta += delta;\n\t\tbreak;\n\tcase XFS_TRANS_SB_RBMBLOCKS:\n\t\ttp->t_rbmblocks_delta += delta;\n\t\tbreak;\n\tcase XFS_TRANS_SB_RBLOCKS:\n\t\ttp->t_rblocks_delta += delta;\n\t\tbreak;\n\tcase XFS_TRANS_SB_REXTENTS:\n\t\ttp->t_rextents_delta += delta;\n\t\tbreak;\n\tcase XFS_TRANS_SB_REXTSLOG:\n\t\ttp->t_rextslog_delta += delta;\n\t\tbreak;\n\tdefault:\n\t\tASSERT(0);\n\t\treturn;\n\t}\n\n\ttp->t_flags |= flags;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_rtfree_range",
          "args": [
            "mp",
            "tp",
            "bno",
            "len",
            "&sumbp",
            "&sb"
          ],
          "line": 970
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_rtfree_range",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_rtbitmap.c",
          "lines": "671-741",
          "snippet": "int\nxfs_rtfree_range(\n\txfs_mount_t\t*mp,\t\t/* file system mount point */\n\txfs_trans_t\t*tp,\t\t/* transaction pointer */\n\txfs_rtblock_t\tstart,\t\t/* starting block to free */\n\txfs_extlen_t\tlen,\t\t/* length to free */\n\txfs_buf_t\t**rbpp,\t\t/* in/out: summary block buffer */\n\txfs_fsblock_t\t*rsb)\t\t/* in/out: summary block number */\n{\n\txfs_rtblock_t\tend;\t\t/* end of the freed extent */\n\tint\t\terror;\t\t/* error value */\n\txfs_rtblock_t\tpostblock;\t/* first block freed > end */\n\txfs_rtblock_t\tpreblock;\t/* first block freed < start */\n\n\tend = start + len - 1;\n\t/*\n\t * Modify the bitmap to mark this extent freed.\n\t */\n\terror = xfs_rtmodify_range(mp, tp, start, len, 1);\n\tif (error) {\n\t\treturn error;\n\t}\n\t/*\n\t * Assume we're freeing out of the middle of an allocated extent.\n\t * We need to find the beginning and end of the extent so we can\n\t * properly update the summary.\n\t */\n\terror = xfs_rtfind_back(mp, tp, start, 0, &preblock);\n\tif (error) {\n\t\treturn error;\n\t}\n\t/*\n\t * Find the next allocated block (end of allocated extent).\n\t */\n\terror = xfs_rtfind_forw(mp, tp, end, mp->m_sb.sb_rextents - 1,\n\t\t&postblock);\n\tif (error)\n\t\treturn error;\n\t/*\n\t * If there are blocks not being freed at the front of the\n\t * old extent, add summary data for them to be allocated.\n\t */\n\tif (preblock < start) {\n\t\terror = xfs_rtmodify_summary(mp, tp,\n\t\t\tXFS_RTBLOCKLOG(start - preblock),\n\t\t\tXFS_BITTOBLOCK(mp, preblock), -1, rbpp, rsb);\n\t\tif (error) {\n\t\t\treturn error;\n\t\t}\n\t}\n\t/*\n\t * If there are blocks not being freed at the end of the\n\t * old extent, add summary data for them to be allocated.\n\t */\n\tif (postblock > end) {\n\t\terror = xfs_rtmodify_summary(mp, tp,\n\t\t\tXFS_RTBLOCKLOG(postblock - end),\n\t\t\tXFS_BITTOBLOCK(mp, end + 1), -1, rbpp, rsb);\n\t\tif (error) {\n\t\t\treturn error;\n\t\t}\n\t}\n\t/*\n\t * Increment the summary information corresponding to the entire\n\t * (new) free extent.\n\t */\n\terror = xfs_rtmodify_summary(mp, tp,\n\t\tXFS_RTBLOCKLOG(postblock + 1 - preblock),\n\t\tXFS_BITTOBLOCK(mp, preblock), 1, rbpp, rsb);\n\treturn error;\n}",
          "includes": [
            "#include \"xfs_rtalloc.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_buf.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_trans_space.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_rtalloc.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_buf.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_error.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nint\nxfs_rtfree_range(\n\txfs_mount_t\t*mp,\t\t/* file system mount point */\n\txfs_trans_t\t*tp,\t\t/* transaction pointer */\n\txfs_rtblock_t\tstart,\t\t/* starting block to free */\n\txfs_extlen_t\tlen,\t\t/* length to free */\n\txfs_buf_t\t**rbpp,\t\t/* in/out: summary block buffer */\n\txfs_fsblock_t\t*rsb)\t\t/* in/out: summary block number */\n{\n\txfs_rtblock_t\tend;\t\t/* end of the freed extent */\n\tint\t\terror;\t\t/* error value */\n\txfs_rtblock_t\tpostblock;\t/* first block freed > end */\n\txfs_rtblock_t\tpreblock;\t/* first block freed < start */\n\n\tend = start + len - 1;\n\t/*\n\t * Modify the bitmap to mark this extent freed.\n\t */\n\terror = xfs_rtmodify_range(mp, tp, start, len, 1);\n\tif (error) {\n\t\treturn error;\n\t}\n\t/*\n\t * Assume we're freeing out of the middle of an allocated extent.\n\t * We need to find the beginning and end of the extent so we can\n\t * properly update the summary.\n\t */\n\terror = xfs_rtfind_back(mp, tp, start, 0, &preblock);\n\tif (error) {\n\t\treturn error;\n\t}\n\t/*\n\t * Find the next allocated block (end of allocated extent).\n\t */\n\terror = xfs_rtfind_forw(mp, tp, end, mp->m_sb.sb_rextents - 1,\n\t\t&postblock);\n\tif (error)\n\t\treturn error;\n\t/*\n\t * If there are blocks not being freed at the front of the\n\t * old extent, add summary data for them to be allocated.\n\t */\n\tif (preblock < start) {\n\t\terror = xfs_rtmodify_summary(mp, tp,\n\t\t\tXFS_RTBLOCKLOG(start - preblock),\n\t\t\tXFS_BITTOBLOCK(mp, preblock), -1, rbpp, rsb);\n\t\tif (error) {\n\t\t\treturn error;\n\t\t}\n\t}\n\t/*\n\t * If there are blocks not being freed at the end of the\n\t * old extent, add summary data for them to be allocated.\n\t */\n\tif (postblock > end) {\n\t\terror = xfs_rtmodify_summary(mp, tp,\n\t\t\tXFS_RTBLOCKLOG(postblock - end),\n\t\t\tXFS_BITTOBLOCK(mp, end + 1), -1, rbpp, rsb);\n\t\tif (error) {\n\t\t\treturn error;\n\t\t}\n\t}\n\t/*\n\t * Increment the summary information corresponding to the entire\n\t * (new) free extent.\n\t */\n\terror = xfs_rtmodify_summary(mp, tp,\n\t\tXFS_RTBLOCKLOG(postblock + 1 - preblock),\n\t\tXFS_BITTOBLOCK(mp, preblock), 1, rbpp, rsb);\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_rtcheck_alloc_range",
          "args": [
            "mp",
            "tp",
            "bno",
            "len"
          ],
          "line": 963
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_rtcheck_alloc_range",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_rtbitmap.c",
          "lines": "923-939",
          "snippet": "STATIC int\t\t\t\t/* error */\nxfs_rtcheck_alloc_range(\n\txfs_mount_t\t*mp,\t\t/* file system mount point */\n\txfs_trans_t\t*tp,\t\t/* transaction pointer */\n\txfs_rtblock_t\tbno,\t\t/* starting block number of extent */\n\txfs_extlen_t\tlen)\t\t/* length of extent */\n{\n\txfs_rtblock_t\tnew;\t\t/* dummy for xfs_rtcheck_range */\n\tint\t\tstat;\n\tint\t\terror;\n\n\terror = xfs_rtcheck_range(mp, tp, bno, len, 0, &new, &stat);\n\tif (error)\n\t\treturn error;\n\tASSERT(stat);\n\treturn 0;\n}",
          "includes": [
            "#include \"xfs_rtalloc.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_buf.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_trans_space.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_rtalloc.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_buf.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_error.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC int\t\t\t\t/* error */\nxfs_rtcheck_alloc_range(\n\txfs_mount_t\t*mp,\t\t/* file system mount point */\n\txfs_trans_t\t*tp,\t\t/* transaction pointer */\n\txfs_rtblock_t\tbno,\t\t/* starting block number of extent */\n\txfs_extlen_t\tlen)\t\t/* length of extent */\n{\n\txfs_rtblock_t\tnew;\t\t/* dummy for xfs_rtcheck_range */\n\tint\t\tstat;\n\tint\t\terror;\n\n\terror = xfs_rtcheck_range(mp, tp, bno, len, 0, &new, &stat);\n\tif (error)\n\t\treturn error;\n\tASSERT(stat);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "xfs_isilocked(mp->m_rbmip, XFS_ILOCK_EXCL)"
          ],
          "line": 961
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_isilocked",
          "args": [
            "mp->m_rbmip",
            "XFS_ILOCK_EXCL"
          ],
          "line": 961
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_isilocked",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_inode.c",
          "lines": "286-305",
          "snippet": "int\nxfs_isilocked(\n\txfs_inode_t\t\t*ip,\n\tuint\t\t\tlock_flags)\n{\n\tif (lock_flags & (XFS_ILOCK_EXCL|XFS_ILOCK_SHARED)) {\n\t\tif (!(lock_flags & XFS_ILOCK_SHARED))\n\t\t\treturn !!ip->i_lock.mr_writer;\n\t\treturn rwsem_is_locked(&ip->i_lock.mr_lock);\n\t}\n\n\tif (lock_flags & (XFS_IOLOCK_EXCL|XFS_IOLOCK_SHARED)) {\n\t\tif (!(lock_flags & XFS_IOLOCK_SHARED))\n\t\t\treturn !!ip->i_iolock.mr_writer;\n\t\treturn rwsem_is_locked(&ip->i_iolock.mr_lock);\n\t}\n\n\tASSERT(0);\n\treturn 0;\n}",
          "includes": [
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_symlink.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_filestream.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_ialloc.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_trans_space.h\"",
            "#include \"xfs_attr.h\"",
            "#include \"xfs_attr_sf.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\"",
            "#include <linux/log2.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC int xfs_iunlink_remove(xfs_trans_t *, xfs_inode_t *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_bmap_btree.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_symlink.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_filestream.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_attr_sf.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n#include <linux/log2.h>\n\nSTATIC int xfs_iunlink_remove(xfs_trans_t *, xfs_inode_t *);\n\nint\nxfs_isilocked(\n\txfs_inode_t\t\t*ip,\n\tuint\t\t\tlock_flags)\n{\n\tif (lock_flags & (XFS_ILOCK_EXCL|XFS_ILOCK_SHARED)) {\n\t\tif (!(lock_flags & XFS_ILOCK_SHARED))\n\t\t\treturn !!ip->i_lock.mr_writer;\n\t\treturn rwsem_is_locked(&ip->i_lock.mr_lock);\n\t}\n\n\tif (lock_flags & (XFS_IOLOCK_EXCL|XFS_IOLOCK_SHARED)) {\n\t\tif (!(lock_flags & XFS_IOLOCK_SHARED))\n\t\t\treturn !!ip->i_iolock.mr_writer;\n\t\treturn rwsem_is_locked(&ip->i_iolock.mr_lock);\n\t}\n\n\tASSERT(0);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "mp->m_rbmip->i_itemp != NULL"
          ],
          "line": 960
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xfs_rtalloc.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_buf.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_error.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nint\t\t\t\t\t/* error */\nxfs_rtfree_extent(\n\txfs_trans_t\t*tp,\t\t/* transaction pointer */\n\txfs_rtblock_t\tbno,\t\t/* starting block number to free */\n\txfs_extlen_t\tlen)\t\t/* length of extent freed */\n{\n\tint\t\terror;\t\t/* error value */\n\txfs_mount_t\t*mp;\t\t/* file system mount structure */\n\txfs_fsblock_t\tsb;\t\t/* summary file block number */\n\txfs_buf_t\t*sumbp = NULL;\t/* summary file block buffer */\n\n\tmp = tp->t_mountp;\n\n\tASSERT(mp->m_rbmip->i_itemp != NULL);\n\tASSERT(xfs_isilocked(mp->m_rbmip, XFS_ILOCK_EXCL));\n\n\terror = xfs_rtcheck_alloc_range(mp, tp, bno, len);\n\tif (error)\n\t\treturn error;\n\n\t/*\n\t * Free the range of realtime blocks.\n\t */\n\terror = xfs_rtfree_range(mp, tp, bno, len, &sumbp, &sb);\n\tif (error) {\n\t\treturn error;\n\t}\n\t/*\n\t * Mark more blocks free in the superblock.\n\t */\n\txfs_trans_mod_sb(tp, XFS_TRANS_SB_FREXTENTS, (long)len);\n\t/*\n\t * If we've now freed all the blocks, reset the file sequence\n\t * number to 0.\n\t */\n\tif (tp->t_frextents_delta + mp->m_sb.sb_frextents ==\n\t    mp->m_sb.sb_rextents) {\n\t\tif (!(mp->m_rbmip->i_d.di_flags & XFS_DIFLAG_NEWRTBM))\n\t\t\tmp->m_rbmip->i_d.di_flags |= XFS_DIFLAG_NEWRTBM;\n\t\t*(__uint64_t *)&mp->m_rbmip->i_d.di_atime = 0;\n\t\txfs_trans_log_inode(tp, mp->m_rbmip, XFS_ILOG_CORE);\n\t}\n\treturn 0;\n}"
  },
  {
    "function_name": "xfs_rtcheck_alloc_range",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_rtbitmap.c",
    "lines": "923-939",
    "snippet": "STATIC int\t\t\t\t/* error */\nxfs_rtcheck_alloc_range(\n\txfs_mount_t\t*mp,\t\t/* file system mount point */\n\txfs_trans_t\t*tp,\t\t/* transaction pointer */\n\txfs_rtblock_t\tbno,\t\t/* starting block number of extent */\n\txfs_extlen_t\tlen)\t\t/* length of extent */\n{\n\txfs_rtblock_t\tnew;\t\t/* dummy for xfs_rtcheck_range */\n\tint\t\tstat;\n\tint\t\terror;\n\n\terror = xfs_rtcheck_range(mp, tp, bno, len, 0, &new, &stat);\n\tif (error)\n\t\treturn error;\n\tASSERT(stat);\n\treturn 0;\n}",
    "includes": [
      "#include \"xfs_rtalloc.h\"",
      "#include \"xfs_icache.h\"",
      "#include \"xfs_buf.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_trans_space.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_alloc.h\"",
      "#include \"xfs_bmap_btree.h\"",
      "#include \"xfs_bmap_util.h\"",
      "#include \"xfs_bmap.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_bit.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "stat"
          ],
          "line": 937
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_rtcheck_range",
          "args": [
            "mp",
            "tp",
            "bno",
            "len",
            "0",
            "&new",
            "&stat"
          ],
          "line": 934
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_rtcheck_range",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_rtbitmap.c",
          "lines": "747-917",
          "snippet": "int\nxfs_rtcheck_range(\n\txfs_mount_t\t*mp,\t\t/* file system mount point */\n\txfs_trans_t\t*tp,\t\t/* transaction pointer */\n\txfs_rtblock_t\tstart,\t\t/* starting block number of extent */\n\txfs_extlen_t\tlen,\t\t/* length of extent */\n\tint\t\tval,\t\t/* 1 for free, 0 for allocated */\n\txfs_rtblock_t\t*new,\t\t/* out: first block not matching */\n\tint\t\t*stat)\t\t/* out: 1 for matches, 0 for not */\n{\n\txfs_rtword_t\t*b;\t\t/* current word in buffer */\n\tint\t\tbit;\t\t/* bit number in the word */\n\txfs_rtblock_t\tblock;\t\t/* bitmap block number */\n\txfs_buf_t\t*bp;\t\t/* buf for the block */\n\txfs_rtword_t\t*bufp;\t\t/* starting word in buffer */\n\tint\t\terror;\t\t/* error value */\n\txfs_rtblock_t\ti;\t\t/* current bit number rel. to start */\n\txfs_rtblock_t\tlastbit;\t/* last useful bit in word */\n\txfs_rtword_t\tmask;\t\t/* mask of relevant bits for value */\n\txfs_rtword_t\twdiff;\t\t/* difference from wanted value */\n\tint\t\tword;\t\t/* word number in the buffer */\n\n\t/*\n\t * Compute starting bitmap block number\n\t */\n\tblock = XFS_BITTOBLOCK(mp, start);\n\t/*\n\t * Read the bitmap block.\n\t */\n\terror = xfs_rtbuf_get(mp, tp, block, 0, &bp);\n\tif (error) {\n\t\treturn error;\n\t}\n\tbufp = bp->b_addr;\n\t/*\n\t * Compute the starting word's address, and starting bit.\n\t */\n\tword = XFS_BITTOWORD(mp, start);\n\tb = &bufp[word];\n\tbit = (int)(start & (XFS_NBWORD - 1));\n\t/*\n\t * 0 (allocated) => all zero's; 1 (free) => all one's.\n\t */\n\tval = -val;\n\t/*\n\t * If not starting on a word boundary, deal with the first\n\t * (partial) word.\n\t */\n\tif (bit) {\n\t\t/*\n\t\t * Compute first bit not examined.\n\t\t */\n\t\tlastbit = XFS_RTMIN(bit + len, XFS_NBWORD);\n\t\t/*\n\t\t * Mask of relevant bits.\n\t\t */\n\t\tmask = (((xfs_rtword_t)1 << (lastbit - bit)) - 1) << bit;\n\t\t/*\n\t\t * Compute difference between actual and desired value.\n\t\t */\n\t\tif ((wdiff = (*b ^ val) & mask)) {\n\t\t\t/*\n\t\t\t * Different, compute first wrong bit and return.\n\t\t\t */\n\t\t\txfs_trans_brelse(tp, bp);\n\t\t\ti = XFS_RTLOBIT(wdiff) - bit;\n\t\t\t*new = start + i;\n\t\t\t*stat = 0;\n\t\t\treturn 0;\n\t\t}\n\t\ti = lastbit - bit;\n\t\t/*\n\t\t * Go on to next block if that's where the next word is\n\t\t * and we need the next word.\n\t\t */\n\t\tif (++word == XFS_BLOCKWSIZE(mp) && i < len) {\n\t\t\t/*\n\t\t\t * If done with this block, get the next one.\n\t\t\t */\n\t\t\txfs_trans_brelse(tp, bp);\n\t\t\terror = xfs_rtbuf_get(mp, tp, ++block, 0, &bp);\n\t\t\tif (error) {\n\t\t\t\treturn error;\n\t\t\t}\n\t\t\tb = bufp = bp->b_addr;\n\t\t\tword = 0;\n\t\t} else {\n\t\t\t/*\n\t\t\t * Go on to the next word in the buffer.\n\t\t\t */\n\t\t\tb++;\n\t\t}\n\t} else {\n\t\t/*\n\t\t * Starting on a word boundary, no partial word.\n\t\t */\n\t\ti = 0;\n\t}\n\t/*\n\t * Loop over whole words in buffers.  When we use up one buffer\n\t * we move on to the next one.\n\t */\n\twhile (len - i >= XFS_NBWORD) {\n\t\t/*\n\t\t * Compute difference between actual and desired value.\n\t\t */\n\t\tif ((wdiff = *b ^ val)) {\n\t\t\t/*\n\t\t\t * Different, compute first wrong bit and return.\n\t\t\t */\n\t\t\txfs_trans_brelse(tp, bp);\n\t\t\ti += XFS_RTLOBIT(wdiff);\n\t\t\t*new = start + i;\n\t\t\t*stat = 0;\n\t\t\treturn 0;\n\t\t}\n\t\ti += XFS_NBWORD;\n\t\t/*\n\t\t * Go on to next block if that's where the next word is\n\t\t * and we need the next word.\n\t\t */\n\t\tif (++word == XFS_BLOCKWSIZE(mp) && i < len) {\n\t\t\t/*\n\t\t\t * If done with this block, get the next one.\n\t\t\t */\n\t\t\txfs_trans_brelse(tp, bp);\n\t\t\terror = xfs_rtbuf_get(mp, tp, ++block, 0, &bp);\n\t\t\tif (error) {\n\t\t\t\treturn error;\n\t\t\t}\n\t\t\tb = bufp = bp->b_addr;\n\t\t\tword = 0;\n\t\t} else {\n\t\t\t/*\n\t\t\t * Go on to the next word in the buffer.\n\t\t\t */\n\t\t\tb++;\n\t\t}\n\t}\n\t/*\n\t * If not ending on a word boundary, deal with the last\n\t * (partial) word.\n\t */\n\tif ((lastbit = len - i)) {\n\t\t/*\n\t\t * Mask of relevant bits.\n\t\t */\n\t\tmask = ((xfs_rtword_t)1 << lastbit) - 1;\n\t\t/*\n\t\t * Compute difference between actual and desired value.\n\t\t */\n\t\tif ((wdiff = (*b ^ val) & mask)) {\n\t\t\t/*\n\t\t\t * Different, compute first wrong bit and return.\n\t\t\t */\n\t\t\txfs_trans_brelse(tp, bp);\n\t\t\ti += XFS_RTLOBIT(wdiff);\n\t\t\t*new = start + i;\n\t\t\t*stat = 0;\n\t\t\treturn 0;\n\t\t} else\n\t\t\ti = len;\n\t}\n\t/*\n\t * Successful, return.\n\t */\n\txfs_trans_brelse(tp, bp);\n\t*new = start + i;\n\t*stat = 1;\n\treturn 0;\n}",
          "includes": [
            "#include \"xfs_rtalloc.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_buf.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_trans_space.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_rtalloc.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_buf.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_error.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nint\nxfs_rtcheck_range(\n\txfs_mount_t\t*mp,\t\t/* file system mount point */\n\txfs_trans_t\t*tp,\t\t/* transaction pointer */\n\txfs_rtblock_t\tstart,\t\t/* starting block number of extent */\n\txfs_extlen_t\tlen,\t\t/* length of extent */\n\tint\t\tval,\t\t/* 1 for free, 0 for allocated */\n\txfs_rtblock_t\t*new,\t\t/* out: first block not matching */\n\tint\t\t*stat)\t\t/* out: 1 for matches, 0 for not */\n{\n\txfs_rtword_t\t*b;\t\t/* current word in buffer */\n\tint\t\tbit;\t\t/* bit number in the word */\n\txfs_rtblock_t\tblock;\t\t/* bitmap block number */\n\txfs_buf_t\t*bp;\t\t/* buf for the block */\n\txfs_rtword_t\t*bufp;\t\t/* starting word in buffer */\n\tint\t\terror;\t\t/* error value */\n\txfs_rtblock_t\ti;\t\t/* current bit number rel. to start */\n\txfs_rtblock_t\tlastbit;\t/* last useful bit in word */\n\txfs_rtword_t\tmask;\t\t/* mask of relevant bits for value */\n\txfs_rtword_t\twdiff;\t\t/* difference from wanted value */\n\tint\t\tword;\t\t/* word number in the buffer */\n\n\t/*\n\t * Compute starting bitmap block number\n\t */\n\tblock = XFS_BITTOBLOCK(mp, start);\n\t/*\n\t * Read the bitmap block.\n\t */\n\terror = xfs_rtbuf_get(mp, tp, block, 0, &bp);\n\tif (error) {\n\t\treturn error;\n\t}\n\tbufp = bp->b_addr;\n\t/*\n\t * Compute the starting word's address, and starting bit.\n\t */\n\tword = XFS_BITTOWORD(mp, start);\n\tb = &bufp[word];\n\tbit = (int)(start & (XFS_NBWORD - 1));\n\t/*\n\t * 0 (allocated) => all zero's; 1 (free) => all one's.\n\t */\n\tval = -val;\n\t/*\n\t * If not starting on a word boundary, deal with the first\n\t * (partial) word.\n\t */\n\tif (bit) {\n\t\t/*\n\t\t * Compute first bit not examined.\n\t\t */\n\t\tlastbit = XFS_RTMIN(bit + len, XFS_NBWORD);\n\t\t/*\n\t\t * Mask of relevant bits.\n\t\t */\n\t\tmask = (((xfs_rtword_t)1 << (lastbit - bit)) - 1) << bit;\n\t\t/*\n\t\t * Compute difference between actual and desired value.\n\t\t */\n\t\tif ((wdiff = (*b ^ val) & mask)) {\n\t\t\t/*\n\t\t\t * Different, compute first wrong bit and return.\n\t\t\t */\n\t\t\txfs_trans_brelse(tp, bp);\n\t\t\ti = XFS_RTLOBIT(wdiff) - bit;\n\t\t\t*new = start + i;\n\t\t\t*stat = 0;\n\t\t\treturn 0;\n\t\t}\n\t\ti = lastbit - bit;\n\t\t/*\n\t\t * Go on to next block if that's where the next word is\n\t\t * and we need the next word.\n\t\t */\n\t\tif (++word == XFS_BLOCKWSIZE(mp) && i < len) {\n\t\t\t/*\n\t\t\t * If done with this block, get the next one.\n\t\t\t */\n\t\t\txfs_trans_brelse(tp, bp);\n\t\t\terror = xfs_rtbuf_get(mp, tp, ++block, 0, &bp);\n\t\t\tif (error) {\n\t\t\t\treturn error;\n\t\t\t}\n\t\t\tb = bufp = bp->b_addr;\n\t\t\tword = 0;\n\t\t} else {\n\t\t\t/*\n\t\t\t * Go on to the next word in the buffer.\n\t\t\t */\n\t\t\tb++;\n\t\t}\n\t} else {\n\t\t/*\n\t\t * Starting on a word boundary, no partial word.\n\t\t */\n\t\ti = 0;\n\t}\n\t/*\n\t * Loop over whole words in buffers.  When we use up one buffer\n\t * we move on to the next one.\n\t */\n\twhile (len - i >= XFS_NBWORD) {\n\t\t/*\n\t\t * Compute difference between actual and desired value.\n\t\t */\n\t\tif ((wdiff = *b ^ val)) {\n\t\t\t/*\n\t\t\t * Different, compute first wrong bit and return.\n\t\t\t */\n\t\t\txfs_trans_brelse(tp, bp);\n\t\t\ti += XFS_RTLOBIT(wdiff);\n\t\t\t*new = start + i;\n\t\t\t*stat = 0;\n\t\t\treturn 0;\n\t\t}\n\t\ti += XFS_NBWORD;\n\t\t/*\n\t\t * Go on to next block if that's where the next word is\n\t\t * and we need the next word.\n\t\t */\n\t\tif (++word == XFS_BLOCKWSIZE(mp) && i < len) {\n\t\t\t/*\n\t\t\t * If done with this block, get the next one.\n\t\t\t */\n\t\t\txfs_trans_brelse(tp, bp);\n\t\t\terror = xfs_rtbuf_get(mp, tp, ++block, 0, &bp);\n\t\t\tif (error) {\n\t\t\t\treturn error;\n\t\t\t}\n\t\t\tb = bufp = bp->b_addr;\n\t\t\tword = 0;\n\t\t} else {\n\t\t\t/*\n\t\t\t * Go on to the next word in the buffer.\n\t\t\t */\n\t\t\tb++;\n\t\t}\n\t}\n\t/*\n\t * If not ending on a word boundary, deal with the last\n\t * (partial) word.\n\t */\n\tif ((lastbit = len - i)) {\n\t\t/*\n\t\t * Mask of relevant bits.\n\t\t */\n\t\tmask = ((xfs_rtword_t)1 << lastbit) - 1;\n\t\t/*\n\t\t * Compute difference between actual and desired value.\n\t\t */\n\t\tif ((wdiff = (*b ^ val) & mask)) {\n\t\t\t/*\n\t\t\t * Different, compute first wrong bit and return.\n\t\t\t */\n\t\t\txfs_trans_brelse(tp, bp);\n\t\t\ti += XFS_RTLOBIT(wdiff);\n\t\t\t*new = start + i;\n\t\t\t*stat = 0;\n\t\t\treturn 0;\n\t\t} else\n\t\t\ti = len;\n\t}\n\t/*\n\t * Successful, return.\n\t */\n\txfs_trans_brelse(tp, bp);\n\t*new = start + i;\n\t*stat = 1;\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"xfs_rtalloc.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_buf.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_error.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC int\t\t\t\t/* error */\nxfs_rtcheck_alloc_range(\n\txfs_mount_t\t*mp,\t\t/* file system mount point */\n\txfs_trans_t\t*tp,\t\t/* transaction pointer */\n\txfs_rtblock_t\tbno,\t\t/* starting block number of extent */\n\txfs_extlen_t\tlen)\t\t/* length of extent */\n{\n\txfs_rtblock_t\tnew;\t\t/* dummy for xfs_rtcheck_range */\n\tint\t\tstat;\n\tint\t\terror;\n\n\terror = xfs_rtcheck_range(mp, tp, bno, len, 0, &new, &stat);\n\tif (error)\n\t\treturn error;\n\tASSERT(stat);\n\treturn 0;\n}"
  },
  {
    "function_name": "xfs_rtcheck_range",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_rtbitmap.c",
    "lines": "747-917",
    "snippet": "int\nxfs_rtcheck_range(\n\txfs_mount_t\t*mp,\t\t/* file system mount point */\n\txfs_trans_t\t*tp,\t\t/* transaction pointer */\n\txfs_rtblock_t\tstart,\t\t/* starting block number of extent */\n\txfs_extlen_t\tlen,\t\t/* length of extent */\n\tint\t\tval,\t\t/* 1 for free, 0 for allocated */\n\txfs_rtblock_t\t*new,\t\t/* out: first block not matching */\n\tint\t\t*stat)\t\t/* out: 1 for matches, 0 for not */\n{\n\txfs_rtword_t\t*b;\t\t/* current word in buffer */\n\tint\t\tbit;\t\t/* bit number in the word */\n\txfs_rtblock_t\tblock;\t\t/* bitmap block number */\n\txfs_buf_t\t*bp;\t\t/* buf for the block */\n\txfs_rtword_t\t*bufp;\t\t/* starting word in buffer */\n\tint\t\terror;\t\t/* error value */\n\txfs_rtblock_t\ti;\t\t/* current bit number rel. to start */\n\txfs_rtblock_t\tlastbit;\t/* last useful bit in word */\n\txfs_rtword_t\tmask;\t\t/* mask of relevant bits for value */\n\txfs_rtword_t\twdiff;\t\t/* difference from wanted value */\n\tint\t\tword;\t\t/* word number in the buffer */\n\n\t/*\n\t * Compute starting bitmap block number\n\t */\n\tblock = XFS_BITTOBLOCK(mp, start);\n\t/*\n\t * Read the bitmap block.\n\t */\n\terror = xfs_rtbuf_get(mp, tp, block, 0, &bp);\n\tif (error) {\n\t\treturn error;\n\t}\n\tbufp = bp->b_addr;\n\t/*\n\t * Compute the starting word's address, and starting bit.\n\t */\n\tword = XFS_BITTOWORD(mp, start);\n\tb = &bufp[word];\n\tbit = (int)(start & (XFS_NBWORD - 1));\n\t/*\n\t * 0 (allocated) => all zero's; 1 (free) => all one's.\n\t */\n\tval = -val;\n\t/*\n\t * If not starting on a word boundary, deal with the first\n\t * (partial) word.\n\t */\n\tif (bit) {\n\t\t/*\n\t\t * Compute first bit not examined.\n\t\t */\n\t\tlastbit = XFS_RTMIN(bit + len, XFS_NBWORD);\n\t\t/*\n\t\t * Mask of relevant bits.\n\t\t */\n\t\tmask = (((xfs_rtword_t)1 << (lastbit - bit)) - 1) << bit;\n\t\t/*\n\t\t * Compute difference between actual and desired value.\n\t\t */\n\t\tif ((wdiff = (*b ^ val) & mask)) {\n\t\t\t/*\n\t\t\t * Different, compute first wrong bit and return.\n\t\t\t */\n\t\t\txfs_trans_brelse(tp, bp);\n\t\t\ti = XFS_RTLOBIT(wdiff) - bit;\n\t\t\t*new = start + i;\n\t\t\t*stat = 0;\n\t\t\treturn 0;\n\t\t}\n\t\ti = lastbit - bit;\n\t\t/*\n\t\t * Go on to next block if that's where the next word is\n\t\t * and we need the next word.\n\t\t */\n\t\tif (++word == XFS_BLOCKWSIZE(mp) && i < len) {\n\t\t\t/*\n\t\t\t * If done with this block, get the next one.\n\t\t\t */\n\t\t\txfs_trans_brelse(tp, bp);\n\t\t\terror = xfs_rtbuf_get(mp, tp, ++block, 0, &bp);\n\t\t\tif (error) {\n\t\t\t\treturn error;\n\t\t\t}\n\t\t\tb = bufp = bp->b_addr;\n\t\t\tword = 0;\n\t\t} else {\n\t\t\t/*\n\t\t\t * Go on to the next word in the buffer.\n\t\t\t */\n\t\t\tb++;\n\t\t}\n\t} else {\n\t\t/*\n\t\t * Starting on a word boundary, no partial word.\n\t\t */\n\t\ti = 0;\n\t}\n\t/*\n\t * Loop over whole words in buffers.  When we use up one buffer\n\t * we move on to the next one.\n\t */\n\twhile (len - i >= XFS_NBWORD) {\n\t\t/*\n\t\t * Compute difference between actual and desired value.\n\t\t */\n\t\tif ((wdiff = *b ^ val)) {\n\t\t\t/*\n\t\t\t * Different, compute first wrong bit and return.\n\t\t\t */\n\t\t\txfs_trans_brelse(tp, bp);\n\t\t\ti += XFS_RTLOBIT(wdiff);\n\t\t\t*new = start + i;\n\t\t\t*stat = 0;\n\t\t\treturn 0;\n\t\t}\n\t\ti += XFS_NBWORD;\n\t\t/*\n\t\t * Go on to next block if that's where the next word is\n\t\t * and we need the next word.\n\t\t */\n\t\tif (++word == XFS_BLOCKWSIZE(mp) && i < len) {\n\t\t\t/*\n\t\t\t * If done with this block, get the next one.\n\t\t\t */\n\t\t\txfs_trans_brelse(tp, bp);\n\t\t\terror = xfs_rtbuf_get(mp, tp, ++block, 0, &bp);\n\t\t\tif (error) {\n\t\t\t\treturn error;\n\t\t\t}\n\t\t\tb = bufp = bp->b_addr;\n\t\t\tword = 0;\n\t\t} else {\n\t\t\t/*\n\t\t\t * Go on to the next word in the buffer.\n\t\t\t */\n\t\t\tb++;\n\t\t}\n\t}\n\t/*\n\t * If not ending on a word boundary, deal with the last\n\t * (partial) word.\n\t */\n\tif ((lastbit = len - i)) {\n\t\t/*\n\t\t * Mask of relevant bits.\n\t\t */\n\t\tmask = ((xfs_rtword_t)1 << lastbit) - 1;\n\t\t/*\n\t\t * Compute difference between actual and desired value.\n\t\t */\n\t\tif ((wdiff = (*b ^ val) & mask)) {\n\t\t\t/*\n\t\t\t * Different, compute first wrong bit and return.\n\t\t\t */\n\t\t\txfs_trans_brelse(tp, bp);\n\t\t\ti += XFS_RTLOBIT(wdiff);\n\t\t\t*new = start + i;\n\t\t\t*stat = 0;\n\t\t\treturn 0;\n\t\t} else\n\t\t\ti = len;\n\t}\n\t/*\n\t * Successful, return.\n\t */\n\txfs_trans_brelse(tp, bp);\n\t*new = start + i;\n\t*stat = 1;\n\treturn 0;\n}",
    "includes": [
      "#include \"xfs_rtalloc.h\"",
      "#include \"xfs_icache.h\"",
      "#include \"xfs_buf.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_trans_space.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_alloc.h\"",
      "#include \"xfs_bmap_btree.h\"",
      "#include \"xfs_bmap_util.h\"",
      "#include \"xfs_bmap.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_bit.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "xfs_trans_brelse",
          "args": [
            "tp",
            "bp"
          ],
          "line": 913
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_trans_brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_trans_buf.c",
          "lines": "354-443",
          "snippet": "void\nxfs_trans_brelse(xfs_trans_t\t*tp,\n\t\t xfs_buf_t\t*bp)\n{\n\txfs_buf_log_item_t\t*bip;\n\n\t/*\n\t * Default to a normal brelse() call if the tp is NULL.\n\t */\n\tif (tp == NULL) {\n\t\tASSERT(bp->b_transp == NULL);\n\t\txfs_buf_relse(bp);\n\t\treturn;\n\t}\n\n\tASSERT(bp->b_transp == tp);\n\tbip = bp->b_fspriv;\n\tASSERT(bip->bli_item.li_type == XFS_LI_BUF);\n\tASSERT(!(bip->bli_flags & XFS_BLI_STALE));\n\tASSERT(!(bip->__bli_format.blf_flags & XFS_BLF_CANCEL));\n\tASSERT(atomic_read(&bip->bli_refcount) > 0);\n\n\ttrace_xfs_trans_brelse(bip);\n\n\t/*\n\t * If the release is just for a recursive lock,\n\t * then decrement the count and return.\n\t */\n\tif (bip->bli_recur > 0) {\n\t\tbip->bli_recur--;\n\t\treturn;\n\t}\n\n\t/*\n\t * If the buffer is dirty within this transaction, we can't\n\t * release it until we commit.\n\t */\n\tif (bip->bli_item.li_desc->lid_flags & XFS_LID_DIRTY)\n\t\treturn;\n\n\t/*\n\t * If the buffer has been invalidated, then we can't release\n\t * it until the transaction commits to disk unless it is re-dirtied\n\t * as part of this transaction.  This prevents us from pulling\n\t * the item from the AIL before we should.\n\t */\n\tif (bip->bli_flags & XFS_BLI_STALE)\n\t\treturn;\n\n\tASSERT(!(bip->bli_flags & XFS_BLI_LOGGED));\n\n\t/*\n\t * Free up the log item descriptor tracking the released item.\n\t */\n\txfs_trans_del_item(&bip->bli_item);\n\n\t/*\n\t * Clear the hold flag in the buf log item if it is set.\n\t * We wouldn't want the next user of the buffer to\n\t * get confused.\n\t */\n\tif (bip->bli_flags & XFS_BLI_HOLD) {\n\t\tbip->bli_flags &= ~XFS_BLI_HOLD;\n\t}\n\n\t/*\n\t * Drop our reference to the buf log item.\n\t */\n\tatomic_dec(&bip->bli_refcount);\n\n\t/*\n\t * If the buf item is not tracking data in the log, then\n\t * we must free it before releasing the buffer back to the\n\t * free pool.  Before releasing the buffer to the free pool,\n\t * clear the transaction pointer in b_fsprivate2 to dissolve\n\t * its relation to this transaction.\n\t */\n\tif (!xfs_buf_item_dirty(bip)) {\n/***\n\t\tASSERT(bp->b_pincount == 0);\n***/\n\t\tASSERT(atomic_read(&bip->bli_refcount) == 0);\n\t\tASSERT(!(bip->bli_item.li_flags & XFS_LI_IN_AIL));\n\t\tASSERT(!(bip->bli_flags & XFS_BLI_INODE_ALLOC_BUF));\n\t\txfs_buf_item_relse(bp);\n\t}\n\n\tbp->b_transp = NULL;\n\txfs_buf_relse(bp);\n}",
          "includes": [
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nvoid\nxfs_trans_brelse(xfs_trans_t\t*tp,\n\t\t xfs_buf_t\t*bp)\n{\n\txfs_buf_log_item_t\t*bip;\n\n\t/*\n\t * Default to a normal brelse() call if the tp is NULL.\n\t */\n\tif (tp == NULL) {\n\t\tASSERT(bp->b_transp == NULL);\n\t\txfs_buf_relse(bp);\n\t\treturn;\n\t}\n\n\tASSERT(bp->b_transp == tp);\n\tbip = bp->b_fspriv;\n\tASSERT(bip->bli_item.li_type == XFS_LI_BUF);\n\tASSERT(!(bip->bli_flags & XFS_BLI_STALE));\n\tASSERT(!(bip->__bli_format.blf_flags & XFS_BLF_CANCEL));\n\tASSERT(atomic_read(&bip->bli_refcount) > 0);\n\n\ttrace_xfs_trans_brelse(bip);\n\n\t/*\n\t * If the release is just for a recursive lock,\n\t * then decrement the count and return.\n\t */\n\tif (bip->bli_recur > 0) {\n\t\tbip->bli_recur--;\n\t\treturn;\n\t}\n\n\t/*\n\t * If the buffer is dirty within this transaction, we can't\n\t * release it until we commit.\n\t */\n\tif (bip->bli_item.li_desc->lid_flags & XFS_LID_DIRTY)\n\t\treturn;\n\n\t/*\n\t * If the buffer has been invalidated, then we can't release\n\t * it until the transaction commits to disk unless it is re-dirtied\n\t * as part of this transaction.  This prevents us from pulling\n\t * the item from the AIL before we should.\n\t */\n\tif (bip->bli_flags & XFS_BLI_STALE)\n\t\treturn;\n\n\tASSERT(!(bip->bli_flags & XFS_BLI_LOGGED));\n\n\t/*\n\t * Free up the log item descriptor tracking the released item.\n\t */\n\txfs_trans_del_item(&bip->bli_item);\n\n\t/*\n\t * Clear the hold flag in the buf log item if it is set.\n\t * We wouldn't want the next user of the buffer to\n\t * get confused.\n\t */\n\tif (bip->bli_flags & XFS_BLI_HOLD) {\n\t\tbip->bli_flags &= ~XFS_BLI_HOLD;\n\t}\n\n\t/*\n\t * Drop our reference to the buf log item.\n\t */\n\tatomic_dec(&bip->bli_refcount);\n\n\t/*\n\t * If the buf item is not tracking data in the log, then\n\t * we must free it before releasing the buffer back to the\n\t * free pool.  Before releasing the buffer to the free pool,\n\t * clear the transaction pointer in b_fsprivate2 to dissolve\n\t * its relation to this transaction.\n\t */\n\tif (!xfs_buf_item_dirty(bip)) {\n/***\n\t\tASSERT(bp->b_pincount == 0);\n***/\n\t\tASSERT(atomic_read(&bip->bli_refcount) == 0);\n\t\tASSERT(!(bip->bli_item.li_flags & XFS_LI_IN_AIL));\n\t\tASSERT(!(bip->bli_flags & XFS_BLI_INODE_ALLOC_BUF));\n\t\txfs_buf_item_relse(bp);\n\t}\n\n\tbp->b_transp = NULL;\n\txfs_buf_relse(bp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "XFS_RTLOBIT",
          "args": [
            "wdiff"
          ],
          "line": 903
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_rtbuf_get",
          "args": [
            "mp",
            "tp",
            "++block",
            "0",
            "&bp"
          ],
          "line": 873
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_rtbuf_get",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_rtbitmap.c",
          "lines": "48-76",
          "snippet": "int\nxfs_rtbuf_get(\n\txfs_mount_t\t*mp,\t\t/* file system mount structure */\n\txfs_trans_t\t*tp,\t\t/* transaction pointer */\n\txfs_rtblock_t\tblock,\t\t/* block number in bitmap or summary */\n\tint\t\tissum,\t\t/* is summary not bitmap */\n\txfs_buf_t\t**bpp)\t\t/* output: buffer for the block */\n{\n\txfs_buf_t\t*bp;\t\t/* block buffer, result */\n\txfs_inode_t\t*ip;\t\t/* bitmap or summary inode */\n\txfs_bmbt_irec_t\tmap;\n\tint\t\tnmap = 1;\n\tint\t\terror;\t\t/* error value */\n\n\tip = issum ? mp->m_rsumip : mp->m_rbmip;\n\n\terror = xfs_bmapi_read(ip, block, 1, &map, &nmap, XFS_DATA_FORK);\n\tif (error)\n\t\treturn error;\n\n\tASSERT(map.br_startblock != NULLFSBLOCK);\n\terror = xfs_trans_read_buf(mp, tp, mp->m_ddev_targp,\n\t\t\t\t   XFS_FSB_TO_DADDR(mp, map.br_startblock),\n\t\t\t\t   mp->m_bsize, 0, &bp, NULL);\n\tif (error)\n\t\treturn error;\n\t*bpp = bp;\n\treturn 0;\n}",
          "includes": [
            "#include \"xfs_rtalloc.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_buf.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_trans_space.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_rtalloc.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_buf.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_error.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nint\nxfs_rtbuf_get(\n\txfs_mount_t\t*mp,\t\t/* file system mount structure */\n\txfs_trans_t\t*tp,\t\t/* transaction pointer */\n\txfs_rtblock_t\tblock,\t\t/* block number in bitmap or summary */\n\tint\t\tissum,\t\t/* is summary not bitmap */\n\txfs_buf_t\t**bpp)\t\t/* output: buffer for the block */\n{\n\txfs_buf_t\t*bp;\t\t/* block buffer, result */\n\txfs_inode_t\t*ip;\t\t/* bitmap or summary inode */\n\txfs_bmbt_irec_t\tmap;\n\tint\t\tnmap = 1;\n\tint\t\terror;\t\t/* error value */\n\n\tip = issum ? mp->m_rsumip : mp->m_rbmip;\n\n\terror = xfs_bmapi_read(ip, block, 1, &map, &nmap, XFS_DATA_FORK);\n\tif (error)\n\t\treturn error;\n\n\tASSERT(map.br_startblock != NULLFSBLOCK);\n\terror = xfs_trans_read_buf(mp, tp, mp->m_ddev_targp,\n\t\t\t\t   XFS_FSB_TO_DADDR(mp, map.br_startblock),\n\t\t\t\t   mp->m_bsize, 0, &bp, NULL);\n\tif (error)\n\t\treturn error;\n\t*bpp = bp;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "XFS_BLOCKWSIZE",
          "args": [
            "mp"
          ],
          "line": 868
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_RTLOBIT",
          "args": [
            "wdiff"
          ],
          "line": 858
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_BLOCKWSIZE",
          "args": [
            "mp"
          ],
          "line": 822
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_RTLOBIT",
          "args": [
            "wdiff"
          ],
          "line": 812
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_RTMIN",
          "args": [
            "bit + len",
            "XFS_NBWORD"
          ],
          "line": 799
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_BITTOWORD",
          "args": [
            "mp",
            "start"
          ],
          "line": 784
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_BITTOBLOCK",
          "args": [
            "mp",
            "start"
          ],
          "line": 772
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xfs_rtalloc.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_buf.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_error.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nint\nxfs_rtcheck_range(\n\txfs_mount_t\t*mp,\t\t/* file system mount point */\n\txfs_trans_t\t*tp,\t\t/* transaction pointer */\n\txfs_rtblock_t\tstart,\t\t/* starting block number of extent */\n\txfs_extlen_t\tlen,\t\t/* length of extent */\n\tint\t\tval,\t\t/* 1 for free, 0 for allocated */\n\txfs_rtblock_t\t*new,\t\t/* out: first block not matching */\n\tint\t\t*stat)\t\t/* out: 1 for matches, 0 for not */\n{\n\txfs_rtword_t\t*b;\t\t/* current word in buffer */\n\tint\t\tbit;\t\t/* bit number in the word */\n\txfs_rtblock_t\tblock;\t\t/* bitmap block number */\n\txfs_buf_t\t*bp;\t\t/* buf for the block */\n\txfs_rtword_t\t*bufp;\t\t/* starting word in buffer */\n\tint\t\terror;\t\t/* error value */\n\txfs_rtblock_t\ti;\t\t/* current bit number rel. to start */\n\txfs_rtblock_t\tlastbit;\t/* last useful bit in word */\n\txfs_rtword_t\tmask;\t\t/* mask of relevant bits for value */\n\txfs_rtword_t\twdiff;\t\t/* difference from wanted value */\n\tint\t\tword;\t\t/* word number in the buffer */\n\n\t/*\n\t * Compute starting bitmap block number\n\t */\n\tblock = XFS_BITTOBLOCK(mp, start);\n\t/*\n\t * Read the bitmap block.\n\t */\n\terror = xfs_rtbuf_get(mp, tp, block, 0, &bp);\n\tif (error) {\n\t\treturn error;\n\t}\n\tbufp = bp->b_addr;\n\t/*\n\t * Compute the starting word's address, and starting bit.\n\t */\n\tword = XFS_BITTOWORD(mp, start);\n\tb = &bufp[word];\n\tbit = (int)(start & (XFS_NBWORD - 1));\n\t/*\n\t * 0 (allocated) => all zero's; 1 (free) => all one's.\n\t */\n\tval = -val;\n\t/*\n\t * If not starting on a word boundary, deal with the first\n\t * (partial) word.\n\t */\n\tif (bit) {\n\t\t/*\n\t\t * Compute first bit not examined.\n\t\t */\n\t\tlastbit = XFS_RTMIN(bit + len, XFS_NBWORD);\n\t\t/*\n\t\t * Mask of relevant bits.\n\t\t */\n\t\tmask = (((xfs_rtword_t)1 << (lastbit - bit)) - 1) << bit;\n\t\t/*\n\t\t * Compute difference between actual and desired value.\n\t\t */\n\t\tif ((wdiff = (*b ^ val) & mask)) {\n\t\t\t/*\n\t\t\t * Different, compute first wrong bit and return.\n\t\t\t */\n\t\t\txfs_trans_brelse(tp, bp);\n\t\t\ti = XFS_RTLOBIT(wdiff) - bit;\n\t\t\t*new = start + i;\n\t\t\t*stat = 0;\n\t\t\treturn 0;\n\t\t}\n\t\ti = lastbit - bit;\n\t\t/*\n\t\t * Go on to next block if that's where the next word is\n\t\t * and we need the next word.\n\t\t */\n\t\tif (++word == XFS_BLOCKWSIZE(mp) && i < len) {\n\t\t\t/*\n\t\t\t * If done with this block, get the next one.\n\t\t\t */\n\t\t\txfs_trans_brelse(tp, bp);\n\t\t\terror = xfs_rtbuf_get(mp, tp, ++block, 0, &bp);\n\t\t\tif (error) {\n\t\t\t\treturn error;\n\t\t\t}\n\t\t\tb = bufp = bp->b_addr;\n\t\t\tword = 0;\n\t\t} else {\n\t\t\t/*\n\t\t\t * Go on to the next word in the buffer.\n\t\t\t */\n\t\t\tb++;\n\t\t}\n\t} else {\n\t\t/*\n\t\t * Starting on a word boundary, no partial word.\n\t\t */\n\t\ti = 0;\n\t}\n\t/*\n\t * Loop over whole words in buffers.  When we use up one buffer\n\t * we move on to the next one.\n\t */\n\twhile (len - i >= XFS_NBWORD) {\n\t\t/*\n\t\t * Compute difference between actual and desired value.\n\t\t */\n\t\tif ((wdiff = *b ^ val)) {\n\t\t\t/*\n\t\t\t * Different, compute first wrong bit and return.\n\t\t\t */\n\t\t\txfs_trans_brelse(tp, bp);\n\t\t\ti += XFS_RTLOBIT(wdiff);\n\t\t\t*new = start + i;\n\t\t\t*stat = 0;\n\t\t\treturn 0;\n\t\t}\n\t\ti += XFS_NBWORD;\n\t\t/*\n\t\t * Go on to next block if that's where the next word is\n\t\t * and we need the next word.\n\t\t */\n\t\tif (++word == XFS_BLOCKWSIZE(mp) && i < len) {\n\t\t\t/*\n\t\t\t * If done with this block, get the next one.\n\t\t\t */\n\t\t\txfs_trans_brelse(tp, bp);\n\t\t\terror = xfs_rtbuf_get(mp, tp, ++block, 0, &bp);\n\t\t\tif (error) {\n\t\t\t\treturn error;\n\t\t\t}\n\t\t\tb = bufp = bp->b_addr;\n\t\t\tword = 0;\n\t\t} else {\n\t\t\t/*\n\t\t\t * Go on to the next word in the buffer.\n\t\t\t */\n\t\t\tb++;\n\t\t}\n\t}\n\t/*\n\t * If not ending on a word boundary, deal with the last\n\t * (partial) word.\n\t */\n\tif ((lastbit = len - i)) {\n\t\t/*\n\t\t * Mask of relevant bits.\n\t\t */\n\t\tmask = ((xfs_rtword_t)1 << lastbit) - 1;\n\t\t/*\n\t\t * Compute difference between actual and desired value.\n\t\t */\n\t\tif ((wdiff = (*b ^ val) & mask)) {\n\t\t\t/*\n\t\t\t * Different, compute first wrong bit and return.\n\t\t\t */\n\t\t\txfs_trans_brelse(tp, bp);\n\t\t\ti += XFS_RTLOBIT(wdiff);\n\t\t\t*new = start + i;\n\t\t\t*stat = 0;\n\t\t\treturn 0;\n\t\t} else\n\t\t\ti = len;\n\t}\n\t/*\n\t * Successful, return.\n\t */\n\txfs_trans_brelse(tp, bp);\n\t*new = start + i;\n\t*stat = 1;\n\treturn 0;\n}"
  },
  {
    "function_name": "xfs_rtfree_range",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_rtbitmap.c",
    "lines": "671-741",
    "snippet": "int\nxfs_rtfree_range(\n\txfs_mount_t\t*mp,\t\t/* file system mount point */\n\txfs_trans_t\t*tp,\t\t/* transaction pointer */\n\txfs_rtblock_t\tstart,\t\t/* starting block to free */\n\txfs_extlen_t\tlen,\t\t/* length to free */\n\txfs_buf_t\t**rbpp,\t\t/* in/out: summary block buffer */\n\txfs_fsblock_t\t*rsb)\t\t/* in/out: summary block number */\n{\n\txfs_rtblock_t\tend;\t\t/* end of the freed extent */\n\tint\t\terror;\t\t/* error value */\n\txfs_rtblock_t\tpostblock;\t/* first block freed > end */\n\txfs_rtblock_t\tpreblock;\t/* first block freed < start */\n\n\tend = start + len - 1;\n\t/*\n\t * Modify the bitmap to mark this extent freed.\n\t */\n\terror = xfs_rtmodify_range(mp, tp, start, len, 1);\n\tif (error) {\n\t\treturn error;\n\t}\n\t/*\n\t * Assume we're freeing out of the middle of an allocated extent.\n\t * We need to find the beginning and end of the extent so we can\n\t * properly update the summary.\n\t */\n\terror = xfs_rtfind_back(mp, tp, start, 0, &preblock);\n\tif (error) {\n\t\treturn error;\n\t}\n\t/*\n\t * Find the next allocated block (end of allocated extent).\n\t */\n\terror = xfs_rtfind_forw(mp, tp, end, mp->m_sb.sb_rextents - 1,\n\t\t&postblock);\n\tif (error)\n\t\treturn error;\n\t/*\n\t * If there are blocks not being freed at the front of the\n\t * old extent, add summary data for them to be allocated.\n\t */\n\tif (preblock < start) {\n\t\terror = xfs_rtmodify_summary(mp, tp,\n\t\t\tXFS_RTBLOCKLOG(start - preblock),\n\t\t\tXFS_BITTOBLOCK(mp, preblock), -1, rbpp, rsb);\n\t\tif (error) {\n\t\t\treturn error;\n\t\t}\n\t}\n\t/*\n\t * If there are blocks not being freed at the end of the\n\t * old extent, add summary data for them to be allocated.\n\t */\n\tif (postblock > end) {\n\t\terror = xfs_rtmodify_summary(mp, tp,\n\t\t\tXFS_RTBLOCKLOG(postblock - end),\n\t\t\tXFS_BITTOBLOCK(mp, end + 1), -1, rbpp, rsb);\n\t\tif (error) {\n\t\t\treturn error;\n\t\t}\n\t}\n\t/*\n\t * Increment the summary information corresponding to the entire\n\t * (new) free extent.\n\t */\n\terror = xfs_rtmodify_summary(mp, tp,\n\t\tXFS_RTBLOCKLOG(postblock + 1 - preblock),\n\t\tXFS_BITTOBLOCK(mp, preblock), 1, rbpp, rsb);\n\treturn error;\n}",
    "includes": [
      "#include \"xfs_rtalloc.h\"",
      "#include \"xfs_icache.h\"",
      "#include \"xfs_buf.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_trans_space.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_alloc.h\"",
      "#include \"xfs_bmap_btree.h\"",
      "#include \"xfs_bmap_util.h\"",
      "#include \"xfs_bmap.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_bit.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "xfs_rtmodify_summary",
          "args": [
            "mp",
            "tp",
            "XFS_RTBLOCKLOG(postblock + 1 - preblock)",
            "XFS_BITTOBLOCK(mp, preblock)",
            "1",
            "rbpp",
            "rsb"
          ],
          "line": 737
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_rtmodify_summary",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_rtbitmap.c",
          "lines": "496-508",
          "snippet": "int\nxfs_rtmodify_summary(\n\txfs_mount_t\t*mp,\t\t/* file system mount structure */\n\txfs_trans_t\t*tp,\t\t/* transaction pointer */\n\tint\t\tlog,\t\t/* log2 of extent size */\n\txfs_rtblock_t\tbbno,\t\t/* bitmap block number */\n\tint\t\tdelta,\t\t/* change to make to summary info */\n\txfs_buf_t\t**rbpp,\t\t/* in/out: summary block buffer */\n\txfs_fsblock_t\t*rsb)\t\t/* in/out: summary block number */\n{\n\treturn xfs_rtmodify_summary_int(mp, tp, log, bbno,\n\t\t\t\t\tdelta, rbpp, rsb, NULL);\n}",
          "includes": [
            "#include \"xfs_rtalloc.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_buf.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_trans_space.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_rtalloc.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_buf.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_error.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nint\nxfs_rtmodify_summary(\n\txfs_mount_t\t*mp,\t\t/* file system mount structure */\n\txfs_trans_t\t*tp,\t\t/* transaction pointer */\n\tint\t\tlog,\t\t/* log2 of extent size */\n\txfs_rtblock_t\tbbno,\t\t/* bitmap block number */\n\tint\t\tdelta,\t\t/* change to make to summary info */\n\txfs_buf_t\t**rbpp,\t\t/* in/out: summary block buffer */\n\txfs_fsblock_t\t*rsb)\t\t/* in/out: summary block number */\n{\n\treturn xfs_rtmodify_summary_int(mp, tp, log, bbno,\n\t\t\t\t\tdelta, rbpp, rsb, NULL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "XFS_BITTOBLOCK",
          "args": [
            "mp",
            "preblock"
          ],
          "line": 739
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_RTBLOCKLOG",
          "args": [
            "postblock + 1 - preblock"
          ],
          "line": 738
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_BITTOBLOCK",
          "args": [
            "mp",
            "end + 1"
          ],
          "line": 728
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_RTBLOCKLOG",
          "args": [
            "postblock - end"
          ],
          "line": 727
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_BITTOBLOCK",
          "args": [
            "mp",
            "preblock"
          ],
          "line": 716
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_RTBLOCKLOG",
          "args": [
            "start - preblock"
          ],
          "line": 715
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_rtfind_forw",
          "args": [
            "mp",
            "tp",
            "end",
            "mp->m_sb.sb_rextents - 1",
            "&postblock"
          ],
          "line": 705
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_rtfind_forw",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_rtbitmap.c",
          "lines": "257-421",
          "snippet": "int\nxfs_rtfind_forw(\n\txfs_mount_t\t*mp,\t\t/* file system mount point */\n\txfs_trans_t\t*tp,\t\t/* transaction pointer */\n\txfs_rtblock_t\tstart,\t\t/* starting block to look at */\n\txfs_rtblock_t\tlimit,\t\t/* last block to look at */\n\txfs_rtblock_t\t*rtblock)\t/* out: start block found */\n{\n\txfs_rtword_t\t*b;\t\t/* current word in buffer */\n\tint\t\tbit;\t\t/* bit number in the word */\n\txfs_rtblock_t\tblock;\t\t/* bitmap block number */\n\txfs_buf_t\t*bp;\t\t/* buf for the block */\n\txfs_rtword_t\t*bufp;\t\t/* starting word in buffer */\n\tint\t\terror;\t\t/* error value */\n\txfs_rtblock_t\ti;\t\t/* current bit number rel. to start */\n\txfs_rtblock_t\tlastbit;\t/* last useful bit in the word */\n\txfs_rtblock_t\tlen;\t\t/* length of inspected area */\n\txfs_rtword_t\tmask;\t\t/* mask of relevant bits for value */\n\txfs_rtword_t\twant;\t\t/* mask for \"good\" values */\n\txfs_rtword_t\twdiff;\t\t/* difference from wanted value */\n\tint\t\tword;\t\t/* word number in the buffer */\n\n\t/*\n\t * Compute and read in starting bitmap block for starting block.\n\t */\n\tblock = XFS_BITTOBLOCK(mp, start);\n\terror = xfs_rtbuf_get(mp, tp, block, 0, &bp);\n\tif (error) {\n\t\treturn error;\n\t}\n\tbufp = bp->b_addr;\n\t/*\n\t * Get the first word's index & point to it.\n\t */\n\tword = XFS_BITTOWORD(mp, start);\n\tb = &bufp[word];\n\tbit = (int)(start & (XFS_NBWORD - 1));\n\tlen = limit - start + 1;\n\t/*\n\t * Compute match value, based on the bit at start: if 1 (free)\n\t * then all-ones, else all-zeroes.\n\t */\n\twant = (*b & ((xfs_rtword_t)1 << bit)) ? -1 : 0;\n\t/*\n\t * If the starting position is not word-aligned, deal with the\n\t * partial word.\n\t */\n\tif (bit) {\n\t\t/*\n\t\t * Calculate last (rightmost) bit number to look at,\n\t\t * and mask for all the relevant bits in this word.\n\t\t */\n\t\tlastbit = XFS_RTMIN(bit + len, XFS_NBWORD);\n\t\tmask = (((xfs_rtword_t)1 << (lastbit - bit)) - 1) << bit;\n\t\t/*\n\t\t * Calculate the difference between the value there\n\t\t * and what we're looking for.\n\t\t */\n\t\tif ((wdiff = (*b ^ want) & mask)) {\n\t\t\t/*\n\t\t\t * Different.  Mark where we are and return.\n\t\t\t */\n\t\t\txfs_trans_brelse(tp, bp);\n\t\t\ti = XFS_RTLOBIT(wdiff) - bit;\n\t\t\t*rtblock = start + i - 1;\n\t\t\treturn 0;\n\t\t}\n\t\ti = lastbit - bit;\n\t\t/*\n\t\t * Go on to next block if that's where the next word is\n\t\t * and we need the next word.\n\t\t */\n\t\tif (++word == XFS_BLOCKWSIZE(mp) && i < len) {\n\t\t\t/*\n\t\t\t * If done with this block, get the previous one.\n\t\t\t */\n\t\t\txfs_trans_brelse(tp, bp);\n\t\t\terror = xfs_rtbuf_get(mp, tp, ++block, 0, &bp);\n\t\t\tif (error) {\n\t\t\t\treturn error;\n\t\t\t}\n\t\t\tb = bufp = bp->b_addr;\n\t\t\tword = 0;\n\t\t} else {\n\t\t\t/*\n\t\t\t * Go on to the previous word in the buffer.\n\t\t\t */\n\t\t\tb++;\n\t\t}\n\t} else {\n\t\t/*\n\t\t * Starting on a word boundary, no partial word.\n\t\t */\n\t\ti = 0;\n\t}\n\t/*\n\t * Loop over whole words in buffers.  When we use up one buffer\n\t * we move on to the next one.\n\t */\n\twhile (len - i >= XFS_NBWORD) {\n\t\t/*\n\t\t * Compute difference between actual and desired value.\n\t\t */\n\t\tif ((wdiff = *b ^ want)) {\n\t\t\t/*\n\t\t\t * Different, mark where we are and return.\n\t\t\t */\n\t\t\txfs_trans_brelse(tp, bp);\n\t\t\ti += XFS_RTLOBIT(wdiff);\n\t\t\t*rtblock = start + i - 1;\n\t\t\treturn 0;\n\t\t}\n\t\ti += XFS_NBWORD;\n\t\t/*\n\t\t * Go on to next block if that's where the next word is\n\t\t * and we need the next word.\n\t\t */\n\t\tif (++word == XFS_BLOCKWSIZE(mp) && i < len) {\n\t\t\t/*\n\t\t\t * If done with this block, get the next one.\n\t\t\t */\n\t\t\txfs_trans_brelse(tp, bp);\n\t\t\terror = xfs_rtbuf_get(mp, tp, ++block, 0, &bp);\n\t\t\tif (error) {\n\t\t\t\treturn error;\n\t\t\t}\n\t\t\tb = bufp = bp->b_addr;\n\t\t\tword = 0;\n\t\t} else {\n\t\t\t/*\n\t\t\t * Go on to the next word in the buffer.\n\t\t\t */\n\t\t\tb++;\n\t\t}\n\t}\n\t/*\n\t * If not ending on a word boundary, deal with the last\n\t * (partial) word.\n\t */\n\tif ((lastbit = len - i)) {\n\t\t/*\n\t\t * Calculate mask for all the relevant bits in this word.\n\t\t */\n\t\tmask = ((xfs_rtword_t)1 << lastbit) - 1;\n\t\t/*\n\t\t * Compute difference between actual and desired value.\n\t\t */\n\t\tif ((wdiff = (*b ^ want) & mask)) {\n\t\t\t/*\n\t\t\t * Different, mark where we are and return.\n\t\t\t */\n\t\t\txfs_trans_brelse(tp, bp);\n\t\t\ti += XFS_RTLOBIT(wdiff);\n\t\t\t*rtblock = start + i - 1;\n\t\t\treturn 0;\n\t\t} else\n\t\t\ti = len;\n\t}\n\t/*\n\t * No match, return that we scanned the whole area.\n\t */\n\txfs_trans_brelse(tp, bp);\n\t*rtblock = start + i - 1;\n\treturn 0;\n}",
          "includes": [
            "#include \"xfs_rtalloc.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_buf.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_trans_space.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_rtalloc.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_buf.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_error.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nint\nxfs_rtfind_forw(\n\txfs_mount_t\t*mp,\t\t/* file system mount point */\n\txfs_trans_t\t*tp,\t\t/* transaction pointer */\n\txfs_rtblock_t\tstart,\t\t/* starting block to look at */\n\txfs_rtblock_t\tlimit,\t\t/* last block to look at */\n\txfs_rtblock_t\t*rtblock)\t/* out: start block found */\n{\n\txfs_rtword_t\t*b;\t\t/* current word in buffer */\n\tint\t\tbit;\t\t/* bit number in the word */\n\txfs_rtblock_t\tblock;\t\t/* bitmap block number */\n\txfs_buf_t\t*bp;\t\t/* buf for the block */\n\txfs_rtword_t\t*bufp;\t\t/* starting word in buffer */\n\tint\t\terror;\t\t/* error value */\n\txfs_rtblock_t\ti;\t\t/* current bit number rel. to start */\n\txfs_rtblock_t\tlastbit;\t/* last useful bit in the word */\n\txfs_rtblock_t\tlen;\t\t/* length of inspected area */\n\txfs_rtword_t\tmask;\t\t/* mask of relevant bits for value */\n\txfs_rtword_t\twant;\t\t/* mask for \"good\" values */\n\txfs_rtword_t\twdiff;\t\t/* difference from wanted value */\n\tint\t\tword;\t\t/* word number in the buffer */\n\n\t/*\n\t * Compute and read in starting bitmap block for starting block.\n\t */\n\tblock = XFS_BITTOBLOCK(mp, start);\n\terror = xfs_rtbuf_get(mp, tp, block, 0, &bp);\n\tif (error) {\n\t\treturn error;\n\t}\n\tbufp = bp->b_addr;\n\t/*\n\t * Get the first word's index & point to it.\n\t */\n\tword = XFS_BITTOWORD(mp, start);\n\tb = &bufp[word];\n\tbit = (int)(start & (XFS_NBWORD - 1));\n\tlen = limit - start + 1;\n\t/*\n\t * Compute match value, based on the bit at start: if 1 (free)\n\t * then all-ones, else all-zeroes.\n\t */\n\twant = (*b & ((xfs_rtword_t)1 << bit)) ? -1 : 0;\n\t/*\n\t * If the starting position is not word-aligned, deal with the\n\t * partial word.\n\t */\n\tif (bit) {\n\t\t/*\n\t\t * Calculate last (rightmost) bit number to look at,\n\t\t * and mask for all the relevant bits in this word.\n\t\t */\n\t\tlastbit = XFS_RTMIN(bit + len, XFS_NBWORD);\n\t\tmask = (((xfs_rtword_t)1 << (lastbit - bit)) - 1) << bit;\n\t\t/*\n\t\t * Calculate the difference between the value there\n\t\t * and what we're looking for.\n\t\t */\n\t\tif ((wdiff = (*b ^ want) & mask)) {\n\t\t\t/*\n\t\t\t * Different.  Mark where we are and return.\n\t\t\t */\n\t\t\txfs_trans_brelse(tp, bp);\n\t\t\ti = XFS_RTLOBIT(wdiff) - bit;\n\t\t\t*rtblock = start + i - 1;\n\t\t\treturn 0;\n\t\t}\n\t\ti = lastbit - bit;\n\t\t/*\n\t\t * Go on to next block if that's where the next word is\n\t\t * and we need the next word.\n\t\t */\n\t\tif (++word == XFS_BLOCKWSIZE(mp) && i < len) {\n\t\t\t/*\n\t\t\t * If done with this block, get the previous one.\n\t\t\t */\n\t\t\txfs_trans_brelse(tp, bp);\n\t\t\terror = xfs_rtbuf_get(mp, tp, ++block, 0, &bp);\n\t\t\tif (error) {\n\t\t\t\treturn error;\n\t\t\t}\n\t\t\tb = bufp = bp->b_addr;\n\t\t\tword = 0;\n\t\t} else {\n\t\t\t/*\n\t\t\t * Go on to the previous word in the buffer.\n\t\t\t */\n\t\t\tb++;\n\t\t}\n\t} else {\n\t\t/*\n\t\t * Starting on a word boundary, no partial word.\n\t\t */\n\t\ti = 0;\n\t}\n\t/*\n\t * Loop over whole words in buffers.  When we use up one buffer\n\t * we move on to the next one.\n\t */\n\twhile (len - i >= XFS_NBWORD) {\n\t\t/*\n\t\t * Compute difference between actual and desired value.\n\t\t */\n\t\tif ((wdiff = *b ^ want)) {\n\t\t\t/*\n\t\t\t * Different, mark where we are and return.\n\t\t\t */\n\t\t\txfs_trans_brelse(tp, bp);\n\t\t\ti += XFS_RTLOBIT(wdiff);\n\t\t\t*rtblock = start + i - 1;\n\t\t\treturn 0;\n\t\t}\n\t\ti += XFS_NBWORD;\n\t\t/*\n\t\t * Go on to next block if that's where the next word is\n\t\t * and we need the next word.\n\t\t */\n\t\tif (++word == XFS_BLOCKWSIZE(mp) && i < len) {\n\t\t\t/*\n\t\t\t * If done with this block, get the next one.\n\t\t\t */\n\t\t\txfs_trans_brelse(tp, bp);\n\t\t\terror = xfs_rtbuf_get(mp, tp, ++block, 0, &bp);\n\t\t\tif (error) {\n\t\t\t\treturn error;\n\t\t\t}\n\t\t\tb = bufp = bp->b_addr;\n\t\t\tword = 0;\n\t\t} else {\n\t\t\t/*\n\t\t\t * Go on to the next word in the buffer.\n\t\t\t */\n\t\t\tb++;\n\t\t}\n\t}\n\t/*\n\t * If not ending on a word boundary, deal with the last\n\t * (partial) word.\n\t */\n\tif ((lastbit = len - i)) {\n\t\t/*\n\t\t * Calculate mask for all the relevant bits in this word.\n\t\t */\n\t\tmask = ((xfs_rtword_t)1 << lastbit) - 1;\n\t\t/*\n\t\t * Compute difference between actual and desired value.\n\t\t */\n\t\tif ((wdiff = (*b ^ want) & mask)) {\n\t\t\t/*\n\t\t\t * Different, mark where we are and return.\n\t\t\t */\n\t\t\txfs_trans_brelse(tp, bp);\n\t\t\ti += XFS_RTLOBIT(wdiff);\n\t\t\t*rtblock = start + i - 1;\n\t\t\treturn 0;\n\t\t} else\n\t\t\ti = len;\n\t}\n\t/*\n\t * No match, return that we scanned the whole area.\n\t */\n\txfs_trans_brelse(tp, bp);\n\t*rtblock = start + i - 1;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_rtfind_back",
          "args": [
            "mp",
            "tp",
            "start",
            "0",
            "&preblock"
          ],
          "line": 698
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_rtfind_back",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_rtbitmap.c",
          "lines": "82-251",
          "snippet": "int\nxfs_rtfind_back(\n\txfs_mount_t\t*mp,\t\t/* file system mount point */\n\txfs_trans_t\t*tp,\t\t/* transaction pointer */\n\txfs_rtblock_t\tstart,\t\t/* starting block to look at */\n\txfs_rtblock_t\tlimit,\t\t/* last block to look at */\n\txfs_rtblock_t\t*rtblock)\t/* out: start block found */\n{\n\txfs_rtword_t\t*b;\t\t/* current word in buffer */\n\tint\t\tbit;\t\t/* bit number in the word */\n\txfs_rtblock_t\tblock;\t\t/* bitmap block number */\n\txfs_buf_t\t*bp;\t\t/* buf for the block */\n\txfs_rtword_t\t*bufp;\t\t/* starting word in buffer */\n\tint\t\terror;\t\t/* error value */\n\txfs_rtblock_t\tfirstbit;\t/* first useful bit in the word */\n\txfs_rtblock_t\ti;\t\t/* current bit number rel. to start */\n\txfs_rtblock_t\tlen;\t\t/* length of inspected area */\n\txfs_rtword_t\tmask;\t\t/* mask of relevant bits for value */\n\txfs_rtword_t\twant;\t\t/* mask for \"good\" values */\n\txfs_rtword_t\twdiff;\t\t/* difference from wanted value */\n\tint\t\tword;\t\t/* word number in the buffer */\n\n\t/*\n\t * Compute and read in starting bitmap block for starting block.\n\t */\n\tblock = XFS_BITTOBLOCK(mp, start);\n\terror = xfs_rtbuf_get(mp, tp, block, 0, &bp);\n\tif (error) {\n\t\treturn error;\n\t}\n\tbufp = bp->b_addr;\n\t/*\n\t * Get the first word's index & point to it.\n\t */\n\tword = XFS_BITTOWORD(mp, start);\n\tb = &bufp[word];\n\tbit = (int)(start & (XFS_NBWORD - 1));\n\tlen = start - limit + 1;\n\t/*\n\t * Compute match value, based on the bit at start: if 1 (free)\n\t * then all-ones, else all-zeroes.\n\t */\n\twant = (*b & ((xfs_rtword_t)1 << bit)) ? -1 : 0;\n\t/*\n\t * If the starting position is not word-aligned, deal with the\n\t * partial word.\n\t */\n\tif (bit < XFS_NBWORD - 1) {\n\t\t/*\n\t\t * Calculate first (leftmost) bit number to look at,\n\t\t * and mask for all the relevant bits in this word.\n\t\t */\n\t\tfirstbit = XFS_RTMAX((xfs_srtblock_t)(bit - len + 1), 0);\n\t\tmask = (((xfs_rtword_t)1 << (bit - firstbit + 1)) - 1) <<\n\t\t\tfirstbit;\n\t\t/*\n\t\t * Calculate the difference between the value there\n\t\t * and what we're looking for.\n\t\t */\n\t\tif ((wdiff = (*b ^ want) & mask)) {\n\t\t\t/*\n\t\t\t * Different.  Mark where we are and return.\n\t\t\t */\n\t\t\txfs_trans_brelse(tp, bp);\n\t\t\ti = bit - XFS_RTHIBIT(wdiff);\n\t\t\t*rtblock = start - i + 1;\n\t\t\treturn 0;\n\t\t}\n\t\ti = bit - firstbit + 1;\n\t\t/*\n\t\t * Go on to previous block if that's where the previous word is\n\t\t * and we need the previous word.\n\t\t */\n\t\tif (--word == -1 && i < len) {\n\t\t\t/*\n\t\t\t * If done with this block, get the previous one.\n\t\t\t */\n\t\t\txfs_trans_brelse(tp, bp);\n\t\t\terror = xfs_rtbuf_get(mp, tp, --block, 0, &bp);\n\t\t\tif (error) {\n\t\t\t\treturn error;\n\t\t\t}\n\t\t\tbufp = bp->b_addr;\n\t\t\tword = XFS_BLOCKWMASK(mp);\n\t\t\tb = &bufp[word];\n\t\t} else {\n\t\t\t/*\n\t\t\t * Go on to the previous word in the buffer.\n\t\t\t */\n\t\t\tb--;\n\t\t}\n\t} else {\n\t\t/*\n\t\t * Starting on a word boundary, no partial word.\n\t\t */\n\t\ti = 0;\n\t}\n\t/*\n\t * Loop over whole words in buffers.  When we use up one buffer\n\t * we move on to the previous one.\n\t */\n\twhile (len - i >= XFS_NBWORD) {\n\t\t/*\n\t\t * Compute difference between actual and desired value.\n\t\t */\n\t\tif ((wdiff = *b ^ want)) {\n\t\t\t/*\n\t\t\t * Different, mark where we are and return.\n\t\t\t */\n\t\t\txfs_trans_brelse(tp, bp);\n\t\t\ti += XFS_NBWORD - 1 - XFS_RTHIBIT(wdiff);\n\t\t\t*rtblock = start - i + 1;\n\t\t\treturn 0;\n\t\t}\n\t\ti += XFS_NBWORD;\n\t\t/*\n\t\t * Go on to previous block if that's where the previous word is\n\t\t * and we need the previous word.\n\t\t */\n\t\tif (--word == -1 && i < len) {\n\t\t\t/*\n\t\t\t * If done with this block, get the previous one.\n\t\t\t */\n\t\t\txfs_trans_brelse(tp, bp);\n\t\t\terror = xfs_rtbuf_get(mp, tp, --block, 0, &bp);\n\t\t\tif (error) {\n\t\t\t\treturn error;\n\t\t\t}\n\t\t\tbufp = bp->b_addr;\n\t\t\tword = XFS_BLOCKWMASK(mp);\n\t\t\tb = &bufp[word];\n\t\t} else {\n\t\t\t/*\n\t\t\t * Go on to the previous word in the buffer.\n\t\t\t */\n\t\t\tb--;\n\t\t}\n\t}\n\t/*\n\t * If not ending on a word boundary, deal with the last\n\t * (partial) word.\n\t */\n\tif (len - i) {\n\t\t/*\n\t\t * Calculate first (leftmost) bit number to look at,\n\t\t * and mask for all the relevant bits in this word.\n\t\t */\n\t\tfirstbit = XFS_NBWORD - (len - i);\n\t\tmask = (((xfs_rtword_t)1 << (len - i)) - 1) << firstbit;\n\t\t/*\n\t\t * Compute difference between actual and desired value.\n\t\t */\n\t\tif ((wdiff = (*b ^ want) & mask)) {\n\t\t\t/*\n\t\t\t * Different, mark where we are and return.\n\t\t\t */\n\t\t\txfs_trans_brelse(tp, bp);\n\t\t\ti += XFS_NBWORD - 1 - XFS_RTHIBIT(wdiff);\n\t\t\t*rtblock = start - i + 1;\n\t\t\treturn 0;\n\t\t} else\n\t\t\ti = len;\n\t}\n\t/*\n\t * No match, return that we scanned the whole area.\n\t */\n\txfs_trans_brelse(tp, bp);\n\t*rtblock = start - i + 1;\n\treturn 0;\n}",
          "includes": [
            "#include \"xfs_rtalloc.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_buf.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_trans_space.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_rtalloc.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_buf.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_error.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nint\nxfs_rtfind_back(\n\txfs_mount_t\t*mp,\t\t/* file system mount point */\n\txfs_trans_t\t*tp,\t\t/* transaction pointer */\n\txfs_rtblock_t\tstart,\t\t/* starting block to look at */\n\txfs_rtblock_t\tlimit,\t\t/* last block to look at */\n\txfs_rtblock_t\t*rtblock)\t/* out: start block found */\n{\n\txfs_rtword_t\t*b;\t\t/* current word in buffer */\n\tint\t\tbit;\t\t/* bit number in the word */\n\txfs_rtblock_t\tblock;\t\t/* bitmap block number */\n\txfs_buf_t\t*bp;\t\t/* buf for the block */\n\txfs_rtword_t\t*bufp;\t\t/* starting word in buffer */\n\tint\t\terror;\t\t/* error value */\n\txfs_rtblock_t\tfirstbit;\t/* first useful bit in the word */\n\txfs_rtblock_t\ti;\t\t/* current bit number rel. to start */\n\txfs_rtblock_t\tlen;\t\t/* length of inspected area */\n\txfs_rtword_t\tmask;\t\t/* mask of relevant bits for value */\n\txfs_rtword_t\twant;\t\t/* mask for \"good\" values */\n\txfs_rtword_t\twdiff;\t\t/* difference from wanted value */\n\tint\t\tword;\t\t/* word number in the buffer */\n\n\t/*\n\t * Compute and read in starting bitmap block for starting block.\n\t */\n\tblock = XFS_BITTOBLOCK(mp, start);\n\terror = xfs_rtbuf_get(mp, tp, block, 0, &bp);\n\tif (error) {\n\t\treturn error;\n\t}\n\tbufp = bp->b_addr;\n\t/*\n\t * Get the first word's index & point to it.\n\t */\n\tword = XFS_BITTOWORD(mp, start);\n\tb = &bufp[word];\n\tbit = (int)(start & (XFS_NBWORD - 1));\n\tlen = start - limit + 1;\n\t/*\n\t * Compute match value, based on the bit at start: if 1 (free)\n\t * then all-ones, else all-zeroes.\n\t */\n\twant = (*b & ((xfs_rtword_t)1 << bit)) ? -1 : 0;\n\t/*\n\t * If the starting position is not word-aligned, deal with the\n\t * partial word.\n\t */\n\tif (bit < XFS_NBWORD - 1) {\n\t\t/*\n\t\t * Calculate first (leftmost) bit number to look at,\n\t\t * and mask for all the relevant bits in this word.\n\t\t */\n\t\tfirstbit = XFS_RTMAX((xfs_srtblock_t)(bit - len + 1), 0);\n\t\tmask = (((xfs_rtword_t)1 << (bit - firstbit + 1)) - 1) <<\n\t\t\tfirstbit;\n\t\t/*\n\t\t * Calculate the difference between the value there\n\t\t * and what we're looking for.\n\t\t */\n\t\tif ((wdiff = (*b ^ want) & mask)) {\n\t\t\t/*\n\t\t\t * Different.  Mark where we are and return.\n\t\t\t */\n\t\t\txfs_trans_brelse(tp, bp);\n\t\t\ti = bit - XFS_RTHIBIT(wdiff);\n\t\t\t*rtblock = start - i + 1;\n\t\t\treturn 0;\n\t\t}\n\t\ti = bit - firstbit + 1;\n\t\t/*\n\t\t * Go on to previous block if that's where the previous word is\n\t\t * and we need the previous word.\n\t\t */\n\t\tif (--word == -1 && i < len) {\n\t\t\t/*\n\t\t\t * If done with this block, get the previous one.\n\t\t\t */\n\t\t\txfs_trans_brelse(tp, bp);\n\t\t\terror = xfs_rtbuf_get(mp, tp, --block, 0, &bp);\n\t\t\tif (error) {\n\t\t\t\treturn error;\n\t\t\t}\n\t\t\tbufp = bp->b_addr;\n\t\t\tword = XFS_BLOCKWMASK(mp);\n\t\t\tb = &bufp[word];\n\t\t} else {\n\t\t\t/*\n\t\t\t * Go on to the previous word in the buffer.\n\t\t\t */\n\t\t\tb--;\n\t\t}\n\t} else {\n\t\t/*\n\t\t * Starting on a word boundary, no partial word.\n\t\t */\n\t\ti = 0;\n\t}\n\t/*\n\t * Loop over whole words in buffers.  When we use up one buffer\n\t * we move on to the previous one.\n\t */\n\twhile (len - i >= XFS_NBWORD) {\n\t\t/*\n\t\t * Compute difference between actual and desired value.\n\t\t */\n\t\tif ((wdiff = *b ^ want)) {\n\t\t\t/*\n\t\t\t * Different, mark where we are and return.\n\t\t\t */\n\t\t\txfs_trans_brelse(tp, bp);\n\t\t\ti += XFS_NBWORD - 1 - XFS_RTHIBIT(wdiff);\n\t\t\t*rtblock = start - i + 1;\n\t\t\treturn 0;\n\t\t}\n\t\ti += XFS_NBWORD;\n\t\t/*\n\t\t * Go on to previous block if that's where the previous word is\n\t\t * and we need the previous word.\n\t\t */\n\t\tif (--word == -1 && i < len) {\n\t\t\t/*\n\t\t\t * If done with this block, get the previous one.\n\t\t\t */\n\t\t\txfs_trans_brelse(tp, bp);\n\t\t\terror = xfs_rtbuf_get(mp, tp, --block, 0, &bp);\n\t\t\tif (error) {\n\t\t\t\treturn error;\n\t\t\t}\n\t\t\tbufp = bp->b_addr;\n\t\t\tword = XFS_BLOCKWMASK(mp);\n\t\t\tb = &bufp[word];\n\t\t} else {\n\t\t\t/*\n\t\t\t * Go on to the previous word in the buffer.\n\t\t\t */\n\t\t\tb--;\n\t\t}\n\t}\n\t/*\n\t * If not ending on a word boundary, deal with the last\n\t * (partial) word.\n\t */\n\tif (len - i) {\n\t\t/*\n\t\t * Calculate first (leftmost) bit number to look at,\n\t\t * and mask for all the relevant bits in this word.\n\t\t */\n\t\tfirstbit = XFS_NBWORD - (len - i);\n\t\tmask = (((xfs_rtword_t)1 << (len - i)) - 1) << firstbit;\n\t\t/*\n\t\t * Compute difference between actual and desired value.\n\t\t */\n\t\tif ((wdiff = (*b ^ want) & mask)) {\n\t\t\t/*\n\t\t\t * Different, mark where we are and return.\n\t\t\t */\n\t\t\txfs_trans_brelse(tp, bp);\n\t\t\ti += XFS_NBWORD - 1 - XFS_RTHIBIT(wdiff);\n\t\t\t*rtblock = start - i + 1;\n\t\t\treturn 0;\n\t\t} else\n\t\t\ti = len;\n\t}\n\t/*\n\t * No match, return that we scanned the whole area.\n\t */\n\txfs_trans_brelse(tp, bp);\n\t*rtblock = start - i + 1;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_rtmodify_range",
          "args": [
            "mp",
            "tp",
            "start",
            "len",
            "1"
          ],
          "line": 689
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_rtmodify_range",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_rtbitmap.c",
          "lines": "514-665",
          "snippet": "int\nxfs_rtmodify_range(\n\txfs_mount_t\t*mp,\t\t/* file system mount point */\n\txfs_trans_t\t*tp,\t\t/* transaction pointer */\n\txfs_rtblock_t\tstart,\t\t/* starting block to modify */\n\txfs_extlen_t\tlen,\t\t/* length of extent to modify */\n\tint\t\tval)\t\t/* 1 for free, 0 for allocated */\n{\n\txfs_rtword_t\t*b;\t\t/* current word in buffer */\n\tint\t\tbit;\t\t/* bit number in the word */\n\txfs_rtblock_t\tblock;\t\t/* bitmap block number */\n\txfs_buf_t\t*bp;\t\t/* buf for the block */\n\txfs_rtword_t\t*bufp;\t\t/* starting word in buffer */\n\tint\t\terror;\t\t/* error value */\n\txfs_rtword_t\t*first;\t\t/* first used word in the buffer */\n\tint\t\ti;\t\t/* current bit number rel. to start */\n\tint\t\tlastbit;\t/* last useful bit in word */\n\txfs_rtword_t\tmask;\t\t/* mask o frelevant bits for value */\n\tint\t\tword;\t\t/* word number in the buffer */\n\n\t/*\n\t * Compute starting bitmap block number.\n\t */\n\tblock = XFS_BITTOBLOCK(mp, start);\n\t/*\n\t * Read the bitmap block, and point to its data.\n\t */\n\terror = xfs_rtbuf_get(mp, tp, block, 0, &bp);\n\tif (error) {\n\t\treturn error;\n\t}\n\tbufp = bp->b_addr;\n\t/*\n\t * Compute the starting word's address, and starting bit.\n\t */\n\tword = XFS_BITTOWORD(mp, start);\n\tfirst = b = &bufp[word];\n\tbit = (int)(start & (XFS_NBWORD - 1));\n\t/*\n\t * 0 (allocated) => all zeroes; 1 (free) => all ones.\n\t */\n\tval = -val;\n\t/*\n\t * If not starting on a word boundary, deal with the first\n\t * (partial) word.\n\t */\n\tif (bit) {\n\t\t/*\n\t\t * Compute first bit not changed and mask of relevant bits.\n\t\t */\n\t\tlastbit = XFS_RTMIN(bit + len, XFS_NBWORD);\n\t\tmask = (((xfs_rtword_t)1 << (lastbit - bit)) - 1) << bit;\n\t\t/*\n\t\t * Set/clear the active bits.\n\t\t */\n\t\tif (val)\n\t\t\t*b |= mask;\n\t\telse\n\t\t\t*b &= ~mask;\n\t\ti = lastbit - bit;\n\t\t/*\n\t\t * Go on to the next block if that's where the next word is\n\t\t * and we need the next word.\n\t\t */\n\t\tif (++word == XFS_BLOCKWSIZE(mp) && i < len) {\n\t\t\t/*\n\t\t\t * Log the changed part of this block.\n\t\t\t * Get the next one.\n\t\t\t */\n\t\t\txfs_trans_log_buf(tp, bp,\n\t\t\t\t(uint)((char *)first - (char *)bufp),\n\t\t\t\t(uint)((char *)b - (char *)bufp));\n\t\t\terror = xfs_rtbuf_get(mp, tp, ++block, 0, &bp);\n\t\t\tif (error) {\n\t\t\t\treturn error;\n\t\t\t}\n\t\t\tfirst = b = bufp = bp->b_addr;\n\t\t\tword = 0;\n\t\t} else {\n\t\t\t/*\n\t\t\t * Go on to the next word in the buffer\n\t\t\t */\n\t\t\tb++;\n\t\t}\n\t} else {\n\t\t/*\n\t\t * Starting on a word boundary, no partial word.\n\t\t */\n\t\ti = 0;\n\t}\n\t/*\n\t * Loop over whole words in buffers.  When we use up one buffer\n\t * we move on to the next one.\n\t */\n\twhile (len - i >= XFS_NBWORD) {\n\t\t/*\n\t\t * Set the word value correctly.\n\t\t */\n\t\t*b = val;\n\t\ti += XFS_NBWORD;\n\t\t/*\n\t\t * Go on to the next block if that's where the next word is\n\t\t * and we need the next word.\n\t\t */\n\t\tif (++word == XFS_BLOCKWSIZE(mp) && i < len) {\n\t\t\t/*\n\t\t\t * Log the changed part of this block.\n\t\t\t * Get the next one.\n\t\t\t */\n\t\t\txfs_trans_log_buf(tp, bp,\n\t\t\t\t(uint)((char *)first - (char *)bufp),\n\t\t\t\t(uint)((char *)b - (char *)bufp));\n\t\t\terror = xfs_rtbuf_get(mp, tp, ++block, 0, &bp);\n\t\t\tif (error) {\n\t\t\t\treturn error;\n\t\t\t}\n\t\t\tfirst = b = bufp = bp->b_addr;\n\t\t\tword = 0;\n\t\t} else {\n\t\t\t/*\n\t\t\t * Go on to the next word in the buffer\n\t\t\t */\n\t\t\tb++;\n\t\t}\n\t}\n\t/*\n\t * If not ending on a word boundary, deal with the last\n\t * (partial) word.\n\t */\n\tif ((lastbit = len - i)) {\n\t\t/*\n\t\t * Compute a mask of relevant bits.\n\t\t */\n\t\tbit = 0;\n\t\tmask = ((xfs_rtword_t)1 << lastbit) - 1;\n\t\t/*\n\t\t * Set/clear the active bits.\n\t\t */\n\t\tif (val)\n\t\t\t*b |= mask;\n\t\telse\n\t\t\t*b &= ~mask;\n\t\tb++;\n\t}\n\t/*\n\t * Log any remaining changed bytes.\n\t */\n\tif (b > first)\n\t\txfs_trans_log_buf(tp, bp, (uint)((char *)first - (char *)bufp),\n\t\t\t(uint)((char *)b - (char *)bufp - 1));\n\treturn 0;\n}",
          "includes": [
            "#include \"xfs_rtalloc.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_buf.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_trans_space.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_rtalloc.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_buf.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_error.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nint\nxfs_rtmodify_range(\n\txfs_mount_t\t*mp,\t\t/* file system mount point */\n\txfs_trans_t\t*tp,\t\t/* transaction pointer */\n\txfs_rtblock_t\tstart,\t\t/* starting block to modify */\n\txfs_extlen_t\tlen,\t\t/* length of extent to modify */\n\tint\t\tval)\t\t/* 1 for free, 0 for allocated */\n{\n\txfs_rtword_t\t*b;\t\t/* current word in buffer */\n\tint\t\tbit;\t\t/* bit number in the word */\n\txfs_rtblock_t\tblock;\t\t/* bitmap block number */\n\txfs_buf_t\t*bp;\t\t/* buf for the block */\n\txfs_rtword_t\t*bufp;\t\t/* starting word in buffer */\n\tint\t\terror;\t\t/* error value */\n\txfs_rtword_t\t*first;\t\t/* first used word in the buffer */\n\tint\t\ti;\t\t/* current bit number rel. to start */\n\tint\t\tlastbit;\t/* last useful bit in word */\n\txfs_rtword_t\tmask;\t\t/* mask o frelevant bits for value */\n\tint\t\tword;\t\t/* word number in the buffer */\n\n\t/*\n\t * Compute starting bitmap block number.\n\t */\n\tblock = XFS_BITTOBLOCK(mp, start);\n\t/*\n\t * Read the bitmap block, and point to its data.\n\t */\n\terror = xfs_rtbuf_get(mp, tp, block, 0, &bp);\n\tif (error) {\n\t\treturn error;\n\t}\n\tbufp = bp->b_addr;\n\t/*\n\t * Compute the starting word's address, and starting bit.\n\t */\n\tword = XFS_BITTOWORD(mp, start);\n\tfirst = b = &bufp[word];\n\tbit = (int)(start & (XFS_NBWORD - 1));\n\t/*\n\t * 0 (allocated) => all zeroes; 1 (free) => all ones.\n\t */\n\tval = -val;\n\t/*\n\t * If not starting on a word boundary, deal with the first\n\t * (partial) word.\n\t */\n\tif (bit) {\n\t\t/*\n\t\t * Compute first bit not changed and mask of relevant bits.\n\t\t */\n\t\tlastbit = XFS_RTMIN(bit + len, XFS_NBWORD);\n\t\tmask = (((xfs_rtword_t)1 << (lastbit - bit)) - 1) << bit;\n\t\t/*\n\t\t * Set/clear the active bits.\n\t\t */\n\t\tif (val)\n\t\t\t*b |= mask;\n\t\telse\n\t\t\t*b &= ~mask;\n\t\ti = lastbit - bit;\n\t\t/*\n\t\t * Go on to the next block if that's where the next word is\n\t\t * and we need the next word.\n\t\t */\n\t\tif (++word == XFS_BLOCKWSIZE(mp) && i < len) {\n\t\t\t/*\n\t\t\t * Log the changed part of this block.\n\t\t\t * Get the next one.\n\t\t\t */\n\t\t\txfs_trans_log_buf(tp, bp,\n\t\t\t\t(uint)((char *)first - (char *)bufp),\n\t\t\t\t(uint)((char *)b - (char *)bufp));\n\t\t\terror = xfs_rtbuf_get(mp, tp, ++block, 0, &bp);\n\t\t\tif (error) {\n\t\t\t\treturn error;\n\t\t\t}\n\t\t\tfirst = b = bufp = bp->b_addr;\n\t\t\tword = 0;\n\t\t} else {\n\t\t\t/*\n\t\t\t * Go on to the next word in the buffer\n\t\t\t */\n\t\t\tb++;\n\t\t}\n\t} else {\n\t\t/*\n\t\t * Starting on a word boundary, no partial word.\n\t\t */\n\t\ti = 0;\n\t}\n\t/*\n\t * Loop over whole words in buffers.  When we use up one buffer\n\t * we move on to the next one.\n\t */\n\twhile (len - i >= XFS_NBWORD) {\n\t\t/*\n\t\t * Set the word value correctly.\n\t\t */\n\t\t*b = val;\n\t\ti += XFS_NBWORD;\n\t\t/*\n\t\t * Go on to the next block if that's where the next word is\n\t\t * and we need the next word.\n\t\t */\n\t\tif (++word == XFS_BLOCKWSIZE(mp) && i < len) {\n\t\t\t/*\n\t\t\t * Log the changed part of this block.\n\t\t\t * Get the next one.\n\t\t\t */\n\t\t\txfs_trans_log_buf(tp, bp,\n\t\t\t\t(uint)((char *)first - (char *)bufp),\n\t\t\t\t(uint)((char *)b - (char *)bufp));\n\t\t\terror = xfs_rtbuf_get(mp, tp, ++block, 0, &bp);\n\t\t\tif (error) {\n\t\t\t\treturn error;\n\t\t\t}\n\t\t\tfirst = b = bufp = bp->b_addr;\n\t\t\tword = 0;\n\t\t} else {\n\t\t\t/*\n\t\t\t * Go on to the next word in the buffer\n\t\t\t */\n\t\t\tb++;\n\t\t}\n\t}\n\t/*\n\t * If not ending on a word boundary, deal with the last\n\t * (partial) word.\n\t */\n\tif ((lastbit = len - i)) {\n\t\t/*\n\t\t * Compute a mask of relevant bits.\n\t\t */\n\t\tbit = 0;\n\t\tmask = ((xfs_rtword_t)1 << lastbit) - 1;\n\t\t/*\n\t\t * Set/clear the active bits.\n\t\t */\n\t\tif (val)\n\t\t\t*b |= mask;\n\t\telse\n\t\t\t*b &= ~mask;\n\t\tb++;\n\t}\n\t/*\n\t * Log any remaining changed bytes.\n\t */\n\tif (b > first)\n\t\txfs_trans_log_buf(tp, bp, (uint)((char *)first - (char *)bufp),\n\t\t\t(uint)((char *)b - (char *)bufp - 1));\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"xfs_rtalloc.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_buf.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_error.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nint\nxfs_rtfree_range(\n\txfs_mount_t\t*mp,\t\t/* file system mount point */\n\txfs_trans_t\t*tp,\t\t/* transaction pointer */\n\txfs_rtblock_t\tstart,\t\t/* starting block to free */\n\txfs_extlen_t\tlen,\t\t/* length to free */\n\txfs_buf_t\t**rbpp,\t\t/* in/out: summary block buffer */\n\txfs_fsblock_t\t*rsb)\t\t/* in/out: summary block number */\n{\n\txfs_rtblock_t\tend;\t\t/* end of the freed extent */\n\tint\t\terror;\t\t/* error value */\n\txfs_rtblock_t\tpostblock;\t/* first block freed > end */\n\txfs_rtblock_t\tpreblock;\t/* first block freed < start */\n\n\tend = start + len - 1;\n\t/*\n\t * Modify the bitmap to mark this extent freed.\n\t */\n\terror = xfs_rtmodify_range(mp, tp, start, len, 1);\n\tif (error) {\n\t\treturn error;\n\t}\n\t/*\n\t * Assume we're freeing out of the middle of an allocated extent.\n\t * We need to find the beginning and end of the extent so we can\n\t * properly update the summary.\n\t */\n\terror = xfs_rtfind_back(mp, tp, start, 0, &preblock);\n\tif (error) {\n\t\treturn error;\n\t}\n\t/*\n\t * Find the next allocated block (end of allocated extent).\n\t */\n\terror = xfs_rtfind_forw(mp, tp, end, mp->m_sb.sb_rextents - 1,\n\t\t&postblock);\n\tif (error)\n\t\treturn error;\n\t/*\n\t * If there are blocks not being freed at the front of the\n\t * old extent, add summary data for them to be allocated.\n\t */\n\tif (preblock < start) {\n\t\terror = xfs_rtmodify_summary(mp, tp,\n\t\t\tXFS_RTBLOCKLOG(start - preblock),\n\t\t\tXFS_BITTOBLOCK(mp, preblock), -1, rbpp, rsb);\n\t\tif (error) {\n\t\t\treturn error;\n\t\t}\n\t}\n\t/*\n\t * If there are blocks not being freed at the end of the\n\t * old extent, add summary data for them to be allocated.\n\t */\n\tif (postblock > end) {\n\t\terror = xfs_rtmodify_summary(mp, tp,\n\t\t\tXFS_RTBLOCKLOG(postblock - end),\n\t\t\tXFS_BITTOBLOCK(mp, end + 1), -1, rbpp, rsb);\n\t\tif (error) {\n\t\t\treturn error;\n\t\t}\n\t}\n\t/*\n\t * Increment the summary information corresponding to the entire\n\t * (new) free extent.\n\t */\n\terror = xfs_rtmodify_summary(mp, tp,\n\t\tXFS_RTBLOCKLOG(postblock + 1 - preblock),\n\t\tXFS_BITTOBLOCK(mp, preblock), 1, rbpp, rsb);\n\treturn error;\n}"
  },
  {
    "function_name": "xfs_rtmodify_range",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_rtbitmap.c",
    "lines": "514-665",
    "snippet": "int\nxfs_rtmodify_range(\n\txfs_mount_t\t*mp,\t\t/* file system mount point */\n\txfs_trans_t\t*tp,\t\t/* transaction pointer */\n\txfs_rtblock_t\tstart,\t\t/* starting block to modify */\n\txfs_extlen_t\tlen,\t\t/* length of extent to modify */\n\tint\t\tval)\t\t/* 1 for free, 0 for allocated */\n{\n\txfs_rtword_t\t*b;\t\t/* current word in buffer */\n\tint\t\tbit;\t\t/* bit number in the word */\n\txfs_rtblock_t\tblock;\t\t/* bitmap block number */\n\txfs_buf_t\t*bp;\t\t/* buf for the block */\n\txfs_rtword_t\t*bufp;\t\t/* starting word in buffer */\n\tint\t\terror;\t\t/* error value */\n\txfs_rtword_t\t*first;\t\t/* first used word in the buffer */\n\tint\t\ti;\t\t/* current bit number rel. to start */\n\tint\t\tlastbit;\t/* last useful bit in word */\n\txfs_rtword_t\tmask;\t\t/* mask o frelevant bits for value */\n\tint\t\tword;\t\t/* word number in the buffer */\n\n\t/*\n\t * Compute starting bitmap block number.\n\t */\n\tblock = XFS_BITTOBLOCK(mp, start);\n\t/*\n\t * Read the bitmap block, and point to its data.\n\t */\n\terror = xfs_rtbuf_get(mp, tp, block, 0, &bp);\n\tif (error) {\n\t\treturn error;\n\t}\n\tbufp = bp->b_addr;\n\t/*\n\t * Compute the starting word's address, and starting bit.\n\t */\n\tword = XFS_BITTOWORD(mp, start);\n\tfirst = b = &bufp[word];\n\tbit = (int)(start & (XFS_NBWORD - 1));\n\t/*\n\t * 0 (allocated) => all zeroes; 1 (free) => all ones.\n\t */\n\tval = -val;\n\t/*\n\t * If not starting on a word boundary, deal with the first\n\t * (partial) word.\n\t */\n\tif (bit) {\n\t\t/*\n\t\t * Compute first bit not changed and mask of relevant bits.\n\t\t */\n\t\tlastbit = XFS_RTMIN(bit + len, XFS_NBWORD);\n\t\tmask = (((xfs_rtword_t)1 << (lastbit - bit)) - 1) << bit;\n\t\t/*\n\t\t * Set/clear the active bits.\n\t\t */\n\t\tif (val)\n\t\t\t*b |= mask;\n\t\telse\n\t\t\t*b &= ~mask;\n\t\ti = lastbit - bit;\n\t\t/*\n\t\t * Go on to the next block if that's where the next word is\n\t\t * and we need the next word.\n\t\t */\n\t\tif (++word == XFS_BLOCKWSIZE(mp) && i < len) {\n\t\t\t/*\n\t\t\t * Log the changed part of this block.\n\t\t\t * Get the next one.\n\t\t\t */\n\t\t\txfs_trans_log_buf(tp, bp,\n\t\t\t\t(uint)((char *)first - (char *)bufp),\n\t\t\t\t(uint)((char *)b - (char *)bufp));\n\t\t\terror = xfs_rtbuf_get(mp, tp, ++block, 0, &bp);\n\t\t\tif (error) {\n\t\t\t\treturn error;\n\t\t\t}\n\t\t\tfirst = b = bufp = bp->b_addr;\n\t\t\tword = 0;\n\t\t} else {\n\t\t\t/*\n\t\t\t * Go on to the next word in the buffer\n\t\t\t */\n\t\t\tb++;\n\t\t}\n\t} else {\n\t\t/*\n\t\t * Starting on a word boundary, no partial word.\n\t\t */\n\t\ti = 0;\n\t}\n\t/*\n\t * Loop over whole words in buffers.  When we use up one buffer\n\t * we move on to the next one.\n\t */\n\twhile (len - i >= XFS_NBWORD) {\n\t\t/*\n\t\t * Set the word value correctly.\n\t\t */\n\t\t*b = val;\n\t\ti += XFS_NBWORD;\n\t\t/*\n\t\t * Go on to the next block if that's where the next word is\n\t\t * and we need the next word.\n\t\t */\n\t\tif (++word == XFS_BLOCKWSIZE(mp) && i < len) {\n\t\t\t/*\n\t\t\t * Log the changed part of this block.\n\t\t\t * Get the next one.\n\t\t\t */\n\t\t\txfs_trans_log_buf(tp, bp,\n\t\t\t\t(uint)((char *)first - (char *)bufp),\n\t\t\t\t(uint)((char *)b - (char *)bufp));\n\t\t\terror = xfs_rtbuf_get(mp, tp, ++block, 0, &bp);\n\t\t\tif (error) {\n\t\t\t\treturn error;\n\t\t\t}\n\t\t\tfirst = b = bufp = bp->b_addr;\n\t\t\tword = 0;\n\t\t} else {\n\t\t\t/*\n\t\t\t * Go on to the next word in the buffer\n\t\t\t */\n\t\t\tb++;\n\t\t}\n\t}\n\t/*\n\t * If not ending on a word boundary, deal with the last\n\t * (partial) word.\n\t */\n\tif ((lastbit = len - i)) {\n\t\t/*\n\t\t * Compute a mask of relevant bits.\n\t\t */\n\t\tbit = 0;\n\t\tmask = ((xfs_rtword_t)1 << lastbit) - 1;\n\t\t/*\n\t\t * Set/clear the active bits.\n\t\t */\n\t\tif (val)\n\t\t\t*b |= mask;\n\t\telse\n\t\t\t*b &= ~mask;\n\t\tb++;\n\t}\n\t/*\n\t * Log any remaining changed bytes.\n\t */\n\tif (b > first)\n\t\txfs_trans_log_buf(tp, bp, (uint)((char *)first - (char *)bufp),\n\t\t\t(uint)((char *)b - (char *)bufp - 1));\n\treturn 0;\n}",
    "includes": [
      "#include \"xfs_rtalloc.h\"",
      "#include \"xfs_icache.h\"",
      "#include \"xfs_buf.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_trans_space.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_alloc.h\"",
      "#include \"xfs_bmap_btree.h\"",
      "#include \"xfs_bmap_util.h\"",
      "#include \"xfs_bmap.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_bit.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "xfs_trans_log_buf",
          "args": [
            "tp",
            "bp",
            "(uint)((char *)first - (char *)bufp)",
            "(uint)((char *)b - (char *)bufp - 1)"
          ],
          "line": 662
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_trans_log_buf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_trans_buf.c",
          "lines": "497-552",
          "snippet": "void\nxfs_trans_log_buf(xfs_trans_t\t*tp,\n\t\t  xfs_buf_t\t*bp,\n\t\t  uint\t\tfirst,\n\t\t  uint\t\tlast)\n{\n\txfs_buf_log_item_t\t*bip = bp->b_fspriv;\n\n\tASSERT(bp->b_transp == tp);\n\tASSERT(bip != NULL);\n\tASSERT(first <= last && last < BBTOB(bp->b_length));\n\tASSERT(bp->b_iodone == NULL ||\n\t       bp->b_iodone == xfs_buf_iodone_callbacks);\n\n\t/*\n\t * Mark the buffer as needing to be written out eventually,\n\t * and set its iodone function to remove the buffer's buf log\n\t * item from the AIL and free it when the buffer is flushed\n\t * to disk.  See xfs_buf_attach_iodone() for more details\n\t * on li_cb and xfs_buf_iodone_callbacks().\n\t * If we end up aborting this transaction, we trap this buffer\n\t * inside the b_bdstrat callback so that this won't get written to\n\t * disk.\n\t */\n\tXFS_BUF_DONE(bp);\n\n\tASSERT(atomic_read(&bip->bli_refcount) > 0);\n\tbp->b_iodone = xfs_buf_iodone_callbacks;\n\tbip->bli_item.li_cb = xfs_buf_iodone;\n\n\ttrace_xfs_trans_log_buf(bip);\n\n\t/*\n\t * If we invalidated the buffer within this transaction, then\n\t * cancel the invalidation now that we're dirtying the buffer\n\t * again.  There are no races with the code in xfs_buf_item_unpin(),\n\t * because we have a reference to the buffer this entire time.\n\t */\n\tif (bip->bli_flags & XFS_BLI_STALE) {\n\t\tbip->bli_flags &= ~XFS_BLI_STALE;\n\t\tASSERT(XFS_BUF_ISSTALE(bp));\n\t\tXFS_BUF_UNSTALE(bp);\n\t\tbip->__bli_format.blf_flags &= ~XFS_BLF_CANCEL;\n\t}\n\n\ttp->t_flags |= XFS_TRANS_DIRTY;\n\tbip->bli_item.li_desc->lid_flags |= XFS_LID_DIRTY;\n\n\t/*\n\t * If we have an ordered buffer we are not logging any dirty range but\n\t * it still needs to be marked dirty and that it has been logged.\n\t */\n\tbip->bli_flags |= XFS_BLI_DIRTY | XFS_BLI_LOGGED;\n\tif (!(bip->bli_flags & XFS_BLI_ORDERED))\n\t\txfs_buf_item_log(bip, first, last);\n}",
          "includes": [
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nvoid\nxfs_trans_log_buf(xfs_trans_t\t*tp,\n\t\t  xfs_buf_t\t*bp,\n\t\t  uint\t\tfirst,\n\t\t  uint\t\tlast)\n{\n\txfs_buf_log_item_t\t*bip = bp->b_fspriv;\n\n\tASSERT(bp->b_transp == tp);\n\tASSERT(bip != NULL);\n\tASSERT(first <= last && last < BBTOB(bp->b_length));\n\tASSERT(bp->b_iodone == NULL ||\n\t       bp->b_iodone == xfs_buf_iodone_callbacks);\n\n\t/*\n\t * Mark the buffer as needing to be written out eventually,\n\t * and set its iodone function to remove the buffer's buf log\n\t * item from the AIL and free it when the buffer is flushed\n\t * to disk.  See xfs_buf_attach_iodone() for more details\n\t * on li_cb and xfs_buf_iodone_callbacks().\n\t * If we end up aborting this transaction, we trap this buffer\n\t * inside the b_bdstrat callback so that this won't get written to\n\t * disk.\n\t */\n\tXFS_BUF_DONE(bp);\n\n\tASSERT(atomic_read(&bip->bli_refcount) > 0);\n\tbp->b_iodone = xfs_buf_iodone_callbacks;\n\tbip->bli_item.li_cb = xfs_buf_iodone;\n\n\ttrace_xfs_trans_log_buf(bip);\n\n\t/*\n\t * If we invalidated the buffer within this transaction, then\n\t * cancel the invalidation now that we're dirtying the buffer\n\t * again.  There are no races with the code in xfs_buf_item_unpin(),\n\t * because we have a reference to the buffer this entire time.\n\t */\n\tif (bip->bli_flags & XFS_BLI_STALE) {\n\t\tbip->bli_flags &= ~XFS_BLI_STALE;\n\t\tASSERT(XFS_BUF_ISSTALE(bp));\n\t\tXFS_BUF_UNSTALE(bp);\n\t\tbip->__bli_format.blf_flags &= ~XFS_BLF_CANCEL;\n\t}\n\n\ttp->t_flags |= XFS_TRANS_DIRTY;\n\tbip->bli_item.li_desc->lid_flags |= XFS_LID_DIRTY;\n\n\t/*\n\t * If we have an ordered buffer we are not logging any dirty range but\n\t * it still needs to be marked dirty and that it has been logged.\n\t */\n\tbip->bli_flags |= XFS_BLI_DIRTY | XFS_BLI_LOGGED;\n\tif (!(bip->bli_flags & XFS_BLI_ORDERED))\n\t\txfs_buf_item_log(bip, first, last);\n}"
        }
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "(char *)b - (char *)bufp - 1"
          ],
          "line": 663
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "(char *)first - (char *)bufp"
          ],
          "line": 662
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_rtbuf_get",
          "args": [
            "mp",
            "tp",
            "++block",
            "0",
            "&bp"
          ],
          "line": 626
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_rtbuf_get",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_rtbitmap.c",
          "lines": "48-76",
          "snippet": "int\nxfs_rtbuf_get(\n\txfs_mount_t\t*mp,\t\t/* file system mount structure */\n\txfs_trans_t\t*tp,\t\t/* transaction pointer */\n\txfs_rtblock_t\tblock,\t\t/* block number in bitmap or summary */\n\tint\t\tissum,\t\t/* is summary not bitmap */\n\txfs_buf_t\t**bpp)\t\t/* output: buffer for the block */\n{\n\txfs_buf_t\t*bp;\t\t/* block buffer, result */\n\txfs_inode_t\t*ip;\t\t/* bitmap or summary inode */\n\txfs_bmbt_irec_t\tmap;\n\tint\t\tnmap = 1;\n\tint\t\terror;\t\t/* error value */\n\n\tip = issum ? mp->m_rsumip : mp->m_rbmip;\n\n\terror = xfs_bmapi_read(ip, block, 1, &map, &nmap, XFS_DATA_FORK);\n\tif (error)\n\t\treturn error;\n\n\tASSERT(map.br_startblock != NULLFSBLOCK);\n\terror = xfs_trans_read_buf(mp, tp, mp->m_ddev_targp,\n\t\t\t\t   XFS_FSB_TO_DADDR(mp, map.br_startblock),\n\t\t\t\t   mp->m_bsize, 0, &bp, NULL);\n\tif (error)\n\t\treturn error;\n\t*bpp = bp;\n\treturn 0;\n}",
          "includes": [
            "#include \"xfs_rtalloc.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_buf.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_trans_space.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_rtalloc.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_buf.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_error.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nint\nxfs_rtbuf_get(\n\txfs_mount_t\t*mp,\t\t/* file system mount structure */\n\txfs_trans_t\t*tp,\t\t/* transaction pointer */\n\txfs_rtblock_t\tblock,\t\t/* block number in bitmap or summary */\n\tint\t\tissum,\t\t/* is summary not bitmap */\n\txfs_buf_t\t**bpp)\t\t/* output: buffer for the block */\n{\n\txfs_buf_t\t*bp;\t\t/* block buffer, result */\n\txfs_inode_t\t*ip;\t\t/* bitmap or summary inode */\n\txfs_bmbt_irec_t\tmap;\n\tint\t\tnmap = 1;\n\tint\t\terror;\t\t/* error value */\n\n\tip = issum ? mp->m_rsumip : mp->m_rbmip;\n\n\terror = xfs_bmapi_read(ip, block, 1, &map, &nmap, XFS_DATA_FORK);\n\tif (error)\n\t\treturn error;\n\n\tASSERT(map.br_startblock != NULLFSBLOCK);\n\terror = xfs_trans_read_buf(mp, tp, mp->m_ddev_targp,\n\t\t\t\t   XFS_FSB_TO_DADDR(mp, map.br_startblock),\n\t\t\t\t   mp->m_bsize, 0, &bp, NULL);\n\tif (error)\n\t\treturn error;\n\t*bpp = bp;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "(char *)b - (char *)bufp"
          ],
          "line": 625
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "(char *)first - (char *)bufp"
          ],
          "line": 624
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_BLOCKWSIZE",
          "args": [
            "mp"
          ],
          "line": 618
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "(char *)b - (char *)bufp"
          ],
          "line": 585
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "(char *)first - (char *)bufp"
          ],
          "line": 584
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_BLOCKWSIZE",
          "args": [
            "mp"
          ],
          "line": 578
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_RTMIN",
          "args": [
            "bit + len",
            "XFS_NBWORD"
          ],
          "line": 564
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_BITTOWORD",
          "args": [
            "mp",
            "start"
          ],
          "line": 549
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_BITTOBLOCK",
          "args": [
            "mp",
            "start"
          ],
          "line": 537
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xfs_rtalloc.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_buf.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_error.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nint\nxfs_rtmodify_range(\n\txfs_mount_t\t*mp,\t\t/* file system mount point */\n\txfs_trans_t\t*tp,\t\t/* transaction pointer */\n\txfs_rtblock_t\tstart,\t\t/* starting block to modify */\n\txfs_extlen_t\tlen,\t\t/* length of extent to modify */\n\tint\t\tval)\t\t/* 1 for free, 0 for allocated */\n{\n\txfs_rtword_t\t*b;\t\t/* current word in buffer */\n\tint\t\tbit;\t\t/* bit number in the word */\n\txfs_rtblock_t\tblock;\t\t/* bitmap block number */\n\txfs_buf_t\t*bp;\t\t/* buf for the block */\n\txfs_rtword_t\t*bufp;\t\t/* starting word in buffer */\n\tint\t\terror;\t\t/* error value */\n\txfs_rtword_t\t*first;\t\t/* first used word in the buffer */\n\tint\t\ti;\t\t/* current bit number rel. to start */\n\tint\t\tlastbit;\t/* last useful bit in word */\n\txfs_rtword_t\tmask;\t\t/* mask o frelevant bits for value */\n\tint\t\tword;\t\t/* word number in the buffer */\n\n\t/*\n\t * Compute starting bitmap block number.\n\t */\n\tblock = XFS_BITTOBLOCK(mp, start);\n\t/*\n\t * Read the bitmap block, and point to its data.\n\t */\n\terror = xfs_rtbuf_get(mp, tp, block, 0, &bp);\n\tif (error) {\n\t\treturn error;\n\t}\n\tbufp = bp->b_addr;\n\t/*\n\t * Compute the starting word's address, and starting bit.\n\t */\n\tword = XFS_BITTOWORD(mp, start);\n\tfirst = b = &bufp[word];\n\tbit = (int)(start & (XFS_NBWORD - 1));\n\t/*\n\t * 0 (allocated) => all zeroes; 1 (free) => all ones.\n\t */\n\tval = -val;\n\t/*\n\t * If not starting on a word boundary, deal with the first\n\t * (partial) word.\n\t */\n\tif (bit) {\n\t\t/*\n\t\t * Compute first bit not changed and mask of relevant bits.\n\t\t */\n\t\tlastbit = XFS_RTMIN(bit + len, XFS_NBWORD);\n\t\tmask = (((xfs_rtword_t)1 << (lastbit - bit)) - 1) << bit;\n\t\t/*\n\t\t * Set/clear the active bits.\n\t\t */\n\t\tif (val)\n\t\t\t*b |= mask;\n\t\telse\n\t\t\t*b &= ~mask;\n\t\ti = lastbit - bit;\n\t\t/*\n\t\t * Go on to the next block if that's where the next word is\n\t\t * and we need the next word.\n\t\t */\n\t\tif (++word == XFS_BLOCKWSIZE(mp) && i < len) {\n\t\t\t/*\n\t\t\t * Log the changed part of this block.\n\t\t\t * Get the next one.\n\t\t\t */\n\t\t\txfs_trans_log_buf(tp, bp,\n\t\t\t\t(uint)((char *)first - (char *)bufp),\n\t\t\t\t(uint)((char *)b - (char *)bufp));\n\t\t\terror = xfs_rtbuf_get(mp, tp, ++block, 0, &bp);\n\t\t\tif (error) {\n\t\t\t\treturn error;\n\t\t\t}\n\t\t\tfirst = b = bufp = bp->b_addr;\n\t\t\tword = 0;\n\t\t} else {\n\t\t\t/*\n\t\t\t * Go on to the next word in the buffer\n\t\t\t */\n\t\t\tb++;\n\t\t}\n\t} else {\n\t\t/*\n\t\t * Starting on a word boundary, no partial word.\n\t\t */\n\t\ti = 0;\n\t}\n\t/*\n\t * Loop over whole words in buffers.  When we use up one buffer\n\t * we move on to the next one.\n\t */\n\twhile (len - i >= XFS_NBWORD) {\n\t\t/*\n\t\t * Set the word value correctly.\n\t\t */\n\t\t*b = val;\n\t\ti += XFS_NBWORD;\n\t\t/*\n\t\t * Go on to the next block if that's where the next word is\n\t\t * and we need the next word.\n\t\t */\n\t\tif (++word == XFS_BLOCKWSIZE(mp) && i < len) {\n\t\t\t/*\n\t\t\t * Log the changed part of this block.\n\t\t\t * Get the next one.\n\t\t\t */\n\t\t\txfs_trans_log_buf(tp, bp,\n\t\t\t\t(uint)((char *)first - (char *)bufp),\n\t\t\t\t(uint)((char *)b - (char *)bufp));\n\t\t\terror = xfs_rtbuf_get(mp, tp, ++block, 0, &bp);\n\t\t\tif (error) {\n\t\t\t\treturn error;\n\t\t\t}\n\t\t\tfirst = b = bufp = bp->b_addr;\n\t\t\tword = 0;\n\t\t} else {\n\t\t\t/*\n\t\t\t * Go on to the next word in the buffer\n\t\t\t */\n\t\t\tb++;\n\t\t}\n\t}\n\t/*\n\t * If not ending on a word boundary, deal with the last\n\t * (partial) word.\n\t */\n\tif ((lastbit = len - i)) {\n\t\t/*\n\t\t * Compute a mask of relevant bits.\n\t\t */\n\t\tbit = 0;\n\t\tmask = ((xfs_rtword_t)1 << lastbit) - 1;\n\t\t/*\n\t\t * Set/clear the active bits.\n\t\t */\n\t\tif (val)\n\t\t\t*b |= mask;\n\t\telse\n\t\t\t*b &= ~mask;\n\t\tb++;\n\t}\n\t/*\n\t * Log any remaining changed bytes.\n\t */\n\tif (b > first)\n\t\txfs_trans_log_buf(tp, bp, (uint)((char *)first - (char *)bufp),\n\t\t\t(uint)((char *)b - (char *)bufp - 1));\n\treturn 0;\n}"
  },
  {
    "function_name": "xfs_rtmodify_summary",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_rtbitmap.c",
    "lines": "496-508",
    "snippet": "int\nxfs_rtmodify_summary(\n\txfs_mount_t\t*mp,\t\t/* file system mount structure */\n\txfs_trans_t\t*tp,\t\t/* transaction pointer */\n\tint\t\tlog,\t\t/* log2 of extent size */\n\txfs_rtblock_t\tbbno,\t\t/* bitmap block number */\n\tint\t\tdelta,\t\t/* change to make to summary info */\n\txfs_buf_t\t**rbpp,\t\t/* in/out: summary block buffer */\n\txfs_fsblock_t\t*rsb)\t\t/* in/out: summary block number */\n{\n\treturn xfs_rtmodify_summary_int(mp, tp, log, bbno,\n\t\t\t\t\tdelta, rbpp, rsb, NULL);\n}",
    "includes": [
      "#include \"xfs_rtalloc.h\"",
      "#include \"xfs_icache.h\"",
      "#include \"xfs_buf.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_trans_space.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_alloc.h\"",
      "#include \"xfs_bmap_btree.h\"",
      "#include \"xfs_bmap_util.h\"",
      "#include \"xfs_bmap.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_bit.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "xfs_rtmodify_summary_int",
          "args": [
            "mp",
            "tp",
            "log",
            "bbno",
            "delta",
            "rbpp",
            "rsb",
            "NULL"
          ],
          "line": 506
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_rtmodify_summary_int",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_rtbitmap.c",
          "lines": "432-494",
          "snippet": "int\nxfs_rtmodify_summary_int(\n\txfs_mount_t\t*mp,\t\t/* file system mount structure */\n\txfs_trans_t\t*tp,\t\t/* transaction pointer */\n\tint\t\tlog,\t\t/* log2 of extent size */\n\txfs_rtblock_t\tbbno,\t\t/* bitmap block number */\n\tint\t\tdelta,\t\t/* change to make to summary info */\n\txfs_buf_t\t**rbpp,\t\t/* in/out: summary block buffer */\n\txfs_fsblock_t\t*rsb,\t\t/* in/out: summary block number */\n\txfs_suminfo_t\t*sum)\t\t/* out: summary info for this block */\n{\n\txfs_buf_t\t*bp;\t\t/* buffer for the summary block */\n\tint\t\terror;\t\t/* error value */\n\txfs_fsblock_t\tsb;\t\t/* summary fsblock */\n\tint\t\tso;\t\t/* index into the summary file */\n\txfs_suminfo_t\t*sp;\t\t/* pointer to returned data */\n\n\t/*\n\t * Compute entry number in the summary file.\n\t */\n\tso = XFS_SUMOFFS(mp, log, bbno);\n\t/*\n\t * Compute the block number in the summary file.\n\t */\n\tsb = XFS_SUMOFFSTOBLOCK(mp, so);\n\t/*\n\t * If we have an old buffer, and the block number matches, use that.\n\t */\n\tif (*rbpp && *rsb == sb)\n\t\tbp = *rbpp;\n\t/*\n\t * Otherwise we have to get the buffer.\n\t */\n\telse {\n\t\t/*\n\t\t * If there was an old one, get rid of it first.\n\t\t */\n\t\tif (*rbpp)\n\t\t\txfs_trans_brelse(tp, *rbpp);\n\t\terror = xfs_rtbuf_get(mp, tp, sb, 1, &bp);\n\t\tif (error) {\n\t\t\treturn error;\n\t\t}\n\t\t/*\n\t\t * Remember this buffer and block for the next call.\n\t\t */\n\t\t*rbpp = bp;\n\t\t*rsb = sb;\n\t}\n\t/*\n\t * Point to the summary information, modify/log it, and/or copy it out.\n\t */\n\tsp = XFS_SUMPTR(mp, bp, so);\n\tif (delta) {\n\t\tuint first = (uint)((char *)sp - (char *)bp->b_addr);\n\n\t\t*sp += delta;\n\t\txfs_trans_log_buf(tp, bp, first, first + sizeof(*sp) - 1);\n\t}\n\tif (sum)\n\t\t*sum = *sp;\n\treturn 0;\n}",
          "includes": [
            "#include \"xfs_rtalloc.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_buf.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_trans_space.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_rtalloc.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_buf.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_error.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nint\nxfs_rtmodify_summary_int(\n\txfs_mount_t\t*mp,\t\t/* file system mount structure */\n\txfs_trans_t\t*tp,\t\t/* transaction pointer */\n\tint\t\tlog,\t\t/* log2 of extent size */\n\txfs_rtblock_t\tbbno,\t\t/* bitmap block number */\n\tint\t\tdelta,\t\t/* change to make to summary info */\n\txfs_buf_t\t**rbpp,\t\t/* in/out: summary block buffer */\n\txfs_fsblock_t\t*rsb,\t\t/* in/out: summary block number */\n\txfs_suminfo_t\t*sum)\t\t/* out: summary info for this block */\n{\n\txfs_buf_t\t*bp;\t\t/* buffer for the summary block */\n\tint\t\terror;\t\t/* error value */\n\txfs_fsblock_t\tsb;\t\t/* summary fsblock */\n\tint\t\tso;\t\t/* index into the summary file */\n\txfs_suminfo_t\t*sp;\t\t/* pointer to returned data */\n\n\t/*\n\t * Compute entry number in the summary file.\n\t */\n\tso = XFS_SUMOFFS(mp, log, bbno);\n\t/*\n\t * Compute the block number in the summary file.\n\t */\n\tsb = XFS_SUMOFFSTOBLOCK(mp, so);\n\t/*\n\t * If we have an old buffer, and the block number matches, use that.\n\t */\n\tif (*rbpp && *rsb == sb)\n\t\tbp = *rbpp;\n\t/*\n\t * Otherwise we have to get the buffer.\n\t */\n\telse {\n\t\t/*\n\t\t * If there was an old one, get rid of it first.\n\t\t */\n\t\tif (*rbpp)\n\t\t\txfs_trans_brelse(tp, *rbpp);\n\t\terror = xfs_rtbuf_get(mp, tp, sb, 1, &bp);\n\t\tif (error) {\n\t\t\treturn error;\n\t\t}\n\t\t/*\n\t\t * Remember this buffer and block for the next call.\n\t\t */\n\t\t*rbpp = bp;\n\t\t*rsb = sb;\n\t}\n\t/*\n\t * Point to the summary information, modify/log it, and/or copy it out.\n\t */\n\tsp = XFS_SUMPTR(mp, bp, so);\n\tif (delta) {\n\t\tuint first = (uint)((char *)sp - (char *)bp->b_addr);\n\n\t\t*sp += delta;\n\t\txfs_trans_log_buf(tp, bp, first, first + sizeof(*sp) - 1);\n\t}\n\tif (sum)\n\t\t*sum = *sp;\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"xfs_rtalloc.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_buf.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_error.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nint\nxfs_rtmodify_summary(\n\txfs_mount_t\t*mp,\t\t/* file system mount structure */\n\txfs_trans_t\t*tp,\t\t/* transaction pointer */\n\tint\t\tlog,\t\t/* log2 of extent size */\n\txfs_rtblock_t\tbbno,\t\t/* bitmap block number */\n\tint\t\tdelta,\t\t/* change to make to summary info */\n\txfs_buf_t\t**rbpp,\t\t/* in/out: summary block buffer */\n\txfs_fsblock_t\t*rsb)\t\t/* in/out: summary block number */\n{\n\treturn xfs_rtmodify_summary_int(mp, tp, log, bbno,\n\t\t\t\t\tdelta, rbpp, rsb, NULL);\n}"
  },
  {
    "function_name": "xfs_rtmodify_summary_int",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_rtbitmap.c",
    "lines": "432-494",
    "snippet": "int\nxfs_rtmodify_summary_int(\n\txfs_mount_t\t*mp,\t\t/* file system mount structure */\n\txfs_trans_t\t*tp,\t\t/* transaction pointer */\n\tint\t\tlog,\t\t/* log2 of extent size */\n\txfs_rtblock_t\tbbno,\t\t/* bitmap block number */\n\tint\t\tdelta,\t\t/* change to make to summary info */\n\txfs_buf_t\t**rbpp,\t\t/* in/out: summary block buffer */\n\txfs_fsblock_t\t*rsb,\t\t/* in/out: summary block number */\n\txfs_suminfo_t\t*sum)\t\t/* out: summary info for this block */\n{\n\txfs_buf_t\t*bp;\t\t/* buffer for the summary block */\n\tint\t\terror;\t\t/* error value */\n\txfs_fsblock_t\tsb;\t\t/* summary fsblock */\n\tint\t\tso;\t\t/* index into the summary file */\n\txfs_suminfo_t\t*sp;\t\t/* pointer to returned data */\n\n\t/*\n\t * Compute entry number in the summary file.\n\t */\n\tso = XFS_SUMOFFS(mp, log, bbno);\n\t/*\n\t * Compute the block number in the summary file.\n\t */\n\tsb = XFS_SUMOFFSTOBLOCK(mp, so);\n\t/*\n\t * If we have an old buffer, and the block number matches, use that.\n\t */\n\tif (*rbpp && *rsb == sb)\n\t\tbp = *rbpp;\n\t/*\n\t * Otherwise we have to get the buffer.\n\t */\n\telse {\n\t\t/*\n\t\t * If there was an old one, get rid of it first.\n\t\t */\n\t\tif (*rbpp)\n\t\t\txfs_trans_brelse(tp, *rbpp);\n\t\terror = xfs_rtbuf_get(mp, tp, sb, 1, &bp);\n\t\tif (error) {\n\t\t\treturn error;\n\t\t}\n\t\t/*\n\t\t * Remember this buffer and block for the next call.\n\t\t */\n\t\t*rbpp = bp;\n\t\t*rsb = sb;\n\t}\n\t/*\n\t * Point to the summary information, modify/log it, and/or copy it out.\n\t */\n\tsp = XFS_SUMPTR(mp, bp, so);\n\tif (delta) {\n\t\tuint first = (uint)((char *)sp - (char *)bp->b_addr);\n\n\t\t*sp += delta;\n\t\txfs_trans_log_buf(tp, bp, first, first + sizeof(*sp) - 1);\n\t}\n\tif (sum)\n\t\t*sum = *sp;\n\treturn 0;\n}",
    "includes": [
      "#include \"xfs_rtalloc.h\"",
      "#include \"xfs_icache.h\"",
      "#include \"xfs_buf.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_trans_space.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_alloc.h\"",
      "#include \"xfs_bmap_btree.h\"",
      "#include \"xfs_bmap_util.h\"",
      "#include \"xfs_bmap.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_bit.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "xfs_trans_log_buf",
          "args": [
            "tp",
            "bp",
            "first",
            "first + sizeof(*sp) - 1"
          ],
          "line": 489
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_trans_log_buf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_trans_buf.c",
          "lines": "497-552",
          "snippet": "void\nxfs_trans_log_buf(xfs_trans_t\t*tp,\n\t\t  xfs_buf_t\t*bp,\n\t\t  uint\t\tfirst,\n\t\t  uint\t\tlast)\n{\n\txfs_buf_log_item_t\t*bip = bp->b_fspriv;\n\n\tASSERT(bp->b_transp == tp);\n\tASSERT(bip != NULL);\n\tASSERT(first <= last && last < BBTOB(bp->b_length));\n\tASSERT(bp->b_iodone == NULL ||\n\t       bp->b_iodone == xfs_buf_iodone_callbacks);\n\n\t/*\n\t * Mark the buffer as needing to be written out eventually,\n\t * and set its iodone function to remove the buffer's buf log\n\t * item from the AIL and free it when the buffer is flushed\n\t * to disk.  See xfs_buf_attach_iodone() for more details\n\t * on li_cb and xfs_buf_iodone_callbacks().\n\t * If we end up aborting this transaction, we trap this buffer\n\t * inside the b_bdstrat callback so that this won't get written to\n\t * disk.\n\t */\n\tXFS_BUF_DONE(bp);\n\n\tASSERT(atomic_read(&bip->bli_refcount) > 0);\n\tbp->b_iodone = xfs_buf_iodone_callbacks;\n\tbip->bli_item.li_cb = xfs_buf_iodone;\n\n\ttrace_xfs_trans_log_buf(bip);\n\n\t/*\n\t * If we invalidated the buffer within this transaction, then\n\t * cancel the invalidation now that we're dirtying the buffer\n\t * again.  There are no races with the code in xfs_buf_item_unpin(),\n\t * because we have a reference to the buffer this entire time.\n\t */\n\tif (bip->bli_flags & XFS_BLI_STALE) {\n\t\tbip->bli_flags &= ~XFS_BLI_STALE;\n\t\tASSERT(XFS_BUF_ISSTALE(bp));\n\t\tXFS_BUF_UNSTALE(bp);\n\t\tbip->__bli_format.blf_flags &= ~XFS_BLF_CANCEL;\n\t}\n\n\ttp->t_flags |= XFS_TRANS_DIRTY;\n\tbip->bli_item.li_desc->lid_flags |= XFS_LID_DIRTY;\n\n\t/*\n\t * If we have an ordered buffer we are not logging any dirty range but\n\t * it still needs to be marked dirty and that it has been logged.\n\t */\n\tbip->bli_flags |= XFS_BLI_DIRTY | XFS_BLI_LOGGED;\n\tif (!(bip->bli_flags & XFS_BLI_ORDERED))\n\t\txfs_buf_item_log(bip, first, last);\n}",
          "includes": [
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nvoid\nxfs_trans_log_buf(xfs_trans_t\t*tp,\n\t\t  xfs_buf_t\t*bp,\n\t\t  uint\t\tfirst,\n\t\t  uint\t\tlast)\n{\n\txfs_buf_log_item_t\t*bip = bp->b_fspriv;\n\n\tASSERT(bp->b_transp == tp);\n\tASSERT(bip != NULL);\n\tASSERT(first <= last && last < BBTOB(bp->b_length));\n\tASSERT(bp->b_iodone == NULL ||\n\t       bp->b_iodone == xfs_buf_iodone_callbacks);\n\n\t/*\n\t * Mark the buffer as needing to be written out eventually,\n\t * and set its iodone function to remove the buffer's buf log\n\t * item from the AIL and free it when the buffer is flushed\n\t * to disk.  See xfs_buf_attach_iodone() for more details\n\t * on li_cb and xfs_buf_iodone_callbacks().\n\t * If we end up aborting this transaction, we trap this buffer\n\t * inside the b_bdstrat callback so that this won't get written to\n\t * disk.\n\t */\n\tXFS_BUF_DONE(bp);\n\n\tASSERT(atomic_read(&bip->bli_refcount) > 0);\n\tbp->b_iodone = xfs_buf_iodone_callbacks;\n\tbip->bli_item.li_cb = xfs_buf_iodone;\n\n\ttrace_xfs_trans_log_buf(bip);\n\n\t/*\n\t * If we invalidated the buffer within this transaction, then\n\t * cancel the invalidation now that we're dirtying the buffer\n\t * again.  There are no races with the code in xfs_buf_item_unpin(),\n\t * because we have a reference to the buffer this entire time.\n\t */\n\tif (bip->bli_flags & XFS_BLI_STALE) {\n\t\tbip->bli_flags &= ~XFS_BLI_STALE;\n\t\tASSERT(XFS_BUF_ISSTALE(bp));\n\t\tXFS_BUF_UNSTALE(bp);\n\t\tbip->__bli_format.blf_flags &= ~XFS_BLF_CANCEL;\n\t}\n\n\ttp->t_flags |= XFS_TRANS_DIRTY;\n\tbip->bli_item.li_desc->lid_flags |= XFS_LID_DIRTY;\n\n\t/*\n\t * If we have an ordered buffer we are not logging any dirty range but\n\t * it still needs to be marked dirty and that it has been logged.\n\t */\n\tbip->bli_flags |= XFS_BLI_DIRTY | XFS_BLI_LOGGED;\n\tif (!(bip->bli_flags & XFS_BLI_ORDERED))\n\t\txfs_buf_item_log(bip, first, last);\n}"
        }
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "(char *)sp - (char *)bp->b_addr"
          ],
          "line": 486
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_SUMPTR",
          "args": [
            "mp",
            "bp",
            "so"
          ],
          "line": 484
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_rtbuf_get",
          "args": [
            "mp",
            "tp",
            "sb",
            "1",
            "&bp"
          ],
          "line": 471
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_rtbuf_get",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_rtbitmap.c",
          "lines": "48-76",
          "snippet": "int\nxfs_rtbuf_get(\n\txfs_mount_t\t*mp,\t\t/* file system mount structure */\n\txfs_trans_t\t*tp,\t\t/* transaction pointer */\n\txfs_rtblock_t\tblock,\t\t/* block number in bitmap or summary */\n\tint\t\tissum,\t\t/* is summary not bitmap */\n\txfs_buf_t\t**bpp)\t\t/* output: buffer for the block */\n{\n\txfs_buf_t\t*bp;\t\t/* block buffer, result */\n\txfs_inode_t\t*ip;\t\t/* bitmap or summary inode */\n\txfs_bmbt_irec_t\tmap;\n\tint\t\tnmap = 1;\n\tint\t\terror;\t\t/* error value */\n\n\tip = issum ? mp->m_rsumip : mp->m_rbmip;\n\n\terror = xfs_bmapi_read(ip, block, 1, &map, &nmap, XFS_DATA_FORK);\n\tif (error)\n\t\treturn error;\n\n\tASSERT(map.br_startblock != NULLFSBLOCK);\n\terror = xfs_trans_read_buf(mp, tp, mp->m_ddev_targp,\n\t\t\t\t   XFS_FSB_TO_DADDR(mp, map.br_startblock),\n\t\t\t\t   mp->m_bsize, 0, &bp, NULL);\n\tif (error)\n\t\treturn error;\n\t*bpp = bp;\n\treturn 0;\n}",
          "includes": [
            "#include \"xfs_rtalloc.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_buf.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_trans_space.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_rtalloc.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_buf.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_error.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nint\nxfs_rtbuf_get(\n\txfs_mount_t\t*mp,\t\t/* file system mount structure */\n\txfs_trans_t\t*tp,\t\t/* transaction pointer */\n\txfs_rtblock_t\tblock,\t\t/* block number in bitmap or summary */\n\tint\t\tissum,\t\t/* is summary not bitmap */\n\txfs_buf_t\t**bpp)\t\t/* output: buffer for the block */\n{\n\txfs_buf_t\t*bp;\t\t/* block buffer, result */\n\txfs_inode_t\t*ip;\t\t/* bitmap or summary inode */\n\txfs_bmbt_irec_t\tmap;\n\tint\t\tnmap = 1;\n\tint\t\terror;\t\t/* error value */\n\n\tip = issum ? mp->m_rsumip : mp->m_rbmip;\n\n\terror = xfs_bmapi_read(ip, block, 1, &map, &nmap, XFS_DATA_FORK);\n\tif (error)\n\t\treturn error;\n\n\tASSERT(map.br_startblock != NULLFSBLOCK);\n\terror = xfs_trans_read_buf(mp, tp, mp->m_ddev_targp,\n\t\t\t\t   XFS_FSB_TO_DADDR(mp, map.br_startblock),\n\t\t\t\t   mp->m_bsize, 0, &bp, NULL);\n\tif (error)\n\t\treturn error;\n\t*bpp = bp;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_trans_brelse",
          "args": [
            "tp",
            "*rbpp"
          ],
          "line": 470
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_trans_brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_trans_buf.c",
          "lines": "354-443",
          "snippet": "void\nxfs_trans_brelse(xfs_trans_t\t*tp,\n\t\t xfs_buf_t\t*bp)\n{\n\txfs_buf_log_item_t\t*bip;\n\n\t/*\n\t * Default to a normal brelse() call if the tp is NULL.\n\t */\n\tif (tp == NULL) {\n\t\tASSERT(bp->b_transp == NULL);\n\t\txfs_buf_relse(bp);\n\t\treturn;\n\t}\n\n\tASSERT(bp->b_transp == tp);\n\tbip = bp->b_fspriv;\n\tASSERT(bip->bli_item.li_type == XFS_LI_BUF);\n\tASSERT(!(bip->bli_flags & XFS_BLI_STALE));\n\tASSERT(!(bip->__bli_format.blf_flags & XFS_BLF_CANCEL));\n\tASSERT(atomic_read(&bip->bli_refcount) > 0);\n\n\ttrace_xfs_trans_brelse(bip);\n\n\t/*\n\t * If the release is just for a recursive lock,\n\t * then decrement the count and return.\n\t */\n\tif (bip->bli_recur > 0) {\n\t\tbip->bli_recur--;\n\t\treturn;\n\t}\n\n\t/*\n\t * If the buffer is dirty within this transaction, we can't\n\t * release it until we commit.\n\t */\n\tif (bip->bli_item.li_desc->lid_flags & XFS_LID_DIRTY)\n\t\treturn;\n\n\t/*\n\t * If the buffer has been invalidated, then we can't release\n\t * it until the transaction commits to disk unless it is re-dirtied\n\t * as part of this transaction.  This prevents us from pulling\n\t * the item from the AIL before we should.\n\t */\n\tif (bip->bli_flags & XFS_BLI_STALE)\n\t\treturn;\n\n\tASSERT(!(bip->bli_flags & XFS_BLI_LOGGED));\n\n\t/*\n\t * Free up the log item descriptor tracking the released item.\n\t */\n\txfs_trans_del_item(&bip->bli_item);\n\n\t/*\n\t * Clear the hold flag in the buf log item if it is set.\n\t * We wouldn't want the next user of the buffer to\n\t * get confused.\n\t */\n\tif (bip->bli_flags & XFS_BLI_HOLD) {\n\t\tbip->bli_flags &= ~XFS_BLI_HOLD;\n\t}\n\n\t/*\n\t * Drop our reference to the buf log item.\n\t */\n\tatomic_dec(&bip->bli_refcount);\n\n\t/*\n\t * If the buf item is not tracking data in the log, then\n\t * we must free it before releasing the buffer back to the\n\t * free pool.  Before releasing the buffer to the free pool,\n\t * clear the transaction pointer in b_fsprivate2 to dissolve\n\t * its relation to this transaction.\n\t */\n\tif (!xfs_buf_item_dirty(bip)) {\n/***\n\t\tASSERT(bp->b_pincount == 0);\n***/\n\t\tASSERT(atomic_read(&bip->bli_refcount) == 0);\n\t\tASSERT(!(bip->bli_item.li_flags & XFS_LI_IN_AIL));\n\t\tASSERT(!(bip->bli_flags & XFS_BLI_INODE_ALLOC_BUF));\n\t\txfs_buf_item_relse(bp);\n\t}\n\n\tbp->b_transp = NULL;\n\txfs_buf_relse(bp);\n}",
          "includes": [
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nvoid\nxfs_trans_brelse(xfs_trans_t\t*tp,\n\t\t xfs_buf_t\t*bp)\n{\n\txfs_buf_log_item_t\t*bip;\n\n\t/*\n\t * Default to a normal brelse() call if the tp is NULL.\n\t */\n\tif (tp == NULL) {\n\t\tASSERT(bp->b_transp == NULL);\n\t\txfs_buf_relse(bp);\n\t\treturn;\n\t}\n\n\tASSERT(bp->b_transp == tp);\n\tbip = bp->b_fspriv;\n\tASSERT(bip->bli_item.li_type == XFS_LI_BUF);\n\tASSERT(!(bip->bli_flags & XFS_BLI_STALE));\n\tASSERT(!(bip->__bli_format.blf_flags & XFS_BLF_CANCEL));\n\tASSERT(atomic_read(&bip->bli_refcount) > 0);\n\n\ttrace_xfs_trans_brelse(bip);\n\n\t/*\n\t * If the release is just for a recursive lock,\n\t * then decrement the count and return.\n\t */\n\tif (bip->bli_recur > 0) {\n\t\tbip->bli_recur--;\n\t\treturn;\n\t}\n\n\t/*\n\t * If the buffer is dirty within this transaction, we can't\n\t * release it until we commit.\n\t */\n\tif (bip->bli_item.li_desc->lid_flags & XFS_LID_DIRTY)\n\t\treturn;\n\n\t/*\n\t * If the buffer has been invalidated, then we can't release\n\t * it until the transaction commits to disk unless it is re-dirtied\n\t * as part of this transaction.  This prevents us from pulling\n\t * the item from the AIL before we should.\n\t */\n\tif (bip->bli_flags & XFS_BLI_STALE)\n\t\treturn;\n\n\tASSERT(!(bip->bli_flags & XFS_BLI_LOGGED));\n\n\t/*\n\t * Free up the log item descriptor tracking the released item.\n\t */\n\txfs_trans_del_item(&bip->bli_item);\n\n\t/*\n\t * Clear the hold flag in the buf log item if it is set.\n\t * We wouldn't want the next user of the buffer to\n\t * get confused.\n\t */\n\tif (bip->bli_flags & XFS_BLI_HOLD) {\n\t\tbip->bli_flags &= ~XFS_BLI_HOLD;\n\t}\n\n\t/*\n\t * Drop our reference to the buf log item.\n\t */\n\tatomic_dec(&bip->bli_refcount);\n\n\t/*\n\t * If the buf item is not tracking data in the log, then\n\t * we must free it before releasing the buffer back to the\n\t * free pool.  Before releasing the buffer to the free pool,\n\t * clear the transaction pointer in b_fsprivate2 to dissolve\n\t * its relation to this transaction.\n\t */\n\tif (!xfs_buf_item_dirty(bip)) {\n/***\n\t\tASSERT(bp->b_pincount == 0);\n***/\n\t\tASSERT(atomic_read(&bip->bli_refcount) == 0);\n\t\tASSERT(!(bip->bli_item.li_flags & XFS_LI_IN_AIL));\n\t\tASSERT(!(bip->bli_flags & XFS_BLI_INODE_ALLOC_BUF));\n\t\txfs_buf_item_relse(bp);\n\t}\n\n\tbp->b_transp = NULL;\n\txfs_buf_relse(bp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "XFS_SUMOFFSTOBLOCK",
          "args": [
            "mp",
            "so"
          ],
          "line": 456
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_SUMOFFS",
          "args": [
            "mp",
            "log",
            "bbno"
          ],
          "line": 452
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xfs_rtalloc.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_buf.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_error.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nint\nxfs_rtmodify_summary_int(\n\txfs_mount_t\t*mp,\t\t/* file system mount structure */\n\txfs_trans_t\t*tp,\t\t/* transaction pointer */\n\tint\t\tlog,\t\t/* log2 of extent size */\n\txfs_rtblock_t\tbbno,\t\t/* bitmap block number */\n\tint\t\tdelta,\t\t/* change to make to summary info */\n\txfs_buf_t\t**rbpp,\t\t/* in/out: summary block buffer */\n\txfs_fsblock_t\t*rsb,\t\t/* in/out: summary block number */\n\txfs_suminfo_t\t*sum)\t\t/* out: summary info for this block */\n{\n\txfs_buf_t\t*bp;\t\t/* buffer for the summary block */\n\tint\t\terror;\t\t/* error value */\n\txfs_fsblock_t\tsb;\t\t/* summary fsblock */\n\tint\t\tso;\t\t/* index into the summary file */\n\txfs_suminfo_t\t*sp;\t\t/* pointer to returned data */\n\n\t/*\n\t * Compute entry number in the summary file.\n\t */\n\tso = XFS_SUMOFFS(mp, log, bbno);\n\t/*\n\t * Compute the block number in the summary file.\n\t */\n\tsb = XFS_SUMOFFSTOBLOCK(mp, so);\n\t/*\n\t * If we have an old buffer, and the block number matches, use that.\n\t */\n\tif (*rbpp && *rsb == sb)\n\t\tbp = *rbpp;\n\t/*\n\t * Otherwise we have to get the buffer.\n\t */\n\telse {\n\t\t/*\n\t\t * If there was an old one, get rid of it first.\n\t\t */\n\t\tif (*rbpp)\n\t\t\txfs_trans_brelse(tp, *rbpp);\n\t\terror = xfs_rtbuf_get(mp, tp, sb, 1, &bp);\n\t\tif (error) {\n\t\t\treturn error;\n\t\t}\n\t\t/*\n\t\t * Remember this buffer and block for the next call.\n\t\t */\n\t\t*rbpp = bp;\n\t\t*rsb = sb;\n\t}\n\t/*\n\t * Point to the summary information, modify/log it, and/or copy it out.\n\t */\n\tsp = XFS_SUMPTR(mp, bp, so);\n\tif (delta) {\n\t\tuint first = (uint)((char *)sp - (char *)bp->b_addr);\n\n\t\t*sp += delta;\n\t\txfs_trans_log_buf(tp, bp, first, first + sizeof(*sp) - 1);\n\t}\n\tif (sum)\n\t\t*sum = *sp;\n\treturn 0;\n}"
  },
  {
    "function_name": "xfs_rtfind_forw",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_rtbitmap.c",
    "lines": "257-421",
    "snippet": "int\nxfs_rtfind_forw(\n\txfs_mount_t\t*mp,\t\t/* file system mount point */\n\txfs_trans_t\t*tp,\t\t/* transaction pointer */\n\txfs_rtblock_t\tstart,\t\t/* starting block to look at */\n\txfs_rtblock_t\tlimit,\t\t/* last block to look at */\n\txfs_rtblock_t\t*rtblock)\t/* out: start block found */\n{\n\txfs_rtword_t\t*b;\t\t/* current word in buffer */\n\tint\t\tbit;\t\t/* bit number in the word */\n\txfs_rtblock_t\tblock;\t\t/* bitmap block number */\n\txfs_buf_t\t*bp;\t\t/* buf for the block */\n\txfs_rtword_t\t*bufp;\t\t/* starting word in buffer */\n\tint\t\terror;\t\t/* error value */\n\txfs_rtblock_t\ti;\t\t/* current bit number rel. to start */\n\txfs_rtblock_t\tlastbit;\t/* last useful bit in the word */\n\txfs_rtblock_t\tlen;\t\t/* length of inspected area */\n\txfs_rtword_t\tmask;\t\t/* mask of relevant bits for value */\n\txfs_rtword_t\twant;\t\t/* mask for \"good\" values */\n\txfs_rtword_t\twdiff;\t\t/* difference from wanted value */\n\tint\t\tword;\t\t/* word number in the buffer */\n\n\t/*\n\t * Compute and read in starting bitmap block for starting block.\n\t */\n\tblock = XFS_BITTOBLOCK(mp, start);\n\terror = xfs_rtbuf_get(mp, tp, block, 0, &bp);\n\tif (error) {\n\t\treturn error;\n\t}\n\tbufp = bp->b_addr;\n\t/*\n\t * Get the first word's index & point to it.\n\t */\n\tword = XFS_BITTOWORD(mp, start);\n\tb = &bufp[word];\n\tbit = (int)(start & (XFS_NBWORD - 1));\n\tlen = limit - start + 1;\n\t/*\n\t * Compute match value, based on the bit at start: if 1 (free)\n\t * then all-ones, else all-zeroes.\n\t */\n\twant = (*b & ((xfs_rtword_t)1 << bit)) ? -1 : 0;\n\t/*\n\t * If the starting position is not word-aligned, deal with the\n\t * partial word.\n\t */\n\tif (bit) {\n\t\t/*\n\t\t * Calculate last (rightmost) bit number to look at,\n\t\t * and mask for all the relevant bits in this word.\n\t\t */\n\t\tlastbit = XFS_RTMIN(bit + len, XFS_NBWORD);\n\t\tmask = (((xfs_rtword_t)1 << (lastbit - bit)) - 1) << bit;\n\t\t/*\n\t\t * Calculate the difference between the value there\n\t\t * and what we're looking for.\n\t\t */\n\t\tif ((wdiff = (*b ^ want) & mask)) {\n\t\t\t/*\n\t\t\t * Different.  Mark where we are and return.\n\t\t\t */\n\t\t\txfs_trans_brelse(tp, bp);\n\t\t\ti = XFS_RTLOBIT(wdiff) - bit;\n\t\t\t*rtblock = start + i - 1;\n\t\t\treturn 0;\n\t\t}\n\t\ti = lastbit - bit;\n\t\t/*\n\t\t * Go on to next block if that's where the next word is\n\t\t * and we need the next word.\n\t\t */\n\t\tif (++word == XFS_BLOCKWSIZE(mp) && i < len) {\n\t\t\t/*\n\t\t\t * If done with this block, get the previous one.\n\t\t\t */\n\t\t\txfs_trans_brelse(tp, bp);\n\t\t\terror = xfs_rtbuf_get(mp, tp, ++block, 0, &bp);\n\t\t\tif (error) {\n\t\t\t\treturn error;\n\t\t\t}\n\t\t\tb = bufp = bp->b_addr;\n\t\t\tword = 0;\n\t\t} else {\n\t\t\t/*\n\t\t\t * Go on to the previous word in the buffer.\n\t\t\t */\n\t\t\tb++;\n\t\t}\n\t} else {\n\t\t/*\n\t\t * Starting on a word boundary, no partial word.\n\t\t */\n\t\ti = 0;\n\t}\n\t/*\n\t * Loop over whole words in buffers.  When we use up one buffer\n\t * we move on to the next one.\n\t */\n\twhile (len - i >= XFS_NBWORD) {\n\t\t/*\n\t\t * Compute difference between actual and desired value.\n\t\t */\n\t\tif ((wdiff = *b ^ want)) {\n\t\t\t/*\n\t\t\t * Different, mark where we are and return.\n\t\t\t */\n\t\t\txfs_trans_brelse(tp, bp);\n\t\t\ti += XFS_RTLOBIT(wdiff);\n\t\t\t*rtblock = start + i - 1;\n\t\t\treturn 0;\n\t\t}\n\t\ti += XFS_NBWORD;\n\t\t/*\n\t\t * Go on to next block if that's where the next word is\n\t\t * and we need the next word.\n\t\t */\n\t\tif (++word == XFS_BLOCKWSIZE(mp) && i < len) {\n\t\t\t/*\n\t\t\t * If done with this block, get the next one.\n\t\t\t */\n\t\t\txfs_trans_brelse(tp, bp);\n\t\t\terror = xfs_rtbuf_get(mp, tp, ++block, 0, &bp);\n\t\t\tif (error) {\n\t\t\t\treturn error;\n\t\t\t}\n\t\t\tb = bufp = bp->b_addr;\n\t\t\tword = 0;\n\t\t} else {\n\t\t\t/*\n\t\t\t * Go on to the next word in the buffer.\n\t\t\t */\n\t\t\tb++;\n\t\t}\n\t}\n\t/*\n\t * If not ending on a word boundary, deal with the last\n\t * (partial) word.\n\t */\n\tif ((lastbit = len - i)) {\n\t\t/*\n\t\t * Calculate mask for all the relevant bits in this word.\n\t\t */\n\t\tmask = ((xfs_rtword_t)1 << lastbit) - 1;\n\t\t/*\n\t\t * Compute difference between actual and desired value.\n\t\t */\n\t\tif ((wdiff = (*b ^ want) & mask)) {\n\t\t\t/*\n\t\t\t * Different, mark where we are and return.\n\t\t\t */\n\t\t\txfs_trans_brelse(tp, bp);\n\t\t\ti += XFS_RTLOBIT(wdiff);\n\t\t\t*rtblock = start + i - 1;\n\t\t\treturn 0;\n\t\t} else\n\t\t\ti = len;\n\t}\n\t/*\n\t * No match, return that we scanned the whole area.\n\t */\n\txfs_trans_brelse(tp, bp);\n\t*rtblock = start + i - 1;\n\treturn 0;\n}",
    "includes": [
      "#include \"xfs_rtalloc.h\"",
      "#include \"xfs_icache.h\"",
      "#include \"xfs_buf.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_trans_space.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_alloc.h\"",
      "#include \"xfs_bmap_btree.h\"",
      "#include \"xfs_bmap_util.h\"",
      "#include \"xfs_bmap.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_bit.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "xfs_trans_brelse",
          "args": [
            "tp",
            "bp"
          ],
          "line": 418
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_trans_brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_trans_buf.c",
          "lines": "354-443",
          "snippet": "void\nxfs_trans_brelse(xfs_trans_t\t*tp,\n\t\t xfs_buf_t\t*bp)\n{\n\txfs_buf_log_item_t\t*bip;\n\n\t/*\n\t * Default to a normal brelse() call if the tp is NULL.\n\t */\n\tif (tp == NULL) {\n\t\tASSERT(bp->b_transp == NULL);\n\t\txfs_buf_relse(bp);\n\t\treturn;\n\t}\n\n\tASSERT(bp->b_transp == tp);\n\tbip = bp->b_fspriv;\n\tASSERT(bip->bli_item.li_type == XFS_LI_BUF);\n\tASSERT(!(bip->bli_flags & XFS_BLI_STALE));\n\tASSERT(!(bip->__bli_format.blf_flags & XFS_BLF_CANCEL));\n\tASSERT(atomic_read(&bip->bli_refcount) > 0);\n\n\ttrace_xfs_trans_brelse(bip);\n\n\t/*\n\t * If the release is just for a recursive lock,\n\t * then decrement the count and return.\n\t */\n\tif (bip->bli_recur > 0) {\n\t\tbip->bli_recur--;\n\t\treturn;\n\t}\n\n\t/*\n\t * If the buffer is dirty within this transaction, we can't\n\t * release it until we commit.\n\t */\n\tif (bip->bli_item.li_desc->lid_flags & XFS_LID_DIRTY)\n\t\treturn;\n\n\t/*\n\t * If the buffer has been invalidated, then we can't release\n\t * it until the transaction commits to disk unless it is re-dirtied\n\t * as part of this transaction.  This prevents us from pulling\n\t * the item from the AIL before we should.\n\t */\n\tif (bip->bli_flags & XFS_BLI_STALE)\n\t\treturn;\n\n\tASSERT(!(bip->bli_flags & XFS_BLI_LOGGED));\n\n\t/*\n\t * Free up the log item descriptor tracking the released item.\n\t */\n\txfs_trans_del_item(&bip->bli_item);\n\n\t/*\n\t * Clear the hold flag in the buf log item if it is set.\n\t * We wouldn't want the next user of the buffer to\n\t * get confused.\n\t */\n\tif (bip->bli_flags & XFS_BLI_HOLD) {\n\t\tbip->bli_flags &= ~XFS_BLI_HOLD;\n\t}\n\n\t/*\n\t * Drop our reference to the buf log item.\n\t */\n\tatomic_dec(&bip->bli_refcount);\n\n\t/*\n\t * If the buf item is not tracking data in the log, then\n\t * we must free it before releasing the buffer back to the\n\t * free pool.  Before releasing the buffer to the free pool,\n\t * clear the transaction pointer in b_fsprivate2 to dissolve\n\t * its relation to this transaction.\n\t */\n\tif (!xfs_buf_item_dirty(bip)) {\n/***\n\t\tASSERT(bp->b_pincount == 0);\n***/\n\t\tASSERT(atomic_read(&bip->bli_refcount) == 0);\n\t\tASSERT(!(bip->bli_item.li_flags & XFS_LI_IN_AIL));\n\t\tASSERT(!(bip->bli_flags & XFS_BLI_INODE_ALLOC_BUF));\n\t\txfs_buf_item_relse(bp);\n\t}\n\n\tbp->b_transp = NULL;\n\txfs_buf_relse(bp);\n}",
          "includes": [
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nvoid\nxfs_trans_brelse(xfs_trans_t\t*tp,\n\t\t xfs_buf_t\t*bp)\n{\n\txfs_buf_log_item_t\t*bip;\n\n\t/*\n\t * Default to a normal brelse() call if the tp is NULL.\n\t */\n\tif (tp == NULL) {\n\t\tASSERT(bp->b_transp == NULL);\n\t\txfs_buf_relse(bp);\n\t\treturn;\n\t}\n\n\tASSERT(bp->b_transp == tp);\n\tbip = bp->b_fspriv;\n\tASSERT(bip->bli_item.li_type == XFS_LI_BUF);\n\tASSERT(!(bip->bli_flags & XFS_BLI_STALE));\n\tASSERT(!(bip->__bli_format.blf_flags & XFS_BLF_CANCEL));\n\tASSERT(atomic_read(&bip->bli_refcount) > 0);\n\n\ttrace_xfs_trans_brelse(bip);\n\n\t/*\n\t * If the release is just for a recursive lock,\n\t * then decrement the count and return.\n\t */\n\tif (bip->bli_recur > 0) {\n\t\tbip->bli_recur--;\n\t\treturn;\n\t}\n\n\t/*\n\t * If the buffer is dirty within this transaction, we can't\n\t * release it until we commit.\n\t */\n\tif (bip->bli_item.li_desc->lid_flags & XFS_LID_DIRTY)\n\t\treturn;\n\n\t/*\n\t * If the buffer has been invalidated, then we can't release\n\t * it until the transaction commits to disk unless it is re-dirtied\n\t * as part of this transaction.  This prevents us from pulling\n\t * the item from the AIL before we should.\n\t */\n\tif (bip->bli_flags & XFS_BLI_STALE)\n\t\treturn;\n\n\tASSERT(!(bip->bli_flags & XFS_BLI_LOGGED));\n\n\t/*\n\t * Free up the log item descriptor tracking the released item.\n\t */\n\txfs_trans_del_item(&bip->bli_item);\n\n\t/*\n\t * Clear the hold flag in the buf log item if it is set.\n\t * We wouldn't want the next user of the buffer to\n\t * get confused.\n\t */\n\tif (bip->bli_flags & XFS_BLI_HOLD) {\n\t\tbip->bli_flags &= ~XFS_BLI_HOLD;\n\t}\n\n\t/*\n\t * Drop our reference to the buf log item.\n\t */\n\tatomic_dec(&bip->bli_refcount);\n\n\t/*\n\t * If the buf item is not tracking data in the log, then\n\t * we must free it before releasing the buffer back to the\n\t * free pool.  Before releasing the buffer to the free pool,\n\t * clear the transaction pointer in b_fsprivate2 to dissolve\n\t * its relation to this transaction.\n\t */\n\tif (!xfs_buf_item_dirty(bip)) {\n/***\n\t\tASSERT(bp->b_pincount == 0);\n***/\n\t\tASSERT(atomic_read(&bip->bli_refcount) == 0);\n\t\tASSERT(!(bip->bli_item.li_flags & XFS_LI_IN_AIL));\n\t\tASSERT(!(bip->bli_flags & XFS_BLI_INODE_ALLOC_BUF));\n\t\txfs_buf_item_relse(bp);\n\t}\n\n\tbp->b_transp = NULL;\n\txfs_buf_relse(bp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "XFS_RTLOBIT",
          "args": [
            "wdiff"
          ],
          "line": 409
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_rtbuf_get",
          "args": [
            "mp",
            "tp",
            "++block",
            "0",
            "&bp"
          ],
          "line": 379
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_rtbuf_get",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_rtbitmap.c",
          "lines": "48-76",
          "snippet": "int\nxfs_rtbuf_get(\n\txfs_mount_t\t*mp,\t\t/* file system mount structure */\n\txfs_trans_t\t*tp,\t\t/* transaction pointer */\n\txfs_rtblock_t\tblock,\t\t/* block number in bitmap or summary */\n\tint\t\tissum,\t\t/* is summary not bitmap */\n\txfs_buf_t\t**bpp)\t\t/* output: buffer for the block */\n{\n\txfs_buf_t\t*bp;\t\t/* block buffer, result */\n\txfs_inode_t\t*ip;\t\t/* bitmap or summary inode */\n\txfs_bmbt_irec_t\tmap;\n\tint\t\tnmap = 1;\n\tint\t\terror;\t\t/* error value */\n\n\tip = issum ? mp->m_rsumip : mp->m_rbmip;\n\n\terror = xfs_bmapi_read(ip, block, 1, &map, &nmap, XFS_DATA_FORK);\n\tif (error)\n\t\treturn error;\n\n\tASSERT(map.br_startblock != NULLFSBLOCK);\n\terror = xfs_trans_read_buf(mp, tp, mp->m_ddev_targp,\n\t\t\t\t   XFS_FSB_TO_DADDR(mp, map.br_startblock),\n\t\t\t\t   mp->m_bsize, 0, &bp, NULL);\n\tif (error)\n\t\treturn error;\n\t*bpp = bp;\n\treturn 0;\n}",
          "includes": [
            "#include \"xfs_rtalloc.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_buf.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_trans_space.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_rtalloc.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_buf.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_error.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nint\nxfs_rtbuf_get(\n\txfs_mount_t\t*mp,\t\t/* file system mount structure */\n\txfs_trans_t\t*tp,\t\t/* transaction pointer */\n\txfs_rtblock_t\tblock,\t\t/* block number in bitmap or summary */\n\tint\t\tissum,\t\t/* is summary not bitmap */\n\txfs_buf_t\t**bpp)\t\t/* output: buffer for the block */\n{\n\txfs_buf_t\t*bp;\t\t/* block buffer, result */\n\txfs_inode_t\t*ip;\t\t/* bitmap or summary inode */\n\txfs_bmbt_irec_t\tmap;\n\tint\t\tnmap = 1;\n\tint\t\terror;\t\t/* error value */\n\n\tip = issum ? mp->m_rsumip : mp->m_rbmip;\n\n\terror = xfs_bmapi_read(ip, block, 1, &map, &nmap, XFS_DATA_FORK);\n\tif (error)\n\t\treturn error;\n\n\tASSERT(map.br_startblock != NULLFSBLOCK);\n\terror = xfs_trans_read_buf(mp, tp, mp->m_ddev_targp,\n\t\t\t\t   XFS_FSB_TO_DADDR(mp, map.br_startblock),\n\t\t\t\t   mp->m_bsize, 0, &bp, NULL);\n\tif (error)\n\t\treturn error;\n\t*bpp = bp;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "XFS_BLOCKWSIZE",
          "args": [
            "mp"
          ],
          "line": 374
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_RTLOBIT",
          "args": [
            "wdiff"
          ],
          "line": 365
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_BLOCKWSIZE",
          "args": [
            "mp"
          ],
          "line": 329
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_RTLOBIT",
          "args": [
            "wdiff"
          ],
          "line": 320
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_RTMIN",
          "args": [
            "bit + len",
            "XFS_NBWORD"
          ],
          "line": 309
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_BITTOWORD",
          "args": [
            "mp",
            "start"
          ],
          "line": 291
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_BITTOBLOCK",
          "args": [
            "mp",
            "start"
          ],
          "line": 282
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xfs_rtalloc.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_buf.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_error.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nint\nxfs_rtfind_forw(\n\txfs_mount_t\t*mp,\t\t/* file system mount point */\n\txfs_trans_t\t*tp,\t\t/* transaction pointer */\n\txfs_rtblock_t\tstart,\t\t/* starting block to look at */\n\txfs_rtblock_t\tlimit,\t\t/* last block to look at */\n\txfs_rtblock_t\t*rtblock)\t/* out: start block found */\n{\n\txfs_rtword_t\t*b;\t\t/* current word in buffer */\n\tint\t\tbit;\t\t/* bit number in the word */\n\txfs_rtblock_t\tblock;\t\t/* bitmap block number */\n\txfs_buf_t\t*bp;\t\t/* buf for the block */\n\txfs_rtword_t\t*bufp;\t\t/* starting word in buffer */\n\tint\t\terror;\t\t/* error value */\n\txfs_rtblock_t\ti;\t\t/* current bit number rel. to start */\n\txfs_rtblock_t\tlastbit;\t/* last useful bit in the word */\n\txfs_rtblock_t\tlen;\t\t/* length of inspected area */\n\txfs_rtword_t\tmask;\t\t/* mask of relevant bits for value */\n\txfs_rtword_t\twant;\t\t/* mask for \"good\" values */\n\txfs_rtword_t\twdiff;\t\t/* difference from wanted value */\n\tint\t\tword;\t\t/* word number in the buffer */\n\n\t/*\n\t * Compute and read in starting bitmap block for starting block.\n\t */\n\tblock = XFS_BITTOBLOCK(mp, start);\n\terror = xfs_rtbuf_get(mp, tp, block, 0, &bp);\n\tif (error) {\n\t\treturn error;\n\t}\n\tbufp = bp->b_addr;\n\t/*\n\t * Get the first word's index & point to it.\n\t */\n\tword = XFS_BITTOWORD(mp, start);\n\tb = &bufp[word];\n\tbit = (int)(start & (XFS_NBWORD - 1));\n\tlen = limit - start + 1;\n\t/*\n\t * Compute match value, based on the bit at start: if 1 (free)\n\t * then all-ones, else all-zeroes.\n\t */\n\twant = (*b & ((xfs_rtword_t)1 << bit)) ? -1 : 0;\n\t/*\n\t * If the starting position is not word-aligned, deal with the\n\t * partial word.\n\t */\n\tif (bit) {\n\t\t/*\n\t\t * Calculate last (rightmost) bit number to look at,\n\t\t * and mask for all the relevant bits in this word.\n\t\t */\n\t\tlastbit = XFS_RTMIN(bit + len, XFS_NBWORD);\n\t\tmask = (((xfs_rtword_t)1 << (lastbit - bit)) - 1) << bit;\n\t\t/*\n\t\t * Calculate the difference between the value there\n\t\t * and what we're looking for.\n\t\t */\n\t\tif ((wdiff = (*b ^ want) & mask)) {\n\t\t\t/*\n\t\t\t * Different.  Mark where we are and return.\n\t\t\t */\n\t\t\txfs_trans_brelse(tp, bp);\n\t\t\ti = XFS_RTLOBIT(wdiff) - bit;\n\t\t\t*rtblock = start + i - 1;\n\t\t\treturn 0;\n\t\t}\n\t\ti = lastbit - bit;\n\t\t/*\n\t\t * Go on to next block if that's where the next word is\n\t\t * and we need the next word.\n\t\t */\n\t\tif (++word == XFS_BLOCKWSIZE(mp) && i < len) {\n\t\t\t/*\n\t\t\t * If done with this block, get the previous one.\n\t\t\t */\n\t\t\txfs_trans_brelse(tp, bp);\n\t\t\terror = xfs_rtbuf_get(mp, tp, ++block, 0, &bp);\n\t\t\tif (error) {\n\t\t\t\treturn error;\n\t\t\t}\n\t\t\tb = bufp = bp->b_addr;\n\t\t\tword = 0;\n\t\t} else {\n\t\t\t/*\n\t\t\t * Go on to the previous word in the buffer.\n\t\t\t */\n\t\t\tb++;\n\t\t}\n\t} else {\n\t\t/*\n\t\t * Starting on a word boundary, no partial word.\n\t\t */\n\t\ti = 0;\n\t}\n\t/*\n\t * Loop over whole words in buffers.  When we use up one buffer\n\t * we move on to the next one.\n\t */\n\twhile (len - i >= XFS_NBWORD) {\n\t\t/*\n\t\t * Compute difference between actual and desired value.\n\t\t */\n\t\tif ((wdiff = *b ^ want)) {\n\t\t\t/*\n\t\t\t * Different, mark where we are and return.\n\t\t\t */\n\t\t\txfs_trans_brelse(tp, bp);\n\t\t\ti += XFS_RTLOBIT(wdiff);\n\t\t\t*rtblock = start + i - 1;\n\t\t\treturn 0;\n\t\t}\n\t\ti += XFS_NBWORD;\n\t\t/*\n\t\t * Go on to next block if that's where the next word is\n\t\t * and we need the next word.\n\t\t */\n\t\tif (++word == XFS_BLOCKWSIZE(mp) && i < len) {\n\t\t\t/*\n\t\t\t * If done with this block, get the next one.\n\t\t\t */\n\t\t\txfs_trans_brelse(tp, bp);\n\t\t\terror = xfs_rtbuf_get(mp, tp, ++block, 0, &bp);\n\t\t\tif (error) {\n\t\t\t\treturn error;\n\t\t\t}\n\t\t\tb = bufp = bp->b_addr;\n\t\t\tword = 0;\n\t\t} else {\n\t\t\t/*\n\t\t\t * Go on to the next word in the buffer.\n\t\t\t */\n\t\t\tb++;\n\t\t}\n\t}\n\t/*\n\t * If not ending on a word boundary, deal with the last\n\t * (partial) word.\n\t */\n\tif ((lastbit = len - i)) {\n\t\t/*\n\t\t * Calculate mask for all the relevant bits in this word.\n\t\t */\n\t\tmask = ((xfs_rtword_t)1 << lastbit) - 1;\n\t\t/*\n\t\t * Compute difference between actual and desired value.\n\t\t */\n\t\tif ((wdiff = (*b ^ want) & mask)) {\n\t\t\t/*\n\t\t\t * Different, mark where we are and return.\n\t\t\t */\n\t\t\txfs_trans_brelse(tp, bp);\n\t\t\ti += XFS_RTLOBIT(wdiff);\n\t\t\t*rtblock = start + i - 1;\n\t\t\treturn 0;\n\t\t} else\n\t\t\ti = len;\n\t}\n\t/*\n\t * No match, return that we scanned the whole area.\n\t */\n\txfs_trans_brelse(tp, bp);\n\t*rtblock = start + i - 1;\n\treturn 0;\n}"
  },
  {
    "function_name": "xfs_rtfind_back",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_rtbitmap.c",
    "lines": "82-251",
    "snippet": "int\nxfs_rtfind_back(\n\txfs_mount_t\t*mp,\t\t/* file system mount point */\n\txfs_trans_t\t*tp,\t\t/* transaction pointer */\n\txfs_rtblock_t\tstart,\t\t/* starting block to look at */\n\txfs_rtblock_t\tlimit,\t\t/* last block to look at */\n\txfs_rtblock_t\t*rtblock)\t/* out: start block found */\n{\n\txfs_rtword_t\t*b;\t\t/* current word in buffer */\n\tint\t\tbit;\t\t/* bit number in the word */\n\txfs_rtblock_t\tblock;\t\t/* bitmap block number */\n\txfs_buf_t\t*bp;\t\t/* buf for the block */\n\txfs_rtword_t\t*bufp;\t\t/* starting word in buffer */\n\tint\t\terror;\t\t/* error value */\n\txfs_rtblock_t\tfirstbit;\t/* first useful bit in the word */\n\txfs_rtblock_t\ti;\t\t/* current bit number rel. to start */\n\txfs_rtblock_t\tlen;\t\t/* length of inspected area */\n\txfs_rtword_t\tmask;\t\t/* mask of relevant bits for value */\n\txfs_rtword_t\twant;\t\t/* mask for \"good\" values */\n\txfs_rtword_t\twdiff;\t\t/* difference from wanted value */\n\tint\t\tword;\t\t/* word number in the buffer */\n\n\t/*\n\t * Compute and read in starting bitmap block for starting block.\n\t */\n\tblock = XFS_BITTOBLOCK(mp, start);\n\terror = xfs_rtbuf_get(mp, tp, block, 0, &bp);\n\tif (error) {\n\t\treturn error;\n\t}\n\tbufp = bp->b_addr;\n\t/*\n\t * Get the first word's index & point to it.\n\t */\n\tword = XFS_BITTOWORD(mp, start);\n\tb = &bufp[word];\n\tbit = (int)(start & (XFS_NBWORD - 1));\n\tlen = start - limit + 1;\n\t/*\n\t * Compute match value, based on the bit at start: if 1 (free)\n\t * then all-ones, else all-zeroes.\n\t */\n\twant = (*b & ((xfs_rtword_t)1 << bit)) ? -1 : 0;\n\t/*\n\t * If the starting position is not word-aligned, deal with the\n\t * partial word.\n\t */\n\tif (bit < XFS_NBWORD - 1) {\n\t\t/*\n\t\t * Calculate first (leftmost) bit number to look at,\n\t\t * and mask for all the relevant bits in this word.\n\t\t */\n\t\tfirstbit = XFS_RTMAX((xfs_srtblock_t)(bit - len + 1), 0);\n\t\tmask = (((xfs_rtword_t)1 << (bit - firstbit + 1)) - 1) <<\n\t\t\tfirstbit;\n\t\t/*\n\t\t * Calculate the difference between the value there\n\t\t * and what we're looking for.\n\t\t */\n\t\tif ((wdiff = (*b ^ want) & mask)) {\n\t\t\t/*\n\t\t\t * Different.  Mark where we are and return.\n\t\t\t */\n\t\t\txfs_trans_brelse(tp, bp);\n\t\t\ti = bit - XFS_RTHIBIT(wdiff);\n\t\t\t*rtblock = start - i + 1;\n\t\t\treturn 0;\n\t\t}\n\t\ti = bit - firstbit + 1;\n\t\t/*\n\t\t * Go on to previous block if that's where the previous word is\n\t\t * and we need the previous word.\n\t\t */\n\t\tif (--word == -1 && i < len) {\n\t\t\t/*\n\t\t\t * If done with this block, get the previous one.\n\t\t\t */\n\t\t\txfs_trans_brelse(tp, bp);\n\t\t\terror = xfs_rtbuf_get(mp, tp, --block, 0, &bp);\n\t\t\tif (error) {\n\t\t\t\treturn error;\n\t\t\t}\n\t\t\tbufp = bp->b_addr;\n\t\t\tword = XFS_BLOCKWMASK(mp);\n\t\t\tb = &bufp[word];\n\t\t} else {\n\t\t\t/*\n\t\t\t * Go on to the previous word in the buffer.\n\t\t\t */\n\t\t\tb--;\n\t\t}\n\t} else {\n\t\t/*\n\t\t * Starting on a word boundary, no partial word.\n\t\t */\n\t\ti = 0;\n\t}\n\t/*\n\t * Loop over whole words in buffers.  When we use up one buffer\n\t * we move on to the previous one.\n\t */\n\twhile (len - i >= XFS_NBWORD) {\n\t\t/*\n\t\t * Compute difference between actual and desired value.\n\t\t */\n\t\tif ((wdiff = *b ^ want)) {\n\t\t\t/*\n\t\t\t * Different, mark where we are and return.\n\t\t\t */\n\t\t\txfs_trans_brelse(tp, bp);\n\t\t\ti += XFS_NBWORD - 1 - XFS_RTHIBIT(wdiff);\n\t\t\t*rtblock = start - i + 1;\n\t\t\treturn 0;\n\t\t}\n\t\ti += XFS_NBWORD;\n\t\t/*\n\t\t * Go on to previous block if that's where the previous word is\n\t\t * and we need the previous word.\n\t\t */\n\t\tif (--word == -1 && i < len) {\n\t\t\t/*\n\t\t\t * If done with this block, get the previous one.\n\t\t\t */\n\t\t\txfs_trans_brelse(tp, bp);\n\t\t\terror = xfs_rtbuf_get(mp, tp, --block, 0, &bp);\n\t\t\tif (error) {\n\t\t\t\treturn error;\n\t\t\t}\n\t\t\tbufp = bp->b_addr;\n\t\t\tword = XFS_BLOCKWMASK(mp);\n\t\t\tb = &bufp[word];\n\t\t} else {\n\t\t\t/*\n\t\t\t * Go on to the previous word in the buffer.\n\t\t\t */\n\t\t\tb--;\n\t\t}\n\t}\n\t/*\n\t * If not ending on a word boundary, deal with the last\n\t * (partial) word.\n\t */\n\tif (len - i) {\n\t\t/*\n\t\t * Calculate first (leftmost) bit number to look at,\n\t\t * and mask for all the relevant bits in this word.\n\t\t */\n\t\tfirstbit = XFS_NBWORD - (len - i);\n\t\tmask = (((xfs_rtword_t)1 << (len - i)) - 1) << firstbit;\n\t\t/*\n\t\t * Compute difference between actual and desired value.\n\t\t */\n\t\tif ((wdiff = (*b ^ want) & mask)) {\n\t\t\t/*\n\t\t\t * Different, mark where we are and return.\n\t\t\t */\n\t\t\txfs_trans_brelse(tp, bp);\n\t\t\ti += XFS_NBWORD - 1 - XFS_RTHIBIT(wdiff);\n\t\t\t*rtblock = start - i + 1;\n\t\t\treturn 0;\n\t\t} else\n\t\t\ti = len;\n\t}\n\t/*\n\t * No match, return that we scanned the whole area.\n\t */\n\txfs_trans_brelse(tp, bp);\n\t*rtblock = start - i + 1;\n\treturn 0;\n}",
    "includes": [
      "#include \"xfs_rtalloc.h\"",
      "#include \"xfs_icache.h\"",
      "#include \"xfs_buf.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_trans_space.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_alloc.h\"",
      "#include \"xfs_bmap_btree.h\"",
      "#include \"xfs_bmap_util.h\"",
      "#include \"xfs_bmap.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_bit.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "xfs_trans_brelse",
          "args": [
            "tp",
            "bp"
          ],
          "line": 248
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_trans_brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_trans_buf.c",
          "lines": "354-443",
          "snippet": "void\nxfs_trans_brelse(xfs_trans_t\t*tp,\n\t\t xfs_buf_t\t*bp)\n{\n\txfs_buf_log_item_t\t*bip;\n\n\t/*\n\t * Default to a normal brelse() call if the tp is NULL.\n\t */\n\tif (tp == NULL) {\n\t\tASSERT(bp->b_transp == NULL);\n\t\txfs_buf_relse(bp);\n\t\treturn;\n\t}\n\n\tASSERT(bp->b_transp == tp);\n\tbip = bp->b_fspriv;\n\tASSERT(bip->bli_item.li_type == XFS_LI_BUF);\n\tASSERT(!(bip->bli_flags & XFS_BLI_STALE));\n\tASSERT(!(bip->__bli_format.blf_flags & XFS_BLF_CANCEL));\n\tASSERT(atomic_read(&bip->bli_refcount) > 0);\n\n\ttrace_xfs_trans_brelse(bip);\n\n\t/*\n\t * If the release is just for a recursive lock,\n\t * then decrement the count and return.\n\t */\n\tif (bip->bli_recur > 0) {\n\t\tbip->bli_recur--;\n\t\treturn;\n\t}\n\n\t/*\n\t * If the buffer is dirty within this transaction, we can't\n\t * release it until we commit.\n\t */\n\tif (bip->bli_item.li_desc->lid_flags & XFS_LID_DIRTY)\n\t\treturn;\n\n\t/*\n\t * If the buffer has been invalidated, then we can't release\n\t * it until the transaction commits to disk unless it is re-dirtied\n\t * as part of this transaction.  This prevents us from pulling\n\t * the item from the AIL before we should.\n\t */\n\tif (bip->bli_flags & XFS_BLI_STALE)\n\t\treturn;\n\n\tASSERT(!(bip->bli_flags & XFS_BLI_LOGGED));\n\n\t/*\n\t * Free up the log item descriptor tracking the released item.\n\t */\n\txfs_trans_del_item(&bip->bli_item);\n\n\t/*\n\t * Clear the hold flag in the buf log item if it is set.\n\t * We wouldn't want the next user of the buffer to\n\t * get confused.\n\t */\n\tif (bip->bli_flags & XFS_BLI_HOLD) {\n\t\tbip->bli_flags &= ~XFS_BLI_HOLD;\n\t}\n\n\t/*\n\t * Drop our reference to the buf log item.\n\t */\n\tatomic_dec(&bip->bli_refcount);\n\n\t/*\n\t * If the buf item is not tracking data in the log, then\n\t * we must free it before releasing the buffer back to the\n\t * free pool.  Before releasing the buffer to the free pool,\n\t * clear the transaction pointer in b_fsprivate2 to dissolve\n\t * its relation to this transaction.\n\t */\n\tif (!xfs_buf_item_dirty(bip)) {\n/***\n\t\tASSERT(bp->b_pincount == 0);\n***/\n\t\tASSERT(atomic_read(&bip->bli_refcount) == 0);\n\t\tASSERT(!(bip->bli_item.li_flags & XFS_LI_IN_AIL));\n\t\tASSERT(!(bip->bli_flags & XFS_BLI_INODE_ALLOC_BUF));\n\t\txfs_buf_item_relse(bp);\n\t}\n\n\tbp->b_transp = NULL;\n\txfs_buf_relse(bp);\n}",
          "includes": [
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nvoid\nxfs_trans_brelse(xfs_trans_t\t*tp,\n\t\t xfs_buf_t\t*bp)\n{\n\txfs_buf_log_item_t\t*bip;\n\n\t/*\n\t * Default to a normal brelse() call if the tp is NULL.\n\t */\n\tif (tp == NULL) {\n\t\tASSERT(bp->b_transp == NULL);\n\t\txfs_buf_relse(bp);\n\t\treturn;\n\t}\n\n\tASSERT(bp->b_transp == tp);\n\tbip = bp->b_fspriv;\n\tASSERT(bip->bli_item.li_type == XFS_LI_BUF);\n\tASSERT(!(bip->bli_flags & XFS_BLI_STALE));\n\tASSERT(!(bip->__bli_format.blf_flags & XFS_BLF_CANCEL));\n\tASSERT(atomic_read(&bip->bli_refcount) > 0);\n\n\ttrace_xfs_trans_brelse(bip);\n\n\t/*\n\t * If the release is just for a recursive lock,\n\t * then decrement the count and return.\n\t */\n\tif (bip->bli_recur > 0) {\n\t\tbip->bli_recur--;\n\t\treturn;\n\t}\n\n\t/*\n\t * If the buffer is dirty within this transaction, we can't\n\t * release it until we commit.\n\t */\n\tif (bip->bli_item.li_desc->lid_flags & XFS_LID_DIRTY)\n\t\treturn;\n\n\t/*\n\t * If the buffer has been invalidated, then we can't release\n\t * it until the transaction commits to disk unless it is re-dirtied\n\t * as part of this transaction.  This prevents us from pulling\n\t * the item from the AIL before we should.\n\t */\n\tif (bip->bli_flags & XFS_BLI_STALE)\n\t\treturn;\n\n\tASSERT(!(bip->bli_flags & XFS_BLI_LOGGED));\n\n\t/*\n\t * Free up the log item descriptor tracking the released item.\n\t */\n\txfs_trans_del_item(&bip->bli_item);\n\n\t/*\n\t * Clear the hold flag in the buf log item if it is set.\n\t * We wouldn't want the next user of the buffer to\n\t * get confused.\n\t */\n\tif (bip->bli_flags & XFS_BLI_HOLD) {\n\t\tbip->bli_flags &= ~XFS_BLI_HOLD;\n\t}\n\n\t/*\n\t * Drop our reference to the buf log item.\n\t */\n\tatomic_dec(&bip->bli_refcount);\n\n\t/*\n\t * If the buf item is not tracking data in the log, then\n\t * we must free it before releasing the buffer back to the\n\t * free pool.  Before releasing the buffer to the free pool,\n\t * clear the transaction pointer in b_fsprivate2 to dissolve\n\t * its relation to this transaction.\n\t */\n\tif (!xfs_buf_item_dirty(bip)) {\n/***\n\t\tASSERT(bp->b_pincount == 0);\n***/\n\t\tASSERT(atomic_read(&bip->bli_refcount) == 0);\n\t\tASSERT(!(bip->bli_item.li_flags & XFS_LI_IN_AIL));\n\t\tASSERT(!(bip->bli_flags & XFS_BLI_INODE_ALLOC_BUF));\n\t\txfs_buf_item_relse(bp);\n\t}\n\n\tbp->b_transp = NULL;\n\txfs_buf_relse(bp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "XFS_RTHIBIT",
          "args": [
            "wdiff"
          ],
          "line": 239
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_BLOCKWMASK",
          "args": [
            "mp"
          ],
          "line": 211
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_rtbuf_get",
          "args": [
            "mp",
            "tp",
            "--block",
            "0",
            "&bp"
          ],
          "line": 206
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_rtbuf_get",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_rtbitmap.c",
          "lines": "48-76",
          "snippet": "int\nxfs_rtbuf_get(\n\txfs_mount_t\t*mp,\t\t/* file system mount structure */\n\txfs_trans_t\t*tp,\t\t/* transaction pointer */\n\txfs_rtblock_t\tblock,\t\t/* block number in bitmap or summary */\n\tint\t\tissum,\t\t/* is summary not bitmap */\n\txfs_buf_t\t**bpp)\t\t/* output: buffer for the block */\n{\n\txfs_buf_t\t*bp;\t\t/* block buffer, result */\n\txfs_inode_t\t*ip;\t\t/* bitmap or summary inode */\n\txfs_bmbt_irec_t\tmap;\n\tint\t\tnmap = 1;\n\tint\t\terror;\t\t/* error value */\n\n\tip = issum ? mp->m_rsumip : mp->m_rbmip;\n\n\terror = xfs_bmapi_read(ip, block, 1, &map, &nmap, XFS_DATA_FORK);\n\tif (error)\n\t\treturn error;\n\n\tASSERT(map.br_startblock != NULLFSBLOCK);\n\terror = xfs_trans_read_buf(mp, tp, mp->m_ddev_targp,\n\t\t\t\t   XFS_FSB_TO_DADDR(mp, map.br_startblock),\n\t\t\t\t   mp->m_bsize, 0, &bp, NULL);\n\tif (error)\n\t\treturn error;\n\t*bpp = bp;\n\treturn 0;\n}",
          "includes": [
            "#include \"xfs_rtalloc.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_buf.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_trans_space.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_rtalloc.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_buf.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_error.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nint\nxfs_rtbuf_get(\n\txfs_mount_t\t*mp,\t\t/* file system mount structure */\n\txfs_trans_t\t*tp,\t\t/* transaction pointer */\n\txfs_rtblock_t\tblock,\t\t/* block number in bitmap or summary */\n\tint\t\tissum,\t\t/* is summary not bitmap */\n\txfs_buf_t\t**bpp)\t\t/* output: buffer for the block */\n{\n\txfs_buf_t\t*bp;\t\t/* block buffer, result */\n\txfs_inode_t\t*ip;\t\t/* bitmap or summary inode */\n\txfs_bmbt_irec_t\tmap;\n\tint\t\tnmap = 1;\n\tint\t\terror;\t\t/* error value */\n\n\tip = issum ? mp->m_rsumip : mp->m_rbmip;\n\n\terror = xfs_bmapi_read(ip, block, 1, &map, &nmap, XFS_DATA_FORK);\n\tif (error)\n\t\treturn error;\n\n\tASSERT(map.br_startblock != NULLFSBLOCK);\n\terror = xfs_trans_read_buf(mp, tp, mp->m_ddev_targp,\n\t\t\t\t   XFS_FSB_TO_DADDR(mp, map.br_startblock),\n\t\t\t\t   mp->m_bsize, 0, &bp, NULL);\n\tif (error)\n\t\treturn error;\n\t*bpp = bp;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "XFS_RTHIBIT",
          "args": [
            "wdiff"
          ],
          "line": 192
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_BLOCKWMASK",
          "args": [
            "mp"
          ],
          "line": 165
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_RTHIBIT",
          "args": [
            "wdiff"
          ],
          "line": 146
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_RTMAX",
          "args": [
            "(xfs_srtblock_t)(bit - len + 1)",
            "0"
          ],
          "line": 134
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "bit - len + 1"
          ],
          "line": 134
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_BITTOWORD",
          "args": [
            "mp",
            "start"
          ],
          "line": 116
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_BITTOBLOCK",
          "args": [
            "mp",
            "start"
          ],
          "line": 107
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xfs_rtalloc.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_buf.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_error.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nint\nxfs_rtfind_back(\n\txfs_mount_t\t*mp,\t\t/* file system mount point */\n\txfs_trans_t\t*tp,\t\t/* transaction pointer */\n\txfs_rtblock_t\tstart,\t\t/* starting block to look at */\n\txfs_rtblock_t\tlimit,\t\t/* last block to look at */\n\txfs_rtblock_t\t*rtblock)\t/* out: start block found */\n{\n\txfs_rtword_t\t*b;\t\t/* current word in buffer */\n\tint\t\tbit;\t\t/* bit number in the word */\n\txfs_rtblock_t\tblock;\t\t/* bitmap block number */\n\txfs_buf_t\t*bp;\t\t/* buf for the block */\n\txfs_rtword_t\t*bufp;\t\t/* starting word in buffer */\n\tint\t\terror;\t\t/* error value */\n\txfs_rtblock_t\tfirstbit;\t/* first useful bit in the word */\n\txfs_rtblock_t\ti;\t\t/* current bit number rel. to start */\n\txfs_rtblock_t\tlen;\t\t/* length of inspected area */\n\txfs_rtword_t\tmask;\t\t/* mask of relevant bits for value */\n\txfs_rtword_t\twant;\t\t/* mask for \"good\" values */\n\txfs_rtword_t\twdiff;\t\t/* difference from wanted value */\n\tint\t\tword;\t\t/* word number in the buffer */\n\n\t/*\n\t * Compute and read in starting bitmap block for starting block.\n\t */\n\tblock = XFS_BITTOBLOCK(mp, start);\n\terror = xfs_rtbuf_get(mp, tp, block, 0, &bp);\n\tif (error) {\n\t\treturn error;\n\t}\n\tbufp = bp->b_addr;\n\t/*\n\t * Get the first word's index & point to it.\n\t */\n\tword = XFS_BITTOWORD(mp, start);\n\tb = &bufp[word];\n\tbit = (int)(start & (XFS_NBWORD - 1));\n\tlen = start - limit + 1;\n\t/*\n\t * Compute match value, based on the bit at start: if 1 (free)\n\t * then all-ones, else all-zeroes.\n\t */\n\twant = (*b & ((xfs_rtword_t)1 << bit)) ? -1 : 0;\n\t/*\n\t * If the starting position is not word-aligned, deal with the\n\t * partial word.\n\t */\n\tif (bit < XFS_NBWORD - 1) {\n\t\t/*\n\t\t * Calculate first (leftmost) bit number to look at,\n\t\t * and mask for all the relevant bits in this word.\n\t\t */\n\t\tfirstbit = XFS_RTMAX((xfs_srtblock_t)(bit - len + 1), 0);\n\t\tmask = (((xfs_rtword_t)1 << (bit - firstbit + 1)) - 1) <<\n\t\t\tfirstbit;\n\t\t/*\n\t\t * Calculate the difference between the value there\n\t\t * and what we're looking for.\n\t\t */\n\t\tif ((wdiff = (*b ^ want) & mask)) {\n\t\t\t/*\n\t\t\t * Different.  Mark where we are and return.\n\t\t\t */\n\t\t\txfs_trans_brelse(tp, bp);\n\t\t\ti = bit - XFS_RTHIBIT(wdiff);\n\t\t\t*rtblock = start - i + 1;\n\t\t\treturn 0;\n\t\t}\n\t\ti = bit - firstbit + 1;\n\t\t/*\n\t\t * Go on to previous block if that's where the previous word is\n\t\t * and we need the previous word.\n\t\t */\n\t\tif (--word == -1 && i < len) {\n\t\t\t/*\n\t\t\t * If done with this block, get the previous one.\n\t\t\t */\n\t\t\txfs_trans_brelse(tp, bp);\n\t\t\terror = xfs_rtbuf_get(mp, tp, --block, 0, &bp);\n\t\t\tif (error) {\n\t\t\t\treturn error;\n\t\t\t}\n\t\t\tbufp = bp->b_addr;\n\t\t\tword = XFS_BLOCKWMASK(mp);\n\t\t\tb = &bufp[word];\n\t\t} else {\n\t\t\t/*\n\t\t\t * Go on to the previous word in the buffer.\n\t\t\t */\n\t\t\tb--;\n\t\t}\n\t} else {\n\t\t/*\n\t\t * Starting on a word boundary, no partial word.\n\t\t */\n\t\ti = 0;\n\t}\n\t/*\n\t * Loop over whole words in buffers.  When we use up one buffer\n\t * we move on to the previous one.\n\t */\n\twhile (len - i >= XFS_NBWORD) {\n\t\t/*\n\t\t * Compute difference between actual and desired value.\n\t\t */\n\t\tif ((wdiff = *b ^ want)) {\n\t\t\t/*\n\t\t\t * Different, mark where we are and return.\n\t\t\t */\n\t\t\txfs_trans_brelse(tp, bp);\n\t\t\ti += XFS_NBWORD - 1 - XFS_RTHIBIT(wdiff);\n\t\t\t*rtblock = start - i + 1;\n\t\t\treturn 0;\n\t\t}\n\t\ti += XFS_NBWORD;\n\t\t/*\n\t\t * Go on to previous block if that's where the previous word is\n\t\t * and we need the previous word.\n\t\t */\n\t\tif (--word == -1 && i < len) {\n\t\t\t/*\n\t\t\t * If done with this block, get the previous one.\n\t\t\t */\n\t\t\txfs_trans_brelse(tp, bp);\n\t\t\terror = xfs_rtbuf_get(mp, tp, --block, 0, &bp);\n\t\t\tif (error) {\n\t\t\t\treturn error;\n\t\t\t}\n\t\t\tbufp = bp->b_addr;\n\t\t\tword = XFS_BLOCKWMASK(mp);\n\t\t\tb = &bufp[word];\n\t\t} else {\n\t\t\t/*\n\t\t\t * Go on to the previous word in the buffer.\n\t\t\t */\n\t\t\tb--;\n\t\t}\n\t}\n\t/*\n\t * If not ending on a word boundary, deal with the last\n\t * (partial) word.\n\t */\n\tif (len - i) {\n\t\t/*\n\t\t * Calculate first (leftmost) bit number to look at,\n\t\t * and mask for all the relevant bits in this word.\n\t\t */\n\t\tfirstbit = XFS_NBWORD - (len - i);\n\t\tmask = (((xfs_rtword_t)1 << (len - i)) - 1) << firstbit;\n\t\t/*\n\t\t * Compute difference between actual and desired value.\n\t\t */\n\t\tif ((wdiff = (*b ^ want) & mask)) {\n\t\t\t/*\n\t\t\t * Different, mark where we are and return.\n\t\t\t */\n\t\t\txfs_trans_brelse(tp, bp);\n\t\t\ti += XFS_NBWORD - 1 - XFS_RTHIBIT(wdiff);\n\t\t\t*rtblock = start - i + 1;\n\t\t\treturn 0;\n\t\t} else\n\t\t\ti = len;\n\t}\n\t/*\n\t * No match, return that we scanned the whole area.\n\t */\n\txfs_trans_brelse(tp, bp);\n\t*rtblock = start - i + 1;\n\treturn 0;\n}"
  },
  {
    "function_name": "xfs_rtbuf_get",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_rtbitmap.c",
    "lines": "48-76",
    "snippet": "int\nxfs_rtbuf_get(\n\txfs_mount_t\t*mp,\t\t/* file system mount structure */\n\txfs_trans_t\t*tp,\t\t/* transaction pointer */\n\txfs_rtblock_t\tblock,\t\t/* block number in bitmap or summary */\n\tint\t\tissum,\t\t/* is summary not bitmap */\n\txfs_buf_t\t**bpp)\t\t/* output: buffer for the block */\n{\n\txfs_buf_t\t*bp;\t\t/* block buffer, result */\n\txfs_inode_t\t*ip;\t\t/* bitmap or summary inode */\n\txfs_bmbt_irec_t\tmap;\n\tint\t\tnmap = 1;\n\tint\t\terror;\t\t/* error value */\n\n\tip = issum ? mp->m_rsumip : mp->m_rbmip;\n\n\terror = xfs_bmapi_read(ip, block, 1, &map, &nmap, XFS_DATA_FORK);\n\tif (error)\n\t\treturn error;\n\n\tASSERT(map.br_startblock != NULLFSBLOCK);\n\terror = xfs_trans_read_buf(mp, tp, mp->m_ddev_targp,\n\t\t\t\t   XFS_FSB_TO_DADDR(mp, map.br_startblock),\n\t\t\t\t   mp->m_bsize, 0, &bp, NULL);\n\tif (error)\n\t\treturn error;\n\t*bpp = bp;\n\treturn 0;\n}",
    "includes": [
      "#include \"xfs_rtalloc.h\"",
      "#include \"xfs_icache.h\"",
      "#include \"xfs_buf.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_trans_space.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_alloc.h\"",
      "#include \"xfs_bmap_btree.h\"",
      "#include \"xfs_bmap_util.h\"",
      "#include \"xfs_bmap.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_bit.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "xfs_trans_read_buf",
          "args": [
            "mp",
            "tp",
            "mp->m_ddev_targp",
            "XFS_FSB_TO_DADDR(mp, map.br_startblock)",
            "mp->m_bsize",
            "0",
            "&bp",
            "NULL"
          ],
          "line": 69
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_trans_read_buf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_trans.h",
          "lines": "186-200",
          "snippet": "static inline int\nxfs_trans_read_buf(\n\tstruct xfs_mount\t*mp,\n\tstruct xfs_trans\t*tp,\n\tstruct xfs_buftarg\t*target,\n\txfs_daddr_t\t\tblkno,\n\tint\t\t\tnumblks,\n\txfs_buf_flags_t\t\tflags,\n\tstruct xfs_buf\t\t**bpp,\n\tconst struct xfs_buf_ops *ops)\n{\n\tDEFINE_SINGLE_BUF_MAP(map, blkno, numblks);\n\treturn xfs_trans_read_buf_map(mp, tp, target, &map, 1,\n\t\t\t\t      flags, bpp, ops);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline int\nxfs_trans_read_buf(\n\tstruct xfs_mount\t*mp,\n\tstruct xfs_trans\t*tp,\n\tstruct xfs_buftarg\t*target,\n\txfs_daddr_t\t\tblkno,\n\tint\t\t\tnumblks,\n\txfs_buf_flags_t\t\tflags,\n\tstruct xfs_buf\t\t**bpp,\n\tconst struct xfs_buf_ops *ops)\n{\n\tDEFINE_SINGLE_BUF_MAP(map, blkno, numblks);\n\treturn xfs_trans_read_buf_map(mp, tp, target, &map, 1,\n\t\t\t\t      flags, bpp, ops);\n}"
        }
      },
      {
        "call_info": {
          "callee": "XFS_FSB_TO_DADDR",
          "args": [
            "mp",
            "map.br_startblock"
          ],
          "line": 70
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "map.br_startblock != NULLFSBLOCK"
          ],
          "line": 68
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_bmapi_read",
          "args": [
            "ip",
            "block",
            "1",
            "&map",
            "&nmap",
            "XFS_DATA_FORK"
          ],
          "line": 64
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_bmapi_read",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_bmap.c",
          "lines": "4017-4103",
          "snippet": "int\nxfs_bmapi_read(\n\tstruct xfs_inode\t*ip,\n\txfs_fileoff_t\t\tbno,\n\txfs_filblks_t\t\tlen,\n\tstruct xfs_bmbt_irec\t*mval,\n\tint\t\t\t*nmap,\n\tint\t\t\tflags)\n{\n\tstruct xfs_mount\t*mp = ip->i_mount;\n\tstruct xfs_ifork\t*ifp;\n\tstruct xfs_bmbt_irec\tgot;\n\tstruct xfs_bmbt_irec\tprev;\n\txfs_fileoff_t\t\tobno;\n\txfs_fileoff_t\t\tend;\n\txfs_extnum_t\t\tlastx;\n\tint\t\t\terror;\n\tint\t\t\teof;\n\tint\t\t\tn = 0;\n\tint\t\t\twhichfork = (flags & XFS_BMAPI_ATTRFORK) ?\n\t\t\t\t\t\tXFS_ATTR_FORK : XFS_DATA_FORK;\n\n\tASSERT(*nmap >= 1);\n\tASSERT(!(flags & ~(XFS_BMAPI_ATTRFORK|XFS_BMAPI_ENTIRE|\n\t\t\t   XFS_BMAPI_IGSTATE)));\n\tASSERT(xfs_isilocked(ip, XFS_ILOCK_SHARED|XFS_ILOCK_EXCL));\n\n\tif (unlikely(XFS_TEST_ERROR(\n\t    (XFS_IFORK_FORMAT(ip, whichfork) != XFS_DINODE_FMT_EXTENTS &&\n\t     XFS_IFORK_FORMAT(ip, whichfork) != XFS_DINODE_FMT_BTREE),\n\t     mp, XFS_ERRTAG_BMAPIFORMAT, XFS_RANDOM_BMAPIFORMAT))) {\n\t\tXFS_ERROR_REPORT(\"xfs_bmapi_read\", XFS_ERRLEVEL_LOW, mp);\n\t\treturn -EFSCORRUPTED;\n\t}\n\n\tif (XFS_FORCED_SHUTDOWN(mp))\n\t\treturn -EIO;\n\n\tXFS_STATS_INC(xs_blk_mapr);\n\n\tifp = XFS_IFORK_PTR(ip, whichfork);\n\n\tif (!(ifp->if_flags & XFS_IFEXTENTS)) {\n\t\terror = xfs_iread_extents(NULL, ip, whichfork);\n\t\tif (error)\n\t\t\treturn error;\n\t}\n\n\txfs_bmap_search_extents(ip, bno, whichfork, &eof, &lastx, &got, &prev);\n\tend = bno + len;\n\tobno = bno;\n\n\twhile (bno < end && n < *nmap) {\n\t\t/* Reading past eof, act as though there's a hole up to end. */\n\t\tif (eof)\n\t\t\tgot.br_startoff = end;\n\t\tif (got.br_startoff > bno) {\n\t\t\t/* Reading in a hole.  */\n\t\t\tmval->br_startoff = bno;\n\t\t\tmval->br_startblock = HOLESTARTBLOCK;\n\t\t\tmval->br_blockcount =\n\t\t\t\tXFS_FILBLKS_MIN(len, got.br_startoff - bno);\n\t\t\tmval->br_state = XFS_EXT_NORM;\n\t\t\tbno += mval->br_blockcount;\n\t\t\tlen -= mval->br_blockcount;\n\t\t\tmval++;\n\t\t\tn++;\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* set up the extent map to return. */\n\t\txfs_bmapi_trim_map(mval, &got, &bno, len, obno, end, n, flags);\n\t\txfs_bmapi_update_map(&mval, &bno, &len, obno, end, &n, flags);\n\n\t\t/* If we're done, stop now. */\n\t\tif (bno >= end || n >= *nmap)\n\t\t\tbreak;\n\n\t\t/* Else go on to the next record. */\n\t\tif (++lastx < ifp->if_bytes / sizeof(xfs_bmbt_rec_t))\n\t\t\txfs_bmbt_get_all(xfs_iext_get_ext(ifp, lastx), &got);\n\t\telse\n\t\t\teof = 1;\n\t}\n\t*nmap = n;\n\treturn 0;\n}",
          "includes": [
            "#include \"xfs_filestream.h\"",
            "#include \"xfs_attr_leaf.h\"",
            "#include \"xfs_symlink.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans_space.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_rtalloc.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_extfree_item.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_filestream.h\"\n#include \"xfs_attr_leaf.h\"\n#include \"xfs_symlink.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_rtalloc.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_extfree_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nint\nxfs_bmapi_read(\n\tstruct xfs_inode\t*ip,\n\txfs_fileoff_t\t\tbno,\n\txfs_filblks_t\t\tlen,\n\tstruct xfs_bmbt_irec\t*mval,\n\tint\t\t\t*nmap,\n\tint\t\t\tflags)\n{\n\tstruct xfs_mount\t*mp = ip->i_mount;\n\tstruct xfs_ifork\t*ifp;\n\tstruct xfs_bmbt_irec\tgot;\n\tstruct xfs_bmbt_irec\tprev;\n\txfs_fileoff_t\t\tobno;\n\txfs_fileoff_t\t\tend;\n\txfs_extnum_t\t\tlastx;\n\tint\t\t\terror;\n\tint\t\t\teof;\n\tint\t\t\tn = 0;\n\tint\t\t\twhichfork = (flags & XFS_BMAPI_ATTRFORK) ?\n\t\t\t\t\t\tXFS_ATTR_FORK : XFS_DATA_FORK;\n\n\tASSERT(*nmap >= 1);\n\tASSERT(!(flags & ~(XFS_BMAPI_ATTRFORK|XFS_BMAPI_ENTIRE|\n\t\t\t   XFS_BMAPI_IGSTATE)));\n\tASSERT(xfs_isilocked(ip, XFS_ILOCK_SHARED|XFS_ILOCK_EXCL));\n\n\tif (unlikely(XFS_TEST_ERROR(\n\t    (XFS_IFORK_FORMAT(ip, whichfork) != XFS_DINODE_FMT_EXTENTS &&\n\t     XFS_IFORK_FORMAT(ip, whichfork) != XFS_DINODE_FMT_BTREE),\n\t     mp, XFS_ERRTAG_BMAPIFORMAT, XFS_RANDOM_BMAPIFORMAT))) {\n\t\tXFS_ERROR_REPORT(\"xfs_bmapi_read\", XFS_ERRLEVEL_LOW, mp);\n\t\treturn -EFSCORRUPTED;\n\t}\n\n\tif (XFS_FORCED_SHUTDOWN(mp))\n\t\treturn -EIO;\n\n\tXFS_STATS_INC(xs_blk_mapr);\n\n\tifp = XFS_IFORK_PTR(ip, whichfork);\n\n\tif (!(ifp->if_flags & XFS_IFEXTENTS)) {\n\t\terror = xfs_iread_extents(NULL, ip, whichfork);\n\t\tif (error)\n\t\t\treturn error;\n\t}\n\n\txfs_bmap_search_extents(ip, bno, whichfork, &eof, &lastx, &got, &prev);\n\tend = bno + len;\n\tobno = bno;\n\n\twhile (bno < end && n < *nmap) {\n\t\t/* Reading past eof, act as though there's a hole up to end. */\n\t\tif (eof)\n\t\t\tgot.br_startoff = end;\n\t\tif (got.br_startoff > bno) {\n\t\t\t/* Reading in a hole.  */\n\t\t\tmval->br_startoff = bno;\n\t\t\tmval->br_startblock = HOLESTARTBLOCK;\n\t\t\tmval->br_blockcount =\n\t\t\t\tXFS_FILBLKS_MIN(len, got.br_startoff - bno);\n\t\t\tmval->br_state = XFS_EXT_NORM;\n\t\t\tbno += mval->br_blockcount;\n\t\t\tlen -= mval->br_blockcount;\n\t\t\tmval++;\n\t\t\tn++;\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* set up the extent map to return. */\n\t\txfs_bmapi_trim_map(mval, &got, &bno, len, obno, end, n, flags);\n\t\txfs_bmapi_update_map(&mval, &bno, &len, obno, end, &n, flags);\n\n\t\t/* If we're done, stop now. */\n\t\tif (bno >= end || n >= *nmap)\n\t\t\tbreak;\n\n\t\t/* Else go on to the next record. */\n\t\tif (++lastx < ifp->if_bytes / sizeof(xfs_bmbt_rec_t))\n\t\t\txfs_bmbt_get_all(xfs_iext_get_ext(ifp, lastx), &got);\n\t\telse\n\t\t\teof = 1;\n\t}\n\t*nmap = n;\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"xfs_rtalloc.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_buf.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_error.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nint\nxfs_rtbuf_get(\n\txfs_mount_t\t*mp,\t\t/* file system mount structure */\n\txfs_trans_t\t*tp,\t\t/* transaction pointer */\n\txfs_rtblock_t\tblock,\t\t/* block number in bitmap or summary */\n\tint\t\tissum,\t\t/* is summary not bitmap */\n\txfs_buf_t\t**bpp)\t\t/* output: buffer for the block */\n{\n\txfs_buf_t\t*bp;\t\t/* block buffer, result */\n\txfs_inode_t\t*ip;\t\t/* bitmap or summary inode */\n\txfs_bmbt_irec_t\tmap;\n\tint\t\tnmap = 1;\n\tint\t\terror;\t\t/* error value */\n\n\tip = issum ? mp->m_rsumip : mp->m_rbmip;\n\n\terror = xfs_bmapi_read(ip, block, 1, &map, &nmap, XFS_DATA_FORK);\n\tif (error)\n\t\treturn error;\n\n\tASSERT(map.br_startblock != NULLFSBLOCK);\n\terror = xfs_trans_read_buf(mp, tp, mp->m_ddev_targp,\n\t\t\t\t   XFS_FSB_TO_DADDR(mp, map.br_startblock),\n\t\t\t\t   mp->m_bsize, 0, &bp, NULL);\n\tif (error)\n\t\treturn error;\n\t*bpp = bp;\n\treturn 0;\n}"
  }
]