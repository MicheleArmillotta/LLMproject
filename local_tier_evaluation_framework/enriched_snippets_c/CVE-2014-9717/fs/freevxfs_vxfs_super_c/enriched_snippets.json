[
  {
    "function_name": "vxfs_cleanup",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/freevxfs/vxfs_super.c",
    "lines": "280-290",
    "snippet": "static void __exit\nvxfs_cleanup(void)\n{\n\tunregister_filesystem(&vxfs_fs_type);\n\t/*\n\t * Make sure all delayed rcu free inodes are flushed before we\n\t * destroy cache.\n\t */\n\trcu_barrier();\n\tkmem_cache_destroy(vxfs_inode_cachep);\n}",
    "includes": [
      "#include \"vxfs_inode.h\"",
      "#include \"vxfs_dir.h\"",
      "#include \"vxfs_extern.h\"",
      "#include \"vxfs.h\"",
      "#include <linux/mount.h>",
      "#include <linux/vfs.h>",
      "#include <linux/stat.h>",
      "#include <linux/slab.h>",
      "#include <linux/kernel.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/fs.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct file_system_type vxfs_fs_type = {\n\t.owner\t\t= THIS_MODULE,\n\t.name\t\t= \"vxfs\",\n\t.mount\t\t= vxfs_mount,\n\t.kill_sb\t= kill_block_super,\n\t.fs_flags\t= FS_REQUIRES_DEV,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kmem_cache_destroy",
          "args": [
            "vxfs_inode_cachep"
          ],
          "line": 289
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_barrier",
          "args": [],
          "line": 288
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unregister_filesystem",
          "args": [
            "&vxfs_fs_type"
          ],
          "line": 283
        },
        "resolved": true,
        "details": {
          "function_name": "unregister_filesystem",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/filesystems.c",
          "lines": "101-120",
          "snippet": "int unregister_filesystem(struct file_system_type * fs)\n{\n\tstruct file_system_type ** tmp;\n\n\twrite_lock(&file_systems_lock);\n\ttmp = &file_systems;\n\twhile (*tmp) {\n\t\tif (fs == *tmp) {\n\t\t\t*tmp = fs->next;\n\t\t\tfs->next = NULL;\n\t\t\twrite_unlock(&file_systems_lock);\n\t\t\tsynchronize_rcu();\n\t\t\treturn 0;\n\t\t}\n\t\ttmp = &(*tmp)->next;\n\t}\n\twrite_unlock(&file_systems_lock);\n\n\treturn -EINVAL;\n}",
          "includes": [
            "#include <asm/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/kmod.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct file_system_type *file_systems;",
            "static DEFINE_RWLOCK(file_systems_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/uaccess.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kmod.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n\nstatic struct file_system_type *file_systems;\nstatic DEFINE_RWLOCK(file_systems_lock);\n\nint unregister_filesystem(struct file_system_type * fs)\n{\n\tstruct file_system_type ** tmp;\n\n\twrite_lock(&file_systems_lock);\n\ttmp = &file_systems;\n\twhile (*tmp) {\n\t\tif (fs == *tmp) {\n\t\t\t*tmp = fs->next;\n\t\t\tfs->next = NULL;\n\t\t\twrite_unlock(&file_systems_lock);\n\t\t\tsynchronize_rcu();\n\t\t\treturn 0;\n\t\t}\n\t\ttmp = &(*tmp)->next;\n\t}\n\twrite_unlock(&file_systems_lock);\n\n\treturn -EINVAL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"vxfs_inode.h\"\n#include \"vxfs_dir.h\"\n#include \"vxfs_extern.h\"\n#include \"vxfs.h\"\n#include <linux/mount.h>\n#include <linux/vfs.h>\n#include <linux/stat.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/buffer_head.h>\n#include <linux/fs.h>\n#include <linux/blkdev.h>\n#include <linux/module.h>\n#include <linux/init.h>\n\nstatic struct file_system_type vxfs_fs_type = {\n\t.owner\t\t= THIS_MODULE,\n\t.name\t\t= \"vxfs\",\n\t.mount\t\t= vxfs_mount,\n\t.kill_sb\t= kill_block_super,\n\t.fs_flags\t= FS_REQUIRES_DEV,\n};\n\nstatic void __exit\nvxfs_cleanup(void)\n{\n\tunregister_filesystem(&vxfs_fs_type);\n\t/*\n\t * Make sure all delayed rcu free inodes are flushed before we\n\t * destroy cache.\n\t */\n\trcu_barrier();\n\tkmem_cache_destroy(vxfs_inode_cachep);\n}"
  },
  {
    "function_name": "vxfs_init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/freevxfs/vxfs_super.c",
    "lines": "264-278",
    "snippet": "static int __init\nvxfs_init(void)\n{\n\tint rv;\n\n\tvxfs_inode_cachep = kmem_cache_create(\"vxfs_inode\",\n\t\t\tsizeof(struct vxfs_inode_info), 0,\n\t\t\tSLAB_RECLAIM_ACCOUNT|SLAB_MEM_SPREAD, NULL);\n\tif (!vxfs_inode_cachep)\n\t\treturn -ENOMEM;\n\trv = register_filesystem(&vxfs_fs_type);\n\tif (rv < 0)\n\t\tkmem_cache_destroy(vxfs_inode_cachep);\n\treturn rv;\n}",
    "includes": [
      "#include \"vxfs_inode.h\"",
      "#include \"vxfs_dir.h\"",
      "#include \"vxfs_extern.h\"",
      "#include \"vxfs.h\"",
      "#include <linux/mount.h>",
      "#include <linux/vfs.h>",
      "#include <linux/stat.h>",
      "#include <linux/slab.h>",
      "#include <linux/kernel.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/fs.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct file_system_type vxfs_fs_type = {\n\t.owner\t\t= THIS_MODULE,\n\t.name\t\t= \"vxfs\",\n\t.mount\t\t= vxfs_mount,\n\t.kill_sb\t= kill_block_super,\n\t.fs_flags\t= FS_REQUIRES_DEV,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kmem_cache_destroy",
          "args": [
            "vxfs_inode_cachep"
          ],
          "line": 276
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "register_filesystem",
          "args": [
            "&vxfs_fs_type"
          ],
          "line": 274
        },
        "resolved": true,
        "details": {
          "function_name": "unregister_filesystem",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/filesystems.c",
          "lines": "101-120",
          "snippet": "int unregister_filesystem(struct file_system_type * fs)\n{\n\tstruct file_system_type ** tmp;\n\n\twrite_lock(&file_systems_lock);\n\ttmp = &file_systems;\n\twhile (*tmp) {\n\t\tif (fs == *tmp) {\n\t\t\t*tmp = fs->next;\n\t\t\tfs->next = NULL;\n\t\t\twrite_unlock(&file_systems_lock);\n\t\t\tsynchronize_rcu();\n\t\t\treturn 0;\n\t\t}\n\t\ttmp = &(*tmp)->next;\n\t}\n\twrite_unlock(&file_systems_lock);\n\n\treturn -EINVAL;\n}",
          "includes": [
            "#include <asm/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/kmod.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct file_system_type *file_systems;",
            "static DEFINE_RWLOCK(file_systems_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/uaccess.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kmod.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n\nstatic struct file_system_type *file_systems;\nstatic DEFINE_RWLOCK(file_systems_lock);\n\nint unregister_filesystem(struct file_system_type * fs)\n{\n\tstruct file_system_type ** tmp;\n\n\twrite_lock(&file_systems_lock);\n\ttmp = &file_systems;\n\twhile (*tmp) {\n\t\tif (fs == *tmp) {\n\t\t\t*tmp = fs->next;\n\t\t\tfs->next = NULL;\n\t\t\twrite_unlock(&file_systems_lock);\n\t\t\tsynchronize_rcu();\n\t\t\treturn 0;\n\t\t}\n\t\ttmp = &(*tmp)->next;\n\t}\n\twrite_unlock(&file_systems_lock);\n\n\treturn -EINVAL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kmem_cache_create",
          "args": [
            "\"vxfs_inode\"",
            "sizeof(struct vxfs_inode_info)",
            "0",
            "SLAB_RECLAIM_ACCOUNT|SLAB_MEM_SPREAD",
            "NULL"
          ],
          "line": 269
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"vxfs_inode.h\"\n#include \"vxfs_dir.h\"\n#include \"vxfs_extern.h\"\n#include \"vxfs.h\"\n#include <linux/mount.h>\n#include <linux/vfs.h>\n#include <linux/stat.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/buffer_head.h>\n#include <linux/fs.h>\n#include <linux/blkdev.h>\n#include <linux/module.h>\n#include <linux/init.h>\n\nstatic struct file_system_type vxfs_fs_type = {\n\t.owner\t\t= THIS_MODULE,\n\t.name\t\t= \"vxfs\",\n\t.mount\t\t= vxfs_mount,\n\t.kill_sb\t= kill_block_super,\n\t.fs_flags\t= FS_REQUIRES_DEV,\n};\n\nstatic int __init\nvxfs_init(void)\n{\n\tint rv;\n\n\tvxfs_inode_cachep = kmem_cache_create(\"vxfs_inode\",\n\t\t\tsizeof(struct vxfs_inode_info), 0,\n\t\t\tSLAB_RECLAIM_ACCOUNT|SLAB_MEM_SPREAD, NULL);\n\tif (!vxfs_inode_cachep)\n\t\treturn -ENOMEM;\n\trv = register_filesystem(&vxfs_fs_type);\n\tif (rv < 0)\n\t\tkmem_cache_destroy(vxfs_inode_cachep);\n\treturn rv;\n}"
  },
  {
    "function_name": "vxfs_mount",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/freevxfs/vxfs_super.c",
    "lines": "248-252",
    "snippet": "static struct dentry *vxfs_mount(struct file_system_type *fs_type,\n\tint flags, const char *dev_name, void *data)\n{\n\treturn mount_bdev(fs_type, flags, dev_name, data, vxfs_fill_super);\n}",
    "includes": [
      "#include \"vxfs_inode.h\"",
      "#include \"vxfs_dir.h\"",
      "#include \"vxfs_extern.h\"",
      "#include \"vxfs.h\"",
      "#include <linux/mount.h>",
      "#include <linux/vfs.h>",
      "#include <linux/stat.h>",
      "#include <linux/slab.h>",
      "#include <linux/kernel.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/fs.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mount_bdev",
          "args": [
            "fs_type",
            "flags",
            "dev_name",
            "data",
            "vxfs_fill_super"
          ],
          "line": 251
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"vxfs_inode.h\"\n#include \"vxfs_dir.h\"\n#include \"vxfs_extern.h\"\n#include \"vxfs.h\"\n#include <linux/mount.h>\n#include <linux/vfs.h>\n#include <linux/stat.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/buffer_head.h>\n#include <linux/fs.h>\n#include <linux/blkdev.h>\n#include <linux/module.h>\n#include <linux/init.h>\n\nstatic struct dentry *vxfs_mount(struct file_system_type *fs_type,\n\tint flags, const char *dev_name, void *data)\n{\n\treturn mount_bdev(fs_type, flags, dev_name, data, vxfs_fill_super);\n}"
  },
  {
    "function_name": "vxfs_fill_super",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/freevxfs/vxfs_super.c",
    "lines": "148-243",
    "snippet": "static int vxfs_fill_super(struct super_block *sbp, void *dp, int silent)\n{\n\tstruct vxfs_sb_info\t*infp;\n\tstruct vxfs_sb\t\t*rsbp;\n\tstruct buffer_head\t*bp = NULL;\n\tu_long\t\t\tbsize;\n\tstruct inode *root;\n\tint ret = -EINVAL;\n\n\tsbp->s_flags |= MS_RDONLY;\n\n\tinfp = kzalloc(sizeof(*infp), GFP_KERNEL);\n\tif (!infp) {\n\t\tprintk(KERN_WARNING \"vxfs: unable to allocate incore superblock\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tbsize = sb_min_blocksize(sbp, BLOCK_SIZE);\n\tif (!bsize) {\n\t\tprintk(KERN_WARNING \"vxfs: unable to set blocksize\\n\");\n\t\tgoto out;\n\t}\n\n\tbp = sb_bread(sbp, 1);\n\tif (!bp || !buffer_mapped(bp)) {\n\t\tif (!silent) {\n\t\t\tprintk(KERN_WARNING\n\t\t\t\t\"vxfs: unable to read disk superblock\\n\");\n\t\t}\n\t\tgoto out;\n\t}\n\n\trsbp = (struct vxfs_sb *)bp->b_data;\n\tif (rsbp->vs_magic != VXFS_SUPER_MAGIC) {\n\t\tif (!silent)\n\t\t\tprintk(KERN_NOTICE \"vxfs: WRONG superblock magic\\n\");\n\t\tgoto out;\n\t}\n\n\tif ((rsbp->vs_version < 2 || rsbp->vs_version > 4) && !silent) {\n\t\tprintk(KERN_NOTICE \"vxfs: unsupported VxFS version (%d)\\n\",\n\t\t       rsbp->vs_version);\n\t\tgoto out;\n\t}\n\n#ifdef DIAGNOSTIC\n\tprintk(KERN_DEBUG \"vxfs: supported VxFS version (%d)\\n\", rsbp->vs_version);\n\tprintk(KERN_DEBUG \"vxfs: blocksize: %d\\n\", rsbp->vs_bsize);\n#endif\n\n\tsbp->s_magic = rsbp->vs_magic;\n\tsbp->s_fs_info = infp;\n\n\tinfp->vsi_raw = rsbp;\n\tinfp->vsi_bp = bp;\n\tinfp->vsi_oltext = rsbp->vs_oltext[0];\n\tinfp->vsi_oltsize = rsbp->vs_oltsize;\n\n\tif (!sb_set_blocksize(sbp, rsbp->vs_bsize)) {\n\t\tprintk(KERN_WARNING \"vxfs: unable to set final block size\\n\");\n\t\tgoto out;\n\t}\n\n\tif (vxfs_read_olt(sbp, bsize)) {\n\t\tprintk(KERN_WARNING \"vxfs: unable to read olt\\n\");\n\t\tgoto out;\n\t}\n\n\tif (vxfs_read_fshead(sbp)) {\n\t\tprintk(KERN_WARNING \"vxfs: unable to read fshead\\n\");\n\t\tgoto out;\n\t}\n\n\tsbp->s_op = &vxfs_super_ops;\n\troot = vxfs_iget(sbp, VXFS_ROOT_INO);\n\tif (IS_ERR(root)) {\n\t\tret = PTR_ERR(root);\n\t\tgoto out;\n\t}\n\tsbp->s_root = d_make_root(root);\n\tif (!sbp->s_root) {\n\t\tprintk(KERN_WARNING \"vxfs: unable to get root dentry.\\n\");\n\t\tgoto out_free_ilist;\n\t}\n\n\treturn 0;\n\t\nout_free_ilist:\n\tvxfs_put_fake_inode(infp->vsi_fship);\n\tvxfs_put_fake_inode(infp->vsi_ilist);\n\tvxfs_put_fake_inode(infp->vsi_stilist);\nout:\n\tbrelse(bp);\n\tkfree(infp);\n\treturn ret;\n}",
    "includes": [
      "#include \"vxfs_inode.h\"",
      "#include \"vxfs_dir.h\"",
      "#include \"vxfs_extern.h\"",
      "#include \"vxfs.h\"",
      "#include <linux/mount.h>",
      "#include <linux/vfs.h>",
      "#include <linux/stat.h>",
      "#include <linux/slab.h>",
      "#include <linux/kernel.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/fs.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void\t\tvxfs_put_super(struct super_block *);",
      "static int\t\tvxfs_remount(struct super_block *, int *, char *);",
      "static const struct super_operations vxfs_super_ops = {\n\t.evict_inode =\t\tvxfs_evict_inode,\n\t.put_super =\t\tvxfs_put_super,\n\t.statfs =\t\tvxfs_statfs,\n\t.remount_fs =\t\tvxfs_remount,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "infp"
          ],
          "line": 241
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "brelse",
          "args": [
            "bp"
          ],
          "line": 240
        },
        "resolved": true,
        "details": {
          "function_name": "__brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1177-1184",
          "snippet": "void __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "vxfs_put_fake_inode",
          "args": [
            "infp->vsi_stilist"
          ],
          "line": 238
        },
        "resolved": true,
        "details": {
          "function_name": "vxfs_put_fake_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/freevxfs/vxfs_inode.c",
          "lines": "277-281",
          "snippet": "void\nvxfs_put_fake_inode(struct inode *ip)\n{\n\tiput(ip);\n}",
          "includes": [
            "#include \"vxfs_extern.h\"",
            "#include \"vxfs_inode.h\"",
            "#include \"vxfs.h\"",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vxfs_extern.h\"\n#include \"vxfs_inode.h\"\n#include \"vxfs.h\"\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/pagemap.h>\n#include <linux/buffer_head.h>\n#include <linux/fs.h>\n\nvoid\nvxfs_put_fake_inode(struct inode *ip)\n{\n\tiput(ip);\n}"
        }
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_WARNING \"vxfs: unable to get root dentry.\\n\""
          ],
          "line": 229
        },
        "resolved": true,
        "details": {
          "function_name": "compat_printk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/compat.c",
          "lines": "59-69",
          "snippet": "int compat_printk(const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\tif (!compat_log)\n\t\treturn 0;\n\tva_start(ap, fmt);\n\tret = vprintk(fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/ioctls.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/aio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/mm.h>",
            "#include <linux/poll.h>",
            "#include <linux/signal.h>",
            "#include <linux/highmem.h>",
            "#include <linux/security.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/personality.h>",
            "#include <linux/highuid.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/dirent.h>",
            "#include <linux/ctype.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/nfs4_mount.h>",
            "#include <linux/ncp_mount.h>",
            "#include <linux/init.h>",
            "#include <linux/ioctl.h>",
            "#include <linux/vfs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/namei.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/errno.h>",
            "#include <linux/compat.h>",
            "#include <linux/linkage.h>",
            "#include <linux/kernel.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int compat_log = 1;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/ioctls.h>\n#include <asm/mmu_context.h>\n#include <asm/uaccess.h>\n#include <linux/aio.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/fs_struct.h>\n#include <linux/mm.h>\n#include <linux/poll.h>\n#include <linux/signal.h>\n#include <linux/highmem.h>\n#include <linux/security.h>\n#include <linux/tsacct_kern.h>\n#include <linux/rwsem.h>\n#include <linux/personality.h>\n#include <linux/highuid.h>\n#include <linux/fsnotify.h>\n#include <linux/dirent.h>\n#include <linux/ctype.h>\n#include <linux/syscalls.h>\n#include <linux/nfs4_mount.h>\n#include <linux/ncp_mount.h>\n#include <linux/init.h>\n#include <linux/ioctl.h>\n#include <linux/vfs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/namei.h>\n#include <linux/fcntl.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <linux/compat.h>\n#include <linux/linkage.h>\n#include <linux/kernel.h>\n#include <linux/stddef.h>\n\nint compat_log = 1;\n\nint compat_printk(const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\tif (!compat_log)\n\t\treturn 0;\n\tva_start(ap, fmt);\n\tret = vprintk(fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "d_make_root",
          "args": [
            "root"
          ],
          "line": 227
        },
        "resolved": true,
        "details": {
          "function_name": "d_make_root",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "1857-1871",
          "snippet": "struct dentry *d_make_root(struct inode *root_inode)\n{\n\tstruct dentry *res = NULL;\n\n\tif (root_inode) {\n\t\tstatic const struct qstr name = QSTR_INIT(\"/\", 1);\n\n\t\tres = __d_alloc(root_inode->i_sb, &name);\n\t\tif (res)\n\t\t\td_instantiate(res, root_inode);\n\t\telse\n\t\t\tiput(root_inode);\n\t}\n\treturn res;\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nstruct dentry *d_make_root(struct inode *root_inode)\n{\n\tstruct dentry *res = NULL;\n\n\tif (root_inode) {\n\t\tstatic const struct qstr name = QSTR_INIT(\"/\", 1);\n\n\t\tres = __d_alloc(root_inode->i_sb, &name);\n\t\tif (res)\n\t\t\td_instantiate(res, root_inode);\n\t\telse\n\t\t\tiput(root_inode);\n\t}\n\treturn res;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "root"
          ],
          "line": 224
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "root"
          ],
          "line": 223
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vxfs_iget",
          "args": [
            "sbp",
            "VXFS_ROOT_INO"
          ],
          "line": 222
        },
        "resolved": true,
        "details": {
          "function_name": "vxfs_iget",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/freevxfs/vxfs_inode.c",
          "lines": "292-338",
          "snippet": "struct inode *\nvxfs_iget(struct super_block *sbp, ino_t ino)\n{\n\tstruct vxfs_inode_info\t\t*vip;\n\tconst struct address_space_operations\t*aops;\n\tstruct inode *ip;\n\n\tip = iget_locked(sbp, ino);\n\tif (!ip)\n\t\treturn ERR_PTR(-ENOMEM);\n\tif (!(ip->i_state & I_NEW))\n\t\treturn ip;\n\n\tvip = __vxfs_iget(ino, VXFS_SBI(sbp)->vsi_ilist);\n\tif (IS_ERR(vip)) {\n\t\tiget_failed(ip);\n\t\treturn ERR_CAST(vip);\n\t}\n\n\tvxfs_iinit(ip, vip);\n\n\tif (VXFS_ISIMMED(vip))\n\t\taops = &vxfs_immed_aops;\n\telse\n\t\taops = &vxfs_aops;\n\n\tif (S_ISREG(ip->i_mode)) {\n\t\tip->i_fop = &generic_ro_fops;\n\t\tip->i_mapping->a_ops = aops;\n\t} else if (S_ISDIR(ip->i_mode)) {\n\t\tip->i_op = &vxfs_dir_inode_ops;\n\t\tip->i_fop = &vxfs_dir_operations;\n\t\tip->i_mapping->a_ops = aops;\n\t} else if (S_ISLNK(ip->i_mode)) {\n\t\tif (!VXFS_ISIMMED(vip)) {\n\t\t\tip->i_op = &page_symlink_inode_operations;\n\t\t\tip->i_mapping->a_ops = &vxfs_aops;\n\t\t} else {\n\t\t\tip->i_op = &vxfs_immed_symlink_iops;\n\t\t\tvip->vii_immed.vi_immed[ip->i_size] = '\\0';\n\t\t}\n\t} else\n\t\tinit_special_inode(ip, ip->i_mode, old_decode_dev(vip->vii_rdev));\n\n\tunlock_new_inode(ip);\n\treturn ip;\n}",
          "includes": [
            "#include \"vxfs_extern.h\"",
            "#include \"vxfs_inode.h\"",
            "#include \"vxfs.h\"",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vxfs_extern.h\"\n#include \"vxfs_inode.h\"\n#include \"vxfs.h\"\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/pagemap.h>\n#include <linux/buffer_head.h>\n#include <linux/fs.h>\n\nstruct inode *\nvxfs_iget(struct super_block *sbp, ino_t ino)\n{\n\tstruct vxfs_inode_info\t\t*vip;\n\tconst struct address_space_operations\t*aops;\n\tstruct inode *ip;\n\n\tip = iget_locked(sbp, ino);\n\tif (!ip)\n\t\treturn ERR_PTR(-ENOMEM);\n\tif (!(ip->i_state & I_NEW))\n\t\treturn ip;\n\n\tvip = __vxfs_iget(ino, VXFS_SBI(sbp)->vsi_ilist);\n\tif (IS_ERR(vip)) {\n\t\tiget_failed(ip);\n\t\treturn ERR_CAST(vip);\n\t}\n\n\tvxfs_iinit(ip, vip);\n\n\tif (VXFS_ISIMMED(vip))\n\t\taops = &vxfs_immed_aops;\n\telse\n\t\taops = &vxfs_aops;\n\n\tif (S_ISREG(ip->i_mode)) {\n\t\tip->i_fop = &generic_ro_fops;\n\t\tip->i_mapping->a_ops = aops;\n\t} else if (S_ISDIR(ip->i_mode)) {\n\t\tip->i_op = &vxfs_dir_inode_ops;\n\t\tip->i_fop = &vxfs_dir_operations;\n\t\tip->i_mapping->a_ops = aops;\n\t} else if (S_ISLNK(ip->i_mode)) {\n\t\tif (!VXFS_ISIMMED(vip)) {\n\t\t\tip->i_op = &page_symlink_inode_operations;\n\t\t\tip->i_mapping->a_ops = &vxfs_aops;\n\t\t} else {\n\t\t\tip->i_op = &vxfs_immed_symlink_iops;\n\t\t\tvip->vii_immed.vi_immed[ip->i_size] = '\\0';\n\t\t}\n\t} else\n\t\tinit_special_inode(ip, ip->i_mode, old_decode_dev(vip->vii_rdev));\n\n\tunlock_new_inode(ip);\n\treturn ip;\n}"
        }
      },
      {
        "call_info": {
          "callee": "vxfs_read_fshead",
          "args": [
            "sbp"
          ],
          "line": 216
        },
        "resolved": true,
        "details": {
          "function_name": "vxfs_read_fshead",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/freevxfs/vxfs_fshead.c",
          "lines": "106-203",
          "snippet": "int\nvxfs_read_fshead(struct super_block *sbp)\n{\n\tstruct vxfs_sb_info\t\t*infp = VXFS_SBI(sbp);\n\tstruct vxfs_fsh\t\t\t*pfp, *sfp;\n\tstruct vxfs_inode_info\t\t*vip, *tip;\n\n\tvip = vxfs_blkiget(sbp, infp->vsi_iext, infp->vsi_fshino);\n\tif (!vip) {\n\t\tprintk(KERN_ERR \"vxfs: unable to read fsh inode\\n\");\n\t\treturn -EINVAL;\n\t}\n\tif (!VXFS_ISFSH(vip)) {\n\t\tprintk(KERN_ERR \"vxfs: fsh list inode is of wrong type (%x)\\n\",\n\t\t\t\tvip->vii_mode & VXFS_TYPE_MASK); \n\t\tgoto out_free_fship;\n\t}\n\n\n#ifdef DIAGNOSTIC\n\tprintk(\"vxfs: fsh inode dump:\\n\");\n\tvxfs_dumpi(vip, infp->vsi_fshino);\n#endif\n\n\tinfp->vsi_fship = vxfs_get_fake_inode(sbp, vip);\n\tif (!infp->vsi_fship) {\n\t\tprintk(KERN_ERR \"vxfs: unable to get fsh inode\\n\");\n\t\tgoto out_free_fship;\n\t}\n\n\tsfp = vxfs_getfsh(infp->vsi_fship, 0);\n\tif (!sfp) {\n\t\tprintk(KERN_ERR \"vxfs: unable to get structural fsh\\n\");\n\t\tgoto out_iput_fship;\n\t} \n\n#ifdef DIAGNOSTIC\n\tvxfs_dumpfsh(sfp);\n#endif\n\n\tpfp = vxfs_getfsh(infp->vsi_fship, 1);\n\tif (!pfp) {\n\t\tprintk(KERN_ERR \"vxfs: unable to get primary fsh\\n\");\n\t\tgoto out_free_sfp;\n\t}\n\n#ifdef DIAGNOSTIC\n\tvxfs_dumpfsh(pfp);\n#endif\n\n\ttip = vxfs_blkiget(sbp, infp->vsi_iext, sfp->fsh_ilistino[0]);\n\tif (!tip)\n\t\tgoto out_free_pfp;\n\n\tinfp->vsi_stilist = vxfs_get_fake_inode(sbp, tip);\n\tif (!infp->vsi_stilist) {\n\t\tprintk(KERN_ERR \"vxfs: unable to get structural list inode\\n\");\n\t\tkfree(tip);\n\t\tgoto out_free_pfp;\n\t}\n\tif (!VXFS_ISILT(VXFS_INO(infp->vsi_stilist))) {\n\t\tprintk(KERN_ERR \"vxfs: structural list inode is of wrong type (%x)\\n\",\n\t\t\t\tVXFS_INO(infp->vsi_stilist)->vii_mode & VXFS_TYPE_MASK); \n\t\tgoto out_iput_stilist;\n\t}\n\n\ttip = vxfs_stiget(sbp, pfp->fsh_ilistino[0]);\n\tif (!tip)\n\t\tgoto out_iput_stilist;\n\tinfp->vsi_ilist = vxfs_get_fake_inode(sbp, tip);\n\tif (!infp->vsi_ilist) {\n\t\tprintk(KERN_ERR \"vxfs: unable to get inode list inode\\n\");\n\t\tkfree(tip);\n\t\tgoto out_iput_stilist;\n\t}\n\tif (!VXFS_ISILT(VXFS_INO(infp->vsi_ilist))) {\n\t\tprintk(KERN_ERR \"vxfs: inode list inode is of wrong type (%x)\\n\",\n\t\t\t\tVXFS_INO(infp->vsi_ilist)->vii_mode & VXFS_TYPE_MASK);\n\t\tgoto out_iput_ilist;\n\t}\n\n\treturn 0;\n\n out_iput_ilist:\n \tiput(infp->vsi_ilist);\n out_iput_stilist:\n \tiput(infp->vsi_stilist);\n out_free_pfp:\n\tkfree(pfp);\n out_free_sfp:\n \tkfree(sfp);\n out_iput_fship:\n\tiput(infp->vsi_fship);\n\treturn -EINVAL;\n out_free_fship:\n \tkfree(vip);\n\treturn -EINVAL;\n}",
          "includes": [
            "#include \"vxfs_fshead.h\"",
            "#include \"vxfs_extern.h\"",
            "#include \"vxfs_inode.h\"",
            "#include \"vxfs.h\"",
            "#include <linux/string.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vxfs_fshead.h\"\n#include \"vxfs_extern.h\"\n#include \"vxfs_inode.h\"\n#include \"vxfs.h\"\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/buffer_head.h>\n#include <linux/fs.h>\n\nint\nvxfs_read_fshead(struct super_block *sbp)\n{\n\tstruct vxfs_sb_info\t\t*infp = VXFS_SBI(sbp);\n\tstruct vxfs_fsh\t\t\t*pfp, *sfp;\n\tstruct vxfs_inode_info\t\t*vip, *tip;\n\n\tvip = vxfs_blkiget(sbp, infp->vsi_iext, infp->vsi_fshino);\n\tif (!vip) {\n\t\tprintk(KERN_ERR \"vxfs: unable to read fsh inode\\n\");\n\t\treturn -EINVAL;\n\t}\n\tif (!VXFS_ISFSH(vip)) {\n\t\tprintk(KERN_ERR \"vxfs: fsh list inode is of wrong type (%x)\\n\",\n\t\t\t\tvip->vii_mode & VXFS_TYPE_MASK); \n\t\tgoto out_free_fship;\n\t}\n\n\n#ifdef DIAGNOSTIC\n\tprintk(\"vxfs: fsh inode dump:\\n\");\n\tvxfs_dumpi(vip, infp->vsi_fshino);\n#endif\n\n\tinfp->vsi_fship = vxfs_get_fake_inode(sbp, vip);\n\tif (!infp->vsi_fship) {\n\t\tprintk(KERN_ERR \"vxfs: unable to get fsh inode\\n\");\n\t\tgoto out_free_fship;\n\t}\n\n\tsfp = vxfs_getfsh(infp->vsi_fship, 0);\n\tif (!sfp) {\n\t\tprintk(KERN_ERR \"vxfs: unable to get structural fsh\\n\");\n\t\tgoto out_iput_fship;\n\t} \n\n#ifdef DIAGNOSTIC\n\tvxfs_dumpfsh(sfp);\n#endif\n\n\tpfp = vxfs_getfsh(infp->vsi_fship, 1);\n\tif (!pfp) {\n\t\tprintk(KERN_ERR \"vxfs: unable to get primary fsh\\n\");\n\t\tgoto out_free_sfp;\n\t}\n\n#ifdef DIAGNOSTIC\n\tvxfs_dumpfsh(pfp);\n#endif\n\n\ttip = vxfs_blkiget(sbp, infp->vsi_iext, sfp->fsh_ilistino[0]);\n\tif (!tip)\n\t\tgoto out_free_pfp;\n\n\tinfp->vsi_stilist = vxfs_get_fake_inode(sbp, tip);\n\tif (!infp->vsi_stilist) {\n\t\tprintk(KERN_ERR \"vxfs: unable to get structural list inode\\n\");\n\t\tkfree(tip);\n\t\tgoto out_free_pfp;\n\t}\n\tif (!VXFS_ISILT(VXFS_INO(infp->vsi_stilist))) {\n\t\tprintk(KERN_ERR \"vxfs: structural list inode is of wrong type (%x)\\n\",\n\t\t\t\tVXFS_INO(infp->vsi_stilist)->vii_mode & VXFS_TYPE_MASK); \n\t\tgoto out_iput_stilist;\n\t}\n\n\ttip = vxfs_stiget(sbp, pfp->fsh_ilistino[0]);\n\tif (!tip)\n\t\tgoto out_iput_stilist;\n\tinfp->vsi_ilist = vxfs_get_fake_inode(sbp, tip);\n\tif (!infp->vsi_ilist) {\n\t\tprintk(KERN_ERR \"vxfs: unable to get inode list inode\\n\");\n\t\tkfree(tip);\n\t\tgoto out_iput_stilist;\n\t}\n\tif (!VXFS_ISILT(VXFS_INO(infp->vsi_ilist))) {\n\t\tprintk(KERN_ERR \"vxfs: inode list inode is of wrong type (%x)\\n\",\n\t\t\t\tVXFS_INO(infp->vsi_ilist)->vii_mode & VXFS_TYPE_MASK);\n\t\tgoto out_iput_ilist;\n\t}\n\n\treturn 0;\n\n out_iput_ilist:\n \tiput(infp->vsi_ilist);\n out_iput_stilist:\n \tiput(infp->vsi_stilist);\n out_free_pfp:\n\tkfree(pfp);\n out_free_sfp:\n \tkfree(sfp);\n out_iput_fship:\n\tiput(infp->vsi_fship);\n\treturn -EINVAL;\n out_free_fship:\n \tkfree(vip);\n\treturn -EINVAL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "vxfs_read_olt",
          "args": [
            "sbp",
            "bsize"
          ],
          "line": 211
        },
        "resolved": true,
        "details": {
          "function_name": "vxfs_read_olt",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/freevxfs/vxfs_olt.c",
          "lines": "76-130",
          "snippet": "int\nvxfs_read_olt(struct super_block *sbp, u_long bsize)\n{\n\tstruct vxfs_sb_info\t*infp = VXFS_SBI(sbp);\n\tstruct buffer_head\t*bp;\n\tstruct vxfs_olt\t\t*op;\n\tchar\t\t\t*oaddr, *eaddr;\n\n\n\tbp = sb_bread(sbp, vxfs_oblock(sbp, infp->vsi_oltext, bsize));\n\tif (!bp || !bp->b_data)\n\t\tgoto fail;\n\n\top = (struct vxfs_olt *)bp->b_data;\n\tif (op->olt_magic != VXFS_OLT_MAGIC) {\n\t\tprintk(KERN_NOTICE \"vxfs: ivalid olt magic number\\n\");\n\t\tgoto fail;\n\t}\n\n\t/*\n\t * It is in theory possible that vsi_oltsize is > 1.\n\t * I've not seen any such filesystem yet and I'm lazy..  --hch\n\t */\n\tif (infp->vsi_oltsize > 1) {\n\t\tprintk(KERN_NOTICE \"vxfs: oltsize > 1 detected.\\n\");\n\t\tprintk(KERN_NOTICE \"vxfs: please notify hch@infradead.org\\n\");\n\t\tgoto fail;\n\t}\n\n\toaddr = bp->b_data + op->olt_size;\n\teaddr = bp->b_data + (infp->vsi_oltsize * sbp->s_blocksize);\n\n\twhile (oaddr < eaddr) {\n\t\tstruct vxfs_oltcommon\t*ocp =\n\t\t\t(struct vxfs_oltcommon *)oaddr;\n\t\t\n\t\tswitch (ocp->olt_type) {\n\t\tcase VXFS_OLT_FSHEAD:\n\t\t\tvxfs_get_fshead((struct vxfs_oltfshead *)oaddr, infp);\n\t\t\tbreak;\n\t\tcase VXFS_OLT_ILIST:\n\t\t\tvxfs_get_ilist((struct vxfs_oltilist *)oaddr, infp);\n\t\t\tbreak;\n\t\t}\n\n\t\toaddr += ocp->olt_size;\n\t}\n\n\tbrelse(bp);\n\treturn 0;\n\nfail:\n\tbrelse(bp);\n\treturn -EINVAL;\n}",
          "includes": [
            "#include \"vxfs_extern.h\"",
            "#include \"vxfs_olt.h\"",
            "#include \"vxfs.h\"",
            "#include <linux/kernel.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vxfs_extern.h\"\n#include \"vxfs_olt.h\"\n#include \"vxfs.h\"\n#include <linux/kernel.h>\n#include <linux/buffer_head.h>\n#include <linux/fs.h>\n\nint\nvxfs_read_olt(struct super_block *sbp, u_long bsize)\n{\n\tstruct vxfs_sb_info\t*infp = VXFS_SBI(sbp);\n\tstruct buffer_head\t*bp;\n\tstruct vxfs_olt\t\t*op;\n\tchar\t\t\t*oaddr, *eaddr;\n\n\n\tbp = sb_bread(sbp, vxfs_oblock(sbp, infp->vsi_oltext, bsize));\n\tif (!bp || !bp->b_data)\n\t\tgoto fail;\n\n\top = (struct vxfs_olt *)bp->b_data;\n\tif (op->olt_magic != VXFS_OLT_MAGIC) {\n\t\tprintk(KERN_NOTICE \"vxfs: ivalid olt magic number\\n\");\n\t\tgoto fail;\n\t}\n\n\t/*\n\t * It is in theory possible that vsi_oltsize is > 1.\n\t * I've not seen any such filesystem yet and I'm lazy..  --hch\n\t */\n\tif (infp->vsi_oltsize > 1) {\n\t\tprintk(KERN_NOTICE \"vxfs: oltsize > 1 detected.\\n\");\n\t\tprintk(KERN_NOTICE \"vxfs: please notify hch@infradead.org\\n\");\n\t\tgoto fail;\n\t}\n\n\toaddr = bp->b_data + op->olt_size;\n\teaddr = bp->b_data + (infp->vsi_oltsize * sbp->s_blocksize);\n\n\twhile (oaddr < eaddr) {\n\t\tstruct vxfs_oltcommon\t*ocp =\n\t\t\t(struct vxfs_oltcommon *)oaddr;\n\t\t\n\t\tswitch (ocp->olt_type) {\n\t\tcase VXFS_OLT_FSHEAD:\n\t\t\tvxfs_get_fshead((struct vxfs_oltfshead *)oaddr, infp);\n\t\t\tbreak;\n\t\tcase VXFS_OLT_ILIST:\n\t\t\tvxfs_get_ilist((struct vxfs_oltilist *)oaddr, infp);\n\t\t\tbreak;\n\t\t}\n\n\t\toaddr += ocp->olt_size;\n\t}\n\n\tbrelse(bp);\n\treturn 0;\n\nfail:\n\tbrelse(bp);\n\treturn -EINVAL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sb_set_blocksize",
          "args": [
            "sbp",
            "rsbp->vs_bsize"
          ],
          "line": 206
        },
        "resolved": true,
        "details": {
          "function_name": "sb_set_blocksize",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/block_dev.c",
          "lines": "116-125",
          "snippet": "int sb_set_blocksize(struct super_block *sb, int size)\n{\n\tif (set_blocksize(sb->s_bdev, size))\n\t\treturn 0;\n\t/* If we get here, we know size is power of two\n\t * and it's value is between 512 and PAGE_SIZE */\n\tsb->s_blocksize = size;\n\tsb->s_blocksize_bits = blksize_bits(size);\n\treturn sb->s_blocksize;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/aio.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/log2.h>",
            "#include <linux/namei.h>",
            "#include <linux/uio.h>",
            "#include <linux/mount.h>",
            "#include <linux/mpage.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/swap.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkpg.h>",
            "#include <linux/module.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/highmem.h>",
            "#include <linux/device_cgroup.h>",
            "#include <linux/major.h>",
            "#include <linux/kmod.h>",
            "#include <linux/slab.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <linux/aio.h>\n#include <linux/cleancache.h>\n#include <linux/log2.h>\n#include <linux/namei.h>\n#include <linux/uio.h>\n#include <linux/mount.h>\n#include <linux/mpage.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/swap.h>\n#include <linux/buffer_head.h>\n#include <linux/magic.h>\n#include <linux/blkpg.h>\n#include <linux/module.h>\n#include <linux/blkdev.h>\n#include <linux/highmem.h>\n#include <linux/device_cgroup.h>\n#include <linux/major.h>\n#include <linux/kmod.h>\n#include <linux/slab.h>\n#include <linux/fcntl.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n\nint sb_set_blocksize(struct super_block *sb, int size)\n{\n\tif (set_blocksize(sb->s_bdev, size))\n\t\treturn 0;\n\t/* If we get here, we know size is power of two\n\t * and it's value is between 512 and PAGE_SIZE */\n\tsb->s_blocksize = size;\n\tsb->s_blocksize_bits = blksize_bits(size);\n\treturn sb->s_blocksize;\n}"
        }
      },
      {
        "call_info": {
          "callee": "buffer_mapped",
          "args": [
            "bp"
          ],
          "line": 172
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sb_bread",
          "args": [
            "sbp",
            "1"
          ],
          "line": 171
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sb_min_blocksize",
          "args": [
            "sbp",
            "BLOCK_SIZE"
          ],
          "line": 165
        },
        "resolved": true,
        "details": {
          "function_name": "sb_min_blocksize",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/block_dev.c",
          "lines": "129-135",
          "snippet": "int sb_min_blocksize(struct super_block *sb, int size)\n{\n\tint minsize = bdev_logical_block_size(sb->s_bdev);\n\tif (size < minsize)\n\t\tsize = minsize;\n\treturn sb_set_blocksize(sb, size);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/aio.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/log2.h>",
            "#include <linux/namei.h>",
            "#include <linux/uio.h>",
            "#include <linux/mount.h>",
            "#include <linux/mpage.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/swap.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkpg.h>",
            "#include <linux/module.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/highmem.h>",
            "#include <linux/device_cgroup.h>",
            "#include <linux/major.h>",
            "#include <linux/kmod.h>",
            "#include <linux/slab.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <linux/aio.h>\n#include <linux/cleancache.h>\n#include <linux/log2.h>\n#include <linux/namei.h>\n#include <linux/uio.h>\n#include <linux/mount.h>\n#include <linux/mpage.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/swap.h>\n#include <linux/buffer_head.h>\n#include <linux/magic.h>\n#include <linux/blkpg.h>\n#include <linux/module.h>\n#include <linux/blkdev.h>\n#include <linux/highmem.h>\n#include <linux/device_cgroup.h>\n#include <linux/major.h>\n#include <linux/kmod.h>\n#include <linux/slab.h>\n#include <linux/fcntl.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n\nint sb_min_blocksize(struct super_block *sb, int size)\n{\n\tint minsize = bdev_logical_block_size(sb->s_bdev);\n\tif (size < minsize)\n\t\tsize = minsize;\n\treturn sb_set_blocksize(sb, size);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "sizeof(*infp)",
            "GFP_KERNEL"
          ],
          "line": 159
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"vxfs_inode.h\"\n#include \"vxfs_dir.h\"\n#include \"vxfs_extern.h\"\n#include \"vxfs.h\"\n#include <linux/mount.h>\n#include <linux/vfs.h>\n#include <linux/stat.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/buffer_head.h>\n#include <linux/fs.h>\n#include <linux/blkdev.h>\n#include <linux/module.h>\n#include <linux/init.h>\n\nstatic void\t\tvxfs_put_super(struct super_block *);\nstatic int\t\tvxfs_remount(struct super_block *, int *, char *);\nstatic const struct super_operations vxfs_super_ops = {\n\t.evict_inode =\t\tvxfs_evict_inode,\n\t.put_super =\t\tvxfs_put_super,\n\t.statfs =\t\tvxfs_statfs,\n\t.remount_fs =\t\tvxfs_remount,\n};\n\nstatic int vxfs_fill_super(struct super_block *sbp, void *dp, int silent)\n{\n\tstruct vxfs_sb_info\t*infp;\n\tstruct vxfs_sb\t\t*rsbp;\n\tstruct buffer_head\t*bp = NULL;\n\tu_long\t\t\tbsize;\n\tstruct inode *root;\n\tint ret = -EINVAL;\n\n\tsbp->s_flags |= MS_RDONLY;\n\n\tinfp = kzalloc(sizeof(*infp), GFP_KERNEL);\n\tif (!infp) {\n\t\tprintk(KERN_WARNING \"vxfs: unable to allocate incore superblock\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tbsize = sb_min_blocksize(sbp, BLOCK_SIZE);\n\tif (!bsize) {\n\t\tprintk(KERN_WARNING \"vxfs: unable to set blocksize\\n\");\n\t\tgoto out;\n\t}\n\n\tbp = sb_bread(sbp, 1);\n\tif (!bp || !buffer_mapped(bp)) {\n\t\tif (!silent) {\n\t\t\tprintk(KERN_WARNING\n\t\t\t\t\"vxfs: unable to read disk superblock\\n\");\n\t\t}\n\t\tgoto out;\n\t}\n\n\trsbp = (struct vxfs_sb *)bp->b_data;\n\tif (rsbp->vs_magic != VXFS_SUPER_MAGIC) {\n\t\tif (!silent)\n\t\t\tprintk(KERN_NOTICE \"vxfs: WRONG superblock magic\\n\");\n\t\tgoto out;\n\t}\n\n\tif ((rsbp->vs_version < 2 || rsbp->vs_version > 4) && !silent) {\n\t\tprintk(KERN_NOTICE \"vxfs: unsupported VxFS version (%d)\\n\",\n\t\t       rsbp->vs_version);\n\t\tgoto out;\n\t}\n\n#ifdef DIAGNOSTIC\n\tprintk(KERN_DEBUG \"vxfs: supported VxFS version (%d)\\n\", rsbp->vs_version);\n\tprintk(KERN_DEBUG \"vxfs: blocksize: %d\\n\", rsbp->vs_bsize);\n#endif\n\n\tsbp->s_magic = rsbp->vs_magic;\n\tsbp->s_fs_info = infp;\n\n\tinfp->vsi_raw = rsbp;\n\tinfp->vsi_bp = bp;\n\tinfp->vsi_oltext = rsbp->vs_oltext[0];\n\tinfp->vsi_oltsize = rsbp->vs_oltsize;\n\n\tif (!sb_set_blocksize(sbp, rsbp->vs_bsize)) {\n\t\tprintk(KERN_WARNING \"vxfs: unable to set final block size\\n\");\n\t\tgoto out;\n\t}\n\n\tif (vxfs_read_olt(sbp, bsize)) {\n\t\tprintk(KERN_WARNING \"vxfs: unable to read olt\\n\");\n\t\tgoto out;\n\t}\n\n\tif (vxfs_read_fshead(sbp)) {\n\t\tprintk(KERN_WARNING \"vxfs: unable to read fshead\\n\");\n\t\tgoto out;\n\t}\n\n\tsbp->s_op = &vxfs_super_ops;\n\troot = vxfs_iget(sbp, VXFS_ROOT_INO);\n\tif (IS_ERR(root)) {\n\t\tret = PTR_ERR(root);\n\t\tgoto out;\n\t}\n\tsbp->s_root = d_make_root(root);\n\tif (!sbp->s_root) {\n\t\tprintk(KERN_WARNING \"vxfs: unable to get root dentry.\\n\");\n\t\tgoto out_free_ilist;\n\t}\n\n\treturn 0;\n\t\nout_free_ilist:\n\tvxfs_put_fake_inode(infp->vsi_fship);\n\tvxfs_put_fake_inode(infp->vsi_ilist);\n\tvxfs_put_fake_inode(infp->vsi_stilist);\nout:\n\tbrelse(bp);\n\tkfree(infp);\n\treturn ret;\n}"
  },
  {
    "function_name": "vxfs_remount",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/freevxfs/vxfs_super.c",
    "lines": "125-130",
    "snippet": "static int vxfs_remount(struct super_block *sb, int *flags, char *data)\n{\n\tsync_filesystem(sb);\n\t*flags |= MS_RDONLY;\n\treturn 0;\n}",
    "includes": [
      "#include \"vxfs_inode.h\"",
      "#include \"vxfs_dir.h\"",
      "#include \"vxfs_extern.h\"",
      "#include \"vxfs.h\"",
      "#include <linux/mount.h>",
      "#include <linux/vfs.h>",
      "#include <linux/stat.h>",
      "#include <linux/slab.h>",
      "#include <linux/kernel.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/fs.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void\t\tvxfs_put_super(struct super_block *);",
      "static int\t\tvxfs_remount(struct super_block *, int *, char *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "sync_filesystem",
          "args": [
            "sb"
          ],
          "line": 127
        },
        "resolved": true,
        "details": {
          "function_name": "sync_filesystem",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/sync.c",
          "lines": "47-67",
          "snippet": "int sync_filesystem(struct super_block *sb)\n{\n\tint ret;\n\n\t/*\n\t * We need to be protected against the filesystem going from\n\t * r/o to r/w or vice versa.\n\t */\n\tWARN_ON(!rwsem_is_locked(&sb->s_umount));\n\n\t/*\n\t * No point in syncing out anything if the filesystem is read-only.\n\t */\n\tif (sb->s_flags & MS_RDONLY)\n\t\treturn 0;\n\n\tret = __sync_filesystem(sb, 0);\n\tif (ret < 0)\n\t\treturn ret;\n\treturn __sync_filesystem(sb, 1);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/backing-dev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/linkage.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/writeback.h>",
            "#include <linux/sched.h>",
            "#include <linux/namei.h>",
            "#include <linux/export.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/backing-dev.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/linkage.h>\n#include <linux/syscalls.h>\n#include <linux/writeback.h>\n#include <linux/sched.h>\n#include <linux/namei.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/kernel.h>\n\nint sync_filesystem(struct super_block *sb)\n{\n\tint ret;\n\n\t/*\n\t * We need to be protected against the filesystem going from\n\t * r/o to r/w or vice versa.\n\t */\n\tWARN_ON(!rwsem_is_locked(&sb->s_umount));\n\n\t/*\n\t * No point in syncing out anything if the filesystem is read-only.\n\t */\n\tif (sb->s_flags & MS_RDONLY)\n\t\treturn 0;\n\n\tret = __sync_filesystem(sb, 0);\n\tif (ret < 0)\n\t\treturn ret;\n\treturn __sync_filesystem(sb, 1);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"vxfs_inode.h\"\n#include \"vxfs_dir.h\"\n#include \"vxfs_extern.h\"\n#include \"vxfs.h\"\n#include <linux/mount.h>\n#include <linux/vfs.h>\n#include <linux/stat.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/buffer_head.h>\n#include <linux/fs.h>\n#include <linux/blkdev.h>\n#include <linux/module.h>\n#include <linux/init.h>\n\nstatic void\t\tvxfs_put_super(struct super_block *);\nstatic int\t\tvxfs_remount(struct super_block *, int *, char *);\n\nstatic int vxfs_remount(struct super_block *sb, int *flags, char *data)\n{\n\tsync_filesystem(sb);\n\t*flags |= MS_RDONLY;\n\treturn 0;\n}"
  },
  {
    "function_name": "vxfs_statfs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/freevxfs/vxfs_super.c",
    "lines": "108-123",
    "snippet": "static int\nvxfs_statfs(struct dentry *dentry, struct kstatfs *bufp)\n{\n\tstruct vxfs_sb_info\t\t*infp = VXFS_SBI(dentry->d_sb);\n\n\tbufp->f_type = VXFS_SUPER_MAGIC;\n\tbufp->f_bsize = dentry->d_sb->s_blocksize;\n\tbufp->f_blocks = infp->vsi_raw->vs_dsize;\n\tbufp->f_bfree = infp->vsi_raw->vs_free;\n\tbufp->f_bavail = 0;\n\tbufp->f_files = 0;\n\tbufp->f_ffree = infp->vsi_raw->vs_ifree;\n\tbufp->f_namelen = VXFS_NAMELEN;\n\n\treturn 0;\n}",
    "includes": [
      "#include \"vxfs_inode.h\"",
      "#include \"vxfs_dir.h\"",
      "#include \"vxfs_extern.h\"",
      "#include \"vxfs.h\"",
      "#include <linux/mount.h>",
      "#include <linux/vfs.h>",
      "#include <linux/stat.h>",
      "#include <linux/slab.h>",
      "#include <linux/kernel.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/fs.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int\t\tvxfs_statfs(struct dentry *, struct kstatfs *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "VXFS_SBI",
          "args": [
            "dentry->d_sb"
          ],
          "line": 111
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"vxfs_inode.h\"\n#include \"vxfs_dir.h\"\n#include \"vxfs_extern.h\"\n#include \"vxfs.h\"\n#include <linux/mount.h>\n#include <linux/vfs.h>\n#include <linux/stat.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/buffer_head.h>\n#include <linux/fs.h>\n#include <linux/blkdev.h>\n#include <linux/module.h>\n#include <linux/init.h>\n\nstatic int\t\tvxfs_statfs(struct dentry *, struct kstatfs *);\n\nstatic int\nvxfs_statfs(struct dentry *dentry, struct kstatfs *bufp)\n{\n\tstruct vxfs_sb_info\t\t*infp = VXFS_SBI(dentry->d_sb);\n\n\tbufp->f_type = VXFS_SUPER_MAGIC;\n\tbufp->f_bsize = dentry->d_sb->s_blocksize;\n\tbufp->f_blocks = infp->vsi_raw->vs_dsize;\n\tbufp->f_bfree = infp->vsi_raw->vs_free;\n\tbufp->f_bavail = 0;\n\tbufp->f_files = 0;\n\tbufp->f_ffree = infp->vsi_raw->vs_ifree;\n\tbufp->f_namelen = VXFS_NAMELEN;\n\n\treturn 0;\n}"
  },
  {
    "function_name": "vxfs_put_super",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/freevxfs/vxfs_super.c",
    "lines": "77-88",
    "snippet": "static void\nvxfs_put_super(struct super_block *sbp)\n{\n\tstruct vxfs_sb_info\t*infp = VXFS_SBI(sbp);\n\n\tvxfs_put_fake_inode(infp->vsi_fship);\n\tvxfs_put_fake_inode(infp->vsi_ilist);\n\tvxfs_put_fake_inode(infp->vsi_stilist);\n\n\tbrelse(infp->vsi_bp);\n\tkfree(infp);\n}",
    "includes": [
      "#include \"vxfs_inode.h\"",
      "#include \"vxfs_dir.h\"",
      "#include \"vxfs_extern.h\"",
      "#include \"vxfs.h\"",
      "#include <linux/mount.h>",
      "#include <linux/vfs.h>",
      "#include <linux/stat.h>",
      "#include <linux/slab.h>",
      "#include <linux/kernel.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/fs.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void\t\tvxfs_put_super(struct super_block *);",
      "static int\t\tvxfs_remount(struct super_block *, int *, char *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "infp"
          ],
          "line": 87
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "brelse",
          "args": [
            "infp->vsi_bp"
          ],
          "line": 86
        },
        "resolved": true,
        "details": {
          "function_name": "__brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1177-1184",
          "snippet": "void __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "vxfs_put_fake_inode",
          "args": [
            "infp->vsi_stilist"
          ],
          "line": 84
        },
        "resolved": true,
        "details": {
          "function_name": "vxfs_put_fake_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/freevxfs/vxfs_inode.c",
          "lines": "277-281",
          "snippet": "void\nvxfs_put_fake_inode(struct inode *ip)\n{\n\tiput(ip);\n}",
          "includes": [
            "#include \"vxfs_extern.h\"",
            "#include \"vxfs_inode.h\"",
            "#include \"vxfs.h\"",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vxfs_extern.h\"\n#include \"vxfs_inode.h\"\n#include \"vxfs.h\"\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/pagemap.h>\n#include <linux/buffer_head.h>\n#include <linux/fs.h>\n\nvoid\nvxfs_put_fake_inode(struct inode *ip)\n{\n\tiput(ip);\n}"
        }
      },
      {
        "call_info": {
          "callee": "VXFS_SBI",
          "args": [
            "sbp"
          ],
          "line": 80
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"vxfs_inode.h\"\n#include \"vxfs_dir.h\"\n#include \"vxfs_extern.h\"\n#include \"vxfs.h\"\n#include <linux/mount.h>\n#include <linux/vfs.h>\n#include <linux/stat.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/buffer_head.h>\n#include <linux/fs.h>\n#include <linux/blkdev.h>\n#include <linux/module.h>\n#include <linux/init.h>\n\nstatic void\t\tvxfs_put_super(struct super_block *);\nstatic int\t\tvxfs_remount(struct super_block *, int *, char *);\n\nstatic void\nvxfs_put_super(struct super_block *sbp)\n{\n\tstruct vxfs_sb_info\t*infp = VXFS_SBI(sbp);\n\n\tvxfs_put_fake_inode(infp->vsi_fship);\n\tvxfs_put_fake_inode(infp->vsi_ilist);\n\tvxfs_put_fake_inode(infp->vsi_stilist);\n\n\tbrelse(infp->vsi_bp);\n\tkfree(infp);\n}"
  }
]