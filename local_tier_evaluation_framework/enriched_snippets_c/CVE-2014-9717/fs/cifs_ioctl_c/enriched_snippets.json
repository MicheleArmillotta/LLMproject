[
  {
    "function_name": "cifs_ioctl",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/ioctl.c",
    "lines": "130-217",
    "snippet": "long cifs_ioctl(struct file *filep, unsigned int command, unsigned long arg)\n{\n\tstruct inode *inode = file_inode(filep);\n\tint rc = -ENOTTY; /* strange error - but the precedent */\n\tunsigned int xid;\n\tstruct cifs_sb_info *cifs_sb;\n\tstruct cifsFileInfo *pSMBFile = filep->private_data;\n\tstruct cifs_tcon *tcon;\n\t__u64\tExtAttrBits = 0;\n\t__u64   caps;\n\n\txid = get_xid();\n\n\tcifs_dbg(FYI, \"ioctl file %p  cmd %u  arg %lu\\n\", filep, command, arg);\n\n\tcifs_sb = CIFS_SB(inode->i_sb);\n\n\tswitch (command) {\n\t\tcase FS_IOC_GETFLAGS:\n\t\t\tif (pSMBFile == NULL)\n\t\t\t\tbreak;\n\t\t\ttcon = tlink_tcon(pSMBFile->tlink);\n\t\t\tcaps = le64_to_cpu(tcon->fsUnixInfo.Capability);\n#ifdef CONFIG_CIFS_POSIX\n\t\t\tif (CIFS_UNIX_EXTATTR_CAP & caps) {\n\t\t\t\t__u64\tExtAttrMask = 0;\n\t\t\t\trc = CIFSGetExtAttr(xid, tcon,\n\t\t\t\t\t\t    pSMBFile->fid.netfid,\n\t\t\t\t\t\t    &ExtAttrBits, &ExtAttrMask);\n\t\t\t\tif (rc == 0)\n\t\t\t\t\trc = put_user(ExtAttrBits &\n\t\t\t\t\t\tFS_FL_USER_VISIBLE,\n\t\t\t\t\t\t(int __user *)arg);\n\t\t\t\tif (rc != EOPNOTSUPP)\n\t\t\t\t\tbreak;\n\t\t\t}\n#endif /* CONFIG_CIFS_POSIX */\n\t\t\trc = 0;\n\t\t\tif (CIFS_I(inode)->cifsAttrs & ATTR_COMPRESSED) {\n\t\t\t\t/* add in the compressed bit */\n\t\t\t\tExtAttrBits = FS_COMPR_FL;\n\t\t\t\trc = put_user(ExtAttrBits & FS_FL_USER_VISIBLE,\n\t\t\t\t\t      (int __user *)arg);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase FS_IOC_SETFLAGS:\n\t\t\tif (pSMBFile == NULL)\n\t\t\t\tbreak;\n\t\t\ttcon = tlink_tcon(pSMBFile->tlink);\n\t\t\tcaps = le64_to_cpu(tcon->fsUnixInfo.Capability);\n\n\t\t\tif (get_user(ExtAttrBits, (int __user *)arg)) {\n\t\t\t\trc = -EFAULT;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * if (CIFS_UNIX_EXTATTR_CAP & caps)\n\t\t\t *\trc = CIFSSetExtAttr(xid, tcon,\n\t\t\t *\t\t       pSMBFile->fid.netfid,\n\t\t\t *\t\t       extAttrBits,\n\t\t\t *\t\t       &ExtAttrMask);\n\t\t\t * if (rc != EOPNOTSUPP)\n\t\t\t *\tbreak;\n\t\t\t */\n\n\t\t\t/* Currently only flag we can set is compressed flag */\n\t\t\tif ((ExtAttrBits & FS_COMPR_FL) == 0)\n\t\t\t\tbreak;\n\n\t\t\t/* Try to set compress flag */\n\t\t\tif (tcon->ses->server->ops->set_compression) {\n\t\t\t\trc = tcon->ses->server->ops->set_compression(\n\t\t\t\t\t\t\txid, tcon, pSMBFile);\n\t\t\t\tcifs_dbg(FYI, \"set compress flag rc %d\\n\", rc);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase CIFS_IOC_COPYCHUNK_FILE:\n\t\t\trc = cifs_ioctl_clone(xid, filep, arg, 0, 0, 0);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tcifs_dbg(FYI, \"unsupported ioctl\\n\");\n\t\t\tbreak;\n\t}\n\n\tfree_xid(xid);\n\treturn rc;\n}",
    "includes": [
      "#include \"cifsfs.h\"",
      "#include \"cifs_debug.h\"",
      "#include \"cifsproto.h\"",
      "#include \"cifsglob.h\"",
      "#include \"cifspdu.h\"",
      "#include <linux/pagemap.h>",
      "#include <linux/mm.h>",
      "#include <linux/mount.h>",
      "#include <linux/file.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [
      "#define CIFS_IOC_COPYCHUNK_FILE\t_IOW(CIFS_IOCTL_MAGIC, 3, int)"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "free_xid",
          "args": [
            "xid"
          ],
          "line": 215
        },
        "resolved": true,
        "details": {
          "function_name": "_free_xid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/misc.c",
          "lines": "63-71",
          "snippet": "void\n_free_xid(unsigned int xid)\n{\n\tspin_lock(&GlobalMid_Lock);\n\t/* if (GlobalTotalActiveXid == 0)\n\t\tBUG(); */\n\tGlobalTotalActiveXid--;\n\tspin_unlock(&GlobalMid_Lock);\n}",
          "includes": [
            "#include \"smb2pdu.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"nterr.h\"",
            "#include \"smberr.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <linux/mempool.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"smb2pdu.h\"\n#include \"cifs_unicode.h\"\n#include \"nterr.h\"\n#include \"smberr.h\"\n#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <linux/mempool.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n\nvoid\n_free_xid(unsigned int xid)\n{\n\tspin_lock(&GlobalMid_Lock);\n\t/* if (GlobalTotalActiveXid == 0)\n\t\tBUG(); */\n\tGlobalTotalActiveXid--;\n\tspin_unlock(&GlobalMid_Lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "FYI",
            "\"unsupported ioctl\\n\""
          ],
          "line": 211
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cifs_ioctl_clone",
          "args": [
            "xid",
            "filep",
            "arg",
            "0",
            "0",
            "0"
          ],
          "line": 208
        },
        "resolved": true,
        "details": {
          "function_name": "cifs_ioctl_clone",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/ioctl.c",
          "lines": "38-128",
          "snippet": "static long cifs_ioctl_clone(unsigned int xid, struct file *dst_file,\n\t\t\tunsigned long srcfd, u64 off, u64 len, u64 destoff)\n{\n\tint rc;\n\tstruct cifsFileInfo *smb_file_target = dst_file->private_data;\n\tstruct inode *target_inode = file_inode(dst_file);\n\tstruct cifs_tcon *target_tcon;\n\tstruct fd src_file;\n\tstruct cifsFileInfo *smb_file_src;\n\tstruct inode *src_inode;\n\tstruct cifs_tcon *src_tcon;\n\n\tcifs_dbg(FYI, \"ioctl clone range\\n\");\n\t/* the destination must be opened for writing */\n\tif (!(dst_file->f_mode & FMODE_WRITE)) {\n\t\tcifs_dbg(FYI, \"file target not open for write\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\t/* check if target volume is readonly and take reference */\n\trc = mnt_want_write_file(dst_file);\n\tif (rc) {\n\t\tcifs_dbg(FYI, \"mnt_want_write failed with rc %d\\n\", rc);\n\t\treturn rc;\n\t}\n\n\tsrc_file = fdget(srcfd);\n\tif (!src_file.file) {\n\t\trc = -EBADF;\n\t\tgoto out_drop_write;\n\t}\n\n\tif ((!src_file.file->private_data) || (!dst_file->private_data)) {\n\t\trc = -EBADF;\n\t\tcifs_dbg(VFS, \"missing cifsFileInfo on copy range src file\\n\");\n\t\tgoto out_fput;\n\t}\n\n\trc = -EXDEV;\n\tsmb_file_target = dst_file->private_data;\n\tsmb_file_src = src_file.file->private_data;\n\tsrc_tcon = tlink_tcon(smb_file_src->tlink);\n\ttarget_tcon = tlink_tcon(smb_file_target->tlink);\n\n\t/* check if source and target are on same tree connection */\n\tif (src_tcon != target_tcon) {\n\t\tcifs_dbg(VFS, \"file copy src and target on different volume\\n\");\n\t\tgoto out_fput;\n\t}\n\n\tsrc_inode = file_inode(src_file.file);\n\trc = -EINVAL;\n\tif (S_ISDIR(src_inode->i_mode))\n\t\tgoto out_fput;\n\n\t/*\n\t * Note: cifs case is easier than btrfs since server responsible for\n\t * checks for proper open modes and file type and if it wants\n\t * server could even support copy of range where source = target\n\t */\n\tlock_two_nondirectories(target_inode, src_inode);\n\n\t/* determine range to clone */\n\trc = -EINVAL;\n\tif (off + len > src_inode->i_size || off + len < off)\n\t\tgoto out_unlock;\n\tif (len == 0)\n\t\tlen = src_inode->i_size - off;\n\n\tcifs_dbg(FYI, \"about to flush pages\\n\");\n\t/* should we flush first and last page first */\n\ttruncate_inode_pages_range(&target_inode->i_data, destoff,\n\t\t\t\t   PAGE_CACHE_ALIGN(destoff + len)-1);\n\n\tif (target_tcon->ses->server->ops->clone_range)\n\t\trc = target_tcon->ses->server->ops->clone_range(xid,\n\t\t\tsmb_file_src, smb_file_target, off, len, destoff);\n\n\t/* force revalidate of size and timestamps of target file now\n\t   that target is updated on the server */\n\tCIFS_I(target_inode)->time = 0;\nout_unlock:\n\t/* although unlocking in the reverse order from locking is not\n\t   strictly necessary here it is a little cleaner to be consistent */\n\tunlock_two_nondirectories(src_inode, target_inode);\nout_fput:\n\tfdput(src_file);\nout_drop_write:\n\tmnt_drop_write_file(dst_file);\n\treturn rc;\n}",
          "includes": [
            "#include \"cifsfs.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/mount.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifsfs.h\"\n#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/mount.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n\nstatic long cifs_ioctl_clone(unsigned int xid, struct file *dst_file,\n\t\t\tunsigned long srcfd, u64 off, u64 len, u64 destoff)\n{\n\tint rc;\n\tstruct cifsFileInfo *smb_file_target = dst_file->private_data;\n\tstruct inode *target_inode = file_inode(dst_file);\n\tstruct cifs_tcon *target_tcon;\n\tstruct fd src_file;\n\tstruct cifsFileInfo *smb_file_src;\n\tstruct inode *src_inode;\n\tstruct cifs_tcon *src_tcon;\n\n\tcifs_dbg(FYI, \"ioctl clone range\\n\");\n\t/* the destination must be opened for writing */\n\tif (!(dst_file->f_mode & FMODE_WRITE)) {\n\t\tcifs_dbg(FYI, \"file target not open for write\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\t/* check if target volume is readonly and take reference */\n\trc = mnt_want_write_file(dst_file);\n\tif (rc) {\n\t\tcifs_dbg(FYI, \"mnt_want_write failed with rc %d\\n\", rc);\n\t\treturn rc;\n\t}\n\n\tsrc_file = fdget(srcfd);\n\tif (!src_file.file) {\n\t\trc = -EBADF;\n\t\tgoto out_drop_write;\n\t}\n\n\tif ((!src_file.file->private_data) || (!dst_file->private_data)) {\n\t\trc = -EBADF;\n\t\tcifs_dbg(VFS, \"missing cifsFileInfo on copy range src file\\n\");\n\t\tgoto out_fput;\n\t}\n\n\trc = -EXDEV;\n\tsmb_file_target = dst_file->private_data;\n\tsmb_file_src = src_file.file->private_data;\n\tsrc_tcon = tlink_tcon(smb_file_src->tlink);\n\ttarget_tcon = tlink_tcon(smb_file_target->tlink);\n\n\t/* check if source and target are on same tree connection */\n\tif (src_tcon != target_tcon) {\n\t\tcifs_dbg(VFS, \"file copy src and target on different volume\\n\");\n\t\tgoto out_fput;\n\t}\n\n\tsrc_inode = file_inode(src_file.file);\n\trc = -EINVAL;\n\tif (S_ISDIR(src_inode->i_mode))\n\t\tgoto out_fput;\n\n\t/*\n\t * Note: cifs case is easier than btrfs since server responsible for\n\t * checks for proper open modes and file type and if it wants\n\t * server could even support copy of range where source = target\n\t */\n\tlock_two_nondirectories(target_inode, src_inode);\n\n\t/* determine range to clone */\n\trc = -EINVAL;\n\tif (off + len > src_inode->i_size || off + len < off)\n\t\tgoto out_unlock;\n\tif (len == 0)\n\t\tlen = src_inode->i_size - off;\n\n\tcifs_dbg(FYI, \"about to flush pages\\n\");\n\t/* should we flush first and last page first */\n\ttruncate_inode_pages_range(&target_inode->i_data, destoff,\n\t\t\t\t   PAGE_CACHE_ALIGN(destoff + len)-1);\n\n\tif (target_tcon->ses->server->ops->clone_range)\n\t\trc = target_tcon->ses->server->ops->clone_range(xid,\n\t\t\tsmb_file_src, smb_file_target, off, len, destoff);\n\n\t/* force revalidate of size and timestamps of target file now\n\t   that target is updated on the server */\n\tCIFS_I(target_inode)->time = 0;\nout_unlock:\n\t/* although unlocking in the reverse order from locking is not\n\t   strictly necessary here it is a little cleaner to be consistent */\n\tunlock_two_nondirectories(src_inode, target_inode);\nout_fput:\n\tfdput(src_file);\nout_drop_write:\n\tmnt_drop_write_file(dst_file);\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "FYI",
            "\"set compress flag rc %d\\n\"",
            "rc"
          ],
          "line": 204
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tcon->ses->server->ops->set_compression",
          "args": [
            "xid",
            "tcon",
            "pSMBFile"
          ],
          "line": 202
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_user",
          "args": [
            "ExtAttrBits",
            "(int __user *)arg"
          ],
          "line": 181
        },
        "resolved": true,
        "details": {
          "function_name": "get_user_arg_ptr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/exec.c",
          "lines": "399-418",
          "snippet": "static const char __user *get_user_arg_ptr(struct user_arg_ptr argv, int nr)\n{\n\tconst char __user *native;\n\n#ifdef CONFIG_COMPAT\n\tif (unlikely(argv.is_compat)) {\n\t\tcompat_uptr_t compat;\n\n\t\tif (get_user(compat, argv.ptr.compat + nr))\n\t\t\treturn ERR_PTR(-EFAULT);\n\n\t\treturn compat_ptr(compat);\n\t}\n#endif\n\n\tif (get_user(native, argv.ptr.native + nr))\n\t\treturn ERR_PTR(-EFAULT);\n\n\treturn native;\n}",
          "includes": [
            "#include <trace/events/sched.h>",
            "#include \"internal.h\"",
            "#include <trace/events/task.h>",
            "#include <asm/tlb.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/oom.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/kmod.h>",
            "#include <linux/tracehook.h>",
            "#include <linux/audit.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/module.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/utsname.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/personality.h>",
            "#include <linux/key.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/highmem.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/init.h>",
            "#include <linux/string.h>",
            "#include <linux/swap.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/stat.h>",
            "#include <linux/vmacache.h>",
            "#include <linux/mm.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/sched.h>\n#include \"internal.h\"\n#include <trace/events/task.h>\n#include <asm/tlb.h>\n#include <asm/mmu_context.h>\n#include <asm/uaccess.h>\n#include <linux/compat.h>\n#include <linux/oom.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/fs_struct.h>\n#include <linux/fsnotify.h>\n#include <linux/kmod.h>\n#include <linux/tracehook.h>\n#include <linux/audit.h>\n#include <linux/cn_proc.h>\n#include <linux/tsacct_kern.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/module.h>\n#include <linux/pid_namespace.h>\n#include <linux/utsname.h>\n#include <linux/binfmts.h>\n#include <linux/personality.h>\n#include <linux/key.h>\n#include <linux/spinlock.h>\n#include <linux/highmem.h>\n#include <linux/perf_event.h>\n#include <linux/pagemap.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/swap.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n\nstatic const char __user *get_user_arg_ptr(struct user_arg_ptr argv, int nr)\n{\n\tconst char __user *native;\n\n#ifdef CONFIG_COMPAT\n\tif (unlikely(argv.is_compat)) {\n\t\tcompat_uptr_t compat;\n\n\t\tif (get_user(compat, argv.ptr.compat + nr))\n\t\t\treturn ERR_PTR(-EFAULT);\n\n\t\treturn compat_ptr(compat);\n\t}\n#endif\n\n\tif (get_user(native, argv.ptr.native + nr))\n\t\treturn ERR_PTR(-EFAULT);\n\n\treturn native;\n}"
        }
      },
      {
        "call_info": {
          "callee": "le64_to_cpu",
          "args": [
            "tcon->fsUnixInfo.Capability"
          ],
          "line": 179
        },
        "resolved": true,
        "details": {
          "function_name": "sle64_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "58-61",
          "snippet": "static inline s64 sle64_to_cpup(sle64 *x)\n{\n\treturn le64_to_cpu(*(__force le64*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s64 sle64_to_cpup(sle64 *x)\n{\n\treturn le64_to_cpu(*(__force le64*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "tlink_tcon",
          "args": [
            "pSMBFile->tlink"
          ],
          "line": 178
        },
        "resolved": true,
        "details": {
          "function_name": "tlink_tcon",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifsglob.h",
          "lines": "931-935",
          "snippet": "static inline struct cifs_tcon *\ntlink_tcon(struct tcon_link *tlink)\n{\n\treturn tlink->tl_tcon;\n}",
          "includes": [
            "#include \"cifspdu.h\"",
            "#include \"smb2pdu.h\"",
            "#include <uapi/linux/cifs/cifs_mount.h>",
            "#include <linux/scatterlist.h>",
            "#include <crypto/internal/hash.h>",
            "#include \"cifsacl.h\"",
            "#include \"cifs_fs_sb.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/mempool.h>",
            "#include <linux/slab.h>",
            "#include <linux/in6.h>",
            "#include <linux/in.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifspdu.h\"\n#include \"smb2pdu.h\"\n#include <uapi/linux/cifs/cifs_mount.h>\n#include <linux/scatterlist.h>\n#include <crypto/internal/hash.h>\n#include \"cifsacl.h\"\n#include \"cifs_fs_sb.h\"\n#include <linux/workqueue.h>\n#include <linux/mempool.h>\n#include <linux/slab.h>\n#include <linux/in6.h>\n#include <linux/in.h>\n\nstatic inline struct cifs_tcon *\ntlink_tcon(struct tcon_link *tlink)\n{\n\treturn tlink->tl_tcon;\n}"
        }
      },
      {
        "call_info": {
          "callee": "put_user",
          "args": [
            "ExtAttrBits & FS_FL_USER_VISIBLE",
            "(int __user *)arg"
          ],
          "line": 171
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CIFS_I",
          "args": [
            "inode"
          ],
          "line": 168
        },
        "resolved": true,
        "details": {
          "function_name": "CIFS_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifsglob.h",
          "lines": "1159-1163",
          "snippet": "static inline struct cifsInodeInfo *\nCIFS_I(struct inode *inode)\n{\n\treturn container_of(inode, struct cifsInodeInfo, vfs_inode);\n}",
          "includes": [
            "#include \"cifspdu.h\"",
            "#include \"smb2pdu.h\"",
            "#include <uapi/linux/cifs/cifs_mount.h>",
            "#include <linux/scatterlist.h>",
            "#include <crypto/internal/hash.h>",
            "#include \"cifsacl.h\"",
            "#include \"cifs_fs_sb.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/mempool.h>",
            "#include <linux/slab.h>",
            "#include <linux/in6.h>",
            "#include <linux/in.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifspdu.h\"\n#include \"smb2pdu.h\"\n#include <uapi/linux/cifs/cifs_mount.h>\n#include <linux/scatterlist.h>\n#include <crypto/internal/hash.h>\n#include \"cifsacl.h\"\n#include \"cifs_fs_sb.h\"\n#include <linux/workqueue.h>\n#include <linux/mempool.h>\n#include <linux/slab.h>\n#include <linux/in6.h>\n#include <linux/in.h>\n\nstatic inline struct cifsInodeInfo *\nCIFS_I(struct inode *inode)\n{\n\treturn container_of(inode, struct cifsInodeInfo, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "put_user",
          "args": [
            "ExtAttrBits &\n\t\t\t\t\t\tFS_FL_USER_VISIBLE",
            "(int __user *)arg"
          ],
          "line": 160
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CIFSGetExtAttr",
          "args": [
            "xid",
            "tcon",
            "pSMBFile->fid.netfid",
            "&ExtAttrBits",
            "&ExtAttrMask"
          ],
          "line": 156
        },
        "resolved": true,
        "details": {
          "function_name": "CIFSGetExtAttr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifssmb.c",
          "lines": "3626-3705",
          "snippet": "int\nCIFSGetExtAttr(const unsigned int xid, struct cifs_tcon *tcon,\n\t       const int netfid, __u64 *pExtAttrBits, __u64 *pMask)\n{\n\tint rc = 0;\n\tstruct smb_t2_qfi_req *pSMB = NULL;\n\tstruct smb_t2_qfi_rsp *pSMBr = NULL;\n\tint bytes_returned;\n\t__u16 params, byte_count;\n\n\tcifs_dbg(FYI, \"In GetExtAttr\\n\");\n\tif (tcon == NULL)\n\t\treturn -ENODEV;\n\nGetExtAttrRetry:\n\trc = smb_init(SMB_COM_TRANSACTION2, 15, tcon, (void **) &pSMB,\n\t\t\t(void **) &pSMBr);\n\tif (rc)\n\t\treturn rc;\n\n\tparams = 2 /* level */ + 2 /* fid */;\n\tpSMB->t2.TotalDataCount = 0;\n\tpSMB->t2.MaxParameterCount = cpu_to_le16(4);\n\t/* BB find exact max data count below from sess structure BB */\n\tpSMB->t2.MaxDataCount = cpu_to_le16(4000);\n\tpSMB->t2.MaxSetupCount = 0;\n\tpSMB->t2.Reserved = 0;\n\tpSMB->t2.Flags = 0;\n\tpSMB->t2.Timeout = 0;\n\tpSMB->t2.Reserved2 = 0;\n\tpSMB->t2.ParameterOffset = cpu_to_le16(offsetof(struct smb_t2_qfi_req,\n\t\t\t\t\t       Fid) - 4);\n\tpSMB->t2.DataCount = 0;\n\tpSMB->t2.DataOffset = 0;\n\tpSMB->t2.SetupCount = 1;\n\tpSMB->t2.Reserved3 = 0;\n\tpSMB->t2.SubCommand = cpu_to_le16(TRANS2_QUERY_FILE_INFORMATION);\n\tbyte_count = params + 1 /* pad */ ;\n\tpSMB->t2.TotalParameterCount = cpu_to_le16(params);\n\tpSMB->t2.ParameterCount = pSMB->t2.TotalParameterCount;\n\tpSMB->InformationLevel = cpu_to_le16(SMB_QUERY_ATTR_FLAGS);\n\tpSMB->Pad = 0;\n\tpSMB->Fid = netfid;\n\tinc_rfc1001_len(pSMB, byte_count);\n\tpSMB->t2.ByteCount = cpu_to_le16(byte_count);\n\n\trc = SendReceive(xid, tcon->ses, (struct smb_hdr *) pSMB,\n\t\t\t (struct smb_hdr *) pSMBr, &bytes_returned, 0);\n\tif (rc) {\n\t\tcifs_dbg(FYI, \"error %d in GetExtAttr\\n\", rc);\n\t} else {\n\t\t/* decode response */\n\t\trc = validate_t2((struct smb_t2_rsp *)pSMBr);\n\t\t/* BB also check enough total bytes returned */\n\t\tif (rc || get_bcc(&pSMBr->hdr) < 2)\n\t\t\t/* If rc should we check for EOPNOSUPP and\n\t\t\t   disable the srvino flag? or in caller? */\n\t\t\trc = -EIO;      /* bad smb */\n\t\telse {\n\t\t\t__u16 data_offset = le16_to_cpu(pSMBr->t2.DataOffset);\n\t\t\t__u16 count = le16_to_cpu(pSMBr->t2.DataCount);\n\t\t\tstruct file_chattr_info *pfinfo;\n\t\t\t/* BB Do we need a cast or hash here ? */\n\t\t\tif (count != 16) {\n\t\t\t\tcifs_dbg(FYI, \"Illegal size ret in GetExtAttr\\n\");\n\t\t\t\trc = -EIO;\n\t\t\t\tgoto GetExtAttrOut;\n\t\t\t}\n\t\t\tpfinfo = (struct file_chattr_info *)\n\t\t\t\t (data_offset + (char *) &pSMBr->hdr.Protocol);\n\t\t\t*pExtAttrBits = le64_to_cpu(pfinfo->mode);\n\t\t\t*pMask = le64_to_cpu(pfinfo->mask);\n\t\t}\n\t}\nGetExtAttrOut:\n\tcifs_buf_release(pSMB);\n\tif (rc == -EAGAIN)\n\t\tgoto GetExtAttrRetry;\n\treturn rc;\n}",
          "includes": [
            "#include \"fscache.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsacl.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/slab.h>",
            "#include <linux/vfs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fscache.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsacl.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <asm/uaccess.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/slab.h>\n#include <linux/vfs.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n\nint\nCIFSGetExtAttr(const unsigned int xid, struct cifs_tcon *tcon,\n\t       const int netfid, __u64 *pExtAttrBits, __u64 *pMask)\n{\n\tint rc = 0;\n\tstruct smb_t2_qfi_req *pSMB = NULL;\n\tstruct smb_t2_qfi_rsp *pSMBr = NULL;\n\tint bytes_returned;\n\t__u16 params, byte_count;\n\n\tcifs_dbg(FYI, \"In GetExtAttr\\n\");\n\tif (tcon == NULL)\n\t\treturn -ENODEV;\n\nGetExtAttrRetry:\n\trc = smb_init(SMB_COM_TRANSACTION2, 15, tcon, (void **) &pSMB,\n\t\t\t(void **) &pSMBr);\n\tif (rc)\n\t\treturn rc;\n\n\tparams = 2 /* level */ + 2 /* fid */;\n\tpSMB->t2.TotalDataCount = 0;\n\tpSMB->t2.MaxParameterCount = cpu_to_le16(4);\n\t/* BB find exact max data count below from sess structure BB */\n\tpSMB->t2.MaxDataCount = cpu_to_le16(4000);\n\tpSMB->t2.MaxSetupCount = 0;\n\tpSMB->t2.Reserved = 0;\n\tpSMB->t2.Flags = 0;\n\tpSMB->t2.Timeout = 0;\n\tpSMB->t2.Reserved2 = 0;\n\tpSMB->t2.ParameterOffset = cpu_to_le16(offsetof(struct smb_t2_qfi_req,\n\t\t\t\t\t       Fid) - 4);\n\tpSMB->t2.DataCount = 0;\n\tpSMB->t2.DataOffset = 0;\n\tpSMB->t2.SetupCount = 1;\n\tpSMB->t2.Reserved3 = 0;\n\tpSMB->t2.SubCommand = cpu_to_le16(TRANS2_QUERY_FILE_INFORMATION);\n\tbyte_count = params + 1 /* pad */ ;\n\tpSMB->t2.TotalParameterCount = cpu_to_le16(params);\n\tpSMB->t2.ParameterCount = pSMB->t2.TotalParameterCount;\n\tpSMB->InformationLevel = cpu_to_le16(SMB_QUERY_ATTR_FLAGS);\n\tpSMB->Pad = 0;\n\tpSMB->Fid = netfid;\n\tinc_rfc1001_len(pSMB, byte_count);\n\tpSMB->t2.ByteCount = cpu_to_le16(byte_count);\n\n\trc = SendReceive(xid, tcon->ses, (struct smb_hdr *) pSMB,\n\t\t\t (struct smb_hdr *) pSMBr, &bytes_returned, 0);\n\tif (rc) {\n\t\tcifs_dbg(FYI, \"error %d in GetExtAttr\\n\", rc);\n\t} else {\n\t\t/* decode response */\n\t\trc = validate_t2((struct smb_t2_rsp *)pSMBr);\n\t\t/* BB also check enough total bytes returned */\n\t\tif (rc || get_bcc(&pSMBr->hdr) < 2)\n\t\t\t/* If rc should we check for EOPNOSUPP and\n\t\t\t   disable the srvino flag? or in caller? */\n\t\t\trc = -EIO;      /* bad smb */\n\t\telse {\n\t\t\t__u16 data_offset = le16_to_cpu(pSMBr->t2.DataOffset);\n\t\t\t__u16 count = le16_to_cpu(pSMBr->t2.DataCount);\n\t\t\tstruct file_chattr_info *pfinfo;\n\t\t\t/* BB Do we need a cast or hash here ? */\n\t\t\tif (count != 16) {\n\t\t\t\tcifs_dbg(FYI, \"Illegal size ret in GetExtAttr\\n\");\n\t\t\t\trc = -EIO;\n\t\t\t\tgoto GetExtAttrOut;\n\t\t\t}\n\t\t\tpfinfo = (struct file_chattr_info *)\n\t\t\t\t (data_offset + (char *) &pSMBr->hdr.Protocol);\n\t\t\t*pExtAttrBits = le64_to_cpu(pfinfo->mode);\n\t\t\t*pMask = le64_to_cpu(pfinfo->mask);\n\t\t}\n\t}\nGetExtAttrOut:\n\tcifs_buf_release(pSMB);\n\tif (rc == -EAGAIN)\n\t\tgoto GetExtAttrRetry;\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "CIFS_SB",
          "args": [
            "inode->i_sb"
          ],
          "line": 145
        },
        "resolved": true,
        "details": {
          "function_name": "CIFS_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifsglob.h",
          "lines": "1165-1169",
          "snippet": "static inline struct cifs_sb_info *\nCIFS_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include \"cifspdu.h\"",
            "#include \"smb2pdu.h\"",
            "#include <uapi/linux/cifs/cifs_mount.h>",
            "#include <linux/scatterlist.h>",
            "#include <crypto/internal/hash.h>",
            "#include \"cifsacl.h\"",
            "#include \"cifs_fs_sb.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/mempool.h>",
            "#include <linux/slab.h>",
            "#include <linux/in6.h>",
            "#include <linux/in.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifspdu.h\"\n#include \"smb2pdu.h\"\n#include <uapi/linux/cifs/cifs_mount.h>\n#include <linux/scatterlist.h>\n#include <crypto/internal/hash.h>\n#include \"cifsacl.h\"\n#include \"cifs_fs_sb.h\"\n#include <linux/workqueue.h>\n#include <linux/mempool.h>\n#include <linux/slab.h>\n#include <linux/in6.h>\n#include <linux/in.h>\n\nstatic inline struct cifs_sb_info *\nCIFS_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "FYI",
            "\"ioctl file %p  cmd %u  arg %lu\\n\"",
            "filep",
            "command",
            "arg"
          ],
          "line": 143
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_xid",
          "args": [],
          "line": 141
        },
        "resolved": true,
        "details": {
          "function_name": "_get_xid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/misc.c",
          "lines": "45-61",
          "snippet": "unsigned int\n_get_xid(void)\n{\n\tunsigned int xid;\n\n\tspin_lock(&GlobalMid_Lock);\n\tGlobalTotalActiveXid++;\n\n\t/* keep high water mark for number of simultaneous ops in filesystem */\n\tif (GlobalTotalActiveXid > GlobalMaxActiveXid)\n\t\tGlobalMaxActiveXid = GlobalTotalActiveXid;\n\tif (GlobalTotalActiveXid > 65000)\n\t\tcifs_dbg(FYI, \"warning: more than 65000 requests active\\n\");\n\txid = GlobalCurrentXid++;\n\tspin_unlock(&GlobalMid_Lock);\n\treturn xid;\n}",
          "includes": [
            "#include \"smb2pdu.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"nterr.h\"",
            "#include \"smberr.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <linux/mempool.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"smb2pdu.h\"\n#include \"cifs_unicode.h\"\n#include \"nterr.h\"\n#include \"smberr.h\"\n#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <linux/mempool.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n\nunsigned int\n_get_xid(void)\n{\n\tunsigned int xid;\n\n\tspin_lock(&GlobalMid_Lock);\n\tGlobalTotalActiveXid++;\n\n\t/* keep high water mark for number of simultaneous ops in filesystem */\n\tif (GlobalTotalActiveXid > GlobalMaxActiveXid)\n\t\tGlobalMaxActiveXid = GlobalTotalActiveXid;\n\tif (GlobalTotalActiveXid > 65000)\n\t\tcifs_dbg(FYI, \"warning: more than 65000 requests active\\n\");\n\txid = GlobalCurrentXid++;\n\tspin_unlock(&GlobalMid_Lock);\n\treturn xid;\n}"
        }
      },
      {
        "call_info": {
          "callee": "file_inode",
          "args": [
            "filep"
          ],
          "line": 132
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_init_file_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/file.c",
          "lines": "3009-3013",
          "snippet": "void fuse_init_file_inode(struct inode *inode)\n{\n\tinode->i_fop = &fuse_file_operations;\n\tinode->i_data.a_ops = &fuse_file_aops;\n}",
          "includes": [
            "#include <linux/falloc.h>",
            "#include <linux/aio.h>",
            "#include <linux/swap.h>",
            "#include <linux/compat.h>",
            "#include <linux/module.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct file_operations fuse_file_operations = {\n\t.llseek\t\t= fuse_file_llseek,\n\t.read\t\t= new_sync_read,\n\t.read_iter\t= fuse_file_read_iter,\n\t.write\t\t= new_sync_write,\n\t.write_iter\t= fuse_file_write_iter,\n\t.mmap\t\t= fuse_file_mmap,\n\t.open\t\t= fuse_open,\n\t.flush\t\t= fuse_flush,\n\t.release\t= fuse_release,\n\t.fsync\t\t= fuse_fsync,\n\t.lock\t\t= fuse_file_lock,\n\t.flock\t\t= fuse_file_flock,\n\t.splice_read\t= generic_file_splice_read,\n\t.unlocked_ioctl\t= fuse_file_ioctl,\n\t.compat_ioctl\t= fuse_file_compat_ioctl,\n\t.poll\t\t= fuse_file_poll,\n\t.fallocate\t= fuse_file_fallocate,\n};",
            "static const struct address_space_operations fuse_file_aops  = {\n\t.readpage\t= fuse_readpage,\n\t.writepage\t= fuse_writepage,\n\t.writepages\t= fuse_writepages,\n\t.launder_page\t= fuse_launder_page,\n\t.readpages\t= fuse_readpages,\n\t.set_page_dirty\t= __set_page_dirty_nobuffers,\n\t.bmap\t\t= fuse_bmap,\n\t.direct_IO\t= fuse_direct_IO,\n\t.write_begin\t= fuse_write_begin,\n\t.write_end\t= fuse_write_end,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/falloc.h>\n#include <linux/aio.h>\n#include <linux/swap.h>\n#include <linux/compat.h>\n#include <linux/module.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nstatic const struct file_operations fuse_file_operations = {\n\t.llseek\t\t= fuse_file_llseek,\n\t.read\t\t= new_sync_read,\n\t.read_iter\t= fuse_file_read_iter,\n\t.write\t\t= new_sync_write,\n\t.write_iter\t= fuse_file_write_iter,\n\t.mmap\t\t= fuse_file_mmap,\n\t.open\t\t= fuse_open,\n\t.flush\t\t= fuse_flush,\n\t.release\t= fuse_release,\n\t.fsync\t\t= fuse_fsync,\n\t.lock\t\t= fuse_file_lock,\n\t.flock\t\t= fuse_file_flock,\n\t.splice_read\t= generic_file_splice_read,\n\t.unlocked_ioctl\t= fuse_file_ioctl,\n\t.compat_ioctl\t= fuse_file_compat_ioctl,\n\t.poll\t\t= fuse_file_poll,\n\t.fallocate\t= fuse_file_fallocate,\n};\nstatic const struct address_space_operations fuse_file_aops  = {\n\t.readpage\t= fuse_readpage,\n\t.writepage\t= fuse_writepage,\n\t.writepages\t= fuse_writepages,\n\t.launder_page\t= fuse_launder_page,\n\t.readpages\t= fuse_readpages,\n\t.set_page_dirty\t= __set_page_dirty_nobuffers,\n\t.bmap\t\t= fuse_bmap,\n\t.direct_IO\t= fuse_direct_IO,\n\t.write_begin\t= fuse_write_begin,\n\t.write_end\t= fuse_write_end,\n};\n\nvoid fuse_init_file_inode(struct inode *inode)\n{\n\tinode->i_fop = &fuse_file_operations;\n\tinode->i_data.a_ops = &fuse_file_aops;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"cifsfs.h\"\n#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/mount.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n\n#define CIFS_IOC_COPYCHUNK_FILE\t_IOW(CIFS_IOCTL_MAGIC, 3, int)\n\nlong cifs_ioctl(struct file *filep, unsigned int command, unsigned long arg)\n{\n\tstruct inode *inode = file_inode(filep);\n\tint rc = -ENOTTY; /* strange error - but the precedent */\n\tunsigned int xid;\n\tstruct cifs_sb_info *cifs_sb;\n\tstruct cifsFileInfo *pSMBFile = filep->private_data;\n\tstruct cifs_tcon *tcon;\n\t__u64\tExtAttrBits = 0;\n\t__u64   caps;\n\n\txid = get_xid();\n\n\tcifs_dbg(FYI, \"ioctl file %p  cmd %u  arg %lu\\n\", filep, command, arg);\n\n\tcifs_sb = CIFS_SB(inode->i_sb);\n\n\tswitch (command) {\n\t\tcase FS_IOC_GETFLAGS:\n\t\t\tif (pSMBFile == NULL)\n\t\t\t\tbreak;\n\t\t\ttcon = tlink_tcon(pSMBFile->tlink);\n\t\t\tcaps = le64_to_cpu(tcon->fsUnixInfo.Capability);\n#ifdef CONFIG_CIFS_POSIX\n\t\t\tif (CIFS_UNIX_EXTATTR_CAP & caps) {\n\t\t\t\t__u64\tExtAttrMask = 0;\n\t\t\t\trc = CIFSGetExtAttr(xid, tcon,\n\t\t\t\t\t\t    pSMBFile->fid.netfid,\n\t\t\t\t\t\t    &ExtAttrBits, &ExtAttrMask);\n\t\t\t\tif (rc == 0)\n\t\t\t\t\trc = put_user(ExtAttrBits &\n\t\t\t\t\t\tFS_FL_USER_VISIBLE,\n\t\t\t\t\t\t(int __user *)arg);\n\t\t\t\tif (rc != EOPNOTSUPP)\n\t\t\t\t\tbreak;\n\t\t\t}\n#endif /* CONFIG_CIFS_POSIX */\n\t\t\trc = 0;\n\t\t\tif (CIFS_I(inode)->cifsAttrs & ATTR_COMPRESSED) {\n\t\t\t\t/* add in the compressed bit */\n\t\t\t\tExtAttrBits = FS_COMPR_FL;\n\t\t\t\trc = put_user(ExtAttrBits & FS_FL_USER_VISIBLE,\n\t\t\t\t\t      (int __user *)arg);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase FS_IOC_SETFLAGS:\n\t\t\tif (pSMBFile == NULL)\n\t\t\t\tbreak;\n\t\t\ttcon = tlink_tcon(pSMBFile->tlink);\n\t\t\tcaps = le64_to_cpu(tcon->fsUnixInfo.Capability);\n\n\t\t\tif (get_user(ExtAttrBits, (int __user *)arg)) {\n\t\t\t\trc = -EFAULT;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * if (CIFS_UNIX_EXTATTR_CAP & caps)\n\t\t\t *\trc = CIFSSetExtAttr(xid, tcon,\n\t\t\t *\t\t       pSMBFile->fid.netfid,\n\t\t\t *\t\t       extAttrBits,\n\t\t\t *\t\t       &ExtAttrMask);\n\t\t\t * if (rc != EOPNOTSUPP)\n\t\t\t *\tbreak;\n\t\t\t */\n\n\t\t\t/* Currently only flag we can set is compressed flag */\n\t\t\tif ((ExtAttrBits & FS_COMPR_FL) == 0)\n\t\t\t\tbreak;\n\n\t\t\t/* Try to set compress flag */\n\t\t\tif (tcon->ses->server->ops->set_compression) {\n\t\t\t\trc = tcon->ses->server->ops->set_compression(\n\t\t\t\t\t\t\txid, tcon, pSMBFile);\n\t\t\t\tcifs_dbg(FYI, \"set compress flag rc %d\\n\", rc);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase CIFS_IOC_COPYCHUNK_FILE:\n\t\t\trc = cifs_ioctl_clone(xid, filep, arg, 0, 0, 0);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tcifs_dbg(FYI, \"unsupported ioctl\\n\");\n\t\t\tbreak;\n\t}\n\n\tfree_xid(xid);\n\treturn rc;\n}"
  },
  {
    "function_name": "cifs_ioctl_clone",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/ioctl.c",
    "lines": "38-128",
    "snippet": "static long cifs_ioctl_clone(unsigned int xid, struct file *dst_file,\n\t\t\tunsigned long srcfd, u64 off, u64 len, u64 destoff)\n{\n\tint rc;\n\tstruct cifsFileInfo *smb_file_target = dst_file->private_data;\n\tstruct inode *target_inode = file_inode(dst_file);\n\tstruct cifs_tcon *target_tcon;\n\tstruct fd src_file;\n\tstruct cifsFileInfo *smb_file_src;\n\tstruct inode *src_inode;\n\tstruct cifs_tcon *src_tcon;\n\n\tcifs_dbg(FYI, \"ioctl clone range\\n\");\n\t/* the destination must be opened for writing */\n\tif (!(dst_file->f_mode & FMODE_WRITE)) {\n\t\tcifs_dbg(FYI, \"file target not open for write\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\t/* check if target volume is readonly and take reference */\n\trc = mnt_want_write_file(dst_file);\n\tif (rc) {\n\t\tcifs_dbg(FYI, \"mnt_want_write failed with rc %d\\n\", rc);\n\t\treturn rc;\n\t}\n\n\tsrc_file = fdget(srcfd);\n\tif (!src_file.file) {\n\t\trc = -EBADF;\n\t\tgoto out_drop_write;\n\t}\n\n\tif ((!src_file.file->private_data) || (!dst_file->private_data)) {\n\t\trc = -EBADF;\n\t\tcifs_dbg(VFS, \"missing cifsFileInfo on copy range src file\\n\");\n\t\tgoto out_fput;\n\t}\n\n\trc = -EXDEV;\n\tsmb_file_target = dst_file->private_data;\n\tsmb_file_src = src_file.file->private_data;\n\tsrc_tcon = tlink_tcon(smb_file_src->tlink);\n\ttarget_tcon = tlink_tcon(smb_file_target->tlink);\n\n\t/* check if source and target are on same tree connection */\n\tif (src_tcon != target_tcon) {\n\t\tcifs_dbg(VFS, \"file copy src and target on different volume\\n\");\n\t\tgoto out_fput;\n\t}\n\n\tsrc_inode = file_inode(src_file.file);\n\trc = -EINVAL;\n\tif (S_ISDIR(src_inode->i_mode))\n\t\tgoto out_fput;\n\n\t/*\n\t * Note: cifs case is easier than btrfs since server responsible for\n\t * checks for proper open modes and file type and if it wants\n\t * server could even support copy of range where source = target\n\t */\n\tlock_two_nondirectories(target_inode, src_inode);\n\n\t/* determine range to clone */\n\trc = -EINVAL;\n\tif (off + len > src_inode->i_size || off + len < off)\n\t\tgoto out_unlock;\n\tif (len == 0)\n\t\tlen = src_inode->i_size - off;\n\n\tcifs_dbg(FYI, \"about to flush pages\\n\");\n\t/* should we flush first and last page first */\n\ttruncate_inode_pages_range(&target_inode->i_data, destoff,\n\t\t\t\t   PAGE_CACHE_ALIGN(destoff + len)-1);\n\n\tif (target_tcon->ses->server->ops->clone_range)\n\t\trc = target_tcon->ses->server->ops->clone_range(xid,\n\t\t\tsmb_file_src, smb_file_target, off, len, destoff);\n\n\t/* force revalidate of size and timestamps of target file now\n\t   that target is updated on the server */\n\tCIFS_I(target_inode)->time = 0;\nout_unlock:\n\t/* although unlocking in the reverse order from locking is not\n\t   strictly necessary here it is a little cleaner to be consistent */\n\tunlock_two_nondirectories(src_inode, target_inode);\nout_fput:\n\tfdput(src_file);\nout_drop_write:\n\tmnt_drop_write_file(dst_file);\n\treturn rc;\n}",
    "includes": [
      "#include \"cifsfs.h\"",
      "#include \"cifs_debug.h\"",
      "#include \"cifsproto.h\"",
      "#include \"cifsglob.h\"",
      "#include \"cifspdu.h\"",
      "#include <linux/pagemap.h>",
      "#include <linux/mm.h>",
      "#include <linux/mount.h>",
      "#include <linux/file.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mnt_drop_write_file",
          "args": [
            "dst_file"
          ],
          "line": 126
        },
        "resolved": true,
        "details": {
          "function_name": "mnt_drop_write_file",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namespace.c",
          "lines": "487-490",
          "snippet": "void mnt_drop_write_file(struct file *file)\n{\n\tmnt_drop_write(file->f_path.mnt);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include \"pnode.h\"",
            "#include <linux/task_work.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/magic.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */",
            "#include <linux/fs_struct.h>\t/* get_fs_root et.al. */",
            "#include <linux/init.h>\t\t/* init_rootfs */",
            "#include <linux/idr.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/mnt_namespace.h>",
            "#include <linux/capability.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void shrink_submounts(struct mount *mnt);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include \"pnode.h\"\n#include <linux/task_work.h>\n#include <linux/bootmem.h>\n#include <linux/magic.h>\n#include <linux/proc_ns.h>\n#include <linux/uaccess.h>\n#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */\n#include <linux/fs_struct.h>\t/* get_fs_root et.al. */\n#include <linux/init.h>\t\t/* init_rootfs */\n#include <linux/idr.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/user_namespace.h>\n#include <linux/mnt_namespace.h>\n#include <linux/capability.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstatic void shrink_submounts(struct mount *mnt);\n\nvoid mnt_drop_write_file(struct file *file)\n{\n\tmnt_drop_write(file->f_path.mnt);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fdput",
          "args": [
            "src_file"
          ],
          "line": 124
        },
        "resolved": true,
        "details": {
          "function_name": "fdput_pos",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/read_write.c",
          "lines": "273-278",
          "snippet": "static inline void fdput_pos(struct fd f)\n{\n\tif (f.flags & FDPUT_POS_UNLOCK)\n\t\tmutex_unlock(&f.file->f_pos_lock);\n\tfdput(f);\n}",
          "includes": [
            "#include <asm/unistd.h>",
            "#include <asm/uaccess.h>",
            "#include \"internal.h\"",
            "#include <linux/compat.h>",
            "#include <linux/splice.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/export.h>",
            "#include <linux/security.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/aio.h>",
            "#include <linux/uio.h>",
            "#include <linux/file.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/stat.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/unistd.h>\n#include <asm/uaccess.h>\n#include \"internal.h\"\n#include <linux/compat.h>\n#include <linux/splice.h>\n#include <linux/pagemap.h>\n#include <linux/syscalls.h>\n#include <linux/export.h>\n#include <linux/security.h>\n#include <linux/fsnotify.h>\n#include <linux/aio.h>\n#include <linux/uio.h>\n#include <linux/file.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/slab.h>\n\nstatic inline void fdput_pos(struct fd f)\n{\n\tif (f.flags & FDPUT_POS_UNLOCK)\n\t\tmutex_unlock(&f.file->f_pos_lock);\n\tfdput(f);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlock_two_nondirectories",
          "args": [
            "src_inode",
            "target_inode"
          ],
          "line": 122
        },
        "resolved": true,
        "details": {
          "function_name": "unlock_two_nondirectories",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "962-968",
          "snippet": "void unlock_two_nondirectories(struct inode *inode1, struct inode *inode2)\n{\n\tif (inode1 && !S_ISDIR(inode1->i_mode))\n\t\tmutex_unlock(&inode1->i_mutex);\n\tif (inode2 && !S_ISDIR(inode2->i_mode) && inode2 != inode1)\n\t\tmutex_unlock(&inode2->i_mutex);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid unlock_two_nondirectories(struct inode *inode1, struct inode *inode2)\n{\n\tif (inode1 && !S_ISDIR(inode1->i_mode))\n\t\tmutex_unlock(&inode1->i_mutex);\n\tif (inode2 && !S_ISDIR(inode2->i_mode) && inode2 != inode1)\n\t\tmutex_unlock(&inode2->i_mutex);\n}"
        }
      },
      {
        "call_info": {
          "callee": "CIFS_I",
          "args": [
            "target_inode"
          ],
          "line": 118
        },
        "resolved": true,
        "details": {
          "function_name": "CIFS_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifsglob.h",
          "lines": "1159-1163",
          "snippet": "static inline struct cifsInodeInfo *\nCIFS_I(struct inode *inode)\n{\n\treturn container_of(inode, struct cifsInodeInfo, vfs_inode);\n}",
          "includes": [
            "#include \"cifspdu.h\"",
            "#include \"smb2pdu.h\"",
            "#include <uapi/linux/cifs/cifs_mount.h>",
            "#include <linux/scatterlist.h>",
            "#include <crypto/internal/hash.h>",
            "#include \"cifsacl.h\"",
            "#include \"cifs_fs_sb.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/mempool.h>",
            "#include <linux/slab.h>",
            "#include <linux/in6.h>",
            "#include <linux/in.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifspdu.h\"\n#include \"smb2pdu.h\"\n#include <uapi/linux/cifs/cifs_mount.h>\n#include <linux/scatterlist.h>\n#include <crypto/internal/hash.h>\n#include \"cifsacl.h\"\n#include \"cifs_fs_sb.h\"\n#include <linux/workqueue.h>\n#include <linux/mempool.h>\n#include <linux/slab.h>\n#include <linux/in6.h>\n#include <linux/in.h>\n\nstatic inline struct cifsInodeInfo *\nCIFS_I(struct inode *inode)\n{\n\treturn container_of(inode, struct cifsInodeInfo, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "target_tcon->ses->server->ops->clone_range",
          "args": [
            "xid",
            "smb_file_src",
            "smb_file_target",
            "off",
            "len",
            "destoff"
          ],
          "line": 113
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "truncate_inode_pages_range",
          "args": [
            "&target_inode->i_data",
            "destoff",
            "PAGE_CACHE_ALIGN(destoff + len)-1"
          ],
          "line": 109
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PAGE_CACHE_ALIGN",
          "args": [
            "destoff + len"
          ],
          "line": 110
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "FYI",
            "\"about to flush pages\\n\""
          ],
          "line": 107
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISDIR",
          "args": [
            "src_inode->i_mode"
          ],
          "line": 90
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "file_inode",
          "args": [
            "src_file.file"
          ],
          "line": 88
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_init_file_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/file.c",
          "lines": "3009-3013",
          "snippet": "void fuse_init_file_inode(struct inode *inode)\n{\n\tinode->i_fop = &fuse_file_operations;\n\tinode->i_data.a_ops = &fuse_file_aops;\n}",
          "includes": [
            "#include <linux/falloc.h>",
            "#include <linux/aio.h>",
            "#include <linux/swap.h>",
            "#include <linux/compat.h>",
            "#include <linux/module.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct file_operations fuse_file_operations = {\n\t.llseek\t\t= fuse_file_llseek,\n\t.read\t\t= new_sync_read,\n\t.read_iter\t= fuse_file_read_iter,\n\t.write\t\t= new_sync_write,\n\t.write_iter\t= fuse_file_write_iter,\n\t.mmap\t\t= fuse_file_mmap,\n\t.open\t\t= fuse_open,\n\t.flush\t\t= fuse_flush,\n\t.release\t= fuse_release,\n\t.fsync\t\t= fuse_fsync,\n\t.lock\t\t= fuse_file_lock,\n\t.flock\t\t= fuse_file_flock,\n\t.splice_read\t= generic_file_splice_read,\n\t.unlocked_ioctl\t= fuse_file_ioctl,\n\t.compat_ioctl\t= fuse_file_compat_ioctl,\n\t.poll\t\t= fuse_file_poll,\n\t.fallocate\t= fuse_file_fallocate,\n};",
            "static const struct address_space_operations fuse_file_aops  = {\n\t.readpage\t= fuse_readpage,\n\t.writepage\t= fuse_writepage,\n\t.writepages\t= fuse_writepages,\n\t.launder_page\t= fuse_launder_page,\n\t.readpages\t= fuse_readpages,\n\t.set_page_dirty\t= __set_page_dirty_nobuffers,\n\t.bmap\t\t= fuse_bmap,\n\t.direct_IO\t= fuse_direct_IO,\n\t.write_begin\t= fuse_write_begin,\n\t.write_end\t= fuse_write_end,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/falloc.h>\n#include <linux/aio.h>\n#include <linux/swap.h>\n#include <linux/compat.h>\n#include <linux/module.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nstatic const struct file_operations fuse_file_operations = {\n\t.llseek\t\t= fuse_file_llseek,\n\t.read\t\t= new_sync_read,\n\t.read_iter\t= fuse_file_read_iter,\n\t.write\t\t= new_sync_write,\n\t.write_iter\t= fuse_file_write_iter,\n\t.mmap\t\t= fuse_file_mmap,\n\t.open\t\t= fuse_open,\n\t.flush\t\t= fuse_flush,\n\t.release\t= fuse_release,\n\t.fsync\t\t= fuse_fsync,\n\t.lock\t\t= fuse_file_lock,\n\t.flock\t\t= fuse_file_flock,\n\t.splice_read\t= generic_file_splice_read,\n\t.unlocked_ioctl\t= fuse_file_ioctl,\n\t.compat_ioctl\t= fuse_file_compat_ioctl,\n\t.poll\t\t= fuse_file_poll,\n\t.fallocate\t= fuse_file_fallocate,\n};\nstatic const struct address_space_operations fuse_file_aops  = {\n\t.readpage\t= fuse_readpage,\n\t.writepage\t= fuse_writepage,\n\t.writepages\t= fuse_writepages,\n\t.launder_page\t= fuse_launder_page,\n\t.readpages\t= fuse_readpages,\n\t.set_page_dirty\t= __set_page_dirty_nobuffers,\n\t.bmap\t\t= fuse_bmap,\n\t.direct_IO\t= fuse_direct_IO,\n\t.write_begin\t= fuse_write_begin,\n\t.write_end\t= fuse_write_end,\n};\n\nvoid fuse_init_file_inode(struct inode *inode)\n{\n\tinode->i_fop = &fuse_file_operations;\n\tinode->i_data.a_ops = &fuse_file_aops;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "VFS",
            "\"file copy src and target on different volume\\n\""
          ],
          "line": 84
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tlink_tcon",
          "args": [
            "smb_file_target->tlink"
          ],
          "line": 80
        },
        "resolved": true,
        "details": {
          "function_name": "tlink_tcon",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifsglob.h",
          "lines": "931-935",
          "snippet": "static inline struct cifs_tcon *\ntlink_tcon(struct tcon_link *tlink)\n{\n\treturn tlink->tl_tcon;\n}",
          "includes": [
            "#include \"cifspdu.h\"",
            "#include \"smb2pdu.h\"",
            "#include <uapi/linux/cifs/cifs_mount.h>",
            "#include <linux/scatterlist.h>",
            "#include <crypto/internal/hash.h>",
            "#include \"cifsacl.h\"",
            "#include \"cifs_fs_sb.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/mempool.h>",
            "#include <linux/slab.h>",
            "#include <linux/in6.h>",
            "#include <linux/in.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifspdu.h\"\n#include \"smb2pdu.h\"\n#include <uapi/linux/cifs/cifs_mount.h>\n#include <linux/scatterlist.h>\n#include <crypto/internal/hash.h>\n#include \"cifsacl.h\"\n#include \"cifs_fs_sb.h\"\n#include <linux/workqueue.h>\n#include <linux/mempool.h>\n#include <linux/slab.h>\n#include <linux/in6.h>\n#include <linux/in.h>\n\nstatic inline struct cifs_tcon *\ntlink_tcon(struct tcon_link *tlink)\n{\n\treturn tlink->tl_tcon;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "VFS",
            "\"missing cifsFileInfo on copy range src file\\n\""
          ],
          "line": 72
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fdget",
          "args": [
            "srcfd"
          ],
          "line": 64
        },
        "resolved": true,
        "details": {
          "function_name": "__fdget_pos",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/file.c",
          "lines": "706-718",
          "snippet": "unsigned long __fdget_pos(unsigned int fd)\n{\n\tunsigned long v = __fdget(fd);\n\tstruct file *file = (struct file *)(v & ~3);\n\n\tif (file && (file->f_mode & FMODE_ATOMIC_POS)) {\n\t\tif (file_count(file) > 1) {\n\t\t\tv |= FDPUT_POS_UNLOCK;\n\t\t\tmutex_lock(&file->f_pos_lock);\n\t\t}\n\t}\n\treturn v;\n}",
          "includes": [
            "#include <linux/workqueue.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/bitops.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/time.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/workqueue.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/interrupt.h>\n#include <linux/bitops.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/time.h>\n#include <linux/mmzone.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nunsigned long __fdget_pos(unsigned int fd)\n{\n\tunsigned long v = __fdget(fd);\n\tstruct file *file = (struct file *)(v & ~3);\n\n\tif (file && (file->f_mode & FMODE_ATOMIC_POS)) {\n\t\tif (file_count(file) > 1) {\n\t\t\tv |= FDPUT_POS_UNLOCK;\n\t\t\tmutex_lock(&file->f_pos_lock);\n\t\t}\n\t}\n\treturn v;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "FYI",
            "\"mnt_want_write failed with rc %d\\n\"",
            "rc"
          ],
          "line": 60
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mnt_want_write_file",
          "args": [
            "dst_file"
          ],
          "line": 58
        },
        "resolved": true,
        "details": {
          "function_name": "mnt_want_write_file",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namespace.c",
          "lines": "440-449",
          "snippet": "int mnt_want_write_file(struct file *file)\n{\n\tint ret;\n\n\tsb_start_write(file->f_path.mnt->mnt_sb);\n\tret = __mnt_want_write_file(file);\n\tif (ret)\n\t\tsb_end_write(file->f_path.mnt->mnt_sb);\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include \"pnode.h\"",
            "#include <linux/task_work.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/magic.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */",
            "#include <linux/fs_struct.h>\t/* get_fs_root et.al. */",
            "#include <linux/init.h>\t\t/* init_rootfs */",
            "#include <linux/idr.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/mnt_namespace.h>",
            "#include <linux/capability.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void shrink_submounts(struct mount *mnt);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include \"pnode.h\"\n#include <linux/task_work.h>\n#include <linux/bootmem.h>\n#include <linux/magic.h>\n#include <linux/proc_ns.h>\n#include <linux/uaccess.h>\n#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */\n#include <linux/fs_struct.h>\t/* get_fs_root et.al. */\n#include <linux/init.h>\t\t/* init_rootfs */\n#include <linux/idr.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/user_namespace.h>\n#include <linux/mnt_namespace.h>\n#include <linux/capability.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstatic void shrink_submounts(struct mount *mnt);\n\nint mnt_want_write_file(struct file *file)\n{\n\tint ret;\n\n\tsb_start_write(file->f_path.mnt->mnt_sb);\n\tret = __mnt_want_write_file(file);\n\tif (ret)\n\t\tsb_end_write(file->f_path.mnt->mnt_sb);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "FYI",
            "\"file target not open for write\\n\""
          ],
          "line": 53
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "FYI",
            "\"ioctl clone range\\n\""
          ],
          "line": 50
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"cifsfs.h\"\n#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/mount.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n\nstatic long cifs_ioctl_clone(unsigned int xid, struct file *dst_file,\n\t\t\tunsigned long srcfd, u64 off, u64 len, u64 destoff)\n{\n\tint rc;\n\tstruct cifsFileInfo *smb_file_target = dst_file->private_data;\n\tstruct inode *target_inode = file_inode(dst_file);\n\tstruct cifs_tcon *target_tcon;\n\tstruct fd src_file;\n\tstruct cifsFileInfo *smb_file_src;\n\tstruct inode *src_inode;\n\tstruct cifs_tcon *src_tcon;\n\n\tcifs_dbg(FYI, \"ioctl clone range\\n\");\n\t/* the destination must be opened for writing */\n\tif (!(dst_file->f_mode & FMODE_WRITE)) {\n\t\tcifs_dbg(FYI, \"file target not open for write\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\t/* check if target volume is readonly and take reference */\n\trc = mnt_want_write_file(dst_file);\n\tif (rc) {\n\t\tcifs_dbg(FYI, \"mnt_want_write failed with rc %d\\n\", rc);\n\t\treturn rc;\n\t}\n\n\tsrc_file = fdget(srcfd);\n\tif (!src_file.file) {\n\t\trc = -EBADF;\n\t\tgoto out_drop_write;\n\t}\n\n\tif ((!src_file.file->private_data) || (!dst_file->private_data)) {\n\t\trc = -EBADF;\n\t\tcifs_dbg(VFS, \"missing cifsFileInfo on copy range src file\\n\");\n\t\tgoto out_fput;\n\t}\n\n\trc = -EXDEV;\n\tsmb_file_target = dst_file->private_data;\n\tsmb_file_src = src_file.file->private_data;\n\tsrc_tcon = tlink_tcon(smb_file_src->tlink);\n\ttarget_tcon = tlink_tcon(smb_file_target->tlink);\n\n\t/* check if source and target are on same tree connection */\n\tif (src_tcon != target_tcon) {\n\t\tcifs_dbg(VFS, \"file copy src and target on different volume\\n\");\n\t\tgoto out_fput;\n\t}\n\n\tsrc_inode = file_inode(src_file.file);\n\trc = -EINVAL;\n\tif (S_ISDIR(src_inode->i_mode))\n\t\tgoto out_fput;\n\n\t/*\n\t * Note: cifs case is easier than btrfs since server responsible for\n\t * checks for proper open modes and file type and if it wants\n\t * server could even support copy of range where source = target\n\t */\n\tlock_two_nondirectories(target_inode, src_inode);\n\n\t/* determine range to clone */\n\trc = -EINVAL;\n\tif (off + len > src_inode->i_size || off + len < off)\n\t\tgoto out_unlock;\n\tif (len == 0)\n\t\tlen = src_inode->i_size - off;\n\n\tcifs_dbg(FYI, \"about to flush pages\\n\");\n\t/* should we flush first and last page first */\n\ttruncate_inode_pages_range(&target_inode->i_data, destoff,\n\t\t\t\t   PAGE_CACHE_ALIGN(destoff + len)-1);\n\n\tif (target_tcon->ses->server->ops->clone_range)\n\t\trc = target_tcon->ses->server->ops->clone_range(xid,\n\t\t\tsmb_file_src, smb_file_target, off, len, destoff);\n\n\t/* force revalidate of size and timestamps of target file now\n\t   that target is updated on the server */\n\tCIFS_I(target_inode)->time = 0;\nout_unlock:\n\t/* although unlocking in the reverse order from locking is not\n\t   strictly necessary here it is a little cleaner to be consistent */\n\tunlock_two_nondirectories(src_inode, target_inode);\nout_fput:\n\tfdput(src_file);\nout_drop_write:\n\tmnt_drop_write_file(dst_file);\n\treturn rc;\n}"
  }
]