[
  {
    "function_name": "ocfs2_wake_downconvert_thread",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlmglue.c",
    "lines": "4091-4101",
    "snippet": "void ocfs2_wake_downconvert_thread(struct ocfs2_super *osb)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&osb->dc_task_lock, flags);\n\t/* make sure the voting thread gets a swipe at whatever changes\n\t * the caller may have made to the voting state */\n\tosb->dc_wake_sequence++;\n\tspin_unlock_irqrestore(&osb->dc_task_lock, flags);\n\twake_up(&osb->dc_event);\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"refcounttree.h\"",
      "#include \"quota.h\"",
      "#include \"uptodate.h\"",
      "#include \"super.h\"",
      "#include \"slot_map.h\"",
      "#include \"stackglue.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"heartbeat.h\"",
      "#include \"file.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"dcache.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2_lockingver.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/time.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/kthread.h>",
      "#include <linux/mm.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void ocfs2_drop_osb_locks(struct ocfs2_super *osb);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "wake_up",
          "args": [
            "&osb->dc_event"
          ],
          "line": 4100
        },
        "resolved": true,
        "details": {
          "function_name": "locks_wake_up_blocks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/locks.c",
          "lines": "656-681",
          "snippet": "static void locks_wake_up_blocks(struct file_lock *blocker)\n{\n\t/*\n\t * Avoid taking global lock if list is empty. This is safe since new\n\t * blocked requests are only added to the list under the flc_lock, and\n\t * the flc_lock is always held here. Note that removal from the fl_block\n\t * list does not require the flc_lock, so we must recheck list_empty()\n\t * after acquiring the blocked_lock_lock.\n\t */\n\tif (list_empty(&blocker->fl_block))\n\t\treturn;\n\n\tspin_lock(&blocked_lock_lock);\n\twhile (!list_empty(&blocker->fl_block)) {\n\t\tstruct file_lock *waiter;\n\n\t\twaiter = list_first_entry(&blocker->fl_block,\n\t\t\t\tstruct file_lock, fl_block);\n\t\t__locks_delete_block(waiter);\n\t\tif (waiter->fl_lmops && waiter->fl_lmops->lm_notify)\n\t\t\twaiter->fl_lmops->lm_notify(waiter);\n\t\telse\n\t\t\twake_up(&waiter->fl_wait);\n\t}\n\tspin_unlock(&blocked_lock_lock);\n}",
          "includes": [
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <asm/uaccess.h>",
            "#include <trace/events/filelock.h>",
            "#include <linux/lglock.h>",
            "#include <linux/percpu.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/time.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/slab.h>",
            "#include <linux/security.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_SPINLOCK(blocked_lock_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <asm/uaccess.h>\n#include <trace/events/filelock.h>\n#include <linux/lglock.h>\n#include <linux/percpu.h>\n#include <linux/hashtable.h>\n#include <linux/pid_namespace.h>\n#include <linux/rcupdate.h>\n#include <linux/time.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n\nstatic DEFINE_SPINLOCK(blocked_lock_lock);\n\nstatic void locks_wake_up_blocks(struct file_lock *blocker)\n{\n\t/*\n\t * Avoid taking global lock if list is empty. This is safe since new\n\t * blocked requests are only added to the list under the flc_lock, and\n\t * the flc_lock is always held here. Note that removal from the fl_block\n\t * list does not require the flc_lock, so we must recheck list_empty()\n\t * after acquiring the blocked_lock_lock.\n\t */\n\tif (list_empty(&blocker->fl_block))\n\t\treturn;\n\n\tspin_lock(&blocked_lock_lock);\n\twhile (!list_empty(&blocker->fl_block)) {\n\t\tstruct file_lock *waiter;\n\n\t\twaiter = list_first_entry(&blocker->fl_block,\n\t\t\t\tstruct file_lock, fl_block);\n\t\t__locks_delete_block(waiter);\n\t\tif (waiter->fl_lmops && waiter->fl_lmops->lm_notify)\n\t\t\twaiter->fl_lmops->lm_notify(waiter);\n\t\telse\n\t\t\twake_up(&waiter->fl_wait);\n\t}\n\tspin_unlock(&blocked_lock_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock_irqrestore",
          "args": [
            "&osb->dc_task_lock",
            "flags"
          ],
          "line": 4099
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock_irqsave",
          "args": [
            "&osb->dc_task_lock",
            "flags"
          ],
          "line": 4095
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"stackglue.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dcache.h\"\n#include \"alloc.h\"\n#include \"ocfs2_lockingver.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/quotaops.h>\n#include <linux/time.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/pagemap.h>\n#include <linux/kthread.h>\n#include <linux/mm.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic void ocfs2_drop_osb_locks(struct ocfs2_super *osb);\n\nvoid ocfs2_wake_downconvert_thread(struct ocfs2_super *osb)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&osb->dc_task_lock, flags);\n\t/* make sure the voting thread gets a swipe at whatever changes\n\t * the caller may have made to the voting state */\n\tosb->dc_wake_sequence++;\n\tspin_unlock_irqrestore(&osb->dc_task_lock, flags);\n\twake_up(&osb->dc_event);\n}"
  },
  {
    "function_name": "ocfs2_downconvert_thread",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlmglue.c",
    "lines": "4068-4089",
    "snippet": "static int ocfs2_downconvert_thread(void *arg)\n{\n\tint status = 0;\n\tstruct ocfs2_super *osb = arg;\n\n\t/* only quit once we've been asked to stop and there is no more\n\t * work available */\n\twhile (!(kthread_should_stop() &&\n\t\tocfs2_downconvert_thread_lists_empty(osb))) {\n\n\t\twait_event_interruptible(osb->dc_event,\n\t\t\t\t\t ocfs2_downconvert_thread_should_wake(osb) ||\n\t\t\t\t\t kthread_should_stop());\n\n\t\tmlog(0, \"downconvert_thread: awoken\\n\");\n\n\t\tocfs2_downconvert_thread_do_work(osb);\n\t}\n\n\tosb->dc_task = NULL;\n\treturn status;\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"refcounttree.h\"",
      "#include \"quota.h\"",
      "#include \"uptodate.h\"",
      "#include \"super.h\"",
      "#include \"slot_map.h\"",
      "#include \"stackglue.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"heartbeat.h\"",
      "#include \"file.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"dcache.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2_lockingver.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/time.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/kthread.h>",
      "#include <linux/mm.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ocfs2_downconvert_thread(void *arg);",
      "static void ocfs2_drop_osb_locks(struct ocfs2_super *osb);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ocfs2_downconvert_thread_do_work",
          "args": [
            "osb"
          ],
          "line": 4084
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_downconvert_thread_do_work",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlmglue.c",
          "lines": "4011-4040",
          "snippet": "static void ocfs2_downconvert_thread_do_work(struct ocfs2_super *osb)\n{\n\tunsigned long processed;\n\tunsigned long flags;\n\tstruct ocfs2_lock_res *lockres;\n\n\tspin_lock_irqsave(&osb->dc_task_lock, flags);\n\t/* grab this early so we know to try again if a state change and\n\t * wake happens part-way through our work  */\n\tosb->dc_work_sequence = osb->dc_wake_sequence;\n\n\tprocessed = osb->blocked_lock_count;\n\twhile (processed) {\n\t\tBUG_ON(list_empty(&osb->blocked_lock_list));\n\n\t\tlockres = list_entry(osb->blocked_lock_list.next,\n\t\t\t\t     struct ocfs2_lock_res, l_blocked_list);\n\t\tlist_del_init(&lockres->l_blocked_list);\n\t\tosb->blocked_lock_count--;\n\t\tspin_unlock_irqrestore(&osb->dc_task_lock, flags);\n\n\t\tBUG_ON(!processed);\n\t\tprocessed--;\n\n\t\tocfs2_process_blocked_lock(osb, lockres);\n\n\t\tspin_lock_irqsave(&osb->dc_task_lock, flags);\n\t}\n\tspin_unlock_irqrestore(&osb->dc_task_lock, flags);\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"refcounttree.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"stackglue.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dcache.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2_lockingver.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/time.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/kthread.h>",
            "#include <linux/mm.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct ocfs2_super *ocfs2_get_dentry_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_inode_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_file_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_qinfo_osb(struct ocfs2_lock_res *lockres);",
            "static void ocfs2_set_meta_lvb(struct ocfs2_lock_res *lockres);",
            "static void ocfs2_dentry_post_unlock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres);",
            "static void ocfs2_set_qinfo_lvb(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_downconvert_action(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_convert_action(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_attach_action(struct ocfs2_lock_res *lockres);",
            "static void ocfs2_schedule_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static void ocfs2_downconvert_on_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static void ocfs2_drop_osb_locks(struct ocfs2_super *osb);",
            "static int ocfs2_prepare_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\t        struct ocfs2_lock_res *lockres);",
            "static int ocfs2_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static void ocfs2_process_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *lockres);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"stackglue.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dcache.h\"\n#include \"alloc.h\"\n#include \"ocfs2_lockingver.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/quotaops.h>\n#include <linux/time.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/pagemap.h>\n#include <linux/kthread.h>\n#include <linux/mm.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic struct ocfs2_super *ocfs2_get_dentry_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_inode_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_file_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_qinfo_osb(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_set_meta_lvb(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_dentry_post_unlock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres);\nstatic void ocfs2_set_qinfo_lvb(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_downconvert_action(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_convert_action(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_attach_action(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_schedule_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_downconvert_on_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_drop_osb_locks(struct ocfs2_super *osb);\nstatic int ocfs2_prepare_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\t        struct ocfs2_lock_res *lockres);\nstatic int ocfs2_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_process_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *lockres);\n\nstatic void ocfs2_downconvert_thread_do_work(struct ocfs2_super *osb)\n{\n\tunsigned long processed;\n\tunsigned long flags;\n\tstruct ocfs2_lock_res *lockres;\n\n\tspin_lock_irqsave(&osb->dc_task_lock, flags);\n\t/* grab this early so we know to try again if a state change and\n\t * wake happens part-way through our work  */\n\tosb->dc_work_sequence = osb->dc_wake_sequence;\n\n\tprocessed = osb->blocked_lock_count;\n\twhile (processed) {\n\t\tBUG_ON(list_empty(&osb->blocked_lock_list));\n\n\t\tlockres = list_entry(osb->blocked_lock_list.next,\n\t\t\t\t     struct ocfs2_lock_res, l_blocked_list);\n\t\tlist_del_init(&lockres->l_blocked_list);\n\t\tosb->blocked_lock_count--;\n\t\tspin_unlock_irqrestore(&osb->dc_task_lock, flags);\n\n\t\tBUG_ON(!processed);\n\t\tprocessed--;\n\n\t\tocfs2_process_blocked_lock(osb, lockres);\n\n\t\tspin_lock_irqsave(&osb->dc_task_lock, flags);\n\t}\n\tspin_unlock_irqrestore(&osb->dc_task_lock, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog",
          "args": [
            "0",
            "\"downconvert_thread: awoken\\n\""
          ],
          "line": 4082
        },
        "resolved": true,
        "details": {
          "function_name": "mlog_mask_show",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/cluster/masklog.c",
          "lines": "36-48",
          "snippet": "static ssize_t mlog_mask_show(u64 mask, char *buf)\n{\n\tchar *state;\n\n\tif (__mlog_test_u64(mask, mlog_and_bits))\n\t\tstate = \"allow\";\n\telse if (__mlog_test_u64(mask, mlog_not_bits))\n\t\tstate = \"deny\";\n\telse\n\t\tstate = \"off\";\n\n\treturn snprintf(buf, PAGE_SIZE, \"%s\\n\", state);\n}",
          "includes": [
            "#include \"masklog.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/string.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct mlog_bits mlog_and_bits = MLOG_BITS_RHS(MLOG_INITIAL_AND_MASK);",
            "struct mlog_bits mlog_not_bits = MLOG_BITS_RHS(0);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"masklog.h\"\n#include <asm/uaccess.h>\n#include <linux/string.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n\nstruct mlog_bits mlog_and_bits = MLOG_BITS_RHS(MLOG_INITIAL_AND_MASK);\nstruct mlog_bits mlog_not_bits = MLOG_BITS_RHS(0);\n\nstatic ssize_t mlog_mask_show(u64 mask, char *buf)\n{\n\tchar *state;\n\n\tif (__mlog_test_u64(mask, mlog_and_bits))\n\t\tstate = \"allow\";\n\telse if (__mlog_test_u64(mask, mlog_not_bits))\n\t\tstate = \"deny\";\n\telse\n\t\tstate = \"off\";\n\n\treturn snprintf(buf, PAGE_SIZE, \"%s\\n\", state);\n}"
        }
      },
      {
        "call_info": {
          "callee": "wait_event_interruptible",
          "args": [
            "osb->dc_event",
            "ocfs2_downconvert_thread_should_wake(osb) ||\n\t\t\t\t\t kthread_should_stop()"
          ],
          "line": 4078
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kthread_should_stop",
          "args": [],
          "line": 4080
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_downconvert_thread_should_wake",
          "args": [
            "osb"
          ],
          "line": 4079
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_downconvert_thread_should_wake",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlmglue.c",
          "lines": "4055-4066",
          "snippet": "static int ocfs2_downconvert_thread_should_wake(struct ocfs2_super *osb)\n{\n\tint should_wake = 0;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&osb->dc_task_lock, flags);\n\tif (osb->dc_work_sequence != osb->dc_wake_sequence)\n\t\tshould_wake = 1;\n\tspin_unlock_irqrestore(&osb->dc_task_lock, flags);\n\n\treturn should_wake;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"refcounttree.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"stackglue.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dcache.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2_lockingver.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/time.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/kthread.h>",
            "#include <linux/mm.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void ocfs2_drop_osb_locks(struct ocfs2_super *osb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"stackglue.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dcache.h\"\n#include \"alloc.h\"\n#include \"ocfs2_lockingver.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/quotaops.h>\n#include <linux/time.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/pagemap.h>\n#include <linux/kthread.h>\n#include <linux/mm.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic void ocfs2_drop_osb_locks(struct ocfs2_super *osb);\n\nstatic int ocfs2_downconvert_thread_should_wake(struct ocfs2_super *osb)\n{\n\tint should_wake = 0;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&osb->dc_task_lock, flags);\n\tif (osb->dc_work_sequence != osb->dc_wake_sequence)\n\t\tshould_wake = 1;\n\tspin_unlock_irqrestore(&osb->dc_task_lock, flags);\n\n\treturn should_wake;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_downconvert_thread_lists_empty",
          "args": [
            "osb"
          ],
          "line": 4076
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_downconvert_thread_lists_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlmglue.c",
          "lines": "4042-4053",
          "snippet": "static int ocfs2_downconvert_thread_lists_empty(struct ocfs2_super *osb)\n{\n\tint empty = 0;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&osb->dc_task_lock, flags);\n\tif (list_empty(&osb->blocked_lock_list))\n\t\tempty = 1;\n\n\tspin_unlock_irqrestore(&osb->dc_task_lock, flags);\n\treturn empty;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"refcounttree.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"stackglue.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dcache.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2_lockingver.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/time.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/kthread.h>",
            "#include <linux/mm.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void ocfs2_drop_osb_locks(struct ocfs2_super *osb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"stackglue.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dcache.h\"\n#include \"alloc.h\"\n#include \"ocfs2_lockingver.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/quotaops.h>\n#include <linux/time.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/pagemap.h>\n#include <linux/kthread.h>\n#include <linux/mm.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic void ocfs2_drop_osb_locks(struct ocfs2_super *osb);\n\nstatic int ocfs2_downconvert_thread_lists_empty(struct ocfs2_super *osb)\n{\n\tint empty = 0;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&osb->dc_task_lock, flags);\n\tif (list_empty(&osb->blocked_lock_list))\n\t\tempty = 1;\n\n\tspin_unlock_irqrestore(&osb->dc_task_lock, flags);\n\treturn empty;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kthread_should_stop",
          "args": [],
          "line": 4075
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"stackglue.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dcache.h\"\n#include \"alloc.h\"\n#include \"ocfs2_lockingver.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/quotaops.h>\n#include <linux/time.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/pagemap.h>\n#include <linux/kthread.h>\n#include <linux/mm.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic int ocfs2_downconvert_thread(void *arg);\nstatic void ocfs2_drop_osb_locks(struct ocfs2_super *osb);\n\nstatic int ocfs2_downconvert_thread(void *arg)\n{\n\tint status = 0;\n\tstruct ocfs2_super *osb = arg;\n\n\t/* only quit once we've been asked to stop and there is no more\n\t * work available */\n\twhile (!(kthread_should_stop() &&\n\t\tocfs2_downconvert_thread_lists_empty(osb))) {\n\n\t\twait_event_interruptible(osb->dc_event,\n\t\t\t\t\t ocfs2_downconvert_thread_should_wake(osb) ||\n\t\t\t\t\t kthread_should_stop());\n\n\t\tmlog(0, \"downconvert_thread: awoken\\n\");\n\n\t\tocfs2_downconvert_thread_do_work(osb);\n\t}\n\n\tosb->dc_task = NULL;\n\treturn status;\n}"
  },
  {
    "function_name": "ocfs2_downconvert_thread_should_wake",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlmglue.c",
    "lines": "4055-4066",
    "snippet": "static int ocfs2_downconvert_thread_should_wake(struct ocfs2_super *osb)\n{\n\tint should_wake = 0;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&osb->dc_task_lock, flags);\n\tif (osb->dc_work_sequence != osb->dc_wake_sequence)\n\t\tshould_wake = 1;\n\tspin_unlock_irqrestore(&osb->dc_task_lock, flags);\n\n\treturn should_wake;\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"refcounttree.h\"",
      "#include \"quota.h\"",
      "#include \"uptodate.h\"",
      "#include \"super.h\"",
      "#include \"slot_map.h\"",
      "#include \"stackglue.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"heartbeat.h\"",
      "#include \"file.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"dcache.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2_lockingver.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/time.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/kthread.h>",
      "#include <linux/mm.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void ocfs2_drop_osb_locks(struct ocfs2_super *osb);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock_irqrestore",
          "args": [
            "&osb->dc_task_lock",
            "flags"
          ],
          "line": 4063
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock_irqsave",
          "args": [
            "&osb->dc_task_lock",
            "flags"
          ],
          "line": 4060
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"stackglue.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dcache.h\"\n#include \"alloc.h\"\n#include \"ocfs2_lockingver.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/quotaops.h>\n#include <linux/time.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/pagemap.h>\n#include <linux/kthread.h>\n#include <linux/mm.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic void ocfs2_drop_osb_locks(struct ocfs2_super *osb);\n\nstatic int ocfs2_downconvert_thread_should_wake(struct ocfs2_super *osb)\n{\n\tint should_wake = 0;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&osb->dc_task_lock, flags);\n\tif (osb->dc_work_sequence != osb->dc_wake_sequence)\n\t\tshould_wake = 1;\n\tspin_unlock_irqrestore(&osb->dc_task_lock, flags);\n\n\treturn should_wake;\n}"
  },
  {
    "function_name": "ocfs2_downconvert_thread_lists_empty",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlmglue.c",
    "lines": "4042-4053",
    "snippet": "static int ocfs2_downconvert_thread_lists_empty(struct ocfs2_super *osb)\n{\n\tint empty = 0;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&osb->dc_task_lock, flags);\n\tif (list_empty(&osb->blocked_lock_list))\n\t\tempty = 1;\n\n\tspin_unlock_irqrestore(&osb->dc_task_lock, flags);\n\treturn empty;\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"refcounttree.h\"",
      "#include \"quota.h\"",
      "#include \"uptodate.h\"",
      "#include \"super.h\"",
      "#include \"slot_map.h\"",
      "#include \"stackglue.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"heartbeat.h\"",
      "#include \"file.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"dcache.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2_lockingver.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/time.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/kthread.h>",
      "#include <linux/mm.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void ocfs2_drop_osb_locks(struct ocfs2_super *osb);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock_irqrestore",
          "args": [
            "&osb->dc_task_lock",
            "flags"
          ],
          "line": 4051
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&osb->blocked_lock_list"
          ],
          "line": 4048
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_dirty_list_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmthread.c",
          "lines": "505-514",
          "snippet": "static int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/timer.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_flush_asts(struct dlm_ctxt *dlm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/timer.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_flush_asts(struct dlm_ctxt *dlm);\n\nstatic int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock_irqsave",
          "args": [
            "&osb->dc_task_lock",
            "flags"
          ],
          "line": 4047
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"stackglue.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dcache.h\"\n#include \"alloc.h\"\n#include \"ocfs2_lockingver.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/quotaops.h>\n#include <linux/time.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/pagemap.h>\n#include <linux/kthread.h>\n#include <linux/mm.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic void ocfs2_drop_osb_locks(struct ocfs2_super *osb);\n\nstatic int ocfs2_downconvert_thread_lists_empty(struct ocfs2_super *osb)\n{\n\tint empty = 0;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&osb->dc_task_lock, flags);\n\tif (list_empty(&osb->blocked_lock_list))\n\t\tempty = 1;\n\n\tspin_unlock_irqrestore(&osb->dc_task_lock, flags);\n\treturn empty;\n}"
  },
  {
    "function_name": "ocfs2_downconvert_thread_do_work",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlmglue.c",
    "lines": "4011-4040",
    "snippet": "static void ocfs2_downconvert_thread_do_work(struct ocfs2_super *osb)\n{\n\tunsigned long processed;\n\tunsigned long flags;\n\tstruct ocfs2_lock_res *lockres;\n\n\tspin_lock_irqsave(&osb->dc_task_lock, flags);\n\t/* grab this early so we know to try again if a state change and\n\t * wake happens part-way through our work  */\n\tosb->dc_work_sequence = osb->dc_wake_sequence;\n\n\tprocessed = osb->blocked_lock_count;\n\twhile (processed) {\n\t\tBUG_ON(list_empty(&osb->blocked_lock_list));\n\n\t\tlockres = list_entry(osb->blocked_lock_list.next,\n\t\t\t\t     struct ocfs2_lock_res, l_blocked_list);\n\t\tlist_del_init(&lockres->l_blocked_list);\n\t\tosb->blocked_lock_count--;\n\t\tspin_unlock_irqrestore(&osb->dc_task_lock, flags);\n\n\t\tBUG_ON(!processed);\n\t\tprocessed--;\n\n\t\tocfs2_process_blocked_lock(osb, lockres);\n\n\t\tspin_lock_irqsave(&osb->dc_task_lock, flags);\n\t}\n\tspin_unlock_irqrestore(&osb->dc_task_lock, flags);\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"refcounttree.h\"",
      "#include \"quota.h\"",
      "#include \"uptodate.h\"",
      "#include \"super.h\"",
      "#include \"slot_map.h\"",
      "#include \"stackglue.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"heartbeat.h\"",
      "#include \"file.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"dcache.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2_lockingver.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/time.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/kthread.h>",
      "#include <linux/mm.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct ocfs2_super *ocfs2_get_dentry_osb(struct ocfs2_lock_res *lockres);",
      "static struct ocfs2_super *ocfs2_get_inode_osb(struct ocfs2_lock_res *lockres);",
      "static struct ocfs2_super *ocfs2_get_file_osb(struct ocfs2_lock_res *lockres);",
      "static struct ocfs2_super *ocfs2_get_qinfo_osb(struct ocfs2_lock_res *lockres);",
      "static void ocfs2_set_meta_lvb(struct ocfs2_lock_res *lockres);",
      "static void ocfs2_dentry_post_unlock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres);",
      "static void ocfs2_set_qinfo_lvb(struct ocfs2_lock_res *lockres);",
      "static inline void ocfs2_generic_handle_downconvert_action(struct ocfs2_lock_res *lockres);",
      "static inline void ocfs2_generic_handle_convert_action(struct ocfs2_lock_res *lockres);",
      "static inline void ocfs2_generic_handle_attach_action(struct ocfs2_lock_res *lockres);",
      "static void ocfs2_schedule_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);",
      "static void ocfs2_downconvert_on_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);",
      "static void ocfs2_drop_osb_locks(struct ocfs2_super *osb);",
      "static int ocfs2_prepare_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\t        struct ocfs2_lock_res *lockres);",
      "static int ocfs2_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres);",
      "static void ocfs2_process_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *lockres);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock_irqrestore",
          "args": [
            "&osb->dc_task_lock",
            "flags"
          ],
          "line": 4039
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock_irqsave",
          "args": [
            "&osb->dc_task_lock",
            "flags"
          ],
          "line": 4037
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_process_blocked_lock",
          "args": [
            "osb",
            "lockres"
          ],
          "line": 4035
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_process_blocked_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlmglue.c",
          "lines": "3938-3982",
          "snippet": "static void ocfs2_process_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *lockres)\n{\n\tint status;\n\tstruct ocfs2_unblock_ctl ctl = {0, 0,};\n\tunsigned long flags;\n\n\t/* Our reference to the lockres in this function can be\n\t * considered valid until we remove the OCFS2_LOCK_QUEUED\n\t * flag. */\n\n\tBUG_ON(!lockres);\n\tBUG_ON(!lockres->l_ops);\n\n\tmlog(ML_BASTS, \"lockres %s blocked\\n\", lockres->l_name);\n\n\t/* Detect whether a lock has been marked as going away while\n\t * the downconvert thread was processing other things. A lock can\n\t * still be marked with OCFS2_LOCK_FREEING after this check,\n\t * but short circuiting here will still save us some\n\t * performance. */\n\tspin_lock_irqsave(&lockres->l_lock, flags);\n\tif (lockres->l_flags & OCFS2_LOCK_FREEING)\n\t\tgoto unqueue;\n\tspin_unlock_irqrestore(&lockres->l_lock, flags);\n\n\tstatus = ocfs2_unblock_lock(osb, lockres, &ctl);\n\tif (status < 0)\n\t\tmlog_errno(status);\n\n\tspin_lock_irqsave(&lockres->l_lock, flags);\nunqueue:\n\tif (lockres->l_flags & OCFS2_LOCK_FREEING || !ctl.requeue) {\n\t\tlockres_clear_flags(lockres, OCFS2_LOCK_QUEUED);\n\t} else\n\t\tocfs2_schedule_blocked_lock(osb, lockres);\n\n\tmlog(ML_BASTS, \"lockres %s, requeue = %s.\\n\", lockres->l_name,\n\t     ctl.requeue ? \"yes\" : \"no\");\n\tspin_unlock_irqrestore(&lockres->l_lock, flags);\n\n\tif (ctl.unblock_action != UNBLOCK_CONTINUE\n\t    && lockres->l_ops->post_unlock)\n\t\tlockres->l_ops->post_unlock(osb, lockres);\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"refcounttree.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"stackglue.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dcache.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2_lockingver.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/time.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/kthread.h>",
            "#include <linux/mm.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct ocfs2_super *ocfs2_get_dentry_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_inode_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_file_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_qinfo_osb(struct ocfs2_lock_res *lockres);",
            "static void ocfs2_set_meta_lvb(struct ocfs2_lock_res *lockres);",
            "static void ocfs2_dentry_post_unlock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres);",
            "static void ocfs2_set_qinfo_lvb(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_downconvert_action(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_convert_action(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_attach_action(struct ocfs2_lock_res *lockres);",
            "static void ocfs2_schedule_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static void ocfs2_downconvert_on_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static void ocfs2_drop_osb_locks(struct ocfs2_super *osb);",
            "static int ocfs2_prepare_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\t        struct ocfs2_lock_res *lockres);",
            "static int ocfs2_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static void ocfs2_process_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *lockres);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"stackglue.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dcache.h\"\n#include \"alloc.h\"\n#include \"ocfs2_lockingver.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/quotaops.h>\n#include <linux/time.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/pagemap.h>\n#include <linux/kthread.h>\n#include <linux/mm.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic struct ocfs2_super *ocfs2_get_dentry_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_inode_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_file_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_qinfo_osb(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_set_meta_lvb(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_dentry_post_unlock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres);\nstatic void ocfs2_set_qinfo_lvb(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_downconvert_action(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_convert_action(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_attach_action(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_schedule_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_downconvert_on_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_drop_osb_locks(struct ocfs2_super *osb);\nstatic int ocfs2_prepare_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\t        struct ocfs2_lock_res *lockres);\nstatic int ocfs2_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_process_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *lockres);\n\nstatic void ocfs2_process_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *lockres)\n{\n\tint status;\n\tstruct ocfs2_unblock_ctl ctl = {0, 0,};\n\tunsigned long flags;\n\n\t/* Our reference to the lockres in this function can be\n\t * considered valid until we remove the OCFS2_LOCK_QUEUED\n\t * flag. */\n\n\tBUG_ON(!lockres);\n\tBUG_ON(!lockres->l_ops);\n\n\tmlog(ML_BASTS, \"lockres %s blocked\\n\", lockres->l_name);\n\n\t/* Detect whether a lock has been marked as going away while\n\t * the downconvert thread was processing other things. A lock can\n\t * still be marked with OCFS2_LOCK_FREEING after this check,\n\t * but short circuiting here will still save us some\n\t * performance. */\n\tspin_lock_irqsave(&lockres->l_lock, flags);\n\tif (lockres->l_flags & OCFS2_LOCK_FREEING)\n\t\tgoto unqueue;\n\tspin_unlock_irqrestore(&lockres->l_lock, flags);\n\n\tstatus = ocfs2_unblock_lock(osb, lockres, &ctl);\n\tif (status < 0)\n\t\tmlog_errno(status);\n\n\tspin_lock_irqsave(&lockres->l_lock, flags);\nunqueue:\n\tif (lockres->l_flags & OCFS2_LOCK_FREEING || !ctl.requeue) {\n\t\tlockres_clear_flags(lockres, OCFS2_LOCK_QUEUED);\n\t} else\n\t\tocfs2_schedule_blocked_lock(osb, lockres);\n\n\tmlog(ML_BASTS, \"lockres %s, requeue = %s.\\n\", lockres->l_name,\n\t     ctl.requeue ? \"yes\" : \"no\");\n\tspin_unlock_irqrestore(&lockres->l_lock, flags);\n\n\tif (ctl.unblock_action != UNBLOCK_CONTINUE\n\t    && lockres->l_ops->post_unlock)\n\t\tlockres->l_ops->post_unlock(osb, lockres);\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!processed"
          ],
          "line": 4032
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock_irqrestore",
          "args": [
            "&osb->dc_task_lock",
            "flags"
          ],
          "line": 4030
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_del_init",
          "args": [
            "&lockres->l_blocked_list"
          ],
          "line": 4028
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_entry",
          "args": [
            "osb->blocked_lock_list.next",
            "structocfs2_lock_res",
            "l_blocked_list"
          ],
          "line": 4026
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "list_empty(&osb->blocked_lock_list)"
          ],
          "line": 4024
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&osb->blocked_lock_list"
          ],
          "line": 4024
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_dirty_list_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmthread.c",
          "lines": "505-514",
          "snippet": "static int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/timer.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_flush_asts(struct dlm_ctxt *dlm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/timer.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_flush_asts(struct dlm_ctxt *dlm);\n\nstatic int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock_irqsave",
          "args": [
            "&osb->dc_task_lock",
            "flags"
          ],
          "line": 4017
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"stackglue.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dcache.h\"\n#include \"alloc.h\"\n#include \"ocfs2_lockingver.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/quotaops.h>\n#include <linux/time.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/pagemap.h>\n#include <linux/kthread.h>\n#include <linux/mm.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic struct ocfs2_super *ocfs2_get_dentry_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_inode_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_file_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_qinfo_osb(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_set_meta_lvb(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_dentry_post_unlock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres);\nstatic void ocfs2_set_qinfo_lvb(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_downconvert_action(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_convert_action(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_attach_action(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_schedule_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_downconvert_on_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_drop_osb_locks(struct ocfs2_super *osb);\nstatic int ocfs2_prepare_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\t        struct ocfs2_lock_res *lockres);\nstatic int ocfs2_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_process_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *lockres);\n\nstatic void ocfs2_downconvert_thread_do_work(struct ocfs2_super *osb)\n{\n\tunsigned long processed;\n\tunsigned long flags;\n\tstruct ocfs2_lock_res *lockres;\n\n\tspin_lock_irqsave(&osb->dc_task_lock, flags);\n\t/* grab this early so we know to try again if a state change and\n\t * wake happens part-way through our work  */\n\tosb->dc_work_sequence = osb->dc_wake_sequence;\n\n\tprocessed = osb->blocked_lock_count;\n\twhile (processed) {\n\t\tBUG_ON(list_empty(&osb->blocked_lock_list));\n\n\t\tlockres = list_entry(osb->blocked_lock_list.next,\n\t\t\t\t     struct ocfs2_lock_res, l_blocked_list);\n\t\tlist_del_init(&lockres->l_blocked_list);\n\t\tosb->blocked_lock_count--;\n\t\tspin_unlock_irqrestore(&osb->dc_task_lock, flags);\n\n\t\tBUG_ON(!processed);\n\t\tprocessed--;\n\n\t\tocfs2_process_blocked_lock(osb, lockres);\n\n\t\tspin_lock_irqsave(&osb->dc_task_lock, flags);\n\t}\n\tspin_unlock_irqrestore(&osb->dc_task_lock, flags);\n}"
  },
  {
    "function_name": "ocfs2_schedule_blocked_lock",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlmglue.c",
    "lines": "3984-4009",
    "snippet": "static void ocfs2_schedule_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres)\n{\n\tunsigned long flags;\n\n\tassert_spin_locked(&lockres->l_lock);\n\n\tif (lockres->l_flags & OCFS2_LOCK_FREEING) {\n\t\t/* Do not schedule a lock for downconvert when it's on\n\t\t * the way to destruction - any nodes wanting access\n\t\t * to the resource will get it soon. */\n\t\tmlog(ML_BASTS, \"lockres %s won't be scheduled: flags 0x%lx\\n\",\n\t\t     lockres->l_name, lockres->l_flags);\n\t\treturn;\n\t}\n\n\tlockres_or_flags(lockres, OCFS2_LOCK_QUEUED);\n\n\tspin_lock_irqsave(&osb->dc_task_lock, flags);\n\tif (list_empty(&lockres->l_blocked_list)) {\n\t\tlist_add_tail(&lockres->l_blocked_list,\n\t\t\t      &osb->blocked_lock_list);\n\t\tosb->blocked_lock_count++;\n\t}\n\tspin_unlock_irqrestore(&osb->dc_task_lock, flags);\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"refcounttree.h\"",
      "#include \"quota.h\"",
      "#include \"uptodate.h\"",
      "#include \"super.h\"",
      "#include \"slot_map.h\"",
      "#include \"stackglue.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"heartbeat.h\"",
      "#include \"file.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"dcache.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2_lockingver.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/time.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/kthread.h>",
      "#include <linux/mm.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct ocfs2_super *ocfs2_get_dentry_osb(struct ocfs2_lock_res *lockres);",
      "static struct ocfs2_super *ocfs2_get_inode_osb(struct ocfs2_lock_res *lockres);",
      "static struct ocfs2_super *ocfs2_get_file_osb(struct ocfs2_lock_res *lockres);",
      "static struct ocfs2_super *ocfs2_get_qinfo_osb(struct ocfs2_lock_res *lockres);",
      "static void ocfs2_set_meta_lvb(struct ocfs2_lock_res *lockres);",
      "static void ocfs2_dentry_post_unlock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres);",
      "static void ocfs2_set_qinfo_lvb(struct ocfs2_lock_res *lockres);",
      "static inline void ocfs2_generic_handle_downconvert_action(struct ocfs2_lock_res *lockres);",
      "static inline void ocfs2_generic_handle_convert_action(struct ocfs2_lock_res *lockres);",
      "static inline void ocfs2_generic_handle_attach_action(struct ocfs2_lock_res *lockres);",
      "static void ocfs2_schedule_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);",
      "static void ocfs2_downconvert_on_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);",
      "static void ocfs2_drop_osb_locks(struct ocfs2_super *osb);",
      "static int ocfs2_prepare_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\t        struct ocfs2_lock_res *lockres);",
      "static int ocfs2_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres);",
      "static void ocfs2_process_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *lockres);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock_irqrestore",
          "args": [
            "&osb->dc_task_lock",
            "flags"
          ],
          "line": 4008
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_add_tail",
          "args": [
            "&lockres->l_blocked_list",
            "&osb->blocked_lock_list"
          ],
          "line": 4004
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&lockres->l_blocked_list"
          ],
          "line": 4003
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_dirty_list_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmthread.c",
          "lines": "505-514",
          "snippet": "static int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/timer.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_flush_asts(struct dlm_ctxt *dlm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/timer.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_flush_asts(struct dlm_ctxt *dlm);\n\nstatic int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock_irqsave",
          "args": [
            "&osb->dc_task_lock",
            "flags"
          ],
          "line": 4002
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lockres_or_flags",
          "args": [
            "lockres",
            "OCFS2_LOCK_QUEUED"
          ],
          "line": 4000
        },
        "resolved": true,
        "details": {
          "function_name": "lockres_or_flags",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlmglue.c",
          "lines": "819-822",
          "snippet": "static void lockres_or_flags(struct ocfs2_lock_res *lockres, unsigned long or)\n{\n\tlockres_set_flags(lockres, lockres->l_flags | or);\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"refcounttree.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"stackglue.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dcache.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2_lockingver.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/time.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/kthread.h>",
            "#include <linux/mm.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct ocfs2_super *ocfs2_get_dentry_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_inode_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_file_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_qinfo_osb(struct ocfs2_lock_res *lockres);",
            "static void ocfs2_set_meta_lvb(struct ocfs2_lock_res *lockres);",
            "static void ocfs2_dentry_post_unlock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres);",
            "static void ocfs2_set_qinfo_lvb(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_downconvert_action(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_convert_action(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_attach_action(struct ocfs2_lock_res *lockres);",
            "static void ocfs2_schedule_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static void ocfs2_downconvert_on_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static int ocfs2_prepare_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\t        struct ocfs2_lock_res *lockres);",
            "static int ocfs2_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static void ocfs2_process_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *lockres);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"stackglue.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dcache.h\"\n#include \"alloc.h\"\n#include \"ocfs2_lockingver.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/quotaops.h>\n#include <linux/time.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/pagemap.h>\n#include <linux/kthread.h>\n#include <linux/mm.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic struct ocfs2_super *ocfs2_get_dentry_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_inode_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_file_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_qinfo_osb(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_set_meta_lvb(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_dentry_post_unlock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres);\nstatic void ocfs2_set_qinfo_lvb(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_downconvert_action(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_convert_action(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_attach_action(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_schedule_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_downconvert_on_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic int ocfs2_prepare_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\t        struct ocfs2_lock_res *lockres);\nstatic int ocfs2_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_process_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *lockres);\n\nstatic void lockres_or_flags(struct ocfs2_lock_res *lockres, unsigned long or)\n{\n\tlockres_set_flags(lockres, lockres->l_flags | or);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog",
          "args": [
            "ML_BASTS",
            "\"lockres %s won't be scheduled: flags 0x%lx\\n\"",
            "lockres->l_name",
            "lockres->l_flags"
          ],
          "line": 3995
        },
        "resolved": true,
        "details": {
          "function_name": "mlog_store",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/cluster/masklog.c",
          "lines": "115-121",
          "snippet": "static ssize_t mlog_store(struct kobject *obj, struct attribute *attr,\n\t\t\t  const char *buf, size_t count)\n{\n\tstruct mlog_attribute *mlog_attr = to_mlog_attr(attr);\n\n\treturn mlog_mask_store(mlog_attr->mask, buf, count);\n}",
          "includes": [
            "#include \"masklog.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/string.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"masklog.h\"\n#include <asm/uaccess.h>\n#include <linux/string.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n\nstatic ssize_t mlog_store(struct kobject *obj, struct attribute *attr,\n\t\t\t  const char *buf, size_t count)\n{\n\tstruct mlog_attribute *mlog_attr = to_mlog_attr(attr);\n\n\treturn mlog_mask_store(mlog_attr->mask, buf, count);\n}"
        }
      },
      {
        "call_info": {
          "callee": "assert_spin_locked",
          "args": [
            "&lockres->l_lock"
          ],
          "line": 3989
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"stackglue.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dcache.h\"\n#include \"alloc.h\"\n#include \"ocfs2_lockingver.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/quotaops.h>\n#include <linux/time.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/pagemap.h>\n#include <linux/kthread.h>\n#include <linux/mm.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic struct ocfs2_super *ocfs2_get_dentry_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_inode_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_file_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_qinfo_osb(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_set_meta_lvb(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_dentry_post_unlock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres);\nstatic void ocfs2_set_qinfo_lvb(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_downconvert_action(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_convert_action(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_attach_action(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_schedule_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_downconvert_on_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_drop_osb_locks(struct ocfs2_super *osb);\nstatic int ocfs2_prepare_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\t        struct ocfs2_lock_res *lockres);\nstatic int ocfs2_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_process_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *lockres);\n\nstatic void ocfs2_schedule_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres)\n{\n\tunsigned long flags;\n\n\tassert_spin_locked(&lockres->l_lock);\n\n\tif (lockres->l_flags & OCFS2_LOCK_FREEING) {\n\t\t/* Do not schedule a lock for downconvert when it's on\n\t\t * the way to destruction - any nodes wanting access\n\t\t * to the resource will get it soon. */\n\t\tmlog(ML_BASTS, \"lockres %s won't be scheduled: flags 0x%lx\\n\",\n\t\t     lockres->l_name, lockres->l_flags);\n\t\treturn;\n\t}\n\n\tlockres_or_flags(lockres, OCFS2_LOCK_QUEUED);\n\n\tspin_lock_irqsave(&osb->dc_task_lock, flags);\n\tif (list_empty(&lockres->l_blocked_list)) {\n\t\tlist_add_tail(&lockres->l_blocked_list,\n\t\t\t      &osb->blocked_lock_list);\n\t\tosb->blocked_lock_count++;\n\t}\n\tspin_unlock_irqrestore(&osb->dc_task_lock, flags);\n}"
  },
  {
    "function_name": "ocfs2_process_blocked_lock",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlmglue.c",
    "lines": "3938-3982",
    "snippet": "static void ocfs2_process_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *lockres)\n{\n\tint status;\n\tstruct ocfs2_unblock_ctl ctl = {0, 0,};\n\tunsigned long flags;\n\n\t/* Our reference to the lockres in this function can be\n\t * considered valid until we remove the OCFS2_LOCK_QUEUED\n\t * flag. */\n\n\tBUG_ON(!lockres);\n\tBUG_ON(!lockres->l_ops);\n\n\tmlog(ML_BASTS, \"lockres %s blocked\\n\", lockres->l_name);\n\n\t/* Detect whether a lock has been marked as going away while\n\t * the downconvert thread was processing other things. A lock can\n\t * still be marked with OCFS2_LOCK_FREEING after this check,\n\t * but short circuiting here will still save us some\n\t * performance. */\n\tspin_lock_irqsave(&lockres->l_lock, flags);\n\tif (lockres->l_flags & OCFS2_LOCK_FREEING)\n\t\tgoto unqueue;\n\tspin_unlock_irqrestore(&lockres->l_lock, flags);\n\n\tstatus = ocfs2_unblock_lock(osb, lockres, &ctl);\n\tif (status < 0)\n\t\tmlog_errno(status);\n\n\tspin_lock_irqsave(&lockres->l_lock, flags);\nunqueue:\n\tif (lockres->l_flags & OCFS2_LOCK_FREEING || !ctl.requeue) {\n\t\tlockres_clear_flags(lockres, OCFS2_LOCK_QUEUED);\n\t} else\n\t\tocfs2_schedule_blocked_lock(osb, lockres);\n\n\tmlog(ML_BASTS, \"lockres %s, requeue = %s.\\n\", lockres->l_name,\n\t     ctl.requeue ? \"yes\" : \"no\");\n\tspin_unlock_irqrestore(&lockres->l_lock, flags);\n\n\tif (ctl.unblock_action != UNBLOCK_CONTINUE\n\t    && lockres->l_ops->post_unlock)\n\t\tlockres->l_ops->post_unlock(osb, lockres);\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"refcounttree.h\"",
      "#include \"quota.h\"",
      "#include \"uptodate.h\"",
      "#include \"super.h\"",
      "#include \"slot_map.h\"",
      "#include \"stackglue.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"heartbeat.h\"",
      "#include \"file.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"dcache.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2_lockingver.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/time.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/kthread.h>",
      "#include <linux/mm.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct ocfs2_super *ocfs2_get_dentry_osb(struct ocfs2_lock_res *lockres);",
      "static struct ocfs2_super *ocfs2_get_inode_osb(struct ocfs2_lock_res *lockres);",
      "static struct ocfs2_super *ocfs2_get_file_osb(struct ocfs2_lock_res *lockres);",
      "static struct ocfs2_super *ocfs2_get_qinfo_osb(struct ocfs2_lock_res *lockres);",
      "static void ocfs2_set_meta_lvb(struct ocfs2_lock_res *lockres);",
      "static void ocfs2_dentry_post_unlock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres);",
      "static void ocfs2_set_qinfo_lvb(struct ocfs2_lock_res *lockres);",
      "static inline void ocfs2_generic_handle_downconvert_action(struct ocfs2_lock_res *lockres);",
      "static inline void ocfs2_generic_handle_convert_action(struct ocfs2_lock_res *lockres);",
      "static inline void ocfs2_generic_handle_attach_action(struct ocfs2_lock_res *lockres);",
      "static void ocfs2_schedule_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);",
      "static void ocfs2_downconvert_on_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);",
      "static void ocfs2_drop_osb_locks(struct ocfs2_super *osb);",
      "static int ocfs2_prepare_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\t        struct ocfs2_lock_res *lockres);",
      "static int ocfs2_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres);",
      "static void ocfs2_process_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *lockres);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "lockres->l_ops->post_unlock",
          "args": [
            "osb",
            "lockres"
          ],
          "line": 3981
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock_irqrestore",
          "args": [
            "&lockres->l_lock",
            "flags"
          ],
          "line": 3977
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mlog",
          "args": [
            "ML_BASTS",
            "\"lockres %s, requeue = %s.\\n\"",
            "lockres->l_name",
            "ctl.requeue ? \"yes\" : \"no\""
          ],
          "line": 3975
        },
        "resolved": true,
        "details": {
          "function_name": "mlog_store",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/cluster/masklog.c",
          "lines": "115-121",
          "snippet": "static ssize_t mlog_store(struct kobject *obj, struct attribute *attr,\n\t\t\t  const char *buf, size_t count)\n{\n\tstruct mlog_attribute *mlog_attr = to_mlog_attr(attr);\n\n\treturn mlog_mask_store(mlog_attr->mask, buf, count);\n}",
          "includes": [
            "#include \"masklog.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/string.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"masklog.h\"\n#include <asm/uaccess.h>\n#include <linux/string.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n\nstatic ssize_t mlog_store(struct kobject *obj, struct attribute *attr,\n\t\t\t  const char *buf, size_t count)\n{\n\tstruct mlog_attribute *mlog_attr = to_mlog_attr(attr);\n\n\treturn mlog_mask_store(mlog_attr->mask, buf, count);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_schedule_blocked_lock",
          "args": [
            "osb",
            "lockres"
          ],
          "line": 3973
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_schedule_blocked_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlmglue.c",
          "lines": "3984-4009",
          "snippet": "static void ocfs2_schedule_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres)\n{\n\tunsigned long flags;\n\n\tassert_spin_locked(&lockres->l_lock);\n\n\tif (lockres->l_flags & OCFS2_LOCK_FREEING) {\n\t\t/* Do not schedule a lock for downconvert when it's on\n\t\t * the way to destruction - any nodes wanting access\n\t\t * to the resource will get it soon. */\n\t\tmlog(ML_BASTS, \"lockres %s won't be scheduled: flags 0x%lx\\n\",\n\t\t     lockres->l_name, lockres->l_flags);\n\t\treturn;\n\t}\n\n\tlockres_or_flags(lockres, OCFS2_LOCK_QUEUED);\n\n\tspin_lock_irqsave(&osb->dc_task_lock, flags);\n\tif (list_empty(&lockres->l_blocked_list)) {\n\t\tlist_add_tail(&lockres->l_blocked_list,\n\t\t\t      &osb->blocked_lock_list);\n\t\tosb->blocked_lock_count++;\n\t}\n\tspin_unlock_irqrestore(&osb->dc_task_lock, flags);\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"refcounttree.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"stackglue.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dcache.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2_lockingver.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/time.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/kthread.h>",
            "#include <linux/mm.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct ocfs2_super *ocfs2_get_dentry_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_inode_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_file_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_qinfo_osb(struct ocfs2_lock_res *lockres);",
            "static void ocfs2_set_meta_lvb(struct ocfs2_lock_res *lockres);",
            "static void ocfs2_dentry_post_unlock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres);",
            "static void ocfs2_set_qinfo_lvb(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_downconvert_action(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_convert_action(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_attach_action(struct ocfs2_lock_res *lockres);",
            "static void ocfs2_schedule_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static void ocfs2_downconvert_on_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static void ocfs2_drop_osb_locks(struct ocfs2_super *osb);",
            "static int ocfs2_prepare_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\t        struct ocfs2_lock_res *lockres);",
            "static int ocfs2_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static void ocfs2_process_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *lockres);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"stackglue.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dcache.h\"\n#include \"alloc.h\"\n#include \"ocfs2_lockingver.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/quotaops.h>\n#include <linux/time.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/pagemap.h>\n#include <linux/kthread.h>\n#include <linux/mm.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic struct ocfs2_super *ocfs2_get_dentry_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_inode_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_file_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_qinfo_osb(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_set_meta_lvb(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_dentry_post_unlock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres);\nstatic void ocfs2_set_qinfo_lvb(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_downconvert_action(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_convert_action(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_attach_action(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_schedule_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_downconvert_on_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_drop_osb_locks(struct ocfs2_super *osb);\nstatic int ocfs2_prepare_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\t        struct ocfs2_lock_res *lockres);\nstatic int ocfs2_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_process_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *lockres);\n\nstatic void ocfs2_schedule_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres)\n{\n\tunsigned long flags;\n\n\tassert_spin_locked(&lockres->l_lock);\n\n\tif (lockres->l_flags & OCFS2_LOCK_FREEING) {\n\t\t/* Do not schedule a lock for downconvert when it's on\n\t\t * the way to destruction - any nodes wanting access\n\t\t * to the resource will get it soon. */\n\t\tmlog(ML_BASTS, \"lockres %s won't be scheduled: flags 0x%lx\\n\",\n\t\t     lockres->l_name, lockres->l_flags);\n\t\treturn;\n\t}\n\n\tlockres_or_flags(lockres, OCFS2_LOCK_QUEUED);\n\n\tspin_lock_irqsave(&osb->dc_task_lock, flags);\n\tif (list_empty(&lockres->l_blocked_list)) {\n\t\tlist_add_tail(&lockres->l_blocked_list,\n\t\t\t      &osb->blocked_lock_list);\n\t\tosb->blocked_lock_count++;\n\t}\n\tspin_unlock_irqrestore(&osb->dc_task_lock, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "lockres_clear_flags",
          "args": [
            "lockres",
            "OCFS2_LOCK_QUEUED"
          ],
          "line": 3971
        },
        "resolved": true,
        "details": {
          "function_name": "lockres_clear_flags",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlmglue.c",
          "lines": "823-827",
          "snippet": "static void lockres_clear_flags(struct ocfs2_lock_res *lockres,\n\t\t\t\tunsigned long clear)\n{\n\tlockres_set_flags(lockres, lockres->l_flags & ~clear);\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"refcounttree.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"stackglue.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dcache.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2_lockingver.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/time.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/kthread.h>",
            "#include <linux/mm.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct ocfs2_super *ocfs2_get_dentry_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_inode_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_file_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_qinfo_osb(struct ocfs2_lock_res *lockres);",
            "static void ocfs2_set_meta_lvb(struct ocfs2_lock_res *lockres);",
            "static void ocfs2_dentry_post_unlock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres);",
            "static void ocfs2_set_qinfo_lvb(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_downconvert_action(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_convert_action(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_attach_action(struct ocfs2_lock_res *lockres);",
            "static void ocfs2_schedule_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static void ocfs2_downconvert_on_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static int ocfs2_prepare_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\t        struct ocfs2_lock_res *lockres);",
            "static int ocfs2_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static void ocfs2_process_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *lockres);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"stackglue.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dcache.h\"\n#include \"alloc.h\"\n#include \"ocfs2_lockingver.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/quotaops.h>\n#include <linux/time.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/pagemap.h>\n#include <linux/kthread.h>\n#include <linux/mm.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic struct ocfs2_super *ocfs2_get_dentry_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_inode_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_file_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_qinfo_osb(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_set_meta_lvb(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_dentry_post_unlock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres);\nstatic void ocfs2_set_qinfo_lvb(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_downconvert_action(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_convert_action(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_attach_action(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_schedule_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_downconvert_on_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic int ocfs2_prepare_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\t        struct ocfs2_lock_res *lockres);\nstatic int ocfs2_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_process_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *lockres);\n\nstatic void lockres_clear_flags(struct ocfs2_lock_res *lockres,\n\t\t\t\tunsigned long clear)\n{\n\tlockres_set_flags(lockres, lockres->l_flags & ~clear);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock_irqsave",
          "args": [
            "&lockres->l_lock",
            "flags"
          ],
          "line": 3968
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "status"
          ],
          "line": 3966
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_unblock_lock",
          "args": [
            "osb",
            "lockres",
            "&ctl"
          ],
          "line": 3964
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_unblock_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlmglue.c",
          "lines": "3382-3577",
          "snippet": "static int ocfs2_unblock_lock(struct ocfs2_super *osb,\n\t\t\t      struct ocfs2_lock_res *lockres,\n\t\t\t      struct ocfs2_unblock_ctl *ctl)\n{\n\tunsigned long flags;\n\tint blocking;\n\tint new_level;\n\tint level;\n\tint ret = 0;\n\tint set_lvb = 0;\n\tunsigned int gen;\n\n\tspin_lock_irqsave(&lockres->l_lock, flags);\n\nrecheck:\n\t/*\n\t * Is it still blocking? If not, we have no more work to do.\n\t */\n\tif (!(lockres->l_flags & OCFS2_LOCK_BLOCKED)) {\n\t\tBUG_ON(lockres->l_blocking != DLM_LOCK_NL);\n\t\tspin_unlock_irqrestore(&lockres->l_lock, flags);\n\t\tret = 0;\n\t\tgoto leave;\n\t}\n\n\tif (lockres->l_flags & OCFS2_LOCK_BUSY) {\n\t\t/* XXX\n\t\t * This is a *big* race.  The OCFS2_LOCK_PENDING flag\n\t\t * exists entirely for one reason - another thread has set\n\t\t * OCFS2_LOCK_BUSY, but has *NOT* yet called dlm_lock().\n\t\t *\n\t\t * If we do ocfs2_cancel_convert() before the other thread\n\t\t * calls dlm_lock(), our cancel will do nothing.  We will\n\t\t * get no ast, and we will have no way of knowing the\n\t\t * cancel failed.  Meanwhile, the other thread will call\n\t\t * into dlm_lock() and wait...forever.\n\t\t *\n\t\t * Why forever?  Because another node has asked for the\n\t\t * lock first; that's why we're here in unblock_lock().\n\t\t *\n\t\t * The solution is OCFS2_LOCK_PENDING.  When PENDING is\n\t\t * set, we just requeue the unblock.  Only when the other\n\t\t * thread has called dlm_lock() and cleared PENDING will\n\t\t * we then cancel their request.\n\t\t *\n\t\t * All callers of dlm_lock() must set OCFS2_DLM_PENDING\n\t\t * at the same time they set OCFS2_DLM_BUSY.  They must\n\t\t * clear OCFS2_DLM_PENDING after dlm_lock() returns.\n\t\t */\n\t\tif (lockres->l_flags & OCFS2_LOCK_PENDING) {\n\t\t\tmlog(ML_BASTS, \"lockres %s, ReQ: Pending\\n\",\n\t\t\t     lockres->l_name);\n\t\t\tgoto leave_requeue;\n\t\t}\n\n\t\tctl->requeue = 1;\n\t\tret = ocfs2_prepare_cancel_convert(osb, lockres);\n\t\tspin_unlock_irqrestore(&lockres->l_lock, flags);\n\t\tif (ret) {\n\t\t\tret = ocfs2_cancel_convert(osb, lockres);\n\t\t\tif (ret < 0)\n\t\t\t\tmlog_errno(ret);\n\t\t}\n\t\tgoto leave;\n\t}\n\n\t/*\n\t * This prevents livelocks. OCFS2_LOCK_UPCONVERT_FINISHING flag is\n\t * set when the ast is received for an upconvert just before the\n\t * OCFS2_LOCK_BUSY flag is cleared. Now if the fs received a bast\n\t * on the heels of the ast, we want to delay the downconvert just\n\t * enough to allow the up requestor to do its task. Because this\n\t * lock is in the blocked queue, the lock will be downconverted\n\t * as soon as the requestor is done with the lock.\n\t */\n\tif (lockres->l_flags & OCFS2_LOCK_UPCONVERT_FINISHING)\n\t\tgoto leave_requeue;\n\n\t/*\n\t * How can we block and yet be at NL?  We were trying to upconvert\n\t * from NL and got canceled.  The code comes back here, and now\n\t * we notice and clear BLOCKING.\n\t */\n\tif (lockres->l_level == DLM_LOCK_NL) {\n\t\tBUG_ON(lockres->l_ex_holders || lockres->l_ro_holders);\n\t\tmlog(ML_BASTS, \"lockres %s, Aborting dc\\n\", lockres->l_name);\n\t\tlockres->l_blocking = DLM_LOCK_NL;\n\t\tlockres_clear_flags(lockres, OCFS2_LOCK_BLOCKED);\n\t\tspin_unlock_irqrestore(&lockres->l_lock, flags);\n\t\tgoto leave;\n\t}\n\n\t/* if we're blocking an exclusive and we have *any* holders,\n\t * then requeue. */\n\tif ((lockres->l_blocking == DLM_LOCK_EX)\n\t    && (lockres->l_ex_holders || lockres->l_ro_holders)) {\n\t\tmlog(ML_BASTS, \"lockres %s, ReQ: EX/PR Holders %u,%u\\n\",\n\t\t     lockres->l_name, lockres->l_ex_holders,\n\t\t     lockres->l_ro_holders);\n\t\tgoto leave_requeue;\n\t}\n\n\t/* If it's a PR we're blocking, then only\n\t * requeue if we've got any EX holders */\n\tif (lockres->l_blocking == DLM_LOCK_PR &&\n\t    lockres->l_ex_holders) {\n\t\tmlog(ML_BASTS, \"lockres %s, ReQ: EX Holders %u\\n\",\n\t\t     lockres->l_name, lockres->l_ex_holders);\n\t\tgoto leave_requeue;\n\t}\n\n\t/*\n\t * Can we get a lock in this state if the holder counts are\n\t * zero? The meta data unblock code used to check this.\n\t */\n\tif ((lockres->l_ops->flags & LOCK_TYPE_REQUIRES_REFRESH)\n\t    && (lockres->l_flags & OCFS2_LOCK_REFRESHING)) {\n\t\tmlog(ML_BASTS, \"lockres %s, ReQ: Lock Refreshing\\n\",\n\t\t     lockres->l_name);\n\t\tgoto leave_requeue;\n\t}\n\n\tnew_level = ocfs2_highest_compat_lock_level(lockres->l_blocking);\n\n\tif (lockres->l_ops->check_downconvert\n\t    && !lockres->l_ops->check_downconvert(lockres, new_level)) {\n\t\tmlog(ML_BASTS, \"lockres %s, ReQ: Checkpointing\\n\",\n\t\t     lockres->l_name);\n\t\tgoto leave_requeue;\n\t}\n\n\t/* If we get here, then we know that there are no more\n\t * incompatible holders (and anyone asking for an incompatible\n\t * lock is blocked). We can now downconvert the lock */\n\tif (!lockres->l_ops->downconvert_worker)\n\t\tgoto downconvert;\n\n\t/* Some lockres types want to do a bit of work before\n\t * downconverting a lock. Allow that here. The worker function\n\t * may sleep, so we save off a copy of what we're blocking as\n\t * it may change while we're not holding the spin lock. */\n\tblocking = lockres->l_blocking;\n\tlevel = lockres->l_level;\n\tspin_unlock_irqrestore(&lockres->l_lock, flags);\n\n\tctl->unblock_action = lockres->l_ops->downconvert_worker(lockres, blocking);\n\n\tif (ctl->unblock_action == UNBLOCK_STOP_POST) {\n\t\tmlog(ML_BASTS, \"lockres %s, UNBLOCK_STOP_POST\\n\",\n\t\t     lockres->l_name);\n\t\tgoto leave;\n\t}\n\n\tspin_lock_irqsave(&lockres->l_lock, flags);\n\tif ((blocking != lockres->l_blocking) || (level != lockres->l_level)) {\n\t\t/* If this changed underneath us, then we can't drop\n\t\t * it just yet. */\n\t\tmlog(ML_BASTS, \"lockres %s, block=%d:%d, level=%d:%d, \"\n\t\t     \"Recheck\\n\", lockres->l_name, blocking,\n\t\t     lockres->l_blocking, level, lockres->l_level);\n\t\tgoto recheck;\n\t}\n\ndownconvert:\n\tctl->requeue = 0;\n\n\tif (lockres->l_ops->flags & LOCK_TYPE_USES_LVB) {\n\t\tif (lockres->l_level == DLM_LOCK_EX)\n\t\t\tset_lvb = 1;\n\n\t\t/*\n\t\t * We only set the lvb if the lock has been fully\n\t\t * refreshed - otherwise we risk setting stale\n\t\t * data. Otherwise, there's no need to actually clear\n\t\t * out the lvb here as it's value is still valid.\n\t\t */\n\t\tif (set_lvb && !(lockres->l_flags & OCFS2_LOCK_NEEDS_REFRESH))\n\t\t\tlockres->l_ops->set_lvb(lockres);\n\t}\n\n\tgen = ocfs2_prepare_downconvert(lockres, new_level);\n\tspin_unlock_irqrestore(&lockres->l_lock, flags);\n\tret = ocfs2_downconvert_lock(osb, lockres, new_level, set_lvb,\n\t\t\t\t     gen);\n\nleave:\n\tif (ret)\n\t\tmlog_errno(ret);\n\treturn ret;\n\nleave_requeue:\n\tspin_unlock_irqrestore(&lockres->l_lock, flags);\n\tctl->requeue = 1;\n\n\treturn 0;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"refcounttree.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"stackglue.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dcache.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2_lockingver.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/time.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/kthread.h>",
            "#include <linux/mm.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [
            "#define LOCK_TYPE_USES_LVB\t\t0x2",
            "#define LOCK_TYPE_REQUIRES_REFRESH 0x1"
          ],
          "globals_used": [
            "static struct ocfs2_super *ocfs2_get_dentry_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_inode_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_file_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_qinfo_osb(struct ocfs2_lock_res *lockres);",
            "static int ocfs2_check_meta_downconvert(struct ocfs2_lock_res *lockres,\n\t\t\t\t\tint new_level);",
            "static void ocfs2_set_meta_lvb(struct ocfs2_lock_res *lockres);",
            "static int ocfs2_data_convert_worker(struct ocfs2_lock_res *lockres,\n\t\t\t\t     int blocking);",
            "static int ocfs2_dentry_convert_worker(struct ocfs2_lock_res *lockres,\n\t\t\t\t       int blocking);",
            "static void ocfs2_dentry_post_unlock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres);",
            "static void ocfs2_set_qinfo_lvb(struct ocfs2_lock_res *lockres);",
            "static int ocfs2_check_refcount_downconvert(struct ocfs2_lock_res *lockres,\n\t\t\t\t\t    int new_level);",
            "static int ocfs2_refcount_convert_worker(struct ocfs2_lock_res *lockres,\n\t\t\t\t\t int blocking);",
            "static inline void ocfs2_generic_handle_downconvert_action(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_convert_action(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_attach_action(struct ocfs2_lock_res *lockres);",
            "static int ocfs2_generic_handle_bast(struct ocfs2_lock_res *lockres, int level);",
            "static void ocfs2_schedule_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static void ocfs2_downconvert_on_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static void ocfs2_drop_osb_locks(struct ocfs2_super *osb);",
            "static inline int ocfs2_highest_compat_lock_level(int level);",
            "static unsigned int ocfs2_prepare_downconvert(struct ocfs2_lock_res *lockres,\n\t\t\t\t\t      int new_level);",
            "static int ocfs2_prepare_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\t        struct ocfs2_lock_res *lockres);",
            "static int ocfs2_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static void ocfs2_process_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *lockres);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"stackglue.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dcache.h\"\n#include \"alloc.h\"\n#include \"ocfs2_lockingver.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/quotaops.h>\n#include <linux/time.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/pagemap.h>\n#include <linux/kthread.h>\n#include <linux/mm.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\n#define LOCK_TYPE_USES_LVB\t\t0x2\n#define LOCK_TYPE_REQUIRES_REFRESH 0x1\n\nstatic struct ocfs2_super *ocfs2_get_dentry_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_inode_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_file_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_qinfo_osb(struct ocfs2_lock_res *lockres);\nstatic int ocfs2_check_meta_downconvert(struct ocfs2_lock_res *lockres,\n\t\t\t\t\tint new_level);\nstatic void ocfs2_set_meta_lvb(struct ocfs2_lock_res *lockres);\nstatic int ocfs2_data_convert_worker(struct ocfs2_lock_res *lockres,\n\t\t\t\t     int blocking);\nstatic int ocfs2_dentry_convert_worker(struct ocfs2_lock_res *lockres,\n\t\t\t\t       int blocking);\nstatic void ocfs2_dentry_post_unlock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres);\nstatic void ocfs2_set_qinfo_lvb(struct ocfs2_lock_res *lockres);\nstatic int ocfs2_check_refcount_downconvert(struct ocfs2_lock_res *lockres,\n\t\t\t\t\t    int new_level);\nstatic int ocfs2_refcount_convert_worker(struct ocfs2_lock_res *lockres,\n\t\t\t\t\t int blocking);\nstatic inline void ocfs2_generic_handle_downconvert_action(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_convert_action(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_attach_action(struct ocfs2_lock_res *lockres);\nstatic int ocfs2_generic_handle_bast(struct ocfs2_lock_res *lockres, int level);\nstatic void ocfs2_schedule_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_downconvert_on_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_drop_osb_locks(struct ocfs2_super *osb);\nstatic inline int ocfs2_highest_compat_lock_level(int level);\nstatic unsigned int ocfs2_prepare_downconvert(struct ocfs2_lock_res *lockres,\n\t\t\t\t\t      int new_level);\nstatic int ocfs2_prepare_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\t        struct ocfs2_lock_res *lockres);\nstatic int ocfs2_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_process_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *lockres);\n\nstatic int ocfs2_unblock_lock(struct ocfs2_super *osb,\n\t\t\t      struct ocfs2_lock_res *lockres,\n\t\t\t      struct ocfs2_unblock_ctl *ctl)\n{\n\tunsigned long flags;\n\tint blocking;\n\tint new_level;\n\tint level;\n\tint ret = 0;\n\tint set_lvb = 0;\n\tunsigned int gen;\n\n\tspin_lock_irqsave(&lockres->l_lock, flags);\n\nrecheck:\n\t/*\n\t * Is it still blocking? If not, we have no more work to do.\n\t */\n\tif (!(lockres->l_flags & OCFS2_LOCK_BLOCKED)) {\n\t\tBUG_ON(lockres->l_blocking != DLM_LOCK_NL);\n\t\tspin_unlock_irqrestore(&lockres->l_lock, flags);\n\t\tret = 0;\n\t\tgoto leave;\n\t}\n\n\tif (lockres->l_flags & OCFS2_LOCK_BUSY) {\n\t\t/* XXX\n\t\t * This is a *big* race.  The OCFS2_LOCK_PENDING flag\n\t\t * exists entirely for one reason - another thread has set\n\t\t * OCFS2_LOCK_BUSY, but has *NOT* yet called dlm_lock().\n\t\t *\n\t\t * If we do ocfs2_cancel_convert() before the other thread\n\t\t * calls dlm_lock(), our cancel will do nothing.  We will\n\t\t * get no ast, and we will have no way of knowing the\n\t\t * cancel failed.  Meanwhile, the other thread will call\n\t\t * into dlm_lock() and wait...forever.\n\t\t *\n\t\t * Why forever?  Because another node has asked for the\n\t\t * lock first; that's why we're here in unblock_lock().\n\t\t *\n\t\t * The solution is OCFS2_LOCK_PENDING.  When PENDING is\n\t\t * set, we just requeue the unblock.  Only when the other\n\t\t * thread has called dlm_lock() and cleared PENDING will\n\t\t * we then cancel their request.\n\t\t *\n\t\t * All callers of dlm_lock() must set OCFS2_DLM_PENDING\n\t\t * at the same time they set OCFS2_DLM_BUSY.  They must\n\t\t * clear OCFS2_DLM_PENDING after dlm_lock() returns.\n\t\t */\n\t\tif (lockres->l_flags & OCFS2_LOCK_PENDING) {\n\t\t\tmlog(ML_BASTS, \"lockres %s, ReQ: Pending\\n\",\n\t\t\t     lockres->l_name);\n\t\t\tgoto leave_requeue;\n\t\t}\n\n\t\tctl->requeue = 1;\n\t\tret = ocfs2_prepare_cancel_convert(osb, lockres);\n\t\tspin_unlock_irqrestore(&lockres->l_lock, flags);\n\t\tif (ret) {\n\t\t\tret = ocfs2_cancel_convert(osb, lockres);\n\t\t\tif (ret < 0)\n\t\t\t\tmlog_errno(ret);\n\t\t}\n\t\tgoto leave;\n\t}\n\n\t/*\n\t * This prevents livelocks. OCFS2_LOCK_UPCONVERT_FINISHING flag is\n\t * set when the ast is received for an upconvert just before the\n\t * OCFS2_LOCK_BUSY flag is cleared. Now if the fs received a bast\n\t * on the heels of the ast, we want to delay the downconvert just\n\t * enough to allow the up requestor to do its task. Because this\n\t * lock is in the blocked queue, the lock will be downconverted\n\t * as soon as the requestor is done with the lock.\n\t */\n\tif (lockres->l_flags & OCFS2_LOCK_UPCONVERT_FINISHING)\n\t\tgoto leave_requeue;\n\n\t/*\n\t * How can we block and yet be at NL?  We were trying to upconvert\n\t * from NL and got canceled.  The code comes back here, and now\n\t * we notice and clear BLOCKING.\n\t */\n\tif (lockres->l_level == DLM_LOCK_NL) {\n\t\tBUG_ON(lockres->l_ex_holders || lockres->l_ro_holders);\n\t\tmlog(ML_BASTS, \"lockres %s, Aborting dc\\n\", lockres->l_name);\n\t\tlockres->l_blocking = DLM_LOCK_NL;\n\t\tlockres_clear_flags(lockres, OCFS2_LOCK_BLOCKED);\n\t\tspin_unlock_irqrestore(&lockres->l_lock, flags);\n\t\tgoto leave;\n\t}\n\n\t/* if we're blocking an exclusive and we have *any* holders,\n\t * then requeue. */\n\tif ((lockres->l_blocking == DLM_LOCK_EX)\n\t    && (lockres->l_ex_holders || lockres->l_ro_holders)) {\n\t\tmlog(ML_BASTS, \"lockres %s, ReQ: EX/PR Holders %u,%u\\n\",\n\t\t     lockres->l_name, lockres->l_ex_holders,\n\t\t     lockres->l_ro_holders);\n\t\tgoto leave_requeue;\n\t}\n\n\t/* If it's a PR we're blocking, then only\n\t * requeue if we've got any EX holders */\n\tif (lockres->l_blocking == DLM_LOCK_PR &&\n\t    lockres->l_ex_holders) {\n\t\tmlog(ML_BASTS, \"lockres %s, ReQ: EX Holders %u\\n\",\n\t\t     lockres->l_name, lockres->l_ex_holders);\n\t\tgoto leave_requeue;\n\t}\n\n\t/*\n\t * Can we get a lock in this state if the holder counts are\n\t * zero? The meta data unblock code used to check this.\n\t */\n\tif ((lockres->l_ops->flags & LOCK_TYPE_REQUIRES_REFRESH)\n\t    && (lockres->l_flags & OCFS2_LOCK_REFRESHING)) {\n\t\tmlog(ML_BASTS, \"lockres %s, ReQ: Lock Refreshing\\n\",\n\t\t     lockres->l_name);\n\t\tgoto leave_requeue;\n\t}\n\n\tnew_level = ocfs2_highest_compat_lock_level(lockres->l_blocking);\n\n\tif (lockres->l_ops->check_downconvert\n\t    && !lockres->l_ops->check_downconvert(lockres, new_level)) {\n\t\tmlog(ML_BASTS, \"lockres %s, ReQ: Checkpointing\\n\",\n\t\t     lockres->l_name);\n\t\tgoto leave_requeue;\n\t}\n\n\t/* If we get here, then we know that there are no more\n\t * incompatible holders (and anyone asking for an incompatible\n\t * lock is blocked). We can now downconvert the lock */\n\tif (!lockres->l_ops->downconvert_worker)\n\t\tgoto downconvert;\n\n\t/* Some lockres types want to do a bit of work before\n\t * downconverting a lock. Allow that here. The worker function\n\t * may sleep, so we save off a copy of what we're blocking as\n\t * it may change while we're not holding the spin lock. */\n\tblocking = lockres->l_blocking;\n\tlevel = lockres->l_level;\n\tspin_unlock_irqrestore(&lockres->l_lock, flags);\n\n\tctl->unblock_action = lockres->l_ops->downconvert_worker(lockres, blocking);\n\n\tif (ctl->unblock_action == UNBLOCK_STOP_POST) {\n\t\tmlog(ML_BASTS, \"lockres %s, UNBLOCK_STOP_POST\\n\",\n\t\t     lockres->l_name);\n\t\tgoto leave;\n\t}\n\n\tspin_lock_irqsave(&lockres->l_lock, flags);\n\tif ((blocking != lockres->l_blocking) || (level != lockres->l_level)) {\n\t\t/* If this changed underneath us, then we can't drop\n\t\t * it just yet. */\n\t\tmlog(ML_BASTS, \"lockres %s, block=%d:%d, level=%d:%d, \"\n\t\t     \"Recheck\\n\", lockres->l_name, blocking,\n\t\t     lockres->l_blocking, level, lockres->l_level);\n\t\tgoto recheck;\n\t}\n\ndownconvert:\n\tctl->requeue = 0;\n\n\tif (lockres->l_ops->flags & LOCK_TYPE_USES_LVB) {\n\t\tif (lockres->l_level == DLM_LOCK_EX)\n\t\t\tset_lvb = 1;\n\n\t\t/*\n\t\t * We only set the lvb if the lock has been fully\n\t\t * refreshed - otherwise we risk setting stale\n\t\t * data. Otherwise, there's no need to actually clear\n\t\t * out the lvb here as it's value is still valid.\n\t\t */\n\t\tif (set_lvb && !(lockres->l_flags & OCFS2_LOCK_NEEDS_REFRESH))\n\t\t\tlockres->l_ops->set_lvb(lockres);\n\t}\n\n\tgen = ocfs2_prepare_downconvert(lockres, new_level);\n\tspin_unlock_irqrestore(&lockres->l_lock, flags);\n\tret = ocfs2_downconvert_lock(osb, lockres, new_level, set_lvb,\n\t\t\t\t     gen);\n\nleave:\n\tif (ret)\n\t\tmlog_errno(ret);\n\treturn ret;\n\nleave_requeue:\n\tspin_unlock_irqrestore(&lockres->l_lock, flags);\n\tctl->requeue = 1;\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock_irqrestore",
          "args": [
            "&lockres->l_lock",
            "flags"
          ],
          "line": 3962
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock_irqsave",
          "args": [
            "&lockres->l_lock",
            "flags"
          ],
          "line": 3959
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mlog",
          "args": [
            "ML_BASTS",
            "\"lockres %s blocked\\n\"",
            "lockres->l_name"
          ],
          "line": 3952
        },
        "resolved": true,
        "details": {
          "function_name": "mlog_show",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/cluster/masklog.c",
          "lines": "107-113",
          "snippet": "static ssize_t mlog_show(struct kobject *obj, struct attribute *attr,\n\t\t\t char *buf)\n{\n\tstruct mlog_attribute *mlog_attr = to_mlog_attr(attr);\n\n\treturn mlog_mask_show(mlog_attr->mask, buf);\n}",
          "includes": [
            "#include \"masklog.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/string.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"masklog.h\"\n#include <asm/uaccess.h>\n#include <linux/string.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n\nstatic ssize_t mlog_show(struct kobject *obj, struct attribute *attr,\n\t\t\t char *buf)\n{\n\tstruct mlog_attribute *mlog_attr = to_mlog_attr(attr);\n\n\treturn mlog_mask_show(mlog_attr->mask, buf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!lockres->l_ops"
          ],
          "line": 3950
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!lockres"
          ],
          "line": 3949
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"stackglue.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dcache.h\"\n#include \"alloc.h\"\n#include \"ocfs2_lockingver.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/quotaops.h>\n#include <linux/time.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/pagemap.h>\n#include <linux/kthread.h>\n#include <linux/mm.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic struct ocfs2_super *ocfs2_get_dentry_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_inode_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_file_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_qinfo_osb(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_set_meta_lvb(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_dentry_post_unlock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres);\nstatic void ocfs2_set_qinfo_lvb(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_downconvert_action(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_convert_action(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_attach_action(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_schedule_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_downconvert_on_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_drop_osb_locks(struct ocfs2_super *osb);\nstatic int ocfs2_prepare_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\t        struct ocfs2_lock_res *lockres);\nstatic int ocfs2_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_process_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *lockres);\n\nstatic void ocfs2_process_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *lockres)\n{\n\tint status;\n\tstruct ocfs2_unblock_ctl ctl = {0, 0,};\n\tunsigned long flags;\n\n\t/* Our reference to the lockres in this function can be\n\t * considered valid until we remove the OCFS2_LOCK_QUEUED\n\t * flag. */\n\n\tBUG_ON(!lockres);\n\tBUG_ON(!lockres->l_ops);\n\n\tmlog(ML_BASTS, \"lockres %s blocked\\n\", lockres->l_name);\n\n\t/* Detect whether a lock has been marked as going away while\n\t * the downconvert thread was processing other things. A lock can\n\t * still be marked with OCFS2_LOCK_FREEING after this check,\n\t * but short circuiting here will still save us some\n\t * performance. */\n\tspin_lock_irqsave(&lockres->l_lock, flags);\n\tif (lockres->l_flags & OCFS2_LOCK_FREEING)\n\t\tgoto unqueue;\n\tspin_unlock_irqrestore(&lockres->l_lock, flags);\n\n\tstatus = ocfs2_unblock_lock(osb, lockres, &ctl);\n\tif (status < 0)\n\t\tmlog_errno(status);\n\n\tspin_lock_irqsave(&lockres->l_lock, flags);\nunqueue:\n\tif (lockres->l_flags & OCFS2_LOCK_FREEING || !ctl.requeue) {\n\t\tlockres_clear_flags(lockres, OCFS2_LOCK_QUEUED);\n\t} else\n\t\tocfs2_schedule_blocked_lock(osb, lockres);\n\n\tmlog(ML_BASTS, \"lockres %s, requeue = %s.\\n\", lockres->l_name,\n\t     ctl.requeue ? \"yes\" : \"no\");\n\tspin_unlock_irqrestore(&lockres->l_lock, flags);\n\n\tif (ctl.unblock_action != UNBLOCK_CONTINUE\n\t    && lockres->l_ops->post_unlock)\n\t\tlockres->l_ops->post_unlock(osb, lockres);\n}"
  },
  {
    "function_name": "ocfs2_refcount_unlock",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlmglue.c",
    "lines": "3928-3936",
    "snippet": "void ocfs2_refcount_unlock(struct ocfs2_refcount_tree *ref_tree, int ex)\n{\n\tint level = ex ? DLM_LOCK_EX : DLM_LOCK_PR;\n\tstruct ocfs2_lock_res *lockres = &ref_tree->rf_lockres;\n\tstruct ocfs2_super *osb = lockres->l_priv;\n\n\tif (!ocfs2_mount_local(osb))\n\t\tocfs2_cluster_unlock(osb, lockres, level);\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"refcounttree.h\"",
      "#include \"quota.h\"",
      "#include \"uptodate.h\"",
      "#include \"super.h\"",
      "#include \"slot_map.h\"",
      "#include \"stackglue.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"heartbeat.h\"",
      "#include \"file.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"dcache.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2_lockingver.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/time.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/kthread.h>",
      "#include <linux/mm.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct ocfs2_super *ocfs2_get_dentry_osb(struct ocfs2_lock_res *lockres);",
      "static struct ocfs2_super *ocfs2_get_inode_osb(struct ocfs2_lock_res *lockres);",
      "static struct ocfs2_super *ocfs2_get_file_osb(struct ocfs2_lock_res *lockres);",
      "static struct ocfs2_super *ocfs2_get_qinfo_osb(struct ocfs2_lock_res *lockres);",
      "static void ocfs2_set_meta_lvb(struct ocfs2_lock_res *lockres);",
      "static void ocfs2_dentry_post_unlock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres);",
      "static void ocfs2_set_qinfo_lvb(struct ocfs2_lock_res *lockres);",
      "static inline void ocfs2_generic_handle_downconvert_action(struct ocfs2_lock_res *lockres);",
      "static inline void ocfs2_generic_handle_convert_action(struct ocfs2_lock_res *lockres);",
      "static inline void ocfs2_generic_handle_attach_action(struct ocfs2_lock_res *lockres);",
      "static int ocfs2_generic_handle_bast(struct ocfs2_lock_res *lockres, int level);",
      "static void ocfs2_schedule_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);",
      "static void ocfs2_downconvert_on_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);",
      "static void ocfs2_drop_osb_locks(struct ocfs2_super *osb);",
      "static inline int ocfs2_highest_compat_lock_level(int level);",
      "static int ocfs2_prepare_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\t        struct ocfs2_lock_res *lockres);",
      "static int ocfs2_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres);",
      "static void ocfs2_process_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *lockres);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ocfs2_cluster_unlock",
          "args": [
            "osb",
            "lockres",
            "level"
          ],
          "line": 3935
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_cluster_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlmglue.c",
          "lines": "349-354",
          "snippet": "static inline void ocfs2_cluster_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres,\n\t\t\t\t\tint level)\n{\n\t__ocfs2_cluster_unlock(osb, lockres, level, _RET_IP_);\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"refcounttree.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"stackglue.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dcache.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2_lockingver.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/time.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/kthread.h>",
            "#include <linux/mm.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct ocfs2_super *ocfs2_get_dentry_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_inode_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_file_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_qinfo_osb(struct ocfs2_lock_res *lockres);",
            "static void ocfs2_set_meta_lvb(struct ocfs2_lock_res *lockres);",
            "static void ocfs2_dentry_post_unlock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres);",
            "static void ocfs2_set_qinfo_lvb(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_downconvert_action(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_convert_action(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_attach_action(struct ocfs2_lock_res *lockres);",
            "static int ocfs2_generic_handle_bast(struct ocfs2_lock_res *lockres, int level);",
            "static void ocfs2_schedule_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static void ocfs2_downconvert_on_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static void ocfs2_drop_osb_locks(struct ocfs2_super *osb);",
            "static inline int ocfs2_highest_compat_lock_level(int level);",
            "static int ocfs2_prepare_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\t        struct ocfs2_lock_res *lockres);",
            "static int ocfs2_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static void ocfs2_process_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *lockres);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"stackglue.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dcache.h\"\n#include \"alloc.h\"\n#include \"ocfs2_lockingver.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/quotaops.h>\n#include <linux/time.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/pagemap.h>\n#include <linux/kthread.h>\n#include <linux/mm.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic struct ocfs2_super *ocfs2_get_dentry_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_inode_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_file_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_qinfo_osb(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_set_meta_lvb(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_dentry_post_unlock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres);\nstatic void ocfs2_set_qinfo_lvb(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_downconvert_action(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_convert_action(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_attach_action(struct ocfs2_lock_res *lockres);\nstatic int ocfs2_generic_handle_bast(struct ocfs2_lock_res *lockres, int level);\nstatic void ocfs2_schedule_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_downconvert_on_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_drop_osb_locks(struct ocfs2_super *osb);\nstatic inline int ocfs2_highest_compat_lock_level(int level);\nstatic int ocfs2_prepare_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\t        struct ocfs2_lock_res *lockres);\nstatic int ocfs2_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_process_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *lockres);\n\nstatic inline void ocfs2_cluster_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres,\n\t\t\t\t\tint level)\n{\n\t__ocfs2_cluster_unlock(osb, lockres, level, _RET_IP_);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_mount_local",
          "args": [
            "osb"
          ],
          "line": 3934
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_mount_local",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "668-671",
          "snippet": "static inline int ocfs2_mount_local(struct ocfs2_super *osb)\n{\n\treturn (osb->s_feature_incompat & OCFS2_FEATURE_INCOMPAT_LOCAL_MOUNT);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\nstatic inline int ocfs2_mount_local(struct ocfs2_super *osb)\n{\n\treturn (osb->s_feature_incompat & OCFS2_FEATURE_INCOMPAT_LOCAL_MOUNT);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"stackglue.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dcache.h\"\n#include \"alloc.h\"\n#include \"ocfs2_lockingver.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/quotaops.h>\n#include <linux/time.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/pagemap.h>\n#include <linux/kthread.h>\n#include <linux/mm.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic struct ocfs2_super *ocfs2_get_dentry_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_inode_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_file_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_qinfo_osb(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_set_meta_lvb(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_dentry_post_unlock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres);\nstatic void ocfs2_set_qinfo_lvb(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_downconvert_action(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_convert_action(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_attach_action(struct ocfs2_lock_res *lockres);\nstatic int ocfs2_generic_handle_bast(struct ocfs2_lock_res *lockres, int level);\nstatic void ocfs2_schedule_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_downconvert_on_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_drop_osb_locks(struct ocfs2_super *osb);\nstatic inline int ocfs2_highest_compat_lock_level(int level);\nstatic int ocfs2_prepare_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\t        struct ocfs2_lock_res *lockres);\nstatic int ocfs2_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_process_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *lockres);\n\nvoid ocfs2_refcount_unlock(struct ocfs2_refcount_tree *ref_tree, int ex)\n{\n\tint level = ex ? DLM_LOCK_EX : DLM_LOCK_PR;\n\tstruct ocfs2_lock_res *lockres = &ref_tree->rf_lockres;\n\tstruct ocfs2_super *osb = lockres->l_priv;\n\n\tif (!ocfs2_mount_local(osb))\n\t\tocfs2_cluster_unlock(osb, lockres, level);\n}"
  },
  {
    "function_name": "ocfs2_refcount_lock",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlmglue.c",
    "lines": "3907-3926",
    "snippet": "int ocfs2_refcount_lock(struct ocfs2_refcount_tree *ref_tree, int ex)\n{\n\tint status;\n\tint level = ex ? DLM_LOCK_EX : DLM_LOCK_PR;\n\tstruct ocfs2_lock_res *lockres = &ref_tree->rf_lockres;\n\tstruct ocfs2_super *osb = lockres->l_priv;\n\n\n\tif (ocfs2_is_hard_readonly(osb))\n\t\treturn -EROFS;\n\n\tif (ocfs2_mount_local(osb))\n\t\treturn 0;\n\n\tstatus = ocfs2_cluster_lock(osb, lockres, level, 0, 0);\n\tif (status < 0)\n\t\tmlog_errno(status);\n\n\treturn status;\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"refcounttree.h\"",
      "#include \"quota.h\"",
      "#include \"uptodate.h\"",
      "#include \"super.h\"",
      "#include \"slot_map.h\"",
      "#include \"stackglue.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"heartbeat.h\"",
      "#include \"file.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"dcache.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2_lockingver.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/time.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/kthread.h>",
      "#include <linux/mm.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct ocfs2_super *ocfs2_get_dentry_osb(struct ocfs2_lock_res *lockres);",
      "static struct ocfs2_super *ocfs2_get_inode_osb(struct ocfs2_lock_res *lockres);",
      "static struct ocfs2_super *ocfs2_get_file_osb(struct ocfs2_lock_res *lockres);",
      "static struct ocfs2_super *ocfs2_get_qinfo_osb(struct ocfs2_lock_res *lockres);",
      "static void ocfs2_set_meta_lvb(struct ocfs2_lock_res *lockres);",
      "static void ocfs2_dentry_post_unlock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres);",
      "static void ocfs2_set_qinfo_lvb(struct ocfs2_lock_res *lockres);",
      "static inline void ocfs2_generic_handle_downconvert_action(struct ocfs2_lock_res *lockres);",
      "static inline void ocfs2_generic_handle_convert_action(struct ocfs2_lock_res *lockres);",
      "static inline void ocfs2_generic_handle_attach_action(struct ocfs2_lock_res *lockres);",
      "static int ocfs2_generic_handle_bast(struct ocfs2_lock_res *lockres, int level);",
      "static void ocfs2_schedule_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);",
      "static void ocfs2_downconvert_on_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);",
      "static void ocfs2_drop_osb_locks(struct ocfs2_super *osb);",
      "static inline int ocfs2_highest_compat_lock_level(int level);",
      "static int ocfs2_prepare_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\t        struct ocfs2_lock_res *lockres);",
      "static int ocfs2_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres);",
      "static void ocfs2_process_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *lockres);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "status"
          ],
          "line": 3923
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_cluster_lock",
          "args": [
            "osb",
            "lockres",
            "level",
            "0",
            "0"
          ],
          "line": 3921
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_cluster_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlmglue.c",
          "lines": "1570-1578",
          "snippet": "static inline int ocfs2_cluster_lock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres,\n\t\t\t\t     int level,\n\t\t\t\t     u32 lkm_flags,\n\t\t\t\t     int arg_flags)\n{\n\treturn __ocfs2_cluster_lock(osb, lockres, level, lkm_flags, arg_flags,\n\t\t\t\t    0, _RET_IP_);\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"refcounttree.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"stackglue.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dcache.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2_lockingver.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/time.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/kthread.h>",
            "#include <linux/mm.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct ocfs2_super *ocfs2_get_dentry_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_inode_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_file_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_qinfo_osb(struct ocfs2_lock_res *lockres);",
            "static void ocfs2_set_meta_lvb(struct ocfs2_lock_res *lockres);",
            "static void ocfs2_dentry_post_unlock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres);",
            "static void ocfs2_set_qinfo_lvb(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_downconvert_action(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_convert_action(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_attach_action(struct ocfs2_lock_res *lockres);",
            "static int ocfs2_generic_handle_bast(struct ocfs2_lock_res *lockres, int level);",
            "static void ocfs2_schedule_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static void ocfs2_downconvert_on_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static void ocfs2_drop_osb_locks(struct ocfs2_super *osb);",
            "static inline int ocfs2_highest_compat_lock_level(int level);",
            "static int ocfs2_prepare_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\t        struct ocfs2_lock_res *lockres);",
            "static int ocfs2_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static void ocfs2_process_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *lockres);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"stackglue.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dcache.h\"\n#include \"alloc.h\"\n#include \"ocfs2_lockingver.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/quotaops.h>\n#include <linux/time.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/pagemap.h>\n#include <linux/kthread.h>\n#include <linux/mm.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic struct ocfs2_super *ocfs2_get_dentry_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_inode_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_file_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_qinfo_osb(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_set_meta_lvb(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_dentry_post_unlock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres);\nstatic void ocfs2_set_qinfo_lvb(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_downconvert_action(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_convert_action(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_attach_action(struct ocfs2_lock_res *lockres);\nstatic int ocfs2_generic_handle_bast(struct ocfs2_lock_res *lockres, int level);\nstatic void ocfs2_schedule_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_downconvert_on_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_drop_osb_locks(struct ocfs2_super *osb);\nstatic inline int ocfs2_highest_compat_lock_level(int level);\nstatic int ocfs2_prepare_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\t        struct ocfs2_lock_res *lockres);\nstatic int ocfs2_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_process_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *lockres);\n\nstatic inline int ocfs2_cluster_lock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres,\n\t\t\t\t     int level,\n\t\t\t\t     u32 lkm_flags,\n\t\t\t\t     int arg_flags)\n{\n\treturn __ocfs2_cluster_lock(osb, lockres, level, lkm_flags, arg_flags,\n\t\t\t\t    0, _RET_IP_);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_mount_local",
          "args": [
            "osb"
          ],
          "line": 3918
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_mount_local",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "668-671",
          "snippet": "static inline int ocfs2_mount_local(struct ocfs2_super *osb)\n{\n\treturn (osb->s_feature_incompat & OCFS2_FEATURE_INCOMPAT_LOCAL_MOUNT);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\nstatic inline int ocfs2_mount_local(struct ocfs2_super *osb)\n{\n\treturn (osb->s_feature_incompat & OCFS2_FEATURE_INCOMPAT_LOCAL_MOUNT);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_is_hard_readonly",
          "args": [
            "osb"
          ],
          "line": 3915
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_is_hard_readonly",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "615-624",
          "snippet": "static inline int ocfs2_is_hard_readonly(struct ocfs2_super *osb)\n{\n\tint ret;\n\n\tspin_lock(&osb->osb_lock);\n\tret = osb->osb_flags & OCFS2_OSB_HARD_RO;\n\tspin_unlock(&osb->osb_lock);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [
            "#define OCFS2_OSB_HARD_RO\t0x0002"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\n#define OCFS2_OSB_HARD_RO\t0x0002\n\nstatic inline int ocfs2_is_hard_readonly(struct ocfs2_super *osb)\n{\n\tint ret;\n\n\tspin_lock(&osb->osb_lock);\n\tret = osb->osb_flags & OCFS2_OSB_HARD_RO;\n\tspin_unlock(&osb->osb_lock);\n\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"stackglue.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dcache.h\"\n#include \"alloc.h\"\n#include \"ocfs2_lockingver.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/quotaops.h>\n#include <linux/time.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/pagemap.h>\n#include <linux/kthread.h>\n#include <linux/mm.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic struct ocfs2_super *ocfs2_get_dentry_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_inode_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_file_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_qinfo_osb(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_set_meta_lvb(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_dentry_post_unlock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres);\nstatic void ocfs2_set_qinfo_lvb(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_downconvert_action(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_convert_action(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_attach_action(struct ocfs2_lock_res *lockres);\nstatic int ocfs2_generic_handle_bast(struct ocfs2_lock_res *lockres, int level);\nstatic void ocfs2_schedule_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_downconvert_on_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_drop_osb_locks(struct ocfs2_super *osb);\nstatic inline int ocfs2_highest_compat_lock_level(int level);\nstatic int ocfs2_prepare_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\t        struct ocfs2_lock_res *lockres);\nstatic int ocfs2_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_process_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *lockres);\n\nint ocfs2_refcount_lock(struct ocfs2_refcount_tree *ref_tree, int ex)\n{\n\tint status;\n\tint level = ex ? DLM_LOCK_EX : DLM_LOCK_PR;\n\tstruct ocfs2_lock_res *lockres = &ref_tree->rf_lockres;\n\tstruct ocfs2_super *osb = lockres->l_priv;\n\n\n\tif (ocfs2_is_hard_readonly(osb))\n\t\treturn -EROFS;\n\n\tif (ocfs2_mount_local(osb))\n\t\treturn 0;\n\n\tstatus = ocfs2_cluster_lock(osb, lockres, level, 0, 0);\n\tif (status < 0)\n\t\tmlog_errno(status);\n\n\treturn status;\n}"
  },
  {
    "function_name": "ocfs2_qinfo_lock",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlmglue.c",
    "lines": "3875-3905",
    "snippet": "int ocfs2_qinfo_lock(struct ocfs2_mem_dqinfo *oinfo, int ex)\n{\n\tstruct ocfs2_lock_res *lockres = &oinfo->dqi_gqlock;\n\tstruct ocfs2_super *osb = OCFS2_SB(oinfo->dqi_gi.dqi_sb);\n\tint level = ex ? DLM_LOCK_EX : DLM_LOCK_PR;\n\tint status = 0;\n\n\t/* On RO devices, locking really isn't needed... */\n\tif (ocfs2_is_hard_readonly(osb)) {\n\t\tif (ex)\n\t\t\tstatus = -EROFS;\n\t\tgoto bail;\n\t}\n\tif (ocfs2_mount_local(osb))\n\t\tgoto bail;\n\n\tstatus = ocfs2_cluster_lock(osb, lockres, level, 0, 0);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\tif (!ocfs2_should_refresh_lock_res(lockres))\n\t\tgoto bail;\n\t/* OK, we have the lock but we need to refresh the quota info */\n\tstatus = ocfs2_refresh_qinfo(oinfo);\n\tif (status)\n\t\tocfs2_qinfo_unlock(oinfo, ex);\n\tocfs2_complete_lock_res_refresh(lockres, status);\nbail:\n\treturn status;\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"refcounttree.h\"",
      "#include \"quota.h\"",
      "#include \"uptodate.h\"",
      "#include \"super.h\"",
      "#include \"slot_map.h\"",
      "#include \"stackglue.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"heartbeat.h\"",
      "#include \"file.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"dcache.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2_lockingver.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/time.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/kthread.h>",
      "#include <linux/mm.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct ocfs2_super *ocfs2_get_dentry_osb(struct ocfs2_lock_res *lockres);",
      "static struct ocfs2_super *ocfs2_get_inode_osb(struct ocfs2_lock_res *lockres);",
      "static struct ocfs2_super *ocfs2_get_file_osb(struct ocfs2_lock_res *lockres);",
      "static struct ocfs2_super *ocfs2_get_qinfo_osb(struct ocfs2_lock_res *lockres);",
      "static void ocfs2_set_meta_lvb(struct ocfs2_lock_res *lockres);",
      "static void ocfs2_dentry_post_unlock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres);",
      "static void ocfs2_set_qinfo_lvb(struct ocfs2_lock_res *lockres);",
      "static inline void ocfs2_generic_handle_downconvert_action(struct ocfs2_lock_res *lockres);",
      "static inline void ocfs2_generic_handle_convert_action(struct ocfs2_lock_res *lockres);",
      "static inline void ocfs2_generic_handle_attach_action(struct ocfs2_lock_res *lockres);",
      "static int ocfs2_generic_handle_bast(struct ocfs2_lock_res *lockres, int level);",
      "static void ocfs2_schedule_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);",
      "static void ocfs2_downconvert_on_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);",
      "static void ocfs2_drop_osb_locks(struct ocfs2_super *osb);",
      "static inline int ocfs2_highest_compat_lock_level(int level);",
      "static int ocfs2_prepare_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\t        struct ocfs2_lock_res *lockres);",
      "static int ocfs2_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres);",
      "static void ocfs2_process_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *lockres);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ocfs2_complete_lock_res_refresh",
          "args": [
            "lockres",
            "status"
          ],
          "line": 3902
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_complete_lock_res_refresh",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlmglue.c",
          "lines": "2186-2198",
          "snippet": "static inline void ocfs2_complete_lock_res_refresh(struct ocfs2_lock_res *lockres,\n\t\t\t\t\t\t   int status)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&lockres->l_lock, flags);\n\tlockres_clear_flags(lockres, OCFS2_LOCK_REFRESHING);\n\tif (!status)\n\t\tlockres_clear_flags(lockres, OCFS2_LOCK_NEEDS_REFRESH);\n\tspin_unlock_irqrestore(&lockres->l_lock, flags);\n\n\twake_up(&lockres->l_event);\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"refcounttree.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"stackglue.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dcache.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2_lockingver.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/time.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/kthread.h>",
            "#include <linux/mm.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct ocfs2_super *ocfs2_get_dentry_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_inode_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_file_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_qinfo_osb(struct ocfs2_lock_res *lockres);",
            "static void ocfs2_set_meta_lvb(struct ocfs2_lock_res *lockres);",
            "static void ocfs2_dentry_post_unlock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres);",
            "static void ocfs2_set_qinfo_lvb(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_downconvert_action(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_convert_action(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_attach_action(struct ocfs2_lock_res *lockres);",
            "static void ocfs2_schedule_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static void ocfs2_downconvert_on_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static int ocfs2_prepare_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\t        struct ocfs2_lock_res *lockres);",
            "static int ocfs2_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static void ocfs2_process_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *lockres);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"stackglue.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dcache.h\"\n#include \"alloc.h\"\n#include \"ocfs2_lockingver.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/quotaops.h>\n#include <linux/time.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/pagemap.h>\n#include <linux/kthread.h>\n#include <linux/mm.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic struct ocfs2_super *ocfs2_get_dentry_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_inode_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_file_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_qinfo_osb(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_set_meta_lvb(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_dentry_post_unlock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres);\nstatic void ocfs2_set_qinfo_lvb(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_downconvert_action(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_convert_action(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_attach_action(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_schedule_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_downconvert_on_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic int ocfs2_prepare_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\t        struct ocfs2_lock_res *lockres);\nstatic int ocfs2_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_process_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *lockres);\n\nstatic inline void ocfs2_complete_lock_res_refresh(struct ocfs2_lock_res *lockres,\n\t\t\t\t\t\t   int status)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&lockres->l_lock, flags);\n\tlockres_clear_flags(lockres, OCFS2_LOCK_REFRESHING);\n\tif (!status)\n\t\tlockres_clear_flags(lockres, OCFS2_LOCK_NEEDS_REFRESH);\n\tspin_unlock_irqrestore(&lockres->l_lock, flags);\n\n\twake_up(&lockres->l_event);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_qinfo_unlock",
          "args": [
            "oinfo",
            "ex"
          ],
          "line": 3901
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_qinfo_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlmglue.c",
          "lines": "3820-3828",
          "snippet": "void ocfs2_qinfo_unlock(struct ocfs2_mem_dqinfo *oinfo, int ex)\n{\n\tstruct ocfs2_lock_res *lockres = &oinfo->dqi_gqlock;\n\tstruct ocfs2_super *osb = OCFS2_SB(oinfo->dqi_gi.dqi_sb);\n\tint level = ex ? DLM_LOCK_EX : DLM_LOCK_PR;\n\n\tif (!ocfs2_is_hard_readonly(osb) && !ocfs2_mount_local(osb))\n\t\tocfs2_cluster_unlock(osb, lockres, level);\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"refcounttree.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"stackglue.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dcache.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2_lockingver.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/time.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/kthread.h>",
            "#include <linux/mm.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct ocfs2_super *ocfs2_get_dentry_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_inode_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_file_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_qinfo_osb(struct ocfs2_lock_res *lockres);",
            "static void ocfs2_set_meta_lvb(struct ocfs2_lock_res *lockres);",
            "static void ocfs2_dentry_post_unlock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres);",
            "static void ocfs2_set_qinfo_lvb(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_downconvert_action(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_convert_action(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_attach_action(struct ocfs2_lock_res *lockres);",
            "static int ocfs2_generic_handle_bast(struct ocfs2_lock_res *lockres, int level);",
            "static void ocfs2_schedule_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static void ocfs2_downconvert_on_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static void ocfs2_drop_osb_locks(struct ocfs2_super *osb);",
            "static inline int ocfs2_highest_compat_lock_level(int level);",
            "static int ocfs2_prepare_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\t        struct ocfs2_lock_res *lockres);",
            "static int ocfs2_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static void ocfs2_process_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *lockres);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"stackglue.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dcache.h\"\n#include \"alloc.h\"\n#include \"ocfs2_lockingver.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/quotaops.h>\n#include <linux/time.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/pagemap.h>\n#include <linux/kthread.h>\n#include <linux/mm.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic struct ocfs2_super *ocfs2_get_dentry_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_inode_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_file_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_qinfo_osb(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_set_meta_lvb(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_dentry_post_unlock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres);\nstatic void ocfs2_set_qinfo_lvb(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_downconvert_action(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_convert_action(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_attach_action(struct ocfs2_lock_res *lockres);\nstatic int ocfs2_generic_handle_bast(struct ocfs2_lock_res *lockres, int level);\nstatic void ocfs2_schedule_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_downconvert_on_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_drop_osb_locks(struct ocfs2_super *osb);\nstatic inline int ocfs2_highest_compat_lock_level(int level);\nstatic int ocfs2_prepare_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\t        struct ocfs2_lock_res *lockres);\nstatic int ocfs2_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_process_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *lockres);\n\nvoid ocfs2_qinfo_unlock(struct ocfs2_mem_dqinfo *oinfo, int ex)\n{\n\tstruct ocfs2_lock_res *lockres = &oinfo->dqi_gqlock;\n\tstruct ocfs2_super *osb = OCFS2_SB(oinfo->dqi_gi.dqi_sb);\n\tint level = ex ? DLM_LOCK_EX : DLM_LOCK_PR;\n\n\tif (!ocfs2_is_hard_readonly(osb) && !ocfs2_mount_local(osb))\n\t\tocfs2_cluster_unlock(osb, lockres, level);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_refresh_qinfo",
          "args": [
            "oinfo"
          ],
          "line": 3899
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_refresh_qinfo",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlmglue.c",
          "lines": "3830-3871",
          "snippet": "static int ocfs2_refresh_qinfo(struct ocfs2_mem_dqinfo *oinfo)\n{\n\tstruct mem_dqinfo *info = sb_dqinfo(oinfo->dqi_gi.dqi_sb,\n\t\t\t\t\t    oinfo->dqi_gi.dqi_type);\n\tstruct ocfs2_lock_res *lockres = &oinfo->dqi_gqlock;\n\tstruct ocfs2_qinfo_lvb *lvb = ocfs2_dlm_lvb(&lockres->l_lksb);\n\tstruct buffer_head *bh = NULL;\n\tstruct ocfs2_global_disk_dqinfo *gdinfo;\n\tint status = 0;\n\n\tif (ocfs2_dlm_lvb_valid(&lockres->l_lksb) &&\n\t    lvb->lvb_version == OCFS2_QINFO_LVB_VERSION) {\n\t\tinfo->dqi_bgrace = be32_to_cpu(lvb->lvb_bgrace);\n\t\tinfo->dqi_igrace = be32_to_cpu(lvb->lvb_igrace);\n\t\toinfo->dqi_syncms = be32_to_cpu(lvb->lvb_syncms);\n\t\toinfo->dqi_gi.dqi_blocks = be32_to_cpu(lvb->lvb_blocks);\n\t\toinfo->dqi_gi.dqi_free_blk = be32_to_cpu(lvb->lvb_free_blk);\n\t\toinfo->dqi_gi.dqi_free_entry =\n\t\t\t\t\tbe32_to_cpu(lvb->lvb_free_entry);\n\t} else {\n\t\tstatus = ocfs2_read_quota_phys_block(oinfo->dqi_gqinode,\n\t\t\t\t\t\t     oinfo->dqi_giblk, &bh);\n\t\tif (status) {\n\t\t\tmlog_errno(status);\n\t\t\tgoto bail;\n\t\t}\n\t\tgdinfo = (struct ocfs2_global_disk_dqinfo *)\n\t\t\t\t\t(bh->b_data + OCFS2_GLOBAL_INFO_OFF);\n\t\tinfo->dqi_bgrace = le32_to_cpu(gdinfo->dqi_bgrace);\n\t\tinfo->dqi_igrace = le32_to_cpu(gdinfo->dqi_igrace);\n\t\toinfo->dqi_syncms = le32_to_cpu(gdinfo->dqi_syncms);\n\t\toinfo->dqi_gi.dqi_blocks = le32_to_cpu(gdinfo->dqi_blocks);\n\t\toinfo->dqi_gi.dqi_free_blk = le32_to_cpu(gdinfo->dqi_free_blk);\n\t\toinfo->dqi_gi.dqi_free_entry =\n\t\t\t\t\tle32_to_cpu(gdinfo->dqi_free_entry);\n\t\tbrelse(bh);\n\t\tocfs2_track_lock_refresh(lockres);\n\t}\n\nbail:\n\treturn status;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"refcounttree.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"stackglue.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dcache.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2_lockingver.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/time.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/kthread.h>",
            "#include <linux/mm.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct ocfs2_super *ocfs2_get_dentry_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_inode_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_file_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_qinfo_osb(struct ocfs2_lock_res *lockres);",
            "static void ocfs2_set_meta_lvb(struct ocfs2_lock_res *lockres);",
            "static void ocfs2_dentry_post_unlock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres);",
            "static void ocfs2_set_qinfo_lvb(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_downconvert_action(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_convert_action(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_attach_action(struct ocfs2_lock_res *lockres);",
            "static void ocfs2_schedule_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static void ocfs2_downconvert_on_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static int ocfs2_inode_lock_update(struct inode *inode,\n\t\t\t\t  struct buffer_head **bh);",
            "static int ocfs2_prepare_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\t        struct ocfs2_lock_res *lockres);",
            "static int ocfs2_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static void ocfs2_process_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *lockres);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"stackglue.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dcache.h\"\n#include \"alloc.h\"\n#include \"ocfs2_lockingver.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/quotaops.h>\n#include <linux/time.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/pagemap.h>\n#include <linux/kthread.h>\n#include <linux/mm.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic struct ocfs2_super *ocfs2_get_dentry_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_inode_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_file_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_qinfo_osb(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_set_meta_lvb(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_dentry_post_unlock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres);\nstatic void ocfs2_set_qinfo_lvb(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_downconvert_action(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_convert_action(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_attach_action(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_schedule_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_downconvert_on_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic int ocfs2_inode_lock_update(struct inode *inode,\n\t\t\t\t  struct buffer_head **bh);\nstatic int ocfs2_prepare_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\t        struct ocfs2_lock_res *lockres);\nstatic int ocfs2_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_process_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *lockres);\n\nstatic int ocfs2_refresh_qinfo(struct ocfs2_mem_dqinfo *oinfo)\n{\n\tstruct mem_dqinfo *info = sb_dqinfo(oinfo->dqi_gi.dqi_sb,\n\t\t\t\t\t    oinfo->dqi_gi.dqi_type);\n\tstruct ocfs2_lock_res *lockres = &oinfo->dqi_gqlock;\n\tstruct ocfs2_qinfo_lvb *lvb = ocfs2_dlm_lvb(&lockres->l_lksb);\n\tstruct buffer_head *bh = NULL;\n\tstruct ocfs2_global_disk_dqinfo *gdinfo;\n\tint status = 0;\n\n\tif (ocfs2_dlm_lvb_valid(&lockres->l_lksb) &&\n\t    lvb->lvb_version == OCFS2_QINFO_LVB_VERSION) {\n\t\tinfo->dqi_bgrace = be32_to_cpu(lvb->lvb_bgrace);\n\t\tinfo->dqi_igrace = be32_to_cpu(lvb->lvb_igrace);\n\t\toinfo->dqi_syncms = be32_to_cpu(lvb->lvb_syncms);\n\t\toinfo->dqi_gi.dqi_blocks = be32_to_cpu(lvb->lvb_blocks);\n\t\toinfo->dqi_gi.dqi_free_blk = be32_to_cpu(lvb->lvb_free_blk);\n\t\toinfo->dqi_gi.dqi_free_entry =\n\t\t\t\t\tbe32_to_cpu(lvb->lvb_free_entry);\n\t} else {\n\t\tstatus = ocfs2_read_quota_phys_block(oinfo->dqi_gqinode,\n\t\t\t\t\t\t     oinfo->dqi_giblk, &bh);\n\t\tif (status) {\n\t\t\tmlog_errno(status);\n\t\t\tgoto bail;\n\t\t}\n\t\tgdinfo = (struct ocfs2_global_disk_dqinfo *)\n\t\t\t\t\t(bh->b_data + OCFS2_GLOBAL_INFO_OFF);\n\t\tinfo->dqi_bgrace = le32_to_cpu(gdinfo->dqi_bgrace);\n\t\tinfo->dqi_igrace = le32_to_cpu(gdinfo->dqi_igrace);\n\t\toinfo->dqi_syncms = le32_to_cpu(gdinfo->dqi_syncms);\n\t\toinfo->dqi_gi.dqi_blocks = le32_to_cpu(gdinfo->dqi_blocks);\n\t\toinfo->dqi_gi.dqi_free_blk = le32_to_cpu(gdinfo->dqi_free_blk);\n\t\toinfo->dqi_gi.dqi_free_entry =\n\t\t\t\t\tle32_to_cpu(gdinfo->dqi_free_entry);\n\t\tbrelse(bh);\n\t\tocfs2_track_lock_refresh(lockres);\n\t}\n\nbail:\n\treturn status;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_should_refresh_lock_res",
          "args": [
            "lockres"
          ],
          "line": 3896
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_should_refresh_lock_res",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlmglue.c",
          "lines": "2155-2182",
          "snippet": "static int ocfs2_should_refresh_lock_res(struct ocfs2_lock_res *lockres)\n{\n\tunsigned long flags;\n\tint status = 0;\n\nrefresh_check:\n\tspin_lock_irqsave(&lockres->l_lock, flags);\n\tif (!(lockres->l_flags & OCFS2_LOCK_NEEDS_REFRESH)) {\n\t\tspin_unlock_irqrestore(&lockres->l_lock, flags);\n\t\tgoto bail;\n\t}\n\n\tif (lockres->l_flags & OCFS2_LOCK_REFRESHING) {\n\t\tspin_unlock_irqrestore(&lockres->l_lock, flags);\n\n\t\tocfs2_wait_on_refreshing_lock(lockres);\n\t\tgoto refresh_check;\n\t}\n\n\t/* Ok, I'll be the one to refresh this lock. */\n\tlockres_or_flags(lockres, OCFS2_LOCK_REFRESHING);\n\tspin_unlock_irqrestore(&lockres->l_lock, flags);\n\n\tstatus = 1;\nbail:\n\tmlog(0, \"status %d\\n\", status);\n\treturn status;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"refcounttree.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"stackglue.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dcache.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2_lockingver.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/time.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/kthread.h>",
            "#include <linux/mm.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct ocfs2_super *ocfs2_get_dentry_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_inode_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_file_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_qinfo_osb(struct ocfs2_lock_res *lockres);",
            "static void ocfs2_set_meta_lvb(struct ocfs2_lock_res *lockres);",
            "static void ocfs2_dentry_post_unlock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres);",
            "static void ocfs2_set_qinfo_lvb(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_downconvert_action(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_convert_action(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_attach_action(struct ocfs2_lock_res *lockres);",
            "static void ocfs2_schedule_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static void ocfs2_downconvert_on_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static int ocfs2_prepare_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\t        struct ocfs2_lock_res *lockres);",
            "static int ocfs2_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static void ocfs2_process_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *lockres);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"stackglue.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dcache.h\"\n#include \"alloc.h\"\n#include \"ocfs2_lockingver.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/quotaops.h>\n#include <linux/time.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/pagemap.h>\n#include <linux/kthread.h>\n#include <linux/mm.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic struct ocfs2_super *ocfs2_get_dentry_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_inode_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_file_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_qinfo_osb(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_set_meta_lvb(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_dentry_post_unlock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres);\nstatic void ocfs2_set_qinfo_lvb(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_downconvert_action(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_convert_action(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_attach_action(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_schedule_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_downconvert_on_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic int ocfs2_prepare_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\t        struct ocfs2_lock_res *lockres);\nstatic int ocfs2_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_process_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *lockres);\n\nstatic int ocfs2_should_refresh_lock_res(struct ocfs2_lock_res *lockres)\n{\n\tunsigned long flags;\n\tint status = 0;\n\nrefresh_check:\n\tspin_lock_irqsave(&lockres->l_lock, flags);\n\tif (!(lockres->l_flags & OCFS2_LOCK_NEEDS_REFRESH)) {\n\t\tspin_unlock_irqrestore(&lockres->l_lock, flags);\n\t\tgoto bail;\n\t}\n\n\tif (lockres->l_flags & OCFS2_LOCK_REFRESHING) {\n\t\tspin_unlock_irqrestore(&lockres->l_lock, flags);\n\n\t\tocfs2_wait_on_refreshing_lock(lockres);\n\t\tgoto refresh_check;\n\t}\n\n\t/* Ok, I'll be the one to refresh this lock. */\n\tlockres_or_flags(lockres, OCFS2_LOCK_REFRESHING);\n\tspin_unlock_irqrestore(&lockres->l_lock, flags);\n\n\tstatus = 1;\nbail:\n\tmlog(0, \"status %d\\n\", status);\n\treturn status;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "status"
          ],
          "line": 3893
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_cluster_lock",
          "args": [
            "osb",
            "lockres",
            "level",
            "0",
            "0"
          ],
          "line": 3891
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_cluster_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlmglue.c",
          "lines": "1570-1578",
          "snippet": "static inline int ocfs2_cluster_lock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres,\n\t\t\t\t     int level,\n\t\t\t\t     u32 lkm_flags,\n\t\t\t\t     int arg_flags)\n{\n\treturn __ocfs2_cluster_lock(osb, lockres, level, lkm_flags, arg_flags,\n\t\t\t\t    0, _RET_IP_);\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"refcounttree.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"stackglue.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dcache.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2_lockingver.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/time.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/kthread.h>",
            "#include <linux/mm.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct ocfs2_super *ocfs2_get_dentry_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_inode_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_file_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_qinfo_osb(struct ocfs2_lock_res *lockres);",
            "static void ocfs2_set_meta_lvb(struct ocfs2_lock_res *lockres);",
            "static void ocfs2_dentry_post_unlock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres);",
            "static void ocfs2_set_qinfo_lvb(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_downconvert_action(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_convert_action(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_attach_action(struct ocfs2_lock_res *lockres);",
            "static int ocfs2_generic_handle_bast(struct ocfs2_lock_res *lockres, int level);",
            "static void ocfs2_schedule_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static void ocfs2_downconvert_on_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static void ocfs2_drop_osb_locks(struct ocfs2_super *osb);",
            "static inline int ocfs2_highest_compat_lock_level(int level);",
            "static int ocfs2_prepare_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\t        struct ocfs2_lock_res *lockres);",
            "static int ocfs2_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static void ocfs2_process_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *lockres);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"stackglue.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dcache.h\"\n#include \"alloc.h\"\n#include \"ocfs2_lockingver.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/quotaops.h>\n#include <linux/time.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/pagemap.h>\n#include <linux/kthread.h>\n#include <linux/mm.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic struct ocfs2_super *ocfs2_get_dentry_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_inode_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_file_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_qinfo_osb(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_set_meta_lvb(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_dentry_post_unlock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres);\nstatic void ocfs2_set_qinfo_lvb(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_downconvert_action(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_convert_action(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_attach_action(struct ocfs2_lock_res *lockres);\nstatic int ocfs2_generic_handle_bast(struct ocfs2_lock_res *lockres, int level);\nstatic void ocfs2_schedule_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_downconvert_on_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_drop_osb_locks(struct ocfs2_super *osb);\nstatic inline int ocfs2_highest_compat_lock_level(int level);\nstatic int ocfs2_prepare_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\t        struct ocfs2_lock_res *lockres);\nstatic int ocfs2_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_process_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *lockres);\n\nstatic inline int ocfs2_cluster_lock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres,\n\t\t\t\t     int level,\n\t\t\t\t     u32 lkm_flags,\n\t\t\t\t     int arg_flags)\n{\n\treturn __ocfs2_cluster_lock(osb, lockres, level, lkm_flags, arg_flags,\n\t\t\t\t    0, _RET_IP_);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_mount_local",
          "args": [
            "osb"
          ],
          "line": 3888
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_mount_local",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "668-671",
          "snippet": "static inline int ocfs2_mount_local(struct ocfs2_super *osb)\n{\n\treturn (osb->s_feature_incompat & OCFS2_FEATURE_INCOMPAT_LOCAL_MOUNT);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\nstatic inline int ocfs2_mount_local(struct ocfs2_super *osb)\n{\n\treturn (osb->s_feature_incompat & OCFS2_FEATURE_INCOMPAT_LOCAL_MOUNT);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_is_hard_readonly",
          "args": [
            "osb"
          ],
          "line": 3883
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_is_hard_readonly",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "615-624",
          "snippet": "static inline int ocfs2_is_hard_readonly(struct ocfs2_super *osb)\n{\n\tint ret;\n\n\tspin_lock(&osb->osb_lock);\n\tret = osb->osb_flags & OCFS2_OSB_HARD_RO;\n\tspin_unlock(&osb->osb_lock);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [
            "#define OCFS2_OSB_HARD_RO\t0x0002"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\n#define OCFS2_OSB_HARD_RO\t0x0002\n\nstatic inline int ocfs2_is_hard_readonly(struct ocfs2_super *osb)\n{\n\tint ret;\n\n\tspin_lock(&osb->osb_lock);\n\tret = osb->osb_flags & OCFS2_OSB_HARD_RO;\n\tspin_unlock(&osb->osb_lock);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "OCFS2_SB",
          "args": [
            "oinfo->dqi_gi.dqi_sb"
          ],
          "line": 3878
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"stackglue.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dcache.h\"\n#include \"alloc.h\"\n#include \"ocfs2_lockingver.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/quotaops.h>\n#include <linux/time.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/pagemap.h>\n#include <linux/kthread.h>\n#include <linux/mm.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic struct ocfs2_super *ocfs2_get_dentry_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_inode_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_file_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_qinfo_osb(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_set_meta_lvb(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_dentry_post_unlock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres);\nstatic void ocfs2_set_qinfo_lvb(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_downconvert_action(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_convert_action(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_attach_action(struct ocfs2_lock_res *lockres);\nstatic int ocfs2_generic_handle_bast(struct ocfs2_lock_res *lockres, int level);\nstatic void ocfs2_schedule_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_downconvert_on_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_drop_osb_locks(struct ocfs2_super *osb);\nstatic inline int ocfs2_highest_compat_lock_level(int level);\nstatic int ocfs2_prepare_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\t        struct ocfs2_lock_res *lockres);\nstatic int ocfs2_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_process_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *lockres);\n\nint ocfs2_qinfo_lock(struct ocfs2_mem_dqinfo *oinfo, int ex)\n{\n\tstruct ocfs2_lock_res *lockres = &oinfo->dqi_gqlock;\n\tstruct ocfs2_super *osb = OCFS2_SB(oinfo->dqi_gi.dqi_sb);\n\tint level = ex ? DLM_LOCK_EX : DLM_LOCK_PR;\n\tint status = 0;\n\n\t/* On RO devices, locking really isn't needed... */\n\tif (ocfs2_is_hard_readonly(osb)) {\n\t\tif (ex)\n\t\t\tstatus = -EROFS;\n\t\tgoto bail;\n\t}\n\tif (ocfs2_mount_local(osb))\n\t\tgoto bail;\n\n\tstatus = ocfs2_cluster_lock(osb, lockres, level, 0, 0);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\tif (!ocfs2_should_refresh_lock_res(lockres))\n\t\tgoto bail;\n\t/* OK, we have the lock but we need to refresh the quota info */\n\tstatus = ocfs2_refresh_qinfo(oinfo);\n\tif (status)\n\t\tocfs2_qinfo_unlock(oinfo, ex);\n\tocfs2_complete_lock_res_refresh(lockres, status);\nbail:\n\treturn status;\n}"
  },
  {
    "function_name": "ocfs2_refresh_qinfo",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlmglue.c",
    "lines": "3830-3871",
    "snippet": "static int ocfs2_refresh_qinfo(struct ocfs2_mem_dqinfo *oinfo)\n{\n\tstruct mem_dqinfo *info = sb_dqinfo(oinfo->dqi_gi.dqi_sb,\n\t\t\t\t\t    oinfo->dqi_gi.dqi_type);\n\tstruct ocfs2_lock_res *lockres = &oinfo->dqi_gqlock;\n\tstruct ocfs2_qinfo_lvb *lvb = ocfs2_dlm_lvb(&lockres->l_lksb);\n\tstruct buffer_head *bh = NULL;\n\tstruct ocfs2_global_disk_dqinfo *gdinfo;\n\tint status = 0;\n\n\tif (ocfs2_dlm_lvb_valid(&lockres->l_lksb) &&\n\t    lvb->lvb_version == OCFS2_QINFO_LVB_VERSION) {\n\t\tinfo->dqi_bgrace = be32_to_cpu(lvb->lvb_bgrace);\n\t\tinfo->dqi_igrace = be32_to_cpu(lvb->lvb_igrace);\n\t\toinfo->dqi_syncms = be32_to_cpu(lvb->lvb_syncms);\n\t\toinfo->dqi_gi.dqi_blocks = be32_to_cpu(lvb->lvb_blocks);\n\t\toinfo->dqi_gi.dqi_free_blk = be32_to_cpu(lvb->lvb_free_blk);\n\t\toinfo->dqi_gi.dqi_free_entry =\n\t\t\t\t\tbe32_to_cpu(lvb->lvb_free_entry);\n\t} else {\n\t\tstatus = ocfs2_read_quota_phys_block(oinfo->dqi_gqinode,\n\t\t\t\t\t\t     oinfo->dqi_giblk, &bh);\n\t\tif (status) {\n\t\t\tmlog_errno(status);\n\t\t\tgoto bail;\n\t\t}\n\t\tgdinfo = (struct ocfs2_global_disk_dqinfo *)\n\t\t\t\t\t(bh->b_data + OCFS2_GLOBAL_INFO_OFF);\n\t\tinfo->dqi_bgrace = le32_to_cpu(gdinfo->dqi_bgrace);\n\t\tinfo->dqi_igrace = le32_to_cpu(gdinfo->dqi_igrace);\n\t\toinfo->dqi_syncms = le32_to_cpu(gdinfo->dqi_syncms);\n\t\toinfo->dqi_gi.dqi_blocks = le32_to_cpu(gdinfo->dqi_blocks);\n\t\toinfo->dqi_gi.dqi_free_blk = le32_to_cpu(gdinfo->dqi_free_blk);\n\t\toinfo->dqi_gi.dqi_free_entry =\n\t\t\t\t\tle32_to_cpu(gdinfo->dqi_free_entry);\n\t\tbrelse(bh);\n\t\tocfs2_track_lock_refresh(lockres);\n\t}\n\nbail:\n\treturn status;\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"refcounttree.h\"",
      "#include \"quota.h\"",
      "#include \"uptodate.h\"",
      "#include \"super.h\"",
      "#include \"slot_map.h\"",
      "#include \"stackglue.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"heartbeat.h\"",
      "#include \"file.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"dcache.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2_lockingver.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/time.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/kthread.h>",
      "#include <linux/mm.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct ocfs2_super *ocfs2_get_dentry_osb(struct ocfs2_lock_res *lockres);",
      "static struct ocfs2_super *ocfs2_get_inode_osb(struct ocfs2_lock_res *lockres);",
      "static struct ocfs2_super *ocfs2_get_file_osb(struct ocfs2_lock_res *lockres);",
      "static struct ocfs2_super *ocfs2_get_qinfo_osb(struct ocfs2_lock_res *lockres);",
      "static void ocfs2_set_meta_lvb(struct ocfs2_lock_res *lockres);",
      "static void ocfs2_dentry_post_unlock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres);",
      "static void ocfs2_set_qinfo_lvb(struct ocfs2_lock_res *lockres);",
      "static inline void ocfs2_generic_handle_downconvert_action(struct ocfs2_lock_res *lockres);",
      "static inline void ocfs2_generic_handle_convert_action(struct ocfs2_lock_res *lockres);",
      "static inline void ocfs2_generic_handle_attach_action(struct ocfs2_lock_res *lockres);",
      "static void ocfs2_schedule_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);",
      "static void ocfs2_downconvert_on_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);",
      "static int ocfs2_inode_lock_update(struct inode *inode,\n\t\t\t\t  struct buffer_head **bh);",
      "static int ocfs2_prepare_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\t        struct ocfs2_lock_res *lockres);",
      "static int ocfs2_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres);",
      "static void ocfs2_process_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *lockres);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ocfs2_track_lock_refresh",
          "args": [
            "lockres"
          ],
          "line": 3866
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_track_lock_refresh",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlmglue.c",
          "lines": "488-490",
          "snippet": "static inline void ocfs2_track_lock_refresh(struct ocfs2_lock_res *lockres)\n{\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"refcounttree.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"stackglue.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dcache.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2_lockingver.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/time.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/kthread.h>",
            "#include <linux/mm.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct ocfs2_super *ocfs2_get_dentry_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_inode_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_file_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_qinfo_osb(struct ocfs2_lock_res *lockres);",
            "static void ocfs2_set_meta_lvb(struct ocfs2_lock_res *lockres);",
            "static void ocfs2_dentry_post_unlock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres);",
            "static void ocfs2_set_qinfo_lvb(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_downconvert_action(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_convert_action(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_attach_action(struct ocfs2_lock_res *lockres);",
            "static void ocfs2_schedule_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static void ocfs2_downconvert_on_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static int ocfs2_prepare_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\t        struct ocfs2_lock_res *lockres);",
            "static int ocfs2_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static void ocfs2_process_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *lockres);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"stackglue.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dcache.h\"\n#include \"alloc.h\"\n#include \"ocfs2_lockingver.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/quotaops.h>\n#include <linux/time.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/pagemap.h>\n#include <linux/kthread.h>\n#include <linux/mm.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic struct ocfs2_super *ocfs2_get_dentry_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_inode_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_file_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_qinfo_osb(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_set_meta_lvb(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_dentry_post_unlock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres);\nstatic void ocfs2_set_qinfo_lvb(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_downconvert_action(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_convert_action(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_attach_action(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_schedule_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_downconvert_on_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic int ocfs2_prepare_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\t        struct ocfs2_lock_res *lockres);\nstatic int ocfs2_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_process_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *lockres);\n\nstatic inline void ocfs2_track_lock_refresh(struct ocfs2_lock_res *lockres)\n{\n}"
        }
      },
      {
        "call_info": {
          "callee": "brelse",
          "args": [
            "bh"
          ],
          "line": 3865
        },
        "resolved": true,
        "details": {
          "function_name": "__brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1177-1184",
          "snippet": "void __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "gdinfo->dqi_free_entry"
          ],
          "line": 3864
        },
        "resolved": true,
        "details": {
          "function_name": "sle32_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "53-56",
          "snippet": "static inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "status"
          ],
          "line": 3853
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_read_quota_phys_block",
          "args": [
            "oinfo->dqi_gqinode",
            "oinfo->dqi_giblk",
            "&bh"
          ],
          "line": 3850
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_read_quota_phys_block",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/quota_global.c",
          "lines": "149-160",
          "snippet": "int ocfs2_read_quota_phys_block(struct inode *inode, u64 p_block,\n\t\t\t\tstruct buffer_head **bhp)\n{\n\tint rc;\n\n\t*bhp = NULL;\n\trc = ocfs2_read_blocks(INODE_CACHE(inode), p_block, 1, bhp, 0,\n\t\t\t       ocfs2_validate_quota_block);\n\tif (rc)\n\t\tmlog_errno(rc);\n\treturn rc;\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"quota.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"super.h\"",
            "#include \"uptodate.h\"",
            "#include \"dlmglue.h\"",
            "#include \"sysfile.h\"",
            "#include \"file.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/llist.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/writeback.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/dqblk_qtree.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/quota.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"quota.h\"\n#include \"buffer_head_io.h\"\n#include \"super.h\"\n#include \"uptodate.h\"\n#include \"dlmglue.h\"\n#include \"sysfile.h\"\n#include \"file.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include \"ocfs2_fs.h\"\n#include <cluster/masklog.h>\n#include <linux/llist.h>\n#include <linux/workqueue.h>\n#include <linux/writeback.h>\n#include <linux/jiffies.h>\n#include <linux/dqblk_qtree.h>\n#include <linux/quotaops.h>\n#include <linux/quota.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/spinlock.h>\n\nint ocfs2_read_quota_phys_block(struct inode *inode, u64 p_block,\n\t\t\t\tstruct buffer_head **bhp)\n{\n\tint rc;\n\n\t*bhp = NULL;\n\trc = ocfs2_read_blocks(INODE_CACHE(inode), p_block, 1, bhp, 0,\n\t\t\t       ocfs2_validate_quota_block);\n\tif (rc)\n\t\tmlog_errno(rc);\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "lvb->lvb_free_entry"
          ],
          "line": 3848
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "lvb->lvb_free_blk"
          ],
          "line": 3846
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "lvb->lvb_blocks"
          ],
          "line": 3845
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "lvb->lvb_syncms"
          ],
          "line": 3844
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "lvb->lvb_igrace"
          ],
          "line": 3843
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "lvb->lvb_bgrace"
          ],
          "line": 3842
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_dlm_lvb_valid",
          "args": [
            "&lockres->l_lksb"
          ],
          "line": 3840
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_dlm_lvb_valid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/stackglue.c",
          "lines": "273-276",
          "snippet": "int ocfs2_dlm_lvb_valid(struct ocfs2_dlm_lksb *lksb)\n{\n\treturn active_stack->sp_ops->lvb_valid(lksb);\n}",
          "includes": [
            "#include \"stackglue.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include <linux/sysctl.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/fs.h>",
            "#include <linux/kmod.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/list.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct ocfs2_stack_plugin *active_stack;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"stackglue.h\"\n#include \"ocfs2_fs.h\"\n#include <linux/sysctl.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/fs.h>\n#include <linux/kmod.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/spinlock.h>\n#include <linux/list.h>\n\nstatic struct ocfs2_stack_plugin *active_stack;\n\nint ocfs2_dlm_lvb_valid(struct ocfs2_dlm_lksb *lksb)\n{\n\treturn active_stack->sp_ops->lvb_valid(lksb);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_dlm_lvb",
          "args": [
            "&lockres->l_lksb"
          ],
          "line": 3835
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_dlm_lvb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/stackglue.c",
          "lines": "279-282",
          "snippet": "void *ocfs2_dlm_lvb(struct ocfs2_dlm_lksb *lksb)\n{\n\treturn active_stack->sp_ops->lock_lvb(lksb);\n}",
          "includes": [
            "#include \"stackglue.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include <linux/sysctl.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/fs.h>",
            "#include <linux/kmod.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/list.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct ocfs2_stack_plugin *active_stack;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"stackglue.h\"\n#include \"ocfs2_fs.h\"\n#include <linux/sysctl.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/fs.h>\n#include <linux/kmod.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/spinlock.h>\n#include <linux/list.h>\n\nstatic struct ocfs2_stack_plugin *active_stack;\n\nvoid *ocfs2_dlm_lvb(struct ocfs2_dlm_lksb *lksb)\n{\n\treturn active_stack->sp_ops->lock_lvb(lksb);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sb_dqinfo",
          "args": [
            "oinfo->dqi_gi.dqi_sb",
            "oinfo->dqi_gi.dqi_type"
          ],
          "line": 3832
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"stackglue.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dcache.h\"\n#include \"alloc.h\"\n#include \"ocfs2_lockingver.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/quotaops.h>\n#include <linux/time.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/pagemap.h>\n#include <linux/kthread.h>\n#include <linux/mm.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic struct ocfs2_super *ocfs2_get_dentry_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_inode_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_file_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_qinfo_osb(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_set_meta_lvb(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_dentry_post_unlock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres);\nstatic void ocfs2_set_qinfo_lvb(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_downconvert_action(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_convert_action(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_attach_action(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_schedule_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_downconvert_on_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic int ocfs2_inode_lock_update(struct inode *inode,\n\t\t\t\t  struct buffer_head **bh);\nstatic int ocfs2_prepare_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\t        struct ocfs2_lock_res *lockres);\nstatic int ocfs2_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_process_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *lockres);\n\nstatic int ocfs2_refresh_qinfo(struct ocfs2_mem_dqinfo *oinfo)\n{\n\tstruct mem_dqinfo *info = sb_dqinfo(oinfo->dqi_gi.dqi_sb,\n\t\t\t\t\t    oinfo->dqi_gi.dqi_type);\n\tstruct ocfs2_lock_res *lockres = &oinfo->dqi_gqlock;\n\tstruct ocfs2_qinfo_lvb *lvb = ocfs2_dlm_lvb(&lockres->l_lksb);\n\tstruct buffer_head *bh = NULL;\n\tstruct ocfs2_global_disk_dqinfo *gdinfo;\n\tint status = 0;\n\n\tif (ocfs2_dlm_lvb_valid(&lockres->l_lksb) &&\n\t    lvb->lvb_version == OCFS2_QINFO_LVB_VERSION) {\n\t\tinfo->dqi_bgrace = be32_to_cpu(lvb->lvb_bgrace);\n\t\tinfo->dqi_igrace = be32_to_cpu(lvb->lvb_igrace);\n\t\toinfo->dqi_syncms = be32_to_cpu(lvb->lvb_syncms);\n\t\toinfo->dqi_gi.dqi_blocks = be32_to_cpu(lvb->lvb_blocks);\n\t\toinfo->dqi_gi.dqi_free_blk = be32_to_cpu(lvb->lvb_free_blk);\n\t\toinfo->dqi_gi.dqi_free_entry =\n\t\t\t\t\tbe32_to_cpu(lvb->lvb_free_entry);\n\t} else {\n\t\tstatus = ocfs2_read_quota_phys_block(oinfo->dqi_gqinode,\n\t\t\t\t\t\t     oinfo->dqi_giblk, &bh);\n\t\tif (status) {\n\t\t\tmlog_errno(status);\n\t\t\tgoto bail;\n\t\t}\n\t\tgdinfo = (struct ocfs2_global_disk_dqinfo *)\n\t\t\t\t\t(bh->b_data + OCFS2_GLOBAL_INFO_OFF);\n\t\tinfo->dqi_bgrace = le32_to_cpu(gdinfo->dqi_bgrace);\n\t\tinfo->dqi_igrace = le32_to_cpu(gdinfo->dqi_igrace);\n\t\toinfo->dqi_syncms = le32_to_cpu(gdinfo->dqi_syncms);\n\t\toinfo->dqi_gi.dqi_blocks = le32_to_cpu(gdinfo->dqi_blocks);\n\t\toinfo->dqi_gi.dqi_free_blk = le32_to_cpu(gdinfo->dqi_free_blk);\n\t\toinfo->dqi_gi.dqi_free_entry =\n\t\t\t\t\tle32_to_cpu(gdinfo->dqi_free_entry);\n\t\tbrelse(bh);\n\t\tocfs2_track_lock_refresh(lockres);\n\t}\n\nbail:\n\treturn status;\n}"
  },
  {
    "function_name": "ocfs2_qinfo_unlock",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlmglue.c",
    "lines": "3820-3828",
    "snippet": "void ocfs2_qinfo_unlock(struct ocfs2_mem_dqinfo *oinfo, int ex)\n{\n\tstruct ocfs2_lock_res *lockres = &oinfo->dqi_gqlock;\n\tstruct ocfs2_super *osb = OCFS2_SB(oinfo->dqi_gi.dqi_sb);\n\tint level = ex ? DLM_LOCK_EX : DLM_LOCK_PR;\n\n\tif (!ocfs2_is_hard_readonly(osb) && !ocfs2_mount_local(osb))\n\t\tocfs2_cluster_unlock(osb, lockres, level);\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"refcounttree.h\"",
      "#include \"quota.h\"",
      "#include \"uptodate.h\"",
      "#include \"super.h\"",
      "#include \"slot_map.h\"",
      "#include \"stackglue.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"heartbeat.h\"",
      "#include \"file.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"dcache.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2_lockingver.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/time.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/kthread.h>",
      "#include <linux/mm.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct ocfs2_super *ocfs2_get_dentry_osb(struct ocfs2_lock_res *lockres);",
      "static struct ocfs2_super *ocfs2_get_inode_osb(struct ocfs2_lock_res *lockres);",
      "static struct ocfs2_super *ocfs2_get_file_osb(struct ocfs2_lock_res *lockres);",
      "static struct ocfs2_super *ocfs2_get_qinfo_osb(struct ocfs2_lock_res *lockres);",
      "static void ocfs2_set_meta_lvb(struct ocfs2_lock_res *lockres);",
      "static void ocfs2_dentry_post_unlock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres);",
      "static void ocfs2_set_qinfo_lvb(struct ocfs2_lock_res *lockres);",
      "static inline void ocfs2_generic_handle_downconvert_action(struct ocfs2_lock_res *lockres);",
      "static inline void ocfs2_generic_handle_convert_action(struct ocfs2_lock_res *lockres);",
      "static inline void ocfs2_generic_handle_attach_action(struct ocfs2_lock_res *lockres);",
      "static int ocfs2_generic_handle_bast(struct ocfs2_lock_res *lockres, int level);",
      "static void ocfs2_schedule_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);",
      "static void ocfs2_downconvert_on_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);",
      "static void ocfs2_drop_osb_locks(struct ocfs2_super *osb);",
      "static inline int ocfs2_highest_compat_lock_level(int level);",
      "static int ocfs2_prepare_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\t        struct ocfs2_lock_res *lockres);",
      "static int ocfs2_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres);",
      "static void ocfs2_process_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *lockres);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ocfs2_cluster_unlock",
          "args": [
            "osb",
            "lockres",
            "level"
          ],
          "line": 3827
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_cluster_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlmglue.c",
          "lines": "349-354",
          "snippet": "static inline void ocfs2_cluster_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres,\n\t\t\t\t\tint level)\n{\n\t__ocfs2_cluster_unlock(osb, lockres, level, _RET_IP_);\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"refcounttree.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"stackglue.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dcache.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2_lockingver.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/time.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/kthread.h>",
            "#include <linux/mm.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct ocfs2_super *ocfs2_get_dentry_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_inode_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_file_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_qinfo_osb(struct ocfs2_lock_res *lockres);",
            "static void ocfs2_set_meta_lvb(struct ocfs2_lock_res *lockres);",
            "static void ocfs2_dentry_post_unlock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres);",
            "static void ocfs2_set_qinfo_lvb(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_downconvert_action(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_convert_action(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_attach_action(struct ocfs2_lock_res *lockres);",
            "static int ocfs2_generic_handle_bast(struct ocfs2_lock_res *lockres, int level);",
            "static void ocfs2_schedule_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static void ocfs2_downconvert_on_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static void ocfs2_drop_osb_locks(struct ocfs2_super *osb);",
            "static inline int ocfs2_highest_compat_lock_level(int level);",
            "static int ocfs2_prepare_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\t        struct ocfs2_lock_res *lockres);",
            "static int ocfs2_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static void ocfs2_process_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *lockres);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"stackglue.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dcache.h\"\n#include \"alloc.h\"\n#include \"ocfs2_lockingver.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/quotaops.h>\n#include <linux/time.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/pagemap.h>\n#include <linux/kthread.h>\n#include <linux/mm.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic struct ocfs2_super *ocfs2_get_dentry_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_inode_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_file_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_qinfo_osb(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_set_meta_lvb(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_dentry_post_unlock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres);\nstatic void ocfs2_set_qinfo_lvb(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_downconvert_action(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_convert_action(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_attach_action(struct ocfs2_lock_res *lockres);\nstatic int ocfs2_generic_handle_bast(struct ocfs2_lock_res *lockres, int level);\nstatic void ocfs2_schedule_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_downconvert_on_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_drop_osb_locks(struct ocfs2_super *osb);\nstatic inline int ocfs2_highest_compat_lock_level(int level);\nstatic int ocfs2_prepare_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\t        struct ocfs2_lock_res *lockres);\nstatic int ocfs2_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_process_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *lockres);\n\nstatic inline void ocfs2_cluster_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres,\n\t\t\t\t\tint level)\n{\n\t__ocfs2_cluster_unlock(osb, lockres, level, _RET_IP_);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_mount_local",
          "args": [
            "osb"
          ],
          "line": 3826
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_mount_local",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "668-671",
          "snippet": "static inline int ocfs2_mount_local(struct ocfs2_super *osb)\n{\n\treturn (osb->s_feature_incompat & OCFS2_FEATURE_INCOMPAT_LOCAL_MOUNT);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\nstatic inline int ocfs2_mount_local(struct ocfs2_super *osb)\n{\n\treturn (osb->s_feature_incompat & OCFS2_FEATURE_INCOMPAT_LOCAL_MOUNT);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_is_hard_readonly",
          "args": [
            "osb"
          ],
          "line": 3826
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_is_hard_readonly",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "615-624",
          "snippet": "static inline int ocfs2_is_hard_readonly(struct ocfs2_super *osb)\n{\n\tint ret;\n\n\tspin_lock(&osb->osb_lock);\n\tret = osb->osb_flags & OCFS2_OSB_HARD_RO;\n\tspin_unlock(&osb->osb_lock);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [
            "#define OCFS2_OSB_HARD_RO\t0x0002"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\n#define OCFS2_OSB_HARD_RO\t0x0002\n\nstatic inline int ocfs2_is_hard_readonly(struct ocfs2_super *osb)\n{\n\tint ret;\n\n\tspin_lock(&osb->osb_lock);\n\tret = osb->osb_flags & OCFS2_OSB_HARD_RO;\n\tspin_unlock(&osb->osb_lock);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "OCFS2_SB",
          "args": [
            "oinfo->dqi_gi.dqi_sb"
          ],
          "line": 3823
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"stackglue.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dcache.h\"\n#include \"alloc.h\"\n#include \"ocfs2_lockingver.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/quotaops.h>\n#include <linux/time.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/pagemap.h>\n#include <linux/kthread.h>\n#include <linux/mm.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic struct ocfs2_super *ocfs2_get_dentry_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_inode_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_file_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_qinfo_osb(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_set_meta_lvb(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_dentry_post_unlock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres);\nstatic void ocfs2_set_qinfo_lvb(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_downconvert_action(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_convert_action(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_attach_action(struct ocfs2_lock_res *lockres);\nstatic int ocfs2_generic_handle_bast(struct ocfs2_lock_res *lockres, int level);\nstatic void ocfs2_schedule_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_downconvert_on_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_drop_osb_locks(struct ocfs2_super *osb);\nstatic inline int ocfs2_highest_compat_lock_level(int level);\nstatic int ocfs2_prepare_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\t        struct ocfs2_lock_res *lockres);\nstatic int ocfs2_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_process_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *lockres);\n\nvoid ocfs2_qinfo_unlock(struct ocfs2_mem_dqinfo *oinfo, int ex)\n{\n\tstruct ocfs2_lock_res *lockres = &oinfo->dqi_gqlock;\n\tstruct ocfs2_super *osb = OCFS2_SB(oinfo->dqi_gi.dqi_sb);\n\tint level = ex ? DLM_LOCK_EX : DLM_LOCK_PR;\n\n\tif (!ocfs2_is_hard_readonly(osb) && !ocfs2_mount_local(osb))\n\t\tocfs2_cluster_unlock(osb, lockres, level);\n}"
  },
  {
    "function_name": "ocfs2_set_qinfo_lvb",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlmglue.c",
    "lines": "3803-3818",
    "snippet": "static void ocfs2_set_qinfo_lvb(struct ocfs2_lock_res *lockres)\n{\n\tstruct ocfs2_qinfo_lvb *lvb;\n\tstruct ocfs2_mem_dqinfo *oinfo = ocfs2_lock_res_qinfo(lockres);\n\tstruct mem_dqinfo *info = sb_dqinfo(oinfo->dqi_gi.dqi_sb,\n\t\t\t\t\t    oinfo->dqi_gi.dqi_type);\n\n\tlvb = ocfs2_dlm_lvb(&lockres->l_lksb);\n\tlvb->lvb_version = OCFS2_QINFO_LVB_VERSION;\n\tlvb->lvb_bgrace = cpu_to_be32(info->dqi_bgrace);\n\tlvb->lvb_igrace = cpu_to_be32(info->dqi_igrace);\n\tlvb->lvb_syncms = cpu_to_be32(oinfo->dqi_syncms);\n\tlvb->lvb_blocks = cpu_to_be32(oinfo->dqi_gi.dqi_blocks);\n\tlvb->lvb_free_blk = cpu_to_be32(oinfo->dqi_gi.dqi_free_blk);\n\tlvb->lvb_free_entry = cpu_to_be32(oinfo->dqi_gi.dqi_free_entry);\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"refcounttree.h\"",
      "#include \"quota.h\"",
      "#include \"uptodate.h\"",
      "#include \"super.h\"",
      "#include \"slot_map.h\"",
      "#include \"stackglue.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"heartbeat.h\"",
      "#include \"file.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"dcache.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2_lockingver.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/time.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/kthread.h>",
      "#include <linux/mm.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct ocfs2_super *ocfs2_get_dentry_osb(struct ocfs2_lock_res *lockres);",
      "static struct ocfs2_super *ocfs2_get_inode_osb(struct ocfs2_lock_res *lockres);",
      "static struct ocfs2_super *ocfs2_get_file_osb(struct ocfs2_lock_res *lockres);",
      "static struct ocfs2_super *ocfs2_get_qinfo_osb(struct ocfs2_lock_res *lockres);",
      "static void ocfs2_set_meta_lvb(struct ocfs2_lock_res *lockres);",
      "static void ocfs2_dentry_post_unlock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres);",
      "static void ocfs2_set_qinfo_lvb(struct ocfs2_lock_res *lockres);",
      "static inline void ocfs2_generic_handle_downconvert_action(struct ocfs2_lock_res *lockres);",
      "static inline void ocfs2_generic_handle_convert_action(struct ocfs2_lock_res *lockres);",
      "static inline void ocfs2_generic_handle_attach_action(struct ocfs2_lock_res *lockres);",
      "static void ocfs2_schedule_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);",
      "static void ocfs2_downconvert_on_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);",
      "static int ocfs2_prepare_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\t        struct ocfs2_lock_res *lockres);",
      "static int ocfs2_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres);",
      "static void ocfs2_process_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *lockres);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "oinfo->dqi_gi.dqi_free_entry"
          ],
          "line": 3817
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "oinfo->dqi_gi.dqi_free_blk"
          ],
          "line": 3816
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "oinfo->dqi_gi.dqi_blocks"
          ],
          "line": 3815
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "oinfo->dqi_syncms"
          ],
          "line": 3814
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "info->dqi_igrace"
          ],
          "line": 3813
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "info->dqi_bgrace"
          ],
          "line": 3812
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_dlm_lvb",
          "args": [
            "&lockres->l_lksb"
          ],
          "line": 3810
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_dlm_lvb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/stackglue.c",
          "lines": "279-282",
          "snippet": "void *ocfs2_dlm_lvb(struct ocfs2_dlm_lksb *lksb)\n{\n\treturn active_stack->sp_ops->lock_lvb(lksb);\n}",
          "includes": [
            "#include \"stackglue.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include <linux/sysctl.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/fs.h>",
            "#include <linux/kmod.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/list.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct ocfs2_stack_plugin *active_stack;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"stackglue.h\"\n#include \"ocfs2_fs.h\"\n#include <linux/sysctl.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/fs.h>\n#include <linux/kmod.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/spinlock.h>\n#include <linux/list.h>\n\nstatic struct ocfs2_stack_plugin *active_stack;\n\nvoid *ocfs2_dlm_lvb(struct ocfs2_dlm_lksb *lksb)\n{\n\treturn active_stack->sp_ops->lock_lvb(lksb);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sb_dqinfo",
          "args": [
            "oinfo->dqi_gi.dqi_sb",
            "oinfo->dqi_gi.dqi_type"
          ],
          "line": 3807
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_lock_res_qinfo",
          "args": [
            "lockres"
          ],
          "line": 3806
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_lock_res_qinfo",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlmglue.c",
          "lines": "319-324",
          "snippet": "static inline struct ocfs2_mem_dqinfo *ocfs2_lock_res_qinfo(struct ocfs2_lock_res *lockres)\n{\n\tBUG_ON(lockres->l_type != OCFS2_LOCK_TYPE_QINFO);\n\n\treturn (struct ocfs2_mem_dqinfo *)lockres->l_priv;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"refcounttree.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"stackglue.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dcache.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2_lockingver.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/time.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/kthread.h>",
            "#include <linux/mm.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct ocfs2_super *ocfs2_get_dentry_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_inode_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_file_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_qinfo_osb(struct ocfs2_lock_res *lockres);",
            "static void ocfs2_set_meta_lvb(struct ocfs2_lock_res *lockres);",
            "static void ocfs2_dentry_post_unlock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres);",
            "static void ocfs2_set_qinfo_lvb(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_downconvert_action(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_convert_action(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_attach_action(struct ocfs2_lock_res *lockres);",
            "static void ocfs2_schedule_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static void ocfs2_downconvert_on_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static int ocfs2_prepare_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\t        struct ocfs2_lock_res *lockres);",
            "static int ocfs2_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static void ocfs2_process_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *lockres);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"stackglue.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dcache.h\"\n#include \"alloc.h\"\n#include \"ocfs2_lockingver.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/quotaops.h>\n#include <linux/time.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/pagemap.h>\n#include <linux/kthread.h>\n#include <linux/mm.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic struct ocfs2_super *ocfs2_get_dentry_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_inode_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_file_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_qinfo_osb(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_set_meta_lvb(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_dentry_post_unlock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres);\nstatic void ocfs2_set_qinfo_lvb(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_downconvert_action(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_convert_action(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_attach_action(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_schedule_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_downconvert_on_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic int ocfs2_prepare_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\t        struct ocfs2_lock_res *lockres);\nstatic int ocfs2_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_process_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *lockres);\n\nstatic inline struct ocfs2_mem_dqinfo *ocfs2_lock_res_qinfo(struct ocfs2_lock_res *lockres)\n{\n\tBUG_ON(lockres->l_type != OCFS2_LOCK_TYPE_QINFO);\n\n\treturn (struct ocfs2_mem_dqinfo *)lockres->l_priv;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"stackglue.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dcache.h\"\n#include \"alloc.h\"\n#include \"ocfs2_lockingver.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/quotaops.h>\n#include <linux/time.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/pagemap.h>\n#include <linux/kthread.h>\n#include <linux/mm.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic struct ocfs2_super *ocfs2_get_dentry_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_inode_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_file_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_qinfo_osb(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_set_meta_lvb(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_dentry_post_unlock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres);\nstatic void ocfs2_set_qinfo_lvb(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_downconvert_action(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_convert_action(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_attach_action(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_schedule_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_downconvert_on_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic int ocfs2_prepare_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\t        struct ocfs2_lock_res *lockres);\nstatic int ocfs2_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_process_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *lockres);\n\nstatic void ocfs2_set_qinfo_lvb(struct ocfs2_lock_res *lockres)\n{\n\tstruct ocfs2_qinfo_lvb *lvb;\n\tstruct ocfs2_mem_dqinfo *oinfo = ocfs2_lock_res_qinfo(lockres);\n\tstruct mem_dqinfo *info = sb_dqinfo(oinfo->dqi_gi.dqi_sb,\n\t\t\t\t\t    oinfo->dqi_gi.dqi_type);\n\n\tlvb = ocfs2_dlm_lvb(&lockres->l_lksb);\n\tlvb->lvb_version = OCFS2_QINFO_LVB_VERSION;\n\tlvb->lvb_bgrace = cpu_to_be32(info->dqi_bgrace);\n\tlvb->lvb_igrace = cpu_to_be32(info->dqi_igrace);\n\tlvb->lvb_syncms = cpu_to_be32(oinfo->dqi_syncms);\n\tlvb->lvb_blocks = cpu_to_be32(oinfo->dqi_gi.dqi_blocks);\n\tlvb->lvb_free_blk = cpu_to_be32(oinfo->dqi_gi.dqi_free_blk);\n\tlvb->lvb_free_entry = cpu_to_be32(oinfo->dqi_gi.dqi_free_entry);\n}"
  },
  {
    "function_name": "ocfs2_refcount_convert_worker",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlmglue.c",
    "lines": "3792-3801",
    "snippet": "static int ocfs2_refcount_convert_worker(struct ocfs2_lock_res *lockres,\n\t\t\t\t\t int blocking)\n{\n\tstruct ocfs2_refcount_tree *tree =\n\t\t\t\tocfs2_lock_res_refcount_tree(lockres);\n\n\tocfs2_metadata_cache_purge(&tree->rf_ci);\n\n\treturn UNBLOCK_CONTINUE;\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"refcounttree.h\"",
      "#include \"quota.h\"",
      "#include \"uptodate.h\"",
      "#include \"super.h\"",
      "#include \"slot_map.h\"",
      "#include \"stackglue.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"heartbeat.h\"",
      "#include \"file.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"dcache.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2_lockingver.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/time.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/kthread.h>",
      "#include <linux/mm.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct ocfs2_super *ocfs2_get_dentry_osb(struct ocfs2_lock_res *lockres);",
      "static struct ocfs2_super *ocfs2_get_inode_osb(struct ocfs2_lock_res *lockres);",
      "static struct ocfs2_super *ocfs2_get_file_osb(struct ocfs2_lock_res *lockres);",
      "static struct ocfs2_super *ocfs2_get_qinfo_osb(struct ocfs2_lock_res *lockres);",
      "static void ocfs2_set_meta_lvb(struct ocfs2_lock_res *lockres);",
      "static int ocfs2_data_convert_worker(struct ocfs2_lock_res *lockres,\n\t\t\t\t     int blocking);",
      "static int ocfs2_dentry_convert_worker(struct ocfs2_lock_res *lockres,\n\t\t\t\t       int blocking);",
      "static void ocfs2_dentry_post_unlock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres);",
      "static void ocfs2_set_qinfo_lvb(struct ocfs2_lock_res *lockres);",
      "static int ocfs2_refcount_convert_worker(struct ocfs2_lock_res *lockres,\n\t\t\t\t\t int blocking);",
      "static inline void ocfs2_generic_handle_downconvert_action(struct ocfs2_lock_res *lockres);",
      "static inline void ocfs2_generic_handle_convert_action(struct ocfs2_lock_res *lockres);",
      "static inline void ocfs2_generic_handle_attach_action(struct ocfs2_lock_res *lockres);",
      "static void ocfs2_schedule_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);",
      "static void ocfs2_downconvert_on_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);",
      "static int ocfs2_prepare_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\t        struct ocfs2_lock_res *lockres);",
      "static int ocfs2_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres);",
      "static void ocfs2_process_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *lockres);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ocfs2_metadata_cache_purge",
          "args": [
            "&tree->rf_ci"
          ],
          "line": 3798
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_metadata_cache_purge",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/uptodate.c",
          "lines": "171-203",
          "snippet": "void ocfs2_metadata_cache_purge(struct ocfs2_caching_info *ci)\n{\n\tunsigned int tree, to_purge, purged;\n\tstruct rb_root root = RB_ROOT;\n\n\tBUG_ON(!ci || !ci->ci_ops);\n\n\tocfs2_metadata_cache_lock(ci);\n\ttree = !(ci->ci_flags & OCFS2_CACHE_FL_INLINE);\n\tto_purge = ci->ci_num_cached;\n\n\ttrace_ocfs2_metadata_cache_purge(\n\t\t(unsigned long long)ocfs2_metadata_cache_owner(ci),\n\t\tto_purge, tree);\n\n\t/* If we're a tree, save off the root so that we can safely\n\t * initialize the cache. We do the work to free tree members\n\t * without the spinlock. */\n\tif (tree)\n\t\troot = ci->ci_cache.ci_tree;\n\n\tocfs2_metadata_cache_reset(ci, 0);\n\tocfs2_metadata_cache_unlock(ci);\n\n\tpurged = ocfs2_purge_copied_metadata_tree(&root);\n\t/* If possible, track the number wiped so that we can more\n\t * easily detect counting errors. Unfortunately, this is only\n\t * meaningful for trees. */\n\tif (tree && purged != to_purge)\n\t\tmlog(ML_ERROR, \"Owner %llu, count = %u, purged = %u\\n\",\n\t\t     (unsigned long long)ocfs2_metadata_cache_owner(ci),\n\t\t     to_purge, purged);\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"inode.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"inode.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/rbtree.h>\n#include <linux/buffer_head.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nvoid ocfs2_metadata_cache_purge(struct ocfs2_caching_info *ci)\n{\n\tunsigned int tree, to_purge, purged;\n\tstruct rb_root root = RB_ROOT;\n\n\tBUG_ON(!ci || !ci->ci_ops);\n\n\tocfs2_metadata_cache_lock(ci);\n\ttree = !(ci->ci_flags & OCFS2_CACHE_FL_INLINE);\n\tto_purge = ci->ci_num_cached;\n\n\ttrace_ocfs2_metadata_cache_purge(\n\t\t(unsigned long long)ocfs2_metadata_cache_owner(ci),\n\t\tto_purge, tree);\n\n\t/* If we're a tree, save off the root so that we can safely\n\t * initialize the cache. We do the work to free tree members\n\t * without the spinlock. */\n\tif (tree)\n\t\troot = ci->ci_cache.ci_tree;\n\n\tocfs2_metadata_cache_reset(ci, 0);\n\tocfs2_metadata_cache_unlock(ci);\n\n\tpurged = ocfs2_purge_copied_metadata_tree(&root);\n\t/* If possible, track the number wiped so that we can more\n\t * easily detect counting errors. Unfortunately, this is only\n\t * meaningful for trees. */\n\tif (tree && purged != to_purge)\n\t\tmlog(ML_ERROR, \"Owner %llu, count = %u, purged = %u\\n\",\n\t\t     (unsigned long long)ocfs2_metadata_cache_owner(ci),\n\t\t     to_purge, purged);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_lock_res_refcount_tree",
          "args": [
            "lockres"
          ],
          "line": 3796
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_lock_res_refcount_tree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlmglue.c",
          "lines": "326-330",
          "snippet": "static inline struct ocfs2_refcount_tree *\nocfs2_lock_res_refcount_tree(struct ocfs2_lock_res *res)\n{\n\treturn container_of(res, struct ocfs2_refcount_tree, rf_lockres);\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"refcounttree.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"stackglue.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dcache.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2_lockingver.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/time.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/kthread.h>",
            "#include <linux/mm.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"stackglue.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dcache.h\"\n#include \"alloc.h\"\n#include \"ocfs2_lockingver.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/quotaops.h>\n#include <linux/time.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/pagemap.h>\n#include <linux/kthread.h>\n#include <linux/mm.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic inline struct ocfs2_refcount_tree *\nocfs2_lock_res_refcount_tree(struct ocfs2_lock_res *res)\n{\n\treturn container_of(res, struct ocfs2_refcount_tree, rf_lockres);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"stackglue.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dcache.h\"\n#include \"alloc.h\"\n#include \"ocfs2_lockingver.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/quotaops.h>\n#include <linux/time.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/pagemap.h>\n#include <linux/kthread.h>\n#include <linux/mm.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic struct ocfs2_super *ocfs2_get_dentry_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_inode_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_file_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_qinfo_osb(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_set_meta_lvb(struct ocfs2_lock_res *lockres);\nstatic int ocfs2_data_convert_worker(struct ocfs2_lock_res *lockres,\n\t\t\t\t     int blocking);\nstatic int ocfs2_dentry_convert_worker(struct ocfs2_lock_res *lockres,\n\t\t\t\t       int blocking);\nstatic void ocfs2_dentry_post_unlock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres);\nstatic void ocfs2_set_qinfo_lvb(struct ocfs2_lock_res *lockres);\nstatic int ocfs2_refcount_convert_worker(struct ocfs2_lock_res *lockres,\n\t\t\t\t\t int blocking);\nstatic inline void ocfs2_generic_handle_downconvert_action(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_convert_action(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_attach_action(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_schedule_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_downconvert_on_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic int ocfs2_prepare_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\t        struct ocfs2_lock_res *lockres);\nstatic int ocfs2_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_process_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *lockres);\n\nstatic int ocfs2_refcount_convert_worker(struct ocfs2_lock_res *lockres,\n\t\t\t\t\t int blocking)\n{\n\tstruct ocfs2_refcount_tree *tree =\n\t\t\t\tocfs2_lock_res_refcount_tree(lockres);\n\n\tocfs2_metadata_cache_purge(&tree->rf_ci);\n\n\treturn UNBLOCK_CONTINUE;\n}"
  },
  {
    "function_name": "ocfs2_check_refcount_downconvert",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlmglue.c",
    "lines": "3783-3790",
    "snippet": "static int ocfs2_check_refcount_downconvert(struct ocfs2_lock_res *lockres,\n\t\t\t\t\t    int new_level)\n{\n\tstruct ocfs2_refcount_tree *tree =\n\t\t\t\tocfs2_lock_res_refcount_tree(lockres);\n\n\treturn ocfs2_ci_checkpointed(&tree->rf_ci, lockres, new_level);\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"refcounttree.h\"",
      "#include \"quota.h\"",
      "#include \"uptodate.h\"",
      "#include \"super.h\"",
      "#include \"slot_map.h\"",
      "#include \"stackglue.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"heartbeat.h\"",
      "#include \"file.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"dcache.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2_lockingver.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/time.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/kthread.h>",
      "#include <linux/mm.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct ocfs2_super *ocfs2_get_dentry_osb(struct ocfs2_lock_res *lockres);",
      "static struct ocfs2_super *ocfs2_get_inode_osb(struct ocfs2_lock_res *lockres);",
      "static struct ocfs2_super *ocfs2_get_file_osb(struct ocfs2_lock_res *lockres);",
      "static struct ocfs2_super *ocfs2_get_qinfo_osb(struct ocfs2_lock_res *lockres);",
      "static int ocfs2_check_meta_downconvert(struct ocfs2_lock_res *lockres,\n\t\t\t\t\tint new_level);",
      "static void ocfs2_set_meta_lvb(struct ocfs2_lock_res *lockres);",
      "static void ocfs2_dentry_post_unlock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres);",
      "static void ocfs2_set_qinfo_lvb(struct ocfs2_lock_res *lockres);",
      "static int ocfs2_check_refcount_downconvert(struct ocfs2_lock_res *lockres,\n\t\t\t\t\t    int new_level);",
      "static inline void ocfs2_generic_handle_downconvert_action(struct ocfs2_lock_res *lockres);",
      "static inline void ocfs2_generic_handle_convert_action(struct ocfs2_lock_res *lockres);",
      "static inline void ocfs2_generic_handle_attach_action(struct ocfs2_lock_res *lockres);",
      "static void ocfs2_schedule_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);",
      "static void ocfs2_downconvert_on_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);",
      "static unsigned int ocfs2_prepare_downconvert(struct ocfs2_lock_res *lockres,\n\t\t\t\t\t      int new_level);",
      "static int ocfs2_prepare_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\t        struct ocfs2_lock_res *lockres);",
      "static int ocfs2_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres);",
      "static void ocfs2_process_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *lockres);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ocfs2_ci_checkpointed",
          "args": [
            "&tree->rf_ci",
            "lockres",
            "new_level"
          ],
          "line": 3789
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_ci_checkpointed",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlmglue.c",
          "lines": "3628-3642",
          "snippet": "static int ocfs2_ci_checkpointed(struct ocfs2_caching_info *ci,\n\t\t\t\t struct ocfs2_lock_res *lockres,\n\t\t\t\t int new_level)\n{\n\tint checkpointed = ocfs2_ci_fully_checkpointed(ci);\n\n\tBUG_ON(new_level != DLM_LOCK_NL && new_level != DLM_LOCK_PR);\n\tBUG_ON(lockres->l_level != DLM_LOCK_EX && !checkpointed);\n\n\tif (checkpointed)\n\t\treturn 1;\n\n\tocfs2_start_checkpoint(OCFS2_SB(ocfs2_metadata_cache_get_super(ci)));\n\treturn 0;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"refcounttree.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"stackglue.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dcache.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2_lockingver.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/time.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/kthread.h>",
            "#include <linux/mm.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct ocfs2_super *ocfs2_get_dentry_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_inode_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_file_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_qinfo_osb(struct ocfs2_lock_res *lockres);",
            "static int ocfs2_check_meta_downconvert(struct ocfs2_lock_res *lockres,\n\t\t\t\t\tint new_level);",
            "static void ocfs2_set_meta_lvb(struct ocfs2_lock_res *lockres);",
            "static void ocfs2_dentry_post_unlock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres);",
            "static void ocfs2_set_qinfo_lvb(struct ocfs2_lock_res *lockres);",
            "static int ocfs2_check_refcount_downconvert(struct ocfs2_lock_res *lockres,\n\t\t\t\t\t    int new_level);",
            "static inline void ocfs2_generic_handle_downconvert_action(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_convert_action(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_attach_action(struct ocfs2_lock_res *lockres);",
            "static void ocfs2_schedule_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static void ocfs2_downconvert_on_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static unsigned int ocfs2_prepare_downconvert(struct ocfs2_lock_res *lockres,\n\t\t\t\t\t      int new_level);",
            "static int ocfs2_prepare_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\t        struct ocfs2_lock_res *lockres);",
            "static int ocfs2_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static void ocfs2_process_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *lockres);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"stackglue.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dcache.h\"\n#include \"alloc.h\"\n#include \"ocfs2_lockingver.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/quotaops.h>\n#include <linux/time.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/pagemap.h>\n#include <linux/kthread.h>\n#include <linux/mm.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic struct ocfs2_super *ocfs2_get_dentry_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_inode_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_file_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_qinfo_osb(struct ocfs2_lock_res *lockres);\nstatic int ocfs2_check_meta_downconvert(struct ocfs2_lock_res *lockres,\n\t\t\t\t\tint new_level);\nstatic void ocfs2_set_meta_lvb(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_dentry_post_unlock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres);\nstatic void ocfs2_set_qinfo_lvb(struct ocfs2_lock_res *lockres);\nstatic int ocfs2_check_refcount_downconvert(struct ocfs2_lock_res *lockres,\n\t\t\t\t\t    int new_level);\nstatic inline void ocfs2_generic_handle_downconvert_action(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_convert_action(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_attach_action(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_schedule_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_downconvert_on_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic unsigned int ocfs2_prepare_downconvert(struct ocfs2_lock_res *lockres,\n\t\t\t\t\t      int new_level);\nstatic int ocfs2_prepare_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\t        struct ocfs2_lock_res *lockres);\nstatic int ocfs2_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_process_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *lockres);\n\nstatic int ocfs2_ci_checkpointed(struct ocfs2_caching_info *ci,\n\t\t\t\t struct ocfs2_lock_res *lockres,\n\t\t\t\t int new_level)\n{\n\tint checkpointed = ocfs2_ci_fully_checkpointed(ci);\n\n\tBUG_ON(new_level != DLM_LOCK_NL && new_level != DLM_LOCK_PR);\n\tBUG_ON(lockres->l_level != DLM_LOCK_EX && !checkpointed);\n\n\tif (checkpointed)\n\t\treturn 1;\n\n\tocfs2_start_checkpoint(OCFS2_SB(ocfs2_metadata_cache_get_super(ci)));\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_lock_res_refcount_tree",
          "args": [
            "lockres"
          ],
          "line": 3787
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_lock_res_refcount_tree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlmglue.c",
          "lines": "326-330",
          "snippet": "static inline struct ocfs2_refcount_tree *\nocfs2_lock_res_refcount_tree(struct ocfs2_lock_res *res)\n{\n\treturn container_of(res, struct ocfs2_refcount_tree, rf_lockres);\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"refcounttree.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"stackglue.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dcache.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2_lockingver.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/time.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/kthread.h>",
            "#include <linux/mm.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"stackglue.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dcache.h\"\n#include \"alloc.h\"\n#include \"ocfs2_lockingver.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/quotaops.h>\n#include <linux/time.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/pagemap.h>\n#include <linux/kthread.h>\n#include <linux/mm.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic inline struct ocfs2_refcount_tree *\nocfs2_lock_res_refcount_tree(struct ocfs2_lock_res *res)\n{\n\treturn container_of(res, struct ocfs2_refcount_tree, rf_lockres);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"stackglue.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dcache.h\"\n#include \"alloc.h\"\n#include \"ocfs2_lockingver.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/quotaops.h>\n#include <linux/time.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/pagemap.h>\n#include <linux/kthread.h>\n#include <linux/mm.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic struct ocfs2_super *ocfs2_get_dentry_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_inode_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_file_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_qinfo_osb(struct ocfs2_lock_res *lockres);\nstatic int ocfs2_check_meta_downconvert(struct ocfs2_lock_res *lockres,\n\t\t\t\t\tint new_level);\nstatic void ocfs2_set_meta_lvb(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_dentry_post_unlock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres);\nstatic void ocfs2_set_qinfo_lvb(struct ocfs2_lock_res *lockres);\nstatic int ocfs2_check_refcount_downconvert(struct ocfs2_lock_res *lockres,\n\t\t\t\t\t    int new_level);\nstatic inline void ocfs2_generic_handle_downconvert_action(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_convert_action(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_attach_action(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_schedule_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_downconvert_on_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic unsigned int ocfs2_prepare_downconvert(struct ocfs2_lock_res *lockres,\n\t\t\t\t\t      int new_level);\nstatic int ocfs2_prepare_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\t        struct ocfs2_lock_res *lockres);\nstatic int ocfs2_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_process_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *lockres);\n\nstatic int ocfs2_check_refcount_downconvert(struct ocfs2_lock_res *lockres,\n\t\t\t\t\t    int new_level)\n{\n\tstruct ocfs2_refcount_tree *tree =\n\t\t\t\tocfs2_lock_res_refcount_tree(lockres);\n\n\treturn ocfs2_ci_checkpointed(&tree->rf_ci, lockres, new_level);\n}"
  },
  {
    "function_name": "ocfs2_dentry_convert_worker",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlmglue.c",
    "lines": "3690-3781",
    "snippet": "static int ocfs2_dentry_convert_worker(struct ocfs2_lock_res *lockres,\n\t\t\t\t       int blocking)\n{\n\tstruct ocfs2_dentry_lock *dl = ocfs2_lock_res_dl(lockres);\n\tstruct ocfs2_inode_info *oi = OCFS2_I(dl->dl_inode);\n\tstruct dentry *dentry;\n\tunsigned long flags;\n\tint extra_ref = 0;\n\n\t/*\n\t * This node is blocking another node from getting a read\n\t * lock. This happens when we've renamed within a\n\t * directory. We've forced the other nodes to d_delete(), but\n\t * we never actually dropped our lock because it's still\n\t * valid. The downconvert code will retain a PR for this node,\n\t * so there's no further work to do.\n\t */\n\tif (blocking == DLM_LOCK_PR)\n\t\treturn UNBLOCK_CONTINUE;\n\n\t/*\n\t * Mark this inode as potentially orphaned. The code in\n\t * ocfs2_delete_inode() will figure out whether it actually\n\t * needs to be freed or not.\n\t */\n\tspin_lock(&oi->ip_lock);\n\toi->ip_flags |= OCFS2_INODE_MAYBE_ORPHANED;\n\tspin_unlock(&oi->ip_lock);\n\n\t/*\n\t * Yuck. We need to make sure however that the check of\n\t * OCFS2_LOCK_FREEING and the extra reference are atomic with\n\t * respect to a reference decrement or the setting of that\n\t * flag.\n\t */\n\tspin_lock_irqsave(&lockres->l_lock, flags);\n\tspin_lock(&dentry_attach_lock);\n\tif (!(lockres->l_flags & OCFS2_LOCK_FREEING)\n\t    && dl->dl_count) {\n\t\tdl->dl_count++;\n\t\textra_ref = 1;\n\t}\n\tspin_unlock(&dentry_attach_lock);\n\tspin_unlock_irqrestore(&lockres->l_lock, flags);\n\n\tmlog(0, \"extra_ref = %d\\n\", extra_ref);\n\n\t/*\n\t * We have a process waiting on us in ocfs2_dentry_iput(),\n\t * which means we can't have any more outstanding\n\t * aliases. There's no need to do any more work.\n\t */\n\tif (!extra_ref)\n\t\treturn UNBLOCK_CONTINUE;\n\n\tspin_lock(&dentry_attach_lock);\n\twhile (1) {\n\t\tdentry = ocfs2_find_local_alias(dl->dl_inode,\n\t\t\t\t\t\tdl->dl_parent_blkno, 1);\n\t\tif (!dentry)\n\t\t\tbreak;\n\t\tspin_unlock(&dentry_attach_lock);\n\n\t\tif (S_ISDIR(dl->dl_inode->i_mode))\n\t\t\tshrink_dcache_parent(dentry);\n\n\t\tmlog(0, \"d_delete(%pd);\\n\", dentry);\n\n\t\t/*\n\t\t * The following dcache calls may do an\n\t\t * iput(). Normally we don't want that from the\n\t\t * downconverting thread, but in this case it's ok\n\t\t * because the requesting node already has an\n\t\t * exclusive lock on the inode, so it can't be queued\n\t\t * for a downconvert.\n\t\t */\n\t\td_delete(dentry);\n\t\tdput(dentry);\n\n\t\tspin_lock(&dentry_attach_lock);\n\t}\n\tspin_unlock(&dentry_attach_lock);\n\n\t/*\n\t * If we are the last holder of this dentry lock, there is no\n\t * reason to downconvert so skip straight to the unlock.\n\t */\n\tif (dl->dl_count == 1)\n\t\treturn UNBLOCK_STOP_POST;\n\n\treturn UNBLOCK_CONTINUE_POST;\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"refcounttree.h\"",
      "#include \"quota.h\"",
      "#include \"uptodate.h\"",
      "#include \"super.h\"",
      "#include \"slot_map.h\"",
      "#include \"stackglue.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"heartbeat.h\"",
      "#include \"file.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"dcache.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2_lockingver.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/time.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/kthread.h>",
      "#include <linux/mm.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct ocfs2_super *ocfs2_get_dentry_osb(struct ocfs2_lock_res *lockres);",
      "static struct ocfs2_super *ocfs2_get_inode_osb(struct ocfs2_lock_res *lockres);",
      "static struct ocfs2_super *ocfs2_get_file_osb(struct ocfs2_lock_res *lockres);",
      "static struct ocfs2_super *ocfs2_get_qinfo_osb(struct ocfs2_lock_res *lockres);",
      "static void ocfs2_set_meta_lvb(struct ocfs2_lock_res *lockres);",
      "static int ocfs2_data_convert_worker(struct ocfs2_lock_res *lockres,\n\t\t\t\t     int blocking);",
      "static int ocfs2_dentry_convert_worker(struct ocfs2_lock_res *lockres,\n\t\t\t\t       int blocking);",
      "static void ocfs2_dentry_post_unlock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres);",
      "static void ocfs2_set_qinfo_lvb(struct ocfs2_lock_res *lockres);",
      "static int ocfs2_refcount_convert_worker(struct ocfs2_lock_res *lockres,\n\t\t\t\t\t int blocking);",
      "static inline void ocfs2_generic_handle_downconvert_action(struct ocfs2_lock_res *lockres);",
      "static inline void ocfs2_generic_handle_convert_action(struct ocfs2_lock_res *lockres);",
      "static inline void ocfs2_generic_handle_attach_action(struct ocfs2_lock_res *lockres);",
      "static void ocfs2_schedule_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);",
      "static void ocfs2_downconvert_on_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);",
      "static int ocfs2_prepare_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\t        struct ocfs2_lock_res *lockres);",
      "static int ocfs2_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres);",
      "static void ocfs2_process_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *lockres);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&dentry_attach_lock"
          ],
          "line": 3771
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&dentry_attach_lock"
          ],
          "line": 3769
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "dput",
          "args": [
            "dentry"
          ],
          "line": 3767
        },
        "resolved": true,
        "details": {
          "function_name": "dput",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "726-762",
          "snippet": "void dput(struct dentry *dentry)\n{\n\tif (unlikely(!dentry))\n\t\treturn;\n\nrepeat:\n\trcu_read_lock();\n\tif (likely(fast_dput(dentry))) {\n\t\trcu_read_unlock();\n\t\treturn;\n\t}\n\n\t/* Slow case: now with the dentry lock held */\n\trcu_read_unlock();\n\n\t/* Unreachable? Get rid of it */\n\tif (unlikely(d_unhashed(dentry)))\n\t\tgoto kill_it;\n\n\tif (unlikely(dentry->d_flags & DCACHE_OP_DELETE)) {\n\t\tif (dentry->d_op->d_delete(dentry))\n\t\t\tgoto kill_it;\n\t}\n\n\tif (!(dentry->d_flags & DCACHE_REFERENCED))\n\t\tdentry->d_flags |= DCACHE_REFERENCED;\n\tdentry_lru_add(dentry);\n\n\tdentry->d_lockref.count--;\n\tspin_unlock(&dentry->d_lock);\n\treturn;\n\nkill_it:\n\tdentry = dentry_kill(dentry);\n\tif (dentry)\n\t\tgoto repeat;\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nvoid dput(struct dentry *dentry)\n{\n\tif (unlikely(!dentry))\n\t\treturn;\n\nrepeat:\n\trcu_read_lock();\n\tif (likely(fast_dput(dentry))) {\n\t\trcu_read_unlock();\n\t\treturn;\n\t}\n\n\t/* Slow case: now with the dentry lock held */\n\trcu_read_unlock();\n\n\t/* Unreachable? Get rid of it */\n\tif (unlikely(d_unhashed(dentry)))\n\t\tgoto kill_it;\n\n\tif (unlikely(dentry->d_flags & DCACHE_OP_DELETE)) {\n\t\tif (dentry->d_op->d_delete(dentry))\n\t\t\tgoto kill_it;\n\t}\n\n\tif (!(dentry->d_flags & DCACHE_REFERENCED))\n\t\tdentry->d_flags |= DCACHE_REFERENCED;\n\tdentry_lru_add(dentry);\n\n\tdentry->d_lockref.count--;\n\tspin_unlock(&dentry->d_lock);\n\treturn;\n\nkill_it:\n\tdentry = dentry_kill(dentry);\n\tif (dentry)\n\t\tgoto repeat;\n}"
        }
      },
      {
        "call_info": {
          "callee": "d_delete",
          "args": [
            "dentry"
          ],
          "line": 3766
        },
        "resolved": true,
        "details": {
          "function_name": "d_delete",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "2350-2379",
          "snippet": "void d_delete(struct dentry * dentry)\n{\n\tstruct inode *inode;\n\tint isdir = 0;\n\t/*\n\t * Are we the only user?\n\t */\nagain:\n\tspin_lock(&dentry->d_lock);\n\tinode = dentry->d_inode;\n\tisdir = S_ISDIR(inode->i_mode);\n\tif (dentry->d_lockref.count == 1) {\n\t\tif (!spin_trylock(&inode->i_lock)) {\n\t\t\tspin_unlock(&dentry->d_lock);\n\t\t\tcpu_relax();\n\t\t\tgoto again;\n\t\t}\n\t\tdentry->d_flags &= ~DCACHE_CANT_MOUNT;\n\t\tdentry_unlink_inode(dentry);\n\t\tfsnotify_nameremove(dentry, isdir);\n\t\treturn;\n\t}\n\n\tif (!d_unhashed(dentry))\n\t\t__d_drop(dentry);\n\n\tspin_unlock(&dentry->d_lock);\n\n\tfsnotify_nameremove(dentry, isdir);\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nvoid d_delete(struct dentry * dentry)\n{\n\tstruct inode *inode;\n\tint isdir = 0;\n\t/*\n\t * Are we the only user?\n\t */\nagain:\n\tspin_lock(&dentry->d_lock);\n\tinode = dentry->d_inode;\n\tisdir = S_ISDIR(inode->i_mode);\n\tif (dentry->d_lockref.count == 1) {\n\t\tif (!spin_trylock(&inode->i_lock)) {\n\t\t\tspin_unlock(&dentry->d_lock);\n\t\t\tcpu_relax();\n\t\t\tgoto again;\n\t\t}\n\t\tdentry->d_flags &= ~DCACHE_CANT_MOUNT;\n\t\tdentry_unlink_inode(dentry);\n\t\tfsnotify_nameremove(dentry, isdir);\n\t\treturn;\n\t}\n\n\tif (!d_unhashed(dentry))\n\t\t__d_drop(dentry);\n\n\tspin_unlock(&dentry->d_lock);\n\n\tfsnotify_nameremove(dentry, isdir);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog",
          "args": [
            "0",
            "\"d_delete(%pd);\\n\"",
            "dentry"
          ],
          "line": 3756
        },
        "resolved": true,
        "details": {
          "function_name": "mlog_show",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/cluster/masklog.c",
          "lines": "107-113",
          "snippet": "static ssize_t mlog_show(struct kobject *obj, struct attribute *attr,\n\t\t\t char *buf)\n{\n\tstruct mlog_attribute *mlog_attr = to_mlog_attr(attr);\n\n\treturn mlog_mask_show(mlog_attr->mask, buf);\n}",
          "includes": [
            "#include \"masklog.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/string.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"masklog.h\"\n#include <asm/uaccess.h>\n#include <linux/string.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n\nstatic ssize_t mlog_show(struct kobject *obj, struct attribute *attr,\n\t\t\t char *buf)\n{\n\tstruct mlog_attribute *mlog_attr = to_mlog_attr(attr);\n\n\treturn mlog_mask_show(mlog_attr->mask, buf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "shrink_dcache_parent",
          "args": [
            "dentry"
          ],
          "line": 3754
        },
        "resolved": true,
        "details": {
          "function_name": "shrink_dcache_parent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "1361-1377",
          "snippet": "void shrink_dcache_parent(struct dentry *parent)\n{\n\tfor (;;) {\n\t\tstruct select_data data;\n\n\t\tINIT_LIST_HEAD(&data.dispose);\n\t\tdata.start = parent;\n\t\tdata.found = 0;\n\n\t\td_walk(parent, &data, select_collect, NULL);\n\t\tif (!data.found)\n\t\t\tbreak;\n\n\t\tshrink_dentry_list(&data.dispose);\n\t\tcond_resched();\n\t}\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nvoid shrink_dcache_parent(struct dentry *parent)\n{\n\tfor (;;) {\n\t\tstruct select_data data;\n\n\t\tINIT_LIST_HEAD(&data.dispose);\n\t\tdata.start = parent;\n\t\tdata.found = 0;\n\n\t\td_walk(parent, &data, select_collect, NULL);\n\t\tif (!data.found)\n\t\t\tbreak;\n\n\t\tshrink_dentry_list(&data.dispose);\n\t\tcond_resched();\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "S_ISDIR",
          "args": [
            "dl->dl_inode->i_mode"
          ],
          "line": 3753
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_find_local_alias",
          "args": [
            "dl->dl_inode",
            "dl->dl_parent_blkno",
            "1"
          ],
          "line": 3747
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_find_local_alias",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dcache.c",
          "lines": "168-190",
          "snippet": "struct dentry *ocfs2_find_local_alias(struct inode *inode,\n\t\t\t\t      u64 parent_blkno,\n\t\t\t\t      int skip_unhashed)\n{\n\tstruct dentry *dentry;\n\n\tspin_lock(&inode->i_lock);\n\thlist_for_each_entry(dentry, &inode->i_dentry, d_u.d_alias) {\n\t\tspin_lock(&dentry->d_lock);\n\t\tif (ocfs2_match_dentry(dentry, parent_blkno, skip_unhashed)) {\n\t\t\ttrace_ocfs2_find_local_alias(dentry->d_name.len,\n\t\t\t\t\t\t     dentry->d_name.name);\n\n\t\t\tdget_dlock(dentry);\n\t\t\tspin_unlock(&dentry->d_lock);\n\t\t\tspin_unlock(&inode->i_lock);\n\t\t\treturn dentry;\n\t\t}\n\t\tspin_unlock(&dentry->d_lock);\n\t}\n\tspin_unlock(&inode->i_lock);\n\treturn NULL;\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dcache.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"dlmglue.h\"\n#include \"dcache.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstruct dentry *ocfs2_find_local_alias(struct inode *inode,\n\t\t\t\t      u64 parent_blkno,\n\t\t\t\t      int skip_unhashed)\n{\n\tstruct dentry *dentry;\n\n\tspin_lock(&inode->i_lock);\n\thlist_for_each_entry(dentry, &inode->i_dentry, d_u.d_alias) {\n\t\tspin_lock(&dentry->d_lock);\n\t\tif (ocfs2_match_dentry(dentry, parent_blkno, skip_unhashed)) {\n\t\t\ttrace_ocfs2_find_local_alias(dentry->d_name.len,\n\t\t\t\t\t\t     dentry->d_name.name);\n\n\t\t\tdget_dlock(dentry);\n\t\t\tspin_unlock(&dentry->d_lock);\n\t\t\tspin_unlock(&inode->i_lock);\n\t\t\treturn dentry;\n\t\t}\n\t\tspin_unlock(&dentry->d_lock);\n\t}\n\tspin_unlock(&inode->i_lock);\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock_irqrestore",
          "args": [
            "&lockres->l_lock",
            "flags"
          ],
          "line": 3733
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock_irqsave",
          "args": [
            "&lockres->l_lock",
            "flags"
          ],
          "line": 3725
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "OCFS2_I",
          "args": [
            "dl->dl_inode"
          ],
          "line": 3694
        },
        "resolved": true,
        "details": {
          "function_name": "OCFS2_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/inode.h",
          "lines": "118-121",
          "snippet": "static inline struct ocfs2_inode_info *OCFS2_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ocfs2_inode_info, vfs_inode);\n}",
          "includes": [
            "#include \"extent_map.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extent_map.h\"\n\nstatic inline struct ocfs2_inode_info *OCFS2_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ocfs2_inode_info, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_lock_res_dl",
          "args": [
            "lockres"
          ],
          "line": 3693
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_lock_res_dl",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlmglue.c",
          "lines": "312-317",
          "snippet": "static inline struct ocfs2_dentry_lock *ocfs2_lock_res_dl(struct ocfs2_lock_res *lockres)\n{\n\tBUG_ON(lockres->l_type != OCFS2_LOCK_TYPE_DENTRY);\n\n\treturn (struct ocfs2_dentry_lock *)lockres->l_priv;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"refcounttree.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"stackglue.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dcache.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2_lockingver.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/time.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/kthread.h>",
            "#include <linux/mm.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct ocfs2_super *ocfs2_get_dentry_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_inode_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_file_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_qinfo_osb(struct ocfs2_lock_res *lockres);",
            "static void ocfs2_set_meta_lvb(struct ocfs2_lock_res *lockres);",
            "static void ocfs2_dentry_post_unlock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres);",
            "static void ocfs2_set_qinfo_lvb(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_downconvert_action(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_convert_action(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_attach_action(struct ocfs2_lock_res *lockres);",
            "static void ocfs2_schedule_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static void ocfs2_downconvert_on_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static int ocfs2_prepare_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\t        struct ocfs2_lock_res *lockres);",
            "static int ocfs2_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static void ocfs2_process_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *lockres);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"stackglue.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dcache.h\"\n#include \"alloc.h\"\n#include \"ocfs2_lockingver.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/quotaops.h>\n#include <linux/time.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/pagemap.h>\n#include <linux/kthread.h>\n#include <linux/mm.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic struct ocfs2_super *ocfs2_get_dentry_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_inode_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_file_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_qinfo_osb(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_set_meta_lvb(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_dentry_post_unlock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres);\nstatic void ocfs2_set_qinfo_lvb(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_downconvert_action(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_convert_action(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_attach_action(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_schedule_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_downconvert_on_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic int ocfs2_prepare_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\t        struct ocfs2_lock_res *lockres);\nstatic int ocfs2_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_process_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *lockres);\n\nstatic inline struct ocfs2_dentry_lock *ocfs2_lock_res_dl(struct ocfs2_lock_res *lockres)\n{\n\tBUG_ON(lockres->l_type != OCFS2_LOCK_TYPE_DENTRY);\n\n\treturn (struct ocfs2_dentry_lock *)lockres->l_priv;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"stackglue.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dcache.h\"\n#include \"alloc.h\"\n#include \"ocfs2_lockingver.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/quotaops.h>\n#include <linux/time.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/pagemap.h>\n#include <linux/kthread.h>\n#include <linux/mm.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic struct ocfs2_super *ocfs2_get_dentry_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_inode_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_file_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_qinfo_osb(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_set_meta_lvb(struct ocfs2_lock_res *lockres);\nstatic int ocfs2_data_convert_worker(struct ocfs2_lock_res *lockres,\n\t\t\t\t     int blocking);\nstatic int ocfs2_dentry_convert_worker(struct ocfs2_lock_res *lockres,\n\t\t\t\t       int blocking);\nstatic void ocfs2_dentry_post_unlock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres);\nstatic void ocfs2_set_qinfo_lvb(struct ocfs2_lock_res *lockres);\nstatic int ocfs2_refcount_convert_worker(struct ocfs2_lock_res *lockres,\n\t\t\t\t\t int blocking);\nstatic inline void ocfs2_generic_handle_downconvert_action(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_convert_action(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_attach_action(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_schedule_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_downconvert_on_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic int ocfs2_prepare_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\t        struct ocfs2_lock_res *lockres);\nstatic int ocfs2_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_process_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *lockres);\n\nstatic int ocfs2_dentry_convert_worker(struct ocfs2_lock_res *lockres,\n\t\t\t\t       int blocking)\n{\n\tstruct ocfs2_dentry_lock *dl = ocfs2_lock_res_dl(lockres);\n\tstruct ocfs2_inode_info *oi = OCFS2_I(dl->dl_inode);\n\tstruct dentry *dentry;\n\tunsigned long flags;\n\tint extra_ref = 0;\n\n\t/*\n\t * This node is blocking another node from getting a read\n\t * lock. This happens when we've renamed within a\n\t * directory. We've forced the other nodes to d_delete(), but\n\t * we never actually dropped our lock because it's still\n\t * valid. The downconvert code will retain a PR for this node,\n\t * so there's no further work to do.\n\t */\n\tif (blocking == DLM_LOCK_PR)\n\t\treturn UNBLOCK_CONTINUE;\n\n\t/*\n\t * Mark this inode as potentially orphaned. The code in\n\t * ocfs2_delete_inode() will figure out whether it actually\n\t * needs to be freed or not.\n\t */\n\tspin_lock(&oi->ip_lock);\n\toi->ip_flags |= OCFS2_INODE_MAYBE_ORPHANED;\n\tspin_unlock(&oi->ip_lock);\n\n\t/*\n\t * Yuck. We need to make sure however that the check of\n\t * OCFS2_LOCK_FREEING and the extra reference are atomic with\n\t * respect to a reference decrement or the setting of that\n\t * flag.\n\t */\n\tspin_lock_irqsave(&lockres->l_lock, flags);\n\tspin_lock(&dentry_attach_lock);\n\tif (!(lockres->l_flags & OCFS2_LOCK_FREEING)\n\t    && dl->dl_count) {\n\t\tdl->dl_count++;\n\t\textra_ref = 1;\n\t}\n\tspin_unlock(&dentry_attach_lock);\n\tspin_unlock_irqrestore(&lockres->l_lock, flags);\n\n\tmlog(0, \"extra_ref = %d\\n\", extra_ref);\n\n\t/*\n\t * We have a process waiting on us in ocfs2_dentry_iput(),\n\t * which means we can't have any more outstanding\n\t * aliases. There's no need to do any more work.\n\t */\n\tif (!extra_ref)\n\t\treturn UNBLOCK_CONTINUE;\n\n\tspin_lock(&dentry_attach_lock);\n\twhile (1) {\n\t\tdentry = ocfs2_find_local_alias(dl->dl_inode,\n\t\t\t\t\t\tdl->dl_parent_blkno, 1);\n\t\tif (!dentry)\n\t\t\tbreak;\n\t\tspin_unlock(&dentry_attach_lock);\n\n\t\tif (S_ISDIR(dl->dl_inode->i_mode))\n\t\t\tshrink_dcache_parent(dentry);\n\n\t\tmlog(0, \"d_delete(%pd);\\n\", dentry);\n\n\t\t/*\n\t\t * The following dcache calls may do an\n\t\t * iput(). Normally we don't want that from the\n\t\t * downconverting thread, but in this case it's ok\n\t\t * because the requesting node already has an\n\t\t * exclusive lock on the inode, so it can't be queued\n\t\t * for a downconvert.\n\t\t */\n\t\td_delete(dentry);\n\t\tdput(dentry);\n\n\t\tspin_lock(&dentry_attach_lock);\n\t}\n\tspin_unlock(&dentry_attach_lock);\n\n\t/*\n\t * If we are the last holder of this dentry lock, there is no\n\t * reason to downconvert so skip straight to the unlock.\n\t */\n\tif (dl->dl_count == 1)\n\t\treturn UNBLOCK_STOP_POST;\n\n\treturn UNBLOCK_CONTINUE_POST;\n}"
  },
  {
    "function_name": "ocfs2_dentry_post_unlock",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlmglue.c",
    "lines": "3664-3669",
    "snippet": "static void ocfs2_dentry_post_unlock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres)\n{\n\tstruct ocfs2_dentry_lock *dl = ocfs2_lock_res_dl(lockres);\n\tocfs2_dentry_lock_put(osb, dl);\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"refcounttree.h\"",
      "#include \"quota.h\"",
      "#include \"uptodate.h\"",
      "#include \"super.h\"",
      "#include \"slot_map.h\"",
      "#include \"stackglue.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"heartbeat.h\"",
      "#include \"file.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"dcache.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2_lockingver.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/time.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/kthread.h>",
      "#include <linux/mm.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct ocfs2_super *ocfs2_get_dentry_osb(struct ocfs2_lock_res *lockres);",
      "static struct ocfs2_super *ocfs2_get_inode_osb(struct ocfs2_lock_res *lockres);",
      "static struct ocfs2_super *ocfs2_get_file_osb(struct ocfs2_lock_res *lockres);",
      "static struct ocfs2_super *ocfs2_get_qinfo_osb(struct ocfs2_lock_res *lockres);",
      "static void ocfs2_set_meta_lvb(struct ocfs2_lock_res *lockres);",
      "static void ocfs2_dentry_post_unlock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres);",
      "static void ocfs2_set_qinfo_lvb(struct ocfs2_lock_res *lockres);",
      "static inline void ocfs2_generic_handle_downconvert_action(struct ocfs2_lock_res *lockres);",
      "static inline void ocfs2_generic_handle_convert_action(struct ocfs2_lock_res *lockres);",
      "static inline void ocfs2_generic_handle_attach_action(struct ocfs2_lock_res *lockres);",
      "static void ocfs2_schedule_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);",
      "static void ocfs2_downconvert_on_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);",
      "static void ocfs2_drop_osb_locks(struct ocfs2_super *osb);",
      "static int ocfs2_prepare_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\t        struct ocfs2_lock_res *lockres);",
      "static int ocfs2_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres);",
      "static void ocfs2_process_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *lockres);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ocfs2_dentry_lock_put",
          "args": [
            "osb",
            "dl"
          ],
          "line": 3668
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_dentry_lock_put",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dcache.c",
          "lines": "378-392",
          "snippet": "void ocfs2_dentry_lock_put(struct ocfs2_super *osb,\n\t\t\t   struct ocfs2_dentry_lock *dl)\n{\n\tint unlock = 0;\n\n\tBUG_ON(dl->dl_count == 0);\n\n\tspin_lock(&dentry_attach_lock);\n\tdl->dl_count--;\n\tunlock = !dl->dl_count;\n\tspin_unlock(&dentry_attach_lock);\n\n\tif (unlock)\n\t\tocfs2_drop_dentry_lock(osb, dl);\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dcache.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"dlmglue.h\"\n#include \"dcache.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nvoid ocfs2_dentry_lock_put(struct ocfs2_super *osb,\n\t\t\t   struct ocfs2_dentry_lock *dl)\n{\n\tint unlock = 0;\n\n\tBUG_ON(dl->dl_count == 0);\n\n\tspin_lock(&dentry_attach_lock);\n\tdl->dl_count--;\n\tunlock = !dl->dl_count;\n\tspin_unlock(&dentry_attach_lock);\n\n\tif (unlock)\n\t\tocfs2_drop_dentry_lock(osb, dl);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_lock_res_dl",
          "args": [
            "lockres"
          ],
          "line": 3667
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_lock_res_dl",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlmglue.c",
          "lines": "312-317",
          "snippet": "static inline struct ocfs2_dentry_lock *ocfs2_lock_res_dl(struct ocfs2_lock_res *lockres)\n{\n\tBUG_ON(lockres->l_type != OCFS2_LOCK_TYPE_DENTRY);\n\n\treturn (struct ocfs2_dentry_lock *)lockres->l_priv;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"refcounttree.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"stackglue.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dcache.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2_lockingver.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/time.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/kthread.h>",
            "#include <linux/mm.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct ocfs2_super *ocfs2_get_dentry_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_inode_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_file_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_qinfo_osb(struct ocfs2_lock_res *lockres);",
            "static void ocfs2_set_meta_lvb(struct ocfs2_lock_res *lockres);",
            "static void ocfs2_dentry_post_unlock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres);",
            "static void ocfs2_set_qinfo_lvb(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_downconvert_action(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_convert_action(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_attach_action(struct ocfs2_lock_res *lockres);",
            "static void ocfs2_schedule_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static void ocfs2_downconvert_on_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static int ocfs2_prepare_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\t        struct ocfs2_lock_res *lockres);",
            "static int ocfs2_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static void ocfs2_process_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *lockres);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"stackglue.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dcache.h\"\n#include \"alloc.h\"\n#include \"ocfs2_lockingver.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/quotaops.h>\n#include <linux/time.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/pagemap.h>\n#include <linux/kthread.h>\n#include <linux/mm.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic struct ocfs2_super *ocfs2_get_dentry_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_inode_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_file_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_qinfo_osb(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_set_meta_lvb(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_dentry_post_unlock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres);\nstatic void ocfs2_set_qinfo_lvb(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_downconvert_action(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_convert_action(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_attach_action(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_schedule_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_downconvert_on_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic int ocfs2_prepare_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\t        struct ocfs2_lock_res *lockres);\nstatic int ocfs2_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_process_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *lockres);\n\nstatic inline struct ocfs2_dentry_lock *ocfs2_lock_res_dl(struct ocfs2_lock_res *lockres)\n{\n\tBUG_ON(lockres->l_type != OCFS2_LOCK_TYPE_DENTRY);\n\n\treturn (struct ocfs2_dentry_lock *)lockres->l_priv;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"stackglue.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dcache.h\"\n#include \"alloc.h\"\n#include \"ocfs2_lockingver.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/quotaops.h>\n#include <linux/time.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/pagemap.h>\n#include <linux/kthread.h>\n#include <linux/mm.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic struct ocfs2_super *ocfs2_get_dentry_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_inode_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_file_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_qinfo_osb(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_set_meta_lvb(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_dentry_post_unlock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres);\nstatic void ocfs2_set_qinfo_lvb(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_downconvert_action(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_convert_action(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_attach_action(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_schedule_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_downconvert_on_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_drop_osb_locks(struct ocfs2_super *osb);\nstatic int ocfs2_prepare_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\t        struct ocfs2_lock_res *lockres);\nstatic int ocfs2_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_process_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *lockres);\n\nstatic void ocfs2_dentry_post_unlock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres)\n{\n\tstruct ocfs2_dentry_lock *dl = ocfs2_lock_res_dl(lockres);\n\tocfs2_dentry_lock_put(osb, dl);\n}"
  },
  {
    "function_name": "ocfs2_set_meta_lvb",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlmglue.c",
    "lines": "3652-3657",
    "snippet": "static void ocfs2_set_meta_lvb(struct ocfs2_lock_res *lockres)\n{\n\tstruct inode *inode = ocfs2_lock_res_inode(lockres);\n\n\t__ocfs2_stuff_meta_lvb(inode);\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"refcounttree.h\"",
      "#include \"quota.h\"",
      "#include \"uptodate.h\"",
      "#include \"super.h\"",
      "#include \"slot_map.h\"",
      "#include \"stackglue.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"heartbeat.h\"",
      "#include \"file.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"dcache.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2_lockingver.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/time.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/kthread.h>",
      "#include <linux/mm.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct ocfs2_super *ocfs2_get_dentry_osb(struct ocfs2_lock_res *lockres);",
      "static struct ocfs2_super *ocfs2_get_inode_osb(struct ocfs2_lock_res *lockres);",
      "static struct ocfs2_super *ocfs2_get_file_osb(struct ocfs2_lock_res *lockres);",
      "static struct ocfs2_super *ocfs2_get_qinfo_osb(struct ocfs2_lock_res *lockres);",
      "static void ocfs2_set_meta_lvb(struct ocfs2_lock_res *lockres);",
      "static void ocfs2_dentry_post_unlock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres);",
      "static void ocfs2_set_qinfo_lvb(struct ocfs2_lock_res *lockres);",
      "static inline void ocfs2_generic_handle_downconvert_action(struct ocfs2_lock_res *lockres);",
      "static inline void ocfs2_generic_handle_convert_action(struct ocfs2_lock_res *lockres);",
      "static inline void ocfs2_generic_handle_attach_action(struct ocfs2_lock_res *lockres);",
      "static void ocfs2_schedule_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);",
      "static void ocfs2_downconvert_on_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);",
      "static int ocfs2_prepare_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\t        struct ocfs2_lock_res *lockres);",
      "static int ocfs2_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres);",
      "static void ocfs2_process_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *lockres);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "__ocfs2_stuff_meta_lvb",
          "args": [
            "inode"
          ],
          "line": 3656
        },
        "resolved": true,
        "details": {
          "function_name": "__ocfs2_stuff_meta_lvb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlmglue.c",
          "lines": "2052-2089",
          "snippet": "static void __ocfs2_stuff_meta_lvb(struct inode *inode)\n{\n\tstruct ocfs2_inode_info *oi = OCFS2_I(inode);\n\tstruct ocfs2_lock_res *lockres = &oi->ip_inode_lockres;\n\tstruct ocfs2_meta_lvb *lvb;\n\n\tlvb = ocfs2_dlm_lvb(&lockres->l_lksb);\n\n\t/*\n\t * Invalidate the LVB of a deleted inode - this way other\n\t * nodes are forced to go to disk and discover the new inode\n\t * status.\n\t */\n\tif (oi->ip_flags & OCFS2_INODE_DELETED) {\n\t\tlvb->lvb_version = 0;\n\t\tgoto out;\n\t}\n\n\tlvb->lvb_version   = OCFS2_LVB_VERSION;\n\tlvb->lvb_isize\t   = cpu_to_be64(i_size_read(inode));\n\tlvb->lvb_iclusters = cpu_to_be32(oi->ip_clusters);\n\tlvb->lvb_iuid      = cpu_to_be32(i_uid_read(inode));\n\tlvb->lvb_igid      = cpu_to_be32(i_gid_read(inode));\n\tlvb->lvb_imode     = cpu_to_be16(inode->i_mode);\n\tlvb->lvb_inlink    = cpu_to_be16(inode->i_nlink);\n\tlvb->lvb_iatime_packed  =\n\t\tcpu_to_be64(ocfs2_pack_timespec(&inode->i_atime));\n\tlvb->lvb_ictime_packed =\n\t\tcpu_to_be64(ocfs2_pack_timespec(&inode->i_ctime));\n\tlvb->lvb_imtime_packed =\n\t\tcpu_to_be64(ocfs2_pack_timespec(&inode->i_mtime));\n\tlvb->lvb_iattr    = cpu_to_be32(oi->ip_attr);\n\tlvb->lvb_idynfeatures = cpu_to_be16(oi->ip_dyn_features);\n\tlvb->lvb_igeneration = cpu_to_be32(inode->i_generation);\n\nout:\n\tmlog_meta_lvb(0, lockres);\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"refcounttree.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"stackglue.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dcache.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2_lockingver.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/time.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/kthread.h>",
            "#include <linux/mm.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct ocfs2_super *ocfs2_get_dentry_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_inode_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_file_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_qinfo_osb(struct ocfs2_lock_res *lockres);",
            "static void ocfs2_set_meta_lvb(struct ocfs2_lock_res *lockres);",
            "static void ocfs2_dentry_post_unlock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres);",
            "static void ocfs2_set_qinfo_lvb(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_downconvert_action(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_convert_action(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_attach_action(struct ocfs2_lock_res *lockres);",
            "static void ocfs2_schedule_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static void ocfs2_downconvert_on_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static int ocfs2_prepare_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\t        struct ocfs2_lock_res *lockres);",
            "static int ocfs2_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static void ocfs2_process_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *lockres);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"stackglue.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dcache.h\"\n#include \"alloc.h\"\n#include \"ocfs2_lockingver.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/quotaops.h>\n#include <linux/time.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/pagemap.h>\n#include <linux/kthread.h>\n#include <linux/mm.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic struct ocfs2_super *ocfs2_get_dentry_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_inode_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_file_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_qinfo_osb(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_set_meta_lvb(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_dentry_post_unlock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres);\nstatic void ocfs2_set_qinfo_lvb(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_downconvert_action(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_convert_action(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_attach_action(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_schedule_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_downconvert_on_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic int ocfs2_prepare_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\t        struct ocfs2_lock_res *lockres);\nstatic int ocfs2_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_process_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *lockres);\n\nstatic void __ocfs2_stuff_meta_lvb(struct inode *inode)\n{\n\tstruct ocfs2_inode_info *oi = OCFS2_I(inode);\n\tstruct ocfs2_lock_res *lockres = &oi->ip_inode_lockres;\n\tstruct ocfs2_meta_lvb *lvb;\n\n\tlvb = ocfs2_dlm_lvb(&lockres->l_lksb);\n\n\t/*\n\t * Invalidate the LVB of a deleted inode - this way other\n\t * nodes are forced to go to disk and discover the new inode\n\t * status.\n\t */\n\tif (oi->ip_flags & OCFS2_INODE_DELETED) {\n\t\tlvb->lvb_version = 0;\n\t\tgoto out;\n\t}\n\n\tlvb->lvb_version   = OCFS2_LVB_VERSION;\n\tlvb->lvb_isize\t   = cpu_to_be64(i_size_read(inode));\n\tlvb->lvb_iclusters = cpu_to_be32(oi->ip_clusters);\n\tlvb->lvb_iuid      = cpu_to_be32(i_uid_read(inode));\n\tlvb->lvb_igid      = cpu_to_be32(i_gid_read(inode));\n\tlvb->lvb_imode     = cpu_to_be16(inode->i_mode);\n\tlvb->lvb_inlink    = cpu_to_be16(inode->i_nlink);\n\tlvb->lvb_iatime_packed  =\n\t\tcpu_to_be64(ocfs2_pack_timespec(&inode->i_atime));\n\tlvb->lvb_ictime_packed =\n\t\tcpu_to_be64(ocfs2_pack_timespec(&inode->i_ctime));\n\tlvb->lvb_imtime_packed =\n\t\tcpu_to_be64(ocfs2_pack_timespec(&inode->i_mtime));\n\tlvb->lvb_iattr    = cpu_to_be32(oi->ip_attr);\n\tlvb->lvb_idynfeatures = cpu_to_be16(oi->ip_dyn_features);\n\tlvb->lvb_igeneration = cpu_to_be32(inode->i_generation);\n\nout:\n\tmlog_meta_lvb(0, lockres);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_lock_res_inode",
          "args": [
            "lockres"
          ],
          "line": 3654
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_lock_res_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlmglue.c",
          "lines": "305-310",
          "snippet": "static inline struct inode *ocfs2_lock_res_inode(struct ocfs2_lock_res *lockres)\n{\n\tBUG_ON(!ocfs2_is_inode_lock(lockres));\n\n\treturn (struct inode *) lockres->l_priv;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"refcounttree.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"stackglue.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dcache.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2_lockingver.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/time.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/kthread.h>",
            "#include <linux/mm.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct ocfs2_super *ocfs2_get_dentry_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_inode_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_file_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_qinfo_osb(struct ocfs2_lock_res *lockres);",
            "static void ocfs2_set_meta_lvb(struct ocfs2_lock_res *lockres);",
            "static void ocfs2_dentry_post_unlock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres);",
            "static void ocfs2_set_qinfo_lvb(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_downconvert_action(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_convert_action(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_attach_action(struct ocfs2_lock_res *lockres);",
            "static void ocfs2_schedule_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static void ocfs2_downconvert_on_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static int ocfs2_prepare_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\t        struct ocfs2_lock_res *lockres);",
            "static int ocfs2_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static void ocfs2_process_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *lockres);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"stackglue.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dcache.h\"\n#include \"alloc.h\"\n#include \"ocfs2_lockingver.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/quotaops.h>\n#include <linux/time.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/pagemap.h>\n#include <linux/kthread.h>\n#include <linux/mm.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic struct ocfs2_super *ocfs2_get_dentry_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_inode_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_file_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_qinfo_osb(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_set_meta_lvb(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_dentry_post_unlock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres);\nstatic void ocfs2_set_qinfo_lvb(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_downconvert_action(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_convert_action(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_attach_action(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_schedule_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_downconvert_on_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic int ocfs2_prepare_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\t        struct ocfs2_lock_res *lockres);\nstatic int ocfs2_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_process_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *lockres);\n\nstatic inline struct inode *ocfs2_lock_res_inode(struct ocfs2_lock_res *lockres)\n{\n\tBUG_ON(!ocfs2_is_inode_lock(lockres));\n\n\treturn (struct inode *) lockres->l_priv;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"stackglue.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dcache.h\"\n#include \"alloc.h\"\n#include \"ocfs2_lockingver.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/quotaops.h>\n#include <linux/time.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/pagemap.h>\n#include <linux/kthread.h>\n#include <linux/mm.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic struct ocfs2_super *ocfs2_get_dentry_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_inode_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_file_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_qinfo_osb(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_set_meta_lvb(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_dentry_post_unlock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres);\nstatic void ocfs2_set_qinfo_lvb(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_downconvert_action(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_convert_action(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_attach_action(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_schedule_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_downconvert_on_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic int ocfs2_prepare_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\t        struct ocfs2_lock_res *lockres);\nstatic int ocfs2_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_process_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *lockres);\n\nstatic void ocfs2_set_meta_lvb(struct ocfs2_lock_res *lockres)\n{\n\tstruct inode *inode = ocfs2_lock_res_inode(lockres);\n\n\t__ocfs2_stuff_meta_lvb(inode);\n}"
  },
  {
    "function_name": "ocfs2_check_meta_downconvert",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlmglue.c",
    "lines": "3644-3650",
    "snippet": "static int ocfs2_check_meta_downconvert(struct ocfs2_lock_res *lockres,\n\t\t\t\t\tint new_level)\n{\n\tstruct inode *inode = ocfs2_lock_res_inode(lockres);\n\n\treturn ocfs2_ci_checkpointed(INODE_CACHE(inode), lockres, new_level);\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"refcounttree.h\"",
      "#include \"quota.h\"",
      "#include \"uptodate.h\"",
      "#include \"super.h\"",
      "#include \"slot_map.h\"",
      "#include \"stackglue.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"heartbeat.h\"",
      "#include \"file.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"dcache.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2_lockingver.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/time.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/kthread.h>",
      "#include <linux/mm.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct ocfs2_super *ocfs2_get_dentry_osb(struct ocfs2_lock_res *lockres);",
      "static struct ocfs2_super *ocfs2_get_inode_osb(struct ocfs2_lock_res *lockres);",
      "static struct ocfs2_super *ocfs2_get_file_osb(struct ocfs2_lock_res *lockres);",
      "static struct ocfs2_super *ocfs2_get_qinfo_osb(struct ocfs2_lock_res *lockres);",
      "static int ocfs2_check_meta_downconvert(struct ocfs2_lock_res *lockres,\n\t\t\t\t\tint new_level);",
      "static void ocfs2_set_meta_lvb(struct ocfs2_lock_res *lockres);",
      "static void ocfs2_dentry_post_unlock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres);",
      "static void ocfs2_set_qinfo_lvb(struct ocfs2_lock_res *lockres);",
      "static int ocfs2_check_refcount_downconvert(struct ocfs2_lock_res *lockres,\n\t\t\t\t\t    int new_level);",
      "static inline void ocfs2_generic_handle_downconvert_action(struct ocfs2_lock_res *lockres);",
      "static inline void ocfs2_generic_handle_convert_action(struct ocfs2_lock_res *lockres);",
      "static inline void ocfs2_generic_handle_attach_action(struct ocfs2_lock_res *lockres);",
      "static void ocfs2_schedule_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);",
      "static void ocfs2_downconvert_on_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);",
      "static unsigned int ocfs2_prepare_downconvert(struct ocfs2_lock_res *lockres,\n\t\t\t\t\t      int new_level);",
      "static int ocfs2_prepare_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\t        struct ocfs2_lock_res *lockres);",
      "static int ocfs2_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres);",
      "static void ocfs2_process_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *lockres);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ocfs2_ci_checkpointed",
          "args": [
            "INODE_CACHE(inode)",
            "lockres",
            "new_level"
          ],
          "line": 3649
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_ci_checkpointed",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlmglue.c",
          "lines": "3628-3642",
          "snippet": "static int ocfs2_ci_checkpointed(struct ocfs2_caching_info *ci,\n\t\t\t\t struct ocfs2_lock_res *lockres,\n\t\t\t\t int new_level)\n{\n\tint checkpointed = ocfs2_ci_fully_checkpointed(ci);\n\n\tBUG_ON(new_level != DLM_LOCK_NL && new_level != DLM_LOCK_PR);\n\tBUG_ON(lockres->l_level != DLM_LOCK_EX && !checkpointed);\n\n\tif (checkpointed)\n\t\treturn 1;\n\n\tocfs2_start_checkpoint(OCFS2_SB(ocfs2_metadata_cache_get_super(ci)));\n\treturn 0;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"refcounttree.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"stackglue.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dcache.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2_lockingver.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/time.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/kthread.h>",
            "#include <linux/mm.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct ocfs2_super *ocfs2_get_dentry_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_inode_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_file_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_qinfo_osb(struct ocfs2_lock_res *lockres);",
            "static int ocfs2_check_meta_downconvert(struct ocfs2_lock_res *lockres,\n\t\t\t\t\tint new_level);",
            "static void ocfs2_set_meta_lvb(struct ocfs2_lock_res *lockres);",
            "static void ocfs2_dentry_post_unlock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres);",
            "static void ocfs2_set_qinfo_lvb(struct ocfs2_lock_res *lockres);",
            "static int ocfs2_check_refcount_downconvert(struct ocfs2_lock_res *lockres,\n\t\t\t\t\t    int new_level);",
            "static inline void ocfs2_generic_handle_downconvert_action(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_convert_action(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_attach_action(struct ocfs2_lock_res *lockres);",
            "static void ocfs2_schedule_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static void ocfs2_downconvert_on_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static unsigned int ocfs2_prepare_downconvert(struct ocfs2_lock_res *lockres,\n\t\t\t\t\t      int new_level);",
            "static int ocfs2_prepare_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\t        struct ocfs2_lock_res *lockres);",
            "static int ocfs2_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static void ocfs2_process_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *lockres);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"stackglue.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dcache.h\"\n#include \"alloc.h\"\n#include \"ocfs2_lockingver.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/quotaops.h>\n#include <linux/time.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/pagemap.h>\n#include <linux/kthread.h>\n#include <linux/mm.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic struct ocfs2_super *ocfs2_get_dentry_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_inode_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_file_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_qinfo_osb(struct ocfs2_lock_res *lockres);\nstatic int ocfs2_check_meta_downconvert(struct ocfs2_lock_res *lockres,\n\t\t\t\t\tint new_level);\nstatic void ocfs2_set_meta_lvb(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_dentry_post_unlock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres);\nstatic void ocfs2_set_qinfo_lvb(struct ocfs2_lock_res *lockres);\nstatic int ocfs2_check_refcount_downconvert(struct ocfs2_lock_res *lockres,\n\t\t\t\t\t    int new_level);\nstatic inline void ocfs2_generic_handle_downconvert_action(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_convert_action(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_attach_action(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_schedule_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_downconvert_on_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic unsigned int ocfs2_prepare_downconvert(struct ocfs2_lock_res *lockres,\n\t\t\t\t\t      int new_level);\nstatic int ocfs2_prepare_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\t        struct ocfs2_lock_res *lockres);\nstatic int ocfs2_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_process_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *lockres);\n\nstatic int ocfs2_ci_checkpointed(struct ocfs2_caching_info *ci,\n\t\t\t\t struct ocfs2_lock_res *lockres,\n\t\t\t\t int new_level)\n{\n\tint checkpointed = ocfs2_ci_fully_checkpointed(ci);\n\n\tBUG_ON(new_level != DLM_LOCK_NL && new_level != DLM_LOCK_PR);\n\tBUG_ON(lockres->l_level != DLM_LOCK_EX && !checkpointed);\n\n\tif (checkpointed)\n\t\treturn 1;\n\n\tocfs2_start_checkpoint(OCFS2_SB(ocfs2_metadata_cache_get_super(ci)));\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "INODE_CACHE",
          "args": [
            "inode"
          ],
          "line": 3649
        },
        "resolved": true,
        "details": {
          "function_name": "INODE_CACHE",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/inode.h",
          "lines": "131-134",
          "snippet": "static inline struct ocfs2_caching_info *INODE_CACHE(struct inode *inode)\n{\n\treturn &OCFS2_I(inode)->ip_metadata_cache;\n}",
          "includes": [
            "#include \"extent_map.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extent_map.h\"\n\nstatic inline struct ocfs2_caching_info *INODE_CACHE(struct inode *inode)\n{\n\treturn &OCFS2_I(inode)->ip_metadata_cache;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_lock_res_inode",
          "args": [
            "lockres"
          ],
          "line": 3647
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_lock_res_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlmglue.c",
          "lines": "305-310",
          "snippet": "static inline struct inode *ocfs2_lock_res_inode(struct ocfs2_lock_res *lockres)\n{\n\tBUG_ON(!ocfs2_is_inode_lock(lockres));\n\n\treturn (struct inode *) lockres->l_priv;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"refcounttree.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"stackglue.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dcache.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2_lockingver.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/time.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/kthread.h>",
            "#include <linux/mm.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct ocfs2_super *ocfs2_get_dentry_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_inode_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_file_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_qinfo_osb(struct ocfs2_lock_res *lockres);",
            "static void ocfs2_set_meta_lvb(struct ocfs2_lock_res *lockres);",
            "static void ocfs2_dentry_post_unlock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres);",
            "static void ocfs2_set_qinfo_lvb(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_downconvert_action(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_convert_action(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_attach_action(struct ocfs2_lock_res *lockres);",
            "static void ocfs2_schedule_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static void ocfs2_downconvert_on_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static int ocfs2_prepare_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\t        struct ocfs2_lock_res *lockres);",
            "static int ocfs2_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static void ocfs2_process_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *lockres);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"stackglue.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dcache.h\"\n#include \"alloc.h\"\n#include \"ocfs2_lockingver.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/quotaops.h>\n#include <linux/time.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/pagemap.h>\n#include <linux/kthread.h>\n#include <linux/mm.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic struct ocfs2_super *ocfs2_get_dentry_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_inode_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_file_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_qinfo_osb(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_set_meta_lvb(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_dentry_post_unlock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres);\nstatic void ocfs2_set_qinfo_lvb(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_downconvert_action(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_convert_action(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_attach_action(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_schedule_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_downconvert_on_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic int ocfs2_prepare_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\t        struct ocfs2_lock_res *lockres);\nstatic int ocfs2_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_process_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *lockres);\n\nstatic inline struct inode *ocfs2_lock_res_inode(struct ocfs2_lock_res *lockres)\n{\n\tBUG_ON(!ocfs2_is_inode_lock(lockres));\n\n\treturn (struct inode *) lockres->l_priv;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"stackglue.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dcache.h\"\n#include \"alloc.h\"\n#include \"ocfs2_lockingver.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/quotaops.h>\n#include <linux/time.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/pagemap.h>\n#include <linux/kthread.h>\n#include <linux/mm.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic struct ocfs2_super *ocfs2_get_dentry_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_inode_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_file_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_qinfo_osb(struct ocfs2_lock_res *lockres);\nstatic int ocfs2_check_meta_downconvert(struct ocfs2_lock_res *lockres,\n\t\t\t\t\tint new_level);\nstatic void ocfs2_set_meta_lvb(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_dentry_post_unlock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres);\nstatic void ocfs2_set_qinfo_lvb(struct ocfs2_lock_res *lockres);\nstatic int ocfs2_check_refcount_downconvert(struct ocfs2_lock_res *lockres,\n\t\t\t\t\t    int new_level);\nstatic inline void ocfs2_generic_handle_downconvert_action(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_convert_action(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_attach_action(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_schedule_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_downconvert_on_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic unsigned int ocfs2_prepare_downconvert(struct ocfs2_lock_res *lockres,\n\t\t\t\t\t      int new_level);\nstatic int ocfs2_prepare_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\t        struct ocfs2_lock_res *lockres);\nstatic int ocfs2_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_process_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *lockres);\n\nstatic int ocfs2_check_meta_downconvert(struct ocfs2_lock_res *lockres,\n\t\t\t\t\tint new_level)\n{\n\tstruct inode *inode = ocfs2_lock_res_inode(lockres);\n\n\treturn ocfs2_ci_checkpointed(INODE_CACHE(inode), lockres, new_level);\n}"
  },
  {
    "function_name": "ocfs2_ci_checkpointed",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlmglue.c",
    "lines": "3628-3642",
    "snippet": "static int ocfs2_ci_checkpointed(struct ocfs2_caching_info *ci,\n\t\t\t\t struct ocfs2_lock_res *lockres,\n\t\t\t\t int new_level)\n{\n\tint checkpointed = ocfs2_ci_fully_checkpointed(ci);\n\n\tBUG_ON(new_level != DLM_LOCK_NL && new_level != DLM_LOCK_PR);\n\tBUG_ON(lockres->l_level != DLM_LOCK_EX && !checkpointed);\n\n\tif (checkpointed)\n\t\treturn 1;\n\n\tocfs2_start_checkpoint(OCFS2_SB(ocfs2_metadata_cache_get_super(ci)));\n\treturn 0;\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"refcounttree.h\"",
      "#include \"quota.h\"",
      "#include \"uptodate.h\"",
      "#include \"super.h\"",
      "#include \"slot_map.h\"",
      "#include \"stackglue.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"heartbeat.h\"",
      "#include \"file.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"dcache.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2_lockingver.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/time.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/kthread.h>",
      "#include <linux/mm.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct ocfs2_super *ocfs2_get_dentry_osb(struct ocfs2_lock_res *lockres);",
      "static struct ocfs2_super *ocfs2_get_inode_osb(struct ocfs2_lock_res *lockres);",
      "static struct ocfs2_super *ocfs2_get_file_osb(struct ocfs2_lock_res *lockres);",
      "static struct ocfs2_super *ocfs2_get_qinfo_osb(struct ocfs2_lock_res *lockres);",
      "static int ocfs2_check_meta_downconvert(struct ocfs2_lock_res *lockres,\n\t\t\t\t\tint new_level);",
      "static void ocfs2_set_meta_lvb(struct ocfs2_lock_res *lockres);",
      "static void ocfs2_dentry_post_unlock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres);",
      "static void ocfs2_set_qinfo_lvb(struct ocfs2_lock_res *lockres);",
      "static int ocfs2_check_refcount_downconvert(struct ocfs2_lock_res *lockres,\n\t\t\t\t\t    int new_level);",
      "static inline void ocfs2_generic_handle_downconvert_action(struct ocfs2_lock_res *lockres);",
      "static inline void ocfs2_generic_handle_convert_action(struct ocfs2_lock_res *lockres);",
      "static inline void ocfs2_generic_handle_attach_action(struct ocfs2_lock_res *lockres);",
      "static void ocfs2_schedule_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);",
      "static void ocfs2_downconvert_on_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);",
      "static unsigned int ocfs2_prepare_downconvert(struct ocfs2_lock_res *lockres,\n\t\t\t\t\t      int new_level);",
      "static int ocfs2_prepare_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\t        struct ocfs2_lock_res *lockres);",
      "static int ocfs2_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres);",
      "static void ocfs2_process_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *lockres);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ocfs2_start_checkpoint",
          "args": [
            "OCFS2_SB(ocfs2_metadata_cache_get_super(ci))"
          ],
          "line": 3640
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_start_checkpoint",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/journal.h",
          "lines": "201-204",
          "snippet": "static inline void ocfs2_start_checkpoint(struct ocfs2_super *osb)\n{\n\twake_up(&osb->checkpoint_event);\n}",
          "includes": [
            "#include <linux/jbd2.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/jbd2.h>\n#include <linux/fs.h>\n\nstatic inline void ocfs2_start_checkpoint(struct ocfs2_super *osb)\n{\n\twake_up(&osb->checkpoint_event);\n}"
        }
      },
      {
        "call_info": {
          "callee": "OCFS2_SB",
          "args": [
            "ocfs2_metadata_cache_get_super(ci)"
          ],
          "line": 3640
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_metadata_cache_get_super",
          "args": [
            "ci"
          ],
          "line": 3640
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_metadata_cache_get_super",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/uptodate.c",
          "lines": "79-84",
          "snippet": "struct super_block *ocfs2_metadata_cache_get_super(struct ocfs2_caching_info *ci)\n{\n\tBUG_ON(!ci || !ci->ci_ops);\n\n\treturn ci->ci_ops->co_get_super(ci);\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"inode.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"inode.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/rbtree.h>\n#include <linux/buffer_head.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstruct super_block *ocfs2_metadata_cache_get_super(struct ocfs2_caching_info *ci)\n{\n\tBUG_ON(!ci || !ci->ci_ops);\n\n\treturn ci->ci_ops->co_get_super(ci);\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "lockres->l_level != DLM_LOCK_EX && !checkpointed"
          ],
          "line": 3635
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "new_level != DLM_LOCK_NL && new_level != DLM_LOCK_PR"
          ],
          "line": 3634
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_ci_fully_checkpointed",
          "args": [
            "ci"
          ],
          "line": 3632
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_ci_fully_checkpointed",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/journal.h",
          "lines": "107-117",
          "snippet": "static inline int ocfs2_ci_fully_checkpointed(struct ocfs2_caching_info *ci)\n{\n\tint ret;\n\tstruct ocfs2_journal *journal =\n\t\tOCFS2_SB(ocfs2_metadata_cache_get_super(ci))->journal;\n\n\tspin_lock(&trans_inc_lock);\n\tret = time_after(journal->j_trans_id, ci->ci_last_trans);\n\tspin_unlock(&trans_inc_lock);\n\treturn ret;\n}",
          "includes": [
            "#include <linux/jbd2.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/jbd2.h>\n#include <linux/fs.h>\n\nstatic inline int ocfs2_ci_fully_checkpointed(struct ocfs2_caching_info *ci)\n{\n\tint ret;\n\tstruct ocfs2_journal *journal =\n\t\tOCFS2_SB(ocfs2_metadata_cache_get_super(ci))->journal;\n\n\tspin_lock(&trans_inc_lock);\n\tret = time_after(journal->j_trans_id, ci->ci_last_trans);\n\tspin_unlock(&trans_inc_lock);\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"stackglue.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dcache.h\"\n#include \"alloc.h\"\n#include \"ocfs2_lockingver.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/quotaops.h>\n#include <linux/time.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/pagemap.h>\n#include <linux/kthread.h>\n#include <linux/mm.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic struct ocfs2_super *ocfs2_get_dentry_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_inode_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_file_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_qinfo_osb(struct ocfs2_lock_res *lockres);\nstatic int ocfs2_check_meta_downconvert(struct ocfs2_lock_res *lockres,\n\t\t\t\t\tint new_level);\nstatic void ocfs2_set_meta_lvb(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_dentry_post_unlock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres);\nstatic void ocfs2_set_qinfo_lvb(struct ocfs2_lock_res *lockres);\nstatic int ocfs2_check_refcount_downconvert(struct ocfs2_lock_res *lockres,\n\t\t\t\t\t    int new_level);\nstatic inline void ocfs2_generic_handle_downconvert_action(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_convert_action(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_attach_action(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_schedule_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_downconvert_on_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic unsigned int ocfs2_prepare_downconvert(struct ocfs2_lock_res *lockres,\n\t\t\t\t\t      int new_level);\nstatic int ocfs2_prepare_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\t        struct ocfs2_lock_res *lockres);\nstatic int ocfs2_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_process_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *lockres);\n\nstatic int ocfs2_ci_checkpointed(struct ocfs2_caching_info *ci,\n\t\t\t\t struct ocfs2_lock_res *lockres,\n\t\t\t\t int new_level)\n{\n\tint checkpointed = ocfs2_ci_fully_checkpointed(ci);\n\n\tBUG_ON(new_level != DLM_LOCK_NL && new_level != DLM_LOCK_PR);\n\tBUG_ON(lockres->l_level != DLM_LOCK_EX && !checkpointed);\n\n\tif (checkpointed)\n\t\treturn 1;\n\n\tocfs2_start_checkpoint(OCFS2_SB(ocfs2_metadata_cache_get_super(ci)));\n\treturn 0;\n}"
  },
  {
    "function_name": "ocfs2_data_convert_worker",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlmglue.c",
    "lines": "3579-3626",
    "snippet": "static int ocfs2_data_convert_worker(struct ocfs2_lock_res *lockres,\n\t\t\t\t     int blocking)\n{\n\tstruct inode *inode;\n\tstruct address_space *mapping;\n\tstruct ocfs2_inode_info *oi;\n\n       \tinode = ocfs2_lock_res_inode(lockres);\n\tmapping = inode->i_mapping;\n\n\tif (S_ISDIR(inode->i_mode)) {\n\t\toi = OCFS2_I(inode);\n\t\toi->ip_dir_lock_gen++;\n\t\tmlog(0, \"generation: %u\\n\", oi->ip_dir_lock_gen);\n\t\tgoto out;\n\t}\n\n\tif (!S_ISREG(inode->i_mode))\n\t\tgoto out;\n\n\t/*\n\t * We need this before the filemap_fdatawrite() so that it can\n\t * transfer the dirty bit from the PTE to the\n\t * page. Unfortunately this means that even for EX->PR\n\t * downconverts, we'll lose our mappings and have to build\n\t * them up again.\n\t */\n\tunmap_mapping_range(mapping, 0, 0, 0);\n\n\tif (filemap_fdatawrite(mapping)) {\n\t\tmlog(ML_ERROR, \"Could not sync inode %llu for downconvert!\",\n\t\t     (unsigned long long)OCFS2_I(inode)->ip_blkno);\n\t}\n\tsync_mapping_buffers(mapping);\n\tif (blocking == DLM_LOCK_EX) {\n\t\ttruncate_inode_pages(mapping, 0);\n\t} else {\n\t\t/* We only need to wait on the I/O if we're not also\n\t\t * truncating pages because truncate_inode_pages waits\n\t\t * for us above. We don't truncate pages if we're\n\t\t * blocking anything < EXMODE because we want to keep\n\t\t * them around in that case. */\n\t\tfilemap_fdatawait(mapping);\n\t}\n\nout:\n\treturn UNBLOCK_CONTINUE;\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"refcounttree.h\"",
      "#include \"quota.h\"",
      "#include \"uptodate.h\"",
      "#include \"super.h\"",
      "#include \"slot_map.h\"",
      "#include \"stackglue.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"heartbeat.h\"",
      "#include \"file.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"dcache.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2_lockingver.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/time.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/kthread.h>",
      "#include <linux/mm.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct ocfs2_super *ocfs2_get_dentry_osb(struct ocfs2_lock_res *lockres);",
      "static struct ocfs2_super *ocfs2_get_inode_osb(struct ocfs2_lock_res *lockres);",
      "static struct ocfs2_super *ocfs2_get_file_osb(struct ocfs2_lock_res *lockres);",
      "static struct ocfs2_super *ocfs2_get_qinfo_osb(struct ocfs2_lock_res *lockres);",
      "static void ocfs2_set_meta_lvb(struct ocfs2_lock_res *lockres);",
      "static int ocfs2_data_convert_worker(struct ocfs2_lock_res *lockres,\n\t\t\t\t     int blocking);",
      "static int ocfs2_dentry_convert_worker(struct ocfs2_lock_res *lockres,\n\t\t\t\t       int blocking);",
      "static void ocfs2_dentry_post_unlock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres);",
      "static void ocfs2_set_qinfo_lvb(struct ocfs2_lock_res *lockres);",
      "static int ocfs2_refcount_convert_worker(struct ocfs2_lock_res *lockres,\n\t\t\t\t\t int blocking);",
      "static inline void ocfs2_generic_handle_downconvert_action(struct ocfs2_lock_res *lockres);",
      "static inline void ocfs2_generic_handle_convert_action(struct ocfs2_lock_res *lockres);",
      "static inline void ocfs2_generic_handle_attach_action(struct ocfs2_lock_res *lockres);",
      "static void ocfs2_schedule_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);",
      "static void ocfs2_downconvert_on_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);",
      "static int ocfs2_downconvert_lock(struct ocfs2_super *osb,\n\t\t\t\t  struct ocfs2_lock_res *lockres,\n\t\t\t\t  int new_level,\n\t\t\t\t  int lvb,\n\t\t\t\t  unsigned int generation);",
      "static int ocfs2_prepare_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\t        struct ocfs2_lock_res *lockres);",
      "static int ocfs2_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres);",
      "static void ocfs2_process_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *lockres);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "filemap_fdatawait",
          "args": [
            "mapping"
          ],
          "line": 3621
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "truncate_inode_pages",
          "args": [
            "mapping",
            "0"
          ],
          "line": 3614
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sync_mapping_buffers",
          "args": [
            "mapping"
          ],
          "line": 3612
        },
        "resolved": true,
        "details": {
          "function_name": "sync_mapping_buffers",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "570-579",
          "snippet": "int sync_mapping_buffers(struct address_space *mapping)\n{\n\tstruct address_space *buffer_mapping = mapping->private_data;\n\n\tif (buffer_mapping == NULL || list_empty(&mapping->private_list))\n\t\treturn 0;\n\n\treturn fsync_buffers_list(&buffer_mapping->private_lock,\n\t\t\t\t\t&mapping->private_list);\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nint sync_mapping_buffers(struct address_space *mapping)\n{\n\tstruct address_space *buffer_mapping = mapping->private_data;\n\n\tif (buffer_mapping == NULL || list_empty(&mapping->private_list))\n\t\treturn 0;\n\n\treturn fsync_buffers_list(&buffer_mapping->private_lock,\n\t\t\t\t\t&mapping->private_list);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog",
          "args": [
            "ML_ERROR",
            "\"Could not sync inode %llu for downconvert!\"",
            "(unsigned long long)OCFS2_I(inode)->ip_blkno"
          ],
          "line": 3609
        },
        "resolved": true,
        "details": {
          "function_name": "mlog_show",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/cluster/masklog.c",
          "lines": "107-113",
          "snippet": "static ssize_t mlog_show(struct kobject *obj, struct attribute *attr,\n\t\t\t char *buf)\n{\n\tstruct mlog_attribute *mlog_attr = to_mlog_attr(attr);\n\n\treturn mlog_mask_show(mlog_attr->mask, buf);\n}",
          "includes": [
            "#include \"masklog.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/string.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"masklog.h\"\n#include <asm/uaccess.h>\n#include <linux/string.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n\nstatic ssize_t mlog_show(struct kobject *obj, struct attribute *attr,\n\t\t\t char *buf)\n{\n\tstruct mlog_attribute *mlog_attr = to_mlog_attr(attr);\n\n\treturn mlog_mask_show(mlog_attr->mask, buf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "OCFS2_I",
          "args": [
            "inode"
          ],
          "line": 3610
        },
        "resolved": true,
        "details": {
          "function_name": "OCFS2_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/inode.h",
          "lines": "118-121",
          "snippet": "static inline struct ocfs2_inode_info *OCFS2_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ocfs2_inode_info, vfs_inode);\n}",
          "includes": [
            "#include \"extent_map.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extent_map.h\"\n\nstatic inline struct ocfs2_inode_info *OCFS2_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ocfs2_inode_info, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "filemap_fdatawrite",
          "args": [
            "mapping"
          ],
          "line": 3608
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unmap_mapping_range",
          "args": [
            "mapping",
            "0",
            "0",
            "0"
          ],
          "line": 3606
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISREG",
          "args": [
            "inode->i_mode"
          ],
          "line": 3596
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISDIR",
          "args": [
            "inode->i_mode"
          ],
          "line": 3589
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_lock_res_inode",
          "args": [
            "lockres"
          ],
          "line": 3586
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_lock_res_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlmglue.c",
          "lines": "305-310",
          "snippet": "static inline struct inode *ocfs2_lock_res_inode(struct ocfs2_lock_res *lockres)\n{\n\tBUG_ON(!ocfs2_is_inode_lock(lockres));\n\n\treturn (struct inode *) lockres->l_priv;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"refcounttree.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"stackglue.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dcache.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2_lockingver.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/time.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/kthread.h>",
            "#include <linux/mm.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct ocfs2_super *ocfs2_get_dentry_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_inode_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_file_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_qinfo_osb(struct ocfs2_lock_res *lockres);",
            "static void ocfs2_set_meta_lvb(struct ocfs2_lock_res *lockres);",
            "static void ocfs2_dentry_post_unlock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres);",
            "static void ocfs2_set_qinfo_lvb(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_downconvert_action(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_convert_action(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_attach_action(struct ocfs2_lock_res *lockres);",
            "static void ocfs2_schedule_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static void ocfs2_downconvert_on_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static int ocfs2_prepare_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\t        struct ocfs2_lock_res *lockres);",
            "static int ocfs2_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static void ocfs2_process_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *lockres);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"stackglue.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dcache.h\"\n#include \"alloc.h\"\n#include \"ocfs2_lockingver.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/quotaops.h>\n#include <linux/time.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/pagemap.h>\n#include <linux/kthread.h>\n#include <linux/mm.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic struct ocfs2_super *ocfs2_get_dentry_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_inode_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_file_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_qinfo_osb(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_set_meta_lvb(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_dentry_post_unlock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres);\nstatic void ocfs2_set_qinfo_lvb(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_downconvert_action(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_convert_action(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_attach_action(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_schedule_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_downconvert_on_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic int ocfs2_prepare_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\t        struct ocfs2_lock_res *lockres);\nstatic int ocfs2_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_process_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *lockres);\n\nstatic inline struct inode *ocfs2_lock_res_inode(struct ocfs2_lock_res *lockres)\n{\n\tBUG_ON(!ocfs2_is_inode_lock(lockres));\n\n\treturn (struct inode *) lockres->l_priv;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"stackglue.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dcache.h\"\n#include \"alloc.h\"\n#include \"ocfs2_lockingver.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/quotaops.h>\n#include <linux/time.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/pagemap.h>\n#include <linux/kthread.h>\n#include <linux/mm.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic struct ocfs2_super *ocfs2_get_dentry_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_inode_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_file_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_qinfo_osb(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_set_meta_lvb(struct ocfs2_lock_res *lockres);\nstatic int ocfs2_data_convert_worker(struct ocfs2_lock_res *lockres,\n\t\t\t\t     int blocking);\nstatic int ocfs2_dentry_convert_worker(struct ocfs2_lock_res *lockres,\n\t\t\t\t       int blocking);\nstatic void ocfs2_dentry_post_unlock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres);\nstatic void ocfs2_set_qinfo_lvb(struct ocfs2_lock_res *lockres);\nstatic int ocfs2_refcount_convert_worker(struct ocfs2_lock_res *lockres,\n\t\t\t\t\t int blocking);\nstatic inline void ocfs2_generic_handle_downconvert_action(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_convert_action(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_attach_action(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_schedule_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_downconvert_on_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic int ocfs2_downconvert_lock(struct ocfs2_super *osb,\n\t\t\t\t  struct ocfs2_lock_res *lockres,\n\t\t\t\t  int new_level,\n\t\t\t\t  int lvb,\n\t\t\t\t  unsigned int generation);\nstatic int ocfs2_prepare_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\t        struct ocfs2_lock_res *lockres);\nstatic int ocfs2_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_process_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *lockres);\n\nstatic int ocfs2_data_convert_worker(struct ocfs2_lock_res *lockres,\n\t\t\t\t     int blocking)\n{\n\tstruct inode *inode;\n\tstruct address_space *mapping;\n\tstruct ocfs2_inode_info *oi;\n\n       \tinode = ocfs2_lock_res_inode(lockres);\n\tmapping = inode->i_mapping;\n\n\tif (S_ISDIR(inode->i_mode)) {\n\t\toi = OCFS2_I(inode);\n\t\toi->ip_dir_lock_gen++;\n\t\tmlog(0, \"generation: %u\\n\", oi->ip_dir_lock_gen);\n\t\tgoto out;\n\t}\n\n\tif (!S_ISREG(inode->i_mode))\n\t\tgoto out;\n\n\t/*\n\t * We need this before the filemap_fdatawrite() so that it can\n\t * transfer the dirty bit from the PTE to the\n\t * page. Unfortunately this means that even for EX->PR\n\t * downconverts, we'll lose our mappings and have to build\n\t * them up again.\n\t */\n\tunmap_mapping_range(mapping, 0, 0, 0);\n\n\tif (filemap_fdatawrite(mapping)) {\n\t\tmlog(ML_ERROR, \"Could not sync inode %llu for downconvert!\",\n\t\t     (unsigned long long)OCFS2_I(inode)->ip_blkno);\n\t}\n\tsync_mapping_buffers(mapping);\n\tif (blocking == DLM_LOCK_EX) {\n\t\ttruncate_inode_pages(mapping, 0);\n\t} else {\n\t\t/* We only need to wait on the I/O if we're not also\n\t\t * truncating pages because truncate_inode_pages waits\n\t\t * for us above. We don't truncate pages if we're\n\t\t * blocking anything < EXMODE because we want to keep\n\t\t * them around in that case. */\n\t\tfilemap_fdatawait(mapping);\n\t}\n\nout:\n\treturn UNBLOCK_CONTINUE;\n}"
  },
  {
    "function_name": "ocfs2_unblock_lock",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlmglue.c",
    "lines": "3382-3577",
    "snippet": "static int ocfs2_unblock_lock(struct ocfs2_super *osb,\n\t\t\t      struct ocfs2_lock_res *lockres,\n\t\t\t      struct ocfs2_unblock_ctl *ctl)\n{\n\tunsigned long flags;\n\tint blocking;\n\tint new_level;\n\tint level;\n\tint ret = 0;\n\tint set_lvb = 0;\n\tunsigned int gen;\n\n\tspin_lock_irqsave(&lockres->l_lock, flags);\n\nrecheck:\n\t/*\n\t * Is it still blocking? If not, we have no more work to do.\n\t */\n\tif (!(lockres->l_flags & OCFS2_LOCK_BLOCKED)) {\n\t\tBUG_ON(lockres->l_blocking != DLM_LOCK_NL);\n\t\tspin_unlock_irqrestore(&lockres->l_lock, flags);\n\t\tret = 0;\n\t\tgoto leave;\n\t}\n\n\tif (lockres->l_flags & OCFS2_LOCK_BUSY) {\n\t\t/* XXX\n\t\t * This is a *big* race.  The OCFS2_LOCK_PENDING flag\n\t\t * exists entirely for one reason - another thread has set\n\t\t * OCFS2_LOCK_BUSY, but has *NOT* yet called dlm_lock().\n\t\t *\n\t\t * If we do ocfs2_cancel_convert() before the other thread\n\t\t * calls dlm_lock(), our cancel will do nothing.  We will\n\t\t * get no ast, and we will have no way of knowing the\n\t\t * cancel failed.  Meanwhile, the other thread will call\n\t\t * into dlm_lock() and wait...forever.\n\t\t *\n\t\t * Why forever?  Because another node has asked for the\n\t\t * lock first; that's why we're here in unblock_lock().\n\t\t *\n\t\t * The solution is OCFS2_LOCK_PENDING.  When PENDING is\n\t\t * set, we just requeue the unblock.  Only when the other\n\t\t * thread has called dlm_lock() and cleared PENDING will\n\t\t * we then cancel their request.\n\t\t *\n\t\t * All callers of dlm_lock() must set OCFS2_DLM_PENDING\n\t\t * at the same time they set OCFS2_DLM_BUSY.  They must\n\t\t * clear OCFS2_DLM_PENDING after dlm_lock() returns.\n\t\t */\n\t\tif (lockres->l_flags & OCFS2_LOCK_PENDING) {\n\t\t\tmlog(ML_BASTS, \"lockres %s, ReQ: Pending\\n\",\n\t\t\t     lockres->l_name);\n\t\t\tgoto leave_requeue;\n\t\t}\n\n\t\tctl->requeue = 1;\n\t\tret = ocfs2_prepare_cancel_convert(osb, lockres);\n\t\tspin_unlock_irqrestore(&lockres->l_lock, flags);\n\t\tif (ret) {\n\t\t\tret = ocfs2_cancel_convert(osb, lockres);\n\t\t\tif (ret < 0)\n\t\t\t\tmlog_errno(ret);\n\t\t}\n\t\tgoto leave;\n\t}\n\n\t/*\n\t * This prevents livelocks. OCFS2_LOCK_UPCONVERT_FINISHING flag is\n\t * set when the ast is received for an upconvert just before the\n\t * OCFS2_LOCK_BUSY flag is cleared. Now if the fs received a bast\n\t * on the heels of the ast, we want to delay the downconvert just\n\t * enough to allow the up requestor to do its task. Because this\n\t * lock is in the blocked queue, the lock will be downconverted\n\t * as soon as the requestor is done with the lock.\n\t */\n\tif (lockres->l_flags & OCFS2_LOCK_UPCONVERT_FINISHING)\n\t\tgoto leave_requeue;\n\n\t/*\n\t * How can we block and yet be at NL?  We were trying to upconvert\n\t * from NL and got canceled.  The code comes back here, and now\n\t * we notice and clear BLOCKING.\n\t */\n\tif (lockres->l_level == DLM_LOCK_NL) {\n\t\tBUG_ON(lockres->l_ex_holders || lockres->l_ro_holders);\n\t\tmlog(ML_BASTS, \"lockres %s, Aborting dc\\n\", lockres->l_name);\n\t\tlockres->l_blocking = DLM_LOCK_NL;\n\t\tlockres_clear_flags(lockres, OCFS2_LOCK_BLOCKED);\n\t\tspin_unlock_irqrestore(&lockres->l_lock, flags);\n\t\tgoto leave;\n\t}\n\n\t/* if we're blocking an exclusive and we have *any* holders,\n\t * then requeue. */\n\tif ((lockres->l_blocking == DLM_LOCK_EX)\n\t    && (lockres->l_ex_holders || lockres->l_ro_holders)) {\n\t\tmlog(ML_BASTS, \"lockres %s, ReQ: EX/PR Holders %u,%u\\n\",\n\t\t     lockres->l_name, lockres->l_ex_holders,\n\t\t     lockres->l_ro_holders);\n\t\tgoto leave_requeue;\n\t}\n\n\t/* If it's a PR we're blocking, then only\n\t * requeue if we've got any EX holders */\n\tif (lockres->l_blocking == DLM_LOCK_PR &&\n\t    lockres->l_ex_holders) {\n\t\tmlog(ML_BASTS, \"lockres %s, ReQ: EX Holders %u\\n\",\n\t\t     lockres->l_name, lockres->l_ex_holders);\n\t\tgoto leave_requeue;\n\t}\n\n\t/*\n\t * Can we get a lock in this state if the holder counts are\n\t * zero? The meta data unblock code used to check this.\n\t */\n\tif ((lockres->l_ops->flags & LOCK_TYPE_REQUIRES_REFRESH)\n\t    && (lockres->l_flags & OCFS2_LOCK_REFRESHING)) {\n\t\tmlog(ML_BASTS, \"lockres %s, ReQ: Lock Refreshing\\n\",\n\t\t     lockres->l_name);\n\t\tgoto leave_requeue;\n\t}\n\n\tnew_level = ocfs2_highest_compat_lock_level(lockres->l_blocking);\n\n\tif (lockres->l_ops->check_downconvert\n\t    && !lockres->l_ops->check_downconvert(lockres, new_level)) {\n\t\tmlog(ML_BASTS, \"lockres %s, ReQ: Checkpointing\\n\",\n\t\t     lockres->l_name);\n\t\tgoto leave_requeue;\n\t}\n\n\t/* If we get here, then we know that there are no more\n\t * incompatible holders (and anyone asking for an incompatible\n\t * lock is blocked). We can now downconvert the lock */\n\tif (!lockres->l_ops->downconvert_worker)\n\t\tgoto downconvert;\n\n\t/* Some lockres types want to do a bit of work before\n\t * downconverting a lock. Allow that here. The worker function\n\t * may sleep, so we save off a copy of what we're blocking as\n\t * it may change while we're not holding the spin lock. */\n\tblocking = lockres->l_blocking;\n\tlevel = lockres->l_level;\n\tspin_unlock_irqrestore(&lockres->l_lock, flags);\n\n\tctl->unblock_action = lockres->l_ops->downconvert_worker(lockres, blocking);\n\n\tif (ctl->unblock_action == UNBLOCK_STOP_POST) {\n\t\tmlog(ML_BASTS, \"lockres %s, UNBLOCK_STOP_POST\\n\",\n\t\t     lockres->l_name);\n\t\tgoto leave;\n\t}\n\n\tspin_lock_irqsave(&lockres->l_lock, flags);\n\tif ((blocking != lockres->l_blocking) || (level != lockres->l_level)) {\n\t\t/* If this changed underneath us, then we can't drop\n\t\t * it just yet. */\n\t\tmlog(ML_BASTS, \"lockres %s, block=%d:%d, level=%d:%d, \"\n\t\t     \"Recheck\\n\", lockres->l_name, blocking,\n\t\t     lockres->l_blocking, level, lockres->l_level);\n\t\tgoto recheck;\n\t}\n\ndownconvert:\n\tctl->requeue = 0;\n\n\tif (lockres->l_ops->flags & LOCK_TYPE_USES_LVB) {\n\t\tif (lockres->l_level == DLM_LOCK_EX)\n\t\t\tset_lvb = 1;\n\n\t\t/*\n\t\t * We only set the lvb if the lock has been fully\n\t\t * refreshed - otherwise we risk setting stale\n\t\t * data. Otherwise, there's no need to actually clear\n\t\t * out the lvb here as it's value is still valid.\n\t\t */\n\t\tif (set_lvb && !(lockres->l_flags & OCFS2_LOCK_NEEDS_REFRESH))\n\t\t\tlockres->l_ops->set_lvb(lockres);\n\t}\n\n\tgen = ocfs2_prepare_downconvert(lockres, new_level);\n\tspin_unlock_irqrestore(&lockres->l_lock, flags);\n\tret = ocfs2_downconvert_lock(osb, lockres, new_level, set_lvb,\n\t\t\t\t     gen);\n\nleave:\n\tif (ret)\n\t\tmlog_errno(ret);\n\treturn ret;\n\nleave_requeue:\n\tspin_unlock_irqrestore(&lockres->l_lock, flags);\n\tctl->requeue = 1;\n\n\treturn 0;\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"refcounttree.h\"",
      "#include \"quota.h\"",
      "#include \"uptodate.h\"",
      "#include \"super.h\"",
      "#include \"slot_map.h\"",
      "#include \"stackglue.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"heartbeat.h\"",
      "#include \"file.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"dcache.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2_lockingver.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/time.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/kthread.h>",
      "#include <linux/mm.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [
      "#define LOCK_TYPE_USES_LVB\t\t0x2",
      "#define LOCK_TYPE_REQUIRES_REFRESH 0x1"
    ],
    "globals_used": [
      "static struct ocfs2_super *ocfs2_get_dentry_osb(struct ocfs2_lock_res *lockres);",
      "static struct ocfs2_super *ocfs2_get_inode_osb(struct ocfs2_lock_res *lockres);",
      "static struct ocfs2_super *ocfs2_get_file_osb(struct ocfs2_lock_res *lockres);",
      "static struct ocfs2_super *ocfs2_get_qinfo_osb(struct ocfs2_lock_res *lockres);",
      "static int ocfs2_check_meta_downconvert(struct ocfs2_lock_res *lockres,\n\t\t\t\t\tint new_level);",
      "static void ocfs2_set_meta_lvb(struct ocfs2_lock_res *lockres);",
      "static int ocfs2_data_convert_worker(struct ocfs2_lock_res *lockres,\n\t\t\t\t     int blocking);",
      "static int ocfs2_dentry_convert_worker(struct ocfs2_lock_res *lockres,\n\t\t\t\t       int blocking);",
      "static void ocfs2_dentry_post_unlock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres);",
      "static void ocfs2_set_qinfo_lvb(struct ocfs2_lock_res *lockres);",
      "static int ocfs2_check_refcount_downconvert(struct ocfs2_lock_res *lockres,\n\t\t\t\t\t    int new_level);",
      "static int ocfs2_refcount_convert_worker(struct ocfs2_lock_res *lockres,\n\t\t\t\t\t int blocking);",
      "static inline void ocfs2_generic_handle_downconvert_action(struct ocfs2_lock_res *lockres);",
      "static inline void ocfs2_generic_handle_convert_action(struct ocfs2_lock_res *lockres);",
      "static inline void ocfs2_generic_handle_attach_action(struct ocfs2_lock_res *lockres);",
      "static int ocfs2_generic_handle_bast(struct ocfs2_lock_res *lockres, int level);",
      "static void ocfs2_schedule_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);",
      "static void ocfs2_downconvert_on_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);",
      "static void ocfs2_drop_osb_locks(struct ocfs2_super *osb);",
      "static inline int ocfs2_highest_compat_lock_level(int level);",
      "static unsigned int ocfs2_prepare_downconvert(struct ocfs2_lock_res *lockres,\n\t\t\t\t\t      int new_level);",
      "static int ocfs2_prepare_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\t        struct ocfs2_lock_res *lockres);",
      "static int ocfs2_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres);",
      "static void ocfs2_process_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *lockres);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock_irqrestore",
          "args": [
            "&lockres->l_lock",
            "flags"
          ],
          "line": 3573
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 3569
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_downconvert_lock",
          "args": [
            "osb",
            "lockres",
            "new_level",
            "set_lvb",
            "gen"
          ],
          "line": 3564
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_downconvert_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlmglue.c",
          "lines": "3302-3333",
          "snippet": "static int ocfs2_downconvert_lock(struct ocfs2_super *osb,\n\t\t\t\t  struct ocfs2_lock_res *lockres,\n\t\t\t\t  int new_level,\n\t\t\t\t  int lvb,\n\t\t\t\t  unsigned int generation)\n{\n\tint ret;\n\tu32 dlm_flags = DLM_LKF_CONVERT;\n\n\tmlog(ML_BASTS, \"lockres %s, level %d => %d\\n\", lockres->l_name,\n\t     lockres->l_level, new_level);\n\n\tif (lvb)\n\t\tdlm_flags |= DLM_LKF_VALBLK;\n\n\tret = ocfs2_dlm_lock(osb->cconn,\n\t\t\t     new_level,\n\t\t\t     &lockres->l_lksb,\n\t\t\t     dlm_flags,\n\t\t\t     lockres->l_name,\n\t\t\t     OCFS2_LOCK_ID_MAX_LEN - 1);\n\tlockres_clear_pending(lockres, generation, osb);\n\tif (ret) {\n\t\tocfs2_log_dlm_error(\"ocfs2_dlm_lock\", ret, lockres);\n\t\tocfs2_recover_from_dlm_error(lockres, 1);\n\t\tgoto bail;\n\t}\n\n\tret = 0;\nbail:\n\treturn ret;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"refcounttree.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"stackglue.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dcache.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2_lockingver.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/time.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/kthread.h>",
            "#include <linux/mm.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct ocfs2_super *ocfs2_get_dentry_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_inode_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_file_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_qinfo_osb(struct ocfs2_lock_res *lockres);",
            "static int ocfs2_check_meta_downconvert(struct ocfs2_lock_res *lockres,\n\t\t\t\t\tint new_level);",
            "static void ocfs2_set_meta_lvb(struct ocfs2_lock_res *lockres);",
            "static void ocfs2_dentry_post_unlock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres);",
            "static void ocfs2_set_qinfo_lvb(struct ocfs2_lock_res *lockres);",
            "static int ocfs2_check_refcount_downconvert(struct ocfs2_lock_res *lockres,\n\t\t\t\t\t    int new_level);",
            "static int ocfs2_lock_create(struct ocfs2_super *osb,\n\t\t\t     struct ocfs2_lock_res *lockres,\n\t\t\t     int level,\n\t\t\t     u32 dlm_flags);",
            "static inline void ocfs2_generic_handle_downconvert_action(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_convert_action(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_attach_action(struct ocfs2_lock_res *lockres);",
            "static int ocfs2_generic_handle_bast(struct ocfs2_lock_res *lockres, int level);",
            "static void ocfs2_schedule_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static void ocfs2_downconvert_on_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static void ocfs2_drop_osb_locks(struct ocfs2_super *osb);",
            "static inline int ocfs2_highest_compat_lock_level(int level);",
            "static unsigned int ocfs2_prepare_downconvert(struct ocfs2_lock_res *lockres,\n\t\t\t\t\t      int new_level);",
            "static int ocfs2_downconvert_lock(struct ocfs2_super *osb,\n\t\t\t\t  struct ocfs2_lock_res *lockres,\n\t\t\t\t  int new_level,\n\t\t\t\t  int lvb,\n\t\t\t\t  unsigned int generation);",
            "static int ocfs2_prepare_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\t        struct ocfs2_lock_res *lockres);",
            "static int ocfs2_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static void ocfs2_process_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *lockres);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"stackglue.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dcache.h\"\n#include \"alloc.h\"\n#include \"ocfs2_lockingver.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/quotaops.h>\n#include <linux/time.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/pagemap.h>\n#include <linux/kthread.h>\n#include <linux/mm.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic struct ocfs2_super *ocfs2_get_dentry_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_inode_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_file_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_qinfo_osb(struct ocfs2_lock_res *lockres);\nstatic int ocfs2_check_meta_downconvert(struct ocfs2_lock_res *lockres,\n\t\t\t\t\tint new_level);\nstatic void ocfs2_set_meta_lvb(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_dentry_post_unlock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres);\nstatic void ocfs2_set_qinfo_lvb(struct ocfs2_lock_res *lockres);\nstatic int ocfs2_check_refcount_downconvert(struct ocfs2_lock_res *lockres,\n\t\t\t\t\t    int new_level);\nstatic int ocfs2_lock_create(struct ocfs2_super *osb,\n\t\t\t     struct ocfs2_lock_res *lockres,\n\t\t\t     int level,\n\t\t\t     u32 dlm_flags);\nstatic inline void ocfs2_generic_handle_downconvert_action(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_convert_action(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_attach_action(struct ocfs2_lock_res *lockres);\nstatic int ocfs2_generic_handle_bast(struct ocfs2_lock_res *lockres, int level);\nstatic void ocfs2_schedule_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_downconvert_on_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_drop_osb_locks(struct ocfs2_super *osb);\nstatic inline int ocfs2_highest_compat_lock_level(int level);\nstatic unsigned int ocfs2_prepare_downconvert(struct ocfs2_lock_res *lockres,\n\t\t\t\t\t      int new_level);\nstatic int ocfs2_downconvert_lock(struct ocfs2_super *osb,\n\t\t\t\t  struct ocfs2_lock_res *lockres,\n\t\t\t\t  int new_level,\n\t\t\t\t  int lvb,\n\t\t\t\t  unsigned int generation);\nstatic int ocfs2_prepare_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\t        struct ocfs2_lock_res *lockres);\nstatic int ocfs2_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_process_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *lockres);\n\nstatic int ocfs2_downconvert_lock(struct ocfs2_super *osb,\n\t\t\t\t  struct ocfs2_lock_res *lockres,\n\t\t\t\t  int new_level,\n\t\t\t\t  int lvb,\n\t\t\t\t  unsigned int generation)\n{\n\tint ret;\n\tu32 dlm_flags = DLM_LKF_CONVERT;\n\n\tmlog(ML_BASTS, \"lockres %s, level %d => %d\\n\", lockres->l_name,\n\t     lockres->l_level, new_level);\n\n\tif (lvb)\n\t\tdlm_flags |= DLM_LKF_VALBLK;\n\n\tret = ocfs2_dlm_lock(osb->cconn,\n\t\t\t     new_level,\n\t\t\t     &lockres->l_lksb,\n\t\t\t     dlm_flags,\n\t\t\t     lockres->l_name,\n\t\t\t     OCFS2_LOCK_ID_MAX_LEN - 1);\n\tlockres_clear_pending(lockres, generation, osb);\n\tif (ret) {\n\t\tocfs2_log_dlm_error(\"ocfs2_dlm_lock\", ret, lockres);\n\t\tocfs2_recover_from_dlm_error(lockres, 1);\n\t\tgoto bail;\n\t}\n\n\tret = 0;\nbail:\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock_irqrestore",
          "args": [
            "&lockres->l_lock",
            "flags"
          ],
          "line": 3563
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_prepare_downconvert",
          "args": [
            "lockres",
            "new_level"
          ],
          "line": 3562
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_prepare_downconvert",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlmglue.c",
          "lines": "3273-3300",
          "snippet": "static unsigned int ocfs2_prepare_downconvert(struct ocfs2_lock_res *lockres,\n\t\t\t\t\t      int new_level)\n{\n\tassert_spin_locked(&lockres->l_lock);\n\n\tBUG_ON(lockres->l_blocking <= DLM_LOCK_NL);\n\n\tif (lockres->l_level <= new_level) {\n\t\tmlog(ML_ERROR, \"lockres %s, lvl %d <= %d, blcklst %d, mask %d, \"\n\t\t     \"type %d, flags 0x%lx, hold %d %d, act %d %d, req %d, \"\n\t\t     \"block %d, pgen %d\\n\", lockres->l_name, lockres->l_level,\n\t\t     new_level, list_empty(&lockres->l_blocked_list),\n\t\t     list_empty(&lockres->l_mask_waiters), lockres->l_type,\n\t\t     lockres->l_flags, lockres->l_ro_holders,\n\t\t     lockres->l_ex_holders, lockres->l_action,\n\t\t     lockres->l_unlock_action, lockres->l_requested,\n\t\t     lockres->l_blocking, lockres->l_pending_gen);\n\t\tBUG();\n\t}\n\n\tmlog(ML_BASTS, \"lockres %s, level %d => %d, blocking %d\\n\",\n\t     lockres->l_name, lockres->l_level, new_level, lockres->l_blocking);\n\n\tlockres->l_action = OCFS2_AST_DOWNCONVERT;\n\tlockres->l_requested = new_level;\n\tlockres_or_flags(lockres, OCFS2_LOCK_BUSY);\n\treturn lockres_set_pending(lockres);\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"refcounttree.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"stackglue.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dcache.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2_lockingver.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/time.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/kthread.h>",
            "#include <linux/mm.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct ocfs2_super *ocfs2_get_dentry_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_inode_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_file_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_qinfo_osb(struct ocfs2_lock_res *lockres);",
            "static int ocfs2_check_meta_downconvert(struct ocfs2_lock_res *lockres,\n\t\t\t\t\tint new_level);",
            "static void ocfs2_set_meta_lvb(struct ocfs2_lock_res *lockres);",
            "static int ocfs2_data_convert_worker(struct ocfs2_lock_res *lockres,\n\t\t\t\t     int blocking);",
            "static int ocfs2_dentry_convert_worker(struct ocfs2_lock_res *lockres,\n\t\t\t\t       int blocking);",
            "static void ocfs2_dentry_post_unlock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres);",
            "static void ocfs2_set_qinfo_lvb(struct ocfs2_lock_res *lockres);",
            "static int ocfs2_check_refcount_downconvert(struct ocfs2_lock_res *lockres,\n\t\t\t\t\t    int new_level);",
            "static int ocfs2_refcount_convert_worker(struct ocfs2_lock_res *lockres,\n\t\t\t\t\t int blocking);",
            "static inline void ocfs2_generic_handle_downconvert_action(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_convert_action(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_attach_action(struct ocfs2_lock_res *lockres);",
            "static int ocfs2_generic_handle_bast(struct ocfs2_lock_res *lockres, int level);",
            "static void ocfs2_schedule_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static void ocfs2_downconvert_on_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static inline int ocfs2_highest_compat_lock_level(int level);",
            "static unsigned int ocfs2_prepare_downconvert(struct ocfs2_lock_res *lockres,\n\t\t\t\t\t      int new_level);",
            "static int ocfs2_prepare_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\t        struct ocfs2_lock_res *lockres);",
            "static int ocfs2_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static void ocfs2_process_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *lockres);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"stackglue.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dcache.h\"\n#include \"alloc.h\"\n#include \"ocfs2_lockingver.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/quotaops.h>\n#include <linux/time.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/pagemap.h>\n#include <linux/kthread.h>\n#include <linux/mm.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic struct ocfs2_super *ocfs2_get_dentry_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_inode_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_file_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_qinfo_osb(struct ocfs2_lock_res *lockres);\nstatic int ocfs2_check_meta_downconvert(struct ocfs2_lock_res *lockres,\n\t\t\t\t\tint new_level);\nstatic void ocfs2_set_meta_lvb(struct ocfs2_lock_res *lockres);\nstatic int ocfs2_data_convert_worker(struct ocfs2_lock_res *lockres,\n\t\t\t\t     int blocking);\nstatic int ocfs2_dentry_convert_worker(struct ocfs2_lock_res *lockres,\n\t\t\t\t       int blocking);\nstatic void ocfs2_dentry_post_unlock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres);\nstatic void ocfs2_set_qinfo_lvb(struct ocfs2_lock_res *lockres);\nstatic int ocfs2_check_refcount_downconvert(struct ocfs2_lock_res *lockres,\n\t\t\t\t\t    int new_level);\nstatic int ocfs2_refcount_convert_worker(struct ocfs2_lock_res *lockres,\n\t\t\t\t\t int blocking);\nstatic inline void ocfs2_generic_handle_downconvert_action(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_convert_action(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_attach_action(struct ocfs2_lock_res *lockres);\nstatic int ocfs2_generic_handle_bast(struct ocfs2_lock_res *lockres, int level);\nstatic void ocfs2_schedule_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_downconvert_on_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic inline int ocfs2_highest_compat_lock_level(int level);\nstatic unsigned int ocfs2_prepare_downconvert(struct ocfs2_lock_res *lockres,\n\t\t\t\t\t      int new_level);\nstatic int ocfs2_prepare_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\t        struct ocfs2_lock_res *lockres);\nstatic int ocfs2_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_process_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *lockres);\n\nstatic unsigned int ocfs2_prepare_downconvert(struct ocfs2_lock_res *lockres,\n\t\t\t\t\t      int new_level)\n{\n\tassert_spin_locked(&lockres->l_lock);\n\n\tBUG_ON(lockres->l_blocking <= DLM_LOCK_NL);\n\n\tif (lockres->l_level <= new_level) {\n\t\tmlog(ML_ERROR, \"lockres %s, lvl %d <= %d, blcklst %d, mask %d, \"\n\t\t     \"type %d, flags 0x%lx, hold %d %d, act %d %d, req %d, \"\n\t\t     \"block %d, pgen %d\\n\", lockres->l_name, lockres->l_level,\n\t\t     new_level, list_empty(&lockres->l_blocked_list),\n\t\t     list_empty(&lockres->l_mask_waiters), lockres->l_type,\n\t\t     lockres->l_flags, lockres->l_ro_holders,\n\t\t     lockres->l_ex_holders, lockres->l_action,\n\t\t     lockres->l_unlock_action, lockres->l_requested,\n\t\t     lockres->l_blocking, lockres->l_pending_gen);\n\t\tBUG();\n\t}\n\n\tmlog(ML_BASTS, \"lockres %s, level %d => %d, blocking %d\\n\",\n\t     lockres->l_name, lockres->l_level, new_level, lockres->l_blocking);\n\n\tlockres->l_action = OCFS2_AST_DOWNCONVERT;\n\tlockres->l_requested = new_level;\n\tlockres_or_flags(lockres, OCFS2_LOCK_BUSY);\n\treturn lockres_set_pending(lockres);\n}"
        }
      },
      {
        "call_info": {
          "callee": "lockres->l_ops->set_lvb",
          "args": [
            "lockres"
          ],
          "line": 3559
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mlog",
          "args": [
            "ML_BASTS",
            "\"lockres %s, block=%d:%d, level=%d:%d, \"\n\t\t     \"Recheck\\n\"",
            "lockres->l_name",
            "blocking",
            "lockres->l_blocking",
            "level",
            "lockres->l_level"
          ],
          "line": 3539
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock_irqsave",
          "args": [
            "&lockres->l_lock",
            "flags"
          ],
          "line": 3535
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mlog",
          "args": [
            "ML_BASTS",
            "\"lockres %s, UNBLOCK_STOP_POST\\n\"",
            "lockres->l_name"
          ],
          "line": 3530
        },
        "resolved": true,
        "details": {
          "function_name": "mlog_show",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/cluster/masklog.c",
          "lines": "107-113",
          "snippet": "static ssize_t mlog_show(struct kobject *obj, struct attribute *attr,\n\t\t\t char *buf)\n{\n\tstruct mlog_attribute *mlog_attr = to_mlog_attr(attr);\n\n\treturn mlog_mask_show(mlog_attr->mask, buf);\n}",
          "includes": [
            "#include \"masklog.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/string.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"masklog.h\"\n#include <asm/uaccess.h>\n#include <linux/string.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n\nstatic ssize_t mlog_show(struct kobject *obj, struct attribute *attr,\n\t\t\t char *buf)\n{\n\tstruct mlog_attribute *mlog_attr = to_mlog_attr(attr);\n\n\treturn mlog_mask_show(mlog_attr->mask, buf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "lockres->l_ops->downconvert_worker",
          "args": [
            "lockres",
            "blocking"
          ],
          "line": 3527
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock_irqrestore",
          "args": [
            "&lockres->l_lock",
            "flags"
          ],
          "line": 3525
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lockres->l_ops->check_downconvert",
          "args": [
            "lockres",
            "new_level"
          ],
          "line": 3507
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_highest_compat_lock_level",
          "args": [
            "lockres->l_blocking"
          ],
          "line": 3504
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_highest_compat_lock_level",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlmglue.c",
          "lines": "790-799",
          "snippet": "static inline int ocfs2_highest_compat_lock_level(int level)\n{\n\tint new_level = DLM_LOCK_EX;\n\n\tif (level == DLM_LOCK_EX)\n\t\tnew_level = DLM_LOCK_NL;\n\telse if (level == DLM_LOCK_PR)\n\t\tnew_level = DLM_LOCK_PR;\n\treturn new_level;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"refcounttree.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"stackglue.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dcache.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2_lockingver.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/time.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/kthread.h>",
            "#include <linux/mm.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ocfs2_check_meta_downconvert(struct ocfs2_lock_res *lockres,\n\t\t\t\t\tint new_level);",
            "static int ocfs2_check_refcount_downconvert(struct ocfs2_lock_res *lockres,\n\t\t\t\t\t    int new_level);",
            "static int ocfs2_generic_handle_bast(struct ocfs2_lock_res *lockres, int level);",
            "static inline int ocfs2_highest_compat_lock_level(int level);",
            "static unsigned int ocfs2_prepare_downconvert(struct ocfs2_lock_res *lockres,\n\t\t\t\t\t      int new_level);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"stackglue.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dcache.h\"\n#include \"alloc.h\"\n#include \"ocfs2_lockingver.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/quotaops.h>\n#include <linux/time.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/pagemap.h>\n#include <linux/kthread.h>\n#include <linux/mm.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic int ocfs2_check_meta_downconvert(struct ocfs2_lock_res *lockres,\n\t\t\t\t\tint new_level);\nstatic int ocfs2_check_refcount_downconvert(struct ocfs2_lock_res *lockres,\n\t\t\t\t\t    int new_level);\nstatic int ocfs2_generic_handle_bast(struct ocfs2_lock_res *lockres, int level);\nstatic inline int ocfs2_highest_compat_lock_level(int level);\nstatic unsigned int ocfs2_prepare_downconvert(struct ocfs2_lock_res *lockres,\n\t\t\t\t\t      int new_level);\n\nstatic inline int ocfs2_highest_compat_lock_level(int level)\n{\n\tint new_level = DLM_LOCK_EX;\n\n\tif (level == DLM_LOCK_EX)\n\t\tnew_level = DLM_LOCK_NL;\n\telse if (level == DLM_LOCK_PR)\n\t\tnew_level = DLM_LOCK_PR;\n\treturn new_level;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog",
          "args": [
            "ML_BASTS",
            "\"lockres %s, ReQ: EX Holders %u\\n\"",
            "lockres->l_name",
            "lockres->l_ex_holders"
          ],
          "line": 3488
        },
        "resolved": true,
        "details": {
          "function_name": "mlog_store",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/cluster/masklog.c",
          "lines": "115-121",
          "snippet": "static ssize_t mlog_store(struct kobject *obj, struct attribute *attr,\n\t\t\t  const char *buf, size_t count)\n{\n\tstruct mlog_attribute *mlog_attr = to_mlog_attr(attr);\n\n\treturn mlog_mask_store(mlog_attr->mask, buf, count);\n}",
          "includes": [
            "#include \"masklog.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/string.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"masklog.h\"\n#include <asm/uaccess.h>\n#include <linux/string.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n\nstatic ssize_t mlog_store(struct kobject *obj, struct attribute *attr,\n\t\t\t  const char *buf, size_t count)\n{\n\tstruct mlog_attribute *mlog_attr = to_mlog_attr(attr);\n\n\treturn mlog_mask_store(mlog_attr->mask, buf, count);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog",
          "args": [
            "ML_BASTS",
            "\"lockres %s, ReQ: EX/PR Holders %u,%u\\n\"",
            "lockres->l_name",
            "lockres->l_ex_holders",
            "lockres->l_ro_holders"
          ],
          "line": 3478
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock_irqrestore",
          "args": [
            "&lockres->l_lock",
            "flags"
          ],
          "line": 3470
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lockres_clear_flags",
          "args": [
            "lockres",
            "OCFS2_LOCK_BLOCKED"
          ],
          "line": 3469
        },
        "resolved": true,
        "details": {
          "function_name": "lockres_clear_flags",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlmglue.c",
          "lines": "823-827",
          "snippet": "static void lockres_clear_flags(struct ocfs2_lock_res *lockres,\n\t\t\t\tunsigned long clear)\n{\n\tlockres_set_flags(lockres, lockres->l_flags & ~clear);\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"refcounttree.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"stackglue.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dcache.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2_lockingver.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/time.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/kthread.h>",
            "#include <linux/mm.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct ocfs2_super *ocfs2_get_dentry_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_inode_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_file_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_qinfo_osb(struct ocfs2_lock_res *lockres);",
            "static void ocfs2_set_meta_lvb(struct ocfs2_lock_res *lockres);",
            "static void ocfs2_dentry_post_unlock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres);",
            "static void ocfs2_set_qinfo_lvb(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_downconvert_action(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_convert_action(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_attach_action(struct ocfs2_lock_res *lockres);",
            "static void ocfs2_schedule_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static void ocfs2_downconvert_on_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static int ocfs2_prepare_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\t        struct ocfs2_lock_res *lockres);",
            "static int ocfs2_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static void ocfs2_process_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *lockres);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"stackglue.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dcache.h\"\n#include \"alloc.h\"\n#include \"ocfs2_lockingver.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/quotaops.h>\n#include <linux/time.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/pagemap.h>\n#include <linux/kthread.h>\n#include <linux/mm.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic struct ocfs2_super *ocfs2_get_dentry_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_inode_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_file_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_qinfo_osb(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_set_meta_lvb(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_dentry_post_unlock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres);\nstatic void ocfs2_set_qinfo_lvb(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_downconvert_action(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_convert_action(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_attach_action(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_schedule_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_downconvert_on_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic int ocfs2_prepare_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\t        struct ocfs2_lock_res *lockres);\nstatic int ocfs2_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_process_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *lockres);\n\nstatic void lockres_clear_flags(struct ocfs2_lock_res *lockres,\n\t\t\t\tunsigned long clear)\n{\n\tlockres_set_flags(lockres, lockres->l_flags & ~clear);\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "lockres->l_ex_holders || lockres->l_ro_holders"
          ],
          "line": 3466
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 3443
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_cancel_convert",
          "args": [
            "osb",
            "lockres"
          ],
          "line": 3441
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_cancel_convert",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlmglue.c",
          "lines": "3365-3380",
          "snippet": "static int ocfs2_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres)\n{\n\tint ret;\n\n\tret = ocfs2_dlm_unlock(osb->cconn, &lockres->l_lksb,\n\t\t\t       DLM_LKF_CANCEL);\n\tif (ret) {\n\t\tocfs2_log_dlm_error(\"ocfs2_dlm_unlock\", ret, lockres);\n\t\tocfs2_recover_from_dlm_error(lockres, 0);\n\t}\n\n\tmlog(ML_BASTS, \"lockres %s\\n\", lockres->l_name);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"refcounttree.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"stackglue.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dcache.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2_lockingver.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/time.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/kthread.h>",
            "#include <linux/mm.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct ocfs2_super *ocfs2_get_dentry_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_inode_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_file_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_qinfo_osb(struct ocfs2_lock_res *lockres);",
            "static void ocfs2_set_meta_lvb(struct ocfs2_lock_res *lockres);",
            "static void ocfs2_dentry_post_unlock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres);",
            "static void ocfs2_set_qinfo_lvb(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_downconvert_action(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_convert_action(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_attach_action(struct ocfs2_lock_res *lockres);",
            "static void ocfs2_schedule_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static void ocfs2_downconvert_on_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static void ocfs2_drop_osb_locks(struct ocfs2_super *osb);",
            "static int ocfs2_prepare_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\t        struct ocfs2_lock_res *lockres);",
            "static int ocfs2_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static void ocfs2_process_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *lockres);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"stackglue.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dcache.h\"\n#include \"alloc.h\"\n#include \"ocfs2_lockingver.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/quotaops.h>\n#include <linux/time.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/pagemap.h>\n#include <linux/kthread.h>\n#include <linux/mm.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic struct ocfs2_super *ocfs2_get_dentry_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_inode_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_file_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_qinfo_osb(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_set_meta_lvb(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_dentry_post_unlock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres);\nstatic void ocfs2_set_qinfo_lvb(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_downconvert_action(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_convert_action(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_attach_action(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_schedule_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_downconvert_on_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_drop_osb_locks(struct ocfs2_super *osb);\nstatic int ocfs2_prepare_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\t        struct ocfs2_lock_res *lockres);\nstatic int ocfs2_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_process_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *lockres);\n\nstatic int ocfs2_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres)\n{\n\tint ret;\n\n\tret = ocfs2_dlm_unlock(osb->cconn, &lockres->l_lksb,\n\t\t\t       DLM_LKF_CANCEL);\n\tif (ret) {\n\t\tocfs2_log_dlm_error(\"ocfs2_dlm_unlock\", ret, lockres);\n\t\tocfs2_recover_from_dlm_error(lockres, 0);\n\t}\n\n\tmlog(ML_BASTS, \"lockres %s\\n\", lockres->l_name);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock_irqrestore",
          "args": [
            "&lockres->l_lock",
            "flags"
          ],
          "line": 3439
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_prepare_cancel_convert",
          "args": [
            "osb",
            "lockres"
          ],
          "line": 3438
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_prepare_cancel_convert",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlmglue.c",
          "lines": "3336-3363",
          "snippet": "static int ocfs2_prepare_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\t        struct ocfs2_lock_res *lockres)\n{\n\tassert_spin_locked(&lockres->l_lock);\n\n\tif (lockres->l_unlock_action == OCFS2_UNLOCK_CANCEL_CONVERT) {\n\t\t/* If we're already trying to cancel a lock conversion\n\t\t * then just drop the spinlock and allow the caller to\n\t\t * requeue this lock. */\n\t\tmlog(ML_BASTS, \"lockres %s, skip convert\\n\", lockres->l_name);\n\t\treturn 0;\n\t}\n\n\t/* were we in a convert when we got the bast fire? */\n\tBUG_ON(lockres->l_action != OCFS2_AST_CONVERT &&\n\t       lockres->l_action != OCFS2_AST_DOWNCONVERT);\n\t/* set things up for the unlockast to know to just\n\t * clear out the ast_action and unset busy, etc. */\n\tlockres->l_unlock_action = OCFS2_UNLOCK_CANCEL_CONVERT;\n\n\tmlog_bug_on_msg(!(lockres->l_flags & OCFS2_LOCK_BUSY),\n\t\t\t\"lock %s, invalid flags: 0x%lx\\n\",\n\t\t\tlockres->l_name, lockres->l_flags);\n\n\tmlog(ML_BASTS, \"lockres %s\\n\", lockres->l_name);\n\n\treturn 1;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"refcounttree.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"stackglue.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dcache.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2_lockingver.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/time.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/kthread.h>",
            "#include <linux/mm.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct ocfs2_super *ocfs2_get_dentry_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_inode_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_file_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_qinfo_osb(struct ocfs2_lock_res *lockres);",
            "static void ocfs2_set_meta_lvb(struct ocfs2_lock_res *lockres);",
            "static void ocfs2_dentry_post_unlock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres);",
            "static void ocfs2_set_qinfo_lvb(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_downconvert_action(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_convert_action(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_attach_action(struct ocfs2_lock_res *lockres);",
            "static void ocfs2_schedule_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_recover_from_dlm_error(struct ocfs2_lock_res *lockres,\n\t\t\t\t\t\tint convert);",
            "static void ocfs2_downconvert_on_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static void ocfs2_drop_osb_locks(struct ocfs2_super *osb);",
            "static int ocfs2_prepare_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\t        struct ocfs2_lock_res *lockres);",
            "static int ocfs2_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static void ocfs2_process_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *lockres);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"stackglue.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dcache.h\"\n#include \"alloc.h\"\n#include \"ocfs2_lockingver.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/quotaops.h>\n#include <linux/time.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/pagemap.h>\n#include <linux/kthread.h>\n#include <linux/mm.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic struct ocfs2_super *ocfs2_get_dentry_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_inode_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_file_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_qinfo_osb(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_set_meta_lvb(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_dentry_post_unlock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres);\nstatic void ocfs2_set_qinfo_lvb(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_downconvert_action(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_convert_action(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_attach_action(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_schedule_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_recover_from_dlm_error(struct ocfs2_lock_res *lockres,\n\t\t\t\t\t\tint convert);\nstatic void ocfs2_downconvert_on_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_drop_osb_locks(struct ocfs2_super *osb);\nstatic int ocfs2_prepare_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\t        struct ocfs2_lock_res *lockres);\nstatic int ocfs2_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_process_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *lockres);\n\nstatic int ocfs2_prepare_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\t        struct ocfs2_lock_res *lockres)\n{\n\tassert_spin_locked(&lockres->l_lock);\n\n\tif (lockres->l_unlock_action == OCFS2_UNLOCK_CANCEL_CONVERT) {\n\t\t/* If we're already trying to cancel a lock conversion\n\t\t * then just drop the spinlock and allow the caller to\n\t\t * requeue this lock. */\n\t\tmlog(ML_BASTS, \"lockres %s, skip convert\\n\", lockres->l_name);\n\t\treturn 0;\n\t}\n\n\t/* were we in a convert when we got the bast fire? */\n\tBUG_ON(lockres->l_action != OCFS2_AST_CONVERT &&\n\t       lockres->l_action != OCFS2_AST_DOWNCONVERT);\n\t/* set things up for the unlockast to know to just\n\t * clear out the ast_action and unset busy, etc. */\n\tlockres->l_unlock_action = OCFS2_UNLOCK_CANCEL_CONVERT;\n\n\tmlog_bug_on_msg(!(lockres->l_flags & OCFS2_LOCK_BUSY),\n\t\t\t\"lock %s, invalid flags: 0x%lx\\n\",\n\t\t\tlockres->l_name, lockres->l_flags);\n\n\tmlog(ML_BASTS, \"lockres %s\\n\", lockres->l_name);\n\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock_irqrestore",
          "args": [
            "&lockres->l_lock",
            "flags"
          ],
          "line": 3402
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "lockres->l_blocking != DLM_LOCK_NL"
          ],
          "line": 3401
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock_irqsave",
          "args": [
            "&lockres->l_lock",
            "flags"
          ],
          "line": 3394
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"stackglue.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dcache.h\"\n#include \"alloc.h\"\n#include \"ocfs2_lockingver.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/quotaops.h>\n#include <linux/time.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/pagemap.h>\n#include <linux/kthread.h>\n#include <linux/mm.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\n#define LOCK_TYPE_USES_LVB\t\t0x2\n#define LOCK_TYPE_REQUIRES_REFRESH 0x1\n\nstatic struct ocfs2_super *ocfs2_get_dentry_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_inode_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_file_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_qinfo_osb(struct ocfs2_lock_res *lockres);\nstatic int ocfs2_check_meta_downconvert(struct ocfs2_lock_res *lockres,\n\t\t\t\t\tint new_level);\nstatic void ocfs2_set_meta_lvb(struct ocfs2_lock_res *lockres);\nstatic int ocfs2_data_convert_worker(struct ocfs2_lock_res *lockres,\n\t\t\t\t     int blocking);\nstatic int ocfs2_dentry_convert_worker(struct ocfs2_lock_res *lockres,\n\t\t\t\t       int blocking);\nstatic void ocfs2_dentry_post_unlock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres);\nstatic void ocfs2_set_qinfo_lvb(struct ocfs2_lock_res *lockres);\nstatic int ocfs2_check_refcount_downconvert(struct ocfs2_lock_res *lockres,\n\t\t\t\t\t    int new_level);\nstatic int ocfs2_refcount_convert_worker(struct ocfs2_lock_res *lockres,\n\t\t\t\t\t int blocking);\nstatic inline void ocfs2_generic_handle_downconvert_action(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_convert_action(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_attach_action(struct ocfs2_lock_res *lockres);\nstatic int ocfs2_generic_handle_bast(struct ocfs2_lock_res *lockres, int level);\nstatic void ocfs2_schedule_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_downconvert_on_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_drop_osb_locks(struct ocfs2_super *osb);\nstatic inline int ocfs2_highest_compat_lock_level(int level);\nstatic unsigned int ocfs2_prepare_downconvert(struct ocfs2_lock_res *lockres,\n\t\t\t\t\t      int new_level);\nstatic int ocfs2_prepare_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\t        struct ocfs2_lock_res *lockres);\nstatic int ocfs2_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_process_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *lockres);\n\nstatic int ocfs2_unblock_lock(struct ocfs2_super *osb,\n\t\t\t      struct ocfs2_lock_res *lockres,\n\t\t\t      struct ocfs2_unblock_ctl *ctl)\n{\n\tunsigned long flags;\n\tint blocking;\n\tint new_level;\n\tint level;\n\tint ret = 0;\n\tint set_lvb = 0;\n\tunsigned int gen;\n\n\tspin_lock_irqsave(&lockres->l_lock, flags);\n\nrecheck:\n\t/*\n\t * Is it still blocking? If not, we have no more work to do.\n\t */\n\tif (!(lockres->l_flags & OCFS2_LOCK_BLOCKED)) {\n\t\tBUG_ON(lockres->l_blocking != DLM_LOCK_NL);\n\t\tspin_unlock_irqrestore(&lockres->l_lock, flags);\n\t\tret = 0;\n\t\tgoto leave;\n\t}\n\n\tif (lockres->l_flags & OCFS2_LOCK_BUSY) {\n\t\t/* XXX\n\t\t * This is a *big* race.  The OCFS2_LOCK_PENDING flag\n\t\t * exists entirely for one reason - another thread has set\n\t\t * OCFS2_LOCK_BUSY, but has *NOT* yet called dlm_lock().\n\t\t *\n\t\t * If we do ocfs2_cancel_convert() before the other thread\n\t\t * calls dlm_lock(), our cancel will do nothing.  We will\n\t\t * get no ast, and we will have no way of knowing the\n\t\t * cancel failed.  Meanwhile, the other thread will call\n\t\t * into dlm_lock() and wait...forever.\n\t\t *\n\t\t * Why forever?  Because another node has asked for the\n\t\t * lock first; that's why we're here in unblock_lock().\n\t\t *\n\t\t * The solution is OCFS2_LOCK_PENDING.  When PENDING is\n\t\t * set, we just requeue the unblock.  Only when the other\n\t\t * thread has called dlm_lock() and cleared PENDING will\n\t\t * we then cancel their request.\n\t\t *\n\t\t * All callers of dlm_lock() must set OCFS2_DLM_PENDING\n\t\t * at the same time they set OCFS2_DLM_BUSY.  They must\n\t\t * clear OCFS2_DLM_PENDING after dlm_lock() returns.\n\t\t */\n\t\tif (lockres->l_flags & OCFS2_LOCK_PENDING) {\n\t\t\tmlog(ML_BASTS, \"lockres %s, ReQ: Pending\\n\",\n\t\t\t     lockres->l_name);\n\t\t\tgoto leave_requeue;\n\t\t}\n\n\t\tctl->requeue = 1;\n\t\tret = ocfs2_prepare_cancel_convert(osb, lockres);\n\t\tspin_unlock_irqrestore(&lockres->l_lock, flags);\n\t\tif (ret) {\n\t\t\tret = ocfs2_cancel_convert(osb, lockres);\n\t\t\tif (ret < 0)\n\t\t\t\tmlog_errno(ret);\n\t\t}\n\t\tgoto leave;\n\t}\n\n\t/*\n\t * This prevents livelocks. OCFS2_LOCK_UPCONVERT_FINISHING flag is\n\t * set when the ast is received for an upconvert just before the\n\t * OCFS2_LOCK_BUSY flag is cleared. Now if the fs received a bast\n\t * on the heels of the ast, we want to delay the downconvert just\n\t * enough to allow the up requestor to do its task. Because this\n\t * lock is in the blocked queue, the lock will be downconverted\n\t * as soon as the requestor is done with the lock.\n\t */\n\tif (lockres->l_flags & OCFS2_LOCK_UPCONVERT_FINISHING)\n\t\tgoto leave_requeue;\n\n\t/*\n\t * How can we block and yet be at NL?  We were trying to upconvert\n\t * from NL and got canceled.  The code comes back here, and now\n\t * we notice and clear BLOCKING.\n\t */\n\tif (lockres->l_level == DLM_LOCK_NL) {\n\t\tBUG_ON(lockres->l_ex_holders || lockres->l_ro_holders);\n\t\tmlog(ML_BASTS, \"lockres %s, Aborting dc\\n\", lockres->l_name);\n\t\tlockres->l_blocking = DLM_LOCK_NL;\n\t\tlockres_clear_flags(lockres, OCFS2_LOCK_BLOCKED);\n\t\tspin_unlock_irqrestore(&lockres->l_lock, flags);\n\t\tgoto leave;\n\t}\n\n\t/* if we're blocking an exclusive and we have *any* holders,\n\t * then requeue. */\n\tif ((lockres->l_blocking == DLM_LOCK_EX)\n\t    && (lockres->l_ex_holders || lockres->l_ro_holders)) {\n\t\tmlog(ML_BASTS, \"lockres %s, ReQ: EX/PR Holders %u,%u\\n\",\n\t\t     lockres->l_name, lockres->l_ex_holders,\n\t\t     lockres->l_ro_holders);\n\t\tgoto leave_requeue;\n\t}\n\n\t/* If it's a PR we're blocking, then only\n\t * requeue if we've got any EX holders */\n\tif (lockres->l_blocking == DLM_LOCK_PR &&\n\t    lockres->l_ex_holders) {\n\t\tmlog(ML_BASTS, \"lockres %s, ReQ: EX Holders %u\\n\",\n\t\t     lockres->l_name, lockres->l_ex_holders);\n\t\tgoto leave_requeue;\n\t}\n\n\t/*\n\t * Can we get a lock in this state if the holder counts are\n\t * zero? The meta data unblock code used to check this.\n\t */\n\tif ((lockres->l_ops->flags & LOCK_TYPE_REQUIRES_REFRESH)\n\t    && (lockres->l_flags & OCFS2_LOCK_REFRESHING)) {\n\t\tmlog(ML_BASTS, \"lockres %s, ReQ: Lock Refreshing\\n\",\n\t\t     lockres->l_name);\n\t\tgoto leave_requeue;\n\t}\n\n\tnew_level = ocfs2_highest_compat_lock_level(lockres->l_blocking);\n\n\tif (lockres->l_ops->check_downconvert\n\t    && !lockres->l_ops->check_downconvert(lockres, new_level)) {\n\t\tmlog(ML_BASTS, \"lockres %s, ReQ: Checkpointing\\n\",\n\t\t     lockres->l_name);\n\t\tgoto leave_requeue;\n\t}\n\n\t/* If we get here, then we know that there are no more\n\t * incompatible holders (and anyone asking for an incompatible\n\t * lock is blocked). We can now downconvert the lock */\n\tif (!lockres->l_ops->downconvert_worker)\n\t\tgoto downconvert;\n\n\t/* Some lockres types want to do a bit of work before\n\t * downconverting a lock. Allow that here. The worker function\n\t * may sleep, so we save off a copy of what we're blocking as\n\t * it may change while we're not holding the spin lock. */\n\tblocking = lockres->l_blocking;\n\tlevel = lockres->l_level;\n\tspin_unlock_irqrestore(&lockres->l_lock, flags);\n\n\tctl->unblock_action = lockres->l_ops->downconvert_worker(lockres, blocking);\n\n\tif (ctl->unblock_action == UNBLOCK_STOP_POST) {\n\t\tmlog(ML_BASTS, \"lockres %s, UNBLOCK_STOP_POST\\n\",\n\t\t     lockres->l_name);\n\t\tgoto leave;\n\t}\n\n\tspin_lock_irqsave(&lockres->l_lock, flags);\n\tif ((blocking != lockres->l_blocking) || (level != lockres->l_level)) {\n\t\t/* If this changed underneath us, then we can't drop\n\t\t * it just yet. */\n\t\tmlog(ML_BASTS, \"lockres %s, block=%d:%d, level=%d:%d, \"\n\t\t     \"Recheck\\n\", lockres->l_name, blocking,\n\t\t     lockres->l_blocking, level, lockres->l_level);\n\t\tgoto recheck;\n\t}\n\ndownconvert:\n\tctl->requeue = 0;\n\n\tif (lockres->l_ops->flags & LOCK_TYPE_USES_LVB) {\n\t\tif (lockres->l_level == DLM_LOCK_EX)\n\t\t\tset_lvb = 1;\n\n\t\t/*\n\t\t * We only set the lvb if the lock has been fully\n\t\t * refreshed - otherwise we risk setting stale\n\t\t * data. Otherwise, there's no need to actually clear\n\t\t * out the lvb here as it's value is still valid.\n\t\t */\n\t\tif (set_lvb && !(lockres->l_flags & OCFS2_LOCK_NEEDS_REFRESH))\n\t\t\tlockres->l_ops->set_lvb(lockres);\n\t}\n\n\tgen = ocfs2_prepare_downconvert(lockres, new_level);\n\tspin_unlock_irqrestore(&lockres->l_lock, flags);\n\tret = ocfs2_downconvert_lock(osb, lockres, new_level, set_lvb,\n\t\t\t\t     gen);\n\nleave:\n\tif (ret)\n\t\tmlog_errno(ret);\n\treturn ret;\n\nleave_requeue:\n\tspin_unlock_irqrestore(&lockres->l_lock, flags);\n\tctl->requeue = 1;\n\n\treturn 0;\n}"
  },
  {
    "function_name": "ocfs2_cancel_convert",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlmglue.c",
    "lines": "3365-3380",
    "snippet": "static int ocfs2_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres)\n{\n\tint ret;\n\n\tret = ocfs2_dlm_unlock(osb->cconn, &lockres->l_lksb,\n\t\t\t       DLM_LKF_CANCEL);\n\tif (ret) {\n\t\tocfs2_log_dlm_error(\"ocfs2_dlm_unlock\", ret, lockres);\n\t\tocfs2_recover_from_dlm_error(lockres, 0);\n\t}\n\n\tmlog(ML_BASTS, \"lockres %s\\n\", lockres->l_name);\n\n\treturn ret;\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"refcounttree.h\"",
      "#include \"quota.h\"",
      "#include \"uptodate.h\"",
      "#include \"super.h\"",
      "#include \"slot_map.h\"",
      "#include \"stackglue.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"heartbeat.h\"",
      "#include \"file.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"dcache.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2_lockingver.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/time.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/kthread.h>",
      "#include <linux/mm.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct ocfs2_super *ocfs2_get_dentry_osb(struct ocfs2_lock_res *lockres);",
      "static struct ocfs2_super *ocfs2_get_inode_osb(struct ocfs2_lock_res *lockres);",
      "static struct ocfs2_super *ocfs2_get_file_osb(struct ocfs2_lock_res *lockres);",
      "static struct ocfs2_super *ocfs2_get_qinfo_osb(struct ocfs2_lock_res *lockres);",
      "static void ocfs2_set_meta_lvb(struct ocfs2_lock_res *lockres);",
      "static void ocfs2_dentry_post_unlock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres);",
      "static void ocfs2_set_qinfo_lvb(struct ocfs2_lock_res *lockres);",
      "static inline void ocfs2_generic_handle_downconvert_action(struct ocfs2_lock_res *lockres);",
      "static inline void ocfs2_generic_handle_convert_action(struct ocfs2_lock_res *lockres);",
      "static inline void ocfs2_generic_handle_attach_action(struct ocfs2_lock_res *lockres);",
      "static void ocfs2_schedule_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);",
      "static void ocfs2_downconvert_on_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);",
      "static void ocfs2_drop_osb_locks(struct ocfs2_super *osb);",
      "static int ocfs2_prepare_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\t        struct ocfs2_lock_res *lockres);",
      "static int ocfs2_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres);",
      "static void ocfs2_process_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *lockres);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mlog",
          "args": [
            "ML_BASTS",
            "\"lockres %s\\n\"",
            "lockres->l_name"
          ],
          "line": 3377
        },
        "resolved": true,
        "details": {
          "function_name": "mlog_show",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/cluster/masklog.c",
          "lines": "107-113",
          "snippet": "static ssize_t mlog_show(struct kobject *obj, struct attribute *attr,\n\t\t\t char *buf)\n{\n\tstruct mlog_attribute *mlog_attr = to_mlog_attr(attr);\n\n\treturn mlog_mask_show(mlog_attr->mask, buf);\n}",
          "includes": [
            "#include \"masklog.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/string.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"masklog.h\"\n#include <asm/uaccess.h>\n#include <linux/string.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n\nstatic ssize_t mlog_show(struct kobject *obj, struct attribute *attr,\n\t\t\t char *buf)\n{\n\tstruct mlog_attribute *mlog_attr = to_mlog_attr(attr);\n\n\treturn mlog_mask_show(mlog_attr->mask, buf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_recover_from_dlm_error",
          "args": [
            "lockres",
            "0"
          ],
          "line": 3374
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_recover_from_dlm_error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlmglue.c",
          "lines": "1199-1214",
          "snippet": "static inline void ocfs2_recover_from_dlm_error(struct ocfs2_lock_res *lockres,\n\t\t\t\t\t\tint convert)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&lockres->l_lock, flags);\n\tlockres_clear_flags(lockres, OCFS2_LOCK_BUSY);\n\tlockres_clear_flags(lockres, OCFS2_LOCK_UPCONVERT_FINISHING);\n\tif (convert)\n\t\tlockres->l_action = OCFS2_AST_INVALID;\n\telse\n\t\tlockres->l_unlock_action = OCFS2_UNLOCK_INVALID;\n\tspin_unlock_irqrestore(&lockres->l_lock, flags);\n\n\twake_up(&lockres->l_event);\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"refcounttree.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"stackglue.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dcache.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2_lockingver.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/time.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/kthread.h>",
            "#include <linux/mm.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct ocfs2_super *ocfs2_get_dentry_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_inode_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_file_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_qinfo_osb(struct ocfs2_lock_res *lockres);",
            "static void ocfs2_set_meta_lvb(struct ocfs2_lock_res *lockres);",
            "static void ocfs2_dentry_post_unlock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres);",
            "static void ocfs2_set_qinfo_lvb(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_downconvert_action(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_convert_action(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_attach_action(struct ocfs2_lock_res *lockres);",
            "static void ocfs2_schedule_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_recover_from_dlm_error(struct ocfs2_lock_res *lockres,\n\t\t\t\t\t\tint convert);",
            "static void ocfs2_downconvert_on_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static int ocfs2_prepare_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\t        struct ocfs2_lock_res *lockres);",
            "static int ocfs2_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static void ocfs2_process_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *lockres);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"stackglue.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dcache.h\"\n#include \"alloc.h\"\n#include \"ocfs2_lockingver.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/quotaops.h>\n#include <linux/time.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/pagemap.h>\n#include <linux/kthread.h>\n#include <linux/mm.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic struct ocfs2_super *ocfs2_get_dentry_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_inode_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_file_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_qinfo_osb(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_set_meta_lvb(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_dentry_post_unlock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres);\nstatic void ocfs2_set_qinfo_lvb(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_downconvert_action(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_convert_action(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_attach_action(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_schedule_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_recover_from_dlm_error(struct ocfs2_lock_res *lockres,\n\t\t\t\t\t\tint convert);\nstatic void ocfs2_downconvert_on_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic int ocfs2_prepare_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\t        struct ocfs2_lock_res *lockres);\nstatic int ocfs2_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_process_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *lockres);\n\nstatic inline void ocfs2_recover_from_dlm_error(struct ocfs2_lock_res *lockres,\n\t\t\t\t\t\tint convert)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&lockres->l_lock, flags);\n\tlockres_clear_flags(lockres, OCFS2_LOCK_BUSY);\n\tlockres_clear_flags(lockres, OCFS2_LOCK_UPCONVERT_FINISHING);\n\tif (convert)\n\t\tlockres->l_action = OCFS2_AST_INVALID;\n\telse\n\t\tlockres->l_unlock_action = OCFS2_UNLOCK_INVALID;\n\tspin_unlock_irqrestore(&lockres->l_lock, flags);\n\n\twake_up(&lockres->l_event);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_log_dlm_error",
          "args": [
            "\"ocfs2_dlm_unlock\"",
            "ret",
            "lockres"
          ],
          "line": 3373
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_dlm_unlock",
          "args": [
            "osb->cconn",
            "&lockres->l_lksb",
            "DLM_LKF_CANCEL"
          ],
          "line": 3370
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_dlm_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/stackglue.c",
          "lines": "257-264",
          "snippet": "int ocfs2_dlm_unlock(struct ocfs2_cluster_connection *conn,\n\t\t     struct ocfs2_dlm_lksb *lksb,\n\t\t     u32 flags)\n{\n\tBUG_ON(lksb->lksb_conn == NULL);\n\n\treturn active_stack->sp_ops->dlm_unlock(conn, lksb, flags);\n}",
          "includes": [
            "#include \"stackglue.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include <linux/sysctl.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/fs.h>",
            "#include <linux/kmod.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/list.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct ocfs2_stack_plugin *active_stack;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"stackglue.h\"\n#include \"ocfs2_fs.h\"\n#include <linux/sysctl.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/fs.h>\n#include <linux/kmod.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/spinlock.h>\n#include <linux/list.h>\n\nstatic struct ocfs2_stack_plugin *active_stack;\n\nint ocfs2_dlm_unlock(struct ocfs2_cluster_connection *conn,\n\t\t     struct ocfs2_dlm_lksb *lksb,\n\t\t     u32 flags)\n{\n\tBUG_ON(lksb->lksb_conn == NULL);\n\n\treturn active_stack->sp_ops->dlm_unlock(conn, lksb, flags);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"stackglue.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dcache.h\"\n#include \"alloc.h\"\n#include \"ocfs2_lockingver.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/quotaops.h>\n#include <linux/time.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/pagemap.h>\n#include <linux/kthread.h>\n#include <linux/mm.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic struct ocfs2_super *ocfs2_get_dentry_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_inode_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_file_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_qinfo_osb(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_set_meta_lvb(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_dentry_post_unlock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres);\nstatic void ocfs2_set_qinfo_lvb(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_downconvert_action(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_convert_action(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_attach_action(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_schedule_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_downconvert_on_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_drop_osb_locks(struct ocfs2_super *osb);\nstatic int ocfs2_prepare_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\t        struct ocfs2_lock_res *lockres);\nstatic int ocfs2_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_process_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *lockres);\n\nstatic int ocfs2_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres)\n{\n\tint ret;\n\n\tret = ocfs2_dlm_unlock(osb->cconn, &lockres->l_lksb,\n\t\t\t       DLM_LKF_CANCEL);\n\tif (ret) {\n\t\tocfs2_log_dlm_error(\"ocfs2_dlm_unlock\", ret, lockres);\n\t\tocfs2_recover_from_dlm_error(lockres, 0);\n\t}\n\n\tmlog(ML_BASTS, \"lockres %s\\n\", lockres->l_name);\n\n\treturn ret;\n}"
  },
  {
    "function_name": "ocfs2_prepare_cancel_convert",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlmglue.c",
    "lines": "3336-3363",
    "snippet": "static int ocfs2_prepare_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\t        struct ocfs2_lock_res *lockres)\n{\n\tassert_spin_locked(&lockres->l_lock);\n\n\tif (lockres->l_unlock_action == OCFS2_UNLOCK_CANCEL_CONVERT) {\n\t\t/* If we're already trying to cancel a lock conversion\n\t\t * then just drop the spinlock and allow the caller to\n\t\t * requeue this lock. */\n\t\tmlog(ML_BASTS, \"lockres %s, skip convert\\n\", lockres->l_name);\n\t\treturn 0;\n\t}\n\n\t/* were we in a convert when we got the bast fire? */\n\tBUG_ON(lockres->l_action != OCFS2_AST_CONVERT &&\n\t       lockres->l_action != OCFS2_AST_DOWNCONVERT);\n\t/* set things up for the unlockast to know to just\n\t * clear out the ast_action and unset busy, etc. */\n\tlockres->l_unlock_action = OCFS2_UNLOCK_CANCEL_CONVERT;\n\n\tmlog_bug_on_msg(!(lockres->l_flags & OCFS2_LOCK_BUSY),\n\t\t\t\"lock %s, invalid flags: 0x%lx\\n\",\n\t\t\tlockres->l_name, lockres->l_flags);\n\n\tmlog(ML_BASTS, \"lockres %s\\n\", lockres->l_name);\n\n\treturn 1;\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"refcounttree.h\"",
      "#include \"quota.h\"",
      "#include \"uptodate.h\"",
      "#include \"super.h\"",
      "#include \"slot_map.h\"",
      "#include \"stackglue.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"heartbeat.h\"",
      "#include \"file.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"dcache.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2_lockingver.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/time.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/kthread.h>",
      "#include <linux/mm.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct ocfs2_super *ocfs2_get_dentry_osb(struct ocfs2_lock_res *lockres);",
      "static struct ocfs2_super *ocfs2_get_inode_osb(struct ocfs2_lock_res *lockres);",
      "static struct ocfs2_super *ocfs2_get_file_osb(struct ocfs2_lock_res *lockres);",
      "static struct ocfs2_super *ocfs2_get_qinfo_osb(struct ocfs2_lock_res *lockres);",
      "static void ocfs2_set_meta_lvb(struct ocfs2_lock_res *lockres);",
      "static void ocfs2_dentry_post_unlock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres);",
      "static void ocfs2_set_qinfo_lvb(struct ocfs2_lock_res *lockres);",
      "static inline void ocfs2_generic_handle_downconvert_action(struct ocfs2_lock_res *lockres);",
      "static inline void ocfs2_generic_handle_convert_action(struct ocfs2_lock_res *lockres);",
      "static inline void ocfs2_generic_handle_attach_action(struct ocfs2_lock_res *lockres);",
      "static void ocfs2_schedule_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);",
      "static inline void ocfs2_recover_from_dlm_error(struct ocfs2_lock_res *lockres,\n\t\t\t\t\t\tint convert);",
      "static void ocfs2_downconvert_on_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);",
      "static void ocfs2_drop_osb_locks(struct ocfs2_super *osb);",
      "static int ocfs2_prepare_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\t        struct ocfs2_lock_res *lockres);",
      "static int ocfs2_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres);",
      "static void ocfs2_process_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *lockres);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mlog",
          "args": [
            "ML_BASTS",
            "\"lockres %s\\n\"",
            "lockres->l_name"
          ],
          "line": 3360
        },
        "resolved": true,
        "details": {
          "function_name": "mlog_show",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/cluster/masklog.c",
          "lines": "107-113",
          "snippet": "static ssize_t mlog_show(struct kobject *obj, struct attribute *attr,\n\t\t\t char *buf)\n{\n\tstruct mlog_attribute *mlog_attr = to_mlog_attr(attr);\n\n\treturn mlog_mask_show(mlog_attr->mask, buf);\n}",
          "includes": [
            "#include \"masklog.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/string.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"masklog.h\"\n#include <asm/uaccess.h>\n#include <linux/string.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n\nstatic ssize_t mlog_show(struct kobject *obj, struct attribute *attr,\n\t\t\t char *buf)\n{\n\tstruct mlog_attribute *mlog_attr = to_mlog_attr(attr);\n\n\treturn mlog_mask_show(mlog_attr->mask, buf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_bug_on_msg",
          "args": [
            "!(lockres->l_flags & OCFS2_LOCK_BUSY)",
            "\"lock %s, invalid flags: 0x%lx\\n\"",
            "lockres->l_name",
            "lockres->l_flags"
          ],
          "line": 3356
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "lockres->l_action != OCFS2_AST_CONVERT &&\n\t       lockres->l_action != OCFS2_AST_DOWNCONVERT"
          ],
          "line": 3350
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "assert_spin_locked",
          "args": [
            "&lockres->l_lock"
          ],
          "line": 3339
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"stackglue.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dcache.h\"\n#include \"alloc.h\"\n#include \"ocfs2_lockingver.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/quotaops.h>\n#include <linux/time.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/pagemap.h>\n#include <linux/kthread.h>\n#include <linux/mm.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic struct ocfs2_super *ocfs2_get_dentry_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_inode_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_file_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_qinfo_osb(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_set_meta_lvb(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_dentry_post_unlock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres);\nstatic void ocfs2_set_qinfo_lvb(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_downconvert_action(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_convert_action(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_attach_action(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_schedule_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_recover_from_dlm_error(struct ocfs2_lock_res *lockres,\n\t\t\t\t\t\tint convert);\nstatic void ocfs2_downconvert_on_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_drop_osb_locks(struct ocfs2_super *osb);\nstatic int ocfs2_prepare_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\t        struct ocfs2_lock_res *lockres);\nstatic int ocfs2_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_process_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *lockres);\n\nstatic int ocfs2_prepare_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\t        struct ocfs2_lock_res *lockres)\n{\n\tassert_spin_locked(&lockres->l_lock);\n\n\tif (lockres->l_unlock_action == OCFS2_UNLOCK_CANCEL_CONVERT) {\n\t\t/* If we're already trying to cancel a lock conversion\n\t\t * then just drop the spinlock and allow the caller to\n\t\t * requeue this lock. */\n\t\tmlog(ML_BASTS, \"lockres %s, skip convert\\n\", lockres->l_name);\n\t\treturn 0;\n\t}\n\n\t/* were we in a convert when we got the bast fire? */\n\tBUG_ON(lockres->l_action != OCFS2_AST_CONVERT &&\n\t       lockres->l_action != OCFS2_AST_DOWNCONVERT);\n\t/* set things up for the unlockast to know to just\n\t * clear out the ast_action and unset busy, etc. */\n\tlockres->l_unlock_action = OCFS2_UNLOCK_CANCEL_CONVERT;\n\n\tmlog_bug_on_msg(!(lockres->l_flags & OCFS2_LOCK_BUSY),\n\t\t\t\"lock %s, invalid flags: 0x%lx\\n\",\n\t\t\tlockres->l_name, lockres->l_flags);\n\n\tmlog(ML_BASTS, \"lockres %s\\n\", lockres->l_name);\n\n\treturn 1;\n}"
  },
  {
    "function_name": "ocfs2_downconvert_lock",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlmglue.c",
    "lines": "3302-3333",
    "snippet": "static int ocfs2_downconvert_lock(struct ocfs2_super *osb,\n\t\t\t\t  struct ocfs2_lock_res *lockres,\n\t\t\t\t  int new_level,\n\t\t\t\t  int lvb,\n\t\t\t\t  unsigned int generation)\n{\n\tint ret;\n\tu32 dlm_flags = DLM_LKF_CONVERT;\n\n\tmlog(ML_BASTS, \"lockres %s, level %d => %d\\n\", lockres->l_name,\n\t     lockres->l_level, new_level);\n\n\tif (lvb)\n\t\tdlm_flags |= DLM_LKF_VALBLK;\n\n\tret = ocfs2_dlm_lock(osb->cconn,\n\t\t\t     new_level,\n\t\t\t     &lockres->l_lksb,\n\t\t\t     dlm_flags,\n\t\t\t     lockres->l_name,\n\t\t\t     OCFS2_LOCK_ID_MAX_LEN - 1);\n\tlockres_clear_pending(lockres, generation, osb);\n\tif (ret) {\n\t\tocfs2_log_dlm_error(\"ocfs2_dlm_lock\", ret, lockres);\n\t\tocfs2_recover_from_dlm_error(lockres, 1);\n\t\tgoto bail;\n\t}\n\n\tret = 0;\nbail:\n\treturn ret;\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"refcounttree.h\"",
      "#include \"quota.h\"",
      "#include \"uptodate.h\"",
      "#include \"super.h\"",
      "#include \"slot_map.h\"",
      "#include \"stackglue.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"heartbeat.h\"",
      "#include \"file.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"dcache.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2_lockingver.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/time.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/kthread.h>",
      "#include <linux/mm.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct ocfs2_super *ocfs2_get_dentry_osb(struct ocfs2_lock_res *lockres);",
      "static struct ocfs2_super *ocfs2_get_inode_osb(struct ocfs2_lock_res *lockres);",
      "static struct ocfs2_super *ocfs2_get_file_osb(struct ocfs2_lock_res *lockres);",
      "static struct ocfs2_super *ocfs2_get_qinfo_osb(struct ocfs2_lock_res *lockres);",
      "static int ocfs2_check_meta_downconvert(struct ocfs2_lock_res *lockres,\n\t\t\t\t\tint new_level);",
      "static void ocfs2_set_meta_lvb(struct ocfs2_lock_res *lockres);",
      "static void ocfs2_dentry_post_unlock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres);",
      "static void ocfs2_set_qinfo_lvb(struct ocfs2_lock_res *lockres);",
      "static int ocfs2_check_refcount_downconvert(struct ocfs2_lock_res *lockres,\n\t\t\t\t\t    int new_level);",
      "static int ocfs2_lock_create(struct ocfs2_super *osb,\n\t\t\t     struct ocfs2_lock_res *lockres,\n\t\t\t     int level,\n\t\t\t     u32 dlm_flags);",
      "static inline void ocfs2_generic_handle_downconvert_action(struct ocfs2_lock_res *lockres);",
      "static inline void ocfs2_generic_handle_convert_action(struct ocfs2_lock_res *lockres);",
      "static inline void ocfs2_generic_handle_attach_action(struct ocfs2_lock_res *lockres);",
      "static int ocfs2_generic_handle_bast(struct ocfs2_lock_res *lockres, int level);",
      "static void ocfs2_schedule_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);",
      "static void ocfs2_downconvert_on_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);",
      "static void ocfs2_drop_osb_locks(struct ocfs2_super *osb);",
      "static inline int ocfs2_highest_compat_lock_level(int level);",
      "static unsigned int ocfs2_prepare_downconvert(struct ocfs2_lock_res *lockres,\n\t\t\t\t\t      int new_level);",
      "static int ocfs2_downconvert_lock(struct ocfs2_super *osb,\n\t\t\t\t  struct ocfs2_lock_res *lockres,\n\t\t\t\t  int new_level,\n\t\t\t\t  int lvb,\n\t\t\t\t  unsigned int generation);",
      "static int ocfs2_prepare_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\t        struct ocfs2_lock_res *lockres);",
      "static int ocfs2_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres);",
      "static void ocfs2_process_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *lockres);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ocfs2_recover_from_dlm_error",
          "args": [
            "lockres",
            "1"
          ],
          "line": 3326
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_recover_from_dlm_error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlmglue.c",
          "lines": "1199-1214",
          "snippet": "static inline void ocfs2_recover_from_dlm_error(struct ocfs2_lock_res *lockres,\n\t\t\t\t\t\tint convert)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&lockres->l_lock, flags);\n\tlockres_clear_flags(lockres, OCFS2_LOCK_BUSY);\n\tlockres_clear_flags(lockres, OCFS2_LOCK_UPCONVERT_FINISHING);\n\tif (convert)\n\t\tlockres->l_action = OCFS2_AST_INVALID;\n\telse\n\t\tlockres->l_unlock_action = OCFS2_UNLOCK_INVALID;\n\tspin_unlock_irqrestore(&lockres->l_lock, flags);\n\n\twake_up(&lockres->l_event);\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"refcounttree.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"stackglue.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dcache.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2_lockingver.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/time.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/kthread.h>",
            "#include <linux/mm.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct ocfs2_super *ocfs2_get_dentry_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_inode_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_file_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_qinfo_osb(struct ocfs2_lock_res *lockres);",
            "static void ocfs2_set_meta_lvb(struct ocfs2_lock_res *lockres);",
            "static void ocfs2_dentry_post_unlock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres);",
            "static void ocfs2_set_qinfo_lvb(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_downconvert_action(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_convert_action(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_attach_action(struct ocfs2_lock_res *lockres);",
            "static void ocfs2_schedule_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_recover_from_dlm_error(struct ocfs2_lock_res *lockres,\n\t\t\t\t\t\tint convert);",
            "static void ocfs2_downconvert_on_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static int ocfs2_prepare_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\t        struct ocfs2_lock_res *lockres);",
            "static int ocfs2_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static void ocfs2_process_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *lockres);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"stackglue.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dcache.h\"\n#include \"alloc.h\"\n#include \"ocfs2_lockingver.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/quotaops.h>\n#include <linux/time.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/pagemap.h>\n#include <linux/kthread.h>\n#include <linux/mm.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic struct ocfs2_super *ocfs2_get_dentry_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_inode_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_file_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_qinfo_osb(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_set_meta_lvb(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_dentry_post_unlock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres);\nstatic void ocfs2_set_qinfo_lvb(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_downconvert_action(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_convert_action(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_attach_action(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_schedule_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_recover_from_dlm_error(struct ocfs2_lock_res *lockres,\n\t\t\t\t\t\tint convert);\nstatic void ocfs2_downconvert_on_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic int ocfs2_prepare_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\t        struct ocfs2_lock_res *lockres);\nstatic int ocfs2_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_process_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *lockres);\n\nstatic inline void ocfs2_recover_from_dlm_error(struct ocfs2_lock_res *lockres,\n\t\t\t\t\t\tint convert)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&lockres->l_lock, flags);\n\tlockres_clear_flags(lockres, OCFS2_LOCK_BUSY);\n\tlockres_clear_flags(lockres, OCFS2_LOCK_UPCONVERT_FINISHING);\n\tif (convert)\n\t\tlockres->l_action = OCFS2_AST_INVALID;\n\telse\n\t\tlockres->l_unlock_action = OCFS2_UNLOCK_INVALID;\n\tspin_unlock_irqrestore(&lockres->l_lock, flags);\n\n\twake_up(&lockres->l_event);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_log_dlm_error",
          "args": [
            "\"ocfs2_dlm_lock\"",
            "ret",
            "lockres"
          ],
          "line": 3325
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lockres_clear_pending",
          "args": [
            "lockres",
            "generation",
            "osb"
          ],
          "line": 3323
        },
        "resolved": true,
        "details": {
          "function_name": "lockres_clear_pending",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlmglue.c",
          "lines": "1004-1013",
          "snippet": "static void lockres_clear_pending(struct ocfs2_lock_res *lockres,\n\t\t\t\t  unsigned int generation,\n\t\t\t\t  struct ocfs2_super *osb)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&lockres->l_lock, flags);\n\t__lockres_clear_pending(lockres, generation, osb);\n\tspin_unlock_irqrestore(&lockres->l_lock, flags);\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"refcounttree.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"stackglue.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dcache.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2_lockingver.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/time.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/kthread.h>",
            "#include <linux/mm.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct ocfs2_super *ocfs2_get_dentry_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_inode_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_file_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_qinfo_osb(struct ocfs2_lock_res *lockres);",
            "static void ocfs2_set_meta_lvb(struct ocfs2_lock_res *lockres);",
            "static void ocfs2_dentry_post_unlock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres);",
            "static void ocfs2_set_qinfo_lvb(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_downconvert_action(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_convert_action(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_attach_action(struct ocfs2_lock_res *lockres);",
            "static void ocfs2_schedule_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static void ocfs2_downconvert_on_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static void ocfs2_drop_osb_locks(struct ocfs2_super *osb);",
            "static int ocfs2_downconvert_lock(struct ocfs2_super *osb,\n\t\t\t\t  struct ocfs2_lock_res *lockres,\n\t\t\t\t  int new_level,\n\t\t\t\t  int lvb,\n\t\t\t\t  unsigned int generation);",
            "static int ocfs2_prepare_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\t        struct ocfs2_lock_res *lockres);",
            "static int ocfs2_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static void ocfs2_process_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *lockres);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"stackglue.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dcache.h\"\n#include \"alloc.h\"\n#include \"ocfs2_lockingver.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/quotaops.h>\n#include <linux/time.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/pagemap.h>\n#include <linux/kthread.h>\n#include <linux/mm.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic struct ocfs2_super *ocfs2_get_dentry_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_inode_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_file_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_qinfo_osb(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_set_meta_lvb(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_dentry_post_unlock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres);\nstatic void ocfs2_set_qinfo_lvb(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_downconvert_action(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_convert_action(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_attach_action(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_schedule_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_downconvert_on_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_drop_osb_locks(struct ocfs2_super *osb);\nstatic int ocfs2_downconvert_lock(struct ocfs2_super *osb,\n\t\t\t\t  struct ocfs2_lock_res *lockres,\n\t\t\t\t  int new_level,\n\t\t\t\t  int lvb,\n\t\t\t\t  unsigned int generation);\nstatic int ocfs2_prepare_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\t        struct ocfs2_lock_res *lockres);\nstatic int ocfs2_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_process_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *lockres);\n\nstatic void lockres_clear_pending(struct ocfs2_lock_res *lockres,\n\t\t\t\t  unsigned int generation,\n\t\t\t\t  struct ocfs2_super *osb)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&lockres->l_lock, flags);\n\t__lockres_clear_pending(lockres, generation, osb);\n\tspin_unlock_irqrestore(&lockres->l_lock, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_dlm_lock",
          "args": [
            "osb->cconn",
            "new_level",
            "&lockres->l_lksb",
            "dlm_flags",
            "lockres->l_name",
            "OCFS2_LOCK_ID_MAX_LEN - 1"
          ],
          "line": 3317
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_dlm_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/stackglue.c",
          "lines": "241-254",
          "snippet": "int ocfs2_dlm_lock(struct ocfs2_cluster_connection *conn,\n\t\t   int mode,\n\t\t   struct ocfs2_dlm_lksb *lksb,\n\t\t   u32 flags,\n\t\t   void *name,\n\t\t   unsigned int namelen)\n{\n\tif (!lksb->lksb_conn)\n\t\tlksb->lksb_conn = conn;\n\telse\n\t\tBUG_ON(lksb->lksb_conn != conn);\n\treturn active_stack->sp_ops->dlm_lock(conn, mode, lksb, flags,\n\t\t\t\t\t      name, namelen);\n}",
          "includes": [
            "#include \"stackglue.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include <linux/sysctl.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/fs.h>",
            "#include <linux/kmod.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/list.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct ocfs2_stack_plugin *active_stack;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"stackglue.h\"\n#include \"ocfs2_fs.h\"\n#include <linux/sysctl.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/fs.h>\n#include <linux/kmod.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/spinlock.h>\n#include <linux/list.h>\n\nstatic struct ocfs2_stack_plugin *active_stack;\n\nint ocfs2_dlm_lock(struct ocfs2_cluster_connection *conn,\n\t\t   int mode,\n\t\t   struct ocfs2_dlm_lksb *lksb,\n\t\t   u32 flags,\n\t\t   void *name,\n\t\t   unsigned int namelen)\n{\n\tif (!lksb->lksb_conn)\n\t\tlksb->lksb_conn = conn;\n\telse\n\t\tBUG_ON(lksb->lksb_conn != conn);\n\treturn active_stack->sp_ops->dlm_lock(conn, mode, lksb, flags,\n\t\t\t\t\t      name, namelen);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog",
          "args": [
            "ML_BASTS",
            "\"lockres %s, level %d => %d\\n\"",
            "lockres->l_name",
            "lockres->l_level",
            "new_level"
          ],
          "line": 3311
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"stackglue.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dcache.h\"\n#include \"alloc.h\"\n#include \"ocfs2_lockingver.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/quotaops.h>\n#include <linux/time.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/pagemap.h>\n#include <linux/kthread.h>\n#include <linux/mm.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic struct ocfs2_super *ocfs2_get_dentry_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_inode_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_file_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_qinfo_osb(struct ocfs2_lock_res *lockres);\nstatic int ocfs2_check_meta_downconvert(struct ocfs2_lock_res *lockres,\n\t\t\t\t\tint new_level);\nstatic void ocfs2_set_meta_lvb(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_dentry_post_unlock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres);\nstatic void ocfs2_set_qinfo_lvb(struct ocfs2_lock_res *lockres);\nstatic int ocfs2_check_refcount_downconvert(struct ocfs2_lock_res *lockres,\n\t\t\t\t\t    int new_level);\nstatic int ocfs2_lock_create(struct ocfs2_super *osb,\n\t\t\t     struct ocfs2_lock_res *lockres,\n\t\t\t     int level,\n\t\t\t     u32 dlm_flags);\nstatic inline void ocfs2_generic_handle_downconvert_action(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_convert_action(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_attach_action(struct ocfs2_lock_res *lockres);\nstatic int ocfs2_generic_handle_bast(struct ocfs2_lock_res *lockres, int level);\nstatic void ocfs2_schedule_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_downconvert_on_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_drop_osb_locks(struct ocfs2_super *osb);\nstatic inline int ocfs2_highest_compat_lock_level(int level);\nstatic unsigned int ocfs2_prepare_downconvert(struct ocfs2_lock_res *lockres,\n\t\t\t\t\t      int new_level);\nstatic int ocfs2_downconvert_lock(struct ocfs2_super *osb,\n\t\t\t\t  struct ocfs2_lock_res *lockres,\n\t\t\t\t  int new_level,\n\t\t\t\t  int lvb,\n\t\t\t\t  unsigned int generation);\nstatic int ocfs2_prepare_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\t        struct ocfs2_lock_res *lockres);\nstatic int ocfs2_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_process_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *lockres);\n\nstatic int ocfs2_downconvert_lock(struct ocfs2_super *osb,\n\t\t\t\t  struct ocfs2_lock_res *lockres,\n\t\t\t\t  int new_level,\n\t\t\t\t  int lvb,\n\t\t\t\t  unsigned int generation)\n{\n\tint ret;\n\tu32 dlm_flags = DLM_LKF_CONVERT;\n\n\tmlog(ML_BASTS, \"lockres %s, level %d => %d\\n\", lockres->l_name,\n\t     lockres->l_level, new_level);\n\n\tif (lvb)\n\t\tdlm_flags |= DLM_LKF_VALBLK;\n\n\tret = ocfs2_dlm_lock(osb->cconn,\n\t\t\t     new_level,\n\t\t\t     &lockres->l_lksb,\n\t\t\t     dlm_flags,\n\t\t\t     lockres->l_name,\n\t\t\t     OCFS2_LOCK_ID_MAX_LEN - 1);\n\tlockres_clear_pending(lockres, generation, osb);\n\tif (ret) {\n\t\tocfs2_log_dlm_error(\"ocfs2_dlm_lock\", ret, lockres);\n\t\tocfs2_recover_from_dlm_error(lockres, 1);\n\t\tgoto bail;\n\t}\n\n\tret = 0;\nbail:\n\treturn ret;\n}"
  },
  {
    "function_name": "ocfs2_prepare_downconvert",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlmglue.c",
    "lines": "3273-3300",
    "snippet": "static unsigned int ocfs2_prepare_downconvert(struct ocfs2_lock_res *lockres,\n\t\t\t\t\t      int new_level)\n{\n\tassert_spin_locked(&lockres->l_lock);\n\n\tBUG_ON(lockres->l_blocking <= DLM_LOCK_NL);\n\n\tif (lockres->l_level <= new_level) {\n\t\tmlog(ML_ERROR, \"lockres %s, lvl %d <= %d, blcklst %d, mask %d, \"\n\t\t     \"type %d, flags 0x%lx, hold %d %d, act %d %d, req %d, \"\n\t\t     \"block %d, pgen %d\\n\", lockres->l_name, lockres->l_level,\n\t\t     new_level, list_empty(&lockres->l_blocked_list),\n\t\t     list_empty(&lockres->l_mask_waiters), lockres->l_type,\n\t\t     lockres->l_flags, lockres->l_ro_holders,\n\t\t     lockres->l_ex_holders, lockres->l_action,\n\t\t     lockres->l_unlock_action, lockres->l_requested,\n\t\t     lockres->l_blocking, lockres->l_pending_gen);\n\t\tBUG();\n\t}\n\n\tmlog(ML_BASTS, \"lockres %s, level %d => %d, blocking %d\\n\",\n\t     lockres->l_name, lockres->l_level, new_level, lockres->l_blocking);\n\n\tlockres->l_action = OCFS2_AST_DOWNCONVERT;\n\tlockres->l_requested = new_level;\n\tlockres_or_flags(lockres, OCFS2_LOCK_BUSY);\n\treturn lockres_set_pending(lockres);\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"refcounttree.h\"",
      "#include \"quota.h\"",
      "#include \"uptodate.h\"",
      "#include \"super.h\"",
      "#include \"slot_map.h\"",
      "#include \"stackglue.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"heartbeat.h\"",
      "#include \"file.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"dcache.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2_lockingver.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/time.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/kthread.h>",
      "#include <linux/mm.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct ocfs2_super *ocfs2_get_dentry_osb(struct ocfs2_lock_res *lockres);",
      "static struct ocfs2_super *ocfs2_get_inode_osb(struct ocfs2_lock_res *lockres);",
      "static struct ocfs2_super *ocfs2_get_file_osb(struct ocfs2_lock_res *lockres);",
      "static struct ocfs2_super *ocfs2_get_qinfo_osb(struct ocfs2_lock_res *lockres);",
      "static int ocfs2_check_meta_downconvert(struct ocfs2_lock_res *lockres,\n\t\t\t\t\tint new_level);",
      "static void ocfs2_set_meta_lvb(struct ocfs2_lock_res *lockres);",
      "static int ocfs2_data_convert_worker(struct ocfs2_lock_res *lockres,\n\t\t\t\t     int blocking);",
      "static int ocfs2_dentry_convert_worker(struct ocfs2_lock_res *lockres,\n\t\t\t\t       int blocking);",
      "static void ocfs2_dentry_post_unlock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres);",
      "static void ocfs2_set_qinfo_lvb(struct ocfs2_lock_res *lockres);",
      "static int ocfs2_check_refcount_downconvert(struct ocfs2_lock_res *lockres,\n\t\t\t\t\t    int new_level);",
      "static int ocfs2_refcount_convert_worker(struct ocfs2_lock_res *lockres,\n\t\t\t\t\t int blocking);",
      "static inline void ocfs2_generic_handle_downconvert_action(struct ocfs2_lock_res *lockres);",
      "static inline void ocfs2_generic_handle_convert_action(struct ocfs2_lock_res *lockres);",
      "static inline void ocfs2_generic_handle_attach_action(struct ocfs2_lock_res *lockres);",
      "static int ocfs2_generic_handle_bast(struct ocfs2_lock_res *lockres, int level);",
      "static void ocfs2_schedule_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);",
      "static void ocfs2_downconvert_on_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);",
      "static inline int ocfs2_highest_compat_lock_level(int level);",
      "static unsigned int ocfs2_prepare_downconvert(struct ocfs2_lock_res *lockres,\n\t\t\t\t\t      int new_level);",
      "static int ocfs2_prepare_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\t        struct ocfs2_lock_res *lockres);",
      "static int ocfs2_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres);",
      "static void ocfs2_process_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *lockres);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "lockres_set_pending",
          "args": [
            "lockres"
          ],
          "line": 3299
        },
        "resolved": true,
        "details": {
          "function_name": "lockres_set_pending",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlmglue.c",
          "lines": "1015-1023",
          "snippet": "static unsigned int lockres_set_pending(struct ocfs2_lock_res *lockres)\n{\n\tassert_spin_locked(&lockres->l_lock);\n\tBUG_ON(!(lockres->l_flags & OCFS2_LOCK_BUSY));\n\n\tlockres_or_flags(lockres, OCFS2_LOCK_PENDING);\n\n\treturn lockres->l_pending_gen;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"refcounttree.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"stackglue.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dcache.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2_lockingver.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/time.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/kthread.h>",
            "#include <linux/mm.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct ocfs2_super *ocfs2_get_dentry_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_inode_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_file_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_qinfo_osb(struct ocfs2_lock_res *lockres);",
            "static void ocfs2_set_meta_lvb(struct ocfs2_lock_res *lockres);",
            "static void ocfs2_dentry_post_unlock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres);",
            "static void ocfs2_set_qinfo_lvb(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_downconvert_action(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_convert_action(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_attach_action(struct ocfs2_lock_res *lockres);",
            "static void ocfs2_schedule_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static void ocfs2_downconvert_on_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static int ocfs2_prepare_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\t        struct ocfs2_lock_res *lockres);",
            "static int ocfs2_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static void ocfs2_process_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *lockres);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"stackglue.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dcache.h\"\n#include \"alloc.h\"\n#include \"ocfs2_lockingver.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/quotaops.h>\n#include <linux/time.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/pagemap.h>\n#include <linux/kthread.h>\n#include <linux/mm.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic struct ocfs2_super *ocfs2_get_dentry_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_inode_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_file_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_qinfo_osb(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_set_meta_lvb(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_dentry_post_unlock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres);\nstatic void ocfs2_set_qinfo_lvb(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_downconvert_action(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_convert_action(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_attach_action(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_schedule_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_downconvert_on_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic int ocfs2_prepare_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\t        struct ocfs2_lock_res *lockres);\nstatic int ocfs2_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_process_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *lockres);\n\nstatic unsigned int lockres_set_pending(struct ocfs2_lock_res *lockres)\n{\n\tassert_spin_locked(&lockres->l_lock);\n\tBUG_ON(!(lockres->l_flags & OCFS2_LOCK_BUSY));\n\n\tlockres_or_flags(lockres, OCFS2_LOCK_PENDING);\n\n\treturn lockres->l_pending_gen;\n}"
        }
      },
      {
        "call_info": {
          "callee": "lockres_or_flags",
          "args": [
            "lockres",
            "OCFS2_LOCK_BUSY"
          ],
          "line": 3298
        },
        "resolved": true,
        "details": {
          "function_name": "lockres_or_flags",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlmglue.c",
          "lines": "819-822",
          "snippet": "static void lockres_or_flags(struct ocfs2_lock_res *lockres, unsigned long or)\n{\n\tlockres_set_flags(lockres, lockres->l_flags | or);\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"refcounttree.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"stackglue.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dcache.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2_lockingver.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/time.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/kthread.h>",
            "#include <linux/mm.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct ocfs2_super *ocfs2_get_dentry_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_inode_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_file_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_qinfo_osb(struct ocfs2_lock_res *lockres);",
            "static void ocfs2_set_meta_lvb(struct ocfs2_lock_res *lockres);",
            "static void ocfs2_dentry_post_unlock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres);",
            "static void ocfs2_set_qinfo_lvb(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_downconvert_action(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_convert_action(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_attach_action(struct ocfs2_lock_res *lockres);",
            "static void ocfs2_schedule_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static void ocfs2_downconvert_on_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static int ocfs2_prepare_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\t        struct ocfs2_lock_res *lockres);",
            "static int ocfs2_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static void ocfs2_process_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *lockres);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"stackglue.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dcache.h\"\n#include \"alloc.h\"\n#include \"ocfs2_lockingver.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/quotaops.h>\n#include <linux/time.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/pagemap.h>\n#include <linux/kthread.h>\n#include <linux/mm.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic struct ocfs2_super *ocfs2_get_dentry_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_inode_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_file_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_qinfo_osb(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_set_meta_lvb(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_dentry_post_unlock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres);\nstatic void ocfs2_set_qinfo_lvb(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_downconvert_action(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_convert_action(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_attach_action(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_schedule_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_downconvert_on_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic int ocfs2_prepare_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\t        struct ocfs2_lock_res *lockres);\nstatic int ocfs2_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_process_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *lockres);\n\nstatic void lockres_or_flags(struct ocfs2_lock_res *lockres, unsigned long or)\n{\n\tlockres_set_flags(lockres, lockres->l_flags | or);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog",
          "args": [
            "ML_BASTS",
            "\"lockres %s, level %d => %d, blocking %d\\n\"",
            "lockres->l_name",
            "lockres->l_level",
            "new_level",
            "lockres->l_blocking"
          ],
          "line": 3293
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG",
          "args": [],
          "line": 3290
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mlog",
          "args": [
            "ML_ERROR",
            "\"lockres %s, lvl %d <= %d, blcklst %d, mask %d, \"\n\t\t     \"type %d, flags 0x%lx, hold %d %d, act %d %d, req %d, \"\n\t\t     \"block %d, pgen %d\\n\"",
            "lockres->l_name",
            "lockres->l_level",
            "new_level",
            "list_empty(&lockres->l_blocked_list)",
            "list_empty(&lockres->l_mask_waiters)",
            "lockres->l_type",
            "lockres->l_flags",
            "lockres->l_ro_holders",
            "lockres->l_ex_holders",
            "lockres->l_action",
            "lockres->l_unlock_action",
            "lockres->l_requested",
            "lockres->l_blocking",
            "lockres->l_pending_gen"
          ],
          "line": 3281
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&lockres->l_mask_waiters"
          ],
          "line": 3285
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_dirty_list_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmthread.c",
          "lines": "505-514",
          "snippet": "static int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/timer.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_flush_asts(struct dlm_ctxt *dlm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/timer.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_flush_asts(struct dlm_ctxt *dlm);\n\nstatic int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "lockres->l_blocking <= DLM_LOCK_NL"
          ],
          "line": 3278
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "assert_spin_locked",
          "args": [
            "&lockres->l_lock"
          ],
          "line": 3276
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"stackglue.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dcache.h\"\n#include \"alloc.h\"\n#include \"ocfs2_lockingver.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/quotaops.h>\n#include <linux/time.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/pagemap.h>\n#include <linux/kthread.h>\n#include <linux/mm.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic struct ocfs2_super *ocfs2_get_dentry_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_inode_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_file_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_qinfo_osb(struct ocfs2_lock_res *lockres);\nstatic int ocfs2_check_meta_downconvert(struct ocfs2_lock_res *lockres,\n\t\t\t\t\tint new_level);\nstatic void ocfs2_set_meta_lvb(struct ocfs2_lock_res *lockres);\nstatic int ocfs2_data_convert_worker(struct ocfs2_lock_res *lockres,\n\t\t\t\t     int blocking);\nstatic int ocfs2_dentry_convert_worker(struct ocfs2_lock_res *lockres,\n\t\t\t\t       int blocking);\nstatic void ocfs2_dentry_post_unlock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres);\nstatic void ocfs2_set_qinfo_lvb(struct ocfs2_lock_res *lockres);\nstatic int ocfs2_check_refcount_downconvert(struct ocfs2_lock_res *lockres,\n\t\t\t\t\t    int new_level);\nstatic int ocfs2_refcount_convert_worker(struct ocfs2_lock_res *lockres,\n\t\t\t\t\t int blocking);\nstatic inline void ocfs2_generic_handle_downconvert_action(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_convert_action(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_attach_action(struct ocfs2_lock_res *lockres);\nstatic int ocfs2_generic_handle_bast(struct ocfs2_lock_res *lockres, int level);\nstatic void ocfs2_schedule_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_downconvert_on_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic inline int ocfs2_highest_compat_lock_level(int level);\nstatic unsigned int ocfs2_prepare_downconvert(struct ocfs2_lock_res *lockres,\n\t\t\t\t\t      int new_level);\nstatic int ocfs2_prepare_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\t        struct ocfs2_lock_res *lockres);\nstatic int ocfs2_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_process_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *lockres);\n\nstatic unsigned int ocfs2_prepare_downconvert(struct ocfs2_lock_res *lockres,\n\t\t\t\t\t      int new_level)\n{\n\tassert_spin_locked(&lockres->l_lock);\n\n\tBUG_ON(lockres->l_blocking <= DLM_LOCK_NL);\n\n\tif (lockres->l_level <= new_level) {\n\t\tmlog(ML_ERROR, \"lockres %s, lvl %d <= %d, blcklst %d, mask %d, \"\n\t\t     \"type %d, flags 0x%lx, hold %d %d, act %d %d, req %d, \"\n\t\t     \"block %d, pgen %d\\n\", lockres->l_name, lockres->l_level,\n\t\t     new_level, list_empty(&lockres->l_blocked_list),\n\t\t     list_empty(&lockres->l_mask_waiters), lockres->l_type,\n\t\t     lockres->l_flags, lockres->l_ro_holders,\n\t\t     lockres->l_ex_holders, lockres->l_action,\n\t\t     lockres->l_unlock_action, lockres->l_requested,\n\t\t     lockres->l_blocking, lockres->l_pending_gen);\n\t\tBUG();\n\t}\n\n\tmlog(ML_BASTS, \"lockres %s, level %d => %d, blocking %d\\n\",\n\t     lockres->l_name, lockres->l_level, new_level, lockres->l_blocking);\n\n\tlockres->l_action = OCFS2_AST_DOWNCONVERT;\n\tlockres->l_requested = new_level;\n\tlockres_or_flags(lockres, OCFS2_LOCK_BUSY);\n\treturn lockres_set_pending(lockres);\n}"
  },
  {
    "function_name": "ocfs2_drop_inode_locks",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlmglue.c",
    "lines": "3242-3271",
    "snippet": "int ocfs2_drop_inode_locks(struct inode *inode)\n{\n\tint status, err;\n\n\t/* No need to call ocfs2_mark_lockres_freeing here -\n\t * ocfs2_clear_inode has done it for us. */\n\n\terr = ocfs2_drop_lock(OCFS2_SB(inode->i_sb),\n\t\t\t      &OCFS2_I(inode)->ip_open_lockres);\n\tif (err < 0)\n\t\tmlog_errno(err);\n\n\tstatus = err;\n\n\terr = ocfs2_drop_lock(OCFS2_SB(inode->i_sb),\n\t\t\t      &OCFS2_I(inode)->ip_inode_lockres);\n\tif (err < 0)\n\t\tmlog_errno(err);\n\tif (err < 0 && !status)\n\t\tstatus = err;\n\n\terr = ocfs2_drop_lock(OCFS2_SB(inode->i_sb),\n\t\t\t      &OCFS2_I(inode)->ip_rw_lockres);\n\tif (err < 0)\n\t\tmlog_errno(err);\n\tif (err < 0 && !status)\n\t\tstatus = err;\n\n\treturn status;\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"refcounttree.h\"",
      "#include \"quota.h\"",
      "#include \"uptodate.h\"",
      "#include \"super.h\"",
      "#include \"slot_map.h\"",
      "#include \"stackglue.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"heartbeat.h\"",
      "#include \"file.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"dcache.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2_lockingver.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/time.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/kthread.h>",
      "#include <linux/mm.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "err"
          ],
          "line": 3266
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_drop_lock",
          "args": [
            "OCFS2_SB(inode->i_sb)",
            "&OCFS2_I(inode)->ip_rw_lockres"
          ],
          "line": 3263
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_drop_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlmglue.c",
          "lines": "3072-3152",
          "snippet": "static int ocfs2_drop_lock(struct ocfs2_super *osb,\n\t\t\t   struct ocfs2_lock_res *lockres)\n{\n\tint ret;\n\tunsigned long flags;\n\tu32 lkm_flags = 0;\n\n\t/* We didn't get anywhere near actually using this lockres. */\n\tif (!(lockres->l_flags & OCFS2_LOCK_INITIALIZED))\n\t\tgoto out;\n\n\tif (lockres->l_ops->flags & LOCK_TYPE_USES_LVB)\n\t\tlkm_flags |= DLM_LKF_VALBLK;\n\n\tspin_lock_irqsave(&lockres->l_lock, flags);\n\n\tmlog_bug_on_msg(!(lockres->l_flags & OCFS2_LOCK_FREEING),\n\t\t\t\"lockres %s, flags 0x%lx\\n\",\n\t\t\tlockres->l_name, lockres->l_flags);\n\n\twhile (lockres->l_flags & OCFS2_LOCK_BUSY) {\n\t\tmlog(0, \"waiting on busy lock \\\"%s\\\": flags = %lx, action = \"\n\t\t     \"%u, unlock_action = %u\\n\",\n\t\t     lockres->l_name, lockres->l_flags, lockres->l_action,\n\t\t     lockres->l_unlock_action);\n\n\t\tspin_unlock_irqrestore(&lockres->l_lock, flags);\n\n\t\t/* XXX: Today we just wait on any busy\n\t\t * locks... Perhaps we need to cancel converts in the\n\t\t * future? */\n\t\tocfs2_wait_on_busy_lock(lockres);\n\n\t\tspin_lock_irqsave(&lockres->l_lock, flags);\n\t}\n\n\tif (lockres->l_ops->flags & LOCK_TYPE_USES_LVB) {\n\t\tif (lockres->l_flags & OCFS2_LOCK_ATTACHED &&\n\t\t    lockres->l_level == DLM_LOCK_EX &&\n\t\t    !(lockres->l_flags & OCFS2_LOCK_NEEDS_REFRESH))\n\t\t\tlockres->l_ops->set_lvb(lockres);\n\t}\n\n\tif (lockres->l_flags & OCFS2_LOCK_BUSY)\n\t\tmlog(ML_ERROR, \"destroying busy lock: \\\"%s\\\"\\n\",\n\t\t     lockres->l_name);\n\tif (lockres->l_flags & OCFS2_LOCK_BLOCKED)\n\t\tmlog(0, \"destroying blocked lock: \\\"%s\\\"\\n\", lockres->l_name);\n\n\tif (!(lockres->l_flags & OCFS2_LOCK_ATTACHED)) {\n\t\tspin_unlock_irqrestore(&lockres->l_lock, flags);\n\t\tgoto out;\n\t}\n\n\tlockres_clear_flags(lockres, OCFS2_LOCK_ATTACHED);\n\n\t/* make sure we never get here while waiting for an ast to\n\t * fire. */\n\tBUG_ON(lockres->l_action != OCFS2_AST_INVALID);\n\n\t/* is this necessary? */\n\tlockres_or_flags(lockres, OCFS2_LOCK_BUSY);\n\tlockres->l_unlock_action = OCFS2_UNLOCK_DROP_LOCK;\n\tspin_unlock_irqrestore(&lockres->l_lock, flags);\n\n\tmlog(0, \"lock %s\\n\", lockres->l_name);\n\n\tret = ocfs2_dlm_unlock(osb->cconn, &lockres->l_lksb, lkm_flags);\n\tif (ret) {\n\t\tocfs2_log_dlm_error(\"ocfs2_dlm_unlock\", ret, lockres);\n\t\tmlog(ML_ERROR, \"lockres flags: %lu\\n\", lockres->l_flags);\n\t\tocfs2_dlm_dump_lksb(&lockres->l_lksb);\n\t\tBUG();\n\t}\n\tmlog(0, \"lock %s, successful return from ocfs2_dlm_unlock\\n\",\n\t     lockres->l_name);\n\n\tocfs2_wait_on_busy_lock(lockres);\nout:\n\treturn 0;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"refcounttree.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"stackglue.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dcache.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2_lockingver.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/time.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/kthread.h>",
            "#include <linux/mm.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [
            "#define LOCK_TYPE_USES_LVB\t\t0x2"
          ],
          "globals_used": [
            "static struct ocfs2_super *ocfs2_get_dentry_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_inode_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_file_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_qinfo_osb(struct ocfs2_lock_res *lockres);",
            "static void ocfs2_set_meta_lvb(struct ocfs2_lock_res *lockres);",
            "static void ocfs2_dentry_post_unlock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres);",
            "static void ocfs2_set_qinfo_lvb(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_downconvert_action(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_convert_action(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_attach_action(struct ocfs2_lock_res *lockres);",
            "static void ocfs2_schedule_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static void ocfs2_downconvert_on_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static void ocfs2_drop_osb_locks(struct ocfs2_super *osb);",
            "static int ocfs2_prepare_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\t        struct ocfs2_lock_res *lockres);",
            "static int ocfs2_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static void ocfs2_process_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *lockres);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"stackglue.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dcache.h\"\n#include \"alloc.h\"\n#include \"ocfs2_lockingver.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/quotaops.h>\n#include <linux/time.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/pagemap.h>\n#include <linux/kthread.h>\n#include <linux/mm.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\n#define LOCK_TYPE_USES_LVB\t\t0x2\n\nstatic struct ocfs2_super *ocfs2_get_dentry_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_inode_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_file_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_qinfo_osb(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_set_meta_lvb(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_dentry_post_unlock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres);\nstatic void ocfs2_set_qinfo_lvb(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_downconvert_action(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_convert_action(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_attach_action(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_schedule_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_downconvert_on_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_drop_osb_locks(struct ocfs2_super *osb);\nstatic int ocfs2_prepare_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\t        struct ocfs2_lock_res *lockres);\nstatic int ocfs2_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_process_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *lockres);\n\nstatic int ocfs2_drop_lock(struct ocfs2_super *osb,\n\t\t\t   struct ocfs2_lock_res *lockres)\n{\n\tint ret;\n\tunsigned long flags;\n\tu32 lkm_flags = 0;\n\n\t/* We didn't get anywhere near actually using this lockres. */\n\tif (!(lockres->l_flags & OCFS2_LOCK_INITIALIZED))\n\t\tgoto out;\n\n\tif (lockres->l_ops->flags & LOCK_TYPE_USES_LVB)\n\t\tlkm_flags |= DLM_LKF_VALBLK;\n\n\tspin_lock_irqsave(&lockres->l_lock, flags);\n\n\tmlog_bug_on_msg(!(lockres->l_flags & OCFS2_LOCK_FREEING),\n\t\t\t\"lockres %s, flags 0x%lx\\n\",\n\t\t\tlockres->l_name, lockres->l_flags);\n\n\twhile (lockres->l_flags & OCFS2_LOCK_BUSY) {\n\t\tmlog(0, \"waiting on busy lock \\\"%s\\\": flags = %lx, action = \"\n\t\t     \"%u, unlock_action = %u\\n\",\n\t\t     lockres->l_name, lockres->l_flags, lockres->l_action,\n\t\t     lockres->l_unlock_action);\n\n\t\tspin_unlock_irqrestore(&lockres->l_lock, flags);\n\n\t\t/* XXX: Today we just wait on any busy\n\t\t * locks... Perhaps we need to cancel converts in the\n\t\t * future? */\n\t\tocfs2_wait_on_busy_lock(lockres);\n\n\t\tspin_lock_irqsave(&lockres->l_lock, flags);\n\t}\n\n\tif (lockres->l_ops->flags & LOCK_TYPE_USES_LVB) {\n\t\tif (lockres->l_flags & OCFS2_LOCK_ATTACHED &&\n\t\t    lockres->l_level == DLM_LOCK_EX &&\n\t\t    !(lockres->l_flags & OCFS2_LOCK_NEEDS_REFRESH))\n\t\t\tlockres->l_ops->set_lvb(lockres);\n\t}\n\n\tif (lockres->l_flags & OCFS2_LOCK_BUSY)\n\t\tmlog(ML_ERROR, \"destroying busy lock: \\\"%s\\\"\\n\",\n\t\t     lockres->l_name);\n\tif (lockres->l_flags & OCFS2_LOCK_BLOCKED)\n\t\tmlog(0, \"destroying blocked lock: \\\"%s\\\"\\n\", lockres->l_name);\n\n\tif (!(lockres->l_flags & OCFS2_LOCK_ATTACHED)) {\n\t\tspin_unlock_irqrestore(&lockres->l_lock, flags);\n\t\tgoto out;\n\t}\n\n\tlockres_clear_flags(lockres, OCFS2_LOCK_ATTACHED);\n\n\t/* make sure we never get here while waiting for an ast to\n\t * fire. */\n\tBUG_ON(lockres->l_action != OCFS2_AST_INVALID);\n\n\t/* is this necessary? */\n\tlockres_or_flags(lockres, OCFS2_LOCK_BUSY);\n\tlockres->l_unlock_action = OCFS2_UNLOCK_DROP_LOCK;\n\tspin_unlock_irqrestore(&lockres->l_lock, flags);\n\n\tmlog(0, \"lock %s\\n\", lockres->l_name);\n\n\tret = ocfs2_dlm_unlock(osb->cconn, &lockres->l_lksb, lkm_flags);\n\tif (ret) {\n\t\tocfs2_log_dlm_error(\"ocfs2_dlm_unlock\", ret, lockres);\n\t\tmlog(ML_ERROR, \"lockres flags: %lu\\n\", lockres->l_flags);\n\t\tocfs2_dlm_dump_lksb(&lockres->l_lksb);\n\t\tBUG();\n\t}\n\tmlog(0, \"lock %s, successful return from ocfs2_dlm_unlock\\n\",\n\t     lockres->l_name);\n\n\tocfs2_wait_on_busy_lock(lockres);\nout:\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "OCFS2_I",
          "args": [
            "inode"
          ],
          "line": 3264
        },
        "resolved": true,
        "details": {
          "function_name": "OCFS2_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/inode.h",
          "lines": "118-121",
          "snippet": "static inline struct ocfs2_inode_info *OCFS2_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ocfs2_inode_info, vfs_inode);\n}",
          "includes": [
            "#include \"extent_map.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extent_map.h\"\n\nstatic inline struct ocfs2_inode_info *OCFS2_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ocfs2_inode_info, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "OCFS2_SB",
          "args": [
            "inode->i_sb"
          ],
          "line": 3263
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "err"
          ],
          "line": 3259
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "OCFS2_SB",
          "args": [
            "inode->i_sb"
          ],
          "line": 3256
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "err"
          ],
          "line": 3252
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "OCFS2_SB",
          "args": [
            "inode->i_sb"
          ],
          "line": 3249
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"stackglue.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dcache.h\"\n#include \"alloc.h\"\n#include \"ocfs2_lockingver.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/quotaops.h>\n#include <linux/time.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/pagemap.h>\n#include <linux/kthread.h>\n#include <linux/mm.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nint ocfs2_drop_inode_locks(struct inode *inode)\n{\n\tint status, err;\n\n\t/* No need to call ocfs2_mark_lockres_freeing here -\n\t * ocfs2_clear_inode has done it for us. */\n\n\terr = ocfs2_drop_lock(OCFS2_SB(inode->i_sb),\n\t\t\t      &OCFS2_I(inode)->ip_open_lockres);\n\tif (err < 0)\n\t\tmlog_errno(err);\n\n\tstatus = err;\n\n\terr = ocfs2_drop_lock(OCFS2_SB(inode->i_sb),\n\t\t\t      &OCFS2_I(inode)->ip_inode_lockres);\n\tif (err < 0)\n\t\tmlog_errno(err);\n\tif (err < 0 && !status)\n\t\tstatus = err;\n\n\terr = ocfs2_drop_lock(OCFS2_SB(inode->i_sb),\n\t\t\t      &OCFS2_I(inode)->ip_rw_lockres);\n\tif (err < 0)\n\t\tmlog_errno(err);\n\tif (err < 0 && !status)\n\t\tstatus = err;\n\n\treturn status;\n}"
  },
  {
    "function_name": "ocfs2_drop_osb_locks",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlmglue.c",
    "lines": "3234-3240",
    "snippet": "static void ocfs2_drop_osb_locks(struct ocfs2_super *osb)\n{\n\tocfs2_simple_drop_lockres(osb, &osb->osb_super_lockres);\n\tocfs2_simple_drop_lockres(osb, &osb->osb_rename_lockres);\n\tocfs2_simple_drop_lockres(osb, &osb->osb_nfs_sync_lockres);\n\tocfs2_simple_drop_lockres(osb, &osb->osb_orphan_scan.os_lockres);\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"refcounttree.h\"",
      "#include \"quota.h\"",
      "#include \"uptodate.h\"",
      "#include \"super.h\"",
      "#include \"slot_map.h\"",
      "#include \"stackglue.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"heartbeat.h\"",
      "#include \"file.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"dcache.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2_lockingver.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/time.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/kthread.h>",
      "#include <linux/mm.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void ocfs2_drop_osb_locks(struct ocfs2_super *osb);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ocfs2_simple_drop_lockres",
          "args": [
            "osb",
            "&osb->osb_orphan_scan.os_lockres"
          ],
          "line": 3239
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_simple_drop_lockres",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlmglue.c",
          "lines": "3223-3232",
          "snippet": "void ocfs2_simple_drop_lockres(struct ocfs2_super *osb,\n\t\t\t       struct ocfs2_lock_res *lockres)\n{\n\tint ret;\n\n\tocfs2_mark_lockres_freeing(osb, lockres);\n\tret = ocfs2_drop_lock(osb, lockres);\n\tif (ret)\n\t\tmlog_errno(ret);\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"refcounttree.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"stackglue.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dcache.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2_lockingver.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/time.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/kthread.h>",
            "#include <linux/mm.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct ocfs2_super *ocfs2_get_dentry_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_inode_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_file_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_qinfo_osb(struct ocfs2_lock_res *lockres);",
            "static void ocfs2_set_meta_lvb(struct ocfs2_lock_res *lockres);",
            "static void ocfs2_dentry_post_unlock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres);",
            "static void ocfs2_set_qinfo_lvb(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_downconvert_action(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_convert_action(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_attach_action(struct ocfs2_lock_res *lockres);",
            "static void ocfs2_schedule_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static void ocfs2_downconvert_on_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static void ocfs2_drop_osb_locks(struct ocfs2_super *osb);",
            "static int ocfs2_prepare_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\t        struct ocfs2_lock_res *lockres);",
            "static int ocfs2_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static void ocfs2_process_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *lockres);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"stackglue.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dcache.h\"\n#include \"alloc.h\"\n#include \"ocfs2_lockingver.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/quotaops.h>\n#include <linux/time.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/pagemap.h>\n#include <linux/kthread.h>\n#include <linux/mm.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic struct ocfs2_super *ocfs2_get_dentry_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_inode_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_file_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_qinfo_osb(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_set_meta_lvb(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_dentry_post_unlock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres);\nstatic void ocfs2_set_qinfo_lvb(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_downconvert_action(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_convert_action(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_attach_action(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_schedule_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_downconvert_on_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_drop_osb_locks(struct ocfs2_super *osb);\nstatic int ocfs2_prepare_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\t        struct ocfs2_lock_res *lockres);\nstatic int ocfs2_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_process_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *lockres);\n\nvoid ocfs2_simple_drop_lockres(struct ocfs2_super *osb,\n\t\t\t       struct ocfs2_lock_res *lockres)\n{\n\tint ret;\n\n\tocfs2_mark_lockres_freeing(osb, lockres);\n\tret = ocfs2_drop_lock(osb, lockres);\n\tif (ret)\n\t\tmlog_errno(ret);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"stackglue.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dcache.h\"\n#include \"alloc.h\"\n#include \"ocfs2_lockingver.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/quotaops.h>\n#include <linux/time.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/pagemap.h>\n#include <linux/kthread.h>\n#include <linux/mm.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic void ocfs2_drop_osb_locks(struct ocfs2_super *osb);\n\nstatic void ocfs2_drop_osb_locks(struct ocfs2_super *osb)\n{\n\tocfs2_simple_drop_lockres(osb, &osb->osb_super_lockres);\n\tocfs2_simple_drop_lockres(osb, &osb->osb_rename_lockres);\n\tocfs2_simple_drop_lockres(osb, &osb->osb_nfs_sync_lockres);\n\tocfs2_simple_drop_lockres(osb, &osb->osb_orphan_scan.os_lockres);\n}"
  },
  {
    "function_name": "ocfs2_simple_drop_lockres",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlmglue.c",
    "lines": "3223-3232",
    "snippet": "void ocfs2_simple_drop_lockres(struct ocfs2_super *osb,\n\t\t\t       struct ocfs2_lock_res *lockres)\n{\n\tint ret;\n\n\tocfs2_mark_lockres_freeing(osb, lockres);\n\tret = ocfs2_drop_lock(osb, lockres);\n\tif (ret)\n\t\tmlog_errno(ret);\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"refcounttree.h\"",
      "#include \"quota.h\"",
      "#include \"uptodate.h\"",
      "#include \"super.h\"",
      "#include \"slot_map.h\"",
      "#include \"stackglue.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"heartbeat.h\"",
      "#include \"file.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"dcache.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2_lockingver.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/time.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/kthread.h>",
      "#include <linux/mm.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct ocfs2_super *ocfs2_get_dentry_osb(struct ocfs2_lock_res *lockres);",
      "static struct ocfs2_super *ocfs2_get_inode_osb(struct ocfs2_lock_res *lockres);",
      "static struct ocfs2_super *ocfs2_get_file_osb(struct ocfs2_lock_res *lockres);",
      "static struct ocfs2_super *ocfs2_get_qinfo_osb(struct ocfs2_lock_res *lockres);",
      "static void ocfs2_set_meta_lvb(struct ocfs2_lock_res *lockres);",
      "static void ocfs2_dentry_post_unlock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres);",
      "static void ocfs2_set_qinfo_lvb(struct ocfs2_lock_res *lockres);",
      "static inline void ocfs2_generic_handle_downconvert_action(struct ocfs2_lock_res *lockres);",
      "static inline void ocfs2_generic_handle_convert_action(struct ocfs2_lock_res *lockres);",
      "static inline void ocfs2_generic_handle_attach_action(struct ocfs2_lock_res *lockres);",
      "static void ocfs2_schedule_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);",
      "static void ocfs2_downconvert_on_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);",
      "static void ocfs2_drop_osb_locks(struct ocfs2_super *osb);",
      "static int ocfs2_prepare_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\t        struct ocfs2_lock_res *lockres);",
      "static int ocfs2_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres);",
      "static void ocfs2_process_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *lockres);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 3231
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_drop_lock",
          "args": [
            "osb",
            "lockres"
          ],
          "line": 3229
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_drop_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlmglue.c",
          "lines": "3072-3152",
          "snippet": "static int ocfs2_drop_lock(struct ocfs2_super *osb,\n\t\t\t   struct ocfs2_lock_res *lockres)\n{\n\tint ret;\n\tunsigned long flags;\n\tu32 lkm_flags = 0;\n\n\t/* We didn't get anywhere near actually using this lockres. */\n\tif (!(lockres->l_flags & OCFS2_LOCK_INITIALIZED))\n\t\tgoto out;\n\n\tif (lockres->l_ops->flags & LOCK_TYPE_USES_LVB)\n\t\tlkm_flags |= DLM_LKF_VALBLK;\n\n\tspin_lock_irqsave(&lockres->l_lock, flags);\n\n\tmlog_bug_on_msg(!(lockres->l_flags & OCFS2_LOCK_FREEING),\n\t\t\t\"lockres %s, flags 0x%lx\\n\",\n\t\t\tlockres->l_name, lockres->l_flags);\n\n\twhile (lockres->l_flags & OCFS2_LOCK_BUSY) {\n\t\tmlog(0, \"waiting on busy lock \\\"%s\\\": flags = %lx, action = \"\n\t\t     \"%u, unlock_action = %u\\n\",\n\t\t     lockres->l_name, lockres->l_flags, lockres->l_action,\n\t\t     lockres->l_unlock_action);\n\n\t\tspin_unlock_irqrestore(&lockres->l_lock, flags);\n\n\t\t/* XXX: Today we just wait on any busy\n\t\t * locks... Perhaps we need to cancel converts in the\n\t\t * future? */\n\t\tocfs2_wait_on_busy_lock(lockres);\n\n\t\tspin_lock_irqsave(&lockres->l_lock, flags);\n\t}\n\n\tif (lockres->l_ops->flags & LOCK_TYPE_USES_LVB) {\n\t\tif (lockres->l_flags & OCFS2_LOCK_ATTACHED &&\n\t\t    lockres->l_level == DLM_LOCK_EX &&\n\t\t    !(lockres->l_flags & OCFS2_LOCK_NEEDS_REFRESH))\n\t\t\tlockres->l_ops->set_lvb(lockres);\n\t}\n\n\tif (lockres->l_flags & OCFS2_LOCK_BUSY)\n\t\tmlog(ML_ERROR, \"destroying busy lock: \\\"%s\\\"\\n\",\n\t\t     lockres->l_name);\n\tif (lockres->l_flags & OCFS2_LOCK_BLOCKED)\n\t\tmlog(0, \"destroying blocked lock: \\\"%s\\\"\\n\", lockres->l_name);\n\n\tif (!(lockres->l_flags & OCFS2_LOCK_ATTACHED)) {\n\t\tspin_unlock_irqrestore(&lockres->l_lock, flags);\n\t\tgoto out;\n\t}\n\n\tlockres_clear_flags(lockres, OCFS2_LOCK_ATTACHED);\n\n\t/* make sure we never get here while waiting for an ast to\n\t * fire. */\n\tBUG_ON(lockres->l_action != OCFS2_AST_INVALID);\n\n\t/* is this necessary? */\n\tlockres_or_flags(lockres, OCFS2_LOCK_BUSY);\n\tlockres->l_unlock_action = OCFS2_UNLOCK_DROP_LOCK;\n\tspin_unlock_irqrestore(&lockres->l_lock, flags);\n\n\tmlog(0, \"lock %s\\n\", lockres->l_name);\n\n\tret = ocfs2_dlm_unlock(osb->cconn, &lockres->l_lksb, lkm_flags);\n\tif (ret) {\n\t\tocfs2_log_dlm_error(\"ocfs2_dlm_unlock\", ret, lockres);\n\t\tmlog(ML_ERROR, \"lockres flags: %lu\\n\", lockres->l_flags);\n\t\tocfs2_dlm_dump_lksb(&lockres->l_lksb);\n\t\tBUG();\n\t}\n\tmlog(0, \"lock %s, successful return from ocfs2_dlm_unlock\\n\",\n\t     lockres->l_name);\n\n\tocfs2_wait_on_busy_lock(lockres);\nout:\n\treturn 0;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"refcounttree.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"stackglue.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dcache.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2_lockingver.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/time.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/kthread.h>",
            "#include <linux/mm.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [
            "#define LOCK_TYPE_USES_LVB\t\t0x2"
          ],
          "globals_used": [
            "static struct ocfs2_super *ocfs2_get_dentry_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_inode_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_file_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_qinfo_osb(struct ocfs2_lock_res *lockres);",
            "static void ocfs2_set_meta_lvb(struct ocfs2_lock_res *lockres);",
            "static void ocfs2_dentry_post_unlock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres);",
            "static void ocfs2_set_qinfo_lvb(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_downconvert_action(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_convert_action(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_attach_action(struct ocfs2_lock_res *lockres);",
            "static void ocfs2_schedule_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static void ocfs2_downconvert_on_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static void ocfs2_drop_osb_locks(struct ocfs2_super *osb);",
            "static int ocfs2_prepare_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\t        struct ocfs2_lock_res *lockres);",
            "static int ocfs2_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static void ocfs2_process_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *lockres);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"stackglue.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dcache.h\"\n#include \"alloc.h\"\n#include \"ocfs2_lockingver.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/quotaops.h>\n#include <linux/time.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/pagemap.h>\n#include <linux/kthread.h>\n#include <linux/mm.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\n#define LOCK_TYPE_USES_LVB\t\t0x2\n\nstatic struct ocfs2_super *ocfs2_get_dentry_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_inode_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_file_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_qinfo_osb(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_set_meta_lvb(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_dentry_post_unlock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres);\nstatic void ocfs2_set_qinfo_lvb(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_downconvert_action(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_convert_action(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_attach_action(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_schedule_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_downconvert_on_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_drop_osb_locks(struct ocfs2_super *osb);\nstatic int ocfs2_prepare_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\t        struct ocfs2_lock_res *lockres);\nstatic int ocfs2_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_process_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *lockres);\n\nstatic int ocfs2_drop_lock(struct ocfs2_super *osb,\n\t\t\t   struct ocfs2_lock_res *lockres)\n{\n\tint ret;\n\tunsigned long flags;\n\tu32 lkm_flags = 0;\n\n\t/* We didn't get anywhere near actually using this lockres. */\n\tif (!(lockres->l_flags & OCFS2_LOCK_INITIALIZED))\n\t\tgoto out;\n\n\tif (lockres->l_ops->flags & LOCK_TYPE_USES_LVB)\n\t\tlkm_flags |= DLM_LKF_VALBLK;\n\n\tspin_lock_irqsave(&lockres->l_lock, flags);\n\n\tmlog_bug_on_msg(!(lockres->l_flags & OCFS2_LOCK_FREEING),\n\t\t\t\"lockres %s, flags 0x%lx\\n\",\n\t\t\tlockres->l_name, lockres->l_flags);\n\n\twhile (lockres->l_flags & OCFS2_LOCK_BUSY) {\n\t\tmlog(0, \"waiting on busy lock \\\"%s\\\": flags = %lx, action = \"\n\t\t     \"%u, unlock_action = %u\\n\",\n\t\t     lockres->l_name, lockres->l_flags, lockres->l_action,\n\t\t     lockres->l_unlock_action);\n\n\t\tspin_unlock_irqrestore(&lockres->l_lock, flags);\n\n\t\t/* XXX: Today we just wait on any busy\n\t\t * locks... Perhaps we need to cancel converts in the\n\t\t * future? */\n\t\tocfs2_wait_on_busy_lock(lockres);\n\n\t\tspin_lock_irqsave(&lockres->l_lock, flags);\n\t}\n\n\tif (lockres->l_ops->flags & LOCK_TYPE_USES_LVB) {\n\t\tif (lockres->l_flags & OCFS2_LOCK_ATTACHED &&\n\t\t    lockres->l_level == DLM_LOCK_EX &&\n\t\t    !(lockres->l_flags & OCFS2_LOCK_NEEDS_REFRESH))\n\t\t\tlockres->l_ops->set_lvb(lockres);\n\t}\n\n\tif (lockres->l_flags & OCFS2_LOCK_BUSY)\n\t\tmlog(ML_ERROR, \"destroying busy lock: \\\"%s\\\"\\n\",\n\t\t     lockres->l_name);\n\tif (lockres->l_flags & OCFS2_LOCK_BLOCKED)\n\t\tmlog(0, \"destroying blocked lock: \\\"%s\\\"\\n\", lockres->l_name);\n\n\tif (!(lockres->l_flags & OCFS2_LOCK_ATTACHED)) {\n\t\tspin_unlock_irqrestore(&lockres->l_lock, flags);\n\t\tgoto out;\n\t}\n\n\tlockres_clear_flags(lockres, OCFS2_LOCK_ATTACHED);\n\n\t/* make sure we never get here while waiting for an ast to\n\t * fire. */\n\tBUG_ON(lockres->l_action != OCFS2_AST_INVALID);\n\n\t/* is this necessary? */\n\tlockres_or_flags(lockres, OCFS2_LOCK_BUSY);\n\tlockres->l_unlock_action = OCFS2_UNLOCK_DROP_LOCK;\n\tspin_unlock_irqrestore(&lockres->l_lock, flags);\n\n\tmlog(0, \"lock %s\\n\", lockres->l_name);\n\n\tret = ocfs2_dlm_unlock(osb->cconn, &lockres->l_lksb, lkm_flags);\n\tif (ret) {\n\t\tocfs2_log_dlm_error(\"ocfs2_dlm_unlock\", ret, lockres);\n\t\tmlog(ML_ERROR, \"lockres flags: %lu\\n\", lockres->l_flags);\n\t\tocfs2_dlm_dump_lksb(&lockres->l_lksb);\n\t\tBUG();\n\t}\n\tmlog(0, \"lock %s, successful return from ocfs2_dlm_unlock\\n\",\n\t     lockres->l_name);\n\n\tocfs2_wait_on_busy_lock(lockres);\nout:\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_mark_lockres_freeing",
          "args": [
            "osb",
            "lockres"
          ],
          "line": 3228
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_mark_lockres_freeing",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlmglue.c",
          "lines": "3163-3221",
          "snippet": "void ocfs2_mark_lockres_freeing(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres)\n{\n\tint status;\n\tstruct ocfs2_mask_waiter mw;\n\tunsigned long flags, flags2;\n\n\tocfs2_init_mask_waiter(&mw);\n\n\tspin_lock_irqsave(&lockres->l_lock, flags);\n\tlockres->l_flags |= OCFS2_LOCK_FREEING;\n\tif (lockres->l_flags & OCFS2_LOCK_QUEUED && current == osb->dc_task) {\n\t\t/*\n\t\t * We know the downconvert is queued but not in progress\n\t\t * because we are the downconvert thread and processing\n\t\t * different lock. So we can just remove the lock from the\n\t\t * queue. This is not only an optimization but also a way\n\t\t * to avoid the following deadlock:\n\t\t *   ocfs2_dentry_post_unlock()\n\t\t *     ocfs2_dentry_lock_put()\n\t\t *       ocfs2_drop_dentry_lock()\n\t\t *         iput()\n\t\t *           ocfs2_evict_inode()\n\t\t *             ocfs2_clear_inode()\n\t\t *               ocfs2_mark_lockres_freeing()\n\t\t *                 ... blocks waiting for OCFS2_LOCK_QUEUED\n\t\t *                 since we are the downconvert thread which\n\t\t *                 should clear the flag.\n\t\t */\n\t\tspin_unlock_irqrestore(&lockres->l_lock, flags);\n\t\tspin_lock_irqsave(&osb->dc_task_lock, flags2);\n\t\tlist_del_init(&lockres->l_blocked_list);\n\t\tosb->blocked_lock_count--;\n\t\tspin_unlock_irqrestore(&osb->dc_task_lock, flags2);\n\t\t/*\n\t\t * Warn if we recurse into another post_unlock call.  Strictly\n\t\t * speaking it isn't a problem but we need to be careful if\n\t\t * that happens (stack overflow, deadlocks, ...) so warn if\n\t\t * ocfs2 grows a path for which this can happen.\n\t\t */\n\t\tWARN_ON_ONCE(lockres->l_ops->post_unlock);\n\t\t/* Since the lock is freeing we don't do much in the fn below */\n\t\tocfs2_process_blocked_lock(osb, lockres);\n\t\treturn;\n\t}\n\twhile (lockres->l_flags & OCFS2_LOCK_QUEUED) {\n\t\tlockres_add_mask_waiter(lockres, &mw, OCFS2_LOCK_QUEUED, 0);\n\t\tspin_unlock_irqrestore(&lockres->l_lock, flags);\n\n\t\tmlog(0, \"Waiting on lockres %s\\n\", lockres->l_name);\n\n\t\tstatus = ocfs2_wait_for_mask(&mw);\n\t\tif (status)\n\t\t\tmlog_errno(status);\n\n\t\tspin_lock_irqsave(&lockres->l_lock, flags);\n\t}\n\tspin_unlock_irqrestore(&lockres->l_lock, flags);\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"refcounttree.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"stackglue.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dcache.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2_lockingver.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/time.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/kthread.h>",
            "#include <linux/mm.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct ocfs2_super *ocfs2_get_dentry_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_inode_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_file_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_qinfo_osb(struct ocfs2_lock_res *lockres);",
            "static void ocfs2_set_meta_lvb(struct ocfs2_lock_res *lockres);",
            "static void ocfs2_dentry_post_unlock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres);",
            "static void ocfs2_set_qinfo_lvb(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_downconvert_action(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_convert_action(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_attach_action(struct ocfs2_lock_res *lockres);",
            "static void ocfs2_schedule_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static void ocfs2_downconvert_on_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static void ocfs2_drop_osb_locks(struct ocfs2_super *osb);",
            "static int ocfs2_prepare_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\t        struct ocfs2_lock_res *lockres);",
            "static int ocfs2_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static void ocfs2_process_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *lockres);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"stackglue.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dcache.h\"\n#include \"alloc.h\"\n#include \"ocfs2_lockingver.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/quotaops.h>\n#include <linux/time.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/pagemap.h>\n#include <linux/kthread.h>\n#include <linux/mm.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic struct ocfs2_super *ocfs2_get_dentry_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_inode_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_file_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_qinfo_osb(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_set_meta_lvb(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_dentry_post_unlock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres);\nstatic void ocfs2_set_qinfo_lvb(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_downconvert_action(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_convert_action(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_attach_action(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_schedule_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_downconvert_on_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_drop_osb_locks(struct ocfs2_super *osb);\nstatic int ocfs2_prepare_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\t        struct ocfs2_lock_res *lockres);\nstatic int ocfs2_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_process_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *lockres);\n\nvoid ocfs2_mark_lockres_freeing(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres)\n{\n\tint status;\n\tstruct ocfs2_mask_waiter mw;\n\tunsigned long flags, flags2;\n\n\tocfs2_init_mask_waiter(&mw);\n\n\tspin_lock_irqsave(&lockres->l_lock, flags);\n\tlockres->l_flags |= OCFS2_LOCK_FREEING;\n\tif (lockres->l_flags & OCFS2_LOCK_QUEUED && current == osb->dc_task) {\n\t\t/*\n\t\t * We know the downconvert is queued but not in progress\n\t\t * because we are the downconvert thread and processing\n\t\t * different lock. So we can just remove the lock from the\n\t\t * queue. This is not only an optimization but also a way\n\t\t * to avoid the following deadlock:\n\t\t *   ocfs2_dentry_post_unlock()\n\t\t *     ocfs2_dentry_lock_put()\n\t\t *       ocfs2_drop_dentry_lock()\n\t\t *         iput()\n\t\t *           ocfs2_evict_inode()\n\t\t *             ocfs2_clear_inode()\n\t\t *               ocfs2_mark_lockres_freeing()\n\t\t *                 ... blocks waiting for OCFS2_LOCK_QUEUED\n\t\t *                 since we are the downconvert thread which\n\t\t *                 should clear the flag.\n\t\t */\n\t\tspin_unlock_irqrestore(&lockres->l_lock, flags);\n\t\tspin_lock_irqsave(&osb->dc_task_lock, flags2);\n\t\tlist_del_init(&lockres->l_blocked_list);\n\t\tosb->blocked_lock_count--;\n\t\tspin_unlock_irqrestore(&osb->dc_task_lock, flags2);\n\t\t/*\n\t\t * Warn if we recurse into another post_unlock call.  Strictly\n\t\t * speaking it isn't a problem but we need to be careful if\n\t\t * that happens (stack overflow, deadlocks, ...) so warn if\n\t\t * ocfs2 grows a path for which this can happen.\n\t\t */\n\t\tWARN_ON_ONCE(lockres->l_ops->post_unlock);\n\t\t/* Since the lock is freeing we don't do much in the fn below */\n\t\tocfs2_process_blocked_lock(osb, lockres);\n\t\treturn;\n\t}\n\twhile (lockres->l_flags & OCFS2_LOCK_QUEUED) {\n\t\tlockres_add_mask_waiter(lockres, &mw, OCFS2_LOCK_QUEUED, 0);\n\t\tspin_unlock_irqrestore(&lockres->l_lock, flags);\n\n\t\tmlog(0, \"Waiting on lockres %s\\n\", lockres->l_name);\n\n\t\tstatus = ocfs2_wait_for_mask(&mw);\n\t\tif (status)\n\t\t\tmlog_errno(status);\n\n\t\tspin_lock_irqsave(&lockres->l_lock, flags);\n\t}\n\tspin_unlock_irqrestore(&lockres->l_lock, flags);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"stackglue.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dcache.h\"\n#include \"alloc.h\"\n#include \"ocfs2_lockingver.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/quotaops.h>\n#include <linux/time.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/pagemap.h>\n#include <linux/kthread.h>\n#include <linux/mm.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic struct ocfs2_super *ocfs2_get_dentry_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_inode_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_file_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_qinfo_osb(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_set_meta_lvb(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_dentry_post_unlock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres);\nstatic void ocfs2_set_qinfo_lvb(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_downconvert_action(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_convert_action(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_attach_action(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_schedule_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_downconvert_on_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_drop_osb_locks(struct ocfs2_super *osb);\nstatic int ocfs2_prepare_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\t        struct ocfs2_lock_res *lockres);\nstatic int ocfs2_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_process_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *lockres);\n\nvoid ocfs2_simple_drop_lockres(struct ocfs2_super *osb,\n\t\t\t       struct ocfs2_lock_res *lockres)\n{\n\tint ret;\n\n\tocfs2_mark_lockres_freeing(osb, lockres);\n\tret = ocfs2_drop_lock(osb, lockres);\n\tif (ret)\n\t\tmlog_errno(ret);\n}"
  },
  {
    "function_name": "ocfs2_mark_lockres_freeing",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlmglue.c",
    "lines": "3163-3221",
    "snippet": "void ocfs2_mark_lockres_freeing(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres)\n{\n\tint status;\n\tstruct ocfs2_mask_waiter mw;\n\tunsigned long flags, flags2;\n\n\tocfs2_init_mask_waiter(&mw);\n\n\tspin_lock_irqsave(&lockres->l_lock, flags);\n\tlockres->l_flags |= OCFS2_LOCK_FREEING;\n\tif (lockres->l_flags & OCFS2_LOCK_QUEUED && current == osb->dc_task) {\n\t\t/*\n\t\t * We know the downconvert is queued but not in progress\n\t\t * because we are the downconvert thread and processing\n\t\t * different lock. So we can just remove the lock from the\n\t\t * queue. This is not only an optimization but also a way\n\t\t * to avoid the following deadlock:\n\t\t *   ocfs2_dentry_post_unlock()\n\t\t *     ocfs2_dentry_lock_put()\n\t\t *       ocfs2_drop_dentry_lock()\n\t\t *         iput()\n\t\t *           ocfs2_evict_inode()\n\t\t *             ocfs2_clear_inode()\n\t\t *               ocfs2_mark_lockres_freeing()\n\t\t *                 ... blocks waiting for OCFS2_LOCK_QUEUED\n\t\t *                 since we are the downconvert thread which\n\t\t *                 should clear the flag.\n\t\t */\n\t\tspin_unlock_irqrestore(&lockres->l_lock, flags);\n\t\tspin_lock_irqsave(&osb->dc_task_lock, flags2);\n\t\tlist_del_init(&lockres->l_blocked_list);\n\t\tosb->blocked_lock_count--;\n\t\tspin_unlock_irqrestore(&osb->dc_task_lock, flags2);\n\t\t/*\n\t\t * Warn if we recurse into another post_unlock call.  Strictly\n\t\t * speaking it isn't a problem but we need to be careful if\n\t\t * that happens (stack overflow, deadlocks, ...) so warn if\n\t\t * ocfs2 grows a path for which this can happen.\n\t\t */\n\t\tWARN_ON_ONCE(lockres->l_ops->post_unlock);\n\t\t/* Since the lock is freeing we don't do much in the fn below */\n\t\tocfs2_process_blocked_lock(osb, lockres);\n\t\treturn;\n\t}\n\twhile (lockres->l_flags & OCFS2_LOCK_QUEUED) {\n\t\tlockres_add_mask_waiter(lockres, &mw, OCFS2_LOCK_QUEUED, 0);\n\t\tspin_unlock_irqrestore(&lockres->l_lock, flags);\n\n\t\tmlog(0, \"Waiting on lockres %s\\n\", lockres->l_name);\n\n\t\tstatus = ocfs2_wait_for_mask(&mw);\n\t\tif (status)\n\t\t\tmlog_errno(status);\n\n\t\tspin_lock_irqsave(&lockres->l_lock, flags);\n\t}\n\tspin_unlock_irqrestore(&lockres->l_lock, flags);\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"refcounttree.h\"",
      "#include \"quota.h\"",
      "#include \"uptodate.h\"",
      "#include \"super.h\"",
      "#include \"slot_map.h\"",
      "#include \"stackglue.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"heartbeat.h\"",
      "#include \"file.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"dcache.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2_lockingver.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/time.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/kthread.h>",
      "#include <linux/mm.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct ocfs2_super *ocfs2_get_dentry_osb(struct ocfs2_lock_res *lockres);",
      "static struct ocfs2_super *ocfs2_get_inode_osb(struct ocfs2_lock_res *lockres);",
      "static struct ocfs2_super *ocfs2_get_file_osb(struct ocfs2_lock_res *lockres);",
      "static struct ocfs2_super *ocfs2_get_qinfo_osb(struct ocfs2_lock_res *lockres);",
      "static void ocfs2_set_meta_lvb(struct ocfs2_lock_res *lockres);",
      "static void ocfs2_dentry_post_unlock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres);",
      "static void ocfs2_set_qinfo_lvb(struct ocfs2_lock_res *lockres);",
      "static inline void ocfs2_generic_handle_downconvert_action(struct ocfs2_lock_res *lockres);",
      "static inline void ocfs2_generic_handle_convert_action(struct ocfs2_lock_res *lockres);",
      "static inline void ocfs2_generic_handle_attach_action(struct ocfs2_lock_res *lockres);",
      "static void ocfs2_schedule_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);",
      "static void ocfs2_downconvert_on_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);",
      "static void ocfs2_drop_osb_locks(struct ocfs2_super *osb);",
      "static int ocfs2_prepare_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\t        struct ocfs2_lock_res *lockres);",
      "static int ocfs2_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres);",
      "static void ocfs2_process_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *lockres);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock_irqrestore",
          "args": [
            "&lockres->l_lock",
            "flags"
          ],
          "line": 3220
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock_irqsave",
          "args": [
            "&lockres->l_lock",
            "flags"
          ],
          "line": 3218
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "status"
          ],
          "line": 3216
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_wait_for_mask",
          "args": [
            "&mw"
          ],
          "line": 3214
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_wait_for_mask",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlmglue.c",
          "lines": "1308-1314",
          "snippet": "static int ocfs2_wait_for_mask(struct ocfs2_mask_waiter *mw)\n{\n\twait_for_completion(&mw->mw_complete);\n\t/* Re-arm the completion in case we want to wait on it again */\n\treinit_completion(&mw->mw_complete);\n\treturn mw->mw_status;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"refcounttree.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"stackglue.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dcache.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2_lockingver.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/time.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/kthread.h>",
            "#include <linux/mm.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"stackglue.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dcache.h\"\n#include \"alloc.h\"\n#include \"ocfs2_lockingver.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/quotaops.h>\n#include <linux/time.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/pagemap.h>\n#include <linux/kthread.h>\n#include <linux/mm.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic int ocfs2_wait_for_mask(struct ocfs2_mask_waiter *mw)\n{\n\twait_for_completion(&mw->mw_complete);\n\t/* Re-arm the completion in case we want to wait on it again */\n\treinit_completion(&mw->mw_complete);\n\treturn mw->mw_status;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog",
          "args": [
            "0",
            "\"Waiting on lockres %s\\n\"",
            "lockres->l_name"
          ],
          "line": 3212
        },
        "resolved": true,
        "details": {
          "function_name": "mlog_show",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/cluster/masklog.c",
          "lines": "107-113",
          "snippet": "static ssize_t mlog_show(struct kobject *obj, struct attribute *attr,\n\t\t\t char *buf)\n{\n\tstruct mlog_attribute *mlog_attr = to_mlog_attr(attr);\n\n\treturn mlog_mask_show(mlog_attr->mask, buf);\n}",
          "includes": [
            "#include \"masklog.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/string.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"masklog.h\"\n#include <asm/uaccess.h>\n#include <linux/string.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n\nstatic ssize_t mlog_show(struct kobject *obj, struct attribute *attr,\n\t\t\t char *buf)\n{\n\tstruct mlog_attribute *mlog_attr = to_mlog_attr(attr);\n\n\treturn mlog_mask_show(mlog_attr->mask, buf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock_irqrestore",
          "args": [
            "&lockres->l_lock",
            "flags"
          ],
          "line": 3210
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lockres_add_mask_waiter",
          "args": [
            "lockres",
            "&mw",
            "OCFS2_LOCK_QUEUED",
            "0"
          ],
          "line": 3209
        },
        "resolved": true,
        "details": {
          "function_name": "lockres_add_mask_waiter",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlmglue.c",
          "lines": "1316-1328",
          "snippet": "static void lockres_add_mask_waiter(struct ocfs2_lock_res *lockres,\n\t\t\t\t    struct ocfs2_mask_waiter *mw,\n\t\t\t\t    unsigned long mask,\n\t\t\t\t    unsigned long goal)\n{\n\tBUG_ON(!list_empty(&mw->mw_item));\n\n\tassert_spin_locked(&lockres->l_lock);\n\n\tlist_add_tail(&mw->mw_item, &lockres->l_mask_waiters);\n\tmw->mw_mask = mask;\n\tmw->mw_goal = goal;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"refcounttree.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"stackglue.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dcache.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2_lockingver.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/time.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/kthread.h>",
            "#include <linux/mm.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct ocfs2_super *ocfs2_get_dentry_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_inode_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_file_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_qinfo_osb(struct ocfs2_lock_res *lockres);",
            "static void ocfs2_set_meta_lvb(struct ocfs2_lock_res *lockres);",
            "static void ocfs2_dentry_post_unlock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres);",
            "static void ocfs2_set_qinfo_lvb(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_downconvert_action(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_convert_action(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_attach_action(struct ocfs2_lock_res *lockres);",
            "static void ocfs2_schedule_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static void ocfs2_downconvert_on_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static int ocfs2_prepare_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\t        struct ocfs2_lock_res *lockres);",
            "static int ocfs2_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static void ocfs2_process_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *lockres);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"stackglue.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dcache.h\"\n#include \"alloc.h\"\n#include \"ocfs2_lockingver.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/quotaops.h>\n#include <linux/time.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/pagemap.h>\n#include <linux/kthread.h>\n#include <linux/mm.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic struct ocfs2_super *ocfs2_get_dentry_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_inode_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_file_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_qinfo_osb(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_set_meta_lvb(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_dentry_post_unlock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres);\nstatic void ocfs2_set_qinfo_lvb(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_downconvert_action(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_convert_action(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_attach_action(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_schedule_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_downconvert_on_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic int ocfs2_prepare_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\t        struct ocfs2_lock_res *lockres);\nstatic int ocfs2_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_process_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *lockres);\n\nstatic void lockres_add_mask_waiter(struct ocfs2_lock_res *lockres,\n\t\t\t\t    struct ocfs2_mask_waiter *mw,\n\t\t\t\t    unsigned long mask,\n\t\t\t\t    unsigned long goal)\n{\n\tBUG_ON(!list_empty(&mw->mw_item));\n\n\tassert_spin_locked(&lockres->l_lock);\n\n\tlist_add_tail(&mw->mw_item, &lockres->l_mask_waiters);\n\tmw->mw_mask = mask;\n\tmw->mw_goal = goal;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_process_blocked_lock",
          "args": [
            "osb",
            "lockres"
          ],
          "line": 3205
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_process_blocked_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlmglue.c",
          "lines": "3938-3982",
          "snippet": "static void ocfs2_process_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *lockres)\n{\n\tint status;\n\tstruct ocfs2_unblock_ctl ctl = {0, 0,};\n\tunsigned long flags;\n\n\t/* Our reference to the lockres in this function can be\n\t * considered valid until we remove the OCFS2_LOCK_QUEUED\n\t * flag. */\n\n\tBUG_ON(!lockres);\n\tBUG_ON(!lockres->l_ops);\n\n\tmlog(ML_BASTS, \"lockres %s blocked\\n\", lockres->l_name);\n\n\t/* Detect whether a lock has been marked as going away while\n\t * the downconvert thread was processing other things. A lock can\n\t * still be marked with OCFS2_LOCK_FREEING after this check,\n\t * but short circuiting here will still save us some\n\t * performance. */\n\tspin_lock_irqsave(&lockres->l_lock, flags);\n\tif (lockres->l_flags & OCFS2_LOCK_FREEING)\n\t\tgoto unqueue;\n\tspin_unlock_irqrestore(&lockres->l_lock, flags);\n\n\tstatus = ocfs2_unblock_lock(osb, lockres, &ctl);\n\tif (status < 0)\n\t\tmlog_errno(status);\n\n\tspin_lock_irqsave(&lockres->l_lock, flags);\nunqueue:\n\tif (lockres->l_flags & OCFS2_LOCK_FREEING || !ctl.requeue) {\n\t\tlockres_clear_flags(lockres, OCFS2_LOCK_QUEUED);\n\t} else\n\t\tocfs2_schedule_blocked_lock(osb, lockres);\n\n\tmlog(ML_BASTS, \"lockres %s, requeue = %s.\\n\", lockres->l_name,\n\t     ctl.requeue ? \"yes\" : \"no\");\n\tspin_unlock_irqrestore(&lockres->l_lock, flags);\n\n\tif (ctl.unblock_action != UNBLOCK_CONTINUE\n\t    && lockres->l_ops->post_unlock)\n\t\tlockres->l_ops->post_unlock(osb, lockres);\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"refcounttree.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"stackglue.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dcache.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2_lockingver.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/time.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/kthread.h>",
            "#include <linux/mm.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct ocfs2_super *ocfs2_get_dentry_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_inode_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_file_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_qinfo_osb(struct ocfs2_lock_res *lockres);",
            "static void ocfs2_set_meta_lvb(struct ocfs2_lock_res *lockres);",
            "static void ocfs2_dentry_post_unlock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres);",
            "static void ocfs2_set_qinfo_lvb(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_downconvert_action(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_convert_action(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_attach_action(struct ocfs2_lock_res *lockres);",
            "static void ocfs2_schedule_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static void ocfs2_downconvert_on_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static void ocfs2_drop_osb_locks(struct ocfs2_super *osb);",
            "static int ocfs2_prepare_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\t        struct ocfs2_lock_res *lockres);",
            "static int ocfs2_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static void ocfs2_process_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *lockres);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"stackglue.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dcache.h\"\n#include \"alloc.h\"\n#include \"ocfs2_lockingver.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/quotaops.h>\n#include <linux/time.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/pagemap.h>\n#include <linux/kthread.h>\n#include <linux/mm.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic struct ocfs2_super *ocfs2_get_dentry_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_inode_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_file_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_qinfo_osb(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_set_meta_lvb(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_dentry_post_unlock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres);\nstatic void ocfs2_set_qinfo_lvb(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_downconvert_action(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_convert_action(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_attach_action(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_schedule_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_downconvert_on_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_drop_osb_locks(struct ocfs2_super *osb);\nstatic int ocfs2_prepare_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\t        struct ocfs2_lock_res *lockres);\nstatic int ocfs2_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_process_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *lockres);\n\nstatic void ocfs2_process_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *lockres)\n{\n\tint status;\n\tstruct ocfs2_unblock_ctl ctl = {0, 0,};\n\tunsigned long flags;\n\n\t/* Our reference to the lockres in this function can be\n\t * considered valid until we remove the OCFS2_LOCK_QUEUED\n\t * flag. */\n\n\tBUG_ON(!lockres);\n\tBUG_ON(!lockres->l_ops);\n\n\tmlog(ML_BASTS, \"lockres %s blocked\\n\", lockres->l_name);\n\n\t/* Detect whether a lock has been marked as going away while\n\t * the downconvert thread was processing other things. A lock can\n\t * still be marked with OCFS2_LOCK_FREEING after this check,\n\t * but short circuiting here will still save us some\n\t * performance. */\n\tspin_lock_irqsave(&lockres->l_lock, flags);\n\tif (lockres->l_flags & OCFS2_LOCK_FREEING)\n\t\tgoto unqueue;\n\tspin_unlock_irqrestore(&lockres->l_lock, flags);\n\n\tstatus = ocfs2_unblock_lock(osb, lockres, &ctl);\n\tif (status < 0)\n\t\tmlog_errno(status);\n\n\tspin_lock_irqsave(&lockres->l_lock, flags);\nunqueue:\n\tif (lockres->l_flags & OCFS2_LOCK_FREEING || !ctl.requeue) {\n\t\tlockres_clear_flags(lockres, OCFS2_LOCK_QUEUED);\n\t} else\n\t\tocfs2_schedule_blocked_lock(osb, lockres);\n\n\tmlog(ML_BASTS, \"lockres %s, requeue = %s.\\n\", lockres->l_name,\n\t     ctl.requeue ? \"yes\" : \"no\");\n\tspin_unlock_irqrestore(&lockres->l_lock, flags);\n\n\tif (ctl.unblock_action != UNBLOCK_CONTINUE\n\t    && lockres->l_ops->post_unlock)\n\t\tlockres->l_ops->post_unlock(osb, lockres);\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "lockres->l_ops->post_unlock"
          ],
          "line": 3203
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock_irqrestore",
          "args": [
            "&osb->dc_task_lock",
            "flags2"
          ],
          "line": 3196
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_del_init",
          "args": [
            "&lockres->l_blocked_list"
          ],
          "line": 3194
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock_irqsave",
          "args": [
            "&osb->dc_task_lock",
            "flags2"
          ],
          "line": 3193
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock_irqrestore",
          "args": [
            "&lockres->l_lock",
            "flags"
          ],
          "line": 3192
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock_irqsave",
          "args": [
            "&lockres->l_lock",
            "flags"
          ],
          "line": 3172
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_init_mask_waiter",
          "args": [
            "&mw"
          ],
          "line": 3170
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_init_mask_waiter",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlmglue.c",
          "lines": "1301-1306",
          "snippet": "static void ocfs2_init_mask_waiter(struct ocfs2_mask_waiter *mw)\n{\n\tINIT_LIST_HEAD(&mw->mw_item);\n\tinit_completion(&mw->mw_complete);\n\tocfs2_init_start_time(mw);\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"refcounttree.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"stackglue.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dcache.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2_lockingver.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/time.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/kthread.h>",
            "#include <linux/mm.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"stackglue.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dcache.h\"\n#include \"alloc.h\"\n#include \"ocfs2_lockingver.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/quotaops.h>\n#include <linux/time.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/pagemap.h>\n#include <linux/kthread.h>\n#include <linux/mm.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic void ocfs2_init_mask_waiter(struct ocfs2_mask_waiter *mw)\n{\n\tINIT_LIST_HEAD(&mw->mw_item);\n\tinit_completion(&mw->mw_complete);\n\tocfs2_init_start_time(mw);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"stackglue.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dcache.h\"\n#include \"alloc.h\"\n#include \"ocfs2_lockingver.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/quotaops.h>\n#include <linux/time.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/pagemap.h>\n#include <linux/kthread.h>\n#include <linux/mm.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic struct ocfs2_super *ocfs2_get_dentry_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_inode_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_file_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_qinfo_osb(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_set_meta_lvb(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_dentry_post_unlock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres);\nstatic void ocfs2_set_qinfo_lvb(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_downconvert_action(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_convert_action(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_attach_action(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_schedule_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_downconvert_on_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_drop_osb_locks(struct ocfs2_super *osb);\nstatic int ocfs2_prepare_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\t        struct ocfs2_lock_res *lockres);\nstatic int ocfs2_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_process_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *lockres);\n\nvoid ocfs2_mark_lockres_freeing(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres)\n{\n\tint status;\n\tstruct ocfs2_mask_waiter mw;\n\tunsigned long flags, flags2;\n\n\tocfs2_init_mask_waiter(&mw);\n\n\tspin_lock_irqsave(&lockres->l_lock, flags);\n\tlockres->l_flags |= OCFS2_LOCK_FREEING;\n\tif (lockres->l_flags & OCFS2_LOCK_QUEUED && current == osb->dc_task) {\n\t\t/*\n\t\t * We know the downconvert is queued but not in progress\n\t\t * because we are the downconvert thread and processing\n\t\t * different lock. So we can just remove the lock from the\n\t\t * queue. This is not only an optimization but also a way\n\t\t * to avoid the following deadlock:\n\t\t *   ocfs2_dentry_post_unlock()\n\t\t *     ocfs2_dentry_lock_put()\n\t\t *       ocfs2_drop_dentry_lock()\n\t\t *         iput()\n\t\t *           ocfs2_evict_inode()\n\t\t *             ocfs2_clear_inode()\n\t\t *               ocfs2_mark_lockres_freeing()\n\t\t *                 ... blocks waiting for OCFS2_LOCK_QUEUED\n\t\t *                 since we are the downconvert thread which\n\t\t *                 should clear the flag.\n\t\t */\n\t\tspin_unlock_irqrestore(&lockres->l_lock, flags);\n\t\tspin_lock_irqsave(&osb->dc_task_lock, flags2);\n\t\tlist_del_init(&lockres->l_blocked_list);\n\t\tosb->blocked_lock_count--;\n\t\tspin_unlock_irqrestore(&osb->dc_task_lock, flags2);\n\t\t/*\n\t\t * Warn if we recurse into another post_unlock call.  Strictly\n\t\t * speaking it isn't a problem but we need to be careful if\n\t\t * that happens (stack overflow, deadlocks, ...) so warn if\n\t\t * ocfs2 grows a path for which this can happen.\n\t\t */\n\t\tWARN_ON_ONCE(lockres->l_ops->post_unlock);\n\t\t/* Since the lock is freeing we don't do much in the fn below */\n\t\tocfs2_process_blocked_lock(osb, lockres);\n\t\treturn;\n\t}\n\twhile (lockres->l_flags & OCFS2_LOCK_QUEUED) {\n\t\tlockres_add_mask_waiter(lockres, &mw, OCFS2_LOCK_QUEUED, 0);\n\t\tspin_unlock_irqrestore(&lockres->l_lock, flags);\n\n\t\tmlog(0, \"Waiting on lockres %s\\n\", lockres->l_name);\n\n\t\tstatus = ocfs2_wait_for_mask(&mw);\n\t\tif (status)\n\t\t\tmlog_errno(status);\n\n\t\tspin_lock_irqsave(&lockres->l_lock, flags);\n\t}\n\tspin_unlock_irqrestore(&lockres->l_lock, flags);\n}"
  },
  {
    "function_name": "ocfs2_drop_lock",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlmglue.c",
    "lines": "3072-3152",
    "snippet": "static int ocfs2_drop_lock(struct ocfs2_super *osb,\n\t\t\t   struct ocfs2_lock_res *lockres)\n{\n\tint ret;\n\tunsigned long flags;\n\tu32 lkm_flags = 0;\n\n\t/* We didn't get anywhere near actually using this lockres. */\n\tif (!(lockres->l_flags & OCFS2_LOCK_INITIALIZED))\n\t\tgoto out;\n\n\tif (lockres->l_ops->flags & LOCK_TYPE_USES_LVB)\n\t\tlkm_flags |= DLM_LKF_VALBLK;\n\n\tspin_lock_irqsave(&lockres->l_lock, flags);\n\n\tmlog_bug_on_msg(!(lockres->l_flags & OCFS2_LOCK_FREEING),\n\t\t\t\"lockres %s, flags 0x%lx\\n\",\n\t\t\tlockres->l_name, lockres->l_flags);\n\n\twhile (lockres->l_flags & OCFS2_LOCK_BUSY) {\n\t\tmlog(0, \"waiting on busy lock \\\"%s\\\": flags = %lx, action = \"\n\t\t     \"%u, unlock_action = %u\\n\",\n\t\t     lockres->l_name, lockres->l_flags, lockres->l_action,\n\t\t     lockres->l_unlock_action);\n\n\t\tspin_unlock_irqrestore(&lockres->l_lock, flags);\n\n\t\t/* XXX: Today we just wait on any busy\n\t\t * locks... Perhaps we need to cancel converts in the\n\t\t * future? */\n\t\tocfs2_wait_on_busy_lock(lockres);\n\n\t\tspin_lock_irqsave(&lockres->l_lock, flags);\n\t}\n\n\tif (lockres->l_ops->flags & LOCK_TYPE_USES_LVB) {\n\t\tif (lockres->l_flags & OCFS2_LOCK_ATTACHED &&\n\t\t    lockres->l_level == DLM_LOCK_EX &&\n\t\t    !(lockres->l_flags & OCFS2_LOCK_NEEDS_REFRESH))\n\t\t\tlockres->l_ops->set_lvb(lockres);\n\t}\n\n\tif (lockres->l_flags & OCFS2_LOCK_BUSY)\n\t\tmlog(ML_ERROR, \"destroying busy lock: \\\"%s\\\"\\n\",\n\t\t     lockres->l_name);\n\tif (lockres->l_flags & OCFS2_LOCK_BLOCKED)\n\t\tmlog(0, \"destroying blocked lock: \\\"%s\\\"\\n\", lockres->l_name);\n\n\tif (!(lockres->l_flags & OCFS2_LOCK_ATTACHED)) {\n\t\tspin_unlock_irqrestore(&lockres->l_lock, flags);\n\t\tgoto out;\n\t}\n\n\tlockres_clear_flags(lockres, OCFS2_LOCK_ATTACHED);\n\n\t/* make sure we never get here while waiting for an ast to\n\t * fire. */\n\tBUG_ON(lockres->l_action != OCFS2_AST_INVALID);\n\n\t/* is this necessary? */\n\tlockres_or_flags(lockres, OCFS2_LOCK_BUSY);\n\tlockres->l_unlock_action = OCFS2_UNLOCK_DROP_LOCK;\n\tspin_unlock_irqrestore(&lockres->l_lock, flags);\n\n\tmlog(0, \"lock %s\\n\", lockres->l_name);\n\n\tret = ocfs2_dlm_unlock(osb->cconn, &lockres->l_lksb, lkm_flags);\n\tif (ret) {\n\t\tocfs2_log_dlm_error(\"ocfs2_dlm_unlock\", ret, lockres);\n\t\tmlog(ML_ERROR, \"lockres flags: %lu\\n\", lockres->l_flags);\n\t\tocfs2_dlm_dump_lksb(&lockres->l_lksb);\n\t\tBUG();\n\t}\n\tmlog(0, \"lock %s, successful return from ocfs2_dlm_unlock\\n\",\n\t     lockres->l_name);\n\n\tocfs2_wait_on_busy_lock(lockres);\nout:\n\treturn 0;\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"refcounttree.h\"",
      "#include \"quota.h\"",
      "#include \"uptodate.h\"",
      "#include \"super.h\"",
      "#include \"slot_map.h\"",
      "#include \"stackglue.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"heartbeat.h\"",
      "#include \"file.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"dcache.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2_lockingver.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/time.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/kthread.h>",
      "#include <linux/mm.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [
      "#define LOCK_TYPE_USES_LVB\t\t0x2"
    ],
    "globals_used": [
      "static struct ocfs2_super *ocfs2_get_dentry_osb(struct ocfs2_lock_res *lockres);",
      "static struct ocfs2_super *ocfs2_get_inode_osb(struct ocfs2_lock_res *lockres);",
      "static struct ocfs2_super *ocfs2_get_file_osb(struct ocfs2_lock_res *lockres);",
      "static struct ocfs2_super *ocfs2_get_qinfo_osb(struct ocfs2_lock_res *lockres);",
      "static void ocfs2_set_meta_lvb(struct ocfs2_lock_res *lockres);",
      "static void ocfs2_dentry_post_unlock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres);",
      "static void ocfs2_set_qinfo_lvb(struct ocfs2_lock_res *lockres);",
      "static inline void ocfs2_generic_handle_downconvert_action(struct ocfs2_lock_res *lockres);",
      "static inline void ocfs2_generic_handle_convert_action(struct ocfs2_lock_res *lockres);",
      "static inline void ocfs2_generic_handle_attach_action(struct ocfs2_lock_res *lockres);",
      "static void ocfs2_schedule_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);",
      "static void ocfs2_downconvert_on_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);",
      "static void ocfs2_drop_osb_locks(struct ocfs2_super *osb);",
      "static int ocfs2_prepare_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\t        struct ocfs2_lock_res *lockres);",
      "static int ocfs2_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres);",
      "static void ocfs2_process_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *lockres);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ocfs2_wait_on_busy_lock",
          "args": [
            "lockres"
          ],
          "line": 3149
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_wait_on_busy_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlmglue.c",
          "lines": "1276-1281",
          "snippet": "static inline void ocfs2_wait_on_busy_lock(struct ocfs2_lock_res *lockres)\n\n{\n\twait_event(lockres->l_event,\n\t\t   !ocfs2_check_wait_flag(lockres, OCFS2_LOCK_BUSY));\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"refcounttree.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"stackglue.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dcache.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2_lockingver.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/time.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/kthread.h>",
            "#include <linux/mm.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct ocfs2_super *ocfs2_get_dentry_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_inode_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_file_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_qinfo_osb(struct ocfs2_lock_res *lockres);",
            "static void ocfs2_set_meta_lvb(struct ocfs2_lock_res *lockres);",
            "static void ocfs2_dentry_post_unlock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres);",
            "static void ocfs2_set_qinfo_lvb(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_downconvert_action(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_convert_action(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_attach_action(struct ocfs2_lock_res *lockres);",
            "static void ocfs2_schedule_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static void ocfs2_downconvert_on_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static int ocfs2_prepare_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\t        struct ocfs2_lock_res *lockres);",
            "static int ocfs2_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static void ocfs2_process_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *lockres);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"stackglue.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dcache.h\"\n#include \"alloc.h\"\n#include \"ocfs2_lockingver.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/quotaops.h>\n#include <linux/time.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/pagemap.h>\n#include <linux/kthread.h>\n#include <linux/mm.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic struct ocfs2_super *ocfs2_get_dentry_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_inode_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_file_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_qinfo_osb(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_set_meta_lvb(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_dentry_post_unlock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres);\nstatic void ocfs2_set_qinfo_lvb(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_downconvert_action(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_convert_action(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_attach_action(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_schedule_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_downconvert_on_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic int ocfs2_prepare_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\t        struct ocfs2_lock_res *lockres);\nstatic int ocfs2_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_process_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *lockres);\n\nstatic inline void ocfs2_wait_on_busy_lock(struct ocfs2_lock_res *lockres)\n\n{\n\twait_event(lockres->l_event,\n\t\t   !ocfs2_check_wait_flag(lockres, OCFS2_LOCK_BUSY));\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog",
          "args": [
            "0",
            "\"lock %s, successful return from ocfs2_dlm_unlock\\n\"",
            "lockres->l_name"
          ],
          "line": 3146
        },
        "resolved": true,
        "details": {
          "function_name": "mlog_show",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/cluster/masklog.c",
          "lines": "107-113",
          "snippet": "static ssize_t mlog_show(struct kobject *obj, struct attribute *attr,\n\t\t\t char *buf)\n{\n\tstruct mlog_attribute *mlog_attr = to_mlog_attr(attr);\n\n\treturn mlog_mask_show(mlog_attr->mask, buf);\n}",
          "includes": [
            "#include \"masklog.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/string.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"masklog.h\"\n#include <asm/uaccess.h>\n#include <linux/string.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n\nstatic ssize_t mlog_show(struct kobject *obj, struct attribute *attr,\n\t\t\t char *buf)\n{\n\tstruct mlog_attribute *mlog_attr = to_mlog_attr(attr);\n\n\treturn mlog_mask_show(mlog_attr->mask, buf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG",
          "args": [],
          "line": 3144
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_dlm_dump_lksb",
          "args": [
            "&lockres->l_lksb"
          ],
          "line": 3143
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_dlm_dump_lksb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/stackglue.c",
          "lines": "285-288",
          "snippet": "void ocfs2_dlm_dump_lksb(struct ocfs2_dlm_lksb *lksb)\n{\n\tactive_stack->sp_ops->dump_lksb(lksb);\n}",
          "includes": [
            "#include \"stackglue.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include <linux/sysctl.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/fs.h>",
            "#include <linux/kmod.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/list.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct ocfs2_stack_plugin *active_stack;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"stackglue.h\"\n#include \"ocfs2_fs.h\"\n#include <linux/sysctl.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/fs.h>\n#include <linux/kmod.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/spinlock.h>\n#include <linux/list.h>\n\nstatic struct ocfs2_stack_plugin *active_stack;\n\nvoid ocfs2_dlm_dump_lksb(struct ocfs2_dlm_lksb *lksb)\n{\n\tactive_stack->sp_ops->dump_lksb(lksb);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_log_dlm_error",
          "args": [
            "\"ocfs2_dlm_unlock\"",
            "ret",
            "lockres"
          ],
          "line": 3141
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_dlm_unlock",
          "args": [
            "osb->cconn",
            "&lockres->l_lksb",
            "lkm_flags"
          ],
          "line": 3139
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_dlm_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/stackglue.c",
          "lines": "257-264",
          "snippet": "int ocfs2_dlm_unlock(struct ocfs2_cluster_connection *conn,\n\t\t     struct ocfs2_dlm_lksb *lksb,\n\t\t     u32 flags)\n{\n\tBUG_ON(lksb->lksb_conn == NULL);\n\n\treturn active_stack->sp_ops->dlm_unlock(conn, lksb, flags);\n}",
          "includes": [
            "#include \"stackglue.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include <linux/sysctl.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/fs.h>",
            "#include <linux/kmod.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/list.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct ocfs2_stack_plugin *active_stack;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"stackglue.h\"\n#include \"ocfs2_fs.h\"\n#include <linux/sysctl.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/fs.h>\n#include <linux/kmod.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/spinlock.h>\n#include <linux/list.h>\n\nstatic struct ocfs2_stack_plugin *active_stack;\n\nint ocfs2_dlm_unlock(struct ocfs2_cluster_connection *conn,\n\t\t     struct ocfs2_dlm_lksb *lksb,\n\t\t     u32 flags)\n{\n\tBUG_ON(lksb->lksb_conn == NULL);\n\n\treturn active_stack->sp_ops->dlm_unlock(conn, lksb, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock_irqrestore",
          "args": [
            "&lockres->l_lock",
            "flags"
          ],
          "line": 3135
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lockres_or_flags",
          "args": [
            "lockres",
            "OCFS2_LOCK_BUSY"
          ],
          "line": 3133
        },
        "resolved": true,
        "details": {
          "function_name": "lockres_or_flags",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlmglue.c",
          "lines": "819-822",
          "snippet": "static void lockres_or_flags(struct ocfs2_lock_res *lockres, unsigned long or)\n{\n\tlockres_set_flags(lockres, lockres->l_flags | or);\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"refcounttree.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"stackglue.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dcache.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2_lockingver.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/time.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/kthread.h>",
            "#include <linux/mm.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct ocfs2_super *ocfs2_get_dentry_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_inode_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_file_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_qinfo_osb(struct ocfs2_lock_res *lockres);",
            "static void ocfs2_set_meta_lvb(struct ocfs2_lock_res *lockres);",
            "static void ocfs2_dentry_post_unlock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres);",
            "static void ocfs2_set_qinfo_lvb(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_downconvert_action(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_convert_action(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_attach_action(struct ocfs2_lock_res *lockres);",
            "static void ocfs2_schedule_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static void ocfs2_downconvert_on_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static int ocfs2_prepare_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\t        struct ocfs2_lock_res *lockres);",
            "static int ocfs2_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static void ocfs2_process_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *lockres);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"stackglue.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dcache.h\"\n#include \"alloc.h\"\n#include \"ocfs2_lockingver.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/quotaops.h>\n#include <linux/time.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/pagemap.h>\n#include <linux/kthread.h>\n#include <linux/mm.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic struct ocfs2_super *ocfs2_get_dentry_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_inode_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_file_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_qinfo_osb(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_set_meta_lvb(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_dentry_post_unlock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres);\nstatic void ocfs2_set_qinfo_lvb(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_downconvert_action(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_convert_action(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_attach_action(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_schedule_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_downconvert_on_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic int ocfs2_prepare_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\t        struct ocfs2_lock_res *lockres);\nstatic int ocfs2_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_process_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *lockres);\n\nstatic void lockres_or_flags(struct ocfs2_lock_res *lockres, unsigned long or)\n{\n\tlockres_set_flags(lockres, lockres->l_flags | or);\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "lockres->l_action != OCFS2_AST_INVALID"
          ],
          "line": 3130
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lockres_clear_flags",
          "args": [
            "lockres",
            "OCFS2_LOCK_ATTACHED"
          ],
          "line": 3126
        },
        "resolved": true,
        "details": {
          "function_name": "lockres_clear_flags",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlmglue.c",
          "lines": "823-827",
          "snippet": "static void lockres_clear_flags(struct ocfs2_lock_res *lockres,\n\t\t\t\tunsigned long clear)\n{\n\tlockres_set_flags(lockres, lockres->l_flags & ~clear);\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"refcounttree.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"stackglue.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dcache.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2_lockingver.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/time.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/kthread.h>",
            "#include <linux/mm.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct ocfs2_super *ocfs2_get_dentry_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_inode_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_file_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_qinfo_osb(struct ocfs2_lock_res *lockres);",
            "static void ocfs2_set_meta_lvb(struct ocfs2_lock_res *lockres);",
            "static void ocfs2_dentry_post_unlock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres);",
            "static void ocfs2_set_qinfo_lvb(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_downconvert_action(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_convert_action(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_attach_action(struct ocfs2_lock_res *lockres);",
            "static void ocfs2_schedule_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static void ocfs2_downconvert_on_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static int ocfs2_prepare_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\t        struct ocfs2_lock_res *lockres);",
            "static int ocfs2_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static void ocfs2_process_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *lockres);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"stackglue.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dcache.h\"\n#include \"alloc.h\"\n#include \"ocfs2_lockingver.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/quotaops.h>\n#include <linux/time.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/pagemap.h>\n#include <linux/kthread.h>\n#include <linux/mm.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic struct ocfs2_super *ocfs2_get_dentry_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_inode_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_file_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_qinfo_osb(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_set_meta_lvb(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_dentry_post_unlock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres);\nstatic void ocfs2_set_qinfo_lvb(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_downconvert_action(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_convert_action(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_attach_action(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_schedule_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_downconvert_on_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic int ocfs2_prepare_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\t        struct ocfs2_lock_res *lockres);\nstatic int ocfs2_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_process_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *lockres);\n\nstatic void lockres_clear_flags(struct ocfs2_lock_res *lockres,\n\t\t\t\tunsigned long clear)\n{\n\tlockres_set_flags(lockres, lockres->l_flags & ~clear);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock_irqrestore",
          "args": [
            "&lockres->l_lock",
            "flags"
          ],
          "line": 3122
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lockres->l_ops->set_lvb",
          "args": [
            "lockres"
          ],
          "line": 3112
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock_irqsave",
          "args": [
            "&lockres->l_lock",
            "flags"
          ],
          "line": 3105
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock_irqrestore",
          "args": [
            "&lockres->l_lock",
            "flags"
          ],
          "line": 3098
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mlog",
          "args": [
            "0",
            "\"waiting on busy lock \\\"%s\\\": flags = %lx, action = \"\n\t\t     \"%u, unlock_action = %u\\n\"",
            "lockres->l_name",
            "lockres->l_flags",
            "lockres->l_action",
            "lockres->l_unlock_action"
          ],
          "line": 3093
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mlog_bug_on_msg",
          "args": [
            "!(lockres->l_flags & OCFS2_LOCK_FREEING)",
            "\"lockres %s, flags 0x%lx\\n\"",
            "lockres->l_name",
            "lockres->l_flags"
          ],
          "line": 3088
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock_irqsave",
          "args": [
            "&lockres->l_lock",
            "flags"
          ],
          "line": 3086
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"stackglue.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dcache.h\"\n#include \"alloc.h\"\n#include \"ocfs2_lockingver.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/quotaops.h>\n#include <linux/time.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/pagemap.h>\n#include <linux/kthread.h>\n#include <linux/mm.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\n#define LOCK_TYPE_USES_LVB\t\t0x2\n\nstatic struct ocfs2_super *ocfs2_get_dentry_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_inode_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_file_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_qinfo_osb(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_set_meta_lvb(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_dentry_post_unlock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres);\nstatic void ocfs2_set_qinfo_lvb(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_downconvert_action(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_convert_action(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_attach_action(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_schedule_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_downconvert_on_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_drop_osb_locks(struct ocfs2_super *osb);\nstatic int ocfs2_prepare_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\t        struct ocfs2_lock_res *lockres);\nstatic int ocfs2_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_process_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *lockres);\n\nstatic int ocfs2_drop_lock(struct ocfs2_super *osb,\n\t\t\t   struct ocfs2_lock_res *lockres)\n{\n\tint ret;\n\tunsigned long flags;\n\tu32 lkm_flags = 0;\n\n\t/* We didn't get anywhere near actually using this lockres. */\n\tif (!(lockres->l_flags & OCFS2_LOCK_INITIALIZED))\n\t\tgoto out;\n\n\tif (lockres->l_ops->flags & LOCK_TYPE_USES_LVB)\n\t\tlkm_flags |= DLM_LKF_VALBLK;\n\n\tspin_lock_irqsave(&lockres->l_lock, flags);\n\n\tmlog_bug_on_msg(!(lockres->l_flags & OCFS2_LOCK_FREEING),\n\t\t\t\"lockres %s, flags 0x%lx\\n\",\n\t\t\tlockres->l_name, lockres->l_flags);\n\n\twhile (lockres->l_flags & OCFS2_LOCK_BUSY) {\n\t\tmlog(0, \"waiting on busy lock \\\"%s\\\": flags = %lx, action = \"\n\t\t     \"%u, unlock_action = %u\\n\",\n\t\t     lockres->l_name, lockres->l_flags, lockres->l_action,\n\t\t     lockres->l_unlock_action);\n\n\t\tspin_unlock_irqrestore(&lockres->l_lock, flags);\n\n\t\t/* XXX: Today we just wait on any busy\n\t\t * locks... Perhaps we need to cancel converts in the\n\t\t * future? */\n\t\tocfs2_wait_on_busy_lock(lockres);\n\n\t\tspin_lock_irqsave(&lockres->l_lock, flags);\n\t}\n\n\tif (lockres->l_ops->flags & LOCK_TYPE_USES_LVB) {\n\t\tif (lockres->l_flags & OCFS2_LOCK_ATTACHED &&\n\t\t    lockres->l_level == DLM_LOCK_EX &&\n\t\t    !(lockres->l_flags & OCFS2_LOCK_NEEDS_REFRESH))\n\t\t\tlockres->l_ops->set_lvb(lockres);\n\t}\n\n\tif (lockres->l_flags & OCFS2_LOCK_BUSY)\n\t\tmlog(ML_ERROR, \"destroying busy lock: \\\"%s\\\"\\n\",\n\t\t     lockres->l_name);\n\tif (lockres->l_flags & OCFS2_LOCK_BLOCKED)\n\t\tmlog(0, \"destroying blocked lock: \\\"%s\\\"\\n\", lockres->l_name);\n\n\tif (!(lockres->l_flags & OCFS2_LOCK_ATTACHED)) {\n\t\tspin_unlock_irqrestore(&lockres->l_lock, flags);\n\t\tgoto out;\n\t}\n\n\tlockres_clear_flags(lockres, OCFS2_LOCK_ATTACHED);\n\n\t/* make sure we never get here while waiting for an ast to\n\t * fire. */\n\tBUG_ON(lockres->l_action != OCFS2_AST_INVALID);\n\n\t/* is this necessary? */\n\tlockres_or_flags(lockres, OCFS2_LOCK_BUSY);\n\tlockres->l_unlock_action = OCFS2_UNLOCK_DROP_LOCK;\n\tspin_unlock_irqrestore(&lockres->l_lock, flags);\n\n\tmlog(0, \"lock %s\\n\", lockres->l_name);\n\n\tret = ocfs2_dlm_unlock(osb->cconn, &lockres->l_lksb, lkm_flags);\n\tif (ret) {\n\t\tocfs2_log_dlm_error(\"ocfs2_dlm_unlock\", ret, lockres);\n\t\tmlog(ML_ERROR, \"lockres flags: %lu\\n\", lockres->l_flags);\n\t\tocfs2_dlm_dump_lksb(&lockres->l_lksb);\n\t\tBUG();\n\t}\n\tmlog(0, \"lock %s, successful return from ocfs2_dlm_unlock\\n\",\n\t     lockres->l_name);\n\n\tocfs2_wait_on_busy_lock(lockres);\nout:\n\treturn 0;\n}"
  },
  {
    "function_name": "ocfs2_dlm_shutdown",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlmglue.c",
    "lines": "3045-3070",
    "snippet": "void ocfs2_dlm_shutdown(struct ocfs2_super *osb,\n\t\t\tint hangup_pending)\n{\n\tocfs2_drop_osb_locks(osb);\n\n\t/*\n\t * Now that we have dropped all locks and ocfs2_dismount_volume()\n\t * has disabled recovery, the DLM won't be talking to us.  It's\n\t * safe to tear things down before disconnecting the cluster.\n\t */\n\n\tif (osb->dc_task) {\n\t\tkthread_stop(osb->dc_task);\n\t\tosb->dc_task = NULL;\n\t}\n\n\tocfs2_lock_res_free(&osb->osb_super_lockres);\n\tocfs2_lock_res_free(&osb->osb_rename_lockres);\n\tocfs2_lock_res_free(&osb->osb_nfs_sync_lockres);\n\tocfs2_lock_res_free(&osb->osb_orphan_scan.os_lockres);\n\n\tocfs2_cluster_disconnect(osb->cconn, hangup_pending);\n\tosb->cconn = NULL;\n\n\tocfs2_dlm_shutdown_debug(osb);\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"refcounttree.h\"",
      "#include \"quota.h\"",
      "#include \"uptodate.h\"",
      "#include \"super.h\"",
      "#include \"slot_map.h\"",
      "#include \"stackglue.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"heartbeat.h\"",
      "#include \"file.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"dcache.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2_lockingver.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/time.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/kthread.h>",
      "#include <linux/mm.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void ocfs2_drop_osb_locks(struct ocfs2_super *osb);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ocfs2_dlm_shutdown_debug",
          "args": [
            "osb"
          ],
          "line": 3069
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_dlm_shutdown_debug",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlmglue.c",
          "lines": "2969-2977",
          "snippet": "static void ocfs2_dlm_shutdown_debug(struct ocfs2_super *osb)\n{\n\tstruct ocfs2_dlm_debug *dlm_debug = osb->osb_dlm_debug;\n\n\tif (dlm_debug) {\n\t\tdebugfs_remove(dlm_debug->d_locking_state);\n\t\tocfs2_put_dlm_debug(dlm_debug);\n\t}\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"refcounttree.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"stackglue.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dcache.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2_lockingver.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/time.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/kthread.h>",
            "#include <linux/mm.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void ocfs2_drop_osb_locks(struct ocfs2_super *osb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"stackglue.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dcache.h\"\n#include \"alloc.h\"\n#include \"ocfs2_lockingver.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/quotaops.h>\n#include <linux/time.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/pagemap.h>\n#include <linux/kthread.h>\n#include <linux/mm.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic void ocfs2_drop_osb_locks(struct ocfs2_super *osb);\n\nstatic void ocfs2_dlm_shutdown_debug(struct ocfs2_super *osb)\n{\n\tstruct ocfs2_dlm_debug *dlm_debug = osb->osb_dlm_debug;\n\n\tif (dlm_debug) {\n\t\tdebugfs_remove(dlm_debug->d_locking_state);\n\t\tocfs2_put_dlm_debug(dlm_debug);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_cluster_disconnect",
          "args": [
            "osb->cconn",
            "hangup_pending"
          ],
          "line": 3066
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_cluster_disconnect",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/stackglue.c",
          "lines": "402-419",
          "snippet": "int ocfs2_cluster_disconnect(struct ocfs2_cluster_connection *conn,\n\t\t\t     int hangup_pending)\n{\n\tint ret;\n\n\tBUG_ON(conn == NULL);\n\n\tret = active_stack->sp_ops->disconnect(conn);\n\n\t/* XXX Should we free it anyway? */\n\tif (!ret) {\n\t\tkfree(conn);\n\t\tif (!hangup_pending)\n\t\t\tocfs2_stack_driver_put();\n\t}\n\n\treturn ret;\n}",
          "includes": [
            "#include \"stackglue.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include <linux/sysctl.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/fs.h>",
            "#include <linux/kmod.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/list.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct ocfs2_stack_plugin *active_stack;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"stackglue.h\"\n#include \"ocfs2_fs.h\"\n#include <linux/sysctl.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/fs.h>\n#include <linux/kmod.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/spinlock.h>\n#include <linux/list.h>\n\nstatic struct ocfs2_stack_plugin *active_stack;\n\nint ocfs2_cluster_disconnect(struct ocfs2_cluster_connection *conn,\n\t\t\t     int hangup_pending)\n{\n\tint ret;\n\n\tBUG_ON(conn == NULL);\n\n\tret = active_stack->sp_ops->disconnect(conn);\n\n\t/* XXX Should we free it anyway? */\n\tif (!ret) {\n\t\tkfree(conn);\n\t\tif (!hangup_pending)\n\t\t\tocfs2_stack_driver_put();\n\t}\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_lock_res_free",
          "args": [
            "&osb->osb_orphan_scan.os_lockres"
          ],
          "line": 3064
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_lock_res_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlmglue.c",
          "lines": "722-749",
          "snippet": "void ocfs2_lock_res_free(struct ocfs2_lock_res *res)\n{\n\tif (!(res->l_flags & OCFS2_LOCK_INITIALIZED))\n\t\treturn;\n\n\tocfs2_remove_lockres_tracking(res);\n\n\tmlog_bug_on_msg(!list_empty(&res->l_blocked_list),\n\t\t\t\"Lockres %s is on the blocked list\\n\",\n\t\t\tres->l_name);\n\tmlog_bug_on_msg(!list_empty(&res->l_mask_waiters),\n\t\t\t\"Lockres %s has mask waiters pending\\n\",\n\t\t\tres->l_name);\n\tmlog_bug_on_msg(spin_is_locked(&res->l_lock),\n\t\t\t\"Lockres %s is locked\\n\",\n\t\t\tres->l_name);\n\tmlog_bug_on_msg(res->l_ro_holders,\n\t\t\t\"Lockres %s has %u ro holders\\n\",\n\t\t\tres->l_name, res->l_ro_holders);\n\tmlog_bug_on_msg(res->l_ex_holders,\n\t\t\t\"Lockres %s has %u ex holders\\n\",\n\t\t\tres->l_name, res->l_ex_holders);\n\n\t/* Need to clear out the lock status block for the dlm */\n\tmemset(&res->l_lksb, 0, sizeof(res->l_lksb));\n\n\tres->l_flags = 0UL;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"refcounttree.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"stackglue.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dcache.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2_lockingver.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/time.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/kthread.h>",
            "#include <linux/mm.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"stackglue.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dcache.h\"\n#include \"alloc.h\"\n#include \"ocfs2_lockingver.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/quotaops.h>\n#include <linux/time.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/pagemap.h>\n#include <linux/kthread.h>\n#include <linux/mm.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nvoid ocfs2_lock_res_free(struct ocfs2_lock_res *res)\n{\n\tif (!(res->l_flags & OCFS2_LOCK_INITIALIZED))\n\t\treturn;\n\n\tocfs2_remove_lockres_tracking(res);\n\n\tmlog_bug_on_msg(!list_empty(&res->l_blocked_list),\n\t\t\t\"Lockres %s is on the blocked list\\n\",\n\t\t\tres->l_name);\n\tmlog_bug_on_msg(!list_empty(&res->l_mask_waiters),\n\t\t\t\"Lockres %s has mask waiters pending\\n\",\n\t\t\tres->l_name);\n\tmlog_bug_on_msg(spin_is_locked(&res->l_lock),\n\t\t\t\"Lockres %s is locked\\n\",\n\t\t\tres->l_name);\n\tmlog_bug_on_msg(res->l_ro_holders,\n\t\t\t\"Lockres %s has %u ro holders\\n\",\n\t\t\tres->l_name, res->l_ro_holders);\n\tmlog_bug_on_msg(res->l_ex_holders,\n\t\t\t\"Lockres %s has %u ex holders\\n\",\n\t\t\tres->l_name, res->l_ex_holders);\n\n\t/* Need to clear out the lock status block for the dlm */\n\tmemset(&res->l_lksb, 0, sizeof(res->l_lksb));\n\n\tres->l_flags = 0UL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kthread_stop",
          "args": [
            "osb->dc_task"
          ],
          "line": 3057
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_drop_osb_locks",
          "args": [
            "osb"
          ],
          "line": 3048
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_drop_osb_locks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlmglue.c",
          "lines": "3234-3240",
          "snippet": "static void ocfs2_drop_osb_locks(struct ocfs2_super *osb)\n{\n\tocfs2_simple_drop_lockres(osb, &osb->osb_super_lockres);\n\tocfs2_simple_drop_lockres(osb, &osb->osb_rename_lockres);\n\tocfs2_simple_drop_lockres(osb, &osb->osb_nfs_sync_lockres);\n\tocfs2_simple_drop_lockres(osb, &osb->osb_orphan_scan.os_lockres);\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"refcounttree.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"stackglue.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dcache.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2_lockingver.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/time.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/kthread.h>",
            "#include <linux/mm.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void ocfs2_drop_osb_locks(struct ocfs2_super *osb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"stackglue.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dcache.h\"\n#include \"alloc.h\"\n#include \"ocfs2_lockingver.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/quotaops.h>\n#include <linux/time.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/pagemap.h>\n#include <linux/kthread.h>\n#include <linux/mm.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic void ocfs2_drop_osb_locks(struct ocfs2_super *osb);\n\nstatic void ocfs2_drop_osb_locks(struct ocfs2_super *osb)\n{\n\tocfs2_simple_drop_lockres(osb, &osb->osb_super_lockres);\n\tocfs2_simple_drop_lockres(osb, &osb->osb_rename_lockres);\n\tocfs2_simple_drop_lockres(osb, &osb->osb_nfs_sync_lockres);\n\tocfs2_simple_drop_lockres(osb, &osb->osb_orphan_scan.os_lockres);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"stackglue.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dcache.h\"\n#include \"alloc.h\"\n#include \"ocfs2_lockingver.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/quotaops.h>\n#include <linux/time.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/pagemap.h>\n#include <linux/kthread.h>\n#include <linux/mm.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic void ocfs2_drop_osb_locks(struct ocfs2_super *osb);\n\nvoid ocfs2_dlm_shutdown(struct ocfs2_super *osb,\n\t\t\tint hangup_pending)\n{\n\tocfs2_drop_osb_locks(osb);\n\n\t/*\n\t * Now that we have dropped all locks and ocfs2_dismount_volume()\n\t * has disabled recovery, the DLM won't be talking to us.  It's\n\t * safe to tear things down before disconnecting the cluster.\n\t */\n\n\tif (osb->dc_task) {\n\t\tkthread_stop(osb->dc_task);\n\t\tosb->dc_task = NULL;\n\t}\n\n\tocfs2_lock_res_free(&osb->osb_super_lockres);\n\tocfs2_lock_res_free(&osb->osb_rename_lockres);\n\tocfs2_lock_res_free(&osb->osb_nfs_sync_lockres);\n\tocfs2_lock_res_free(&osb->osb_orphan_scan.os_lockres);\n\n\tocfs2_cluster_disconnect(osb->cconn, hangup_pending);\n\tosb->cconn = NULL;\n\n\tocfs2_dlm_shutdown_debug(osb);\n}"
  },
  {
    "function_name": "ocfs2_dlm_init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlmglue.c",
    "lines": "2979-3043",
    "snippet": "int ocfs2_dlm_init(struct ocfs2_super *osb)\n{\n\tint status = 0;\n\tstruct ocfs2_cluster_connection *conn = NULL;\n\n\tif (ocfs2_mount_local(osb)) {\n\t\tosb->node_num = 0;\n\t\tgoto local;\n\t}\n\n\tstatus = ocfs2_dlm_init_debug(osb);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\t/* launch downconvert thread */\n\tosb->dc_task = kthread_run(ocfs2_downconvert_thread, osb, \"ocfs2dc\");\n\tif (IS_ERR(osb->dc_task)) {\n\t\tstatus = PTR_ERR(osb->dc_task);\n\t\tosb->dc_task = NULL;\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\t/* for now, uuid == domain */\n\tstatus = ocfs2_cluster_connect(osb->osb_cluster_stack,\n\t\t\t\t       osb->osb_cluster_name,\n\t\t\t\t       strlen(osb->osb_cluster_name),\n\t\t\t\t       osb->uuid_str,\n\t\t\t\t       strlen(osb->uuid_str),\n\t\t\t\t       &lproto, ocfs2_do_node_down, osb,\n\t\t\t\t       &conn);\n\tif (status) {\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\tstatus = ocfs2_cluster_this_node(conn, &osb->node_num);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tmlog(ML_ERROR,\n\t\t     \"could not find this host's node number\\n\");\n\t\tocfs2_cluster_disconnect(conn, 0);\n\t\tgoto bail;\n\t}\n\nlocal:\n\tocfs2_super_lock_res_init(&osb->osb_super_lockres, osb);\n\tocfs2_rename_lock_res_init(&osb->osb_rename_lockres, osb);\n\tocfs2_nfs_sync_lock_res_init(&osb->osb_nfs_sync_lockres, osb);\n\tocfs2_orphan_scan_lock_res_init(&osb->osb_orphan_scan.os_lockres, osb);\n\n\tosb->cconn = conn;\n\n\tstatus = 0;\nbail:\n\tif (status < 0) {\n\t\tocfs2_dlm_shutdown_debug(osb);\n\t\tif (osb->dc_task)\n\t\t\tkthread_stop(osb->dc_task);\n\t}\n\n\treturn status;\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"refcounttree.h\"",
      "#include \"quota.h\"",
      "#include \"uptodate.h\"",
      "#include \"super.h\"",
      "#include \"slot_map.h\"",
      "#include \"stackglue.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"heartbeat.h\"",
      "#include \"file.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"dcache.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2_lockingver.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/time.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/kthread.h>",
      "#include <linux/mm.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void ocfs2_drop_osb_locks(struct ocfs2_super *osb);",
      "static struct ocfs2_locking_protocol lproto = {\n\t.lp_max_version = {\n\t\t.pv_major = OCFS2_LOCKING_PROTOCOL_MAJOR,\n\t\t.pv_minor = OCFS2_LOCKING_PROTOCOL_MINOR,\n\t},\n\t.lp_lock_ast\t\t= ocfs2_locking_ast,\n\t.lp_blocking_ast\t= ocfs2_blocking_ast,\n\t.lp_unlock_ast\t\t= ocfs2_unlock_ast,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kthread_stop",
          "args": [
            "osb->dc_task"
          ],
          "line": 3039
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_dlm_shutdown_debug",
          "args": [
            "osb"
          ],
          "line": 3037
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_dlm_shutdown_debug",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlmglue.c",
          "lines": "2969-2977",
          "snippet": "static void ocfs2_dlm_shutdown_debug(struct ocfs2_super *osb)\n{\n\tstruct ocfs2_dlm_debug *dlm_debug = osb->osb_dlm_debug;\n\n\tif (dlm_debug) {\n\t\tdebugfs_remove(dlm_debug->d_locking_state);\n\t\tocfs2_put_dlm_debug(dlm_debug);\n\t}\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"refcounttree.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"stackglue.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dcache.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2_lockingver.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/time.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/kthread.h>",
            "#include <linux/mm.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void ocfs2_drop_osb_locks(struct ocfs2_super *osb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"stackglue.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dcache.h\"\n#include \"alloc.h\"\n#include \"ocfs2_lockingver.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/quotaops.h>\n#include <linux/time.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/pagemap.h>\n#include <linux/kthread.h>\n#include <linux/mm.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic void ocfs2_drop_osb_locks(struct ocfs2_super *osb);\n\nstatic void ocfs2_dlm_shutdown_debug(struct ocfs2_super *osb)\n{\n\tstruct ocfs2_dlm_debug *dlm_debug = osb->osb_dlm_debug;\n\n\tif (dlm_debug) {\n\t\tdebugfs_remove(dlm_debug->d_locking_state);\n\t\tocfs2_put_dlm_debug(dlm_debug);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_orphan_scan_lock_res_init",
          "args": [
            "&osb->osb_orphan_scan.os_lockres",
            "osb"
          ],
          "line": 3030
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_orphan_scan_lock_res_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlmglue.c",
          "lines": "676-683",
          "snippet": "static void ocfs2_orphan_scan_lock_res_init(struct ocfs2_lock_res *res,\n\t\t\t\t\t    struct ocfs2_super *osb)\n{\n\tocfs2_lock_res_init_once(res);\n\tocfs2_build_lock_name(OCFS2_LOCK_TYPE_ORPHAN_SCAN, 0, 0, res->l_name);\n\tocfs2_lock_res_init_common(osb, res, OCFS2_LOCK_TYPE_ORPHAN_SCAN,\n\t\t\t\t   &ocfs2_orphan_scan_lops, osb);\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"refcounttree.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"stackglue.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dcache.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2_lockingver.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/time.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/kthread.h>",
            "#include <linux/mm.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct ocfs2_lock_res_ops ocfs2_orphan_scan_lops = {\n\t.flags\t\t= LOCK_TYPE_REQUIRES_REFRESH|LOCK_TYPE_USES_LVB,\n};",
            "static void ocfs2_drop_osb_locks(struct ocfs2_super *osb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"stackglue.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dcache.h\"\n#include \"alloc.h\"\n#include \"ocfs2_lockingver.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/quotaops.h>\n#include <linux/time.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/pagemap.h>\n#include <linux/kthread.h>\n#include <linux/mm.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic struct ocfs2_lock_res_ops ocfs2_orphan_scan_lops = {\n\t.flags\t\t= LOCK_TYPE_REQUIRES_REFRESH|LOCK_TYPE_USES_LVB,\n};\nstatic void ocfs2_drop_osb_locks(struct ocfs2_super *osb);\n\nstatic void ocfs2_orphan_scan_lock_res_init(struct ocfs2_lock_res *res,\n\t\t\t\t\t    struct ocfs2_super *osb)\n{\n\tocfs2_lock_res_init_once(res);\n\tocfs2_build_lock_name(OCFS2_LOCK_TYPE_ORPHAN_SCAN, 0, 0, res->l_name);\n\tocfs2_lock_res_init_common(osb, res, OCFS2_LOCK_TYPE_ORPHAN_SCAN,\n\t\t\t\t   &ocfs2_orphan_scan_lops, osb);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_nfs_sync_lock_res_init",
          "args": [
            "&osb->osb_nfs_sync_lockres",
            "osb"
          ],
          "line": 3029
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_nfs_sync_lock_res_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlmglue.c",
          "lines": "665-674",
          "snippet": "static void ocfs2_nfs_sync_lock_res_init(struct ocfs2_lock_res *res,\n\t\t\t\t\t struct ocfs2_super *osb)\n{\n\t/* nfs_sync lockres doesn't come from a slab so we call init\n\t * once on it manually.  */\n\tocfs2_lock_res_init_once(res);\n\tocfs2_build_lock_name(OCFS2_LOCK_TYPE_NFS_SYNC, 0, 0, res->l_name);\n\tocfs2_lock_res_init_common(osb, res, OCFS2_LOCK_TYPE_NFS_SYNC,\n\t\t\t\t   &ocfs2_nfs_sync_lops, osb);\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"refcounttree.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"stackglue.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dcache.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2_lockingver.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/time.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/kthread.h>",
            "#include <linux/mm.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct ocfs2_super *ocfs2_get_dentry_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_inode_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_file_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_qinfo_osb(struct ocfs2_lock_res *lockres);",
            "static void ocfs2_set_meta_lvb(struct ocfs2_lock_res *lockres);",
            "static void ocfs2_dentry_post_unlock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres);",
            "static void ocfs2_set_qinfo_lvb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_lock_res_ops ocfs2_nfs_sync_lops = {\n\t.flags\t\t= 0,\n};",
            "static inline void ocfs2_generic_handle_downconvert_action(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_convert_action(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_attach_action(struct ocfs2_lock_res *lockres);",
            "static void ocfs2_schedule_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static void ocfs2_downconvert_on_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static void ocfs2_drop_osb_locks(struct ocfs2_super *osb);",
            "static int ocfs2_prepare_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\t        struct ocfs2_lock_res *lockres);",
            "static int ocfs2_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static void ocfs2_process_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *lockres);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"stackglue.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dcache.h\"\n#include \"alloc.h\"\n#include \"ocfs2_lockingver.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/quotaops.h>\n#include <linux/time.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/pagemap.h>\n#include <linux/kthread.h>\n#include <linux/mm.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic struct ocfs2_super *ocfs2_get_dentry_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_inode_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_file_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_qinfo_osb(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_set_meta_lvb(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_dentry_post_unlock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres);\nstatic void ocfs2_set_qinfo_lvb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_lock_res_ops ocfs2_nfs_sync_lops = {\n\t.flags\t\t= 0,\n};\nstatic inline void ocfs2_generic_handle_downconvert_action(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_convert_action(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_attach_action(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_schedule_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_downconvert_on_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_drop_osb_locks(struct ocfs2_super *osb);\nstatic int ocfs2_prepare_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\t        struct ocfs2_lock_res *lockres);\nstatic int ocfs2_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_process_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *lockres);\n\nstatic void ocfs2_nfs_sync_lock_res_init(struct ocfs2_lock_res *res,\n\t\t\t\t\t struct ocfs2_super *osb)\n{\n\t/* nfs_sync lockres doesn't come from a slab so we call init\n\t * once on it manually.  */\n\tocfs2_lock_res_init_once(res);\n\tocfs2_build_lock_name(OCFS2_LOCK_TYPE_NFS_SYNC, 0, 0, res->l_name);\n\tocfs2_lock_res_init_common(osb, res, OCFS2_LOCK_TYPE_NFS_SYNC,\n\t\t\t\t   &ocfs2_nfs_sync_lops, osb);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_rename_lock_res_init",
          "args": [
            "&osb->osb_rename_lockres",
            "osb"
          ],
          "line": 3028
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_rename_lock_res_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlmglue.c",
          "lines": "654-663",
          "snippet": "static void ocfs2_rename_lock_res_init(struct ocfs2_lock_res *res,\n\t\t\t\t       struct ocfs2_super *osb)\n{\n\t/* Rename lockres doesn't come from a slab so we call init\n\t * once on it manually.  */\n\tocfs2_lock_res_init_once(res);\n\tocfs2_build_lock_name(OCFS2_LOCK_TYPE_RENAME, 0, 0, res->l_name);\n\tocfs2_lock_res_init_common(osb, res, OCFS2_LOCK_TYPE_RENAME,\n\t\t\t\t   &ocfs2_rename_lops, osb);\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"refcounttree.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"stackglue.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dcache.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2_lockingver.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/time.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/kthread.h>",
            "#include <linux/mm.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct ocfs2_super *ocfs2_get_dentry_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_inode_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_file_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_qinfo_osb(struct ocfs2_lock_res *lockres);",
            "static void ocfs2_set_meta_lvb(struct ocfs2_lock_res *lockres);",
            "static void ocfs2_dentry_post_unlock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres);",
            "static void ocfs2_set_qinfo_lvb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_lock_res_ops ocfs2_rename_lops = {\n\t.flags\t\t= 0,\n};",
            "static inline void ocfs2_generic_handle_downconvert_action(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_convert_action(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_attach_action(struct ocfs2_lock_res *lockres);",
            "static void ocfs2_schedule_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static void ocfs2_downconvert_on_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static void ocfs2_drop_osb_locks(struct ocfs2_super *osb);",
            "static int ocfs2_prepare_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\t        struct ocfs2_lock_res *lockres);",
            "static int ocfs2_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static void ocfs2_process_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *lockres);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"stackglue.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dcache.h\"\n#include \"alloc.h\"\n#include \"ocfs2_lockingver.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/quotaops.h>\n#include <linux/time.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/pagemap.h>\n#include <linux/kthread.h>\n#include <linux/mm.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic struct ocfs2_super *ocfs2_get_dentry_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_inode_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_file_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_qinfo_osb(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_set_meta_lvb(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_dentry_post_unlock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres);\nstatic void ocfs2_set_qinfo_lvb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_lock_res_ops ocfs2_rename_lops = {\n\t.flags\t\t= 0,\n};\nstatic inline void ocfs2_generic_handle_downconvert_action(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_convert_action(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_attach_action(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_schedule_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_downconvert_on_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_drop_osb_locks(struct ocfs2_super *osb);\nstatic int ocfs2_prepare_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\t        struct ocfs2_lock_res *lockres);\nstatic int ocfs2_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_process_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *lockres);\n\nstatic void ocfs2_rename_lock_res_init(struct ocfs2_lock_res *res,\n\t\t\t\t       struct ocfs2_super *osb)\n{\n\t/* Rename lockres doesn't come from a slab so we call init\n\t * once on it manually.  */\n\tocfs2_lock_res_init_once(res);\n\tocfs2_build_lock_name(OCFS2_LOCK_TYPE_RENAME, 0, 0, res->l_name);\n\tocfs2_lock_res_init_common(osb, res, OCFS2_LOCK_TYPE_RENAME,\n\t\t\t\t   &ocfs2_rename_lops, osb);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_super_lock_res_init",
          "args": [
            "&osb->osb_super_lockres",
            "osb"
          ],
          "line": 3027
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_super_lock_res_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlmglue.c",
          "lines": "642-652",
          "snippet": "static void ocfs2_super_lock_res_init(struct ocfs2_lock_res *res,\n\t\t\t\t      struct ocfs2_super *osb)\n{\n\t/* Superblock lockres doesn't come from a slab so we call init\n\t * once on it manually.  */\n\tocfs2_lock_res_init_once(res);\n\tocfs2_build_lock_name(OCFS2_LOCK_TYPE_SUPER, OCFS2_SUPER_BLOCK_BLKNO,\n\t\t\t      0, res->l_name);\n\tocfs2_lock_res_init_common(osb, res, OCFS2_LOCK_TYPE_SUPER,\n\t\t\t\t   &ocfs2_super_lops, osb);\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"refcounttree.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"stackglue.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dcache.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2_lockingver.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/time.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/kthread.h>",
            "#include <linux/mm.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct ocfs2_super *ocfs2_get_dentry_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_inode_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_file_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_qinfo_osb(struct ocfs2_lock_res *lockres);",
            "static void ocfs2_set_meta_lvb(struct ocfs2_lock_res *lockres);",
            "static void ocfs2_dentry_post_unlock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres);",
            "static void ocfs2_set_qinfo_lvb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_lock_res_ops ocfs2_super_lops = {\n\t.flags\t\t= LOCK_TYPE_REQUIRES_REFRESH,\n};",
            "static inline void ocfs2_generic_handle_downconvert_action(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_convert_action(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_attach_action(struct ocfs2_lock_res *lockres);",
            "static void ocfs2_schedule_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static void ocfs2_downconvert_on_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static void ocfs2_drop_osb_locks(struct ocfs2_super *osb);",
            "static int ocfs2_prepare_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\t        struct ocfs2_lock_res *lockres);",
            "static int ocfs2_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static void ocfs2_process_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *lockres);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"stackglue.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dcache.h\"\n#include \"alloc.h\"\n#include \"ocfs2_lockingver.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/quotaops.h>\n#include <linux/time.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/pagemap.h>\n#include <linux/kthread.h>\n#include <linux/mm.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic struct ocfs2_super *ocfs2_get_dentry_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_inode_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_file_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_qinfo_osb(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_set_meta_lvb(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_dentry_post_unlock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres);\nstatic void ocfs2_set_qinfo_lvb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_lock_res_ops ocfs2_super_lops = {\n\t.flags\t\t= LOCK_TYPE_REQUIRES_REFRESH,\n};\nstatic inline void ocfs2_generic_handle_downconvert_action(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_convert_action(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_attach_action(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_schedule_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_downconvert_on_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_drop_osb_locks(struct ocfs2_super *osb);\nstatic int ocfs2_prepare_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\t        struct ocfs2_lock_res *lockres);\nstatic int ocfs2_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_process_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *lockres);\n\nstatic void ocfs2_super_lock_res_init(struct ocfs2_lock_res *res,\n\t\t\t\t      struct ocfs2_super *osb)\n{\n\t/* Superblock lockres doesn't come from a slab so we call init\n\t * once on it manually.  */\n\tocfs2_lock_res_init_once(res);\n\tocfs2_build_lock_name(OCFS2_LOCK_TYPE_SUPER, OCFS2_SUPER_BLOCK_BLKNO,\n\t\t\t      0, res->l_name);\n\tocfs2_lock_res_init_common(osb, res, OCFS2_LOCK_TYPE_SUPER,\n\t\t\t\t   &ocfs2_super_lops, osb);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_cluster_disconnect",
          "args": [
            "conn",
            "0"
          ],
          "line": 3022
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_cluster_disconnect",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/stackglue.c",
          "lines": "402-419",
          "snippet": "int ocfs2_cluster_disconnect(struct ocfs2_cluster_connection *conn,\n\t\t\t     int hangup_pending)\n{\n\tint ret;\n\n\tBUG_ON(conn == NULL);\n\n\tret = active_stack->sp_ops->disconnect(conn);\n\n\t/* XXX Should we free it anyway? */\n\tif (!ret) {\n\t\tkfree(conn);\n\t\tif (!hangup_pending)\n\t\t\tocfs2_stack_driver_put();\n\t}\n\n\treturn ret;\n}",
          "includes": [
            "#include \"stackglue.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include <linux/sysctl.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/fs.h>",
            "#include <linux/kmod.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/list.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct ocfs2_stack_plugin *active_stack;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"stackglue.h\"\n#include \"ocfs2_fs.h\"\n#include <linux/sysctl.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/fs.h>\n#include <linux/kmod.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/spinlock.h>\n#include <linux/list.h>\n\nstatic struct ocfs2_stack_plugin *active_stack;\n\nint ocfs2_cluster_disconnect(struct ocfs2_cluster_connection *conn,\n\t\t\t     int hangup_pending)\n{\n\tint ret;\n\n\tBUG_ON(conn == NULL);\n\n\tret = active_stack->sp_ops->disconnect(conn);\n\n\t/* XXX Should we free it anyway? */\n\tif (!ret) {\n\t\tkfree(conn);\n\t\tif (!hangup_pending)\n\t\t\tocfs2_stack_driver_put();\n\t}\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog",
          "args": [
            "ML_ERROR",
            "\"could not find this host's node number\\n\""
          ],
          "line": 3020
        },
        "resolved": true,
        "details": {
          "function_name": "mlog_mask_show",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/cluster/masklog.c",
          "lines": "36-48",
          "snippet": "static ssize_t mlog_mask_show(u64 mask, char *buf)\n{\n\tchar *state;\n\n\tif (__mlog_test_u64(mask, mlog_and_bits))\n\t\tstate = \"allow\";\n\telse if (__mlog_test_u64(mask, mlog_not_bits))\n\t\tstate = \"deny\";\n\telse\n\t\tstate = \"off\";\n\n\treturn snprintf(buf, PAGE_SIZE, \"%s\\n\", state);\n}",
          "includes": [
            "#include \"masklog.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/string.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct mlog_bits mlog_and_bits = MLOG_BITS_RHS(MLOG_INITIAL_AND_MASK);",
            "struct mlog_bits mlog_not_bits = MLOG_BITS_RHS(0);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"masklog.h\"\n#include <asm/uaccess.h>\n#include <linux/string.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n\nstruct mlog_bits mlog_and_bits = MLOG_BITS_RHS(MLOG_INITIAL_AND_MASK);\nstruct mlog_bits mlog_not_bits = MLOG_BITS_RHS(0);\n\nstatic ssize_t mlog_mask_show(u64 mask, char *buf)\n{\n\tchar *state;\n\n\tif (__mlog_test_u64(mask, mlog_and_bits))\n\t\tstate = \"allow\";\n\telse if (__mlog_test_u64(mask, mlog_not_bits))\n\t\tstate = \"deny\";\n\telse\n\t\tstate = \"off\";\n\n\treturn snprintf(buf, PAGE_SIZE, \"%s\\n\", state);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "status"
          ],
          "line": 3019
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_cluster_this_node",
          "args": [
            "conn",
            "&osb->node_num"
          ],
          "line": 3017
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_cluster_this_node",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/stackglue.c",
          "lines": "470-474",
          "snippet": "int ocfs2_cluster_this_node(struct ocfs2_cluster_connection *conn,\n\t\t\t    unsigned int *node)\n{\n\treturn active_stack->sp_ops->this_node(conn, node);\n}",
          "includes": [
            "#include \"stackglue.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include <linux/sysctl.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/fs.h>",
            "#include <linux/kmod.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/list.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct ocfs2_stack_plugin *active_stack;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"stackglue.h\"\n#include \"ocfs2_fs.h\"\n#include <linux/sysctl.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/fs.h>\n#include <linux/kmod.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/spinlock.h>\n#include <linux/list.h>\n\nstatic struct ocfs2_stack_plugin *active_stack;\n\nint ocfs2_cluster_this_node(struct ocfs2_cluster_connection *conn,\n\t\t\t    unsigned int *node)\n{\n\treturn active_stack->sp_ops->this_node(conn, node);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "status"
          ],
          "line": 3013
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_cluster_connect",
          "args": [
            "osb->osb_cluster_stack",
            "osb->osb_cluster_name",
            "strlen(osb->osb_cluster_name)",
            "osb->uuid_str",
            "strlen(osb->uuid_str)",
            "&lproto",
            "ocfs2_do_node_down",
            "osb",
            "&conn"
          ],
          "line": 3005
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_cluster_connect",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/stackglue.c",
          "lines": "311-379",
          "snippet": "int ocfs2_cluster_connect(const char *stack_name,\n\t\t\t  const char *cluster_name,\n\t\t\t  int cluster_name_len,\n\t\t\t  const char *group,\n\t\t\t  int grouplen,\n\t\t\t  struct ocfs2_locking_protocol *lproto,\n\t\t\t  void (*recovery_handler)(int node_num,\n\t\t\t\t\t\t   void *recovery_data),\n\t\t\t  void *recovery_data,\n\t\t\t  struct ocfs2_cluster_connection **conn)\n{\n\tint rc = 0;\n\tstruct ocfs2_cluster_connection *new_conn;\n\n\tBUG_ON(group == NULL);\n\tBUG_ON(conn == NULL);\n\tBUG_ON(recovery_handler == NULL);\n\n\tif (grouplen > GROUP_NAME_MAX) {\n\t\trc = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tif (memcmp(&lproto->lp_max_version, &locking_max_version,\n\t\t   sizeof(struct ocfs2_protocol_version))) {\n\t\trc = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tnew_conn = kzalloc(sizeof(struct ocfs2_cluster_connection),\n\t\t\t   GFP_KERNEL);\n\tif (!new_conn) {\n\t\trc = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tstrlcpy(new_conn->cc_name, group, GROUP_NAME_MAX + 1);\n\tnew_conn->cc_namelen = grouplen;\n\tif (cluster_name_len)\n\t\tstrlcpy(new_conn->cc_cluster_name, cluster_name,\n\t\t\tCLUSTER_NAME_MAX + 1);\n\tnew_conn->cc_cluster_name_len = cluster_name_len;\n\tnew_conn->cc_recovery_handler = recovery_handler;\n\tnew_conn->cc_recovery_data = recovery_data;\n\n\tnew_conn->cc_proto = lproto;\n\t/* Start the new connection at our maximum compatibility level */\n\tnew_conn->cc_version = lproto->lp_max_version;\n\n\t/* This will pin the stack driver if successful */\n\trc = ocfs2_stack_driver_get(stack_name);\n\tif (rc)\n\t\tgoto out_free;\n\n\trc = active_stack->sp_ops->connect(new_conn);\n\tif (rc) {\n\t\tocfs2_stack_driver_put();\n\t\tgoto out_free;\n\t}\n\n\t*conn = new_conn;\n\nout_free:\n\tif (rc)\n\t\tkfree(new_conn);\n\nout:\n\treturn rc;\n}",
          "includes": [
            "#include \"stackglue.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include <linux/sysctl.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/fs.h>",
            "#include <linux/kmod.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/list.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct ocfs2_protocol_version locking_max_version;",
            "static struct ocfs2_stack_plugin *active_stack;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"stackglue.h\"\n#include \"ocfs2_fs.h\"\n#include <linux/sysctl.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/fs.h>\n#include <linux/kmod.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/spinlock.h>\n#include <linux/list.h>\n\nstatic struct ocfs2_protocol_version locking_max_version;\nstatic struct ocfs2_stack_plugin *active_stack;\n\nint ocfs2_cluster_connect(const char *stack_name,\n\t\t\t  const char *cluster_name,\n\t\t\t  int cluster_name_len,\n\t\t\t  const char *group,\n\t\t\t  int grouplen,\n\t\t\t  struct ocfs2_locking_protocol *lproto,\n\t\t\t  void (*recovery_handler)(int node_num,\n\t\t\t\t\t\t   void *recovery_data),\n\t\t\t  void *recovery_data,\n\t\t\t  struct ocfs2_cluster_connection **conn)\n{\n\tint rc = 0;\n\tstruct ocfs2_cluster_connection *new_conn;\n\n\tBUG_ON(group == NULL);\n\tBUG_ON(conn == NULL);\n\tBUG_ON(recovery_handler == NULL);\n\n\tif (grouplen > GROUP_NAME_MAX) {\n\t\trc = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tif (memcmp(&lproto->lp_max_version, &locking_max_version,\n\t\t   sizeof(struct ocfs2_protocol_version))) {\n\t\trc = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tnew_conn = kzalloc(sizeof(struct ocfs2_cluster_connection),\n\t\t\t   GFP_KERNEL);\n\tif (!new_conn) {\n\t\trc = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tstrlcpy(new_conn->cc_name, group, GROUP_NAME_MAX + 1);\n\tnew_conn->cc_namelen = grouplen;\n\tif (cluster_name_len)\n\t\tstrlcpy(new_conn->cc_cluster_name, cluster_name,\n\t\t\tCLUSTER_NAME_MAX + 1);\n\tnew_conn->cc_cluster_name_len = cluster_name_len;\n\tnew_conn->cc_recovery_handler = recovery_handler;\n\tnew_conn->cc_recovery_data = recovery_data;\n\n\tnew_conn->cc_proto = lproto;\n\t/* Start the new connection at our maximum compatibility level */\n\tnew_conn->cc_version = lproto->lp_max_version;\n\n\t/* This will pin the stack driver if successful */\n\trc = ocfs2_stack_driver_get(stack_name);\n\tif (rc)\n\t\tgoto out_free;\n\n\trc = active_stack->sp_ops->connect(new_conn);\n\tif (rc) {\n\t\tocfs2_stack_driver_put();\n\t\tgoto out_free;\n\t}\n\n\t*conn = new_conn;\n\nout_free:\n\tif (rc)\n\t\tkfree(new_conn);\n\nout:\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "osb->uuid_str"
          ],
          "line": 3009
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_ea_strlen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/xattr.c",
          "lines": "351-363",
          "snippet": "static inline unsigned int gfs2_ea_strlen(struct gfs2_ea_header *ea)\n{\n\tswitch (ea->ea_type) {\n\tcase GFS2_EATYPE_USR:\n\t\treturn 5 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SYS:\n\t\treturn 7 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SECURITY:\n\t\treturn 9 + ea->ea_name_len + 1;\n\tdefault:\n\t\treturn 0;\n\t}\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"trans.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"inode.h\"",
            "#include \"glock.h\"",
            "#include \"xattr.h\"",
            "#include \"acl.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/xattr.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"trans.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"xattr.h\"\n#include \"acl.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <asm/uaccess.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/xattr.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nstatic inline unsigned int gfs2_ea_strlen(struct gfs2_ea_header *ea)\n{\n\tswitch (ea->ea_type) {\n\tcase GFS2_EATYPE_USR:\n\t\treturn 5 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SYS:\n\t\treturn 7 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SECURITY:\n\t\treturn 9 + ea->ea_name_len + 1;\n\tdefault:\n\t\treturn 0;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "status"
          ],
          "line": 3000
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "osb->dc_task"
          ],
          "line": 2998
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "osb->dc_task"
          ],
          "line": 2997
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kthread_run",
          "args": [
            "ocfs2_downconvert_thread",
            "osb",
            "\"ocfs2dc\""
          ],
          "line": 2996
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "status"
          ],
          "line": 2991
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_dlm_init_debug",
          "args": [
            "osb"
          ],
          "line": 2989
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_dlm_init_debug",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlmglue.c",
          "lines": "2947-2967",
          "snippet": "static int ocfs2_dlm_init_debug(struct ocfs2_super *osb)\n{\n\tint ret = 0;\n\tstruct ocfs2_dlm_debug *dlm_debug = osb->osb_dlm_debug;\n\n\tdlm_debug->d_locking_state = debugfs_create_file(\"locking_state\",\n\t\t\t\t\t\t\t S_IFREG|S_IRUSR,\n\t\t\t\t\t\t\t osb->osb_debug_root,\n\t\t\t\t\t\t\t osb,\n\t\t\t\t\t\t\t &ocfs2_dlm_debug_fops);\n\tif (!dlm_debug->d_locking_state) {\n\t\tret = -EINVAL;\n\t\tmlog(ML_ERROR,\n\t\t     \"Unable to create locking state debugfs file.\\n\");\n\t\tgoto out;\n\t}\n\n\tocfs2_get_dlm_debug(dlm_debug);\nout:\n\treturn ret;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"refcounttree.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"stackglue.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dcache.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2_lockingver.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/time.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/kthread.h>",
            "#include <linux/mm.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void ocfs2_drop_osb_locks(struct ocfs2_super *osb);",
            "static const struct file_operations ocfs2_dlm_debug_fops = {\n\t.open =\t\tocfs2_dlm_debug_open,\n\t.release =\tocfs2_dlm_debug_release,\n\t.read =\t\tseq_read,\n\t.llseek =\tseq_lseek,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"stackglue.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dcache.h\"\n#include \"alloc.h\"\n#include \"ocfs2_lockingver.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/quotaops.h>\n#include <linux/time.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/pagemap.h>\n#include <linux/kthread.h>\n#include <linux/mm.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic void ocfs2_drop_osb_locks(struct ocfs2_super *osb);\nstatic const struct file_operations ocfs2_dlm_debug_fops = {\n\t.open =\t\tocfs2_dlm_debug_open,\n\t.release =\tocfs2_dlm_debug_release,\n\t.read =\t\tseq_read,\n\t.llseek =\tseq_lseek,\n};\n\nstatic int ocfs2_dlm_init_debug(struct ocfs2_super *osb)\n{\n\tint ret = 0;\n\tstruct ocfs2_dlm_debug *dlm_debug = osb->osb_dlm_debug;\n\n\tdlm_debug->d_locking_state = debugfs_create_file(\"locking_state\",\n\t\t\t\t\t\t\t S_IFREG|S_IRUSR,\n\t\t\t\t\t\t\t osb->osb_debug_root,\n\t\t\t\t\t\t\t osb,\n\t\t\t\t\t\t\t &ocfs2_dlm_debug_fops);\n\tif (!dlm_debug->d_locking_state) {\n\t\tret = -EINVAL;\n\t\tmlog(ML_ERROR,\n\t\t     \"Unable to create locking state debugfs file.\\n\");\n\t\tgoto out;\n\t}\n\n\tocfs2_get_dlm_debug(dlm_debug);\nout:\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_mount_local",
          "args": [
            "osb"
          ],
          "line": 2984
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_mount_local",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "668-671",
          "snippet": "static inline int ocfs2_mount_local(struct ocfs2_super *osb)\n{\n\treturn (osb->s_feature_incompat & OCFS2_FEATURE_INCOMPAT_LOCAL_MOUNT);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\nstatic inline int ocfs2_mount_local(struct ocfs2_super *osb)\n{\n\treturn (osb->s_feature_incompat & OCFS2_FEATURE_INCOMPAT_LOCAL_MOUNT);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"stackglue.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dcache.h\"\n#include \"alloc.h\"\n#include \"ocfs2_lockingver.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/quotaops.h>\n#include <linux/time.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/pagemap.h>\n#include <linux/kthread.h>\n#include <linux/mm.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic void ocfs2_drop_osb_locks(struct ocfs2_super *osb);\nstatic struct ocfs2_locking_protocol lproto = {\n\t.lp_max_version = {\n\t\t.pv_major = OCFS2_LOCKING_PROTOCOL_MAJOR,\n\t\t.pv_minor = OCFS2_LOCKING_PROTOCOL_MINOR,\n\t},\n\t.lp_lock_ast\t\t= ocfs2_locking_ast,\n\t.lp_blocking_ast\t= ocfs2_blocking_ast,\n\t.lp_unlock_ast\t\t= ocfs2_unlock_ast,\n};\n\nint ocfs2_dlm_init(struct ocfs2_super *osb)\n{\n\tint status = 0;\n\tstruct ocfs2_cluster_connection *conn = NULL;\n\n\tif (ocfs2_mount_local(osb)) {\n\t\tosb->node_num = 0;\n\t\tgoto local;\n\t}\n\n\tstatus = ocfs2_dlm_init_debug(osb);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\t/* launch downconvert thread */\n\tosb->dc_task = kthread_run(ocfs2_downconvert_thread, osb, \"ocfs2dc\");\n\tif (IS_ERR(osb->dc_task)) {\n\t\tstatus = PTR_ERR(osb->dc_task);\n\t\tosb->dc_task = NULL;\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\t/* for now, uuid == domain */\n\tstatus = ocfs2_cluster_connect(osb->osb_cluster_stack,\n\t\t\t\t       osb->osb_cluster_name,\n\t\t\t\t       strlen(osb->osb_cluster_name),\n\t\t\t\t       osb->uuid_str,\n\t\t\t\t       strlen(osb->uuid_str),\n\t\t\t\t       &lproto, ocfs2_do_node_down, osb,\n\t\t\t\t       &conn);\n\tif (status) {\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\tstatus = ocfs2_cluster_this_node(conn, &osb->node_num);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tmlog(ML_ERROR,\n\t\t     \"could not find this host's node number\\n\");\n\t\tocfs2_cluster_disconnect(conn, 0);\n\t\tgoto bail;\n\t}\n\nlocal:\n\tocfs2_super_lock_res_init(&osb->osb_super_lockres, osb);\n\tocfs2_rename_lock_res_init(&osb->osb_rename_lockres, osb);\n\tocfs2_nfs_sync_lock_res_init(&osb->osb_nfs_sync_lockres, osb);\n\tocfs2_orphan_scan_lock_res_init(&osb->osb_orphan_scan.os_lockres, osb);\n\n\tosb->cconn = conn;\n\n\tstatus = 0;\nbail:\n\tif (status < 0) {\n\t\tocfs2_dlm_shutdown_debug(osb);\n\t\tif (osb->dc_task)\n\t\t\tkthread_stop(osb->dc_task);\n\t}\n\n\treturn status;\n}"
  },
  {
    "function_name": "ocfs2_dlm_shutdown_debug",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlmglue.c",
    "lines": "2969-2977",
    "snippet": "static void ocfs2_dlm_shutdown_debug(struct ocfs2_super *osb)\n{\n\tstruct ocfs2_dlm_debug *dlm_debug = osb->osb_dlm_debug;\n\n\tif (dlm_debug) {\n\t\tdebugfs_remove(dlm_debug->d_locking_state);\n\t\tocfs2_put_dlm_debug(dlm_debug);\n\t}\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"refcounttree.h\"",
      "#include \"quota.h\"",
      "#include \"uptodate.h\"",
      "#include \"super.h\"",
      "#include \"slot_map.h\"",
      "#include \"stackglue.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"heartbeat.h\"",
      "#include \"file.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"dcache.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2_lockingver.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/time.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/kthread.h>",
      "#include <linux/mm.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void ocfs2_drop_osb_locks(struct ocfs2_super *osb);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ocfs2_put_dlm_debug",
          "args": [
            "dlm_debug"
          ],
          "line": 2975
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_put_dlm_debug",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlmglue.c",
          "lines": "2698-2702",
          "snippet": "void ocfs2_put_dlm_debug(struct ocfs2_dlm_debug *dlm_debug)\n{\n\tif (dlm_debug)\n\t\tkref_put(&dlm_debug->d_refcnt, ocfs2_dlm_debug_free);\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"refcounttree.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"stackglue.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dcache.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2_lockingver.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/time.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/kthread.h>",
            "#include <linux/mm.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"stackglue.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dcache.h\"\n#include \"alloc.h\"\n#include \"ocfs2_lockingver.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/quotaops.h>\n#include <linux/time.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/pagemap.h>\n#include <linux/kthread.h>\n#include <linux/mm.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nvoid ocfs2_put_dlm_debug(struct ocfs2_dlm_debug *dlm_debug)\n{\n\tif (dlm_debug)\n\t\tkref_put(&dlm_debug->d_refcnt, ocfs2_dlm_debug_free);\n}"
        }
      },
      {
        "call_info": {
          "callee": "debugfs_remove",
          "args": [
            "dlm_debug->d_locking_state"
          ],
          "line": 2974
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_blockcheck_stats_debugfs_remove",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/blockcheck.c",
          "lines": "318-321",
          "snippet": "void ocfs2_blockcheck_stats_debugfs_remove(struct ocfs2_blockcheck_stats *stats)\n{\n\tocfs2_blockcheck_debug_remove(stats);\n}",
          "includes": [
            "#include \"blockcheck.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/bitops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/crc32.h>",
            "#include <linux/types.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"blockcheck.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <asm/byteorder.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n#include <linux/debugfs.h>\n#include <linux/bitops.h>\n#include <linux/buffer_head.h>\n#include <linux/crc32.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n\nvoid ocfs2_blockcheck_stats_debugfs_remove(struct ocfs2_blockcheck_stats *stats)\n{\n\tocfs2_blockcheck_debug_remove(stats);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"stackglue.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dcache.h\"\n#include \"alloc.h\"\n#include \"ocfs2_lockingver.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/quotaops.h>\n#include <linux/time.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/pagemap.h>\n#include <linux/kthread.h>\n#include <linux/mm.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic void ocfs2_drop_osb_locks(struct ocfs2_super *osb);\n\nstatic void ocfs2_dlm_shutdown_debug(struct ocfs2_super *osb)\n{\n\tstruct ocfs2_dlm_debug *dlm_debug = osb->osb_dlm_debug;\n\n\tif (dlm_debug) {\n\t\tdebugfs_remove(dlm_debug->d_locking_state);\n\t\tocfs2_put_dlm_debug(dlm_debug);\n\t}\n}"
  },
  {
    "function_name": "ocfs2_dlm_init_debug",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlmglue.c",
    "lines": "2947-2967",
    "snippet": "static int ocfs2_dlm_init_debug(struct ocfs2_super *osb)\n{\n\tint ret = 0;\n\tstruct ocfs2_dlm_debug *dlm_debug = osb->osb_dlm_debug;\n\n\tdlm_debug->d_locking_state = debugfs_create_file(\"locking_state\",\n\t\t\t\t\t\t\t S_IFREG|S_IRUSR,\n\t\t\t\t\t\t\t osb->osb_debug_root,\n\t\t\t\t\t\t\t osb,\n\t\t\t\t\t\t\t &ocfs2_dlm_debug_fops);\n\tif (!dlm_debug->d_locking_state) {\n\t\tret = -EINVAL;\n\t\tmlog(ML_ERROR,\n\t\t     \"Unable to create locking state debugfs file.\\n\");\n\t\tgoto out;\n\t}\n\n\tocfs2_get_dlm_debug(dlm_debug);\nout:\n\treturn ret;\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"refcounttree.h\"",
      "#include \"quota.h\"",
      "#include \"uptodate.h\"",
      "#include \"super.h\"",
      "#include \"slot_map.h\"",
      "#include \"stackglue.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"heartbeat.h\"",
      "#include \"file.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"dcache.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2_lockingver.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/time.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/kthread.h>",
      "#include <linux/mm.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void ocfs2_drop_osb_locks(struct ocfs2_super *osb);",
      "static const struct file_operations ocfs2_dlm_debug_fops = {\n\t.open =\t\tocfs2_dlm_debug_open,\n\t.release =\tocfs2_dlm_debug_release,\n\t.read =\t\tseq_read,\n\t.llseek =\tseq_lseek,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ocfs2_get_dlm_debug",
          "args": [
            "dlm_debug"
          ],
          "line": 2964
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_get_dlm_debug",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlmglue.c",
          "lines": "2704-2707",
          "snippet": "static void ocfs2_get_dlm_debug(struct ocfs2_dlm_debug *debug)\n{\n\tkref_get(&debug->d_refcnt);\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"refcounttree.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"stackglue.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dcache.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2_lockingver.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/time.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/kthread.h>",
            "#include <linux/mm.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"stackglue.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dcache.h\"\n#include \"alloc.h\"\n#include \"ocfs2_lockingver.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/quotaops.h>\n#include <linux/time.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/pagemap.h>\n#include <linux/kthread.h>\n#include <linux/mm.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic void ocfs2_get_dlm_debug(struct ocfs2_dlm_debug *debug)\n{\n\tkref_get(&debug->d_refcnt);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog",
          "args": [
            "ML_ERROR",
            "\"Unable to create locking state debugfs file.\\n\""
          ],
          "line": 2959
        },
        "resolved": true,
        "details": {
          "function_name": "mlog_mask_show",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/cluster/masklog.c",
          "lines": "36-48",
          "snippet": "static ssize_t mlog_mask_show(u64 mask, char *buf)\n{\n\tchar *state;\n\n\tif (__mlog_test_u64(mask, mlog_and_bits))\n\t\tstate = \"allow\";\n\telse if (__mlog_test_u64(mask, mlog_not_bits))\n\t\tstate = \"deny\";\n\telse\n\t\tstate = \"off\";\n\n\treturn snprintf(buf, PAGE_SIZE, \"%s\\n\", state);\n}",
          "includes": [
            "#include \"masklog.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/string.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct mlog_bits mlog_and_bits = MLOG_BITS_RHS(MLOG_INITIAL_AND_MASK);",
            "struct mlog_bits mlog_not_bits = MLOG_BITS_RHS(0);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"masklog.h\"\n#include <asm/uaccess.h>\n#include <linux/string.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n\nstruct mlog_bits mlog_and_bits = MLOG_BITS_RHS(MLOG_INITIAL_AND_MASK);\nstruct mlog_bits mlog_not_bits = MLOG_BITS_RHS(0);\n\nstatic ssize_t mlog_mask_show(u64 mask, char *buf)\n{\n\tchar *state;\n\n\tif (__mlog_test_u64(mask, mlog_and_bits))\n\t\tstate = \"allow\";\n\telse if (__mlog_test_u64(mask, mlog_not_bits))\n\t\tstate = \"deny\";\n\telse\n\t\tstate = \"off\";\n\n\treturn snprintf(buf, PAGE_SIZE, \"%s\\n\", state);\n}"
        }
      },
      {
        "call_info": {
          "callee": "debugfs_create_file",
          "args": [
            "\"locking_state\"",
            "S_IFREG|S_IRUSR",
            "osb->osb_debug_root",
            "osb",
            "&ocfs2_dlm_debug_fops"
          ],
          "line": 2952
        },
        "resolved": true,
        "details": {
          "function_name": "debugfs_create_file",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/debugfs/inode.c",
          "lines": "321-346",
          "snippet": "struct dentry *debugfs_create_file(const char *name, umode_t mode,\n\t\t\t\t   struct dentry *parent, void *data,\n\t\t\t\t   const struct file_operations *fops)\n{\n\tstruct dentry *dentry;\n\tstruct inode *inode;\n\n\tif (!(mode & S_IFMT))\n\t\tmode |= S_IFREG;\n\tBUG_ON(!S_ISREG(mode));\n\tdentry = start_creating(name, parent);\n\n\tif (IS_ERR(dentry))\n\t\treturn NULL;\n\n\tinode = debugfs_get_inode(dentry->d_sb);\n\tif (unlikely(!inode))\n\t\treturn failed_creating(dentry);\n\n\tinode->i_mode = mode;\n\tinode->i_fop = fops ? fops : &debugfs_file_operations;\n\tinode->i_private = data;\n\td_instantiate(dentry, inode);\n\tfsnotify_create(dentry->d_parent->d_inode, dentry);\n\treturn end_creating(dentry);\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/magic.h>",
            "#include <linux/parser.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/string.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/namei.h>",
            "#include <linux/kobject.h>",
            "#include <linux/init.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/magic.h>\n#include <linux/parser.h>\n#include <linux/seq_file.h>\n#include <linux/string.h>\n#include <linux/fsnotify.h>\n#include <linux/debugfs.h>\n#include <linux/namei.h>\n#include <linux/kobject.h>\n#include <linux/init.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstruct dentry *debugfs_create_file(const char *name, umode_t mode,\n\t\t\t\t   struct dentry *parent, void *data,\n\t\t\t\t   const struct file_operations *fops)\n{\n\tstruct dentry *dentry;\n\tstruct inode *inode;\n\n\tif (!(mode & S_IFMT))\n\t\tmode |= S_IFREG;\n\tBUG_ON(!S_ISREG(mode));\n\tdentry = start_creating(name, parent);\n\n\tif (IS_ERR(dentry))\n\t\treturn NULL;\n\n\tinode = debugfs_get_inode(dentry->d_sb);\n\tif (unlikely(!inode))\n\t\treturn failed_creating(dentry);\n\n\tinode->i_mode = mode;\n\tinode->i_fop = fops ? fops : &debugfs_file_operations;\n\tinode->i_private = data;\n\td_instantiate(dentry, inode);\n\tfsnotify_create(dentry->d_parent->d_inode, dentry);\n\treturn end_creating(dentry);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"stackglue.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dcache.h\"\n#include \"alloc.h\"\n#include \"ocfs2_lockingver.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/quotaops.h>\n#include <linux/time.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/pagemap.h>\n#include <linux/kthread.h>\n#include <linux/mm.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic void ocfs2_drop_osb_locks(struct ocfs2_super *osb);\nstatic const struct file_operations ocfs2_dlm_debug_fops = {\n\t.open =\t\tocfs2_dlm_debug_open,\n\t.release =\tocfs2_dlm_debug_release,\n\t.read =\t\tseq_read,\n\t.llseek =\tseq_lseek,\n};\n\nstatic int ocfs2_dlm_init_debug(struct ocfs2_super *osb)\n{\n\tint ret = 0;\n\tstruct ocfs2_dlm_debug *dlm_debug = osb->osb_dlm_debug;\n\n\tdlm_debug->d_locking_state = debugfs_create_file(\"locking_state\",\n\t\t\t\t\t\t\t S_IFREG|S_IRUSR,\n\t\t\t\t\t\t\t osb->osb_debug_root,\n\t\t\t\t\t\t\t osb,\n\t\t\t\t\t\t\t &ocfs2_dlm_debug_fops);\n\tif (!dlm_debug->d_locking_state) {\n\t\tret = -EINVAL;\n\t\tmlog(ML_ERROR,\n\t\t     \"Unable to create locking state debugfs file.\\n\");\n\t\tgoto out;\n\t}\n\n\tocfs2_get_dlm_debug(dlm_debug);\nout:\n\treturn ret;\n}"
  },
  {
    "function_name": "ocfs2_dlm_debug_open",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlmglue.c",
    "lines": "2918-2938",
    "snippet": "static int ocfs2_dlm_debug_open(struct inode *inode, struct file *file)\n{\n\tstruct ocfs2_dlm_seq_priv *priv;\n\tstruct ocfs2_super *osb;\n\n\tpriv = __seq_open_private(file, &ocfs2_dlm_seq_ops, sizeof(*priv));\n\tif (!priv) {\n\t\tmlog_errno(-ENOMEM);\n\t\treturn -ENOMEM;\n\t}\n\n\tosb = inode->i_private;\n\tocfs2_get_dlm_debug(osb->osb_dlm_debug);\n\tpriv->p_dlm_debug = osb->osb_dlm_debug;\n\tINIT_LIST_HEAD(&priv->p_iter_res.l_debug_list);\n\n\tocfs2_add_lockres_tracking(&priv->p_iter_res,\n\t\t\t\t   priv->p_dlm_debug);\n\n\treturn 0;\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"refcounttree.h\"",
      "#include \"quota.h\"",
      "#include \"uptodate.h\"",
      "#include \"super.h\"",
      "#include \"slot_map.h\"",
      "#include \"stackglue.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"heartbeat.h\"",
      "#include \"file.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"dcache.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2_lockingver.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/time.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/kthread.h>",
      "#include <linux/mm.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void ocfs2_drop_osb_locks(struct ocfs2_super *osb);",
      "static const struct seq_operations ocfs2_dlm_seq_ops = {\n\t.start =\tocfs2_dlm_seq_start,\n\t.stop =\t\tocfs2_dlm_seq_stop,\n\t.next =\t\tocfs2_dlm_seq_next,\n\t.show =\t\tocfs2_dlm_seq_show,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ocfs2_add_lockres_tracking",
          "args": [
            "&priv->p_iter_res",
            "priv->p_dlm_debug"
          ],
          "line": 2934
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_add_lockres_tracking",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlmglue.c",
          "lines": "413-421",
          "snippet": "static void ocfs2_add_lockres_tracking(struct ocfs2_lock_res *res,\n\t\t\t\t       struct ocfs2_dlm_debug *dlm_debug)\n{\n\tmlog(0, \"Add tracking for lockres %s\\n\", res->l_name);\n\n\tspin_lock(&ocfs2_dlm_tracking_lock);\n\tlist_add(&res->l_debug_list, &dlm_debug->d_lockres_tracking);\n\tspin_unlock(&ocfs2_dlm_tracking_lock);\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"refcounttree.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"stackglue.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dcache.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2_lockingver.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/time.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/kthread.h>",
            "#include <linux/mm.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct ocfs2_super *ocfs2_get_dentry_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_inode_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_file_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_qinfo_osb(struct ocfs2_lock_res *lockres);",
            "static void ocfs2_set_meta_lvb(struct ocfs2_lock_res *lockres);",
            "static void ocfs2_dentry_post_unlock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres);",
            "static void ocfs2_set_qinfo_lvb(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_downconvert_action(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_convert_action(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_attach_action(struct ocfs2_lock_res *lockres);",
            "static void ocfs2_schedule_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static void ocfs2_downconvert_on_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static int ocfs2_prepare_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\t        struct ocfs2_lock_res *lockres);",
            "static int ocfs2_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static DEFINE_SPINLOCK(ocfs2_dlm_tracking_lock);",
            "static void ocfs2_process_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *lockres);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"stackglue.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dcache.h\"\n#include \"alloc.h\"\n#include \"ocfs2_lockingver.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/quotaops.h>\n#include <linux/time.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/pagemap.h>\n#include <linux/kthread.h>\n#include <linux/mm.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic struct ocfs2_super *ocfs2_get_dentry_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_inode_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_file_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_qinfo_osb(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_set_meta_lvb(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_dentry_post_unlock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres);\nstatic void ocfs2_set_qinfo_lvb(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_downconvert_action(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_convert_action(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_attach_action(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_schedule_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_downconvert_on_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic int ocfs2_prepare_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\t        struct ocfs2_lock_res *lockres);\nstatic int ocfs2_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic DEFINE_SPINLOCK(ocfs2_dlm_tracking_lock);\nstatic void ocfs2_process_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *lockres);\n\nstatic void ocfs2_add_lockres_tracking(struct ocfs2_lock_res *res,\n\t\t\t\t       struct ocfs2_dlm_debug *dlm_debug)\n{\n\tmlog(0, \"Add tracking for lockres %s\\n\", res->l_name);\n\n\tspin_lock(&ocfs2_dlm_tracking_lock);\n\tlist_add(&res->l_debug_list, &dlm_debug->d_lockres_tracking);\n\tspin_unlock(&ocfs2_dlm_tracking_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&priv->p_iter_res.l_debug_list"
          ],
          "line": 2932
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_get_dlm_debug",
          "args": [
            "osb->osb_dlm_debug"
          ],
          "line": 2930
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_get_dlm_debug",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlmglue.c",
          "lines": "2704-2707",
          "snippet": "static void ocfs2_get_dlm_debug(struct ocfs2_dlm_debug *debug)\n{\n\tkref_get(&debug->d_refcnt);\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"refcounttree.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"stackglue.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dcache.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2_lockingver.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/time.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/kthread.h>",
            "#include <linux/mm.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"stackglue.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dcache.h\"\n#include \"alloc.h\"\n#include \"ocfs2_lockingver.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/quotaops.h>\n#include <linux/time.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/pagemap.h>\n#include <linux/kthread.h>\n#include <linux/mm.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic void ocfs2_get_dlm_debug(struct ocfs2_dlm_debug *debug)\n{\n\tkref_get(&debug->d_refcnt);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "-ENOMEM"
          ],
          "line": 2925
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__seq_open_private",
          "args": [
            "file",
            "&ocfs2_dlm_seq_ops",
            "sizeof(*priv)"
          ],
          "line": 2923
        },
        "resolved": true,
        "details": {
          "function_name": "__seq_open_private",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/seq_file.c",
          "lines": "615-638",
          "snippet": "void *__seq_open_private(struct file *f, const struct seq_operations *ops,\n\t\tint psize)\n{\n\tint rc;\n\tvoid *private;\n\tstruct seq_file *seq;\n\n\tprivate = kzalloc(psize, GFP_KERNEL);\n\tif (private == NULL)\n\t\tgoto out;\n\n\trc = seq_open(f, ops);\n\tif (rc < 0)\n\t\tgoto out_free;\n\n\tseq = f->private_data;\n\tseq->private = private;\n\treturn private;\n\nout_free:\n\tkfree(private);\nout:\n\treturn NULL;\n}",
          "includes": [
            "#include <asm/page.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/mm.h>",
            "#include <linux/cred.h>",
            "#include <linux/slab.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/export.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <linux/mm.h>\n#include <linux/cred.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/seq_file.h>\n#include <linux/export.h>\n#include <linux/fs.h>\n\nvoid *__seq_open_private(struct file *f, const struct seq_operations *ops,\n\t\tint psize)\n{\n\tint rc;\n\tvoid *private;\n\tstruct seq_file *seq;\n\n\tprivate = kzalloc(psize, GFP_KERNEL);\n\tif (private == NULL)\n\t\tgoto out;\n\n\trc = seq_open(f, ops);\n\tif (rc < 0)\n\t\tgoto out_free;\n\n\tseq = f->private_data;\n\tseq->private = private;\n\treturn private;\n\nout_free:\n\tkfree(private);\nout:\n\treturn NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"stackglue.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dcache.h\"\n#include \"alloc.h\"\n#include \"ocfs2_lockingver.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/quotaops.h>\n#include <linux/time.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/pagemap.h>\n#include <linux/kthread.h>\n#include <linux/mm.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic void ocfs2_drop_osb_locks(struct ocfs2_super *osb);\nstatic const struct seq_operations ocfs2_dlm_seq_ops = {\n\t.start =\tocfs2_dlm_seq_start,\n\t.stop =\t\tocfs2_dlm_seq_stop,\n\t.next =\t\tocfs2_dlm_seq_next,\n\t.show =\t\tocfs2_dlm_seq_show,\n};\n\nstatic int ocfs2_dlm_debug_open(struct inode *inode, struct file *file)\n{\n\tstruct ocfs2_dlm_seq_priv *priv;\n\tstruct ocfs2_super *osb;\n\n\tpriv = __seq_open_private(file, &ocfs2_dlm_seq_ops, sizeof(*priv));\n\tif (!priv) {\n\t\tmlog_errno(-ENOMEM);\n\t\treturn -ENOMEM;\n\t}\n\n\tosb = inode->i_private;\n\tocfs2_get_dlm_debug(osb->osb_dlm_debug);\n\tpriv->p_dlm_debug = osb->osb_dlm_debug;\n\tINIT_LIST_HEAD(&priv->p_iter_res.l_debug_list);\n\n\tocfs2_add_lockres_tracking(&priv->p_iter_res,\n\t\t\t\t   priv->p_dlm_debug);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "ocfs2_dlm_debug_release",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlmglue.c",
    "lines": "2907-2916",
    "snippet": "static int ocfs2_dlm_debug_release(struct inode *inode, struct file *file)\n{\n\tstruct seq_file *seq = file->private_data;\n\tstruct ocfs2_dlm_seq_priv *priv = seq->private;\n\tstruct ocfs2_lock_res *res = &priv->p_iter_res;\n\n\tocfs2_remove_lockres_tracking(res);\n\tocfs2_put_dlm_debug(priv->p_dlm_debug);\n\treturn seq_release_private(inode, file);\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"refcounttree.h\"",
      "#include \"quota.h\"",
      "#include \"uptodate.h\"",
      "#include \"super.h\"",
      "#include \"slot_map.h\"",
      "#include \"stackglue.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"heartbeat.h\"",
      "#include \"file.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"dcache.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2_lockingver.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/time.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/kthread.h>",
      "#include <linux/mm.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "seq_release_private",
          "args": [
            "inode",
            "file"
          ],
          "line": 2915
        },
        "resolved": true,
        "details": {
          "function_name": "seq_release_private",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/seq_file.c",
          "lines": "605-612",
          "snippet": "int seq_release_private(struct inode *inode, struct file *file)\n{\n\tstruct seq_file *seq = file->private_data;\n\n\tkfree(seq->private);\n\tseq->private = NULL;\n\treturn seq_release(inode, file);\n}",
          "includes": [
            "#include <asm/page.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/mm.h>",
            "#include <linux/cred.h>",
            "#include <linux/slab.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/export.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <linux/mm.h>\n#include <linux/cred.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/seq_file.h>\n#include <linux/export.h>\n#include <linux/fs.h>\n\nint seq_release_private(struct inode *inode, struct file *file)\n{\n\tstruct seq_file *seq = file->private_data;\n\n\tkfree(seq->private);\n\tseq->private = NULL;\n\treturn seq_release(inode, file);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_put_dlm_debug",
          "args": [
            "priv->p_dlm_debug"
          ],
          "line": 2914
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_put_dlm_debug",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlmglue.c",
          "lines": "2698-2702",
          "snippet": "void ocfs2_put_dlm_debug(struct ocfs2_dlm_debug *dlm_debug)\n{\n\tif (dlm_debug)\n\t\tkref_put(&dlm_debug->d_refcnt, ocfs2_dlm_debug_free);\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"refcounttree.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"stackglue.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dcache.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2_lockingver.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/time.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/kthread.h>",
            "#include <linux/mm.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"stackglue.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dcache.h\"\n#include \"alloc.h\"\n#include \"ocfs2_lockingver.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/quotaops.h>\n#include <linux/time.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/pagemap.h>\n#include <linux/kthread.h>\n#include <linux/mm.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nvoid ocfs2_put_dlm_debug(struct ocfs2_dlm_debug *dlm_debug)\n{\n\tif (dlm_debug)\n\t\tkref_put(&dlm_debug->d_refcnt, ocfs2_dlm_debug_free);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_remove_lockres_tracking",
          "args": [
            "res"
          ],
          "line": 2913
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_remove_lockres_tracking",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlmglue.c",
          "lines": "423-429",
          "snippet": "static void ocfs2_remove_lockres_tracking(struct ocfs2_lock_res *res)\n{\n\tspin_lock(&ocfs2_dlm_tracking_lock);\n\tif (!list_empty(&res->l_debug_list))\n\t\tlist_del_init(&res->l_debug_list);\n\tspin_unlock(&ocfs2_dlm_tracking_lock);\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"refcounttree.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"stackglue.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dcache.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2_lockingver.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/time.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/kthread.h>",
            "#include <linux/mm.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_SPINLOCK(ocfs2_dlm_tracking_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"stackglue.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dcache.h\"\n#include \"alloc.h\"\n#include \"ocfs2_lockingver.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/quotaops.h>\n#include <linux/time.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/pagemap.h>\n#include <linux/kthread.h>\n#include <linux/mm.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic DEFINE_SPINLOCK(ocfs2_dlm_tracking_lock);\n\nstatic void ocfs2_remove_lockres_tracking(struct ocfs2_lock_res *res)\n{\n\tspin_lock(&ocfs2_dlm_tracking_lock);\n\tif (!list_empty(&res->l_debug_list))\n\t\tlist_del_init(&res->l_debug_list);\n\tspin_unlock(&ocfs2_dlm_tracking_lock);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"stackglue.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dcache.h\"\n#include \"alloc.h\"\n#include \"ocfs2_lockingver.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/quotaops.h>\n#include <linux/time.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/pagemap.h>\n#include <linux/kthread.h>\n#include <linux/mm.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic int ocfs2_dlm_debug_release(struct inode *inode, struct file *file)\n{\n\tstruct seq_file *seq = file->private_data;\n\tstruct ocfs2_dlm_seq_priv *priv = seq->private;\n\tstruct ocfs2_lock_res *res = &priv->p_iter_res;\n\n\tocfs2_remove_lockres_tracking(res);\n\tocfs2_put_dlm_debug(priv->p_dlm_debug);\n\treturn seq_release_private(inode, file);\n}"
  },
  {
    "function_name": "ocfs2_dlm_seq_show",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlmglue.c",
    "lines": "2814-2898",
    "snippet": "static int ocfs2_dlm_seq_show(struct seq_file *m, void *v)\n{\n\tint i;\n\tchar *lvb;\n\tstruct ocfs2_lock_res *lockres = v;\n\n\tif (!lockres)\n\t\treturn -EINVAL;\n\n\tseq_printf(m, \"0x%x\\t\", OCFS2_DLM_DEBUG_STR_VERSION);\n\n\tif (lockres->l_type == OCFS2_LOCK_TYPE_DENTRY)\n\t\tseq_printf(m, \"%.*s%08x\\t\", OCFS2_DENTRY_LOCK_INO_START - 1,\n\t\t\t   lockres->l_name,\n\t\t\t   (unsigned int)ocfs2_get_dentry_lock_ino(lockres));\n\telse\n\t\tseq_printf(m, \"%.*s\\t\", OCFS2_LOCK_ID_MAX_LEN, lockres->l_name);\n\n\tseq_printf(m, \"%d\\t\"\n\t\t   \"0x%lx\\t\"\n\t\t   \"0x%x\\t\"\n\t\t   \"0x%x\\t\"\n\t\t   \"%u\\t\"\n\t\t   \"%u\\t\"\n\t\t   \"%d\\t\"\n\t\t   \"%d\\t\",\n\t\t   lockres->l_level,\n\t\t   lockres->l_flags,\n\t\t   lockres->l_action,\n\t\t   lockres->l_unlock_action,\n\t\t   lockres->l_ro_holders,\n\t\t   lockres->l_ex_holders,\n\t\t   lockres->l_requested,\n\t\t   lockres->l_blocking);\n\n\t/* Dump the raw LVB */\n\tlvb = ocfs2_dlm_lvb(&lockres->l_lksb);\n\tfor(i = 0; i < DLM_LVB_LEN; i++)\n\t\tseq_printf(m, \"0x%x\\t\", lvb[i]);\n\n#ifdef CONFIG_OCFS2_FS_STATS\n# define lock_num_prmode(_l)\t\t((_l)->l_lock_prmode.ls_gets)\n# define lock_num_exmode(_l)\t\t((_l)->l_lock_exmode.ls_gets)\n# define lock_num_prmode_failed(_l)\t((_l)->l_lock_prmode.ls_fail)\n# define lock_num_exmode_failed(_l)\t((_l)->l_lock_exmode.ls_fail)\n# define lock_total_prmode(_l)\t\t((_l)->l_lock_prmode.ls_total)\n# define lock_total_exmode(_l)\t\t((_l)->l_lock_exmode.ls_total)\n# define lock_max_prmode(_l)\t\t((_l)->l_lock_prmode.ls_max)\n# define lock_max_exmode(_l)\t\t((_l)->l_lock_exmode.ls_max)\n# define lock_refresh(_l)\t\t((_l)->l_lock_refresh)\n#else\n# define lock_num_prmode(_l)\t\t(0)\n# define lock_num_exmode(_l)\t\t(0)\n# define lock_num_prmode_failed(_l)\t(0)\n# define lock_num_exmode_failed(_l)\t(0)\n# define lock_total_prmode(_l)\t\t(0ULL)\n# define lock_total_exmode(_l)\t\t(0ULL)\n# define lock_max_prmode(_l)\t\t(0)\n# define lock_max_exmode(_l)\t\t(0)\n# define lock_refresh(_l)\t\t(0)\n#endif\n\t/* The following seq_print was added in version 2 of this output */\n\tseq_printf(m, \"%u\\t\"\n\t\t   \"%u\\t\"\n\t\t   \"%u\\t\"\n\t\t   \"%u\\t\"\n\t\t   \"%llu\\t\"\n\t\t   \"%llu\\t\"\n\t\t   \"%u\\t\"\n\t\t   \"%u\\t\"\n\t\t   \"%u\\t\",\n\t\t   lock_num_prmode(lockres),\n\t\t   lock_num_exmode(lockres),\n\t\t   lock_num_prmode_failed(lockres),\n\t\t   lock_num_exmode_failed(lockres),\n\t\t   lock_total_prmode(lockres),\n\t\t   lock_total_exmode(lockres),\n\t\t   lock_max_prmode(lockres),\n\t\t   lock_max_exmode(lockres),\n\t\t   lock_refresh(lockres));\n\n\t/* End the line */\n\tseq_printf(m, \"\\n\");\n\treturn 0;\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"refcounttree.h\"",
      "#include \"quota.h\"",
      "#include \"uptodate.h\"",
      "#include \"super.h\"",
      "#include \"slot_map.h\"",
      "#include \"stackglue.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"heartbeat.h\"",
      "#include \"file.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"dcache.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2_lockingver.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/time.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/kthread.h>",
      "#include <linux/mm.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [
      "#define OCFS2_DLM_DEBUG_STR_VERSION 3"
    ],
    "globals_used": [
      "static struct ocfs2_super *ocfs2_get_dentry_osb(struct ocfs2_lock_res *lockres);",
      "static struct ocfs2_super *ocfs2_get_inode_osb(struct ocfs2_lock_res *lockres);",
      "static struct ocfs2_super *ocfs2_get_file_osb(struct ocfs2_lock_res *lockres);",
      "static struct ocfs2_super *ocfs2_get_qinfo_osb(struct ocfs2_lock_res *lockres);",
      "static void ocfs2_set_meta_lvb(struct ocfs2_lock_res *lockres);",
      "static void ocfs2_dentry_post_unlock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres);",
      "static void ocfs2_set_qinfo_lvb(struct ocfs2_lock_res *lockres);",
      "static inline void ocfs2_generic_handle_downconvert_action(struct ocfs2_lock_res *lockres);",
      "static inline void ocfs2_generic_handle_convert_action(struct ocfs2_lock_res *lockres);",
      "static inline void ocfs2_generic_handle_attach_action(struct ocfs2_lock_res *lockres);",
      "static void ocfs2_schedule_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);",
      "static void ocfs2_downconvert_on_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);",
      "static int ocfs2_prepare_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\t        struct ocfs2_lock_res *lockres);",
      "static int ocfs2_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres);",
      "static void ocfs2_process_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *lockres);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "seq_printf",
          "args": [
            "m",
            "\"\\n\""
          ],
          "line": 2896
        },
        "resolved": true,
        "details": {
          "function_name": "seq_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/seq_file.c",
          "lines": "416-426",
          "snippet": "int seq_printf(struct seq_file *m, const char *f, ...)\n{\n\tint ret;\n\tva_list args;\n\n\tva_start(args, f);\n\tret = seq_vprintf(m, f, args);\n\tva_end(args);\n\n\treturn ret;\n}",
          "includes": [
            "#include <asm/page.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/mm.h>",
            "#include <linux/cred.h>",
            "#include <linux/slab.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/export.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <linux/mm.h>\n#include <linux/cred.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/seq_file.h>\n#include <linux/export.h>\n#include <linux/fs.h>\n\nint seq_printf(struct seq_file *m, const char *f, ...)\n{\n\tint ret;\n\tva_list args;\n\n\tva_start(args, f);\n\tret = seq_vprintf(m, f, args);\n\tva_end(args);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "lock_refresh",
          "args": [
            "lockres"
          ],
          "line": 2893
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_track_lock_refresh",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlmglue.c",
          "lines": "488-490",
          "snippet": "static inline void ocfs2_track_lock_refresh(struct ocfs2_lock_res *lockres)\n{\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"refcounttree.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"stackglue.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dcache.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2_lockingver.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/time.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/kthread.h>",
            "#include <linux/mm.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct ocfs2_super *ocfs2_get_dentry_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_inode_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_file_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_qinfo_osb(struct ocfs2_lock_res *lockres);",
            "static void ocfs2_set_meta_lvb(struct ocfs2_lock_res *lockres);",
            "static void ocfs2_dentry_post_unlock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres);",
            "static void ocfs2_set_qinfo_lvb(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_downconvert_action(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_convert_action(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_attach_action(struct ocfs2_lock_res *lockres);",
            "static void ocfs2_schedule_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static void ocfs2_downconvert_on_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static int ocfs2_prepare_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\t        struct ocfs2_lock_res *lockres);",
            "static int ocfs2_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static void ocfs2_process_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *lockres);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"stackglue.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dcache.h\"\n#include \"alloc.h\"\n#include \"ocfs2_lockingver.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/quotaops.h>\n#include <linux/time.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/pagemap.h>\n#include <linux/kthread.h>\n#include <linux/mm.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic struct ocfs2_super *ocfs2_get_dentry_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_inode_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_file_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_qinfo_osb(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_set_meta_lvb(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_dentry_post_unlock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres);\nstatic void ocfs2_set_qinfo_lvb(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_downconvert_action(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_convert_action(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_attach_action(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_schedule_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_downconvert_on_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic int ocfs2_prepare_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\t        struct ocfs2_lock_res *lockres);\nstatic int ocfs2_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_process_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *lockres);\n\nstatic inline void ocfs2_track_lock_refresh(struct ocfs2_lock_res *lockres)\n{\n}"
        }
      },
      {
        "call_info": {
          "callee": "lock_max_exmode",
          "args": [
            "lockres"
          ],
          "line": 2892
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lock_max_prmode",
          "args": [
            "lockres"
          ],
          "line": 2891
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lock_total_exmode",
          "args": [
            "lockres"
          ],
          "line": 2890
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lock_total_prmode",
          "args": [
            "lockres"
          ],
          "line": 2889
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lock_num_exmode_failed",
          "args": [
            "lockres"
          ],
          "line": 2888
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lock_num_prmode_failed",
          "args": [
            "lockres"
          ],
          "line": 2887
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lock_num_exmode",
          "args": [
            "lockres"
          ],
          "line": 2886
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lock_num_prmode",
          "args": [
            "lockres"
          ],
          "line": 2885
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_dlm_lvb",
          "args": [
            "&lockres->l_lksb"
          ],
          "line": 2850
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_dlm_lvb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/stackglue.c",
          "lines": "279-282",
          "snippet": "void *ocfs2_dlm_lvb(struct ocfs2_dlm_lksb *lksb)\n{\n\treturn active_stack->sp_ops->lock_lvb(lksb);\n}",
          "includes": [
            "#include \"stackglue.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include <linux/sysctl.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/fs.h>",
            "#include <linux/kmod.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/list.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct ocfs2_stack_plugin *active_stack;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"stackglue.h\"\n#include \"ocfs2_fs.h\"\n#include <linux/sysctl.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/fs.h>\n#include <linux/kmod.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/spinlock.h>\n#include <linux/list.h>\n\nstatic struct ocfs2_stack_plugin *active_stack;\n\nvoid *ocfs2_dlm_lvb(struct ocfs2_dlm_lksb *lksb)\n{\n\treturn active_stack->sp_ops->lock_lvb(lksb);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_get_dentry_lock_ino",
          "args": [
            "lockres"
          ],
          "line": 2828
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_get_dentry_lock_ino",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlmglue.c",
          "lines": "585-593",
          "snippet": "static __u64 ocfs2_get_dentry_lock_ino(struct ocfs2_lock_res *lockres)\n{\n\t__be64 inode_blkno_be;\n\n\tmemcpy(&inode_blkno_be, &lockres->l_name[OCFS2_DENTRY_LOCK_INO_START],\n\t       sizeof(__be64));\n\n\treturn be64_to_cpu(inode_blkno_be);\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"refcounttree.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"stackglue.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dcache.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2_lockingver.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/time.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/kthread.h>",
            "#include <linux/mm.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct ocfs2_super *ocfs2_get_dentry_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_inode_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_file_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_qinfo_osb(struct ocfs2_lock_res *lockres);",
            "static void ocfs2_set_meta_lvb(struct ocfs2_lock_res *lockres);",
            "static void ocfs2_dentry_post_unlock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres);",
            "static void ocfs2_set_qinfo_lvb(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_downconvert_action(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_convert_action(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_attach_action(struct ocfs2_lock_res *lockres);",
            "static void ocfs2_schedule_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static void ocfs2_downconvert_on_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static int ocfs2_prepare_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\t        struct ocfs2_lock_res *lockres);",
            "static int ocfs2_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static void ocfs2_process_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *lockres);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"stackglue.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dcache.h\"\n#include \"alloc.h\"\n#include \"ocfs2_lockingver.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/quotaops.h>\n#include <linux/time.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/pagemap.h>\n#include <linux/kthread.h>\n#include <linux/mm.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic struct ocfs2_super *ocfs2_get_dentry_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_inode_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_file_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_qinfo_osb(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_set_meta_lvb(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_dentry_post_unlock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres);\nstatic void ocfs2_set_qinfo_lvb(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_downconvert_action(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_convert_action(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_attach_action(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_schedule_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_downconvert_on_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic int ocfs2_prepare_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\t        struct ocfs2_lock_res *lockres);\nstatic int ocfs2_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_process_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *lockres);\n\nstatic __u64 ocfs2_get_dentry_lock_ino(struct ocfs2_lock_res *lockres)\n{\n\t__be64 inode_blkno_be;\n\n\tmemcpy(&inode_blkno_be, &lockres->l_name[OCFS2_DENTRY_LOCK_INO_START],\n\t       sizeof(__be64));\n\n\treturn be64_to_cpu(inode_blkno_be);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"stackglue.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dcache.h\"\n#include \"alloc.h\"\n#include \"ocfs2_lockingver.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/quotaops.h>\n#include <linux/time.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/pagemap.h>\n#include <linux/kthread.h>\n#include <linux/mm.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\n#define OCFS2_DLM_DEBUG_STR_VERSION 3\n\nstatic struct ocfs2_super *ocfs2_get_dentry_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_inode_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_file_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_qinfo_osb(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_set_meta_lvb(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_dentry_post_unlock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres);\nstatic void ocfs2_set_qinfo_lvb(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_downconvert_action(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_convert_action(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_attach_action(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_schedule_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_downconvert_on_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic int ocfs2_prepare_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\t        struct ocfs2_lock_res *lockres);\nstatic int ocfs2_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_process_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *lockres);\n\nstatic int ocfs2_dlm_seq_show(struct seq_file *m, void *v)\n{\n\tint i;\n\tchar *lvb;\n\tstruct ocfs2_lock_res *lockres = v;\n\n\tif (!lockres)\n\t\treturn -EINVAL;\n\n\tseq_printf(m, \"0x%x\\t\", OCFS2_DLM_DEBUG_STR_VERSION);\n\n\tif (lockres->l_type == OCFS2_LOCK_TYPE_DENTRY)\n\t\tseq_printf(m, \"%.*s%08x\\t\", OCFS2_DENTRY_LOCK_INO_START - 1,\n\t\t\t   lockres->l_name,\n\t\t\t   (unsigned int)ocfs2_get_dentry_lock_ino(lockres));\n\telse\n\t\tseq_printf(m, \"%.*s\\t\", OCFS2_LOCK_ID_MAX_LEN, lockres->l_name);\n\n\tseq_printf(m, \"%d\\t\"\n\t\t   \"0x%lx\\t\"\n\t\t   \"0x%x\\t\"\n\t\t   \"0x%x\\t\"\n\t\t   \"%u\\t\"\n\t\t   \"%u\\t\"\n\t\t   \"%d\\t\"\n\t\t   \"%d\\t\",\n\t\t   lockres->l_level,\n\t\t   lockres->l_flags,\n\t\t   lockres->l_action,\n\t\t   lockres->l_unlock_action,\n\t\t   lockres->l_ro_holders,\n\t\t   lockres->l_ex_holders,\n\t\t   lockres->l_requested,\n\t\t   lockres->l_blocking);\n\n\t/* Dump the raw LVB */\n\tlvb = ocfs2_dlm_lvb(&lockres->l_lksb);\n\tfor(i = 0; i < DLM_LVB_LEN; i++)\n\t\tseq_printf(m, \"0x%x\\t\", lvb[i]);\n\n#ifdef CONFIG_OCFS2_FS_STATS\n# define lock_num_prmode(_l)\t\t((_l)->l_lock_prmode.ls_gets)\n# define lock_num_exmode(_l)\t\t((_l)->l_lock_exmode.ls_gets)\n# define lock_num_prmode_failed(_l)\t((_l)->l_lock_prmode.ls_fail)\n# define lock_num_exmode_failed(_l)\t((_l)->l_lock_exmode.ls_fail)\n# define lock_total_prmode(_l)\t\t((_l)->l_lock_prmode.ls_total)\n# define lock_total_exmode(_l)\t\t((_l)->l_lock_exmode.ls_total)\n# define lock_max_prmode(_l)\t\t((_l)->l_lock_prmode.ls_max)\n# define lock_max_exmode(_l)\t\t((_l)->l_lock_exmode.ls_max)\n# define lock_refresh(_l)\t\t((_l)->l_lock_refresh)\n#else\n# define lock_num_prmode(_l)\t\t(0)\n# define lock_num_exmode(_l)\t\t(0)\n# define lock_num_prmode_failed(_l)\t(0)\n# define lock_num_exmode_failed(_l)\t(0)\n# define lock_total_prmode(_l)\t\t(0ULL)\n# define lock_total_exmode(_l)\t\t(0ULL)\n# define lock_max_prmode(_l)\t\t(0)\n# define lock_max_exmode(_l)\t\t(0)\n# define lock_refresh(_l)\t\t(0)\n#endif\n\t/* The following seq_print was added in version 2 of this output */\n\tseq_printf(m, \"%u\\t\"\n\t\t   \"%u\\t\"\n\t\t   \"%u\\t\"\n\t\t   \"%u\\t\"\n\t\t   \"%llu\\t\"\n\t\t   \"%llu\\t\"\n\t\t   \"%u\\t\"\n\t\t   \"%u\\t\"\n\t\t   \"%u\\t\",\n\t\t   lock_num_prmode(lockres),\n\t\t   lock_num_exmode(lockres),\n\t\t   lock_num_prmode_failed(lockres),\n\t\t   lock_num_exmode_failed(lockres),\n\t\t   lock_total_prmode(lockres),\n\t\t   lock_total_exmode(lockres),\n\t\t   lock_max_prmode(lockres),\n\t\t   lock_max_exmode(lockres),\n\t\t   lock_refresh(lockres));\n\n\t/* End the line */\n\tseq_printf(m, \"\\n\");\n\treturn 0;\n}"
  },
  {
    "function_name": "ocfs2_dlm_seq_next",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlmglue.c",
    "lines": "2786-2803",
    "snippet": "static void *ocfs2_dlm_seq_next(struct seq_file *m, void *v, loff_t *pos)\n{\n\tstruct ocfs2_dlm_seq_priv *priv = m->private;\n\tstruct ocfs2_lock_res *iter = v;\n\tstruct ocfs2_lock_res *dummy = &priv->p_iter_res;\n\n\tspin_lock(&ocfs2_dlm_tracking_lock);\n\titer = ocfs2_dlm_next_res(iter, priv);\n\tlist_del_init(&dummy->l_debug_list);\n\tif (iter) {\n\t\tlist_add(&dummy->l_debug_list, &iter->l_debug_list);\n\t\tpriv->p_tmp_res = *iter;\n\t\titer = &priv->p_tmp_res;\n\t}\n\tspin_unlock(&ocfs2_dlm_tracking_lock);\n\n\treturn iter;\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"refcounttree.h\"",
      "#include \"quota.h\"",
      "#include \"uptodate.h\"",
      "#include \"super.h\"",
      "#include \"slot_map.h\"",
      "#include \"stackglue.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"heartbeat.h\"",
      "#include \"file.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"dcache.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2_lockingver.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/time.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/kthread.h>",
      "#include <linux/mm.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_SPINLOCK(ocfs2_dlm_tracking_lock);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&ocfs2_dlm_tracking_lock"
          ],
          "line": 2800
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_add",
          "args": [
            "&dummy->l_debug_list",
            "&iter->l_debug_list"
          ],
          "line": 2796
        },
        "resolved": true,
        "details": {
          "function_name": "simple_xattr_list_add",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xattr.c",
          "lines": "966-972",
          "snippet": "void simple_xattr_list_add(struct simple_xattrs *xattrs,\n\t\t\t   struct simple_xattr *new_xattr)\n{\n\tspin_lock(&xattrs->lock);\n\tlist_add(&new_xattr->list, &xattrs->head);\n\tspin_unlock(&xattrs->lock);\n}",
          "includes": [
            "#include <asm/uaccess.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/audit.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/evm.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/xattr.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/uaccess.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/vmalloc.h>\n#include <linux/audit.h>\n#include <linux/fsnotify.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n#include <linux/evm.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/xattr.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nvoid simple_xattr_list_add(struct simple_xattrs *xattrs,\n\t\t\t   struct simple_xattr *new_xattr)\n{\n\tspin_lock(&xattrs->lock);\n\tlist_add(&new_xattr->list, &xattrs->head);\n\tspin_unlock(&xattrs->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_del_init",
          "args": [
            "&dummy->l_debug_list"
          ],
          "line": 2794
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_dlm_next_res",
          "args": [
            "iter",
            "priv"
          ],
          "line": 2793
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_dlm_next_res",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlmglue.c",
          "lines": "2733-2757",
          "snippet": "static struct ocfs2_lock_res *ocfs2_dlm_next_res(struct ocfs2_lock_res *start,\n\t\t\t\t\t\t struct ocfs2_dlm_seq_priv *priv)\n{\n\tstruct ocfs2_lock_res *iter, *ret = NULL;\n\tstruct ocfs2_dlm_debug *dlm_debug = priv->p_dlm_debug;\n\n\tassert_spin_locked(&ocfs2_dlm_tracking_lock);\n\n\tlist_for_each_entry(iter, &start->l_debug_list, l_debug_list) {\n\t\t/* discover the head of the list */\n\t\tif (&iter->l_debug_list == &dlm_debug->d_lockres_tracking) {\n\t\t\tmlog(0, \"End of list found, %p\\n\", ret);\n\t\t\tbreak;\n\t\t}\n\n\t\t/* We track our \"dummy\" iteration lockres' by a NULL\n\t\t * l_ops field. */\n\t\tif (iter->l_ops != NULL) {\n\t\t\tret = iter;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn ret;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"refcounttree.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"stackglue.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dcache.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2_lockingver.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/time.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/kthread.h>",
            "#include <linux/mm.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct ocfs2_super *ocfs2_get_dentry_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_inode_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_file_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_qinfo_osb(struct ocfs2_lock_res *lockres);",
            "static void ocfs2_set_meta_lvb(struct ocfs2_lock_res *lockres);",
            "static void ocfs2_dentry_post_unlock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres);",
            "static void ocfs2_set_qinfo_lvb(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_downconvert_action(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_convert_action(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_attach_action(struct ocfs2_lock_res *lockres);",
            "static void ocfs2_schedule_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static void ocfs2_downconvert_on_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static int ocfs2_prepare_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\t        struct ocfs2_lock_res *lockres);",
            "static int ocfs2_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static DEFINE_SPINLOCK(ocfs2_dlm_tracking_lock);",
            "static void ocfs2_process_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *lockres);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"stackglue.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dcache.h\"\n#include \"alloc.h\"\n#include \"ocfs2_lockingver.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/quotaops.h>\n#include <linux/time.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/pagemap.h>\n#include <linux/kthread.h>\n#include <linux/mm.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic struct ocfs2_super *ocfs2_get_dentry_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_inode_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_file_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_qinfo_osb(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_set_meta_lvb(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_dentry_post_unlock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres);\nstatic void ocfs2_set_qinfo_lvb(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_downconvert_action(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_convert_action(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_attach_action(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_schedule_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_downconvert_on_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic int ocfs2_prepare_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\t        struct ocfs2_lock_res *lockres);\nstatic int ocfs2_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic DEFINE_SPINLOCK(ocfs2_dlm_tracking_lock);\nstatic void ocfs2_process_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *lockres);\n\nstatic struct ocfs2_lock_res *ocfs2_dlm_next_res(struct ocfs2_lock_res *start,\n\t\t\t\t\t\t struct ocfs2_dlm_seq_priv *priv)\n{\n\tstruct ocfs2_lock_res *iter, *ret = NULL;\n\tstruct ocfs2_dlm_debug *dlm_debug = priv->p_dlm_debug;\n\n\tassert_spin_locked(&ocfs2_dlm_tracking_lock);\n\n\tlist_for_each_entry(iter, &start->l_debug_list, l_debug_list) {\n\t\t/* discover the head of the list */\n\t\tif (&iter->l_debug_list == &dlm_debug->d_lockres_tracking) {\n\t\t\tmlog(0, \"End of list found, %p\\n\", ret);\n\t\t\tbreak;\n\t\t}\n\n\t\t/* We track our \"dummy\" iteration lockres' by a NULL\n\t\t * l_ops field. */\n\t\tif (iter->l_ops != NULL) {\n\t\t\tret = iter;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&ocfs2_dlm_tracking_lock"
          ],
          "line": 2792
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"stackglue.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dcache.h\"\n#include \"alloc.h\"\n#include \"ocfs2_lockingver.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/quotaops.h>\n#include <linux/time.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/pagemap.h>\n#include <linux/kthread.h>\n#include <linux/mm.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic DEFINE_SPINLOCK(ocfs2_dlm_tracking_lock);\n\nstatic void *ocfs2_dlm_seq_next(struct seq_file *m, void *v, loff_t *pos)\n{\n\tstruct ocfs2_dlm_seq_priv *priv = m->private;\n\tstruct ocfs2_lock_res *iter = v;\n\tstruct ocfs2_lock_res *dummy = &priv->p_iter_res;\n\n\tspin_lock(&ocfs2_dlm_tracking_lock);\n\titer = ocfs2_dlm_next_res(iter, priv);\n\tlist_del_init(&dummy->l_debug_list);\n\tif (iter) {\n\t\tlist_add(&dummy->l_debug_list, &iter->l_debug_list);\n\t\tpriv->p_tmp_res = *iter;\n\t\titer = &priv->p_tmp_res;\n\t}\n\tspin_unlock(&ocfs2_dlm_tracking_lock);\n\n\treturn iter;\n}"
  },
  {
    "function_name": "ocfs2_dlm_seq_stop",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlmglue.c",
    "lines": "2782-2784",
    "snippet": "static void ocfs2_dlm_seq_stop(struct seq_file *m, void *v)\n{\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"refcounttree.h\"",
      "#include \"quota.h\"",
      "#include \"uptodate.h\"",
      "#include \"super.h\"",
      "#include \"slot_map.h\"",
      "#include \"stackglue.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"heartbeat.h\"",
      "#include \"file.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"dcache.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2_lockingver.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/time.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/kthread.h>",
      "#include <linux/mm.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"stackglue.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dcache.h\"\n#include \"alloc.h\"\n#include \"ocfs2_lockingver.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/quotaops.h>\n#include <linux/time.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/pagemap.h>\n#include <linux/kthread.h>\n#include <linux/mm.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic void ocfs2_dlm_seq_stop(struct seq_file *m, void *v)\n{\n}"
  },
  {
    "function_name": "ocfs2_dlm_seq_start",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlmglue.c",
    "lines": "2759-2780",
    "snippet": "static void *ocfs2_dlm_seq_start(struct seq_file *m, loff_t *pos)\n{\n\tstruct ocfs2_dlm_seq_priv *priv = m->private;\n\tstruct ocfs2_lock_res *iter;\n\n\tspin_lock(&ocfs2_dlm_tracking_lock);\n\titer = ocfs2_dlm_next_res(&priv->p_iter_res, priv);\n\tif (iter) {\n\t\t/* Since lockres' have the lifetime of their container\n\t\t * (which can be inodes, ocfs2_supers, etc) we want to\n\t\t * copy this out to a temporary lockres while still\n\t\t * under the spinlock. Obviously after this we can't\n\t\t * trust any pointers on the copy returned, but that's\n\t\t * ok as the information we want isn't typically held\n\t\t * in them. */\n\t\tpriv->p_tmp_res = *iter;\n\t\titer = &priv->p_tmp_res;\n\t}\n\tspin_unlock(&ocfs2_dlm_tracking_lock);\n\n\treturn iter;\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"refcounttree.h\"",
      "#include \"quota.h\"",
      "#include \"uptodate.h\"",
      "#include \"super.h\"",
      "#include \"slot_map.h\"",
      "#include \"stackglue.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"heartbeat.h\"",
      "#include \"file.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"dcache.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2_lockingver.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/time.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/kthread.h>",
      "#include <linux/mm.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct ocfs2_super *ocfs2_get_dentry_osb(struct ocfs2_lock_res *lockres);",
      "static struct ocfs2_super *ocfs2_get_inode_osb(struct ocfs2_lock_res *lockres);",
      "static struct ocfs2_super *ocfs2_get_file_osb(struct ocfs2_lock_res *lockres);",
      "static struct ocfs2_super *ocfs2_get_qinfo_osb(struct ocfs2_lock_res *lockres);",
      "static void ocfs2_set_meta_lvb(struct ocfs2_lock_res *lockres);",
      "static void ocfs2_dentry_post_unlock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres);",
      "static void ocfs2_set_qinfo_lvb(struct ocfs2_lock_res *lockres);",
      "static inline void ocfs2_generic_handle_downconvert_action(struct ocfs2_lock_res *lockres);",
      "static inline void ocfs2_generic_handle_convert_action(struct ocfs2_lock_res *lockres);",
      "static inline void ocfs2_generic_handle_attach_action(struct ocfs2_lock_res *lockres);",
      "static void ocfs2_schedule_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);",
      "static void ocfs2_downconvert_on_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);",
      "static int ocfs2_prepare_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\t        struct ocfs2_lock_res *lockres);",
      "static int ocfs2_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres);",
      "static DEFINE_SPINLOCK(ocfs2_dlm_tracking_lock);",
      "static void ocfs2_process_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *lockres);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&ocfs2_dlm_tracking_lock"
          ],
          "line": 2777
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_dlm_next_res",
          "args": [
            "&priv->p_iter_res",
            "priv"
          ],
          "line": 2765
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_dlm_next_res",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlmglue.c",
          "lines": "2733-2757",
          "snippet": "static struct ocfs2_lock_res *ocfs2_dlm_next_res(struct ocfs2_lock_res *start,\n\t\t\t\t\t\t struct ocfs2_dlm_seq_priv *priv)\n{\n\tstruct ocfs2_lock_res *iter, *ret = NULL;\n\tstruct ocfs2_dlm_debug *dlm_debug = priv->p_dlm_debug;\n\n\tassert_spin_locked(&ocfs2_dlm_tracking_lock);\n\n\tlist_for_each_entry(iter, &start->l_debug_list, l_debug_list) {\n\t\t/* discover the head of the list */\n\t\tif (&iter->l_debug_list == &dlm_debug->d_lockres_tracking) {\n\t\t\tmlog(0, \"End of list found, %p\\n\", ret);\n\t\t\tbreak;\n\t\t}\n\n\t\t/* We track our \"dummy\" iteration lockres' by a NULL\n\t\t * l_ops field. */\n\t\tif (iter->l_ops != NULL) {\n\t\t\tret = iter;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn ret;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"refcounttree.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"stackglue.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dcache.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2_lockingver.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/time.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/kthread.h>",
            "#include <linux/mm.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct ocfs2_super *ocfs2_get_dentry_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_inode_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_file_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_qinfo_osb(struct ocfs2_lock_res *lockres);",
            "static void ocfs2_set_meta_lvb(struct ocfs2_lock_res *lockres);",
            "static void ocfs2_dentry_post_unlock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres);",
            "static void ocfs2_set_qinfo_lvb(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_downconvert_action(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_convert_action(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_attach_action(struct ocfs2_lock_res *lockres);",
            "static void ocfs2_schedule_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static void ocfs2_downconvert_on_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static int ocfs2_prepare_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\t        struct ocfs2_lock_res *lockres);",
            "static int ocfs2_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static DEFINE_SPINLOCK(ocfs2_dlm_tracking_lock);",
            "static void ocfs2_process_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *lockres);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"stackglue.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dcache.h\"\n#include \"alloc.h\"\n#include \"ocfs2_lockingver.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/quotaops.h>\n#include <linux/time.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/pagemap.h>\n#include <linux/kthread.h>\n#include <linux/mm.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic struct ocfs2_super *ocfs2_get_dentry_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_inode_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_file_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_qinfo_osb(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_set_meta_lvb(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_dentry_post_unlock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres);\nstatic void ocfs2_set_qinfo_lvb(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_downconvert_action(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_convert_action(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_attach_action(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_schedule_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_downconvert_on_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic int ocfs2_prepare_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\t        struct ocfs2_lock_res *lockres);\nstatic int ocfs2_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic DEFINE_SPINLOCK(ocfs2_dlm_tracking_lock);\nstatic void ocfs2_process_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *lockres);\n\nstatic struct ocfs2_lock_res *ocfs2_dlm_next_res(struct ocfs2_lock_res *start,\n\t\t\t\t\t\t struct ocfs2_dlm_seq_priv *priv)\n{\n\tstruct ocfs2_lock_res *iter, *ret = NULL;\n\tstruct ocfs2_dlm_debug *dlm_debug = priv->p_dlm_debug;\n\n\tassert_spin_locked(&ocfs2_dlm_tracking_lock);\n\n\tlist_for_each_entry(iter, &start->l_debug_list, l_debug_list) {\n\t\t/* discover the head of the list */\n\t\tif (&iter->l_debug_list == &dlm_debug->d_lockres_tracking) {\n\t\t\tmlog(0, \"End of list found, %p\\n\", ret);\n\t\t\tbreak;\n\t\t}\n\n\t\t/* We track our \"dummy\" iteration lockres' by a NULL\n\t\t * l_ops field. */\n\t\tif (iter->l_ops != NULL) {\n\t\t\tret = iter;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&ocfs2_dlm_tracking_lock"
          ],
          "line": 2764
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"stackglue.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dcache.h\"\n#include \"alloc.h\"\n#include \"ocfs2_lockingver.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/quotaops.h>\n#include <linux/time.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/pagemap.h>\n#include <linux/kthread.h>\n#include <linux/mm.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic struct ocfs2_super *ocfs2_get_dentry_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_inode_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_file_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_qinfo_osb(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_set_meta_lvb(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_dentry_post_unlock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres);\nstatic void ocfs2_set_qinfo_lvb(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_downconvert_action(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_convert_action(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_attach_action(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_schedule_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_downconvert_on_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic int ocfs2_prepare_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\t        struct ocfs2_lock_res *lockres);\nstatic int ocfs2_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic DEFINE_SPINLOCK(ocfs2_dlm_tracking_lock);\nstatic void ocfs2_process_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *lockres);\n\nstatic void *ocfs2_dlm_seq_start(struct seq_file *m, loff_t *pos)\n{\n\tstruct ocfs2_dlm_seq_priv *priv = m->private;\n\tstruct ocfs2_lock_res *iter;\n\n\tspin_lock(&ocfs2_dlm_tracking_lock);\n\titer = ocfs2_dlm_next_res(&priv->p_iter_res, priv);\n\tif (iter) {\n\t\t/* Since lockres' have the lifetime of their container\n\t\t * (which can be inodes, ocfs2_supers, etc) we want to\n\t\t * copy this out to a temporary lockres while still\n\t\t * under the spinlock. Obviously after this we can't\n\t\t * trust any pointers on the copy returned, but that's\n\t\t * ok as the information we want isn't typically held\n\t\t * in them. */\n\t\tpriv->p_tmp_res = *iter;\n\t\titer = &priv->p_tmp_res;\n\t}\n\tspin_unlock(&ocfs2_dlm_tracking_lock);\n\n\treturn iter;\n}"
  },
  {
    "function_name": "ocfs2_dlm_next_res",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlmglue.c",
    "lines": "2733-2757",
    "snippet": "static struct ocfs2_lock_res *ocfs2_dlm_next_res(struct ocfs2_lock_res *start,\n\t\t\t\t\t\t struct ocfs2_dlm_seq_priv *priv)\n{\n\tstruct ocfs2_lock_res *iter, *ret = NULL;\n\tstruct ocfs2_dlm_debug *dlm_debug = priv->p_dlm_debug;\n\n\tassert_spin_locked(&ocfs2_dlm_tracking_lock);\n\n\tlist_for_each_entry(iter, &start->l_debug_list, l_debug_list) {\n\t\t/* discover the head of the list */\n\t\tif (&iter->l_debug_list == &dlm_debug->d_lockres_tracking) {\n\t\t\tmlog(0, \"End of list found, %p\\n\", ret);\n\t\t\tbreak;\n\t\t}\n\n\t\t/* We track our \"dummy\" iteration lockres' by a NULL\n\t\t * l_ops field. */\n\t\tif (iter->l_ops != NULL) {\n\t\t\tret = iter;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn ret;\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"refcounttree.h\"",
      "#include \"quota.h\"",
      "#include \"uptodate.h\"",
      "#include \"super.h\"",
      "#include \"slot_map.h\"",
      "#include \"stackglue.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"heartbeat.h\"",
      "#include \"file.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"dcache.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2_lockingver.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/time.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/kthread.h>",
      "#include <linux/mm.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct ocfs2_super *ocfs2_get_dentry_osb(struct ocfs2_lock_res *lockres);",
      "static struct ocfs2_super *ocfs2_get_inode_osb(struct ocfs2_lock_res *lockres);",
      "static struct ocfs2_super *ocfs2_get_file_osb(struct ocfs2_lock_res *lockres);",
      "static struct ocfs2_super *ocfs2_get_qinfo_osb(struct ocfs2_lock_res *lockres);",
      "static void ocfs2_set_meta_lvb(struct ocfs2_lock_res *lockres);",
      "static void ocfs2_dentry_post_unlock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres);",
      "static void ocfs2_set_qinfo_lvb(struct ocfs2_lock_res *lockres);",
      "static inline void ocfs2_generic_handle_downconvert_action(struct ocfs2_lock_res *lockres);",
      "static inline void ocfs2_generic_handle_convert_action(struct ocfs2_lock_res *lockres);",
      "static inline void ocfs2_generic_handle_attach_action(struct ocfs2_lock_res *lockres);",
      "static void ocfs2_schedule_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);",
      "static void ocfs2_downconvert_on_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);",
      "static int ocfs2_prepare_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\t        struct ocfs2_lock_res *lockres);",
      "static int ocfs2_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres);",
      "static DEFINE_SPINLOCK(ocfs2_dlm_tracking_lock);",
      "static void ocfs2_process_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *lockres);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mlog",
          "args": [
            "0",
            "\"End of list found, %p\\n\"",
            "ret"
          ],
          "line": 2744
        },
        "resolved": true,
        "details": {
          "function_name": "mlog_show",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/cluster/masklog.c",
          "lines": "107-113",
          "snippet": "static ssize_t mlog_show(struct kobject *obj, struct attribute *attr,\n\t\t\t char *buf)\n{\n\tstruct mlog_attribute *mlog_attr = to_mlog_attr(attr);\n\n\treturn mlog_mask_show(mlog_attr->mask, buf);\n}",
          "includes": [
            "#include \"masklog.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/string.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"masklog.h\"\n#include <asm/uaccess.h>\n#include <linux/string.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n\nstatic ssize_t mlog_show(struct kobject *obj, struct attribute *attr,\n\t\t\t char *buf)\n{\n\tstruct mlog_attribute *mlog_attr = to_mlog_attr(attr);\n\n\treturn mlog_mask_show(mlog_attr->mask, buf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "iter",
            "&start->l_debug_list",
            "l_debug_list"
          ],
          "line": 2741
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "assert_spin_locked",
          "args": [
            "&ocfs2_dlm_tracking_lock"
          ],
          "line": 2739
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"stackglue.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dcache.h\"\n#include \"alloc.h\"\n#include \"ocfs2_lockingver.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/quotaops.h>\n#include <linux/time.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/pagemap.h>\n#include <linux/kthread.h>\n#include <linux/mm.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic struct ocfs2_super *ocfs2_get_dentry_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_inode_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_file_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_qinfo_osb(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_set_meta_lvb(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_dentry_post_unlock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres);\nstatic void ocfs2_set_qinfo_lvb(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_downconvert_action(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_convert_action(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_attach_action(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_schedule_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_downconvert_on_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic int ocfs2_prepare_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\t        struct ocfs2_lock_res *lockres);\nstatic int ocfs2_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic DEFINE_SPINLOCK(ocfs2_dlm_tracking_lock);\nstatic void ocfs2_process_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *lockres);\n\nstatic struct ocfs2_lock_res *ocfs2_dlm_next_res(struct ocfs2_lock_res *start,\n\t\t\t\t\t\t struct ocfs2_dlm_seq_priv *priv)\n{\n\tstruct ocfs2_lock_res *iter, *ret = NULL;\n\tstruct ocfs2_dlm_debug *dlm_debug = priv->p_dlm_debug;\n\n\tassert_spin_locked(&ocfs2_dlm_tracking_lock);\n\n\tlist_for_each_entry(iter, &start->l_debug_list, l_debug_list) {\n\t\t/* discover the head of the list */\n\t\tif (&iter->l_debug_list == &dlm_debug->d_lockres_tracking) {\n\t\t\tmlog(0, \"End of list found, %p\\n\", ret);\n\t\t\tbreak;\n\t\t}\n\n\t\t/* We track our \"dummy\" iteration lockres' by a NULL\n\t\t * l_ops field. */\n\t\tif (iter->l_ops != NULL) {\n\t\t\tret = iter;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn ret;\n}"
  },
  {
    "function_name": "ocfs2_new_dlm_debug",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlmglue.c",
    "lines": "2709-2724",
    "snippet": "struct ocfs2_dlm_debug *ocfs2_new_dlm_debug(void)\n{\n\tstruct ocfs2_dlm_debug *dlm_debug;\n\n\tdlm_debug = kmalloc(sizeof(struct ocfs2_dlm_debug), GFP_KERNEL);\n\tif (!dlm_debug) {\n\t\tmlog_errno(-ENOMEM);\n\t\tgoto out;\n\t}\n\n\tkref_init(&dlm_debug->d_refcnt);\n\tINIT_LIST_HEAD(&dlm_debug->d_lockres_tracking);\n\tdlm_debug->d_locking_state = NULL;\nout:\n\treturn dlm_debug;\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"refcounttree.h\"",
      "#include \"quota.h\"",
      "#include \"uptodate.h\"",
      "#include \"super.h\"",
      "#include \"slot_map.h\"",
      "#include \"stackglue.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"heartbeat.h\"",
      "#include \"file.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"dcache.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2_lockingver.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/time.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/kthread.h>",
      "#include <linux/mm.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&dlm_debug->d_lockres_tracking"
          ],
          "line": 2720
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kref_init",
          "args": [
            "&dlm_debug->d_refcnt"
          ],
          "line": 2719
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "-ENOMEM"
          ],
          "line": 2715
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmalloc",
          "args": [
            "sizeof(struct ocfs2_dlm_debug)",
            "GFP_KERNEL"
          ],
          "line": 2713
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_dx_dir_kmalloc_leaves",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
          "lines": "2534-2546",
          "snippet": "static struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"stackglue.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dcache.h\"\n#include \"alloc.h\"\n#include \"ocfs2_lockingver.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/quotaops.h>\n#include <linux/time.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/pagemap.h>\n#include <linux/kthread.h>\n#include <linux/mm.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstruct ocfs2_dlm_debug *ocfs2_new_dlm_debug(void)\n{\n\tstruct ocfs2_dlm_debug *dlm_debug;\n\n\tdlm_debug = kmalloc(sizeof(struct ocfs2_dlm_debug), GFP_KERNEL);\n\tif (!dlm_debug) {\n\t\tmlog_errno(-ENOMEM);\n\t\tgoto out;\n\t}\n\n\tkref_init(&dlm_debug->d_refcnt);\n\tINIT_LIST_HEAD(&dlm_debug->d_lockres_tracking);\n\tdlm_debug->d_locking_state = NULL;\nout:\n\treturn dlm_debug;\n}"
  },
  {
    "function_name": "ocfs2_get_dlm_debug",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlmglue.c",
    "lines": "2704-2707",
    "snippet": "static void ocfs2_get_dlm_debug(struct ocfs2_dlm_debug *debug)\n{\n\tkref_get(&debug->d_refcnt);\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"refcounttree.h\"",
      "#include \"quota.h\"",
      "#include \"uptodate.h\"",
      "#include \"super.h\"",
      "#include \"slot_map.h\"",
      "#include \"stackglue.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"heartbeat.h\"",
      "#include \"file.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"dcache.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2_lockingver.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/time.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/kthread.h>",
      "#include <linux/mm.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kref_get",
          "args": [
            "&debug->d_refcnt"
          ],
          "line": 2706
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"stackglue.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dcache.h\"\n#include \"alloc.h\"\n#include \"ocfs2_lockingver.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/quotaops.h>\n#include <linux/time.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/pagemap.h>\n#include <linux/kthread.h>\n#include <linux/mm.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic void ocfs2_get_dlm_debug(struct ocfs2_dlm_debug *debug)\n{\n\tkref_get(&debug->d_refcnt);\n}"
  },
  {
    "function_name": "ocfs2_put_dlm_debug",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlmglue.c",
    "lines": "2698-2702",
    "snippet": "void ocfs2_put_dlm_debug(struct ocfs2_dlm_debug *dlm_debug)\n{\n\tif (dlm_debug)\n\t\tkref_put(&dlm_debug->d_refcnt, ocfs2_dlm_debug_free);\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"refcounttree.h\"",
      "#include \"quota.h\"",
      "#include \"uptodate.h\"",
      "#include \"super.h\"",
      "#include \"slot_map.h\"",
      "#include \"stackglue.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"heartbeat.h\"",
      "#include \"file.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"dcache.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2_lockingver.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/time.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/kthread.h>",
      "#include <linux/mm.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kref_put",
          "args": [
            "&dlm_debug->d_refcnt",
            "ocfs2_dlm_debug_free"
          ],
          "line": 2701
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"stackglue.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dcache.h\"\n#include \"alloc.h\"\n#include \"ocfs2_lockingver.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/quotaops.h>\n#include <linux/time.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/pagemap.h>\n#include <linux/kthread.h>\n#include <linux/mm.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nvoid ocfs2_put_dlm_debug(struct ocfs2_dlm_debug *dlm_debug)\n{\n\tif (dlm_debug)\n\t\tkref_put(&dlm_debug->d_refcnt, ocfs2_dlm_debug_free);\n}"
  },
  {
    "function_name": "ocfs2_dlm_debug_free",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlmglue.c",
    "lines": "2689-2696",
    "snippet": "static void ocfs2_dlm_debug_free(struct kref *kref)\n{\n\tstruct ocfs2_dlm_debug *dlm_debug;\n\n\tdlm_debug = container_of(kref, struct ocfs2_dlm_debug, d_refcnt);\n\n\tkfree(dlm_debug);\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"refcounttree.h\"",
      "#include \"quota.h\"",
      "#include \"uptodate.h\"",
      "#include \"super.h\"",
      "#include \"slot_map.h\"",
      "#include \"stackglue.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"heartbeat.h\"",
      "#include \"file.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"dcache.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2_lockingver.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/time.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/kthread.h>",
      "#include <linux/mm.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "dlm_debug"
          ],
          "line": 2695
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "kref",
            "structocfs2_dlm_debug",
            "d_refcnt"
          ],
          "line": 2693
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"stackglue.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dcache.h\"\n#include \"alloc.h\"\n#include \"ocfs2_lockingver.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/quotaops.h>\n#include <linux/time.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/pagemap.h>\n#include <linux/kthread.h>\n#include <linux/mm.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic void ocfs2_dlm_debug_free(struct kref *kref)\n{\n\tstruct ocfs2_dlm_debug *dlm_debug;\n\n\tdlm_debug = container_of(kref, struct ocfs2_dlm_debug, d_refcnt);\n\n\tkfree(dlm_debug);\n}"
  },
  {
    "function_name": "ocfs2_dentry_unlock",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlmglue.c",
    "lines": "2676-2684",
    "snippet": "void ocfs2_dentry_unlock(struct dentry *dentry, int ex)\n{\n\tint level = ex ? DLM_LOCK_EX : DLM_LOCK_PR;\n\tstruct ocfs2_dentry_lock *dl = dentry->d_fsdata;\n\tstruct ocfs2_super *osb = OCFS2_SB(dentry->d_sb);\n\n\tif (!ocfs2_is_hard_readonly(osb) && !ocfs2_mount_local(osb))\n\t\tocfs2_cluster_unlock(osb, &dl->dl_lockres, level);\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"refcounttree.h\"",
      "#include \"quota.h\"",
      "#include \"uptodate.h\"",
      "#include \"super.h\"",
      "#include \"slot_map.h\"",
      "#include \"stackglue.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"heartbeat.h\"",
      "#include \"file.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"dcache.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2_lockingver.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/time.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/kthread.h>",
      "#include <linux/mm.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ocfs2_generic_handle_bast(struct ocfs2_lock_res *lockres, int level);",
      "static void ocfs2_drop_osb_locks(struct ocfs2_super *osb);",
      "static inline int ocfs2_highest_compat_lock_level(int level);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ocfs2_cluster_unlock",
          "args": [
            "osb",
            "&dl->dl_lockres",
            "level"
          ],
          "line": 2683
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_cluster_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlmglue.c",
          "lines": "349-354",
          "snippet": "static inline void ocfs2_cluster_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres,\n\t\t\t\t\tint level)\n{\n\t__ocfs2_cluster_unlock(osb, lockres, level, _RET_IP_);\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"refcounttree.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"stackglue.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dcache.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2_lockingver.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/time.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/kthread.h>",
            "#include <linux/mm.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct ocfs2_super *ocfs2_get_dentry_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_inode_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_file_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_qinfo_osb(struct ocfs2_lock_res *lockres);",
            "static void ocfs2_set_meta_lvb(struct ocfs2_lock_res *lockres);",
            "static void ocfs2_dentry_post_unlock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres);",
            "static void ocfs2_set_qinfo_lvb(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_downconvert_action(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_convert_action(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_attach_action(struct ocfs2_lock_res *lockres);",
            "static int ocfs2_generic_handle_bast(struct ocfs2_lock_res *lockres, int level);",
            "static void ocfs2_schedule_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static void ocfs2_downconvert_on_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static void ocfs2_drop_osb_locks(struct ocfs2_super *osb);",
            "static inline int ocfs2_highest_compat_lock_level(int level);",
            "static int ocfs2_prepare_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\t        struct ocfs2_lock_res *lockres);",
            "static int ocfs2_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static void ocfs2_process_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *lockres);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"stackglue.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dcache.h\"\n#include \"alloc.h\"\n#include \"ocfs2_lockingver.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/quotaops.h>\n#include <linux/time.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/pagemap.h>\n#include <linux/kthread.h>\n#include <linux/mm.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic struct ocfs2_super *ocfs2_get_dentry_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_inode_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_file_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_qinfo_osb(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_set_meta_lvb(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_dentry_post_unlock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres);\nstatic void ocfs2_set_qinfo_lvb(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_downconvert_action(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_convert_action(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_attach_action(struct ocfs2_lock_res *lockres);\nstatic int ocfs2_generic_handle_bast(struct ocfs2_lock_res *lockres, int level);\nstatic void ocfs2_schedule_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_downconvert_on_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_drop_osb_locks(struct ocfs2_super *osb);\nstatic inline int ocfs2_highest_compat_lock_level(int level);\nstatic int ocfs2_prepare_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\t        struct ocfs2_lock_res *lockres);\nstatic int ocfs2_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_process_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *lockres);\n\nstatic inline void ocfs2_cluster_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres,\n\t\t\t\t\tint level)\n{\n\t__ocfs2_cluster_unlock(osb, lockres, level, _RET_IP_);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_mount_local",
          "args": [
            "osb"
          ],
          "line": 2682
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_mount_local",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "668-671",
          "snippet": "static inline int ocfs2_mount_local(struct ocfs2_super *osb)\n{\n\treturn (osb->s_feature_incompat & OCFS2_FEATURE_INCOMPAT_LOCAL_MOUNT);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\nstatic inline int ocfs2_mount_local(struct ocfs2_super *osb)\n{\n\treturn (osb->s_feature_incompat & OCFS2_FEATURE_INCOMPAT_LOCAL_MOUNT);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_is_hard_readonly",
          "args": [
            "osb"
          ],
          "line": 2682
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_is_hard_readonly",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "615-624",
          "snippet": "static inline int ocfs2_is_hard_readonly(struct ocfs2_super *osb)\n{\n\tint ret;\n\n\tspin_lock(&osb->osb_lock);\n\tret = osb->osb_flags & OCFS2_OSB_HARD_RO;\n\tspin_unlock(&osb->osb_lock);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [
            "#define OCFS2_OSB_HARD_RO\t0x0002"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\n#define OCFS2_OSB_HARD_RO\t0x0002\n\nstatic inline int ocfs2_is_hard_readonly(struct ocfs2_super *osb)\n{\n\tint ret;\n\n\tspin_lock(&osb->osb_lock);\n\tret = osb->osb_flags & OCFS2_OSB_HARD_RO;\n\tspin_unlock(&osb->osb_lock);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "OCFS2_SB",
          "args": [
            "dentry->d_sb"
          ],
          "line": 2680
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"stackglue.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dcache.h\"\n#include \"alloc.h\"\n#include \"ocfs2_lockingver.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/quotaops.h>\n#include <linux/time.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/pagemap.h>\n#include <linux/kthread.h>\n#include <linux/mm.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic int ocfs2_generic_handle_bast(struct ocfs2_lock_res *lockres, int level);\nstatic void ocfs2_drop_osb_locks(struct ocfs2_super *osb);\nstatic inline int ocfs2_highest_compat_lock_level(int level);\n\nvoid ocfs2_dentry_unlock(struct dentry *dentry, int ex)\n{\n\tint level = ex ? DLM_LOCK_EX : DLM_LOCK_PR;\n\tstruct ocfs2_dentry_lock *dl = dentry->d_fsdata;\n\tstruct ocfs2_super *osb = OCFS2_SB(dentry->d_sb);\n\n\tif (!ocfs2_is_hard_readonly(osb) && !ocfs2_mount_local(osb))\n\t\tocfs2_cluster_unlock(osb, &dl->dl_lockres, level);\n}"
  },
  {
    "function_name": "ocfs2_dentry_lock",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlmglue.c",
    "lines": "2651-2674",
    "snippet": "int ocfs2_dentry_lock(struct dentry *dentry, int ex)\n{\n\tint ret;\n\tint level = ex ? DLM_LOCK_EX : DLM_LOCK_PR;\n\tstruct ocfs2_dentry_lock *dl = dentry->d_fsdata;\n\tstruct ocfs2_super *osb = OCFS2_SB(dentry->d_sb);\n\n\tBUG_ON(!dl);\n\n\tif (ocfs2_is_hard_readonly(osb)) {\n\t\tif (ex)\n\t\t\treturn -EROFS;\n\t\treturn 0;\n\t}\n\n\tif (ocfs2_mount_local(osb))\n\t\treturn 0;\n\n\tret = ocfs2_cluster_lock(osb, &dl->dl_lockres, level, 0, 0);\n\tif (ret < 0)\n\t\tmlog_errno(ret);\n\n\treturn ret;\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"refcounttree.h\"",
      "#include \"quota.h\"",
      "#include \"uptodate.h\"",
      "#include \"super.h\"",
      "#include \"slot_map.h\"",
      "#include \"stackglue.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"heartbeat.h\"",
      "#include \"file.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"dcache.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2_lockingver.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/time.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/kthread.h>",
      "#include <linux/mm.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ocfs2_generic_handle_bast(struct ocfs2_lock_res *lockres, int level);",
      "static void ocfs2_drop_osb_locks(struct ocfs2_super *osb);",
      "static inline int ocfs2_highest_compat_lock_level(int level);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 2671
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_cluster_lock",
          "args": [
            "osb",
            "&dl->dl_lockres",
            "level",
            "0",
            "0"
          ],
          "line": 2669
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_cluster_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlmglue.c",
          "lines": "1570-1578",
          "snippet": "static inline int ocfs2_cluster_lock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres,\n\t\t\t\t     int level,\n\t\t\t\t     u32 lkm_flags,\n\t\t\t\t     int arg_flags)\n{\n\treturn __ocfs2_cluster_lock(osb, lockres, level, lkm_flags, arg_flags,\n\t\t\t\t    0, _RET_IP_);\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"refcounttree.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"stackglue.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dcache.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2_lockingver.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/time.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/kthread.h>",
            "#include <linux/mm.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct ocfs2_super *ocfs2_get_dentry_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_inode_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_file_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_qinfo_osb(struct ocfs2_lock_res *lockres);",
            "static void ocfs2_set_meta_lvb(struct ocfs2_lock_res *lockres);",
            "static void ocfs2_dentry_post_unlock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres);",
            "static void ocfs2_set_qinfo_lvb(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_downconvert_action(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_convert_action(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_attach_action(struct ocfs2_lock_res *lockres);",
            "static int ocfs2_generic_handle_bast(struct ocfs2_lock_res *lockres, int level);",
            "static void ocfs2_schedule_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static void ocfs2_downconvert_on_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static void ocfs2_drop_osb_locks(struct ocfs2_super *osb);",
            "static inline int ocfs2_highest_compat_lock_level(int level);",
            "static int ocfs2_prepare_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\t        struct ocfs2_lock_res *lockres);",
            "static int ocfs2_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static void ocfs2_process_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *lockres);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"stackglue.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dcache.h\"\n#include \"alloc.h\"\n#include \"ocfs2_lockingver.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/quotaops.h>\n#include <linux/time.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/pagemap.h>\n#include <linux/kthread.h>\n#include <linux/mm.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic struct ocfs2_super *ocfs2_get_dentry_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_inode_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_file_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_qinfo_osb(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_set_meta_lvb(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_dentry_post_unlock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres);\nstatic void ocfs2_set_qinfo_lvb(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_downconvert_action(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_convert_action(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_attach_action(struct ocfs2_lock_res *lockres);\nstatic int ocfs2_generic_handle_bast(struct ocfs2_lock_res *lockres, int level);\nstatic void ocfs2_schedule_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_downconvert_on_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_drop_osb_locks(struct ocfs2_super *osb);\nstatic inline int ocfs2_highest_compat_lock_level(int level);\nstatic int ocfs2_prepare_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\t        struct ocfs2_lock_res *lockres);\nstatic int ocfs2_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_process_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *lockres);\n\nstatic inline int ocfs2_cluster_lock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres,\n\t\t\t\t     int level,\n\t\t\t\t     u32 lkm_flags,\n\t\t\t\t     int arg_flags)\n{\n\treturn __ocfs2_cluster_lock(osb, lockres, level, lkm_flags, arg_flags,\n\t\t\t\t    0, _RET_IP_);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_mount_local",
          "args": [
            "osb"
          ],
          "line": 2666
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_mount_local",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "668-671",
          "snippet": "static inline int ocfs2_mount_local(struct ocfs2_super *osb)\n{\n\treturn (osb->s_feature_incompat & OCFS2_FEATURE_INCOMPAT_LOCAL_MOUNT);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\nstatic inline int ocfs2_mount_local(struct ocfs2_super *osb)\n{\n\treturn (osb->s_feature_incompat & OCFS2_FEATURE_INCOMPAT_LOCAL_MOUNT);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_is_hard_readonly",
          "args": [
            "osb"
          ],
          "line": 2660
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_is_hard_readonly",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "615-624",
          "snippet": "static inline int ocfs2_is_hard_readonly(struct ocfs2_super *osb)\n{\n\tint ret;\n\n\tspin_lock(&osb->osb_lock);\n\tret = osb->osb_flags & OCFS2_OSB_HARD_RO;\n\tspin_unlock(&osb->osb_lock);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [
            "#define OCFS2_OSB_HARD_RO\t0x0002"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\n#define OCFS2_OSB_HARD_RO\t0x0002\n\nstatic inline int ocfs2_is_hard_readonly(struct ocfs2_super *osb)\n{\n\tint ret;\n\n\tspin_lock(&osb->osb_lock);\n\tret = osb->osb_flags & OCFS2_OSB_HARD_RO;\n\tspin_unlock(&osb->osb_lock);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!dl"
          ],
          "line": 2658
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "OCFS2_SB",
          "args": [
            "dentry->d_sb"
          ],
          "line": 2656
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"stackglue.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dcache.h\"\n#include \"alloc.h\"\n#include \"ocfs2_lockingver.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/quotaops.h>\n#include <linux/time.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/pagemap.h>\n#include <linux/kthread.h>\n#include <linux/mm.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic int ocfs2_generic_handle_bast(struct ocfs2_lock_res *lockres, int level);\nstatic void ocfs2_drop_osb_locks(struct ocfs2_super *osb);\nstatic inline int ocfs2_highest_compat_lock_level(int level);\n\nint ocfs2_dentry_lock(struct dentry *dentry, int ex)\n{\n\tint ret;\n\tint level = ex ? DLM_LOCK_EX : DLM_LOCK_PR;\n\tstruct ocfs2_dentry_lock *dl = dentry->d_fsdata;\n\tstruct ocfs2_super *osb = OCFS2_SB(dentry->d_sb);\n\n\tBUG_ON(!dl);\n\n\tif (ocfs2_is_hard_readonly(osb)) {\n\t\tif (ex)\n\t\t\treturn -EROFS;\n\t\treturn 0;\n\t}\n\n\tif (ocfs2_mount_local(osb))\n\t\treturn 0;\n\n\tret = ocfs2_cluster_lock(osb, &dl->dl_lockres, level, 0, 0);\n\tif (ret < 0)\n\t\tmlog_errno(ret);\n\n\treturn ret;\n}"
  },
  {
    "function_name": "ocfs2_nfs_sync_unlock",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlmglue.c",
    "lines": "2642-2649",
    "snippet": "void ocfs2_nfs_sync_unlock(struct ocfs2_super *osb, int ex)\n{\n\tstruct ocfs2_lock_res *lockres = &osb->osb_nfs_sync_lockres;\n\n\tif (!ocfs2_mount_local(osb))\n\t\tocfs2_cluster_unlock(osb, lockres,\n\t\t\t\t     ex ? LKM_EXMODE : LKM_PRMODE);\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"refcounttree.h\"",
      "#include \"quota.h\"",
      "#include \"uptodate.h\"",
      "#include \"super.h\"",
      "#include \"slot_map.h\"",
      "#include \"stackglue.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"heartbeat.h\"",
      "#include \"file.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"dcache.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2_lockingver.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/time.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/kthread.h>",
      "#include <linux/mm.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct ocfs2_super *ocfs2_get_dentry_osb(struct ocfs2_lock_res *lockres);",
      "static struct ocfs2_super *ocfs2_get_inode_osb(struct ocfs2_lock_res *lockres);",
      "static struct ocfs2_super *ocfs2_get_file_osb(struct ocfs2_lock_res *lockres);",
      "static struct ocfs2_super *ocfs2_get_qinfo_osb(struct ocfs2_lock_res *lockres);",
      "static void ocfs2_set_meta_lvb(struct ocfs2_lock_res *lockres);",
      "static void ocfs2_dentry_post_unlock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres);",
      "static void ocfs2_set_qinfo_lvb(struct ocfs2_lock_res *lockres);",
      "static inline void ocfs2_generic_handle_downconvert_action(struct ocfs2_lock_res *lockres);",
      "static inline void ocfs2_generic_handle_convert_action(struct ocfs2_lock_res *lockres);",
      "static inline void ocfs2_generic_handle_attach_action(struct ocfs2_lock_res *lockres);",
      "static void ocfs2_schedule_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);",
      "static void ocfs2_downconvert_on_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);",
      "static void ocfs2_drop_osb_locks(struct ocfs2_super *osb);",
      "static int ocfs2_prepare_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\t        struct ocfs2_lock_res *lockres);",
      "static int ocfs2_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres);",
      "static void ocfs2_process_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *lockres);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ocfs2_cluster_unlock",
          "args": [
            "osb",
            "lockres",
            "ex ? LKM_EXMODE : LKM_PRMODE"
          ],
          "line": 2647
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_cluster_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlmglue.c",
          "lines": "349-354",
          "snippet": "static inline void ocfs2_cluster_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres,\n\t\t\t\t\tint level)\n{\n\t__ocfs2_cluster_unlock(osb, lockres, level, _RET_IP_);\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"refcounttree.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"stackglue.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dcache.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2_lockingver.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/time.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/kthread.h>",
            "#include <linux/mm.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct ocfs2_super *ocfs2_get_dentry_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_inode_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_file_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_qinfo_osb(struct ocfs2_lock_res *lockres);",
            "static void ocfs2_set_meta_lvb(struct ocfs2_lock_res *lockres);",
            "static void ocfs2_dentry_post_unlock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres);",
            "static void ocfs2_set_qinfo_lvb(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_downconvert_action(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_convert_action(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_attach_action(struct ocfs2_lock_res *lockres);",
            "static int ocfs2_generic_handle_bast(struct ocfs2_lock_res *lockres, int level);",
            "static void ocfs2_schedule_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static void ocfs2_downconvert_on_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static void ocfs2_drop_osb_locks(struct ocfs2_super *osb);",
            "static inline int ocfs2_highest_compat_lock_level(int level);",
            "static int ocfs2_prepare_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\t        struct ocfs2_lock_res *lockres);",
            "static int ocfs2_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static void ocfs2_process_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *lockres);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"stackglue.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dcache.h\"\n#include \"alloc.h\"\n#include \"ocfs2_lockingver.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/quotaops.h>\n#include <linux/time.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/pagemap.h>\n#include <linux/kthread.h>\n#include <linux/mm.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic struct ocfs2_super *ocfs2_get_dentry_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_inode_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_file_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_qinfo_osb(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_set_meta_lvb(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_dentry_post_unlock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres);\nstatic void ocfs2_set_qinfo_lvb(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_downconvert_action(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_convert_action(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_attach_action(struct ocfs2_lock_res *lockres);\nstatic int ocfs2_generic_handle_bast(struct ocfs2_lock_res *lockres, int level);\nstatic void ocfs2_schedule_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_downconvert_on_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_drop_osb_locks(struct ocfs2_super *osb);\nstatic inline int ocfs2_highest_compat_lock_level(int level);\nstatic int ocfs2_prepare_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\t        struct ocfs2_lock_res *lockres);\nstatic int ocfs2_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_process_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *lockres);\n\nstatic inline void ocfs2_cluster_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres,\n\t\t\t\t\tint level)\n{\n\t__ocfs2_cluster_unlock(osb, lockres, level, _RET_IP_);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_mount_local",
          "args": [
            "osb"
          ],
          "line": 2646
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_mount_local",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "668-671",
          "snippet": "static inline int ocfs2_mount_local(struct ocfs2_super *osb)\n{\n\treturn (osb->s_feature_incompat & OCFS2_FEATURE_INCOMPAT_LOCAL_MOUNT);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\nstatic inline int ocfs2_mount_local(struct ocfs2_super *osb)\n{\n\treturn (osb->s_feature_incompat & OCFS2_FEATURE_INCOMPAT_LOCAL_MOUNT);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"stackglue.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dcache.h\"\n#include \"alloc.h\"\n#include \"ocfs2_lockingver.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/quotaops.h>\n#include <linux/time.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/pagemap.h>\n#include <linux/kthread.h>\n#include <linux/mm.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic struct ocfs2_super *ocfs2_get_dentry_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_inode_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_file_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_qinfo_osb(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_set_meta_lvb(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_dentry_post_unlock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres);\nstatic void ocfs2_set_qinfo_lvb(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_downconvert_action(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_convert_action(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_attach_action(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_schedule_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_downconvert_on_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_drop_osb_locks(struct ocfs2_super *osb);\nstatic int ocfs2_prepare_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\t        struct ocfs2_lock_res *lockres);\nstatic int ocfs2_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_process_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *lockres);\n\nvoid ocfs2_nfs_sync_unlock(struct ocfs2_super *osb, int ex)\n{\n\tstruct ocfs2_lock_res *lockres = &osb->osb_nfs_sync_lockres;\n\n\tif (!ocfs2_mount_local(osb))\n\t\tocfs2_cluster_unlock(osb, lockres,\n\t\t\t\t     ex ? LKM_EXMODE : LKM_PRMODE);\n}"
  },
  {
    "function_name": "ocfs2_nfs_sync_lock",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlmglue.c",
    "lines": "2623-2640",
    "snippet": "int ocfs2_nfs_sync_lock(struct ocfs2_super *osb, int ex)\n{\n\tint status;\n\tstruct ocfs2_lock_res *lockres = &osb->osb_nfs_sync_lockres;\n\n\tif (ocfs2_is_hard_readonly(osb))\n\t\treturn -EROFS;\n\n\tif (ocfs2_mount_local(osb))\n\t\treturn 0;\n\n\tstatus = ocfs2_cluster_lock(osb, lockres, ex ? LKM_EXMODE : LKM_PRMODE,\n\t\t\t\t    0, 0);\n\tif (status < 0)\n\t\tmlog(ML_ERROR, \"lock on nfs sync lock failed %d\\n\", status);\n\n\treturn status;\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"refcounttree.h\"",
      "#include \"quota.h\"",
      "#include \"uptodate.h\"",
      "#include \"super.h\"",
      "#include \"slot_map.h\"",
      "#include \"stackglue.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"heartbeat.h\"",
      "#include \"file.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"dcache.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2_lockingver.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/time.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/kthread.h>",
      "#include <linux/mm.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct ocfs2_super *ocfs2_get_dentry_osb(struct ocfs2_lock_res *lockres);",
      "static struct ocfs2_super *ocfs2_get_inode_osb(struct ocfs2_lock_res *lockres);",
      "static struct ocfs2_super *ocfs2_get_file_osb(struct ocfs2_lock_res *lockres);",
      "static struct ocfs2_super *ocfs2_get_qinfo_osb(struct ocfs2_lock_res *lockres);",
      "static void ocfs2_set_meta_lvb(struct ocfs2_lock_res *lockres);",
      "static void ocfs2_dentry_post_unlock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres);",
      "static void ocfs2_set_qinfo_lvb(struct ocfs2_lock_res *lockres);",
      "static inline void ocfs2_generic_handle_downconvert_action(struct ocfs2_lock_res *lockres);",
      "static inline void ocfs2_generic_handle_convert_action(struct ocfs2_lock_res *lockres);",
      "static inline void ocfs2_generic_handle_attach_action(struct ocfs2_lock_res *lockres);",
      "static void ocfs2_schedule_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);",
      "static void ocfs2_downconvert_on_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);",
      "static void ocfs2_drop_osb_locks(struct ocfs2_super *osb);",
      "static int ocfs2_prepare_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\t        struct ocfs2_lock_res *lockres);",
      "static int ocfs2_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres);",
      "static void ocfs2_process_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *lockres);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mlog",
          "args": [
            "ML_ERROR",
            "\"lock on nfs sync lock failed %d\\n\"",
            "status"
          ],
          "line": 2637
        },
        "resolved": true,
        "details": {
          "function_name": "mlog_show",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/cluster/masklog.c",
          "lines": "107-113",
          "snippet": "static ssize_t mlog_show(struct kobject *obj, struct attribute *attr,\n\t\t\t char *buf)\n{\n\tstruct mlog_attribute *mlog_attr = to_mlog_attr(attr);\n\n\treturn mlog_mask_show(mlog_attr->mask, buf);\n}",
          "includes": [
            "#include \"masklog.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/string.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"masklog.h\"\n#include <asm/uaccess.h>\n#include <linux/string.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n\nstatic ssize_t mlog_show(struct kobject *obj, struct attribute *attr,\n\t\t\t char *buf)\n{\n\tstruct mlog_attribute *mlog_attr = to_mlog_attr(attr);\n\n\treturn mlog_mask_show(mlog_attr->mask, buf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_cluster_lock",
          "args": [
            "osb",
            "lockres",
            "ex ? LKM_EXMODE : LKM_PRMODE",
            "0",
            "0"
          ],
          "line": 2634
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_cluster_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlmglue.c",
          "lines": "1570-1578",
          "snippet": "static inline int ocfs2_cluster_lock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres,\n\t\t\t\t     int level,\n\t\t\t\t     u32 lkm_flags,\n\t\t\t\t     int arg_flags)\n{\n\treturn __ocfs2_cluster_lock(osb, lockres, level, lkm_flags, arg_flags,\n\t\t\t\t    0, _RET_IP_);\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"refcounttree.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"stackglue.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dcache.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2_lockingver.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/time.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/kthread.h>",
            "#include <linux/mm.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct ocfs2_super *ocfs2_get_dentry_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_inode_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_file_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_qinfo_osb(struct ocfs2_lock_res *lockres);",
            "static void ocfs2_set_meta_lvb(struct ocfs2_lock_res *lockres);",
            "static void ocfs2_dentry_post_unlock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres);",
            "static void ocfs2_set_qinfo_lvb(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_downconvert_action(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_convert_action(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_attach_action(struct ocfs2_lock_res *lockres);",
            "static int ocfs2_generic_handle_bast(struct ocfs2_lock_res *lockres, int level);",
            "static void ocfs2_schedule_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static void ocfs2_downconvert_on_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static void ocfs2_drop_osb_locks(struct ocfs2_super *osb);",
            "static inline int ocfs2_highest_compat_lock_level(int level);",
            "static int ocfs2_prepare_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\t        struct ocfs2_lock_res *lockres);",
            "static int ocfs2_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static void ocfs2_process_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *lockres);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"stackglue.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dcache.h\"\n#include \"alloc.h\"\n#include \"ocfs2_lockingver.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/quotaops.h>\n#include <linux/time.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/pagemap.h>\n#include <linux/kthread.h>\n#include <linux/mm.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic struct ocfs2_super *ocfs2_get_dentry_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_inode_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_file_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_qinfo_osb(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_set_meta_lvb(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_dentry_post_unlock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres);\nstatic void ocfs2_set_qinfo_lvb(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_downconvert_action(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_convert_action(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_attach_action(struct ocfs2_lock_res *lockres);\nstatic int ocfs2_generic_handle_bast(struct ocfs2_lock_res *lockres, int level);\nstatic void ocfs2_schedule_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_downconvert_on_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_drop_osb_locks(struct ocfs2_super *osb);\nstatic inline int ocfs2_highest_compat_lock_level(int level);\nstatic int ocfs2_prepare_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\t        struct ocfs2_lock_res *lockres);\nstatic int ocfs2_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_process_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *lockres);\n\nstatic inline int ocfs2_cluster_lock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres,\n\t\t\t\t     int level,\n\t\t\t\t     u32 lkm_flags,\n\t\t\t\t     int arg_flags)\n{\n\treturn __ocfs2_cluster_lock(osb, lockres, level, lkm_flags, arg_flags,\n\t\t\t\t    0, _RET_IP_);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_mount_local",
          "args": [
            "osb"
          ],
          "line": 2631
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_mount_local",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "668-671",
          "snippet": "static inline int ocfs2_mount_local(struct ocfs2_super *osb)\n{\n\treturn (osb->s_feature_incompat & OCFS2_FEATURE_INCOMPAT_LOCAL_MOUNT);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\nstatic inline int ocfs2_mount_local(struct ocfs2_super *osb)\n{\n\treturn (osb->s_feature_incompat & OCFS2_FEATURE_INCOMPAT_LOCAL_MOUNT);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_is_hard_readonly",
          "args": [
            "osb"
          ],
          "line": 2628
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_is_hard_readonly",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "615-624",
          "snippet": "static inline int ocfs2_is_hard_readonly(struct ocfs2_super *osb)\n{\n\tint ret;\n\n\tspin_lock(&osb->osb_lock);\n\tret = osb->osb_flags & OCFS2_OSB_HARD_RO;\n\tspin_unlock(&osb->osb_lock);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [
            "#define OCFS2_OSB_HARD_RO\t0x0002"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\n#define OCFS2_OSB_HARD_RO\t0x0002\n\nstatic inline int ocfs2_is_hard_readonly(struct ocfs2_super *osb)\n{\n\tint ret;\n\n\tspin_lock(&osb->osb_lock);\n\tret = osb->osb_flags & OCFS2_OSB_HARD_RO;\n\tspin_unlock(&osb->osb_lock);\n\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"stackglue.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dcache.h\"\n#include \"alloc.h\"\n#include \"ocfs2_lockingver.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/quotaops.h>\n#include <linux/time.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/pagemap.h>\n#include <linux/kthread.h>\n#include <linux/mm.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic struct ocfs2_super *ocfs2_get_dentry_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_inode_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_file_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_qinfo_osb(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_set_meta_lvb(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_dentry_post_unlock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres);\nstatic void ocfs2_set_qinfo_lvb(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_downconvert_action(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_convert_action(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_attach_action(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_schedule_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_downconvert_on_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_drop_osb_locks(struct ocfs2_super *osb);\nstatic int ocfs2_prepare_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\t        struct ocfs2_lock_res *lockres);\nstatic int ocfs2_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_process_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *lockres);\n\nint ocfs2_nfs_sync_lock(struct ocfs2_super *osb, int ex)\n{\n\tint status;\n\tstruct ocfs2_lock_res *lockres = &osb->osb_nfs_sync_lockres;\n\n\tif (ocfs2_is_hard_readonly(osb))\n\t\treturn -EROFS;\n\n\tif (ocfs2_mount_local(osb))\n\t\treturn 0;\n\n\tstatus = ocfs2_cluster_lock(osb, lockres, ex ? LKM_EXMODE : LKM_PRMODE,\n\t\t\t\t    0, 0);\n\tif (status < 0)\n\t\tmlog(ML_ERROR, \"lock on nfs sync lock failed %d\\n\", status);\n\n\treturn status;\n}"
  },
  {
    "function_name": "ocfs2_rename_unlock",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlmglue.c",
    "lines": "2615-2621",
    "snippet": "void ocfs2_rename_unlock(struct ocfs2_super *osb)\n{\n\tstruct ocfs2_lock_res *lockres = &osb->osb_rename_lockres;\n\n\tif (!ocfs2_mount_local(osb))\n\t\tocfs2_cluster_unlock(osb, lockres, DLM_LOCK_EX);\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"refcounttree.h\"",
      "#include \"quota.h\"",
      "#include \"uptodate.h\"",
      "#include \"super.h\"",
      "#include \"slot_map.h\"",
      "#include \"stackglue.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"heartbeat.h\"",
      "#include \"file.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"dcache.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2_lockingver.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/time.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/kthread.h>",
      "#include <linux/mm.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct ocfs2_super *ocfs2_get_dentry_osb(struct ocfs2_lock_res *lockres);",
      "static struct ocfs2_super *ocfs2_get_inode_osb(struct ocfs2_lock_res *lockres);",
      "static struct ocfs2_super *ocfs2_get_file_osb(struct ocfs2_lock_res *lockres);",
      "static struct ocfs2_super *ocfs2_get_qinfo_osb(struct ocfs2_lock_res *lockres);",
      "static void ocfs2_set_meta_lvb(struct ocfs2_lock_res *lockres);",
      "static void ocfs2_dentry_post_unlock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres);",
      "static void ocfs2_set_qinfo_lvb(struct ocfs2_lock_res *lockres);",
      "static inline void ocfs2_generic_handle_downconvert_action(struct ocfs2_lock_res *lockres);",
      "static inline void ocfs2_generic_handle_convert_action(struct ocfs2_lock_res *lockres);",
      "static inline void ocfs2_generic_handle_attach_action(struct ocfs2_lock_res *lockres);",
      "static void ocfs2_schedule_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);",
      "static void ocfs2_downconvert_on_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);",
      "static void ocfs2_drop_osb_locks(struct ocfs2_super *osb);",
      "static int ocfs2_prepare_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\t        struct ocfs2_lock_res *lockres);",
      "static int ocfs2_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres);",
      "static void ocfs2_process_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *lockres);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ocfs2_cluster_unlock",
          "args": [
            "osb",
            "lockres",
            "DLM_LOCK_EX"
          ],
          "line": 2620
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_cluster_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlmglue.c",
          "lines": "349-354",
          "snippet": "static inline void ocfs2_cluster_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres,\n\t\t\t\t\tint level)\n{\n\t__ocfs2_cluster_unlock(osb, lockres, level, _RET_IP_);\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"refcounttree.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"stackglue.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dcache.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2_lockingver.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/time.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/kthread.h>",
            "#include <linux/mm.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct ocfs2_super *ocfs2_get_dentry_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_inode_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_file_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_qinfo_osb(struct ocfs2_lock_res *lockres);",
            "static void ocfs2_set_meta_lvb(struct ocfs2_lock_res *lockres);",
            "static void ocfs2_dentry_post_unlock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres);",
            "static void ocfs2_set_qinfo_lvb(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_downconvert_action(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_convert_action(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_attach_action(struct ocfs2_lock_res *lockres);",
            "static int ocfs2_generic_handle_bast(struct ocfs2_lock_res *lockres, int level);",
            "static void ocfs2_schedule_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static void ocfs2_downconvert_on_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static void ocfs2_drop_osb_locks(struct ocfs2_super *osb);",
            "static inline int ocfs2_highest_compat_lock_level(int level);",
            "static int ocfs2_prepare_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\t        struct ocfs2_lock_res *lockres);",
            "static int ocfs2_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static void ocfs2_process_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *lockres);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"stackglue.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dcache.h\"\n#include \"alloc.h\"\n#include \"ocfs2_lockingver.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/quotaops.h>\n#include <linux/time.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/pagemap.h>\n#include <linux/kthread.h>\n#include <linux/mm.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic struct ocfs2_super *ocfs2_get_dentry_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_inode_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_file_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_qinfo_osb(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_set_meta_lvb(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_dentry_post_unlock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres);\nstatic void ocfs2_set_qinfo_lvb(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_downconvert_action(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_convert_action(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_attach_action(struct ocfs2_lock_res *lockres);\nstatic int ocfs2_generic_handle_bast(struct ocfs2_lock_res *lockres, int level);\nstatic void ocfs2_schedule_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_downconvert_on_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_drop_osb_locks(struct ocfs2_super *osb);\nstatic inline int ocfs2_highest_compat_lock_level(int level);\nstatic int ocfs2_prepare_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\t        struct ocfs2_lock_res *lockres);\nstatic int ocfs2_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_process_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *lockres);\n\nstatic inline void ocfs2_cluster_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres,\n\t\t\t\t\tint level)\n{\n\t__ocfs2_cluster_unlock(osb, lockres, level, _RET_IP_);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_mount_local",
          "args": [
            "osb"
          ],
          "line": 2619
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_mount_local",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "668-671",
          "snippet": "static inline int ocfs2_mount_local(struct ocfs2_super *osb)\n{\n\treturn (osb->s_feature_incompat & OCFS2_FEATURE_INCOMPAT_LOCAL_MOUNT);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\nstatic inline int ocfs2_mount_local(struct ocfs2_super *osb)\n{\n\treturn (osb->s_feature_incompat & OCFS2_FEATURE_INCOMPAT_LOCAL_MOUNT);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"stackglue.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dcache.h\"\n#include \"alloc.h\"\n#include \"ocfs2_lockingver.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/quotaops.h>\n#include <linux/time.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/pagemap.h>\n#include <linux/kthread.h>\n#include <linux/mm.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic struct ocfs2_super *ocfs2_get_dentry_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_inode_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_file_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_qinfo_osb(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_set_meta_lvb(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_dentry_post_unlock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres);\nstatic void ocfs2_set_qinfo_lvb(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_downconvert_action(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_convert_action(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_attach_action(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_schedule_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_downconvert_on_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_drop_osb_locks(struct ocfs2_super *osb);\nstatic int ocfs2_prepare_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\t        struct ocfs2_lock_res *lockres);\nstatic int ocfs2_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_process_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *lockres);\n\nvoid ocfs2_rename_unlock(struct ocfs2_super *osb)\n{\n\tstruct ocfs2_lock_res *lockres = &osb->osb_rename_lockres;\n\n\tif (!ocfs2_mount_local(osb))\n\t\tocfs2_cluster_unlock(osb, lockres, DLM_LOCK_EX);\n}"
  },
  {
    "function_name": "ocfs2_rename_lock",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlmglue.c",
    "lines": "2597-2613",
    "snippet": "int ocfs2_rename_lock(struct ocfs2_super *osb)\n{\n\tint status;\n\tstruct ocfs2_lock_res *lockres = &osb->osb_rename_lockres;\n\n\tif (ocfs2_is_hard_readonly(osb))\n\t\treturn -EROFS;\n\n\tif (ocfs2_mount_local(osb))\n\t\treturn 0;\n\n\tstatus = ocfs2_cluster_lock(osb, lockres, DLM_LOCK_EX, 0, 0);\n\tif (status < 0)\n\t\tmlog_errno(status);\n\n\treturn status;\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"refcounttree.h\"",
      "#include \"quota.h\"",
      "#include \"uptodate.h\"",
      "#include \"super.h\"",
      "#include \"slot_map.h\"",
      "#include \"stackglue.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"heartbeat.h\"",
      "#include \"file.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"dcache.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2_lockingver.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/time.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/kthread.h>",
      "#include <linux/mm.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct ocfs2_super *ocfs2_get_dentry_osb(struct ocfs2_lock_res *lockres);",
      "static struct ocfs2_super *ocfs2_get_inode_osb(struct ocfs2_lock_res *lockres);",
      "static struct ocfs2_super *ocfs2_get_file_osb(struct ocfs2_lock_res *lockres);",
      "static struct ocfs2_super *ocfs2_get_qinfo_osb(struct ocfs2_lock_res *lockres);",
      "static void ocfs2_set_meta_lvb(struct ocfs2_lock_res *lockres);",
      "static void ocfs2_dentry_post_unlock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres);",
      "static void ocfs2_set_qinfo_lvb(struct ocfs2_lock_res *lockres);",
      "static inline void ocfs2_generic_handle_downconvert_action(struct ocfs2_lock_res *lockres);",
      "static inline void ocfs2_generic_handle_convert_action(struct ocfs2_lock_res *lockres);",
      "static inline void ocfs2_generic_handle_attach_action(struct ocfs2_lock_res *lockres);",
      "static void ocfs2_schedule_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);",
      "static void ocfs2_downconvert_on_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);",
      "static void ocfs2_drop_osb_locks(struct ocfs2_super *osb);",
      "static int ocfs2_prepare_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\t        struct ocfs2_lock_res *lockres);",
      "static int ocfs2_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres);",
      "static void ocfs2_process_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *lockres);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "status"
          ],
          "line": 2610
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_cluster_lock",
          "args": [
            "osb",
            "lockres",
            "DLM_LOCK_EX",
            "0",
            "0"
          ],
          "line": 2608
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_cluster_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlmglue.c",
          "lines": "1570-1578",
          "snippet": "static inline int ocfs2_cluster_lock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres,\n\t\t\t\t     int level,\n\t\t\t\t     u32 lkm_flags,\n\t\t\t\t     int arg_flags)\n{\n\treturn __ocfs2_cluster_lock(osb, lockres, level, lkm_flags, arg_flags,\n\t\t\t\t    0, _RET_IP_);\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"refcounttree.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"stackglue.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dcache.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2_lockingver.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/time.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/kthread.h>",
            "#include <linux/mm.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct ocfs2_super *ocfs2_get_dentry_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_inode_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_file_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_qinfo_osb(struct ocfs2_lock_res *lockres);",
            "static void ocfs2_set_meta_lvb(struct ocfs2_lock_res *lockres);",
            "static void ocfs2_dentry_post_unlock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres);",
            "static void ocfs2_set_qinfo_lvb(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_downconvert_action(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_convert_action(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_attach_action(struct ocfs2_lock_res *lockres);",
            "static int ocfs2_generic_handle_bast(struct ocfs2_lock_res *lockres, int level);",
            "static void ocfs2_schedule_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static void ocfs2_downconvert_on_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static void ocfs2_drop_osb_locks(struct ocfs2_super *osb);",
            "static inline int ocfs2_highest_compat_lock_level(int level);",
            "static int ocfs2_prepare_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\t        struct ocfs2_lock_res *lockres);",
            "static int ocfs2_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static void ocfs2_process_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *lockres);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"stackglue.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dcache.h\"\n#include \"alloc.h\"\n#include \"ocfs2_lockingver.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/quotaops.h>\n#include <linux/time.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/pagemap.h>\n#include <linux/kthread.h>\n#include <linux/mm.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic struct ocfs2_super *ocfs2_get_dentry_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_inode_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_file_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_qinfo_osb(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_set_meta_lvb(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_dentry_post_unlock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres);\nstatic void ocfs2_set_qinfo_lvb(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_downconvert_action(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_convert_action(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_attach_action(struct ocfs2_lock_res *lockres);\nstatic int ocfs2_generic_handle_bast(struct ocfs2_lock_res *lockres, int level);\nstatic void ocfs2_schedule_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_downconvert_on_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_drop_osb_locks(struct ocfs2_super *osb);\nstatic inline int ocfs2_highest_compat_lock_level(int level);\nstatic int ocfs2_prepare_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\t        struct ocfs2_lock_res *lockres);\nstatic int ocfs2_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_process_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *lockres);\n\nstatic inline int ocfs2_cluster_lock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres,\n\t\t\t\t     int level,\n\t\t\t\t     u32 lkm_flags,\n\t\t\t\t     int arg_flags)\n{\n\treturn __ocfs2_cluster_lock(osb, lockres, level, lkm_flags, arg_flags,\n\t\t\t\t    0, _RET_IP_);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_mount_local",
          "args": [
            "osb"
          ],
          "line": 2605
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_mount_local",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "668-671",
          "snippet": "static inline int ocfs2_mount_local(struct ocfs2_super *osb)\n{\n\treturn (osb->s_feature_incompat & OCFS2_FEATURE_INCOMPAT_LOCAL_MOUNT);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\nstatic inline int ocfs2_mount_local(struct ocfs2_super *osb)\n{\n\treturn (osb->s_feature_incompat & OCFS2_FEATURE_INCOMPAT_LOCAL_MOUNT);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_is_hard_readonly",
          "args": [
            "osb"
          ],
          "line": 2602
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_is_hard_readonly",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "615-624",
          "snippet": "static inline int ocfs2_is_hard_readonly(struct ocfs2_super *osb)\n{\n\tint ret;\n\n\tspin_lock(&osb->osb_lock);\n\tret = osb->osb_flags & OCFS2_OSB_HARD_RO;\n\tspin_unlock(&osb->osb_lock);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [
            "#define OCFS2_OSB_HARD_RO\t0x0002"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\n#define OCFS2_OSB_HARD_RO\t0x0002\n\nstatic inline int ocfs2_is_hard_readonly(struct ocfs2_super *osb)\n{\n\tint ret;\n\n\tspin_lock(&osb->osb_lock);\n\tret = osb->osb_flags & OCFS2_OSB_HARD_RO;\n\tspin_unlock(&osb->osb_lock);\n\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"stackglue.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dcache.h\"\n#include \"alloc.h\"\n#include \"ocfs2_lockingver.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/quotaops.h>\n#include <linux/time.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/pagemap.h>\n#include <linux/kthread.h>\n#include <linux/mm.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic struct ocfs2_super *ocfs2_get_dentry_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_inode_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_file_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_qinfo_osb(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_set_meta_lvb(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_dentry_post_unlock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres);\nstatic void ocfs2_set_qinfo_lvb(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_downconvert_action(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_convert_action(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_attach_action(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_schedule_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_downconvert_on_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_drop_osb_locks(struct ocfs2_super *osb);\nstatic int ocfs2_prepare_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\t        struct ocfs2_lock_res *lockres);\nstatic int ocfs2_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_process_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *lockres);\n\nint ocfs2_rename_lock(struct ocfs2_super *osb)\n{\n\tint status;\n\tstruct ocfs2_lock_res *lockres = &osb->osb_rename_lockres;\n\n\tif (ocfs2_is_hard_readonly(osb))\n\t\treturn -EROFS;\n\n\tif (ocfs2_mount_local(osb))\n\t\treturn 0;\n\n\tstatus = ocfs2_cluster_lock(osb, lockres, DLM_LOCK_EX, 0, 0);\n\tif (status < 0)\n\t\tmlog_errno(status);\n\n\treturn status;\n}"
  },
  {
    "function_name": "ocfs2_super_unlock",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlmglue.c",
    "lines": "2587-2595",
    "snippet": "void ocfs2_super_unlock(struct ocfs2_super *osb,\n\t\t\tint ex)\n{\n\tint level = ex ? DLM_LOCK_EX : DLM_LOCK_PR;\n\tstruct ocfs2_lock_res *lockres = &osb->osb_super_lockres;\n\n\tif (!ocfs2_mount_local(osb))\n\t\tocfs2_cluster_unlock(osb, lockres, level);\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"refcounttree.h\"",
      "#include \"quota.h\"",
      "#include \"uptodate.h\"",
      "#include \"super.h\"",
      "#include \"slot_map.h\"",
      "#include \"stackglue.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"heartbeat.h\"",
      "#include \"file.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"dcache.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2_lockingver.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/time.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/kthread.h>",
      "#include <linux/mm.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct ocfs2_super *ocfs2_get_dentry_osb(struct ocfs2_lock_res *lockres);",
      "static struct ocfs2_super *ocfs2_get_inode_osb(struct ocfs2_lock_res *lockres);",
      "static struct ocfs2_super *ocfs2_get_file_osb(struct ocfs2_lock_res *lockres);",
      "static struct ocfs2_super *ocfs2_get_qinfo_osb(struct ocfs2_lock_res *lockres);",
      "static void ocfs2_set_meta_lvb(struct ocfs2_lock_res *lockres);",
      "static void ocfs2_dentry_post_unlock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres);",
      "static void ocfs2_set_qinfo_lvb(struct ocfs2_lock_res *lockres);",
      "static inline void ocfs2_generic_handle_downconvert_action(struct ocfs2_lock_res *lockres);",
      "static inline void ocfs2_generic_handle_convert_action(struct ocfs2_lock_res *lockres);",
      "static inline void ocfs2_generic_handle_attach_action(struct ocfs2_lock_res *lockres);",
      "static int ocfs2_generic_handle_bast(struct ocfs2_lock_res *lockres, int level);",
      "static void ocfs2_schedule_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);",
      "static void ocfs2_downconvert_on_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);",
      "static void ocfs2_drop_osb_locks(struct ocfs2_super *osb);",
      "static inline int ocfs2_highest_compat_lock_level(int level);",
      "static int ocfs2_prepare_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\t        struct ocfs2_lock_res *lockres);",
      "static int ocfs2_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres);",
      "static void ocfs2_process_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *lockres);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ocfs2_cluster_unlock",
          "args": [
            "osb",
            "lockres",
            "level"
          ],
          "line": 2594
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_cluster_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlmglue.c",
          "lines": "349-354",
          "snippet": "static inline void ocfs2_cluster_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres,\n\t\t\t\t\tint level)\n{\n\t__ocfs2_cluster_unlock(osb, lockres, level, _RET_IP_);\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"refcounttree.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"stackglue.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dcache.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2_lockingver.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/time.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/kthread.h>",
            "#include <linux/mm.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct ocfs2_super *ocfs2_get_dentry_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_inode_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_file_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_qinfo_osb(struct ocfs2_lock_res *lockres);",
            "static void ocfs2_set_meta_lvb(struct ocfs2_lock_res *lockres);",
            "static void ocfs2_dentry_post_unlock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres);",
            "static void ocfs2_set_qinfo_lvb(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_downconvert_action(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_convert_action(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_attach_action(struct ocfs2_lock_res *lockres);",
            "static int ocfs2_generic_handle_bast(struct ocfs2_lock_res *lockres, int level);",
            "static void ocfs2_schedule_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static void ocfs2_downconvert_on_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static void ocfs2_drop_osb_locks(struct ocfs2_super *osb);",
            "static inline int ocfs2_highest_compat_lock_level(int level);",
            "static int ocfs2_prepare_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\t        struct ocfs2_lock_res *lockres);",
            "static int ocfs2_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static void ocfs2_process_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *lockres);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"stackglue.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dcache.h\"\n#include \"alloc.h\"\n#include \"ocfs2_lockingver.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/quotaops.h>\n#include <linux/time.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/pagemap.h>\n#include <linux/kthread.h>\n#include <linux/mm.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic struct ocfs2_super *ocfs2_get_dentry_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_inode_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_file_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_qinfo_osb(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_set_meta_lvb(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_dentry_post_unlock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres);\nstatic void ocfs2_set_qinfo_lvb(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_downconvert_action(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_convert_action(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_attach_action(struct ocfs2_lock_res *lockres);\nstatic int ocfs2_generic_handle_bast(struct ocfs2_lock_res *lockres, int level);\nstatic void ocfs2_schedule_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_downconvert_on_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_drop_osb_locks(struct ocfs2_super *osb);\nstatic inline int ocfs2_highest_compat_lock_level(int level);\nstatic int ocfs2_prepare_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\t        struct ocfs2_lock_res *lockres);\nstatic int ocfs2_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_process_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *lockres);\n\nstatic inline void ocfs2_cluster_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres,\n\t\t\t\t\tint level)\n{\n\t__ocfs2_cluster_unlock(osb, lockres, level, _RET_IP_);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_mount_local",
          "args": [
            "osb"
          ],
          "line": 2593
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_mount_local",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "668-671",
          "snippet": "static inline int ocfs2_mount_local(struct ocfs2_super *osb)\n{\n\treturn (osb->s_feature_incompat & OCFS2_FEATURE_INCOMPAT_LOCAL_MOUNT);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\nstatic inline int ocfs2_mount_local(struct ocfs2_super *osb)\n{\n\treturn (osb->s_feature_incompat & OCFS2_FEATURE_INCOMPAT_LOCAL_MOUNT);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"stackglue.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dcache.h\"\n#include \"alloc.h\"\n#include \"ocfs2_lockingver.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/quotaops.h>\n#include <linux/time.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/pagemap.h>\n#include <linux/kthread.h>\n#include <linux/mm.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic struct ocfs2_super *ocfs2_get_dentry_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_inode_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_file_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_qinfo_osb(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_set_meta_lvb(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_dentry_post_unlock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres);\nstatic void ocfs2_set_qinfo_lvb(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_downconvert_action(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_convert_action(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_attach_action(struct ocfs2_lock_res *lockres);\nstatic int ocfs2_generic_handle_bast(struct ocfs2_lock_res *lockres, int level);\nstatic void ocfs2_schedule_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_downconvert_on_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_drop_osb_locks(struct ocfs2_super *osb);\nstatic inline int ocfs2_highest_compat_lock_level(int level);\nstatic int ocfs2_prepare_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\t        struct ocfs2_lock_res *lockres);\nstatic int ocfs2_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_process_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *lockres);\n\nvoid ocfs2_super_unlock(struct ocfs2_super *osb,\n\t\t\tint ex)\n{\n\tint level = ex ? DLM_LOCK_EX : DLM_LOCK_PR;\n\tstruct ocfs2_lock_res *lockres = &osb->osb_super_lockres;\n\n\tif (!ocfs2_mount_local(osb))\n\t\tocfs2_cluster_unlock(osb, lockres, level);\n}"
  },
  {
    "function_name": "ocfs2_super_lock",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlmglue.c",
    "lines": "2548-2585",
    "snippet": "int ocfs2_super_lock(struct ocfs2_super *osb,\n\t\t     int ex)\n{\n\tint status = 0;\n\tint level = ex ? DLM_LOCK_EX : DLM_LOCK_PR;\n\tstruct ocfs2_lock_res *lockres = &osb->osb_super_lockres;\n\n\tif (ocfs2_is_hard_readonly(osb))\n\t\treturn -EROFS;\n\n\tif (ocfs2_mount_local(osb))\n\t\tgoto bail;\n\n\tstatus = ocfs2_cluster_lock(osb, lockres, level, 0, 0);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\t/* The super block lock path is really in the best position to\n\t * know when resources covered by the lock need to be\n\t * refreshed, so we do it here. Of course, making sense of\n\t * everything is up to the caller :) */\n\tstatus = ocfs2_should_refresh_lock_res(lockres);\n\tif (status) {\n\t\tstatus = ocfs2_refresh_slot_info(osb);\n\n\t\tocfs2_complete_lock_res_refresh(lockres, status);\n\n\t\tif (status < 0) {\n\t\t\tocfs2_cluster_unlock(osb, lockres, level);\n\t\t\tmlog_errno(status);\n\t\t}\n\t\tocfs2_track_lock_refresh(lockres);\n\t}\nbail:\n\treturn status;\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"refcounttree.h\"",
      "#include \"quota.h\"",
      "#include \"uptodate.h\"",
      "#include \"super.h\"",
      "#include \"slot_map.h\"",
      "#include \"stackglue.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"heartbeat.h\"",
      "#include \"file.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"dcache.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2_lockingver.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/time.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/kthread.h>",
      "#include <linux/mm.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct ocfs2_super *ocfs2_get_dentry_osb(struct ocfs2_lock_res *lockres);",
      "static struct ocfs2_super *ocfs2_get_inode_osb(struct ocfs2_lock_res *lockres);",
      "static struct ocfs2_super *ocfs2_get_file_osb(struct ocfs2_lock_res *lockres);",
      "static struct ocfs2_super *ocfs2_get_qinfo_osb(struct ocfs2_lock_res *lockres);",
      "static void ocfs2_set_meta_lvb(struct ocfs2_lock_res *lockres);",
      "static void ocfs2_dentry_post_unlock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres);",
      "static void ocfs2_set_qinfo_lvb(struct ocfs2_lock_res *lockres);",
      "static inline void ocfs2_generic_handle_downconvert_action(struct ocfs2_lock_res *lockres);",
      "static inline void ocfs2_generic_handle_convert_action(struct ocfs2_lock_res *lockres);",
      "static inline void ocfs2_generic_handle_attach_action(struct ocfs2_lock_res *lockres);",
      "static int ocfs2_generic_handle_bast(struct ocfs2_lock_res *lockres, int level);",
      "static void ocfs2_schedule_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);",
      "static void ocfs2_downconvert_on_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);",
      "static void ocfs2_drop_osb_locks(struct ocfs2_super *osb);",
      "static inline int ocfs2_highest_compat_lock_level(int level);",
      "static int ocfs2_prepare_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\t        struct ocfs2_lock_res *lockres);",
      "static int ocfs2_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres);",
      "static void ocfs2_process_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *lockres);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ocfs2_track_lock_refresh",
          "args": [
            "lockres"
          ],
          "line": 2581
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_track_lock_refresh",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlmglue.c",
          "lines": "488-490",
          "snippet": "static inline void ocfs2_track_lock_refresh(struct ocfs2_lock_res *lockres)\n{\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"refcounttree.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"stackglue.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dcache.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2_lockingver.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/time.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/kthread.h>",
            "#include <linux/mm.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct ocfs2_super *ocfs2_get_dentry_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_inode_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_file_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_qinfo_osb(struct ocfs2_lock_res *lockres);",
            "static void ocfs2_set_meta_lvb(struct ocfs2_lock_res *lockres);",
            "static void ocfs2_dentry_post_unlock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres);",
            "static void ocfs2_set_qinfo_lvb(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_downconvert_action(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_convert_action(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_attach_action(struct ocfs2_lock_res *lockres);",
            "static void ocfs2_schedule_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static void ocfs2_downconvert_on_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static int ocfs2_prepare_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\t        struct ocfs2_lock_res *lockres);",
            "static int ocfs2_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static void ocfs2_process_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *lockres);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"stackglue.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dcache.h\"\n#include \"alloc.h\"\n#include \"ocfs2_lockingver.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/quotaops.h>\n#include <linux/time.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/pagemap.h>\n#include <linux/kthread.h>\n#include <linux/mm.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic struct ocfs2_super *ocfs2_get_dentry_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_inode_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_file_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_qinfo_osb(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_set_meta_lvb(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_dentry_post_unlock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres);\nstatic void ocfs2_set_qinfo_lvb(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_downconvert_action(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_convert_action(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_attach_action(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_schedule_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_downconvert_on_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic int ocfs2_prepare_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\t        struct ocfs2_lock_res *lockres);\nstatic int ocfs2_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_process_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *lockres);\n\nstatic inline void ocfs2_track_lock_refresh(struct ocfs2_lock_res *lockres)\n{\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "status"
          ],
          "line": 2579
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_cluster_unlock",
          "args": [
            "osb",
            "lockres",
            "level"
          ],
          "line": 2578
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_cluster_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlmglue.c",
          "lines": "349-354",
          "snippet": "static inline void ocfs2_cluster_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres,\n\t\t\t\t\tint level)\n{\n\t__ocfs2_cluster_unlock(osb, lockres, level, _RET_IP_);\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"refcounttree.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"stackglue.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dcache.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2_lockingver.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/time.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/kthread.h>",
            "#include <linux/mm.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct ocfs2_super *ocfs2_get_dentry_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_inode_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_file_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_qinfo_osb(struct ocfs2_lock_res *lockres);",
            "static void ocfs2_set_meta_lvb(struct ocfs2_lock_res *lockres);",
            "static void ocfs2_dentry_post_unlock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres);",
            "static void ocfs2_set_qinfo_lvb(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_downconvert_action(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_convert_action(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_attach_action(struct ocfs2_lock_res *lockres);",
            "static int ocfs2_generic_handle_bast(struct ocfs2_lock_res *lockres, int level);",
            "static void ocfs2_schedule_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static void ocfs2_downconvert_on_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static void ocfs2_drop_osb_locks(struct ocfs2_super *osb);",
            "static inline int ocfs2_highest_compat_lock_level(int level);",
            "static int ocfs2_prepare_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\t        struct ocfs2_lock_res *lockres);",
            "static int ocfs2_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static void ocfs2_process_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *lockres);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"stackglue.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dcache.h\"\n#include \"alloc.h\"\n#include \"ocfs2_lockingver.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/quotaops.h>\n#include <linux/time.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/pagemap.h>\n#include <linux/kthread.h>\n#include <linux/mm.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic struct ocfs2_super *ocfs2_get_dentry_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_inode_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_file_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_qinfo_osb(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_set_meta_lvb(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_dentry_post_unlock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres);\nstatic void ocfs2_set_qinfo_lvb(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_downconvert_action(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_convert_action(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_attach_action(struct ocfs2_lock_res *lockres);\nstatic int ocfs2_generic_handle_bast(struct ocfs2_lock_res *lockres, int level);\nstatic void ocfs2_schedule_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_downconvert_on_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_drop_osb_locks(struct ocfs2_super *osb);\nstatic inline int ocfs2_highest_compat_lock_level(int level);\nstatic int ocfs2_prepare_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\t        struct ocfs2_lock_res *lockres);\nstatic int ocfs2_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_process_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *lockres);\n\nstatic inline void ocfs2_cluster_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres,\n\t\t\t\t\tint level)\n{\n\t__ocfs2_cluster_unlock(osb, lockres, level, _RET_IP_);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_complete_lock_res_refresh",
          "args": [
            "lockres",
            "status"
          ],
          "line": 2575
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_complete_lock_res_refresh",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlmglue.c",
          "lines": "2186-2198",
          "snippet": "static inline void ocfs2_complete_lock_res_refresh(struct ocfs2_lock_res *lockres,\n\t\t\t\t\t\t   int status)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&lockres->l_lock, flags);\n\tlockres_clear_flags(lockres, OCFS2_LOCK_REFRESHING);\n\tif (!status)\n\t\tlockres_clear_flags(lockres, OCFS2_LOCK_NEEDS_REFRESH);\n\tspin_unlock_irqrestore(&lockres->l_lock, flags);\n\n\twake_up(&lockres->l_event);\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"refcounttree.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"stackglue.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dcache.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2_lockingver.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/time.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/kthread.h>",
            "#include <linux/mm.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct ocfs2_super *ocfs2_get_dentry_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_inode_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_file_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_qinfo_osb(struct ocfs2_lock_res *lockres);",
            "static void ocfs2_set_meta_lvb(struct ocfs2_lock_res *lockres);",
            "static void ocfs2_dentry_post_unlock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres);",
            "static void ocfs2_set_qinfo_lvb(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_downconvert_action(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_convert_action(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_attach_action(struct ocfs2_lock_res *lockres);",
            "static void ocfs2_schedule_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static void ocfs2_downconvert_on_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static int ocfs2_prepare_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\t        struct ocfs2_lock_res *lockres);",
            "static int ocfs2_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static void ocfs2_process_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *lockres);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"stackglue.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dcache.h\"\n#include \"alloc.h\"\n#include \"ocfs2_lockingver.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/quotaops.h>\n#include <linux/time.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/pagemap.h>\n#include <linux/kthread.h>\n#include <linux/mm.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic struct ocfs2_super *ocfs2_get_dentry_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_inode_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_file_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_qinfo_osb(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_set_meta_lvb(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_dentry_post_unlock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres);\nstatic void ocfs2_set_qinfo_lvb(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_downconvert_action(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_convert_action(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_attach_action(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_schedule_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_downconvert_on_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic int ocfs2_prepare_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\t        struct ocfs2_lock_res *lockres);\nstatic int ocfs2_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_process_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *lockres);\n\nstatic inline void ocfs2_complete_lock_res_refresh(struct ocfs2_lock_res *lockres,\n\t\t\t\t\t\t   int status)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&lockres->l_lock, flags);\n\tlockres_clear_flags(lockres, OCFS2_LOCK_REFRESHING);\n\tif (!status)\n\t\tlockres_clear_flags(lockres, OCFS2_LOCK_NEEDS_REFRESH);\n\tspin_unlock_irqrestore(&lockres->l_lock, flags);\n\n\twake_up(&lockres->l_event);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_refresh_slot_info",
          "args": [
            "osb"
          ],
          "line": 2573
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_refresh_slot_info",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/slot_map.c",
          "lines": "134-161",
          "snippet": "int ocfs2_refresh_slot_info(struct ocfs2_super *osb)\n{\n\tint ret;\n\tstruct ocfs2_slot_info *si = osb->slot_info;\n\n\tif (si == NULL)\n\t\treturn 0;\n\n\tBUG_ON(si->si_blocks == 0);\n\tBUG_ON(si->si_bh == NULL);\n\n\ttrace_ocfs2_refresh_slot_info(si->si_blocks);\n\n\t/*\n\t * We pass -1 as blocknr because we expect all of si->si_bh to\n\t * be !NULL.  Thus, ocfs2_read_blocks() will ignore blocknr.  If\n\t * this is not true, the read of -1 (UINT64_MAX) will fail.\n\t */\n\tret = ocfs2_read_blocks(INODE_CACHE(si->si_inode), -1, si->si_blocks,\n\t\t\t\tsi->si_bh, OCFS2_BH_IGNORE_CACHE, NULL);\n\tif (ret == 0) {\n\t\tspin_lock(&osb->osb_lock);\n\t\tocfs2_update_slot_info(si);\n\t\tspin_unlock(&osb->osb_lock);\n\t}\n\n\treturn ret;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nint ocfs2_refresh_slot_info(struct ocfs2_super *osb)\n{\n\tint ret;\n\tstruct ocfs2_slot_info *si = osb->slot_info;\n\n\tif (si == NULL)\n\t\treturn 0;\n\n\tBUG_ON(si->si_blocks == 0);\n\tBUG_ON(si->si_bh == NULL);\n\n\ttrace_ocfs2_refresh_slot_info(si->si_blocks);\n\n\t/*\n\t * We pass -1 as blocknr because we expect all of si->si_bh to\n\t * be !NULL.  Thus, ocfs2_read_blocks() will ignore blocknr.  If\n\t * this is not true, the read of -1 (UINT64_MAX) will fail.\n\t */\n\tret = ocfs2_read_blocks(INODE_CACHE(si->si_inode), -1, si->si_blocks,\n\t\t\t\tsi->si_bh, OCFS2_BH_IGNORE_CACHE, NULL);\n\tif (ret == 0) {\n\t\tspin_lock(&osb->osb_lock);\n\t\tocfs2_update_slot_info(si);\n\t\tspin_unlock(&osb->osb_lock);\n\t}\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_should_refresh_lock_res",
          "args": [
            "lockres"
          ],
          "line": 2571
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_should_refresh_lock_res",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlmglue.c",
          "lines": "2155-2182",
          "snippet": "static int ocfs2_should_refresh_lock_res(struct ocfs2_lock_res *lockres)\n{\n\tunsigned long flags;\n\tint status = 0;\n\nrefresh_check:\n\tspin_lock_irqsave(&lockres->l_lock, flags);\n\tif (!(lockres->l_flags & OCFS2_LOCK_NEEDS_REFRESH)) {\n\t\tspin_unlock_irqrestore(&lockres->l_lock, flags);\n\t\tgoto bail;\n\t}\n\n\tif (lockres->l_flags & OCFS2_LOCK_REFRESHING) {\n\t\tspin_unlock_irqrestore(&lockres->l_lock, flags);\n\n\t\tocfs2_wait_on_refreshing_lock(lockres);\n\t\tgoto refresh_check;\n\t}\n\n\t/* Ok, I'll be the one to refresh this lock. */\n\tlockres_or_flags(lockres, OCFS2_LOCK_REFRESHING);\n\tspin_unlock_irqrestore(&lockres->l_lock, flags);\n\n\tstatus = 1;\nbail:\n\tmlog(0, \"status %d\\n\", status);\n\treturn status;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"refcounttree.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"stackglue.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dcache.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2_lockingver.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/time.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/kthread.h>",
            "#include <linux/mm.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct ocfs2_super *ocfs2_get_dentry_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_inode_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_file_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_qinfo_osb(struct ocfs2_lock_res *lockres);",
            "static void ocfs2_set_meta_lvb(struct ocfs2_lock_res *lockres);",
            "static void ocfs2_dentry_post_unlock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres);",
            "static void ocfs2_set_qinfo_lvb(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_downconvert_action(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_convert_action(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_attach_action(struct ocfs2_lock_res *lockres);",
            "static void ocfs2_schedule_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static void ocfs2_downconvert_on_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static int ocfs2_prepare_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\t        struct ocfs2_lock_res *lockres);",
            "static int ocfs2_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static void ocfs2_process_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *lockres);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"stackglue.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dcache.h\"\n#include \"alloc.h\"\n#include \"ocfs2_lockingver.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/quotaops.h>\n#include <linux/time.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/pagemap.h>\n#include <linux/kthread.h>\n#include <linux/mm.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic struct ocfs2_super *ocfs2_get_dentry_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_inode_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_file_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_qinfo_osb(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_set_meta_lvb(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_dentry_post_unlock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres);\nstatic void ocfs2_set_qinfo_lvb(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_downconvert_action(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_convert_action(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_attach_action(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_schedule_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_downconvert_on_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic int ocfs2_prepare_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\t        struct ocfs2_lock_res *lockres);\nstatic int ocfs2_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_process_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *lockres);\n\nstatic int ocfs2_should_refresh_lock_res(struct ocfs2_lock_res *lockres)\n{\n\tunsigned long flags;\n\tint status = 0;\n\nrefresh_check:\n\tspin_lock_irqsave(&lockres->l_lock, flags);\n\tif (!(lockres->l_flags & OCFS2_LOCK_NEEDS_REFRESH)) {\n\t\tspin_unlock_irqrestore(&lockres->l_lock, flags);\n\t\tgoto bail;\n\t}\n\n\tif (lockres->l_flags & OCFS2_LOCK_REFRESHING) {\n\t\tspin_unlock_irqrestore(&lockres->l_lock, flags);\n\n\t\tocfs2_wait_on_refreshing_lock(lockres);\n\t\tgoto refresh_check;\n\t}\n\n\t/* Ok, I'll be the one to refresh this lock. */\n\tlockres_or_flags(lockres, OCFS2_LOCK_REFRESHING);\n\tspin_unlock_irqrestore(&lockres->l_lock, flags);\n\n\tstatus = 1;\nbail:\n\tmlog(0, \"status %d\\n\", status);\n\treturn status;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "status"
          ],
          "line": 2563
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_cluster_lock",
          "args": [
            "osb",
            "lockres",
            "level",
            "0",
            "0"
          ],
          "line": 2561
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_cluster_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlmglue.c",
          "lines": "1570-1578",
          "snippet": "static inline int ocfs2_cluster_lock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres,\n\t\t\t\t     int level,\n\t\t\t\t     u32 lkm_flags,\n\t\t\t\t     int arg_flags)\n{\n\treturn __ocfs2_cluster_lock(osb, lockres, level, lkm_flags, arg_flags,\n\t\t\t\t    0, _RET_IP_);\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"refcounttree.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"stackglue.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dcache.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2_lockingver.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/time.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/kthread.h>",
            "#include <linux/mm.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct ocfs2_super *ocfs2_get_dentry_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_inode_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_file_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_qinfo_osb(struct ocfs2_lock_res *lockres);",
            "static void ocfs2_set_meta_lvb(struct ocfs2_lock_res *lockres);",
            "static void ocfs2_dentry_post_unlock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres);",
            "static void ocfs2_set_qinfo_lvb(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_downconvert_action(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_convert_action(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_attach_action(struct ocfs2_lock_res *lockres);",
            "static int ocfs2_generic_handle_bast(struct ocfs2_lock_res *lockres, int level);",
            "static void ocfs2_schedule_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static void ocfs2_downconvert_on_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static void ocfs2_drop_osb_locks(struct ocfs2_super *osb);",
            "static inline int ocfs2_highest_compat_lock_level(int level);",
            "static int ocfs2_prepare_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\t        struct ocfs2_lock_res *lockres);",
            "static int ocfs2_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static void ocfs2_process_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *lockres);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"stackglue.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dcache.h\"\n#include \"alloc.h\"\n#include \"ocfs2_lockingver.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/quotaops.h>\n#include <linux/time.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/pagemap.h>\n#include <linux/kthread.h>\n#include <linux/mm.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic struct ocfs2_super *ocfs2_get_dentry_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_inode_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_file_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_qinfo_osb(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_set_meta_lvb(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_dentry_post_unlock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres);\nstatic void ocfs2_set_qinfo_lvb(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_downconvert_action(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_convert_action(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_attach_action(struct ocfs2_lock_res *lockres);\nstatic int ocfs2_generic_handle_bast(struct ocfs2_lock_res *lockres, int level);\nstatic void ocfs2_schedule_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_downconvert_on_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_drop_osb_locks(struct ocfs2_super *osb);\nstatic inline int ocfs2_highest_compat_lock_level(int level);\nstatic int ocfs2_prepare_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\t        struct ocfs2_lock_res *lockres);\nstatic int ocfs2_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_process_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *lockres);\n\nstatic inline int ocfs2_cluster_lock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres,\n\t\t\t\t     int level,\n\t\t\t\t     u32 lkm_flags,\n\t\t\t\t     int arg_flags)\n{\n\treturn __ocfs2_cluster_lock(osb, lockres, level, lkm_flags, arg_flags,\n\t\t\t\t    0, _RET_IP_);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_mount_local",
          "args": [
            "osb"
          ],
          "line": 2558
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_mount_local",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "668-671",
          "snippet": "static inline int ocfs2_mount_local(struct ocfs2_super *osb)\n{\n\treturn (osb->s_feature_incompat & OCFS2_FEATURE_INCOMPAT_LOCAL_MOUNT);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\nstatic inline int ocfs2_mount_local(struct ocfs2_super *osb)\n{\n\treturn (osb->s_feature_incompat & OCFS2_FEATURE_INCOMPAT_LOCAL_MOUNT);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_is_hard_readonly",
          "args": [
            "osb"
          ],
          "line": 2555
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_is_hard_readonly",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "615-624",
          "snippet": "static inline int ocfs2_is_hard_readonly(struct ocfs2_super *osb)\n{\n\tint ret;\n\n\tspin_lock(&osb->osb_lock);\n\tret = osb->osb_flags & OCFS2_OSB_HARD_RO;\n\tspin_unlock(&osb->osb_lock);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [
            "#define OCFS2_OSB_HARD_RO\t0x0002"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\n#define OCFS2_OSB_HARD_RO\t0x0002\n\nstatic inline int ocfs2_is_hard_readonly(struct ocfs2_super *osb)\n{\n\tint ret;\n\n\tspin_lock(&osb->osb_lock);\n\tret = osb->osb_flags & OCFS2_OSB_HARD_RO;\n\tspin_unlock(&osb->osb_lock);\n\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"stackglue.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dcache.h\"\n#include \"alloc.h\"\n#include \"ocfs2_lockingver.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/quotaops.h>\n#include <linux/time.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/pagemap.h>\n#include <linux/kthread.h>\n#include <linux/mm.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic struct ocfs2_super *ocfs2_get_dentry_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_inode_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_file_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_qinfo_osb(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_set_meta_lvb(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_dentry_post_unlock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres);\nstatic void ocfs2_set_qinfo_lvb(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_downconvert_action(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_convert_action(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_attach_action(struct ocfs2_lock_res *lockres);\nstatic int ocfs2_generic_handle_bast(struct ocfs2_lock_res *lockres, int level);\nstatic void ocfs2_schedule_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_downconvert_on_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_drop_osb_locks(struct ocfs2_super *osb);\nstatic inline int ocfs2_highest_compat_lock_level(int level);\nstatic int ocfs2_prepare_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\t        struct ocfs2_lock_res *lockres);\nstatic int ocfs2_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_process_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *lockres);\n\nint ocfs2_super_lock(struct ocfs2_super *osb,\n\t\t     int ex)\n{\n\tint status = 0;\n\tint level = ex ? DLM_LOCK_EX : DLM_LOCK_PR;\n\tstruct ocfs2_lock_res *lockres = &osb->osb_super_lockres;\n\n\tif (ocfs2_is_hard_readonly(osb))\n\t\treturn -EROFS;\n\n\tif (ocfs2_mount_local(osb))\n\t\tgoto bail;\n\n\tstatus = ocfs2_cluster_lock(osb, lockres, level, 0, 0);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\t/* The super block lock path is really in the best position to\n\t * know when resources covered by the lock need to be\n\t * refreshed, so we do it here. Of course, making sense of\n\t * everything is up to the caller :) */\n\tstatus = ocfs2_should_refresh_lock_res(lockres);\n\tif (status) {\n\t\tstatus = ocfs2_refresh_slot_info(osb);\n\n\t\tocfs2_complete_lock_res_refresh(lockres, status);\n\n\t\tif (status < 0) {\n\t\t\tocfs2_cluster_unlock(osb, lockres, level);\n\t\t\tmlog_errno(status);\n\t\t}\n\t\tocfs2_track_lock_refresh(lockres);\n\t}\nbail:\n\treturn status;\n}"
  },
  {
    "function_name": "ocfs2_orphan_scan_unlock",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlmglue.c",
    "lines": "2534-2546",
    "snippet": "void ocfs2_orphan_scan_unlock(struct ocfs2_super *osb, u32 seqno)\n{\n\tstruct ocfs2_lock_res *lockres;\n\tstruct ocfs2_orphan_scan_lvb *lvb;\n\n\tif (!ocfs2_is_hard_readonly(osb) && !ocfs2_mount_local(osb)) {\n\t\tlockres = &osb->osb_orphan_scan.os_lockres;\n\t\tlvb = ocfs2_dlm_lvb(&lockres->l_lksb);\n\t\tlvb->lvb_version = OCFS2_ORPHAN_LVB_VERSION;\n\t\tlvb->lvb_os_seqno = cpu_to_be32(seqno);\n\t\tocfs2_cluster_unlock(osb, lockres, DLM_LOCK_EX);\n\t}\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"refcounttree.h\"",
      "#include \"quota.h\"",
      "#include \"uptodate.h\"",
      "#include \"super.h\"",
      "#include \"slot_map.h\"",
      "#include \"stackglue.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"heartbeat.h\"",
      "#include \"file.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"dcache.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2_lockingver.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/time.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/kthread.h>",
      "#include <linux/mm.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct ocfs2_super *ocfs2_get_dentry_osb(struct ocfs2_lock_res *lockres);",
      "static struct ocfs2_super *ocfs2_get_inode_osb(struct ocfs2_lock_res *lockres);",
      "static struct ocfs2_super *ocfs2_get_file_osb(struct ocfs2_lock_res *lockres);",
      "static struct ocfs2_super *ocfs2_get_qinfo_osb(struct ocfs2_lock_res *lockres);",
      "static void ocfs2_set_meta_lvb(struct ocfs2_lock_res *lockres);",
      "static void ocfs2_dentry_post_unlock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres);",
      "static void ocfs2_set_qinfo_lvb(struct ocfs2_lock_res *lockres);",
      "static inline void ocfs2_generic_handle_downconvert_action(struct ocfs2_lock_res *lockres);",
      "static inline void ocfs2_generic_handle_convert_action(struct ocfs2_lock_res *lockres);",
      "static inline void ocfs2_generic_handle_attach_action(struct ocfs2_lock_res *lockres);",
      "static void ocfs2_schedule_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);",
      "static void ocfs2_downconvert_on_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);",
      "static void ocfs2_drop_osb_locks(struct ocfs2_super *osb);",
      "static int ocfs2_prepare_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\t        struct ocfs2_lock_res *lockres);",
      "static int ocfs2_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres);",
      "static void ocfs2_process_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *lockres);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ocfs2_cluster_unlock",
          "args": [
            "osb",
            "lockres",
            "DLM_LOCK_EX"
          ],
          "line": 2544
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_cluster_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlmglue.c",
          "lines": "349-354",
          "snippet": "static inline void ocfs2_cluster_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres,\n\t\t\t\t\tint level)\n{\n\t__ocfs2_cluster_unlock(osb, lockres, level, _RET_IP_);\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"refcounttree.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"stackglue.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dcache.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2_lockingver.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/time.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/kthread.h>",
            "#include <linux/mm.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct ocfs2_super *ocfs2_get_dentry_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_inode_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_file_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_qinfo_osb(struct ocfs2_lock_res *lockres);",
            "static void ocfs2_set_meta_lvb(struct ocfs2_lock_res *lockres);",
            "static void ocfs2_dentry_post_unlock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres);",
            "static void ocfs2_set_qinfo_lvb(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_downconvert_action(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_convert_action(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_attach_action(struct ocfs2_lock_res *lockres);",
            "static int ocfs2_generic_handle_bast(struct ocfs2_lock_res *lockres, int level);",
            "static void ocfs2_schedule_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static void ocfs2_downconvert_on_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static void ocfs2_drop_osb_locks(struct ocfs2_super *osb);",
            "static inline int ocfs2_highest_compat_lock_level(int level);",
            "static int ocfs2_prepare_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\t        struct ocfs2_lock_res *lockres);",
            "static int ocfs2_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static void ocfs2_process_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *lockres);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"stackglue.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dcache.h\"\n#include \"alloc.h\"\n#include \"ocfs2_lockingver.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/quotaops.h>\n#include <linux/time.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/pagemap.h>\n#include <linux/kthread.h>\n#include <linux/mm.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic struct ocfs2_super *ocfs2_get_dentry_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_inode_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_file_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_qinfo_osb(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_set_meta_lvb(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_dentry_post_unlock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres);\nstatic void ocfs2_set_qinfo_lvb(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_downconvert_action(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_convert_action(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_attach_action(struct ocfs2_lock_res *lockres);\nstatic int ocfs2_generic_handle_bast(struct ocfs2_lock_res *lockres, int level);\nstatic void ocfs2_schedule_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_downconvert_on_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_drop_osb_locks(struct ocfs2_super *osb);\nstatic inline int ocfs2_highest_compat_lock_level(int level);\nstatic int ocfs2_prepare_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\t        struct ocfs2_lock_res *lockres);\nstatic int ocfs2_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_process_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *lockres);\n\nstatic inline void ocfs2_cluster_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres,\n\t\t\t\t\tint level)\n{\n\t__ocfs2_cluster_unlock(osb, lockres, level, _RET_IP_);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "seqno"
          ],
          "line": 2543
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_dlm_lvb",
          "args": [
            "&lockres->l_lksb"
          ],
          "line": 2541
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_dlm_lvb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/stackglue.c",
          "lines": "279-282",
          "snippet": "void *ocfs2_dlm_lvb(struct ocfs2_dlm_lksb *lksb)\n{\n\treturn active_stack->sp_ops->lock_lvb(lksb);\n}",
          "includes": [
            "#include \"stackglue.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include <linux/sysctl.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/fs.h>",
            "#include <linux/kmod.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/list.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct ocfs2_stack_plugin *active_stack;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"stackglue.h\"\n#include \"ocfs2_fs.h\"\n#include <linux/sysctl.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/fs.h>\n#include <linux/kmod.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/spinlock.h>\n#include <linux/list.h>\n\nstatic struct ocfs2_stack_plugin *active_stack;\n\nvoid *ocfs2_dlm_lvb(struct ocfs2_dlm_lksb *lksb)\n{\n\treturn active_stack->sp_ops->lock_lvb(lksb);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_mount_local",
          "args": [
            "osb"
          ],
          "line": 2539
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_mount_local",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "668-671",
          "snippet": "static inline int ocfs2_mount_local(struct ocfs2_super *osb)\n{\n\treturn (osb->s_feature_incompat & OCFS2_FEATURE_INCOMPAT_LOCAL_MOUNT);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\nstatic inline int ocfs2_mount_local(struct ocfs2_super *osb)\n{\n\treturn (osb->s_feature_incompat & OCFS2_FEATURE_INCOMPAT_LOCAL_MOUNT);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_is_hard_readonly",
          "args": [
            "osb"
          ],
          "line": 2539
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_is_hard_readonly",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "615-624",
          "snippet": "static inline int ocfs2_is_hard_readonly(struct ocfs2_super *osb)\n{\n\tint ret;\n\n\tspin_lock(&osb->osb_lock);\n\tret = osb->osb_flags & OCFS2_OSB_HARD_RO;\n\tspin_unlock(&osb->osb_lock);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [
            "#define OCFS2_OSB_HARD_RO\t0x0002"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\n#define OCFS2_OSB_HARD_RO\t0x0002\n\nstatic inline int ocfs2_is_hard_readonly(struct ocfs2_super *osb)\n{\n\tint ret;\n\n\tspin_lock(&osb->osb_lock);\n\tret = osb->osb_flags & OCFS2_OSB_HARD_RO;\n\tspin_unlock(&osb->osb_lock);\n\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"stackglue.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dcache.h\"\n#include \"alloc.h\"\n#include \"ocfs2_lockingver.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/quotaops.h>\n#include <linux/time.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/pagemap.h>\n#include <linux/kthread.h>\n#include <linux/mm.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic struct ocfs2_super *ocfs2_get_dentry_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_inode_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_file_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_qinfo_osb(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_set_meta_lvb(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_dentry_post_unlock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres);\nstatic void ocfs2_set_qinfo_lvb(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_downconvert_action(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_convert_action(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_attach_action(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_schedule_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_downconvert_on_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_drop_osb_locks(struct ocfs2_super *osb);\nstatic int ocfs2_prepare_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\t        struct ocfs2_lock_res *lockres);\nstatic int ocfs2_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_process_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *lockres);\n\nvoid ocfs2_orphan_scan_unlock(struct ocfs2_super *osb, u32 seqno)\n{\n\tstruct ocfs2_lock_res *lockres;\n\tstruct ocfs2_orphan_scan_lvb *lvb;\n\n\tif (!ocfs2_is_hard_readonly(osb) && !ocfs2_mount_local(osb)) {\n\t\tlockres = &osb->osb_orphan_scan.os_lockres;\n\t\tlvb = ocfs2_dlm_lvb(&lockres->l_lksb);\n\t\tlvb->lvb_version = OCFS2_ORPHAN_LVB_VERSION;\n\t\tlvb->lvb_os_seqno = cpu_to_be32(seqno);\n\t\tocfs2_cluster_unlock(osb, lockres, DLM_LOCK_EX);\n\t}\n}"
  },
  {
    "function_name": "ocfs2_orphan_scan_lock",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlmglue.c",
    "lines": "2507-2532",
    "snippet": "int ocfs2_orphan_scan_lock(struct ocfs2_super *osb, u32 *seqno)\n{\n\tstruct ocfs2_lock_res *lockres;\n\tstruct ocfs2_orphan_scan_lvb *lvb;\n\tint status = 0;\n\n\tif (ocfs2_is_hard_readonly(osb))\n\t\treturn -EROFS;\n\n\tif (ocfs2_mount_local(osb))\n\t\treturn 0;\n\n\tlockres = &osb->osb_orphan_scan.os_lockres;\n\tstatus = ocfs2_cluster_lock(osb, lockres, DLM_LOCK_EX, 0, 0);\n\tif (status < 0)\n\t\treturn status;\n\n\tlvb = ocfs2_dlm_lvb(&lockres->l_lksb);\n\tif (ocfs2_dlm_lvb_valid(&lockres->l_lksb) &&\n\t    lvb->lvb_version == OCFS2_ORPHAN_LVB_VERSION)\n\t\t*seqno = be32_to_cpu(lvb->lvb_os_seqno);\n\telse\n\t\t*seqno = osb->osb_orphan_scan.os_seqno + 1;\n\n\treturn status;\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"refcounttree.h\"",
      "#include \"quota.h\"",
      "#include \"uptodate.h\"",
      "#include \"super.h\"",
      "#include \"slot_map.h\"",
      "#include \"stackglue.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"heartbeat.h\"",
      "#include \"file.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"dcache.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2_lockingver.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/time.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/kthread.h>",
      "#include <linux/mm.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct ocfs2_super *ocfs2_get_dentry_osb(struct ocfs2_lock_res *lockres);",
      "static struct ocfs2_super *ocfs2_get_inode_osb(struct ocfs2_lock_res *lockres);",
      "static struct ocfs2_super *ocfs2_get_file_osb(struct ocfs2_lock_res *lockres);",
      "static struct ocfs2_super *ocfs2_get_qinfo_osb(struct ocfs2_lock_res *lockres);",
      "static void ocfs2_set_meta_lvb(struct ocfs2_lock_res *lockres);",
      "static void ocfs2_dentry_post_unlock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres);",
      "static void ocfs2_set_qinfo_lvb(struct ocfs2_lock_res *lockres);",
      "static inline void ocfs2_generic_handle_downconvert_action(struct ocfs2_lock_res *lockres);",
      "static inline void ocfs2_generic_handle_convert_action(struct ocfs2_lock_res *lockres);",
      "static inline void ocfs2_generic_handle_attach_action(struct ocfs2_lock_res *lockres);",
      "static void ocfs2_schedule_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);",
      "static void ocfs2_downconvert_on_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);",
      "static void ocfs2_drop_osb_locks(struct ocfs2_super *osb);",
      "static int ocfs2_prepare_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\t        struct ocfs2_lock_res *lockres);",
      "static int ocfs2_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres);",
      "static void ocfs2_process_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *lockres);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "lvb->lvb_os_seqno"
          ],
          "line": 2527
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_dlm_lvb_valid",
          "args": [
            "&lockres->l_lksb"
          ],
          "line": 2525
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_dlm_lvb_valid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/stackglue.c",
          "lines": "273-276",
          "snippet": "int ocfs2_dlm_lvb_valid(struct ocfs2_dlm_lksb *lksb)\n{\n\treturn active_stack->sp_ops->lvb_valid(lksb);\n}",
          "includes": [
            "#include \"stackglue.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include <linux/sysctl.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/fs.h>",
            "#include <linux/kmod.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/list.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct ocfs2_stack_plugin *active_stack;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"stackglue.h\"\n#include \"ocfs2_fs.h\"\n#include <linux/sysctl.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/fs.h>\n#include <linux/kmod.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/spinlock.h>\n#include <linux/list.h>\n\nstatic struct ocfs2_stack_plugin *active_stack;\n\nint ocfs2_dlm_lvb_valid(struct ocfs2_dlm_lksb *lksb)\n{\n\treturn active_stack->sp_ops->lvb_valid(lksb);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_dlm_lvb",
          "args": [
            "&lockres->l_lksb"
          ],
          "line": 2524
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_dlm_lvb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/stackglue.c",
          "lines": "279-282",
          "snippet": "void *ocfs2_dlm_lvb(struct ocfs2_dlm_lksb *lksb)\n{\n\treturn active_stack->sp_ops->lock_lvb(lksb);\n}",
          "includes": [
            "#include \"stackglue.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include <linux/sysctl.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/fs.h>",
            "#include <linux/kmod.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/list.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct ocfs2_stack_plugin *active_stack;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"stackglue.h\"\n#include \"ocfs2_fs.h\"\n#include <linux/sysctl.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/fs.h>\n#include <linux/kmod.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/spinlock.h>\n#include <linux/list.h>\n\nstatic struct ocfs2_stack_plugin *active_stack;\n\nvoid *ocfs2_dlm_lvb(struct ocfs2_dlm_lksb *lksb)\n{\n\treturn active_stack->sp_ops->lock_lvb(lksb);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_cluster_lock",
          "args": [
            "osb",
            "lockres",
            "DLM_LOCK_EX",
            "0",
            "0"
          ],
          "line": 2520
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_cluster_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlmglue.c",
          "lines": "1570-1578",
          "snippet": "static inline int ocfs2_cluster_lock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres,\n\t\t\t\t     int level,\n\t\t\t\t     u32 lkm_flags,\n\t\t\t\t     int arg_flags)\n{\n\treturn __ocfs2_cluster_lock(osb, lockres, level, lkm_flags, arg_flags,\n\t\t\t\t    0, _RET_IP_);\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"refcounttree.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"stackglue.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dcache.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2_lockingver.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/time.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/kthread.h>",
            "#include <linux/mm.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct ocfs2_super *ocfs2_get_dentry_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_inode_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_file_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_qinfo_osb(struct ocfs2_lock_res *lockres);",
            "static void ocfs2_set_meta_lvb(struct ocfs2_lock_res *lockres);",
            "static void ocfs2_dentry_post_unlock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres);",
            "static void ocfs2_set_qinfo_lvb(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_downconvert_action(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_convert_action(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_attach_action(struct ocfs2_lock_res *lockres);",
            "static int ocfs2_generic_handle_bast(struct ocfs2_lock_res *lockres, int level);",
            "static void ocfs2_schedule_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static void ocfs2_downconvert_on_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static void ocfs2_drop_osb_locks(struct ocfs2_super *osb);",
            "static inline int ocfs2_highest_compat_lock_level(int level);",
            "static int ocfs2_prepare_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\t        struct ocfs2_lock_res *lockres);",
            "static int ocfs2_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static void ocfs2_process_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *lockres);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"stackglue.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dcache.h\"\n#include \"alloc.h\"\n#include \"ocfs2_lockingver.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/quotaops.h>\n#include <linux/time.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/pagemap.h>\n#include <linux/kthread.h>\n#include <linux/mm.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic struct ocfs2_super *ocfs2_get_dentry_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_inode_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_file_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_qinfo_osb(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_set_meta_lvb(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_dentry_post_unlock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres);\nstatic void ocfs2_set_qinfo_lvb(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_downconvert_action(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_convert_action(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_attach_action(struct ocfs2_lock_res *lockres);\nstatic int ocfs2_generic_handle_bast(struct ocfs2_lock_res *lockres, int level);\nstatic void ocfs2_schedule_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_downconvert_on_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_drop_osb_locks(struct ocfs2_super *osb);\nstatic inline int ocfs2_highest_compat_lock_level(int level);\nstatic int ocfs2_prepare_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\t        struct ocfs2_lock_res *lockres);\nstatic int ocfs2_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_process_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *lockres);\n\nstatic inline int ocfs2_cluster_lock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres,\n\t\t\t\t     int level,\n\t\t\t\t     u32 lkm_flags,\n\t\t\t\t     int arg_flags)\n{\n\treturn __ocfs2_cluster_lock(osb, lockres, level, lkm_flags, arg_flags,\n\t\t\t\t    0, _RET_IP_);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_mount_local",
          "args": [
            "osb"
          ],
          "line": 2516
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_mount_local",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "668-671",
          "snippet": "static inline int ocfs2_mount_local(struct ocfs2_super *osb)\n{\n\treturn (osb->s_feature_incompat & OCFS2_FEATURE_INCOMPAT_LOCAL_MOUNT);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\nstatic inline int ocfs2_mount_local(struct ocfs2_super *osb)\n{\n\treturn (osb->s_feature_incompat & OCFS2_FEATURE_INCOMPAT_LOCAL_MOUNT);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_is_hard_readonly",
          "args": [
            "osb"
          ],
          "line": 2513
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_is_hard_readonly",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "615-624",
          "snippet": "static inline int ocfs2_is_hard_readonly(struct ocfs2_super *osb)\n{\n\tint ret;\n\n\tspin_lock(&osb->osb_lock);\n\tret = osb->osb_flags & OCFS2_OSB_HARD_RO;\n\tspin_unlock(&osb->osb_lock);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [
            "#define OCFS2_OSB_HARD_RO\t0x0002"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\n#define OCFS2_OSB_HARD_RO\t0x0002\n\nstatic inline int ocfs2_is_hard_readonly(struct ocfs2_super *osb)\n{\n\tint ret;\n\n\tspin_lock(&osb->osb_lock);\n\tret = osb->osb_flags & OCFS2_OSB_HARD_RO;\n\tspin_unlock(&osb->osb_lock);\n\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"stackglue.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dcache.h\"\n#include \"alloc.h\"\n#include \"ocfs2_lockingver.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/quotaops.h>\n#include <linux/time.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/pagemap.h>\n#include <linux/kthread.h>\n#include <linux/mm.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic struct ocfs2_super *ocfs2_get_dentry_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_inode_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_file_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_qinfo_osb(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_set_meta_lvb(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_dentry_post_unlock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres);\nstatic void ocfs2_set_qinfo_lvb(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_downconvert_action(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_convert_action(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_attach_action(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_schedule_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_downconvert_on_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_drop_osb_locks(struct ocfs2_super *osb);\nstatic int ocfs2_prepare_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\t        struct ocfs2_lock_res *lockres);\nstatic int ocfs2_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_process_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *lockres);\n\nint ocfs2_orphan_scan_lock(struct ocfs2_super *osb, u32 *seqno)\n{\n\tstruct ocfs2_lock_res *lockres;\n\tstruct ocfs2_orphan_scan_lvb *lvb;\n\tint status = 0;\n\n\tif (ocfs2_is_hard_readonly(osb))\n\t\treturn -EROFS;\n\n\tif (ocfs2_mount_local(osb))\n\t\treturn 0;\n\n\tlockres = &osb->osb_orphan_scan.os_lockres;\n\tstatus = ocfs2_cluster_lock(osb, lockres, DLM_LOCK_EX, 0, 0);\n\tif (status < 0)\n\t\treturn status;\n\n\tlvb = ocfs2_dlm_lvb(&lockres->l_lksb);\n\tif (ocfs2_dlm_lvb_valid(&lockres->l_lksb) &&\n\t    lvb->lvb_version == OCFS2_ORPHAN_LVB_VERSION)\n\t\t*seqno = be32_to_cpu(lvb->lvb_os_seqno);\n\telse\n\t\t*seqno = osb->osb_orphan_scan.os_seqno + 1;\n\n\treturn status;\n}"
  },
  {
    "function_name": "ocfs2_inode_unlock",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlmglue.c",
    "lines": "2491-2505",
    "snippet": "void ocfs2_inode_unlock(struct inode *inode,\n\t\t       int ex)\n{\n\tint level = ex ? DLM_LOCK_EX : DLM_LOCK_PR;\n\tstruct ocfs2_lock_res *lockres = &OCFS2_I(inode)->ip_inode_lockres;\n\tstruct ocfs2_super *osb = OCFS2_SB(inode->i_sb);\n\n\tmlog(0, \"inode %llu drop %s META lock\\n\",\n\t     (unsigned long long)OCFS2_I(inode)->ip_blkno,\n\t     ex ? \"EXMODE\" : \"PRMODE\");\n\n\tif (!ocfs2_is_hard_readonly(OCFS2_SB(inode->i_sb)) &&\n\t    !ocfs2_mount_local(osb))\n\t\tocfs2_cluster_unlock(OCFS2_SB(inode->i_sb), lockres, level);\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"refcounttree.h\"",
      "#include \"quota.h\"",
      "#include \"uptodate.h\"",
      "#include \"super.h\"",
      "#include \"slot_map.h\"",
      "#include \"stackglue.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"heartbeat.h\"",
      "#include \"file.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"dcache.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2_lockingver.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/time.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/kthread.h>",
      "#include <linux/mm.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct ocfs2_super *ocfs2_get_dentry_osb(struct ocfs2_lock_res *lockres);",
      "static struct ocfs2_super *ocfs2_get_inode_osb(struct ocfs2_lock_res *lockres);",
      "static struct ocfs2_super *ocfs2_get_file_osb(struct ocfs2_lock_res *lockres);",
      "static struct ocfs2_super *ocfs2_get_qinfo_osb(struct ocfs2_lock_res *lockres);",
      "static void ocfs2_set_meta_lvb(struct ocfs2_lock_res *lockres);",
      "static void ocfs2_dentry_post_unlock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres);",
      "static void ocfs2_set_qinfo_lvb(struct ocfs2_lock_res *lockres);",
      "static inline void ocfs2_generic_handle_downconvert_action(struct ocfs2_lock_res *lockres);",
      "static inline void ocfs2_generic_handle_convert_action(struct ocfs2_lock_res *lockres);",
      "static inline void ocfs2_generic_handle_attach_action(struct ocfs2_lock_res *lockres);",
      "static int ocfs2_generic_handle_bast(struct ocfs2_lock_res *lockres, int level);",
      "static void ocfs2_schedule_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);",
      "static void ocfs2_downconvert_on_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);",
      "static void ocfs2_drop_osb_locks(struct ocfs2_super *osb);",
      "static inline int ocfs2_highest_compat_lock_level(int level);",
      "static int ocfs2_prepare_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\t        struct ocfs2_lock_res *lockres);",
      "static int ocfs2_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres);",
      "static void ocfs2_process_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *lockres);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ocfs2_cluster_unlock",
          "args": [
            "OCFS2_SB(inode->i_sb)",
            "lockres",
            "level"
          ],
          "line": 2504
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_cluster_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlmglue.c",
          "lines": "349-354",
          "snippet": "static inline void ocfs2_cluster_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres,\n\t\t\t\t\tint level)\n{\n\t__ocfs2_cluster_unlock(osb, lockres, level, _RET_IP_);\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"refcounttree.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"stackglue.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dcache.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2_lockingver.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/time.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/kthread.h>",
            "#include <linux/mm.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct ocfs2_super *ocfs2_get_dentry_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_inode_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_file_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_qinfo_osb(struct ocfs2_lock_res *lockres);",
            "static void ocfs2_set_meta_lvb(struct ocfs2_lock_res *lockres);",
            "static void ocfs2_dentry_post_unlock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres);",
            "static void ocfs2_set_qinfo_lvb(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_downconvert_action(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_convert_action(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_attach_action(struct ocfs2_lock_res *lockres);",
            "static int ocfs2_generic_handle_bast(struct ocfs2_lock_res *lockres, int level);",
            "static void ocfs2_schedule_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static void ocfs2_downconvert_on_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static void ocfs2_drop_osb_locks(struct ocfs2_super *osb);",
            "static inline int ocfs2_highest_compat_lock_level(int level);",
            "static int ocfs2_prepare_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\t        struct ocfs2_lock_res *lockres);",
            "static int ocfs2_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static void ocfs2_process_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *lockres);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"stackglue.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dcache.h\"\n#include \"alloc.h\"\n#include \"ocfs2_lockingver.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/quotaops.h>\n#include <linux/time.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/pagemap.h>\n#include <linux/kthread.h>\n#include <linux/mm.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic struct ocfs2_super *ocfs2_get_dentry_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_inode_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_file_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_qinfo_osb(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_set_meta_lvb(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_dentry_post_unlock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres);\nstatic void ocfs2_set_qinfo_lvb(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_downconvert_action(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_convert_action(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_attach_action(struct ocfs2_lock_res *lockres);\nstatic int ocfs2_generic_handle_bast(struct ocfs2_lock_res *lockres, int level);\nstatic void ocfs2_schedule_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_downconvert_on_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_drop_osb_locks(struct ocfs2_super *osb);\nstatic inline int ocfs2_highest_compat_lock_level(int level);\nstatic int ocfs2_prepare_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\t        struct ocfs2_lock_res *lockres);\nstatic int ocfs2_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_process_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *lockres);\n\nstatic inline void ocfs2_cluster_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres,\n\t\t\t\t\tint level)\n{\n\t__ocfs2_cluster_unlock(osb, lockres, level, _RET_IP_);\n}"
        }
      },
      {
        "call_info": {
          "callee": "OCFS2_SB",
          "args": [
            "inode->i_sb"
          ],
          "line": 2504
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_mount_local",
          "args": [
            "osb"
          ],
          "line": 2503
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_mount_local",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "668-671",
          "snippet": "static inline int ocfs2_mount_local(struct ocfs2_super *osb)\n{\n\treturn (osb->s_feature_incompat & OCFS2_FEATURE_INCOMPAT_LOCAL_MOUNT);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\nstatic inline int ocfs2_mount_local(struct ocfs2_super *osb)\n{\n\treturn (osb->s_feature_incompat & OCFS2_FEATURE_INCOMPAT_LOCAL_MOUNT);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_is_hard_readonly",
          "args": [
            "OCFS2_SB(inode->i_sb)"
          ],
          "line": 2502
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_is_hard_readonly",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "615-624",
          "snippet": "static inline int ocfs2_is_hard_readonly(struct ocfs2_super *osb)\n{\n\tint ret;\n\n\tspin_lock(&osb->osb_lock);\n\tret = osb->osb_flags & OCFS2_OSB_HARD_RO;\n\tspin_unlock(&osb->osb_lock);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [
            "#define OCFS2_OSB_HARD_RO\t0x0002"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\n#define OCFS2_OSB_HARD_RO\t0x0002\n\nstatic inline int ocfs2_is_hard_readonly(struct ocfs2_super *osb)\n{\n\tint ret;\n\n\tspin_lock(&osb->osb_lock);\n\tret = osb->osb_flags & OCFS2_OSB_HARD_RO;\n\tspin_unlock(&osb->osb_lock);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "OCFS2_SB",
          "args": [
            "inode->i_sb"
          ],
          "line": 2502
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mlog",
          "args": [
            "0",
            "\"inode %llu drop %s META lock\\n\"",
            "(unsigned long long)OCFS2_I(inode)->ip_blkno",
            "ex ? \"EXMODE\" : \"PRMODE\""
          ],
          "line": 2498
        },
        "resolved": true,
        "details": {
          "function_name": "mlog_store",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/cluster/masklog.c",
          "lines": "115-121",
          "snippet": "static ssize_t mlog_store(struct kobject *obj, struct attribute *attr,\n\t\t\t  const char *buf, size_t count)\n{\n\tstruct mlog_attribute *mlog_attr = to_mlog_attr(attr);\n\n\treturn mlog_mask_store(mlog_attr->mask, buf, count);\n}",
          "includes": [
            "#include \"masklog.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/string.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"masklog.h\"\n#include <asm/uaccess.h>\n#include <linux/string.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n\nstatic ssize_t mlog_store(struct kobject *obj, struct attribute *attr,\n\t\t\t  const char *buf, size_t count)\n{\n\tstruct mlog_attribute *mlog_attr = to_mlog_attr(attr);\n\n\treturn mlog_mask_store(mlog_attr->mask, buf, count);\n}"
        }
      },
      {
        "call_info": {
          "callee": "OCFS2_I",
          "args": [
            "inode"
          ],
          "line": 2499
        },
        "resolved": true,
        "details": {
          "function_name": "OCFS2_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/inode.h",
          "lines": "118-121",
          "snippet": "static inline struct ocfs2_inode_info *OCFS2_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ocfs2_inode_info, vfs_inode);\n}",
          "includes": [
            "#include \"extent_map.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extent_map.h\"\n\nstatic inline struct ocfs2_inode_info *OCFS2_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ocfs2_inode_info, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "OCFS2_SB",
          "args": [
            "inode->i_sb"
          ],
          "line": 2496
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"stackglue.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dcache.h\"\n#include \"alloc.h\"\n#include \"ocfs2_lockingver.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/quotaops.h>\n#include <linux/time.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/pagemap.h>\n#include <linux/kthread.h>\n#include <linux/mm.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic struct ocfs2_super *ocfs2_get_dentry_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_inode_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_file_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_qinfo_osb(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_set_meta_lvb(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_dentry_post_unlock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres);\nstatic void ocfs2_set_qinfo_lvb(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_downconvert_action(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_convert_action(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_attach_action(struct ocfs2_lock_res *lockres);\nstatic int ocfs2_generic_handle_bast(struct ocfs2_lock_res *lockres, int level);\nstatic void ocfs2_schedule_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_downconvert_on_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_drop_osb_locks(struct ocfs2_super *osb);\nstatic inline int ocfs2_highest_compat_lock_level(int level);\nstatic int ocfs2_prepare_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\t        struct ocfs2_lock_res *lockres);\nstatic int ocfs2_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_process_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *lockres);\n\nvoid ocfs2_inode_unlock(struct inode *inode,\n\t\t       int ex)\n{\n\tint level = ex ? DLM_LOCK_EX : DLM_LOCK_PR;\n\tstruct ocfs2_lock_res *lockres = &OCFS2_I(inode)->ip_inode_lockres;\n\tstruct ocfs2_super *osb = OCFS2_SB(inode->i_sb);\n\n\tmlog(0, \"inode %llu drop %s META lock\\n\",\n\t     (unsigned long long)OCFS2_I(inode)->ip_blkno,\n\t     ex ? \"EXMODE\" : \"PRMODE\");\n\n\tif (!ocfs2_is_hard_readonly(OCFS2_SB(inode->i_sb)) &&\n\t    !ocfs2_mount_local(osb))\n\t\tocfs2_cluster_unlock(OCFS2_SB(inode->i_sb), lockres, level);\n}"
  },
  {
    "function_name": "ocfs2_inode_lock_atime",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlmglue.c",
    "lines": "2455-2489",
    "snippet": "int ocfs2_inode_lock_atime(struct inode *inode,\n\t\t\t  struct vfsmount *vfsmnt,\n\t\t\t  int *level)\n{\n\tint ret;\n\n\tret = ocfs2_inode_lock(inode, NULL, 0);\n\tif (ret < 0) {\n\t\tmlog_errno(ret);\n\t\treturn ret;\n\t}\n\n\t/*\n\t * If we should update atime, we will get EX lock,\n\t * otherwise we just get PR lock.\n\t */\n\tif (ocfs2_should_update_atime(inode, vfsmnt)) {\n\t\tstruct buffer_head *bh = NULL;\n\n\t\tocfs2_inode_unlock(inode, 0);\n\t\tret = ocfs2_inode_lock(inode, &bh, 1);\n\t\tif (ret < 0) {\n\t\t\tmlog_errno(ret);\n\t\t\treturn ret;\n\t\t}\n\t\t*level = 1;\n\t\tif (ocfs2_should_update_atime(inode, vfsmnt))\n\t\t\tocfs2_update_inode_atime(inode, bh);\n\t\tif (bh)\n\t\t\tbrelse(bh);\n\t} else\n\t\t*level = 0;\n\n\treturn ret;\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"refcounttree.h\"",
      "#include \"quota.h\"",
      "#include \"uptodate.h\"",
      "#include \"super.h\"",
      "#include \"slot_map.h\"",
      "#include \"stackglue.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"heartbeat.h\"",
      "#include \"file.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"dcache.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2_lockingver.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/time.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/kthread.h>",
      "#include <linux/mm.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ocfs2_generic_handle_bast(struct ocfs2_lock_res *lockres, int level);",
      "static int ocfs2_inode_lock_update(struct inode *inode,\n\t\t\t\t  struct buffer_head **bh);",
      "static inline int ocfs2_highest_compat_lock_level(int level);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "brelse",
          "args": [
            "bh"
          ],
          "line": 2484
        },
        "resolved": true,
        "details": {
          "function_name": "__brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1177-1184",
          "snippet": "void __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_update_inode_atime",
          "args": [
            "inode",
            "bh"
          ],
          "line": 2482
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_update_inode_atime",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/file.c",
          "lines": "259-296",
          "snippet": "int ocfs2_update_inode_atime(struct inode *inode,\n\t\t\t     struct buffer_head *bh)\n{\n\tint ret;\n\tstruct ocfs2_super *osb = OCFS2_SB(inode->i_sb);\n\thandle_t *handle;\n\tstruct ocfs2_dinode *di = (struct ocfs2_dinode *) bh->b_data;\n\n\thandle = ocfs2_start_trans(osb, OCFS2_INODE_UPDATE_CREDITS);\n\tif (IS_ERR(handle)) {\n\t\tret = PTR_ERR(handle);\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tret = ocfs2_journal_access_di(handle, INODE_CACHE(inode), bh,\n\t\t\t\t      OCFS2_JOURNAL_ACCESS_WRITE);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out_commit;\n\t}\n\n\t/*\n\t * Don't use ocfs2_mark_inode_dirty() here as we don't always\n\t * have i_mutex to guard against concurrent changes to other\n\t * inode fields.\n\t */\n\tinode->i_atime = CURRENT_TIME;\n\tdi->i_atime = cpu_to_le64(inode->i_atime.tv_sec);\n\tdi->i_atime_nsec = cpu_to_le32(inode->i_atime.tv_nsec);\n\tocfs2_update_inode_fsync_trans(handle, inode, 0);\n\tocfs2_journal_dirty(handle, bh);\n\nout_commit:\n\tocfs2_commit_trans(OCFS2_SB(inode->i_sb), handle);\nout:\n\treturn ret;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"quota.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"mmap.h\"",
            "#include \"locks.h\"",
            "#include \"journal.h\"",
            "#include \"ioctl.h\"",
            "#include \"inode.h\"",
            "#include \"sysfile.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/falloc.h>",
            "#include <linux/writeback.h>",
            "#include <linux/mount.h>",
            "#include <linux/splice.h>",
            "#include <linux/sched.h>",
            "#include <linux/uio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"mmap.h\"\n#include \"locks.h\"\n#include \"journal.h\"\n#include \"ioctl.h\"\n#include \"inode.h\"\n#include \"sysfile.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/falloc.h>\n#include <linux/writeback.h>\n#include <linux/mount.h>\n#include <linux/splice.h>\n#include <linux/sched.h>\n#include <linux/uio.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n\nint ocfs2_update_inode_atime(struct inode *inode,\n\t\t\t     struct buffer_head *bh)\n{\n\tint ret;\n\tstruct ocfs2_super *osb = OCFS2_SB(inode->i_sb);\n\thandle_t *handle;\n\tstruct ocfs2_dinode *di = (struct ocfs2_dinode *) bh->b_data;\n\n\thandle = ocfs2_start_trans(osb, OCFS2_INODE_UPDATE_CREDITS);\n\tif (IS_ERR(handle)) {\n\t\tret = PTR_ERR(handle);\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tret = ocfs2_journal_access_di(handle, INODE_CACHE(inode), bh,\n\t\t\t\t      OCFS2_JOURNAL_ACCESS_WRITE);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out_commit;\n\t}\n\n\t/*\n\t * Don't use ocfs2_mark_inode_dirty() here as we don't always\n\t * have i_mutex to guard against concurrent changes to other\n\t * inode fields.\n\t */\n\tinode->i_atime = CURRENT_TIME;\n\tdi->i_atime = cpu_to_le64(inode->i_atime.tv_sec);\n\tdi->i_atime_nsec = cpu_to_le32(inode->i_atime.tv_nsec);\n\tocfs2_update_inode_fsync_trans(handle, inode, 0);\n\tocfs2_journal_dirty(handle, bh);\n\nout_commit:\n\tocfs2_commit_trans(OCFS2_SB(inode->i_sb), handle);\nout:\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_should_update_atime",
          "args": [
            "inode",
            "vfsmnt"
          ],
          "line": 2481
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_should_update_atime",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/file.c",
          "lines": "216-257",
          "snippet": "int ocfs2_should_update_atime(struct inode *inode,\n\t\t\t      struct vfsmount *vfsmnt)\n{\n\tstruct timespec now;\n\tstruct ocfs2_super *osb = OCFS2_SB(inode->i_sb);\n\n\tif (ocfs2_is_hard_readonly(osb) || ocfs2_is_soft_readonly(osb))\n\t\treturn 0;\n\n\tif ((inode->i_flags & S_NOATIME) ||\n\t    ((inode->i_sb->s_flags & MS_NODIRATIME) && S_ISDIR(inode->i_mode)))\n\t\treturn 0;\n\n\t/*\n\t * We can be called with no vfsmnt structure - NFSD will\n\t * sometimes do this.\n\t *\n\t * Note that our action here is different than touch_atime() -\n\t * if we can't tell whether this is a noatime mount, then we\n\t * don't know whether to trust the value of s_atime_quantum.\n\t */\n\tif (vfsmnt == NULL)\n\t\treturn 0;\n\n\tif ((vfsmnt->mnt_flags & MNT_NOATIME) ||\n\t    ((vfsmnt->mnt_flags & MNT_NODIRATIME) && S_ISDIR(inode->i_mode)))\n\t\treturn 0;\n\n\tif (vfsmnt->mnt_flags & MNT_RELATIME) {\n\t\tif ((timespec_compare(&inode->i_atime, &inode->i_mtime) <= 0) ||\n\t\t    (timespec_compare(&inode->i_atime, &inode->i_ctime) <= 0))\n\t\t\treturn 1;\n\n\t\treturn 0;\n\t}\n\n\tnow = CURRENT_TIME;\n\tif ((now.tv_sec - inode->i_atime.tv_sec <= osb->s_atime_quantum))\n\t\treturn 0;\n\telse\n\t\treturn 1;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"quota.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"mmap.h\"",
            "#include \"locks.h\"",
            "#include \"journal.h\"",
            "#include \"ioctl.h\"",
            "#include \"inode.h\"",
            "#include \"sysfile.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/falloc.h>",
            "#include <linux/writeback.h>",
            "#include <linux/mount.h>",
            "#include <linux/splice.h>",
            "#include <linux/sched.h>",
            "#include <linux/uio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"mmap.h\"\n#include \"locks.h\"\n#include \"journal.h\"\n#include \"ioctl.h\"\n#include \"inode.h\"\n#include \"sysfile.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/falloc.h>\n#include <linux/writeback.h>\n#include <linux/mount.h>\n#include <linux/splice.h>\n#include <linux/sched.h>\n#include <linux/uio.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n\nint ocfs2_should_update_atime(struct inode *inode,\n\t\t\t      struct vfsmount *vfsmnt)\n{\n\tstruct timespec now;\n\tstruct ocfs2_super *osb = OCFS2_SB(inode->i_sb);\n\n\tif (ocfs2_is_hard_readonly(osb) || ocfs2_is_soft_readonly(osb))\n\t\treturn 0;\n\n\tif ((inode->i_flags & S_NOATIME) ||\n\t    ((inode->i_sb->s_flags & MS_NODIRATIME) && S_ISDIR(inode->i_mode)))\n\t\treturn 0;\n\n\t/*\n\t * We can be called with no vfsmnt structure - NFSD will\n\t * sometimes do this.\n\t *\n\t * Note that our action here is different than touch_atime() -\n\t * if we can't tell whether this is a noatime mount, then we\n\t * don't know whether to trust the value of s_atime_quantum.\n\t */\n\tif (vfsmnt == NULL)\n\t\treturn 0;\n\n\tif ((vfsmnt->mnt_flags & MNT_NOATIME) ||\n\t    ((vfsmnt->mnt_flags & MNT_NODIRATIME) && S_ISDIR(inode->i_mode)))\n\t\treturn 0;\n\n\tif (vfsmnt->mnt_flags & MNT_RELATIME) {\n\t\tif ((timespec_compare(&inode->i_atime, &inode->i_mtime) <= 0) ||\n\t\t    (timespec_compare(&inode->i_atime, &inode->i_ctime) <= 0))\n\t\t\treturn 1;\n\n\t\treturn 0;\n\t}\n\n\tnow = CURRENT_TIME;\n\tif ((now.tv_sec - inode->i_atime.tv_sec <= osb->s_atime_quantum))\n\t\treturn 0;\n\telse\n\t\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 2477
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_inode_lock",
          "args": [
            "inode",
            "&bh",
            "1"
          ],
          "line": 2475
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_inode_lock_atime",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlmglue.c",
          "lines": "2455-2489",
          "snippet": "int ocfs2_inode_lock_atime(struct inode *inode,\n\t\t\t  struct vfsmount *vfsmnt,\n\t\t\t  int *level)\n{\n\tint ret;\n\n\tret = ocfs2_inode_lock(inode, NULL, 0);\n\tif (ret < 0) {\n\t\tmlog_errno(ret);\n\t\treturn ret;\n\t}\n\n\t/*\n\t * If we should update atime, we will get EX lock,\n\t * otherwise we just get PR lock.\n\t */\n\tif (ocfs2_should_update_atime(inode, vfsmnt)) {\n\t\tstruct buffer_head *bh = NULL;\n\n\t\tocfs2_inode_unlock(inode, 0);\n\t\tret = ocfs2_inode_lock(inode, &bh, 1);\n\t\tif (ret < 0) {\n\t\t\tmlog_errno(ret);\n\t\t\treturn ret;\n\t\t}\n\t\t*level = 1;\n\t\tif (ocfs2_should_update_atime(inode, vfsmnt))\n\t\t\tocfs2_update_inode_atime(inode, bh);\n\t\tif (bh)\n\t\t\tbrelse(bh);\n\t} else\n\t\t*level = 0;\n\n\treturn ret;\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_inode_unlock",
          "args": [
            "inode",
            "0"
          ],
          "line": 2474
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_inode_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlmglue.c",
          "lines": "2491-2505",
          "snippet": "void ocfs2_inode_unlock(struct inode *inode,\n\t\t       int ex)\n{\n\tint level = ex ? DLM_LOCK_EX : DLM_LOCK_PR;\n\tstruct ocfs2_lock_res *lockres = &OCFS2_I(inode)->ip_inode_lockres;\n\tstruct ocfs2_super *osb = OCFS2_SB(inode->i_sb);\n\n\tmlog(0, \"inode %llu drop %s META lock\\n\",\n\t     (unsigned long long)OCFS2_I(inode)->ip_blkno,\n\t     ex ? \"EXMODE\" : \"PRMODE\");\n\n\tif (!ocfs2_is_hard_readonly(OCFS2_SB(inode->i_sb)) &&\n\t    !ocfs2_mount_local(osb))\n\t\tocfs2_cluster_unlock(OCFS2_SB(inode->i_sb), lockres, level);\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"refcounttree.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"stackglue.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dcache.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2_lockingver.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/time.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/kthread.h>",
            "#include <linux/mm.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct ocfs2_super *ocfs2_get_dentry_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_inode_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_file_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_qinfo_osb(struct ocfs2_lock_res *lockres);",
            "static void ocfs2_set_meta_lvb(struct ocfs2_lock_res *lockres);",
            "static void ocfs2_dentry_post_unlock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres);",
            "static void ocfs2_set_qinfo_lvb(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_downconvert_action(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_convert_action(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_attach_action(struct ocfs2_lock_res *lockres);",
            "static int ocfs2_generic_handle_bast(struct ocfs2_lock_res *lockres, int level);",
            "static void ocfs2_schedule_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static void ocfs2_downconvert_on_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static void ocfs2_drop_osb_locks(struct ocfs2_super *osb);",
            "static inline int ocfs2_highest_compat_lock_level(int level);",
            "static int ocfs2_prepare_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\t        struct ocfs2_lock_res *lockres);",
            "static int ocfs2_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static void ocfs2_process_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *lockres);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"stackglue.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dcache.h\"\n#include \"alloc.h\"\n#include \"ocfs2_lockingver.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/quotaops.h>\n#include <linux/time.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/pagemap.h>\n#include <linux/kthread.h>\n#include <linux/mm.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic struct ocfs2_super *ocfs2_get_dentry_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_inode_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_file_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_qinfo_osb(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_set_meta_lvb(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_dentry_post_unlock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres);\nstatic void ocfs2_set_qinfo_lvb(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_downconvert_action(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_convert_action(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_attach_action(struct ocfs2_lock_res *lockres);\nstatic int ocfs2_generic_handle_bast(struct ocfs2_lock_res *lockres, int level);\nstatic void ocfs2_schedule_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_downconvert_on_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_drop_osb_locks(struct ocfs2_super *osb);\nstatic inline int ocfs2_highest_compat_lock_level(int level);\nstatic int ocfs2_prepare_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\t        struct ocfs2_lock_res *lockres);\nstatic int ocfs2_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_process_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *lockres);\n\nvoid ocfs2_inode_unlock(struct inode *inode,\n\t\t       int ex)\n{\n\tint level = ex ? DLM_LOCK_EX : DLM_LOCK_PR;\n\tstruct ocfs2_lock_res *lockres = &OCFS2_I(inode)->ip_inode_lockres;\n\tstruct ocfs2_super *osb = OCFS2_SB(inode->i_sb);\n\n\tmlog(0, \"inode %llu drop %s META lock\\n\",\n\t     (unsigned long long)OCFS2_I(inode)->ip_blkno,\n\t     ex ? \"EXMODE\" : \"PRMODE\");\n\n\tif (!ocfs2_is_hard_readonly(OCFS2_SB(inode->i_sb)) &&\n\t    !ocfs2_mount_local(osb))\n\t\tocfs2_cluster_unlock(OCFS2_SB(inode->i_sb), lockres, level);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 2463
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"stackglue.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dcache.h\"\n#include \"alloc.h\"\n#include \"ocfs2_lockingver.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/quotaops.h>\n#include <linux/time.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/pagemap.h>\n#include <linux/kthread.h>\n#include <linux/mm.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic int ocfs2_generic_handle_bast(struct ocfs2_lock_res *lockres, int level);\nstatic int ocfs2_inode_lock_update(struct inode *inode,\n\t\t\t\t  struct buffer_head **bh);\nstatic inline int ocfs2_highest_compat_lock_level(int level);\n\nint ocfs2_inode_lock_atime(struct inode *inode,\n\t\t\t  struct vfsmount *vfsmnt,\n\t\t\t  int *level)\n{\n\tint ret;\n\n\tret = ocfs2_inode_lock(inode, NULL, 0);\n\tif (ret < 0) {\n\t\tmlog_errno(ret);\n\t\treturn ret;\n\t}\n\n\t/*\n\t * If we should update atime, we will get EX lock,\n\t * otherwise we just get PR lock.\n\t */\n\tif (ocfs2_should_update_atime(inode, vfsmnt)) {\n\t\tstruct buffer_head *bh = NULL;\n\n\t\tocfs2_inode_unlock(inode, 0);\n\t\tret = ocfs2_inode_lock(inode, &bh, 1);\n\t\tif (ret < 0) {\n\t\t\tmlog_errno(ret);\n\t\t\treturn ret;\n\t\t}\n\t\t*level = 1;\n\t\tif (ocfs2_should_update_atime(inode, vfsmnt))\n\t\t\tocfs2_update_inode_atime(inode, bh);\n\t\tif (bh)\n\t\t\tbrelse(bh);\n\t} else\n\t\t*level = 0;\n\n\treturn ret;\n}"
  },
  {
    "function_name": "ocfs2_inode_lock_with_page",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlmglue.c",
    "lines": "2437-2453",
    "snippet": "int ocfs2_inode_lock_with_page(struct inode *inode,\n\t\t\t      struct buffer_head **ret_bh,\n\t\t\t      int ex,\n\t\t\t      struct page *page)\n{\n\tint ret;\n\n\tret = ocfs2_inode_lock_full(inode, ret_bh, ex, OCFS2_LOCK_NONBLOCK);\n\tif (ret == -EAGAIN) {\n\t\tunlock_page(page);\n\t\tif (ocfs2_inode_lock(inode, ret_bh, ex) == 0)\n\t\t\tocfs2_inode_unlock(inode, ex);\n\t\tret = AOP_TRUNCATED_PAGE;\n\t}\n\n\treturn ret;\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"refcounttree.h\"",
      "#include \"quota.h\"",
      "#include \"uptodate.h\"",
      "#include \"super.h\"",
      "#include \"slot_map.h\"",
      "#include \"stackglue.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"heartbeat.h\"",
      "#include \"file.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"dcache.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2_lockingver.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/time.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/kthread.h>",
      "#include <linux/mm.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ocfs2_inode_unlock",
          "args": [
            "inode",
            "ex"
          ],
          "line": 2448
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_inode_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlmglue.c",
          "lines": "2491-2505",
          "snippet": "void ocfs2_inode_unlock(struct inode *inode,\n\t\t       int ex)\n{\n\tint level = ex ? DLM_LOCK_EX : DLM_LOCK_PR;\n\tstruct ocfs2_lock_res *lockres = &OCFS2_I(inode)->ip_inode_lockres;\n\tstruct ocfs2_super *osb = OCFS2_SB(inode->i_sb);\n\n\tmlog(0, \"inode %llu drop %s META lock\\n\",\n\t     (unsigned long long)OCFS2_I(inode)->ip_blkno,\n\t     ex ? \"EXMODE\" : \"PRMODE\");\n\n\tif (!ocfs2_is_hard_readonly(OCFS2_SB(inode->i_sb)) &&\n\t    !ocfs2_mount_local(osb))\n\t\tocfs2_cluster_unlock(OCFS2_SB(inode->i_sb), lockres, level);\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"refcounttree.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"stackglue.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dcache.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2_lockingver.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/time.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/kthread.h>",
            "#include <linux/mm.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct ocfs2_super *ocfs2_get_dentry_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_inode_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_file_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_qinfo_osb(struct ocfs2_lock_res *lockres);",
            "static void ocfs2_set_meta_lvb(struct ocfs2_lock_res *lockres);",
            "static void ocfs2_dentry_post_unlock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres);",
            "static void ocfs2_set_qinfo_lvb(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_downconvert_action(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_convert_action(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_attach_action(struct ocfs2_lock_res *lockres);",
            "static int ocfs2_generic_handle_bast(struct ocfs2_lock_res *lockres, int level);",
            "static void ocfs2_schedule_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static void ocfs2_downconvert_on_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static void ocfs2_drop_osb_locks(struct ocfs2_super *osb);",
            "static inline int ocfs2_highest_compat_lock_level(int level);",
            "static int ocfs2_prepare_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\t        struct ocfs2_lock_res *lockres);",
            "static int ocfs2_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static void ocfs2_process_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *lockres);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"stackglue.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dcache.h\"\n#include \"alloc.h\"\n#include \"ocfs2_lockingver.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/quotaops.h>\n#include <linux/time.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/pagemap.h>\n#include <linux/kthread.h>\n#include <linux/mm.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic struct ocfs2_super *ocfs2_get_dentry_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_inode_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_file_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_qinfo_osb(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_set_meta_lvb(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_dentry_post_unlock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres);\nstatic void ocfs2_set_qinfo_lvb(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_downconvert_action(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_convert_action(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_attach_action(struct ocfs2_lock_res *lockres);\nstatic int ocfs2_generic_handle_bast(struct ocfs2_lock_res *lockres, int level);\nstatic void ocfs2_schedule_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_downconvert_on_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_drop_osb_locks(struct ocfs2_super *osb);\nstatic inline int ocfs2_highest_compat_lock_level(int level);\nstatic int ocfs2_prepare_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\t        struct ocfs2_lock_res *lockres);\nstatic int ocfs2_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_process_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *lockres);\n\nvoid ocfs2_inode_unlock(struct inode *inode,\n\t\t       int ex)\n{\n\tint level = ex ? DLM_LOCK_EX : DLM_LOCK_PR;\n\tstruct ocfs2_lock_res *lockres = &OCFS2_I(inode)->ip_inode_lockres;\n\tstruct ocfs2_super *osb = OCFS2_SB(inode->i_sb);\n\n\tmlog(0, \"inode %llu drop %s META lock\\n\",\n\t     (unsigned long long)OCFS2_I(inode)->ip_blkno,\n\t     ex ? \"EXMODE\" : \"PRMODE\");\n\n\tif (!ocfs2_is_hard_readonly(OCFS2_SB(inode->i_sb)) &&\n\t    !ocfs2_mount_local(osb))\n\t\tocfs2_cluster_unlock(OCFS2_SB(inode->i_sb), lockres, level);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_inode_lock",
          "args": [
            "inode",
            "ret_bh",
            "ex"
          ],
          "line": 2447
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_inode_lock_atime",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlmglue.c",
          "lines": "2455-2489",
          "snippet": "int ocfs2_inode_lock_atime(struct inode *inode,\n\t\t\t  struct vfsmount *vfsmnt,\n\t\t\t  int *level)\n{\n\tint ret;\n\n\tret = ocfs2_inode_lock(inode, NULL, 0);\n\tif (ret < 0) {\n\t\tmlog_errno(ret);\n\t\treturn ret;\n\t}\n\n\t/*\n\t * If we should update atime, we will get EX lock,\n\t * otherwise we just get PR lock.\n\t */\n\tif (ocfs2_should_update_atime(inode, vfsmnt)) {\n\t\tstruct buffer_head *bh = NULL;\n\n\t\tocfs2_inode_unlock(inode, 0);\n\t\tret = ocfs2_inode_lock(inode, &bh, 1);\n\t\tif (ret < 0) {\n\t\t\tmlog_errno(ret);\n\t\t\treturn ret;\n\t\t}\n\t\t*level = 1;\n\t\tif (ocfs2_should_update_atime(inode, vfsmnt))\n\t\t\tocfs2_update_inode_atime(inode, bh);\n\t\tif (bh)\n\t\t\tbrelse(bh);\n\t} else\n\t\t*level = 0;\n\n\treturn ret;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"refcounttree.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"stackglue.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dcache.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2_lockingver.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/time.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/kthread.h>",
            "#include <linux/mm.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ocfs2_generic_handle_bast(struct ocfs2_lock_res *lockres, int level);",
            "static int ocfs2_inode_lock_update(struct inode *inode,\n\t\t\t\t  struct buffer_head **bh);",
            "static inline int ocfs2_highest_compat_lock_level(int level);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"stackglue.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dcache.h\"\n#include \"alloc.h\"\n#include \"ocfs2_lockingver.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/quotaops.h>\n#include <linux/time.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/pagemap.h>\n#include <linux/kthread.h>\n#include <linux/mm.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic int ocfs2_generic_handle_bast(struct ocfs2_lock_res *lockres, int level);\nstatic int ocfs2_inode_lock_update(struct inode *inode,\n\t\t\t\t  struct buffer_head **bh);\nstatic inline int ocfs2_highest_compat_lock_level(int level);\n\nint ocfs2_inode_lock_atime(struct inode *inode,\n\t\t\t  struct vfsmount *vfsmnt,\n\t\t\t  int *level)\n{\n\tint ret;\n\n\tret = ocfs2_inode_lock(inode, NULL, 0);\n\tif (ret < 0) {\n\t\tmlog_errno(ret);\n\t\treturn ret;\n\t}\n\n\t/*\n\t * If we should update atime, we will get EX lock,\n\t * otherwise we just get PR lock.\n\t */\n\tif (ocfs2_should_update_atime(inode, vfsmnt)) {\n\t\tstruct buffer_head *bh = NULL;\n\n\t\tocfs2_inode_unlock(inode, 0);\n\t\tret = ocfs2_inode_lock(inode, &bh, 1);\n\t\tif (ret < 0) {\n\t\t\tmlog_errno(ret);\n\t\t\treturn ret;\n\t\t}\n\t\t*level = 1;\n\t\tif (ocfs2_should_update_atime(inode, vfsmnt))\n\t\t\tocfs2_update_inode_atime(inode, bh);\n\t\tif (bh)\n\t\t\tbrelse(bh);\n\t} else\n\t\t*level = 0;\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlock_page",
          "args": [
            "page"
          ],
          "line": 2446
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_unlock_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/aops.c",
          "lines": "1127-1148",
          "snippet": "static void ocfs2_unlock_pages(struct ocfs2_write_ctxt *wc)\n{\n\tint i;\n\n\t/*\n\t * w_target_locked is only set to true in the page_mkwrite() case.\n\t * The intent is to allow us to lock the target page from write_begin()\n\t * to write_end(). The caller must hold a ref on w_target_page.\n\t */\n\tif (wc->w_target_locked) {\n\t\tBUG_ON(!wc->w_target_page);\n\t\tfor (i = 0; i < wc->w_num_pages; i++) {\n\t\t\tif (wc->w_target_page == wc->w_pages[i]) {\n\t\t\t\twc->w_pages[i] = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tmark_page_accessed(wc->w_target_page);\n\t\tpage_cache_release(wc->w_target_page);\n\t}\n\tocfs2_unlock_and_free_pages(wc->w_pages, wc->w_num_pages);\n}",
          "includes": [
            "#include \"sysfile.h\"",
            "#include \"namei.h\"",
            "#include \"dir.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"symlink.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/mpage.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/swap.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sysfile.h\"\n#include \"namei.h\"\n#include \"dir.h\"\n#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"symlink.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/mpage.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/swap.h>\n#include <asm/byteorder.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic void ocfs2_unlock_pages(struct ocfs2_write_ctxt *wc)\n{\n\tint i;\n\n\t/*\n\t * w_target_locked is only set to true in the page_mkwrite() case.\n\t * The intent is to allow us to lock the target page from write_begin()\n\t * to write_end(). The caller must hold a ref on w_target_page.\n\t */\n\tif (wc->w_target_locked) {\n\t\tBUG_ON(!wc->w_target_page);\n\t\tfor (i = 0; i < wc->w_num_pages; i++) {\n\t\t\tif (wc->w_target_page == wc->w_pages[i]) {\n\t\t\t\twc->w_pages[i] = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tmark_page_accessed(wc->w_target_page);\n\t\tpage_cache_release(wc->w_target_page);\n\t}\n\tocfs2_unlock_and_free_pages(wc->w_pages, wc->w_num_pages);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_inode_lock_full",
          "args": [
            "inode",
            "ret_bh",
            "ex",
            "OCFS2_LOCK_NONBLOCK"
          ],
          "line": 2444
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"stackglue.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dcache.h\"\n#include \"alloc.h\"\n#include \"ocfs2_lockingver.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/quotaops.h>\n#include <linux/time.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/pagemap.h>\n#include <linux/kthread.h>\n#include <linux/mm.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nint ocfs2_inode_lock_with_page(struct inode *inode,\n\t\t\t      struct buffer_head **ret_bh,\n\t\t\t      int ex,\n\t\t\t      struct page *page)\n{\n\tint ret;\n\n\tret = ocfs2_inode_lock_full(inode, ret_bh, ex, OCFS2_LOCK_NONBLOCK);\n\tif (ret == -EAGAIN) {\n\t\tunlock_page(page);\n\t\tif (ocfs2_inode_lock(inode, ret_bh, ex) == 0)\n\t\t\tocfs2_inode_unlock(inode, ex);\n\t\tret = AOP_TRUNCATED_PAGE;\n\t}\n\n\treturn ret;\n}"
  },
  {
    "function_name": "ocfs2_inode_lock_full_nested",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlmglue.c",
    "lines": "2307-2413",
    "snippet": "int ocfs2_inode_lock_full_nested(struct inode *inode,\n\t\t\t\t struct buffer_head **ret_bh,\n\t\t\t\t int ex,\n\t\t\t\t int arg_flags,\n\t\t\t\t int subclass)\n{\n\tint status, level, acquired;\n\tu32 dlm_flags;\n\tstruct ocfs2_lock_res *lockres = NULL;\n\tstruct ocfs2_super *osb = OCFS2_SB(inode->i_sb);\n\tstruct buffer_head *local_bh = NULL;\n\n\tBUG_ON(!inode);\n\n\tmlog(0, \"inode %llu, take %s META lock\\n\",\n\t     (unsigned long long)OCFS2_I(inode)->ip_blkno,\n\t     ex ? \"EXMODE\" : \"PRMODE\");\n\n\tstatus = 0;\n\tacquired = 0;\n\t/* We'll allow faking a readonly metadata lock for\n\t * rodevices. */\n\tif (ocfs2_is_hard_readonly(osb)) {\n\t\tif (ex)\n\t\t\tstatus = -EROFS;\n\t\tgoto getbh;\n\t}\n\n\tif (ocfs2_mount_local(osb))\n\t\tgoto local;\n\n\tif (!(arg_flags & OCFS2_META_LOCK_RECOVERY))\n\t\tocfs2_wait_for_recovery(osb);\n\n\tlockres = &OCFS2_I(inode)->ip_inode_lockres;\n\tlevel = ex ? DLM_LOCK_EX : DLM_LOCK_PR;\n\tdlm_flags = 0;\n\tif (arg_flags & OCFS2_META_LOCK_NOQUEUE)\n\t\tdlm_flags |= DLM_LKF_NOQUEUE;\n\n\tstatus = __ocfs2_cluster_lock(osb, lockres, level, dlm_flags,\n\t\t\t\t      arg_flags, subclass, _RET_IP_);\n\tif (status < 0) {\n\t\tif (status != -EAGAIN)\n\t\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\t/* Notify the error cleanup path to drop the cluster lock. */\n\tacquired = 1;\n\n\t/* We wait twice because a node may have died while we were in\n\t * the lower dlm layers. The second time though, we've\n\t * committed to owning this lock so we don't allow signals to\n\t * abort the operation. */\n\tif (!(arg_flags & OCFS2_META_LOCK_RECOVERY))\n\t\tocfs2_wait_for_recovery(osb);\n\nlocal:\n\t/*\n\t * We only see this flag if we're being called from\n\t * ocfs2_read_locked_inode(). It means we're locking an inode\n\t * which hasn't been populated yet, so clear the refresh flag\n\t * and let the caller handle it.\n\t */\n\tif (inode->i_state & I_NEW) {\n\t\tstatus = 0;\n\t\tif (lockres)\n\t\t\tocfs2_complete_lock_res_refresh(lockres, 0);\n\t\tgoto bail;\n\t}\n\n\t/* This is fun. The caller may want a bh back, or it may\n\t * not. ocfs2_inode_lock_update definitely wants one in, but\n\t * may or may not read one, depending on what's in the\n\t * LVB. The result of all of this is that we've *only* gone to\n\t * disk if we have to, so the complexity is worthwhile. */\n\tstatus = ocfs2_inode_lock_update(inode, &local_bh);\n\tif (status < 0) {\n\t\tif (status != -ENOENT)\n\t\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\ngetbh:\n\tif (ret_bh) {\n\t\tstatus = ocfs2_assign_bh(inode, ret_bh, local_bh);\n\t\tif (status < 0) {\n\t\t\tmlog_errno(status);\n\t\t\tgoto bail;\n\t\t}\n\t}\n\nbail:\n\tif (status < 0) {\n\t\tif (ret_bh && (*ret_bh)) {\n\t\t\tbrelse(*ret_bh);\n\t\t\t*ret_bh = NULL;\n\t\t}\n\t\tif (acquired)\n\t\t\tocfs2_inode_unlock(inode, ex);\n\t}\n\n\tif (local_bh)\n\t\tbrelse(local_bh);\n\n\treturn status;\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"refcounttree.h\"",
      "#include \"quota.h\"",
      "#include \"uptodate.h\"",
      "#include \"super.h\"",
      "#include \"slot_map.h\"",
      "#include \"stackglue.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"heartbeat.h\"",
      "#include \"file.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"dcache.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2_lockingver.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/time.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/kthread.h>",
      "#include <linux/mm.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct ocfs2_super *ocfs2_get_dentry_osb(struct ocfs2_lock_res *lockres);",
      "static struct ocfs2_super *ocfs2_get_inode_osb(struct ocfs2_lock_res *lockres);",
      "static struct ocfs2_super *ocfs2_get_file_osb(struct ocfs2_lock_res *lockres);",
      "static struct ocfs2_super *ocfs2_get_qinfo_osb(struct ocfs2_lock_res *lockres);",
      "static void ocfs2_set_meta_lvb(struct ocfs2_lock_res *lockres);",
      "static void ocfs2_dentry_post_unlock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres);",
      "static void ocfs2_set_qinfo_lvb(struct ocfs2_lock_res *lockres);",
      "static int ocfs2_lock_create(struct ocfs2_super *osb,\n\t\t\t     struct ocfs2_lock_res *lockres,\n\t\t\t     int level,\n\t\t\t     u32 dlm_flags);",
      "static inline void ocfs2_generic_handle_downconvert_action(struct ocfs2_lock_res *lockres);",
      "static inline void ocfs2_generic_handle_convert_action(struct ocfs2_lock_res *lockres);",
      "static inline void ocfs2_generic_handle_attach_action(struct ocfs2_lock_res *lockres);",
      "static int ocfs2_generic_handle_bast(struct ocfs2_lock_res *lockres, int level);",
      "static void ocfs2_schedule_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);",
      "static void ocfs2_downconvert_on_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);",
      "static int ocfs2_inode_lock_update(struct inode *inode,\n\t\t\t\t  struct buffer_head **bh);",
      "static void ocfs2_drop_osb_locks(struct ocfs2_super *osb);",
      "static inline int ocfs2_highest_compat_lock_level(int level);",
      "static int ocfs2_prepare_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\t        struct ocfs2_lock_res *lockres);",
      "static int ocfs2_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres);",
      "static void ocfs2_process_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *lockres);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "brelse",
          "args": [
            "local_bh"
          ],
          "line": 2410
        },
        "resolved": true,
        "details": {
          "function_name": "__brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1177-1184",
          "snippet": "void __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_inode_unlock",
          "args": [
            "inode",
            "ex"
          ],
          "line": 2406
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_inode_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlmglue.c",
          "lines": "2491-2505",
          "snippet": "void ocfs2_inode_unlock(struct inode *inode,\n\t\t       int ex)\n{\n\tint level = ex ? DLM_LOCK_EX : DLM_LOCK_PR;\n\tstruct ocfs2_lock_res *lockres = &OCFS2_I(inode)->ip_inode_lockres;\n\tstruct ocfs2_super *osb = OCFS2_SB(inode->i_sb);\n\n\tmlog(0, \"inode %llu drop %s META lock\\n\",\n\t     (unsigned long long)OCFS2_I(inode)->ip_blkno,\n\t     ex ? \"EXMODE\" : \"PRMODE\");\n\n\tif (!ocfs2_is_hard_readonly(OCFS2_SB(inode->i_sb)) &&\n\t    !ocfs2_mount_local(osb))\n\t\tocfs2_cluster_unlock(OCFS2_SB(inode->i_sb), lockres, level);\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"refcounttree.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"stackglue.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dcache.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2_lockingver.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/time.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/kthread.h>",
            "#include <linux/mm.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct ocfs2_super *ocfs2_get_dentry_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_inode_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_file_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_qinfo_osb(struct ocfs2_lock_res *lockres);",
            "static void ocfs2_set_meta_lvb(struct ocfs2_lock_res *lockres);",
            "static void ocfs2_dentry_post_unlock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres);",
            "static void ocfs2_set_qinfo_lvb(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_downconvert_action(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_convert_action(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_attach_action(struct ocfs2_lock_res *lockres);",
            "static int ocfs2_generic_handle_bast(struct ocfs2_lock_res *lockres, int level);",
            "static void ocfs2_schedule_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static void ocfs2_downconvert_on_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static void ocfs2_drop_osb_locks(struct ocfs2_super *osb);",
            "static inline int ocfs2_highest_compat_lock_level(int level);",
            "static int ocfs2_prepare_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\t        struct ocfs2_lock_res *lockres);",
            "static int ocfs2_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static void ocfs2_process_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *lockres);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"stackglue.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dcache.h\"\n#include \"alloc.h\"\n#include \"ocfs2_lockingver.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/quotaops.h>\n#include <linux/time.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/pagemap.h>\n#include <linux/kthread.h>\n#include <linux/mm.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic struct ocfs2_super *ocfs2_get_dentry_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_inode_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_file_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_qinfo_osb(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_set_meta_lvb(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_dentry_post_unlock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres);\nstatic void ocfs2_set_qinfo_lvb(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_downconvert_action(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_convert_action(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_attach_action(struct ocfs2_lock_res *lockres);\nstatic int ocfs2_generic_handle_bast(struct ocfs2_lock_res *lockres, int level);\nstatic void ocfs2_schedule_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_downconvert_on_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_drop_osb_locks(struct ocfs2_super *osb);\nstatic inline int ocfs2_highest_compat_lock_level(int level);\nstatic int ocfs2_prepare_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\t        struct ocfs2_lock_res *lockres);\nstatic int ocfs2_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_process_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *lockres);\n\nvoid ocfs2_inode_unlock(struct inode *inode,\n\t\t       int ex)\n{\n\tint level = ex ? DLM_LOCK_EX : DLM_LOCK_PR;\n\tstruct ocfs2_lock_res *lockres = &OCFS2_I(inode)->ip_inode_lockres;\n\tstruct ocfs2_super *osb = OCFS2_SB(inode->i_sb);\n\n\tmlog(0, \"inode %llu drop %s META lock\\n\",\n\t     (unsigned long long)OCFS2_I(inode)->ip_blkno,\n\t     ex ? \"EXMODE\" : \"PRMODE\");\n\n\tif (!ocfs2_is_hard_readonly(OCFS2_SB(inode->i_sb)) &&\n\t    !ocfs2_mount_local(osb))\n\t\tocfs2_cluster_unlock(OCFS2_SB(inode->i_sb), lockres, level);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "status"
          ],
          "line": 2394
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_assign_bh",
          "args": [
            "inode",
            "ret_bh",
            "local_bh"
          ],
          "line": 2392
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_assign_bh",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlmglue.c",
          "lines": "2281-2301",
          "snippet": "static int ocfs2_assign_bh(struct inode *inode,\n\t\t\t   struct buffer_head **ret_bh,\n\t\t\t   struct buffer_head *passed_bh)\n{\n\tint status;\n\n\tif (passed_bh) {\n\t\t/* Ok, the update went to disk for us, use the\n\t\t * returned bh. */\n\t\t*ret_bh = passed_bh;\n\t\tget_bh(*ret_bh);\n\n\t\treturn 0;\n\t}\n\n\tstatus = ocfs2_read_inode_block(inode, ret_bh);\n\tif (status < 0)\n\t\tmlog_errno(status);\n\n\treturn status;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"refcounttree.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"stackglue.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dcache.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2_lockingver.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/time.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/kthread.h>",
            "#include <linux/mm.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ocfs2_inode_lock_update(struct inode *inode,\n\t\t\t\t  struct buffer_head **bh);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"stackglue.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dcache.h\"\n#include \"alloc.h\"\n#include \"ocfs2_lockingver.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/quotaops.h>\n#include <linux/time.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/pagemap.h>\n#include <linux/kthread.h>\n#include <linux/mm.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic int ocfs2_inode_lock_update(struct inode *inode,\n\t\t\t\t  struct buffer_head **bh);\n\nstatic int ocfs2_assign_bh(struct inode *inode,\n\t\t\t   struct buffer_head **ret_bh,\n\t\t\t   struct buffer_head *passed_bh)\n{\n\tint status;\n\n\tif (passed_bh) {\n\t\t/* Ok, the update went to disk for us, use the\n\t\t * returned bh. */\n\t\t*ret_bh = passed_bh;\n\t\tget_bh(*ret_bh);\n\n\t\treturn 0;\n\t}\n\n\tstatus = ocfs2_read_inode_block(inode, ret_bh);\n\tif (status < 0)\n\t\tmlog_errno(status);\n\n\treturn status;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "status"
          ],
          "line": 2387
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_inode_lock_update",
          "args": [
            "inode",
            "&local_bh"
          ],
          "line": 2384
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_inode_lock_update",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlmglue.c",
          "lines": "2201-2279",
          "snippet": "static int ocfs2_inode_lock_update(struct inode *inode,\n\t\t\t\t  struct buffer_head **bh)\n{\n\tint status = 0;\n\tstruct ocfs2_inode_info *oi = OCFS2_I(inode);\n\tstruct ocfs2_lock_res *lockres = &oi->ip_inode_lockres;\n\tstruct ocfs2_dinode *fe;\n\tstruct ocfs2_super *osb = OCFS2_SB(inode->i_sb);\n\n\tif (ocfs2_mount_local(osb))\n\t\tgoto bail;\n\n\tspin_lock(&oi->ip_lock);\n\tif (oi->ip_flags & OCFS2_INODE_DELETED) {\n\t\tmlog(0, \"Orphaned inode %llu was deleted while we \"\n\t\t     \"were waiting on a lock. ip_flags = 0x%x\\n\",\n\t\t     (unsigned long long)oi->ip_blkno, oi->ip_flags);\n\t\tspin_unlock(&oi->ip_lock);\n\t\tstatus = -ENOENT;\n\t\tgoto bail;\n\t}\n\tspin_unlock(&oi->ip_lock);\n\n\tif (!ocfs2_should_refresh_lock_res(lockres))\n\t\tgoto bail;\n\n\t/* This will discard any caching information we might have had\n\t * for the inode metadata. */\n\tocfs2_metadata_cache_purge(INODE_CACHE(inode));\n\n\tocfs2_extent_map_trunc(inode, 0);\n\n\tif (ocfs2_meta_lvb_is_trustable(inode, lockres)) {\n\t\tmlog(0, \"Trusting LVB on inode %llu\\n\",\n\t\t     (unsigned long long)oi->ip_blkno);\n\t\tocfs2_refresh_inode_from_lvb(inode);\n\t} else {\n\t\t/* Boo, we have to go to disk. */\n\t\t/* read bh, cast, ocfs2_refresh_inode */\n\t\tstatus = ocfs2_read_inode_block(inode, bh);\n\t\tif (status < 0) {\n\t\t\tmlog_errno(status);\n\t\t\tgoto bail_refresh;\n\t\t}\n\t\tfe = (struct ocfs2_dinode *) (*bh)->b_data;\n\n\t\t/* This is a good chance to make sure we're not\n\t\t * locking an invalid object.  ocfs2_read_inode_block()\n\t\t * already checked that the inode block is sane.\n\t\t *\n\t\t * We bug on a stale inode here because we checked\n\t\t * above whether it was wiped from disk. The wiping\n\t\t * node provides a guarantee that we receive that\n\t\t * message and can mark the inode before dropping any\n\t\t * locks associated with it. */\n\t\tmlog_bug_on_msg(inode->i_generation !=\n\t\t\t\tle32_to_cpu(fe->i_generation),\n\t\t\t\t\"Invalid dinode %llu disk generation: %u \"\n\t\t\t\t\"inode->i_generation: %u\\n\",\n\t\t\t\t(unsigned long long)oi->ip_blkno,\n\t\t\t\tle32_to_cpu(fe->i_generation),\n\t\t\t\tinode->i_generation);\n\t\tmlog_bug_on_msg(le64_to_cpu(fe->i_dtime) ||\n\t\t\t\t!(fe->i_flags & cpu_to_le32(OCFS2_VALID_FL)),\n\t\t\t\t\"Stale dinode %llu dtime: %llu flags: 0x%x\\n\",\n\t\t\t\t(unsigned long long)oi->ip_blkno,\n\t\t\t\t(unsigned long long)le64_to_cpu(fe->i_dtime),\n\t\t\t\tle32_to_cpu(fe->i_flags));\n\n\t\tocfs2_refresh_inode(inode, fe);\n\t\tocfs2_track_lock_refresh(lockres);\n\t}\n\n\tstatus = 0;\nbail_refresh:\n\tocfs2_complete_lock_res_refresh(lockres, status);\nbail:\n\treturn status;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"refcounttree.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"stackglue.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dcache.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2_lockingver.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/time.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/kthread.h>",
            "#include <linux/mm.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct ocfs2_super *ocfs2_get_dentry_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_inode_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_file_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_qinfo_osb(struct ocfs2_lock_res *lockres);",
            "static void ocfs2_set_meta_lvb(struct ocfs2_lock_res *lockres);",
            "static void ocfs2_dentry_post_unlock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres);",
            "static void ocfs2_set_qinfo_lvb(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_downconvert_action(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_convert_action(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_attach_action(struct ocfs2_lock_res *lockres);",
            "static void ocfs2_schedule_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static void ocfs2_downconvert_on_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static int ocfs2_inode_lock_update(struct inode *inode,\n\t\t\t\t  struct buffer_head **bh);",
            "static void ocfs2_drop_osb_locks(struct ocfs2_super *osb);",
            "static int ocfs2_downconvert_lock(struct ocfs2_super *osb,\n\t\t\t\t  struct ocfs2_lock_res *lockres,\n\t\t\t\t  int new_level,\n\t\t\t\t  int lvb,\n\t\t\t\t  unsigned int generation);",
            "static int ocfs2_prepare_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\t        struct ocfs2_lock_res *lockres);",
            "static int ocfs2_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static void ocfs2_process_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *lockres);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"stackglue.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dcache.h\"\n#include \"alloc.h\"\n#include \"ocfs2_lockingver.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/quotaops.h>\n#include <linux/time.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/pagemap.h>\n#include <linux/kthread.h>\n#include <linux/mm.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic struct ocfs2_super *ocfs2_get_dentry_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_inode_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_file_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_qinfo_osb(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_set_meta_lvb(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_dentry_post_unlock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres);\nstatic void ocfs2_set_qinfo_lvb(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_downconvert_action(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_convert_action(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_attach_action(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_schedule_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_downconvert_on_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic int ocfs2_inode_lock_update(struct inode *inode,\n\t\t\t\t  struct buffer_head **bh);\nstatic void ocfs2_drop_osb_locks(struct ocfs2_super *osb);\nstatic int ocfs2_downconvert_lock(struct ocfs2_super *osb,\n\t\t\t\t  struct ocfs2_lock_res *lockres,\n\t\t\t\t  int new_level,\n\t\t\t\t  int lvb,\n\t\t\t\t  unsigned int generation);\nstatic int ocfs2_prepare_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\t        struct ocfs2_lock_res *lockres);\nstatic int ocfs2_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_process_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *lockres);\n\nstatic int ocfs2_inode_lock_update(struct inode *inode,\n\t\t\t\t  struct buffer_head **bh)\n{\n\tint status = 0;\n\tstruct ocfs2_inode_info *oi = OCFS2_I(inode);\n\tstruct ocfs2_lock_res *lockres = &oi->ip_inode_lockres;\n\tstruct ocfs2_dinode *fe;\n\tstruct ocfs2_super *osb = OCFS2_SB(inode->i_sb);\n\n\tif (ocfs2_mount_local(osb))\n\t\tgoto bail;\n\n\tspin_lock(&oi->ip_lock);\n\tif (oi->ip_flags & OCFS2_INODE_DELETED) {\n\t\tmlog(0, \"Orphaned inode %llu was deleted while we \"\n\t\t     \"were waiting on a lock. ip_flags = 0x%x\\n\",\n\t\t     (unsigned long long)oi->ip_blkno, oi->ip_flags);\n\t\tspin_unlock(&oi->ip_lock);\n\t\tstatus = -ENOENT;\n\t\tgoto bail;\n\t}\n\tspin_unlock(&oi->ip_lock);\n\n\tif (!ocfs2_should_refresh_lock_res(lockres))\n\t\tgoto bail;\n\n\t/* This will discard any caching information we might have had\n\t * for the inode metadata. */\n\tocfs2_metadata_cache_purge(INODE_CACHE(inode));\n\n\tocfs2_extent_map_trunc(inode, 0);\n\n\tif (ocfs2_meta_lvb_is_trustable(inode, lockres)) {\n\t\tmlog(0, \"Trusting LVB on inode %llu\\n\",\n\t\t     (unsigned long long)oi->ip_blkno);\n\t\tocfs2_refresh_inode_from_lvb(inode);\n\t} else {\n\t\t/* Boo, we have to go to disk. */\n\t\t/* read bh, cast, ocfs2_refresh_inode */\n\t\tstatus = ocfs2_read_inode_block(inode, bh);\n\t\tif (status < 0) {\n\t\t\tmlog_errno(status);\n\t\t\tgoto bail_refresh;\n\t\t}\n\t\tfe = (struct ocfs2_dinode *) (*bh)->b_data;\n\n\t\t/* This is a good chance to make sure we're not\n\t\t * locking an invalid object.  ocfs2_read_inode_block()\n\t\t * already checked that the inode block is sane.\n\t\t *\n\t\t * We bug on a stale inode here because we checked\n\t\t * above whether it was wiped from disk. The wiping\n\t\t * node provides a guarantee that we receive that\n\t\t * message and can mark the inode before dropping any\n\t\t * locks associated with it. */\n\t\tmlog_bug_on_msg(inode->i_generation !=\n\t\t\t\tle32_to_cpu(fe->i_generation),\n\t\t\t\t\"Invalid dinode %llu disk generation: %u \"\n\t\t\t\t\"inode->i_generation: %u\\n\",\n\t\t\t\t(unsigned long long)oi->ip_blkno,\n\t\t\t\tle32_to_cpu(fe->i_generation),\n\t\t\t\tinode->i_generation);\n\t\tmlog_bug_on_msg(le64_to_cpu(fe->i_dtime) ||\n\t\t\t\t!(fe->i_flags & cpu_to_le32(OCFS2_VALID_FL)),\n\t\t\t\t\"Stale dinode %llu dtime: %llu flags: 0x%x\\n\",\n\t\t\t\t(unsigned long long)oi->ip_blkno,\n\t\t\t\t(unsigned long long)le64_to_cpu(fe->i_dtime),\n\t\t\t\tle32_to_cpu(fe->i_flags));\n\n\t\tocfs2_refresh_inode(inode, fe);\n\t\tocfs2_track_lock_refresh(lockres);\n\t}\n\n\tstatus = 0;\nbail_refresh:\n\tocfs2_complete_lock_res_refresh(lockres, status);\nbail:\n\treturn status;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_complete_lock_res_refresh",
          "args": [
            "lockres",
            "0"
          ],
          "line": 2375
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_complete_lock_res_refresh",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlmglue.c",
          "lines": "2186-2198",
          "snippet": "static inline void ocfs2_complete_lock_res_refresh(struct ocfs2_lock_res *lockres,\n\t\t\t\t\t\t   int status)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&lockres->l_lock, flags);\n\tlockres_clear_flags(lockres, OCFS2_LOCK_REFRESHING);\n\tif (!status)\n\t\tlockres_clear_flags(lockres, OCFS2_LOCK_NEEDS_REFRESH);\n\tspin_unlock_irqrestore(&lockres->l_lock, flags);\n\n\twake_up(&lockres->l_event);\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"refcounttree.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"stackglue.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dcache.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2_lockingver.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/time.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/kthread.h>",
            "#include <linux/mm.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct ocfs2_super *ocfs2_get_dentry_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_inode_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_file_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_qinfo_osb(struct ocfs2_lock_res *lockres);",
            "static void ocfs2_set_meta_lvb(struct ocfs2_lock_res *lockres);",
            "static void ocfs2_dentry_post_unlock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres);",
            "static void ocfs2_set_qinfo_lvb(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_downconvert_action(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_convert_action(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_attach_action(struct ocfs2_lock_res *lockres);",
            "static void ocfs2_schedule_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static void ocfs2_downconvert_on_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static int ocfs2_prepare_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\t        struct ocfs2_lock_res *lockres);",
            "static int ocfs2_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static void ocfs2_process_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *lockres);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"stackglue.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dcache.h\"\n#include \"alloc.h\"\n#include \"ocfs2_lockingver.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/quotaops.h>\n#include <linux/time.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/pagemap.h>\n#include <linux/kthread.h>\n#include <linux/mm.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic struct ocfs2_super *ocfs2_get_dentry_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_inode_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_file_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_qinfo_osb(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_set_meta_lvb(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_dentry_post_unlock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres);\nstatic void ocfs2_set_qinfo_lvb(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_downconvert_action(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_convert_action(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_attach_action(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_schedule_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_downconvert_on_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic int ocfs2_prepare_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\t        struct ocfs2_lock_res *lockres);\nstatic int ocfs2_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_process_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *lockres);\n\nstatic inline void ocfs2_complete_lock_res_refresh(struct ocfs2_lock_res *lockres,\n\t\t\t\t\t\t   int status)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&lockres->l_lock, flags);\n\tlockres_clear_flags(lockres, OCFS2_LOCK_REFRESHING);\n\tif (!status)\n\t\tlockres_clear_flags(lockres, OCFS2_LOCK_NEEDS_REFRESH);\n\tspin_unlock_irqrestore(&lockres->l_lock, flags);\n\n\twake_up(&lockres->l_event);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_wait_for_recovery",
          "args": [
            "osb"
          ],
          "line": 2363
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_wait_for_recovery",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/journal.c",
          "lines": "1116-1119",
          "snippet": "void ocfs2_wait_for_recovery(struct ocfs2_super *osb)\n{\n\twait_event(osb->recovery_event, ocfs2_recovery_completed(osb));\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"namei.h\"",
            "#include \"file.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/delay.h>",
            "#include <linux/random.h>",
            "#include <linux/time.h>",
            "#include <linux/kthread.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ocfs2_commit_cache(struct ocfs2_super *osb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"buffer_head_io.h\"\n#include \"namei.h\"\n#include \"file.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/delay.h>\n#include <linux/random.h>\n#include <linux/time.h>\n#include <linux/kthread.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_commit_cache(struct ocfs2_super *osb);\n\nvoid ocfs2_wait_for_recovery(struct ocfs2_super *osb)\n{\n\twait_event(osb->recovery_event, ocfs2_recovery_completed(osb));\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "status"
          ],
          "line": 2351
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__ocfs2_cluster_lock",
          "args": [
            "osb",
            "lockres",
            "level",
            "dlm_flags",
            "arg_flags",
            "subclass",
            "_RET_IP_"
          ],
          "line": 2347
        },
        "resolved": true,
        "details": {
          "function_name": "__ocfs2_cluster_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlmglue.c",
          "lines": "1378-1568",
          "snippet": "static int __ocfs2_cluster_lock(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres,\n\t\t\t\tint level,\n\t\t\t\tu32 lkm_flags,\n\t\t\t\tint arg_flags,\n\t\t\t\tint l_subclass,\n\t\t\t\tunsigned long caller_ip)\n{\n\tstruct ocfs2_mask_waiter mw;\n\tint wait, catch_signals = !(osb->s_mount_opt & OCFS2_MOUNT_NOINTR);\n\tint ret = 0; /* gcc doesn't realize wait = 1 guarantees ret is set */\n\tunsigned long flags;\n\tunsigned int gen;\n\tint noqueue_attempted = 0;\n\tint dlm_locked = 0;\n\n\tocfs2_init_mask_waiter(&mw);\n\n\tif (lockres->l_ops->flags & LOCK_TYPE_USES_LVB)\n\t\tlkm_flags |= DLM_LKF_VALBLK;\n\nagain:\n\twait = 0;\n\n\tspin_lock_irqsave(&lockres->l_lock, flags);\n\n\tif (catch_signals && signal_pending(current)) {\n\t\tret = -ERESTARTSYS;\n\t\tgoto unlock;\n\t}\n\n\tmlog_bug_on_msg(lockres->l_flags & OCFS2_LOCK_FREEING,\n\t\t\t\"Cluster lock called on freeing lockres %s! flags \"\n\t\t\t\"0x%lx\\n\", lockres->l_name, lockres->l_flags);\n\n\t/* We only compare against the currently granted level\n\t * here. If the lock is blocked waiting on a downconvert,\n\t * we'll get caught below. */\n\tif (lockres->l_flags & OCFS2_LOCK_BUSY &&\n\t    level > lockres->l_level) {\n\t\t/* is someone sitting in dlm_lock? If so, wait on\n\t\t * them. */\n\t\tlockres_add_mask_waiter(lockres, &mw, OCFS2_LOCK_BUSY, 0);\n\t\twait = 1;\n\t\tgoto unlock;\n\t}\n\n\tif (lockres->l_flags & OCFS2_LOCK_UPCONVERT_FINISHING) {\n\t\t/*\n\t\t * We've upconverted. If the lock now has a level we can\n\t\t * work with, we take it. If, however, the lock is not at the\n\t\t * required level, we go thru the full cycle. One way this could\n\t\t * happen is if a process requesting an upconvert to PR is\n\t\t * closely followed by another requesting upconvert to an EX.\n\t\t * If the process requesting EX lands here, we want it to\n\t\t * continue attempting to upconvert and let the process\n\t\t * requesting PR take the lock.\n\t\t * If multiple processes request upconvert to PR, the first one\n\t\t * here will take the lock. The others will have to go thru the\n\t\t * OCFS2_LOCK_BLOCKED check to ensure that there is no pending\n\t\t * downconvert request.\n\t\t */\n\t\tif (level <= lockres->l_level)\n\t\t\tgoto update_holders;\n\t}\n\n\tif (lockres->l_flags & OCFS2_LOCK_BLOCKED &&\n\t    !ocfs2_may_continue_on_blocked_lock(lockres, level)) {\n\t\t/* is the lock is currently blocked on behalf of\n\t\t * another node */\n\t\tlockres_add_mask_waiter(lockres, &mw, OCFS2_LOCK_BLOCKED, 0);\n\t\twait = 1;\n\t\tgoto unlock;\n\t}\n\n\tif (level > lockres->l_level) {\n\t\tif (noqueue_attempted > 0) {\n\t\t\tret = -EAGAIN;\n\t\t\tgoto unlock;\n\t\t}\n\t\tif (lkm_flags & DLM_LKF_NOQUEUE)\n\t\t\tnoqueue_attempted = 1;\n\n\t\tif (lockres->l_action != OCFS2_AST_INVALID)\n\t\t\tmlog(ML_ERROR, \"lockres %s has action %u pending\\n\",\n\t\t\t     lockres->l_name, lockres->l_action);\n\n\t\tif (!(lockres->l_flags & OCFS2_LOCK_ATTACHED)) {\n\t\t\tlockres->l_action = OCFS2_AST_ATTACH;\n\t\t\tlkm_flags &= ~DLM_LKF_CONVERT;\n\t\t} else {\n\t\t\tlockres->l_action = OCFS2_AST_CONVERT;\n\t\t\tlkm_flags |= DLM_LKF_CONVERT;\n\t\t}\n\n\t\tlockres->l_requested = level;\n\t\tlockres_or_flags(lockres, OCFS2_LOCK_BUSY);\n\t\tgen = lockres_set_pending(lockres);\n\t\tspin_unlock_irqrestore(&lockres->l_lock, flags);\n\n\t\tBUG_ON(level == DLM_LOCK_IV);\n\t\tBUG_ON(level == DLM_LOCK_NL);\n\n\t\tmlog(ML_BASTS, \"lockres %s, convert from %d to %d\\n\",\n\t\t     lockres->l_name, lockres->l_level, level);\n\n\t\t/* call dlm_lock to upgrade lock now */\n\t\tret = ocfs2_dlm_lock(osb->cconn,\n\t\t\t\t     level,\n\t\t\t\t     &lockres->l_lksb,\n\t\t\t\t     lkm_flags,\n\t\t\t\t     lockres->l_name,\n\t\t\t\t     OCFS2_LOCK_ID_MAX_LEN - 1);\n\t\tlockres_clear_pending(lockres, gen, osb);\n\t\tif (ret) {\n\t\t\tif (!(lkm_flags & DLM_LKF_NOQUEUE) ||\n\t\t\t    (ret != -EAGAIN)) {\n\t\t\t\tocfs2_log_dlm_error(\"ocfs2_dlm_lock\",\n\t\t\t\t\t\t    ret, lockres);\n\t\t\t}\n\t\t\tocfs2_recover_from_dlm_error(lockres, 1);\n\t\t\tgoto out;\n\t\t}\n\t\tdlm_locked = 1;\n\n\t\tmlog(0, \"lock %s, successful return from ocfs2_dlm_lock\\n\",\n\t\t     lockres->l_name);\n\n\t\t/* At this point we've gone inside the dlm and need to\n\t\t * complete our work regardless. */\n\t\tcatch_signals = 0;\n\n\t\t/* wait for busy to clear and carry on */\n\t\tgoto again;\n\t}\n\nupdate_holders:\n\t/* Ok, if we get here then we're good to go. */\n\tocfs2_inc_holders(lockres, level);\n\n\tret = 0;\nunlock:\n\tlockres_clear_flags(lockres, OCFS2_LOCK_UPCONVERT_FINISHING);\n\n\tspin_unlock_irqrestore(&lockres->l_lock, flags);\nout:\n\t/*\n\t * This is helping work around a lock inversion between the page lock\n\t * and dlm locks.  One path holds the page lock while calling aops\n\t * which block acquiring dlm locks.  The voting thread holds dlm\n\t * locks while acquiring page locks while down converting data locks.\n\t * This block is helping an aop path notice the inversion and back\n\t * off to unlock its page lock before trying the dlm lock again.\n\t */\n\tif (wait && arg_flags & OCFS2_LOCK_NONBLOCK &&\n\t    mw.mw_mask & (OCFS2_LOCK_BUSY|OCFS2_LOCK_BLOCKED)) {\n\t\twait = 0;\n\t\tspin_lock_irqsave(&lockres->l_lock, flags);\n\t\tif (__lockres_remove_mask_waiter(lockres, &mw)) {\n\t\t\tif (dlm_locked)\n\t\t\t\tlockres_or_flags(lockres,\n\t\t\t\t\tOCFS2_LOCK_NONBLOCK_FINISHED);\n\t\t\tspin_unlock_irqrestore(&lockres->l_lock, flags);\n\t\t\tret = -EAGAIN;\n\t\t} else {\n\t\t\tspin_unlock_irqrestore(&lockres->l_lock, flags);\n\t\t\tgoto again;\n\t\t}\n\t}\n\tif (wait) {\n\t\tret = ocfs2_wait_for_mask(&mw);\n\t\tif (ret == 0)\n\t\t\tgoto again;\n\t\tmlog_errno(ret);\n\t}\n\tocfs2_update_lock_stats(lockres, level, &mw, ret);\n\n#ifdef CONFIG_DEBUG_LOCK_ALLOC\n\tif (!ret && lockres->l_lockdep_map.key != NULL) {\n\t\tif (level == DLM_LOCK_PR)\n\t\t\trwsem_acquire_read(&lockres->l_lockdep_map, l_subclass,\n\t\t\t\t!!(arg_flags & OCFS2_META_LOCK_NOQUEUE),\n\t\t\t\tcaller_ip);\n\t\telse\n\t\t\trwsem_acquire(&lockres->l_lockdep_map, l_subclass,\n\t\t\t\t!!(arg_flags & OCFS2_META_LOCK_NOQUEUE),\n\t\t\t\tcaller_ip);\n\t}\n#endif\n\treturn ret;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"refcounttree.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"stackglue.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dcache.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2_lockingver.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/time.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/kthread.h>",
            "#include <linux/mm.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [
            "#define LOCK_TYPE_USES_LVB\t\t0x2"
          ],
          "globals_used": [
            "static struct ocfs2_super *ocfs2_get_dentry_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_inode_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_file_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_qinfo_osb(struct ocfs2_lock_res *lockres);",
            "static void ocfs2_set_meta_lvb(struct ocfs2_lock_res *lockres);",
            "static void ocfs2_dentry_post_unlock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres);",
            "static void ocfs2_set_qinfo_lvb(struct ocfs2_lock_res *lockres);",
            "static void __ocfs2_cluster_unlock(struct ocfs2_super *osb,\n\t\t\t\t   struct ocfs2_lock_res *lockres,\n\t\t\t\t   int level, unsigned long caller_ip);",
            "static inline void ocfs2_generic_handle_downconvert_action(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_convert_action(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_attach_action(struct ocfs2_lock_res *lockres);",
            "static int ocfs2_generic_handle_bast(struct ocfs2_lock_res *lockres, int level);",
            "static void ocfs2_schedule_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_recover_from_dlm_error(struct ocfs2_lock_res *lockres,\n\t\t\t\t\t\tint convert);",
            "static void ocfs2_downconvert_on_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static void ocfs2_drop_osb_locks(struct ocfs2_super *osb);",
            "static inline int ocfs2_highest_compat_lock_level(int level);",
            "static int ocfs2_prepare_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\t        struct ocfs2_lock_res *lockres);",
            "static int ocfs2_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static void ocfs2_process_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *lockres);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"stackglue.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dcache.h\"\n#include \"alloc.h\"\n#include \"ocfs2_lockingver.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/quotaops.h>\n#include <linux/time.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/pagemap.h>\n#include <linux/kthread.h>\n#include <linux/mm.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\n#define LOCK_TYPE_USES_LVB\t\t0x2\n\nstatic struct ocfs2_super *ocfs2_get_dentry_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_inode_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_file_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_qinfo_osb(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_set_meta_lvb(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_dentry_post_unlock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres);\nstatic void ocfs2_set_qinfo_lvb(struct ocfs2_lock_res *lockres);\nstatic void __ocfs2_cluster_unlock(struct ocfs2_super *osb,\n\t\t\t\t   struct ocfs2_lock_res *lockres,\n\t\t\t\t   int level, unsigned long caller_ip);\nstatic inline void ocfs2_generic_handle_downconvert_action(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_convert_action(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_attach_action(struct ocfs2_lock_res *lockres);\nstatic int ocfs2_generic_handle_bast(struct ocfs2_lock_res *lockres, int level);\nstatic void ocfs2_schedule_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_recover_from_dlm_error(struct ocfs2_lock_res *lockres,\n\t\t\t\t\t\tint convert);\nstatic void ocfs2_downconvert_on_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_drop_osb_locks(struct ocfs2_super *osb);\nstatic inline int ocfs2_highest_compat_lock_level(int level);\nstatic int ocfs2_prepare_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\t        struct ocfs2_lock_res *lockres);\nstatic int ocfs2_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_process_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *lockres);\n\nstatic int __ocfs2_cluster_lock(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres,\n\t\t\t\tint level,\n\t\t\t\tu32 lkm_flags,\n\t\t\t\tint arg_flags,\n\t\t\t\tint l_subclass,\n\t\t\t\tunsigned long caller_ip)\n{\n\tstruct ocfs2_mask_waiter mw;\n\tint wait, catch_signals = !(osb->s_mount_opt & OCFS2_MOUNT_NOINTR);\n\tint ret = 0; /* gcc doesn't realize wait = 1 guarantees ret is set */\n\tunsigned long flags;\n\tunsigned int gen;\n\tint noqueue_attempted = 0;\n\tint dlm_locked = 0;\n\n\tocfs2_init_mask_waiter(&mw);\n\n\tif (lockres->l_ops->flags & LOCK_TYPE_USES_LVB)\n\t\tlkm_flags |= DLM_LKF_VALBLK;\n\nagain:\n\twait = 0;\n\n\tspin_lock_irqsave(&lockres->l_lock, flags);\n\n\tif (catch_signals && signal_pending(current)) {\n\t\tret = -ERESTARTSYS;\n\t\tgoto unlock;\n\t}\n\n\tmlog_bug_on_msg(lockres->l_flags & OCFS2_LOCK_FREEING,\n\t\t\t\"Cluster lock called on freeing lockres %s! flags \"\n\t\t\t\"0x%lx\\n\", lockres->l_name, lockres->l_flags);\n\n\t/* We only compare against the currently granted level\n\t * here. If the lock is blocked waiting on a downconvert,\n\t * we'll get caught below. */\n\tif (lockres->l_flags & OCFS2_LOCK_BUSY &&\n\t    level > lockres->l_level) {\n\t\t/* is someone sitting in dlm_lock? If so, wait on\n\t\t * them. */\n\t\tlockres_add_mask_waiter(lockres, &mw, OCFS2_LOCK_BUSY, 0);\n\t\twait = 1;\n\t\tgoto unlock;\n\t}\n\n\tif (lockres->l_flags & OCFS2_LOCK_UPCONVERT_FINISHING) {\n\t\t/*\n\t\t * We've upconverted. If the lock now has a level we can\n\t\t * work with, we take it. If, however, the lock is not at the\n\t\t * required level, we go thru the full cycle. One way this could\n\t\t * happen is if a process requesting an upconvert to PR is\n\t\t * closely followed by another requesting upconvert to an EX.\n\t\t * If the process requesting EX lands here, we want it to\n\t\t * continue attempting to upconvert and let the process\n\t\t * requesting PR take the lock.\n\t\t * If multiple processes request upconvert to PR, the first one\n\t\t * here will take the lock. The others will have to go thru the\n\t\t * OCFS2_LOCK_BLOCKED check to ensure that there is no pending\n\t\t * downconvert request.\n\t\t */\n\t\tif (level <= lockres->l_level)\n\t\t\tgoto update_holders;\n\t}\n\n\tif (lockres->l_flags & OCFS2_LOCK_BLOCKED &&\n\t    !ocfs2_may_continue_on_blocked_lock(lockres, level)) {\n\t\t/* is the lock is currently blocked on behalf of\n\t\t * another node */\n\t\tlockres_add_mask_waiter(lockres, &mw, OCFS2_LOCK_BLOCKED, 0);\n\t\twait = 1;\n\t\tgoto unlock;\n\t}\n\n\tif (level > lockres->l_level) {\n\t\tif (noqueue_attempted > 0) {\n\t\t\tret = -EAGAIN;\n\t\t\tgoto unlock;\n\t\t}\n\t\tif (lkm_flags & DLM_LKF_NOQUEUE)\n\t\t\tnoqueue_attempted = 1;\n\n\t\tif (lockres->l_action != OCFS2_AST_INVALID)\n\t\t\tmlog(ML_ERROR, \"lockres %s has action %u pending\\n\",\n\t\t\t     lockres->l_name, lockres->l_action);\n\n\t\tif (!(lockres->l_flags & OCFS2_LOCK_ATTACHED)) {\n\t\t\tlockres->l_action = OCFS2_AST_ATTACH;\n\t\t\tlkm_flags &= ~DLM_LKF_CONVERT;\n\t\t} else {\n\t\t\tlockres->l_action = OCFS2_AST_CONVERT;\n\t\t\tlkm_flags |= DLM_LKF_CONVERT;\n\t\t}\n\n\t\tlockres->l_requested = level;\n\t\tlockres_or_flags(lockres, OCFS2_LOCK_BUSY);\n\t\tgen = lockres_set_pending(lockres);\n\t\tspin_unlock_irqrestore(&lockres->l_lock, flags);\n\n\t\tBUG_ON(level == DLM_LOCK_IV);\n\t\tBUG_ON(level == DLM_LOCK_NL);\n\n\t\tmlog(ML_BASTS, \"lockres %s, convert from %d to %d\\n\",\n\t\t     lockres->l_name, lockres->l_level, level);\n\n\t\t/* call dlm_lock to upgrade lock now */\n\t\tret = ocfs2_dlm_lock(osb->cconn,\n\t\t\t\t     level,\n\t\t\t\t     &lockres->l_lksb,\n\t\t\t\t     lkm_flags,\n\t\t\t\t     lockres->l_name,\n\t\t\t\t     OCFS2_LOCK_ID_MAX_LEN - 1);\n\t\tlockres_clear_pending(lockres, gen, osb);\n\t\tif (ret) {\n\t\t\tif (!(lkm_flags & DLM_LKF_NOQUEUE) ||\n\t\t\t    (ret != -EAGAIN)) {\n\t\t\t\tocfs2_log_dlm_error(\"ocfs2_dlm_lock\",\n\t\t\t\t\t\t    ret, lockres);\n\t\t\t}\n\t\t\tocfs2_recover_from_dlm_error(lockres, 1);\n\t\t\tgoto out;\n\t\t}\n\t\tdlm_locked = 1;\n\n\t\tmlog(0, \"lock %s, successful return from ocfs2_dlm_lock\\n\",\n\t\t     lockres->l_name);\n\n\t\t/* At this point we've gone inside the dlm and need to\n\t\t * complete our work regardless. */\n\t\tcatch_signals = 0;\n\n\t\t/* wait for busy to clear and carry on */\n\t\tgoto again;\n\t}\n\nupdate_holders:\n\t/* Ok, if we get here then we're good to go. */\n\tocfs2_inc_holders(lockres, level);\n\n\tret = 0;\nunlock:\n\tlockres_clear_flags(lockres, OCFS2_LOCK_UPCONVERT_FINISHING);\n\n\tspin_unlock_irqrestore(&lockres->l_lock, flags);\nout:\n\t/*\n\t * This is helping work around a lock inversion between the page lock\n\t * and dlm locks.  One path holds the page lock while calling aops\n\t * which block acquiring dlm locks.  The voting thread holds dlm\n\t * locks while acquiring page locks while down converting data locks.\n\t * This block is helping an aop path notice the inversion and back\n\t * off to unlock its page lock before trying the dlm lock again.\n\t */\n\tif (wait && arg_flags & OCFS2_LOCK_NONBLOCK &&\n\t    mw.mw_mask & (OCFS2_LOCK_BUSY|OCFS2_LOCK_BLOCKED)) {\n\t\twait = 0;\n\t\tspin_lock_irqsave(&lockres->l_lock, flags);\n\t\tif (__lockres_remove_mask_waiter(lockres, &mw)) {\n\t\t\tif (dlm_locked)\n\t\t\t\tlockres_or_flags(lockres,\n\t\t\t\t\tOCFS2_LOCK_NONBLOCK_FINISHED);\n\t\t\tspin_unlock_irqrestore(&lockres->l_lock, flags);\n\t\t\tret = -EAGAIN;\n\t\t} else {\n\t\t\tspin_unlock_irqrestore(&lockres->l_lock, flags);\n\t\t\tgoto again;\n\t\t}\n\t}\n\tif (wait) {\n\t\tret = ocfs2_wait_for_mask(&mw);\n\t\tif (ret == 0)\n\t\t\tgoto again;\n\t\tmlog_errno(ret);\n\t}\n\tocfs2_update_lock_stats(lockres, level, &mw, ret);\n\n#ifdef CONFIG_DEBUG_LOCK_ALLOC\n\tif (!ret && lockres->l_lockdep_map.key != NULL) {\n\t\tif (level == DLM_LOCK_PR)\n\t\t\trwsem_acquire_read(&lockres->l_lockdep_map, l_subclass,\n\t\t\t\t!!(arg_flags & OCFS2_META_LOCK_NOQUEUE),\n\t\t\t\tcaller_ip);\n\t\telse\n\t\t\trwsem_acquire(&lockres->l_lockdep_map, l_subclass,\n\t\t\t\t!!(arg_flags & OCFS2_META_LOCK_NOQUEUE),\n\t\t\t\tcaller_ip);\n\t}\n#endif\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "OCFS2_I",
          "args": [
            "inode"
          ],
          "line": 2341
        },
        "resolved": true,
        "details": {
          "function_name": "OCFS2_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/inode.h",
          "lines": "118-121",
          "snippet": "static inline struct ocfs2_inode_info *OCFS2_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ocfs2_inode_info, vfs_inode);\n}",
          "includes": [
            "#include \"extent_map.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extent_map.h\"\n\nstatic inline struct ocfs2_inode_info *OCFS2_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ocfs2_inode_info, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_mount_local",
          "args": [
            "osb"
          ],
          "line": 2335
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_mount_local",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "668-671",
          "snippet": "static inline int ocfs2_mount_local(struct ocfs2_super *osb)\n{\n\treturn (osb->s_feature_incompat & OCFS2_FEATURE_INCOMPAT_LOCAL_MOUNT);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\nstatic inline int ocfs2_mount_local(struct ocfs2_super *osb)\n{\n\treturn (osb->s_feature_incompat & OCFS2_FEATURE_INCOMPAT_LOCAL_MOUNT);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_is_hard_readonly",
          "args": [
            "osb"
          ],
          "line": 2329
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_is_hard_readonly",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "615-624",
          "snippet": "static inline int ocfs2_is_hard_readonly(struct ocfs2_super *osb)\n{\n\tint ret;\n\n\tspin_lock(&osb->osb_lock);\n\tret = osb->osb_flags & OCFS2_OSB_HARD_RO;\n\tspin_unlock(&osb->osb_lock);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [
            "#define OCFS2_OSB_HARD_RO\t0x0002"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\n#define OCFS2_OSB_HARD_RO\t0x0002\n\nstatic inline int ocfs2_is_hard_readonly(struct ocfs2_super *osb)\n{\n\tint ret;\n\n\tspin_lock(&osb->osb_lock);\n\tret = osb->osb_flags & OCFS2_OSB_HARD_RO;\n\tspin_unlock(&osb->osb_lock);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog",
          "args": [
            "0",
            "\"inode %llu, take %s META lock\\n\"",
            "(unsigned long long)OCFS2_I(inode)->ip_blkno",
            "ex ? \"EXMODE\" : \"PRMODE\""
          ],
          "line": 2321
        },
        "resolved": true,
        "details": {
          "function_name": "mlog_store",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/cluster/masklog.c",
          "lines": "115-121",
          "snippet": "static ssize_t mlog_store(struct kobject *obj, struct attribute *attr,\n\t\t\t  const char *buf, size_t count)\n{\n\tstruct mlog_attribute *mlog_attr = to_mlog_attr(attr);\n\n\treturn mlog_mask_store(mlog_attr->mask, buf, count);\n}",
          "includes": [
            "#include \"masklog.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/string.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"masklog.h\"\n#include <asm/uaccess.h>\n#include <linux/string.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n\nstatic ssize_t mlog_store(struct kobject *obj, struct attribute *attr,\n\t\t\t  const char *buf, size_t count)\n{\n\tstruct mlog_attribute *mlog_attr = to_mlog_attr(attr);\n\n\treturn mlog_mask_store(mlog_attr->mask, buf, count);\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!inode"
          ],
          "line": 2319
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "OCFS2_SB",
          "args": [
            "inode->i_sb"
          ],
          "line": 2316
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"stackglue.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dcache.h\"\n#include \"alloc.h\"\n#include \"ocfs2_lockingver.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/quotaops.h>\n#include <linux/time.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/pagemap.h>\n#include <linux/kthread.h>\n#include <linux/mm.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic struct ocfs2_super *ocfs2_get_dentry_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_inode_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_file_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_qinfo_osb(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_set_meta_lvb(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_dentry_post_unlock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres);\nstatic void ocfs2_set_qinfo_lvb(struct ocfs2_lock_res *lockres);\nstatic int ocfs2_lock_create(struct ocfs2_super *osb,\n\t\t\t     struct ocfs2_lock_res *lockres,\n\t\t\t     int level,\n\t\t\t     u32 dlm_flags);\nstatic inline void ocfs2_generic_handle_downconvert_action(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_convert_action(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_attach_action(struct ocfs2_lock_res *lockres);\nstatic int ocfs2_generic_handle_bast(struct ocfs2_lock_res *lockres, int level);\nstatic void ocfs2_schedule_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_downconvert_on_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic int ocfs2_inode_lock_update(struct inode *inode,\n\t\t\t\t  struct buffer_head **bh);\nstatic void ocfs2_drop_osb_locks(struct ocfs2_super *osb);\nstatic inline int ocfs2_highest_compat_lock_level(int level);\nstatic int ocfs2_prepare_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\t        struct ocfs2_lock_res *lockres);\nstatic int ocfs2_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_process_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *lockres);\n\nint ocfs2_inode_lock_full_nested(struct inode *inode,\n\t\t\t\t struct buffer_head **ret_bh,\n\t\t\t\t int ex,\n\t\t\t\t int arg_flags,\n\t\t\t\t int subclass)\n{\n\tint status, level, acquired;\n\tu32 dlm_flags;\n\tstruct ocfs2_lock_res *lockres = NULL;\n\tstruct ocfs2_super *osb = OCFS2_SB(inode->i_sb);\n\tstruct buffer_head *local_bh = NULL;\n\n\tBUG_ON(!inode);\n\n\tmlog(0, \"inode %llu, take %s META lock\\n\",\n\t     (unsigned long long)OCFS2_I(inode)->ip_blkno,\n\t     ex ? \"EXMODE\" : \"PRMODE\");\n\n\tstatus = 0;\n\tacquired = 0;\n\t/* We'll allow faking a readonly metadata lock for\n\t * rodevices. */\n\tif (ocfs2_is_hard_readonly(osb)) {\n\t\tif (ex)\n\t\t\tstatus = -EROFS;\n\t\tgoto getbh;\n\t}\n\n\tif (ocfs2_mount_local(osb))\n\t\tgoto local;\n\n\tif (!(arg_flags & OCFS2_META_LOCK_RECOVERY))\n\t\tocfs2_wait_for_recovery(osb);\n\n\tlockres = &OCFS2_I(inode)->ip_inode_lockres;\n\tlevel = ex ? DLM_LOCK_EX : DLM_LOCK_PR;\n\tdlm_flags = 0;\n\tif (arg_flags & OCFS2_META_LOCK_NOQUEUE)\n\t\tdlm_flags |= DLM_LKF_NOQUEUE;\n\n\tstatus = __ocfs2_cluster_lock(osb, lockres, level, dlm_flags,\n\t\t\t\t      arg_flags, subclass, _RET_IP_);\n\tif (status < 0) {\n\t\tif (status != -EAGAIN)\n\t\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\t/* Notify the error cleanup path to drop the cluster lock. */\n\tacquired = 1;\n\n\t/* We wait twice because a node may have died while we were in\n\t * the lower dlm layers. The second time though, we've\n\t * committed to owning this lock so we don't allow signals to\n\t * abort the operation. */\n\tif (!(arg_flags & OCFS2_META_LOCK_RECOVERY))\n\t\tocfs2_wait_for_recovery(osb);\n\nlocal:\n\t/*\n\t * We only see this flag if we're being called from\n\t * ocfs2_read_locked_inode(). It means we're locking an inode\n\t * which hasn't been populated yet, so clear the refresh flag\n\t * and let the caller handle it.\n\t */\n\tif (inode->i_state & I_NEW) {\n\t\tstatus = 0;\n\t\tif (lockres)\n\t\t\tocfs2_complete_lock_res_refresh(lockres, 0);\n\t\tgoto bail;\n\t}\n\n\t/* This is fun. The caller may want a bh back, or it may\n\t * not. ocfs2_inode_lock_update definitely wants one in, but\n\t * may or may not read one, depending on what's in the\n\t * LVB. The result of all of this is that we've *only* gone to\n\t * disk if we have to, so the complexity is worthwhile. */\n\tstatus = ocfs2_inode_lock_update(inode, &local_bh);\n\tif (status < 0) {\n\t\tif (status != -ENOENT)\n\t\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\ngetbh:\n\tif (ret_bh) {\n\t\tstatus = ocfs2_assign_bh(inode, ret_bh, local_bh);\n\t\tif (status < 0) {\n\t\t\tmlog_errno(status);\n\t\t\tgoto bail;\n\t\t}\n\t}\n\nbail:\n\tif (status < 0) {\n\t\tif (ret_bh && (*ret_bh)) {\n\t\t\tbrelse(*ret_bh);\n\t\t\t*ret_bh = NULL;\n\t\t}\n\t\tif (acquired)\n\t\t\tocfs2_inode_unlock(inode, ex);\n\t}\n\n\tif (local_bh)\n\t\tbrelse(local_bh);\n\n\treturn status;\n}"
  },
  {
    "function_name": "ocfs2_assign_bh",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlmglue.c",
    "lines": "2281-2301",
    "snippet": "static int ocfs2_assign_bh(struct inode *inode,\n\t\t\t   struct buffer_head **ret_bh,\n\t\t\t   struct buffer_head *passed_bh)\n{\n\tint status;\n\n\tif (passed_bh) {\n\t\t/* Ok, the update went to disk for us, use the\n\t\t * returned bh. */\n\t\t*ret_bh = passed_bh;\n\t\tget_bh(*ret_bh);\n\n\t\treturn 0;\n\t}\n\n\tstatus = ocfs2_read_inode_block(inode, ret_bh);\n\tif (status < 0)\n\t\tmlog_errno(status);\n\n\treturn status;\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"refcounttree.h\"",
      "#include \"quota.h\"",
      "#include \"uptodate.h\"",
      "#include \"super.h\"",
      "#include \"slot_map.h\"",
      "#include \"stackglue.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"heartbeat.h\"",
      "#include \"file.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"dcache.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2_lockingver.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/time.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/kthread.h>",
      "#include <linux/mm.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ocfs2_inode_lock_update(struct inode *inode,\n\t\t\t\t  struct buffer_head **bh);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "status"
          ],
          "line": 2298
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_read_inode_block",
          "args": [
            "inode",
            "ret_bh"
          ],
          "line": 2296
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_read_inode_block",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/inode.c",
          "lines": "1404-1407",
          "snippet": "int ocfs2_read_inode_block(struct inode *inode, struct buffer_head **bh)\n{\n\treturn ocfs2_read_inode_block_full(inode, bh, 0);\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"symlink.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"dir.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"symlink.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"dir.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <asm/byteorder.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nint ocfs2_read_inode_block(struct inode *inode, struct buffer_head **bh)\n{\n\treturn ocfs2_read_inode_block_full(inode, bh, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_bh",
          "args": [
            "*ret_bh"
          ],
          "line": 2291
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"stackglue.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dcache.h\"\n#include \"alloc.h\"\n#include \"ocfs2_lockingver.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/quotaops.h>\n#include <linux/time.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/pagemap.h>\n#include <linux/kthread.h>\n#include <linux/mm.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic int ocfs2_inode_lock_update(struct inode *inode,\n\t\t\t\t  struct buffer_head **bh);\n\nstatic int ocfs2_assign_bh(struct inode *inode,\n\t\t\t   struct buffer_head **ret_bh,\n\t\t\t   struct buffer_head *passed_bh)\n{\n\tint status;\n\n\tif (passed_bh) {\n\t\t/* Ok, the update went to disk for us, use the\n\t\t * returned bh. */\n\t\t*ret_bh = passed_bh;\n\t\tget_bh(*ret_bh);\n\n\t\treturn 0;\n\t}\n\n\tstatus = ocfs2_read_inode_block(inode, ret_bh);\n\tif (status < 0)\n\t\tmlog_errno(status);\n\n\treturn status;\n}"
  },
  {
    "function_name": "ocfs2_inode_lock_update",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlmglue.c",
    "lines": "2201-2279",
    "snippet": "static int ocfs2_inode_lock_update(struct inode *inode,\n\t\t\t\t  struct buffer_head **bh)\n{\n\tint status = 0;\n\tstruct ocfs2_inode_info *oi = OCFS2_I(inode);\n\tstruct ocfs2_lock_res *lockres = &oi->ip_inode_lockres;\n\tstruct ocfs2_dinode *fe;\n\tstruct ocfs2_super *osb = OCFS2_SB(inode->i_sb);\n\n\tif (ocfs2_mount_local(osb))\n\t\tgoto bail;\n\n\tspin_lock(&oi->ip_lock);\n\tif (oi->ip_flags & OCFS2_INODE_DELETED) {\n\t\tmlog(0, \"Orphaned inode %llu was deleted while we \"\n\t\t     \"were waiting on a lock. ip_flags = 0x%x\\n\",\n\t\t     (unsigned long long)oi->ip_blkno, oi->ip_flags);\n\t\tspin_unlock(&oi->ip_lock);\n\t\tstatus = -ENOENT;\n\t\tgoto bail;\n\t}\n\tspin_unlock(&oi->ip_lock);\n\n\tif (!ocfs2_should_refresh_lock_res(lockres))\n\t\tgoto bail;\n\n\t/* This will discard any caching information we might have had\n\t * for the inode metadata. */\n\tocfs2_metadata_cache_purge(INODE_CACHE(inode));\n\n\tocfs2_extent_map_trunc(inode, 0);\n\n\tif (ocfs2_meta_lvb_is_trustable(inode, lockres)) {\n\t\tmlog(0, \"Trusting LVB on inode %llu\\n\",\n\t\t     (unsigned long long)oi->ip_blkno);\n\t\tocfs2_refresh_inode_from_lvb(inode);\n\t} else {\n\t\t/* Boo, we have to go to disk. */\n\t\t/* read bh, cast, ocfs2_refresh_inode */\n\t\tstatus = ocfs2_read_inode_block(inode, bh);\n\t\tif (status < 0) {\n\t\t\tmlog_errno(status);\n\t\t\tgoto bail_refresh;\n\t\t}\n\t\tfe = (struct ocfs2_dinode *) (*bh)->b_data;\n\n\t\t/* This is a good chance to make sure we're not\n\t\t * locking an invalid object.  ocfs2_read_inode_block()\n\t\t * already checked that the inode block is sane.\n\t\t *\n\t\t * We bug on a stale inode here because we checked\n\t\t * above whether it was wiped from disk. The wiping\n\t\t * node provides a guarantee that we receive that\n\t\t * message and can mark the inode before dropping any\n\t\t * locks associated with it. */\n\t\tmlog_bug_on_msg(inode->i_generation !=\n\t\t\t\tle32_to_cpu(fe->i_generation),\n\t\t\t\t\"Invalid dinode %llu disk generation: %u \"\n\t\t\t\t\"inode->i_generation: %u\\n\",\n\t\t\t\t(unsigned long long)oi->ip_blkno,\n\t\t\t\tle32_to_cpu(fe->i_generation),\n\t\t\t\tinode->i_generation);\n\t\tmlog_bug_on_msg(le64_to_cpu(fe->i_dtime) ||\n\t\t\t\t!(fe->i_flags & cpu_to_le32(OCFS2_VALID_FL)),\n\t\t\t\t\"Stale dinode %llu dtime: %llu flags: 0x%x\\n\",\n\t\t\t\t(unsigned long long)oi->ip_blkno,\n\t\t\t\t(unsigned long long)le64_to_cpu(fe->i_dtime),\n\t\t\t\tle32_to_cpu(fe->i_flags));\n\n\t\tocfs2_refresh_inode(inode, fe);\n\t\tocfs2_track_lock_refresh(lockres);\n\t}\n\n\tstatus = 0;\nbail_refresh:\n\tocfs2_complete_lock_res_refresh(lockres, status);\nbail:\n\treturn status;\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"refcounttree.h\"",
      "#include \"quota.h\"",
      "#include \"uptodate.h\"",
      "#include \"super.h\"",
      "#include \"slot_map.h\"",
      "#include \"stackglue.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"heartbeat.h\"",
      "#include \"file.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"dcache.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2_lockingver.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/time.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/kthread.h>",
      "#include <linux/mm.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct ocfs2_super *ocfs2_get_dentry_osb(struct ocfs2_lock_res *lockres);",
      "static struct ocfs2_super *ocfs2_get_inode_osb(struct ocfs2_lock_res *lockres);",
      "static struct ocfs2_super *ocfs2_get_file_osb(struct ocfs2_lock_res *lockres);",
      "static struct ocfs2_super *ocfs2_get_qinfo_osb(struct ocfs2_lock_res *lockres);",
      "static void ocfs2_set_meta_lvb(struct ocfs2_lock_res *lockres);",
      "static void ocfs2_dentry_post_unlock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres);",
      "static void ocfs2_set_qinfo_lvb(struct ocfs2_lock_res *lockres);",
      "static inline void ocfs2_generic_handle_downconvert_action(struct ocfs2_lock_res *lockres);",
      "static inline void ocfs2_generic_handle_convert_action(struct ocfs2_lock_res *lockres);",
      "static inline void ocfs2_generic_handle_attach_action(struct ocfs2_lock_res *lockres);",
      "static void ocfs2_schedule_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);",
      "static void ocfs2_downconvert_on_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);",
      "static int ocfs2_inode_lock_update(struct inode *inode,\n\t\t\t\t  struct buffer_head **bh);",
      "static void ocfs2_drop_osb_locks(struct ocfs2_super *osb);",
      "static int ocfs2_downconvert_lock(struct ocfs2_super *osb,\n\t\t\t\t  struct ocfs2_lock_res *lockres,\n\t\t\t\t  int new_level,\n\t\t\t\t  int lvb,\n\t\t\t\t  unsigned int generation);",
      "static int ocfs2_prepare_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\t        struct ocfs2_lock_res *lockres);",
      "static int ocfs2_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres);",
      "static void ocfs2_process_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *lockres);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ocfs2_complete_lock_res_refresh",
          "args": [
            "lockres",
            "status"
          ],
          "line": 2276
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_complete_lock_res_refresh",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlmglue.c",
          "lines": "2186-2198",
          "snippet": "static inline void ocfs2_complete_lock_res_refresh(struct ocfs2_lock_res *lockres,\n\t\t\t\t\t\t   int status)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&lockres->l_lock, flags);\n\tlockres_clear_flags(lockres, OCFS2_LOCK_REFRESHING);\n\tif (!status)\n\t\tlockres_clear_flags(lockres, OCFS2_LOCK_NEEDS_REFRESH);\n\tspin_unlock_irqrestore(&lockres->l_lock, flags);\n\n\twake_up(&lockres->l_event);\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"refcounttree.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"stackglue.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dcache.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2_lockingver.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/time.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/kthread.h>",
            "#include <linux/mm.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct ocfs2_super *ocfs2_get_dentry_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_inode_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_file_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_qinfo_osb(struct ocfs2_lock_res *lockres);",
            "static void ocfs2_set_meta_lvb(struct ocfs2_lock_res *lockres);",
            "static void ocfs2_dentry_post_unlock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres);",
            "static void ocfs2_set_qinfo_lvb(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_downconvert_action(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_convert_action(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_attach_action(struct ocfs2_lock_res *lockres);",
            "static void ocfs2_schedule_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static void ocfs2_downconvert_on_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static int ocfs2_prepare_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\t        struct ocfs2_lock_res *lockres);",
            "static int ocfs2_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static void ocfs2_process_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *lockres);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"stackglue.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dcache.h\"\n#include \"alloc.h\"\n#include \"ocfs2_lockingver.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/quotaops.h>\n#include <linux/time.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/pagemap.h>\n#include <linux/kthread.h>\n#include <linux/mm.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic struct ocfs2_super *ocfs2_get_dentry_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_inode_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_file_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_qinfo_osb(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_set_meta_lvb(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_dentry_post_unlock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres);\nstatic void ocfs2_set_qinfo_lvb(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_downconvert_action(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_convert_action(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_attach_action(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_schedule_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_downconvert_on_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic int ocfs2_prepare_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\t        struct ocfs2_lock_res *lockres);\nstatic int ocfs2_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_process_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *lockres);\n\nstatic inline void ocfs2_complete_lock_res_refresh(struct ocfs2_lock_res *lockres,\n\t\t\t\t\t\t   int status)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&lockres->l_lock, flags);\n\tlockres_clear_flags(lockres, OCFS2_LOCK_REFRESHING);\n\tif (!status)\n\t\tlockres_clear_flags(lockres, OCFS2_LOCK_NEEDS_REFRESH);\n\tspin_unlock_irqrestore(&lockres->l_lock, flags);\n\n\twake_up(&lockres->l_event);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_track_lock_refresh",
          "args": [
            "lockres"
          ],
          "line": 2271
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_track_lock_refresh",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlmglue.c",
          "lines": "488-490",
          "snippet": "static inline void ocfs2_track_lock_refresh(struct ocfs2_lock_res *lockres)\n{\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"refcounttree.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"stackglue.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dcache.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2_lockingver.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/time.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/kthread.h>",
            "#include <linux/mm.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct ocfs2_super *ocfs2_get_dentry_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_inode_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_file_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_qinfo_osb(struct ocfs2_lock_res *lockres);",
            "static void ocfs2_set_meta_lvb(struct ocfs2_lock_res *lockres);",
            "static void ocfs2_dentry_post_unlock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres);",
            "static void ocfs2_set_qinfo_lvb(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_downconvert_action(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_convert_action(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_attach_action(struct ocfs2_lock_res *lockres);",
            "static void ocfs2_schedule_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static void ocfs2_downconvert_on_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static int ocfs2_prepare_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\t        struct ocfs2_lock_res *lockres);",
            "static int ocfs2_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static void ocfs2_process_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *lockres);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"stackglue.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dcache.h\"\n#include \"alloc.h\"\n#include \"ocfs2_lockingver.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/quotaops.h>\n#include <linux/time.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/pagemap.h>\n#include <linux/kthread.h>\n#include <linux/mm.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic struct ocfs2_super *ocfs2_get_dentry_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_inode_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_file_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_qinfo_osb(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_set_meta_lvb(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_dentry_post_unlock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres);\nstatic void ocfs2_set_qinfo_lvb(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_downconvert_action(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_convert_action(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_attach_action(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_schedule_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_downconvert_on_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic int ocfs2_prepare_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\t        struct ocfs2_lock_res *lockres);\nstatic int ocfs2_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_process_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *lockres);\n\nstatic inline void ocfs2_track_lock_refresh(struct ocfs2_lock_res *lockres)\n{\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_refresh_inode",
          "args": [
            "inode",
            "fe"
          ],
          "line": 2270
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_refresh_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/inode.c",
          "lines": "1296-1322",
          "snippet": "void ocfs2_refresh_inode(struct inode *inode,\n\t\t\t struct ocfs2_dinode *fe)\n{\n\tspin_lock(&OCFS2_I(inode)->ip_lock);\n\n\tOCFS2_I(inode)->ip_clusters = le32_to_cpu(fe->i_clusters);\n\tOCFS2_I(inode)->ip_attr = le32_to_cpu(fe->i_attr);\n\tOCFS2_I(inode)->ip_dyn_features = le16_to_cpu(fe->i_dyn_features);\n\tocfs2_set_inode_flags(inode);\n\ti_size_write(inode, le64_to_cpu(fe->i_size));\n\tset_nlink(inode, ocfs2_read_links_count(fe));\n\ti_uid_write(inode, le32_to_cpu(fe->i_uid));\n\ti_gid_write(inode, le32_to_cpu(fe->i_gid));\n\tinode->i_mode = le16_to_cpu(fe->i_mode);\n\tif (S_ISLNK(inode->i_mode) && le32_to_cpu(fe->i_clusters) == 0)\n\t\tinode->i_blocks = 0;\n\telse\n\t\tinode->i_blocks = ocfs2_inode_sector_count(inode);\n\tinode->i_atime.tv_sec = le64_to_cpu(fe->i_atime);\n\tinode->i_atime.tv_nsec = le32_to_cpu(fe->i_atime_nsec);\n\tinode->i_mtime.tv_sec = le64_to_cpu(fe->i_mtime);\n\tinode->i_mtime.tv_nsec = le32_to_cpu(fe->i_mtime_nsec);\n\tinode->i_ctime.tv_sec = le64_to_cpu(fe->i_ctime);\n\tinode->i_ctime.tv_nsec = le32_to_cpu(fe->i_ctime_nsec);\n\n\tspin_unlock(&OCFS2_I(inode)->ip_lock);\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"symlink.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"dir.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"symlink.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"dir.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <asm/byteorder.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nvoid ocfs2_refresh_inode(struct inode *inode,\n\t\t\t struct ocfs2_dinode *fe)\n{\n\tspin_lock(&OCFS2_I(inode)->ip_lock);\n\n\tOCFS2_I(inode)->ip_clusters = le32_to_cpu(fe->i_clusters);\n\tOCFS2_I(inode)->ip_attr = le32_to_cpu(fe->i_attr);\n\tOCFS2_I(inode)->ip_dyn_features = le16_to_cpu(fe->i_dyn_features);\n\tocfs2_set_inode_flags(inode);\n\ti_size_write(inode, le64_to_cpu(fe->i_size));\n\tset_nlink(inode, ocfs2_read_links_count(fe));\n\ti_uid_write(inode, le32_to_cpu(fe->i_uid));\n\ti_gid_write(inode, le32_to_cpu(fe->i_gid));\n\tinode->i_mode = le16_to_cpu(fe->i_mode);\n\tif (S_ISLNK(inode->i_mode) && le32_to_cpu(fe->i_clusters) == 0)\n\t\tinode->i_blocks = 0;\n\telse\n\t\tinode->i_blocks = ocfs2_inode_sector_count(inode);\n\tinode->i_atime.tv_sec = le64_to_cpu(fe->i_atime);\n\tinode->i_atime.tv_nsec = le32_to_cpu(fe->i_atime_nsec);\n\tinode->i_mtime.tv_sec = le64_to_cpu(fe->i_mtime);\n\tinode->i_mtime.tv_nsec = le32_to_cpu(fe->i_mtime_nsec);\n\tinode->i_ctime.tv_sec = le64_to_cpu(fe->i_ctime);\n\tinode->i_ctime.tv_nsec = le32_to_cpu(fe->i_ctime_nsec);\n\n\tspin_unlock(&OCFS2_I(inode)->ip_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_bug_on_msg",
          "args": [
            "le64_to_cpu(fe->i_dtime) ||\n\t\t\t\t!(fe->i_flags & cpu_to_le32(OCFS2_VALID_FL))",
            "\"Stale dinode %llu dtime: %llu flags: 0x%x\\n\"",
            "(unsigned long long)oi->ip_blkno",
            "(unsigned long long)le64_to_cpu(fe->i_dtime)",
            "le32_to_cpu(fe->i_flags)"
          ],
          "line": 2263
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "fe->i_flags"
          ],
          "line": 2268
        },
        "resolved": true,
        "details": {
          "function_name": "sle32_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "53-56",
          "snippet": "static inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "le64_to_cpu",
          "args": [
            "fe->i_dtime"
          ],
          "line": 2267
        },
        "resolved": true,
        "details": {
          "function_name": "sle64_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "58-61",
          "snippet": "static inline s64 sle64_to_cpup(sle64 *x)\n{\n\treturn le64_to_cpu(*(__force le64*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s64 sle64_to_cpup(sle64 *x)\n{\n\treturn le64_to_cpu(*(__force le64*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "OCFS2_VALID_FL"
          ],
          "line": 2264
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mlog_bug_on_msg",
          "args": [
            "inode->i_generation !=\n\t\t\t\tle32_to_cpu(fe->i_generation)",
            "\"Invalid dinode %llu disk generation: %u \"\n\t\t\t\t\"inode->i_generation: %u\\n\"",
            "(unsigned long long)oi->ip_blkno",
            "le32_to_cpu(fe->i_generation)",
            "inode->i_generation"
          ],
          "line": 2256
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "status"
          ],
          "line": 2242
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_read_inode_block",
          "args": [
            "inode",
            "bh"
          ],
          "line": 2240
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_read_inode_block",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/inode.c",
          "lines": "1404-1407",
          "snippet": "int ocfs2_read_inode_block(struct inode *inode, struct buffer_head **bh)\n{\n\treturn ocfs2_read_inode_block_full(inode, bh, 0);\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"symlink.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"dir.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"symlink.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"dir.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <asm/byteorder.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nint ocfs2_read_inode_block(struct inode *inode, struct buffer_head **bh)\n{\n\treturn ocfs2_read_inode_block_full(inode, bh, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_refresh_inode_from_lvb",
          "args": [
            "inode"
          ],
          "line": 2236
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_refresh_inode_from_lvb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlmglue.c",
          "lines": "2098-2134",
          "snippet": "static void ocfs2_refresh_inode_from_lvb(struct inode *inode)\n{\n\tstruct ocfs2_inode_info *oi = OCFS2_I(inode);\n\tstruct ocfs2_lock_res *lockres = &oi->ip_inode_lockres;\n\tstruct ocfs2_meta_lvb *lvb;\n\n\tmlog_meta_lvb(0, lockres);\n\n\tlvb = ocfs2_dlm_lvb(&lockres->l_lksb);\n\n\t/* We're safe here without the lockres lock... */\n\tspin_lock(&oi->ip_lock);\n\toi->ip_clusters = be32_to_cpu(lvb->lvb_iclusters);\n\ti_size_write(inode, be64_to_cpu(lvb->lvb_isize));\n\n\toi->ip_attr = be32_to_cpu(lvb->lvb_iattr);\n\toi->ip_dyn_features = be16_to_cpu(lvb->lvb_idynfeatures);\n\tocfs2_set_inode_flags(inode);\n\n\t/* fast-symlinks are a special case */\n\tif (S_ISLNK(inode->i_mode) && !oi->ip_clusters)\n\t\tinode->i_blocks = 0;\n\telse\n\t\tinode->i_blocks = ocfs2_inode_sector_count(inode);\n\n\ti_uid_write(inode, be32_to_cpu(lvb->lvb_iuid));\n\ti_gid_write(inode, be32_to_cpu(lvb->lvb_igid));\n\tinode->i_mode    = be16_to_cpu(lvb->lvb_imode);\n\tset_nlink(inode, be16_to_cpu(lvb->lvb_inlink));\n\tocfs2_unpack_timespec(&inode->i_atime,\n\t\t\t      be64_to_cpu(lvb->lvb_iatime_packed));\n\tocfs2_unpack_timespec(&inode->i_mtime,\n\t\t\t      be64_to_cpu(lvb->lvb_imtime_packed));\n\tocfs2_unpack_timespec(&inode->i_ctime,\n\t\t\t      be64_to_cpu(lvb->lvb_ictime_packed));\n\tspin_unlock(&oi->ip_lock);\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"refcounttree.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"stackglue.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dcache.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2_lockingver.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/time.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/kthread.h>",
            "#include <linux/mm.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct ocfs2_super *ocfs2_get_dentry_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_inode_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_file_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_qinfo_osb(struct ocfs2_lock_res *lockres);",
            "static void ocfs2_set_meta_lvb(struct ocfs2_lock_res *lockres);",
            "static void ocfs2_dentry_post_unlock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres);",
            "static void ocfs2_set_qinfo_lvb(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_downconvert_action(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_convert_action(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_attach_action(struct ocfs2_lock_res *lockres);",
            "static void ocfs2_schedule_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static void ocfs2_downconvert_on_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static int ocfs2_prepare_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\t        struct ocfs2_lock_res *lockres);",
            "static int ocfs2_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static void ocfs2_process_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *lockres);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"stackglue.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dcache.h\"\n#include \"alloc.h\"\n#include \"ocfs2_lockingver.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/quotaops.h>\n#include <linux/time.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/pagemap.h>\n#include <linux/kthread.h>\n#include <linux/mm.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic struct ocfs2_super *ocfs2_get_dentry_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_inode_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_file_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_qinfo_osb(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_set_meta_lvb(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_dentry_post_unlock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres);\nstatic void ocfs2_set_qinfo_lvb(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_downconvert_action(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_convert_action(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_attach_action(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_schedule_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_downconvert_on_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic int ocfs2_prepare_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\t        struct ocfs2_lock_res *lockres);\nstatic int ocfs2_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_process_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *lockres);\n\nstatic void ocfs2_refresh_inode_from_lvb(struct inode *inode)\n{\n\tstruct ocfs2_inode_info *oi = OCFS2_I(inode);\n\tstruct ocfs2_lock_res *lockres = &oi->ip_inode_lockres;\n\tstruct ocfs2_meta_lvb *lvb;\n\n\tmlog_meta_lvb(0, lockres);\n\n\tlvb = ocfs2_dlm_lvb(&lockres->l_lksb);\n\n\t/* We're safe here without the lockres lock... */\n\tspin_lock(&oi->ip_lock);\n\toi->ip_clusters = be32_to_cpu(lvb->lvb_iclusters);\n\ti_size_write(inode, be64_to_cpu(lvb->lvb_isize));\n\n\toi->ip_attr = be32_to_cpu(lvb->lvb_iattr);\n\toi->ip_dyn_features = be16_to_cpu(lvb->lvb_idynfeatures);\n\tocfs2_set_inode_flags(inode);\n\n\t/* fast-symlinks are a special case */\n\tif (S_ISLNK(inode->i_mode) && !oi->ip_clusters)\n\t\tinode->i_blocks = 0;\n\telse\n\t\tinode->i_blocks = ocfs2_inode_sector_count(inode);\n\n\ti_uid_write(inode, be32_to_cpu(lvb->lvb_iuid));\n\ti_gid_write(inode, be32_to_cpu(lvb->lvb_igid));\n\tinode->i_mode    = be16_to_cpu(lvb->lvb_imode);\n\tset_nlink(inode, be16_to_cpu(lvb->lvb_inlink));\n\tocfs2_unpack_timespec(&inode->i_atime,\n\t\t\t      be64_to_cpu(lvb->lvb_iatime_packed));\n\tocfs2_unpack_timespec(&inode->i_mtime,\n\t\t\t      be64_to_cpu(lvb->lvb_imtime_packed));\n\tocfs2_unpack_timespec(&inode->i_ctime,\n\t\t\t      be64_to_cpu(lvb->lvb_ictime_packed));\n\tspin_unlock(&oi->ip_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog",
          "args": [
            "0",
            "\"Trusting LVB on inode %llu\\n\"",
            "(unsigned long long)oi->ip_blkno"
          ],
          "line": 2234
        },
        "resolved": true,
        "details": {
          "function_name": "mlog_show",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/cluster/masklog.c",
          "lines": "107-113",
          "snippet": "static ssize_t mlog_show(struct kobject *obj, struct attribute *attr,\n\t\t\t char *buf)\n{\n\tstruct mlog_attribute *mlog_attr = to_mlog_attr(attr);\n\n\treturn mlog_mask_show(mlog_attr->mask, buf);\n}",
          "includes": [
            "#include \"masklog.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/string.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"masklog.h\"\n#include <asm/uaccess.h>\n#include <linux/string.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n\nstatic ssize_t mlog_show(struct kobject *obj, struct attribute *attr,\n\t\t\t char *buf)\n{\n\tstruct mlog_attribute *mlog_attr = to_mlog_attr(attr);\n\n\treturn mlog_mask_show(mlog_attr->mask, buf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_meta_lvb_is_trustable",
          "args": [
            "inode",
            "lockres"
          ],
          "line": 2233
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_meta_lvb_is_trustable",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlmglue.c",
          "lines": "2136-2146",
          "snippet": "static inline int ocfs2_meta_lvb_is_trustable(struct inode *inode,\n\t\t\t\t\t      struct ocfs2_lock_res *lockres)\n{\n\tstruct ocfs2_meta_lvb *lvb = ocfs2_dlm_lvb(&lockres->l_lksb);\n\n\tif (ocfs2_dlm_lvb_valid(&lockres->l_lksb)\n\t    && lvb->lvb_version == OCFS2_LVB_VERSION\n\t    && be32_to_cpu(lvb->lvb_igeneration) == inode->i_generation)\n\t\treturn 1;\n\treturn 0;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"refcounttree.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"stackglue.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dcache.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2_lockingver.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/time.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/kthread.h>",
            "#include <linux/mm.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct ocfs2_super *ocfs2_get_dentry_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_inode_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_file_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_qinfo_osb(struct ocfs2_lock_res *lockres);",
            "static void ocfs2_set_meta_lvb(struct ocfs2_lock_res *lockres);",
            "static void ocfs2_dentry_post_unlock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres);",
            "static void ocfs2_set_qinfo_lvb(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_downconvert_action(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_convert_action(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_attach_action(struct ocfs2_lock_res *lockres);",
            "static void ocfs2_schedule_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static void ocfs2_downconvert_on_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static int ocfs2_prepare_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\t        struct ocfs2_lock_res *lockres);",
            "static int ocfs2_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static void ocfs2_process_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *lockres);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"stackglue.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dcache.h\"\n#include \"alloc.h\"\n#include \"ocfs2_lockingver.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/quotaops.h>\n#include <linux/time.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/pagemap.h>\n#include <linux/kthread.h>\n#include <linux/mm.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic struct ocfs2_super *ocfs2_get_dentry_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_inode_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_file_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_qinfo_osb(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_set_meta_lvb(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_dentry_post_unlock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres);\nstatic void ocfs2_set_qinfo_lvb(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_downconvert_action(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_convert_action(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_attach_action(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_schedule_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_downconvert_on_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic int ocfs2_prepare_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\t        struct ocfs2_lock_res *lockres);\nstatic int ocfs2_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_process_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *lockres);\n\nstatic inline int ocfs2_meta_lvb_is_trustable(struct inode *inode,\n\t\t\t\t\t      struct ocfs2_lock_res *lockres)\n{\n\tstruct ocfs2_meta_lvb *lvb = ocfs2_dlm_lvb(&lockres->l_lksb);\n\n\tif (ocfs2_dlm_lvb_valid(&lockres->l_lksb)\n\t    && lvb->lvb_version == OCFS2_LVB_VERSION\n\t    && be32_to_cpu(lvb->lvb_igeneration) == inode->i_generation)\n\t\treturn 1;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_extent_map_trunc",
          "args": [
            "inode",
            "0"
          ],
          "line": 2231
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_extent_map_trunc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/extent_map.c",
          "lines": "114-144",
          "snippet": "void ocfs2_extent_map_trunc(struct inode *inode, unsigned int cpos)\n{\n\tstruct ocfs2_extent_map_item *emi, *n;\n\tstruct ocfs2_inode_info *oi = OCFS2_I(inode);\n\tstruct ocfs2_extent_map *em = &oi->ip_extent_map;\n\tLIST_HEAD(tmp_list);\n\tunsigned int range;\n\n\tspin_lock(&oi->ip_lock);\n\tlist_for_each_entry_safe(emi, n, &em->em_list, ei_list) {\n\t\tif (emi->ei_cpos >= cpos) {\n\t\t\t/* Full truncate of this record. */\n\t\t\tlist_move(&emi->ei_list, &tmp_list);\n\t\t\tBUG_ON(em->em_num_items == 0);\n\t\t\tem->em_num_items--;\n\t\t\tcontinue;\n\t\t}\n\n\t\trange = emi->ei_cpos + emi->ei_clusters;\n\t\tif (range > cpos) {\n\t\t\t/* Partial truncate */\n\t\t\temi->ei_clusters = cpos - emi->ei_cpos;\n\t\t}\n\t}\n\tspin_unlock(&oi->ip_lock);\n\n\tlist_for_each_entry_safe(emi, n, &tmp_list, ei_list) {\n\t\tlist_del(&emi->ei_list);\n\t\tkfree(emi);\n\t}\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"symlink.h\"",
            "#include \"super.h\"",
            "#include \"inode.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/fiemap.h>",
            "#include <linux/types.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"symlink.h\"\n#include \"super.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/fiemap.h>\n#include <linux/types.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n\nvoid ocfs2_extent_map_trunc(struct inode *inode, unsigned int cpos)\n{\n\tstruct ocfs2_extent_map_item *emi, *n;\n\tstruct ocfs2_inode_info *oi = OCFS2_I(inode);\n\tstruct ocfs2_extent_map *em = &oi->ip_extent_map;\n\tLIST_HEAD(tmp_list);\n\tunsigned int range;\n\n\tspin_lock(&oi->ip_lock);\n\tlist_for_each_entry_safe(emi, n, &em->em_list, ei_list) {\n\t\tif (emi->ei_cpos >= cpos) {\n\t\t\t/* Full truncate of this record. */\n\t\t\tlist_move(&emi->ei_list, &tmp_list);\n\t\t\tBUG_ON(em->em_num_items == 0);\n\t\t\tem->em_num_items--;\n\t\t\tcontinue;\n\t\t}\n\n\t\trange = emi->ei_cpos + emi->ei_clusters;\n\t\tif (range > cpos) {\n\t\t\t/* Partial truncate */\n\t\t\temi->ei_clusters = cpos - emi->ei_cpos;\n\t\t}\n\t}\n\tspin_unlock(&oi->ip_lock);\n\n\tlist_for_each_entry_safe(emi, n, &tmp_list, ei_list) {\n\t\tlist_del(&emi->ei_list);\n\t\tkfree(emi);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_metadata_cache_purge",
          "args": [
            "INODE_CACHE(inode)"
          ],
          "line": 2229
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_metadata_cache_purge",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/uptodate.c",
          "lines": "171-203",
          "snippet": "void ocfs2_metadata_cache_purge(struct ocfs2_caching_info *ci)\n{\n\tunsigned int tree, to_purge, purged;\n\tstruct rb_root root = RB_ROOT;\n\n\tBUG_ON(!ci || !ci->ci_ops);\n\n\tocfs2_metadata_cache_lock(ci);\n\ttree = !(ci->ci_flags & OCFS2_CACHE_FL_INLINE);\n\tto_purge = ci->ci_num_cached;\n\n\ttrace_ocfs2_metadata_cache_purge(\n\t\t(unsigned long long)ocfs2_metadata_cache_owner(ci),\n\t\tto_purge, tree);\n\n\t/* If we're a tree, save off the root so that we can safely\n\t * initialize the cache. We do the work to free tree members\n\t * without the spinlock. */\n\tif (tree)\n\t\troot = ci->ci_cache.ci_tree;\n\n\tocfs2_metadata_cache_reset(ci, 0);\n\tocfs2_metadata_cache_unlock(ci);\n\n\tpurged = ocfs2_purge_copied_metadata_tree(&root);\n\t/* If possible, track the number wiped so that we can more\n\t * easily detect counting errors. Unfortunately, this is only\n\t * meaningful for trees. */\n\tif (tree && purged != to_purge)\n\t\tmlog(ML_ERROR, \"Owner %llu, count = %u, purged = %u\\n\",\n\t\t     (unsigned long long)ocfs2_metadata_cache_owner(ci),\n\t\t     to_purge, purged);\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"inode.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"inode.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/rbtree.h>\n#include <linux/buffer_head.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nvoid ocfs2_metadata_cache_purge(struct ocfs2_caching_info *ci)\n{\n\tunsigned int tree, to_purge, purged;\n\tstruct rb_root root = RB_ROOT;\n\n\tBUG_ON(!ci || !ci->ci_ops);\n\n\tocfs2_metadata_cache_lock(ci);\n\ttree = !(ci->ci_flags & OCFS2_CACHE_FL_INLINE);\n\tto_purge = ci->ci_num_cached;\n\n\ttrace_ocfs2_metadata_cache_purge(\n\t\t(unsigned long long)ocfs2_metadata_cache_owner(ci),\n\t\tto_purge, tree);\n\n\t/* If we're a tree, save off the root so that we can safely\n\t * initialize the cache. We do the work to free tree members\n\t * without the spinlock. */\n\tif (tree)\n\t\troot = ci->ci_cache.ci_tree;\n\n\tocfs2_metadata_cache_reset(ci, 0);\n\tocfs2_metadata_cache_unlock(ci);\n\n\tpurged = ocfs2_purge_copied_metadata_tree(&root);\n\t/* If possible, track the number wiped so that we can more\n\t * easily detect counting errors. Unfortunately, this is only\n\t * meaningful for trees. */\n\tif (tree && purged != to_purge)\n\t\tmlog(ML_ERROR, \"Owner %llu, count = %u, purged = %u\\n\",\n\t\t     (unsigned long long)ocfs2_metadata_cache_owner(ci),\n\t\t     to_purge, purged);\n}"
        }
      },
      {
        "call_info": {
          "callee": "INODE_CACHE",
          "args": [
            "inode"
          ],
          "line": 2229
        },
        "resolved": true,
        "details": {
          "function_name": "INODE_CACHE",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/inode.h",
          "lines": "131-134",
          "snippet": "static inline struct ocfs2_caching_info *INODE_CACHE(struct inode *inode)\n{\n\treturn &OCFS2_I(inode)->ip_metadata_cache;\n}",
          "includes": [
            "#include \"extent_map.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extent_map.h\"\n\nstatic inline struct ocfs2_caching_info *INODE_CACHE(struct inode *inode)\n{\n\treturn &OCFS2_I(inode)->ip_metadata_cache;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_should_refresh_lock_res",
          "args": [
            "lockres"
          ],
          "line": 2224
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_should_refresh_lock_res",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlmglue.c",
          "lines": "2155-2182",
          "snippet": "static int ocfs2_should_refresh_lock_res(struct ocfs2_lock_res *lockres)\n{\n\tunsigned long flags;\n\tint status = 0;\n\nrefresh_check:\n\tspin_lock_irqsave(&lockres->l_lock, flags);\n\tif (!(lockres->l_flags & OCFS2_LOCK_NEEDS_REFRESH)) {\n\t\tspin_unlock_irqrestore(&lockres->l_lock, flags);\n\t\tgoto bail;\n\t}\n\n\tif (lockres->l_flags & OCFS2_LOCK_REFRESHING) {\n\t\tspin_unlock_irqrestore(&lockres->l_lock, flags);\n\n\t\tocfs2_wait_on_refreshing_lock(lockres);\n\t\tgoto refresh_check;\n\t}\n\n\t/* Ok, I'll be the one to refresh this lock. */\n\tlockres_or_flags(lockres, OCFS2_LOCK_REFRESHING);\n\tspin_unlock_irqrestore(&lockres->l_lock, flags);\n\n\tstatus = 1;\nbail:\n\tmlog(0, \"status %d\\n\", status);\n\treturn status;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"refcounttree.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"stackglue.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dcache.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2_lockingver.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/time.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/kthread.h>",
            "#include <linux/mm.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct ocfs2_super *ocfs2_get_dentry_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_inode_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_file_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_qinfo_osb(struct ocfs2_lock_res *lockres);",
            "static void ocfs2_set_meta_lvb(struct ocfs2_lock_res *lockres);",
            "static void ocfs2_dentry_post_unlock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres);",
            "static void ocfs2_set_qinfo_lvb(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_downconvert_action(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_convert_action(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_attach_action(struct ocfs2_lock_res *lockres);",
            "static void ocfs2_schedule_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static void ocfs2_downconvert_on_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static int ocfs2_prepare_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\t        struct ocfs2_lock_res *lockres);",
            "static int ocfs2_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static void ocfs2_process_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *lockres);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"stackglue.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dcache.h\"\n#include \"alloc.h\"\n#include \"ocfs2_lockingver.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/quotaops.h>\n#include <linux/time.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/pagemap.h>\n#include <linux/kthread.h>\n#include <linux/mm.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic struct ocfs2_super *ocfs2_get_dentry_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_inode_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_file_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_qinfo_osb(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_set_meta_lvb(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_dentry_post_unlock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres);\nstatic void ocfs2_set_qinfo_lvb(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_downconvert_action(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_convert_action(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_attach_action(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_schedule_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_downconvert_on_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic int ocfs2_prepare_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\t        struct ocfs2_lock_res *lockres);\nstatic int ocfs2_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_process_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *lockres);\n\nstatic int ocfs2_should_refresh_lock_res(struct ocfs2_lock_res *lockres)\n{\n\tunsigned long flags;\n\tint status = 0;\n\nrefresh_check:\n\tspin_lock_irqsave(&lockres->l_lock, flags);\n\tif (!(lockres->l_flags & OCFS2_LOCK_NEEDS_REFRESH)) {\n\t\tspin_unlock_irqrestore(&lockres->l_lock, flags);\n\t\tgoto bail;\n\t}\n\n\tif (lockres->l_flags & OCFS2_LOCK_REFRESHING) {\n\t\tspin_unlock_irqrestore(&lockres->l_lock, flags);\n\n\t\tocfs2_wait_on_refreshing_lock(lockres);\n\t\tgoto refresh_check;\n\t}\n\n\t/* Ok, I'll be the one to refresh this lock. */\n\tlockres_or_flags(lockres, OCFS2_LOCK_REFRESHING);\n\tspin_unlock_irqrestore(&lockres->l_lock, flags);\n\n\tstatus = 1;\nbail:\n\tmlog(0, \"status %d\\n\", status);\n\treturn status;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&oi->ip_lock"
          ],
          "line": 2222
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog",
          "args": [
            "0",
            "\"Orphaned inode %llu was deleted while we \"\n\t\t     \"were waiting on a lock. ip_flags = 0x%x\\n\"",
            "(unsigned long long)oi->ip_blkno",
            "oi->ip_flags"
          ],
          "line": 2215
        },
        "resolved": true,
        "details": {
          "function_name": "mlog_store",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/cluster/masklog.c",
          "lines": "115-121",
          "snippet": "static ssize_t mlog_store(struct kobject *obj, struct attribute *attr,\n\t\t\t  const char *buf, size_t count)\n{\n\tstruct mlog_attribute *mlog_attr = to_mlog_attr(attr);\n\n\treturn mlog_mask_store(mlog_attr->mask, buf, count);\n}",
          "includes": [
            "#include \"masklog.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/string.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"masklog.h\"\n#include <asm/uaccess.h>\n#include <linux/string.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n\nstatic ssize_t mlog_store(struct kobject *obj, struct attribute *attr,\n\t\t\t  const char *buf, size_t count)\n{\n\tstruct mlog_attribute *mlog_attr = to_mlog_attr(attr);\n\n\treturn mlog_mask_store(mlog_attr->mask, buf, count);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&oi->ip_lock"
          ],
          "line": 2213
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_mount_local",
          "args": [
            "osb"
          ],
          "line": 2210
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_mount_local",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "668-671",
          "snippet": "static inline int ocfs2_mount_local(struct ocfs2_super *osb)\n{\n\treturn (osb->s_feature_incompat & OCFS2_FEATURE_INCOMPAT_LOCAL_MOUNT);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\nstatic inline int ocfs2_mount_local(struct ocfs2_super *osb)\n{\n\treturn (osb->s_feature_incompat & OCFS2_FEATURE_INCOMPAT_LOCAL_MOUNT);\n}"
        }
      },
      {
        "call_info": {
          "callee": "OCFS2_SB",
          "args": [
            "inode->i_sb"
          ],
          "line": 2208
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "OCFS2_I",
          "args": [
            "inode"
          ],
          "line": 2205
        },
        "resolved": true,
        "details": {
          "function_name": "OCFS2_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/inode.h",
          "lines": "118-121",
          "snippet": "static inline struct ocfs2_inode_info *OCFS2_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ocfs2_inode_info, vfs_inode);\n}",
          "includes": [
            "#include \"extent_map.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extent_map.h\"\n\nstatic inline struct ocfs2_inode_info *OCFS2_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ocfs2_inode_info, vfs_inode);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"stackglue.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dcache.h\"\n#include \"alloc.h\"\n#include \"ocfs2_lockingver.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/quotaops.h>\n#include <linux/time.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/pagemap.h>\n#include <linux/kthread.h>\n#include <linux/mm.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic struct ocfs2_super *ocfs2_get_dentry_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_inode_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_file_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_qinfo_osb(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_set_meta_lvb(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_dentry_post_unlock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres);\nstatic void ocfs2_set_qinfo_lvb(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_downconvert_action(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_convert_action(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_attach_action(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_schedule_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_downconvert_on_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic int ocfs2_inode_lock_update(struct inode *inode,\n\t\t\t\t  struct buffer_head **bh);\nstatic void ocfs2_drop_osb_locks(struct ocfs2_super *osb);\nstatic int ocfs2_downconvert_lock(struct ocfs2_super *osb,\n\t\t\t\t  struct ocfs2_lock_res *lockres,\n\t\t\t\t  int new_level,\n\t\t\t\t  int lvb,\n\t\t\t\t  unsigned int generation);\nstatic int ocfs2_prepare_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\t        struct ocfs2_lock_res *lockres);\nstatic int ocfs2_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_process_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *lockres);\n\nstatic int ocfs2_inode_lock_update(struct inode *inode,\n\t\t\t\t  struct buffer_head **bh)\n{\n\tint status = 0;\n\tstruct ocfs2_inode_info *oi = OCFS2_I(inode);\n\tstruct ocfs2_lock_res *lockres = &oi->ip_inode_lockres;\n\tstruct ocfs2_dinode *fe;\n\tstruct ocfs2_super *osb = OCFS2_SB(inode->i_sb);\n\n\tif (ocfs2_mount_local(osb))\n\t\tgoto bail;\n\n\tspin_lock(&oi->ip_lock);\n\tif (oi->ip_flags & OCFS2_INODE_DELETED) {\n\t\tmlog(0, \"Orphaned inode %llu was deleted while we \"\n\t\t     \"were waiting on a lock. ip_flags = 0x%x\\n\",\n\t\t     (unsigned long long)oi->ip_blkno, oi->ip_flags);\n\t\tspin_unlock(&oi->ip_lock);\n\t\tstatus = -ENOENT;\n\t\tgoto bail;\n\t}\n\tspin_unlock(&oi->ip_lock);\n\n\tif (!ocfs2_should_refresh_lock_res(lockres))\n\t\tgoto bail;\n\n\t/* This will discard any caching information we might have had\n\t * for the inode metadata. */\n\tocfs2_metadata_cache_purge(INODE_CACHE(inode));\n\n\tocfs2_extent_map_trunc(inode, 0);\n\n\tif (ocfs2_meta_lvb_is_trustable(inode, lockres)) {\n\t\tmlog(0, \"Trusting LVB on inode %llu\\n\",\n\t\t     (unsigned long long)oi->ip_blkno);\n\t\tocfs2_refresh_inode_from_lvb(inode);\n\t} else {\n\t\t/* Boo, we have to go to disk. */\n\t\t/* read bh, cast, ocfs2_refresh_inode */\n\t\tstatus = ocfs2_read_inode_block(inode, bh);\n\t\tif (status < 0) {\n\t\t\tmlog_errno(status);\n\t\t\tgoto bail_refresh;\n\t\t}\n\t\tfe = (struct ocfs2_dinode *) (*bh)->b_data;\n\n\t\t/* This is a good chance to make sure we're not\n\t\t * locking an invalid object.  ocfs2_read_inode_block()\n\t\t * already checked that the inode block is sane.\n\t\t *\n\t\t * We bug on a stale inode here because we checked\n\t\t * above whether it was wiped from disk. The wiping\n\t\t * node provides a guarantee that we receive that\n\t\t * message and can mark the inode before dropping any\n\t\t * locks associated with it. */\n\t\tmlog_bug_on_msg(inode->i_generation !=\n\t\t\t\tle32_to_cpu(fe->i_generation),\n\t\t\t\t\"Invalid dinode %llu disk generation: %u \"\n\t\t\t\t\"inode->i_generation: %u\\n\",\n\t\t\t\t(unsigned long long)oi->ip_blkno,\n\t\t\t\tle32_to_cpu(fe->i_generation),\n\t\t\t\tinode->i_generation);\n\t\tmlog_bug_on_msg(le64_to_cpu(fe->i_dtime) ||\n\t\t\t\t!(fe->i_flags & cpu_to_le32(OCFS2_VALID_FL)),\n\t\t\t\t\"Stale dinode %llu dtime: %llu flags: 0x%x\\n\",\n\t\t\t\t(unsigned long long)oi->ip_blkno,\n\t\t\t\t(unsigned long long)le64_to_cpu(fe->i_dtime),\n\t\t\t\tle32_to_cpu(fe->i_flags));\n\n\t\tocfs2_refresh_inode(inode, fe);\n\t\tocfs2_track_lock_refresh(lockres);\n\t}\n\n\tstatus = 0;\nbail_refresh:\n\tocfs2_complete_lock_res_refresh(lockres, status);\nbail:\n\treturn status;\n}"
  },
  {
    "function_name": "ocfs2_complete_lock_res_refresh",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlmglue.c",
    "lines": "2186-2198",
    "snippet": "static inline void ocfs2_complete_lock_res_refresh(struct ocfs2_lock_res *lockres,\n\t\t\t\t\t\t   int status)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&lockres->l_lock, flags);\n\tlockres_clear_flags(lockres, OCFS2_LOCK_REFRESHING);\n\tif (!status)\n\t\tlockres_clear_flags(lockres, OCFS2_LOCK_NEEDS_REFRESH);\n\tspin_unlock_irqrestore(&lockres->l_lock, flags);\n\n\twake_up(&lockres->l_event);\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"refcounttree.h\"",
      "#include \"quota.h\"",
      "#include \"uptodate.h\"",
      "#include \"super.h\"",
      "#include \"slot_map.h\"",
      "#include \"stackglue.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"heartbeat.h\"",
      "#include \"file.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"dcache.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2_lockingver.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/time.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/kthread.h>",
      "#include <linux/mm.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct ocfs2_super *ocfs2_get_dentry_osb(struct ocfs2_lock_res *lockres);",
      "static struct ocfs2_super *ocfs2_get_inode_osb(struct ocfs2_lock_res *lockres);",
      "static struct ocfs2_super *ocfs2_get_file_osb(struct ocfs2_lock_res *lockres);",
      "static struct ocfs2_super *ocfs2_get_qinfo_osb(struct ocfs2_lock_res *lockres);",
      "static void ocfs2_set_meta_lvb(struct ocfs2_lock_res *lockres);",
      "static void ocfs2_dentry_post_unlock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres);",
      "static void ocfs2_set_qinfo_lvb(struct ocfs2_lock_res *lockres);",
      "static inline void ocfs2_generic_handle_downconvert_action(struct ocfs2_lock_res *lockres);",
      "static inline void ocfs2_generic_handle_convert_action(struct ocfs2_lock_res *lockres);",
      "static inline void ocfs2_generic_handle_attach_action(struct ocfs2_lock_res *lockres);",
      "static void ocfs2_schedule_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);",
      "static void ocfs2_downconvert_on_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);",
      "static int ocfs2_prepare_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\t        struct ocfs2_lock_res *lockres);",
      "static int ocfs2_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres);",
      "static void ocfs2_process_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *lockres);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "wake_up",
          "args": [
            "&lockres->l_event"
          ],
          "line": 2197
        },
        "resolved": true,
        "details": {
          "function_name": "locks_wake_up_blocks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/locks.c",
          "lines": "656-681",
          "snippet": "static void locks_wake_up_blocks(struct file_lock *blocker)\n{\n\t/*\n\t * Avoid taking global lock if list is empty. This is safe since new\n\t * blocked requests are only added to the list under the flc_lock, and\n\t * the flc_lock is always held here. Note that removal from the fl_block\n\t * list does not require the flc_lock, so we must recheck list_empty()\n\t * after acquiring the blocked_lock_lock.\n\t */\n\tif (list_empty(&blocker->fl_block))\n\t\treturn;\n\n\tspin_lock(&blocked_lock_lock);\n\twhile (!list_empty(&blocker->fl_block)) {\n\t\tstruct file_lock *waiter;\n\n\t\twaiter = list_first_entry(&blocker->fl_block,\n\t\t\t\tstruct file_lock, fl_block);\n\t\t__locks_delete_block(waiter);\n\t\tif (waiter->fl_lmops && waiter->fl_lmops->lm_notify)\n\t\t\twaiter->fl_lmops->lm_notify(waiter);\n\t\telse\n\t\t\twake_up(&waiter->fl_wait);\n\t}\n\tspin_unlock(&blocked_lock_lock);\n}",
          "includes": [
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <asm/uaccess.h>",
            "#include <trace/events/filelock.h>",
            "#include <linux/lglock.h>",
            "#include <linux/percpu.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/time.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/slab.h>",
            "#include <linux/security.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_SPINLOCK(blocked_lock_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <asm/uaccess.h>\n#include <trace/events/filelock.h>\n#include <linux/lglock.h>\n#include <linux/percpu.h>\n#include <linux/hashtable.h>\n#include <linux/pid_namespace.h>\n#include <linux/rcupdate.h>\n#include <linux/time.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n\nstatic DEFINE_SPINLOCK(blocked_lock_lock);\n\nstatic void locks_wake_up_blocks(struct file_lock *blocker)\n{\n\t/*\n\t * Avoid taking global lock if list is empty. This is safe since new\n\t * blocked requests are only added to the list under the flc_lock, and\n\t * the flc_lock is always held here. Note that removal from the fl_block\n\t * list does not require the flc_lock, so we must recheck list_empty()\n\t * after acquiring the blocked_lock_lock.\n\t */\n\tif (list_empty(&blocker->fl_block))\n\t\treturn;\n\n\tspin_lock(&blocked_lock_lock);\n\twhile (!list_empty(&blocker->fl_block)) {\n\t\tstruct file_lock *waiter;\n\n\t\twaiter = list_first_entry(&blocker->fl_block,\n\t\t\t\tstruct file_lock, fl_block);\n\t\t__locks_delete_block(waiter);\n\t\tif (waiter->fl_lmops && waiter->fl_lmops->lm_notify)\n\t\t\twaiter->fl_lmops->lm_notify(waiter);\n\t\telse\n\t\t\twake_up(&waiter->fl_wait);\n\t}\n\tspin_unlock(&blocked_lock_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock_irqrestore",
          "args": [
            "&lockres->l_lock",
            "flags"
          ],
          "line": 2195
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lockres_clear_flags",
          "args": [
            "lockres",
            "OCFS2_LOCK_NEEDS_REFRESH"
          ],
          "line": 2194
        },
        "resolved": true,
        "details": {
          "function_name": "lockres_clear_flags",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlmglue.c",
          "lines": "823-827",
          "snippet": "static void lockres_clear_flags(struct ocfs2_lock_res *lockres,\n\t\t\t\tunsigned long clear)\n{\n\tlockres_set_flags(lockres, lockres->l_flags & ~clear);\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"refcounttree.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"stackglue.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dcache.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2_lockingver.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/time.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/kthread.h>",
            "#include <linux/mm.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct ocfs2_super *ocfs2_get_dentry_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_inode_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_file_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_qinfo_osb(struct ocfs2_lock_res *lockres);",
            "static void ocfs2_set_meta_lvb(struct ocfs2_lock_res *lockres);",
            "static void ocfs2_dentry_post_unlock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres);",
            "static void ocfs2_set_qinfo_lvb(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_downconvert_action(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_convert_action(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_attach_action(struct ocfs2_lock_res *lockres);",
            "static void ocfs2_schedule_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static void ocfs2_downconvert_on_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static int ocfs2_prepare_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\t        struct ocfs2_lock_res *lockres);",
            "static int ocfs2_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static void ocfs2_process_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *lockres);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"stackglue.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dcache.h\"\n#include \"alloc.h\"\n#include \"ocfs2_lockingver.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/quotaops.h>\n#include <linux/time.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/pagemap.h>\n#include <linux/kthread.h>\n#include <linux/mm.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic struct ocfs2_super *ocfs2_get_dentry_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_inode_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_file_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_qinfo_osb(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_set_meta_lvb(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_dentry_post_unlock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres);\nstatic void ocfs2_set_qinfo_lvb(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_downconvert_action(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_convert_action(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_attach_action(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_schedule_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_downconvert_on_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic int ocfs2_prepare_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\t        struct ocfs2_lock_res *lockres);\nstatic int ocfs2_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_process_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *lockres);\n\nstatic void lockres_clear_flags(struct ocfs2_lock_res *lockres,\n\t\t\t\tunsigned long clear)\n{\n\tlockres_set_flags(lockres, lockres->l_flags & ~clear);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock_irqsave",
          "args": [
            "&lockres->l_lock",
            "flags"
          ],
          "line": 2191
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"stackglue.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dcache.h\"\n#include \"alloc.h\"\n#include \"ocfs2_lockingver.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/quotaops.h>\n#include <linux/time.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/pagemap.h>\n#include <linux/kthread.h>\n#include <linux/mm.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic struct ocfs2_super *ocfs2_get_dentry_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_inode_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_file_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_qinfo_osb(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_set_meta_lvb(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_dentry_post_unlock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres);\nstatic void ocfs2_set_qinfo_lvb(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_downconvert_action(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_convert_action(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_attach_action(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_schedule_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_downconvert_on_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic int ocfs2_prepare_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\t        struct ocfs2_lock_res *lockres);\nstatic int ocfs2_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_process_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *lockres);\n\nstatic inline void ocfs2_complete_lock_res_refresh(struct ocfs2_lock_res *lockres,\n\t\t\t\t\t\t   int status)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&lockres->l_lock, flags);\n\tlockres_clear_flags(lockres, OCFS2_LOCK_REFRESHING);\n\tif (!status)\n\t\tlockres_clear_flags(lockres, OCFS2_LOCK_NEEDS_REFRESH);\n\tspin_unlock_irqrestore(&lockres->l_lock, flags);\n\n\twake_up(&lockres->l_event);\n}"
  },
  {
    "function_name": "ocfs2_should_refresh_lock_res",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlmglue.c",
    "lines": "2155-2182",
    "snippet": "static int ocfs2_should_refresh_lock_res(struct ocfs2_lock_res *lockres)\n{\n\tunsigned long flags;\n\tint status = 0;\n\nrefresh_check:\n\tspin_lock_irqsave(&lockres->l_lock, flags);\n\tif (!(lockres->l_flags & OCFS2_LOCK_NEEDS_REFRESH)) {\n\t\tspin_unlock_irqrestore(&lockres->l_lock, flags);\n\t\tgoto bail;\n\t}\n\n\tif (lockres->l_flags & OCFS2_LOCK_REFRESHING) {\n\t\tspin_unlock_irqrestore(&lockres->l_lock, flags);\n\n\t\tocfs2_wait_on_refreshing_lock(lockres);\n\t\tgoto refresh_check;\n\t}\n\n\t/* Ok, I'll be the one to refresh this lock. */\n\tlockres_or_flags(lockres, OCFS2_LOCK_REFRESHING);\n\tspin_unlock_irqrestore(&lockres->l_lock, flags);\n\n\tstatus = 1;\nbail:\n\tmlog(0, \"status %d\\n\", status);\n\treturn status;\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"refcounttree.h\"",
      "#include \"quota.h\"",
      "#include \"uptodate.h\"",
      "#include \"super.h\"",
      "#include \"slot_map.h\"",
      "#include \"stackglue.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"heartbeat.h\"",
      "#include \"file.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"dcache.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2_lockingver.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/time.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/kthread.h>",
      "#include <linux/mm.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct ocfs2_super *ocfs2_get_dentry_osb(struct ocfs2_lock_res *lockres);",
      "static struct ocfs2_super *ocfs2_get_inode_osb(struct ocfs2_lock_res *lockres);",
      "static struct ocfs2_super *ocfs2_get_file_osb(struct ocfs2_lock_res *lockres);",
      "static struct ocfs2_super *ocfs2_get_qinfo_osb(struct ocfs2_lock_res *lockres);",
      "static void ocfs2_set_meta_lvb(struct ocfs2_lock_res *lockres);",
      "static void ocfs2_dentry_post_unlock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres);",
      "static void ocfs2_set_qinfo_lvb(struct ocfs2_lock_res *lockres);",
      "static inline void ocfs2_generic_handle_downconvert_action(struct ocfs2_lock_res *lockres);",
      "static inline void ocfs2_generic_handle_convert_action(struct ocfs2_lock_res *lockres);",
      "static inline void ocfs2_generic_handle_attach_action(struct ocfs2_lock_res *lockres);",
      "static void ocfs2_schedule_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);",
      "static void ocfs2_downconvert_on_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);",
      "static int ocfs2_prepare_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\t        struct ocfs2_lock_res *lockres);",
      "static int ocfs2_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres);",
      "static void ocfs2_process_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *lockres);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mlog",
          "args": [
            "0",
            "\"status %d\\n\"",
            "status"
          ],
          "line": 2180
        },
        "resolved": true,
        "details": {
          "function_name": "mlog_show",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/cluster/masklog.c",
          "lines": "107-113",
          "snippet": "static ssize_t mlog_show(struct kobject *obj, struct attribute *attr,\n\t\t\t char *buf)\n{\n\tstruct mlog_attribute *mlog_attr = to_mlog_attr(attr);\n\n\treturn mlog_mask_show(mlog_attr->mask, buf);\n}",
          "includes": [
            "#include \"masklog.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/string.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"masklog.h\"\n#include <asm/uaccess.h>\n#include <linux/string.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n\nstatic ssize_t mlog_show(struct kobject *obj, struct attribute *attr,\n\t\t\t char *buf)\n{\n\tstruct mlog_attribute *mlog_attr = to_mlog_attr(attr);\n\n\treturn mlog_mask_show(mlog_attr->mask, buf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock_irqrestore",
          "args": [
            "&lockres->l_lock",
            "flags"
          ],
          "line": 2176
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lockres_or_flags",
          "args": [
            "lockres",
            "OCFS2_LOCK_REFRESHING"
          ],
          "line": 2175
        },
        "resolved": true,
        "details": {
          "function_name": "lockres_or_flags",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlmglue.c",
          "lines": "819-822",
          "snippet": "static void lockres_or_flags(struct ocfs2_lock_res *lockres, unsigned long or)\n{\n\tlockres_set_flags(lockres, lockres->l_flags | or);\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"refcounttree.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"stackglue.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dcache.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2_lockingver.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/time.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/kthread.h>",
            "#include <linux/mm.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct ocfs2_super *ocfs2_get_dentry_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_inode_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_file_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_qinfo_osb(struct ocfs2_lock_res *lockres);",
            "static void ocfs2_set_meta_lvb(struct ocfs2_lock_res *lockres);",
            "static void ocfs2_dentry_post_unlock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres);",
            "static void ocfs2_set_qinfo_lvb(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_downconvert_action(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_convert_action(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_attach_action(struct ocfs2_lock_res *lockres);",
            "static void ocfs2_schedule_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static void ocfs2_downconvert_on_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static int ocfs2_prepare_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\t        struct ocfs2_lock_res *lockres);",
            "static int ocfs2_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static void ocfs2_process_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *lockres);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"stackglue.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dcache.h\"\n#include \"alloc.h\"\n#include \"ocfs2_lockingver.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/quotaops.h>\n#include <linux/time.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/pagemap.h>\n#include <linux/kthread.h>\n#include <linux/mm.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic struct ocfs2_super *ocfs2_get_dentry_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_inode_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_file_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_qinfo_osb(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_set_meta_lvb(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_dentry_post_unlock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres);\nstatic void ocfs2_set_qinfo_lvb(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_downconvert_action(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_convert_action(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_attach_action(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_schedule_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_downconvert_on_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic int ocfs2_prepare_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\t        struct ocfs2_lock_res *lockres);\nstatic int ocfs2_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_process_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *lockres);\n\nstatic void lockres_or_flags(struct ocfs2_lock_res *lockres, unsigned long or)\n{\n\tlockres_set_flags(lockres, lockres->l_flags | or);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_wait_on_refreshing_lock",
          "args": [
            "lockres"
          ],
          "line": 2170
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_wait_on_refreshing_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlmglue.c",
          "lines": "1283-1288",
          "snippet": "static inline void ocfs2_wait_on_refreshing_lock(struct ocfs2_lock_res *lockres)\n\n{\n\twait_event(lockres->l_event,\n\t\t   !ocfs2_check_wait_flag(lockres, OCFS2_LOCK_REFRESHING));\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"refcounttree.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"stackglue.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dcache.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2_lockingver.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/time.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/kthread.h>",
            "#include <linux/mm.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct ocfs2_super *ocfs2_get_dentry_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_inode_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_file_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_qinfo_osb(struct ocfs2_lock_res *lockres);",
            "static void ocfs2_set_meta_lvb(struct ocfs2_lock_res *lockres);",
            "static void ocfs2_dentry_post_unlock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres);",
            "static void ocfs2_set_qinfo_lvb(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_downconvert_action(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_convert_action(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_attach_action(struct ocfs2_lock_res *lockres);",
            "static void ocfs2_schedule_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static void ocfs2_downconvert_on_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static int ocfs2_prepare_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\t        struct ocfs2_lock_res *lockres);",
            "static int ocfs2_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static void ocfs2_process_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *lockres);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"stackglue.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dcache.h\"\n#include \"alloc.h\"\n#include \"ocfs2_lockingver.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/quotaops.h>\n#include <linux/time.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/pagemap.h>\n#include <linux/kthread.h>\n#include <linux/mm.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic struct ocfs2_super *ocfs2_get_dentry_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_inode_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_file_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_qinfo_osb(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_set_meta_lvb(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_dentry_post_unlock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres);\nstatic void ocfs2_set_qinfo_lvb(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_downconvert_action(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_convert_action(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_attach_action(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_schedule_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_downconvert_on_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic int ocfs2_prepare_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\t        struct ocfs2_lock_res *lockres);\nstatic int ocfs2_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_process_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *lockres);\n\nstatic inline void ocfs2_wait_on_refreshing_lock(struct ocfs2_lock_res *lockres)\n\n{\n\twait_event(lockres->l_event,\n\t\t   !ocfs2_check_wait_flag(lockres, OCFS2_LOCK_REFRESHING));\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock_irqrestore",
          "args": [
            "&lockres->l_lock",
            "flags"
          ],
          "line": 2168
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock_irqrestore",
          "args": [
            "&lockres->l_lock",
            "flags"
          ],
          "line": 2163
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock_irqsave",
          "args": [
            "&lockres->l_lock",
            "flags"
          ],
          "line": 2161
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"stackglue.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dcache.h\"\n#include \"alloc.h\"\n#include \"ocfs2_lockingver.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/quotaops.h>\n#include <linux/time.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/pagemap.h>\n#include <linux/kthread.h>\n#include <linux/mm.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic struct ocfs2_super *ocfs2_get_dentry_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_inode_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_file_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_qinfo_osb(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_set_meta_lvb(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_dentry_post_unlock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres);\nstatic void ocfs2_set_qinfo_lvb(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_downconvert_action(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_convert_action(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_attach_action(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_schedule_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_downconvert_on_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic int ocfs2_prepare_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\t        struct ocfs2_lock_res *lockres);\nstatic int ocfs2_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_process_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *lockres);\n\nstatic int ocfs2_should_refresh_lock_res(struct ocfs2_lock_res *lockres)\n{\n\tunsigned long flags;\n\tint status = 0;\n\nrefresh_check:\n\tspin_lock_irqsave(&lockres->l_lock, flags);\n\tif (!(lockres->l_flags & OCFS2_LOCK_NEEDS_REFRESH)) {\n\t\tspin_unlock_irqrestore(&lockres->l_lock, flags);\n\t\tgoto bail;\n\t}\n\n\tif (lockres->l_flags & OCFS2_LOCK_REFRESHING) {\n\t\tspin_unlock_irqrestore(&lockres->l_lock, flags);\n\n\t\tocfs2_wait_on_refreshing_lock(lockres);\n\t\tgoto refresh_check;\n\t}\n\n\t/* Ok, I'll be the one to refresh this lock. */\n\tlockres_or_flags(lockres, OCFS2_LOCK_REFRESHING);\n\tspin_unlock_irqrestore(&lockres->l_lock, flags);\n\n\tstatus = 1;\nbail:\n\tmlog(0, \"status %d\\n\", status);\n\treturn status;\n}"
  },
  {
    "function_name": "ocfs2_meta_lvb_is_trustable",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlmglue.c",
    "lines": "2136-2146",
    "snippet": "static inline int ocfs2_meta_lvb_is_trustable(struct inode *inode,\n\t\t\t\t\t      struct ocfs2_lock_res *lockres)\n{\n\tstruct ocfs2_meta_lvb *lvb = ocfs2_dlm_lvb(&lockres->l_lksb);\n\n\tif (ocfs2_dlm_lvb_valid(&lockres->l_lksb)\n\t    && lvb->lvb_version == OCFS2_LVB_VERSION\n\t    && be32_to_cpu(lvb->lvb_igeneration) == inode->i_generation)\n\t\treturn 1;\n\treturn 0;\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"refcounttree.h\"",
      "#include \"quota.h\"",
      "#include \"uptodate.h\"",
      "#include \"super.h\"",
      "#include \"slot_map.h\"",
      "#include \"stackglue.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"heartbeat.h\"",
      "#include \"file.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"dcache.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2_lockingver.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/time.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/kthread.h>",
      "#include <linux/mm.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct ocfs2_super *ocfs2_get_dentry_osb(struct ocfs2_lock_res *lockres);",
      "static struct ocfs2_super *ocfs2_get_inode_osb(struct ocfs2_lock_res *lockres);",
      "static struct ocfs2_super *ocfs2_get_file_osb(struct ocfs2_lock_res *lockres);",
      "static struct ocfs2_super *ocfs2_get_qinfo_osb(struct ocfs2_lock_res *lockres);",
      "static void ocfs2_set_meta_lvb(struct ocfs2_lock_res *lockres);",
      "static void ocfs2_dentry_post_unlock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres);",
      "static void ocfs2_set_qinfo_lvb(struct ocfs2_lock_res *lockres);",
      "static inline void ocfs2_generic_handle_downconvert_action(struct ocfs2_lock_res *lockres);",
      "static inline void ocfs2_generic_handle_convert_action(struct ocfs2_lock_res *lockres);",
      "static inline void ocfs2_generic_handle_attach_action(struct ocfs2_lock_res *lockres);",
      "static void ocfs2_schedule_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);",
      "static void ocfs2_downconvert_on_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);",
      "static int ocfs2_prepare_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\t        struct ocfs2_lock_res *lockres);",
      "static int ocfs2_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres);",
      "static void ocfs2_process_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *lockres);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "lvb->lvb_igeneration"
          ],
          "line": 2143
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_dlm_lvb_valid",
          "args": [
            "&lockres->l_lksb"
          ],
          "line": 2141
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_dlm_lvb_valid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/stackglue.c",
          "lines": "273-276",
          "snippet": "int ocfs2_dlm_lvb_valid(struct ocfs2_dlm_lksb *lksb)\n{\n\treturn active_stack->sp_ops->lvb_valid(lksb);\n}",
          "includes": [
            "#include \"stackglue.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include <linux/sysctl.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/fs.h>",
            "#include <linux/kmod.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/list.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct ocfs2_stack_plugin *active_stack;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"stackglue.h\"\n#include \"ocfs2_fs.h\"\n#include <linux/sysctl.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/fs.h>\n#include <linux/kmod.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/spinlock.h>\n#include <linux/list.h>\n\nstatic struct ocfs2_stack_plugin *active_stack;\n\nint ocfs2_dlm_lvb_valid(struct ocfs2_dlm_lksb *lksb)\n{\n\treturn active_stack->sp_ops->lvb_valid(lksb);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_dlm_lvb",
          "args": [
            "&lockres->l_lksb"
          ],
          "line": 2139
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_dlm_lvb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/stackglue.c",
          "lines": "279-282",
          "snippet": "void *ocfs2_dlm_lvb(struct ocfs2_dlm_lksb *lksb)\n{\n\treturn active_stack->sp_ops->lock_lvb(lksb);\n}",
          "includes": [
            "#include \"stackglue.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include <linux/sysctl.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/fs.h>",
            "#include <linux/kmod.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/list.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct ocfs2_stack_plugin *active_stack;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"stackglue.h\"\n#include \"ocfs2_fs.h\"\n#include <linux/sysctl.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/fs.h>\n#include <linux/kmod.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/spinlock.h>\n#include <linux/list.h>\n\nstatic struct ocfs2_stack_plugin *active_stack;\n\nvoid *ocfs2_dlm_lvb(struct ocfs2_dlm_lksb *lksb)\n{\n\treturn active_stack->sp_ops->lock_lvb(lksb);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"stackglue.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dcache.h\"\n#include \"alloc.h\"\n#include \"ocfs2_lockingver.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/quotaops.h>\n#include <linux/time.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/pagemap.h>\n#include <linux/kthread.h>\n#include <linux/mm.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic struct ocfs2_super *ocfs2_get_dentry_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_inode_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_file_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_qinfo_osb(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_set_meta_lvb(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_dentry_post_unlock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres);\nstatic void ocfs2_set_qinfo_lvb(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_downconvert_action(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_convert_action(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_attach_action(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_schedule_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_downconvert_on_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic int ocfs2_prepare_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\t        struct ocfs2_lock_res *lockres);\nstatic int ocfs2_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_process_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *lockres);\n\nstatic inline int ocfs2_meta_lvb_is_trustable(struct inode *inode,\n\t\t\t\t\t      struct ocfs2_lock_res *lockres)\n{\n\tstruct ocfs2_meta_lvb *lvb = ocfs2_dlm_lvb(&lockres->l_lksb);\n\n\tif (ocfs2_dlm_lvb_valid(&lockres->l_lksb)\n\t    && lvb->lvb_version == OCFS2_LVB_VERSION\n\t    && be32_to_cpu(lvb->lvb_igeneration) == inode->i_generation)\n\t\treturn 1;\n\treturn 0;\n}"
  },
  {
    "function_name": "ocfs2_refresh_inode_from_lvb",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlmglue.c",
    "lines": "2098-2134",
    "snippet": "static void ocfs2_refresh_inode_from_lvb(struct inode *inode)\n{\n\tstruct ocfs2_inode_info *oi = OCFS2_I(inode);\n\tstruct ocfs2_lock_res *lockres = &oi->ip_inode_lockres;\n\tstruct ocfs2_meta_lvb *lvb;\n\n\tmlog_meta_lvb(0, lockres);\n\n\tlvb = ocfs2_dlm_lvb(&lockres->l_lksb);\n\n\t/* We're safe here without the lockres lock... */\n\tspin_lock(&oi->ip_lock);\n\toi->ip_clusters = be32_to_cpu(lvb->lvb_iclusters);\n\ti_size_write(inode, be64_to_cpu(lvb->lvb_isize));\n\n\toi->ip_attr = be32_to_cpu(lvb->lvb_iattr);\n\toi->ip_dyn_features = be16_to_cpu(lvb->lvb_idynfeatures);\n\tocfs2_set_inode_flags(inode);\n\n\t/* fast-symlinks are a special case */\n\tif (S_ISLNK(inode->i_mode) && !oi->ip_clusters)\n\t\tinode->i_blocks = 0;\n\telse\n\t\tinode->i_blocks = ocfs2_inode_sector_count(inode);\n\n\ti_uid_write(inode, be32_to_cpu(lvb->lvb_iuid));\n\ti_gid_write(inode, be32_to_cpu(lvb->lvb_igid));\n\tinode->i_mode    = be16_to_cpu(lvb->lvb_imode);\n\tset_nlink(inode, be16_to_cpu(lvb->lvb_inlink));\n\tocfs2_unpack_timespec(&inode->i_atime,\n\t\t\t      be64_to_cpu(lvb->lvb_iatime_packed));\n\tocfs2_unpack_timespec(&inode->i_mtime,\n\t\t\t      be64_to_cpu(lvb->lvb_imtime_packed));\n\tocfs2_unpack_timespec(&inode->i_ctime,\n\t\t\t      be64_to_cpu(lvb->lvb_ictime_packed));\n\tspin_unlock(&oi->ip_lock);\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"refcounttree.h\"",
      "#include \"quota.h\"",
      "#include \"uptodate.h\"",
      "#include \"super.h\"",
      "#include \"slot_map.h\"",
      "#include \"stackglue.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"heartbeat.h\"",
      "#include \"file.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"dcache.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2_lockingver.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/time.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/kthread.h>",
      "#include <linux/mm.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct ocfs2_super *ocfs2_get_dentry_osb(struct ocfs2_lock_res *lockres);",
      "static struct ocfs2_super *ocfs2_get_inode_osb(struct ocfs2_lock_res *lockres);",
      "static struct ocfs2_super *ocfs2_get_file_osb(struct ocfs2_lock_res *lockres);",
      "static struct ocfs2_super *ocfs2_get_qinfo_osb(struct ocfs2_lock_res *lockres);",
      "static void ocfs2_set_meta_lvb(struct ocfs2_lock_res *lockres);",
      "static void ocfs2_dentry_post_unlock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres);",
      "static void ocfs2_set_qinfo_lvb(struct ocfs2_lock_res *lockres);",
      "static inline void ocfs2_generic_handle_downconvert_action(struct ocfs2_lock_res *lockres);",
      "static inline void ocfs2_generic_handle_convert_action(struct ocfs2_lock_res *lockres);",
      "static inline void ocfs2_generic_handle_attach_action(struct ocfs2_lock_res *lockres);",
      "static void ocfs2_schedule_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);",
      "static void ocfs2_downconvert_on_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);",
      "static int ocfs2_prepare_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\t        struct ocfs2_lock_res *lockres);",
      "static int ocfs2_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres);",
      "static void ocfs2_process_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *lockres);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&oi->ip_lock"
          ],
          "line": 2133
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_unpack_timespec",
          "args": [
            "&inode->i_ctime",
            "be64_to_cpu(lvb->lvb_ictime_packed)"
          ],
          "line": 2131
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_unpack_timespec",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlmglue.c",
          "lines": "2091-2096",
          "snippet": "static void ocfs2_unpack_timespec(struct timespec *spec,\n\t\t\t\t  u64 packed_time)\n{\n\tspec->tv_sec = packed_time >> OCFS2_SEC_SHIFT;\n\tspec->tv_nsec = packed_time & OCFS2_NSEC_MASK;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"refcounttree.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"stackglue.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dcache.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2_lockingver.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/time.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/kthread.h>",
            "#include <linux/mm.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [
            "#define OCFS2_NSEC_MASK  ((1ULL << OCFS2_SEC_SHIFT) - 1)",
            "#define OCFS2_SEC_SHIFT  (64 - 34)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"stackglue.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dcache.h\"\n#include \"alloc.h\"\n#include \"ocfs2_lockingver.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/quotaops.h>\n#include <linux/time.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/pagemap.h>\n#include <linux/kthread.h>\n#include <linux/mm.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\n#define OCFS2_NSEC_MASK  ((1ULL << OCFS2_SEC_SHIFT) - 1)\n#define OCFS2_SEC_SHIFT  (64 - 34)\n\nstatic void ocfs2_unpack_timespec(struct timespec *spec,\n\t\t\t\t  u64 packed_time)\n{\n\tspec->tv_sec = packed_time >> OCFS2_SEC_SHIFT;\n\tspec->tv_nsec = packed_time & OCFS2_NSEC_MASK;\n}"
        }
      },
      {
        "call_info": {
          "callee": "be64_to_cpu",
          "args": [
            "lvb->lvb_ictime_packed"
          ],
          "line": 2132
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be64_to_cpu",
          "args": [
            "lvb->lvb_imtime_packed"
          ],
          "line": 2130
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be64_to_cpu",
          "args": [
            "lvb->lvb_iatime_packed"
          ],
          "line": 2128
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_nlink",
          "args": [
            "inode",
            "be16_to_cpu(lvb->lvb_inlink)"
          ],
          "line": 2126
        },
        "resolved": true,
        "details": {
          "function_name": "set_nlink",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "305-316",
          "snippet": "void set_nlink(struct inode *inode, unsigned int nlink)\n{\n\tif (!nlink) {\n\t\tclear_nlink(inode);\n\t} else {\n\t\t/* Yes, some filesystems do change nlink from zero to one */\n\t\tif (inode->i_nlink == 0)\n\t\t\tatomic_long_dec(&inode->i_sb->s_remove_count);\n\n\t\tinode->__i_nlink = nlink;\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid set_nlink(struct inode *inode, unsigned int nlink)\n{\n\tif (!nlink) {\n\t\tclear_nlink(inode);\n\t} else {\n\t\t/* Yes, some filesystems do change nlink from zero to one */\n\t\tif (inode->i_nlink == 0)\n\t\t\tatomic_long_dec(&inode->i_sb->s_remove_count);\n\n\t\tinode->__i_nlink = nlink;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "be16_to_cpu",
          "args": [
            "lvb->lvb_inlink"
          ],
          "line": 2126
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be16_to_cpu",
          "args": [
            "lvb->lvb_imode"
          ],
          "line": 2125
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "i_gid_write",
          "args": [
            "inode",
            "be32_to_cpu(lvb->lvb_igid)"
          ],
          "line": 2124
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "lvb->lvb_igid"
          ],
          "line": 2124
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "i_uid_write",
          "args": [
            "inode",
            "be32_to_cpu(lvb->lvb_iuid)"
          ],
          "line": 2123
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "lvb->lvb_iuid"
          ],
          "line": 2123
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_inode_sector_count",
          "args": [
            "inode"
          ],
          "line": 2121
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_inode_sector_count",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/inode.h",
          "lines": "165-170",
          "snippet": "static inline blkcnt_t ocfs2_inode_sector_count(struct inode *inode)\n{\n\tint c_to_s_bits = OCFS2_SB(inode->i_sb)->s_clustersize_bits - 9;\n\n\treturn (blkcnt_t)OCFS2_I(inode)->ip_clusters << c_to_s_bits;\n}",
          "includes": [
            "#include \"extent_map.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extent_map.h\"\n\nstatic inline blkcnt_t ocfs2_inode_sector_count(struct inode *inode)\n{\n\tint c_to_s_bits = OCFS2_SB(inode->i_sb)->s_clustersize_bits - 9;\n\n\treturn (blkcnt_t)OCFS2_I(inode)->ip_clusters << c_to_s_bits;\n}"
        }
      },
      {
        "call_info": {
          "callee": "S_ISLNK",
          "args": [
            "inode->i_mode"
          ],
          "line": 2118
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_set_inode_flags",
          "args": [
            "inode"
          ],
          "line": 2115
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_set_inode_flags",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/inode.c",
          "lines": "77-95",
          "snippet": "void ocfs2_set_inode_flags(struct inode *inode)\n{\n\tunsigned int flags = OCFS2_I(inode)->ip_attr;\n\n\tinode->i_flags &= ~(S_IMMUTABLE |\n\t\tS_SYNC | S_APPEND | S_NOATIME | S_DIRSYNC);\n\n\tif (flags & OCFS2_IMMUTABLE_FL)\n\t\tinode->i_flags |= S_IMMUTABLE;\n\n\tif (flags & OCFS2_SYNC_FL)\n\t\tinode->i_flags |= S_SYNC;\n\tif (flags & OCFS2_APPEND_FL)\n\t\tinode->i_flags |= S_APPEND;\n\tif (flags & OCFS2_NOATIME_FL)\n\t\tinode->i_flags |= S_NOATIME;\n\tif (flags & OCFS2_DIRSYNC_FL)\n\t\tinode->i_flags |= S_DIRSYNC;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"symlink.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"dir.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"symlink.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"dir.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <asm/byteorder.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nvoid ocfs2_set_inode_flags(struct inode *inode)\n{\n\tunsigned int flags = OCFS2_I(inode)->ip_attr;\n\n\tinode->i_flags &= ~(S_IMMUTABLE |\n\t\tS_SYNC | S_APPEND | S_NOATIME | S_DIRSYNC);\n\n\tif (flags & OCFS2_IMMUTABLE_FL)\n\t\tinode->i_flags |= S_IMMUTABLE;\n\n\tif (flags & OCFS2_SYNC_FL)\n\t\tinode->i_flags |= S_SYNC;\n\tif (flags & OCFS2_APPEND_FL)\n\t\tinode->i_flags |= S_APPEND;\n\tif (flags & OCFS2_NOATIME_FL)\n\t\tinode->i_flags |= S_NOATIME;\n\tif (flags & OCFS2_DIRSYNC_FL)\n\t\tinode->i_flags |= S_DIRSYNC;\n}"
        }
      },
      {
        "call_info": {
          "callee": "be16_to_cpu",
          "args": [
            "lvb->lvb_idynfeatures"
          ],
          "line": 2114
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "lvb->lvb_iattr"
          ],
          "line": 2113
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "i_size_write",
          "args": [
            "inode",
            "be64_to_cpu(lvb->lvb_isize)"
          ],
          "line": 2111
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_i_size_write",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/btrfs_inode.h",
          "lines": "233-237",
          "snippet": "static inline void btrfs_i_size_write(struct inode *inode, u64 size)\n{\n\ti_size_write(inode, size);\n\tBTRFS_I(inode)->disk_i_size = size;\n}",
          "includes": [
            "#include \"delayed-inode.h\"",
            "#include \"ordered-data.h\"",
            "#include \"extent_io.h\"",
            "#include \"extent_map.h\"",
            "#include <linux/hash.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"delayed-inode.h\"\n#include \"ordered-data.h\"\n#include \"extent_io.h\"\n#include \"extent_map.h\"\n#include <linux/hash.h>\n\nstatic inline void btrfs_i_size_write(struct inode *inode, u64 size)\n{\n\ti_size_write(inode, size);\n\tBTRFS_I(inode)->disk_i_size = size;\n}"
        }
      },
      {
        "call_info": {
          "callee": "be64_to_cpu",
          "args": [
            "lvb->lvb_isize"
          ],
          "line": 2111
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "lvb->lvb_iclusters"
          ],
          "line": 2110
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&oi->ip_lock"
          ],
          "line": 2109
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_dlm_lvb",
          "args": [
            "&lockres->l_lksb"
          ],
          "line": 2106
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_dlm_lvb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/stackglue.c",
          "lines": "279-282",
          "snippet": "void *ocfs2_dlm_lvb(struct ocfs2_dlm_lksb *lksb)\n{\n\treturn active_stack->sp_ops->lock_lvb(lksb);\n}",
          "includes": [
            "#include \"stackglue.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include <linux/sysctl.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/fs.h>",
            "#include <linux/kmod.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/list.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct ocfs2_stack_plugin *active_stack;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"stackglue.h\"\n#include \"ocfs2_fs.h\"\n#include <linux/sysctl.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/fs.h>\n#include <linux/kmod.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/spinlock.h>\n#include <linux/list.h>\n\nstatic struct ocfs2_stack_plugin *active_stack;\n\nvoid *ocfs2_dlm_lvb(struct ocfs2_dlm_lksb *lksb)\n{\n\treturn active_stack->sp_ops->lock_lvb(lksb);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_meta_lvb",
          "args": [
            "0",
            "lockres"
          ],
          "line": 2104
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "OCFS2_I",
          "args": [
            "inode"
          ],
          "line": 2100
        },
        "resolved": true,
        "details": {
          "function_name": "OCFS2_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/inode.h",
          "lines": "118-121",
          "snippet": "static inline struct ocfs2_inode_info *OCFS2_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ocfs2_inode_info, vfs_inode);\n}",
          "includes": [
            "#include \"extent_map.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extent_map.h\"\n\nstatic inline struct ocfs2_inode_info *OCFS2_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ocfs2_inode_info, vfs_inode);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"stackglue.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dcache.h\"\n#include \"alloc.h\"\n#include \"ocfs2_lockingver.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/quotaops.h>\n#include <linux/time.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/pagemap.h>\n#include <linux/kthread.h>\n#include <linux/mm.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic struct ocfs2_super *ocfs2_get_dentry_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_inode_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_file_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_qinfo_osb(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_set_meta_lvb(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_dentry_post_unlock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres);\nstatic void ocfs2_set_qinfo_lvb(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_downconvert_action(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_convert_action(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_attach_action(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_schedule_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_downconvert_on_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic int ocfs2_prepare_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\t        struct ocfs2_lock_res *lockres);\nstatic int ocfs2_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_process_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *lockres);\n\nstatic void ocfs2_refresh_inode_from_lvb(struct inode *inode)\n{\n\tstruct ocfs2_inode_info *oi = OCFS2_I(inode);\n\tstruct ocfs2_lock_res *lockres = &oi->ip_inode_lockres;\n\tstruct ocfs2_meta_lvb *lvb;\n\n\tmlog_meta_lvb(0, lockres);\n\n\tlvb = ocfs2_dlm_lvb(&lockres->l_lksb);\n\n\t/* We're safe here without the lockres lock... */\n\tspin_lock(&oi->ip_lock);\n\toi->ip_clusters = be32_to_cpu(lvb->lvb_iclusters);\n\ti_size_write(inode, be64_to_cpu(lvb->lvb_isize));\n\n\toi->ip_attr = be32_to_cpu(lvb->lvb_iattr);\n\toi->ip_dyn_features = be16_to_cpu(lvb->lvb_idynfeatures);\n\tocfs2_set_inode_flags(inode);\n\n\t/* fast-symlinks are a special case */\n\tif (S_ISLNK(inode->i_mode) && !oi->ip_clusters)\n\t\tinode->i_blocks = 0;\n\telse\n\t\tinode->i_blocks = ocfs2_inode_sector_count(inode);\n\n\ti_uid_write(inode, be32_to_cpu(lvb->lvb_iuid));\n\ti_gid_write(inode, be32_to_cpu(lvb->lvb_igid));\n\tinode->i_mode    = be16_to_cpu(lvb->lvb_imode);\n\tset_nlink(inode, be16_to_cpu(lvb->lvb_inlink));\n\tocfs2_unpack_timespec(&inode->i_atime,\n\t\t\t      be64_to_cpu(lvb->lvb_iatime_packed));\n\tocfs2_unpack_timespec(&inode->i_mtime,\n\t\t\t      be64_to_cpu(lvb->lvb_imtime_packed));\n\tocfs2_unpack_timespec(&inode->i_ctime,\n\t\t\t      be64_to_cpu(lvb->lvb_ictime_packed));\n\tspin_unlock(&oi->ip_lock);\n}"
  },
  {
    "function_name": "ocfs2_unpack_timespec",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlmglue.c",
    "lines": "2091-2096",
    "snippet": "static void ocfs2_unpack_timespec(struct timespec *spec,\n\t\t\t\t  u64 packed_time)\n{\n\tspec->tv_sec = packed_time >> OCFS2_SEC_SHIFT;\n\tspec->tv_nsec = packed_time & OCFS2_NSEC_MASK;\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"refcounttree.h\"",
      "#include \"quota.h\"",
      "#include \"uptodate.h\"",
      "#include \"super.h\"",
      "#include \"slot_map.h\"",
      "#include \"stackglue.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"heartbeat.h\"",
      "#include \"file.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"dcache.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2_lockingver.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/time.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/kthread.h>",
      "#include <linux/mm.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [
      "#define OCFS2_NSEC_MASK  ((1ULL << OCFS2_SEC_SHIFT) - 1)",
      "#define OCFS2_SEC_SHIFT  (64 - 34)"
    ],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"stackglue.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dcache.h\"\n#include \"alloc.h\"\n#include \"ocfs2_lockingver.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/quotaops.h>\n#include <linux/time.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/pagemap.h>\n#include <linux/kthread.h>\n#include <linux/mm.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\n#define OCFS2_NSEC_MASK  ((1ULL << OCFS2_SEC_SHIFT) - 1)\n#define OCFS2_SEC_SHIFT  (64 - 34)\n\nstatic void ocfs2_unpack_timespec(struct timespec *spec,\n\t\t\t\t  u64 packed_time)\n{\n\tspec->tv_sec = packed_time >> OCFS2_SEC_SHIFT;\n\tspec->tv_nsec = packed_time & OCFS2_NSEC_MASK;\n}"
  },
  {
    "function_name": "__ocfs2_stuff_meta_lvb",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlmglue.c",
    "lines": "2052-2089",
    "snippet": "static void __ocfs2_stuff_meta_lvb(struct inode *inode)\n{\n\tstruct ocfs2_inode_info *oi = OCFS2_I(inode);\n\tstruct ocfs2_lock_res *lockres = &oi->ip_inode_lockres;\n\tstruct ocfs2_meta_lvb *lvb;\n\n\tlvb = ocfs2_dlm_lvb(&lockres->l_lksb);\n\n\t/*\n\t * Invalidate the LVB of a deleted inode - this way other\n\t * nodes are forced to go to disk and discover the new inode\n\t * status.\n\t */\n\tif (oi->ip_flags & OCFS2_INODE_DELETED) {\n\t\tlvb->lvb_version = 0;\n\t\tgoto out;\n\t}\n\n\tlvb->lvb_version   = OCFS2_LVB_VERSION;\n\tlvb->lvb_isize\t   = cpu_to_be64(i_size_read(inode));\n\tlvb->lvb_iclusters = cpu_to_be32(oi->ip_clusters);\n\tlvb->lvb_iuid      = cpu_to_be32(i_uid_read(inode));\n\tlvb->lvb_igid      = cpu_to_be32(i_gid_read(inode));\n\tlvb->lvb_imode     = cpu_to_be16(inode->i_mode);\n\tlvb->lvb_inlink    = cpu_to_be16(inode->i_nlink);\n\tlvb->lvb_iatime_packed  =\n\t\tcpu_to_be64(ocfs2_pack_timespec(&inode->i_atime));\n\tlvb->lvb_ictime_packed =\n\t\tcpu_to_be64(ocfs2_pack_timespec(&inode->i_ctime));\n\tlvb->lvb_imtime_packed =\n\t\tcpu_to_be64(ocfs2_pack_timespec(&inode->i_mtime));\n\tlvb->lvb_iattr    = cpu_to_be32(oi->ip_attr);\n\tlvb->lvb_idynfeatures = cpu_to_be16(oi->ip_dyn_features);\n\tlvb->lvb_igeneration = cpu_to_be32(inode->i_generation);\n\nout:\n\tmlog_meta_lvb(0, lockres);\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"refcounttree.h\"",
      "#include \"quota.h\"",
      "#include \"uptodate.h\"",
      "#include \"super.h\"",
      "#include \"slot_map.h\"",
      "#include \"stackglue.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"heartbeat.h\"",
      "#include \"file.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"dcache.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2_lockingver.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/time.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/kthread.h>",
      "#include <linux/mm.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct ocfs2_super *ocfs2_get_dentry_osb(struct ocfs2_lock_res *lockres);",
      "static struct ocfs2_super *ocfs2_get_inode_osb(struct ocfs2_lock_res *lockres);",
      "static struct ocfs2_super *ocfs2_get_file_osb(struct ocfs2_lock_res *lockres);",
      "static struct ocfs2_super *ocfs2_get_qinfo_osb(struct ocfs2_lock_res *lockres);",
      "static void ocfs2_set_meta_lvb(struct ocfs2_lock_res *lockres);",
      "static void ocfs2_dentry_post_unlock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres);",
      "static void ocfs2_set_qinfo_lvb(struct ocfs2_lock_res *lockres);",
      "static inline void ocfs2_generic_handle_downconvert_action(struct ocfs2_lock_res *lockres);",
      "static inline void ocfs2_generic_handle_convert_action(struct ocfs2_lock_res *lockres);",
      "static inline void ocfs2_generic_handle_attach_action(struct ocfs2_lock_res *lockres);",
      "static void ocfs2_schedule_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);",
      "static void ocfs2_downconvert_on_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);",
      "static int ocfs2_prepare_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\t        struct ocfs2_lock_res *lockres);",
      "static int ocfs2_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres);",
      "static void ocfs2_process_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *lockres);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mlog_meta_lvb",
          "args": [
            "0",
            "lockres"
          ],
          "line": 2088
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "inode->i_generation"
          ],
          "line": 2085
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be16",
          "args": [
            "oi->ip_dyn_features"
          ],
          "line": 2084
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "oi->ip_attr"
          ],
          "line": 2083
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be64",
          "args": [
            "ocfs2_pack_timespec(&inode->i_mtime)"
          ],
          "line": 2082
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_pack_timespec",
          "args": [
            "&inode->i_mtime"
          ],
          "line": 2082
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_pack_timespec",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlmglue.c",
          "lines": "2038-2047",
          "snippet": "static u64 ocfs2_pack_timespec(struct timespec *spec)\n{\n\tu64 res;\n\tu64 sec = spec->tv_sec;\n\tu32 nsec = spec->tv_nsec;\n\n\tres = (sec << OCFS2_SEC_SHIFT) | (nsec & OCFS2_NSEC_MASK);\n\n\treturn res;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"refcounttree.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"stackglue.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dcache.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2_lockingver.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/time.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/kthread.h>",
            "#include <linux/mm.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [
            "#define OCFS2_NSEC_MASK  ((1ULL << OCFS2_SEC_SHIFT) - 1)",
            "#define OCFS2_SEC_SHIFT  (64 - 34)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"stackglue.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dcache.h\"\n#include \"alloc.h\"\n#include \"ocfs2_lockingver.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/quotaops.h>\n#include <linux/time.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/pagemap.h>\n#include <linux/kthread.h>\n#include <linux/mm.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\n#define OCFS2_NSEC_MASK  ((1ULL << OCFS2_SEC_SHIFT) - 1)\n#define OCFS2_SEC_SHIFT  (64 - 34)\n\nstatic u64 ocfs2_pack_timespec(struct timespec *spec)\n{\n\tu64 res;\n\tu64 sec = spec->tv_sec;\n\tu32 nsec = spec->tv_nsec;\n\n\tres = (sec << OCFS2_SEC_SHIFT) | (nsec & OCFS2_NSEC_MASK);\n\n\treturn res;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_be64",
          "args": [
            "ocfs2_pack_timespec(&inode->i_ctime)"
          ],
          "line": 2080
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be64",
          "args": [
            "ocfs2_pack_timespec(&inode->i_atime)"
          ],
          "line": 2078
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be16",
          "args": [
            "inode->i_nlink"
          ],
          "line": 2076
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be16",
          "args": [
            "inode->i_mode"
          ],
          "line": 2075
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "i_gid_read(inode)"
          ],
          "line": 2074
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "i_gid_read",
          "args": [
            "inode"
          ],
          "line": 2074
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "i_uid_read(inode)"
          ],
          "line": 2073
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "i_uid_read",
          "args": [
            "inode"
          ],
          "line": 2073
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "oi->ip_clusters"
          ],
          "line": 2072
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be64",
          "args": [
            "i_size_read(inode)"
          ],
          "line": 2071
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "i_size_read",
          "args": [
            "inode"
          ],
          "line": 2071
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_dlm_lvb",
          "args": [
            "&lockres->l_lksb"
          ],
          "line": 2058
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_dlm_lvb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/stackglue.c",
          "lines": "279-282",
          "snippet": "void *ocfs2_dlm_lvb(struct ocfs2_dlm_lksb *lksb)\n{\n\treturn active_stack->sp_ops->lock_lvb(lksb);\n}",
          "includes": [
            "#include \"stackglue.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include <linux/sysctl.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/fs.h>",
            "#include <linux/kmod.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/list.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct ocfs2_stack_plugin *active_stack;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"stackglue.h\"\n#include \"ocfs2_fs.h\"\n#include <linux/sysctl.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/fs.h>\n#include <linux/kmod.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/spinlock.h>\n#include <linux/list.h>\n\nstatic struct ocfs2_stack_plugin *active_stack;\n\nvoid *ocfs2_dlm_lvb(struct ocfs2_dlm_lksb *lksb)\n{\n\treturn active_stack->sp_ops->lock_lvb(lksb);\n}"
        }
      },
      {
        "call_info": {
          "callee": "OCFS2_I",
          "args": [
            "inode"
          ],
          "line": 2054
        },
        "resolved": true,
        "details": {
          "function_name": "OCFS2_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/inode.h",
          "lines": "118-121",
          "snippet": "static inline struct ocfs2_inode_info *OCFS2_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ocfs2_inode_info, vfs_inode);\n}",
          "includes": [
            "#include \"extent_map.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extent_map.h\"\n\nstatic inline struct ocfs2_inode_info *OCFS2_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ocfs2_inode_info, vfs_inode);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"stackglue.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dcache.h\"\n#include \"alloc.h\"\n#include \"ocfs2_lockingver.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/quotaops.h>\n#include <linux/time.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/pagemap.h>\n#include <linux/kthread.h>\n#include <linux/mm.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic struct ocfs2_super *ocfs2_get_dentry_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_inode_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_file_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_qinfo_osb(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_set_meta_lvb(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_dentry_post_unlock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres);\nstatic void ocfs2_set_qinfo_lvb(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_downconvert_action(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_convert_action(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_attach_action(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_schedule_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_downconvert_on_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic int ocfs2_prepare_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\t        struct ocfs2_lock_res *lockres);\nstatic int ocfs2_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_process_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *lockres);\n\nstatic void __ocfs2_stuff_meta_lvb(struct inode *inode)\n{\n\tstruct ocfs2_inode_info *oi = OCFS2_I(inode);\n\tstruct ocfs2_lock_res *lockres = &oi->ip_inode_lockres;\n\tstruct ocfs2_meta_lvb *lvb;\n\n\tlvb = ocfs2_dlm_lvb(&lockres->l_lksb);\n\n\t/*\n\t * Invalidate the LVB of a deleted inode - this way other\n\t * nodes are forced to go to disk and discover the new inode\n\t * status.\n\t */\n\tif (oi->ip_flags & OCFS2_INODE_DELETED) {\n\t\tlvb->lvb_version = 0;\n\t\tgoto out;\n\t}\n\n\tlvb->lvb_version   = OCFS2_LVB_VERSION;\n\tlvb->lvb_isize\t   = cpu_to_be64(i_size_read(inode));\n\tlvb->lvb_iclusters = cpu_to_be32(oi->ip_clusters);\n\tlvb->lvb_iuid      = cpu_to_be32(i_uid_read(inode));\n\tlvb->lvb_igid      = cpu_to_be32(i_gid_read(inode));\n\tlvb->lvb_imode     = cpu_to_be16(inode->i_mode);\n\tlvb->lvb_inlink    = cpu_to_be16(inode->i_nlink);\n\tlvb->lvb_iatime_packed  =\n\t\tcpu_to_be64(ocfs2_pack_timespec(&inode->i_atime));\n\tlvb->lvb_ictime_packed =\n\t\tcpu_to_be64(ocfs2_pack_timespec(&inode->i_ctime));\n\tlvb->lvb_imtime_packed =\n\t\tcpu_to_be64(ocfs2_pack_timespec(&inode->i_mtime));\n\tlvb->lvb_iattr    = cpu_to_be32(oi->ip_attr);\n\tlvb->lvb_idynfeatures = cpu_to_be16(oi->ip_dyn_features);\n\tlvb->lvb_igeneration = cpu_to_be32(inode->i_generation);\n\nout:\n\tmlog_meta_lvb(0, lockres);\n}"
  },
  {
    "function_name": "ocfs2_pack_timespec",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlmglue.c",
    "lines": "2038-2047",
    "snippet": "static u64 ocfs2_pack_timespec(struct timespec *spec)\n{\n\tu64 res;\n\tu64 sec = spec->tv_sec;\n\tu32 nsec = spec->tv_nsec;\n\n\tres = (sec << OCFS2_SEC_SHIFT) | (nsec & OCFS2_NSEC_MASK);\n\n\treturn res;\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"refcounttree.h\"",
      "#include \"quota.h\"",
      "#include \"uptodate.h\"",
      "#include \"super.h\"",
      "#include \"slot_map.h\"",
      "#include \"stackglue.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"heartbeat.h\"",
      "#include \"file.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"dcache.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2_lockingver.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/time.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/kthread.h>",
      "#include <linux/mm.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [
      "#define OCFS2_NSEC_MASK  ((1ULL << OCFS2_SEC_SHIFT) - 1)",
      "#define OCFS2_SEC_SHIFT  (64 - 34)"
    ],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"stackglue.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dcache.h\"\n#include \"alloc.h\"\n#include \"ocfs2_lockingver.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/quotaops.h>\n#include <linux/time.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/pagemap.h>\n#include <linux/kthread.h>\n#include <linux/mm.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\n#define OCFS2_NSEC_MASK  ((1ULL << OCFS2_SEC_SHIFT) - 1)\n#define OCFS2_SEC_SHIFT  (64 - 34)\n\nstatic u64 ocfs2_pack_timespec(struct timespec *spec)\n{\n\tu64 res;\n\tu64 sec = spec->tv_sec;\n\tu32 nsec = spec->tv_nsec;\n\n\tres = (sec << OCFS2_SEC_SHIFT) | (nsec & OCFS2_NSEC_MASK);\n\n\treturn res;\n}"
  },
  {
    "function_name": "ocfs2_downconvert_on_unlock",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlmglue.c",
    "lines": "2005-2030",
    "snippet": "static void ocfs2_downconvert_on_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres)\n{\n\tint kick = 0;\n\n\t/* If we know that another node is waiting on our lock, kick\n\t * the downconvert thread * pre-emptively when we reach a release\n\t * condition. */\n\tif (lockres->l_flags & OCFS2_LOCK_BLOCKED) {\n\t\tswitch(lockres->l_blocking) {\n\t\tcase DLM_LOCK_EX:\n\t\t\tif (!lockres->l_ex_holders && !lockres->l_ro_holders)\n\t\t\t\tkick = 1;\n\t\t\tbreak;\n\t\tcase DLM_LOCK_PR:\n\t\t\tif (!lockres->l_ex_holders)\n\t\t\t\tkick = 1;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tBUG();\n\t\t}\n\t}\n\n\tif (kick)\n\t\tocfs2_wake_downconvert_thread(osb);\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"refcounttree.h\"",
      "#include \"quota.h\"",
      "#include \"uptodate.h\"",
      "#include \"super.h\"",
      "#include \"slot_map.h\"",
      "#include \"stackglue.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"heartbeat.h\"",
      "#include \"file.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"dcache.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2_lockingver.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/time.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/kthread.h>",
      "#include <linux/mm.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct ocfs2_super *ocfs2_get_dentry_osb(struct ocfs2_lock_res *lockres);",
      "static struct ocfs2_super *ocfs2_get_inode_osb(struct ocfs2_lock_res *lockres);",
      "static struct ocfs2_super *ocfs2_get_file_osb(struct ocfs2_lock_res *lockres);",
      "static struct ocfs2_super *ocfs2_get_qinfo_osb(struct ocfs2_lock_res *lockres);",
      "static void ocfs2_set_meta_lvb(struct ocfs2_lock_res *lockres);",
      "static void ocfs2_dentry_post_unlock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres);",
      "static void ocfs2_set_qinfo_lvb(struct ocfs2_lock_res *lockres);",
      "static inline void ocfs2_generic_handle_downconvert_action(struct ocfs2_lock_res *lockres);",
      "static inline void ocfs2_generic_handle_convert_action(struct ocfs2_lock_res *lockres);",
      "static inline void ocfs2_generic_handle_attach_action(struct ocfs2_lock_res *lockres);",
      "static void ocfs2_schedule_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);",
      "static void ocfs2_downconvert_on_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);",
      "static void ocfs2_drop_osb_locks(struct ocfs2_super *osb);",
      "static int ocfs2_prepare_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\t        struct ocfs2_lock_res *lockres);",
      "static int ocfs2_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres);",
      "static void ocfs2_process_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *lockres);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ocfs2_wake_downconvert_thread",
          "args": [
            "osb"
          ],
          "line": 2029
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_wake_downconvert_thread",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlmglue.c",
          "lines": "4091-4101",
          "snippet": "void ocfs2_wake_downconvert_thread(struct ocfs2_super *osb)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&osb->dc_task_lock, flags);\n\t/* make sure the voting thread gets a swipe at whatever changes\n\t * the caller may have made to the voting state */\n\tosb->dc_wake_sequence++;\n\tspin_unlock_irqrestore(&osb->dc_task_lock, flags);\n\twake_up(&osb->dc_event);\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"refcounttree.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"stackglue.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dcache.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2_lockingver.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/time.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/kthread.h>",
            "#include <linux/mm.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void ocfs2_drop_osb_locks(struct ocfs2_super *osb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"stackglue.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dcache.h\"\n#include \"alloc.h\"\n#include \"ocfs2_lockingver.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/quotaops.h>\n#include <linux/time.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/pagemap.h>\n#include <linux/kthread.h>\n#include <linux/mm.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic void ocfs2_drop_osb_locks(struct ocfs2_super *osb);\n\nvoid ocfs2_wake_downconvert_thread(struct ocfs2_super *osb)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&osb->dc_task_lock, flags);\n\t/* make sure the voting thread gets a swipe at whatever changes\n\t * the caller may have made to the voting state */\n\tosb->dc_wake_sequence++;\n\tspin_unlock_irqrestore(&osb->dc_task_lock, flags);\n\twake_up(&osb->dc_event);\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG",
          "args": [],
          "line": 2024
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"stackglue.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dcache.h\"\n#include \"alloc.h\"\n#include \"ocfs2_lockingver.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/quotaops.h>\n#include <linux/time.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/pagemap.h>\n#include <linux/kthread.h>\n#include <linux/mm.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic struct ocfs2_super *ocfs2_get_dentry_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_inode_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_file_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_qinfo_osb(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_set_meta_lvb(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_dentry_post_unlock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres);\nstatic void ocfs2_set_qinfo_lvb(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_downconvert_action(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_convert_action(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_attach_action(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_schedule_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_downconvert_on_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_drop_osb_locks(struct ocfs2_super *osb);\nstatic int ocfs2_prepare_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\t        struct ocfs2_lock_res *lockres);\nstatic int ocfs2_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_process_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *lockres);\n\nstatic void ocfs2_downconvert_on_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres)\n{\n\tint kick = 0;\n\n\t/* If we know that another node is waiting on our lock, kick\n\t * the downconvert thread * pre-emptively when we reach a release\n\t * condition. */\n\tif (lockres->l_flags & OCFS2_LOCK_BLOCKED) {\n\t\tswitch(lockres->l_blocking) {\n\t\tcase DLM_LOCK_EX:\n\t\t\tif (!lockres->l_ex_holders && !lockres->l_ro_holders)\n\t\t\t\tkick = 1;\n\t\t\tbreak;\n\t\tcase DLM_LOCK_PR:\n\t\t\tif (!lockres->l_ex_holders)\n\t\t\t\tkick = 1;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tBUG();\n\t\t}\n\t}\n\n\tif (kick)\n\t\tocfs2_wake_downconvert_thread(osb);\n}"
  },
  {
    "function_name": "ocfs2_file_unlock",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlmglue.c",
    "lines": "1961-2003",
    "snippet": "void ocfs2_file_unlock(struct file *file)\n{\n\tint ret;\n\tunsigned int gen;\n\tunsigned long flags;\n\tstruct ocfs2_file_private *fp = file->private_data;\n\tstruct ocfs2_lock_res *lockres = &fp->fp_flock;\n\tstruct ocfs2_super *osb = OCFS2_SB(file->f_mapping->host->i_sb);\n\tstruct ocfs2_mask_waiter mw;\n\n\tocfs2_init_mask_waiter(&mw);\n\n\tif (!(lockres->l_flags & OCFS2_LOCK_ATTACHED))\n\t\treturn;\n\n\tif (lockres->l_level == DLM_LOCK_NL)\n\t\treturn;\n\n\tmlog(0, \"Unlock: \\\"%s\\\" flags: 0x%lx, level: %d, act: %d\\n\",\n\t     lockres->l_name, lockres->l_flags, lockres->l_level,\n\t     lockres->l_action);\n\n\tspin_lock_irqsave(&lockres->l_lock, flags);\n\t/*\n\t * Fake a blocking ast for the downconvert code.\n\t */\n\tlockres_or_flags(lockres, OCFS2_LOCK_BLOCKED);\n\tlockres->l_blocking = DLM_LOCK_EX;\n\n\tgen = ocfs2_prepare_downconvert(lockres, DLM_LOCK_NL);\n\tlockres_add_mask_waiter(lockres, &mw, OCFS2_LOCK_BUSY, 0);\n\tspin_unlock_irqrestore(&lockres->l_lock, flags);\n\n\tret = ocfs2_downconvert_lock(osb, lockres, DLM_LOCK_NL, 0, gen);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\treturn;\n\t}\n\n\tret = ocfs2_wait_for_mask(&mw);\n\tif (ret)\n\t\tmlog_errno(ret);\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"refcounttree.h\"",
      "#include \"quota.h\"",
      "#include \"uptodate.h\"",
      "#include \"super.h\"",
      "#include \"slot_map.h\"",
      "#include \"stackglue.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"heartbeat.h\"",
      "#include \"file.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"dcache.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2_lockingver.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/time.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/kthread.h>",
      "#include <linux/mm.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct ocfs2_super *ocfs2_get_dentry_osb(struct ocfs2_lock_res *lockres);",
      "static struct ocfs2_super *ocfs2_get_inode_osb(struct ocfs2_lock_res *lockres);",
      "static struct ocfs2_super *ocfs2_get_file_osb(struct ocfs2_lock_res *lockres);",
      "static struct ocfs2_super *ocfs2_get_qinfo_osb(struct ocfs2_lock_res *lockres);",
      "static void ocfs2_set_meta_lvb(struct ocfs2_lock_res *lockres);",
      "static int ocfs2_data_convert_worker(struct ocfs2_lock_res *lockres,\n\t\t\t\t     int blocking);",
      "static int ocfs2_dentry_convert_worker(struct ocfs2_lock_res *lockres,\n\t\t\t\t       int blocking);",
      "static void ocfs2_dentry_post_unlock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres);",
      "static void ocfs2_set_qinfo_lvb(struct ocfs2_lock_res *lockres);",
      "static int ocfs2_refcount_convert_worker(struct ocfs2_lock_res *lockres,\n\t\t\t\t\t int blocking);",
      "static inline void ocfs2_generic_handle_downconvert_action(struct ocfs2_lock_res *lockres);",
      "static inline void ocfs2_generic_handle_convert_action(struct ocfs2_lock_res *lockres);",
      "static inline void ocfs2_generic_handle_attach_action(struct ocfs2_lock_res *lockres);",
      "static int ocfs2_generic_handle_bast(struct ocfs2_lock_res *lockres, int level);",
      "static void ocfs2_schedule_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);",
      "static void ocfs2_downconvert_on_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);",
      "static void ocfs2_drop_osb_locks(struct ocfs2_super *osb);",
      "static inline int ocfs2_highest_compat_lock_level(int level);",
      "static int ocfs2_prepare_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\t        struct ocfs2_lock_res *lockres);",
      "static int ocfs2_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres);",
      "static void ocfs2_process_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *lockres);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 2002
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_wait_for_mask",
          "args": [
            "&mw"
          ],
          "line": 2000
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_wait_for_mask",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlmglue.c",
          "lines": "1308-1314",
          "snippet": "static int ocfs2_wait_for_mask(struct ocfs2_mask_waiter *mw)\n{\n\twait_for_completion(&mw->mw_complete);\n\t/* Re-arm the completion in case we want to wait on it again */\n\treinit_completion(&mw->mw_complete);\n\treturn mw->mw_status;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"refcounttree.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"stackglue.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dcache.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2_lockingver.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/time.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/kthread.h>",
            "#include <linux/mm.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"stackglue.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dcache.h\"\n#include \"alloc.h\"\n#include \"ocfs2_lockingver.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/quotaops.h>\n#include <linux/time.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/pagemap.h>\n#include <linux/kthread.h>\n#include <linux/mm.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic int ocfs2_wait_for_mask(struct ocfs2_mask_waiter *mw)\n{\n\twait_for_completion(&mw->mw_complete);\n\t/* Re-arm the completion in case we want to wait on it again */\n\treinit_completion(&mw->mw_complete);\n\treturn mw->mw_status;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 1996
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_downconvert_lock",
          "args": [
            "osb",
            "lockres",
            "DLM_LOCK_NL",
            "0",
            "gen"
          ],
          "line": 1994
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_downconvert_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlmglue.c",
          "lines": "3302-3333",
          "snippet": "static int ocfs2_downconvert_lock(struct ocfs2_super *osb,\n\t\t\t\t  struct ocfs2_lock_res *lockres,\n\t\t\t\t  int new_level,\n\t\t\t\t  int lvb,\n\t\t\t\t  unsigned int generation)\n{\n\tint ret;\n\tu32 dlm_flags = DLM_LKF_CONVERT;\n\n\tmlog(ML_BASTS, \"lockres %s, level %d => %d\\n\", lockres->l_name,\n\t     lockres->l_level, new_level);\n\n\tif (lvb)\n\t\tdlm_flags |= DLM_LKF_VALBLK;\n\n\tret = ocfs2_dlm_lock(osb->cconn,\n\t\t\t     new_level,\n\t\t\t     &lockres->l_lksb,\n\t\t\t     dlm_flags,\n\t\t\t     lockres->l_name,\n\t\t\t     OCFS2_LOCK_ID_MAX_LEN - 1);\n\tlockres_clear_pending(lockres, generation, osb);\n\tif (ret) {\n\t\tocfs2_log_dlm_error(\"ocfs2_dlm_lock\", ret, lockres);\n\t\tocfs2_recover_from_dlm_error(lockres, 1);\n\t\tgoto bail;\n\t}\n\n\tret = 0;\nbail:\n\treturn ret;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"refcounttree.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"stackglue.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dcache.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2_lockingver.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/time.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/kthread.h>",
            "#include <linux/mm.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct ocfs2_super *ocfs2_get_dentry_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_inode_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_file_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_qinfo_osb(struct ocfs2_lock_res *lockres);",
            "static int ocfs2_check_meta_downconvert(struct ocfs2_lock_res *lockres,\n\t\t\t\t\tint new_level);",
            "static void ocfs2_set_meta_lvb(struct ocfs2_lock_res *lockres);",
            "static void ocfs2_dentry_post_unlock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres);",
            "static void ocfs2_set_qinfo_lvb(struct ocfs2_lock_res *lockres);",
            "static int ocfs2_check_refcount_downconvert(struct ocfs2_lock_res *lockres,\n\t\t\t\t\t    int new_level);",
            "static int ocfs2_lock_create(struct ocfs2_super *osb,\n\t\t\t     struct ocfs2_lock_res *lockres,\n\t\t\t     int level,\n\t\t\t     u32 dlm_flags);",
            "static inline void ocfs2_generic_handle_downconvert_action(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_convert_action(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_attach_action(struct ocfs2_lock_res *lockres);",
            "static int ocfs2_generic_handle_bast(struct ocfs2_lock_res *lockres, int level);",
            "static void ocfs2_schedule_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static void ocfs2_downconvert_on_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static void ocfs2_drop_osb_locks(struct ocfs2_super *osb);",
            "static inline int ocfs2_highest_compat_lock_level(int level);",
            "static unsigned int ocfs2_prepare_downconvert(struct ocfs2_lock_res *lockres,\n\t\t\t\t\t      int new_level);",
            "static int ocfs2_downconvert_lock(struct ocfs2_super *osb,\n\t\t\t\t  struct ocfs2_lock_res *lockres,\n\t\t\t\t  int new_level,\n\t\t\t\t  int lvb,\n\t\t\t\t  unsigned int generation);",
            "static int ocfs2_prepare_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\t        struct ocfs2_lock_res *lockres);",
            "static int ocfs2_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static void ocfs2_process_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *lockres);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"stackglue.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dcache.h\"\n#include \"alloc.h\"\n#include \"ocfs2_lockingver.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/quotaops.h>\n#include <linux/time.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/pagemap.h>\n#include <linux/kthread.h>\n#include <linux/mm.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic struct ocfs2_super *ocfs2_get_dentry_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_inode_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_file_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_qinfo_osb(struct ocfs2_lock_res *lockres);\nstatic int ocfs2_check_meta_downconvert(struct ocfs2_lock_res *lockres,\n\t\t\t\t\tint new_level);\nstatic void ocfs2_set_meta_lvb(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_dentry_post_unlock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres);\nstatic void ocfs2_set_qinfo_lvb(struct ocfs2_lock_res *lockres);\nstatic int ocfs2_check_refcount_downconvert(struct ocfs2_lock_res *lockres,\n\t\t\t\t\t    int new_level);\nstatic int ocfs2_lock_create(struct ocfs2_super *osb,\n\t\t\t     struct ocfs2_lock_res *lockres,\n\t\t\t     int level,\n\t\t\t     u32 dlm_flags);\nstatic inline void ocfs2_generic_handle_downconvert_action(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_convert_action(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_attach_action(struct ocfs2_lock_res *lockres);\nstatic int ocfs2_generic_handle_bast(struct ocfs2_lock_res *lockres, int level);\nstatic void ocfs2_schedule_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_downconvert_on_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_drop_osb_locks(struct ocfs2_super *osb);\nstatic inline int ocfs2_highest_compat_lock_level(int level);\nstatic unsigned int ocfs2_prepare_downconvert(struct ocfs2_lock_res *lockres,\n\t\t\t\t\t      int new_level);\nstatic int ocfs2_downconvert_lock(struct ocfs2_super *osb,\n\t\t\t\t  struct ocfs2_lock_res *lockres,\n\t\t\t\t  int new_level,\n\t\t\t\t  int lvb,\n\t\t\t\t  unsigned int generation);\nstatic int ocfs2_prepare_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\t        struct ocfs2_lock_res *lockres);\nstatic int ocfs2_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_process_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *lockres);\n\nstatic int ocfs2_downconvert_lock(struct ocfs2_super *osb,\n\t\t\t\t  struct ocfs2_lock_res *lockres,\n\t\t\t\t  int new_level,\n\t\t\t\t  int lvb,\n\t\t\t\t  unsigned int generation)\n{\n\tint ret;\n\tu32 dlm_flags = DLM_LKF_CONVERT;\n\n\tmlog(ML_BASTS, \"lockres %s, level %d => %d\\n\", lockres->l_name,\n\t     lockres->l_level, new_level);\n\n\tif (lvb)\n\t\tdlm_flags |= DLM_LKF_VALBLK;\n\n\tret = ocfs2_dlm_lock(osb->cconn,\n\t\t\t     new_level,\n\t\t\t     &lockres->l_lksb,\n\t\t\t     dlm_flags,\n\t\t\t     lockres->l_name,\n\t\t\t     OCFS2_LOCK_ID_MAX_LEN - 1);\n\tlockres_clear_pending(lockres, generation, osb);\n\tif (ret) {\n\t\tocfs2_log_dlm_error(\"ocfs2_dlm_lock\", ret, lockres);\n\t\tocfs2_recover_from_dlm_error(lockres, 1);\n\t\tgoto bail;\n\t}\n\n\tret = 0;\nbail:\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock_irqrestore",
          "args": [
            "&lockres->l_lock",
            "flags"
          ],
          "line": 1992
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lockres_add_mask_waiter",
          "args": [
            "lockres",
            "&mw",
            "OCFS2_LOCK_BUSY",
            "0"
          ],
          "line": 1991
        },
        "resolved": true,
        "details": {
          "function_name": "lockres_add_mask_waiter",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlmglue.c",
          "lines": "1316-1328",
          "snippet": "static void lockres_add_mask_waiter(struct ocfs2_lock_res *lockres,\n\t\t\t\t    struct ocfs2_mask_waiter *mw,\n\t\t\t\t    unsigned long mask,\n\t\t\t\t    unsigned long goal)\n{\n\tBUG_ON(!list_empty(&mw->mw_item));\n\n\tassert_spin_locked(&lockres->l_lock);\n\n\tlist_add_tail(&mw->mw_item, &lockres->l_mask_waiters);\n\tmw->mw_mask = mask;\n\tmw->mw_goal = goal;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"refcounttree.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"stackglue.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dcache.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2_lockingver.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/time.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/kthread.h>",
            "#include <linux/mm.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct ocfs2_super *ocfs2_get_dentry_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_inode_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_file_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_qinfo_osb(struct ocfs2_lock_res *lockres);",
            "static void ocfs2_set_meta_lvb(struct ocfs2_lock_res *lockres);",
            "static void ocfs2_dentry_post_unlock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres);",
            "static void ocfs2_set_qinfo_lvb(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_downconvert_action(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_convert_action(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_attach_action(struct ocfs2_lock_res *lockres);",
            "static void ocfs2_schedule_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static void ocfs2_downconvert_on_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static int ocfs2_prepare_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\t        struct ocfs2_lock_res *lockres);",
            "static int ocfs2_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static void ocfs2_process_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *lockres);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"stackglue.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dcache.h\"\n#include \"alloc.h\"\n#include \"ocfs2_lockingver.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/quotaops.h>\n#include <linux/time.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/pagemap.h>\n#include <linux/kthread.h>\n#include <linux/mm.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic struct ocfs2_super *ocfs2_get_dentry_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_inode_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_file_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_qinfo_osb(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_set_meta_lvb(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_dentry_post_unlock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres);\nstatic void ocfs2_set_qinfo_lvb(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_downconvert_action(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_convert_action(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_attach_action(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_schedule_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_downconvert_on_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic int ocfs2_prepare_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\t        struct ocfs2_lock_res *lockres);\nstatic int ocfs2_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_process_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *lockres);\n\nstatic void lockres_add_mask_waiter(struct ocfs2_lock_res *lockres,\n\t\t\t\t    struct ocfs2_mask_waiter *mw,\n\t\t\t\t    unsigned long mask,\n\t\t\t\t    unsigned long goal)\n{\n\tBUG_ON(!list_empty(&mw->mw_item));\n\n\tassert_spin_locked(&lockres->l_lock);\n\n\tlist_add_tail(&mw->mw_item, &lockres->l_mask_waiters);\n\tmw->mw_mask = mask;\n\tmw->mw_goal = goal;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_prepare_downconvert",
          "args": [
            "lockres",
            "DLM_LOCK_NL"
          ],
          "line": 1990
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_prepare_downconvert",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlmglue.c",
          "lines": "3273-3300",
          "snippet": "static unsigned int ocfs2_prepare_downconvert(struct ocfs2_lock_res *lockres,\n\t\t\t\t\t      int new_level)\n{\n\tassert_spin_locked(&lockres->l_lock);\n\n\tBUG_ON(lockres->l_blocking <= DLM_LOCK_NL);\n\n\tif (lockres->l_level <= new_level) {\n\t\tmlog(ML_ERROR, \"lockres %s, lvl %d <= %d, blcklst %d, mask %d, \"\n\t\t     \"type %d, flags 0x%lx, hold %d %d, act %d %d, req %d, \"\n\t\t     \"block %d, pgen %d\\n\", lockres->l_name, lockres->l_level,\n\t\t     new_level, list_empty(&lockres->l_blocked_list),\n\t\t     list_empty(&lockres->l_mask_waiters), lockres->l_type,\n\t\t     lockres->l_flags, lockres->l_ro_holders,\n\t\t     lockres->l_ex_holders, lockres->l_action,\n\t\t     lockres->l_unlock_action, lockres->l_requested,\n\t\t     lockres->l_blocking, lockres->l_pending_gen);\n\t\tBUG();\n\t}\n\n\tmlog(ML_BASTS, \"lockres %s, level %d => %d, blocking %d\\n\",\n\t     lockres->l_name, lockres->l_level, new_level, lockres->l_blocking);\n\n\tlockres->l_action = OCFS2_AST_DOWNCONVERT;\n\tlockres->l_requested = new_level;\n\tlockres_or_flags(lockres, OCFS2_LOCK_BUSY);\n\treturn lockres_set_pending(lockres);\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"refcounttree.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"stackglue.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dcache.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2_lockingver.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/time.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/kthread.h>",
            "#include <linux/mm.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct ocfs2_super *ocfs2_get_dentry_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_inode_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_file_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_qinfo_osb(struct ocfs2_lock_res *lockres);",
            "static int ocfs2_check_meta_downconvert(struct ocfs2_lock_res *lockres,\n\t\t\t\t\tint new_level);",
            "static void ocfs2_set_meta_lvb(struct ocfs2_lock_res *lockres);",
            "static int ocfs2_data_convert_worker(struct ocfs2_lock_res *lockres,\n\t\t\t\t     int blocking);",
            "static int ocfs2_dentry_convert_worker(struct ocfs2_lock_res *lockres,\n\t\t\t\t       int blocking);",
            "static void ocfs2_dentry_post_unlock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres);",
            "static void ocfs2_set_qinfo_lvb(struct ocfs2_lock_res *lockres);",
            "static int ocfs2_check_refcount_downconvert(struct ocfs2_lock_res *lockres,\n\t\t\t\t\t    int new_level);",
            "static int ocfs2_refcount_convert_worker(struct ocfs2_lock_res *lockres,\n\t\t\t\t\t int blocking);",
            "static inline void ocfs2_generic_handle_downconvert_action(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_convert_action(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_attach_action(struct ocfs2_lock_res *lockres);",
            "static int ocfs2_generic_handle_bast(struct ocfs2_lock_res *lockres, int level);",
            "static void ocfs2_schedule_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static void ocfs2_downconvert_on_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static inline int ocfs2_highest_compat_lock_level(int level);",
            "static unsigned int ocfs2_prepare_downconvert(struct ocfs2_lock_res *lockres,\n\t\t\t\t\t      int new_level);",
            "static int ocfs2_prepare_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\t        struct ocfs2_lock_res *lockres);",
            "static int ocfs2_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static void ocfs2_process_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *lockres);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"stackglue.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dcache.h\"\n#include \"alloc.h\"\n#include \"ocfs2_lockingver.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/quotaops.h>\n#include <linux/time.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/pagemap.h>\n#include <linux/kthread.h>\n#include <linux/mm.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic struct ocfs2_super *ocfs2_get_dentry_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_inode_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_file_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_qinfo_osb(struct ocfs2_lock_res *lockres);\nstatic int ocfs2_check_meta_downconvert(struct ocfs2_lock_res *lockres,\n\t\t\t\t\tint new_level);\nstatic void ocfs2_set_meta_lvb(struct ocfs2_lock_res *lockres);\nstatic int ocfs2_data_convert_worker(struct ocfs2_lock_res *lockres,\n\t\t\t\t     int blocking);\nstatic int ocfs2_dentry_convert_worker(struct ocfs2_lock_res *lockres,\n\t\t\t\t       int blocking);\nstatic void ocfs2_dentry_post_unlock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres);\nstatic void ocfs2_set_qinfo_lvb(struct ocfs2_lock_res *lockres);\nstatic int ocfs2_check_refcount_downconvert(struct ocfs2_lock_res *lockres,\n\t\t\t\t\t    int new_level);\nstatic int ocfs2_refcount_convert_worker(struct ocfs2_lock_res *lockres,\n\t\t\t\t\t int blocking);\nstatic inline void ocfs2_generic_handle_downconvert_action(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_convert_action(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_attach_action(struct ocfs2_lock_res *lockres);\nstatic int ocfs2_generic_handle_bast(struct ocfs2_lock_res *lockres, int level);\nstatic void ocfs2_schedule_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_downconvert_on_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic inline int ocfs2_highest_compat_lock_level(int level);\nstatic unsigned int ocfs2_prepare_downconvert(struct ocfs2_lock_res *lockres,\n\t\t\t\t\t      int new_level);\nstatic int ocfs2_prepare_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\t        struct ocfs2_lock_res *lockres);\nstatic int ocfs2_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_process_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *lockres);\n\nstatic unsigned int ocfs2_prepare_downconvert(struct ocfs2_lock_res *lockres,\n\t\t\t\t\t      int new_level)\n{\n\tassert_spin_locked(&lockres->l_lock);\n\n\tBUG_ON(lockres->l_blocking <= DLM_LOCK_NL);\n\n\tif (lockres->l_level <= new_level) {\n\t\tmlog(ML_ERROR, \"lockres %s, lvl %d <= %d, blcklst %d, mask %d, \"\n\t\t     \"type %d, flags 0x%lx, hold %d %d, act %d %d, req %d, \"\n\t\t     \"block %d, pgen %d\\n\", lockres->l_name, lockres->l_level,\n\t\t     new_level, list_empty(&lockres->l_blocked_list),\n\t\t     list_empty(&lockres->l_mask_waiters), lockres->l_type,\n\t\t     lockres->l_flags, lockres->l_ro_holders,\n\t\t     lockres->l_ex_holders, lockres->l_action,\n\t\t     lockres->l_unlock_action, lockres->l_requested,\n\t\t     lockres->l_blocking, lockres->l_pending_gen);\n\t\tBUG();\n\t}\n\n\tmlog(ML_BASTS, \"lockres %s, level %d => %d, blocking %d\\n\",\n\t     lockres->l_name, lockres->l_level, new_level, lockres->l_blocking);\n\n\tlockres->l_action = OCFS2_AST_DOWNCONVERT;\n\tlockres->l_requested = new_level;\n\tlockres_or_flags(lockres, OCFS2_LOCK_BUSY);\n\treturn lockres_set_pending(lockres);\n}"
        }
      },
      {
        "call_info": {
          "callee": "lockres_or_flags",
          "args": [
            "lockres",
            "OCFS2_LOCK_BLOCKED"
          ],
          "line": 1987
        },
        "resolved": true,
        "details": {
          "function_name": "lockres_or_flags",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlmglue.c",
          "lines": "819-822",
          "snippet": "static void lockres_or_flags(struct ocfs2_lock_res *lockres, unsigned long or)\n{\n\tlockres_set_flags(lockres, lockres->l_flags | or);\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"refcounttree.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"stackglue.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dcache.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2_lockingver.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/time.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/kthread.h>",
            "#include <linux/mm.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct ocfs2_super *ocfs2_get_dentry_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_inode_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_file_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_qinfo_osb(struct ocfs2_lock_res *lockres);",
            "static void ocfs2_set_meta_lvb(struct ocfs2_lock_res *lockres);",
            "static void ocfs2_dentry_post_unlock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres);",
            "static void ocfs2_set_qinfo_lvb(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_downconvert_action(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_convert_action(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_attach_action(struct ocfs2_lock_res *lockres);",
            "static void ocfs2_schedule_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static void ocfs2_downconvert_on_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static int ocfs2_prepare_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\t        struct ocfs2_lock_res *lockres);",
            "static int ocfs2_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static void ocfs2_process_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *lockres);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"stackglue.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dcache.h\"\n#include \"alloc.h\"\n#include \"ocfs2_lockingver.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/quotaops.h>\n#include <linux/time.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/pagemap.h>\n#include <linux/kthread.h>\n#include <linux/mm.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic struct ocfs2_super *ocfs2_get_dentry_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_inode_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_file_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_qinfo_osb(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_set_meta_lvb(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_dentry_post_unlock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres);\nstatic void ocfs2_set_qinfo_lvb(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_downconvert_action(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_convert_action(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_attach_action(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_schedule_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_downconvert_on_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic int ocfs2_prepare_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\t        struct ocfs2_lock_res *lockres);\nstatic int ocfs2_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_process_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *lockres);\n\nstatic void lockres_or_flags(struct ocfs2_lock_res *lockres, unsigned long or)\n{\n\tlockres_set_flags(lockres, lockres->l_flags | or);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock_irqsave",
          "args": [
            "&lockres->l_lock",
            "flags"
          ],
          "line": 1983
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mlog",
          "args": [
            "0",
            "\"Unlock: \\\"%s\\\" flags: 0x%lx, level: %d, act: %d\\n\"",
            "lockres->l_name",
            "lockres->l_flags",
            "lockres->l_level",
            "lockres->l_action"
          ],
          "line": 1979
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_init_mask_waiter",
          "args": [
            "&mw"
          ],
          "line": 1971
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_init_mask_waiter",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlmglue.c",
          "lines": "1301-1306",
          "snippet": "static void ocfs2_init_mask_waiter(struct ocfs2_mask_waiter *mw)\n{\n\tINIT_LIST_HEAD(&mw->mw_item);\n\tinit_completion(&mw->mw_complete);\n\tocfs2_init_start_time(mw);\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"refcounttree.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"stackglue.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dcache.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2_lockingver.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/time.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/kthread.h>",
            "#include <linux/mm.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"stackglue.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dcache.h\"\n#include \"alloc.h\"\n#include \"ocfs2_lockingver.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/quotaops.h>\n#include <linux/time.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/pagemap.h>\n#include <linux/kthread.h>\n#include <linux/mm.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic void ocfs2_init_mask_waiter(struct ocfs2_mask_waiter *mw)\n{\n\tINIT_LIST_HEAD(&mw->mw_item);\n\tinit_completion(&mw->mw_complete);\n\tocfs2_init_start_time(mw);\n}"
        }
      },
      {
        "call_info": {
          "callee": "OCFS2_SB",
          "args": [
            "file->f_mapping->host->i_sb"
          ],
          "line": 1968
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"stackglue.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dcache.h\"\n#include \"alloc.h\"\n#include \"ocfs2_lockingver.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/quotaops.h>\n#include <linux/time.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/pagemap.h>\n#include <linux/kthread.h>\n#include <linux/mm.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic struct ocfs2_super *ocfs2_get_dentry_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_inode_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_file_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_qinfo_osb(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_set_meta_lvb(struct ocfs2_lock_res *lockres);\nstatic int ocfs2_data_convert_worker(struct ocfs2_lock_res *lockres,\n\t\t\t\t     int blocking);\nstatic int ocfs2_dentry_convert_worker(struct ocfs2_lock_res *lockres,\n\t\t\t\t       int blocking);\nstatic void ocfs2_dentry_post_unlock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres);\nstatic void ocfs2_set_qinfo_lvb(struct ocfs2_lock_res *lockres);\nstatic int ocfs2_refcount_convert_worker(struct ocfs2_lock_res *lockres,\n\t\t\t\t\t int blocking);\nstatic inline void ocfs2_generic_handle_downconvert_action(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_convert_action(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_attach_action(struct ocfs2_lock_res *lockres);\nstatic int ocfs2_generic_handle_bast(struct ocfs2_lock_res *lockres, int level);\nstatic void ocfs2_schedule_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_downconvert_on_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_drop_osb_locks(struct ocfs2_super *osb);\nstatic inline int ocfs2_highest_compat_lock_level(int level);\nstatic int ocfs2_prepare_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\t        struct ocfs2_lock_res *lockres);\nstatic int ocfs2_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_process_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *lockres);\n\nvoid ocfs2_file_unlock(struct file *file)\n{\n\tint ret;\n\tunsigned int gen;\n\tunsigned long flags;\n\tstruct ocfs2_file_private *fp = file->private_data;\n\tstruct ocfs2_lock_res *lockres = &fp->fp_flock;\n\tstruct ocfs2_super *osb = OCFS2_SB(file->f_mapping->host->i_sb);\n\tstruct ocfs2_mask_waiter mw;\n\n\tocfs2_init_mask_waiter(&mw);\n\n\tif (!(lockres->l_flags & OCFS2_LOCK_ATTACHED))\n\t\treturn;\n\n\tif (lockres->l_level == DLM_LOCK_NL)\n\t\treturn;\n\n\tmlog(0, \"Unlock: \\\"%s\\\" flags: 0x%lx, level: %d, act: %d\\n\",\n\t     lockres->l_name, lockres->l_flags, lockres->l_level,\n\t     lockres->l_action);\n\n\tspin_lock_irqsave(&lockres->l_lock, flags);\n\t/*\n\t * Fake a blocking ast for the downconvert code.\n\t */\n\tlockres_or_flags(lockres, OCFS2_LOCK_BLOCKED);\n\tlockres->l_blocking = DLM_LOCK_EX;\n\n\tgen = ocfs2_prepare_downconvert(lockres, DLM_LOCK_NL);\n\tlockres_add_mask_waiter(lockres, &mw, OCFS2_LOCK_BUSY, 0);\n\tspin_unlock_irqrestore(&lockres->l_lock, flags);\n\n\tret = ocfs2_downconvert_lock(osb, lockres, DLM_LOCK_NL, 0, gen);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\treturn;\n\t}\n\n\tret = ocfs2_wait_for_mask(&mw);\n\tif (ret)\n\t\tmlog_errno(ret);\n}"
  },
  {
    "function_name": "ocfs2_file_lock",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlmglue.c",
    "lines": "1865-1959",
    "snippet": "int ocfs2_file_lock(struct file *file, int ex, int trylock)\n{\n\tint ret, level = ex ? DLM_LOCK_EX : DLM_LOCK_PR;\n\tunsigned int lkm_flags = trylock ? DLM_LKF_NOQUEUE : 0;\n\tunsigned long flags;\n\tstruct ocfs2_file_private *fp = file->private_data;\n\tstruct ocfs2_lock_res *lockres = &fp->fp_flock;\n\tstruct ocfs2_super *osb = OCFS2_SB(file->f_mapping->host->i_sb);\n\tstruct ocfs2_mask_waiter mw;\n\n\tocfs2_init_mask_waiter(&mw);\n\n\tif ((lockres->l_flags & OCFS2_LOCK_BUSY) ||\n\t    (lockres->l_level > DLM_LOCK_NL)) {\n\t\tmlog(ML_ERROR,\n\t\t     \"File lock \\\"%s\\\" has busy or locked state: flags: 0x%lx, \"\n\t\t     \"level: %u\\n\", lockres->l_name, lockres->l_flags,\n\t\t     lockres->l_level);\n\t\treturn -EINVAL;\n\t}\n\n\tspin_lock_irqsave(&lockres->l_lock, flags);\n\tif (!(lockres->l_flags & OCFS2_LOCK_ATTACHED)) {\n\t\tlockres_add_mask_waiter(lockres, &mw, OCFS2_LOCK_BUSY, 0);\n\t\tspin_unlock_irqrestore(&lockres->l_lock, flags);\n\n\t\t/*\n\t\t * Get the lock at NLMODE to start - that way we\n\t\t * can cancel the upconvert request if need be.\n\t\t */\n\t\tret = ocfs2_lock_create(osb, lockres, DLM_LOCK_NL, 0);\n\t\tif (ret < 0) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\tret = ocfs2_wait_for_mask(&mw);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\t\tspin_lock_irqsave(&lockres->l_lock, flags);\n\t}\n\n\tlockres->l_action = OCFS2_AST_CONVERT;\n\tlkm_flags |= DLM_LKF_CONVERT;\n\tlockres->l_requested = level;\n\tlockres_or_flags(lockres, OCFS2_LOCK_BUSY);\n\n\tlockres_add_mask_waiter(lockres, &mw, OCFS2_LOCK_BUSY, 0);\n\tspin_unlock_irqrestore(&lockres->l_lock, flags);\n\n\tret = ocfs2_dlm_lock(osb->cconn, level, &lockres->l_lksb, lkm_flags,\n\t\t\t     lockres->l_name, OCFS2_LOCK_ID_MAX_LEN - 1);\n\tif (ret) {\n\t\tif (!trylock || (ret != -EAGAIN)) {\n\t\t\tocfs2_log_dlm_error(\"ocfs2_dlm_lock\", ret, lockres);\n\t\t\tret = -EINVAL;\n\t\t}\n\n\t\tocfs2_recover_from_dlm_error(lockres, 1);\n\t\tlockres_remove_mask_waiter(lockres, &mw);\n\t\tgoto out;\n\t}\n\n\tret = ocfs2_wait_for_mask_interruptible(&mw, lockres);\n\tif (ret == -ERESTARTSYS) {\n\t\t/*\n\t\t * Userspace can cause deadlock itself with\n\t\t * flock(). Current behavior locally is to allow the\n\t\t * deadlock, but abort the system call if a signal is\n\t\t * received. We follow this example, otherwise a\n\t\t * poorly written program could sit in kernel until\n\t\t * reboot.\n\t\t *\n\t\t * Handling this is a bit more complicated for Ocfs2\n\t\t * though. We can't exit this function with an\n\t\t * outstanding lock request, so a cancel convert is\n\t\t * required. We intentionally overwrite 'ret' - if the\n\t\t * cancel fails and the lock was granted, it's easier\n\t\t * to just bubble success back up to the user.\n\t\t */\n\t\tret = ocfs2_flock_handle_signal(lockres, level);\n\t} else if (!ret && (level > lockres->l_level)) {\n\t\t/* Trylock failed asynchronously */\n\t\tBUG_ON(!trylock);\n\t\tret = -EAGAIN;\n\t}\n\nout:\n\n\tmlog(0, \"Lock: \\\"%s\\\" ex: %d, trylock: %d, returns: %d\\n\",\n\t     lockres->l_name, ex, trylock, ret);\n\treturn ret;\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"refcounttree.h\"",
      "#include \"quota.h\"",
      "#include \"uptodate.h\"",
      "#include \"super.h\"",
      "#include \"slot_map.h\"",
      "#include \"stackglue.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"heartbeat.h\"",
      "#include \"file.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"dcache.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2_lockingver.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/time.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/kthread.h>",
      "#include <linux/mm.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct ocfs2_super *ocfs2_get_dentry_osb(struct ocfs2_lock_res *lockres);",
      "static struct ocfs2_super *ocfs2_get_inode_osb(struct ocfs2_lock_res *lockres);",
      "static struct ocfs2_super *ocfs2_get_file_osb(struct ocfs2_lock_res *lockres);",
      "static struct ocfs2_super *ocfs2_get_qinfo_osb(struct ocfs2_lock_res *lockres);",
      "static void ocfs2_set_meta_lvb(struct ocfs2_lock_res *lockres);",
      "static void ocfs2_dentry_post_unlock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres);",
      "static void ocfs2_set_qinfo_lvb(struct ocfs2_lock_res *lockres);",
      "static inline void ocfs2_generic_handle_downconvert_action(struct ocfs2_lock_res *lockres);",
      "static inline void ocfs2_generic_handle_convert_action(struct ocfs2_lock_res *lockres);",
      "static inline void ocfs2_generic_handle_attach_action(struct ocfs2_lock_res *lockres);",
      "static int ocfs2_generic_handle_bast(struct ocfs2_lock_res *lockres, int level);",
      "static void ocfs2_schedule_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);",
      "static inline void ocfs2_recover_from_dlm_error(struct ocfs2_lock_res *lockres,\n\t\t\t\t\t\tint convert);",
      "static void ocfs2_downconvert_on_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);",
      "static void ocfs2_drop_osb_locks(struct ocfs2_super *osb);",
      "static inline int ocfs2_highest_compat_lock_level(int level);",
      "static int ocfs2_prepare_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\t        struct ocfs2_lock_res *lockres);",
      "static int ocfs2_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres);",
      "static void ocfs2_process_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *lockres);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mlog",
          "args": [
            "0",
            "\"Lock: \\\"%s\\\" ex: %d, trylock: %d, returns: %d\\n\"",
            "lockres->l_name",
            "ex",
            "trylock",
            "ret"
          ],
          "line": 1956
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!trylock"
          ],
          "line": 1950
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_flock_handle_signal",
          "args": [
            "lockres",
            "level"
          ],
          "line": 1947
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_flock_handle_signal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlmglue.c",
          "lines": "1797-1842",
          "snippet": "static int ocfs2_flock_handle_signal(struct ocfs2_lock_res *lockres,\n\t\t\t\t     int level)\n{\n\tint ret;\n\tstruct ocfs2_super *osb = ocfs2_get_lockres_osb(lockres);\n\tunsigned long flags;\n\tstruct ocfs2_mask_waiter mw;\n\n\tocfs2_init_mask_waiter(&mw);\n\nretry_cancel:\n\tspin_lock_irqsave(&lockres->l_lock, flags);\n\tif (lockres->l_flags & OCFS2_LOCK_BUSY) {\n\t\tret = ocfs2_prepare_cancel_convert(osb, lockres);\n\t\tif (ret) {\n\t\t\tspin_unlock_irqrestore(&lockres->l_lock, flags);\n\t\t\tret = ocfs2_cancel_convert(osb, lockres);\n\t\t\tif (ret < 0) {\n\t\t\t\tmlog_errno(ret);\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tgoto retry_cancel;\n\t\t}\n\t\tlockres_add_mask_waiter(lockres, &mw, OCFS2_LOCK_BUSY, 0);\n\t\tspin_unlock_irqrestore(&lockres->l_lock, flags);\n\n\t\tocfs2_wait_for_mask(&mw);\n\t\tgoto retry_cancel;\n\t}\n\n\tret = -ERESTARTSYS;\n\t/*\n\t * We may still have gotten the lock, in which case there's no\n\t * point to restarting the syscall.\n\t */\n\tif (lockres->l_level == level)\n\t\tret = 0;\n\n\tmlog(0, \"Cancel returning %d. flags: 0x%lx, level: %d, act: %d\\n\", ret,\n\t     lockres->l_flags, lockres->l_level, lockres->l_action);\n\n\tspin_unlock_irqrestore(&lockres->l_lock, flags);\n\nout:\n\treturn ret;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"refcounttree.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"stackglue.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dcache.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2_lockingver.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/time.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/kthread.h>",
            "#include <linux/mm.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct ocfs2_super *ocfs2_get_dentry_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_inode_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_file_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_qinfo_osb(struct ocfs2_lock_res *lockres);",
            "static void ocfs2_set_meta_lvb(struct ocfs2_lock_res *lockres);",
            "static void ocfs2_dentry_post_unlock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres);",
            "static void ocfs2_set_qinfo_lvb(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_downconvert_action(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_convert_action(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_attach_action(struct ocfs2_lock_res *lockres);",
            "static int ocfs2_generic_handle_bast(struct ocfs2_lock_res *lockres, int level);",
            "static void ocfs2_schedule_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static void ocfs2_downconvert_on_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static void ocfs2_drop_osb_locks(struct ocfs2_super *osb);",
            "static inline int ocfs2_highest_compat_lock_level(int level);",
            "static int ocfs2_prepare_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\t        struct ocfs2_lock_res *lockres);",
            "static int ocfs2_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static void ocfs2_process_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *lockres);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"stackglue.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dcache.h\"\n#include \"alloc.h\"\n#include \"ocfs2_lockingver.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/quotaops.h>\n#include <linux/time.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/pagemap.h>\n#include <linux/kthread.h>\n#include <linux/mm.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic struct ocfs2_super *ocfs2_get_dentry_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_inode_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_file_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_qinfo_osb(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_set_meta_lvb(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_dentry_post_unlock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres);\nstatic void ocfs2_set_qinfo_lvb(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_downconvert_action(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_convert_action(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_attach_action(struct ocfs2_lock_res *lockres);\nstatic int ocfs2_generic_handle_bast(struct ocfs2_lock_res *lockres, int level);\nstatic void ocfs2_schedule_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_downconvert_on_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_drop_osb_locks(struct ocfs2_super *osb);\nstatic inline int ocfs2_highest_compat_lock_level(int level);\nstatic int ocfs2_prepare_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\t        struct ocfs2_lock_res *lockres);\nstatic int ocfs2_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_process_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *lockres);\n\nstatic int ocfs2_flock_handle_signal(struct ocfs2_lock_res *lockres,\n\t\t\t\t     int level)\n{\n\tint ret;\n\tstruct ocfs2_super *osb = ocfs2_get_lockres_osb(lockres);\n\tunsigned long flags;\n\tstruct ocfs2_mask_waiter mw;\n\n\tocfs2_init_mask_waiter(&mw);\n\nretry_cancel:\n\tspin_lock_irqsave(&lockres->l_lock, flags);\n\tif (lockres->l_flags & OCFS2_LOCK_BUSY) {\n\t\tret = ocfs2_prepare_cancel_convert(osb, lockres);\n\t\tif (ret) {\n\t\t\tspin_unlock_irqrestore(&lockres->l_lock, flags);\n\t\t\tret = ocfs2_cancel_convert(osb, lockres);\n\t\t\tif (ret < 0) {\n\t\t\t\tmlog_errno(ret);\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tgoto retry_cancel;\n\t\t}\n\t\tlockres_add_mask_waiter(lockres, &mw, OCFS2_LOCK_BUSY, 0);\n\t\tspin_unlock_irqrestore(&lockres->l_lock, flags);\n\n\t\tocfs2_wait_for_mask(&mw);\n\t\tgoto retry_cancel;\n\t}\n\n\tret = -ERESTARTSYS;\n\t/*\n\t * We may still have gotten the lock, in which case there's no\n\t * point to restarting the syscall.\n\t */\n\tif (lockres->l_level == level)\n\t\tret = 0;\n\n\tmlog(0, \"Cancel returning %d. flags: 0x%lx, level: %d, act: %d\\n\", ret,\n\t     lockres->l_flags, lockres->l_level, lockres->l_action);\n\n\tspin_unlock_irqrestore(&lockres->l_lock, flags);\n\nout:\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_wait_for_mask_interruptible",
          "args": [
            "&mw",
            "lockres"
          ],
          "line": 1930
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_wait_for_mask_interruptible",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlmglue.c",
          "lines": "1363-1376",
          "snippet": "static int ocfs2_wait_for_mask_interruptible(struct ocfs2_mask_waiter *mw,\n\t\t\t\t\t     struct ocfs2_lock_res *lockres)\n{\n\tint ret;\n\n\tret = wait_for_completion_interruptible(&mw->mw_complete);\n\tif (ret)\n\t\tlockres_remove_mask_waiter(lockres, mw);\n\telse\n\t\tret = mw->mw_status;\n\t/* Re-arm the completion in case we want to wait on it again */\n\treinit_completion(&mw->mw_complete);\n\treturn ret;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"refcounttree.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"stackglue.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dcache.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2_lockingver.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/time.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/kthread.h>",
            "#include <linux/mm.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct ocfs2_super *ocfs2_get_dentry_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_inode_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_file_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_qinfo_osb(struct ocfs2_lock_res *lockres);",
            "static void ocfs2_set_meta_lvb(struct ocfs2_lock_res *lockres);",
            "static void ocfs2_dentry_post_unlock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres);",
            "static void ocfs2_set_qinfo_lvb(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_downconvert_action(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_convert_action(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_attach_action(struct ocfs2_lock_res *lockres);",
            "static void ocfs2_schedule_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static void ocfs2_downconvert_on_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static int ocfs2_prepare_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\t        struct ocfs2_lock_res *lockres);",
            "static int ocfs2_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static void ocfs2_process_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *lockres);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"stackglue.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dcache.h\"\n#include \"alloc.h\"\n#include \"ocfs2_lockingver.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/quotaops.h>\n#include <linux/time.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/pagemap.h>\n#include <linux/kthread.h>\n#include <linux/mm.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic struct ocfs2_super *ocfs2_get_dentry_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_inode_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_file_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_qinfo_osb(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_set_meta_lvb(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_dentry_post_unlock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres);\nstatic void ocfs2_set_qinfo_lvb(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_downconvert_action(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_convert_action(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_attach_action(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_schedule_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_downconvert_on_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic int ocfs2_prepare_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\t        struct ocfs2_lock_res *lockres);\nstatic int ocfs2_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_process_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *lockres);\n\nstatic int ocfs2_wait_for_mask_interruptible(struct ocfs2_mask_waiter *mw,\n\t\t\t\t\t     struct ocfs2_lock_res *lockres)\n{\n\tint ret;\n\n\tret = wait_for_completion_interruptible(&mw->mw_complete);\n\tif (ret)\n\t\tlockres_remove_mask_waiter(lockres, mw);\n\telse\n\t\tret = mw->mw_status;\n\t/* Re-arm the completion in case we want to wait on it again */\n\treinit_completion(&mw->mw_complete);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "lockres_remove_mask_waiter",
          "args": [
            "lockres",
            "&mw"
          ],
          "line": 1926
        },
        "resolved": true,
        "details": {
          "function_name": "lockres_remove_mask_waiter",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlmglue.c",
          "lines": "1349-1361",
          "snippet": "static int lockres_remove_mask_waiter(struct ocfs2_lock_res *lockres,\n\t\t\t\t      struct ocfs2_mask_waiter *mw)\n{\n\tunsigned long flags;\n\tint ret = 0;\n\n\tspin_lock_irqsave(&lockres->l_lock, flags);\n\tret = __lockres_remove_mask_waiter(lockres, mw);\n\tspin_unlock_irqrestore(&lockres->l_lock, flags);\n\n\treturn ret;\n\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"refcounttree.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"stackglue.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dcache.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2_lockingver.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/time.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/kthread.h>",
            "#include <linux/mm.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct ocfs2_super *ocfs2_get_dentry_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_inode_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_file_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_qinfo_osb(struct ocfs2_lock_res *lockres);",
            "static void ocfs2_set_meta_lvb(struct ocfs2_lock_res *lockres);",
            "static void ocfs2_dentry_post_unlock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres);",
            "static void ocfs2_set_qinfo_lvb(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_downconvert_action(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_convert_action(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_attach_action(struct ocfs2_lock_res *lockres);",
            "static void ocfs2_schedule_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static void ocfs2_downconvert_on_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static int ocfs2_prepare_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\t        struct ocfs2_lock_res *lockres);",
            "static int ocfs2_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static void ocfs2_process_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *lockres);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"stackglue.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dcache.h\"\n#include \"alloc.h\"\n#include \"ocfs2_lockingver.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/quotaops.h>\n#include <linux/time.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/pagemap.h>\n#include <linux/kthread.h>\n#include <linux/mm.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic struct ocfs2_super *ocfs2_get_dentry_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_inode_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_file_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_qinfo_osb(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_set_meta_lvb(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_dentry_post_unlock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres);\nstatic void ocfs2_set_qinfo_lvb(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_downconvert_action(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_convert_action(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_attach_action(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_schedule_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_downconvert_on_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic int ocfs2_prepare_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\t        struct ocfs2_lock_res *lockres);\nstatic int ocfs2_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_process_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *lockres);\n\nstatic int lockres_remove_mask_waiter(struct ocfs2_lock_res *lockres,\n\t\t\t\t      struct ocfs2_mask_waiter *mw)\n{\n\tunsigned long flags;\n\tint ret = 0;\n\n\tspin_lock_irqsave(&lockres->l_lock, flags);\n\tret = __lockres_remove_mask_waiter(lockres, mw);\n\tspin_unlock_irqrestore(&lockres->l_lock, flags);\n\n\treturn ret;\n\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_recover_from_dlm_error",
          "args": [
            "lockres",
            "1"
          ],
          "line": 1925
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_recover_from_dlm_error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlmglue.c",
          "lines": "1199-1214",
          "snippet": "static inline void ocfs2_recover_from_dlm_error(struct ocfs2_lock_res *lockres,\n\t\t\t\t\t\tint convert)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&lockres->l_lock, flags);\n\tlockres_clear_flags(lockres, OCFS2_LOCK_BUSY);\n\tlockres_clear_flags(lockres, OCFS2_LOCK_UPCONVERT_FINISHING);\n\tif (convert)\n\t\tlockres->l_action = OCFS2_AST_INVALID;\n\telse\n\t\tlockres->l_unlock_action = OCFS2_UNLOCK_INVALID;\n\tspin_unlock_irqrestore(&lockres->l_lock, flags);\n\n\twake_up(&lockres->l_event);\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"refcounttree.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"stackglue.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dcache.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2_lockingver.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/time.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/kthread.h>",
            "#include <linux/mm.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct ocfs2_super *ocfs2_get_dentry_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_inode_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_file_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_qinfo_osb(struct ocfs2_lock_res *lockres);",
            "static void ocfs2_set_meta_lvb(struct ocfs2_lock_res *lockres);",
            "static void ocfs2_dentry_post_unlock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres);",
            "static void ocfs2_set_qinfo_lvb(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_downconvert_action(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_convert_action(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_attach_action(struct ocfs2_lock_res *lockres);",
            "static void ocfs2_schedule_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_recover_from_dlm_error(struct ocfs2_lock_res *lockres,\n\t\t\t\t\t\tint convert);",
            "static void ocfs2_downconvert_on_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static int ocfs2_prepare_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\t        struct ocfs2_lock_res *lockres);",
            "static int ocfs2_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static void ocfs2_process_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *lockres);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"stackglue.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dcache.h\"\n#include \"alloc.h\"\n#include \"ocfs2_lockingver.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/quotaops.h>\n#include <linux/time.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/pagemap.h>\n#include <linux/kthread.h>\n#include <linux/mm.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic struct ocfs2_super *ocfs2_get_dentry_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_inode_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_file_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_qinfo_osb(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_set_meta_lvb(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_dentry_post_unlock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres);\nstatic void ocfs2_set_qinfo_lvb(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_downconvert_action(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_convert_action(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_attach_action(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_schedule_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_recover_from_dlm_error(struct ocfs2_lock_res *lockres,\n\t\t\t\t\t\tint convert);\nstatic void ocfs2_downconvert_on_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic int ocfs2_prepare_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\t        struct ocfs2_lock_res *lockres);\nstatic int ocfs2_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_process_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *lockres);\n\nstatic inline void ocfs2_recover_from_dlm_error(struct ocfs2_lock_res *lockres,\n\t\t\t\t\t\tint convert)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&lockres->l_lock, flags);\n\tlockres_clear_flags(lockres, OCFS2_LOCK_BUSY);\n\tlockres_clear_flags(lockres, OCFS2_LOCK_UPCONVERT_FINISHING);\n\tif (convert)\n\t\tlockres->l_action = OCFS2_AST_INVALID;\n\telse\n\t\tlockres->l_unlock_action = OCFS2_UNLOCK_INVALID;\n\tspin_unlock_irqrestore(&lockres->l_lock, flags);\n\n\twake_up(&lockres->l_event);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_log_dlm_error",
          "args": [
            "\"ocfs2_dlm_lock\"",
            "ret",
            "lockres"
          ],
          "line": 1921
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_dlm_lock",
          "args": [
            "osb->cconn",
            "level",
            "&lockres->l_lksb",
            "lkm_flags",
            "lockres->l_name",
            "OCFS2_LOCK_ID_MAX_LEN - 1"
          ],
          "line": 1917
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_dlm_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/stackglue.c",
          "lines": "241-254",
          "snippet": "int ocfs2_dlm_lock(struct ocfs2_cluster_connection *conn,\n\t\t   int mode,\n\t\t   struct ocfs2_dlm_lksb *lksb,\n\t\t   u32 flags,\n\t\t   void *name,\n\t\t   unsigned int namelen)\n{\n\tif (!lksb->lksb_conn)\n\t\tlksb->lksb_conn = conn;\n\telse\n\t\tBUG_ON(lksb->lksb_conn != conn);\n\treturn active_stack->sp_ops->dlm_lock(conn, mode, lksb, flags,\n\t\t\t\t\t      name, namelen);\n}",
          "includes": [
            "#include \"stackglue.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include <linux/sysctl.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/fs.h>",
            "#include <linux/kmod.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/list.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct ocfs2_stack_plugin *active_stack;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"stackglue.h\"\n#include \"ocfs2_fs.h\"\n#include <linux/sysctl.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/fs.h>\n#include <linux/kmod.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/spinlock.h>\n#include <linux/list.h>\n\nstatic struct ocfs2_stack_plugin *active_stack;\n\nint ocfs2_dlm_lock(struct ocfs2_cluster_connection *conn,\n\t\t   int mode,\n\t\t   struct ocfs2_dlm_lksb *lksb,\n\t\t   u32 flags,\n\t\t   void *name,\n\t\t   unsigned int namelen)\n{\n\tif (!lksb->lksb_conn)\n\t\tlksb->lksb_conn = conn;\n\telse\n\t\tBUG_ON(lksb->lksb_conn != conn);\n\treturn active_stack->sp_ops->dlm_lock(conn, mode, lksb, flags,\n\t\t\t\t\t      name, namelen);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock_irqrestore",
          "args": [
            "&lockres->l_lock",
            "flags"
          ],
          "line": 1915
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lockres_add_mask_waiter",
          "args": [
            "lockres",
            "&mw",
            "OCFS2_LOCK_BUSY",
            "0"
          ],
          "line": 1914
        },
        "resolved": true,
        "details": {
          "function_name": "lockres_add_mask_waiter",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlmglue.c",
          "lines": "1316-1328",
          "snippet": "static void lockres_add_mask_waiter(struct ocfs2_lock_res *lockres,\n\t\t\t\t    struct ocfs2_mask_waiter *mw,\n\t\t\t\t    unsigned long mask,\n\t\t\t\t    unsigned long goal)\n{\n\tBUG_ON(!list_empty(&mw->mw_item));\n\n\tassert_spin_locked(&lockres->l_lock);\n\n\tlist_add_tail(&mw->mw_item, &lockres->l_mask_waiters);\n\tmw->mw_mask = mask;\n\tmw->mw_goal = goal;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"refcounttree.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"stackglue.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dcache.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2_lockingver.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/time.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/kthread.h>",
            "#include <linux/mm.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct ocfs2_super *ocfs2_get_dentry_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_inode_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_file_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_qinfo_osb(struct ocfs2_lock_res *lockres);",
            "static void ocfs2_set_meta_lvb(struct ocfs2_lock_res *lockres);",
            "static void ocfs2_dentry_post_unlock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres);",
            "static void ocfs2_set_qinfo_lvb(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_downconvert_action(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_convert_action(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_attach_action(struct ocfs2_lock_res *lockres);",
            "static void ocfs2_schedule_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static void ocfs2_downconvert_on_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static int ocfs2_prepare_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\t        struct ocfs2_lock_res *lockres);",
            "static int ocfs2_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static void ocfs2_process_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *lockres);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"stackglue.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dcache.h\"\n#include \"alloc.h\"\n#include \"ocfs2_lockingver.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/quotaops.h>\n#include <linux/time.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/pagemap.h>\n#include <linux/kthread.h>\n#include <linux/mm.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic struct ocfs2_super *ocfs2_get_dentry_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_inode_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_file_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_qinfo_osb(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_set_meta_lvb(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_dentry_post_unlock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres);\nstatic void ocfs2_set_qinfo_lvb(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_downconvert_action(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_convert_action(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_attach_action(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_schedule_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_downconvert_on_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic int ocfs2_prepare_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\t        struct ocfs2_lock_res *lockres);\nstatic int ocfs2_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_process_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *lockres);\n\nstatic void lockres_add_mask_waiter(struct ocfs2_lock_res *lockres,\n\t\t\t\t    struct ocfs2_mask_waiter *mw,\n\t\t\t\t    unsigned long mask,\n\t\t\t\t    unsigned long goal)\n{\n\tBUG_ON(!list_empty(&mw->mw_item));\n\n\tassert_spin_locked(&lockres->l_lock);\n\n\tlist_add_tail(&mw->mw_item, &lockres->l_mask_waiters);\n\tmw->mw_mask = mask;\n\tmw->mw_goal = goal;\n}"
        }
      },
      {
        "call_info": {
          "callee": "lockres_or_flags",
          "args": [
            "lockres",
            "OCFS2_LOCK_BUSY"
          ],
          "line": 1912
        },
        "resolved": true,
        "details": {
          "function_name": "lockres_or_flags",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlmglue.c",
          "lines": "819-822",
          "snippet": "static void lockres_or_flags(struct ocfs2_lock_res *lockres, unsigned long or)\n{\n\tlockres_set_flags(lockres, lockres->l_flags | or);\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"refcounttree.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"stackglue.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dcache.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2_lockingver.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/time.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/kthread.h>",
            "#include <linux/mm.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct ocfs2_super *ocfs2_get_dentry_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_inode_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_file_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_qinfo_osb(struct ocfs2_lock_res *lockres);",
            "static void ocfs2_set_meta_lvb(struct ocfs2_lock_res *lockres);",
            "static void ocfs2_dentry_post_unlock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres);",
            "static void ocfs2_set_qinfo_lvb(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_downconvert_action(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_convert_action(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_attach_action(struct ocfs2_lock_res *lockres);",
            "static void ocfs2_schedule_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static void ocfs2_downconvert_on_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static int ocfs2_prepare_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\t        struct ocfs2_lock_res *lockres);",
            "static int ocfs2_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static void ocfs2_process_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *lockres);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"stackglue.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dcache.h\"\n#include \"alloc.h\"\n#include \"ocfs2_lockingver.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/quotaops.h>\n#include <linux/time.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/pagemap.h>\n#include <linux/kthread.h>\n#include <linux/mm.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic struct ocfs2_super *ocfs2_get_dentry_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_inode_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_file_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_qinfo_osb(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_set_meta_lvb(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_dentry_post_unlock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres);\nstatic void ocfs2_set_qinfo_lvb(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_downconvert_action(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_convert_action(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_attach_action(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_schedule_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_downconvert_on_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic int ocfs2_prepare_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\t        struct ocfs2_lock_res *lockres);\nstatic int ocfs2_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_process_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *lockres);\n\nstatic void lockres_or_flags(struct ocfs2_lock_res *lockres, unsigned long or)\n{\n\tlockres_set_flags(lockres, lockres->l_flags | or);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock_irqsave",
          "args": [
            "&lockres->l_lock",
            "flags"
          ],
          "line": 1906
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 1903
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_wait_for_mask",
          "args": [
            "&mw"
          ],
          "line": 1901
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_wait_for_mask",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlmglue.c",
          "lines": "1308-1314",
          "snippet": "static int ocfs2_wait_for_mask(struct ocfs2_mask_waiter *mw)\n{\n\twait_for_completion(&mw->mw_complete);\n\t/* Re-arm the completion in case we want to wait on it again */\n\treinit_completion(&mw->mw_complete);\n\treturn mw->mw_status;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"refcounttree.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"stackglue.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dcache.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2_lockingver.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/time.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/kthread.h>",
            "#include <linux/mm.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"stackglue.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dcache.h\"\n#include \"alloc.h\"\n#include \"ocfs2_lockingver.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/quotaops.h>\n#include <linux/time.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/pagemap.h>\n#include <linux/kthread.h>\n#include <linux/mm.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic int ocfs2_wait_for_mask(struct ocfs2_mask_waiter *mw)\n{\n\twait_for_completion(&mw->mw_complete);\n\t/* Re-arm the completion in case we want to wait on it again */\n\treinit_completion(&mw->mw_complete);\n\treturn mw->mw_status;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 1897
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_lock_create",
          "args": [
            "osb",
            "lockres",
            "DLM_LOCK_NL",
            "0"
          ],
          "line": 1895
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_lock_create",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlmglue.c",
          "lines": "1220-1261",
          "snippet": "static int ocfs2_lock_create(struct ocfs2_super *osb,\n\t\t\t     struct ocfs2_lock_res *lockres,\n\t\t\t     int level,\n\t\t\t     u32 dlm_flags)\n{\n\tint ret = 0;\n\tunsigned long flags;\n\tunsigned int gen;\n\n\tmlog(0, \"lock %s, level = %d, flags = %u\\n\", lockres->l_name, level,\n\t     dlm_flags);\n\n\tspin_lock_irqsave(&lockres->l_lock, flags);\n\tif ((lockres->l_flags & OCFS2_LOCK_ATTACHED) ||\n\t    (lockres->l_flags & OCFS2_LOCK_BUSY)) {\n\t\tspin_unlock_irqrestore(&lockres->l_lock, flags);\n\t\tgoto bail;\n\t}\n\n\tlockres->l_action = OCFS2_AST_ATTACH;\n\tlockres->l_requested = level;\n\tlockres_or_flags(lockres, OCFS2_LOCK_BUSY);\n\tgen = lockres_set_pending(lockres);\n\tspin_unlock_irqrestore(&lockres->l_lock, flags);\n\n\tret = ocfs2_dlm_lock(osb->cconn,\n\t\t\t     level,\n\t\t\t     &lockres->l_lksb,\n\t\t\t     dlm_flags,\n\t\t\t     lockres->l_name,\n\t\t\t     OCFS2_LOCK_ID_MAX_LEN - 1);\n\tlockres_clear_pending(lockres, gen, osb);\n\tif (ret) {\n\t\tocfs2_log_dlm_error(\"ocfs2_dlm_lock\", ret, lockres);\n\t\tocfs2_recover_from_dlm_error(lockres, 1);\n\t}\n\n\tmlog(0, \"lock %s, return from ocfs2_dlm_lock\\n\", lockres->l_name);\n\nbail:\n\treturn ret;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"refcounttree.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"stackglue.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dcache.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2_lockingver.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/time.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/kthread.h>",
            "#include <linux/mm.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct ocfs2_super *ocfs2_get_dentry_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_inode_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_file_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_qinfo_osb(struct ocfs2_lock_res *lockres);",
            "static void ocfs2_set_meta_lvb(struct ocfs2_lock_res *lockres);",
            "static void ocfs2_dentry_post_unlock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres);",
            "static void ocfs2_set_qinfo_lvb(struct ocfs2_lock_res *lockres);",
            "static int ocfs2_lock_create(struct ocfs2_super *osb,\n\t\t\t     struct ocfs2_lock_res *lockres,\n\t\t\t     int level,\n\t\t\t     u32 dlm_flags);",
            "static inline void ocfs2_generic_handle_downconvert_action(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_convert_action(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_attach_action(struct ocfs2_lock_res *lockres);",
            "static int ocfs2_generic_handle_bast(struct ocfs2_lock_res *lockres, int level);",
            "static void ocfs2_schedule_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static void ocfs2_downconvert_on_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static void ocfs2_drop_osb_locks(struct ocfs2_super *osb);",
            "static inline int ocfs2_highest_compat_lock_level(int level);",
            "static int ocfs2_prepare_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\t        struct ocfs2_lock_res *lockres);",
            "static int ocfs2_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static void ocfs2_process_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *lockres);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"stackglue.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dcache.h\"\n#include \"alloc.h\"\n#include \"ocfs2_lockingver.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/quotaops.h>\n#include <linux/time.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/pagemap.h>\n#include <linux/kthread.h>\n#include <linux/mm.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic struct ocfs2_super *ocfs2_get_dentry_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_inode_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_file_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_qinfo_osb(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_set_meta_lvb(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_dentry_post_unlock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres);\nstatic void ocfs2_set_qinfo_lvb(struct ocfs2_lock_res *lockres);\nstatic int ocfs2_lock_create(struct ocfs2_super *osb,\n\t\t\t     struct ocfs2_lock_res *lockres,\n\t\t\t     int level,\n\t\t\t     u32 dlm_flags);\nstatic inline void ocfs2_generic_handle_downconvert_action(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_convert_action(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_attach_action(struct ocfs2_lock_res *lockres);\nstatic int ocfs2_generic_handle_bast(struct ocfs2_lock_res *lockres, int level);\nstatic void ocfs2_schedule_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_downconvert_on_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_drop_osb_locks(struct ocfs2_super *osb);\nstatic inline int ocfs2_highest_compat_lock_level(int level);\nstatic int ocfs2_prepare_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\t        struct ocfs2_lock_res *lockres);\nstatic int ocfs2_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_process_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *lockres);\n\nstatic int ocfs2_lock_create(struct ocfs2_super *osb,\n\t\t\t     struct ocfs2_lock_res *lockres,\n\t\t\t     int level,\n\t\t\t     u32 dlm_flags)\n{\n\tint ret = 0;\n\tunsigned long flags;\n\tunsigned int gen;\n\n\tmlog(0, \"lock %s, level = %d, flags = %u\\n\", lockres->l_name, level,\n\t     dlm_flags);\n\n\tspin_lock_irqsave(&lockres->l_lock, flags);\n\tif ((lockres->l_flags & OCFS2_LOCK_ATTACHED) ||\n\t    (lockres->l_flags & OCFS2_LOCK_BUSY)) {\n\t\tspin_unlock_irqrestore(&lockres->l_lock, flags);\n\t\tgoto bail;\n\t}\n\n\tlockres->l_action = OCFS2_AST_ATTACH;\n\tlockres->l_requested = level;\n\tlockres_or_flags(lockres, OCFS2_LOCK_BUSY);\n\tgen = lockres_set_pending(lockres);\n\tspin_unlock_irqrestore(&lockres->l_lock, flags);\n\n\tret = ocfs2_dlm_lock(osb->cconn,\n\t\t\t     level,\n\t\t\t     &lockres->l_lksb,\n\t\t\t     dlm_flags,\n\t\t\t     lockres->l_name,\n\t\t\t     OCFS2_LOCK_ID_MAX_LEN - 1);\n\tlockres_clear_pending(lockres, gen, osb);\n\tif (ret) {\n\t\tocfs2_log_dlm_error(\"ocfs2_dlm_lock\", ret, lockres);\n\t\tocfs2_recover_from_dlm_error(lockres, 1);\n\t}\n\n\tmlog(0, \"lock %s, return from ocfs2_dlm_lock\\n\", lockres->l_name);\n\nbail:\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock_irqrestore",
          "args": [
            "&lockres->l_lock",
            "flags"
          ],
          "line": 1889
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock_irqsave",
          "args": [
            "&lockres->l_lock",
            "flags"
          ],
          "line": 1886
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mlog",
          "args": [
            "ML_ERROR",
            "\"File lock \\\"%s\\\" has busy or locked state: flags: 0x%lx, \"\n\t\t     \"level: %u\\n\"",
            "lockres->l_name",
            "lockres->l_flags",
            "lockres->l_level"
          ],
          "line": 1879
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_init_mask_waiter",
          "args": [
            "&mw"
          ],
          "line": 1875
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_init_mask_waiter",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlmglue.c",
          "lines": "1301-1306",
          "snippet": "static void ocfs2_init_mask_waiter(struct ocfs2_mask_waiter *mw)\n{\n\tINIT_LIST_HEAD(&mw->mw_item);\n\tinit_completion(&mw->mw_complete);\n\tocfs2_init_start_time(mw);\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"refcounttree.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"stackglue.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dcache.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2_lockingver.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/time.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/kthread.h>",
            "#include <linux/mm.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"stackglue.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dcache.h\"\n#include \"alloc.h\"\n#include \"ocfs2_lockingver.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/quotaops.h>\n#include <linux/time.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/pagemap.h>\n#include <linux/kthread.h>\n#include <linux/mm.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic void ocfs2_init_mask_waiter(struct ocfs2_mask_waiter *mw)\n{\n\tINIT_LIST_HEAD(&mw->mw_item);\n\tinit_completion(&mw->mw_complete);\n\tocfs2_init_start_time(mw);\n}"
        }
      },
      {
        "call_info": {
          "callee": "OCFS2_SB",
          "args": [
            "file->f_mapping->host->i_sb"
          ],
          "line": 1872
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"stackglue.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dcache.h\"\n#include \"alloc.h\"\n#include \"ocfs2_lockingver.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/quotaops.h>\n#include <linux/time.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/pagemap.h>\n#include <linux/kthread.h>\n#include <linux/mm.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic struct ocfs2_super *ocfs2_get_dentry_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_inode_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_file_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_qinfo_osb(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_set_meta_lvb(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_dentry_post_unlock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres);\nstatic void ocfs2_set_qinfo_lvb(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_downconvert_action(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_convert_action(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_attach_action(struct ocfs2_lock_res *lockres);\nstatic int ocfs2_generic_handle_bast(struct ocfs2_lock_res *lockres, int level);\nstatic void ocfs2_schedule_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_recover_from_dlm_error(struct ocfs2_lock_res *lockres,\n\t\t\t\t\t\tint convert);\nstatic void ocfs2_downconvert_on_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_drop_osb_locks(struct ocfs2_super *osb);\nstatic inline int ocfs2_highest_compat_lock_level(int level);\nstatic int ocfs2_prepare_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\t        struct ocfs2_lock_res *lockres);\nstatic int ocfs2_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_process_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *lockres);\n\nint ocfs2_file_lock(struct file *file, int ex, int trylock)\n{\n\tint ret, level = ex ? DLM_LOCK_EX : DLM_LOCK_PR;\n\tunsigned int lkm_flags = trylock ? DLM_LKF_NOQUEUE : 0;\n\tunsigned long flags;\n\tstruct ocfs2_file_private *fp = file->private_data;\n\tstruct ocfs2_lock_res *lockres = &fp->fp_flock;\n\tstruct ocfs2_super *osb = OCFS2_SB(file->f_mapping->host->i_sb);\n\tstruct ocfs2_mask_waiter mw;\n\n\tocfs2_init_mask_waiter(&mw);\n\n\tif ((lockres->l_flags & OCFS2_LOCK_BUSY) ||\n\t    (lockres->l_level > DLM_LOCK_NL)) {\n\t\tmlog(ML_ERROR,\n\t\t     \"File lock \\\"%s\\\" has busy or locked state: flags: 0x%lx, \"\n\t\t     \"level: %u\\n\", lockres->l_name, lockres->l_flags,\n\t\t     lockres->l_level);\n\t\treturn -EINVAL;\n\t}\n\n\tspin_lock_irqsave(&lockres->l_lock, flags);\n\tif (!(lockres->l_flags & OCFS2_LOCK_ATTACHED)) {\n\t\tlockres_add_mask_waiter(lockres, &mw, OCFS2_LOCK_BUSY, 0);\n\t\tspin_unlock_irqrestore(&lockres->l_lock, flags);\n\n\t\t/*\n\t\t * Get the lock at NLMODE to start - that way we\n\t\t * can cancel the upconvert request if need be.\n\t\t */\n\t\tret = ocfs2_lock_create(osb, lockres, DLM_LOCK_NL, 0);\n\t\tif (ret < 0) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\tret = ocfs2_wait_for_mask(&mw);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\t\tspin_lock_irqsave(&lockres->l_lock, flags);\n\t}\n\n\tlockres->l_action = OCFS2_AST_CONVERT;\n\tlkm_flags |= DLM_LKF_CONVERT;\n\tlockres->l_requested = level;\n\tlockres_or_flags(lockres, OCFS2_LOCK_BUSY);\n\n\tlockres_add_mask_waiter(lockres, &mw, OCFS2_LOCK_BUSY, 0);\n\tspin_unlock_irqrestore(&lockres->l_lock, flags);\n\n\tret = ocfs2_dlm_lock(osb->cconn, level, &lockres->l_lksb, lkm_flags,\n\t\t\t     lockres->l_name, OCFS2_LOCK_ID_MAX_LEN - 1);\n\tif (ret) {\n\t\tif (!trylock || (ret != -EAGAIN)) {\n\t\t\tocfs2_log_dlm_error(\"ocfs2_dlm_lock\", ret, lockres);\n\t\t\tret = -EINVAL;\n\t\t}\n\n\t\tocfs2_recover_from_dlm_error(lockres, 1);\n\t\tlockres_remove_mask_waiter(lockres, &mw);\n\t\tgoto out;\n\t}\n\n\tret = ocfs2_wait_for_mask_interruptible(&mw, lockres);\n\tif (ret == -ERESTARTSYS) {\n\t\t/*\n\t\t * Userspace can cause deadlock itself with\n\t\t * flock(). Current behavior locally is to allow the\n\t\t * deadlock, but abort the system call if a signal is\n\t\t * received. We follow this example, otherwise a\n\t\t * poorly written program could sit in kernel until\n\t\t * reboot.\n\t\t *\n\t\t * Handling this is a bit more complicated for Ocfs2\n\t\t * though. We can't exit this function with an\n\t\t * outstanding lock request, so a cancel convert is\n\t\t * required. We intentionally overwrite 'ret' - if the\n\t\t * cancel fails and the lock was granted, it's easier\n\t\t * to just bubble success back up to the user.\n\t\t */\n\t\tret = ocfs2_flock_handle_signal(lockres, level);\n\t} else if (!ret && (level > lockres->l_level)) {\n\t\t/* Trylock failed asynchronously */\n\t\tBUG_ON(!trylock);\n\t\tret = -EAGAIN;\n\t}\n\nout:\n\n\tmlog(0, \"Lock: \\\"%s\\\" ex: %d, trylock: %d, returns: %d\\n\",\n\t     lockres->l_name, ex, trylock, ret);\n\treturn ret;\n}"
  },
  {
    "function_name": "ocfs2_flock_handle_signal",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlmglue.c",
    "lines": "1797-1842",
    "snippet": "static int ocfs2_flock_handle_signal(struct ocfs2_lock_res *lockres,\n\t\t\t\t     int level)\n{\n\tint ret;\n\tstruct ocfs2_super *osb = ocfs2_get_lockres_osb(lockres);\n\tunsigned long flags;\n\tstruct ocfs2_mask_waiter mw;\n\n\tocfs2_init_mask_waiter(&mw);\n\nretry_cancel:\n\tspin_lock_irqsave(&lockres->l_lock, flags);\n\tif (lockres->l_flags & OCFS2_LOCK_BUSY) {\n\t\tret = ocfs2_prepare_cancel_convert(osb, lockres);\n\t\tif (ret) {\n\t\t\tspin_unlock_irqrestore(&lockres->l_lock, flags);\n\t\t\tret = ocfs2_cancel_convert(osb, lockres);\n\t\t\tif (ret < 0) {\n\t\t\t\tmlog_errno(ret);\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tgoto retry_cancel;\n\t\t}\n\t\tlockres_add_mask_waiter(lockres, &mw, OCFS2_LOCK_BUSY, 0);\n\t\tspin_unlock_irqrestore(&lockres->l_lock, flags);\n\n\t\tocfs2_wait_for_mask(&mw);\n\t\tgoto retry_cancel;\n\t}\n\n\tret = -ERESTARTSYS;\n\t/*\n\t * We may still have gotten the lock, in which case there's no\n\t * point to restarting the syscall.\n\t */\n\tif (lockres->l_level == level)\n\t\tret = 0;\n\n\tmlog(0, \"Cancel returning %d. flags: 0x%lx, level: %d, act: %d\\n\", ret,\n\t     lockres->l_flags, lockres->l_level, lockres->l_action);\n\n\tspin_unlock_irqrestore(&lockres->l_lock, flags);\n\nout:\n\treturn ret;\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"refcounttree.h\"",
      "#include \"quota.h\"",
      "#include \"uptodate.h\"",
      "#include \"super.h\"",
      "#include \"slot_map.h\"",
      "#include \"stackglue.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"heartbeat.h\"",
      "#include \"file.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"dcache.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2_lockingver.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/time.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/kthread.h>",
      "#include <linux/mm.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct ocfs2_super *ocfs2_get_dentry_osb(struct ocfs2_lock_res *lockres);",
      "static struct ocfs2_super *ocfs2_get_inode_osb(struct ocfs2_lock_res *lockres);",
      "static struct ocfs2_super *ocfs2_get_file_osb(struct ocfs2_lock_res *lockres);",
      "static struct ocfs2_super *ocfs2_get_qinfo_osb(struct ocfs2_lock_res *lockres);",
      "static void ocfs2_set_meta_lvb(struct ocfs2_lock_res *lockres);",
      "static void ocfs2_dentry_post_unlock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres);",
      "static void ocfs2_set_qinfo_lvb(struct ocfs2_lock_res *lockres);",
      "static inline void ocfs2_generic_handle_downconvert_action(struct ocfs2_lock_res *lockres);",
      "static inline void ocfs2_generic_handle_convert_action(struct ocfs2_lock_res *lockres);",
      "static inline void ocfs2_generic_handle_attach_action(struct ocfs2_lock_res *lockres);",
      "static int ocfs2_generic_handle_bast(struct ocfs2_lock_res *lockres, int level);",
      "static void ocfs2_schedule_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);",
      "static void ocfs2_downconvert_on_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);",
      "static void ocfs2_drop_osb_locks(struct ocfs2_super *osb);",
      "static inline int ocfs2_highest_compat_lock_level(int level);",
      "static int ocfs2_prepare_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\t        struct ocfs2_lock_res *lockres);",
      "static int ocfs2_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres);",
      "static void ocfs2_process_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *lockres);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock_irqrestore",
          "args": [
            "&lockres->l_lock",
            "flags"
          ],
          "line": 1838
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mlog",
          "args": [
            "0",
            "\"Cancel returning %d. flags: 0x%lx, level: %d, act: %d\\n\"",
            "ret",
            "lockres->l_flags",
            "lockres->l_level",
            "lockres->l_action"
          ],
          "line": 1835
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_wait_for_mask",
          "args": [
            "&mw"
          ],
          "line": 1823
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_wait_for_mask",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlmglue.c",
          "lines": "1308-1314",
          "snippet": "static int ocfs2_wait_for_mask(struct ocfs2_mask_waiter *mw)\n{\n\twait_for_completion(&mw->mw_complete);\n\t/* Re-arm the completion in case we want to wait on it again */\n\treinit_completion(&mw->mw_complete);\n\treturn mw->mw_status;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"refcounttree.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"stackglue.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dcache.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2_lockingver.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/time.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/kthread.h>",
            "#include <linux/mm.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"stackglue.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dcache.h\"\n#include \"alloc.h\"\n#include \"ocfs2_lockingver.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/quotaops.h>\n#include <linux/time.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/pagemap.h>\n#include <linux/kthread.h>\n#include <linux/mm.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic int ocfs2_wait_for_mask(struct ocfs2_mask_waiter *mw)\n{\n\twait_for_completion(&mw->mw_complete);\n\t/* Re-arm the completion in case we want to wait on it again */\n\treinit_completion(&mw->mw_complete);\n\treturn mw->mw_status;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock_irqrestore",
          "args": [
            "&lockres->l_lock",
            "flags"
          ],
          "line": 1821
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lockres_add_mask_waiter",
          "args": [
            "lockres",
            "&mw",
            "OCFS2_LOCK_BUSY",
            "0"
          ],
          "line": 1820
        },
        "resolved": true,
        "details": {
          "function_name": "lockres_add_mask_waiter",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlmglue.c",
          "lines": "1316-1328",
          "snippet": "static void lockres_add_mask_waiter(struct ocfs2_lock_res *lockres,\n\t\t\t\t    struct ocfs2_mask_waiter *mw,\n\t\t\t\t    unsigned long mask,\n\t\t\t\t    unsigned long goal)\n{\n\tBUG_ON(!list_empty(&mw->mw_item));\n\n\tassert_spin_locked(&lockres->l_lock);\n\n\tlist_add_tail(&mw->mw_item, &lockres->l_mask_waiters);\n\tmw->mw_mask = mask;\n\tmw->mw_goal = goal;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"refcounttree.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"stackglue.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dcache.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2_lockingver.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/time.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/kthread.h>",
            "#include <linux/mm.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct ocfs2_super *ocfs2_get_dentry_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_inode_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_file_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_qinfo_osb(struct ocfs2_lock_res *lockres);",
            "static void ocfs2_set_meta_lvb(struct ocfs2_lock_res *lockres);",
            "static void ocfs2_dentry_post_unlock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres);",
            "static void ocfs2_set_qinfo_lvb(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_downconvert_action(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_convert_action(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_attach_action(struct ocfs2_lock_res *lockres);",
            "static void ocfs2_schedule_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static void ocfs2_downconvert_on_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static int ocfs2_prepare_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\t        struct ocfs2_lock_res *lockres);",
            "static int ocfs2_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static void ocfs2_process_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *lockres);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"stackglue.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dcache.h\"\n#include \"alloc.h\"\n#include \"ocfs2_lockingver.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/quotaops.h>\n#include <linux/time.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/pagemap.h>\n#include <linux/kthread.h>\n#include <linux/mm.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic struct ocfs2_super *ocfs2_get_dentry_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_inode_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_file_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_qinfo_osb(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_set_meta_lvb(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_dentry_post_unlock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres);\nstatic void ocfs2_set_qinfo_lvb(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_downconvert_action(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_convert_action(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_attach_action(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_schedule_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_downconvert_on_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic int ocfs2_prepare_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\t        struct ocfs2_lock_res *lockres);\nstatic int ocfs2_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_process_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *lockres);\n\nstatic void lockres_add_mask_waiter(struct ocfs2_lock_res *lockres,\n\t\t\t\t    struct ocfs2_mask_waiter *mw,\n\t\t\t\t    unsigned long mask,\n\t\t\t\t    unsigned long goal)\n{\n\tBUG_ON(!list_empty(&mw->mw_item));\n\n\tassert_spin_locked(&lockres->l_lock);\n\n\tlist_add_tail(&mw->mw_item, &lockres->l_mask_waiters);\n\tmw->mw_mask = mask;\n\tmw->mw_goal = goal;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 1815
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_cancel_convert",
          "args": [
            "osb",
            "lockres"
          ],
          "line": 1813
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_cancel_convert",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlmglue.c",
          "lines": "3365-3380",
          "snippet": "static int ocfs2_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres)\n{\n\tint ret;\n\n\tret = ocfs2_dlm_unlock(osb->cconn, &lockres->l_lksb,\n\t\t\t       DLM_LKF_CANCEL);\n\tif (ret) {\n\t\tocfs2_log_dlm_error(\"ocfs2_dlm_unlock\", ret, lockres);\n\t\tocfs2_recover_from_dlm_error(lockres, 0);\n\t}\n\n\tmlog(ML_BASTS, \"lockres %s\\n\", lockres->l_name);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"refcounttree.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"stackglue.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dcache.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2_lockingver.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/time.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/kthread.h>",
            "#include <linux/mm.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct ocfs2_super *ocfs2_get_dentry_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_inode_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_file_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_qinfo_osb(struct ocfs2_lock_res *lockres);",
            "static void ocfs2_set_meta_lvb(struct ocfs2_lock_res *lockres);",
            "static void ocfs2_dentry_post_unlock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres);",
            "static void ocfs2_set_qinfo_lvb(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_downconvert_action(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_convert_action(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_attach_action(struct ocfs2_lock_res *lockres);",
            "static void ocfs2_schedule_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static void ocfs2_downconvert_on_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static void ocfs2_drop_osb_locks(struct ocfs2_super *osb);",
            "static int ocfs2_prepare_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\t        struct ocfs2_lock_res *lockres);",
            "static int ocfs2_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static void ocfs2_process_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *lockres);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"stackglue.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dcache.h\"\n#include \"alloc.h\"\n#include \"ocfs2_lockingver.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/quotaops.h>\n#include <linux/time.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/pagemap.h>\n#include <linux/kthread.h>\n#include <linux/mm.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic struct ocfs2_super *ocfs2_get_dentry_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_inode_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_file_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_qinfo_osb(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_set_meta_lvb(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_dentry_post_unlock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres);\nstatic void ocfs2_set_qinfo_lvb(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_downconvert_action(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_convert_action(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_attach_action(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_schedule_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_downconvert_on_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_drop_osb_locks(struct ocfs2_super *osb);\nstatic int ocfs2_prepare_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\t        struct ocfs2_lock_res *lockres);\nstatic int ocfs2_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_process_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *lockres);\n\nstatic int ocfs2_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres)\n{\n\tint ret;\n\n\tret = ocfs2_dlm_unlock(osb->cconn, &lockres->l_lksb,\n\t\t\t       DLM_LKF_CANCEL);\n\tif (ret) {\n\t\tocfs2_log_dlm_error(\"ocfs2_dlm_unlock\", ret, lockres);\n\t\tocfs2_recover_from_dlm_error(lockres, 0);\n\t}\n\n\tmlog(ML_BASTS, \"lockres %s\\n\", lockres->l_name);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock_irqrestore",
          "args": [
            "&lockres->l_lock",
            "flags"
          ],
          "line": 1812
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_prepare_cancel_convert",
          "args": [
            "osb",
            "lockres"
          ],
          "line": 1810
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_prepare_cancel_convert",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlmglue.c",
          "lines": "3336-3363",
          "snippet": "static int ocfs2_prepare_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\t        struct ocfs2_lock_res *lockres)\n{\n\tassert_spin_locked(&lockres->l_lock);\n\n\tif (lockres->l_unlock_action == OCFS2_UNLOCK_CANCEL_CONVERT) {\n\t\t/* If we're already trying to cancel a lock conversion\n\t\t * then just drop the spinlock and allow the caller to\n\t\t * requeue this lock. */\n\t\tmlog(ML_BASTS, \"lockres %s, skip convert\\n\", lockres->l_name);\n\t\treturn 0;\n\t}\n\n\t/* were we in a convert when we got the bast fire? */\n\tBUG_ON(lockres->l_action != OCFS2_AST_CONVERT &&\n\t       lockres->l_action != OCFS2_AST_DOWNCONVERT);\n\t/* set things up for the unlockast to know to just\n\t * clear out the ast_action and unset busy, etc. */\n\tlockres->l_unlock_action = OCFS2_UNLOCK_CANCEL_CONVERT;\n\n\tmlog_bug_on_msg(!(lockres->l_flags & OCFS2_LOCK_BUSY),\n\t\t\t\"lock %s, invalid flags: 0x%lx\\n\",\n\t\t\tlockres->l_name, lockres->l_flags);\n\n\tmlog(ML_BASTS, \"lockres %s\\n\", lockres->l_name);\n\n\treturn 1;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"refcounttree.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"stackglue.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dcache.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2_lockingver.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/time.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/kthread.h>",
            "#include <linux/mm.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct ocfs2_super *ocfs2_get_dentry_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_inode_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_file_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_qinfo_osb(struct ocfs2_lock_res *lockres);",
            "static void ocfs2_set_meta_lvb(struct ocfs2_lock_res *lockres);",
            "static void ocfs2_dentry_post_unlock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres);",
            "static void ocfs2_set_qinfo_lvb(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_downconvert_action(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_convert_action(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_attach_action(struct ocfs2_lock_res *lockres);",
            "static void ocfs2_schedule_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_recover_from_dlm_error(struct ocfs2_lock_res *lockres,\n\t\t\t\t\t\tint convert);",
            "static void ocfs2_downconvert_on_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static void ocfs2_drop_osb_locks(struct ocfs2_super *osb);",
            "static int ocfs2_prepare_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\t        struct ocfs2_lock_res *lockres);",
            "static int ocfs2_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static void ocfs2_process_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *lockres);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"stackglue.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dcache.h\"\n#include \"alloc.h\"\n#include \"ocfs2_lockingver.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/quotaops.h>\n#include <linux/time.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/pagemap.h>\n#include <linux/kthread.h>\n#include <linux/mm.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic struct ocfs2_super *ocfs2_get_dentry_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_inode_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_file_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_qinfo_osb(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_set_meta_lvb(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_dentry_post_unlock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres);\nstatic void ocfs2_set_qinfo_lvb(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_downconvert_action(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_convert_action(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_attach_action(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_schedule_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_recover_from_dlm_error(struct ocfs2_lock_res *lockres,\n\t\t\t\t\t\tint convert);\nstatic void ocfs2_downconvert_on_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_drop_osb_locks(struct ocfs2_super *osb);\nstatic int ocfs2_prepare_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\t        struct ocfs2_lock_res *lockres);\nstatic int ocfs2_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_process_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *lockres);\n\nstatic int ocfs2_prepare_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\t        struct ocfs2_lock_res *lockres)\n{\n\tassert_spin_locked(&lockres->l_lock);\n\n\tif (lockres->l_unlock_action == OCFS2_UNLOCK_CANCEL_CONVERT) {\n\t\t/* If we're already trying to cancel a lock conversion\n\t\t * then just drop the spinlock and allow the caller to\n\t\t * requeue this lock. */\n\t\tmlog(ML_BASTS, \"lockres %s, skip convert\\n\", lockres->l_name);\n\t\treturn 0;\n\t}\n\n\t/* were we in a convert when we got the bast fire? */\n\tBUG_ON(lockres->l_action != OCFS2_AST_CONVERT &&\n\t       lockres->l_action != OCFS2_AST_DOWNCONVERT);\n\t/* set things up for the unlockast to know to just\n\t * clear out the ast_action and unset busy, etc. */\n\tlockres->l_unlock_action = OCFS2_UNLOCK_CANCEL_CONVERT;\n\n\tmlog_bug_on_msg(!(lockres->l_flags & OCFS2_LOCK_BUSY),\n\t\t\t\"lock %s, invalid flags: 0x%lx\\n\",\n\t\t\tlockres->l_name, lockres->l_flags);\n\n\tmlog(ML_BASTS, \"lockres %s\\n\", lockres->l_name);\n\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock_irqsave",
          "args": [
            "&lockres->l_lock",
            "flags"
          ],
          "line": 1808
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_init_mask_waiter",
          "args": [
            "&mw"
          ],
          "line": 1805
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_init_mask_waiter",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlmglue.c",
          "lines": "1301-1306",
          "snippet": "static void ocfs2_init_mask_waiter(struct ocfs2_mask_waiter *mw)\n{\n\tINIT_LIST_HEAD(&mw->mw_item);\n\tinit_completion(&mw->mw_complete);\n\tocfs2_init_start_time(mw);\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"refcounttree.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"stackglue.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dcache.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2_lockingver.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/time.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/kthread.h>",
            "#include <linux/mm.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"stackglue.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dcache.h\"\n#include \"alloc.h\"\n#include \"ocfs2_lockingver.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/quotaops.h>\n#include <linux/time.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/pagemap.h>\n#include <linux/kthread.h>\n#include <linux/mm.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic void ocfs2_init_mask_waiter(struct ocfs2_mask_waiter *mw)\n{\n\tINIT_LIST_HEAD(&mw->mw_item);\n\tinit_completion(&mw->mw_complete);\n\tocfs2_init_start_time(mw);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_get_lockres_osb",
          "args": [
            "lockres"
          ],
          "line": 1801
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_get_lockres_osb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlmglue.c",
          "lines": "332-338",
          "snippet": "static inline struct ocfs2_super *ocfs2_get_lockres_osb(struct ocfs2_lock_res *lockres)\n{\n\tif (lockres->l_ops->get_osb)\n\t\treturn lockres->l_ops->get_osb(lockres);\n\n\treturn (struct ocfs2_super *)lockres->l_priv;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"refcounttree.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"stackglue.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dcache.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2_lockingver.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/time.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/kthread.h>",
            "#include <linux/mm.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct ocfs2_super *ocfs2_get_dentry_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_inode_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_file_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_qinfo_osb(struct ocfs2_lock_res *lockres);",
            "static void ocfs2_set_meta_lvb(struct ocfs2_lock_res *lockres);",
            "static void ocfs2_dentry_post_unlock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres);",
            "static void ocfs2_set_qinfo_lvb(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_downconvert_action(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_convert_action(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_attach_action(struct ocfs2_lock_res *lockres);",
            "static void ocfs2_schedule_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static void ocfs2_downconvert_on_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static int ocfs2_prepare_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\t        struct ocfs2_lock_res *lockres);",
            "static int ocfs2_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static void ocfs2_process_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *lockres);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"stackglue.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dcache.h\"\n#include \"alloc.h\"\n#include \"ocfs2_lockingver.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/quotaops.h>\n#include <linux/time.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/pagemap.h>\n#include <linux/kthread.h>\n#include <linux/mm.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic struct ocfs2_super *ocfs2_get_dentry_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_inode_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_file_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_qinfo_osb(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_set_meta_lvb(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_dentry_post_unlock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres);\nstatic void ocfs2_set_qinfo_lvb(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_downconvert_action(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_convert_action(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_attach_action(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_schedule_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_downconvert_on_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic int ocfs2_prepare_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\t        struct ocfs2_lock_res *lockres);\nstatic int ocfs2_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_process_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *lockres);\n\nstatic inline struct ocfs2_super *ocfs2_get_lockres_osb(struct ocfs2_lock_res *lockres)\n{\n\tif (lockres->l_ops->get_osb)\n\t\treturn lockres->l_ops->get_osb(lockres);\n\n\treturn (struct ocfs2_super *)lockres->l_priv;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"stackglue.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dcache.h\"\n#include \"alloc.h\"\n#include \"ocfs2_lockingver.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/quotaops.h>\n#include <linux/time.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/pagemap.h>\n#include <linux/kthread.h>\n#include <linux/mm.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic struct ocfs2_super *ocfs2_get_dentry_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_inode_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_file_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_qinfo_osb(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_set_meta_lvb(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_dentry_post_unlock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres);\nstatic void ocfs2_set_qinfo_lvb(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_downconvert_action(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_convert_action(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_attach_action(struct ocfs2_lock_res *lockres);\nstatic int ocfs2_generic_handle_bast(struct ocfs2_lock_res *lockres, int level);\nstatic void ocfs2_schedule_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_downconvert_on_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_drop_osb_locks(struct ocfs2_super *osb);\nstatic inline int ocfs2_highest_compat_lock_level(int level);\nstatic int ocfs2_prepare_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\t        struct ocfs2_lock_res *lockres);\nstatic int ocfs2_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_process_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *lockres);\n\nstatic int ocfs2_flock_handle_signal(struct ocfs2_lock_res *lockres,\n\t\t\t\t     int level)\n{\n\tint ret;\n\tstruct ocfs2_super *osb = ocfs2_get_lockres_osb(lockres);\n\tunsigned long flags;\n\tstruct ocfs2_mask_waiter mw;\n\n\tocfs2_init_mask_waiter(&mw);\n\nretry_cancel:\n\tspin_lock_irqsave(&lockres->l_lock, flags);\n\tif (lockres->l_flags & OCFS2_LOCK_BUSY) {\n\t\tret = ocfs2_prepare_cancel_convert(osb, lockres);\n\t\tif (ret) {\n\t\t\tspin_unlock_irqrestore(&lockres->l_lock, flags);\n\t\t\tret = ocfs2_cancel_convert(osb, lockres);\n\t\t\tif (ret < 0) {\n\t\t\t\tmlog_errno(ret);\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tgoto retry_cancel;\n\t\t}\n\t\tlockres_add_mask_waiter(lockres, &mw, OCFS2_LOCK_BUSY, 0);\n\t\tspin_unlock_irqrestore(&lockres->l_lock, flags);\n\n\t\tocfs2_wait_for_mask(&mw);\n\t\tgoto retry_cancel;\n\t}\n\n\tret = -ERESTARTSYS;\n\t/*\n\t * We may still have gotten the lock, in which case there's no\n\t * point to restarting the syscall.\n\t */\n\tif (lockres->l_level == level)\n\t\tret = 0;\n\n\tmlog(0, \"Cancel returning %d. flags: 0x%lx, level: %d, act: %d\\n\", ret,\n\t     lockres->l_flags, lockres->l_level, lockres->l_action);\n\n\tspin_unlock_irqrestore(&lockres->l_lock, flags);\n\nout:\n\treturn ret;\n}"
  },
  {
    "function_name": "ocfs2_open_unlock",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlmglue.c",
    "lines": "1775-1795",
    "snippet": "void ocfs2_open_unlock(struct inode *inode)\n{\n\tstruct ocfs2_lock_res *lockres = &OCFS2_I(inode)->ip_open_lockres;\n\tstruct ocfs2_super *osb = OCFS2_SB(inode->i_sb);\n\n\tmlog(0, \"inode %llu drop open lock\\n\",\n\t     (unsigned long long)OCFS2_I(inode)->ip_blkno);\n\n\tif (ocfs2_mount_local(osb))\n\t\tgoto out;\n\n\tif(lockres->l_ro_holders)\n\t\tocfs2_cluster_unlock(OCFS2_SB(inode->i_sb), lockres,\n\t\t\t\t     DLM_LOCK_PR);\n\tif(lockres->l_ex_holders)\n\t\tocfs2_cluster_unlock(OCFS2_SB(inode->i_sb), lockres,\n\t\t\t\t     DLM_LOCK_EX);\n\nout:\n\treturn;\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"refcounttree.h\"",
      "#include \"quota.h\"",
      "#include \"uptodate.h\"",
      "#include \"super.h\"",
      "#include \"slot_map.h\"",
      "#include \"stackglue.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"heartbeat.h\"",
      "#include \"file.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"dcache.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2_lockingver.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/time.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/kthread.h>",
      "#include <linux/mm.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct ocfs2_super *ocfs2_get_dentry_osb(struct ocfs2_lock_res *lockres);",
      "static struct ocfs2_super *ocfs2_get_inode_osb(struct ocfs2_lock_res *lockres);",
      "static struct ocfs2_super *ocfs2_get_file_osb(struct ocfs2_lock_res *lockres);",
      "static struct ocfs2_super *ocfs2_get_qinfo_osb(struct ocfs2_lock_res *lockres);",
      "static void ocfs2_set_meta_lvb(struct ocfs2_lock_res *lockres);",
      "static void ocfs2_dentry_post_unlock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres);",
      "static void ocfs2_set_qinfo_lvb(struct ocfs2_lock_res *lockres);",
      "static inline void ocfs2_generic_handle_downconvert_action(struct ocfs2_lock_res *lockres);",
      "static inline void ocfs2_generic_handle_convert_action(struct ocfs2_lock_res *lockres);",
      "static inline void ocfs2_generic_handle_attach_action(struct ocfs2_lock_res *lockres);",
      "static void ocfs2_schedule_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);",
      "static void ocfs2_downconvert_on_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);",
      "static void ocfs2_drop_osb_locks(struct ocfs2_super *osb);",
      "static int ocfs2_prepare_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\t        struct ocfs2_lock_res *lockres);",
      "static int ocfs2_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres);",
      "static void ocfs2_process_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *lockres);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ocfs2_cluster_unlock",
          "args": [
            "OCFS2_SB(inode->i_sb)",
            "lockres",
            "DLM_LOCK_EX"
          ],
          "line": 1790
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_cluster_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlmglue.c",
          "lines": "349-354",
          "snippet": "static inline void ocfs2_cluster_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres,\n\t\t\t\t\tint level)\n{\n\t__ocfs2_cluster_unlock(osb, lockres, level, _RET_IP_);\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"refcounttree.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"stackglue.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dcache.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2_lockingver.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/time.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/kthread.h>",
            "#include <linux/mm.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct ocfs2_super *ocfs2_get_dentry_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_inode_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_file_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_qinfo_osb(struct ocfs2_lock_res *lockres);",
            "static void ocfs2_set_meta_lvb(struct ocfs2_lock_res *lockres);",
            "static void ocfs2_dentry_post_unlock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres);",
            "static void ocfs2_set_qinfo_lvb(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_downconvert_action(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_convert_action(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_attach_action(struct ocfs2_lock_res *lockres);",
            "static int ocfs2_generic_handle_bast(struct ocfs2_lock_res *lockres, int level);",
            "static void ocfs2_schedule_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static void ocfs2_downconvert_on_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static void ocfs2_drop_osb_locks(struct ocfs2_super *osb);",
            "static inline int ocfs2_highest_compat_lock_level(int level);",
            "static int ocfs2_prepare_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\t        struct ocfs2_lock_res *lockres);",
            "static int ocfs2_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static void ocfs2_process_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *lockres);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"stackglue.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dcache.h\"\n#include \"alloc.h\"\n#include \"ocfs2_lockingver.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/quotaops.h>\n#include <linux/time.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/pagemap.h>\n#include <linux/kthread.h>\n#include <linux/mm.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic struct ocfs2_super *ocfs2_get_dentry_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_inode_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_file_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_qinfo_osb(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_set_meta_lvb(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_dentry_post_unlock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres);\nstatic void ocfs2_set_qinfo_lvb(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_downconvert_action(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_convert_action(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_attach_action(struct ocfs2_lock_res *lockres);\nstatic int ocfs2_generic_handle_bast(struct ocfs2_lock_res *lockres, int level);\nstatic void ocfs2_schedule_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_downconvert_on_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_drop_osb_locks(struct ocfs2_super *osb);\nstatic inline int ocfs2_highest_compat_lock_level(int level);\nstatic int ocfs2_prepare_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\t        struct ocfs2_lock_res *lockres);\nstatic int ocfs2_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_process_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *lockres);\n\nstatic inline void ocfs2_cluster_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres,\n\t\t\t\t\tint level)\n{\n\t__ocfs2_cluster_unlock(osb, lockres, level, _RET_IP_);\n}"
        }
      },
      {
        "call_info": {
          "callee": "OCFS2_SB",
          "args": [
            "inode->i_sb"
          ],
          "line": 1790
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "OCFS2_SB",
          "args": [
            "inode->i_sb"
          ],
          "line": 1787
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_mount_local",
          "args": [
            "osb"
          ],
          "line": 1783
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_mount_local",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "668-671",
          "snippet": "static inline int ocfs2_mount_local(struct ocfs2_super *osb)\n{\n\treturn (osb->s_feature_incompat & OCFS2_FEATURE_INCOMPAT_LOCAL_MOUNT);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\nstatic inline int ocfs2_mount_local(struct ocfs2_super *osb)\n{\n\treturn (osb->s_feature_incompat & OCFS2_FEATURE_INCOMPAT_LOCAL_MOUNT);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog",
          "args": [
            "0",
            "\"inode %llu drop open lock\\n\"",
            "(unsigned long long)OCFS2_I(inode)->ip_blkno"
          ],
          "line": 1780
        },
        "resolved": true,
        "details": {
          "function_name": "mlog_show",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/cluster/masklog.c",
          "lines": "107-113",
          "snippet": "static ssize_t mlog_show(struct kobject *obj, struct attribute *attr,\n\t\t\t char *buf)\n{\n\tstruct mlog_attribute *mlog_attr = to_mlog_attr(attr);\n\n\treturn mlog_mask_show(mlog_attr->mask, buf);\n}",
          "includes": [
            "#include \"masklog.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/string.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"masklog.h\"\n#include <asm/uaccess.h>\n#include <linux/string.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n\nstatic ssize_t mlog_show(struct kobject *obj, struct attribute *attr,\n\t\t\t char *buf)\n{\n\tstruct mlog_attribute *mlog_attr = to_mlog_attr(attr);\n\n\treturn mlog_mask_show(mlog_attr->mask, buf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "OCFS2_I",
          "args": [
            "inode"
          ],
          "line": 1781
        },
        "resolved": true,
        "details": {
          "function_name": "OCFS2_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/inode.h",
          "lines": "118-121",
          "snippet": "static inline struct ocfs2_inode_info *OCFS2_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ocfs2_inode_info, vfs_inode);\n}",
          "includes": [
            "#include \"extent_map.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extent_map.h\"\n\nstatic inline struct ocfs2_inode_info *OCFS2_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ocfs2_inode_info, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "OCFS2_SB",
          "args": [
            "inode->i_sb"
          ],
          "line": 1778
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"stackglue.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dcache.h\"\n#include \"alloc.h\"\n#include \"ocfs2_lockingver.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/quotaops.h>\n#include <linux/time.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/pagemap.h>\n#include <linux/kthread.h>\n#include <linux/mm.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic struct ocfs2_super *ocfs2_get_dentry_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_inode_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_file_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_qinfo_osb(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_set_meta_lvb(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_dentry_post_unlock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres);\nstatic void ocfs2_set_qinfo_lvb(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_downconvert_action(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_convert_action(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_attach_action(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_schedule_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_downconvert_on_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_drop_osb_locks(struct ocfs2_super *osb);\nstatic int ocfs2_prepare_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\t        struct ocfs2_lock_res *lockres);\nstatic int ocfs2_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_process_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *lockres);\n\nvoid ocfs2_open_unlock(struct inode *inode)\n{\n\tstruct ocfs2_lock_res *lockres = &OCFS2_I(inode)->ip_open_lockres;\n\tstruct ocfs2_super *osb = OCFS2_SB(inode->i_sb);\n\n\tmlog(0, \"inode %llu drop open lock\\n\",\n\t     (unsigned long long)OCFS2_I(inode)->ip_blkno);\n\n\tif (ocfs2_mount_local(osb))\n\t\tgoto out;\n\n\tif(lockres->l_ro_holders)\n\t\tocfs2_cluster_unlock(OCFS2_SB(inode->i_sb), lockres,\n\t\t\t\t     DLM_LOCK_PR);\n\tif(lockres->l_ex_holders)\n\t\tocfs2_cluster_unlock(OCFS2_SB(inode->i_sb), lockres,\n\t\t\t\t     DLM_LOCK_EX);\n\nout:\n\treturn;\n}"
  },
  {
    "function_name": "ocfs2_try_open_lock",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlmglue.c",
    "lines": "1734-1770",
    "snippet": "int ocfs2_try_open_lock(struct inode *inode, int write)\n{\n\tint status = 0, level;\n\tstruct ocfs2_lock_res *lockres;\n\tstruct ocfs2_super *osb = OCFS2_SB(inode->i_sb);\n\n\tBUG_ON(!inode);\n\n\tmlog(0, \"inode %llu try to take %s open lock\\n\",\n\t     (unsigned long long)OCFS2_I(inode)->ip_blkno,\n\t     write ? \"EXMODE\" : \"PRMODE\");\n\n\tif (ocfs2_is_hard_readonly(osb)) {\n\t\tif (write)\n\t\t\tstatus = -EROFS;\n\t\tgoto out;\n\t}\n\n\tif (ocfs2_mount_local(osb))\n\t\tgoto out;\n\n\tlockres = &OCFS2_I(inode)->ip_open_lockres;\n\n\tlevel = write ? DLM_LOCK_EX : DLM_LOCK_PR;\n\n\t/*\n\t * The file system may already holding a PRMODE/EXMODE open lock.\n\t * Since we pass DLM_LKF_NOQUEUE, the request won't block waiting on\n\t * other nodes and the -EAGAIN will indicate to the caller that\n\t * this inode is still in use.\n\t */\n\tstatus = ocfs2_cluster_lock(OCFS2_SB(inode->i_sb), lockres,\n\t\t\t\t    level, DLM_LKF_NOQUEUE, 0);\n\nout:\n\treturn status;\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"refcounttree.h\"",
      "#include \"quota.h\"",
      "#include \"uptodate.h\"",
      "#include \"super.h\"",
      "#include \"slot_map.h\"",
      "#include \"stackglue.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"heartbeat.h\"",
      "#include \"file.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"dcache.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2_lockingver.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/time.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/kthread.h>",
      "#include <linux/mm.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct ocfs2_super *ocfs2_get_dentry_osb(struct ocfs2_lock_res *lockres);",
      "static struct ocfs2_super *ocfs2_get_inode_osb(struct ocfs2_lock_res *lockres);",
      "static struct ocfs2_super *ocfs2_get_file_osb(struct ocfs2_lock_res *lockres);",
      "static struct ocfs2_super *ocfs2_get_qinfo_osb(struct ocfs2_lock_res *lockres);",
      "static void ocfs2_set_meta_lvb(struct ocfs2_lock_res *lockres);",
      "static void ocfs2_dentry_post_unlock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres);",
      "static void ocfs2_set_qinfo_lvb(struct ocfs2_lock_res *lockres);",
      "static inline void ocfs2_generic_handle_downconvert_action(struct ocfs2_lock_res *lockres);",
      "static inline void ocfs2_generic_handle_convert_action(struct ocfs2_lock_res *lockres);",
      "static inline void ocfs2_generic_handle_attach_action(struct ocfs2_lock_res *lockres);",
      "static int ocfs2_generic_handle_bast(struct ocfs2_lock_res *lockres, int level);",
      "static void ocfs2_schedule_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);",
      "static void ocfs2_downconvert_on_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);",
      "static void ocfs2_drop_osb_locks(struct ocfs2_super *osb);",
      "static inline int ocfs2_highest_compat_lock_level(int level);",
      "static int ocfs2_prepare_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\t        struct ocfs2_lock_res *lockres);",
      "static int ocfs2_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres);",
      "static void ocfs2_process_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *lockres);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ocfs2_cluster_lock",
          "args": [
            "OCFS2_SB(inode->i_sb)",
            "lockres",
            "level",
            "DLM_LKF_NOQUEUE",
            "0"
          ],
          "line": 1765
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_cluster_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlmglue.c",
          "lines": "1570-1578",
          "snippet": "static inline int ocfs2_cluster_lock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres,\n\t\t\t\t     int level,\n\t\t\t\t     u32 lkm_flags,\n\t\t\t\t     int arg_flags)\n{\n\treturn __ocfs2_cluster_lock(osb, lockres, level, lkm_flags, arg_flags,\n\t\t\t\t    0, _RET_IP_);\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"refcounttree.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"stackglue.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dcache.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2_lockingver.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/time.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/kthread.h>",
            "#include <linux/mm.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct ocfs2_super *ocfs2_get_dentry_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_inode_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_file_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_qinfo_osb(struct ocfs2_lock_res *lockres);",
            "static void ocfs2_set_meta_lvb(struct ocfs2_lock_res *lockres);",
            "static void ocfs2_dentry_post_unlock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres);",
            "static void ocfs2_set_qinfo_lvb(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_downconvert_action(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_convert_action(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_attach_action(struct ocfs2_lock_res *lockres);",
            "static int ocfs2_generic_handle_bast(struct ocfs2_lock_res *lockres, int level);",
            "static void ocfs2_schedule_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static void ocfs2_downconvert_on_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static void ocfs2_drop_osb_locks(struct ocfs2_super *osb);",
            "static inline int ocfs2_highest_compat_lock_level(int level);",
            "static int ocfs2_prepare_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\t        struct ocfs2_lock_res *lockres);",
            "static int ocfs2_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static void ocfs2_process_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *lockres);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"stackglue.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dcache.h\"\n#include \"alloc.h\"\n#include \"ocfs2_lockingver.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/quotaops.h>\n#include <linux/time.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/pagemap.h>\n#include <linux/kthread.h>\n#include <linux/mm.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic struct ocfs2_super *ocfs2_get_dentry_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_inode_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_file_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_qinfo_osb(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_set_meta_lvb(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_dentry_post_unlock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres);\nstatic void ocfs2_set_qinfo_lvb(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_downconvert_action(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_convert_action(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_attach_action(struct ocfs2_lock_res *lockres);\nstatic int ocfs2_generic_handle_bast(struct ocfs2_lock_res *lockres, int level);\nstatic void ocfs2_schedule_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_downconvert_on_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_drop_osb_locks(struct ocfs2_super *osb);\nstatic inline int ocfs2_highest_compat_lock_level(int level);\nstatic int ocfs2_prepare_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\t        struct ocfs2_lock_res *lockres);\nstatic int ocfs2_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_process_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *lockres);\n\nstatic inline int ocfs2_cluster_lock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres,\n\t\t\t\t     int level,\n\t\t\t\t     u32 lkm_flags,\n\t\t\t\t     int arg_flags)\n{\n\treturn __ocfs2_cluster_lock(osb, lockres, level, lkm_flags, arg_flags,\n\t\t\t\t    0, _RET_IP_);\n}"
        }
      },
      {
        "call_info": {
          "callee": "OCFS2_SB",
          "args": [
            "inode->i_sb"
          ],
          "line": 1765
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "OCFS2_I",
          "args": [
            "inode"
          ],
          "line": 1755
        },
        "resolved": true,
        "details": {
          "function_name": "OCFS2_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/inode.h",
          "lines": "118-121",
          "snippet": "static inline struct ocfs2_inode_info *OCFS2_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ocfs2_inode_info, vfs_inode);\n}",
          "includes": [
            "#include \"extent_map.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extent_map.h\"\n\nstatic inline struct ocfs2_inode_info *OCFS2_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ocfs2_inode_info, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_mount_local",
          "args": [
            "osb"
          ],
          "line": 1752
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_mount_local",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "668-671",
          "snippet": "static inline int ocfs2_mount_local(struct ocfs2_super *osb)\n{\n\treturn (osb->s_feature_incompat & OCFS2_FEATURE_INCOMPAT_LOCAL_MOUNT);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\nstatic inline int ocfs2_mount_local(struct ocfs2_super *osb)\n{\n\treturn (osb->s_feature_incompat & OCFS2_FEATURE_INCOMPAT_LOCAL_MOUNT);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_is_hard_readonly",
          "args": [
            "osb"
          ],
          "line": 1746
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_is_hard_readonly",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "615-624",
          "snippet": "static inline int ocfs2_is_hard_readonly(struct ocfs2_super *osb)\n{\n\tint ret;\n\n\tspin_lock(&osb->osb_lock);\n\tret = osb->osb_flags & OCFS2_OSB_HARD_RO;\n\tspin_unlock(&osb->osb_lock);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [
            "#define OCFS2_OSB_HARD_RO\t0x0002"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\n#define OCFS2_OSB_HARD_RO\t0x0002\n\nstatic inline int ocfs2_is_hard_readonly(struct ocfs2_super *osb)\n{\n\tint ret;\n\n\tspin_lock(&osb->osb_lock);\n\tret = osb->osb_flags & OCFS2_OSB_HARD_RO;\n\tspin_unlock(&osb->osb_lock);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog",
          "args": [
            "0",
            "\"inode %llu try to take %s open lock\\n\"",
            "(unsigned long long)OCFS2_I(inode)->ip_blkno",
            "write ? \"EXMODE\" : \"PRMODE\""
          ],
          "line": 1742
        },
        "resolved": true,
        "details": {
          "function_name": "mlog_store",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/cluster/masklog.c",
          "lines": "115-121",
          "snippet": "static ssize_t mlog_store(struct kobject *obj, struct attribute *attr,\n\t\t\t  const char *buf, size_t count)\n{\n\tstruct mlog_attribute *mlog_attr = to_mlog_attr(attr);\n\n\treturn mlog_mask_store(mlog_attr->mask, buf, count);\n}",
          "includes": [
            "#include \"masklog.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/string.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"masklog.h\"\n#include <asm/uaccess.h>\n#include <linux/string.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n\nstatic ssize_t mlog_store(struct kobject *obj, struct attribute *attr,\n\t\t\t  const char *buf, size_t count)\n{\n\tstruct mlog_attribute *mlog_attr = to_mlog_attr(attr);\n\n\treturn mlog_mask_store(mlog_attr->mask, buf, count);\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!inode"
          ],
          "line": 1740
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "OCFS2_SB",
          "args": [
            "inode->i_sb"
          ],
          "line": 1738
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"stackglue.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dcache.h\"\n#include \"alloc.h\"\n#include \"ocfs2_lockingver.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/quotaops.h>\n#include <linux/time.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/pagemap.h>\n#include <linux/kthread.h>\n#include <linux/mm.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic struct ocfs2_super *ocfs2_get_dentry_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_inode_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_file_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_qinfo_osb(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_set_meta_lvb(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_dentry_post_unlock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres);\nstatic void ocfs2_set_qinfo_lvb(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_downconvert_action(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_convert_action(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_attach_action(struct ocfs2_lock_res *lockres);\nstatic int ocfs2_generic_handle_bast(struct ocfs2_lock_res *lockres, int level);\nstatic void ocfs2_schedule_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_downconvert_on_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_drop_osb_locks(struct ocfs2_super *osb);\nstatic inline int ocfs2_highest_compat_lock_level(int level);\nstatic int ocfs2_prepare_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\t        struct ocfs2_lock_res *lockres);\nstatic int ocfs2_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_process_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *lockres);\n\nint ocfs2_try_open_lock(struct inode *inode, int write)\n{\n\tint status = 0, level;\n\tstruct ocfs2_lock_res *lockres;\n\tstruct ocfs2_super *osb = OCFS2_SB(inode->i_sb);\n\n\tBUG_ON(!inode);\n\n\tmlog(0, \"inode %llu try to take %s open lock\\n\",\n\t     (unsigned long long)OCFS2_I(inode)->ip_blkno,\n\t     write ? \"EXMODE\" : \"PRMODE\");\n\n\tif (ocfs2_is_hard_readonly(osb)) {\n\t\tif (write)\n\t\t\tstatus = -EROFS;\n\t\tgoto out;\n\t}\n\n\tif (ocfs2_mount_local(osb))\n\t\tgoto out;\n\n\tlockres = &OCFS2_I(inode)->ip_open_lockres;\n\n\tlevel = write ? DLM_LOCK_EX : DLM_LOCK_PR;\n\n\t/*\n\t * The file system may already holding a PRMODE/EXMODE open lock.\n\t * Since we pass DLM_LKF_NOQUEUE, the request won't block waiting on\n\t * other nodes and the -EAGAIN will indicate to the caller that\n\t * this inode is still in use.\n\t */\n\tstatus = ocfs2_cluster_lock(OCFS2_SB(inode->i_sb), lockres,\n\t\t\t\t    level, DLM_LKF_NOQUEUE, 0);\n\nout:\n\treturn status;\n}"
  },
  {
    "function_name": "ocfs2_open_lock",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlmglue.c",
    "lines": "1709-1732",
    "snippet": "int ocfs2_open_lock(struct inode *inode)\n{\n\tint status = 0;\n\tstruct ocfs2_lock_res *lockres;\n\tstruct ocfs2_super *osb = OCFS2_SB(inode->i_sb);\n\n\tBUG_ON(!inode);\n\n\tmlog(0, \"inode %llu take PRMODE open lock\\n\",\n\t     (unsigned long long)OCFS2_I(inode)->ip_blkno);\n\n\tif (ocfs2_is_hard_readonly(osb) || ocfs2_mount_local(osb))\n\t\tgoto out;\n\n\tlockres = &OCFS2_I(inode)->ip_open_lockres;\n\n\tstatus = ocfs2_cluster_lock(OCFS2_SB(inode->i_sb), lockres,\n\t\t\t\t    DLM_LOCK_PR, 0, 0);\n\tif (status < 0)\n\t\tmlog_errno(status);\n\nout:\n\treturn status;\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"refcounttree.h\"",
      "#include \"quota.h\"",
      "#include \"uptodate.h\"",
      "#include \"super.h\"",
      "#include \"slot_map.h\"",
      "#include \"stackglue.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"heartbeat.h\"",
      "#include \"file.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"dcache.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2_lockingver.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/time.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/kthread.h>",
      "#include <linux/mm.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct ocfs2_super *ocfs2_get_dentry_osb(struct ocfs2_lock_res *lockres);",
      "static struct ocfs2_super *ocfs2_get_inode_osb(struct ocfs2_lock_res *lockres);",
      "static struct ocfs2_super *ocfs2_get_file_osb(struct ocfs2_lock_res *lockres);",
      "static struct ocfs2_super *ocfs2_get_qinfo_osb(struct ocfs2_lock_res *lockres);",
      "static void ocfs2_set_meta_lvb(struct ocfs2_lock_res *lockres);",
      "static void ocfs2_dentry_post_unlock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres);",
      "static void ocfs2_set_qinfo_lvb(struct ocfs2_lock_res *lockres);",
      "static inline void ocfs2_generic_handle_downconvert_action(struct ocfs2_lock_res *lockres);",
      "static inline void ocfs2_generic_handle_convert_action(struct ocfs2_lock_res *lockres);",
      "static inline void ocfs2_generic_handle_attach_action(struct ocfs2_lock_res *lockres);",
      "static void ocfs2_schedule_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);",
      "static void ocfs2_downconvert_on_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);",
      "static void ocfs2_drop_osb_locks(struct ocfs2_super *osb);",
      "static int ocfs2_prepare_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\t        struct ocfs2_lock_res *lockres);",
      "static int ocfs2_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres);",
      "static void ocfs2_process_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *lockres);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "status"
          ],
          "line": 1728
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_cluster_lock",
          "args": [
            "OCFS2_SB(inode->i_sb)",
            "lockres",
            "DLM_LOCK_PR",
            "0",
            "0"
          ],
          "line": 1725
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_cluster_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlmglue.c",
          "lines": "1570-1578",
          "snippet": "static inline int ocfs2_cluster_lock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres,\n\t\t\t\t     int level,\n\t\t\t\t     u32 lkm_flags,\n\t\t\t\t     int arg_flags)\n{\n\treturn __ocfs2_cluster_lock(osb, lockres, level, lkm_flags, arg_flags,\n\t\t\t\t    0, _RET_IP_);\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"refcounttree.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"stackglue.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dcache.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2_lockingver.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/time.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/kthread.h>",
            "#include <linux/mm.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct ocfs2_super *ocfs2_get_dentry_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_inode_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_file_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_qinfo_osb(struct ocfs2_lock_res *lockres);",
            "static void ocfs2_set_meta_lvb(struct ocfs2_lock_res *lockres);",
            "static void ocfs2_dentry_post_unlock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres);",
            "static void ocfs2_set_qinfo_lvb(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_downconvert_action(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_convert_action(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_attach_action(struct ocfs2_lock_res *lockres);",
            "static int ocfs2_generic_handle_bast(struct ocfs2_lock_res *lockres, int level);",
            "static void ocfs2_schedule_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static void ocfs2_downconvert_on_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static void ocfs2_drop_osb_locks(struct ocfs2_super *osb);",
            "static inline int ocfs2_highest_compat_lock_level(int level);",
            "static int ocfs2_prepare_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\t        struct ocfs2_lock_res *lockres);",
            "static int ocfs2_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static void ocfs2_process_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *lockres);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"stackglue.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dcache.h\"\n#include \"alloc.h\"\n#include \"ocfs2_lockingver.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/quotaops.h>\n#include <linux/time.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/pagemap.h>\n#include <linux/kthread.h>\n#include <linux/mm.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic struct ocfs2_super *ocfs2_get_dentry_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_inode_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_file_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_qinfo_osb(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_set_meta_lvb(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_dentry_post_unlock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres);\nstatic void ocfs2_set_qinfo_lvb(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_downconvert_action(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_convert_action(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_attach_action(struct ocfs2_lock_res *lockres);\nstatic int ocfs2_generic_handle_bast(struct ocfs2_lock_res *lockres, int level);\nstatic void ocfs2_schedule_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_downconvert_on_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_drop_osb_locks(struct ocfs2_super *osb);\nstatic inline int ocfs2_highest_compat_lock_level(int level);\nstatic int ocfs2_prepare_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\t        struct ocfs2_lock_res *lockres);\nstatic int ocfs2_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_process_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *lockres);\n\nstatic inline int ocfs2_cluster_lock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres,\n\t\t\t\t     int level,\n\t\t\t\t     u32 lkm_flags,\n\t\t\t\t     int arg_flags)\n{\n\treturn __ocfs2_cluster_lock(osb, lockres, level, lkm_flags, arg_flags,\n\t\t\t\t    0, _RET_IP_);\n}"
        }
      },
      {
        "call_info": {
          "callee": "OCFS2_SB",
          "args": [
            "inode->i_sb"
          ],
          "line": 1725
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "OCFS2_I",
          "args": [
            "inode"
          ],
          "line": 1723
        },
        "resolved": true,
        "details": {
          "function_name": "OCFS2_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/inode.h",
          "lines": "118-121",
          "snippet": "static inline struct ocfs2_inode_info *OCFS2_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ocfs2_inode_info, vfs_inode);\n}",
          "includes": [
            "#include \"extent_map.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extent_map.h\"\n\nstatic inline struct ocfs2_inode_info *OCFS2_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ocfs2_inode_info, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_mount_local",
          "args": [
            "osb"
          ],
          "line": 1720
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_mount_local",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "668-671",
          "snippet": "static inline int ocfs2_mount_local(struct ocfs2_super *osb)\n{\n\treturn (osb->s_feature_incompat & OCFS2_FEATURE_INCOMPAT_LOCAL_MOUNT);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\nstatic inline int ocfs2_mount_local(struct ocfs2_super *osb)\n{\n\treturn (osb->s_feature_incompat & OCFS2_FEATURE_INCOMPAT_LOCAL_MOUNT);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_is_hard_readonly",
          "args": [
            "osb"
          ],
          "line": 1720
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_is_hard_readonly",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "615-624",
          "snippet": "static inline int ocfs2_is_hard_readonly(struct ocfs2_super *osb)\n{\n\tint ret;\n\n\tspin_lock(&osb->osb_lock);\n\tret = osb->osb_flags & OCFS2_OSB_HARD_RO;\n\tspin_unlock(&osb->osb_lock);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [
            "#define OCFS2_OSB_HARD_RO\t0x0002"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\n#define OCFS2_OSB_HARD_RO\t0x0002\n\nstatic inline int ocfs2_is_hard_readonly(struct ocfs2_super *osb)\n{\n\tint ret;\n\n\tspin_lock(&osb->osb_lock);\n\tret = osb->osb_flags & OCFS2_OSB_HARD_RO;\n\tspin_unlock(&osb->osb_lock);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog",
          "args": [
            "0",
            "\"inode %llu take PRMODE open lock\\n\"",
            "(unsigned long long)OCFS2_I(inode)->ip_blkno"
          ],
          "line": 1717
        },
        "resolved": true,
        "details": {
          "function_name": "mlog_show",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/cluster/masklog.c",
          "lines": "107-113",
          "snippet": "static ssize_t mlog_show(struct kobject *obj, struct attribute *attr,\n\t\t\t char *buf)\n{\n\tstruct mlog_attribute *mlog_attr = to_mlog_attr(attr);\n\n\treturn mlog_mask_show(mlog_attr->mask, buf);\n}",
          "includes": [
            "#include \"masklog.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/string.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"masklog.h\"\n#include <asm/uaccess.h>\n#include <linux/string.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n\nstatic ssize_t mlog_show(struct kobject *obj, struct attribute *attr,\n\t\t\t char *buf)\n{\n\tstruct mlog_attribute *mlog_attr = to_mlog_attr(attr);\n\n\treturn mlog_mask_show(mlog_attr->mask, buf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!inode"
          ],
          "line": 1715
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "OCFS2_SB",
          "args": [
            "inode->i_sb"
          ],
          "line": 1713
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"stackglue.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dcache.h\"\n#include \"alloc.h\"\n#include \"ocfs2_lockingver.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/quotaops.h>\n#include <linux/time.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/pagemap.h>\n#include <linux/kthread.h>\n#include <linux/mm.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic struct ocfs2_super *ocfs2_get_dentry_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_inode_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_file_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_qinfo_osb(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_set_meta_lvb(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_dentry_post_unlock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres);\nstatic void ocfs2_set_qinfo_lvb(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_downconvert_action(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_convert_action(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_attach_action(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_schedule_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_downconvert_on_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_drop_osb_locks(struct ocfs2_super *osb);\nstatic int ocfs2_prepare_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\t        struct ocfs2_lock_res *lockres);\nstatic int ocfs2_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_process_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *lockres);\n\nint ocfs2_open_lock(struct inode *inode)\n{\n\tint status = 0;\n\tstruct ocfs2_lock_res *lockres;\n\tstruct ocfs2_super *osb = OCFS2_SB(inode->i_sb);\n\n\tBUG_ON(!inode);\n\n\tmlog(0, \"inode %llu take PRMODE open lock\\n\",\n\t     (unsigned long long)OCFS2_I(inode)->ip_blkno);\n\n\tif (ocfs2_is_hard_readonly(osb) || ocfs2_mount_local(osb))\n\t\tgoto out;\n\n\tlockres = &OCFS2_I(inode)->ip_open_lockres;\n\n\tstatus = ocfs2_cluster_lock(OCFS2_SB(inode->i_sb), lockres,\n\t\t\t\t    DLM_LOCK_PR, 0, 0);\n\tif (status < 0)\n\t\tmlog_errno(status);\n\nout:\n\treturn status;\n}"
  },
  {
    "function_name": "ocfs2_rw_unlock",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlmglue.c",
    "lines": "1692-1704",
    "snippet": "void ocfs2_rw_unlock(struct inode *inode, int write)\n{\n\tint level = write ? DLM_LOCK_EX : DLM_LOCK_PR;\n\tstruct ocfs2_lock_res *lockres = &OCFS2_I(inode)->ip_rw_lockres;\n\tstruct ocfs2_super *osb = OCFS2_SB(inode->i_sb);\n\n\tmlog(0, \"inode %llu drop %s RW lock\\n\",\n\t     (unsigned long long)OCFS2_I(inode)->ip_blkno,\n\t     write ? \"EXMODE\" : \"PRMODE\");\n\n\tif (!ocfs2_mount_local(osb))\n\t\tocfs2_cluster_unlock(OCFS2_SB(inode->i_sb), lockres, level);\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"refcounttree.h\"",
      "#include \"quota.h\"",
      "#include \"uptodate.h\"",
      "#include \"super.h\"",
      "#include \"slot_map.h\"",
      "#include \"stackglue.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"heartbeat.h\"",
      "#include \"file.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"dcache.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2_lockingver.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/time.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/kthread.h>",
      "#include <linux/mm.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct ocfs2_super *ocfs2_get_dentry_osb(struct ocfs2_lock_res *lockres);",
      "static struct ocfs2_super *ocfs2_get_inode_osb(struct ocfs2_lock_res *lockres);",
      "static struct ocfs2_super *ocfs2_get_file_osb(struct ocfs2_lock_res *lockres);",
      "static struct ocfs2_super *ocfs2_get_qinfo_osb(struct ocfs2_lock_res *lockres);",
      "static void ocfs2_set_meta_lvb(struct ocfs2_lock_res *lockres);",
      "static void ocfs2_dentry_post_unlock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres);",
      "static void ocfs2_set_qinfo_lvb(struct ocfs2_lock_res *lockres);",
      "static inline void ocfs2_generic_handle_downconvert_action(struct ocfs2_lock_res *lockres);",
      "static inline void ocfs2_generic_handle_convert_action(struct ocfs2_lock_res *lockres);",
      "static inline void ocfs2_generic_handle_attach_action(struct ocfs2_lock_res *lockres);",
      "static int ocfs2_generic_handle_bast(struct ocfs2_lock_res *lockres, int level);",
      "static void ocfs2_schedule_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);",
      "static void ocfs2_downconvert_on_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);",
      "static void ocfs2_drop_osb_locks(struct ocfs2_super *osb);",
      "static inline int ocfs2_highest_compat_lock_level(int level);",
      "static int ocfs2_prepare_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\t        struct ocfs2_lock_res *lockres);",
      "static int ocfs2_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres);",
      "static void ocfs2_process_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *lockres);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ocfs2_cluster_unlock",
          "args": [
            "OCFS2_SB(inode->i_sb)",
            "lockres",
            "level"
          ],
          "line": 1703
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_cluster_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlmglue.c",
          "lines": "349-354",
          "snippet": "static inline void ocfs2_cluster_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres,\n\t\t\t\t\tint level)\n{\n\t__ocfs2_cluster_unlock(osb, lockres, level, _RET_IP_);\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"refcounttree.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"stackglue.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dcache.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2_lockingver.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/time.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/kthread.h>",
            "#include <linux/mm.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct ocfs2_super *ocfs2_get_dentry_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_inode_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_file_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_qinfo_osb(struct ocfs2_lock_res *lockres);",
            "static void ocfs2_set_meta_lvb(struct ocfs2_lock_res *lockres);",
            "static void ocfs2_dentry_post_unlock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres);",
            "static void ocfs2_set_qinfo_lvb(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_downconvert_action(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_convert_action(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_attach_action(struct ocfs2_lock_res *lockres);",
            "static int ocfs2_generic_handle_bast(struct ocfs2_lock_res *lockres, int level);",
            "static void ocfs2_schedule_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static void ocfs2_downconvert_on_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static void ocfs2_drop_osb_locks(struct ocfs2_super *osb);",
            "static inline int ocfs2_highest_compat_lock_level(int level);",
            "static int ocfs2_prepare_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\t        struct ocfs2_lock_res *lockres);",
            "static int ocfs2_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static void ocfs2_process_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *lockres);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"stackglue.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dcache.h\"\n#include \"alloc.h\"\n#include \"ocfs2_lockingver.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/quotaops.h>\n#include <linux/time.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/pagemap.h>\n#include <linux/kthread.h>\n#include <linux/mm.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic struct ocfs2_super *ocfs2_get_dentry_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_inode_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_file_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_qinfo_osb(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_set_meta_lvb(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_dentry_post_unlock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres);\nstatic void ocfs2_set_qinfo_lvb(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_downconvert_action(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_convert_action(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_attach_action(struct ocfs2_lock_res *lockres);\nstatic int ocfs2_generic_handle_bast(struct ocfs2_lock_res *lockres, int level);\nstatic void ocfs2_schedule_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_downconvert_on_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_drop_osb_locks(struct ocfs2_super *osb);\nstatic inline int ocfs2_highest_compat_lock_level(int level);\nstatic int ocfs2_prepare_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\t        struct ocfs2_lock_res *lockres);\nstatic int ocfs2_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_process_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *lockres);\n\nstatic inline void ocfs2_cluster_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres,\n\t\t\t\t\tint level)\n{\n\t__ocfs2_cluster_unlock(osb, lockres, level, _RET_IP_);\n}"
        }
      },
      {
        "call_info": {
          "callee": "OCFS2_SB",
          "args": [
            "inode->i_sb"
          ],
          "line": 1703
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_mount_local",
          "args": [
            "osb"
          ],
          "line": 1702
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_mount_local",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "668-671",
          "snippet": "static inline int ocfs2_mount_local(struct ocfs2_super *osb)\n{\n\treturn (osb->s_feature_incompat & OCFS2_FEATURE_INCOMPAT_LOCAL_MOUNT);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\nstatic inline int ocfs2_mount_local(struct ocfs2_super *osb)\n{\n\treturn (osb->s_feature_incompat & OCFS2_FEATURE_INCOMPAT_LOCAL_MOUNT);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog",
          "args": [
            "0",
            "\"inode %llu drop %s RW lock\\n\"",
            "(unsigned long long)OCFS2_I(inode)->ip_blkno",
            "write ? \"EXMODE\" : \"PRMODE\""
          ],
          "line": 1698
        },
        "resolved": true,
        "details": {
          "function_name": "mlog_store",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/cluster/masklog.c",
          "lines": "115-121",
          "snippet": "static ssize_t mlog_store(struct kobject *obj, struct attribute *attr,\n\t\t\t  const char *buf, size_t count)\n{\n\tstruct mlog_attribute *mlog_attr = to_mlog_attr(attr);\n\n\treturn mlog_mask_store(mlog_attr->mask, buf, count);\n}",
          "includes": [
            "#include \"masklog.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/string.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"masklog.h\"\n#include <asm/uaccess.h>\n#include <linux/string.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n\nstatic ssize_t mlog_store(struct kobject *obj, struct attribute *attr,\n\t\t\t  const char *buf, size_t count)\n{\n\tstruct mlog_attribute *mlog_attr = to_mlog_attr(attr);\n\n\treturn mlog_mask_store(mlog_attr->mask, buf, count);\n}"
        }
      },
      {
        "call_info": {
          "callee": "OCFS2_I",
          "args": [
            "inode"
          ],
          "line": 1699
        },
        "resolved": true,
        "details": {
          "function_name": "OCFS2_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/inode.h",
          "lines": "118-121",
          "snippet": "static inline struct ocfs2_inode_info *OCFS2_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ocfs2_inode_info, vfs_inode);\n}",
          "includes": [
            "#include \"extent_map.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extent_map.h\"\n\nstatic inline struct ocfs2_inode_info *OCFS2_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ocfs2_inode_info, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "OCFS2_SB",
          "args": [
            "inode->i_sb"
          ],
          "line": 1696
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"stackglue.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dcache.h\"\n#include \"alloc.h\"\n#include \"ocfs2_lockingver.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/quotaops.h>\n#include <linux/time.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/pagemap.h>\n#include <linux/kthread.h>\n#include <linux/mm.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic struct ocfs2_super *ocfs2_get_dentry_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_inode_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_file_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_qinfo_osb(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_set_meta_lvb(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_dentry_post_unlock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres);\nstatic void ocfs2_set_qinfo_lvb(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_downconvert_action(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_convert_action(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_attach_action(struct ocfs2_lock_res *lockres);\nstatic int ocfs2_generic_handle_bast(struct ocfs2_lock_res *lockres, int level);\nstatic void ocfs2_schedule_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_downconvert_on_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_drop_osb_locks(struct ocfs2_super *osb);\nstatic inline int ocfs2_highest_compat_lock_level(int level);\nstatic int ocfs2_prepare_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\t        struct ocfs2_lock_res *lockres);\nstatic int ocfs2_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_process_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *lockres);\n\nvoid ocfs2_rw_unlock(struct inode *inode, int write)\n{\n\tint level = write ? DLM_LOCK_EX : DLM_LOCK_PR;\n\tstruct ocfs2_lock_res *lockres = &OCFS2_I(inode)->ip_rw_lockres;\n\tstruct ocfs2_super *osb = OCFS2_SB(inode->i_sb);\n\n\tmlog(0, \"inode %llu drop %s RW lock\\n\",\n\t     (unsigned long long)OCFS2_I(inode)->ip_blkno,\n\t     write ? \"EXMODE\" : \"PRMODE\");\n\n\tif (!ocfs2_mount_local(osb))\n\t\tocfs2_cluster_unlock(OCFS2_SB(inode->i_sb), lockres, level);\n}"
  },
  {
    "function_name": "ocfs2_rw_lock",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlmglue.c",
    "lines": "1665-1690",
    "snippet": "int ocfs2_rw_lock(struct inode *inode, int write)\n{\n\tint status, level;\n\tstruct ocfs2_lock_res *lockres;\n\tstruct ocfs2_super *osb = OCFS2_SB(inode->i_sb);\n\n\tBUG_ON(!inode);\n\n\tmlog(0, \"inode %llu take %s RW lock\\n\",\n\t     (unsigned long long)OCFS2_I(inode)->ip_blkno,\n\t     write ? \"EXMODE\" : \"PRMODE\");\n\n\tif (ocfs2_mount_local(osb))\n\t\treturn 0;\n\n\tlockres = &OCFS2_I(inode)->ip_rw_lockres;\n\n\tlevel = write ? DLM_LOCK_EX : DLM_LOCK_PR;\n\n\tstatus = ocfs2_cluster_lock(OCFS2_SB(inode->i_sb), lockres, level, 0,\n\t\t\t\t    0);\n\tif (status < 0)\n\t\tmlog_errno(status);\n\n\treturn status;\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"refcounttree.h\"",
      "#include \"quota.h\"",
      "#include \"uptodate.h\"",
      "#include \"super.h\"",
      "#include \"slot_map.h\"",
      "#include \"stackglue.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"heartbeat.h\"",
      "#include \"file.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"dcache.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2_lockingver.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/time.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/kthread.h>",
      "#include <linux/mm.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct ocfs2_super *ocfs2_get_dentry_osb(struct ocfs2_lock_res *lockres);",
      "static struct ocfs2_super *ocfs2_get_inode_osb(struct ocfs2_lock_res *lockres);",
      "static struct ocfs2_super *ocfs2_get_file_osb(struct ocfs2_lock_res *lockres);",
      "static struct ocfs2_super *ocfs2_get_qinfo_osb(struct ocfs2_lock_res *lockres);",
      "static void ocfs2_set_meta_lvb(struct ocfs2_lock_res *lockres);",
      "static void ocfs2_dentry_post_unlock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres);",
      "static void ocfs2_set_qinfo_lvb(struct ocfs2_lock_res *lockres);",
      "static inline void ocfs2_generic_handle_downconvert_action(struct ocfs2_lock_res *lockres);",
      "static inline void ocfs2_generic_handle_convert_action(struct ocfs2_lock_res *lockres);",
      "static inline void ocfs2_generic_handle_attach_action(struct ocfs2_lock_res *lockres);",
      "static int ocfs2_generic_handle_bast(struct ocfs2_lock_res *lockres, int level);",
      "static void ocfs2_schedule_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);",
      "static void ocfs2_downconvert_on_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);",
      "static void ocfs2_drop_osb_locks(struct ocfs2_super *osb);",
      "static inline int ocfs2_highest_compat_lock_level(int level);",
      "static int ocfs2_prepare_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\t        struct ocfs2_lock_res *lockres);",
      "static int ocfs2_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres);",
      "static void ocfs2_process_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *lockres);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "status"
          ],
          "line": 1687
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_cluster_lock",
          "args": [
            "OCFS2_SB(inode->i_sb)",
            "lockres",
            "level",
            "0",
            "0"
          ],
          "line": 1684
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_cluster_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlmglue.c",
          "lines": "1570-1578",
          "snippet": "static inline int ocfs2_cluster_lock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres,\n\t\t\t\t     int level,\n\t\t\t\t     u32 lkm_flags,\n\t\t\t\t     int arg_flags)\n{\n\treturn __ocfs2_cluster_lock(osb, lockres, level, lkm_flags, arg_flags,\n\t\t\t\t    0, _RET_IP_);\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"refcounttree.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"stackglue.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dcache.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2_lockingver.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/time.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/kthread.h>",
            "#include <linux/mm.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct ocfs2_super *ocfs2_get_dentry_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_inode_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_file_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_qinfo_osb(struct ocfs2_lock_res *lockres);",
            "static void ocfs2_set_meta_lvb(struct ocfs2_lock_res *lockres);",
            "static void ocfs2_dentry_post_unlock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres);",
            "static void ocfs2_set_qinfo_lvb(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_downconvert_action(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_convert_action(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_attach_action(struct ocfs2_lock_res *lockres);",
            "static int ocfs2_generic_handle_bast(struct ocfs2_lock_res *lockres, int level);",
            "static void ocfs2_schedule_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static void ocfs2_downconvert_on_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static void ocfs2_drop_osb_locks(struct ocfs2_super *osb);",
            "static inline int ocfs2_highest_compat_lock_level(int level);",
            "static int ocfs2_prepare_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\t        struct ocfs2_lock_res *lockres);",
            "static int ocfs2_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static void ocfs2_process_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *lockres);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"stackglue.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dcache.h\"\n#include \"alloc.h\"\n#include \"ocfs2_lockingver.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/quotaops.h>\n#include <linux/time.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/pagemap.h>\n#include <linux/kthread.h>\n#include <linux/mm.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic struct ocfs2_super *ocfs2_get_dentry_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_inode_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_file_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_qinfo_osb(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_set_meta_lvb(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_dentry_post_unlock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres);\nstatic void ocfs2_set_qinfo_lvb(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_downconvert_action(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_convert_action(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_attach_action(struct ocfs2_lock_res *lockres);\nstatic int ocfs2_generic_handle_bast(struct ocfs2_lock_res *lockres, int level);\nstatic void ocfs2_schedule_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_downconvert_on_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_drop_osb_locks(struct ocfs2_super *osb);\nstatic inline int ocfs2_highest_compat_lock_level(int level);\nstatic int ocfs2_prepare_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\t        struct ocfs2_lock_res *lockres);\nstatic int ocfs2_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_process_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *lockres);\n\nstatic inline int ocfs2_cluster_lock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres,\n\t\t\t\t     int level,\n\t\t\t\t     u32 lkm_flags,\n\t\t\t\t     int arg_flags)\n{\n\treturn __ocfs2_cluster_lock(osb, lockres, level, lkm_flags, arg_flags,\n\t\t\t\t    0, _RET_IP_);\n}"
        }
      },
      {
        "call_info": {
          "callee": "OCFS2_SB",
          "args": [
            "inode->i_sb"
          ],
          "line": 1684
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "OCFS2_I",
          "args": [
            "inode"
          ],
          "line": 1680
        },
        "resolved": true,
        "details": {
          "function_name": "OCFS2_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/inode.h",
          "lines": "118-121",
          "snippet": "static inline struct ocfs2_inode_info *OCFS2_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ocfs2_inode_info, vfs_inode);\n}",
          "includes": [
            "#include \"extent_map.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extent_map.h\"\n\nstatic inline struct ocfs2_inode_info *OCFS2_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ocfs2_inode_info, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_mount_local",
          "args": [
            "osb"
          ],
          "line": 1677
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_mount_local",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "668-671",
          "snippet": "static inline int ocfs2_mount_local(struct ocfs2_super *osb)\n{\n\treturn (osb->s_feature_incompat & OCFS2_FEATURE_INCOMPAT_LOCAL_MOUNT);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\nstatic inline int ocfs2_mount_local(struct ocfs2_super *osb)\n{\n\treturn (osb->s_feature_incompat & OCFS2_FEATURE_INCOMPAT_LOCAL_MOUNT);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog",
          "args": [
            "0",
            "\"inode %llu take %s RW lock\\n\"",
            "(unsigned long long)OCFS2_I(inode)->ip_blkno",
            "write ? \"EXMODE\" : \"PRMODE\""
          ],
          "line": 1673
        },
        "resolved": true,
        "details": {
          "function_name": "mlog_store",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/cluster/masklog.c",
          "lines": "115-121",
          "snippet": "static ssize_t mlog_store(struct kobject *obj, struct attribute *attr,\n\t\t\t  const char *buf, size_t count)\n{\n\tstruct mlog_attribute *mlog_attr = to_mlog_attr(attr);\n\n\treturn mlog_mask_store(mlog_attr->mask, buf, count);\n}",
          "includes": [
            "#include \"masklog.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/string.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"masklog.h\"\n#include <asm/uaccess.h>\n#include <linux/string.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n\nstatic ssize_t mlog_store(struct kobject *obj, struct attribute *attr,\n\t\t\t  const char *buf, size_t count)\n{\n\tstruct mlog_attribute *mlog_attr = to_mlog_attr(attr);\n\n\treturn mlog_mask_store(mlog_attr->mask, buf, count);\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!inode"
          ],
          "line": 1671
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "OCFS2_SB",
          "args": [
            "inode->i_sb"
          ],
          "line": 1669
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"stackglue.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dcache.h\"\n#include \"alloc.h\"\n#include \"ocfs2_lockingver.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/quotaops.h>\n#include <linux/time.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/pagemap.h>\n#include <linux/kthread.h>\n#include <linux/mm.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic struct ocfs2_super *ocfs2_get_dentry_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_inode_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_file_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_qinfo_osb(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_set_meta_lvb(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_dentry_post_unlock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres);\nstatic void ocfs2_set_qinfo_lvb(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_downconvert_action(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_convert_action(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_attach_action(struct ocfs2_lock_res *lockres);\nstatic int ocfs2_generic_handle_bast(struct ocfs2_lock_res *lockres, int level);\nstatic void ocfs2_schedule_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_downconvert_on_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_drop_osb_locks(struct ocfs2_super *osb);\nstatic inline int ocfs2_highest_compat_lock_level(int level);\nstatic int ocfs2_prepare_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\t        struct ocfs2_lock_res *lockres);\nstatic int ocfs2_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_process_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *lockres);\n\nint ocfs2_rw_lock(struct inode *inode, int write)\n{\n\tint status, level;\n\tstruct ocfs2_lock_res *lockres;\n\tstruct ocfs2_super *osb = OCFS2_SB(inode->i_sb);\n\n\tBUG_ON(!inode);\n\n\tmlog(0, \"inode %llu take %s RW lock\\n\",\n\t     (unsigned long long)OCFS2_I(inode)->ip_blkno,\n\t     write ? \"EXMODE\" : \"PRMODE\");\n\n\tif (ocfs2_mount_local(osb))\n\t\treturn 0;\n\n\tlockres = &OCFS2_I(inode)->ip_rw_lockres;\n\n\tlevel = write ? DLM_LOCK_EX : DLM_LOCK_PR;\n\n\tstatus = ocfs2_cluster_lock(OCFS2_SB(inode->i_sb), lockres, level, 0,\n\t\t\t\t    0);\n\tif (status < 0)\n\t\tmlog_errno(status);\n\n\treturn status;\n}"
  },
  {
    "function_name": "ocfs2_create_new_inode_locks",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlmglue.c",
    "lines": "1621-1663",
    "snippet": "int ocfs2_create_new_inode_locks(struct inode *inode)\n{\n\tint ret;\n\tstruct ocfs2_super *osb = OCFS2_SB(inode->i_sb);\n\n\tBUG_ON(!inode);\n\tBUG_ON(!ocfs2_inode_is_new(inode));\n\n\tmlog(0, \"Inode %llu\\n\", (unsigned long long)OCFS2_I(inode)->ip_blkno);\n\n\t/* NOTE: That we don't increment any of the holder counts, nor\n\t * do we add anything to a journal handle. Since this is\n\t * supposed to be a new inode which the cluster doesn't know\n\t * about yet, there is no need to.  As far as the LVB handling\n\t * is concerned, this is basically like acquiring an EX lock\n\t * on a resource which has an invalid one -- we'll set it\n\t * valid when we release the EX. */\n\n\tret = ocfs2_create_new_lock(osb, &OCFS2_I(inode)->ip_rw_lockres, 1, 1);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto bail;\n\t}\n\n\t/*\n\t * We don't want to use DLM_LKF_LOCAL on a meta data lock as they\n\t * don't use a generation in their lock names.\n\t */\n\tret = ocfs2_create_new_lock(osb, &OCFS2_I(inode)->ip_inode_lockres, 1, 0);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto bail;\n\t}\n\n\tret = ocfs2_create_new_lock(osb, &OCFS2_I(inode)->ip_open_lockres, 0, 0);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto bail;\n\t}\n\nbail:\n\treturn ret;\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"refcounttree.h\"",
      "#include \"quota.h\"",
      "#include \"uptodate.h\"",
      "#include \"super.h\"",
      "#include \"slot_map.h\"",
      "#include \"stackglue.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"heartbeat.h\"",
      "#include \"file.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"dcache.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2_lockingver.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/time.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/kthread.h>",
      "#include <linux/mm.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void ocfs2_drop_osb_locks(struct ocfs2_super *osb);",
      "static int ocfs2_downconvert_lock(struct ocfs2_super *osb,\n\t\t\t\t  struct ocfs2_lock_res *lockres,\n\t\t\t\t  int new_level,\n\t\t\t\t  int lvb,\n\t\t\t\t  unsigned int generation);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 1657
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_create_new_lock",
          "args": [
            "osb",
            "&OCFS2_I(inode)->ip_open_lockres",
            "0",
            "0"
          ],
          "line": 1655
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_create_new_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlmglue.c",
          "lines": "1598-1613",
          "snippet": "static int ocfs2_create_new_lock(struct ocfs2_super *osb,\n\t\t\t\t struct ocfs2_lock_res *lockres,\n\t\t\t\t int ex,\n\t\t\t\t int local)\n{\n\tint level =  ex ? DLM_LOCK_EX : DLM_LOCK_PR;\n\tunsigned long flags;\n\tu32 lkm_flags = local ? DLM_LKF_LOCAL : 0;\n\n\tspin_lock_irqsave(&lockres->l_lock, flags);\n\tBUG_ON(lockres->l_flags & OCFS2_LOCK_ATTACHED);\n\tlockres_or_flags(lockres, OCFS2_LOCK_LOCAL);\n\tspin_unlock_irqrestore(&lockres->l_lock, flags);\n\n\treturn ocfs2_lock_create(osb, lockres, level, lkm_flags);\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"refcounttree.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"stackglue.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dcache.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2_lockingver.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/time.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/kthread.h>",
            "#include <linux/mm.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct ocfs2_super *ocfs2_get_dentry_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_inode_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_file_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_qinfo_osb(struct ocfs2_lock_res *lockres);",
            "static void ocfs2_set_meta_lvb(struct ocfs2_lock_res *lockres);",
            "static void ocfs2_dentry_post_unlock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres);",
            "static void ocfs2_set_qinfo_lvb(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_downconvert_action(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_convert_action(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_attach_action(struct ocfs2_lock_res *lockres);",
            "static int ocfs2_generic_handle_bast(struct ocfs2_lock_res *lockres, int level);",
            "static void ocfs2_schedule_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static void ocfs2_downconvert_on_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static void ocfs2_drop_osb_locks(struct ocfs2_super *osb);",
            "static inline int ocfs2_highest_compat_lock_level(int level);",
            "static int ocfs2_prepare_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\t        struct ocfs2_lock_res *lockres);",
            "static int ocfs2_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static void ocfs2_process_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *lockres);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"stackglue.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dcache.h\"\n#include \"alloc.h\"\n#include \"ocfs2_lockingver.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/quotaops.h>\n#include <linux/time.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/pagemap.h>\n#include <linux/kthread.h>\n#include <linux/mm.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic struct ocfs2_super *ocfs2_get_dentry_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_inode_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_file_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_qinfo_osb(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_set_meta_lvb(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_dentry_post_unlock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres);\nstatic void ocfs2_set_qinfo_lvb(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_downconvert_action(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_convert_action(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_attach_action(struct ocfs2_lock_res *lockres);\nstatic int ocfs2_generic_handle_bast(struct ocfs2_lock_res *lockres, int level);\nstatic void ocfs2_schedule_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_downconvert_on_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_drop_osb_locks(struct ocfs2_super *osb);\nstatic inline int ocfs2_highest_compat_lock_level(int level);\nstatic int ocfs2_prepare_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\t        struct ocfs2_lock_res *lockres);\nstatic int ocfs2_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_process_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *lockres);\n\nstatic int ocfs2_create_new_lock(struct ocfs2_super *osb,\n\t\t\t\t struct ocfs2_lock_res *lockres,\n\t\t\t\t int ex,\n\t\t\t\t int local)\n{\n\tint level =  ex ? DLM_LOCK_EX : DLM_LOCK_PR;\n\tunsigned long flags;\n\tu32 lkm_flags = local ? DLM_LKF_LOCAL : 0;\n\n\tspin_lock_irqsave(&lockres->l_lock, flags);\n\tBUG_ON(lockres->l_flags & OCFS2_LOCK_ATTACHED);\n\tlockres_or_flags(lockres, OCFS2_LOCK_LOCAL);\n\tspin_unlock_irqrestore(&lockres->l_lock, flags);\n\n\treturn ocfs2_lock_create(osb, lockres, level, lkm_flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "OCFS2_I",
          "args": [
            "inode"
          ],
          "line": 1655
        },
        "resolved": true,
        "details": {
          "function_name": "OCFS2_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/inode.h",
          "lines": "118-121",
          "snippet": "static inline struct ocfs2_inode_info *OCFS2_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ocfs2_inode_info, vfs_inode);\n}",
          "includes": [
            "#include \"extent_map.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extent_map.h\"\n\nstatic inline struct ocfs2_inode_info *OCFS2_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ocfs2_inode_info, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 1651
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 1641
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mlog",
          "args": [
            "0",
            "\"Inode %llu\\n\"",
            "(unsigned long long)OCFS2_I(inode)->ip_blkno"
          ],
          "line": 1629
        },
        "resolved": true,
        "details": {
          "function_name": "mlog_show",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/cluster/masklog.c",
          "lines": "107-113",
          "snippet": "static ssize_t mlog_show(struct kobject *obj, struct attribute *attr,\n\t\t\t char *buf)\n{\n\tstruct mlog_attribute *mlog_attr = to_mlog_attr(attr);\n\n\treturn mlog_mask_show(mlog_attr->mask, buf);\n}",
          "includes": [
            "#include \"masklog.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/string.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"masklog.h\"\n#include <asm/uaccess.h>\n#include <linux/string.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n\nstatic ssize_t mlog_show(struct kobject *obj, struct attribute *attr,\n\t\t\t char *buf)\n{\n\tstruct mlog_attribute *mlog_attr = to_mlog_attr(attr);\n\n\treturn mlog_mask_show(mlog_attr->mask, buf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!ocfs2_inode_is_new(inode)"
          ],
          "line": 1627
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_inode_is_new",
          "args": [
            "inode"
          ],
          "line": 1627
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_inode_is_new",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/journal.h",
          "lines": "138-147",
          "snippet": "static inline int ocfs2_inode_is_new(struct inode *inode)\n{\n\t/* System files are never \"new\" as they're written out by\n\t * mkfs. This helps us early during mount, before we have the\n\t * journal open and j_trans_id could be junk. */\n\tif (OCFS2_I(inode)->ip_flags & OCFS2_INODE_SYSTEM_FILE)\n\t\treturn 0;\n\n\treturn ocfs2_ci_is_new(INODE_CACHE(inode));\n}",
          "includes": [
            "#include <linux/jbd2.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/jbd2.h>\n#include <linux/fs.h>\n\nstatic inline int ocfs2_inode_is_new(struct inode *inode)\n{\n\t/* System files are never \"new\" as they're written out by\n\t * mkfs. This helps us early during mount, before we have the\n\t * journal open and j_trans_id could be junk. */\n\tif (OCFS2_I(inode)->ip_flags & OCFS2_INODE_SYSTEM_FILE)\n\t\treturn 0;\n\n\treturn ocfs2_ci_is_new(INODE_CACHE(inode));\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!inode"
          ],
          "line": 1626
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "OCFS2_SB",
          "args": [
            "inode->i_sb"
          ],
          "line": 1624
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"stackglue.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dcache.h\"\n#include \"alloc.h\"\n#include \"ocfs2_lockingver.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/quotaops.h>\n#include <linux/time.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/pagemap.h>\n#include <linux/kthread.h>\n#include <linux/mm.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic void ocfs2_drop_osb_locks(struct ocfs2_super *osb);\nstatic int ocfs2_downconvert_lock(struct ocfs2_super *osb,\n\t\t\t\t  struct ocfs2_lock_res *lockres,\n\t\t\t\t  int new_level,\n\t\t\t\t  int lvb,\n\t\t\t\t  unsigned int generation);\n\nint ocfs2_create_new_inode_locks(struct inode *inode)\n{\n\tint ret;\n\tstruct ocfs2_super *osb = OCFS2_SB(inode->i_sb);\n\n\tBUG_ON(!inode);\n\tBUG_ON(!ocfs2_inode_is_new(inode));\n\n\tmlog(0, \"Inode %llu\\n\", (unsigned long long)OCFS2_I(inode)->ip_blkno);\n\n\t/* NOTE: That we don't increment any of the holder counts, nor\n\t * do we add anything to a journal handle. Since this is\n\t * supposed to be a new inode which the cluster doesn't know\n\t * about yet, there is no need to.  As far as the LVB handling\n\t * is concerned, this is basically like acquiring an EX lock\n\t * on a resource which has an invalid one -- we'll set it\n\t * valid when we release the EX. */\n\n\tret = ocfs2_create_new_lock(osb, &OCFS2_I(inode)->ip_rw_lockres, 1, 1);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto bail;\n\t}\n\n\t/*\n\t * We don't want to use DLM_LKF_LOCAL on a meta data lock as they\n\t * don't use a generation in their lock names.\n\t */\n\tret = ocfs2_create_new_lock(osb, &OCFS2_I(inode)->ip_inode_lockres, 1, 0);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto bail;\n\t}\n\n\tret = ocfs2_create_new_lock(osb, &OCFS2_I(inode)->ip_open_lockres, 0, 0);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto bail;\n\t}\n\nbail:\n\treturn ret;\n}"
  },
  {
    "function_name": "ocfs2_create_new_lock",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlmglue.c",
    "lines": "1598-1613",
    "snippet": "static int ocfs2_create_new_lock(struct ocfs2_super *osb,\n\t\t\t\t struct ocfs2_lock_res *lockres,\n\t\t\t\t int ex,\n\t\t\t\t int local)\n{\n\tint level =  ex ? DLM_LOCK_EX : DLM_LOCK_PR;\n\tunsigned long flags;\n\tu32 lkm_flags = local ? DLM_LKF_LOCAL : 0;\n\n\tspin_lock_irqsave(&lockres->l_lock, flags);\n\tBUG_ON(lockres->l_flags & OCFS2_LOCK_ATTACHED);\n\tlockres_or_flags(lockres, OCFS2_LOCK_LOCAL);\n\tspin_unlock_irqrestore(&lockres->l_lock, flags);\n\n\treturn ocfs2_lock_create(osb, lockres, level, lkm_flags);\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"refcounttree.h\"",
      "#include \"quota.h\"",
      "#include \"uptodate.h\"",
      "#include \"super.h\"",
      "#include \"slot_map.h\"",
      "#include \"stackglue.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"heartbeat.h\"",
      "#include \"file.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"dcache.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2_lockingver.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/time.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/kthread.h>",
      "#include <linux/mm.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct ocfs2_super *ocfs2_get_dentry_osb(struct ocfs2_lock_res *lockres);",
      "static struct ocfs2_super *ocfs2_get_inode_osb(struct ocfs2_lock_res *lockres);",
      "static struct ocfs2_super *ocfs2_get_file_osb(struct ocfs2_lock_res *lockres);",
      "static struct ocfs2_super *ocfs2_get_qinfo_osb(struct ocfs2_lock_res *lockres);",
      "static void ocfs2_set_meta_lvb(struct ocfs2_lock_res *lockres);",
      "static void ocfs2_dentry_post_unlock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres);",
      "static void ocfs2_set_qinfo_lvb(struct ocfs2_lock_res *lockres);",
      "static inline void ocfs2_generic_handle_downconvert_action(struct ocfs2_lock_res *lockres);",
      "static inline void ocfs2_generic_handle_convert_action(struct ocfs2_lock_res *lockres);",
      "static inline void ocfs2_generic_handle_attach_action(struct ocfs2_lock_res *lockres);",
      "static int ocfs2_generic_handle_bast(struct ocfs2_lock_res *lockres, int level);",
      "static void ocfs2_schedule_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);",
      "static void ocfs2_downconvert_on_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);",
      "static void ocfs2_drop_osb_locks(struct ocfs2_super *osb);",
      "static inline int ocfs2_highest_compat_lock_level(int level);",
      "static int ocfs2_prepare_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\t        struct ocfs2_lock_res *lockres);",
      "static int ocfs2_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres);",
      "static void ocfs2_process_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *lockres);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ocfs2_lock_create",
          "args": [
            "osb",
            "lockres",
            "level",
            "lkm_flags"
          ],
          "line": 1612
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_lock_create",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlmglue.c",
          "lines": "1220-1261",
          "snippet": "static int ocfs2_lock_create(struct ocfs2_super *osb,\n\t\t\t     struct ocfs2_lock_res *lockres,\n\t\t\t     int level,\n\t\t\t     u32 dlm_flags)\n{\n\tint ret = 0;\n\tunsigned long flags;\n\tunsigned int gen;\n\n\tmlog(0, \"lock %s, level = %d, flags = %u\\n\", lockres->l_name, level,\n\t     dlm_flags);\n\n\tspin_lock_irqsave(&lockres->l_lock, flags);\n\tif ((lockres->l_flags & OCFS2_LOCK_ATTACHED) ||\n\t    (lockres->l_flags & OCFS2_LOCK_BUSY)) {\n\t\tspin_unlock_irqrestore(&lockres->l_lock, flags);\n\t\tgoto bail;\n\t}\n\n\tlockres->l_action = OCFS2_AST_ATTACH;\n\tlockres->l_requested = level;\n\tlockres_or_flags(lockres, OCFS2_LOCK_BUSY);\n\tgen = lockres_set_pending(lockres);\n\tspin_unlock_irqrestore(&lockres->l_lock, flags);\n\n\tret = ocfs2_dlm_lock(osb->cconn,\n\t\t\t     level,\n\t\t\t     &lockres->l_lksb,\n\t\t\t     dlm_flags,\n\t\t\t     lockres->l_name,\n\t\t\t     OCFS2_LOCK_ID_MAX_LEN - 1);\n\tlockres_clear_pending(lockres, gen, osb);\n\tif (ret) {\n\t\tocfs2_log_dlm_error(\"ocfs2_dlm_lock\", ret, lockres);\n\t\tocfs2_recover_from_dlm_error(lockres, 1);\n\t}\n\n\tmlog(0, \"lock %s, return from ocfs2_dlm_lock\\n\", lockres->l_name);\n\nbail:\n\treturn ret;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"refcounttree.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"stackglue.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dcache.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2_lockingver.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/time.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/kthread.h>",
            "#include <linux/mm.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct ocfs2_super *ocfs2_get_dentry_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_inode_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_file_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_qinfo_osb(struct ocfs2_lock_res *lockres);",
            "static void ocfs2_set_meta_lvb(struct ocfs2_lock_res *lockres);",
            "static void ocfs2_dentry_post_unlock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres);",
            "static void ocfs2_set_qinfo_lvb(struct ocfs2_lock_res *lockres);",
            "static int ocfs2_lock_create(struct ocfs2_super *osb,\n\t\t\t     struct ocfs2_lock_res *lockres,\n\t\t\t     int level,\n\t\t\t     u32 dlm_flags);",
            "static inline void ocfs2_generic_handle_downconvert_action(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_convert_action(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_attach_action(struct ocfs2_lock_res *lockres);",
            "static int ocfs2_generic_handle_bast(struct ocfs2_lock_res *lockres, int level);",
            "static void ocfs2_schedule_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static void ocfs2_downconvert_on_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static void ocfs2_drop_osb_locks(struct ocfs2_super *osb);",
            "static inline int ocfs2_highest_compat_lock_level(int level);",
            "static int ocfs2_prepare_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\t        struct ocfs2_lock_res *lockres);",
            "static int ocfs2_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static void ocfs2_process_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *lockres);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"stackglue.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dcache.h\"\n#include \"alloc.h\"\n#include \"ocfs2_lockingver.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/quotaops.h>\n#include <linux/time.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/pagemap.h>\n#include <linux/kthread.h>\n#include <linux/mm.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic struct ocfs2_super *ocfs2_get_dentry_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_inode_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_file_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_qinfo_osb(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_set_meta_lvb(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_dentry_post_unlock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres);\nstatic void ocfs2_set_qinfo_lvb(struct ocfs2_lock_res *lockres);\nstatic int ocfs2_lock_create(struct ocfs2_super *osb,\n\t\t\t     struct ocfs2_lock_res *lockres,\n\t\t\t     int level,\n\t\t\t     u32 dlm_flags);\nstatic inline void ocfs2_generic_handle_downconvert_action(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_convert_action(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_attach_action(struct ocfs2_lock_res *lockres);\nstatic int ocfs2_generic_handle_bast(struct ocfs2_lock_res *lockres, int level);\nstatic void ocfs2_schedule_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_downconvert_on_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_drop_osb_locks(struct ocfs2_super *osb);\nstatic inline int ocfs2_highest_compat_lock_level(int level);\nstatic int ocfs2_prepare_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\t        struct ocfs2_lock_res *lockres);\nstatic int ocfs2_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_process_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *lockres);\n\nstatic int ocfs2_lock_create(struct ocfs2_super *osb,\n\t\t\t     struct ocfs2_lock_res *lockres,\n\t\t\t     int level,\n\t\t\t     u32 dlm_flags)\n{\n\tint ret = 0;\n\tunsigned long flags;\n\tunsigned int gen;\n\n\tmlog(0, \"lock %s, level = %d, flags = %u\\n\", lockres->l_name, level,\n\t     dlm_flags);\n\n\tspin_lock_irqsave(&lockres->l_lock, flags);\n\tif ((lockres->l_flags & OCFS2_LOCK_ATTACHED) ||\n\t    (lockres->l_flags & OCFS2_LOCK_BUSY)) {\n\t\tspin_unlock_irqrestore(&lockres->l_lock, flags);\n\t\tgoto bail;\n\t}\n\n\tlockres->l_action = OCFS2_AST_ATTACH;\n\tlockres->l_requested = level;\n\tlockres_or_flags(lockres, OCFS2_LOCK_BUSY);\n\tgen = lockres_set_pending(lockres);\n\tspin_unlock_irqrestore(&lockres->l_lock, flags);\n\n\tret = ocfs2_dlm_lock(osb->cconn,\n\t\t\t     level,\n\t\t\t     &lockres->l_lksb,\n\t\t\t     dlm_flags,\n\t\t\t     lockres->l_name,\n\t\t\t     OCFS2_LOCK_ID_MAX_LEN - 1);\n\tlockres_clear_pending(lockres, gen, osb);\n\tif (ret) {\n\t\tocfs2_log_dlm_error(\"ocfs2_dlm_lock\", ret, lockres);\n\t\tocfs2_recover_from_dlm_error(lockres, 1);\n\t}\n\n\tmlog(0, \"lock %s, return from ocfs2_dlm_lock\\n\", lockres->l_name);\n\nbail:\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock_irqrestore",
          "args": [
            "&lockres->l_lock",
            "flags"
          ],
          "line": 1610
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lockres_or_flags",
          "args": [
            "lockres",
            "OCFS2_LOCK_LOCAL"
          ],
          "line": 1609
        },
        "resolved": true,
        "details": {
          "function_name": "lockres_or_flags",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlmglue.c",
          "lines": "819-822",
          "snippet": "static void lockres_or_flags(struct ocfs2_lock_res *lockres, unsigned long or)\n{\n\tlockres_set_flags(lockres, lockres->l_flags | or);\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"refcounttree.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"stackglue.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dcache.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2_lockingver.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/time.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/kthread.h>",
            "#include <linux/mm.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct ocfs2_super *ocfs2_get_dentry_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_inode_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_file_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_qinfo_osb(struct ocfs2_lock_res *lockres);",
            "static void ocfs2_set_meta_lvb(struct ocfs2_lock_res *lockres);",
            "static void ocfs2_dentry_post_unlock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres);",
            "static void ocfs2_set_qinfo_lvb(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_downconvert_action(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_convert_action(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_attach_action(struct ocfs2_lock_res *lockres);",
            "static void ocfs2_schedule_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static void ocfs2_downconvert_on_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static int ocfs2_prepare_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\t        struct ocfs2_lock_res *lockres);",
            "static int ocfs2_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static void ocfs2_process_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *lockres);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"stackglue.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dcache.h\"\n#include \"alloc.h\"\n#include \"ocfs2_lockingver.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/quotaops.h>\n#include <linux/time.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/pagemap.h>\n#include <linux/kthread.h>\n#include <linux/mm.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic struct ocfs2_super *ocfs2_get_dentry_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_inode_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_file_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_qinfo_osb(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_set_meta_lvb(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_dentry_post_unlock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres);\nstatic void ocfs2_set_qinfo_lvb(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_downconvert_action(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_convert_action(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_attach_action(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_schedule_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_downconvert_on_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic int ocfs2_prepare_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\t        struct ocfs2_lock_res *lockres);\nstatic int ocfs2_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_process_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *lockres);\n\nstatic void lockres_or_flags(struct ocfs2_lock_res *lockres, unsigned long or)\n{\n\tlockres_set_flags(lockres, lockres->l_flags | or);\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "lockres->l_flags & OCFS2_LOCK_ATTACHED"
          ],
          "line": 1608
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock_irqsave",
          "args": [
            "&lockres->l_lock",
            "flags"
          ],
          "line": 1607
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"stackglue.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dcache.h\"\n#include \"alloc.h\"\n#include \"ocfs2_lockingver.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/quotaops.h>\n#include <linux/time.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/pagemap.h>\n#include <linux/kthread.h>\n#include <linux/mm.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic struct ocfs2_super *ocfs2_get_dentry_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_inode_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_file_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_qinfo_osb(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_set_meta_lvb(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_dentry_post_unlock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres);\nstatic void ocfs2_set_qinfo_lvb(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_downconvert_action(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_convert_action(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_attach_action(struct ocfs2_lock_res *lockres);\nstatic int ocfs2_generic_handle_bast(struct ocfs2_lock_res *lockres, int level);\nstatic void ocfs2_schedule_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_downconvert_on_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_drop_osb_locks(struct ocfs2_super *osb);\nstatic inline int ocfs2_highest_compat_lock_level(int level);\nstatic int ocfs2_prepare_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\t        struct ocfs2_lock_res *lockres);\nstatic int ocfs2_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_process_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *lockres);\n\nstatic int ocfs2_create_new_lock(struct ocfs2_super *osb,\n\t\t\t\t struct ocfs2_lock_res *lockres,\n\t\t\t\t int ex,\n\t\t\t\t int local)\n{\n\tint level =  ex ? DLM_LOCK_EX : DLM_LOCK_PR;\n\tunsigned long flags;\n\tu32 lkm_flags = local ? DLM_LKF_LOCAL : 0;\n\n\tspin_lock_irqsave(&lockres->l_lock, flags);\n\tBUG_ON(lockres->l_flags & OCFS2_LOCK_ATTACHED);\n\tlockres_or_flags(lockres, OCFS2_LOCK_LOCAL);\n\tspin_unlock_irqrestore(&lockres->l_lock, flags);\n\n\treturn ocfs2_lock_create(osb, lockres, level, lkm_flags);\n}"
  },
  {
    "function_name": "__ocfs2_cluster_unlock",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlmglue.c",
    "lines": "1581-1596",
    "snippet": "static void __ocfs2_cluster_unlock(struct ocfs2_super *osb,\n\t\t\t\t   struct ocfs2_lock_res *lockres,\n\t\t\t\t   int level,\n\t\t\t\t   unsigned long caller_ip)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&lockres->l_lock, flags);\n\tocfs2_dec_holders(lockres, level);\n\tocfs2_downconvert_on_unlock(osb, lockres);\n\tspin_unlock_irqrestore(&lockres->l_lock, flags);\n#ifdef CONFIG_DEBUG_LOCK_ALLOC\n\tif (lockres->l_lockdep_map.key != NULL)\n\t\trwsem_release(&lockres->l_lockdep_map, 1, caller_ip);\n#endif\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"refcounttree.h\"",
      "#include \"quota.h\"",
      "#include \"uptodate.h\"",
      "#include \"super.h\"",
      "#include \"slot_map.h\"",
      "#include \"stackglue.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"heartbeat.h\"",
      "#include \"file.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"dcache.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2_lockingver.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/time.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/kthread.h>",
      "#include <linux/mm.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct ocfs2_super *ocfs2_get_dentry_osb(struct ocfs2_lock_res *lockres);",
      "static struct ocfs2_super *ocfs2_get_inode_osb(struct ocfs2_lock_res *lockres);",
      "static struct ocfs2_super *ocfs2_get_file_osb(struct ocfs2_lock_res *lockres);",
      "static struct ocfs2_super *ocfs2_get_qinfo_osb(struct ocfs2_lock_res *lockres);",
      "static void ocfs2_set_meta_lvb(struct ocfs2_lock_res *lockres);",
      "static void ocfs2_dentry_post_unlock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres);",
      "static void ocfs2_set_qinfo_lvb(struct ocfs2_lock_res *lockres);",
      "static void __ocfs2_cluster_unlock(struct ocfs2_super *osb,\n\t\t\t\t   struct ocfs2_lock_res *lockres,\n\t\t\t\t   int level, unsigned long caller_ip);",
      "static inline void ocfs2_generic_handle_downconvert_action(struct ocfs2_lock_res *lockres);",
      "static inline void ocfs2_generic_handle_convert_action(struct ocfs2_lock_res *lockres);",
      "static inline void ocfs2_generic_handle_attach_action(struct ocfs2_lock_res *lockres);",
      "static int ocfs2_generic_handle_bast(struct ocfs2_lock_res *lockres, int level);",
      "static void ocfs2_schedule_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);",
      "static void ocfs2_downconvert_on_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);",
      "static void ocfs2_drop_osb_locks(struct ocfs2_super *osb);",
      "static inline int ocfs2_highest_compat_lock_level(int level);",
      "static int ocfs2_prepare_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\t        struct ocfs2_lock_res *lockres);",
      "static int ocfs2_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres);",
      "static void ocfs2_process_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *lockres);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "rwsem_release",
          "args": [
            "&lockres->l_lockdep_map",
            "1",
            "caller_ip"
          ],
          "line": 1594
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock_irqrestore",
          "args": [
            "&lockres->l_lock",
            "flags"
          ],
          "line": 1591
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_downconvert_on_unlock",
          "args": [
            "osb",
            "lockres"
          ],
          "line": 1590
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_downconvert_on_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlmglue.c",
          "lines": "2005-2030",
          "snippet": "static void ocfs2_downconvert_on_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres)\n{\n\tint kick = 0;\n\n\t/* If we know that another node is waiting on our lock, kick\n\t * the downconvert thread * pre-emptively when we reach a release\n\t * condition. */\n\tif (lockres->l_flags & OCFS2_LOCK_BLOCKED) {\n\t\tswitch(lockres->l_blocking) {\n\t\tcase DLM_LOCK_EX:\n\t\t\tif (!lockres->l_ex_holders && !lockres->l_ro_holders)\n\t\t\t\tkick = 1;\n\t\t\tbreak;\n\t\tcase DLM_LOCK_PR:\n\t\t\tif (!lockres->l_ex_holders)\n\t\t\t\tkick = 1;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tBUG();\n\t\t}\n\t}\n\n\tif (kick)\n\t\tocfs2_wake_downconvert_thread(osb);\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"refcounttree.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"stackglue.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dcache.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2_lockingver.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/time.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/kthread.h>",
            "#include <linux/mm.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct ocfs2_super *ocfs2_get_dentry_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_inode_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_file_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_qinfo_osb(struct ocfs2_lock_res *lockres);",
            "static void ocfs2_set_meta_lvb(struct ocfs2_lock_res *lockres);",
            "static void ocfs2_dentry_post_unlock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres);",
            "static void ocfs2_set_qinfo_lvb(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_downconvert_action(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_convert_action(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_attach_action(struct ocfs2_lock_res *lockres);",
            "static void ocfs2_schedule_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static void ocfs2_downconvert_on_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static void ocfs2_drop_osb_locks(struct ocfs2_super *osb);",
            "static int ocfs2_prepare_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\t        struct ocfs2_lock_res *lockres);",
            "static int ocfs2_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static void ocfs2_process_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *lockres);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"stackglue.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dcache.h\"\n#include \"alloc.h\"\n#include \"ocfs2_lockingver.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/quotaops.h>\n#include <linux/time.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/pagemap.h>\n#include <linux/kthread.h>\n#include <linux/mm.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic struct ocfs2_super *ocfs2_get_dentry_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_inode_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_file_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_qinfo_osb(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_set_meta_lvb(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_dentry_post_unlock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres);\nstatic void ocfs2_set_qinfo_lvb(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_downconvert_action(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_convert_action(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_attach_action(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_schedule_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_downconvert_on_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_drop_osb_locks(struct ocfs2_super *osb);\nstatic int ocfs2_prepare_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\t        struct ocfs2_lock_res *lockres);\nstatic int ocfs2_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_process_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *lockres);\n\nstatic void ocfs2_downconvert_on_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres)\n{\n\tint kick = 0;\n\n\t/* If we know that another node is waiting on our lock, kick\n\t * the downconvert thread * pre-emptively when we reach a release\n\t * condition. */\n\tif (lockres->l_flags & OCFS2_LOCK_BLOCKED) {\n\t\tswitch(lockres->l_blocking) {\n\t\tcase DLM_LOCK_EX:\n\t\t\tif (!lockres->l_ex_holders && !lockres->l_ro_holders)\n\t\t\t\tkick = 1;\n\t\t\tbreak;\n\t\tcase DLM_LOCK_PR:\n\t\t\tif (!lockres->l_ex_holders)\n\t\t\t\tkick = 1;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tBUG();\n\t\t}\n\t}\n\n\tif (kick)\n\t\tocfs2_wake_downconvert_thread(osb);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_dec_holders",
          "args": [
            "lockres",
            "level"
          ],
          "line": 1589
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_dec_holders",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlmglue.c",
          "lines": "768-785",
          "snippet": "static inline void ocfs2_dec_holders(struct ocfs2_lock_res *lockres,\n\t\t\t\t     int level)\n{\n\tBUG_ON(!lockres);\n\n\tswitch(level) {\n\tcase DLM_LOCK_EX:\n\t\tBUG_ON(!lockres->l_ex_holders);\n\t\tlockres->l_ex_holders--;\n\t\tbreak;\n\tcase DLM_LOCK_PR:\n\t\tBUG_ON(!lockres->l_ro_holders);\n\t\tlockres->l_ro_holders--;\n\t\tbreak;\n\tdefault:\n\t\tBUG();\n\t}\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"refcounttree.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"stackglue.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dcache.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2_lockingver.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/time.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/kthread.h>",
            "#include <linux/mm.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct ocfs2_super *ocfs2_get_dentry_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_inode_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_file_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_qinfo_osb(struct ocfs2_lock_res *lockres);",
            "static void ocfs2_set_meta_lvb(struct ocfs2_lock_res *lockres);",
            "static void ocfs2_dentry_post_unlock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres);",
            "static void ocfs2_set_qinfo_lvb(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_downconvert_action(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_convert_action(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_attach_action(struct ocfs2_lock_res *lockres);",
            "static int ocfs2_generic_handle_bast(struct ocfs2_lock_res *lockres, int level);",
            "static void ocfs2_schedule_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static void ocfs2_downconvert_on_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static inline int ocfs2_highest_compat_lock_level(int level);",
            "static int ocfs2_prepare_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\t        struct ocfs2_lock_res *lockres);",
            "static int ocfs2_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static void ocfs2_process_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *lockres);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"stackglue.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dcache.h\"\n#include \"alloc.h\"\n#include \"ocfs2_lockingver.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/quotaops.h>\n#include <linux/time.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/pagemap.h>\n#include <linux/kthread.h>\n#include <linux/mm.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic struct ocfs2_super *ocfs2_get_dentry_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_inode_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_file_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_qinfo_osb(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_set_meta_lvb(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_dentry_post_unlock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres);\nstatic void ocfs2_set_qinfo_lvb(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_downconvert_action(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_convert_action(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_attach_action(struct ocfs2_lock_res *lockres);\nstatic int ocfs2_generic_handle_bast(struct ocfs2_lock_res *lockres, int level);\nstatic void ocfs2_schedule_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_downconvert_on_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic inline int ocfs2_highest_compat_lock_level(int level);\nstatic int ocfs2_prepare_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\t        struct ocfs2_lock_res *lockres);\nstatic int ocfs2_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_process_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *lockres);\n\nstatic inline void ocfs2_dec_holders(struct ocfs2_lock_res *lockres,\n\t\t\t\t     int level)\n{\n\tBUG_ON(!lockres);\n\n\tswitch(level) {\n\tcase DLM_LOCK_EX:\n\t\tBUG_ON(!lockres->l_ex_holders);\n\t\tlockres->l_ex_holders--;\n\t\tbreak;\n\tcase DLM_LOCK_PR:\n\t\tBUG_ON(!lockres->l_ro_holders);\n\t\tlockres->l_ro_holders--;\n\t\tbreak;\n\tdefault:\n\t\tBUG();\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock_irqsave",
          "args": [
            "&lockres->l_lock",
            "flags"
          ],
          "line": 1588
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"stackglue.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dcache.h\"\n#include \"alloc.h\"\n#include \"ocfs2_lockingver.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/quotaops.h>\n#include <linux/time.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/pagemap.h>\n#include <linux/kthread.h>\n#include <linux/mm.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic struct ocfs2_super *ocfs2_get_dentry_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_inode_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_file_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_qinfo_osb(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_set_meta_lvb(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_dentry_post_unlock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres);\nstatic void ocfs2_set_qinfo_lvb(struct ocfs2_lock_res *lockres);\nstatic void __ocfs2_cluster_unlock(struct ocfs2_super *osb,\n\t\t\t\t   struct ocfs2_lock_res *lockres,\n\t\t\t\t   int level, unsigned long caller_ip);\nstatic inline void ocfs2_generic_handle_downconvert_action(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_convert_action(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_attach_action(struct ocfs2_lock_res *lockres);\nstatic int ocfs2_generic_handle_bast(struct ocfs2_lock_res *lockres, int level);\nstatic void ocfs2_schedule_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_downconvert_on_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_drop_osb_locks(struct ocfs2_super *osb);\nstatic inline int ocfs2_highest_compat_lock_level(int level);\nstatic int ocfs2_prepare_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\t        struct ocfs2_lock_res *lockres);\nstatic int ocfs2_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_process_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *lockres);\n\nstatic void __ocfs2_cluster_unlock(struct ocfs2_super *osb,\n\t\t\t\t   struct ocfs2_lock_res *lockres,\n\t\t\t\t   int level,\n\t\t\t\t   unsigned long caller_ip)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&lockres->l_lock, flags);\n\tocfs2_dec_holders(lockres, level);\n\tocfs2_downconvert_on_unlock(osb, lockres);\n\tspin_unlock_irqrestore(&lockres->l_lock, flags);\n#ifdef CONFIG_DEBUG_LOCK_ALLOC\n\tif (lockres->l_lockdep_map.key != NULL)\n\t\trwsem_release(&lockres->l_lockdep_map, 1, caller_ip);\n#endif\n}"
  },
  {
    "function_name": "ocfs2_cluster_lock",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlmglue.c",
    "lines": "1570-1578",
    "snippet": "static inline int ocfs2_cluster_lock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres,\n\t\t\t\t     int level,\n\t\t\t\t     u32 lkm_flags,\n\t\t\t\t     int arg_flags)\n{\n\treturn __ocfs2_cluster_lock(osb, lockres, level, lkm_flags, arg_flags,\n\t\t\t\t    0, _RET_IP_);\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"refcounttree.h\"",
      "#include \"quota.h\"",
      "#include \"uptodate.h\"",
      "#include \"super.h\"",
      "#include \"slot_map.h\"",
      "#include \"stackglue.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"heartbeat.h\"",
      "#include \"file.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"dcache.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2_lockingver.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/time.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/kthread.h>",
      "#include <linux/mm.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct ocfs2_super *ocfs2_get_dentry_osb(struct ocfs2_lock_res *lockres);",
      "static struct ocfs2_super *ocfs2_get_inode_osb(struct ocfs2_lock_res *lockres);",
      "static struct ocfs2_super *ocfs2_get_file_osb(struct ocfs2_lock_res *lockres);",
      "static struct ocfs2_super *ocfs2_get_qinfo_osb(struct ocfs2_lock_res *lockres);",
      "static void ocfs2_set_meta_lvb(struct ocfs2_lock_res *lockres);",
      "static void ocfs2_dentry_post_unlock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres);",
      "static void ocfs2_set_qinfo_lvb(struct ocfs2_lock_res *lockres);",
      "static inline void ocfs2_generic_handle_downconvert_action(struct ocfs2_lock_res *lockres);",
      "static inline void ocfs2_generic_handle_convert_action(struct ocfs2_lock_res *lockres);",
      "static inline void ocfs2_generic_handle_attach_action(struct ocfs2_lock_res *lockres);",
      "static int ocfs2_generic_handle_bast(struct ocfs2_lock_res *lockres, int level);",
      "static void ocfs2_schedule_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);",
      "static void ocfs2_downconvert_on_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);",
      "static void ocfs2_drop_osb_locks(struct ocfs2_super *osb);",
      "static inline int ocfs2_highest_compat_lock_level(int level);",
      "static int ocfs2_prepare_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\t        struct ocfs2_lock_res *lockres);",
      "static int ocfs2_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres);",
      "static void ocfs2_process_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *lockres);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "__ocfs2_cluster_lock",
          "args": [
            "osb",
            "lockres",
            "level",
            "lkm_flags",
            "arg_flags",
            "0",
            "_RET_IP_"
          ],
          "line": 1576
        },
        "resolved": true,
        "details": {
          "function_name": "__ocfs2_cluster_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlmglue.c",
          "lines": "1378-1568",
          "snippet": "static int __ocfs2_cluster_lock(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres,\n\t\t\t\tint level,\n\t\t\t\tu32 lkm_flags,\n\t\t\t\tint arg_flags,\n\t\t\t\tint l_subclass,\n\t\t\t\tunsigned long caller_ip)\n{\n\tstruct ocfs2_mask_waiter mw;\n\tint wait, catch_signals = !(osb->s_mount_opt & OCFS2_MOUNT_NOINTR);\n\tint ret = 0; /* gcc doesn't realize wait = 1 guarantees ret is set */\n\tunsigned long flags;\n\tunsigned int gen;\n\tint noqueue_attempted = 0;\n\tint dlm_locked = 0;\n\n\tocfs2_init_mask_waiter(&mw);\n\n\tif (lockres->l_ops->flags & LOCK_TYPE_USES_LVB)\n\t\tlkm_flags |= DLM_LKF_VALBLK;\n\nagain:\n\twait = 0;\n\n\tspin_lock_irqsave(&lockres->l_lock, flags);\n\n\tif (catch_signals && signal_pending(current)) {\n\t\tret = -ERESTARTSYS;\n\t\tgoto unlock;\n\t}\n\n\tmlog_bug_on_msg(lockres->l_flags & OCFS2_LOCK_FREEING,\n\t\t\t\"Cluster lock called on freeing lockres %s! flags \"\n\t\t\t\"0x%lx\\n\", lockres->l_name, lockres->l_flags);\n\n\t/* We only compare against the currently granted level\n\t * here. If the lock is blocked waiting on a downconvert,\n\t * we'll get caught below. */\n\tif (lockres->l_flags & OCFS2_LOCK_BUSY &&\n\t    level > lockres->l_level) {\n\t\t/* is someone sitting in dlm_lock? If so, wait on\n\t\t * them. */\n\t\tlockres_add_mask_waiter(lockres, &mw, OCFS2_LOCK_BUSY, 0);\n\t\twait = 1;\n\t\tgoto unlock;\n\t}\n\n\tif (lockres->l_flags & OCFS2_LOCK_UPCONVERT_FINISHING) {\n\t\t/*\n\t\t * We've upconverted. If the lock now has a level we can\n\t\t * work with, we take it. If, however, the lock is not at the\n\t\t * required level, we go thru the full cycle. One way this could\n\t\t * happen is if a process requesting an upconvert to PR is\n\t\t * closely followed by another requesting upconvert to an EX.\n\t\t * If the process requesting EX lands here, we want it to\n\t\t * continue attempting to upconvert and let the process\n\t\t * requesting PR take the lock.\n\t\t * If multiple processes request upconvert to PR, the first one\n\t\t * here will take the lock. The others will have to go thru the\n\t\t * OCFS2_LOCK_BLOCKED check to ensure that there is no pending\n\t\t * downconvert request.\n\t\t */\n\t\tif (level <= lockres->l_level)\n\t\t\tgoto update_holders;\n\t}\n\n\tif (lockres->l_flags & OCFS2_LOCK_BLOCKED &&\n\t    !ocfs2_may_continue_on_blocked_lock(lockres, level)) {\n\t\t/* is the lock is currently blocked on behalf of\n\t\t * another node */\n\t\tlockres_add_mask_waiter(lockres, &mw, OCFS2_LOCK_BLOCKED, 0);\n\t\twait = 1;\n\t\tgoto unlock;\n\t}\n\n\tif (level > lockres->l_level) {\n\t\tif (noqueue_attempted > 0) {\n\t\t\tret = -EAGAIN;\n\t\t\tgoto unlock;\n\t\t}\n\t\tif (lkm_flags & DLM_LKF_NOQUEUE)\n\t\t\tnoqueue_attempted = 1;\n\n\t\tif (lockres->l_action != OCFS2_AST_INVALID)\n\t\t\tmlog(ML_ERROR, \"lockres %s has action %u pending\\n\",\n\t\t\t     lockres->l_name, lockres->l_action);\n\n\t\tif (!(lockres->l_flags & OCFS2_LOCK_ATTACHED)) {\n\t\t\tlockres->l_action = OCFS2_AST_ATTACH;\n\t\t\tlkm_flags &= ~DLM_LKF_CONVERT;\n\t\t} else {\n\t\t\tlockres->l_action = OCFS2_AST_CONVERT;\n\t\t\tlkm_flags |= DLM_LKF_CONVERT;\n\t\t}\n\n\t\tlockres->l_requested = level;\n\t\tlockres_or_flags(lockres, OCFS2_LOCK_BUSY);\n\t\tgen = lockres_set_pending(lockres);\n\t\tspin_unlock_irqrestore(&lockres->l_lock, flags);\n\n\t\tBUG_ON(level == DLM_LOCK_IV);\n\t\tBUG_ON(level == DLM_LOCK_NL);\n\n\t\tmlog(ML_BASTS, \"lockres %s, convert from %d to %d\\n\",\n\t\t     lockres->l_name, lockres->l_level, level);\n\n\t\t/* call dlm_lock to upgrade lock now */\n\t\tret = ocfs2_dlm_lock(osb->cconn,\n\t\t\t\t     level,\n\t\t\t\t     &lockres->l_lksb,\n\t\t\t\t     lkm_flags,\n\t\t\t\t     lockres->l_name,\n\t\t\t\t     OCFS2_LOCK_ID_MAX_LEN - 1);\n\t\tlockres_clear_pending(lockres, gen, osb);\n\t\tif (ret) {\n\t\t\tif (!(lkm_flags & DLM_LKF_NOQUEUE) ||\n\t\t\t    (ret != -EAGAIN)) {\n\t\t\t\tocfs2_log_dlm_error(\"ocfs2_dlm_lock\",\n\t\t\t\t\t\t    ret, lockres);\n\t\t\t}\n\t\t\tocfs2_recover_from_dlm_error(lockres, 1);\n\t\t\tgoto out;\n\t\t}\n\t\tdlm_locked = 1;\n\n\t\tmlog(0, \"lock %s, successful return from ocfs2_dlm_lock\\n\",\n\t\t     lockres->l_name);\n\n\t\t/* At this point we've gone inside the dlm and need to\n\t\t * complete our work regardless. */\n\t\tcatch_signals = 0;\n\n\t\t/* wait for busy to clear and carry on */\n\t\tgoto again;\n\t}\n\nupdate_holders:\n\t/* Ok, if we get here then we're good to go. */\n\tocfs2_inc_holders(lockres, level);\n\n\tret = 0;\nunlock:\n\tlockres_clear_flags(lockres, OCFS2_LOCK_UPCONVERT_FINISHING);\n\n\tspin_unlock_irqrestore(&lockres->l_lock, flags);\nout:\n\t/*\n\t * This is helping work around a lock inversion between the page lock\n\t * and dlm locks.  One path holds the page lock while calling aops\n\t * which block acquiring dlm locks.  The voting thread holds dlm\n\t * locks while acquiring page locks while down converting data locks.\n\t * This block is helping an aop path notice the inversion and back\n\t * off to unlock its page lock before trying the dlm lock again.\n\t */\n\tif (wait && arg_flags & OCFS2_LOCK_NONBLOCK &&\n\t    mw.mw_mask & (OCFS2_LOCK_BUSY|OCFS2_LOCK_BLOCKED)) {\n\t\twait = 0;\n\t\tspin_lock_irqsave(&lockres->l_lock, flags);\n\t\tif (__lockres_remove_mask_waiter(lockres, &mw)) {\n\t\t\tif (dlm_locked)\n\t\t\t\tlockres_or_flags(lockres,\n\t\t\t\t\tOCFS2_LOCK_NONBLOCK_FINISHED);\n\t\t\tspin_unlock_irqrestore(&lockres->l_lock, flags);\n\t\t\tret = -EAGAIN;\n\t\t} else {\n\t\t\tspin_unlock_irqrestore(&lockres->l_lock, flags);\n\t\t\tgoto again;\n\t\t}\n\t}\n\tif (wait) {\n\t\tret = ocfs2_wait_for_mask(&mw);\n\t\tif (ret == 0)\n\t\t\tgoto again;\n\t\tmlog_errno(ret);\n\t}\n\tocfs2_update_lock_stats(lockres, level, &mw, ret);\n\n#ifdef CONFIG_DEBUG_LOCK_ALLOC\n\tif (!ret && lockres->l_lockdep_map.key != NULL) {\n\t\tif (level == DLM_LOCK_PR)\n\t\t\trwsem_acquire_read(&lockres->l_lockdep_map, l_subclass,\n\t\t\t\t!!(arg_flags & OCFS2_META_LOCK_NOQUEUE),\n\t\t\t\tcaller_ip);\n\t\telse\n\t\t\trwsem_acquire(&lockres->l_lockdep_map, l_subclass,\n\t\t\t\t!!(arg_flags & OCFS2_META_LOCK_NOQUEUE),\n\t\t\t\tcaller_ip);\n\t}\n#endif\n\treturn ret;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"refcounttree.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"stackglue.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dcache.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2_lockingver.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/time.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/kthread.h>",
            "#include <linux/mm.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [
            "#define LOCK_TYPE_USES_LVB\t\t0x2"
          ],
          "globals_used": [
            "static struct ocfs2_super *ocfs2_get_dentry_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_inode_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_file_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_qinfo_osb(struct ocfs2_lock_res *lockres);",
            "static void ocfs2_set_meta_lvb(struct ocfs2_lock_res *lockres);",
            "static void ocfs2_dentry_post_unlock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres);",
            "static void ocfs2_set_qinfo_lvb(struct ocfs2_lock_res *lockres);",
            "static void __ocfs2_cluster_unlock(struct ocfs2_super *osb,\n\t\t\t\t   struct ocfs2_lock_res *lockres,\n\t\t\t\t   int level, unsigned long caller_ip);",
            "static inline void ocfs2_generic_handle_downconvert_action(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_convert_action(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_attach_action(struct ocfs2_lock_res *lockres);",
            "static int ocfs2_generic_handle_bast(struct ocfs2_lock_res *lockres, int level);",
            "static void ocfs2_schedule_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_recover_from_dlm_error(struct ocfs2_lock_res *lockres,\n\t\t\t\t\t\tint convert);",
            "static void ocfs2_downconvert_on_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static void ocfs2_drop_osb_locks(struct ocfs2_super *osb);",
            "static inline int ocfs2_highest_compat_lock_level(int level);",
            "static int ocfs2_prepare_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\t        struct ocfs2_lock_res *lockres);",
            "static int ocfs2_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static void ocfs2_process_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *lockres);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"stackglue.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dcache.h\"\n#include \"alloc.h\"\n#include \"ocfs2_lockingver.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/quotaops.h>\n#include <linux/time.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/pagemap.h>\n#include <linux/kthread.h>\n#include <linux/mm.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\n#define LOCK_TYPE_USES_LVB\t\t0x2\n\nstatic struct ocfs2_super *ocfs2_get_dentry_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_inode_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_file_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_qinfo_osb(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_set_meta_lvb(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_dentry_post_unlock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres);\nstatic void ocfs2_set_qinfo_lvb(struct ocfs2_lock_res *lockres);\nstatic void __ocfs2_cluster_unlock(struct ocfs2_super *osb,\n\t\t\t\t   struct ocfs2_lock_res *lockres,\n\t\t\t\t   int level, unsigned long caller_ip);\nstatic inline void ocfs2_generic_handle_downconvert_action(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_convert_action(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_attach_action(struct ocfs2_lock_res *lockres);\nstatic int ocfs2_generic_handle_bast(struct ocfs2_lock_res *lockres, int level);\nstatic void ocfs2_schedule_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_recover_from_dlm_error(struct ocfs2_lock_res *lockres,\n\t\t\t\t\t\tint convert);\nstatic void ocfs2_downconvert_on_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_drop_osb_locks(struct ocfs2_super *osb);\nstatic inline int ocfs2_highest_compat_lock_level(int level);\nstatic int ocfs2_prepare_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\t        struct ocfs2_lock_res *lockres);\nstatic int ocfs2_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_process_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *lockres);\n\nstatic int __ocfs2_cluster_lock(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres,\n\t\t\t\tint level,\n\t\t\t\tu32 lkm_flags,\n\t\t\t\tint arg_flags,\n\t\t\t\tint l_subclass,\n\t\t\t\tunsigned long caller_ip)\n{\n\tstruct ocfs2_mask_waiter mw;\n\tint wait, catch_signals = !(osb->s_mount_opt & OCFS2_MOUNT_NOINTR);\n\tint ret = 0; /* gcc doesn't realize wait = 1 guarantees ret is set */\n\tunsigned long flags;\n\tunsigned int gen;\n\tint noqueue_attempted = 0;\n\tint dlm_locked = 0;\n\n\tocfs2_init_mask_waiter(&mw);\n\n\tif (lockres->l_ops->flags & LOCK_TYPE_USES_LVB)\n\t\tlkm_flags |= DLM_LKF_VALBLK;\n\nagain:\n\twait = 0;\n\n\tspin_lock_irqsave(&lockres->l_lock, flags);\n\n\tif (catch_signals && signal_pending(current)) {\n\t\tret = -ERESTARTSYS;\n\t\tgoto unlock;\n\t}\n\n\tmlog_bug_on_msg(lockres->l_flags & OCFS2_LOCK_FREEING,\n\t\t\t\"Cluster lock called on freeing lockres %s! flags \"\n\t\t\t\"0x%lx\\n\", lockres->l_name, lockres->l_flags);\n\n\t/* We only compare against the currently granted level\n\t * here. If the lock is blocked waiting on a downconvert,\n\t * we'll get caught below. */\n\tif (lockres->l_flags & OCFS2_LOCK_BUSY &&\n\t    level > lockres->l_level) {\n\t\t/* is someone sitting in dlm_lock? If so, wait on\n\t\t * them. */\n\t\tlockres_add_mask_waiter(lockres, &mw, OCFS2_LOCK_BUSY, 0);\n\t\twait = 1;\n\t\tgoto unlock;\n\t}\n\n\tif (lockres->l_flags & OCFS2_LOCK_UPCONVERT_FINISHING) {\n\t\t/*\n\t\t * We've upconverted. If the lock now has a level we can\n\t\t * work with, we take it. If, however, the lock is not at the\n\t\t * required level, we go thru the full cycle. One way this could\n\t\t * happen is if a process requesting an upconvert to PR is\n\t\t * closely followed by another requesting upconvert to an EX.\n\t\t * If the process requesting EX lands here, we want it to\n\t\t * continue attempting to upconvert and let the process\n\t\t * requesting PR take the lock.\n\t\t * If multiple processes request upconvert to PR, the first one\n\t\t * here will take the lock. The others will have to go thru the\n\t\t * OCFS2_LOCK_BLOCKED check to ensure that there is no pending\n\t\t * downconvert request.\n\t\t */\n\t\tif (level <= lockres->l_level)\n\t\t\tgoto update_holders;\n\t}\n\n\tif (lockres->l_flags & OCFS2_LOCK_BLOCKED &&\n\t    !ocfs2_may_continue_on_blocked_lock(lockres, level)) {\n\t\t/* is the lock is currently blocked on behalf of\n\t\t * another node */\n\t\tlockres_add_mask_waiter(lockres, &mw, OCFS2_LOCK_BLOCKED, 0);\n\t\twait = 1;\n\t\tgoto unlock;\n\t}\n\n\tif (level > lockres->l_level) {\n\t\tif (noqueue_attempted > 0) {\n\t\t\tret = -EAGAIN;\n\t\t\tgoto unlock;\n\t\t}\n\t\tif (lkm_flags & DLM_LKF_NOQUEUE)\n\t\t\tnoqueue_attempted = 1;\n\n\t\tif (lockres->l_action != OCFS2_AST_INVALID)\n\t\t\tmlog(ML_ERROR, \"lockres %s has action %u pending\\n\",\n\t\t\t     lockres->l_name, lockres->l_action);\n\n\t\tif (!(lockres->l_flags & OCFS2_LOCK_ATTACHED)) {\n\t\t\tlockres->l_action = OCFS2_AST_ATTACH;\n\t\t\tlkm_flags &= ~DLM_LKF_CONVERT;\n\t\t} else {\n\t\t\tlockres->l_action = OCFS2_AST_CONVERT;\n\t\t\tlkm_flags |= DLM_LKF_CONVERT;\n\t\t}\n\n\t\tlockres->l_requested = level;\n\t\tlockres_or_flags(lockres, OCFS2_LOCK_BUSY);\n\t\tgen = lockres_set_pending(lockres);\n\t\tspin_unlock_irqrestore(&lockres->l_lock, flags);\n\n\t\tBUG_ON(level == DLM_LOCK_IV);\n\t\tBUG_ON(level == DLM_LOCK_NL);\n\n\t\tmlog(ML_BASTS, \"lockres %s, convert from %d to %d\\n\",\n\t\t     lockres->l_name, lockres->l_level, level);\n\n\t\t/* call dlm_lock to upgrade lock now */\n\t\tret = ocfs2_dlm_lock(osb->cconn,\n\t\t\t\t     level,\n\t\t\t\t     &lockres->l_lksb,\n\t\t\t\t     lkm_flags,\n\t\t\t\t     lockres->l_name,\n\t\t\t\t     OCFS2_LOCK_ID_MAX_LEN - 1);\n\t\tlockres_clear_pending(lockres, gen, osb);\n\t\tif (ret) {\n\t\t\tif (!(lkm_flags & DLM_LKF_NOQUEUE) ||\n\t\t\t    (ret != -EAGAIN)) {\n\t\t\t\tocfs2_log_dlm_error(\"ocfs2_dlm_lock\",\n\t\t\t\t\t\t    ret, lockres);\n\t\t\t}\n\t\t\tocfs2_recover_from_dlm_error(lockres, 1);\n\t\t\tgoto out;\n\t\t}\n\t\tdlm_locked = 1;\n\n\t\tmlog(0, \"lock %s, successful return from ocfs2_dlm_lock\\n\",\n\t\t     lockres->l_name);\n\n\t\t/* At this point we've gone inside the dlm and need to\n\t\t * complete our work regardless. */\n\t\tcatch_signals = 0;\n\n\t\t/* wait for busy to clear and carry on */\n\t\tgoto again;\n\t}\n\nupdate_holders:\n\t/* Ok, if we get here then we're good to go. */\n\tocfs2_inc_holders(lockres, level);\n\n\tret = 0;\nunlock:\n\tlockres_clear_flags(lockres, OCFS2_LOCK_UPCONVERT_FINISHING);\n\n\tspin_unlock_irqrestore(&lockres->l_lock, flags);\nout:\n\t/*\n\t * This is helping work around a lock inversion between the page lock\n\t * and dlm locks.  One path holds the page lock while calling aops\n\t * which block acquiring dlm locks.  The voting thread holds dlm\n\t * locks while acquiring page locks while down converting data locks.\n\t * This block is helping an aop path notice the inversion and back\n\t * off to unlock its page lock before trying the dlm lock again.\n\t */\n\tif (wait && arg_flags & OCFS2_LOCK_NONBLOCK &&\n\t    mw.mw_mask & (OCFS2_LOCK_BUSY|OCFS2_LOCK_BLOCKED)) {\n\t\twait = 0;\n\t\tspin_lock_irqsave(&lockres->l_lock, flags);\n\t\tif (__lockres_remove_mask_waiter(lockres, &mw)) {\n\t\t\tif (dlm_locked)\n\t\t\t\tlockres_or_flags(lockres,\n\t\t\t\t\tOCFS2_LOCK_NONBLOCK_FINISHED);\n\t\t\tspin_unlock_irqrestore(&lockres->l_lock, flags);\n\t\t\tret = -EAGAIN;\n\t\t} else {\n\t\t\tspin_unlock_irqrestore(&lockres->l_lock, flags);\n\t\t\tgoto again;\n\t\t}\n\t}\n\tif (wait) {\n\t\tret = ocfs2_wait_for_mask(&mw);\n\t\tif (ret == 0)\n\t\t\tgoto again;\n\t\tmlog_errno(ret);\n\t}\n\tocfs2_update_lock_stats(lockres, level, &mw, ret);\n\n#ifdef CONFIG_DEBUG_LOCK_ALLOC\n\tif (!ret && lockres->l_lockdep_map.key != NULL) {\n\t\tif (level == DLM_LOCK_PR)\n\t\t\trwsem_acquire_read(&lockres->l_lockdep_map, l_subclass,\n\t\t\t\t!!(arg_flags & OCFS2_META_LOCK_NOQUEUE),\n\t\t\t\tcaller_ip);\n\t\telse\n\t\t\trwsem_acquire(&lockres->l_lockdep_map, l_subclass,\n\t\t\t\t!!(arg_flags & OCFS2_META_LOCK_NOQUEUE),\n\t\t\t\tcaller_ip);\n\t}\n#endif\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"stackglue.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dcache.h\"\n#include \"alloc.h\"\n#include \"ocfs2_lockingver.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/quotaops.h>\n#include <linux/time.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/pagemap.h>\n#include <linux/kthread.h>\n#include <linux/mm.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic struct ocfs2_super *ocfs2_get_dentry_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_inode_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_file_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_qinfo_osb(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_set_meta_lvb(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_dentry_post_unlock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres);\nstatic void ocfs2_set_qinfo_lvb(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_downconvert_action(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_convert_action(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_attach_action(struct ocfs2_lock_res *lockres);\nstatic int ocfs2_generic_handle_bast(struct ocfs2_lock_res *lockres, int level);\nstatic void ocfs2_schedule_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_downconvert_on_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_drop_osb_locks(struct ocfs2_super *osb);\nstatic inline int ocfs2_highest_compat_lock_level(int level);\nstatic int ocfs2_prepare_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\t        struct ocfs2_lock_res *lockres);\nstatic int ocfs2_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_process_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *lockres);\n\nstatic inline int ocfs2_cluster_lock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres,\n\t\t\t\t     int level,\n\t\t\t\t     u32 lkm_flags,\n\t\t\t\t     int arg_flags)\n{\n\treturn __ocfs2_cluster_lock(osb, lockres, level, lkm_flags, arg_flags,\n\t\t\t\t    0, _RET_IP_);\n}"
  },
  {
    "function_name": "__ocfs2_cluster_lock",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlmglue.c",
    "lines": "1378-1568",
    "snippet": "static int __ocfs2_cluster_lock(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres,\n\t\t\t\tint level,\n\t\t\t\tu32 lkm_flags,\n\t\t\t\tint arg_flags,\n\t\t\t\tint l_subclass,\n\t\t\t\tunsigned long caller_ip)\n{\n\tstruct ocfs2_mask_waiter mw;\n\tint wait, catch_signals = !(osb->s_mount_opt & OCFS2_MOUNT_NOINTR);\n\tint ret = 0; /* gcc doesn't realize wait = 1 guarantees ret is set */\n\tunsigned long flags;\n\tunsigned int gen;\n\tint noqueue_attempted = 0;\n\tint dlm_locked = 0;\n\n\tocfs2_init_mask_waiter(&mw);\n\n\tif (lockres->l_ops->flags & LOCK_TYPE_USES_LVB)\n\t\tlkm_flags |= DLM_LKF_VALBLK;\n\nagain:\n\twait = 0;\n\n\tspin_lock_irqsave(&lockres->l_lock, flags);\n\n\tif (catch_signals && signal_pending(current)) {\n\t\tret = -ERESTARTSYS;\n\t\tgoto unlock;\n\t}\n\n\tmlog_bug_on_msg(lockres->l_flags & OCFS2_LOCK_FREEING,\n\t\t\t\"Cluster lock called on freeing lockres %s! flags \"\n\t\t\t\"0x%lx\\n\", lockres->l_name, lockres->l_flags);\n\n\t/* We only compare against the currently granted level\n\t * here. If the lock is blocked waiting on a downconvert,\n\t * we'll get caught below. */\n\tif (lockres->l_flags & OCFS2_LOCK_BUSY &&\n\t    level > lockres->l_level) {\n\t\t/* is someone sitting in dlm_lock? If so, wait on\n\t\t * them. */\n\t\tlockres_add_mask_waiter(lockres, &mw, OCFS2_LOCK_BUSY, 0);\n\t\twait = 1;\n\t\tgoto unlock;\n\t}\n\n\tif (lockres->l_flags & OCFS2_LOCK_UPCONVERT_FINISHING) {\n\t\t/*\n\t\t * We've upconverted. If the lock now has a level we can\n\t\t * work with, we take it. If, however, the lock is not at the\n\t\t * required level, we go thru the full cycle. One way this could\n\t\t * happen is if a process requesting an upconvert to PR is\n\t\t * closely followed by another requesting upconvert to an EX.\n\t\t * If the process requesting EX lands here, we want it to\n\t\t * continue attempting to upconvert and let the process\n\t\t * requesting PR take the lock.\n\t\t * If multiple processes request upconvert to PR, the first one\n\t\t * here will take the lock. The others will have to go thru the\n\t\t * OCFS2_LOCK_BLOCKED check to ensure that there is no pending\n\t\t * downconvert request.\n\t\t */\n\t\tif (level <= lockres->l_level)\n\t\t\tgoto update_holders;\n\t}\n\n\tif (lockres->l_flags & OCFS2_LOCK_BLOCKED &&\n\t    !ocfs2_may_continue_on_blocked_lock(lockres, level)) {\n\t\t/* is the lock is currently blocked on behalf of\n\t\t * another node */\n\t\tlockres_add_mask_waiter(lockres, &mw, OCFS2_LOCK_BLOCKED, 0);\n\t\twait = 1;\n\t\tgoto unlock;\n\t}\n\n\tif (level > lockres->l_level) {\n\t\tif (noqueue_attempted > 0) {\n\t\t\tret = -EAGAIN;\n\t\t\tgoto unlock;\n\t\t}\n\t\tif (lkm_flags & DLM_LKF_NOQUEUE)\n\t\t\tnoqueue_attempted = 1;\n\n\t\tif (lockres->l_action != OCFS2_AST_INVALID)\n\t\t\tmlog(ML_ERROR, \"lockres %s has action %u pending\\n\",\n\t\t\t     lockres->l_name, lockres->l_action);\n\n\t\tif (!(lockres->l_flags & OCFS2_LOCK_ATTACHED)) {\n\t\t\tlockres->l_action = OCFS2_AST_ATTACH;\n\t\t\tlkm_flags &= ~DLM_LKF_CONVERT;\n\t\t} else {\n\t\t\tlockres->l_action = OCFS2_AST_CONVERT;\n\t\t\tlkm_flags |= DLM_LKF_CONVERT;\n\t\t}\n\n\t\tlockres->l_requested = level;\n\t\tlockres_or_flags(lockres, OCFS2_LOCK_BUSY);\n\t\tgen = lockres_set_pending(lockres);\n\t\tspin_unlock_irqrestore(&lockres->l_lock, flags);\n\n\t\tBUG_ON(level == DLM_LOCK_IV);\n\t\tBUG_ON(level == DLM_LOCK_NL);\n\n\t\tmlog(ML_BASTS, \"lockres %s, convert from %d to %d\\n\",\n\t\t     lockres->l_name, lockres->l_level, level);\n\n\t\t/* call dlm_lock to upgrade lock now */\n\t\tret = ocfs2_dlm_lock(osb->cconn,\n\t\t\t\t     level,\n\t\t\t\t     &lockres->l_lksb,\n\t\t\t\t     lkm_flags,\n\t\t\t\t     lockres->l_name,\n\t\t\t\t     OCFS2_LOCK_ID_MAX_LEN - 1);\n\t\tlockres_clear_pending(lockres, gen, osb);\n\t\tif (ret) {\n\t\t\tif (!(lkm_flags & DLM_LKF_NOQUEUE) ||\n\t\t\t    (ret != -EAGAIN)) {\n\t\t\t\tocfs2_log_dlm_error(\"ocfs2_dlm_lock\",\n\t\t\t\t\t\t    ret, lockres);\n\t\t\t}\n\t\t\tocfs2_recover_from_dlm_error(lockres, 1);\n\t\t\tgoto out;\n\t\t}\n\t\tdlm_locked = 1;\n\n\t\tmlog(0, \"lock %s, successful return from ocfs2_dlm_lock\\n\",\n\t\t     lockres->l_name);\n\n\t\t/* At this point we've gone inside the dlm and need to\n\t\t * complete our work regardless. */\n\t\tcatch_signals = 0;\n\n\t\t/* wait for busy to clear and carry on */\n\t\tgoto again;\n\t}\n\nupdate_holders:\n\t/* Ok, if we get here then we're good to go. */\n\tocfs2_inc_holders(lockres, level);\n\n\tret = 0;\nunlock:\n\tlockres_clear_flags(lockres, OCFS2_LOCK_UPCONVERT_FINISHING);\n\n\tspin_unlock_irqrestore(&lockres->l_lock, flags);\nout:\n\t/*\n\t * This is helping work around a lock inversion between the page lock\n\t * and dlm locks.  One path holds the page lock while calling aops\n\t * which block acquiring dlm locks.  The voting thread holds dlm\n\t * locks while acquiring page locks while down converting data locks.\n\t * This block is helping an aop path notice the inversion and back\n\t * off to unlock its page lock before trying the dlm lock again.\n\t */\n\tif (wait && arg_flags & OCFS2_LOCK_NONBLOCK &&\n\t    mw.mw_mask & (OCFS2_LOCK_BUSY|OCFS2_LOCK_BLOCKED)) {\n\t\twait = 0;\n\t\tspin_lock_irqsave(&lockres->l_lock, flags);\n\t\tif (__lockres_remove_mask_waiter(lockres, &mw)) {\n\t\t\tif (dlm_locked)\n\t\t\t\tlockres_or_flags(lockres,\n\t\t\t\t\tOCFS2_LOCK_NONBLOCK_FINISHED);\n\t\t\tspin_unlock_irqrestore(&lockres->l_lock, flags);\n\t\t\tret = -EAGAIN;\n\t\t} else {\n\t\t\tspin_unlock_irqrestore(&lockres->l_lock, flags);\n\t\t\tgoto again;\n\t\t}\n\t}\n\tif (wait) {\n\t\tret = ocfs2_wait_for_mask(&mw);\n\t\tif (ret == 0)\n\t\t\tgoto again;\n\t\tmlog_errno(ret);\n\t}\n\tocfs2_update_lock_stats(lockres, level, &mw, ret);\n\n#ifdef CONFIG_DEBUG_LOCK_ALLOC\n\tif (!ret && lockres->l_lockdep_map.key != NULL) {\n\t\tif (level == DLM_LOCK_PR)\n\t\t\trwsem_acquire_read(&lockres->l_lockdep_map, l_subclass,\n\t\t\t\t!!(arg_flags & OCFS2_META_LOCK_NOQUEUE),\n\t\t\t\tcaller_ip);\n\t\telse\n\t\t\trwsem_acquire(&lockres->l_lockdep_map, l_subclass,\n\t\t\t\t!!(arg_flags & OCFS2_META_LOCK_NOQUEUE),\n\t\t\t\tcaller_ip);\n\t}\n#endif\n\treturn ret;\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"refcounttree.h\"",
      "#include \"quota.h\"",
      "#include \"uptodate.h\"",
      "#include \"super.h\"",
      "#include \"slot_map.h\"",
      "#include \"stackglue.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"heartbeat.h\"",
      "#include \"file.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"dcache.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2_lockingver.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/time.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/kthread.h>",
      "#include <linux/mm.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [
      "#define LOCK_TYPE_USES_LVB\t\t0x2"
    ],
    "globals_used": [
      "static struct ocfs2_super *ocfs2_get_dentry_osb(struct ocfs2_lock_res *lockres);",
      "static struct ocfs2_super *ocfs2_get_inode_osb(struct ocfs2_lock_res *lockres);",
      "static struct ocfs2_super *ocfs2_get_file_osb(struct ocfs2_lock_res *lockres);",
      "static struct ocfs2_super *ocfs2_get_qinfo_osb(struct ocfs2_lock_res *lockres);",
      "static void ocfs2_set_meta_lvb(struct ocfs2_lock_res *lockres);",
      "static void ocfs2_dentry_post_unlock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres);",
      "static void ocfs2_set_qinfo_lvb(struct ocfs2_lock_res *lockres);",
      "static void __ocfs2_cluster_unlock(struct ocfs2_super *osb,\n\t\t\t\t   struct ocfs2_lock_res *lockres,\n\t\t\t\t   int level, unsigned long caller_ip);",
      "static inline void ocfs2_generic_handle_downconvert_action(struct ocfs2_lock_res *lockres);",
      "static inline void ocfs2_generic_handle_convert_action(struct ocfs2_lock_res *lockres);",
      "static inline void ocfs2_generic_handle_attach_action(struct ocfs2_lock_res *lockres);",
      "static int ocfs2_generic_handle_bast(struct ocfs2_lock_res *lockres, int level);",
      "static void ocfs2_schedule_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);",
      "static inline void ocfs2_recover_from_dlm_error(struct ocfs2_lock_res *lockres,\n\t\t\t\t\t\tint convert);",
      "static void ocfs2_downconvert_on_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);",
      "static void ocfs2_drop_osb_locks(struct ocfs2_super *osb);",
      "static inline int ocfs2_highest_compat_lock_level(int level);",
      "static int ocfs2_prepare_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\t        struct ocfs2_lock_res *lockres);",
      "static int ocfs2_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres);",
      "static void ocfs2_process_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *lockres);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "rwsem_acquire",
          "args": [
            "&lockres->l_lockdep_map",
            "l_subclass",
            "!!(arg_flags & OCFS2_META_LOCK_NOQUEUE)",
            "caller_ip"
          ],
          "line": 1562
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rwsem_acquire_read",
          "args": [
            "&lockres->l_lockdep_map",
            "l_subclass",
            "!!(arg_flags & OCFS2_META_LOCK_NOQUEUE)",
            "caller_ip"
          ],
          "line": 1558
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_update_lock_stats",
          "args": [
            "lockres",
            "level",
            "&mw",
            "ret"
          ],
          "line": 1553
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_update_lock_stats",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlmglue.c",
          "lines": "484-487",
          "snippet": "static inline void ocfs2_update_lock_stats(struct ocfs2_lock_res *res,\n\t\t\t   int level, struct ocfs2_mask_waiter *mw, int ret)\n{\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"refcounttree.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"stackglue.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dcache.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2_lockingver.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/time.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/kthread.h>",
            "#include <linux/mm.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ocfs2_generic_handle_bast(struct ocfs2_lock_res *lockres, int level);",
            "static inline int ocfs2_highest_compat_lock_level(int level);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"stackglue.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dcache.h\"\n#include \"alloc.h\"\n#include \"ocfs2_lockingver.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/quotaops.h>\n#include <linux/time.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/pagemap.h>\n#include <linux/kthread.h>\n#include <linux/mm.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic int ocfs2_generic_handle_bast(struct ocfs2_lock_res *lockres, int level);\nstatic inline int ocfs2_highest_compat_lock_level(int level);\n\nstatic inline void ocfs2_update_lock_stats(struct ocfs2_lock_res *res,\n\t\t\t   int level, struct ocfs2_mask_waiter *mw, int ret)\n{\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 1551
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_wait_for_mask",
          "args": [
            "&mw"
          ],
          "line": 1548
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_wait_for_mask",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlmglue.c",
          "lines": "1308-1314",
          "snippet": "static int ocfs2_wait_for_mask(struct ocfs2_mask_waiter *mw)\n{\n\twait_for_completion(&mw->mw_complete);\n\t/* Re-arm the completion in case we want to wait on it again */\n\treinit_completion(&mw->mw_complete);\n\treturn mw->mw_status;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"refcounttree.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"stackglue.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dcache.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2_lockingver.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/time.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/kthread.h>",
            "#include <linux/mm.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"stackglue.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dcache.h\"\n#include \"alloc.h\"\n#include \"ocfs2_lockingver.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/quotaops.h>\n#include <linux/time.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/pagemap.h>\n#include <linux/kthread.h>\n#include <linux/mm.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic int ocfs2_wait_for_mask(struct ocfs2_mask_waiter *mw)\n{\n\twait_for_completion(&mw->mw_complete);\n\t/* Re-arm the completion in case we want to wait on it again */\n\treinit_completion(&mw->mw_complete);\n\treturn mw->mw_status;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock_irqrestore",
          "args": [
            "&lockres->l_lock",
            "flags"
          ],
          "line": 1543
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock_irqrestore",
          "args": [
            "&lockres->l_lock",
            "flags"
          ],
          "line": 1540
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lockres_or_flags",
          "args": [
            "lockres",
            "OCFS2_LOCK_NONBLOCK_FINISHED"
          ],
          "line": 1538
        },
        "resolved": true,
        "details": {
          "function_name": "lockres_or_flags",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlmglue.c",
          "lines": "819-822",
          "snippet": "static void lockres_or_flags(struct ocfs2_lock_res *lockres, unsigned long or)\n{\n\tlockres_set_flags(lockres, lockres->l_flags | or);\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"refcounttree.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"stackglue.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dcache.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2_lockingver.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/time.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/kthread.h>",
            "#include <linux/mm.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct ocfs2_super *ocfs2_get_dentry_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_inode_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_file_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_qinfo_osb(struct ocfs2_lock_res *lockres);",
            "static void ocfs2_set_meta_lvb(struct ocfs2_lock_res *lockres);",
            "static void ocfs2_dentry_post_unlock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres);",
            "static void ocfs2_set_qinfo_lvb(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_downconvert_action(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_convert_action(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_attach_action(struct ocfs2_lock_res *lockres);",
            "static void ocfs2_schedule_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static void ocfs2_downconvert_on_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static int ocfs2_prepare_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\t        struct ocfs2_lock_res *lockres);",
            "static int ocfs2_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static void ocfs2_process_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *lockres);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"stackglue.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dcache.h\"\n#include \"alloc.h\"\n#include \"ocfs2_lockingver.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/quotaops.h>\n#include <linux/time.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/pagemap.h>\n#include <linux/kthread.h>\n#include <linux/mm.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic struct ocfs2_super *ocfs2_get_dentry_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_inode_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_file_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_qinfo_osb(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_set_meta_lvb(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_dentry_post_unlock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres);\nstatic void ocfs2_set_qinfo_lvb(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_downconvert_action(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_convert_action(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_attach_action(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_schedule_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_downconvert_on_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic int ocfs2_prepare_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\t        struct ocfs2_lock_res *lockres);\nstatic int ocfs2_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_process_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *lockres);\n\nstatic void lockres_or_flags(struct ocfs2_lock_res *lockres, unsigned long or)\n{\n\tlockres_set_flags(lockres, lockres->l_flags | or);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__lockres_remove_mask_waiter",
          "args": [
            "lockres",
            "&mw"
          ],
          "line": 1536
        },
        "resolved": true,
        "details": {
          "function_name": "__lockres_remove_mask_waiter",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlmglue.c",
          "lines": "1332-1347",
          "snippet": "static int __lockres_remove_mask_waiter(struct ocfs2_lock_res *lockres,\n\t\t\t\t      struct ocfs2_mask_waiter *mw)\n{\n\tint ret = 0;\n\n\tassert_spin_locked(&lockres->l_lock);\n\tif (!list_empty(&mw->mw_item)) {\n\t\tif ((lockres->l_flags & mw->mw_mask) != mw->mw_goal)\n\t\t\tret = -EBUSY;\n\n\t\tlist_del_init(&mw->mw_item);\n\t\tinit_completion(&mw->mw_complete);\n\t}\n\n\treturn ret;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"refcounttree.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"stackglue.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dcache.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2_lockingver.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/time.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/kthread.h>",
            "#include <linux/mm.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct ocfs2_super *ocfs2_get_dentry_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_inode_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_file_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_qinfo_osb(struct ocfs2_lock_res *lockres);",
            "static void ocfs2_set_meta_lvb(struct ocfs2_lock_res *lockres);",
            "static void ocfs2_dentry_post_unlock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres);",
            "static void ocfs2_set_qinfo_lvb(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_downconvert_action(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_convert_action(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_attach_action(struct ocfs2_lock_res *lockres);",
            "static void ocfs2_schedule_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static void ocfs2_downconvert_on_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static int ocfs2_prepare_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\t        struct ocfs2_lock_res *lockres);",
            "static int ocfs2_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static void ocfs2_process_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *lockres);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"stackglue.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dcache.h\"\n#include \"alloc.h\"\n#include \"ocfs2_lockingver.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/quotaops.h>\n#include <linux/time.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/pagemap.h>\n#include <linux/kthread.h>\n#include <linux/mm.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic struct ocfs2_super *ocfs2_get_dentry_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_inode_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_file_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_qinfo_osb(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_set_meta_lvb(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_dentry_post_unlock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres);\nstatic void ocfs2_set_qinfo_lvb(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_downconvert_action(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_convert_action(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_attach_action(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_schedule_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_downconvert_on_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic int ocfs2_prepare_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\t        struct ocfs2_lock_res *lockres);\nstatic int ocfs2_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_process_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *lockres);\n\nstatic int __lockres_remove_mask_waiter(struct ocfs2_lock_res *lockres,\n\t\t\t\t      struct ocfs2_mask_waiter *mw)\n{\n\tint ret = 0;\n\n\tassert_spin_locked(&lockres->l_lock);\n\tif (!list_empty(&mw->mw_item)) {\n\t\tif ((lockres->l_flags & mw->mw_mask) != mw->mw_goal)\n\t\t\tret = -EBUSY;\n\n\t\tlist_del_init(&mw->mw_item);\n\t\tinit_completion(&mw->mw_complete);\n\t}\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock_irqsave",
          "args": [
            "&lockres->l_lock",
            "flags"
          ],
          "line": 1535
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock_irqrestore",
          "args": [
            "&lockres->l_lock",
            "flags"
          ],
          "line": 1522
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lockres_clear_flags",
          "args": [
            "lockres",
            "OCFS2_LOCK_UPCONVERT_FINISHING"
          ],
          "line": 1520
        },
        "resolved": true,
        "details": {
          "function_name": "lockres_clear_flags",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlmglue.c",
          "lines": "823-827",
          "snippet": "static void lockres_clear_flags(struct ocfs2_lock_res *lockres,\n\t\t\t\tunsigned long clear)\n{\n\tlockres_set_flags(lockres, lockres->l_flags & ~clear);\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"refcounttree.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"stackglue.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dcache.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2_lockingver.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/time.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/kthread.h>",
            "#include <linux/mm.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct ocfs2_super *ocfs2_get_dentry_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_inode_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_file_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_qinfo_osb(struct ocfs2_lock_res *lockres);",
            "static void ocfs2_set_meta_lvb(struct ocfs2_lock_res *lockres);",
            "static void ocfs2_dentry_post_unlock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres);",
            "static void ocfs2_set_qinfo_lvb(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_downconvert_action(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_convert_action(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_attach_action(struct ocfs2_lock_res *lockres);",
            "static void ocfs2_schedule_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static void ocfs2_downconvert_on_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static int ocfs2_prepare_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\t        struct ocfs2_lock_res *lockres);",
            "static int ocfs2_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static void ocfs2_process_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *lockres);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"stackglue.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dcache.h\"\n#include \"alloc.h\"\n#include \"ocfs2_lockingver.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/quotaops.h>\n#include <linux/time.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/pagemap.h>\n#include <linux/kthread.h>\n#include <linux/mm.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic struct ocfs2_super *ocfs2_get_dentry_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_inode_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_file_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_qinfo_osb(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_set_meta_lvb(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_dentry_post_unlock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres);\nstatic void ocfs2_set_qinfo_lvb(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_downconvert_action(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_convert_action(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_attach_action(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_schedule_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_downconvert_on_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic int ocfs2_prepare_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\t        struct ocfs2_lock_res *lockres);\nstatic int ocfs2_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_process_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *lockres);\n\nstatic void lockres_clear_flags(struct ocfs2_lock_res *lockres,\n\t\t\t\tunsigned long clear)\n{\n\tlockres_set_flags(lockres, lockres->l_flags & ~clear);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_inc_holders",
          "args": [
            "lockres",
            "level"
          ],
          "line": 1516
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_inc_holders",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlmglue.c",
          "lines": "751-766",
          "snippet": "static inline void ocfs2_inc_holders(struct ocfs2_lock_res *lockres,\n\t\t\t\t     int level)\n{\n\tBUG_ON(!lockres);\n\n\tswitch(level) {\n\tcase DLM_LOCK_EX:\n\t\tlockres->l_ex_holders++;\n\t\tbreak;\n\tcase DLM_LOCK_PR:\n\t\tlockres->l_ro_holders++;\n\t\tbreak;\n\tdefault:\n\t\tBUG();\n\t}\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"refcounttree.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"stackglue.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dcache.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2_lockingver.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/time.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/kthread.h>",
            "#include <linux/mm.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct ocfs2_super *ocfs2_get_dentry_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_inode_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_file_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_qinfo_osb(struct ocfs2_lock_res *lockres);",
            "static void ocfs2_set_meta_lvb(struct ocfs2_lock_res *lockres);",
            "static void ocfs2_dentry_post_unlock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres);",
            "static void ocfs2_set_qinfo_lvb(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_downconvert_action(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_convert_action(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_attach_action(struct ocfs2_lock_res *lockres);",
            "static int ocfs2_generic_handle_bast(struct ocfs2_lock_res *lockres, int level);",
            "static void ocfs2_schedule_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static void ocfs2_downconvert_on_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static inline int ocfs2_highest_compat_lock_level(int level);",
            "static int ocfs2_prepare_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\t        struct ocfs2_lock_res *lockres);",
            "static int ocfs2_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static void ocfs2_process_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *lockres);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"stackglue.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dcache.h\"\n#include \"alloc.h\"\n#include \"ocfs2_lockingver.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/quotaops.h>\n#include <linux/time.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/pagemap.h>\n#include <linux/kthread.h>\n#include <linux/mm.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic struct ocfs2_super *ocfs2_get_dentry_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_inode_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_file_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_qinfo_osb(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_set_meta_lvb(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_dentry_post_unlock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres);\nstatic void ocfs2_set_qinfo_lvb(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_downconvert_action(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_convert_action(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_attach_action(struct ocfs2_lock_res *lockres);\nstatic int ocfs2_generic_handle_bast(struct ocfs2_lock_res *lockres, int level);\nstatic void ocfs2_schedule_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_downconvert_on_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic inline int ocfs2_highest_compat_lock_level(int level);\nstatic int ocfs2_prepare_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\t        struct ocfs2_lock_res *lockres);\nstatic int ocfs2_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_process_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *lockres);\n\nstatic inline void ocfs2_inc_holders(struct ocfs2_lock_res *lockres,\n\t\t\t\t     int level)\n{\n\tBUG_ON(!lockres);\n\n\tswitch(level) {\n\tcase DLM_LOCK_EX:\n\t\tlockres->l_ex_holders++;\n\t\tbreak;\n\tcase DLM_LOCK_PR:\n\t\tlockres->l_ro_holders++;\n\t\tbreak;\n\tdefault:\n\t\tBUG();\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog",
          "args": [
            "0",
            "\"lock %s, successful return from ocfs2_dlm_lock\\n\"",
            "lockres->l_name"
          ],
          "line": 1503
        },
        "resolved": true,
        "details": {
          "function_name": "mlog_show",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/cluster/masklog.c",
          "lines": "107-113",
          "snippet": "static ssize_t mlog_show(struct kobject *obj, struct attribute *attr,\n\t\t\t char *buf)\n{\n\tstruct mlog_attribute *mlog_attr = to_mlog_attr(attr);\n\n\treturn mlog_mask_show(mlog_attr->mask, buf);\n}",
          "includes": [
            "#include \"masklog.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/string.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"masklog.h\"\n#include <asm/uaccess.h>\n#include <linux/string.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n\nstatic ssize_t mlog_show(struct kobject *obj, struct attribute *attr,\n\t\t\t char *buf)\n{\n\tstruct mlog_attribute *mlog_attr = to_mlog_attr(attr);\n\n\treturn mlog_mask_show(mlog_attr->mask, buf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_recover_from_dlm_error",
          "args": [
            "lockres",
            "1"
          ],
          "line": 1498
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_recover_from_dlm_error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlmglue.c",
          "lines": "1199-1214",
          "snippet": "static inline void ocfs2_recover_from_dlm_error(struct ocfs2_lock_res *lockres,\n\t\t\t\t\t\tint convert)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&lockres->l_lock, flags);\n\tlockres_clear_flags(lockres, OCFS2_LOCK_BUSY);\n\tlockres_clear_flags(lockres, OCFS2_LOCK_UPCONVERT_FINISHING);\n\tif (convert)\n\t\tlockres->l_action = OCFS2_AST_INVALID;\n\telse\n\t\tlockres->l_unlock_action = OCFS2_UNLOCK_INVALID;\n\tspin_unlock_irqrestore(&lockres->l_lock, flags);\n\n\twake_up(&lockres->l_event);\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"refcounttree.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"stackglue.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dcache.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2_lockingver.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/time.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/kthread.h>",
            "#include <linux/mm.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct ocfs2_super *ocfs2_get_dentry_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_inode_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_file_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_qinfo_osb(struct ocfs2_lock_res *lockres);",
            "static void ocfs2_set_meta_lvb(struct ocfs2_lock_res *lockres);",
            "static void ocfs2_dentry_post_unlock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres);",
            "static void ocfs2_set_qinfo_lvb(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_downconvert_action(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_convert_action(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_attach_action(struct ocfs2_lock_res *lockres);",
            "static void ocfs2_schedule_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_recover_from_dlm_error(struct ocfs2_lock_res *lockres,\n\t\t\t\t\t\tint convert);",
            "static void ocfs2_downconvert_on_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static int ocfs2_prepare_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\t        struct ocfs2_lock_res *lockres);",
            "static int ocfs2_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static void ocfs2_process_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *lockres);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"stackglue.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dcache.h\"\n#include \"alloc.h\"\n#include \"ocfs2_lockingver.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/quotaops.h>\n#include <linux/time.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/pagemap.h>\n#include <linux/kthread.h>\n#include <linux/mm.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic struct ocfs2_super *ocfs2_get_dentry_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_inode_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_file_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_qinfo_osb(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_set_meta_lvb(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_dentry_post_unlock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres);\nstatic void ocfs2_set_qinfo_lvb(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_downconvert_action(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_convert_action(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_attach_action(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_schedule_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_recover_from_dlm_error(struct ocfs2_lock_res *lockres,\n\t\t\t\t\t\tint convert);\nstatic void ocfs2_downconvert_on_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic int ocfs2_prepare_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\t        struct ocfs2_lock_res *lockres);\nstatic int ocfs2_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_process_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *lockres);\n\nstatic inline void ocfs2_recover_from_dlm_error(struct ocfs2_lock_res *lockres,\n\t\t\t\t\t\tint convert)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&lockres->l_lock, flags);\n\tlockres_clear_flags(lockres, OCFS2_LOCK_BUSY);\n\tlockres_clear_flags(lockres, OCFS2_LOCK_UPCONVERT_FINISHING);\n\tif (convert)\n\t\tlockres->l_action = OCFS2_AST_INVALID;\n\telse\n\t\tlockres->l_unlock_action = OCFS2_UNLOCK_INVALID;\n\tspin_unlock_irqrestore(&lockres->l_lock, flags);\n\n\twake_up(&lockres->l_event);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_log_dlm_error",
          "args": [
            "\"ocfs2_dlm_lock\"",
            "ret",
            "lockres"
          ],
          "line": 1495
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lockres_clear_pending",
          "args": [
            "lockres",
            "gen",
            "osb"
          ],
          "line": 1491
        },
        "resolved": true,
        "details": {
          "function_name": "lockres_clear_pending",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlmglue.c",
          "lines": "1004-1013",
          "snippet": "static void lockres_clear_pending(struct ocfs2_lock_res *lockres,\n\t\t\t\t  unsigned int generation,\n\t\t\t\t  struct ocfs2_super *osb)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&lockres->l_lock, flags);\n\t__lockres_clear_pending(lockres, generation, osb);\n\tspin_unlock_irqrestore(&lockres->l_lock, flags);\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"refcounttree.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"stackglue.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dcache.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2_lockingver.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/time.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/kthread.h>",
            "#include <linux/mm.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct ocfs2_super *ocfs2_get_dentry_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_inode_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_file_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_qinfo_osb(struct ocfs2_lock_res *lockres);",
            "static void ocfs2_set_meta_lvb(struct ocfs2_lock_res *lockres);",
            "static void ocfs2_dentry_post_unlock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres);",
            "static void ocfs2_set_qinfo_lvb(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_downconvert_action(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_convert_action(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_attach_action(struct ocfs2_lock_res *lockres);",
            "static void ocfs2_schedule_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static void ocfs2_downconvert_on_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static void ocfs2_drop_osb_locks(struct ocfs2_super *osb);",
            "static int ocfs2_downconvert_lock(struct ocfs2_super *osb,\n\t\t\t\t  struct ocfs2_lock_res *lockres,\n\t\t\t\t  int new_level,\n\t\t\t\t  int lvb,\n\t\t\t\t  unsigned int generation);",
            "static int ocfs2_prepare_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\t        struct ocfs2_lock_res *lockres);",
            "static int ocfs2_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static void ocfs2_process_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *lockres);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"stackglue.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dcache.h\"\n#include \"alloc.h\"\n#include \"ocfs2_lockingver.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/quotaops.h>\n#include <linux/time.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/pagemap.h>\n#include <linux/kthread.h>\n#include <linux/mm.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic struct ocfs2_super *ocfs2_get_dentry_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_inode_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_file_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_qinfo_osb(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_set_meta_lvb(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_dentry_post_unlock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres);\nstatic void ocfs2_set_qinfo_lvb(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_downconvert_action(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_convert_action(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_attach_action(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_schedule_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_downconvert_on_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_drop_osb_locks(struct ocfs2_super *osb);\nstatic int ocfs2_downconvert_lock(struct ocfs2_super *osb,\n\t\t\t\t  struct ocfs2_lock_res *lockres,\n\t\t\t\t  int new_level,\n\t\t\t\t  int lvb,\n\t\t\t\t  unsigned int generation);\nstatic int ocfs2_prepare_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\t        struct ocfs2_lock_res *lockres);\nstatic int ocfs2_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_process_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *lockres);\n\nstatic void lockres_clear_pending(struct ocfs2_lock_res *lockres,\n\t\t\t\t  unsigned int generation,\n\t\t\t\t  struct ocfs2_super *osb)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&lockres->l_lock, flags);\n\t__lockres_clear_pending(lockres, generation, osb);\n\tspin_unlock_irqrestore(&lockres->l_lock, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_dlm_lock",
          "args": [
            "osb->cconn",
            "level",
            "&lockres->l_lksb",
            "lkm_flags",
            "lockres->l_name",
            "OCFS2_LOCK_ID_MAX_LEN - 1"
          ],
          "line": 1485
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_dlm_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/stackglue.c",
          "lines": "241-254",
          "snippet": "int ocfs2_dlm_lock(struct ocfs2_cluster_connection *conn,\n\t\t   int mode,\n\t\t   struct ocfs2_dlm_lksb *lksb,\n\t\t   u32 flags,\n\t\t   void *name,\n\t\t   unsigned int namelen)\n{\n\tif (!lksb->lksb_conn)\n\t\tlksb->lksb_conn = conn;\n\telse\n\t\tBUG_ON(lksb->lksb_conn != conn);\n\treturn active_stack->sp_ops->dlm_lock(conn, mode, lksb, flags,\n\t\t\t\t\t      name, namelen);\n}",
          "includes": [
            "#include \"stackglue.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include <linux/sysctl.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/fs.h>",
            "#include <linux/kmod.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/list.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct ocfs2_stack_plugin *active_stack;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"stackglue.h\"\n#include \"ocfs2_fs.h\"\n#include <linux/sysctl.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/fs.h>\n#include <linux/kmod.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/spinlock.h>\n#include <linux/list.h>\n\nstatic struct ocfs2_stack_plugin *active_stack;\n\nint ocfs2_dlm_lock(struct ocfs2_cluster_connection *conn,\n\t\t   int mode,\n\t\t   struct ocfs2_dlm_lksb *lksb,\n\t\t   u32 flags,\n\t\t   void *name,\n\t\t   unsigned int namelen)\n{\n\tif (!lksb->lksb_conn)\n\t\tlksb->lksb_conn = conn;\n\telse\n\t\tBUG_ON(lksb->lksb_conn != conn);\n\treturn active_stack->sp_ops->dlm_lock(conn, mode, lksb, flags,\n\t\t\t\t\t      name, namelen);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog",
          "args": [
            "ML_BASTS",
            "\"lockres %s, convert from %d to %d\\n\"",
            "lockres->l_name",
            "lockres->l_level",
            "level"
          ],
          "line": 1481
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "level == DLM_LOCK_NL"
          ],
          "line": 1479
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "level == DLM_LOCK_IV"
          ],
          "line": 1478
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock_irqrestore",
          "args": [
            "&lockres->l_lock",
            "flags"
          ],
          "line": 1476
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lockres_set_pending",
          "args": [
            "lockres"
          ],
          "line": 1475
        },
        "resolved": true,
        "details": {
          "function_name": "lockres_set_pending",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlmglue.c",
          "lines": "1015-1023",
          "snippet": "static unsigned int lockres_set_pending(struct ocfs2_lock_res *lockres)\n{\n\tassert_spin_locked(&lockres->l_lock);\n\tBUG_ON(!(lockres->l_flags & OCFS2_LOCK_BUSY));\n\n\tlockres_or_flags(lockres, OCFS2_LOCK_PENDING);\n\n\treturn lockres->l_pending_gen;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"refcounttree.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"stackglue.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dcache.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2_lockingver.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/time.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/kthread.h>",
            "#include <linux/mm.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct ocfs2_super *ocfs2_get_dentry_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_inode_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_file_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_qinfo_osb(struct ocfs2_lock_res *lockres);",
            "static void ocfs2_set_meta_lvb(struct ocfs2_lock_res *lockres);",
            "static void ocfs2_dentry_post_unlock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres);",
            "static void ocfs2_set_qinfo_lvb(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_downconvert_action(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_convert_action(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_attach_action(struct ocfs2_lock_res *lockres);",
            "static void ocfs2_schedule_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static void ocfs2_downconvert_on_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static int ocfs2_prepare_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\t        struct ocfs2_lock_res *lockres);",
            "static int ocfs2_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static void ocfs2_process_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *lockres);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"stackglue.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dcache.h\"\n#include \"alloc.h\"\n#include \"ocfs2_lockingver.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/quotaops.h>\n#include <linux/time.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/pagemap.h>\n#include <linux/kthread.h>\n#include <linux/mm.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic struct ocfs2_super *ocfs2_get_dentry_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_inode_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_file_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_qinfo_osb(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_set_meta_lvb(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_dentry_post_unlock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres);\nstatic void ocfs2_set_qinfo_lvb(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_downconvert_action(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_convert_action(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_attach_action(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_schedule_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_downconvert_on_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic int ocfs2_prepare_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\t        struct ocfs2_lock_res *lockres);\nstatic int ocfs2_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_process_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *lockres);\n\nstatic unsigned int lockres_set_pending(struct ocfs2_lock_res *lockres)\n{\n\tassert_spin_locked(&lockres->l_lock);\n\tBUG_ON(!(lockres->l_flags & OCFS2_LOCK_BUSY));\n\n\tlockres_or_flags(lockres, OCFS2_LOCK_PENDING);\n\n\treturn lockres->l_pending_gen;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog",
          "args": [
            "ML_ERROR",
            "\"lockres %s has action %u pending\\n\"",
            "lockres->l_name",
            "lockres->l_action"
          ],
          "line": 1462
        },
        "resolved": true,
        "details": {
          "function_name": "mlog_store",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/cluster/masklog.c",
          "lines": "115-121",
          "snippet": "static ssize_t mlog_store(struct kobject *obj, struct attribute *attr,\n\t\t\t  const char *buf, size_t count)\n{\n\tstruct mlog_attribute *mlog_attr = to_mlog_attr(attr);\n\n\treturn mlog_mask_store(mlog_attr->mask, buf, count);\n}",
          "includes": [
            "#include \"masklog.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/string.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"masklog.h\"\n#include <asm/uaccess.h>\n#include <linux/string.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n\nstatic ssize_t mlog_store(struct kobject *obj, struct attribute *attr,\n\t\t\t  const char *buf, size_t count)\n{\n\tstruct mlog_attribute *mlog_attr = to_mlog_attr(attr);\n\n\treturn mlog_mask_store(mlog_attr->mask, buf, count);\n}"
        }
      },
      {
        "call_info": {
          "callee": "lockres_add_mask_waiter",
          "args": [
            "lockres",
            "&mw",
            "OCFS2_LOCK_BLOCKED",
            "0"
          ],
          "line": 1448
        },
        "resolved": true,
        "details": {
          "function_name": "lockres_add_mask_waiter",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlmglue.c",
          "lines": "1316-1328",
          "snippet": "static void lockres_add_mask_waiter(struct ocfs2_lock_res *lockres,\n\t\t\t\t    struct ocfs2_mask_waiter *mw,\n\t\t\t\t    unsigned long mask,\n\t\t\t\t    unsigned long goal)\n{\n\tBUG_ON(!list_empty(&mw->mw_item));\n\n\tassert_spin_locked(&lockres->l_lock);\n\n\tlist_add_tail(&mw->mw_item, &lockres->l_mask_waiters);\n\tmw->mw_mask = mask;\n\tmw->mw_goal = goal;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"refcounttree.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"stackglue.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dcache.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2_lockingver.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/time.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/kthread.h>",
            "#include <linux/mm.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct ocfs2_super *ocfs2_get_dentry_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_inode_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_file_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_qinfo_osb(struct ocfs2_lock_res *lockres);",
            "static void ocfs2_set_meta_lvb(struct ocfs2_lock_res *lockres);",
            "static void ocfs2_dentry_post_unlock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres);",
            "static void ocfs2_set_qinfo_lvb(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_downconvert_action(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_convert_action(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_attach_action(struct ocfs2_lock_res *lockres);",
            "static void ocfs2_schedule_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static void ocfs2_downconvert_on_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static int ocfs2_prepare_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\t        struct ocfs2_lock_res *lockres);",
            "static int ocfs2_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static void ocfs2_process_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *lockres);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"stackglue.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dcache.h\"\n#include \"alloc.h\"\n#include \"ocfs2_lockingver.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/quotaops.h>\n#include <linux/time.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/pagemap.h>\n#include <linux/kthread.h>\n#include <linux/mm.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic struct ocfs2_super *ocfs2_get_dentry_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_inode_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_file_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_qinfo_osb(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_set_meta_lvb(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_dentry_post_unlock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres);\nstatic void ocfs2_set_qinfo_lvb(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_downconvert_action(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_convert_action(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_attach_action(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_schedule_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_downconvert_on_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic int ocfs2_prepare_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\t        struct ocfs2_lock_res *lockres);\nstatic int ocfs2_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_process_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *lockres);\n\nstatic void lockres_add_mask_waiter(struct ocfs2_lock_res *lockres,\n\t\t\t\t    struct ocfs2_mask_waiter *mw,\n\t\t\t\t    unsigned long mask,\n\t\t\t\t    unsigned long goal)\n{\n\tBUG_ON(!list_empty(&mw->mw_item));\n\n\tassert_spin_locked(&lockres->l_lock);\n\n\tlist_add_tail(&mw->mw_item, &lockres->l_mask_waiters);\n\tmw->mw_mask = mask;\n\tmw->mw_goal = goal;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_may_continue_on_blocked_lock",
          "args": [
            "lockres",
            "level"
          ],
          "line": 1445
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_may_continue_on_blocked_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlmglue.c",
          "lines": "1293-1299",
          "snippet": "static inline int ocfs2_may_continue_on_blocked_lock(struct ocfs2_lock_res *lockres,\n\t\t\t\t\t\t     int wanted)\n{\n\tBUG_ON(!(lockres->l_flags & OCFS2_LOCK_BLOCKED));\n\n\treturn wanted <= ocfs2_highest_compat_lock_level(lockres->l_blocking);\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"refcounttree.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"stackglue.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dcache.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2_lockingver.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/time.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/kthread.h>",
            "#include <linux/mm.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct ocfs2_super *ocfs2_get_dentry_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_inode_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_file_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_qinfo_osb(struct ocfs2_lock_res *lockres);",
            "static void ocfs2_set_meta_lvb(struct ocfs2_lock_res *lockres);",
            "static void ocfs2_dentry_post_unlock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres);",
            "static void ocfs2_set_qinfo_lvb(struct ocfs2_lock_res *lockres);",
            "static inline int ocfs2_may_continue_on_blocked_lock(struct ocfs2_lock_res *lockres,\n\t\t\t\t\t\t     int wanted);",
            "static inline void ocfs2_generic_handle_downconvert_action(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_convert_action(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_attach_action(struct ocfs2_lock_res *lockres);",
            "static void ocfs2_schedule_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static void ocfs2_downconvert_on_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static int ocfs2_prepare_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\t        struct ocfs2_lock_res *lockres);",
            "static int ocfs2_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static void ocfs2_process_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *lockres);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"stackglue.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dcache.h\"\n#include \"alloc.h\"\n#include \"ocfs2_lockingver.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/quotaops.h>\n#include <linux/time.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/pagemap.h>\n#include <linux/kthread.h>\n#include <linux/mm.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic struct ocfs2_super *ocfs2_get_dentry_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_inode_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_file_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_qinfo_osb(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_set_meta_lvb(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_dentry_post_unlock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres);\nstatic void ocfs2_set_qinfo_lvb(struct ocfs2_lock_res *lockres);\nstatic inline int ocfs2_may_continue_on_blocked_lock(struct ocfs2_lock_res *lockres,\n\t\t\t\t\t\t     int wanted);\nstatic inline void ocfs2_generic_handle_downconvert_action(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_convert_action(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_attach_action(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_schedule_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_downconvert_on_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic int ocfs2_prepare_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\t        struct ocfs2_lock_res *lockres);\nstatic int ocfs2_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_process_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *lockres);\n\nstatic inline int ocfs2_may_continue_on_blocked_lock(struct ocfs2_lock_res *lockres,\n\t\t\t\t\t\t     int wanted)\n{\n\tBUG_ON(!(lockres->l_flags & OCFS2_LOCK_BLOCKED));\n\n\treturn wanted <= ocfs2_highest_compat_lock_level(lockres->l_blocking);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_bug_on_msg",
          "args": [
            "lockres->l_flags & OCFS2_LOCK_FREEING",
            "\"Cluster lock called on freeing lockres %s! flags \"\n\t\t\t\"0x%lx\\n\"",
            "lockres->l_name",
            "lockres->l_flags"
          ],
          "line": 1409
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "signal_pending",
          "args": [
            "current"
          ],
          "line": 1404
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock_irqsave",
          "args": [
            "&lockres->l_lock",
            "flags"
          ],
          "line": 1402
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_init_mask_waiter",
          "args": [
            "&mw"
          ],
          "line": 1394
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_init_mask_waiter",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlmglue.c",
          "lines": "1301-1306",
          "snippet": "static void ocfs2_init_mask_waiter(struct ocfs2_mask_waiter *mw)\n{\n\tINIT_LIST_HEAD(&mw->mw_item);\n\tinit_completion(&mw->mw_complete);\n\tocfs2_init_start_time(mw);\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"refcounttree.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"stackglue.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dcache.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2_lockingver.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/time.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/kthread.h>",
            "#include <linux/mm.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"stackglue.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dcache.h\"\n#include \"alloc.h\"\n#include \"ocfs2_lockingver.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/quotaops.h>\n#include <linux/time.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/pagemap.h>\n#include <linux/kthread.h>\n#include <linux/mm.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic void ocfs2_init_mask_waiter(struct ocfs2_mask_waiter *mw)\n{\n\tINIT_LIST_HEAD(&mw->mw_item);\n\tinit_completion(&mw->mw_complete);\n\tocfs2_init_start_time(mw);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"stackglue.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dcache.h\"\n#include \"alloc.h\"\n#include \"ocfs2_lockingver.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/quotaops.h>\n#include <linux/time.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/pagemap.h>\n#include <linux/kthread.h>\n#include <linux/mm.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\n#define LOCK_TYPE_USES_LVB\t\t0x2\n\nstatic struct ocfs2_super *ocfs2_get_dentry_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_inode_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_file_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_qinfo_osb(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_set_meta_lvb(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_dentry_post_unlock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres);\nstatic void ocfs2_set_qinfo_lvb(struct ocfs2_lock_res *lockres);\nstatic void __ocfs2_cluster_unlock(struct ocfs2_super *osb,\n\t\t\t\t   struct ocfs2_lock_res *lockres,\n\t\t\t\t   int level, unsigned long caller_ip);\nstatic inline void ocfs2_generic_handle_downconvert_action(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_convert_action(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_attach_action(struct ocfs2_lock_res *lockres);\nstatic int ocfs2_generic_handle_bast(struct ocfs2_lock_res *lockres, int level);\nstatic void ocfs2_schedule_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_recover_from_dlm_error(struct ocfs2_lock_res *lockres,\n\t\t\t\t\t\tint convert);\nstatic void ocfs2_downconvert_on_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_drop_osb_locks(struct ocfs2_super *osb);\nstatic inline int ocfs2_highest_compat_lock_level(int level);\nstatic int ocfs2_prepare_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\t        struct ocfs2_lock_res *lockres);\nstatic int ocfs2_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_process_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *lockres);\n\nstatic int __ocfs2_cluster_lock(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres,\n\t\t\t\tint level,\n\t\t\t\tu32 lkm_flags,\n\t\t\t\tint arg_flags,\n\t\t\t\tint l_subclass,\n\t\t\t\tunsigned long caller_ip)\n{\n\tstruct ocfs2_mask_waiter mw;\n\tint wait, catch_signals = !(osb->s_mount_opt & OCFS2_MOUNT_NOINTR);\n\tint ret = 0; /* gcc doesn't realize wait = 1 guarantees ret is set */\n\tunsigned long flags;\n\tunsigned int gen;\n\tint noqueue_attempted = 0;\n\tint dlm_locked = 0;\n\n\tocfs2_init_mask_waiter(&mw);\n\n\tif (lockres->l_ops->flags & LOCK_TYPE_USES_LVB)\n\t\tlkm_flags |= DLM_LKF_VALBLK;\n\nagain:\n\twait = 0;\n\n\tspin_lock_irqsave(&lockres->l_lock, flags);\n\n\tif (catch_signals && signal_pending(current)) {\n\t\tret = -ERESTARTSYS;\n\t\tgoto unlock;\n\t}\n\n\tmlog_bug_on_msg(lockres->l_flags & OCFS2_LOCK_FREEING,\n\t\t\t\"Cluster lock called on freeing lockres %s! flags \"\n\t\t\t\"0x%lx\\n\", lockres->l_name, lockres->l_flags);\n\n\t/* We only compare against the currently granted level\n\t * here. If the lock is blocked waiting on a downconvert,\n\t * we'll get caught below. */\n\tif (lockres->l_flags & OCFS2_LOCK_BUSY &&\n\t    level > lockres->l_level) {\n\t\t/* is someone sitting in dlm_lock? If so, wait on\n\t\t * them. */\n\t\tlockres_add_mask_waiter(lockres, &mw, OCFS2_LOCK_BUSY, 0);\n\t\twait = 1;\n\t\tgoto unlock;\n\t}\n\n\tif (lockres->l_flags & OCFS2_LOCK_UPCONVERT_FINISHING) {\n\t\t/*\n\t\t * We've upconverted. If the lock now has a level we can\n\t\t * work with, we take it. If, however, the lock is not at the\n\t\t * required level, we go thru the full cycle. One way this could\n\t\t * happen is if a process requesting an upconvert to PR is\n\t\t * closely followed by another requesting upconvert to an EX.\n\t\t * If the process requesting EX lands here, we want it to\n\t\t * continue attempting to upconvert and let the process\n\t\t * requesting PR take the lock.\n\t\t * If multiple processes request upconvert to PR, the first one\n\t\t * here will take the lock. The others will have to go thru the\n\t\t * OCFS2_LOCK_BLOCKED check to ensure that there is no pending\n\t\t * downconvert request.\n\t\t */\n\t\tif (level <= lockres->l_level)\n\t\t\tgoto update_holders;\n\t}\n\n\tif (lockres->l_flags & OCFS2_LOCK_BLOCKED &&\n\t    !ocfs2_may_continue_on_blocked_lock(lockres, level)) {\n\t\t/* is the lock is currently blocked on behalf of\n\t\t * another node */\n\t\tlockres_add_mask_waiter(lockres, &mw, OCFS2_LOCK_BLOCKED, 0);\n\t\twait = 1;\n\t\tgoto unlock;\n\t}\n\n\tif (level > lockres->l_level) {\n\t\tif (noqueue_attempted > 0) {\n\t\t\tret = -EAGAIN;\n\t\t\tgoto unlock;\n\t\t}\n\t\tif (lkm_flags & DLM_LKF_NOQUEUE)\n\t\t\tnoqueue_attempted = 1;\n\n\t\tif (lockres->l_action != OCFS2_AST_INVALID)\n\t\t\tmlog(ML_ERROR, \"lockres %s has action %u pending\\n\",\n\t\t\t     lockres->l_name, lockres->l_action);\n\n\t\tif (!(lockres->l_flags & OCFS2_LOCK_ATTACHED)) {\n\t\t\tlockres->l_action = OCFS2_AST_ATTACH;\n\t\t\tlkm_flags &= ~DLM_LKF_CONVERT;\n\t\t} else {\n\t\t\tlockres->l_action = OCFS2_AST_CONVERT;\n\t\t\tlkm_flags |= DLM_LKF_CONVERT;\n\t\t}\n\n\t\tlockres->l_requested = level;\n\t\tlockres_or_flags(lockres, OCFS2_LOCK_BUSY);\n\t\tgen = lockres_set_pending(lockres);\n\t\tspin_unlock_irqrestore(&lockres->l_lock, flags);\n\n\t\tBUG_ON(level == DLM_LOCK_IV);\n\t\tBUG_ON(level == DLM_LOCK_NL);\n\n\t\tmlog(ML_BASTS, \"lockres %s, convert from %d to %d\\n\",\n\t\t     lockres->l_name, lockres->l_level, level);\n\n\t\t/* call dlm_lock to upgrade lock now */\n\t\tret = ocfs2_dlm_lock(osb->cconn,\n\t\t\t\t     level,\n\t\t\t\t     &lockres->l_lksb,\n\t\t\t\t     lkm_flags,\n\t\t\t\t     lockres->l_name,\n\t\t\t\t     OCFS2_LOCK_ID_MAX_LEN - 1);\n\t\tlockres_clear_pending(lockres, gen, osb);\n\t\tif (ret) {\n\t\t\tif (!(lkm_flags & DLM_LKF_NOQUEUE) ||\n\t\t\t    (ret != -EAGAIN)) {\n\t\t\t\tocfs2_log_dlm_error(\"ocfs2_dlm_lock\",\n\t\t\t\t\t\t    ret, lockres);\n\t\t\t}\n\t\t\tocfs2_recover_from_dlm_error(lockres, 1);\n\t\t\tgoto out;\n\t\t}\n\t\tdlm_locked = 1;\n\n\t\tmlog(0, \"lock %s, successful return from ocfs2_dlm_lock\\n\",\n\t\t     lockres->l_name);\n\n\t\t/* At this point we've gone inside the dlm and need to\n\t\t * complete our work regardless. */\n\t\tcatch_signals = 0;\n\n\t\t/* wait for busy to clear and carry on */\n\t\tgoto again;\n\t}\n\nupdate_holders:\n\t/* Ok, if we get here then we're good to go. */\n\tocfs2_inc_holders(lockres, level);\n\n\tret = 0;\nunlock:\n\tlockres_clear_flags(lockres, OCFS2_LOCK_UPCONVERT_FINISHING);\n\n\tspin_unlock_irqrestore(&lockres->l_lock, flags);\nout:\n\t/*\n\t * This is helping work around a lock inversion between the page lock\n\t * and dlm locks.  One path holds the page lock while calling aops\n\t * which block acquiring dlm locks.  The voting thread holds dlm\n\t * locks while acquiring page locks while down converting data locks.\n\t * This block is helping an aop path notice the inversion and back\n\t * off to unlock its page lock before trying the dlm lock again.\n\t */\n\tif (wait && arg_flags & OCFS2_LOCK_NONBLOCK &&\n\t    mw.mw_mask & (OCFS2_LOCK_BUSY|OCFS2_LOCK_BLOCKED)) {\n\t\twait = 0;\n\t\tspin_lock_irqsave(&lockres->l_lock, flags);\n\t\tif (__lockres_remove_mask_waiter(lockres, &mw)) {\n\t\t\tif (dlm_locked)\n\t\t\t\tlockres_or_flags(lockres,\n\t\t\t\t\tOCFS2_LOCK_NONBLOCK_FINISHED);\n\t\t\tspin_unlock_irqrestore(&lockres->l_lock, flags);\n\t\t\tret = -EAGAIN;\n\t\t} else {\n\t\t\tspin_unlock_irqrestore(&lockres->l_lock, flags);\n\t\t\tgoto again;\n\t\t}\n\t}\n\tif (wait) {\n\t\tret = ocfs2_wait_for_mask(&mw);\n\t\tif (ret == 0)\n\t\t\tgoto again;\n\t\tmlog_errno(ret);\n\t}\n\tocfs2_update_lock_stats(lockres, level, &mw, ret);\n\n#ifdef CONFIG_DEBUG_LOCK_ALLOC\n\tif (!ret && lockres->l_lockdep_map.key != NULL) {\n\t\tif (level == DLM_LOCK_PR)\n\t\t\trwsem_acquire_read(&lockres->l_lockdep_map, l_subclass,\n\t\t\t\t!!(arg_flags & OCFS2_META_LOCK_NOQUEUE),\n\t\t\t\tcaller_ip);\n\t\telse\n\t\t\trwsem_acquire(&lockres->l_lockdep_map, l_subclass,\n\t\t\t\t!!(arg_flags & OCFS2_META_LOCK_NOQUEUE),\n\t\t\t\tcaller_ip);\n\t}\n#endif\n\treturn ret;\n}"
  },
  {
    "function_name": "ocfs2_wait_for_mask_interruptible",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlmglue.c",
    "lines": "1363-1376",
    "snippet": "static int ocfs2_wait_for_mask_interruptible(struct ocfs2_mask_waiter *mw,\n\t\t\t\t\t     struct ocfs2_lock_res *lockres)\n{\n\tint ret;\n\n\tret = wait_for_completion_interruptible(&mw->mw_complete);\n\tif (ret)\n\t\tlockres_remove_mask_waiter(lockres, mw);\n\telse\n\t\tret = mw->mw_status;\n\t/* Re-arm the completion in case we want to wait on it again */\n\treinit_completion(&mw->mw_complete);\n\treturn ret;\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"refcounttree.h\"",
      "#include \"quota.h\"",
      "#include \"uptodate.h\"",
      "#include \"super.h\"",
      "#include \"slot_map.h\"",
      "#include \"stackglue.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"heartbeat.h\"",
      "#include \"file.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"dcache.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2_lockingver.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/time.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/kthread.h>",
      "#include <linux/mm.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct ocfs2_super *ocfs2_get_dentry_osb(struct ocfs2_lock_res *lockres);",
      "static struct ocfs2_super *ocfs2_get_inode_osb(struct ocfs2_lock_res *lockres);",
      "static struct ocfs2_super *ocfs2_get_file_osb(struct ocfs2_lock_res *lockres);",
      "static struct ocfs2_super *ocfs2_get_qinfo_osb(struct ocfs2_lock_res *lockres);",
      "static void ocfs2_set_meta_lvb(struct ocfs2_lock_res *lockres);",
      "static void ocfs2_dentry_post_unlock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres);",
      "static void ocfs2_set_qinfo_lvb(struct ocfs2_lock_res *lockres);",
      "static inline void ocfs2_generic_handle_downconvert_action(struct ocfs2_lock_res *lockres);",
      "static inline void ocfs2_generic_handle_convert_action(struct ocfs2_lock_res *lockres);",
      "static inline void ocfs2_generic_handle_attach_action(struct ocfs2_lock_res *lockres);",
      "static void ocfs2_schedule_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);",
      "static void ocfs2_downconvert_on_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);",
      "static int ocfs2_prepare_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\t        struct ocfs2_lock_res *lockres);",
      "static int ocfs2_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres);",
      "static void ocfs2_process_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *lockres);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "reinit_completion",
          "args": [
            "&mw->mw_complete"
          ],
          "line": 1374
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lockres_remove_mask_waiter",
          "args": [
            "lockres",
            "mw"
          ],
          "line": 1370
        },
        "resolved": true,
        "details": {
          "function_name": "lockres_remove_mask_waiter",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlmglue.c",
          "lines": "1349-1361",
          "snippet": "static int lockres_remove_mask_waiter(struct ocfs2_lock_res *lockres,\n\t\t\t\t      struct ocfs2_mask_waiter *mw)\n{\n\tunsigned long flags;\n\tint ret = 0;\n\n\tspin_lock_irqsave(&lockres->l_lock, flags);\n\tret = __lockres_remove_mask_waiter(lockres, mw);\n\tspin_unlock_irqrestore(&lockres->l_lock, flags);\n\n\treturn ret;\n\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"refcounttree.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"stackglue.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dcache.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2_lockingver.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/time.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/kthread.h>",
            "#include <linux/mm.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct ocfs2_super *ocfs2_get_dentry_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_inode_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_file_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_qinfo_osb(struct ocfs2_lock_res *lockres);",
            "static void ocfs2_set_meta_lvb(struct ocfs2_lock_res *lockres);",
            "static void ocfs2_dentry_post_unlock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres);",
            "static void ocfs2_set_qinfo_lvb(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_downconvert_action(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_convert_action(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_attach_action(struct ocfs2_lock_res *lockres);",
            "static void ocfs2_schedule_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static void ocfs2_downconvert_on_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static int ocfs2_prepare_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\t        struct ocfs2_lock_res *lockres);",
            "static int ocfs2_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static void ocfs2_process_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *lockres);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"stackglue.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dcache.h\"\n#include \"alloc.h\"\n#include \"ocfs2_lockingver.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/quotaops.h>\n#include <linux/time.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/pagemap.h>\n#include <linux/kthread.h>\n#include <linux/mm.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic struct ocfs2_super *ocfs2_get_dentry_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_inode_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_file_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_qinfo_osb(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_set_meta_lvb(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_dentry_post_unlock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres);\nstatic void ocfs2_set_qinfo_lvb(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_downconvert_action(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_convert_action(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_attach_action(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_schedule_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_downconvert_on_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic int ocfs2_prepare_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\t        struct ocfs2_lock_res *lockres);\nstatic int ocfs2_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_process_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *lockres);\n\nstatic int lockres_remove_mask_waiter(struct ocfs2_lock_res *lockres,\n\t\t\t\t      struct ocfs2_mask_waiter *mw)\n{\n\tunsigned long flags;\n\tint ret = 0;\n\n\tspin_lock_irqsave(&lockres->l_lock, flags);\n\tret = __lockres_remove_mask_waiter(lockres, mw);\n\tspin_unlock_irqrestore(&lockres->l_lock, flags);\n\n\treturn ret;\n\n}"
        }
      },
      {
        "call_info": {
          "callee": "wait_for_completion_interruptible",
          "args": [
            "&mw->mw_complete"
          ],
          "line": 1368
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"stackglue.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dcache.h\"\n#include \"alloc.h\"\n#include \"ocfs2_lockingver.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/quotaops.h>\n#include <linux/time.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/pagemap.h>\n#include <linux/kthread.h>\n#include <linux/mm.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic struct ocfs2_super *ocfs2_get_dentry_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_inode_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_file_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_qinfo_osb(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_set_meta_lvb(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_dentry_post_unlock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres);\nstatic void ocfs2_set_qinfo_lvb(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_downconvert_action(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_convert_action(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_attach_action(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_schedule_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_downconvert_on_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic int ocfs2_prepare_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\t        struct ocfs2_lock_res *lockres);\nstatic int ocfs2_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_process_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *lockres);\n\nstatic int ocfs2_wait_for_mask_interruptible(struct ocfs2_mask_waiter *mw,\n\t\t\t\t\t     struct ocfs2_lock_res *lockres)\n{\n\tint ret;\n\n\tret = wait_for_completion_interruptible(&mw->mw_complete);\n\tif (ret)\n\t\tlockres_remove_mask_waiter(lockres, mw);\n\telse\n\t\tret = mw->mw_status;\n\t/* Re-arm the completion in case we want to wait on it again */\n\treinit_completion(&mw->mw_complete);\n\treturn ret;\n}"
  },
  {
    "function_name": "lockres_remove_mask_waiter",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlmglue.c",
    "lines": "1349-1361",
    "snippet": "static int lockres_remove_mask_waiter(struct ocfs2_lock_res *lockres,\n\t\t\t\t      struct ocfs2_mask_waiter *mw)\n{\n\tunsigned long flags;\n\tint ret = 0;\n\n\tspin_lock_irqsave(&lockres->l_lock, flags);\n\tret = __lockres_remove_mask_waiter(lockres, mw);\n\tspin_unlock_irqrestore(&lockres->l_lock, flags);\n\n\treturn ret;\n\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"refcounttree.h\"",
      "#include \"quota.h\"",
      "#include \"uptodate.h\"",
      "#include \"super.h\"",
      "#include \"slot_map.h\"",
      "#include \"stackglue.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"heartbeat.h\"",
      "#include \"file.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"dcache.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2_lockingver.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/time.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/kthread.h>",
      "#include <linux/mm.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct ocfs2_super *ocfs2_get_dentry_osb(struct ocfs2_lock_res *lockres);",
      "static struct ocfs2_super *ocfs2_get_inode_osb(struct ocfs2_lock_res *lockres);",
      "static struct ocfs2_super *ocfs2_get_file_osb(struct ocfs2_lock_res *lockres);",
      "static struct ocfs2_super *ocfs2_get_qinfo_osb(struct ocfs2_lock_res *lockres);",
      "static void ocfs2_set_meta_lvb(struct ocfs2_lock_res *lockres);",
      "static void ocfs2_dentry_post_unlock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres);",
      "static void ocfs2_set_qinfo_lvb(struct ocfs2_lock_res *lockres);",
      "static inline void ocfs2_generic_handle_downconvert_action(struct ocfs2_lock_res *lockres);",
      "static inline void ocfs2_generic_handle_convert_action(struct ocfs2_lock_res *lockres);",
      "static inline void ocfs2_generic_handle_attach_action(struct ocfs2_lock_res *lockres);",
      "static void ocfs2_schedule_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);",
      "static void ocfs2_downconvert_on_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);",
      "static int ocfs2_prepare_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\t        struct ocfs2_lock_res *lockres);",
      "static int ocfs2_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres);",
      "static void ocfs2_process_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *lockres);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock_irqrestore",
          "args": [
            "&lockres->l_lock",
            "flags"
          ],
          "line": 1357
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__lockres_remove_mask_waiter",
          "args": [
            "lockres",
            "mw"
          ],
          "line": 1356
        },
        "resolved": true,
        "details": {
          "function_name": "__lockres_remove_mask_waiter",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlmglue.c",
          "lines": "1332-1347",
          "snippet": "static int __lockres_remove_mask_waiter(struct ocfs2_lock_res *lockres,\n\t\t\t\t      struct ocfs2_mask_waiter *mw)\n{\n\tint ret = 0;\n\n\tassert_spin_locked(&lockres->l_lock);\n\tif (!list_empty(&mw->mw_item)) {\n\t\tif ((lockres->l_flags & mw->mw_mask) != mw->mw_goal)\n\t\t\tret = -EBUSY;\n\n\t\tlist_del_init(&mw->mw_item);\n\t\tinit_completion(&mw->mw_complete);\n\t}\n\n\treturn ret;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"refcounttree.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"stackglue.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dcache.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2_lockingver.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/time.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/kthread.h>",
            "#include <linux/mm.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct ocfs2_super *ocfs2_get_dentry_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_inode_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_file_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_qinfo_osb(struct ocfs2_lock_res *lockres);",
            "static void ocfs2_set_meta_lvb(struct ocfs2_lock_res *lockres);",
            "static void ocfs2_dentry_post_unlock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres);",
            "static void ocfs2_set_qinfo_lvb(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_downconvert_action(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_convert_action(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_attach_action(struct ocfs2_lock_res *lockres);",
            "static void ocfs2_schedule_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static void ocfs2_downconvert_on_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static int ocfs2_prepare_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\t        struct ocfs2_lock_res *lockres);",
            "static int ocfs2_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static void ocfs2_process_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *lockres);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"stackglue.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dcache.h\"\n#include \"alloc.h\"\n#include \"ocfs2_lockingver.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/quotaops.h>\n#include <linux/time.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/pagemap.h>\n#include <linux/kthread.h>\n#include <linux/mm.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic struct ocfs2_super *ocfs2_get_dentry_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_inode_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_file_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_qinfo_osb(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_set_meta_lvb(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_dentry_post_unlock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres);\nstatic void ocfs2_set_qinfo_lvb(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_downconvert_action(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_convert_action(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_attach_action(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_schedule_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_downconvert_on_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic int ocfs2_prepare_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\t        struct ocfs2_lock_res *lockres);\nstatic int ocfs2_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_process_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *lockres);\n\nstatic int __lockres_remove_mask_waiter(struct ocfs2_lock_res *lockres,\n\t\t\t\t      struct ocfs2_mask_waiter *mw)\n{\n\tint ret = 0;\n\n\tassert_spin_locked(&lockres->l_lock);\n\tif (!list_empty(&mw->mw_item)) {\n\t\tif ((lockres->l_flags & mw->mw_mask) != mw->mw_goal)\n\t\t\tret = -EBUSY;\n\n\t\tlist_del_init(&mw->mw_item);\n\t\tinit_completion(&mw->mw_complete);\n\t}\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock_irqsave",
          "args": [
            "&lockres->l_lock",
            "flags"
          ],
          "line": 1355
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"stackglue.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dcache.h\"\n#include \"alloc.h\"\n#include \"ocfs2_lockingver.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/quotaops.h>\n#include <linux/time.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/pagemap.h>\n#include <linux/kthread.h>\n#include <linux/mm.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic struct ocfs2_super *ocfs2_get_dentry_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_inode_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_file_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_qinfo_osb(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_set_meta_lvb(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_dentry_post_unlock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres);\nstatic void ocfs2_set_qinfo_lvb(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_downconvert_action(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_convert_action(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_attach_action(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_schedule_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_downconvert_on_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic int ocfs2_prepare_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\t        struct ocfs2_lock_res *lockres);\nstatic int ocfs2_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_process_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *lockres);\n\nstatic int lockres_remove_mask_waiter(struct ocfs2_lock_res *lockres,\n\t\t\t\t      struct ocfs2_mask_waiter *mw)\n{\n\tunsigned long flags;\n\tint ret = 0;\n\n\tspin_lock_irqsave(&lockres->l_lock, flags);\n\tret = __lockres_remove_mask_waiter(lockres, mw);\n\tspin_unlock_irqrestore(&lockres->l_lock, flags);\n\n\treturn ret;\n\n}"
  },
  {
    "function_name": "__lockres_remove_mask_waiter",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlmglue.c",
    "lines": "1332-1347",
    "snippet": "static int __lockres_remove_mask_waiter(struct ocfs2_lock_res *lockres,\n\t\t\t\t      struct ocfs2_mask_waiter *mw)\n{\n\tint ret = 0;\n\n\tassert_spin_locked(&lockres->l_lock);\n\tif (!list_empty(&mw->mw_item)) {\n\t\tif ((lockres->l_flags & mw->mw_mask) != mw->mw_goal)\n\t\t\tret = -EBUSY;\n\n\t\tlist_del_init(&mw->mw_item);\n\t\tinit_completion(&mw->mw_complete);\n\t}\n\n\treturn ret;\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"refcounttree.h\"",
      "#include \"quota.h\"",
      "#include \"uptodate.h\"",
      "#include \"super.h\"",
      "#include \"slot_map.h\"",
      "#include \"stackglue.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"heartbeat.h\"",
      "#include \"file.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"dcache.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2_lockingver.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/time.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/kthread.h>",
      "#include <linux/mm.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct ocfs2_super *ocfs2_get_dentry_osb(struct ocfs2_lock_res *lockres);",
      "static struct ocfs2_super *ocfs2_get_inode_osb(struct ocfs2_lock_res *lockres);",
      "static struct ocfs2_super *ocfs2_get_file_osb(struct ocfs2_lock_res *lockres);",
      "static struct ocfs2_super *ocfs2_get_qinfo_osb(struct ocfs2_lock_res *lockres);",
      "static void ocfs2_set_meta_lvb(struct ocfs2_lock_res *lockres);",
      "static void ocfs2_dentry_post_unlock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres);",
      "static void ocfs2_set_qinfo_lvb(struct ocfs2_lock_res *lockres);",
      "static inline void ocfs2_generic_handle_downconvert_action(struct ocfs2_lock_res *lockres);",
      "static inline void ocfs2_generic_handle_convert_action(struct ocfs2_lock_res *lockres);",
      "static inline void ocfs2_generic_handle_attach_action(struct ocfs2_lock_res *lockres);",
      "static void ocfs2_schedule_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);",
      "static void ocfs2_downconvert_on_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);",
      "static int ocfs2_prepare_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\t        struct ocfs2_lock_res *lockres);",
      "static int ocfs2_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres);",
      "static void ocfs2_process_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *lockres);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "init_completion",
          "args": [
            "&mw->mw_complete"
          ],
          "line": 1343
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_del_init",
          "args": [
            "&mw->mw_item"
          ],
          "line": 1342
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&mw->mw_item"
          ],
          "line": 1338
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_dirty_list_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmthread.c",
          "lines": "505-514",
          "snippet": "static int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/timer.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_flush_asts(struct dlm_ctxt *dlm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/timer.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_flush_asts(struct dlm_ctxt *dlm);\n\nstatic int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}"
        }
      },
      {
        "call_info": {
          "callee": "assert_spin_locked",
          "args": [
            "&lockres->l_lock"
          ],
          "line": 1337
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"stackglue.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dcache.h\"\n#include \"alloc.h\"\n#include \"ocfs2_lockingver.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/quotaops.h>\n#include <linux/time.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/pagemap.h>\n#include <linux/kthread.h>\n#include <linux/mm.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic struct ocfs2_super *ocfs2_get_dentry_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_inode_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_file_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_qinfo_osb(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_set_meta_lvb(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_dentry_post_unlock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres);\nstatic void ocfs2_set_qinfo_lvb(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_downconvert_action(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_convert_action(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_attach_action(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_schedule_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_downconvert_on_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic int ocfs2_prepare_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\t        struct ocfs2_lock_res *lockres);\nstatic int ocfs2_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_process_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *lockres);\n\nstatic int __lockres_remove_mask_waiter(struct ocfs2_lock_res *lockres,\n\t\t\t\t      struct ocfs2_mask_waiter *mw)\n{\n\tint ret = 0;\n\n\tassert_spin_locked(&lockres->l_lock);\n\tif (!list_empty(&mw->mw_item)) {\n\t\tif ((lockres->l_flags & mw->mw_mask) != mw->mw_goal)\n\t\t\tret = -EBUSY;\n\n\t\tlist_del_init(&mw->mw_item);\n\t\tinit_completion(&mw->mw_complete);\n\t}\n\n\treturn ret;\n}"
  },
  {
    "function_name": "lockres_add_mask_waiter",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlmglue.c",
    "lines": "1316-1328",
    "snippet": "static void lockres_add_mask_waiter(struct ocfs2_lock_res *lockres,\n\t\t\t\t    struct ocfs2_mask_waiter *mw,\n\t\t\t\t    unsigned long mask,\n\t\t\t\t    unsigned long goal)\n{\n\tBUG_ON(!list_empty(&mw->mw_item));\n\n\tassert_spin_locked(&lockres->l_lock);\n\n\tlist_add_tail(&mw->mw_item, &lockres->l_mask_waiters);\n\tmw->mw_mask = mask;\n\tmw->mw_goal = goal;\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"refcounttree.h\"",
      "#include \"quota.h\"",
      "#include \"uptodate.h\"",
      "#include \"super.h\"",
      "#include \"slot_map.h\"",
      "#include \"stackglue.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"heartbeat.h\"",
      "#include \"file.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"dcache.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2_lockingver.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/time.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/kthread.h>",
      "#include <linux/mm.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct ocfs2_super *ocfs2_get_dentry_osb(struct ocfs2_lock_res *lockres);",
      "static struct ocfs2_super *ocfs2_get_inode_osb(struct ocfs2_lock_res *lockres);",
      "static struct ocfs2_super *ocfs2_get_file_osb(struct ocfs2_lock_res *lockres);",
      "static struct ocfs2_super *ocfs2_get_qinfo_osb(struct ocfs2_lock_res *lockres);",
      "static void ocfs2_set_meta_lvb(struct ocfs2_lock_res *lockres);",
      "static void ocfs2_dentry_post_unlock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres);",
      "static void ocfs2_set_qinfo_lvb(struct ocfs2_lock_res *lockres);",
      "static inline void ocfs2_generic_handle_downconvert_action(struct ocfs2_lock_res *lockres);",
      "static inline void ocfs2_generic_handle_convert_action(struct ocfs2_lock_res *lockres);",
      "static inline void ocfs2_generic_handle_attach_action(struct ocfs2_lock_res *lockres);",
      "static void ocfs2_schedule_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);",
      "static void ocfs2_downconvert_on_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);",
      "static int ocfs2_prepare_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\t        struct ocfs2_lock_res *lockres);",
      "static int ocfs2_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres);",
      "static void ocfs2_process_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *lockres);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "list_add_tail",
          "args": [
            "&mw->mw_item",
            "&lockres->l_mask_waiters"
          ],
          "line": 1325
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "assert_spin_locked",
          "args": [
            "&lockres->l_lock"
          ],
          "line": 1323
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!list_empty(&mw->mw_item)"
          ],
          "line": 1321
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&mw->mw_item"
          ],
          "line": 1321
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_dirty_list_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmthread.c",
          "lines": "505-514",
          "snippet": "static int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/timer.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_flush_asts(struct dlm_ctxt *dlm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/timer.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_flush_asts(struct dlm_ctxt *dlm);\n\nstatic int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"stackglue.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dcache.h\"\n#include \"alloc.h\"\n#include \"ocfs2_lockingver.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/quotaops.h>\n#include <linux/time.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/pagemap.h>\n#include <linux/kthread.h>\n#include <linux/mm.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic struct ocfs2_super *ocfs2_get_dentry_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_inode_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_file_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_qinfo_osb(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_set_meta_lvb(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_dentry_post_unlock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres);\nstatic void ocfs2_set_qinfo_lvb(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_downconvert_action(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_convert_action(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_attach_action(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_schedule_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_downconvert_on_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic int ocfs2_prepare_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\t        struct ocfs2_lock_res *lockres);\nstatic int ocfs2_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_process_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *lockres);\n\nstatic void lockres_add_mask_waiter(struct ocfs2_lock_res *lockres,\n\t\t\t\t    struct ocfs2_mask_waiter *mw,\n\t\t\t\t    unsigned long mask,\n\t\t\t\t    unsigned long goal)\n{\n\tBUG_ON(!list_empty(&mw->mw_item));\n\n\tassert_spin_locked(&lockres->l_lock);\n\n\tlist_add_tail(&mw->mw_item, &lockres->l_mask_waiters);\n\tmw->mw_mask = mask;\n\tmw->mw_goal = goal;\n}"
  },
  {
    "function_name": "ocfs2_wait_for_mask",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlmglue.c",
    "lines": "1308-1314",
    "snippet": "static int ocfs2_wait_for_mask(struct ocfs2_mask_waiter *mw)\n{\n\twait_for_completion(&mw->mw_complete);\n\t/* Re-arm the completion in case we want to wait on it again */\n\treinit_completion(&mw->mw_complete);\n\treturn mw->mw_status;\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"refcounttree.h\"",
      "#include \"quota.h\"",
      "#include \"uptodate.h\"",
      "#include \"super.h\"",
      "#include \"slot_map.h\"",
      "#include \"stackglue.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"heartbeat.h\"",
      "#include \"file.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"dcache.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2_lockingver.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/time.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/kthread.h>",
      "#include <linux/mm.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "reinit_completion",
          "args": [
            "&mw->mw_complete"
          ],
          "line": 1312
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wait_for_completion",
          "args": [
            "&mw->mw_complete"
          ],
          "line": 1310
        },
        "resolved": true,
        "details": {
          "function_name": "nfs4_wait_for_completion_rpc_task",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/nfs4proc.c",
          "lines": "1116-1122",
          "snippet": "static int nfs4_wait_for_completion_rpc_task(struct rpc_task *task)\n{\n\tint ret;\n\n\tret = rpc_wait_for_completion_task(task);\n\treturn ret;\n}",
          "includes": [
            "#include \"nfs4trace.h\"",
            "#include \"fscache.h\"",
            "#include \"nfs4session.h\"",
            "#include \"netns.h\"",
            "#include \"pnfs.h\"",
            "#include \"callback.h\"",
            "#include \"iostat.h\"",
            "#include \"internal.h\"",
            "#include \"delegation.h\"",
            "#include \"nfs4_fs.h\"",
            "#include <linux/freezer.h>",
            "#include <linux/utsname.h>",
            "#include <linux/xattr.h>",
            "#include <linux/nfs_idmap.h>",
            "#include <linux/module.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/nfs_mount.h>",
            "#include <linux/nfs_page.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/nfs4.h>",
            "#include <linux/nfs.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/slab.h>",
            "#include <linux/printk.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/string.h>",
            "#include <linux/errno.h>",
            "#include <linux/delay.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"nfs4trace.h\"\n#include \"fscache.h\"\n#include \"nfs4session.h\"\n#include \"netns.h\"\n#include \"pnfs.h\"\n#include \"callback.h\"\n#include \"iostat.h\"\n#include \"internal.h\"\n#include \"delegation.h\"\n#include \"nfs4_fs.h\"\n#include <linux/freezer.h>\n#include <linux/utsname.h>\n#include <linux/xattr.h>\n#include <linux/nfs_idmap.h>\n#include <linux/module.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/nfs_mount.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_fs.h>\n#include <linux/nfs4.h>\n#include <linux/nfs.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/slab.h>\n#include <linux/printk.h>\n#include <linux/ratelimit.h>\n#include <linux/string.h>\n#include <linux/errno.h>\n#include <linux/delay.h>\n#include <linux/mm.h>\n\nstatic int nfs4_wait_for_completion_rpc_task(struct rpc_task *task)\n{\n\tint ret;\n\n\tret = rpc_wait_for_completion_task(task);\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"stackglue.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dcache.h\"\n#include \"alloc.h\"\n#include \"ocfs2_lockingver.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/quotaops.h>\n#include <linux/time.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/pagemap.h>\n#include <linux/kthread.h>\n#include <linux/mm.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic int ocfs2_wait_for_mask(struct ocfs2_mask_waiter *mw)\n{\n\twait_for_completion(&mw->mw_complete);\n\t/* Re-arm the completion in case we want to wait on it again */\n\treinit_completion(&mw->mw_complete);\n\treturn mw->mw_status;\n}"
  },
  {
    "function_name": "ocfs2_init_mask_waiter",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlmglue.c",
    "lines": "1301-1306",
    "snippet": "static void ocfs2_init_mask_waiter(struct ocfs2_mask_waiter *mw)\n{\n\tINIT_LIST_HEAD(&mw->mw_item);\n\tinit_completion(&mw->mw_complete);\n\tocfs2_init_start_time(mw);\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"refcounttree.h\"",
      "#include \"quota.h\"",
      "#include \"uptodate.h\"",
      "#include \"super.h\"",
      "#include \"slot_map.h\"",
      "#include \"stackglue.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"heartbeat.h\"",
      "#include \"file.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"dcache.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2_lockingver.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/time.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/kthread.h>",
      "#include <linux/mm.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ocfs2_init_start_time",
          "args": [
            "mw"
          ],
          "line": 1305
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_init_start_time",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlmglue.c",
          "lines": "491-493",
          "snippet": "static inline void ocfs2_init_start_time(struct ocfs2_mask_waiter *mw)\n{\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"refcounttree.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"stackglue.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dcache.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2_lockingver.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/time.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/kthread.h>",
            "#include <linux/mm.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"stackglue.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dcache.h\"\n#include \"alloc.h\"\n#include \"ocfs2_lockingver.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/quotaops.h>\n#include <linux/time.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/pagemap.h>\n#include <linux/kthread.h>\n#include <linux/mm.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic inline void ocfs2_init_start_time(struct ocfs2_mask_waiter *mw)\n{\n}"
        }
      },
      {
        "call_info": {
          "callee": "init_completion",
          "args": [
            "&mw->mw_complete"
          ],
          "line": 1304
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&mw->mw_item"
          ],
          "line": 1303
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"stackglue.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dcache.h\"\n#include \"alloc.h\"\n#include \"ocfs2_lockingver.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/quotaops.h>\n#include <linux/time.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/pagemap.h>\n#include <linux/kthread.h>\n#include <linux/mm.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic void ocfs2_init_mask_waiter(struct ocfs2_mask_waiter *mw)\n{\n\tINIT_LIST_HEAD(&mw->mw_item);\n\tinit_completion(&mw->mw_complete);\n\tocfs2_init_start_time(mw);\n}"
  },
  {
    "function_name": "ocfs2_may_continue_on_blocked_lock",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlmglue.c",
    "lines": "1293-1299",
    "snippet": "static inline int ocfs2_may_continue_on_blocked_lock(struct ocfs2_lock_res *lockres,\n\t\t\t\t\t\t     int wanted)\n{\n\tBUG_ON(!(lockres->l_flags & OCFS2_LOCK_BLOCKED));\n\n\treturn wanted <= ocfs2_highest_compat_lock_level(lockres->l_blocking);\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"refcounttree.h\"",
      "#include \"quota.h\"",
      "#include \"uptodate.h\"",
      "#include \"super.h\"",
      "#include \"slot_map.h\"",
      "#include \"stackglue.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"heartbeat.h\"",
      "#include \"file.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"dcache.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2_lockingver.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/time.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/kthread.h>",
      "#include <linux/mm.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct ocfs2_super *ocfs2_get_dentry_osb(struct ocfs2_lock_res *lockres);",
      "static struct ocfs2_super *ocfs2_get_inode_osb(struct ocfs2_lock_res *lockres);",
      "static struct ocfs2_super *ocfs2_get_file_osb(struct ocfs2_lock_res *lockres);",
      "static struct ocfs2_super *ocfs2_get_qinfo_osb(struct ocfs2_lock_res *lockres);",
      "static void ocfs2_set_meta_lvb(struct ocfs2_lock_res *lockres);",
      "static void ocfs2_dentry_post_unlock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres);",
      "static void ocfs2_set_qinfo_lvb(struct ocfs2_lock_res *lockres);",
      "static inline int ocfs2_may_continue_on_blocked_lock(struct ocfs2_lock_res *lockres,\n\t\t\t\t\t\t     int wanted);",
      "static inline void ocfs2_generic_handle_downconvert_action(struct ocfs2_lock_res *lockres);",
      "static inline void ocfs2_generic_handle_convert_action(struct ocfs2_lock_res *lockres);",
      "static inline void ocfs2_generic_handle_attach_action(struct ocfs2_lock_res *lockres);",
      "static void ocfs2_schedule_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);",
      "static void ocfs2_downconvert_on_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);",
      "static int ocfs2_prepare_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\t        struct ocfs2_lock_res *lockres);",
      "static int ocfs2_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres);",
      "static void ocfs2_process_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *lockres);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ocfs2_highest_compat_lock_level",
          "args": [
            "lockres->l_blocking"
          ],
          "line": 1298
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_highest_compat_lock_level",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlmglue.c",
          "lines": "790-799",
          "snippet": "static inline int ocfs2_highest_compat_lock_level(int level)\n{\n\tint new_level = DLM_LOCK_EX;\n\n\tif (level == DLM_LOCK_EX)\n\t\tnew_level = DLM_LOCK_NL;\n\telse if (level == DLM_LOCK_PR)\n\t\tnew_level = DLM_LOCK_PR;\n\treturn new_level;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"refcounttree.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"stackglue.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dcache.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2_lockingver.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/time.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/kthread.h>",
            "#include <linux/mm.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ocfs2_check_meta_downconvert(struct ocfs2_lock_res *lockres,\n\t\t\t\t\tint new_level);",
            "static int ocfs2_check_refcount_downconvert(struct ocfs2_lock_res *lockres,\n\t\t\t\t\t    int new_level);",
            "static int ocfs2_generic_handle_bast(struct ocfs2_lock_res *lockres, int level);",
            "static inline int ocfs2_highest_compat_lock_level(int level);",
            "static unsigned int ocfs2_prepare_downconvert(struct ocfs2_lock_res *lockres,\n\t\t\t\t\t      int new_level);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"stackglue.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dcache.h\"\n#include \"alloc.h\"\n#include \"ocfs2_lockingver.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/quotaops.h>\n#include <linux/time.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/pagemap.h>\n#include <linux/kthread.h>\n#include <linux/mm.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic int ocfs2_check_meta_downconvert(struct ocfs2_lock_res *lockres,\n\t\t\t\t\tint new_level);\nstatic int ocfs2_check_refcount_downconvert(struct ocfs2_lock_res *lockres,\n\t\t\t\t\t    int new_level);\nstatic int ocfs2_generic_handle_bast(struct ocfs2_lock_res *lockres, int level);\nstatic inline int ocfs2_highest_compat_lock_level(int level);\nstatic unsigned int ocfs2_prepare_downconvert(struct ocfs2_lock_res *lockres,\n\t\t\t\t\t      int new_level);\n\nstatic inline int ocfs2_highest_compat_lock_level(int level)\n{\n\tint new_level = DLM_LOCK_EX;\n\n\tif (level == DLM_LOCK_EX)\n\t\tnew_level = DLM_LOCK_NL;\n\telse if (level == DLM_LOCK_PR)\n\t\tnew_level = DLM_LOCK_PR;\n\treturn new_level;\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!(lockres->l_flags & OCFS2_LOCK_BLOCKED)"
          ],
          "line": 1296
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"stackglue.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dcache.h\"\n#include \"alloc.h\"\n#include \"ocfs2_lockingver.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/quotaops.h>\n#include <linux/time.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/pagemap.h>\n#include <linux/kthread.h>\n#include <linux/mm.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic struct ocfs2_super *ocfs2_get_dentry_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_inode_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_file_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_qinfo_osb(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_set_meta_lvb(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_dentry_post_unlock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres);\nstatic void ocfs2_set_qinfo_lvb(struct ocfs2_lock_res *lockres);\nstatic inline int ocfs2_may_continue_on_blocked_lock(struct ocfs2_lock_res *lockres,\n\t\t\t\t\t\t     int wanted);\nstatic inline void ocfs2_generic_handle_downconvert_action(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_convert_action(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_attach_action(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_schedule_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_downconvert_on_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic int ocfs2_prepare_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\t        struct ocfs2_lock_res *lockres);\nstatic int ocfs2_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_process_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *lockres);\n\nstatic inline int ocfs2_may_continue_on_blocked_lock(struct ocfs2_lock_res *lockres,\n\t\t\t\t\t\t     int wanted)\n{\n\tBUG_ON(!(lockres->l_flags & OCFS2_LOCK_BLOCKED));\n\n\treturn wanted <= ocfs2_highest_compat_lock_level(lockres->l_blocking);\n}"
  },
  {
    "function_name": "ocfs2_wait_on_refreshing_lock",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlmglue.c",
    "lines": "1283-1288",
    "snippet": "static inline void ocfs2_wait_on_refreshing_lock(struct ocfs2_lock_res *lockres)\n\n{\n\twait_event(lockres->l_event,\n\t\t   !ocfs2_check_wait_flag(lockres, OCFS2_LOCK_REFRESHING));\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"refcounttree.h\"",
      "#include \"quota.h\"",
      "#include \"uptodate.h\"",
      "#include \"super.h\"",
      "#include \"slot_map.h\"",
      "#include \"stackglue.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"heartbeat.h\"",
      "#include \"file.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"dcache.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2_lockingver.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/time.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/kthread.h>",
      "#include <linux/mm.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct ocfs2_super *ocfs2_get_dentry_osb(struct ocfs2_lock_res *lockres);",
      "static struct ocfs2_super *ocfs2_get_inode_osb(struct ocfs2_lock_res *lockres);",
      "static struct ocfs2_super *ocfs2_get_file_osb(struct ocfs2_lock_res *lockres);",
      "static struct ocfs2_super *ocfs2_get_qinfo_osb(struct ocfs2_lock_res *lockres);",
      "static void ocfs2_set_meta_lvb(struct ocfs2_lock_res *lockres);",
      "static void ocfs2_dentry_post_unlock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres);",
      "static void ocfs2_set_qinfo_lvb(struct ocfs2_lock_res *lockres);",
      "static inline void ocfs2_generic_handle_downconvert_action(struct ocfs2_lock_res *lockres);",
      "static inline void ocfs2_generic_handle_convert_action(struct ocfs2_lock_res *lockres);",
      "static inline void ocfs2_generic_handle_attach_action(struct ocfs2_lock_res *lockres);",
      "static void ocfs2_schedule_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);",
      "static void ocfs2_downconvert_on_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);",
      "static int ocfs2_prepare_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\t        struct ocfs2_lock_res *lockres);",
      "static int ocfs2_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres);",
      "static void ocfs2_process_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *lockres);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "wait_event",
          "args": [
            "lockres->l_event",
            "!ocfs2_check_wait_flag(lockres, OCFS2_LOCK_REFRESHING)"
          ],
          "line": 1286
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_check_wait_flag",
          "args": [
            "lockres",
            "OCFS2_LOCK_REFRESHING"
          ],
          "line": 1287
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_check_wait_flag",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlmglue.c",
          "lines": "1263-1274",
          "snippet": "static inline int ocfs2_check_wait_flag(struct ocfs2_lock_res *lockres,\n\t\t\t\t\tint flag)\n{\n\tunsigned long flags;\n\tint ret;\n\n\tspin_lock_irqsave(&lockres->l_lock, flags);\n\tret = lockres->l_flags & flag;\n\tspin_unlock_irqrestore(&lockres->l_lock, flags);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"refcounttree.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"stackglue.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dcache.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2_lockingver.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/time.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/kthread.h>",
            "#include <linux/mm.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct ocfs2_super *ocfs2_get_dentry_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_inode_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_file_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_qinfo_osb(struct ocfs2_lock_res *lockres);",
            "static void ocfs2_set_meta_lvb(struct ocfs2_lock_res *lockres);",
            "static void ocfs2_dentry_post_unlock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres);",
            "static void ocfs2_set_qinfo_lvb(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_downconvert_action(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_convert_action(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_attach_action(struct ocfs2_lock_res *lockres);",
            "static void ocfs2_schedule_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static void ocfs2_downconvert_on_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static int ocfs2_prepare_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\t        struct ocfs2_lock_res *lockres);",
            "static int ocfs2_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static void ocfs2_process_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *lockres);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"stackglue.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dcache.h\"\n#include \"alloc.h\"\n#include \"ocfs2_lockingver.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/quotaops.h>\n#include <linux/time.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/pagemap.h>\n#include <linux/kthread.h>\n#include <linux/mm.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic struct ocfs2_super *ocfs2_get_dentry_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_inode_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_file_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_qinfo_osb(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_set_meta_lvb(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_dentry_post_unlock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres);\nstatic void ocfs2_set_qinfo_lvb(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_downconvert_action(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_convert_action(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_attach_action(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_schedule_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_downconvert_on_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic int ocfs2_prepare_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\t        struct ocfs2_lock_res *lockres);\nstatic int ocfs2_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_process_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *lockres);\n\nstatic inline int ocfs2_check_wait_flag(struct ocfs2_lock_res *lockres,\n\t\t\t\t\tint flag)\n{\n\tunsigned long flags;\n\tint ret;\n\n\tspin_lock_irqsave(&lockres->l_lock, flags);\n\tret = lockres->l_flags & flag;\n\tspin_unlock_irqrestore(&lockres->l_lock, flags);\n\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"stackglue.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dcache.h\"\n#include \"alloc.h\"\n#include \"ocfs2_lockingver.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/quotaops.h>\n#include <linux/time.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/pagemap.h>\n#include <linux/kthread.h>\n#include <linux/mm.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic struct ocfs2_super *ocfs2_get_dentry_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_inode_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_file_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_qinfo_osb(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_set_meta_lvb(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_dentry_post_unlock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres);\nstatic void ocfs2_set_qinfo_lvb(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_downconvert_action(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_convert_action(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_attach_action(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_schedule_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_downconvert_on_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic int ocfs2_prepare_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\t        struct ocfs2_lock_res *lockres);\nstatic int ocfs2_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_process_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *lockres);\n\nstatic inline void ocfs2_wait_on_refreshing_lock(struct ocfs2_lock_res *lockres)\n\n{\n\twait_event(lockres->l_event,\n\t\t   !ocfs2_check_wait_flag(lockres, OCFS2_LOCK_REFRESHING));\n}"
  },
  {
    "function_name": "ocfs2_wait_on_busy_lock",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlmglue.c",
    "lines": "1276-1281",
    "snippet": "static inline void ocfs2_wait_on_busy_lock(struct ocfs2_lock_res *lockres)\n\n{\n\twait_event(lockres->l_event,\n\t\t   !ocfs2_check_wait_flag(lockres, OCFS2_LOCK_BUSY));\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"refcounttree.h\"",
      "#include \"quota.h\"",
      "#include \"uptodate.h\"",
      "#include \"super.h\"",
      "#include \"slot_map.h\"",
      "#include \"stackglue.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"heartbeat.h\"",
      "#include \"file.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"dcache.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2_lockingver.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/time.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/kthread.h>",
      "#include <linux/mm.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct ocfs2_super *ocfs2_get_dentry_osb(struct ocfs2_lock_res *lockres);",
      "static struct ocfs2_super *ocfs2_get_inode_osb(struct ocfs2_lock_res *lockres);",
      "static struct ocfs2_super *ocfs2_get_file_osb(struct ocfs2_lock_res *lockres);",
      "static struct ocfs2_super *ocfs2_get_qinfo_osb(struct ocfs2_lock_res *lockres);",
      "static void ocfs2_set_meta_lvb(struct ocfs2_lock_res *lockres);",
      "static void ocfs2_dentry_post_unlock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres);",
      "static void ocfs2_set_qinfo_lvb(struct ocfs2_lock_res *lockres);",
      "static inline void ocfs2_generic_handle_downconvert_action(struct ocfs2_lock_res *lockres);",
      "static inline void ocfs2_generic_handle_convert_action(struct ocfs2_lock_res *lockres);",
      "static inline void ocfs2_generic_handle_attach_action(struct ocfs2_lock_res *lockres);",
      "static void ocfs2_schedule_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);",
      "static void ocfs2_downconvert_on_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);",
      "static int ocfs2_prepare_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\t        struct ocfs2_lock_res *lockres);",
      "static int ocfs2_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres);",
      "static void ocfs2_process_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *lockres);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "wait_event",
          "args": [
            "lockres->l_event",
            "!ocfs2_check_wait_flag(lockres, OCFS2_LOCK_BUSY)"
          ],
          "line": 1279
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_check_wait_flag",
          "args": [
            "lockres",
            "OCFS2_LOCK_BUSY"
          ],
          "line": 1280
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_check_wait_flag",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlmglue.c",
          "lines": "1263-1274",
          "snippet": "static inline int ocfs2_check_wait_flag(struct ocfs2_lock_res *lockres,\n\t\t\t\t\tint flag)\n{\n\tunsigned long flags;\n\tint ret;\n\n\tspin_lock_irqsave(&lockres->l_lock, flags);\n\tret = lockres->l_flags & flag;\n\tspin_unlock_irqrestore(&lockres->l_lock, flags);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"refcounttree.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"stackglue.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dcache.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2_lockingver.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/time.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/kthread.h>",
            "#include <linux/mm.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct ocfs2_super *ocfs2_get_dentry_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_inode_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_file_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_qinfo_osb(struct ocfs2_lock_res *lockres);",
            "static void ocfs2_set_meta_lvb(struct ocfs2_lock_res *lockres);",
            "static void ocfs2_dentry_post_unlock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres);",
            "static void ocfs2_set_qinfo_lvb(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_downconvert_action(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_convert_action(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_attach_action(struct ocfs2_lock_res *lockres);",
            "static void ocfs2_schedule_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static void ocfs2_downconvert_on_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static int ocfs2_prepare_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\t        struct ocfs2_lock_res *lockres);",
            "static int ocfs2_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static void ocfs2_process_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *lockres);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"stackglue.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dcache.h\"\n#include \"alloc.h\"\n#include \"ocfs2_lockingver.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/quotaops.h>\n#include <linux/time.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/pagemap.h>\n#include <linux/kthread.h>\n#include <linux/mm.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic struct ocfs2_super *ocfs2_get_dentry_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_inode_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_file_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_qinfo_osb(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_set_meta_lvb(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_dentry_post_unlock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres);\nstatic void ocfs2_set_qinfo_lvb(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_downconvert_action(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_convert_action(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_attach_action(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_schedule_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_downconvert_on_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic int ocfs2_prepare_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\t        struct ocfs2_lock_res *lockres);\nstatic int ocfs2_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_process_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *lockres);\n\nstatic inline int ocfs2_check_wait_flag(struct ocfs2_lock_res *lockres,\n\t\t\t\t\tint flag)\n{\n\tunsigned long flags;\n\tint ret;\n\n\tspin_lock_irqsave(&lockres->l_lock, flags);\n\tret = lockres->l_flags & flag;\n\tspin_unlock_irqrestore(&lockres->l_lock, flags);\n\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"stackglue.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dcache.h\"\n#include \"alloc.h\"\n#include \"ocfs2_lockingver.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/quotaops.h>\n#include <linux/time.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/pagemap.h>\n#include <linux/kthread.h>\n#include <linux/mm.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic struct ocfs2_super *ocfs2_get_dentry_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_inode_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_file_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_qinfo_osb(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_set_meta_lvb(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_dentry_post_unlock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres);\nstatic void ocfs2_set_qinfo_lvb(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_downconvert_action(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_convert_action(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_attach_action(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_schedule_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_downconvert_on_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic int ocfs2_prepare_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\t        struct ocfs2_lock_res *lockres);\nstatic int ocfs2_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_process_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *lockres);\n\nstatic inline void ocfs2_wait_on_busy_lock(struct ocfs2_lock_res *lockres)\n\n{\n\twait_event(lockres->l_event,\n\t\t   !ocfs2_check_wait_flag(lockres, OCFS2_LOCK_BUSY));\n}"
  },
  {
    "function_name": "ocfs2_check_wait_flag",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlmglue.c",
    "lines": "1263-1274",
    "snippet": "static inline int ocfs2_check_wait_flag(struct ocfs2_lock_res *lockres,\n\t\t\t\t\tint flag)\n{\n\tunsigned long flags;\n\tint ret;\n\n\tspin_lock_irqsave(&lockres->l_lock, flags);\n\tret = lockres->l_flags & flag;\n\tspin_unlock_irqrestore(&lockres->l_lock, flags);\n\n\treturn ret;\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"refcounttree.h\"",
      "#include \"quota.h\"",
      "#include \"uptodate.h\"",
      "#include \"super.h\"",
      "#include \"slot_map.h\"",
      "#include \"stackglue.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"heartbeat.h\"",
      "#include \"file.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"dcache.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2_lockingver.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/time.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/kthread.h>",
      "#include <linux/mm.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct ocfs2_super *ocfs2_get_dentry_osb(struct ocfs2_lock_res *lockres);",
      "static struct ocfs2_super *ocfs2_get_inode_osb(struct ocfs2_lock_res *lockres);",
      "static struct ocfs2_super *ocfs2_get_file_osb(struct ocfs2_lock_res *lockres);",
      "static struct ocfs2_super *ocfs2_get_qinfo_osb(struct ocfs2_lock_res *lockres);",
      "static void ocfs2_set_meta_lvb(struct ocfs2_lock_res *lockres);",
      "static void ocfs2_dentry_post_unlock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres);",
      "static void ocfs2_set_qinfo_lvb(struct ocfs2_lock_res *lockres);",
      "static inline void ocfs2_generic_handle_downconvert_action(struct ocfs2_lock_res *lockres);",
      "static inline void ocfs2_generic_handle_convert_action(struct ocfs2_lock_res *lockres);",
      "static inline void ocfs2_generic_handle_attach_action(struct ocfs2_lock_res *lockres);",
      "static void ocfs2_schedule_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);",
      "static void ocfs2_downconvert_on_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);",
      "static int ocfs2_prepare_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\t        struct ocfs2_lock_res *lockres);",
      "static int ocfs2_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres);",
      "static void ocfs2_process_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *lockres);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock_irqrestore",
          "args": [
            "&lockres->l_lock",
            "flags"
          ],
          "line": 1271
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock_irqsave",
          "args": [
            "&lockres->l_lock",
            "flags"
          ],
          "line": 1269
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"stackglue.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dcache.h\"\n#include \"alloc.h\"\n#include \"ocfs2_lockingver.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/quotaops.h>\n#include <linux/time.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/pagemap.h>\n#include <linux/kthread.h>\n#include <linux/mm.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic struct ocfs2_super *ocfs2_get_dentry_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_inode_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_file_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_qinfo_osb(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_set_meta_lvb(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_dentry_post_unlock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres);\nstatic void ocfs2_set_qinfo_lvb(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_downconvert_action(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_convert_action(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_attach_action(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_schedule_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_downconvert_on_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic int ocfs2_prepare_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\t        struct ocfs2_lock_res *lockres);\nstatic int ocfs2_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_process_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *lockres);\n\nstatic inline int ocfs2_check_wait_flag(struct ocfs2_lock_res *lockres,\n\t\t\t\t\tint flag)\n{\n\tunsigned long flags;\n\tint ret;\n\n\tspin_lock_irqsave(&lockres->l_lock, flags);\n\tret = lockres->l_flags & flag;\n\tspin_unlock_irqrestore(&lockres->l_lock, flags);\n\n\treturn ret;\n}"
  },
  {
    "function_name": "ocfs2_lock_create",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlmglue.c",
    "lines": "1220-1261",
    "snippet": "static int ocfs2_lock_create(struct ocfs2_super *osb,\n\t\t\t     struct ocfs2_lock_res *lockres,\n\t\t\t     int level,\n\t\t\t     u32 dlm_flags)\n{\n\tint ret = 0;\n\tunsigned long flags;\n\tunsigned int gen;\n\n\tmlog(0, \"lock %s, level = %d, flags = %u\\n\", lockres->l_name, level,\n\t     dlm_flags);\n\n\tspin_lock_irqsave(&lockres->l_lock, flags);\n\tif ((lockres->l_flags & OCFS2_LOCK_ATTACHED) ||\n\t    (lockres->l_flags & OCFS2_LOCK_BUSY)) {\n\t\tspin_unlock_irqrestore(&lockres->l_lock, flags);\n\t\tgoto bail;\n\t}\n\n\tlockres->l_action = OCFS2_AST_ATTACH;\n\tlockres->l_requested = level;\n\tlockres_or_flags(lockres, OCFS2_LOCK_BUSY);\n\tgen = lockres_set_pending(lockres);\n\tspin_unlock_irqrestore(&lockres->l_lock, flags);\n\n\tret = ocfs2_dlm_lock(osb->cconn,\n\t\t\t     level,\n\t\t\t     &lockres->l_lksb,\n\t\t\t     dlm_flags,\n\t\t\t     lockres->l_name,\n\t\t\t     OCFS2_LOCK_ID_MAX_LEN - 1);\n\tlockres_clear_pending(lockres, gen, osb);\n\tif (ret) {\n\t\tocfs2_log_dlm_error(\"ocfs2_dlm_lock\", ret, lockres);\n\t\tocfs2_recover_from_dlm_error(lockres, 1);\n\t}\n\n\tmlog(0, \"lock %s, return from ocfs2_dlm_lock\\n\", lockres->l_name);\n\nbail:\n\treturn ret;\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"refcounttree.h\"",
      "#include \"quota.h\"",
      "#include \"uptodate.h\"",
      "#include \"super.h\"",
      "#include \"slot_map.h\"",
      "#include \"stackglue.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"heartbeat.h\"",
      "#include \"file.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"dcache.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2_lockingver.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/time.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/kthread.h>",
      "#include <linux/mm.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct ocfs2_super *ocfs2_get_dentry_osb(struct ocfs2_lock_res *lockres);",
      "static struct ocfs2_super *ocfs2_get_inode_osb(struct ocfs2_lock_res *lockres);",
      "static struct ocfs2_super *ocfs2_get_file_osb(struct ocfs2_lock_res *lockres);",
      "static struct ocfs2_super *ocfs2_get_qinfo_osb(struct ocfs2_lock_res *lockres);",
      "static void ocfs2_set_meta_lvb(struct ocfs2_lock_res *lockres);",
      "static void ocfs2_dentry_post_unlock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres);",
      "static void ocfs2_set_qinfo_lvb(struct ocfs2_lock_res *lockres);",
      "static int ocfs2_lock_create(struct ocfs2_super *osb,\n\t\t\t     struct ocfs2_lock_res *lockres,\n\t\t\t     int level,\n\t\t\t     u32 dlm_flags);",
      "static inline void ocfs2_generic_handle_downconvert_action(struct ocfs2_lock_res *lockres);",
      "static inline void ocfs2_generic_handle_convert_action(struct ocfs2_lock_res *lockres);",
      "static inline void ocfs2_generic_handle_attach_action(struct ocfs2_lock_res *lockres);",
      "static int ocfs2_generic_handle_bast(struct ocfs2_lock_res *lockres, int level);",
      "static void ocfs2_schedule_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);",
      "static void ocfs2_downconvert_on_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);",
      "static void ocfs2_drop_osb_locks(struct ocfs2_super *osb);",
      "static inline int ocfs2_highest_compat_lock_level(int level);",
      "static int ocfs2_prepare_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\t        struct ocfs2_lock_res *lockres);",
      "static int ocfs2_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres);",
      "static void ocfs2_process_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *lockres);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mlog",
          "args": [
            "0",
            "\"lock %s, return from ocfs2_dlm_lock\\n\"",
            "lockres->l_name"
          ],
          "line": 1257
        },
        "resolved": true,
        "details": {
          "function_name": "mlog_show",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/cluster/masklog.c",
          "lines": "107-113",
          "snippet": "static ssize_t mlog_show(struct kobject *obj, struct attribute *attr,\n\t\t\t char *buf)\n{\n\tstruct mlog_attribute *mlog_attr = to_mlog_attr(attr);\n\n\treturn mlog_mask_show(mlog_attr->mask, buf);\n}",
          "includes": [
            "#include \"masklog.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/string.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"masklog.h\"\n#include <asm/uaccess.h>\n#include <linux/string.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n\nstatic ssize_t mlog_show(struct kobject *obj, struct attribute *attr,\n\t\t\t char *buf)\n{\n\tstruct mlog_attribute *mlog_attr = to_mlog_attr(attr);\n\n\treturn mlog_mask_show(mlog_attr->mask, buf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_recover_from_dlm_error",
          "args": [
            "lockres",
            "1"
          ],
          "line": 1254
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_recover_from_dlm_error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlmglue.c",
          "lines": "1199-1214",
          "snippet": "static inline void ocfs2_recover_from_dlm_error(struct ocfs2_lock_res *lockres,\n\t\t\t\t\t\tint convert)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&lockres->l_lock, flags);\n\tlockres_clear_flags(lockres, OCFS2_LOCK_BUSY);\n\tlockres_clear_flags(lockres, OCFS2_LOCK_UPCONVERT_FINISHING);\n\tif (convert)\n\t\tlockres->l_action = OCFS2_AST_INVALID;\n\telse\n\t\tlockres->l_unlock_action = OCFS2_UNLOCK_INVALID;\n\tspin_unlock_irqrestore(&lockres->l_lock, flags);\n\n\twake_up(&lockres->l_event);\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"refcounttree.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"stackglue.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dcache.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2_lockingver.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/time.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/kthread.h>",
            "#include <linux/mm.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct ocfs2_super *ocfs2_get_dentry_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_inode_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_file_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_qinfo_osb(struct ocfs2_lock_res *lockres);",
            "static void ocfs2_set_meta_lvb(struct ocfs2_lock_res *lockres);",
            "static void ocfs2_dentry_post_unlock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres);",
            "static void ocfs2_set_qinfo_lvb(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_downconvert_action(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_convert_action(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_attach_action(struct ocfs2_lock_res *lockres);",
            "static void ocfs2_schedule_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_recover_from_dlm_error(struct ocfs2_lock_res *lockres,\n\t\t\t\t\t\tint convert);",
            "static void ocfs2_downconvert_on_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static int ocfs2_prepare_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\t        struct ocfs2_lock_res *lockres);",
            "static int ocfs2_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static void ocfs2_process_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *lockres);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"stackglue.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dcache.h\"\n#include \"alloc.h\"\n#include \"ocfs2_lockingver.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/quotaops.h>\n#include <linux/time.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/pagemap.h>\n#include <linux/kthread.h>\n#include <linux/mm.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic struct ocfs2_super *ocfs2_get_dentry_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_inode_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_file_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_qinfo_osb(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_set_meta_lvb(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_dentry_post_unlock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres);\nstatic void ocfs2_set_qinfo_lvb(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_downconvert_action(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_convert_action(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_attach_action(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_schedule_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_recover_from_dlm_error(struct ocfs2_lock_res *lockres,\n\t\t\t\t\t\tint convert);\nstatic void ocfs2_downconvert_on_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic int ocfs2_prepare_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\t        struct ocfs2_lock_res *lockres);\nstatic int ocfs2_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_process_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *lockres);\n\nstatic inline void ocfs2_recover_from_dlm_error(struct ocfs2_lock_res *lockres,\n\t\t\t\t\t\tint convert)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&lockres->l_lock, flags);\n\tlockres_clear_flags(lockres, OCFS2_LOCK_BUSY);\n\tlockres_clear_flags(lockres, OCFS2_LOCK_UPCONVERT_FINISHING);\n\tif (convert)\n\t\tlockres->l_action = OCFS2_AST_INVALID;\n\telse\n\t\tlockres->l_unlock_action = OCFS2_UNLOCK_INVALID;\n\tspin_unlock_irqrestore(&lockres->l_lock, flags);\n\n\twake_up(&lockres->l_event);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_log_dlm_error",
          "args": [
            "\"ocfs2_dlm_lock\"",
            "ret",
            "lockres"
          ],
          "line": 1253
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lockres_clear_pending",
          "args": [
            "lockres",
            "gen",
            "osb"
          ],
          "line": 1251
        },
        "resolved": true,
        "details": {
          "function_name": "lockres_clear_pending",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlmglue.c",
          "lines": "1004-1013",
          "snippet": "static void lockres_clear_pending(struct ocfs2_lock_res *lockres,\n\t\t\t\t  unsigned int generation,\n\t\t\t\t  struct ocfs2_super *osb)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&lockres->l_lock, flags);\n\t__lockres_clear_pending(lockres, generation, osb);\n\tspin_unlock_irqrestore(&lockres->l_lock, flags);\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"refcounttree.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"stackglue.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dcache.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2_lockingver.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/time.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/kthread.h>",
            "#include <linux/mm.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct ocfs2_super *ocfs2_get_dentry_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_inode_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_file_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_qinfo_osb(struct ocfs2_lock_res *lockres);",
            "static void ocfs2_set_meta_lvb(struct ocfs2_lock_res *lockres);",
            "static void ocfs2_dentry_post_unlock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres);",
            "static void ocfs2_set_qinfo_lvb(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_downconvert_action(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_convert_action(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_attach_action(struct ocfs2_lock_res *lockres);",
            "static void ocfs2_schedule_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static void ocfs2_downconvert_on_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static void ocfs2_drop_osb_locks(struct ocfs2_super *osb);",
            "static int ocfs2_downconvert_lock(struct ocfs2_super *osb,\n\t\t\t\t  struct ocfs2_lock_res *lockres,\n\t\t\t\t  int new_level,\n\t\t\t\t  int lvb,\n\t\t\t\t  unsigned int generation);",
            "static int ocfs2_prepare_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\t        struct ocfs2_lock_res *lockres);",
            "static int ocfs2_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static void ocfs2_process_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *lockres);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"stackglue.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dcache.h\"\n#include \"alloc.h\"\n#include \"ocfs2_lockingver.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/quotaops.h>\n#include <linux/time.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/pagemap.h>\n#include <linux/kthread.h>\n#include <linux/mm.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic struct ocfs2_super *ocfs2_get_dentry_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_inode_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_file_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_qinfo_osb(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_set_meta_lvb(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_dentry_post_unlock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres);\nstatic void ocfs2_set_qinfo_lvb(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_downconvert_action(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_convert_action(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_attach_action(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_schedule_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_downconvert_on_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_drop_osb_locks(struct ocfs2_super *osb);\nstatic int ocfs2_downconvert_lock(struct ocfs2_super *osb,\n\t\t\t\t  struct ocfs2_lock_res *lockres,\n\t\t\t\t  int new_level,\n\t\t\t\t  int lvb,\n\t\t\t\t  unsigned int generation);\nstatic int ocfs2_prepare_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\t        struct ocfs2_lock_res *lockres);\nstatic int ocfs2_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_process_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *lockres);\n\nstatic void lockres_clear_pending(struct ocfs2_lock_res *lockres,\n\t\t\t\t  unsigned int generation,\n\t\t\t\t  struct ocfs2_super *osb)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&lockres->l_lock, flags);\n\t__lockres_clear_pending(lockres, generation, osb);\n\tspin_unlock_irqrestore(&lockres->l_lock, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_dlm_lock",
          "args": [
            "osb->cconn",
            "level",
            "&lockres->l_lksb",
            "dlm_flags",
            "lockres->l_name",
            "OCFS2_LOCK_ID_MAX_LEN - 1"
          ],
          "line": 1245
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_dlm_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/stackglue.c",
          "lines": "241-254",
          "snippet": "int ocfs2_dlm_lock(struct ocfs2_cluster_connection *conn,\n\t\t   int mode,\n\t\t   struct ocfs2_dlm_lksb *lksb,\n\t\t   u32 flags,\n\t\t   void *name,\n\t\t   unsigned int namelen)\n{\n\tif (!lksb->lksb_conn)\n\t\tlksb->lksb_conn = conn;\n\telse\n\t\tBUG_ON(lksb->lksb_conn != conn);\n\treturn active_stack->sp_ops->dlm_lock(conn, mode, lksb, flags,\n\t\t\t\t\t      name, namelen);\n}",
          "includes": [
            "#include \"stackglue.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include <linux/sysctl.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/fs.h>",
            "#include <linux/kmod.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/list.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct ocfs2_stack_plugin *active_stack;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"stackglue.h\"\n#include \"ocfs2_fs.h\"\n#include <linux/sysctl.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/fs.h>\n#include <linux/kmod.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/spinlock.h>\n#include <linux/list.h>\n\nstatic struct ocfs2_stack_plugin *active_stack;\n\nint ocfs2_dlm_lock(struct ocfs2_cluster_connection *conn,\n\t\t   int mode,\n\t\t   struct ocfs2_dlm_lksb *lksb,\n\t\t   u32 flags,\n\t\t   void *name,\n\t\t   unsigned int namelen)\n{\n\tif (!lksb->lksb_conn)\n\t\tlksb->lksb_conn = conn;\n\telse\n\t\tBUG_ON(lksb->lksb_conn != conn);\n\treturn active_stack->sp_ops->dlm_lock(conn, mode, lksb, flags,\n\t\t\t\t\t      name, namelen);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock_irqrestore",
          "args": [
            "&lockres->l_lock",
            "flags"
          ],
          "line": 1243
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lockres_set_pending",
          "args": [
            "lockres"
          ],
          "line": 1242
        },
        "resolved": true,
        "details": {
          "function_name": "lockres_set_pending",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlmglue.c",
          "lines": "1015-1023",
          "snippet": "static unsigned int lockres_set_pending(struct ocfs2_lock_res *lockres)\n{\n\tassert_spin_locked(&lockres->l_lock);\n\tBUG_ON(!(lockres->l_flags & OCFS2_LOCK_BUSY));\n\n\tlockres_or_flags(lockres, OCFS2_LOCK_PENDING);\n\n\treturn lockres->l_pending_gen;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"refcounttree.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"stackglue.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dcache.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2_lockingver.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/time.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/kthread.h>",
            "#include <linux/mm.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct ocfs2_super *ocfs2_get_dentry_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_inode_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_file_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_qinfo_osb(struct ocfs2_lock_res *lockres);",
            "static void ocfs2_set_meta_lvb(struct ocfs2_lock_res *lockres);",
            "static void ocfs2_dentry_post_unlock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres);",
            "static void ocfs2_set_qinfo_lvb(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_downconvert_action(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_convert_action(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_attach_action(struct ocfs2_lock_res *lockres);",
            "static void ocfs2_schedule_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static void ocfs2_downconvert_on_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static int ocfs2_prepare_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\t        struct ocfs2_lock_res *lockres);",
            "static int ocfs2_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static void ocfs2_process_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *lockres);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"stackglue.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dcache.h\"\n#include \"alloc.h\"\n#include \"ocfs2_lockingver.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/quotaops.h>\n#include <linux/time.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/pagemap.h>\n#include <linux/kthread.h>\n#include <linux/mm.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic struct ocfs2_super *ocfs2_get_dentry_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_inode_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_file_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_qinfo_osb(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_set_meta_lvb(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_dentry_post_unlock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres);\nstatic void ocfs2_set_qinfo_lvb(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_downconvert_action(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_convert_action(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_attach_action(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_schedule_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_downconvert_on_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic int ocfs2_prepare_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\t        struct ocfs2_lock_res *lockres);\nstatic int ocfs2_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_process_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *lockres);\n\nstatic unsigned int lockres_set_pending(struct ocfs2_lock_res *lockres)\n{\n\tassert_spin_locked(&lockres->l_lock);\n\tBUG_ON(!(lockres->l_flags & OCFS2_LOCK_BUSY));\n\n\tlockres_or_flags(lockres, OCFS2_LOCK_PENDING);\n\n\treturn lockres->l_pending_gen;\n}"
        }
      },
      {
        "call_info": {
          "callee": "lockres_or_flags",
          "args": [
            "lockres",
            "OCFS2_LOCK_BUSY"
          ],
          "line": 1241
        },
        "resolved": true,
        "details": {
          "function_name": "lockres_or_flags",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlmglue.c",
          "lines": "819-822",
          "snippet": "static void lockres_or_flags(struct ocfs2_lock_res *lockres, unsigned long or)\n{\n\tlockres_set_flags(lockres, lockres->l_flags | or);\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"refcounttree.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"stackglue.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dcache.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2_lockingver.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/time.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/kthread.h>",
            "#include <linux/mm.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct ocfs2_super *ocfs2_get_dentry_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_inode_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_file_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_qinfo_osb(struct ocfs2_lock_res *lockres);",
            "static void ocfs2_set_meta_lvb(struct ocfs2_lock_res *lockres);",
            "static void ocfs2_dentry_post_unlock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres);",
            "static void ocfs2_set_qinfo_lvb(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_downconvert_action(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_convert_action(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_attach_action(struct ocfs2_lock_res *lockres);",
            "static void ocfs2_schedule_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static void ocfs2_downconvert_on_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static int ocfs2_prepare_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\t        struct ocfs2_lock_res *lockres);",
            "static int ocfs2_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static void ocfs2_process_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *lockres);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"stackglue.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dcache.h\"\n#include \"alloc.h\"\n#include \"ocfs2_lockingver.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/quotaops.h>\n#include <linux/time.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/pagemap.h>\n#include <linux/kthread.h>\n#include <linux/mm.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic struct ocfs2_super *ocfs2_get_dentry_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_inode_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_file_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_qinfo_osb(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_set_meta_lvb(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_dentry_post_unlock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres);\nstatic void ocfs2_set_qinfo_lvb(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_downconvert_action(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_convert_action(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_attach_action(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_schedule_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_downconvert_on_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic int ocfs2_prepare_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\t        struct ocfs2_lock_res *lockres);\nstatic int ocfs2_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_process_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *lockres);\n\nstatic void lockres_or_flags(struct ocfs2_lock_res *lockres, unsigned long or)\n{\n\tlockres_set_flags(lockres, lockres->l_flags | or);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock_irqrestore",
          "args": [
            "&lockres->l_lock",
            "flags"
          ],
          "line": 1235
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock_irqsave",
          "args": [
            "&lockres->l_lock",
            "flags"
          ],
          "line": 1232
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mlog",
          "args": [
            "0",
            "\"lock %s, level = %d, flags = %u\\n\"",
            "lockres->l_name",
            "level",
            "dlm_flags"
          ],
          "line": 1229
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"stackglue.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dcache.h\"\n#include \"alloc.h\"\n#include \"ocfs2_lockingver.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/quotaops.h>\n#include <linux/time.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/pagemap.h>\n#include <linux/kthread.h>\n#include <linux/mm.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic struct ocfs2_super *ocfs2_get_dentry_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_inode_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_file_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_qinfo_osb(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_set_meta_lvb(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_dentry_post_unlock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres);\nstatic void ocfs2_set_qinfo_lvb(struct ocfs2_lock_res *lockres);\nstatic int ocfs2_lock_create(struct ocfs2_super *osb,\n\t\t\t     struct ocfs2_lock_res *lockres,\n\t\t\t     int level,\n\t\t\t     u32 dlm_flags);\nstatic inline void ocfs2_generic_handle_downconvert_action(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_convert_action(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_attach_action(struct ocfs2_lock_res *lockres);\nstatic int ocfs2_generic_handle_bast(struct ocfs2_lock_res *lockres, int level);\nstatic void ocfs2_schedule_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_downconvert_on_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_drop_osb_locks(struct ocfs2_super *osb);\nstatic inline int ocfs2_highest_compat_lock_level(int level);\nstatic int ocfs2_prepare_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\t        struct ocfs2_lock_res *lockres);\nstatic int ocfs2_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_process_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *lockres);\n\nstatic int ocfs2_lock_create(struct ocfs2_super *osb,\n\t\t\t     struct ocfs2_lock_res *lockres,\n\t\t\t     int level,\n\t\t\t     u32 dlm_flags)\n{\n\tint ret = 0;\n\tunsigned long flags;\n\tunsigned int gen;\n\n\tmlog(0, \"lock %s, level = %d, flags = %u\\n\", lockres->l_name, level,\n\t     dlm_flags);\n\n\tspin_lock_irqsave(&lockres->l_lock, flags);\n\tif ((lockres->l_flags & OCFS2_LOCK_ATTACHED) ||\n\t    (lockres->l_flags & OCFS2_LOCK_BUSY)) {\n\t\tspin_unlock_irqrestore(&lockres->l_lock, flags);\n\t\tgoto bail;\n\t}\n\n\tlockres->l_action = OCFS2_AST_ATTACH;\n\tlockres->l_requested = level;\n\tlockres_or_flags(lockres, OCFS2_LOCK_BUSY);\n\tgen = lockres_set_pending(lockres);\n\tspin_unlock_irqrestore(&lockres->l_lock, flags);\n\n\tret = ocfs2_dlm_lock(osb->cconn,\n\t\t\t     level,\n\t\t\t     &lockres->l_lksb,\n\t\t\t     dlm_flags,\n\t\t\t     lockres->l_name,\n\t\t\t     OCFS2_LOCK_ID_MAX_LEN - 1);\n\tlockres_clear_pending(lockres, gen, osb);\n\tif (ret) {\n\t\tocfs2_log_dlm_error(\"ocfs2_dlm_lock\", ret, lockres);\n\t\tocfs2_recover_from_dlm_error(lockres, 1);\n\t}\n\n\tmlog(0, \"lock %s, return from ocfs2_dlm_lock\\n\", lockres->l_name);\n\nbail:\n\treturn ret;\n}"
  },
  {
    "function_name": "ocfs2_recover_from_dlm_error",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlmglue.c",
    "lines": "1199-1214",
    "snippet": "static inline void ocfs2_recover_from_dlm_error(struct ocfs2_lock_res *lockres,\n\t\t\t\t\t\tint convert)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&lockres->l_lock, flags);\n\tlockres_clear_flags(lockres, OCFS2_LOCK_BUSY);\n\tlockres_clear_flags(lockres, OCFS2_LOCK_UPCONVERT_FINISHING);\n\tif (convert)\n\t\tlockres->l_action = OCFS2_AST_INVALID;\n\telse\n\t\tlockres->l_unlock_action = OCFS2_UNLOCK_INVALID;\n\tspin_unlock_irqrestore(&lockres->l_lock, flags);\n\n\twake_up(&lockres->l_event);\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"refcounttree.h\"",
      "#include \"quota.h\"",
      "#include \"uptodate.h\"",
      "#include \"super.h\"",
      "#include \"slot_map.h\"",
      "#include \"stackglue.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"heartbeat.h\"",
      "#include \"file.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"dcache.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2_lockingver.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/time.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/kthread.h>",
      "#include <linux/mm.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct ocfs2_super *ocfs2_get_dentry_osb(struct ocfs2_lock_res *lockres);",
      "static struct ocfs2_super *ocfs2_get_inode_osb(struct ocfs2_lock_res *lockres);",
      "static struct ocfs2_super *ocfs2_get_file_osb(struct ocfs2_lock_res *lockres);",
      "static struct ocfs2_super *ocfs2_get_qinfo_osb(struct ocfs2_lock_res *lockres);",
      "static void ocfs2_set_meta_lvb(struct ocfs2_lock_res *lockres);",
      "static void ocfs2_dentry_post_unlock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres);",
      "static void ocfs2_set_qinfo_lvb(struct ocfs2_lock_res *lockres);",
      "static inline void ocfs2_generic_handle_downconvert_action(struct ocfs2_lock_res *lockres);",
      "static inline void ocfs2_generic_handle_convert_action(struct ocfs2_lock_res *lockres);",
      "static inline void ocfs2_generic_handle_attach_action(struct ocfs2_lock_res *lockres);",
      "static void ocfs2_schedule_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);",
      "static inline void ocfs2_recover_from_dlm_error(struct ocfs2_lock_res *lockres,\n\t\t\t\t\t\tint convert);",
      "static void ocfs2_downconvert_on_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);",
      "static int ocfs2_prepare_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\t        struct ocfs2_lock_res *lockres);",
      "static int ocfs2_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres);",
      "static void ocfs2_process_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *lockres);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "wake_up",
          "args": [
            "&lockres->l_event"
          ],
          "line": 1213
        },
        "resolved": true,
        "details": {
          "function_name": "locks_wake_up_blocks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/locks.c",
          "lines": "656-681",
          "snippet": "static void locks_wake_up_blocks(struct file_lock *blocker)\n{\n\t/*\n\t * Avoid taking global lock if list is empty. This is safe since new\n\t * blocked requests are only added to the list under the flc_lock, and\n\t * the flc_lock is always held here. Note that removal from the fl_block\n\t * list does not require the flc_lock, so we must recheck list_empty()\n\t * after acquiring the blocked_lock_lock.\n\t */\n\tif (list_empty(&blocker->fl_block))\n\t\treturn;\n\n\tspin_lock(&blocked_lock_lock);\n\twhile (!list_empty(&blocker->fl_block)) {\n\t\tstruct file_lock *waiter;\n\n\t\twaiter = list_first_entry(&blocker->fl_block,\n\t\t\t\tstruct file_lock, fl_block);\n\t\t__locks_delete_block(waiter);\n\t\tif (waiter->fl_lmops && waiter->fl_lmops->lm_notify)\n\t\t\twaiter->fl_lmops->lm_notify(waiter);\n\t\telse\n\t\t\twake_up(&waiter->fl_wait);\n\t}\n\tspin_unlock(&blocked_lock_lock);\n}",
          "includes": [
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <asm/uaccess.h>",
            "#include <trace/events/filelock.h>",
            "#include <linux/lglock.h>",
            "#include <linux/percpu.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/time.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/slab.h>",
            "#include <linux/security.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_SPINLOCK(blocked_lock_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <asm/uaccess.h>\n#include <trace/events/filelock.h>\n#include <linux/lglock.h>\n#include <linux/percpu.h>\n#include <linux/hashtable.h>\n#include <linux/pid_namespace.h>\n#include <linux/rcupdate.h>\n#include <linux/time.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n\nstatic DEFINE_SPINLOCK(blocked_lock_lock);\n\nstatic void locks_wake_up_blocks(struct file_lock *blocker)\n{\n\t/*\n\t * Avoid taking global lock if list is empty. This is safe since new\n\t * blocked requests are only added to the list under the flc_lock, and\n\t * the flc_lock is always held here. Note that removal from the fl_block\n\t * list does not require the flc_lock, so we must recheck list_empty()\n\t * after acquiring the blocked_lock_lock.\n\t */\n\tif (list_empty(&blocker->fl_block))\n\t\treturn;\n\n\tspin_lock(&blocked_lock_lock);\n\twhile (!list_empty(&blocker->fl_block)) {\n\t\tstruct file_lock *waiter;\n\n\t\twaiter = list_first_entry(&blocker->fl_block,\n\t\t\t\tstruct file_lock, fl_block);\n\t\t__locks_delete_block(waiter);\n\t\tif (waiter->fl_lmops && waiter->fl_lmops->lm_notify)\n\t\t\twaiter->fl_lmops->lm_notify(waiter);\n\t\telse\n\t\t\twake_up(&waiter->fl_wait);\n\t}\n\tspin_unlock(&blocked_lock_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock_irqrestore",
          "args": [
            "&lockres->l_lock",
            "flags"
          ],
          "line": 1211
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lockres_clear_flags",
          "args": [
            "lockres",
            "OCFS2_LOCK_UPCONVERT_FINISHING"
          ],
          "line": 1206
        },
        "resolved": true,
        "details": {
          "function_name": "lockres_clear_flags",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlmglue.c",
          "lines": "823-827",
          "snippet": "static void lockres_clear_flags(struct ocfs2_lock_res *lockres,\n\t\t\t\tunsigned long clear)\n{\n\tlockres_set_flags(lockres, lockres->l_flags & ~clear);\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"refcounttree.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"stackglue.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dcache.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2_lockingver.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/time.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/kthread.h>",
            "#include <linux/mm.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct ocfs2_super *ocfs2_get_dentry_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_inode_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_file_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_qinfo_osb(struct ocfs2_lock_res *lockres);",
            "static void ocfs2_set_meta_lvb(struct ocfs2_lock_res *lockres);",
            "static void ocfs2_dentry_post_unlock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres);",
            "static void ocfs2_set_qinfo_lvb(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_downconvert_action(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_convert_action(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_attach_action(struct ocfs2_lock_res *lockres);",
            "static void ocfs2_schedule_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static void ocfs2_downconvert_on_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static int ocfs2_prepare_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\t        struct ocfs2_lock_res *lockres);",
            "static int ocfs2_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static void ocfs2_process_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *lockres);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"stackglue.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dcache.h\"\n#include \"alloc.h\"\n#include \"ocfs2_lockingver.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/quotaops.h>\n#include <linux/time.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/pagemap.h>\n#include <linux/kthread.h>\n#include <linux/mm.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic struct ocfs2_super *ocfs2_get_dentry_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_inode_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_file_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_qinfo_osb(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_set_meta_lvb(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_dentry_post_unlock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres);\nstatic void ocfs2_set_qinfo_lvb(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_downconvert_action(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_convert_action(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_attach_action(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_schedule_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_downconvert_on_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic int ocfs2_prepare_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\t        struct ocfs2_lock_res *lockres);\nstatic int ocfs2_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_process_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *lockres);\n\nstatic void lockres_clear_flags(struct ocfs2_lock_res *lockres,\n\t\t\t\tunsigned long clear)\n{\n\tlockres_set_flags(lockres, lockres->l_flags & ~clear);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock_irqsave",
          "args": [
            "&lockres->l_lock",
            "flags"
          ],
          "line": 1204
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"stackglue.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dcache.h\"\n#include \"alloc.h\"\n#include \"ocfs2_lockingver.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/quotaops.h>\n#include <linux/time.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/pagemap.h>\n#include <linux/kthread.h>\n#include <linux/mm.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic struct ocfs2_super *ocfs2_get_dentry_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_inode_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_file_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_qinfo_osb(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_set_meta_lvb(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_dentry_post_unlock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres);\nstatic void ocfs2_set_qinfo_lvb(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_downconvert_action(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_convert_action(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_attach_action(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_schedule_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_recover_from_dlm_error(struct ocfs2_lock_res *lockres,\n\t\t\t\t\t\tint convert);\nstatic void ocfs2_downconvert_on_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic int ocfs2_prepare_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\t        struct ocfs2_lock_res *lockres);\nstatic int ocfs2_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_process_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *lockres);\n\nstatic inline void ocfs2_recover_from_dlm_error(struct ocfs2_lock_res *lockres,\n\t\t\t\t\t\tint convert)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&lockres->l_lock, flags);\n\tlockres_clear_flags(lockres, OCFS2_LOCK_BUSY);\n\tlockres_clear_flags(lockres, OCFS2_LOCK_UPCONVERT_FINISHING);\n\tif (convert)\n\t\tlockres->l_action = OCFS2_AST_INVALID;\n\telse\n\t\tlockres->l_unlock_action = OCFS2_UNLOCK_INVALID;\n\tspin_unlock_irqrestore(&lockres->l_lock, flags);\n\n\twake_up(&lockres->l_event);\n}"
  },
  {
    "function_name": "ocfs2_set_locking_protocol",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlmglue.c",
    "lines": "1194-1197",
    "snippet": "void ocfs2_set_locking_protocol(void)\n{\n\tocfs2_stack_glue_set_max_proto_version(&lproto.lp_max_version);\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"refcounttree.h\"",
      "#include \"quota.h\"",
      "#include \"uptodate.h\"",
      "#include \"super.h\"",
      "#include \"slot_map.h\"",
      "#include \"stackglue.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"heartbeat.h\"",
      "#include \"file.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"dcache.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2_lockingver.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/time.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/kthread.h>",
      "#include <linux/mm.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct ocfs2_locking_protocol lproto = {\n\t.lp_max_version = {\n\t\t.pv_major = OCFS2_LOCKING_PROTOCOL_MAJOR,\n\t\t.pv_minor = OCFS2_LOCKING_PROTOCOL_MINOR,\n\t},\n\t.lp_lock_ast\t\t= ocfs2_locking_ast,\n\t.lp_blocking_ast\t= ocfs2_blocking_ast,\n\t.lp_unlock_ast\t\t= ocfs2_unlock_ast,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ocfs2_stack_glue_set_max_proto_version",
          "args": [
            "&lproto.lp_max_version"
          ],
          "line": 1196
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_stack_glue_set_max_proto_version",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/stackglue.c",
          "lines": "216-231",
          "snippet": "void ocfs2_stack_glue_set_max_proto_version(struct ocfs2_protocol_version *max_proto)\n{\n\tstruct ocfs2_stack_plugin *p;\n\n\tspin_lock(&ocfs2_stack_lock);\n\tif (memcmp(max_proto, &locking_max_version,\n\t\t   sizeof(struct ocfs2_protocol_version))) {\n\t\tBUG_ON(locking_max_version.pv_major != 0);\n\n\t\tlocking_max_version = *max_proto;\n\t\tlist_for_each_entry(p, &ocfs2_stack_list, sp_list) {\n\t\t\tp->sp_max_proto = locking_max_version;\n\t\t}\n\t}\n\tspin_unlock(&ocfs2_stack_lock);\n}",
          "includes": [
            "#include \"stackglue.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include <linux/sysctl.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/fs.h>",
            "#include <linux/kmod.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/list.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct ocfs2_protocol_version locking_max_version;",
            "static DEFINE_SPINLOCK(ocfs2_stack_lock);",
            "static LIST_HEAD(ocfs2_stack_list);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"stackglue.h\"\n#include \"ocfs2_fs.h\"\n#include <linux/sysctl.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/fs.h>\n#include <linux/kmod.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/spinlock.h>\n#include <linux/list.h>\n\nstatic struct ocfs2_protocol_version locking_max_version;\nstatic DEFINE_SPINLOCK(ocfs2_stack_lock);\nstatic LIST_HEAD(ocfs2_stack_list);\n\nvoid ocfs2_stack_glue_set_max_proto_version(struct ocfs2_protocol_version *max_proto)\n{\n\tstruct ocfs2_stack_plugin *p;\n\n\tspin_lock(&ocfs2_stack_lock);\n\tif (memcmp(max_proto, &locking_max_version,\n\t\t   sizeof(struct ocfs2_protocol_version))) {\n\t\tBUG_ON(locking_max_version.pv_major != 0);\n\n\t\tlocking_max_version = *max_proto;\n\t\tlist_for_each_entry(p, &ocfs2_stack_list, sp_list) {\n\t\t\tp->sp_max_proto = locking_max_version;\n\t\t}\n\t}\n\tspin_unlock(&ocfs2_stack_lock);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"stackglue.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dcache.h\"\n#include \"alloc.h\"\n#include \"ocfs2_lockingver.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/quotaops.h>\n#include <linux/time.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/pagemap.h>\n#include <linux/kthread.h>\n#include <linux/mm.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic struct ocfs2_locking_protocol lproto = {\n\t.lp_max_version = {\n\t\t.pv_major = OCFS2_LOCKING_PROTOCOL_MAJOR,\n\t\t.pv_minor = OCFS2_LOCKING_PROTOCOL_MINOR,\n\t},\n\t.lp_lock_ast\t\t= ocfs2_locking_ast,\n\t.lp_blocking_ast\t= ocfs2_blocking_ast,\n\t.lp_unlock_ast\t\t= ocfs2_unlock_ast,\n};\n\nvoid ocfs2_set_locking_protocol(void)\n{\n\tocfs2_stack_glue_set_max_proto_version(&lproto.lp_max_version);\n}"
  },
  {
    "function_name": "ocfs2_unlock_ast",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlmglue.c",
    "lines": "1122-1159",
    "snippet": "static void ocfs2_unlock_ast(struct ocfs2_dlm_lksb *lksb, int error)\n{\n\tstruct ocfs2_lock_res *lockres = ocfs2_lksb_to_lock_res(lksb);\n\tunsigned long flags;\n\n\tmlog(ML_BASTS, \"UNLOCK AST fired for lockres %s, action = %d\\n\",\n\t     lockres->l_name, lockres->l_unlock_action);\n\n\tspin_lock_irqsave(&lockres->l_lock, flags);\n\tif (error) {\n\t\tmlog(ML_ERROR, \"Dlm passes error %d for lock %s, \"\n\t\t     \"unlock_action %d\\n\", error, lockres->l_name,\n\t\t     lockres->l_unlock_action);\n\t\tspin_unlock_irqrestore(&lockres->l_lock, flags);\n\t\treturn;\n\t}\n\n\tswitch(lockres->l_unlock_action) {\n\tcase OCFS2_UNLOCK_CANCEL_CONVERT:\n\t\tmlog(0, \"Cancel convert success for %s\\n\", lockres->l_name);\n\t\tlockres->l_action = OCFS2_AST_INVALID;\n\t\t/* Downconvert thread may have requeued this lock, we\n\t\t * need to wake it. */\n\t\tif (lockres->l_flags & OCFS2_LOCK_BLOCKED)\n\t\t\tocfs2_wake_downconvert_thread(ocfs2_get_lockres_osb(lockres));\n\t\tbreak;\n\tcase OCFS2_UNLOCK_DROP_LOCK:\n\t\tlockres->l_level = DLM_LOCK_IV;\n\t\tbreak;\n\tdefault:\n\t\tBUG();\n\t}\n\n\tlockres_clear_flags(lockres, OCFS2_LOCK_BUSY);\n\tlockres->l_unlock_action = OCFS2_UNLOCK_INVALID;\n\twake_up(&lockres->l_event);\n\tspin_unlock_irqrestore(&lockres->l_lock, flags);\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"refcounttree.h\"",
      "#include \"quota.h\"",
      "#include \"uptodate.h\"",
      "#include \"super.h\"",
      "#include \"slot_map.h\"",
      "#include \"stackglue.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"heartbeat.h\"",
      "#include \"file.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"dcache.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2_lockingver.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/time.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/kthread.h>",
      "#include <linux/mm.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct ocfs2_super *ocfs2_get_dentry_osb(struct ocfs2_lock_res *lockres);",
      "static struct ocfs2_super *ocfs2_get_inode_osb(struct ocfs2_lock_res *lockres);",
      "static struct ocfs2_super *ocfs2_get_file_osb(struct ocfs2_lock_res *lockres);",
      "static struct ocfs2_super *ocfs2_get_qinfo_osb(struct ocfs2_lock_res *lockres);",
      "static void ocfs2_set_meta_lvb(struct ocfs2_lock_res *lockres);",
      "static void ocfs2_dentry_post_unlock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres);",
      "static void ocfs2_set_qinfo_lvb(struct ocfs2_lock_res *lockres);",
      "static inline void ocfs2_generic_handle_downconvert_action(struct ocfs2_lock_res *lockres);",
      "static inline void ocfs2_generic_handle_convert_action(struct ocfs2_lock_res *lockres);",
      "static inline void ocfs2_generic_handle_attach_action(struct ocfs2_lock_res *lockres);",
      "static void ocfs2_schedule_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);",
      "static inline void ocfs2_recover_from_dlm_error(struct ocfs2_lock_res *lockres,\n\t\t\t\t\t\tint convert);",
      "static void ocfs2_downconvert_on_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);",
      "static int ocfs2_prepare_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\t        struct ocfs2_lock_res *lockres);",
      "static int ocfs2_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres);",
      "static void ocfs2_process_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *lockres);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock_irqrestore",
          "args": [
            "&lockres->l_lock",
            "flags"
          ],
          "line": 1158
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wake_up",
          "args": [
            "&lockres->l_event"
          ],
          "line": 1157
        },
        "resolved": true,
        "details": {
          "function_name": "locks_wake_up_blocks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/locks.c",
          "lines": "656-681",
          "snippet": "static void locks_wake_up_blocks(struct file_lock *blocker)\n{\n\t/*\n\t * Avoid taking global lock if list is empty. This is safe since new\n\t * blocked requests are only added to the list under the flc_lock, and\n\t * the flc_lock is always held here. Note that removal from the fl_block\n\t * list does not require the flc_lock, so we must recheck list_empty()\n\t * after acquiring the blocked_lock_lock.\n\t */\n\tif (list_empty(&blocker->fl_block))\n\t\treturn;\n\n\tspin_lock(&blocked_lock_lock);\n\twhile (!list_empty(&blocker->fl_block)) {\n\t\tstruct file_lock *waiter;\n\n\t\twaiter = list_first_entry(&blocker->fl_block,\n\t\t\t\tstruct file_lock, fl_block);\n\t\t__locks_delete_block(waiter);\n\t\tif (waiter->fl_lmops && waiter->fl_lmops->lm_notify)\n\t\t\twaiter->fl_lmops->lm_notify(waiter);\n\t\telse\n\t\t\twake_up(&waiter->fl_wait);\n\t}\n\tspin_unlock(&blocked_lock_lock);\n}",
          "includes": [
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <asm/uaccess.h>",
            "#include <trace/events/filelock.h>",
            "#include <linux/lglock.h>",
            "#include <linux/percpu.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/time.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/slab.h>",
            "#include <linux/security.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_SPINLOCK(blocked_lock_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <asm/uaccess.h>\n#include <trace/events/filelock.h>\n#include <linux/lglock.h>\n#include <linux/percpu.h>\n#include <linux/hashtable.h>\n#include <linux/pid_namespace.h>\n#include <linux/rcupdate.h>\n#include <linux/time.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n\nstatic DEFINE_SPINLOCK(blocked_lock_lock);\n\nstatic void locks_wake_up_blocks(struct file_lock *blocker)\n{\n\t/*\n\t * Avoid taking global lock if list is empty. This is safe since new\n\t * blocked requests are only added to the list under the flc_lock, and\n\t * the flc_lock is always held here. Note that removal from the fl_block\n\t * list does not require the flc_lock, so we must recheck list_empty()\n\t * after acquiring the blocked_lock_lock.\n\t */\n\tif (list_empty(&blocker->fl_block))\n\t\treturn;\n\n\tspin_lock(&blocked_lock_lock);\n\twhile (!list_empty(&blocker->fl_block)) {\n\t\tstruct file_lock *waiter;\n\n\t\twaiter = list_first_entry(&blocker->fl_block,\n\t\t\t\tstruct file_lock, fl_block);\n\t\t__locks_delete_block(waiter);\n\t\tif (waiter->fl_lmops && waiter->fl_lmops->lm_notify)\n\t\t\twaiter->fl_lmops->lm_notify(waiter);\n\t\telse\n\t\t\twake_up(&waiter->fl_wait);\n\t}\n\tspin_unlock(&blocked_lock_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "lockres_clear_flags",
          "args": [
            "lockres",
            "OCFS2_LOCK_BUSY"
          ],
          "line": 1155
        },
        "resolved": true,
        "details": {
          "function_name": "lockres_clear_flags",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlmglue.c",
          "lines": "823-827",
          "snippet": "static void lockres_clear_flags(struct ocfs2_lock_res *lockres,\n\t\t\t\tunsigned long clear)\n{\n\tlockres_set_flags(lockres, lockres->l_flags & ~clear);\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"refcounttree.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"stackglue.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dcache.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2_lockingver.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/time.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/kthread.h>",
            "#include <linux/mm.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct ocfs2_super *ocfs2_get_dentry_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_inode_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_file_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_qinfo_osb(struct ocfs2_lock_res *lockres);",
            "static void ocfs2_set_meta_lvb(struct ocfs2_lock_res *lockres);",
            "static void ocfs2_dentry_post_unlock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres);",
            "static void ocfs2_set_qinfo_lvb(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_downconvert_action(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_convert_action(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_attach_action(struct ocfs2_lock_res *lockres);",
            "static void ocfs2_schedule_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static void ocfs2_downconvert_on_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static int ocfs2_prepare_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\t        struct ocfs2_lock_res *lockres);",
            "static int ocfs2_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static void ocfs2_process_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *lockres);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"stackglue.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dcache.h\"\n#include \"alloc.h\"\n#include \"ocfs2_lockingver.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/quotaops.h>\n#include <linux/time.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/pagemap.h>\n#include <linux/kthread.h>\n#include <linux/mm.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic struct ocfs2_super *ocfs2_get_dentry_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_inode_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_file_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_qinfo_osb(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_set_meta_lvb(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_dentry_post_unlock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres);\nstatic void ocfs2_set_qinfo_lvb(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_downconvert_action(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_convert_action(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_attach_action(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_schedule_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_downconvert_on_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic int ocfs2_prepare_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\t        struct ocfs2_lock_res *lockres);\nstatic int ocfs2_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_process_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *lockres);\n\nstatic void lockres_clear_flags(struct ocfs2_lock_res *lockres,\n\t\t\t\tunsigned long clear)\n{\n\tlockres_set_flags(lockres, lockres->l_flags & ~clear);\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG",
          "args": [],
          "line": 1152
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_wake_downconvert_thread",
          "args": [
            "ocfs2_get_lockres_osb(lockres)"
          ],
          "line": 1146
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_wake_downconvert_thread",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlmglue.c",
          "lines": "4091-4101",
          "snippet": "void ocfs2_wake_downconvert_thread(struct ocfs2_super *osb)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&osb->dc_task_lock, flags);\n\t/* make sure the voting thread gets a swipe at whatever changes\n\t * the caller may have made to the voting state */\n\tosb->dc_wake_sequence++;\n\tspin_unlock_irqrestore(&osb->dc_task_lock, flags);\n\twake_up(&osb->dc_event);\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"refcounttree.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"stackglue.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dcache.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2_lockingver.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/time.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/kthread.h>",
            "#include <linux/mm.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void ocfs2_drop_osb_locks(struct ocfs2_super *osb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"stackglue.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dcache.h\"\n#include \"alloc.h\"\n#include \"ocfs2_lockingver.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/quotaops.h>\n#include <linux/time.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/pagemap.h>\n#include <linux/kthread.h>\n#include <linux/mm.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic void ocfs2_drop_osb_locks(struct ocfs2_super *osb);\n\nvoid ocfs2_wake_downconvert_thread(struct ocfs2_super *osb)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&osb->dc_task_lock, flags);\n\t/* make sure the voting thread gets a swipe at whatever changes\n\t * the caller may have made to the voting state */\n\tosb->dc_wake_sequence++;\n\tspin_unlock_irqrestore(&osb->dc_task_lock, flags);\n\twake_up(&osb->dc_event);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_get_lockres_osb",
          "args": [
            "lockres"
          ],
          "line": 1146
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_get_lockres_osb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlmglue.c",
          "lines": "332-338",
          "snippet": "static inline struct ocfs2_super *ocfs2_get_lockres_osb(struct ocfs2_lock_res *lockres)\n{\n\tif (lockres->l_ops->get_osb)\n\t\treturn lockres->l_ops->get_osb(lockres);\n\n\treturn (struct ocfs2_super *)lockres->l_priv;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"refcounttree.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"stackglue.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dcache.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2_lockingver.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/time.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/kthread.h>",
            "#include <linux/mm.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct ocfs2_super *ocfs2_get_dentry_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_inode_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_file_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_qinfo_osb(struct ocfs2_lock_res *lockres);",
            "static void ocfs2_set_meta_lvb(struct ocfs2_lock_res *lockres);",
            "static void ocfs2_dentry_post_unlock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres);",
            "static void ocfs2_set_qinfo_lvb(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_downconvert_action(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_convert_action(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_attach_action(struct ocfs2_lock_res *lockres);",
            "static void ocfs2_schedule_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static void ocfs2_downconvert_on_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static int ocfs2_prepare_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\t        struct ocfs2_lock_res *lockres);",
            "static int ocfs2_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static void ocfs2_process_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *lockres);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"stackglue.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dcache.h\"\n#include \"alloc.h\"\n#include \"ocfs2_lockingver.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/quotaops.h>\n#include <linux/time.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/pagemap.h>\n#include <linux/kthread.h>\n#include <linux/mm.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic struct ocfs2_super *ocfs2_get_dentry_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_inode_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_file_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_qinfo_osb(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_set_meta_lvb(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_dentry_post_unlock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres);\nstatic void ocfs2_set_qinfo_lvb(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_downconvert_action(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_convert_action(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_attach_action(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_schedule_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_downconvert_on_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic int ocfs2_prepare_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\t        struct ocfs2_lock_res *lockres);\nstatic int ocfs2_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_process_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *lockres);\n\nstatic inline struct ocfs2_super *ocfs2_get_lockres_osb(struct ocfs2_lock_res *lockres)\n{\n\tif (lockres->l_ops->get_osb)\n\t\treturn lockres->l_ops->get_osb(lockres);\n\n\treturn (struct ocfs2_super *)lockres->l_priv;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog",
          "args": [
            "0",
            "\"Cancel convert success for %s\\n\"",
            "lockres->l_name"
          ],
          "line": 1141
        },
        "resolved": true,
        "details": {
          "function_name": "mlog_show",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/cluster/masklog.c",
          "lines": "107-113",
          "snippet": "static ssize_t mlog_show(struct kobject *obj, struct attribute *attr,\n\t\t\t char *buf)\n{\n\tstruct mlog_attribute *mlog_attr = to_mlog_attr(attr);\n\n\treturn mlog_mask_show(mlog_attr->mask, buf);\n}",
          "includes": [
            "#include \"masklog.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/string.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"masklog.h\"\n#include <asm/uaccess.h>\n#include <linux/string.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n\nstatic ssize_t mlog_show(struct kobject *obj, struct attribute *attr,\n\t\t\t char *buf)\n{\n\tstruct mlog_attribute *mlog_attr = to_mlog_attr(attr);\n\n\treturn mlog_mask_show(mlog_attr->mask, buf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock_irqrestore",
          "args": [
            "&lockres->l_lock",
            "flags"
          ],
          "line": 1135
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mlog",
          "args": [
            "ML_ERROR",
            "\"Dlm passes error %d for lock %s, \"\n\t\t     \"unlock_action %d\\n\"",
            "error",
            "lockres->l_name",
            "lockres->l_unlock_action"
          ],
          "line": 1132
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock_irqsave",
          "args": [
            "&lockres->l_lock",
            "flags"
          ],
          "line": 1130
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mlog",
          "args": [
            "ML_BASTS",
            "\"UNLOCK AST fired for lockres %s, action = %d\\n\"",
            "lockres->l_name",
            "lockres->l_unlock_action"
          ],
          "line": 1127
        },
        "resolved": true,
        "details": {
          "function_name": "mlog_store",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/cluster/masklog.c",
          "lines": "115-121",
          "snippet": "static ssize_t mlog_store(struct kobject *obj, struct attribute *attr,\n\t\t\t  const char *buf, size_t count)\n{\n\tstruct mlog_attribute *mlog_attr = to_mlog_attr(attr);\n\n\treturn mlog_mask_store(mlog_attr->mask, buf, count);\n}",
          "includes": [
            "#include \"masklog.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/string.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"masklog.h\"\n#include <asm/uaccess.h>\n#include <linux/string.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n\nstatic ssize_t mlog_store(struct kobject *obj, struct attribute *attr,\n\t\t\t  const char *buf, size_t count)\n{\n\tstruct mlog_attribute *mlog_attr = to_mlog_attr(attr);\n\n\treturn mlog_mask_store(mlog_attr->mask, buf, count);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_lksb_to_lock_res",
          "args": [
            "lksb"
          ],
          "line": 1124
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_lksb_to_lock_res",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlmglue.c",
          "lines": "300-303",
          "snippet": "static inline struct ocfs2_lock_res *ocfs2_lksb_to_lock_res(struct ocfs2_dlm_lksb *lksb)\n{\n\treturn container_of(lksb, struct ocfs2_lock_res, l_lksb);\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"refcounttree.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"stackglue.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dcache.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2_lockingver.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/time.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/kthread.h>",
            "#include <linux/mm.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"stackglue.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dcache.h\"\n#include \"alloc.h\"\n#include \"ocfs2_lockingver.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/quotaops.h>\n#include <linux/time.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/pagemap.h>\n#include <linux/kthread.h>\n#include <linux/mm.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic inline struct ocfs2_lock_res *ocfs2_lksb_to_lock_res(struct ocfs2_dlm_lksb *lksb)\n{\n\treturn container_of(lksb, struct ocfs2_lock_res, l_lksb);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"stackglue.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dcache.h\"\n#include \"alloc.h\"\n#include \"ocfs2_lockingver.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/quotaops.h>\n#include <linux/time.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/pagemap.h>\n#include <linux/kthread.h>\n#include <linux/mm.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic struct ocfs2_super *ocfs2_get_dentry_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_inode_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_file_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_qinfo_osb(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_set_meta_lvb(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_dentry_post_unlock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres);\nstatic void ocfs2_set_qinfo_lvb(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_downconvert_action(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_convert_action(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_attach_action(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_schedule_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_recover_from_dlm_error(struct ocfs2_lock_res *lockres,\n\t\t\t\t\t\tint convert);\nstatic void ocfs2_downconvert_on_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic int ocfs2_prepare_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\t        struct ocfs2_lock_res *lockres);\nstatic int ocfs2_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_process_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *lockres);\n\nstatic void ocfs2_unlock_ast(struct ocfs2_dlm_lksb *lksb, int error)\n{\n\tstruct ocfs2_lock_res *lockres = ocfs2_lksb_to_lock_res(lksb);\n\tunsigned long flags;\n\n\tmlog(ML_BASTS, \"UNLOCK AST fired for lockres %s, action = %d\\n\",\n\t     lockres->l_name, lockres->l_unlock_action);\n\n\tspin_lock_irqsave(&lockres->l_lock, flags);\n\tif (error) {\n\t\tmlog(ML_ERROR, \"Dlm passes error %d for lock %s, \"\n\t\t     \"unlock_action %d\\n\", error, lockres->l_name,\n\t\t     lockres->l_unlock_action);\n\t\tspin_unlock_irqrestore(&lockres->l_lock, flags);\n\t\treturn;\n\t}\n\n\tswitch(lockres->l_unlock_action) {\n\tcase OCFS2_UNLOCK_CANCEL_CONVERT:\n\t\tmlog(0, \"Cancel convert success for %s\\n\", lockres->l_name);\n\t\tlockres->l_action = OCFS2_AST_INVALID;\n\t\t/* Downconvert thread may have requeued this lock, we\n\t\t * need to wake it. */\n\t\tif (lockres->l_flags & OCFS2_LOCK_BLOCKED)\n\t\t\tocfs2_wake_downconvert_thread(ocfs2_get_lockres_osb(lockres));\n\t\tbreak;\n\tcase OCFS2_UNLOCK_DROP_LOCK:\n\t\tlockres->l_level = DLM_LOCK_IV;\n\t\tbreak;\n\tdefault:\n\t\tBUG();\n\t}\n\n\tlockres_clear_flags(lockres, OCFS2_LOCK_BUSY);\n\tlockres->l_unlock_action = OCFS2_UNLOCK_INVALID;\n\twake_up(&lockres->l_event);\n\tspin_unlock_irqrestore(&lockres->l_lock, flags);\n}"
  },
  {
    "function_name": "ocfs2_locking_ast",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlmglue.c",
    "lines": "1056-1120",
    "snippet": "static void ocfs2_locking_ast(struct ocfs2_dlm_lksb *lksb)\n{\n\tstruct ocfs2_lock_res *lockres = ocfs2_lksb_to_lock_res(lksb);\n\tstruct ocfs2_super *osb = ocfs2_get_lockres_osb(lockres);\n\tunsigned long flags;\n\tint status;\n\n\tspin_lock_irqsave(&lockres->l_lock, flags);\n\n\tstatus = ocfs2_dlm_lock_status(&lockres->l_lksb);\n\n\tif (status == -EAGAIN) {\n\t\tlockres_clear_flags(lockres, OCFS2_LOCK_BUSY);\n\t\tgoto out;\n\t}\n\n\tif (status) {\n\t\tmlog(ML_ERROR, \"lockres %s: lksb status value of %d!\\n\",\n\t\t     lockres->l_name, status);\n\t\tspin_unlock_irqrestore(&lockres->l_lock, flags);\n\t\treturn;\n\t}\n\n\tmlog(ML_BASTS, \"AST fired for lockres %s, action %d, unlock %d, \"\n\t     \"level %d => %d\\n\", lockres->l_name, lockres->l_action,\n\t     lockres->l_unlock_action, lockres->l_level, lockres->l_requested);\n\n\tswitch(lockres->l_action) {\n\tcase OCFS2_AST_ATTACH:\n\t\tocfs2_generic_handle_attach_action(lockres);\n\t\tlockres_clear_flags(lockres, OCFS2_LOCK_LOCAL);\n\t\tbreak;\n\tcase OCFS2_AST_CONVERT:\n\t\tocfs2_generic_handle_convert_action(lockres);\n\t\tbreak;\n\tcase OCFS2_AST_DOWNCONVERT:\n\t\tocfs2_generic_handle_downconvert_action(lockres);\n\t\tbreak;\n\tdefault:\n\t\tmlog(ML_ERROR, \"lockres %s: AST fired with invalid action: %u, \"\n\t\t     \"flags 0x%lx, unlock: %u\\n\",\n\t\t     lockres->l_name, lockres->l_action, lockres->l_flags,\n\t\t     lockres->l_unlock_action);\n\t\tBUG();\n\t}\nout:\n\t/* set it to something invalid so if we get called again we\n\t * can catch it. */\n\tlockres->l_action = OCFS2_AST_INVALID;\n\n\t/* Did we try to cancel this lock?  Clear that state */\n\tif (lockres->l_unlock_action == OCFS2_UNLOCK_CANCEL_CONVERT)\n\t\tlockres->l_unlock_action = OCFS2_UNLOCK_INVALID;\n\n\t/*\n\t * We may have beaten the locking functions here.  We certainly\n\t * know that dlm_lock() has been called :-)\n\t * Because we can't have two lock calls in flight at once, we\n\t * can use lockres->l_pending_gen.\n\t */\n\t__lockres_clear_pending(lockres, lockres->l_pending_gen,  osb);\n\n\twake_up(&lockres->l_event);\n\tspin_unlock_irqrestore(&lockres->l_lock, flags);\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"refcounttree.h\"",
      "#include \"quota.h\"",
      "#include \"uptodate.h\"",
      "#include \"super.h\"",
      "#include \"slot_map.h\"",
      "#include \"stackglue.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"heartbeat.h\"",
      "#include \"file.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"dcache.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2_lockingver.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/time.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/kthread.h>",
      "#include <linux/mm.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct ocfs2_super *ocfs2_get_dentry_osb(struct ocfs2_lock_res *lockres);",
      "static struct ocfs2_super *ocfs2_get_inode_osb(struct ocfs2_lock_res *lockres);",
      "static struct ocfs2_super *ocfs2_get_file_osb(struct ocfs2_lock_res *lockres);",
      "static struct ocfs2_super *ocfs2_get_qinfo_osb(struct ocfs2_lock_res *lockres);",
      "static void ocfs2_set_meta_lvb(struct ocfs2_lock_res *lockres);",
      "static void ocfs2_dentry_post_unlock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres);",
      "static void ocfs2_set_qinfo_lvb(struct ocfs2_lock_res *lockres);",
      "static inline void ocfs2_generic_handle_downconvert_action(struct ocfs2_lock_res *lockres);",
      "static inline void ocfs2_generic_handle_convert_action(struct ocfs2_lock_res *lockres);",
      "static inline void ocfs2_generic_handle_attach_action(struct ocfs2_lock_res *lockres);",
      "static int ocfs2_generic_handle_bast(struct ocfs2_lock_res *lockres, int level);",
      "static void ocfs2_schedule_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);",
      "static void ocfs2_downconvert_on_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);",
      "static void ocfs2_drop_osb_locks(struct ocfs2_super *osb);",
      "static inline int ocfs2_highest_compat_lock_level(int level);",
      "static int ocfs2_prepare_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\t        struct ocfs2_lock_res *lockres);",
      "static int ocfs2_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres);",
      "static void ocfs2_process_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *lockres);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock_irqrestore",
          "args": [
            "&lockres->l_lock",
            "flags"
          ],
          "line": 1119
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wake_up",
          "args": [
            "&lockres->l_event"
          ],
          "line": 1118
        },
        "resolved": true,
        "details": {
          "function_name": "locks_wake_up_blocks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/locks.c",
          "lines": "656-681",
          "snippet": "static void locks_wake_up_blocks(struct file_lock *blocker)\n{\n\t/*\n\t * Avoid taking global lock if list is empty. This is safe since new\n\t * blocked requests are only added to the list under the flc_lock, and\n\t * the flc_lock is always held here. Note that removal from the fl_block\n\t * list does not require the flc_lock, so we must recheck list_empty()\n\t * after acquiring the blocked_lock_lock.\n\t */\n\tif (list_empty(&blocker->fl_block))\n\t\treturn;\n\n\tspin_lock(&blocked_lock_lock);\n\twhile (!list_empty(&blocker->fl_block)) {\n\t\tstruct file_lock *waiter;\n\n\t\twaiter = list_first_entry(&blocker->fl_block,\n\t\t\t\tstruct file_lock, fl_block);\n\t\t__locks_delete_block(waiter);\n\t\tif (waiter->fl_lmops && waiter->fl_lmops->lm_notify)\n\t\t\twaiter->fl_lmops->lm_notify(waiter);\n\t\telse\n\t\t\twake_up(&waiter->fl_wait);\n\t}\n\tspin_unlock(&blocked_lock_lock);\n}",
          "includes": [
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <asm/uaccess.h>",
            "#include <trace/events/filelock.h>",
            "#include <linux/lglock.h>",
            "#include <linux/percpu.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/time.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/slab.h>",
            "#include <linux/security.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_SPINLOCK(blocked_lock_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <asm/uaccess.h>\n#include <trace/events/filelock.h>\n#include <linux/lglock.h>\n#include <linux/percpu.h>\n#include <linux/hashtable.h>\n#include <linux/pid_namespace.h>\n#include <linux/rcupdate.h>\n#include <linux/time.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n\nstatic DEFINE_SPINLOCK(blocked_lock_lock);\n\nstatic void locks_wake_up_blocks(struct file_lock *blocker)\n{\n\t/*\n\t * Avoid taking global lock if list is empty. This is safe since new\n\t * blocked requests are only added to the list under the flc_lock, and\n\t * the flc_lock is always held here. Note that removal from the fl_block\n\t * list does not require the flc_lock, so we must recheck list_empty()\n\t * after acquiring the blocked_lock_lock.\n\t */\n\tif (list_empty(&blocker->fl_block))\n\t\treturn;\n\n\tspin_lock(&blocked_lock_lock);\n\twhile (!list_empty(&blocker->fl_block)) {\n\t\tstruct file_lock *waiter;\n\n\t\twaiter = list_first_entry(&blocker->fl_block,\n\t\t\t\tstruct file_lock, fl_block);\n\t\t__locks_delete_block(waiter);\n\t\tif (waiter->fl_lmops && waiter->fl_lmops->lm_notify)\n\t\t\twaiter->fl_lmops->lm_notify(waiter);\n\t\telse\n\t\t\twake_up(&waiter->fl_wait);\n\t}\n\tspin_unlock(&blocked_lock_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__lockres_clear_pending",
          "args": [
            "lockres",
            "lockres->l_pending_gen",
            "osb"
          ],
          "line": 1116
        },
        "resolved": true,
        "details": {
          "function_name": "__lockres_clear_pending",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlmglue.c",
          "lines": "978-1001",
          "snippet": "static void __lockres_clear_pending(struct ocfs2_lock_res *lockres,\n\t\t\t\t    unsigned int generation,\n\t\t\t\t    struct ocfs2_super *osb)\n{\n\tassert_spin_locked(&lockres->l_lock);\n\n\t/*\n\t * The ast and locking functions can race us here.  The winner\n\t * will clear pending, the loser will not.\n\t */\n\tif (!(lockres->l_flags & OCFS2_LOCK_PENDING) ||\n\t    (lockres->l_pending_gen != generation))\n\t\treturn;\n\n\tlockres_clear_flags(lockres, OCFS2_LOCK_PENDING);\n\tlockres->l_pending_gen++;\n\n\t/*\n\t * The downconvert thread may have skipped us because we\n\t * were PENDING.  Wake it up.\n\t */\n\tif (lockres->l_flags & OCFS2_LOCK_BLOCKED)\n\t\tocfs2_wake_downconvert_thread(osb);\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"refcounttree.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"stackglue.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dcache.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2_lockingver.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/time.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/kthread.h>",
            "#include <linux/mm.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct ocfs2_super *ocfs2_get_dentry_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_inode_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_file_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_qinfo_osb(struct ocfs2_lock_res *lockres);",
            "static void ocfs2_set_meta_lvb(struct ocfs2_lock_res *lockres);",
            "static void ocfs2_dentry_post_unlock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres);",
            "static void ocfs2_set_qinfo_lvb(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_downconvert_action(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_convert_action(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_attach_action(struct ocfs2_lock_res *lockres);",
            "static void ocfs2_schedule_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static void ocfs2_downconvert_on_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static void ocfs2_drop_osb_locks(struct ocfs2_super *osb);",
            "static int ocfs2_downconvert_lock(struct ocfs2_super *osb,\n\t\t\t\t  struct ocfs2_lock_res *lockres,\n\t\t\t\t  int new_level,\n\t\t\t\t  int lvb,\n\t\t\t\t  unsigned int generation);",
            "static int ocfs2_prepare_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\t        struct ocfs2_lock_res *lockres);",
            "static int ocfs2_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static void ocfs2_process_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *lockres);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"stackglue.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dcache.h\"\n#include \"alloc.h\"\n#include \"ocfs2_lockingver.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/quotaops.h>\n#include <linux/time.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/pagemap.h>\n#include <linux/kthread.h>\n#include <linux/mm.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic struct ocfs2_super *ocfs2_get_dentry_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_inode_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_file_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_qinfo_osb(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_set_meta_lvb(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_dentry_post_unlock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres);\nstatic void ocfs2_set_qinfo_lvb(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_downconvert_action(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_convert_action(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_attach_action(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_schedule_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_downconvert_on_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_drop_osb_locks(struct ocfs2_super *osb);\nstatic int ocfs2_downconvert_lock(struct ocfs2_super *osb,\n\t\t\t\t  struct ocfs2_lock_res *lockres,\n\t\t\t\t  int new_level,\n\t\t\t\t  int lvb,\n\t\t\t\t  unsigned int generation);\nstatic int ocfs2_prepare_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\t        struct ocfs2_lock_res *lockres);\nstatic int ocfs2_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_process_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *lockres);\n\nstatic void __lockres_clear_pending(struct ocfs2_lock_res *lockres,\n\t\t\t\t    unsigned int generation,\n\t\t\t\t    struct ocfs2_super *osb)\n{\n\tassert_spin_locked(&lockres->l_lock);\n\n\t/*\n\t * The ast and locking functions can race us here.  The winner\n\t * will clear pending, the loser will not.\n\t */\n\tif (!(lockres->l_flags & OCFS2_LOCK_PENDING) ||\n\t    (lockres->l_pending_gen != generation))\n\t\treturn;\n\n\tlockres_clear_flags(lockres, OCFS2_LOCK_PENDING);\n\tlockres->l_pending_gen++;\n\n\t/*\n\t * The downconvert thread may have skipped us because we\n\t * were PENDING.  Wake it up.\n\t */\n\tif (lockres->l_flags & OCFS2_LOCK_BLOCKED)\n\t\tocfs2_wake_downconvert_thread(osb);\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG",
          "args": [],
          "line": 1099
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mlog",
          "args": [
            "ML_ERROR",
            "\"lockres %s: AST fired with invalid action: %u, \"\n\t\t     \"flags 0x%lx, unlock: %u\\n\"",
            "lockres->l_name",
            "lockres->l_action",
            "lockres->l_flags",
            "lockres->l_unlock_action"
          ],
          "line": 1095
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_generic_handle_downconvert_action",
          "args": [
            "lockres"
          ],
          "line": 1092
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_generic_handle_downconvert_action",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlmglue.c",
          "lines": "829-843",
          "snippet": "static inline void ocfs2_generic_handle_downconvert_action(struct ocfs2_lock_res *lockres)\n{\n\tBUG_ON(!(lockres->l_flags & OCFS2_LOCK_BUSY));\n\tBUG_ON(!(lockres->l_flags & OCFS2_LOCK_ATTACHED));\n\tBUG_ON(!(lockres->l_flags & OCFS2_LOCK_BLOCKED));\n\tBUG_ON(lockres->l_blocking <= DLM_LOCK_NL);\n\n\tlockres->l_level = lockres->l_requested;\n\tif (lockres->l_level <=\n\t    ocfs2_highest_compat_lock_level(lockres->l_blocking)) {\n\t\tlockres->l_blocking = DLM_LOCK_NL;\n\t\tlockres_clear_flags(lockres, OCFS2_LOCK_BLOCKED);\n\t}\n\tlockres_clear_flags(lockres, OCFS2_LOCK_BUSY);\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"refcounttree.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"stackglue.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dcache.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2_lockingver.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/time.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/kthread.h>",
            "#include <linux/mm.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct ocfs2_super *ocfs2_get_dentry_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_inode_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_file_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_qinfo_osb(struct ocfs2_lock_res *lockres);",
            "static void ocfs2_set_meta_lvb(struct ocfs2_lock_res *lockres);",
            "static void ocfs2_dentry_post_unlock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres);",
            "static void ocfs2_set_qinfo_lvb(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_downconvert_action(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_convert_action(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_attach_action(struct ocfs2_lock_res *lockres);",
            "static void ocfs2_schedule_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static void ocfs2_downconvert_on_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static int ocfs2_prepare_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\t        struct ocfs2_lock_res *lockres);",
            "static int ocfs2_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static void ocfs2_process_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *lockres);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"stackglue.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dcache.h\"\n#include \"alloc.h\"\n#include \"ocfs2_lockingver.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/quotaops.h>\n#include <linux/time.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/pagemap.h>\n#include <linux/kthread.h>\n#include <linux/mm.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic struct ocfs2_super *ocfs2_get_dentry_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_inode_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_file_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_qinfo_osb(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_set_meta_lvb(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_dentry_post_unlock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres);\nstatic void ocfs2_set_qinfo_lvb(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_downconvert_action(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_convert_action(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_attach_action(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_schedule_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_downconvert_on_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic int ocfs2_prepare_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\t        struct ocfs2_lock_res *lockres);\nstatic int ocfs2_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_process_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *lockres);\n\nstatic inline void ocfs2_generic_handle_downconvert_action(struct ocfs2_lock_res *lockres)\n{\n\tBUG_ON(!(lockres->l_flags & OCFS2_LOCK_BUSY));\n\tBUG_ON(!(lockres->l_flags & OCFS2_LOCK_ATTACHED));\n\tBUG_ON(!(lockres->l_flags & OCFS2_LOCK_BLOCKED));\n\tBUG_ON(lockres->l_blocking <= DLM_LOCK_NL);\n\n\tlockres->l_level = lockres->l_requested;\n\tif (lockres->l_level <=\n\t    ocfs2_highest_compat_lock_level(lockres->l_blocking)) {\n\t\tlockres->l_blocking = DLM_LOCK_NL;\n\t\tlockres_clear_flags(lockres, OCFS2_LOCK_BLOCKED);\n\t}\n\tlockres_clear_flags(lockres, OCFS2_LOCK_BUSY);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_generic_handle_convert_action",
          "args": [
            "lockres"
          ],
          "line": 1089
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_generic_handle_convert_action",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlmglue.c",
          "lines": "845-873",
          "snippet": "static inline void ocfs2_generic_handle_convert_action(struct ocfs2_lock_res *lockres)\n{\n\tBUG_ON(!(lockres->l_flags & OCFS2_LOCK_BUSY));\n\tBUG_ON(!(lockres->l_flags & OCFS2_LOCK_ATTACHED));\n\n\t/* Convert from RO to EX doesn't really need anything as our\n\t * information is already up to data. Convert from NL to\n\t * *anything* however should mark ourselves as needing an\n\t * update */\n\tif (lockres->l_level == DLM_LOCK_NL &&\n\t    lockres->l_ops->flags & LOCK_TYPE_REQUIRES_REFRESH)\n\t\tlockres_or_flags(lockres, OCFS2_LOCK_NEEDS_REFRESH);\n\n\tlockres->l_level = lockres->l_requested;\n\n\t/*\n\t * We set the OCFS2_LOCK_UPCONVERT_FINISHING flag before clearing\n\t * the OCFS2_LOCK_BUSY flag to prevent the dc thread from\n\t * downconverting the lock before the upconvert has fully completed.\n\t * Do not prevent the dc thread from downconverting if NONBLOCK lock\n\t * had already returned.\n\t */\n\tif (!(lockres->l_flags & OCFS2_LOCK_NONBLOCK_FINISHED))\n\t\tlockres_or_flags(lockres, OCFS2_LOCK_UPCONVERT_FINISHING);\n\telse\n\t\tlockres_clear_flags(lockres, OCFS2_LOCK_NONBLOCK_FINISHED);\n\n\tlockres_clear_flags(lockres, OCFS2_LOCK_BUSY);\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"refcounttree.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"stackglue.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dcache.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2_lockingver.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/time.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/kthread.h>",
            "#include <linux/mm.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [
            "#define LOCK_TYPE_REQUIRES_REFRESH 0x1"
          ],
          "globals_used": [
            "static struct ocfs2_super *ocfs2_get_dentry_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_inode_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_file_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_qinfo_osb(struct ocfs2_lock_res *lockres);",
            "static void ocfs2_set_meta_lvb(struct ocfs2_lock_res *lockres);",
            "static void ocfs2_dentry_post_unlock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres);",
            "static void ocfs2_set_qinfo_lvb(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_downconvert_action(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_convert_action(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_attach_action(struct ocfs2_lock_res *lockres);",
            "static void ocfs2_schedule_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static void ocfs2_downconvert_on_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static int ocfs2_prepare_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\t        struct ocfs2_lock_res *lockres);",
            "static int ocfs2_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static void ocfs2_process_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *lockres);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"stackglue.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dcache.h\"\n#include \"alloc.h\"\n#include \"ocfs2_lockingver.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/quotaops.h>\n#include <linux/time.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/pagemap.h>\n#include <linux/kthread.h>\n#include <linux/mm.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\n#define LOCK_TYPE_REQUIRES_REFRESH 0x1\n\nstatic struct ocfs2_super *ocfs2_get_dentry_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_inode_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_file_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_qinfo_osb(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_set_meta_lvb(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_dentry_post_unlock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres);\nstatic void ocfs2_set_qinfo_lvb(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_downconvert_action(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_convert_action(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_attach_action(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_schedule_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_downconvert_on_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic int ocfs2_prepare_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\t        struct ocfs2_lock_res *lockres);\nstatic int ocfs2_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_process_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *lockres);\n\nstatic inline void ocfs2_generic_handle_convert_action(struct ocfs2_lock_res *lockres)\n{\n\tBUG_ON(!(lockres->l_flags & OCFS2_LOCK_BUSY));\n\tBUG_ON(!(lockres->l_flags & OCFS2_LOCK_ATTACHED));\n\n\t/* Convert from RO to EX doesn't really need anything as our\n\t * information is already up to data. Convert from NL to\n\t * *anything* however should mark ourselves as needing an\n\t * update */\n\tif (lockres->l_level == DLM_LOCK_NL &&\n\t    lockres->l_ops->flags & LOCK_TYPE_REQUIRES_REFRESH)\n\t\tlockres_or_flags(lockres, OCFS2_LOCK_NEEDS_REFRESH);\n\n\tlockres->l_level = lockres->l_requested;\n\n\t/*\n\t * We set the OCFS2_LOCK_UPCONVERT_FINISHING flag before clearing\n\t * the OCFS2_LOCK_BUSY flag to prevent the dc thread from\n\t * downconverting the lock before the upconvert has fully completed.\n\t * Do not prevent the dc thread from downconverting if NONBLOCK lock\n\t * had already returned.\n\t */\n\tif (!(lockres->l_flags & OCFS2_LOCK_NONBLOCK_FINISHED))\n\t\tlockres_or_flags(lockres, OCFS2_LOCK_UPCONVERT_FINISHING);\n\telse\n\t\tlockres_clear_flags(lockres, OCFS2_LOCK_NONBLOCK_FINISHED);\n\n\tlockres_clear_flags(lockres, OCFS2_LOCK_BUSY);\n}"
        }
      },
      {
        "call_info": {
          "callee": "lockres_clear_flags",
          "args": [
            "lockres",
            "OCFS2_LOCK_LOCAL"
          ],
          "line": 1086
        },
        "resolved": true,
        "details": {
          "function_name": "lockres_clear_flags",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlmglue.c",
          "lines": "823-827",
          "snippet": "static void lockres_clear_flags(struct ocfs2_lock_res *lockres,\n\t\t\t\tunsigned long clear)\n{\n\tlockres_set_flags(lockres, lockres->l_flags & ~clear);\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"refcounttree.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"stackglue.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dcache.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2_lockingver.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/time.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/kthread.h>",
            "#include <linux/mm.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct ocfs2_super *ocfs2_get_dentry_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_inode_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_file_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_qinfo_osb(struct ocfs2_lock_res *lockres);",
            "static void ocfs2_set_meta_lvb(struct ocfs2_lock_res *lockres);",
            "static void ocfs2_dentry_post_unlock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres);",
            "static void ocfs2_set_qinfo_lvb(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_downconvert_action(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_convert_action(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_attach_action(struct ocfs2_lock_res *lockres);",
            "static void ocfs2_schedule_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static void ocfs2_downconvert_on_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static int ocfs2_prepare_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\t        struct ocfs2_lock_res *lockres);",
            "static int ocfs2_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static void ocfs2_process_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *lockres);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"stackglue.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dcache.h\"\n#include \"alloc.h\"\n#include \"ocfs2_lockingver.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/quotaops.h>\n#include <linux/time.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/pagemap.h>\n#include <linux/kthread.h>\n#include <linux/mm.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic struct ocfs2_super *ocfs2_get_dentry_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_inode_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_file_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_qinfo_osb(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_set_meta_lvb(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_dentry_post_unlock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres);\nstatic void ocfs2_set_qinfo_lvb(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_downconvert_action(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_convert_action(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_attach_action(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_schedule_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_downconvert_on_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic int ocfs2_prepare_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\t        struct ocfs2_lock_res *lockres);\nstatic int ocfs2_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_process_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *lockres);\n\nstatic void lockres_clear_flags(struct ocfs2_lock_res *lockres,\n\t\t\t\tunsigned long clear)\n{\n\tlockres_set_flags(lockres, lockres->l_flags & ~clear);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_generic_handle_attach_action",
          "args": [
            "lockres"
          ],
          "line": 1085
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_generic_handle_attach_action",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlmglue.c",
          "lines": "875-888",
          "snippet": "static inline void ocfs2_generic_handle_attach_action(struct ocfs2_lock_res *lockres)\n{\n\tBUG_ON((!(lockres->l_flags & OCFS2_LOCK_BUSY)));\n\tBUG_ON(lockres->l_flags & OCFS2_LOCK_ATTACHED);\n\n\tif (lockres->l_requested > DLM_LOCK_NL &&\n\t    !(lockres->l_flags & OCFS2_LOCK_LOCAL) &&\n\t    lockres->l_ops->flags & LOCK_TYPE_REQUIRES_REFRESH)\n\t\tlockres_or_flags(lockres, OCFS2_LOCK_NEEDS_REFRESH);\n\n\tlockres->l_level = lockres->l_requested;\n\tlockres_or_flags(lockres, OCFS2_LOCK_ATTACHED);\n\tlockres_clear_flags(lockres, OCFS2_LOCK_BUSY);\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"refcounttree.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"stackglue.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dcache.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2_lockingver.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/time.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/kthread.h>",
            "#include <linux/mm.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [
            "#define LOCK_TYPE_REQUIRES_REFRESH 0x1"
          ],
          "globals_used": [
            "static struct ocfs2_super *ocfs2_get_dentry_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_inode_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_file_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_qinfo_osb(struct ocfs2_lock_res *lockres);",
            "static void ocfs2_set_meta_lvb(struct ocfs2_lock_res *lockres);",
            "static void ocfs2_dentry_post_unlock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres);",
            "static void ocfs2_set_qinfo_lvb(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_downconvert_action(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_convert_action(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_attach_action(struct ocfs2_lock_res *lockres);",
            "static void ocfs2_schedule_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static void ocfs2_downconvert_on_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static int ocfs2_prepare_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\t        struct ocfs2_lock_res *lockres);",
            "static int ocfs2_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static void ocfs2_process_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *lockres);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"stackglue.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dcache.h\"\n#include \"alloc.h\"\n#include \"ocfs2_lockingver.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/quotaops.h>\n#include <linux/time.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/pagemap.h>\n#include <linux/kthread.h>\n#include <linux/mm.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\n#define LOCK_TYPE_REQUIRES_REFRESH 0x1\n\nstatic struct ocfs2_super *ocfs2_get_dentry_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_inode_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_file_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_qinfo_osb(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_set_meta_lvb(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_dentry_post_unlock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres);\nstatic void ocfs2_set_qinfo_lvb(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_downconvert_action(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_convert_action(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_attach_action(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_schedule_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_downconvert_on_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic int ocfs2_prepare_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\t        struct ocfs2_lock_res *lockres);\nstatic int ocfs2_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_process_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *lockres);\n\nstatic inline void ocfs2_generic_handle_attach_action(struct ocfs2_lock_res *lockres)\n{\n\tBUG_ON((!(lockres->l_flags & OCFS2_LOCK_BUSY)));\n\tBUG_ON(lockres->l_flags & OCFS2_LOCK_ATTACHED);\n\n\tif (lockres->l_requested > DLM_LOCK_NL &&\n\t    !(lockres->l_flags & OCFS2_LOCK_LOCAL) &&\n\t    lockres->l_ops->flags & LOCK_TYPE_REQUIRES_REFRESH)\n\t\tlockres_or_flags(lockres, OCFS2_LOCK_NEEDS_REFRESH);\n\n\tlockres->l_level = lockres->l_requested;\n\tlockres_or_flags(lockres, OCFS2_LOCK_ATTACHED);\n\tlockres_clear_flags(lockres, OCFS2_LOCK_BUSY);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog",
          "args": [
            "ML_BASTS",
            "\"AST fired for lockres %s, action %d, unlock %d, \"\n\t     \"level %d => %d\\n\"",
            "lockres->l_name",
            "lockres->l_action",
            "lockres->l_unlock_action",
            "lockres->l_level",
            "lockres->l_requested"
          ],
          "line": 1079
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock_irqrestore",
          "args": [
            "&lockres->l_lock",
            "flags"
          ],
          "line": 1075
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mlog",
          "args": [
            "ML_ERROR",
            "\"lockres %s: lksb status value of %d!\\n\"",
            "lockres->l_name",
            "status"
          ],
          "line": 1073
        },
        "resolved": true,
        "details": {
          "function_name": "mlog_store",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/cluster/masklog.c",
          "lines": "115-121",
          "snippet": "static ssize_t mlog_store(struct kobject *obj, struct attribute *attr,\n\t\t\t  const char *buf, size_t count)\n{\n\tstruct mlog_attribute *mlog_attr = to_mlog_attr(attr);\n\n\treturn mlog_mask_store(mlog_attr->mask, buf, count);\n}",
          "includes": [
            "#include \"masklog.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/string.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"masklog.h\"\n#include <asm/uaccess.h>\n#include <linux/string.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n\nstatic ssize_t mlog_store(struct kobject *obj, struct attribute *attr,\n\t\t\t  const char *buf, size_t count)\n{\n\tstruct mlog_attribute *mlog_attr = to_mlog_attr(attr);\n\n\treturn mlog_mask_store(mlog_attr->mask, buf, count);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_dlm_lock_status",
          "args": [
            "&lockres->l_lksb"
          ],
          "line": 1065
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_dlm_lock_status",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/stackglue.c",
          "lines": "267-270",
          "snippet": "int ocfs2_dlm_lock_status(struct ocfs2_dlm_lksb *lksb)\n{\n\treturn active_stack->sp_ops->lock_status(lksb);\n}",
          "includes": [
            "#include \"stackglue.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include <linux/sysctl.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/fs.h>",
            "#include <linux/kmod.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/list.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct ocfs2_stack_plugin *active_stack;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"stackglue.h\"\n#include \"ocfs2_fs.h\"\n#include <linux/sysctl.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/fs.h>\n#include <linux/kmod.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/spinlock.h>\n#include <linux/list.h>\n\nstatic struct ocfs2_stack_plugin *active_stack;\n\nint ocfs2_dlm_lock_status(struct ocfs2_dlm_lksb *lksb)\n{\n\treturn active_stack->sp_ops->lock_status(lksb);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock_irqsave",
          "args": [
            "&lockres->l_lock",
            "flags"
          ],
          "line": 1063
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_get_lockres_osb",
          "args": [
            "lockres"
          ],
          "line": 1059
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_get_lockres_osb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlmglue.c",
          "lines": "332-338",
          "snippet": "static inline struct ocfs2_super *ocfs2_get_lockres_osb(struct ocfs2_lock_res *lockres)\n{\n\tif (lockres->l_ops->get_osb)\n\t\treturn lockres->l_ops->get_osb(lockres);\n\n\treturn (struct ocfs2_super *)lockres->l_priv;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"refcounttree.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"stackglue.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dcache.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2_lockingver.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/time.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/kthread.h>",
            "#include <linux/mm.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct ocfs2_super *ocfs2_get_dentry_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_inode_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_file_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_qinfo_osb(struct ocfs2_lock_res *lockres);",
            "static void ocfs2_set_meta_lvb(struct ocfs2_lock_res *lockres);",
            "static void ocfs2_dentry_post_unlock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres);",
            "static void ocfs2_set_qinfo_lvb(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_downconvert_action(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_convert_action(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_attach_action(struct ocfs2_lock_res *lockres);",
            "static void ocfs2_schedule_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static void ocfs2_downconvert_on_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static int ocfs2_prepare_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\t        struct ocfs2_lock_res *lockres);",
            "static int ocfs2_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static void ocfs2_process_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *lockres);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"stackglue.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dcache.h\"\n#include \"alloc.h\"\n#include \"ocfs2_lockingver.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/quotaops.h>\n#include <linux/time.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/pagemap.h>\n#include <linux/kthread.h>\n#include <linux/mm.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic struct ocfs2_super *ocfs2_get_dentry_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_inode_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_file_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_qinfo_osb(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_set_meta_lvb(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_dentry_post_unlock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres);\nstatic void ocfs2_set_qinfo_lvb(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_downconvert_action(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_convert_action(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_attach_action(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_schedule_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_downconvert_on_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic int ocfs2_prepare_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\t        struct ocfs2_lock_res *lockres);\nstatic int ocfs2_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_process_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *lockres);\n\nstatic inline struct ocfs2_super *ocfs2_get_lockres_osb(struct ocfs2_lock_res *lockres)\n{\n\tif (lockres->l_ops->get_osb)\n\t\treturn lockres->l_ops->get_osb(lockres);\n\n\treturn (struct ocfs2_super *)lockres->l_priv;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_lksb_to_lock_res",
          "args": [
            "lksb"
          ],
          "line": 1058
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_lksb_to_lock_res",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlmglue.c",
          "lines": "300-303",
          "snippet": "static inline struct ocfs2_lock_res *ocfs2_lksb_to_lock_res(struct ocfs2_dlm_lksb *lksb)\n{\n\treturn container_of(lksb, struct ocfs2_lock_res, l_lksb);\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"refcounttree.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"stackglue.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dcache.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2_lockingver.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/time.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/kthread.h>",
            "#include <linux/mm.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"stackglue.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dcache.h\"\n#include \"alloc.h\"\n#include \"ocfs2_lockingver.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/quotaops.h>\n#include <linux/time.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/pagemap.h>\n#include <linux/kthread.h>\n#include <linux/mm.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic inline struct ocfs2_lock_res *ocfs2_lksb_to_lock_res(struct ocfs2_dlm_lksb *lksb)\n{\n\treturn container_of(lksb, struct ocfs2_lock_res, l_lksb);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"stackglue.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dcache.h\"\n#include \"alloc.h\"\n#include \"ocfs2_lockingver.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/quotaops.h>\n#include <linux/time.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/pagemap.h>\n#include <linux/kthread.h>\n#include <linux/mm.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic struct ocfs2_super *ocfs2_get_dentry_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_inode_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_file_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_qinfo_osb(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_set_meta_lvb(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_dentry_post_unlock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres);\nstatic void ocfs2_set_qinfo_lvb(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_downconvert_action(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_convert_action(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_attach_action(struct ocfs2_lock_res *lockres);\nstatic int ocfs2_generic_handle_bast(struct ocfs2_lock_res *lockres, int level);\nstatic void ocfs2_schedule_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_downconvert_on_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_drop_osb_locks(struct ocfs2_super *osb);\nstatic inline int ocfs2_highest_compat_lock_level(int level);\nstatic int ocfs2_prepare_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\t        struct ocfs2_lock_res *lockres);\nstatic int ocfs2_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_process_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *lockres);\n\nstatic void ocfs2_locking_ast(struct ocfs2_dlm_lksb *lksb)\n{\n\tstruct ocfs2_lock_res *lockres = ocfs2_lksb_to_lock_res(lksb);\n\tstruct ocfs2_super *osb = ocfs2_get_lockres_osb(lockres);\n\tunsigned long flags;\n\tint status;\n\n\tspin_lock_irqsave(&lockres->l_lock, flags);\n\n\tstatus = ocfs2_dlm_lock_status(&lockres->l_lksb);\n\n\tif (status == -EAGAIN) {\n\t\tlockres_clear_flags(lockres, OCFS2_LOCK_BUSY);\n\t\tgoto out;\n\t}\n\n\tif (status) {\n\t\tmlog(ML_ERROR, \"lockres %s: lksb status value of %d!\\n\",\n\t\t     lockres->l_name, status);\n\t\tspin_unlock_irqrestore(&lockres->l_lock, flags);\n\t\treturn;\n\t}\n\n\tmlog(ML_BASTS, \"AST fired for lockres %s, action %d, unlock %d, \"\n\t     \"level %d => %d\\n\", lockres->l_name, lockres->l_action,\n\t     lockres->l_unlock_action, lockres->l_level, lockres->l_requested);\n\n\tswitch(lockres->l_action) {\n\tcase OCFS2_AST_ATTACH:\n\t\tocfs2_generic_handle_attach_action(lockres);\n\t\tlockres_clear_flags(lockres, OCFS2_LOCK_LOCAL);\n\t\tbreak;\n\tcase OCFS2_AST_CONVERT:\n\t\tocfs2_generic_handle_convert_action(lockres);\n\t\tbreak;\n\tcase OCFS2_AST_DOWNCONVERT:\n\t\tocfs2_generic_handle_downconvert_action(lockres);\n\t\tbreak;\n\tdefault:\n\t\tmlog(ML_ERROR, \"lockres %s: AST fired with invalid action: %u, \"\n\t\t     \"flags 0x%lx, unlock: %u\\n\",\n\t\t     lockres->l_name, lockres->l_action, lockres->l_flags,\n\t\t     lockres->l_unlock_action);\n\t\tBUG();\n\t}\nout:\n\t/* set it to something invalid so if we get called again we\n\t * can catch it. */\n\tlockres->l_action = OCFS2_AST_INVALID;\n\n\t/* Did we try to cancel this lock?  Clear that state */\n\tif (lockres->l_unlock_action == OCFS2_UNLOCK_CANCEL_CONVERT)\n\t\tlockres->l_unlock_action = OCFS2_UNLOCK_INVALID;\n\n\t/*\n\t * We may have beaten the locking functions here.  We certainly\n\t * know that dlm_lock() has been called :-)\n\t * Because we can't have two lock calls in flight at once, we\n\t * can use lockres->l_pending_gen.\n\t */\n\t__lockres_clear_pending(lockres, lockres->l_pending_gen,  osb);\n\n\twake_up(&lockres->l_event);\n\tspin_unlock_irqrestore(&lockres->l_lock, flags);\n}"
  },
  {
    "function_name": "ocfs2_blocking_ast",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlmglue.c",
    "lines": "1025-1054",
    "snippet": "static void ocfs2_blocking_ast(struct ocfs2_dlm_lksb *lksb, int level)\n{\n\tstruct ocfs2_lock_res *lockres = ocfs2_lksb_to_lock_res(lksb);\n\tstruct ocfs2_super *osb = ocfs2_get_lockres_osb(lockres);\n\tint needs_downconvert;\n\tunsigned long flags;\n\n\tBUG_ON(level <= DLM_LOCK_NL);\n\n\tmlog(ML_BASTS, \"BAST fired for lockres %s, blocking %d, level %d, \"\n\t     \"type %s\\n\", lockres->l_name, level, lockres->l_level,\n\t     ocfs2_lock_type_string(lockres->l_type));\n\n\t/*\n\t * We can skip the bast for locks which don't enable caching -\n\t * they'll be dropped at the earliest possible time anyway.\n\t */\n\tif (lockres->l_flags & OCFS2_LOCK_NOCACHE)\n\t\treturn;\n\n\tspin_lock_irqsave(&lockres->l_lock, flags);\n\tneeds_downconvert = ocfs2_generic_handle_bast(lockres, level);\n\tif (needs_downconvert)\n\t\tocfs2_schedule_blocked_lock(osb, lockres);\n\tspin_unlock_irqrestore(&lockres->l_lock, flags);\n\n\twake_up(&lockres->l_event);\n\n\tocfs2_wake_downconvert_thread(osb);\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"refcounttree.h\"",
      "#include \"quota.h\"",
      "#include \"uptodate.h\"",
      "#include \"super.h\"",
      "#include \"slot_map.h\"",
      "#include \"stackglue.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"heartbeat.h\"",
      "#include \"file.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"dcache.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2_lockingver.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/time.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/kthread.h>",
      "#include <linux/mm.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct ocfs2_super *ocfs2_get_dentry_osb(struct ocfs2_lock_res *lockres);",
      "static struct ocfs2_super *ocfs2_get_inode_osb(struct ocfs2_lock_res *lockres);",
      "static struct ocfs2_super *ocfs2_get_file_osb(struct ocfs2_lock_res *lockres);",
      "static struct ocfs2_super *ocfs2_get_qinfo_osb(struct ocfs2_lock_res *lockres);",
      "static void ocfs2_set_meta_lvb(struct ocfs2_lock_res *lockres);",
      "static int ocfs2_data_convert_worker(struct ocfs2_lock_res *lockres,\n\t\t\t\t     int blocking);",
      "static int ocfs2_dentry_convert_worker(struct ocfs2_lock_res *lockres,\n\t\t\t\t       int blocking);",
      "static void ocfs2_dentry_post_unlock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres);",
      "static void ocfs2_set_qinfo_lvb(struct ocfs2_lock_res *lockres);",
      "static int ocfs2_refcount_convert_worker(struct ocfs2_lock_res *lockres,\n\t\t\t\t\t int blocking);",
      "static inline void ocfs2_generic_handle_downconvert_action(struct ocfs2_lock_res *lockres);",
      "static inline void ocfs2_generic_handle_convert_action(struct ocfs2_lock_res *lockres);",
      "static inline void ocfs2_generic_handle_attach_action(struct ocfs2_lock_res *lockres);",
      "static int ocfs2_generic_handle_bast(struct ocfs2_lock_res *lockres, int level);",
      "static void ocfs2_schedule_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);",
      "static void ocfs2_downconvert_on_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);",
      "static void ocfs2_drop_osb_locks(struct ocfs2_super *osb);",
      "static inline int ocfs2_highest_compat_lock_level(int level);",
      "static int ocfs2_prepare_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\t        struct ocfs2_lock_res *lockres);",
      "static int ocfs2_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres);",
      "static void ocfs2_process_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *lockres);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ocfs2_wake_downconvert_thread",
          "args": [
            "osb"
          ],
          "line": 1053
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_wake_downconvert_thread",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlmglue.c",
          "lines": "4091-4101",
          "snippet": "void ocfs2_wake_downconvert_thread(struct ocfs2_super *osb)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&osb->dc_task_lock, flags);\n\t/* make sure the voting thread gets a swipe at whatever changes\n\t * the caller may have made to the voting state */\n\tosb->dc_wake_sequence++;\n\tspin_unlock_irqrestore(&osb->dc_task_lock, flags);\n\twake_up(&osb->dc_event);\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"refcounttree.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"stackglue.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dcache.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2_lockingver.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/time.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/kthread.h>",
            "#include <linux/mm.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void ocfs2_drop_osb_locks(struct ocfs2_super *osb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"stackglue.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dcache.h\"\n#include \"alloc.h\"\n#include \"ocfs2_lockingver.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/quotaops.h>\n#include <linux/time.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/pagemap.h>\n#include <linux/kthread.h>\n#include <linux/mm.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic void ocfs2_drop_osb_locks(struct ocfs2_super *osb);\n\nvoid ocfs2_wake_downconvert_thread(struct ocfs2_super *osb)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&osb->dc_task_lock, flags);\n\t/* make sure the voting thread gets a swipe at whatever changes\n\t * the caller may have made to the voting state */\n\tosb->dc_wake_sequence++;\n\tspin_unlock_irqrestore(&osb->dc_task_lock, flags);\n\twake_up(&osb->dc_event);\n}"
        }
      },
      {
        "call_info": {
          "callee": "wake_up",
          "args": [
            "&lockres->l_event"
          ],
          "line": 1051
        },
        "resolved": true,
        "details": {
          "function_name": "locks_wake_up_blocks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/locks.c",
          "lines": "656-681",
          "snippet": "static void locks_wake_up_blocks(struct file_lock *blocker)\n{\n\t/*\n\t * Avoid taking global lock if list is empty. This is safe since new\n\t * blocked requests are only added to the list under the flc_lock, and\n\t * the flc_lock is always held here. Note that removal from the fl_block\n\t * list does not require the flc_lock, so we must recheck list_empty()\n\t * after acquiring the blocked_lock_lock.\n\t */\n\tif (list_empty(&blocker->fl_block))\n\t\treturn;\n\n\tspin_lock(&blocked_lock_lock);\n\twhile (!list_empty(&blocker->fl_block)) {\n\t\tstruct file_lock *waiter;\n\n\t\twaiter = list_first_entry(&blocker->fl_block,\n\t\t\t\tstruct file_lock, fl_block);\n\t\t__locks_delete_block(waiter);\n\t\tif (waiter->fl_lmops && waiter->fl_lmops->lm_notify)\n\t\t\twaiter->fl_lmops->lm_notify(waiter);\n\t\telse\n\t\t\twake_up(&waiter->fl_wait);\n\t}\n\tspin_unlock(&blocked_lock_lock);\n}",
          "includes": [
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <asm/uaccess.h>",
            "#include <trace/events/filelock.h>",
            "#include <linux/lglock.h>",
            "#include <linux/percpu.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/time.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/slab.h>",
            "#include <linux/security.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_SPINLOCK(blocked_lock_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <asm/uaccess.h>\n#include <trace/events/filelock.h>\n#include <linux/lglock.h>\n#include <linux/percpu.h>\n#include <linux/hashtable.h>\n#include <linux/pid_namespace.h>\n#include <linux/rcupdate.h>\n#include <linux/time.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n\nstatic DEFINE_SPINLOCK(blocked_lock_lock);\n\nstatic void locks_wake_up_blocks(struct file_lock *blocker)\n{\n\t/*\n\t * Avoid taking global lock if list is empty. This is safe since new\n\t * blocked requests are only added to the list under the flc_lock, and\n\t * the flc_lock is always held here. Note that removal from the fl_block\n\t * list does not require the flc_lock, so we must recheck list_empty()\n\t * after acquiring the blocked_lock_lock.\n\t */\n\tif (list_empty(&blocker->fl_block))\n\t\treturn;\n\n\tspin_lock(&blocked_lock_lock);\n\twhile (!list_empty(&blocker->fl_block)) {\n\t\tstruct file_lock *waiter;\n\n\t\twaiter = list_first_entry(&blocker->fl_block,\n\t\t\t\tstruct file_lock, fl_block);\n\t\t__locks_delete_block(waiter);\n\t\tif (waiter->fl_lmops && waiter->fl_lmops->lm_notify)\n\t\t\twaiter->fl_lmops->lm_notify(waiter);\n\t\telse\n\t\t\twake_up(&waiter->fl_wait);\n\t}\n\tspin_unlock(&blocked_lock_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock_irqrestore",
          "args": [
            "&lockres->l_lock",
            "flags"
          ],
          "line": 1049
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_schedule_blocked_lock",
          "args": [
            "osb",
            "lockres"
          ],
          "line": 1048
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_schedule_blocked_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlmglue.c",
          "lines": "3984-4009",
          "snippet": "static void ocfs2_schedule_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres)\n{\n\tunsigned long flags;\n\n\tassert_spin_locked(&lockres->l_lock);\n\n\tif (lockres->l_flags & OCFS2_LOCK_FREEING) {\n\t\t/* Do not schedule a lock for downconvert when it's on\n\t\t * the way to destruction - any nodes wanting access\n\t\t * to the resource will get it soon. */\n\t\tmlog(ML_BASTS, \"lockres %s won't be scheduled: flags 0x%lx\\n\",\n\t\t     lockres->l_name, lockres->l_flags);\n\t\treturn;\n\t}\n\n\tlockres_or_flags(lockres, OCFS2_LOCK_QUEUED);\n\n\tspin_lock_irqsave(&osb->dc_task_lock, flags);\n\tif (list_empty(&lockres->l_blocked_list)) {\n\t\tlist_add_tail(&lockres->l_blocked_list,\n\t\t\t      &osb->blocked_lock_list);\n\t\tosb->blocked_lock_count++;\n\t}\n\tspin_unlock_irqrestore(&osb->dc_task_lock, flags);\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"refcounttree.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"stackglue.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dcache.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2_lockingver.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/time.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/kthread.h>",
            "#include <linux/mm.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct ocfs2_super *ocfs2_get_dentry_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_inode_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_file_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_qinfo_osb(struct ocfs2_lock_res *lockres);",
            "static void ocfs2_set_meta_lvb(struct ocfs2_lock_res *lockres);",
            "static void ocfs2_dentry_post_unlock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres);",
            "static void ocfs2_set_qinfo_lvb(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_downconvert_action(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_convert_action(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_attach_action(struct ocfs2_lock_res *lockres);",
            "static void ocfs2_schedule_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static void ocfs2_downconvert_on_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static void ocfs2_drop_osb_locks(struct ocfs2_super *osb);",
            "static int ocfs2_prepare_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\t        struct ocfs2_lock_res *lockres);",
            "static int ocfs2_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static void ocfs2_process_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *lockres);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"stackglue.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dcache.h\"\n#include \"alloc.h\"\n#include \"ocfs2_lockingver.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/quotaops.h>\n#include <linux/time.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/pagemap.h>\n#include <linux/kthread.h>\n#include <linux/mm.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic struct ocfs2_super *ocfs2_get_dentry_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_inode_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_file_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_qinfo_osb(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_set_meta_lvb(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_dentry_post_unlock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres);\nstatic void ocfs2_set_qinfo_lvb(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_downconvert_action(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_convert_action(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_attach_action(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_schedule_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_downconvert_on_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_drop_osb_locks(struct ocfs2_super *osb);\nstatic int ocfs2_prepare_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\t        struct ocfs2_lock_res *lockres);\nstatic int ocfs2_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_process_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *lockres);\n\nstatic void ocfs2_schedule_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres)\n{\n\tunsigned long flags;\n\n\tassert_spin_locked(&lockres->l_lock);\n\n\tif (lockres->l_flags & OCFS2_LOCK_FREEING) {\n\t\t/* Do not schedule a lock for downconvert when it's on\n\t\t * the way to destruction - any nodes wanting access\n\t\t * to the resource will get it soon. */\n\t\tmlog(ML_BASTS, \"lockres %s won't be scheduled: flags 0x%lx\\n\",\n\t\t     lockres->l_name, lockres->l_flags);\n\t\treturn;\n\t}\n\n\tlockres_or_flags(lockres, OCFS2_LOCK_QUEUED);\n\n\tspin_lock_irqsave(&osb->dc_task_lock, flags);\n\tif (list_empty(&lockres->l_blocked_list)) {\n\t\tlist_add_tail(&lockres->l_blocked_list,\n\t\t\t      &osb->blocked_lock_list);\n\t\tosb->blocked_lock_count++;\n\t}\n\tspin_unlock_irqrestore(&osb->dc_task_lock, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_generic_handle_bast",
          "args": [
            "lockres",
            "level"
          ],
          "line": 1046
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_generic_handle_bast",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlmglue.c",
          "lines": "890-917",
          "snippet": "static int ocfs2_generic_handle_bast(struct ocfs2_lock_res *lockres,\n\t\t\t\t     int level)\n{\n\tint needs_downconvert = 0;\n\n\tassert_spin_locked(&lockres->l_lock);\n\n\tif (level > lockres->l_blocking) {\n\t\t/* only schedule a downconvert if we haven't already scheduled\n\t\t * one that goes low enough to satisfy the level we're\n\t\t * blocking.  this also catches the case where we get\n\t\t * duplicate BASTs */\n\t\tif (ocfs2_highest_compat_lock_level(level) <\n\t\t    ocfs2_highest_compat_lock_level(lockres->l_blocking))\n\t\t\tneeds_downconvert = 1;\n\n\t\tlockres->l_blocking = level;\n\t}\n\n\tmlog(ML_BASTS, \"lockres %s, block %d, level %d, l_block %d, dwn %d\\n\",\n\t     lockres->l_name, level, lockres->l_level, lockres->l_blocking,\n\t     needs_downconvert);\n\n\tif (needs_downconvert)\n\t\tlockres_or_flags(lockres, OCFS2_LOCK_BLOCKED);\n\tmlog(0, \"needs_downconvert = %d\\n\", needs_downconvert);\n\treturn needs_downconvert;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"refcounttree.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"stackglue.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dcache.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2_lockingver.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/time.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/kthread.h>",
            "#include <linux/mm.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct ocfs2_super *ocfs2_get_dentry_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_inode_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_file_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_qinfo_osb(struct ocfs2_lock_res *lockres);",
            "static void ocfs2_set_meta_lvb(struct ocfs2_lock_res *lockres);",
            "static int ocfs2_data_convert_worker(struct ocfs2_lock_res *lockres,\n\t\t\t\t     int blocking);",
            "static int ocfs2_dentry_convert_worker(struct ocfs2_lock_res *lockres,\n\t\t\t\t       int blocking);",
            "static void ocfs2_dentry_post_unlock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres);",
            "static void ocfs2_set_qinfo_lvb(struct ocfs2_lock_res *lockres);",
            "static int ocfs2_refcount_convert_worker(struct ocfs2_lock_res *lockres,\n\t\t\t\t\t int blocking);",
            "static inline void ocfs2_generic_handle_downconvert_action(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_convert_action(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_attach_action(struct ocfs2_lock_res *lockres);",
            "static int ocfs2_generic_handle_bast(struct ocfs2_lock_res *lockres, int level);",
            "static void ocfs2_schedule_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static void ocfs2_downconvert_on_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static inline int ocfs2_highest_compat_lock_level(int level);",
            "static int ocfs2_prepare_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\t        struct ocfs2_lock_res *lockres);",
            "static int ocfs2_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static void ocfs2_process_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *lockres);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"stackglue.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dcache.h\"\n#include \"alloc.h\"\n#include \"ocfs2_lockingver.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/quotaops.h>\n#include <linux/time.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/pagemap.h>\n#include <linux/kthread.h>\n#include <linux/mm.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic struct ocfs2_super *ocfs2_get_dentry_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_inode_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_file_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_qinfo_osb(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_set_meta_lvb(struct ocfs2_lock_res *lockres);\nstatic int ocfs2_data_convert_worker(struct ocfs2_lock_res *lockres,\n\t\t\t\t     int blocking);\nstatic int ocfs2_dentry_convert_worker(struct ocfs2_lock_res *lockres,\n\t\t\t\t       int blocking);\nstatic void ocfs2_dentry_post_unlock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres);\nstatic void ocfs2_set_qinfo_lvb(struct ocfs2_lock_res *lockres);\nstatic int ocfs2_refcount_convert_worker(struct ocfs2_lock_res *lockres,\n\t\t\t\t\t int blocking);\nstatic inline void ocfs2_generic_handle_downconvert_action(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_convert_action(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_attach_action(struct ocfs2_lock_res *lockres);\nstatic int ocfs2_generic_handle_bast(struct ocfs2_lock_res *lockres, int level);\nstatic void ocfs2_schedule_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_downconvert_on_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic inline int ocfs2_highest_compat_lock_level(int level);\nstatic int ocfs2_prepare_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\t        struct ocfs2_lock_res *lockres);\nstatic int ocfs2_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_process_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *lockres);\n\nstatic int ocfs2_generic_handle_bast(struct ocfs2_lock_res *lockres,\n\t\t\t\t     int level)\n{\n\tint needs_downconvert = 0;\n\n\tassert_spin_locked(&lockres->l_lock);\n\n\tif (level > lockres->l_blocking) {\n\t\t/* only schedule a downconvert if we haven't already scheduled\n\t\t * one that goes low enough to satisfy the level we're\n\t\t * blocking.  this also catches the case where we get\n\t\t * duplicate BASTs */\n\t\tif (ocfs2_highest_compat_lock_level(level) <\n\t\t    ocfs2_highest_compat_lock_level(lockres->l_blocking))\n\t\t\tneeds_downconvert = 1;\n\n\t\tlockres->l_blocking = level;\n\t}\n\n\tmlog(ML_BASTS, \"lockres %s, block %d, level %d, l_block %d, dwn %d\\n\",\n\t     lockres->l_name, level, lockres->l_level, lockres->l_blocking,\n\t     needs_downconvert);\n\n\tif (needs_downconvert)\n\t\tlockres_or_flags(lockres, OCFS2_LOCK_BLOCKED);\n\tmlog(0, \"needs_downconvert = %d\\n\", needs_downconvert);\n\treturn needs_downconvert;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock_irqsave",
          "args": [
            "&lockres->l_lock",
            "flags"
          ],
          "line": 1045
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mlog",
          "args": [
            "ML_BASTS",
            "\"BAST fired for lockres %s, blocking %d, level %d, \"\n\t     \"type %s\\n\"",
            "lockres->l_name",
            "level",
            "lockres->l_level",
            "ocfs2_lock_type_string(lockres->l_type)"
          ],
          "line": 1034
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_lock_type_string",
          "args": [
            "lockres->l_type"
          ],
          "line": 1036
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_lock_type_string",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2_lockid.h",
          "lines": "120-126",
          "snippet": "static inline const char *ocfs2_lock_type_string(enum ocfs2_lock_type type)\n{\n#ifdef __KERNEL__\n\tBUG_ON(type >= OCFS2_NUM_LOCK_TYPES);\n#endif\n\treturn ocfs2_lock_type_strings[type];\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline const char *ocfs2_lock_type_string(enum ocfs2_lock_type type)\n{\n#ifdef __KERNEL__\n\tBUG_ON(type >= OCFS2_NUM_LOCK_TYPES);\n#endif\n\treturn ocfs2_lock_type_strings[type];\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "level <= DLM_LOCK_NL"
          ],
          "line": 1032
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_get_lockres_osb",
          "args": [
            "lockres"
          ],
          "line": 1028
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_get_lockres_osb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlmglue.c",
          "lines": "332-338",
          "snippet": "static inline struct ocfs2_super *ocfs2_get_lockres_osb(struct ocfs2_lock_res *lockres)\n{\n\tif (lockres->l_ops->get_osb)\n\t\treturn lockres->l_ops->get_osb(lockres);\n\n\treturn (struct ocfs2_super *)lockres->l_priv;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"refcounttree.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"stackglue.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dcache.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2_lockingver.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/time.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/kthread.h>",
            "#include <linux/mm.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct ocfs2_super *ocfs2_get_dentry_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_inode_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_file_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_qinfo_osb(struct ocfs2_lock_res *lockres);",
            "static void ocfs2_set_meta_lvb(struct ocfs2_lock_res *lockres);",
            "static void ocfs2_dentry_post_unlock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres);",
            "static void ocfs2_set_qinfo_lvb(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_downconvert_action(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_convert_action(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_attach_action(struct ocfs2_lock_res *lockres);",
            "static void ocfs2_schedule_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static void ocfs2_downconvert_on_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static int ocfs2_prepare_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\t        struct ocfs2_lock_res *lockres);",
            "static int ocfs2_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static void ocfs2_process_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *lockres);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"stackglue.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dcache.h\"\n#include \"alloc.h\"\n#include \"ocfs2_lockingver.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/quotaops.h>\n#include <linux/time.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/pagemap.h>\n#include <linux/kthread.h>\n#include <linux/mm.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic struct ocfs2_super *ocfs2_get_dentry_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_inode_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_file_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_qinfo_osb(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_set_meta_lvb(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_dentry_post_unlock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres);\nstatic void ocfs2_set_qinfo_lvb(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_downconvert_action(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_convert_action(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_attach_action(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_schedule_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_downconvert_on_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic int ocfs2_prepare_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\t        struct ocfs2_lock_res *lockres);\nstatic int ocfs2_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_process_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *lockres);\n\nstatic inline struct ocfs2_super *ocfs2_get_lockres_osb(struct ocfs2_lock_res *lockres)\n{\n\tif (lockres->l_ops->get_osb)\n\t\treturn lockres->l_ops->get_osb(lockres);\n\n\treturn (struct ocfs2_super *)lockres->l_priv;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_lksb_to_lock_res",
          "args": [
            "lksb"
          ],
          "line": 1027
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_lksb_to_lock_res",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlmglue.c",
          "lines": "300-303",
          "snippet": "static inline struct ocfs2_lock_res *ocfs2_lksb_to_lock_res(struct ocfs2_dlm_lksb *lksb)\n{\n\treturn container_of(lksb, struct ocfs2_lock_res, l_lksb);\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"refcounttree.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"stackglue.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dcache.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2_lockingver.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/time.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/kthread.h>",
            "#include <linux/mm.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"stackglue.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dcache.h\"\n#include \"alloc.h\"\n#include \"ocfs2_lockingver.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/quotaops.h>\n#include <linux/time.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/pagemap.h>\n#include <linux/kthread.h>\n#include <linux/mm.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic inline struct ocfs2_lock_res *ocfs2_lksb_to_lock_res(struct ocfs2_dlm_lksb *lksb)\n{\n\treturn container_of(lksb, struct ocfs2_lock_res, l_lksb);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"stackglue.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dcache.h\"\n#include \"alloc.h\"\n#include \"ocfs2_lockingver.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/quotaops.h>\n#include <linux/time.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/pagemap.h>\n#include <linux/kthread.h>\n#include <linux/mm.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic struct ocfs2_super *ocfs2_get_dentry_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_inode_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_file_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_qinfo_osb(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_set_meta_lvb(struct ocfs2_lock_res *lockres);\nstatic int ocfs2_data_convert_worker(struct ocfs2_lock_res *lockres,\n\t\t\t\t     int blocking);\nstatic int ocfs2_dentry_convert_worker(struct ocfs2_lock_res *lockres,\n\t\t\t\t       int blocking);\nstatic void ocfs2_dentry_post_unlock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres);\nstatic void ocfs2_set_qinfo_lvb(struct ocfs2_lock_res *lockres);\nstatic int ocfs2_refcount_convert_worker(struct ocfs2_lock_res *lockres,\n\t\t\t\t\t int blocking);\nstatic inline void ocfs2_generic_handle_downconvert_action(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_convert_action(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_attach_action(struct ocfs2_lock_res *lockres);\nstatic int ocfs2_generic_handle_bast(struct ocfs2_lock_res *lockres, int level);\nstatic void ocfs2_schedule_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_downconvert_on_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_drop_osb_locks(struct ocfs2_super *osb);\nstatic inline int ocfs2_highest_compat_lock_level(int level);\nstatic int ocfs2_prepare_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\t        struct ocfs2_lock_res *lockres);\nstatic int ocfs2_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_process_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *lockres);\n\nstatic void ocfs2_blocking_ast(struct ocfs2_dlm_lksb *lksb, int level)\n{\n\tstruct ocfs2_lock_res *lockres = ocfs2_lksb_to_lock_res(lksb);\n\tstruct ocfs2_super *osb = ocfs2_get_lockres_osb(lockres);\n\tint needs_downconvert;\n\tunsigned long flags;\n\n\tBUG_ON(level <= DLM_LOCK_NL);\n\n\tmlog(ML_BASTS, \"BAST fired for lockres %s, blocking %d, level %d, \"\n\t     \"type %s\\n\", lockres->l_name, level, lockres->l_level,\n\t     ocfs2_lock_type_string(lockres->l_type));\n\n\t/*\n\t * We can skip the bast for locks which don't enable caching -\n\t * they'll be dropped at the earliest possible time anyway.\n\t */\n\tif (lockres->l_flags & OCFS2_LOCK_NOCACHE)\n\t\treturn;\n\n\tspin_lock_irqsave(&lockres->l_lock, flags);\n\tneeds_downconvert = ocfs2_generic_handle_bast(lockres, level);\n\tif (needs_downconvert)\n\t\tocfs2_schedule_blocked_lock(osb, lockres);\n\tspin_unlock_irqrestore(&lockres->l_lock, flags);\n\n\twake_up(&lockres->l_event);\n\n\tocfs2_wake_downconvert_thread(osb);\n}"
  },
  {
    "function_name": "lockres_set_pending",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlmglue.c",
    "lines": "1015-1023",
    "snippet": "static unsigned int lockres_set_pending(struct ocfs2_lock_res *lockres)\n{\n\tassert_spin_locked(&lockres->l_lock);\n\tBUG_ON(!(lockres->l_flags & OCFS2_LOCK_BUSY));\n\n\tlockres_or_flags(lockres, OCFS2_LOCK_PENDING);\n\n\treturn lockres->l_pending_gen;\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"refcounttree.h\"",
      "#include \"quota.h\"",
      "#include \"uptodate.h\"",
      "#include \"super.h\"",
      "#include \"slot_map.h\"",
      "#include \"stackglue.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"heartbeat.h\"",
      "#include \"file.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"dcache.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2_lockingver.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/time.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/kthread.h>",
      "#include <linux/mm.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct ocfs2_super *ocfs2_get_dentry_osb(struct ocfs2_lock_res *lockres);",
      "static struct ocfs2_super *ocfs2_get_inode_osb(struct ocfs2_lock_res *lockres);",
      "static struct ocfs2_super *ocfs2_get_file_osb(struct ocfs2_lock_res *lockres);",
      "static struct ocfs2_super *ocfs2_get_qinfo_osb(struct ocfs2_lock_res *lockres);",
      "static void ocfs2_set_meta_lvb(struct ocfs2_lock_res *lockres);",
      "static void ocfs2_dentry_post_unlock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres);",
      "static void ocfs2_set_qinfo_lvb(struct ocfs2_lock_res *lockres);",
      "static inline void ocfs2_generic_handle_downconvert_action(struct ocfs2_lock_res *lockres);",
      "static inline void ocfs2_generic_handle_convert_action(struct ocfs2_lock_res *lockres);",
      "static inline void ocfs2_generic_handle_attach_action(struct ocfs2_lock_res *lockres);",
      "static void ocfs2_schedule_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);",
      "static void ocfs2_downconvert_on_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);",
      "static int ocfs2_prepare_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\t        struct ocfs2_lock_res *lockres);",
      "static int ocfs2_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres);",
      "static void ocfs2_process_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *lockres);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "lockres_or_flags",
          "args": [
            "lockres",
            "OCFS2_LOCK_PENDING"
          ],
          "line": 1020
        },
        "resolved": true,
        "details": {
          "function_name": "lockres_or_flags",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlmglue.c",
          "lines": "819-822",
          "snippet": "static void lockres_or_flags(struct ocfs2_lock_res *lockres, unsigned long or)\n{\n\tlockres_set_flags(lockres, lockres->l_flags | or);\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"refcounttree.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"stackglue.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dcache.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2_lockingver.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/time.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/kthread.h>",
            "#include <linux/mm.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct ocfs2_super *ocfs2_get_dentry_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_inode_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_file_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_qinfo_osb(struct ocfs2_lock_res *lockres);",
            "static void ocfs2_set_meta_lvb(struct ocfs2_lock_res *lockres);",
            "static void ocfs2_dentry_post_unlock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres);",
            "static void ocfs2_set_qinfo_lvb(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_downconvert_action(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_convert_action(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_attach_action(struct ocfs2_lock_res *lockres);",
            "static void ocfs2_schedule_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static void ocfs2_downconvert_on_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static int ocfs2_prepare_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\t        struct ocfs2_lock_res *lockres);",
            "static int ocfs2_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static void ocfs2_process_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *lockres);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"stackglue.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dcache.h\"\n#include \"alloc.h\"\n#include \"ocfs2_lockingver.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/quotaops.h>\n#include <linux/time.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/pagemap.h>\n#include <linux/kthread.h>\n#include <linux/mm.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic struct ocfs2_super *ocfs2_get_dentry_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_inode_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_file_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_qinfo_osb(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_set_meta_lvb(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_dentry_post_unlock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres);\nstatic void ocfs2_set_qinfo_lvb(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_downconvert_action(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_convert_action(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_attach_action(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_schedule_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_downconvert_on_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic int ocfs2_prepare_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\t        struct ocfs2_lock_res *lockres);\nstatic int ocfs2_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_process_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *lockres);\n\nstatic void lockres_or_flags(struct ocfs2_lock_res *lockres, unsigned long or)\n{\n\tlockres_set_flags(lockres, lockres->l_flags | or);\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!(lockres->l_flags & OCFS2_LOCK_BUSY)"
          ],
          "line": 1018
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "assert_spin_locked",
          "args": [
            "&lockres->l_lock"
          ],
          "line": 1017
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"stackglue.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dcache.h\"\n#include \"alloc.h\"\n#include \"ocfs2_lockingver.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/quotaops.h>\n#include <linux/time.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/pagemap.h>\n#include <linux/kthread.h>\n#include <linux/mm.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic struct ocfs2_super *ocfs2_get_dentry_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_inode_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_file_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_qinfo_osb(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_set_meta_lvb(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_dentry_post_unlock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres);\nstatic void ocfs2_set_qinfo_lvb(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_downconvert_action(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_convert_action(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_attach_action(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_schedule_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_downconvert_on_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic int ocfs2_prepare_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\t        struct ocfs2_lock_res *lockres);\nstatic int ocfs2_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_process_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *lockres);\n\nstatic unsigned int lockres_set_pending(struct ocfs2_lock_res *lockres)\n{\n\tassert_spin_locked(&lockres->l_lock);\n\tBUG_ON(!(lockres->l_flags & OCFS2_LOCK_BUSY));\n\n\tlockres_or_flags(lockres, OCFS2_LOCK_PENDING);\n\n\treturn lockres->l_pending_gen;\n}"
  },
  {
    "function_name": "lockres_clear_pending",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlmglue.c",
    "lines": "1004-1013",
    "snippet": "static void lockres_clear_pending(struct ocfs2_lock_res *lockres,\n\t\t\t\t  unsigned int generation,\n\t\t\t\t  struct ocfs2_super *osb)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&lockres->l_lock, flags);\n\t__lockres_clear_pending(lockres, generation, osb);\n\tspin_unlock_irqrestore(&lockres->l_lock, flags);\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"refcounttree.h\"",
      "#include \"quota.h\"",
      "#include \"uptodate.h\"",
      "#include \"super.h\"",
      "#include \"slot_map.h\"",
      "#include \"stackglue.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"heartbeat.h\"",
      "#include \"file.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"dcache.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2_lockingver.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/time.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/kthread.h>",
      "#include <linux/mm.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct ocfs2_super *ocfs2_get_dentry_osb(struct ocfs2_lock_res *lockres);",
      "static struct ocfs2_super *ocfs2_get_inode_osb(struct ocfs2_lock_res *lockres);",
      "static struct ocfs2_super *ocfs2_get_file_osb(struct ocfs2_lock_res *lockres);",
      "static struct ocfs2_super *ocfs2_get_qinfo_osb(struct ocfs2_lock_res *lockres);",
      "static void ocfs2_set_meta_lvb(struct ocfs2_lock_res *lockres);",
      "static void ocfs2_dentry_post_unlock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres);",
      "static void ocfs2_set_qinfo_lvb(struct ocfs2_lock_res *lockres);",
      "static inline void ocfs2_generic_handle_downconvert_action(struct ocfs2_lock_res *lockres);",
      "static inline void ocfs2_generic_handle_convert_action(struct ocfs2_lock_res *lockres);",
      "static inline void ocfs2_generic_handle_attach_action(struct ocfs2_lock_res *lockres);",
      "static void ocfs2_schedule_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);",
      "static void ocfs2_downconvert_on_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);",
      "static void ocfs2_drop_osb_locks(struct ocfs2_super *osb);",
      "static int ocfs2_downconvert_lock(struct ocfs2_super *osb,\n\t\t\t\t  struct ocfs2_lock_res *lockres,\n\t\t\t\t  int new_level,\n\t\t\t\t  int lvb,\n\t\t\t\t  unsigned int generation);",
      "static int ocfs2_prepare_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\t        struct ocfs2_lock_res *lockres);",
      "static int ocfs2_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres);",
      "static void ocfs2_process_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *lockres);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock_irqrestore",
          "args": [
            "&lockres->l_lock",
            "flags"
          ],
          "line": 1012
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__lockres_clear_pending",
          "args": [
            "lockres",
            "generation",
            "osb"
          ],
          "line": 1011
        },
        "resolved": true,
        "details": {
          "function_name": "__lockres_clear_pending",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlmglue.c",
          "lines": "978-1001",
          "snippet": "static void __lockres_clear_pending(struct ocfs2_lock_res *lockres,\n\t\t\t\t    unsigned int generation,\n\t\t\t\t    struct ocfs2_super *osb)\n{\n\tassert_spin_locked(&lockres->l_lock);\n\n\t/*\n\t * The ast and locking functions can race us here.  The winner\n\t * will clear pending, the loser will not.\n\t */\n\tif (!(lockres->l_flags & OCFS2_LOCK_PENDING) ||\n\t    (lockres->l_pending_gen != generation))\n\t\treturn;\n\n\tlockres_clear_flags(lockres, OCFS2_LOCK_PENDING);\n\tlockres->l_pending_gen++;\n\n\t/*\n\t * The downconvert thread may have skipped us because we\n\t * were PENDING.  Wake it up.\n\t */\n\tif (lockres->l_flags & OCFS2_LOCK_BLOCKED)\n\t\tocfs2_wake_downconvert_thread(osb);\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"refcounttree.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"stackglue.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dcache.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2_lockingver.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/time.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/kthread.h>",
            "#include <linux/mm.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct ocfs2_super *ocfs2_get_dentry_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_inode_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_file_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_qinfo_osb(struct ocfs2_lock_res *lockres);",
            "static void ocfs2_set_meta_lvb(struct ocfs2_lock_res *lockres);",
            "static void ocfs2_dentry_post_unlock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres);",
            "static void ocfs2_set_qinfo_lvb(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_downconvert_action(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_convert_action(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_attach_action(struct ocfs2_lock_res *lockres);",
            "static void ocfs2_schedule_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static void ocfs2_downconvert_on_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static void ocfs2_drop_osb_locks(struct ocfs2_super *osb);",
            "static int ocfs2_downconvert_lock(struct ocfs2_super *osb,\n\t\t\t\t  struct ocfs2_lock_res *lockres,\n\t\t\t\t  int new_level,\n\t\t\t\t  int lvb,\n\t\t\t\t  unsigned int generation);",
            "static int ocfs2_prepare_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\t        struct ocfs2_lock_res *lockres);",
            "static int ocfs2_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static void ocfs2_process_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *lockres);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"stackglue.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dcache.h\"\n#include \"alloc.h\"\n#include \"ocfs2_lockingver.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/quotaops.h>\n#include <linux/time.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/pagemap.h>\n#include <linux/kthread.h>\n#include <linux/mm.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic struct ocfs2_super *ocfs2_get_dentry_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_inode_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_file_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_qinfo_osb(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_set_meta_lvb(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_dentry_post_unlock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres);\nstatic void ocfs2_set_qinfo_lvb(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_downconvert_action(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_convert_action(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_attach_action(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_schedule_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_downconvert_on_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_drop_osb_locks(struct ocfs2_super *osb);\nstatic int ocfs2_downconvert_lock(struct ocfs2_super *osb,\n\t\t\t\t  struct ocfs2_lock_res *lockres,\n\t\t\t\t  int new_level,\n\t\t\t\t  int lvb,\n\t\t\t\t  unsigned int generation);\nstatic int ocfs2_prepare_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\t        struct ocfs2_lock_res *lockres);\nstatic int ocfs2_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_process_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *lockres);\n\nstatic void __lockres_clear_pending(struct ocfs2_lock_res *lockres,\n\t\t\t\t    unsigned int generation,\n\t\t\t\t    struct ocfs2_super *osb)\n{\n\tassert_spin_locked(&lockres->l_lock);\n\n\t/*\n\t * The ast and locking functions can race us here.  The winner\n\t * will clear pending, the loser will not.\n\t */\n\tif (!(lockres->l_flags & OCFS2_LOCK_PENDING) ||\n\t    (lockres->l_pending_gen != generation))\n\t\treturn;\n\n\tlockres_clear_flags(lockres, OCFS2_LOCK_PENDING);\n\tlockres->l_pending_gen++;\n\n\t/*\n\t * The downconvert thread may have skipped us because we\n\t * were PENDING.  Wake it up.\n\t */\n\tif (lockres->l_flags & OCFS2_LOCK_BLOCKED)\n\t\tocfs2_wake_downconvert_thread(osb);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock_irqsave",
          "args": [
            "&lockres->l_lock",
            "flags"
          ],
          "line": 1010
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"stackglue.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dcache.h\"\n#include \"alloc.h\"\n#include \"ocfs2_lockingver.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/quotaops.h>\n#include <linux/time.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/pagemap.h>\n#include <linux/kthread.h>\n#include <linux/mm.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic struct ocfs2_super *ocfs2_get_dentry_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_inode_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_file_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_qinfo_osb(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_set_meta_lvb(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_dentry_post_unlock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres);\nstatic void ocfs2_set_qinfo_lvb(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_downconvert_action(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_convert_action(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_attach_action(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_schedule_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_downconvert_on_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_drop_osb_locks(struct ocfs2_super *osb);\nstatic int ocfs2_downconvert_lock(struct ocfs2_super *osb,\n\t\t\t\t  struct ocfs2_lock_res *lockres,\n\t\t\t\t  int new_level,\n\t\t\t\t  int lvb,\n\t\t\t\t  unsigned int generation);\nstatic int ocfs2_prepare_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\t        struct ocfs2_lock_res *lockres);\nstatic int ocfs2_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_process_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *lockres);\n\nstatic void lockres_clear_pending(struct ocfs2_lock_res *lockres,\n\t\t\t\t  unsigned int generation,\n\t\t\t\t  struct ocfs2_super *osb)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&lockres->l_lock, flags);\n\t__lockres_clear_pending(lockres, generation, osb);\n\tspin_unlock_irqrestore(&lockres->l_lock, flags);\n}"
  },
  {
    "function_name": "__lockres_clear_pending",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlmglue.c",
    "lines": "978-1001",
    "snippet": "static void __lockres_clear_pending(struct ocfs2_lock_res *lockres,\n\t\t\t\t    unsigned int generation,\n\t\t\t\t    struct ocfs2_super *osb)\n{\n\tassert_spin_locked(&lockres->l_lock);\n\n\t/*\n\t * The ast and locking functions can race us here.  The winner\n\t * will clear pending, the loser will not.\n\t */\n\tif (!(lockres->l_flags & OCFS2_LOCK_PENDING) ||\n\t    (lockres->l_pending_gen != generation))\n\t\treturn;\n\n\tlockres_clear_flags(lockres, OCFS2_LOCK_PENDING);\n\tlockres->l_pending_gen++;\n\n\t/*\n\t * The downconvert thread may have skipped us because we\n\t * were PENDING.  Wake it up.\n\t */\n\tif (lockres->l_flags & OCFS2_LOCK_BLOCKED)\n\t\tocfs2_wake_downconvert_thread(osb);\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"refcounttree.h\"",
      "#include \"quota.h\"",
      "#include \"uptodate.h\"",
      "#include \"super.h\"",
      "#include \"slot_map.h\"",
      "#include \"stackglue.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"heartbeat.h\"",
      "#include \"file.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"dcache.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2_lockingver.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/time.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/kthread.h>",
      "#include <linux/mm.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct ocfs2_super *ocfs2_get_dentry_osb(struct ocfs2_lock_res *lockres);",
      "static struct ocfs2_super *ocfs2_get_inode_osb(struct ocfs2_lock_res *lockres);",
      "static struct ocfs2_super *ocfs2_get_file_osb(struct ocfs2_lock_res *lockres);",
      "static struct ocfs2_super *ocfs2_get_qinfo_osb(struct ocfs2_lock_res *lockres);",
      "static void ocfs2_set_meta_lvb(struct ocfs2_lock_res *lockres);",
      "static void ocfs2_dentry_post_unlock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres);",
      "static void ocfs2_set_qinfo_lvb(struct ocfs2_lock_res *lockres);",
      "static inline void ocfs2_generic_handle_downconvert_action(struct ocfs2_lock_res *lockres);",
      "static inline void ocfs2_generic_handle_convert_action(struct ocfs2_lock_res *lockres);",
      "static inline void ocfs2_generic_handle_attach_action(struct ocfs2_lock_res *lockres);",
      "static void ocfs2_schedule_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);",
      "static void ocfs2_downconvert_on_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);",
      "static void ocfs2_drop_osb_locks(struct ocfs2_super *osb);",
      "static int ocfs2_downconvert_lock(struct ocfs2_super *osb,\n\t\t\t\t  struct ocfs2_lock_res *lockres,\n\t\t\t\t  int new_level,\n\t\t\t\t  int lvb,\n\t\t\t\t  unsigned int generation);",
      "static int ocfs2_prepare_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\t        struct ocfs2_lock_res *lockres);",
      "static int ocfs2_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres);",
      "static void ocfs2_process_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *lockres);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ocfs2_wake_downconvert_thread",
          "args": [
            "osb"
          ],
          "line": 1000
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_wake_downconvert_thread",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlmglue.c",
          "lines": "4091-4101",
          "snippet": "void ocfs2_wake_downconvert_thread(struct ocfs2_super *osb)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&osb->dc_task_lock, flags);\n\t/* make sure the voting thread gets a swipe at whatever changes\n\t * the caller may have made to the voting state */\n\tosb->dc_wake_sequence++;\n\tspin_unlock_irqrestore(&osb->dc_task_lock, flags);\n\twake_up(&osb->dc_event);\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"refcounttree.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"stackglue.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dcache.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2_lockingver.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/time.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/kthread.h>",
            "#include <linux/mm.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void ocfs2_drop_osb_locks(struct ocfs2_super *osb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"stackglue.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dcache.h\"\n#include \"alloc.h\"\n#include \"ocfs2_lockingver.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/quotaops.h>\n#include <linux/time.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/pagemap.h>\n#include <linux/kthread.h>\n#include <linux/mm.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic void ocfs2_drop_osb_locks(struct ocfs2_super *osb);\n\nvoid ocfs2_wake_downconvert_thread(struct ocfs2_super *osb)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&osb->dc_task_lock, flags);\n\t/* make sure the voting thread gets a swipe at whatever changes\n\t * the caller may have made to the voting state */\n\tosb->dc_wake_sequence++;\n\tspin_unlock_irqrestore(&osb->dc_task_lock, flags);\n\twake_up(&osb->dc_event);\n}"
        }
      },
      {
        "call_info": {
          "callee": "lockres_clear_flags",
          "args": [
            "lockres",
            "OCFS2_LOCK_PENDING"
          ],
          "line": 992
        },
        "resolved": true,
        "details": {
          "function_name": "lockres_clear_flags",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlmglue.c",
          "lines": "823-827",
          "snippet": "static void lockres_clear_flags(struct ocfs2_lock_res *lockres,\n\t\t\t\tunsigned long clear)\n{\n\tlockres_set_flags(lockres, lockres->l_flags & ~clear);\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"refcounttree.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"stackglue.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dcache.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2_lockingver.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/time.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/kthread.h>",
            "#include <linux/mm.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct ocfs2_super *ocfs2_get_dentry_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_inode_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_file_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_qinfo_osb(struct ocfs2_lock_res *lockres);",
            "static void ocfs2_set_meta_lvb(struct ocfs2_lock_res *lockres);",
            "static void ocfs2_dentry_post_unlock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres);",
            "static void ocfs2_set_qinfo_lvb(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_downconvert_action(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_convert_action(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_attach_action(struct ocfs2_lock_res *lockres);",
            "static void ocfs2_schedule_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static void ocfs2_downconvert_on_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static int ocfs2_prepare_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\t        struct ocfs2_lock_res *lockres);",
            "static int ocfs2_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static void ocfs2_process_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *lockres);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"stackglue.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dcache.h\"\n#include \"alloc.h\"\n#include \"ocfs2_lockingver.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/quotaops.h>\n#include <linux/time.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/pagemap.h>\n#include <linux/kthread.h>\n#include <linux/mm.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic struct ocfs2_super *ocfs2_get_dentry_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_inode_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_file_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_qinfo_osb(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_set_meta_lvb(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_dentry_post_unlock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres);\nstatic void ocfs2_set_qinfo_lvb(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_downconvert_action(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_convert_action(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_attach_action(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_schedule_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_downconvert_on_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic int ocfs2_prepare_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\t        struct ocfs2_lock_res *lockres);\nstatic int ocfs2_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_process_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *lockres);\n\nstatic void lockres_clear_flags(struct ocfs2_lock_res *lockres,\n\t\t\t\tunsigned long clear)\n{\n\tlockres_set_flags(lockres, lockres->l_flags & ~clear);\n}"
        }
      },
      {
        "call_info": {
          "callee": "assert_spin_locked",
          "args": [
            "&lockres->l_lock"
          ],
          "line": 982
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"stackglue.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dcache.h\"\n#include \"alloc.h\"\n#include \"ocfs2_lockingver.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/quotaops.h>\n#include <linux/time.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/pagemap.h>\n#include <linux/kthread.h>\n#include <linux/mm.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic struct ocfs2_super *ocfs2_get_dentry_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_inode_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_file_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_qinfo_osb(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_set_meta_lvb(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_dentry_post_unlock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres);\nstatic void ocfs2_set_qinfo_lvb(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_downconvert_action(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_convert_action(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_attach_action(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_schedule_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_downconvert_on_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_drop_osb_locks(struct ocfs2_super *osb);\nstatic int ocfs2_downconvert_lock(struct ocfs2_super *osb,\n\t\t\t\t  struct ocfs2_lock_res *lockres,\n\t\t\t\t  int new_level,\n\t\t\t\t  int lvb,\n\t\t\t\t  unsigned int generation);\nstatic int ocfs2_prepare_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\t        struct ocfs2_lock_res *lockres);\nstatic int ocfs2_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_process_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *lockres);\n\nstatic void __lockres_clear_pending(struct ocfs2_lock_res *lockres,\n\t\t\t\t    unsigned int generation,\n\t\t\t\t    struct ocfs2_super *osb)\n{\n\tassert_spin_locked(&lockres->l_lock);\n\n\t/*\n\t * The ast and locking functions can race us here.  The winner\n\t * will clear pending, the loser will not.\n\t */\n\tif (!(lockres->l_flags & OCFS2_LOCK_PENDING) ||\n\t    (lockres->l_pending_gen != generation))\n\t\treturn;\n\n\tlockres_clear_flags(lockres, OCFS2_LOCK_PENDING);\n\tlockres->l_pending_gen++;\n\n\t/*\n\t * The downconvert thread may have skipped us because we\n\t * were PENDING.  Wake it up.\n\t */\n\tif (lockres->l_flags & OCFS2_LOCK_BLOCKED)\n\t\tocfs2_wake_downconvert_thread(osb);\n}"
  },
  {
    "function_name": "ocfs2_generic_handle_bast",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlmglue.c",
    "lines": "890-917",
    "snippet": "static int ocfs2_generic_handle_bast(struct ocfs2_lock_res *lockres,\n\t\t\t\t     int level)\n{\n\tint needs_downconvert = 0;\n\n\tassert_spin_locked(&lockres->l_lock);\n\n\tif (level > lockres->l_blocking) {\n\t\t/* only schedule a downconvert if we haven't already scheduled\n\t\t * one that goes low enough to satisfy the level we're\n\t\t * blocking.  this also catches the case where we get\n\t\t * duplicate BASTs */\n\t\tif (ocfs2_highest_compat_lock_level(level) <\n\t\t    ocfs2_highest_compat_lock_level(lockres->l_blocking))\n\t\t\tneeds_downconvert = 1;\n\n\t\tlockres->l_blocking = level;\n\t}\n\n\tmlog(ML_BASTS, \"lockres %s, block %d, level %d, l_block %d, dwn %d\\n\",\n\t     lockres->l_name, level, lockres->l_level, lockres->l_blocking,\n\t     needs_downconvert);\n\n\tif (needs_downconvert)\n\t\tlockres_or_flags(lockres, OCFS2_LOCK_BLOCKED);\n\tmlog(0, \"needs_downconvert = %d\\n\", needs_downconvert);\n\treturn needs_downconvert;\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"refcounttree.h\"",
      "#include \"quota.h\"",
      "#include \"uptodate.h\"",
      "#include \"super.h\"",
      "#include \"slot_map.h\"",
      "#include \"stackglue.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"heartbeat.h\"",
      "#include \"file.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"dcache.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2_lockingver.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/time.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/kthread.h>",
      "#include <linux/mm.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct ocfs2_super *ocfs2_get_dentry_osb(struct ocfs2_lock_res *lockres);",
      "static struct ocfs2_super *ocfs2_get_inode_osb(struct ocfs2_lock_res *lockres);",
      "static struct ocfs2_super *ocfs2_get_file_osb(struct ocfs2_lock_res *lockres);",
      "static struct ocfs2_super *ocfs2_get_qinfo_osb(struct ocfs2_lock_res *lockres);",
      "static void ocfs2_set_meta_lvb(struct ocfs2_lock_res *lockres);",
      "static int ocfs2_data_convert_worker(struct ocfs2_lock_res *lockres,\n\t\t\t\t     int blocking);",
      "static int ocfs2_dentry_convert_worker(struct ocfs2_lock_res *lockres,\n\t\t\t\t       int blocking);",
      "static void ocfs2_dentry_post_unlock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres);",
      "static void ocfs2_set_qinfo_lvb(struct ocfs2_lock_res *lockres);",
      "static int ocfs2_refcount_convert_worker(struct ocfs2_lock_res *lockres,\n\t\t\t\t\t int blocking);",
      "static inline void ocfs2_generic_handle_downconvert_action(struct ocfs2_lock_res *lockres);",
      "static inline void ocfs2_generic_handle_convert_action(struct ocfs2_lock_res *lockres);",
      "static inline void ocfs2_generic_handle_attach_action(struct ocfs2_lock_res *lockres);",
      "static int ocfs2_generic_handle_bast(struct ocfs2_lock_res *lockres, int level);",
      "static void ocfs2_schedule_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);",
      "static void ocfs2_downconvert_on_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);",
      "static inline int ocfs2_highest_compat_lock_level(int level);",
      "static int ocfs2_prepare_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\t        struct ocfs2_lock_res *lockres);",
      "static int ocfs2_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres);",
      "static void ocfs2_process_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *lockres);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mlog",
          "args": [
            "0",
            "\"needs_downconvert = %d\\n\"",
            "needs_downconvert"
          ],
          "line": 915
        },
        "resolved": true,
        "details": {
          "function_name": "mlog_show",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/cluster/masklog.c",
          "lines": "107-113",
          "snippet": "static ssize_t mlog_show(struct kobject *obj, struct attribute *attr,\n\t\t\t char *buf)\n{\n\tstruct mlog_attribute *mlog_attr = to_mlog_attr(attr);\n\n\treturn mlog_mask_show(mlog_attr->mask, buf);\n}",
          "includes": [
            "#include \"masklog.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/string.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"masklog.h\"\n#include <asm/uaccess.h>\n#include <linux/string.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n\nstatic ssize_t mlog_show(struct kobject *obj, struct attribute *attr,\n\t\t\t char *buf)\n{\n\tstruct mlog_attribute *mlog_attr = to_mlog_attr(attr);\n\n\treturn mlog_mask_show(mlog_attr->mask, buf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "lockres_or_flags",
          "args": [
            "lockres",
            "OCFS2_LOCK_BLOCKED"
          ],
          "line": 914
        },
        "resolved": true,
        "details": {
          "function_name": "lockres_or_flags",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlmglue.c",
          "lines": "819-822",
          "snippet": "static void lockres_or_flags(struct ocfs2_lock_res *lockres, unsigned long or)\n{\n\tlockres_set_flags(lockres, lockres->l_flags | or);\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"refcounttree.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"stackglue.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dcache.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2_lockingver.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/time.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/kthread.h>",
            "#include <linux/mm.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct ocfs2_super *ocfs2_get_dentry_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_inode_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_file_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_qinfo_osb(struct ocfs2_lock_res *lockres);",
            "static void ocfs2_set_meta_lvb(struct ocfs2_lock_res *lockres);",
            "static void ocfs2_dentry_post_unlock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres);",
            "static void ocfs2_set_qinfo_lvb(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_downconvert_action(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_convert_action(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_attach_action(struct ocfs2_lock_res *lockres);",
            "static void ocfs2_schedule_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static void ocfs2_downconvert_on_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static int ocfs2_prepare_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\t        struct ocfs2_lock_res *lockres);",
            "static int ocfs2_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static void ocfs2_process_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *lockres);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"stackglue.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dcache.h\"\n#include \"alloc.h\"\n#include \"ocfs2_lockingver.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/quotaops.h>\n#include <linux/time.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/pagemap.h>\n#include <linux/kthread.h>\n#include <linux/mm.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic struct ocfs2_super *ocfs2_get_dentry_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_inode_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_file_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_qinfo_osb(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_set_meta_lvb(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_dentry_post_unlock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres);\nstatic void ocfs2_set_qinfo_lvb(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_downconvert_action(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_convert_action(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_attach_action(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_schedule_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_downconvert_on_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic int ocfs2_prepare_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\t        struct ocfs2_lock_res *lockres);\nstatic int ocfs2_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_process_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *lockres);\n\nstatic void lockres_or_flags(struct ocfs2_lock_res *lockres, unsigned long or)\n{\n\tlockres_set_flags(lockres, lockres->l_flags | or);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog",
          "args": [
            "ML_BASTS",
            "\"lockres %s, block %d, level %d, l_block %d, dwn %d\\n\"",
            "lockres->l_name",
            "level",
            "lockres->l_level",
            "lockres->l_blocking",
            "needs_downconvert"
          ],
          "line": 909
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_highest_compat_lock_level",
          "args": [
            "lockres->l_blocking"
          ],
          "line": 903
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_highest_compat_lock_level",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlmglue.c",
          "lines": "790-799",
          "snippet": "static inline int ocfs2_highest_compat_lock_level(int level)\n{\n\tint new_level = DLM_LOCK_EX;\n\n\tif (level == DLM_LOCK_EX)\n\t\tnew_level = DLM_LOCK_NL;\n\telse if (level == DLM_LOCK_PR)\n\t\tnew_level = DLM_LOCK_PR;\n\treturn new_level;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"refcounttree.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"stackglue.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dcache.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2_lockingver.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/time.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/kthread.h>",
            "#include <linux/mm.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ocfs2_check_meta_downconvert(struct ocfs2_lock_res *lockres,\n\t\t\t\t\tint new_level);",
            "static int ocfs2_check_refcount_downconvert(struct ocfs2_lock_res *lockres,\n\t\t\t\t\t    int new_level);",
            "static int ocfs2_generic_handle_bast(struct ocfs2_lock_res *lockres, int level);",
            "static inline int ocfs2_highest_compat_lock_level(int level);",
            "static unsigned int ocfs2_prepare_downconvert(struct ocfs2_lock_res *lockres,\n\t\t\t\t\t      int new_level);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"stackglue.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dcache.h\"\n#include \"alloc.h\"\n#include \"ocfs2_lockingver.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/quotaops.h>\n#include <linux/time.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/pagemap.h>\n#include <linux/kthread.h>\n#include <linux/mm.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic int ocfs2_check_meta_downconvert(struct ocfs2_lock_res *lockres,\n\t\t\t\t\tint new_level);\nstatic int ocfs2_check_refcount_downconvert(struct ocfs2_lock_res *lockres,\n\t\t\t\t\t    int new_level);\nstatic int ocfs2_generic_handle_bast(struct ocfs2_lock_res *lockres, int level);\nstatic inline int ocfs2_highest_compat_lock_level(int level);\nstatic unsigned int ocfs2_prepare_downconvert(struct ocfs2_lock_res *lockres,\n\t\t\t\t\t      int new_level);\n\nstatic inline int ocfs2_highest_compat_lock_level(int level)\n{\n\tint new_level = DLM_LOCK_EX;\n\n\tif (level == DLM_LOCK_EX)\n\t\tnew_level = DLM_LOCK_NL;\n\telse if (level == DLM_LOCK_PR)\n\t\tnew_level = DLM_LOCK_PR;\n\treturn new_level;\n}"
        }
      },
      {
        "call_info": {
          "callee": "assert_spin_locked",
          "args": [
            "&lockres->l_lock"
          ],
          "line": 895
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"stackglue.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dcache.h\"\n#include \"alloc.h\"\n#include \"ocfs2_lockingver.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/quotaops.h>\n#include <linux/time.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/pagemap.h>\n#include <linux/kthread.h>\n#include <linux/mm.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic struct ocfs2_super *ocfs2_get_dentry_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_inode_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_file_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_qinfo_osb(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_set_meta_lvb(struct ocfs2_lock_res *lockres);\nstatic int ocfs2_data_convert_worker(struct ocfs2_lock_res *lockres,\n\t\t\t\t     int blocking);\nstatic int ocfs2_dentry_convert_worker(struct ocfs2_lock_res *lockres,\n\t\t\t\t       int blocking);\nstatic void ocfs2_dentry_post_unlock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres);\nstatic void ocfs2_set_qinfo_lvb(struct ocfs2_lock_res *lockres);\nstatic int ocfs2_refcount_convert_worker(struct ocfs2_lock_res *lockres,\n\t\t\t\t\t int blocking);\nstatic inline void ocfs2_generic_handle_downconvert_action(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_convert_action(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_attach_action(struct ocfs2_lock_res *lockres);\nstatic int ocfs2_generic_handle_bast(struct ocfs2_lock_res *lockres, int level);\nstatic void ocfs2_schedule_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_downconvert_on_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic inline int ocfs2_highest_compat_lock_level(int level);\nstatic int ocfs2_prepare_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\t        struct ocfs2_lock_res *lockres);\nstatic int ocfs2_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_process_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *lockres);\n\nstatic int ocfs2_generic_handle_bast(struct ocfs2_lock_res *lockres,\n\t\t\t\t     int level)\n{\n\tint needs_downconvert = 0;\n\n\tassert_spin_locked(&lockres->l_lock);\n\n\tif (level > lockres->l_blocking) {\n\t\t/* only schedule a downconvert if we haven't already scheduled\n\t\t * one that goes low enough to satisfy the level we're\n\t\t * blocking.  this also catches the case where we get\n\t\t * duplicate BASTs */\n\t\tif (ocfs2_highest_compat_lock_level(level) <\n\t\t    ocfs2_highest_compat_lock_level(lockres->l_blocking))\n\t\t\tneeds_downconvert = 1;\n\n\t\tlockres->l_blocking = level;\n\t}\n\n\tmlog(ML_BASTS, \"lockres %s, block %d, level %d, l_block %d, dwn %d\\n\",\n\t     lockres->l_name, level, lockres->l_level, lockres->l_blocking,\n\t     needs_downconvert);\n\n\tif (needs_downconvert)\n\t\tlockres_or_flags(lockres, OCFS2_LOCK_BLOCKED);\n\tmlog(0, \"needs_downconvert = %d\\n\", needs_downconvert);\n\treturn needs_downconvert;\n}"
  },
  {
    "function_name": "ocfs2_generic_handle_attach_action",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlmglue.c",
    "lines": "875-888",
    "snippet": "static inline void ocfs2_generic_handle_attach_action(struct ocfs2_lock_res *lockres)\n{\n\tBUG_ON((!(lockres->l_flags & OCFS2_LOCK_BUSY)));\n\tBUG_ON(lockres->l_flags & OCFS2_LOCK_ATTACHED);\n\n\tif (lockres->l_requested > DLM_LOCK_NL &&\n\t    !(lockres->l_flags & OCFS2_LOCK_LOCAL) &&\n\t    lockres->l_ops->flags & LOCK_TYPE_REQUIRES_REFRESH)\n\t\tlockres_or_flags(lockres, OCFS2_LOCK_NEEDS_REFRESH);\n\n\tlockres->l_level = lockres->l_requested;\n\tlockres_or_flags(lockres, OCFS2_LOCK_ATTACHED);\n\tlockres_clear_flags(lockres, OCFS2_LOCK_BUSY);\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"refcounttree.h\"",
      "#include \"quota.h\"",
      "#include \"uptodate.h\"",
      "#include \"super.h\"",
      "#include \"slot_map.h\"",
      "#include \"stackglue.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"heartbeat.h\"",
      "#include \"file.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"dcache.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2_lockingver.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/time.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/kthread.h>",
      "#include <linux/mm.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [
      "#define LOCK_TYPE_REQUIRES_REFRESH 0x1"
    ],
    "globals_used": [
      "static struct ocfs2_super *ocfs2_get_dentry_osb(struct ocfs2_lock_res *lockres);",
      "static struct ocfs2_super *ocfs2_get_inode_osb(struct ocfs2_lock_res *lockres);",
      "static struct ocfs2_super *ocfs2_get_file_osb(struct ocfs2_lock_res *lockres);",
      "static struct ocfs2_super *ocfs2_get_qinfo_osb(struct ocfs2_lock_res *lockres);",
      "static void ocfs2_set_meta_lvb(struct ocfs2_lock_res *lockres);",
      "static void ocfs2_dentry_post_unlock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres);",
      "static void ocfs2_set_qinfo_lvb(struct ocfs2_lock_res *lockres);",
      "static inline void ocfs2_generic_handle_downconvert_action(struct ocfs2_lock_res *lockres);",
      "static inline void ocfs2_generic_handle_convert_action(struct ocfs2_lock_res *lockres);",
      "static inline void ocfs2_generic_handle_attach_action(struct ocfs2_lock_res *lockres);",
      "static void ocfs2_schedule_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);",
      "static void ocfs2_downconvert_on_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);",
      "static int ocfs2_prepare_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\t        struct ocfs2_lock_res *lockres);",
      "static int ocfs2_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres);",
      "static void ocfs2_process_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *lockres);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "lockres_clear_flags",
          "args": [
            "lockres",
            "OCFS2_LOCK_BUSY"
          ],
          "line": 887
        },
        "resolved": true,
        "details": {
          "function_name": "lockres_clear_flags",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlmglue.c",
          "lines": "823-827",
          "snippet": "static void lockres_clear_flags(struct ocfs2_lock_res *lockres,\n\t\t\t\tunsigned long clear)\n{\n\tlockres_set_flags(lockres, lockres->l_flags & ~clear);\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"refcounttree.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"stackglue.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dcache.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2_lockingver.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/time.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/kthread.h>",
            "#include <linux/mm.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct ocfs2_super *ocfs2_get_dentry_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_inode_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_file_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_qinfo_osb(struct ocfs2_lock_res *lockres);",
            "static void ocfs2_set_meta_lvb(struct ocfs2_lock_res *lockres);",
            "static void ocfs2_dentry_post_unlock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres);",
            "static void ocfs2_set_qinfo_lvb(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_downconvert_action(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_convert_action(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_attach_action(struct ocfs2_lock_res *lockres);",
            "static void ocfs2_schedule_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static void ocfs2_downconvert_on_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static int ocfs2_prepare_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\t        struct ocfs2_lock_res *lockres);",
            "static int ocfs2_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static void ocfs2_process_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *lockres);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"stackglue.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dcache.h\"\n#include \"alloc.h\"\n#include \"ocfs2_lockingver.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/quotaops.h>\n#include <linux/time.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/pagemap.h>\n#include <linux/kthread.h>\n#include <linux/mm.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic struct ocfs2_super *ocfs2_get_dentry_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_inode_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_file_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_qinfo_osb(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_set_meta_lvb(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_dentry_post_unlock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres);\nstatic void ocfs2_set_qinfo_lvb(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_downconvert_action(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_convert_action(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_attach_action(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_schedule_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_downconvert_on_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic int ocfs2_prepare_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\t        struct ocfs2_lock_res *lockres);\nstatic int ocfs2_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_process_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *lockres);\n\nstatic void lockres_clear_flags(struct ocfs2_lock_res *lockres,\n\t\t\t\tunsigned long clear)\n{\n\tlockres_set_flags(lockres, lockres->l_flags & ~clear);\n}"
        }
      },
      {
        "call_info": {
          "callee": "lockres_or_flags",
          "args": [
            "lockres",
            "OCFS2_LOCK_ATTACHED"
          ],
          "line": 886
        },
        "resolved": true,
        "details": {
          "function_name": "lockres_or_flags",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlmglue.c",
          "lines": "819-822",
          "snippet": "static void lockres_or_flags(struct ocfs2_lock_res *lockres, unsigned long or)\n{\n\tlockres_set_flags(lockres, lockres->l_flags | or);\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"refcounttree.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"stackglue.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dcache.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2_lockingver.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/time.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/kthread.h>",
            "#include <linux/mm.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct ocfs2_super *ocfs2_get_dentry_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_inode_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_file_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_qinfo_osb(struct ocfs2_lock_res *lockres);",
            "static void ocfs2_set_meta_lvb(struct ocfs2_lock_res *lockres);",
            "static void ocfs2_dentry_post_unlock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres);",
            "static void ocfs2_set_qinfo_lvb(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_downconvert_action(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_convert_action(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_attach_action(struct ocfs2_lock_res *lockres);",
            "static void ocfs2_schedule_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static void ocfs2_downconvert_on_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static int ocfs2_prepare_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\t        struct ocfs2_lock_res *lockres);",
            "static int ocfs2_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static void ocfs2_process_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *lockres);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"stackglue.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dcache.h\"\n#include \"alloc.h\"\n#include \"ocfs2_lockingver.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/quotaops.h>\n#include <linux/time.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/pagemap.h>\n#include <linux/kthread.h>\n#include <linux/mm.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic struct ocfs2_super *ocfs2_get_dentry_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_inode_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_file_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_qinfo_osb(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_set_meta_lvb(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_dentry_post_unlock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres);\nstatic void ocfs2_set_qinfo_lvb(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_downconvert_action(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_convert_action(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_attach_action(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_schedule_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_downconvert_on_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic int ocfs2_prepare_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\t        struct ocfs2_lock_res *lockres);\nstatic int ocfs2_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_process_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *lockres);\n\nstatic void lockres_or_flags(struct ocfs2_lock_res *lockres, unsigned long or)\n{\n\tlockres_set_flags(lockres, lockres->l_flags | or);\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "lockres->l_flags & OCFS2_LOCK_ATTACHED"
          ],
          "line": 878
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "(!(lockres->l_flags & OCFS2_LOCK_BUSY))"
          ],
          "line": 877
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"stackglue.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dcache.h\"\n#include \"alloc.h\"\n#include \"ocfs2_lockingver.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/quotaops.h>\n#include <linux/time.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/pagemap.h>\n#include <linux/kthread.h>\n#include <linux/mm.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\n#define LOCK_TYPE_REQUIRES_REFRESH 0x1\n\nstatic struct ocfs2_super *ocfs2_get_dentry_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_inode_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_file_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_qinfo_osb(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_set_meta_lvb(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_dentry_post_unlock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres);\nstatic void ocfs2_set_qinfo_lvb(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_downconvert_action(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_convert_action(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_attach_action(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_schedule_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_downconvert_on_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic int ocfs2_prepare_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\t        struct ocfs2_lock_res *lockres);\nstatic int ocfs2_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_process_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *lockres);\n\nstatic inline void ocfs2_generic_handle_attach_action(struct ocfs2_lock_res *lockres)\n{\n\tBUG_ON((!(lockres->l_flags & OCFS2_LOCK_BUSY)));\n\tBUG_ON(lockres->l_flags & OCFS2_LOCK_ATTACHED);\n\n\tif (lockres->l_requested > DLM_LOCK_NL &&\n\t    !(lockres->l_flags & OCFS2_LOCK_LOCAL) &&\n\t    lockres->l_ops->flags & LOCK_TYPE_REQUIRES_REFRESH)\n\t\tlockres_or_flags(lockres, OCFS2_LOCK_NEEDS_REFRESH);\n\n\tlockres->l_level = lockres->l_requested;\n\tlockres_or_flags(lockres, OCFS2_LOCK_ATTACHED);\n\tlockres_clear_flags(lockres, OCFS2_LOCK_BUSY);\n}"
  },
  {
    "function_name": "ocfs2_generic_handle_convert_action",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlmglue.c",
    "lines": "845-873",
    "snippet": "static inline void ocfs2_generic_handle_convert_action(struct ocfs2_lock_res *lockres)\n{\n\tBUG_ON(!(lockres->l_flags & OCFS2_LOCK_BUSY));\n\tBUG_ON(!(lockres->l_flags & OCFS2_LOCK_ATTACHED));\n\n\t/* Convert from RO to EX doesn't really need anything as our\n\t * information is already up to data. Convert from NL to\n\t * *anything* however should mark ourselves as needing an\n\t * update */\n\tif (lockres->l_level == DLM_LOCK_NL &&\n\t    lockres->l_ops->flags & LOCK_TYPE_REQUIRES_REFRESH)\n\t\tlockres_or_flags(lockres, OCFS2_LOCK_NEEDS_REFRESH);\n\n\tlockres->l_level = lockres->l_requested;\n\n\t/*\n\t * We set the OCFS2_LOCK_UPCONVERT_FINISHING flag before clearing\n\t * the OCFS2_LOCK_BUSY flag to prevent the dc thread from\n\t * downconverting the lock before the upconvert has fully completed.\n\t * Do not prevent the dc thread from downconverting if NONBLOCK lock\n\t * had already returned.\n\t */\n\tif (!(lockres->l_flags & OCFS2_LOCK_NONBLOCK_FINISHED))\n\t\tlockres_or_flags(lockres, OCFS2_LOCK_UPCONVERT_FINISHING);\n\telse\n\t\tlockres_clear_flags(lockres, OCFS2_LOCK_NONBLOCK_FINISHED);\n\n\tlockres_clear_flags(lockres, OCFS2_LOCK_BUSY);\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"refcounttree.h\"",
      "#include \"quota.h\"",
      "#include \"uptodate.h\"",
      "#include \"super.h\"",
      "#include \"slot_map.h\"",
      "#include \"stackglue.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"heartbeat.h\"",
      "#include \"file.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"dcache.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2_lockingver.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/time.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/kthread.h>",
      "#include <linux/mm.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [
      "#define LOCK_TYPE_REQUIRES_REFRESH 0x1"
    ],
    "globals_used": [
      "static struct ocfs2_super *ocfs2_get_dentry_osb(struct ocfs2_lock_res *lockres);",
      "static struct ocfs2_super *ocfs2_get_inode_osb(struct ocfs2_lock_res *lockres);",
      "static struct ocfs2_super *ocfs2_get_file_osb(struct ocfs2_lock_res *lockres);",
      "static struct ocfs2_super *ocfs2_get_qinfo_osb(struct ocfs2_lock_res *lockres);",
      "static void ocfs2_set_meta_lvb(struct ocfs2_lock_res *lockres);",
      "static void ocfs2_dentry_post_unlock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres);",
      "static void ocfs2_set_qinfo_lvb(struct ocfs2_lock_res *lockres);",
      "static inline void ocfs2_generic_handle_downconvert_action(struct ocfs2_lock_res *lockres);",
      "static inline void ocfs2_generic_handle_convert_action(struct ocfs2_lock_res *lockres);",
      "static inline void ocfs2_generic_handle_attach_action(struct ocfs2_lock_res *lockres);",
      "static void ocfs2_schedule_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);",
      "static void ocfs2_downconvert_on_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);",
      "static int ocfs2_prepare_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\t        struct ocfs2_lock_res *lockres);",
      "static int ocfs2_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres);",
      "static void ocfs2_process_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *lockres);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "lockres_clear_flags",
          "args": [
            "lockres",
            "OCFS2_LOCK_BUSY"
          ],
          "line": 872
        },
        "resolved": true,
        "details": {
          "function_name": "lockres_clear_flags",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlmglue.c",
          "lines": "823-827",
          "snippet": "static void lockres_clear_flags(struct ocfs2_lock_res *lockres,\n\t\t\t\tunsigned long clear)\n{\n\tlockres_set_flags(lockres, lockres->l_flags & ~clear);\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"refcounttree.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"stackglue.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dcache.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2_lockingver.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/time.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/kthread.h>",
            "#include <linux/mm.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct ocfs2_super *ocfs2_get_dentry_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_inode_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_file_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_qinfo_osb(struct ocfs2_lock_res *lockres);",
            "static void ocfs2_set_meta_lvb(struct ocfs2_lock_res *lockres);",
            "static void ocfs2_dentry_post_unlock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres);",
            "static void ocfs2_set_qinfo_lvb(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_downconvert_action(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_convert_action(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_attach_action(struct ocfs2_lock_res *lockres);",
            "static void ocfs2_schedule_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static void ocfs2_downconvert_on_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static int ocfs2_prepare_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\t        struct ocfs2_lock_res *lockres);",
            "static int ocfs2_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static void ocfs2_process_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *lockres);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"stackglue.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dcache.h\"\n#include \"alloc.h\"\n#include \"ocfs2_lockingver.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/quotaops.h>\n#include <linux/time.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/pagemap.h>\n#include <linux/kthread.h>\n#include <linux/mm.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic struct ocfs2_super *ocfs2_get_dentry_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_inode_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_file_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_qinfo_osb(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_set_meta_lvb(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_dentry_post_unlock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres);\nstatic void ocfs2_set_qinfo_lvb(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_downconvert_action(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_convert_action(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_attach_action(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_schedule_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_downconvert_on_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic int ocfs2_prepare_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\t        struct ocfs2_lock_res *lockres);\nstatic int ocfs2_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_process_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *lockres);\n\nstatic void lockres_clear_flags(struct ocfs2_lock_res *lockres,\n\t\t\t\tunsigned long clear)\n{\n\tlockres_set_flags(lockres, lockres->l_flags & ~clear);\n}"
        }
      },
      {
        "call_info": {
          "callee": "lockres_or_flags",
          "args": [
            "lockres",
            "OCFS2_LOCK_UPCONVERT_FINISHING"
          ],
          "line": 868
        },
        "resolved": true,
        "details": {
          "function_name": "lockres_or_flags",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlmglue.c",
          "lines": "819-822",
          "snippet": "static void lockres_or_flags(struct ocfs2_lock_res *lockres, unsigned long or)\n{\n\tlockres_set_flags(lockres, lockres->l_flags | or);\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"refcounttree.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"stackglue.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dcache.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2_lockingver.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/time.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/kthread.h>",
            "#include <linux/mm.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct ocfs2_super *ocfs2_get_dentry_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_inode_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_file_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_qinfo_osb(struct ocfs2_lock_res *lockres);",
            "static void ocfs2_set_meta_lvb(struct ocfs2_lock_res *lockres);",
            "static void ocfs2_dentry_post_unlock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres);",
            "static void ocfs2_set_qinfo_lvb(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_downconvert_action(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_convert_action(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_attach_action(struct ocfs2_lock_res *lockres);",
            "static void ocfs2_schedule_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static void ocfs2_downconvert_on_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static int ocfs2_prepare_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\t        struct ocfs2_lock_res *lockres);",
            "static int ocfs2_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static void ocfs2_process_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *lockres);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"stackglue.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dcache.h\"\n#include \"alloc.h\"\n#include \"ocfs2_lockingver.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/quotaops.h>\n#include <linux/time.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/pagemap.h>\n#include <linux/kthread.h>\n#include <linux/mm.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic struct ocfs2_super *ocfs2_get_dentry_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_inode_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_file_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_qinfo_osb(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_set_meta_lvb(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_dentry_post_unlock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres);\nstatic void ocfs2_set_qinfo_lvb(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_downconvert_action(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_convert_action(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_attach_action(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_schedule_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_downconvert_on_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic int ocfs2_prepare_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\t        struct ocfs2_lock_res *lockres);\nstatic int ocfs2_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_process_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *lockres);\n\nstatic void lockres_or_flags(struct ocfs2_lock_res *lockres, unsigned long or)\n{\n\tlockres_set_flags(lockres, lockres->l_flags | or);\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!(lockres->l_flags & OCFS2_LOCK_ATTACHED)"
          ],
          "line": 848
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!(lockres->l_flags & OCFS2_LOCK_BUSY)"
          ],
          "line": 847
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"stackglue.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dcache.h\"\n#include \"alloc.h\"\n#include \"ocfs2_lockingver.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/quotaops.h>\n#include <linux/time.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/pagemap.h>\n#include <linux/kthread.h>\n#include <linux/mm.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\n#define LOCK_TYPE_REQUIRES_REFRESH 0x1\n\nstatic struct ocfs2_super *ocfs2_get_dentry_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_inode_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_file_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_qinfo_osb(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_set_meta_lvb(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_dentry_post_unlock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres);\nstatic void ocfs2_set_qinfo_lvb(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_downconvert_action(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_convert_action(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_attach_action(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_schedule_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_downconvert_on_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic int ocfs2_prepare_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\t        struct ocfs2_lock_res *lockres);\nstatic int ocfs2_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_process_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *lockres);\n\nstatic inline void ocfs2_generic_handle_convert_action(struct ocfs2_lock_res *lockres)\n{\n\tBUG_ON(!(lockres->l_flags & OCFS2_LOCK_BUSY));\n\tBUG_ON(!(lockres->l_flags & OCFS2_LOCK_ATTACHED));\n\n\t/* Convert from RO to EX doesn't really need anything as our\n\t * information is already up to data. Convert from NL to\n\t * *anything* however should mark ourselves as needing an\n\t * update */\n\tif (lockres->l_level == DLM_LOCK_NL &&\n\t    lockres->l_ops->flags & LOCK_TYPE_REQUIRES_REFRESH)\n\t\tlockres_or_flags(lockres, OCFS2_LOCK_NEEDS_REFRESH);\n\n\tlockres->l_level = lockres->l_requested;\n\n\t/*\n\t * We set the OCFS2_LOCK_UPCONVERT_FINISHING flag before clearing\n\t * the OCFS2_LOCK_BUSY flag to prevent the dc thread from\n\t * downconverting the lock before the upconvert has fully completed.\n\t * Do not prevent the dc thread from downconverting if NONBLOCK lock\n\t * had already returned.\n\t */\n\tif (!(lockres->l_flags & OCFS2_LOCK_NONBLOCK_FINISHED))\n\t\tlockres_or_flags(lockres, OCFS2_LOCK_UPCONVERT_FINISHING);\n\telse\n\t\tlockres_clear_flags(lockres, OCFS2_LOCK_NONBLOCK_FINISHED);\n\n\tlockres_clear_flags(lockres, OCFS2_LOCK_BUSY);\n}"
  },
  {
    "function_name": "ocfs2_generic_handle_downconvert_action",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlmglue.c",
    "lines": "829-843",
    "snippet": "static inline void ocfs2_generic_handle_downconvert_action(struct ocfs2_lock_res *lockres)\n{\n\tBUG_ON(!(lockres->l_flags & OCFS2_LOCK_BUSY));\n\tBUG_ON(!(lockres->l_flags & OCFS2_LOCK_ATTACHED));\n\tBUG_ON(!(lockres->l_flags & OCFS2_LOCK_BLOCKED));\n\tBUG_ON(lockres->l_blocking <= DLM_LOCK_NL);\n\n\tlockres->l_level = lockres->l_requested;\n\tif (lockres->l_level <=\n\t    ocfs2_highest_compat_lock_level(lockres->l_blocking)) {\n\t\tlockres->l_blocking = DLM_LOCK_NL;\n\t\tlockres_clear_flags(lockres, OCFS2_LOCK_BLOCKED);\n\t}\n\tlockres_clear_flags(lockres, OCFS2_LOCK_BUSY);\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"refcounttree.h\"",
      "#include \"quota.h\"",
      "#include \"uptodate.h\"",
      "#include \"super.h\"",
      "#include \"slot_map.h\"",
      "#include \"stackglue.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"heartbeat.h\"",
      "#include \"file.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"dcache.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2_lockingver.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/time.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/kthread.h>",
      "#include <linux/mm.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct ocfs2_super *ocfs2_get_dentry_osb(struct ocfs2_lock_res *lockres);",
      "static struct ocfs2_super *ocfs2_get_inode_osb(struct ocfs2_lock_res *lockres);",
      "static struct ocfs2_super *ocfs2_get_file_osb(struct ocfs2_lock_res *lockres);",
      "static struct ocfs2_super *ocfs2_get_qinfo_osb(struct ocfs2_lock_res *lockres);",
      "static void ocfs2_set_meta_lvb(struct ocfs2_lock_res *lockres);",
      "static void ocfs2_dentry_post_unlock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres);",
      "static void ocfs2_set_qinfo_lvb(struct ocfs2_lock_res *lockres);",
      "static inline void ocfs2_generic_handle_downconvert_action(struct ocfs2_lock_res *lockres);",
      "static inline void ocfs2_generic_handle_convert_action(struct ocfs2_lock_res *lockres);",
      "static inline void ocfs2_generic_handle_attach_action(struct ocfs2_lock_res *lockres);",
      "static void ocfs2_schedule_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);",
      "static void ocfs2_downconvert_on_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);",
      "static int ocfs2_prepare_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\t        struct ocfs2_lock_res *lockres);",
      "static int ocfs2_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres);",
      "static void ocfs2_process_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *lockres);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "lockres_clear_flags",
          "args": [
            "lockres",
            "OCFS2_LOCK_BUSY"
          ],
          "line": 842
        },
        "resolved": true,
        "details": {
          "function_name": "lockres_clear_flags",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlmglue.c",
          "lines": "823-827",
          "snippet": "static void lockres_clear_flags(struct ocfs2_lock_res *lockres,\n\t\t\t\tunsigned long clear)\n{\n\tlockres_set_flags(lockres, lockres->l_flags & ~clear);\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"refcounttree.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"stackglue.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dcache.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2_lockingver.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/time.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/kthread.h>",
            "#include <linux/mm.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct ocfs2_super *ocfs2_get_dentry_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_inode_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_file_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_qinfo_osb(struct ocfs2_lock_res *lockres);",
            "static void ocfs2_set_meta_lvb(struct ocfs2_lock_res *lockres);",
            "static void ocfs2_dentry_post_unlock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres);",
            "static void ocfs2_set_qinfo_lvb(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_downconvert_action(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_convert_action(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_attach_action(struct ocfs2_lock_res *lockres);",
            "static void ocfs2_schedule_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static void ocfs2_downconvert_on_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static int ocfs2_prepare_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\t        struct ocfs2_lock_res *lockres);",
            "static int ocfs2_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static void ocfs2_process_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *lockres);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"stackglue.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dcache.h\"\n#include \"alloc.h\"\n#include \"ocfs2_lockingver.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/quotaops.h>\n#include <linux/time.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/pagemap.h>\n#include <linux/kthread.h>\n#include <linux/mm.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic struct ocfs2_super *ocfs2_get_dentry_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_inode_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_file_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_qinfo_osb(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_set_meta_lvb(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_dentry_post_unlock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres);\nstatic void ocfs2_set_qinfo_lvb(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_downconvert_action(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_convert_action(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_attach_action(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_schedule_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_downconvert_on_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic int ocfs2_prepare_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\t        struct ocfs2_lock_res *lockres);\nstatic int ocfs2_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_process_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *lockres);\n\nstatic void lockres_clear_flags(struct ocfs2_lock_res *lockres,\n\t\t\t\tunsigned long clear)\n{\n\tlockres_set_flags(lockres, lockres->l_flags & ~clear);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_highest_compat_lock_level",
          "args": [
            "lockres->l_blocking"
          ],
          "line": 838
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_highest_compat_lock_level",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlmglue.c",
          "lines": "790-799",
          "snippet": "static inline int ocfs2_highest_compat_lock_level(int level)\n{\n\tint new_level = DLM_LOCK_EX;\n\n\tif (level == DLM_LOCK_EX)\n\t\tnew_level = DLM_LOCK_NL;\n\telse if (level == DLM_LOCK_PR)\n\t\tnew_level = DLM_LOCK_PR;\n\treturn new_level;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"refcounttree.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"stackglue.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dcache.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2_lockingver.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/time.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/kthread.h>",
            "#include <linux/mm.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ocfs2_check_meta_downconvert(struct ocfs2_lock_res *lockres,\n\t\t\t\t\tint new_level);",
            "static int ocfs2_check_refcount_downconvert(struct ocfs2_lock_res *lockres,\n\t\t\t\t\t    int new_level);",
            "static int ocfs2_generic_handle_bast(struct ocfs2_lock_res *lockres, int level);",
            "static inline int ocfs2_highest_compat_lock_level(int level);",
            "static unsigned int ocfs2_prepare_downconvert(struct ocfs2_lock_res *lockres,\n\t\t\t\t\t      int new_level);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"stackglue.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dcache.h\"\n#include \"alloc.h\"\n#include \"ocfs2_lockingver.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/quotaops.h>\n#include <linux/time.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/pagemap.h>\n#include <linux/kthread.h>\n#include <linux/mm.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic int ocfs2_check_meta_downconvert(struct ocfs2_lock_res *lockres,\n\t\t\t\t\tint new_level);\nstatic int ocfs2_check_refcount_downconvert(struct ocfs2_lock_res *lockres,\n\t\t\t\t\t    int new_level);\nstatic int ocfs2_generic_handle_bast(struct ocfs2_lock_res *lockres, int level);\nstatic inline int ocfs2_highest_compat_lock_level(int level);\nstatic unsigned int ocfs2_prepare_downconvert(struct ocfs2_lock_res *lockres,\n\t\t\t\t\t      int new_level);\n\nstatic inline int ocfs2_highest_compat_lock_level(int level)\n{\n\tint new_level = DLM_LOCK_EX;\n\n\tif (level == DLM_LOCK_EX)\n\t\tnew_level = DLM_LOCK_NL;\n\telse if (level == DLM_LOCK_PR)\n\t\tnew_level = DLM_LOCK_PR;\n\treturn new_level;\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "lockres->l_blocking <= DLM_LOCK_NL"
          ],
          "line": 834
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!(lockres->l_flags & OCFS2_LOCK_BLOCKED)"
          ],
          "line": 833
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!(lockres->l_flags & OCFS2_LOCK_ATTACHED)"
          ],
          "line": 832
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!(lockres->l_flags & OCFS2_LOCK_BUSY)"
          ],
          "line": 831
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"stackglue.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dcache.h\"\n#include \"alloc.h\"\n#include \"ocfs2_lockingver.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/quotaops.h>\n#include <linux/time.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/pagemap.h>\n#include <linux/kthread.h>\n#include <linux/mm.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic struct ocfs2_super *ocfs2_get_dentry_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_inode_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_file_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_qinfo_osb(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_set_meta_lvb(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_dentry_post_unlock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres);\nstatic void ocfs2_set_qinfo_lvb(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_downconvert_action(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_convert_action(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_attach_action(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_schedule_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_downconvert_on_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic int ocfs2_prepare_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\t        struct ocfs2_lock_res *lockres);\nstatic int ocfs2_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_process_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *lockres);\n\nstatic inline void ocfs2_generic_handle_downconvert_action(struct ocfs2_lock_res *lockres)\n{\n\tBUG_ON(!(lockres->l_flags & OCFS2_LOCK_BUSY));\n\tBUG_ON(!(lockres->l_flags & OCFS2_LOCK_ATTACHED));\n\tBUG_ON(!(lockres->l_flags & OCFS2_LOCK_BLOCKED));\n\tBUG_ON(lockres->l_blocking <= DLM_LOCK_NL);\n\n\tlockres->l_level = lockres->l_requested;\n\tif (lockres->l_level <=\n\t    ocfs2_highest_compat_lock_level(lockres->l_blocking)) {\n\t\tlockres->l_blocking = DLM_LOCK_NL;\n\t\tlockres_clear_flags(lockres, OCFS2_LOCK_BLOCKED);\n\t}\n\tlockres_clear_flags(lockres, OCFS2_LOCK_BUSY);\n}"
  },
  {
    "function_name": "lockres_clear_flags",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlmglue.c",
    "lines": "823-827",
    "snippet": "static void lockres_clear_flags(struct ocfs2_lock_res *lockres,\n\t\t\t\tunsigned long clear)\n{\n\tlockres_set_flags(lockres, lockres->l_flags & ~clear);\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"refcounttree.h\"",
      "#include \"quota.h\"",
      "#include \"uptodate.h\"",
      "#include \"super.h\"",
      "#include \"slot_map.h\"",
      "#include \"stackglue.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"heartbeat.h\"",
      "#include \"file.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"dcache.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2_lockingver.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/time.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/kthread.h>",
      "#include <linux/mm.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct ocfs2_super *ocfs2_get_dentry_osb(struct ocfs2_lock_res *lockres);",
      "static struct ocfs2_super *ocfs2_get_inode_osb(struct ocfs2_lock_res *lockres);",
      "static struct ocfs2_super *ocfs2_get_file_osb(struct ocfs2_lock_res *lockres);",
      "static struct ocfs2_super *ocfs2_get_qinfo_osb(struct ocfs2_lock_res *lockres);",
      "static void ocfs2_set_meta_lvb(struct ocfs2_lock_res *lockres);",
      "static void ocfs2_dentry_post_unlock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres);",
      "static void ocfs2_set_qinfo_lvb(struct ocfs2_lock_res *lockres);",
      "static inline void ocfs2_generic_handle_downconvert_action(struct ocfs2_lock_res *lockres);",
      "static inline void ocfs2_generic_handle_convert_action(struct ocfs2_lock_res *lockres);",
      "static inline void ocfs2_generic_handle_attach_action(struct ocfs2_lock_res *lockres);",
      "static void ocfs2_schedule_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);",
      "static void ocfs2_downconvert_on_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);",
      "static int ocfs2_prepare_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\t        struct ocfs2_lock_res *lockres);",
      "static int ocfs2_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres);",
      "static void ocfs2_process_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *lockres);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "lockres_set_flags",
          "args": [
            "lockres",
            "lockres->l_flags & ~clear"
          ],
          "line": 826
        },
        "resolved": true,
        "details": {
          "function_name": "lockres_set_flags",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlmglue.c",
          "lines": "801-818",
          "snippet": "static void lockres_set_flags(struct ocfs2_lock_res *lockres,\n\t\t\t      unsigned long newflags)\n{\n\tstruct ocfs2_mask_waiter *mw, *tmp;\n\n \tassert_spin_locked(&lockres->l_lock);\n\n\tlockres->l_flags = newflags;\n\n\tlist_for_each_entry_safe(mw, tmp, &lockres->l_mask_waiters, mw_item) {\n\t\tif ((lockres->l_flags & mw->mw_mask) != mw->mw_goal)\n\t\t\tcontinue;\n\n\t\tlist_del_init(&mw->mw_item);\n\t\tmw->mw_status = 0;\n\t\tcomplete(&mw->mw_complete);\n\t}\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"refcounttree.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"stackglue.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dcache.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2_lockingver.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/time.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/kthread.h>",
            "#include <linux/mm.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct ocfs2_super *ocfs2_get_dentry_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_inode_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_file_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_qinfo_osb(struct ocfs2_lock_res *lockres);",
            "static void ocfs2_set_meta_lvb(struct ocfs2_lock_res *lockres);",
            "static void ocfs2_dentry_post_unlock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres);",
            "static void ocfs2_set_qinfo_lvb(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_downconvert_action(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_convert_action(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_attach_action(struct ocfs2_lock_res *lockres);",
            "static void ocfs2_schedule_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static void ocfs2_downconvert_on_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static int ocfs2_prepare_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\t        struct ocfs2_lock_res *lockres);",
            "static int ocfs2_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static void ocfs2_process_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *lockres);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"stackglue.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dcache.h\"\n#include \"alloc.h\"\n#include \"ocfs2_lockingver.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/quotaops.h>\n#include <linux/time.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/pagemap.h>\n#include <linux/kthread.h>\n#include <linux/mm.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic struct ocfs2_super *ocfs2_get_dentry_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_inode_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_file_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_qinfo_osb(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_set_meta_lvb(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_dentry_post_unlock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres);\nstatic void ocfs2_set_qinfo_lvb(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_downconvert_action(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_convert_action(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_attach_action(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_schedule_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_downconvert_on_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic int ocfs2_prepare_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\t        struct ocfs2_lock_res *lockres);\nstatic int ocfs2_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_process_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *lockres);\n\nstatic void lockres_set_flags(struct ocfs2_lock_res *lockres,\n\t\t\t      unsigned long newflags)\n{\n\tstruct ocfs2_mask_waiter *mw, *tmp;\n\n \tassert_spin_locked(&lockres->l_lock);\n\n\tlockres->l_flags = newflags;\n\n\tlist_for_each_entry_safe(mw, tmp, &lockres->l_mask_waiters, mw_item) {\n\t\tif ((lockres->l_flags & mw->mw_mask) != mw->mw_goal)\n\t\t\tcontinue;\n\n\t\tlist_del_init(&mw->mw_item);\n\t\tmw->mw_status = 0;\n\t\tcomplete(&mw->mw_complete);\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"stackglue.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dcache.h\"\n#include \"alloc.h\"\n#include \"ocfs2_lockingver.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/quotaops.h>\n#include <linux/time.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/pagemap.h>\n#include <linux/kthread.h>\n#include <linux/mm.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic struct ocfs2_super *ocfs2_get_dentry_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_inode_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_file_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_qinfo_osb(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_set_meta_lvb(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_dentry_post_unlock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres);\nstatic void ocfs2_set_qinfo_lvb(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_downconvert_action(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_convert_action(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_attach_action(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_schedule_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_downconvert_on_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic int ocfs2_prepare_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\t        struct ocfs2_lock_res *lockres);\nstatic int ocfs2_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_process_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *lockres);\n\nstatic void lockres_clear_flags(struct ocfs2_lock_res *lockres,\n\t\t\t\tunsigned long clear)\n{\n\tlockres_set_flags(lockres, lockres->l_flags & ~clear);\n}"
  },
  {
    "function_name": "lockres_or_flags",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlmglue.c",
    "lines": "819-822",
    "snippet": "static void lockres_or_flags(struct ocfs2_lock_res *lockres, unsigned long or)\n{\n\tlockres_set_flags(lockres, lockres->l_flags | or);\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"refcounttree.h\"",
      "#include \"quota.h\"",
      "#include \"uptodate.h\"",
      "#include \"super.h\"",
      "#include \"slot_map.h\"",
      "#include \"stackglue.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"heartbeat.h\"",
      "#include \"file.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"dcache.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2_lockingver.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/time.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/kthread.h>",
      "#include <linux/mm.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct ocfs2_super *ocfs2_get_dentry_osb(struct ocfs2_lock_res *lockres);",
      "static struct ocfs2_super *ocfs2_get_inode_osb(struct ocfs2_lock_res *lockres);",
      "static struct ocfs2_super *ocfs2_get_file_osb(struct ocfs2_lock_res *lockres);",
      "static struct ocfs2_super *ocfs2_get_qinfo_osb(struct ocfs2_lock_res *lockres);",
      "static void ocfs2_set_meta_lvb(struct ocfs2_lock_res *lockres);",
      "static void ocfs2_dentry_post_unlock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres);",
      "static void ocfs2_set_qinfo_lvb(struct ocfs2_lock_res *lockres);",
      "static inline void ocfs2_generic_handle_downconvert_action(struct ocfs2_lock_res *lockres);",
      "static inline void ocfs2_generic_handle_convert_action(struct ocfs2_lock_res *lockres);",
      "static inline void ocfs2_generic_handle_attach_action(struct ocfs2_lock_res *lockres);",
      "static void ocfs2_schedule_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);",
      "static void ocfs2_downconvert_on_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);",
      "static int ocfs2_prepare_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\t        struct ocfs2_lock_res *lockres);",
      "static int ocfs2_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres);",
      "static void ocfs2_process_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *lockres);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "lockres_set_flags",
          "args": [
            "lockres",
            "lockres->l_flags | or"
          ],
          "line": 821
        },
        "resolved": true,
        "details": {
          "function_name": "lockres_set_flags",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlmglue.c",
          "lines": "801-818",
          "snippet": "static void lockres_set_flags(struct ocfs2_lock_res *lockres,\n\t\t\t      unsigned long newflags)\n{\n\tstruct ocfs2_mask_waiter *mw, *tmp;\n\n \tassert_spin_locked(&lockres->l_lock);\n\n\tlockres->l_flags = newflags;\n\n\tlist_for_each_entry_safe(mw, tmp, &lockres->l_mask_waiters, mw_item) {\n\t\tif ((lockres->l_flags & mw->mw_mask) != mw->mw_goal)\n\t\t\tcontinue;\n\n\t\tlist_del_init(&mw->mw_item);\n\t\tmw->mw_status = 0;\n\t\tcomplete(&mw->mw_complete);\n\t}\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"refcounttree.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"stackglue.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dcache.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2_lockingver.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/time.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/kthread.h>",
            "#include <linux/mm.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct ocfs2_super *ocfs2_get_dentry_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_inode_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_file_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_qinfo_osb(struct ocfs2_lock_res *lockres);",
            "static void ocfs2_set_meta_lvb(struct ocfs2_lock_res *lockres);",
            "static void ocfs2_dentry_post_unlock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres);",
            "static void ocfs2_set_qinfo_lvb(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_downconvert_action(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_convert_action(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_attach_action(struct ocfs2_lock_res *lockres);",
            "static void ocfs2_schedule_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static void ocfs2_downconvert_on_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static int ocfs2_prepare_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\t        struct ocfs2_lock_res *lockres);",
            "static int ocfs2_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static void ocfs2_process_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *lockres);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"stackglue.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dcache.h\"\n#include \"alloc.h\"\n#include \"ocfs2_lockingver.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/quotaops.h>\n#include <linux/time.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/pagemap.h>\n#include <linux/kthread.h>\n#include <linux/mm.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic struct ocfs2_super *ocfs2_get_dentry_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_inode_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_file_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_qinfo_osb(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_set_meta_lvb(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_dentry_post_unlock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres);\nstatic void ocfs2_set_qinfo_lvb(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_downconvert_action(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_convert_action(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_attach_action(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_schedule_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_downconvert_on_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic int ocfs2_prepare_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\t        struct ocfs2_lock_res *lockres);\nstatic int ocfs2_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_process_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *lockres);\n\nstatic void lockres_set_flags(struct ocfs2_lock_res *lockres,\n\t\t\t      unsigned long newflags)\n{\n\tstruct ocfs2_mask_waiter *mw, *tmp;\n\n \tassert_spin_locked(&lockres->l_lock);\n\n\tlockres->l_flags = newflags;\n\n\tlist_for_each_entry_safe(mw, tmp, &lockres->l_mask_waiters, mw_item) {\n\t\tif ((lockres->l_flags & mw->mw_mask) != mw->mw_goal)\n\t\t\tcontinue;\n\n\t\tlist_del_init(&mw->mw_item);\n\t\tmw->mw_status = 0;\n\t\tcomplete(&mw->mw_complete);\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"stackglue.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dcache.h\"\n#include \"alloc.h\"\n#include \"ocfs2_lockingver.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/quotaops.h>\n#include <linux/time.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/pagemap.h>\n#include <linux/kthread.h>\n#include <linux/mm.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic struct ocfs2_super *ocfs2_get_dentry_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_inode_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_file_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_qinfo_osb(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_set_meta_lvb(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_dentry_post_unlock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres);\nstatic void ocfs2_set_qinfo_lvb(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_downconvert_action(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_convert_action(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_attach_action(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_schedule_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_downconvert_on_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic int ocfs2_prepare_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\t        struct ocfs2_lock_res *lockres);\nstatic int ocfs2_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_process_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *lockres);\n\nstatic void lockres_or_flags(struct ocfs2_lock_res *lockres, unsigned long or)\n{\n\tlockres_set_flags(lockres, lockres->l_flags | or);\n}"
  },
  {
    "function_name": "lockres_set_flags",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlmglue.c",
    "lines": "801-818",
    "snippet": "static void lockres_set_flags(struct ocfs2_lock_res *lockres,\n\t\t\t      unsigned long newflags)\n{\n\tstruct ocfs2_mask_waiter *mw, *tmp;\n\n \tassert_spin_locked(&lockres->l_lock);\n\n\tlockres->l_flags = newflags;\n\n\tlist_for_each_entry_safe(mw, tmp, &lockres->l_mask_waiters, mw_item) {\n\t\tif ((lockres->l_flags & mw->mw_mask) != mw->mw_goal)\n\t\t\tcontinue;\n\n\t\tlist_del_init(&mw->mw_item);\n\t\tmw->mw_status = 0;\n\t\tcomplete(&mw->mw_complete);\n\t}\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"refcounttree.h\"",
      "#include \"quota.h\"",
      "#include \"uptodate.h\"",
      "#include \"super.h\"",
      "#include \"slot_map.h\"",
      "#include \"stackglue.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"heartbeat.h\"",
      "#include \"file.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"dcache.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2_lockingver.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/time.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/kthread.h>",
      "#include <linux/mm.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct ocfs2_super *ocfs2_get_dentry_osb(struct ocfs2_lock_res *lockres);",
      "static struct ocfs2_super *ocfs2_get_inode_osb(struct ocfs2_lock_res *lockres);",
      "static struct ocfs2_super *ocfs2_get_file_osb(struct ocfs2_lock_res *lockres);",
      "static struct ocfs2_super *ocfs2_get_qinfo_osb(struct ocfs2_lock_res *lockres);",
      "static void ocfs2_set_meta_lvb(struct ocfs2_lock_res *lockres);",
      "static void ocfs2_dentry_post_unlock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres);",
      "static void ocfs2_set_qinfo_lvb(struct ocfs2_lock_res *lockres);",
      "static inline void ocfs2_generic_handle_downconvert_action(struct ocfs2_lock_res *lockres);",
      "static inline void ocfs2_generic_handle_convert_action(struct ocfs2_lock_res *lockres);",
      "static inline void ocfs2_generic_handle_attach_action(struct ocfs2_lock_res *lockres);",
      "static void ocfs2_schedule_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);",
      "static void ocfs2_downconvert_on_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);",
      "static int ocfs2_prepare_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\t        struct ocfs2_lock_res *lockres);",
      "static int ocfs2_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres);",
      "static void ocfs2_process_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *lockres);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "complete",
          "args": [
            "&mw->mw_complete"
          ],
          "line": 816
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_complete_quota_recovery",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/journal.c",
          "lines": "1332-1343",
          "snippet": "void ocfs2_complete_quota_recovery(struct ocfs2_super *osb)\n{\n\tif (osb->quota_rec) {\n\t\tocfs2_queue_recovery_completion(osb->journal,\n\t\t\t\t\t\tosb->slot_num,\n\t\t\t\t\t\tNULL,\n\t\t\t\t\t\tNULL,\n\t\t\t\t\t\tosb->quota_rec,\n\t\t\t\t\t\tORPHAN_NEED_TRUNCATE);\n\t\tosb->quota_rec = NULL;\n\t}\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"namei.h\"",
            "#include \"file.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/delay.h>",
            "#include <linux/random.h>",
            "#include <linux/time.h>",
            "#include <linux/kthread.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ocfs2_recover_node(struct ocfs2_super *osb,\n\t\t\t      int node_num, int slot_num);",
            "static int ocfs2_commit_cache(struct ocfs2_super *osb);",
            "static int ocfs2_trylock_journal(struct ocfs2_super *osb,\n\t\t\t\t int slot_num);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"buffer_head_io.h\"\n#include \"namei.h\"\n#include \"file.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/delay.h>\n#include <linux/random.h>\n#include <linux/time.h>\n#include <linux/kthread.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_recover_node(struct ocfs2_super *osb,\n\t\t\t      int node_num, int slot_num);\nstatic int ocfs2_commit_cache(struct ocfs2_super *osb);\nstatic int ocfs2_trylock_journal(struct ocfs2_super *osb,\n\t\t\t\t int slot_num);\n\nvoid ocfs2_complete_quota_recovery(struct ocfs2_super *osb)\n{\n\tif (osb->quota_rec) {\n\t\tocfs2_queue_recovery_completion(osb->journal,\n\t\t\t\t\t\tosb->slot_num,\n\t\t\t\t\t\tNULL,\n\t\t\t\t\t\tNULL,\n\t\t\t\t\t\tosb->quota_rec,\n\t\t\t\t\t\tORPHAN_NEED_TRUNCATE);\n\t\tosb->quota_rec = NULL;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_del_init",
          "args": [
            "&mw->mw_item"
          ],
          "line": 814
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_entry_safe",
          "args": [
            "mw",
            "tmp",
            "&lockres->l_mask_waiters",
            "mw_item"
          ],
          "line": 810
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "assert_spin_locked",
          "args": [
            "&lockres->l_lock"
          ],
          "line": 806
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"stackglue.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dcache.h\"\n#include \"alloc.h\"\n#include \"ocfs2_lockingver.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/quotaops.h>\n#include <linux/time.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/pagemap.h>\n#include <linux/kthread.h>\n#include <linux/mm.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic struct ocfs2_super *ocfs2_get_dentry_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_inode_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_file_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_qinfo_osb(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_set_meta_lvb(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_dentry_post_unlock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres);\nstatic void ocfs2_set_qinfo_lvb(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_downconvert_action(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_convert_action(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_attach_action(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_schedule_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_downconvert_on_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic int ocfs2_prepare_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\t        struct ocfs2_lock_res *lockres);\nstatic int ocfs2_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_process_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *lockres);\n\nstatic void lockres_set_flags(struct ocfs2_lock_res *lockres,\n\t\t\t      unsigned long newflags)\n{\n\tstruct ocfs2_mask_waiter *mw, *tmp;\n\n \tassert_spin_locked(&lockres->l_lock);\n\n\tlockres->l_flags = newflags;\n\n\tlist_for_each_entry_safe(mw, tmp, &lockres->l_mask_waiters, mw_item) {\n\t\tif ((lockres->l_flags & mw->mw_mask) != mw->mw_goal)\n\t\t\tcontinue;\n\n\t\tlist_del_init(&mw->mw_item);\n\t\tmw->mw_status = 0;\n\t\tcomplete(&mw->mw_complete);\n\t}\n}"
  },
  {
    "function_name": "ocfs2_highest_compat_lock_level",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlmglue.c",
    "lines": "790-799",
    "snippet": "static inline int ocfs2_highest_compat_lock_level(int level)\n{\n\tint new_level = DLM_LOCK_EX;\n\n\tif (level == DLM_LOCK_EX)\n\t\tnew_level = DLM_LOCK_NL;\n\telse if (level == DLM_LOCK_PR)\n\t\tnew_level = DLM_LOCK_PR;\n\treturn new_level;\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"refcounttree.h\"",
      "#include \"quota.h\"",
      "#include \"uptodate.h\"",
      "#include \"super.h\"",
      "#include \"slot_map.h\"",
      "#include \"stackglue.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"heartbeat.h\"",
      "#include \"file.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"dcache.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2_lockingver.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/time.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/kthread.h>",
      "#include <linux/mm.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ocfs2_check_meta_downconvert(struct ocfs2_lock_res *lockres,\n\t\t\t\t\tint new_level);",
      "static int ocfs2_check_refcount_downconvert(struct ocfs2_lock_res *lockres,\n\t\t\t\t\t    int new_level);",
      "static int ocfs2_generic_handle_bast(struct ocfs2_lock_res *lockres, int level);",
      "static inline int ocfs2_highest_compat_lock_level(int level);",
      "static unsigned int ocfs2_prepare_downconvert(struct ocfs2_lock_res *lockres,\n\t\t\t\t\t      int new_level);"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"stackglue.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dcache.h\"\n#include \"alloc.h\"\n#include \"ocfs2_lockingver.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/quotaops.h>\n#include <linux/time.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/pagemap.h>\n#include <linux/kthread.h>\n#include <linux/mm.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic int ocfs2_check_meta_downconvert(struct ocfs2_lock_res *lockres,\n\t\t\t\t\tint new_level);\nstatic int ocfs2_check_refcount_downconvert(struct ocfs2_lock_res *lockres,\n\t\t\t\t\t    int new_level);\nstatic int ocfs2_generic_handle_bast(struct ocfs2_lock_res *lockres, int level);\nstatic inline int ocfs2_highest_compat_lock_level(int level);\nstatic unsigned int ocfs2_prepare_downconvert(struct ocfs2_lock_res *lockres,\n\t\t\t\t\t      int new_level);\n\nstatic inline int ocfs2_highest_compat_lock_level(int level)\n{\n\tint new_level = DLM_LOCK_EX;\n\n\tif (level == DLM_LOCK_EX)\n\t\tnew_level = DLM_LOCK_NL;\n\telse if (level == DLM_LOCK_PR)\n\t\tnew_level = DLM_LOCK_PR;\n\treturn new_level;\n}"
  },
  {
    "function_name": "ocfs2_dec_holders",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlmglue.c",
    "lines": "768-785",
    "snippet": "static inline void ocfs2_dec_holders(struct ocfs2_lock_res *lockres,\n\t\t\t\t     int level)\n{\n\tBUG_ON(!lockres);\n\n\tswitch(level) {\n\tcase DLM_LOCK_EX:\n\t\tBUG_ON(!lockres->l_ex_holders);\n\t\tlockres->l_ex_holders--;\n\t\tbreak;\n\tcase DLM_LOCK_PR:\n\t\tBUG_ON(!lockres->l_ro_holders);\n\t\tlockres->l_ro_holders--;\n\t\tbreak;\n\tdefault:\n\t\tBUG();\n\t}\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"refcounttree.h\"",
      "#include \"quota.h\"",
      "#include \"uptodate.h\"",
      "#include \"super.h\"",
      "#include \"slot_map.h\"",
      "#include \"stackglue.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"heartbeat.h\"",
      "#include \"file.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"dcache.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2_lockingver.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/time.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/kthread.h>",
      "#include <linux/mm.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct ocfs2_super *ocfs2_get_dentry_osb(struct ocfs2_lock_res *lockres);",
      "static struct ocfs2_super *ocfs2_get_inode_osb(struct ocfs2_lock_res *lockres);",
      "static struct ocfs2_super *ocfs2_get_file_osb(struct ocfs2_lock_res *lockres);",
      "static struct ocfs2_super *ocfs2_get_qinfo_osb(struct ocfs2_lock_res *lockres);",
      "static void ocfs2_set_meta_lvb(struct ocfs2_lock_res *lockres);",
      "static void ocfs2_dentry_post_unlock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres);",
      "static void ocfs2_set_qinfo_lvb(struct ocfs2_lock_res *lockres);",
      "static inline void ocfs2_generic_handle_downconvert_action(struct ocfs2_lock_res *lockres);",
      "static inline void ocfs2_generic_handle_convert_action(struct ocfs2_lock_res *lockres);",
      "static inline void ocfs2_generic_handle_attach_action(struct ocfs2_lock_res *lockres);",
      "static int ocfs2_generic_handle_bast(struct ocfs2_lock_res *lockres, int level);",
      "static void ocfs2_schedule_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);",
      "static void ocfs2_downconvert_on_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);",
      "static inline int ocfs2_highest_compat_lock_level(int level);",
      "static int ocfs2_prepare_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\t        struct ocfs2_lock_res *lockres);",
      "static int ocfs2_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres);",
      "static void ocfs2_process_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *lockres);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "BUG",
          "args": [],
          "line": 783
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!lockres->l_ro_holders"
          ],
          "line": 779
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!lockres->l_ex_holders"
          ],
          "line": 775
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!lockres"
          ],
          "line": 771
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"stackglue.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dcache.h\"\n#include \"alloc.h\"\n#include \"ocfs2_lockingver.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/quotaops.h>\n#include <linux/time.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/pagemap.h>\n#include <linux/kthread.h>\n#include <linux/mm.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic struct ocfs2_super *ocfs2_get_dentry_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_inode_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_file_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_qinfo_osb(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_set_meta_lvb(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_dentry_post_unlock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres);\nstatic void ocfs2_set_qinfo_lvb(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_downconvert_action(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_convert_action(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_attach_action(struct ocfs2_lock_res *lockres);\nstatic int ocfs2_generic_handle_bast(struct ocfs2_lock_res *lockres, int level);\nstatic void ocfs2_schedule_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_downconvert_on_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic inline int ocfs2_highest_compat_lock_level(int level);\nstatic int ocfs2_prepare_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\t        struct ocfs2_lock_res *lockres);\nstatic int ocfs2_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_process_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *lockres);\n\nstatic inline void ocfs2_dec_holders(struct ocfs2_lock_res *lockres,\n\t\t\t\t     int level)\n{\n\tBUG_ON(!lockres);\n\n\tswitch(level) {\n\tcase DLM_LOCK_EX:\n\t\tBUG_ON(!lockres->l_ex_holders);\n\t\tlockres->l_ex_holders--;\n\t\tbreak;\n\tcase DLM_LOCK_PR:\n\t\tBUG_ON(!lockres->l_ro_holders);\n\t\tlockres->l_ro_holders--;\n\t\tbreak;\n\tdefault:\n\t\tBUG();\n\t}\n}"
  },
  {
    "function_name": "ocfs2_inc_holders",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlmglue.c",
    "lines": "751-766",
    "snippet": "static inline void ocfs2_inc_holders(struct ocfs2_lock_res *lockres,\n\t\t\t\t     int level)\n{\n\tBUG_ON(!lockres);\n\n\tswitch(level) {\n\tcase DLM_LOCK_EX:\n\t\tlockres->l_ex_holders++;\n\t\tbreak;\n\tcase DLM_LOCK_PR:\n\t\tlockres->l_ro_holders++;\n\t\tbreak;\n\tdefault:\n\t\tBUG();\n\t}\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"refcounttree.h\"",
      "#include \"quota.h\"",
      "#include \"uptodate.h\"",
      "#include \"super.h\"",
      "#include \"slot_map.h\"",
      "#include \"stackglue.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"heartbeat.h\"",
      "#include \"file.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"dcache.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2_lockingver.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/time.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/kthread.h>",
      "#include <linux/mm.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct ocfs2_super *ocfs2_get_dentry_osb(struct ocfs2_lock_res *lockres);",
      "static struct ocfs2_super *ocfs2_get_inode_osb(struct ocfs2_lock_res *lockres);",
      "static struct ocfs2_super *ocfs2_get_file_osb(struct ocfs2_lock_res *lockres);",
      "static struct ocfs2_super *ocfs2_get_qinfo_osb(struct ocfs2_lock_res *lockres);",
      "static void ocfs2_set_meta_lvb(struct ocfs2_lock_res *lockres);",
      "static void ocfs2_dentry_post_unlock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres);",
      "static void ocfs2_set_qinfo_lvb(struct ocfs2_lock_res *lockres);",
      "static inline void ocfs2_generic_handle_downconvert_action(struct ocfs2_lock_res *lockres);",
      "static inline void ocfs2_generic_handle_convert_action(struct ocfs2_lock_res *lockres);",
      "static inline void ocfs2_generic_handle_attach_action(struct ocfs2_lock_res *lockres);",
      "static int ocfs2_generic_handle_bast(struct ocfs2_lock_res *lockres, int level);",
      "static void ocfs2_schedule_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);",
      "static void ocfs2_downconvert_on_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);",
      "static inline int ocfs2_highest_compat_lock_level(int level);",
      "static int ocfs2_prepare_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\t        struct ocfs2_lock_res *lockres);",
      "static int ocfs2_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres);",
      "static void ocfs2_process_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *lockres);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "BUG",
          "args": [],
          "line": 764
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!lockres"
          ],
          "line": 754
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"stackglue.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dcache.h\"\n#include \"alloc.h\"\n#include \"ocfs2_lockingver.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/quotaops.h>\n#include <linux/time.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/pagemap.h>\n#include <linux/kthread.h>\n#include <linux/mm.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic struct ocfs2_super *ocfs2_get_dentry_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_inode_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_file_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_qinfo_osb(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_set_meta_lvb(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_dentry_post_unlock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres);\nstatic void ocfs2_set_qinfo_lvb(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_downconvert_action(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_convert_action(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_attach_action(struct ocfs2_lock_res *lockres);\nstatic int ocfs2_generic_handle_bast(struct ocfs2_lock_res *lockres, int level);\nstatic void ocfs2_schedule_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_downconvert_on_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic inline int ocfs2_highest_compat_lock_level(int level);\nstatic int ocfs2_prepare_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\t        struct ocfs2_lock_res *lockres);\nstatic int ocfs2_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_process_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *lockres);\n\nstatic inline void ocfs2_inc_holders(struct ocfs2_lock_res *lockres,\n\t\t\t\t     int level)\n{\n\tBUG_ON(!lockres);\n\n\tswitch(level) {\n\tcase DLM_LOCK_EX:\n\t\tlockres->l_ex_holders++;\n\t\tbreak;\n\tcase DLM_LOCK_PR:\n\t\tlockres->l_ro_holders++;\n\t\tbreak;\n\tdefault:\n\t\tBUG();\n\t}\n}"
  },
  {
    "function_name": "ocfs2_lock_res_free",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlmglue.c",
    "lines": "722-749",
    "snippet": "void ocfs2_lock_res_free(struct ocfs2_lock_res *res)\n{\n\tif (!(res->l_flags & OCFS2_LOCK_INITIALIZED))\n\t\treturn;\n\n\tocfs2_remove_lockres_tracking(res);\n\n\tmlog_bug_on_msg(!list_empty(&res->l_blocked_list),\n\t\t\t\"Lockres %s is on the blocked list\\n\",\n\t\t\tres->l_name);\n\tmlog_bug_on_msg(!list_empty(&res->l_mask_waiters),\n\t\t\t\"Lockres %s has mask waiters pending\\n\",\n\t\t\tres->l_name);\n\tmlog_bug_on_msg(spin_is_locked(&res->l_lock),\n\t\t\t\"Lockres %s is locked\\n\",\n\t\t\tres->l_name);\n\tmlog_bug_on_msg(res->l_ro_holders,\n\t\t\t\"Lockres %s has %u ro holders\\n\",\n\t\t\tres->l_name, res->l_ro_holders);\n\tmlog_bug_on_msg(res->l_ex_holders,\n\t\t\t\"Lockres %s has %u ex holders\\n\",\n\t\t\tres->l_name, res->l_ex_holders);\n\n\t/* Need to clear out the lock status block for the dlm */\n\tmemset(&res->l_lksb, 0, sizeof(res->l_lksb));\n\n\tres->l_flags = 0UL;\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"refcounttree.h\"",
      "#include \"quota.h\"",
      "#include \"uptodate.h\"",
      "#include \"super.h\"",
      "#include \"slot_map.h\"",
      "#include \"stackglue.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"heartbeat.h\"",
      "#include \"file.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"dcache.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2_lockingver.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/time.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/kthread.h>",
      "#include <linux/mm.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&res->l_lksb",
            "0",
            "sizeof(res->l_lksb)"
          ],
          "line": 746
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mlog_bug_on_msg",
          "args": [
            "res->l_ex_holders",
            "\"Lockres %s has %u ex holders\\n\"",
            "res->l_name",
            "res->l_ex_holders"
          ],
          "line": 741
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mlog_bug_on_msg",
          "args": [
            "res->l_ro_holders",
            "\"Lockres %s has %u ro holders\\n\"",
            "res->l_name",
            "res->l_ro_holders"
          ],
          "line": 738
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mlog_bug_on_msg",
          "args": [
            "spin_is_locked(&res->l_lock)",
            "\"Lockres %s is locked\\n\"",
            "res->l_name"
          ],
          "line": 735
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_is_locked",
          "args": [
            "&res->l_lock"
          ],
          "line": 735
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mlog_bug_on_msg",
          "args": [
            "!list_empty(&res->l_mask_waiters)",
            "\"Lockres %s has mask waiters pending\\n\"",
            "res->l_name"
          ],
          "line": 732
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&res->l_mask_waiters"
          ],
          "line": 732
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_dirty_list_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmthread.c",
          "lines": "505-514",
          "snippet": "static int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/timer.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_flush_asts(struct dlm_ctxt *dlm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/timer.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_flush_asts(struct dlm_ctxt *dlm);\n\nstatic int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_bug_on_msg",
          "args": [
            "!list_empty(&res->l_blocked_list)",
            "\"Lockres %s is on the blocked list\\n\"",
            "res->l_name"
          ],
          "line": 729
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_remove_lockres_tracking",
          "args": [
            "res"
          ],
          "line": 727
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_remove_lockres_tracking",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlmglue.c",
          "lines": "423-429",
          "snippet": "static void ocfs2_remove_lockres_tracking(struct ocfs2_lock_res *res)\n{\n\tspin_lock(&ocfs2_dlm_tracking_lock);\n\tif (!list_empty(&res->l_debug_list))\n\t\tlist_del_init(&res->l_debug_list);\n\tspin_unlock(&ocfs2_dlm_tracking_lock);\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"refcounttree.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"stackglue.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dcache.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2_lockingver.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/time.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/kthread.h>",
            "#include <linux/mm.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_SPINLOCK(ocfs2_dlm_tracking_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"stackglue.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dcache.h\"\n#include \"alloc.h\"\n#include \"ocfs2_lockingver.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/quotaops.h>\n#include <linux/time.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/pagemap.h>\n#include <linux/kthread.h>\n#include <linux/mm.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic DEFINE_SPINLOCK(ocfs2_dlm_tracking_lock);\n\nstatic void ocfs2_remove_lockres_tracking(struct ocfs2_lock_res *res)\n{\n\tspin_lock(&ocfs2_dlm_tracking_lock);\n\tif (!list_empty(&res->l_debug_list))\n\t\tlist_del_init(&res->l_debug_list);\n\tspin_unlock(&ocfs2_dlm_tracking_lock);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"stackglue.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dcache.h\"\n#include \"alloc.h\"\n#include \"ocfs2_lockingver.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/quotaops.h>\n#include <linux/time.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/pagemap.h>\n#include <linux/kthread.h>\n#include <linux/mm.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nvoid ocfs2_lock_res_free(struct ocfs2_lock_res *res)\n{\n\tif (!(res->l_flags & OCFS2_LOCK_INITIALIZED))\n\t\treturn;\n\n\tocfs2_remove_lockres_tracking(res);\n\n\tmlog_bug_on_msg(!list_empty(&res->l_blocked_list),\n\t\t\t\"Lockres %s is on the blocked list\\n\",\n\t\t\tres->l_name);\n\tmlog_bug_on_msg(!list_empty(&res->l_mask_waiters),\n\t\t\t\"Lockres %s has mask waiters pending\\n\",\n\t\t\tres->l_name);\n\tmlog_bug_on_msg(spin_is_locked(&res->l_lock),\n\t\t\t\"Lockres %s is locked\\n\",\n\t\t\tres->l_name);\n\tmlog_bug_on_msg(res->l_ro_holders,\n\t\t\t\"Lockres %s has %u ro holders\\n\",\n\t\t\tres->l_name, res->l_ro_holders);\n\tmlog_bug_on_msg(res->l_ex_holders,\n\t\t\t\"Lockres %s has %u ex holders\\n\",\n\t\t\tres->l_name, res->l_ex_holders);\n\n\t/* Need to clear out the lock status block for the dlm */\n\tmemset(&res->l_lksb, 0, sizeof(res->l_lksb));\n\n\tres->l_flags = 0UL;\n}"
  },
  {
    "function_name": "ocfs2_refcount_lock_res_init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlmglue.c",
    "lines": "711-720",
    "snippet": "void ocfs2_refcount_lock_res_init(struct ocfs2_lock_res *lockres,\n\t\t\t\t  struct ocfs2_super *osb, u64 ref_blkno,\n\t\t\t\t  unsigned int generation)\n{\n\tocfs2_lock_res_init_once(lockres);\n\tocfs2_build_lock_name(OCFS2_LOCK_TYPE_REFCOUNT, ref_blkno,\n\t\t\t      generation, lockres->l_name);\n\tocfs2_lock_res_init_common(osb, lockres, OCFS2_LOCK_TYPE_REFCOUNT,\n\t\t\t\t   &ocfs2_refcount_block_lops, osb);\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"refcounttree.h\"",
      "#include \"quota.h\"",
      "#include \"uptodate.h\"",
      "#include \"super.h\"",
      "#include \"slot_map.h\"",
      "#include \"stackglue.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"heartbeat.h\"",
      "#include \"file.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"dcache.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2_lockingver.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/time.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/kthread.h>",
      "#include <linux/mm.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct ocfs2_super *ocfs2_get_dentry_osb(struct ocfs2_lock_res *lockres);",
      "static struct ocfs2_super *ocfs2_get_inode_osb(struct ocfs2_lock_res *lockres);",
      "static struct ocfs2_super *ocfs2_get_file_osb(struct ocfs2_lock_res *lockres);",
      "static struct ocfs2_super *ocfs2_get_qinfo_osb(struct ocfs2_lock_res *lockres);",
      "static void ocfs2_set_meta_lvb(struct ocfs2_lock_res *lockres);",
      "static void ocfs2_dentry_post_unlock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres);",
      "static void ocfs2_set_qinfo_lvb(struct ocfs2_lock_res *lockres);",
      "static struct ocfs2_lock_res_ops ocfs2_refcount_block_lops = {\n\t.check_downconvert = ocfs2_check_refcount_downconvert,\n\t.downconvert_worker = ocfs2_refcount_convert_worker,\n\t.flags\t\t= 0,\n};",
      "static inline void ocfs2_generic_handle_downconvert_action(struct ocfs2_lock_res *lockres);",
      "static inline void ocfs2_generic_handle_convert_action(struct ocfs2_lock_res *lockres);",
      "static inline void ocfs2_generic_handle_attach_action(struct ocfs2_lock_res *lockres);",
      "static void ocfs2_schedule_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);",
      "static void ocfs2_downconvert_on_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);",
      "static void ocfs2_drop_osb_locks(struct ocfs2_super *osb);",
      "static int ocfs2_downconvert_lock(struct ocfs2_super *osb,\n\t\t\t\t  struct ocfs2_lock_res *lockres,\n\t\t\t\t  int new_level,\n\t\t\t\t  int lvb,\n\t\t\t\t  unsigned int generation);",
      "static int ocfs2_prepare_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\t        struct ocfs2_lock_res *lockres);",
      "static int ocfs2_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres);",
      "static void ocfs2_process_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *lockres);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ocfs2_lock_res_init_common",
          "args": [
            "osb",
            "lockres",
            "OCFS2_LOCK_TYPE_REFCOUNT",
            "&ocfs2_refcount_block_lops",
            "osb"
          ],
          "line": 718
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_lock_res_init_common",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlmglue.c",
          "lines": "496-524",
          "snippet": "static void ocfs2_lock_res_init_common(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *res,\n\t\t\t\t       enum ocfs2_lock_type type,\n\t\t\t\t       struct ocfs2_lock_res_ops *ops,\n\t\t\t\t       void *priv)\n{\n\tres->l_type          = type;\n\tres->l_ops           = ops;\n\tres->l_priv          = priv;\n\n\tres->l_level         = DLM_LOCK_IV;\n\tres->l_requested     = DLM_LOCK_IV;\n\tres->l_blocking      = DLM_LOCK_IV;\n\tres->l_action        = OCFS2_AST_INVALID;\n\tres->l_unlock_action = OCFS2_UNLOCK_INVALID;\n\n\tres->l_flags         = OCFS2_LOCK_INITIALIZED;\n\n\tocfs2_add_lockres_tracking(res, osb->osb_dlm_debug);\n\n\tocfs2_init_lock_stats(res);\n#ifdef CONFIG_DEBUG_LOCK_ALLOC\n\tif (type != OCFS2_LOCK_TYPE_OPEN)\n\t\tlockdep_init_map(&res->l_lockdep_map, ocfs2_lock_type_strings[type],\n\t\t\t\t &lockdep_keys[type], 0);\n\telse\n\t\tres->l_lockdep_map.key = NULL;\n#endif\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"refcounttree.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"stackglue.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dcache.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2_lockingver.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/time.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/kthread.h>",
            "#include <linux/mm.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct lock_class_key lockdep_keys[OCFS2_NUM_LOCK_TYPES];",
            "static void ocfs2_drop_osb_locks(struct ocfs2_super *osb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"stackglue.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dcache.h\"\n#include \"alloc.h\"\n#include \"ocfs2_lockingver.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/quotaops.h>\n#include <linux/time.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/pagemap.h>\n#include <linux/kthread.h>\n#include <linux/mm.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstruct lock_class_key lockdep_keys[OCFS2_NUM_LOCK_TYPES];\nstatic void ocfs2_drop_osb_locks(struct ocfs2_super *osb);\n\nstatic void ocfs2_lock_res_init_common(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *res,\n\t\t\t\t       enum ocfs2_lock_type type,\n\t\t\t\t       struct ocfs2_lock_res_ops *ops,\n\t\t\t\t       void *priv)\n{\n\tres->l_type          = type;\n\tres->l_ops           = ops;\n\tres->l_priv          = priv;\n\n\tres->l_level         = DLM_LOCK_IV;\n\tres->l_requested     = DLM_LOCK_IV;\n\tres->l_blocking      = DLM_LOCK_IV;\n\tres->l_action        = OCFS2_AST_INVALID;\n\tres->l_unlock_action = OCFS2_UNLOCK_INVALID;\n\n\tres->l_flags         = OCFS2_LOCK_INITIALIZED;\n\n\tocfs2_add_lockres_tracking(res, osb->osb_dlm_debug);\n\n\tocfs2_init_lock_stats(res);\n#ifdef CONFIG_DEBUG_LOCK_ALLOC\n\tif (type != OCFS2_LOCK_TYPE_OPEN)\n\t\tlockdep_init_map(&res->l_lockdep_map, ocfs2_lock_type_strings[type],\n\t\t\t\t &lockdep_keys[type], 0);\n\telse\n\t\tres->l_lockdep_map.key = NULL;\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_build_lock_name",
          "args": [
            "OCFS2_LOCK_TYPE_REFCOUNT",
            "ref_blkno",
            "generation",
            "lockres->l_name"
          ],
          "line": 716
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_build_lock_name",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlmglue.c",
          "lines": "393-409",
          "snippet": "static void ocfs2_build_lock_name(enum ocfs2_lock_type type,\n\t\t\t\t  u64 blkno,\n\t\t\t\t  u32 generation,\n\t\t\t\t  char *name)\n{\n\tint len;\n\n\tBUG_ON(type >= OCFS2_NUM_LOCK_TYPES);\n\n\tlen = snprintf(name, OCFS2_LOCK_ID_MAX_LEN, \"%c%s%016llx%08x\",\n\t\t       ocfs2_lock_type_char(type), OCFS2_LOCK_ID_PAD,\n\t\t       (long long)blkno, generation);\n\n\tBUG_ON(len != (OCFS2_LOCK_ID_MAX_LEN - 1));\n\n\tmlog(0, \"built lock resource with name: %s\\n\", name);\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"refcounttree.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"stackglue.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dcache.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2_lockingver.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/time.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/kthread.h>",
            "#include <linux/mm.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ocfs2_downconvert_lock(struct ocfs2_super *osb,\n\t\t\t\t  struct ocfs2_lock_res *lockres,\n\t\t\t\t  int new_level,\n\t\t\t\t  int lvb,\n\t\t\t\t  unsigned int generation);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"stackglue.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dcache.h\"\n#include \"alloc.h\"\n#include \"ocfs2_lockingver.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/quotaops.h>\n#include <linux/time.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/pagemap.h>\n#include <linux/kthread.h>\n#include <linux/mm.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic int ocfs2_downconvert_lock(struct ocfs2_super *osb,\n\t\t\t\t  struct ocfs2_lock_res *lockres,\n\t\t\t\t  int new_level,\n\t\t\t\t  int lvb,\n\t\t\t\t  unsigned int generation);\n\nstatic void ocfs2_build_lock_name(enum ocfs2_lock_type type,\n\t\t\t\t  u64 blkno,\n\t\t\t\t  u32 generation,\n\t\t\t\t  char *name)\n{\n\tint len;\n\n\tBUG_ON(type >= OCFS2_NUM_LOCK_TYPES);\n\n\tlen = snprintf(name, OCFS2_LOCK_ID_MAX_LEN, \"%c%s%016llx%08x\",\n\t\t       ocfs2_lock_type_char(type), OCFS2_LOCK_ID_PAD,\n\t\t       (long long)blkno, generation);\n\n\tBUG_ON(len != (OCFS2_LOCK_ID_MAX_LEN - 1));\n\n\tmlog(0, \"built lock resource with name: %s\\n\", name);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_lock_res_init_once",
          "args": [
            "lockres"
          ],
          "line": 715
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_lock_res_init_once",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlmglue.c",
          "lines": "526-534",
          "snippet": "void ocfs2_lock_res_init_once(struct ocfs2_lock_res *res)\n{\n\t/* This also clears out the lock status block */\n\tmemset(res, 0, sizeof(struct ocfs2_lock_res));\n\tspin_lock_init(&res->l_lock);\n\tinit_waitqueue_head(&res->l_event);\n\tINIT_LIST_HEAD(&res->l_blocked_list);\n\tINIT_LIST_HEAD(&res->l_mask_waiters);\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"refcounttree.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"stackglue.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dcache.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2_lockingver.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/time.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/kthread.h>",
            "#include <linux/mm.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"stackglue.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dcache.h\"\n#include \"alloc.h\"\n#include \"ocfs2_lockingver.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/quotaops.h>\n#include <linux/time.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/pagemap.h>\n#include <linux/kthread.h>\n#include <linux/mm.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nvoid ocfs2_lock_res_init_once(struct ocfs2_lock_res *res)\n{\n\t/* This also clears out the lock status block */\n\tmemset(res, 0, sizeof(struct ocfs2_lock_res));\n\tspin_lock_init(&res->l_lock);\n\tinit_waitqueue_head(&res->l_event);\n\tINIT_LIST_HEAD(&res->l_blocked_list);\n\tINIT_LIST_HEAD(&res->l_mask_waiters);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"stackglue.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dcache.h\"\n#include \"alloc.h\"\n#include \"ocfs2_lockingver.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/quotaops.h>\n#include <linux/time.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/pagemap.h>\n#include <linux/kthread.h>\n#include <linux/mm.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic struct ocfs2_super *ocfs2_get_dentry_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_inode_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_file_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_qinfo_osb(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_set_meta_lvb(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_dentry_post_unlock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres);\nstatic void ocfs2_set_qinfo_lvb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_lock_res_ops ocfs2_refcount_block_lops = {\n\t.check_downconvert = ocfs2_check_refcount_downconvert,\n\t.downconvert_worker = ocfs2_refcount_convert_worker,\n\t.flags\t\t= 0,\n};\nstatic inline void ocfs2_generic_handle_downconvert_action(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_convert_action(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_attach_action(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_schedule_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_downconvert_on_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_drop_osb_locks(struct ocfs2_super *osb);\nstatic int ocfs2_downconvert_lock(struct ocfs2_super *osb,\n\t\t\t\t  struct ocfs2_lock_res *lockres,\n\t\t\t\t  int new_level,\n\t\t\t\t  int lvb,\n\t\t\t\t  unsigned int generation);\nstatic int ocfs2_prepare_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\t        struct ocfs2_lock_res *lockres);\nstatic int ocfs2_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_process_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *lockres);\n\nvoid ocfs2_refcount_lock_res_init(struct ocfs2_lock_res *lockres,\n\t\t\t\t  struct ocfs2_super *osb, u64 ref_blkno,\n\t\t\t\t  unsigned int generation)\n{\n\tocfs2_lock_res_init_once(lockres);\n\tocfs2_build_lock_name(OCFS2_LOCK_TYPE_REFCOUNT, ref_blkno,\n\t\t\t      generation, lockres->l_name);\n\tocfs2_lock_res_init_common(osb, lockres, OCFS2_LOCK_TYPE_REFCOUNT,\n\t\t\t\t   &ocfs2_refcount_block_lops, osb);\n}"
  },
  {
    "function_name": "ocfs2_qinfo_lock_res_init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlmglue.c",
    "lines": "700-709",
    "snippet": "void ocfs2_qinfo_lock_res_init(struct ocfs2_lock_res *lockres,\n\t\t\t       struct ocfs2_mem_dqinfo *info)\n{\n\tocfs2_lock_res_init_once(lockres);\n\tocfs2_build_lock_name(OCFS2_LOCK_TYPE_QINFO, info->dqi_gi.dqi_type,\n\t\t\t      0, lockres->l_name);\n\tocfs2_lock_res_init_common(OCFS2_SB(info->dqi_gi.dqi_sb), lockres,\n\t\t\t\t   OCFS2_LOCK_TYPE_QINFO, &ocfs2_qinfo_lops,\n\t\t\t\t   info);\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"refcounttree.h\"",
      "#include \"quota.h\"",
      "#include \"uptodate.h\"",
      "#include \"super.h\"",
      "#include \"slot_map.h\"",
      "#include \"stackglue.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"heartbeat.h\"",
      "#include \"file.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"dcache.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2_lockingver.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/time.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/kthread.h>",
      "#include <linux/mm.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct ocfs2_super *ocfs2_get_dentry_osb(struct ocfs2_lock_res *lockres);",
      "static struct ocfs2_super *ocfs2_get_inode_osb(struct ocfs2_lock_res *lockres);",
      "static struct ocfs2_super *ocfs2_get_file_osb(struct ocfs2_lock_res *lockres);",
      "static struct ocfs2_super *ocfs2_get_qinfo_osb(struct ocfs2_lock_res *lockres);",
      "static void ocfs2_set_meta_lvb(struct ocfs2_lock_res *lockres);",
      "static void ocfs2_dentry_post_unlock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres);",
      "static void ocfs2_set_qinfo_lvb(struct ocfs2_lock_res *lockres);",
      "static struct ocfs2_lock_res_ops ocfs2_qinfo_lops = {\n\t.set_lvb\t= ocfs2_set_qinfo_lvb,\n\t.get_osb\t= ocfs2_get_qinfo_osb,\n\t.flags\t\t= LOCK_TYPE_REQUIRES_REFRESH | LOCK_TYPE_USES_LVB,\n};",
      "static inline void ocfs2_generic_handle_downconvert_action(struct ocfs2_lock_res *lockres);",
      "static inline void ocfs2_generic_handle_convert_action(struct ocfs2_lock_res *lockres);",
      "static inline void ocfs2_generic_handle_attach_action(struct ocfs2_lock_res *lockres);",
      "static void ocfs2_schedule_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);",
      "static void ocfs2_downconvert_on_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);",
      "static int ocfs2_prepare_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\t        struct ocfs2_lock_res *lockres);",
      "static int ocfs2_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres);",
      "static void ocfs2_process_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *lockres);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ocfs2_lock_res_init_common",
          "args": [
            "OCFS2_SB(info->dqi_gi.dqi_sb)",
            "lockres",
            "OCFS2_LOCK_TYPE_QINFO",
            "&ocfs2_qinfo_lops",
            "info"
          ],
          "line": 706
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_lock_res_init_common",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlmglue.c",
          "lines": "496-524",
          "snippet": "static void ocfs2_lock_res_init_common(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *res,\n\t\t\t\t       enum ocfs2_lock_type type,\n\t\t\t\t       struct ocfs2_lock_res_ops *ops,\n\t\t\t\t       void *priv)\n{\n\tres->l_type          = type;\n\tres->l_ops           = ops;\n\tres->l_priv          = priv;\n\n\tres->l_level         = DLM_LOCK_IV;\n\tres->l_requested     = DLM_LOCK_IV;\n\tres->l_blocking      = DLM_LOCK_IV;\n\tres->l_action        = OCFS2_AST_INVALID;\n\tres->l_unlock_action = OCFS2_UNLOCK_INVALID;\n\n\tres->l_flags         = OCFS2_LOCK_INITIALIZED;\n\n\tocfs2_add_lockres_tracking(res, osb->osb_dlm_debug);\n\n\tocfs2_init_lock_stats(res);\n#ifdef CONFIG_DEBUG_LOCK_ALLOC\n\tif (type != OCFS2_LOCK_TYPE_OPEN)\n\t\tlockdep_init_map(&res->l_lockdep_map, ocfs2_lock_type_strings[type],\n\t\t\t\t &lockdep_keys[type], 0);\n\telse\n\t\tres->l_lockdep_map.key = NULL;\n#endif\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"refcounttree.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"stackglue.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dcache.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2_lockingver.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/time.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/kthread.h>",
            "#include <linux/mm.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct lock_class_key lockdep_keys[OCFS2_NUM_LOCK_TYPES];",
            "static void ocfs2_drop_osb_locks(struct ocfs2_super *osb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"stackglue.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dcache.h\"\n#include \"alloc.h\"\n#include \"ocfs2_lockingver.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/quotaops.h>\n#include <linux/time.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/pagemap.h>\n#include <linux/kthread.h>\n#include <linux/mm.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstruct lock_class_key lockdep_keys[OCFS2_NUM_LOCK_TYPES];\nstatic void ocfs2_drop_osb_locks(struct ocfs2_super *osb);\n\nstatic void ocfs2_lock_res_init_common(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *res,\n\t\t\t\t       enum ocfs2_lock_type type,\n\t\t\t\t       struct ocfs2_lock_res_ops *ops,\n\t\t\t\t       void *priv)\n{\n\tres->l_type          = type;\n\tres->l_ops           = ops;\n\tres->l_priv          = priv;\n\n\tres->l_level         = DLM_LOCK_IV;\n\tres->l_requested     = DLM_LOCK_IV;\n\tres->l_blocking      = DLM_LOCK_IV;\n\tres->l_action        = OCFS2_AST_INVALID;\n\tres->l_unlock_action = OCFS2_UNLOCK_INVALID;\n\n\tres->l_flags         = OCFS2_LOCK_INITIALIZED;\n\n\tocfs2_add_lockres_tracking(res, osb->osb_dlm_debug);\n\n\tocfs2_init_lock_stats(res);\n#ifdef CONFIG_DEBUG_LOCK_ALLOC\n\tif (type != OCFS2_LOCK_TYPE_OPEN)\n\t\tlockdep_init_map(&res->l_lockdep_map, ocfs2_lock_type_strings[type],\n\t\t\t\t &lockdep_keys[type], 0);\n\telse\n\t\tres->l_lockdep_map.key = NULL;\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "OCFS2_SB",
          "args": [
            "info->dqi_gi.dqi_sb"
          ],
          "line": 706
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_build_lock_name",
          "args": [
            "OCFS2_LOCK_TYPE_QINFO",
            "info->dqi_gi.dqi_type",
            "0",
            "lockres->l_name"
          ],
          "line": 704
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_build_lock_name",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlmglue.c",
          "lines": "393-409",
          "snippet": "static void ocfs2_build_lock_name(enum ocfs2_lock_type type,\n\t\t\t\t  u64 blkno,\n\t\t\t\t  u32 generation,\n\t\t\t\t  char *name)\n{\n\tint len;\n\n\tBUG_ON(type >= OCFS2_NUM_LOCK_TYPES);\n\n\tlen = snprintf(name, OCFS2_LOCK_ID_MAX_LEN, \"%c%s%016llx%08x\",\n\t\t       ocfs2_lock_type_char(type), OCFS2_LOCK_ID_PAD,\n\t\t       (long long)blkno, generation);\n\n\tBUG_ON(len != (OCFS2_LOCK_ID_MAX_LEN - 1));\n\n\tmlog(0, \"built lock resource with name: %s\\n\", name);\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"refcounttree.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"stackglue.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dcache.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2_lockingver.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/time.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/kthread.h>",
            "#include <linux/mm.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ocfs2_downconvert_lock(struct ocfs2_super *osb,\n\t\t\t\t  struct ocfs2_lock_res *lockres,\n\t\t\t\t  int new_level,\n\t\t\t\t  int lvb,\n\t\t\t\t  unsigned int generation);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"stackglue.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dcache.h\"\n#include \"alloc.h\"\n#include \"ocfs2_lockingver.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/quotaops.h>\n#include <linux/time.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/pagemap.h>\n#include <linux/kthread.h>\n#include <linux/mm.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic int ocfs2_downconvert_lock(struct ocfs2_super *osb,\n\t\t\t\t  struct ocfs2_lock_res *lockres,\n\t\t\t\t  int new_level,\n\t\t\t\t  int lvb,\n\t\t\t\t  unsigned int generation);\n\nstatic void ocfs2_build_lock_name(enum ocfs2_lock_type type,\n\t\t\t\t  u64 blkno,\n\t\t\t\t  u32 generation,\n\t\t\t\t  char *name)\n{\n\tint len;\n\n\tBUG_ON(type >= OCFS2_NUM_LOCK_TYPES);\n\n\tlen = snprintf(name, OCFS2_LOCK_ID_MAX_LEN, \"%c%s%016llx%08x\",\n\t\t       ocfs2_lock_type_char(type), OCFS2_LOCK_ID_PAD,\n\t\t       (long long)blkno, generation);\n\n\tBUG_ON(len != (OCFS2_LOCK_ID_MAX_LEN - 1));\n\n\tmlog(0, \"built lock resource with name: %s\\n\", name);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_lock_res_init_once",
          "args": [
            "lockres"
          ],
          "line": 703
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_lock_res_init_once",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlmglue.c",
          "lines": "526-534",
          "snippet": "void ocfs2_lock_res_init_once(struct ocfs2_lock_res *res)\n{\n\t/* This also clears out the lock status block */\n\tmemset(res, 0, sizeof(struct ocfs2_lock_res));\n\tspin_lock_init(&res->l_lock);\n\tinit_waitqueue_head(&res->l_event);\n\tINIT_LIST_HEAD(&res->l_blocked_list);\n\tINIT_LIST_HEAD(&res->l_mask_waiters);\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"refcounttree.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"stackglue.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dcache.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2_lockingver.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/time.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/kthread.h>",
            "#include <linux/mm.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"stackglue.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dcache.h\"\n#include \"alloc.h\"\n#include \"ocfs2_lockingver.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/quotaops.h>\n#include <linux/time.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/pagemap.h>\n#include <linux/kthread.h>\n#include <linux/mm.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nvoid ocfs2_lock_res_init_once(struct ocfs2_lock_res *res)\n{\n\t/* This also clears out the lock status block */\n\tmemset(res, 0, sizeof(struct ocfs2_lock_res));\n\tspin_lock_init(&res->l_lock);\n\tinit_waitqueue_head(&res->l_event);\n\tINIT_LIST_HEAD(&res->l_blocked_list);\n\tINIT_LIST_HEAD(&res->l_mask_waiters);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"stackglue.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dcache.h\"\n#include \"alloc.h\"\n#include \"ocfs2_lockingver.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/quotaops.h>\n#include <linux/time.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/pagemap.h>\n#include <linux/kthread.h>\n#include <linux/mm.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic struct ocfs2_super *ocfs2_get_dentry_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_inode_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_file_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_qinfo_osb(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_set_meta_lvb(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_dentry_post_unlock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres);\nstatic void ocfs2_set_qinfo_lvb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_lock_res_ops ocfs2_qinfo_lops = {\n\t.set_lvb\t= ocfs2_set_qinfo_lvb,\n\t.get_osb\t= ocfs2_get_qinfo_osb,\n\t.flags\t\t= LOCK_TYPE_REQUIRES_REFRESH | LOCK_TYPE_USES_LVB,\n};\nstatic inline void ocfs2_generic_handle_downconvert_action(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_convert_action(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_attach_action(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_schedule_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_downconvert_on_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic int ocfs2_prepare_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\t        struct ocfs2_lock_res *lockres);\nstatic int ocfs2_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_process_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *lockres);\n\nvoid ocfs2_qinfo_lock_res_init(struct ocfs2_lock_res *lockres,\n\t\t\t       struct ocfs2_mem_dqinfo *info)\n{\n\tocfs2_lock_res_init_once(lockres);\n\tocfs2_build_lock_name(OCFS2_LOCK_TYPE_QINFO, info->dqi_gi.dqi_type,\n\t\t\t      0, lockres->l_name);\n\tocfs2_lock_res_init_common(OCFS2_SB(info->dqi_gi.dqi_sb), lockres,\n\t\t\t\t   OCFS2_LOCK_TYPE_QINFO, &ocfs2_qinfo_lops,\n\t\t\t\t   info);\n}"
  },
  {
    "function_name": "ocfs2_file_lock_res_init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlmglue.c",
    "lines": "685-698",
    "snippet": "void ocfs2_file_lock_res_init(struct ocfs2_lock_res *lockres,\n\t\t\t      struct ocfs2_file_private *fp)\n{\n\tstruct inode *inode = fp->fp_file->f_mapping->host;\n\tstruct ocfs2_inode_info *oi = OCFS2_I(inode);\n\n\tocfs2_lock_res_init_once(lockres);\n\tocfs2_build_lock_name(OCFS2_LOCK_TYPE_FLOCK, oi->ip_blkno,\n\t\t\t      inode->i_generation, lockres->l_name);\n\tocfs2_lock_res_init_common(OCFS2_SB(inode->i_sb), lockres,\n\t\t\t\t   OCFS2_LOCK_TYPE_FLOCK, &ocfs2_flock_lops,\n\t\t\t\t   fp);\n\tlockres->l_flags |= OCFS2_LOCK_NOCACHE;\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"refcounttree.h\"",
      "#include \"quota.h\"",
      "#include \"uptodate.h\"",
      "#include \"super.h\"",
      "#include \"slot_map.h\"",
      "#include \"stackglue.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"heartbeat.h\"",
      "#include \"file.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"dcache.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2_lockingver.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/time.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/kthread.h>",
      "#include <linux/mm.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct ocfs2_super *ocfs2_get_dentry_osb(struct ocfs2_lock_res *lockres);",
      "static struct ocfs2_super *ocfs2_get_inode_osb(struct ocfs2_lock_res *lockres);",
      "static struct ocfs2_super *ocfs2_get_file_osb(struct ocfs2_lock_res *lockres);",
      "static struct ocfs2_super *ocfs2_get_qinfo_osb(struct ocfs2_lock_res *lockres);",
      "static void ocfs2_set_meta_lvb(struct ocfs2_lock_res *lockres);",
      "static void ocfs2_dentry_post_unlock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres);",
      "static void ocfs2_set_qinfo_lvb(struct ocfs2_lock_res *lockres);",
      "static struct ocfs2_lock_res_ops ocfs2_flock_lops = {\n\t.get_osb\t= ocfs2_get_file_osb,\n\t.flags\t\t= 0,\n};",
      "static inline void ocfs2_generic_handle_downconvert_action(struct ocfs2_lock_res *lockres);",
      "static inline void ocfs2_generic_handle_convert_action(struct ocfs2_lock_res *lockres);",
      "static inline void ocfs2_generic_handle_attach_action(struct ocfs2_lock_res *lockres);",
      "static void ocfs2_schedule_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);",
      "static void ocfs2_downconvert_on_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);",
      "static int ocfs2_prepare_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\t        struct ocfs2_lock_res *lockres);",
      "static int ocfs2_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres);",
      "static void ocfs2_process_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *lockres);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ocfs2_lock_res_init_common",
          "args": [
            "OCFS2_SB(inode->i_sb)",
            "lockres",
            "OCFS2_LOCK_TYPE_FLOCK",
            "&ocfs2_flock_lops",
            "fp"
          ],
          "line": 694
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_lock_res_init_common",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlmglue.c",
          "lines": "496-524",
          "snippet": "static void ocfs2_lock_res_init_common(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *res,\n\t\t\t\t       enum ocfs2_lock_type type,\n\t\t\t\t       struct ocfs2_lock_res_ops *ops,\n\t\t\t\t       void *priv)\n{\n\tres->l_type          = type;\n\tres->l_ops           = ops;\n\tres->l_priv          = priv;\n\n\tres->l_level         = DLM_LOCK_IV;\n\tres->l_requested     = DLM_LOCK_IV;\n\tres->l_blocking      = DLM_LOCK_IV;\n\tres->l_action        = OCFS2_AST_INVALID;\n\tres->l_unlock_action = OCFS2_UNLOCK_INVALID;\n\n\tres->l_flags         = OCFS2_LOCK_INITIALIZED;\n\n\tocfs2_add_lockres_tracking(res, osb->osb_dlm_debug);\n\n\tocfs2_init_lock_stats(res);\n#ifdef CONFIG_DEBUG_LOCK_ALLOC\n\tif (type != OCFS2_LOCK_TYPE_OPEN)\n\t\tlockdep_init_map(&res->l_lockdep_map, ocfs2_lock_type_strings[type],\n\t\t\t\t &lockdep_keys[type], 0);\n\telse\n\t\tres->l_lockdep_map.key = NULL;\n#endif\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"refcounttree.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"stackglue.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dcache.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2_lockingver.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/time.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/kthread.h>",
            "#include <linux/mm.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct lock_class_key lockdep_keys[OCFS2_NUM_LOCK_TYPES];",
            "static void ocfs2_drop_osb_locks(struct ocfs2_super *osb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"stackglue.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dcache.h\"\n#include \"alloc.h\"\n#include \"ocfs2_lockingver.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/quotaops.h>\n#include <linux/time.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/pagemap.h>\n#include <linux/kthread.h>\n#include <linux/mm.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstruct lock_class_key lockdep_keys[OCFS2_NUM_LOCK_TYPES];\nstatic void ocfs2_drop_osb_locks(struct ocfs2_super *osb);\n\nstatic void ocfs2_lock_res_init_common(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *res,\n\t\t\t\t       enum ocfs2_lock_type type,\n\t\t\t\t       struct ocfs2_lock_res_ops *ops,\n\t\t\t\t       void *priv)\n{\n\tres->l_type          = type;\n\tres->l_ops           = ops;\n\tres->l_priv          = priv;\n\n\tres->l_level         = DLM_LOCK_IV;\n\tres->l_requested     = DLM_LOCK_IV;\n\tres->l_blocking      = DLM_LOCK_IV;\n\tres->l_action        = OCFS2_AST_INVALID;\n\tres->l_unlock_action = OCFS2_UNLOCK_INVALID;\n\n\tres->l_flags         = OCFS2_LOCK_INITIALIZED;\n\n\tocfs2_add_lockres_tracking(res, osb->osb_dlm_debug);\n\n\tocfs2_init_lock_stats(res);\n#ifdef CONFIG_DEBUG_LOCK_ALLOC\n\tif (type != OCFS2_LOCK_TYPE_OPEN)\n\t\tlockdep_init_map(&res->l_lockdep_map, ocfs2_lock_type_strings[type],\n\t\t\t\t &lockdep_keys[type], 0);\n\telse\n\t\tres->l_lockdep_map.key = NULL;\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "OCFS2_SB",
          "args": [
            "inode->i_sb"
          ],
          "line": 694
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_build_lock_name",
          "args": [
            "OCFS2_LOCK_TYPE_FLOCK",
            "oi->ip_blkno",
            "inode->i_generation",
            "lockres->l_name"
          ],
          "line": 692
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_build_lock_name",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlmglue.c",
          "lines": "393-409",
          "snippet": "static void ocfs2_build_lock_name(enum ocfs2_lock_type type,\n\t\t\t\t  u64 blkno,\n\t\t\t\t  u32 generation,\n\t\t\t\t  char *name)\n{\n\tint len;\n\n\tBUG_ON(type >= OCFS2_NUM_LOCK_TYPES);\n\n\tlen = snprintf(name, OCFS2_LOCK_ID_MAX_LEN, \"%c%s%016llx%08x\",\n\t\t       ocfs2_lock_type_char(type), OCFS2_LOCK_ID_PAD,\n\t\t       (long long)blkno, generation);\n\n\tBUG_ON(len != (OCFS2_LOCK_ID_MAX_LEN - 1));\n\n\tmlog(0, \"built lock resource with name: %s\\n\", name);\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"refcounttree.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"stackglue.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dcache.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2_lockingver.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/time.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/kthread.h>",
            "#include <linux/mm.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ocfs2_downconvert_lock(struct ocfs2_super *osb,\n\t\t\t\t  struct ocfs2_lock_res *lockres,\n\t\t\t\t  int new_level,\n\t\t\t\t  int lvb,\n\t\t\t\t  unsigned int generation);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"stackglue.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dcache.h\"\n#include \"alloc.h\"\n#include \"ocfs2_lockingver.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/quotaops.h>\n#include <linux/time.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/pagemap.h>\n#include <linux/kthread.h>\n#include <linux/mm.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic int ocfs2_downconvert_lock(struct ocfs2_super *osb,\n\t\t\t\t  struct ocfs2_lock_res *lockres,\n\t\t\t\t  int new_level,\n\t\t\t\t  int lvb,\n\t\t\t\t  unsigned int generation);\n\nstatic void ocfs2_build_lock_name(enum ocfs2_lock_type type,\n\t\t\t\t  u64 blkno,\n\t\t\t\t  u32 generation,\n\t\t\t\t  char *name)\n{\n\tint len;\n\n\tBUG_ON(type >= OCFS2_NUM_LOCK_TYPES);\n\n\tlen = snprintf(name, OCFS2_LOCK_ID_MAX_LEN, \"%c%s%016llx%08x\",\n\t\t       ocfs2_lock_type_char(type), OCFS2_LOCK_ID_PAD,\n\t\t       (long long)blkno, generation);\n\n\tBUG_ON(len != (OCFS2_LOCK_ID_MAX_LEN - 1));\n\n\tmlog(0, \"built lock resource with name: %s\\n\", name);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_lock_res_init_once",
          "args": [
            "lockres"
          ],
          "line": 691
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_lock_res_init_once",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlmglue.c",
          "lines": "526-534",
          "snippet": "void ocfs2_lock_res_init_once(struct ocfs2_lock_res *res)\n{\n\t/* This also clears out the lock status block */\n\tmemset(res, 0, sizeof(struct ocfs2_lock_res));\n\tspin_lock_init(&res->l_lock);\n\tinit_waitqueue_head(&res->l_event);\n\tINIT_LIST_HEAD(&res->l_blocked_list);\n\tINIT_LIST_HEAD(&res->l_mask_waiters);\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"refcounttree.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"stackglue.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dcache.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2_lockingver.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/time.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/kthread.h>",
            "#include <linux/mm.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"stackglue.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dcache.h\"\n#include \"alloc.h\"\n#include \"ocfs2_lockingver.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/quotaops.h>\n#include <linux/time.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/pagemap.h>\n#include <linux/kthread.h>\n#include <linux/mm.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nvoid ocfs2_lock_res_init_once(struct ocfs2_lock_res *res)\n{\n\t/* This also clears out the lock status block */\n\tmemset(res, 0, sizeof(struct ocfs2_lock_res));\n\tspin_lock_init(&res->l_lock);\n\tinit_waitqueue_head(&res->l_event);\n\tINIT_LIST_HEAD(&res->l_blocked_list);\n\tINIT_LIST_HEAD(&res->l_mask_waiters);\n}"
        }
      },
      {
        "call_info": {
          "callee": "OCFS2_I",
          "args": [
            "inode"
          ],
          "line": 689
        },
        "resolved": true,
        "details": {
          "function_name": "OCFS2_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/inode.h",
          "lines": "118-121",
          "snippet": "static inline struct ocfs2_inode_info *OCFS2_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ocfs2_inode_info, vfs_inode);\n}",
          "includes": [
            "#include \"extent_map.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extent_map.h\"\n\nstatic inline struct ocfs2_inode_info *OCFS2_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ocfs2_inode_info, vfs_inode);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"stackglue.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dcache.h\"\n#include \"alloc.h\"\n#include \"ocfs2_lockingver.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/quotaops.h>\n#include <linux/time.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/pagemap.h>\n#include <linux/kthread.h>\n#include <linux/mm.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic struct ocfs2_super *ocfs2_get_dentry_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_inode_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_file_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_qinfo_osb(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_set_meta_lvb(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_dentry_post_unlock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres);\nstatic void ocfs2_set_qinfo_lvb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_lock_res_ops ocfs2_flock_lops = {\n\t.get_osb\t= ocfs2_get_file_osb,\n\t.flags\t\t= 0,\n};\nstatic inline void ocfs2_generic_handle_downconvert_action(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_convert_action(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_attach_action(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_schedule_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_downconvert_on_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic int ocfs2_prepare_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\t        struct ocfs2_lock_res *lockres);\nstatic int ocfs2_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_process_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *lockres);\n\nvoid ocfs2_file_lock_res_init(struct ocfs2_lock_res *lockres,\n\t\t\t      struct ocfs2_file_private *fp)\n{\n\tstruct inode *inode = fp->fp_file->f_mapping->host;\n\tstruct ocfs2_inode_info *oi = OCFS2_I(inode);\n\n\tocfs2_lock_res_init_once(lockres);\n\tocfs2_build_lock_name(OCFS2_LOCK_TYPE_FLOCK, oi->ip_blkno,\n\t\t\t      inode->i_generation, lockres->l_name);\n\tocfs2_lock_res_init_common(OCFS2_SB(inode->i_sb), lockres,\n\t\t\t\t   OCFS2_LOCK_TYPE_FLOCK, &ocfs2_flock_lops,\n\t\t\t\t   fp);\n\tlockres->l_flags |= OCFS2_LOCK_NOCACHE;\n}"
  },
  {
    "function_name": "ocfs2_orphan_scan_lock_res_init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlmglue.c",
    "lines": "676-683",
    "snippet": "static void ocfs2_orphan_scan_lock_res_init(struct ocfs2_lock_res *res,\n\t\t\t\t\t    struct ocfs2_super *osb)\n{\n\tocfs2_lock_res_init_once(res);\n\tocfs2_build_lock_name(OCFS2_LOCK_TYPE_ORPHAN_SCAN, 0, 0, res->l_name);\n\tocfs2_lock_res_init_common(osb, res, OCFS2_LOCK_TYPE_ORPHAN_SCAN,\n\t\t\t\t   &ocfs2_orphan_scan_lops, osb);\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"refcounttree.h\"",
      "#include \"quota.h\"",
      "#include \"uptodate.h\"",
      "#include \"super.h\"",
      "#include \"slot_map.h\"",
      "#include \"stackglue.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"heartbeat.h\"",
      "#include \"file.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"dcache.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2_lockingver.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/time.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/kthread.h>",
      "#include <linux/mm.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct ocfs2_lock_res_ops ocfs2_orphan_scan_lops = {\n\t.flags\t\t= LOCK_TYPE_REQUIRES_REFRESH|LOCK_TYPE_USES_LVB,\n};",
      "static void ocfs2_drop_osb_locks(struct ocfs2_super *osb);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ocfs2_lock_res_init_common",
          "args": [
            "osb",
            "res",
            "OCFS2_LOCK_TYPE_ORPHAN_SCAN",
            "&ocfs2_orphan_scan_lops",
            "osb"
          ],
          "line": 681
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_lock_res_init_common",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlmglue.c",
          "lines": "496-524",
          "snippet": "static void ocfs2_lock_res_init_common(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *res,\n\t\t\t\t       enum ocfs2_lock_type type,\n\t\t\t\t       struct ocfs2_lock_res_ops *ops,\n\t\t\t\t       void *priv)\n{\n\tres->l_type          = type;\n\tres->l_ops           = ops;\n\tres->l_priv          = priv;\n\n\tres->l_level         = DLM_LOCK_IV;\n\tres->l_requested     = DLM_LOCK_IV;\n\tres->l_blocking      = DLM_LOCK_IV;\n\tres->l_action        = OCFS2_AST_INVALID;\n\tres->l_unlock_action = OCFS2_UNLOCK_INVALID;\n\n\tres->l_flags         = OCFS2_LOCK_INITIALIZED;\n\n\tocfs2_add_lockres_tracking(res, osb->osb_dlm_debug);\n\n\tocfs2_init_lock_stats(res);\n#ifdef CONFIG_DEBUG_LOCK_ALLOC\n\tif (type != OCFS2_LOCK_TYPE_OPEN)\n\t\tlockdep_init_map(&res->l_lockdep_map, ocfs2_lock_type_strings[type],\n\t\t\t\t &lockdep_keys[type], 0);\n\telse\n\t\tres->l_lockdep_map.key = NULL;\n#endif\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"refcounttree.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"stackglue.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dcache.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2_lockingver.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/time.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/kthread.h>",
            "#include <linux/mm.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct lock_class_key lockdep_keys[OCFS2_NUM_LOCK_TYPES];",
            "static void ocfs2_drop_osb_locks(struct ocfs2_super *osb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"stackglue.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dcache.h\"\n#include \"alloc.h\"\n#include \"ocfs2_lockingver.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/quotaops.h>\n#include <linux/time.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/pagemap.h>\n#include <linux/kthread.h>\n#include <linux/mm.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstruct lock_class_key lockdep_keys[OCFS2_NUM_LOCK_TYPES];\nstatic void ocfs2_drop_osb_locks(struct ocfs2_super *osb);\n\nstatic void ocfs2_lock_res_init_common(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *res,\n\t\t\t\t       enum ocfs2_lock_type type,\n\t\t\t\t       struct ocfs2_lock_res_ops *ops,\n\t\t\t\t       void *priv)\n{\n\tres->l_type          = type;\n\tres->l_ops           = ops;\n\tres->l_priv          = priv;\n\n\tres->l_level         = DLM_LOCK_IV;\n\tres->l_requested     = DLM_LOCK_IV;\n\tres->l_blocking      = DLM_LOCK_IV;\n\tres->l_action        = OCFS2_AST_INVALID;\n\tres->l_unlock_action = OCFS2_UNLOCK_INVALID;\n\n\tres->l_flags         = OCFS2_LOCK_INITIALIZED;\n\n\tocfs2_add_lockres_tracking(res, osb->osb_dlm_debug);\n\n\tocfs2_init_lock_stats(res);\n#ifdef CONFIG_DEBUG_LOCK_ALLOC\n\tif (type != OCFS2_LOCK_TYPE_OPEN)\n\t\tlockdep_init_map(&res->l_lockdep_map, ocfs2_lock_type_strings[type],\n\t\t\t\t &lockdep_keys[type], 0);\n\telse\n\t\tres->l_lockdep_map.key = NULL;\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_build_lock_name",
          "args": [
            "OCFS2_LOCK_TYPE_ORPHAN_SCAN",
            "0",
            "0",
            "res->l_name"
          ],
          "line": 680
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_build_lock_name",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlmglue.c",
          "lines": "393-409",
          "snippet": "static void ocfs2_build_lock_name(enum ocfs2_lock_type type,\n\t\t\t\t  u64 blkno,\n\t\t\t\t  u32 generation,\n\t\t\t\t  char *name)\n{\n\tint len;\n\n\tBUG_ON(type >= OCFS2_NUM_LOCK_TYPES);\n\n\tlen = snprintf(name, OCFS2_LOCK_ID_MAX_LEN, \"%c%s%016llx%08x\",\n\t\t       ocfs2_lock_type_char(type), OCFS2_LOCK_ID_PAD,\n\t\t       (long long)blkno, generation);\n\n\tBUG_ON(len != (OCFS2_LOCK_ID_MAX_LEN - 1));\n\n\tmlog(0, \"built lock resource with name: %s\\n\", name);\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"refcounttree.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"stackglue.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dcache.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2_lockingver.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/time.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/kthread.h>",
            "#include <linux/mm.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ocfs2_downconvert_lock(struct ocfs2_super *osb,\n\t\t\t\t  struct ocfs2_lock_res *lockres,\n\t\t\t\t  int new_level,\n\t\t\t\t  int lvb,\n\t\t\t\t  unsigned int generation);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"stackglue.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dcache.h\"\n#include \"alloc.h\"\n#include \"ocfs2_lockingver.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/quotaops.h>\n#include <linux/time.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/pagemap.h>\n#include <linux/kthread.h>\n#include <linux/mm.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic int ocfs2_downconvert_lock(struct ocfs2_super *osb,\n\t\t\t\t  struct ocfs2_lock_res *lockres,\n\t\t\t\t  int new_level,\n\t\t\t\t  int lvb,\n\t\t\t\t  unsigned int generation);\n\nstatic void ocfs2_build_lock_name(enum ocfs2_lock_type type,\n\t\t\t\t  u64 blkno,\n\t\t\t\t  u32 generation,\n\t\t\t\t  char *name)\n{\n\tint len;\n\n\tBUG_ON(type >= OCFS2_NUM_LOCK_TYPES);\n\n\tlen = snprintf(name, OCFS2_LOCK_ID_MAX_LEN, \"%c%s%016llx%08x\",\n\t\t       ocfs2_lock_type_char(type), OCFS2_LOCK_ID_PAD,\n\t\t       (long long)blkno, generation);\n\n\tBUG_ON(len != (OCFS2_LOCK_ID_MAX_LEN - 1));\n\n\tmlog(0, \"built lock resource with name: %s\\n\", name);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_lock_res_init_once",
          "args": [
            "res"
          ],
          "line": 679
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_lock_res_init_once",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlmglue.c",
          "lines": "526-534",
          "snippet": "void ocfs2_lock_res_init_once(struct ocfs2_lock_res *res)\n{\n\t/* This also clears out the lock status block */\n\tmemset(res, 0, sizeof(struct ocfs2_lock_res));\n\tspin_lock_init(&res->l_lock);\n\tinit_waitqueue_head(&res->l_event);\n\tINIT_LIST_HEAD(&res->l_blocked_list);\n\tINIT_LIST_HEAD(&res->l_mask_waiters);\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"refcounttree.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"stackglue.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dcache.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2_lockingver.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/time.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/kthread.h>",
            "#include <linux/mm.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"stackglue.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dcache.h\"\n#include \"alloc.h\"\n#include \"ocfs2_lockingver.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/quotaops.h>\n#include <linux/time.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/pagemap.h>\n#include <linux/kthread.h>\n#include <linux/mm.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nvoid ocfs2_lock_res_init_once(struct ocfs2_lock_res *res)\n{\n\t/* This also clears out the lock status block */\n\tmemset(res, 0, sizeof(struct ocfs2_lock_res));\n\tspin_lock_init(&res->l_lock);\n\tinit_waitqueue_head(&res->l_event);\n\tINIT_LIST_HEAD(&res->l_blocked_list);\n\tINIT_LIST_HEAD(&res->l_mask_waiters);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"stackglue.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dcache.h\"\n#include \"alloc.h\"\n#include \"ocfs2_lockingver.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/quotaops.h>\n#include <linux/time.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/pagemap.h>\n#include <linux/kthread.h>\n#include <linux/mm.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic struct ocfs2_lock_res_ops ocfs2_orphan_scan_lops = {\n\t.flags\t\t= LOCK_TYPE_REQUIRES_REFRESH|LOCK_TYPE_USES_LVB,\n};\nstatic void ocfs2_drop_osb_locks(struct ocfs2_super *osb);\n\nstatic void ocfs2_orphan_scan_lock_res_init(struct ocfs2_lock_res *res,\n\t\t\t\t\t    struct ocfs2_super *osb)\n{\n\tocfs2_lock_res_init_once(res);\n\tocfs2_build_lock_name(OCFS2_LOCK_TYPE_ORPHAN_SCAN, 0, 0, res->l_name);\n\tocfs2_lock_res_init_common(osb, res, OCFS2_LOCK_TYPE_ORPHAN_SCAN,\n\t\t\t\t   &ocfs2_orphan_scan_lops, osb);\n}"
  },
  {
    "function_name": "ocfs2_nfs_sync_lock_res_init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlmglue.c",
    "lines": "665-674",
    "snippet": "static void ocfs2_nfs_sync_lock_res_init(struct ocfs2_lock_res *res,\n\t\t\t\t\t struct ocfs2_super *osb)\n{\n\t/* nfs_sync lockres doesn't come from a slab so we call init\n\t * once on it manually.  */\n\tocfs2_lock_res_init_once(res);\n\tocfs2_build_lock_name(OCFS2_LOCK_TYPE_NFS_SYNC, 0, 0, res->l_name);\n\tocfs2_lock_res_init_common(osb, res, OCFS2_LOCK_TYPE_NFS_SYNC,\n\t\t\t\t   &ocfs2_nfs_sync_lops, osb);\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"refcounttree.h\"",
      "#include \"quota.h\"",
      "#include \"uptodate.h\"",
      "#include \"super.h\"",
      "#include \"slot_map.h\"",
      "#include \"stackglue.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"heartbeat.h\"",
      "#include \"file.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"dcache.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2_lockingver.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/time.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/kthread.h>",
      "#include <linux/mm.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct ocfs2_super *ocfs2_get_dentry_osb(struct ocfs2_lock_res *lockres);",
      "static struct ocfs2_super *ocfs2_get_inode_osb(struct ocfs2_lock_res *lockres);",
      "static struct ocfs2_super *ocfs2_get_file_osb(struct ocfs2_lock_res *lockres);",
      "static struct ocfs2_super *ocfs2_get_qinfo_osb(struct ocfs2_lock_res *lockres);",
      "static void ocfs2_set_meta_lvb(struct ocfs2_lock_res *lockres);",
      "static void ocfs2_dentry_post_unlock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres);",
      "static void ocfs2_set_qinfo_lvb(struct ocfs2_lock_res *lockres);",
      "static struct ocfs2_lock_res_ops ocfs2_nfs_sync_lops = {\n\t.flags\t\t= 0,\n};",
      "static inline void ocfs2_generic_handle_downconvert_action(struct ocfs2_lock_res *lockres);",
      "static inline void ocfs2_generic_handle_convert_action(struct ocfs2_lock_res *lockres);",
      "static inline void ocfs2_generic_handle_attach_action(struct ocfs2_lock_res *lockres);",
      "static void ocfs2_schedule_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);",
      "static void ocfs2_downconvert_on_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);",
      "static void ocfs2_drop_osb_locks(struct ocfs2_super *osb);",
      "static int ocfs2_prepare_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\t        struct ocfs2_lock_res *lockres);",
      "static int ocfs2_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres);",
      "static void ocfs2_process_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *lockres);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ocfs2_lock_res_init_common",
          "args": [
            "osb",
            "res",
            "OCFS2_LOCK_TYPE_NFS_SYNC",
            "&ocfs2_nfs_sync_lops",
            "osb"
          ],
          "line": 672
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_lock_res_init_common",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlmglue.c",
          "lines": "496-524",
          "snippet": "static void ocfs2_lock_res_init_common(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *res,\n\t\t\t\t       enum ocfs2_lock_type type,\n\t\t\t\t       struct ocfs2_lock_res_ops *ops,\n\t\t\t\t       void *priv)\n{\n\tres->l_type          = type;\n\tres->l_ops           = ops;\n\tres->l_priv          = priv;\n\n\tres->l_level         = DLM_LOCK_IV;\n\tres->l_requested     = DLM_LOCK_IV;\n\tres->l_blocking      = DLM_LOCK_IV;\n\tres->l_action        = OCFS2_AST_INVALID;\n\tres->l_unlock_action = OCFS2_UNLOCK_INVALID;\n\n\tres->l_flags         = OCFS2_LOCK_INITIALIZED;\n\n\tocfs2_add_lockres_tracking(res, osb->osb_dlm_debug);\n\n\tocfs2_init_lock_stats(res);\n#ifdef CONFIG_DEBUG_LOCK_ALLOC\n\tif (type != OCFS2_LOCK_TYPE_OPEN)\n\t\tlockdep_init_map(&res->l_lockdep_map, ocfs2_lock_type_strings[type],\n\t\t\t\t &lockdep_keys[type], 0);\n\telse\n\t\tres->l_lockdep_map.key = NULL;\n#endif\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"refcounttree.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"stackglue.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dcache.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2_lockingver.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/time.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/kthread.h>",
            "#include <linux/mm.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct lock_class_key lockdep_keys[OCFS2_NUM_LOCK_TYPES];",
            "static void ocfs2_drop_osb_locks(struct ocfs2_super *osb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"stackglue.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dcache.h\"\n#include \"alloc.h\"\n#include \"ocfs2_lockingver.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/quotaops.h>\n#include <linux/time.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/pagemap.h>\n#include <linux/kthread.h>\n#include <linux/mm.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstruct lock_class_key lockdep_keys[OCFS2_NUM_LOCK_TYPES];\nstatic void ocfs2_drop_osb_locks(struct ocfs2_super *osb);\n\nstatic void ocfs2_lock_res_init_common(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *res,\n\t\t\t\t       enum ocfs2_lock_type type,\n\t\t\t\t       struct ocfs2_lock_res_ops *ops,\n\t\t\t\t       void *priv)\n{\n\tres->l_type          = type;\n\tres->l_ops           = ops;\n\tres->l_priv          = priv;\n\n\tres->l_level         = DLM_LOCK_IV;\n\tres->l_requested     = DLM_LOCK_IV;\n\tres->l_blocking      = DLM_LOCK_IV;\n\tres->l_action        = OCFS2_AST_INVALID;\n\tres->l_unlock_action = OCFS2_UNLOCK_INVALID;\n\n\tres->l_flags         = OCFS2_LOCK_INITIALIZED;\n\n\tocfs2_add_lockres_tracking(res, osb->osb_dlm_debug);\n\n\tocfs2_init_lock_stats(res);\n#ifdef CONFIG_DEBUG_LOCK_ALLOC\n\tif (type != OCFS2_LOCK_TYPE_OPEN)\n\t\tlockdep_init_map(&res->l_lockdep_map, ocfs2_lock_type_strings[type],\n\t\t\t\t &lockdep_keys[type], 0);\n\telse\n\t\tres->l_lockdep_map.key = NULL;\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_build_lock_name",
          "args": [
            "OCFS2_LOCK_TYPE_NFS_SYNC",
            "0",
            "0",
            "res->l_name"
          ],
          "line": 671
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_build_lock_name",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlmglue.c",
          "lines": "393-409",
          "snippet": "static void ocfs2_build_lock_name(enum ocfs2_lock_type type,\n\t\t\t\t  u64 blkno,\n\t\t\t\t  u32 generation,\n\t\t\t\t  char *name)\n{\n\tint len;\n\n\tBUG_ON(type >= OCFS2_NUM_LOCK_TYPES);\n\n\tlen = snprintf(name, OCFS2_LOCK_ID_MAX_LEN, \"%c%s%016llx%08x\",\n\t\t       ocfs2_lock_type_char(type), OCFS2_LOCK_ID_PAD,\n\t\t       (long long)blkno, generation);\n\n\tBUG_ON(len != (OCFS2_LOCK_ID_MAX_LEN - 1));\n\n\tmlog(0, \"built lock resource with name: %s\\n\", name);\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"refcounttree.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"stackglue.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dcache.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2_lockingver.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/time.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/kthread.h>",
            "#include <linux/mm.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ocfs2_downconvert_lock(struct ocfs2_super *osb,\n\t\t\t\t  struct ocfs2_lock_res *lockres,\n\t\t\t\t  int new_level,\n\t\t\t\t  int lvb,\n\t\t\t\t  unsigned int generation);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"stackglue.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dcache.h\"\n#include \"alloc.h\"\n#include \"ocfs2_lockingver.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/quotaops.h>\n#include <linux/time.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/pagemap.h>\n#include <linux/kthread.h>\n#include <linux/mm.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic int ocfs2_downconvert_lock(struct ocfs2_super *osb,\n\t\t\t\t  struct ocfs2_lock_res *lockres,\n\t\t\t\t  int new_level,\n\t\t\t\t  int lvb,\n\t\t\t\t  unsigned int generation);\n\nstatic void ocfs2_build_lock_name(enum ocfs2_lock_type type,\n\t\t\t\t  u64 blkno,\n\t\t\t\t  u32 generation,\n\t\t\t\t  char *name)\n{\n\tint len;\n\n\tBUG_ON(type >= OCFS2_NUM_LOCK_TYPES);\n\n\tlen = snprintf(name, OCFS2_LOCK_ID_MAX_LEN, \"%c%s%016llx%08x\",\n\t\t       ocfs2_lock_type_char(type), OCFS2_LOCK_ID_PAD,\n\t\t       (long long)blkno, generation);\n\n\tBUG_ON(len != (OCFS2_LOCK_ID_MAX_LEN - 1));\n\n\tmlog(0, \"built lock resource with name: %s\\n\", name);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_lock_res_init_once",
          "args": [
            "res"
          ],
          "line": 670
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_lock_res_init_once",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlmglue.c",
          "lines": "526-534",
          "snippet": "void ocfs2_lock_res_init_once(struct ocfs2_lock_res *res)\n{\n\t/* This also clears out the lock status block */\n\tmemset(res, 0, sizeof(struct ocfs2_lock_res));\n\tspin_lock_init(&res->l_lock);\n\tinit_waitqueue_head(&res->l_event);\n\tINIT_LIST_HEAD(&res->l_blocked_list);\n\tINIT_LIST_HEAD(&res->l_mask_waiters);\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"refcounttree.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"stackglue.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dcache.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2_lockingver.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/time.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/kthread.h>",
            "#include <linux/mm.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"stackglue.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dcache.h\"\n#include \"alloc.h\"\n#include \"ocfs2_lockingver.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/quotaops.h>\n#include <linux/time.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/pagemap.h>\n#include <linux/kthread.h>\n#include <linux/mm.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nvoid ocfs2_lock_res_init_once(struct ocfs2_lock_res *res)\n{\n\t/* This also clears out the lock status block */\n\tmemset(res, 0, sizeof(struct ocfs2_lock_res));\n\tspin_lock_init(&res->l_lock);\n\tinit_waitqueue_head(&res->l_event);\n\tINIT_LIST_HEAD(&res->l_blocked_list);\n\tINIT_LIST_HEAD(&res->l_mask_waiters);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"stackglue.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dcache.h\"\n#include \"alloc.h\"\n#include \"ocfs2_lockingver.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/quotaops.h>\n#include <linux/time.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/pagemap.h>\n#include <linux/kthread.h>\n#include <linux/mm.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic struct ocfs2_super *ocfs2_get_dentry_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_inode_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_file_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_qinfo_osb(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_set_meta_lvb(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_dentry_post_unlock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres);\nstatic void ocfs2_set_qinfo_lvb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_lock_res_ops ocfs2_nfs_sync_lops = {\n\t.flags\t\t= 0,\n};\nstatic inline void ocfs2_generic_handle_downconvert_action(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_convert_action(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_attach_action(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_schedule_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_downconvert_on_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_drop_osb_locks(struct ocfs2_super *osb);\nstatic int ocfs2_prepare_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\t        struct ocfs2_lock_res *lockres);\nstatic int ocfs2_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_process_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *lockres);\n\nstatic void ocfs2_nfs_sync_lock_res_init(struct ocfs2_lock_res *res,\n\t\t\t\t\t struct ocfs2_super *osb)\n{\n\t/* nfs_sync lockres doesn't come from a slab so we call init\n\t * once on it manually.  */\n\tocfs2_lock_res_init_once(res);\n\tocfs2_build_lock_name(OCFS2_LOCK_TYPE_NFS_SYNC, 0, 0, res->l_name);\n\tocfs2_lock_res_init_common(osb, res, OCFS2_LOCK_TYPE_NFS_SYNC,\n\t\t\t\t   &ocfs2_nfs_sync_lops, osb);\n}"
  },
  {
    "function_name": "ocfs2_rename_lock_res_init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlmglue.c",
    "lines": "654-663",
    "snippet": "static void ocfs2_rename_lock_res_init(struct ocfs2_lock_res *res,\n\t\t\t\t       struct ocfs2_super *osb)\n{\n\t/* Rename lockres doesn't come from a slab so we call init\n\t * once on it manually.  */\n\tocfs2_lock_res_init_once(res);\n\tocfs2_build_lock_name(OCFS2_LOCK_TYPE_RENAME, 0, 0, res->l_name);\n\tocfs2_lock_res_init_common(osb, res, OCFS2_LOCK_TYPE_RENAME,\n\t\t\t\t   &ocfs2_rename_lops, osb);\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"refcounttree.h\"",
      "#include \"quota.h\"",
      "#include \"uptodate.h\"",
      "#include \"super.h\"",
      "#include \"slot_map.h\"",
      "#include \"stackglue.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"heartbeat.h\"",
      "#include \"file.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"dcache.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2_lockingver.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/time.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/kthread.h>",
      "#include <linux/mm.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct ocfs2_super *ocfs2_get_dentry_osb(struct ocfs2_lock_res *lockres);",
      "static struct ocfs2_super *ocfs2_get_inode_osb(struct ocfs2_lock_res *lockres);",
      "static struct ocfs2_super *ocfs2_get_file_osb(struct ocfs2_lock_res *lockres);",
      "static struct ocfs2_super *ocfs2_get_qinfo_osb(struct ocfs2_lock_res *lockres);",
      "static void ocfs2_set_meta_lvb(struct ocfs2_lock_res *lockres);",
      "static void ocfs2_dentry_post_unlock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres);",
      "static void ocfs2_set_qinfo_lvb(struct ocfs2_lock_res *lockres);",
      "static struct ocfs2_lock_res_ops ocfs2_rename_lops = {\n\t.flags\t\t= 0,\n};",
      "static inline void ocfs2_generic_handle_downconvert_action(struct ocfs2_lock_res *lockres);",
      "static inline void ocfs2_generic_handle_convert_action(struct ocfs2_lock_res *lockres);",
      "static inline void ocfs2_generic_handle_attach_action(struct ocfs2_lock_res *lockres);",
      "static void ocfs2_schedule_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);",
      "static void ocfs2_downconvert_on_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);",
      "static void ocfs2_drop_osb_locks(struct ocfs2_super *osb);",
      "static int ocfs2_prepare_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\t        struct ocfs2_lock_res *lockres);",
      "static int ocfs2_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres);",
      "static void ocfs2_process_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *lockres);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ocfs2_lock_res_init_common",
          "args": [
            "osb",
            "res",
            "OCFS2_LOCK_TYPE_RENAME",
            "&ocfs2_rename_lops",
            "osb"
          ],
          "line": 661
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_lock_res_init_common",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlmglue.c",
          "lines": "496-524",
          "snippet": "static void ocfs2_lock_res_init_common(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *res,\n\t\t\t\t       enum ocfs2_lock_type type,\n\t\t\t\t       struct ocfs2_lock_res_ops *ops,\n\t\t\t\t       void *priv)\n{\n\tres->l_type          = type;\n\tres->l_ops           = ops;\n\tres->l_priv          = priv;\n\n\tres->l_level         = DLM_LOCK_IV;\n\tres->l_requested     = DLM_LOCK_IV;\n\tres->l_blocking      = DLM_LOCK_IV;\n\tres->l_action        = OCFS2_AST_INVALID;\n\tres->l_unlock_action = OCFS2_UNLOCK_INVALID;\n\n\tres->l_flags         = OCFS2_LOCK_INITIALIZED;\n\n\tocfs2_add_lockres_tracking(res, osb->osb_dlm_debug);\n\n\tocfs2_init_lock_stats(res);\n#ifdef CONFIG_DEBUG_LOCK_ALLOC\n\tif (type != OCFS2_LOCK_TYPE_OPEN)\n\t\tlockdep_init_map(&res->l_lockdep_map, ocfs2_lock_type_strings[type],\n\t\t\t\t &lockdep_keys[type], 0);\n\telse\n\t\tres->l_lockdep_map.key = NULL;\n#endif\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"refcounttree.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"stackglue.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dcache.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2_lockingver.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/time.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/kthread.h>",
            "#include <linux/mm.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct lock_class_key lockdep_keys[OCFS2_NUM_LOCK_TYPES];",
            "static void ocfs2_drop_osb_locks(struct ocfs2_super *osb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"stackglue.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dcache.h\"\n#include \"alloc.h\"\n#include \"ocfs2_lockingver.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/quotaops.h>\n#include <linux/time.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/pagemap.h>\n#include <linux/kthread.h>\n#include <linux/mm.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstruct lock_class_key lockdep_keys[OCFS2_NUM_LOCK_TYPES];\nstatic void ocfs2_drop_osb_locks(struct ocfs2_super *osb);\n\nstatic void ocfs2_lock_res_init_common(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *res,\n\t\t\t\t       enum ocfs2_lock_type type,\n\t\t\t\t       struct ocfs2_lock_res_ops *ops,\n\t\t\t\t       void *priv)\n{\n\tres->l_type          = type;\n\tres->l_ops           = ops;\n\tres->l_priv          = priv;\n\n\tres->l_level         = DLM_LOCK_IV;\n\tres->l_requested     = DLM_LOCK_IV;\n\tres->l_blocking      = DLM_LOCK_IV;\n\tres->l_action        = OCFS2_AST_INVALID;\n\tres->l_unlock_action = OCFS2_UNLOCK_INVALID;\n\n\tres->l_flags         = OCFS2_LOCK_INITIALIZED;\n\n\tocfs2_add_lockres_tracking(res, osb->osb_dlm_debug);\n\n\tocfs2_init_lock_stats(res);\n#ifdef CONFIG_DEBUG_LOCK_ALLOC\n\tif (type != OCFS2_LOCK_TYPE_OPEN)\n\t\tlockdep_init_map(&res->l_lockdep_map, ocfs2_lock_type_strings[type],\n\t\t\t\t &lockdep_keys[type], 0);\n\telse\n\t\tres->l_lockdep_map.key = NULL;\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_build_lock_name",
          "args": [
            "OCFS2_LOCK_TYPE_RENAME",
            "0",
            "0",
            "res->l_name"
          ],
          "line": 660
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_build_lock_name",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlmglue.c",
          "lines": "393-409",
          "snippet": "static void ocfs2_build_lock_name(enum ocfs2_lock_type type,\n\t\t\t\t  u64 blkno,\n\t\t\t\t  u32 generation,\n\t\t\t\t  char *name)\n{\n\tint len;\n\n\tBUG_ON(type >= OCFS2_NUM_LOCK_TYPES);\n\n\tlen = snprintf(name, OCFS2_LOCK_ID_MAX_LEN, \"%c%s%016llx%08x\",\n\t\t       ocfs2_lock_type_char(type), OCFS2_LOCK_ID_PAD,\n\t\t       (long long)blkno, generation);\n\n\tBUG_ON(len != (OCFS2_LOCK_ID_MAX_LEN - 1));\n\n\tmlog(0, \"built lock resource with name: %s\\n\", name);\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"refcounttree.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"stackglue.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dcache.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2_lockingver.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/time.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/kthread.h>",
            "#include <linux/mm.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ocfs2_downconvert_lock(struct ocfs2_super *osb,\n\t\t\t\t  struct ocfs2_lock_res *lockres,\n\t\t\t\t  int new_level,\n\t\t\t\t  int lvb,\n\t\t\t\t  unsigned int generation);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"stackglue.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dcache.h\"\n#include \"alloc.h\"\n#include \"ocfs2_lockingver.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/quotaops.h>\n#include <linux/time.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/pagemap.h>\n#include <linux/kthread.h>\n#include <linux/mm.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic int ocfs2_downconvert_lock(struct ocfs2_super *osb,\n\t\t\t\t  struct ocfs2_lock_res *lockres,\n\t\t\t\t  int new_level,\n\t\t\t\t  int lvb,\n\t\t\t\t  unsigned int generation);\n\nstatic void ocfs2_build_lock_name(enum ocfs2_lock_type type,\n\t\t\t\t  u64 blkno,\n\t\t\t\t  u32 generation,\n\t\t\t\t  char *name)\n{\n\tint len;\n\n\tBUG_ON(type >= OCFS2_NUM_LOCK_TYPES);\n\n\tlen = snprintf(name, OCFS2_LOCK_ID_MAX_LEN, \"%c%s%016llx%08x\",\n\t\t       ocfs2_lock_type_char(type), OCFS2_LOCK_ID_PAD,\n\t\t       (long long)blkno, generation);\n\n\tBUG_ON(len != (OCFS2_LOCK_ID_MAX_LEN - 1));\n\n\tmlog(0, \"built lock resource with name: %s\\n\", name);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_lock_res_init_once",
          "args": [
            "res"
          ],
          "line": 659
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_lock_res_init_once",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlmglue.c",
          "lines": "526-534",
          "snippet": "void ocfs2_lock_res_init_once(struct ocfs2_lock_res *res)\n{\n\t/* This also clears out the lock status block */\n\tmemset(res, 0, sizeof(struct ocfs2_lock_res));\n\tspin_lock_init(&res->l_lock);\n\tinit_waitqueue_head(&res->l_event);\n\tINIT_LIST_HEAD(&res->l_blocked_list);\n\tINIT_LIST_HEAD(&res->l_mask_waiters);\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"refcounttree.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"stackglue.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dcache.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2_lockingver.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/time.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/kthread.h>",
            "#include <linux/mm.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"stackglue.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dcache.h\"\n#include \"alloc.h\"\n#include \"ocfs2_lockingver.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/quotaops.h>\n#include <linux/time.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/pagemap.h>\n#include <linux/kthread.h>\n#include <linux/mm.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nvoid ocfs2_lock_res_init_once(struct ocfs2_lock_res *res)\n{\n\t/* This also clears out the lock status block */\n\tmemset(res, 0, sizeof(struct ocfs2_lock_res));\n\tspin_lock_init(&res->l_lock);\n\tinit_waitqueue_head(&res->l_event);\n\tINIT_LIST_HEAD(&res->l_blocked_list);\n\tINIT_LIST_HEAD(&res->l_mask_waiters);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"stackglue.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dcache.h\"\n#include \"alloc.h\"\n#include \"ocfs2_lockingver.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/quotaops.h>\n#include <linux/time.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/pagemap.h>\n#include <linux/kthread.h>\n#include <linux/mm.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic struct ocfs2_super *ocfs2_get_dentry_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_inode_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_file_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_qinfo_osb(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_set_meta_lvb(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_dentry_post_unlock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres);\nstatic void ocfs2_set_qinfo_lvb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_lock_res_ops ocfs2_rename_lops = {\n\t.flags\t\t= 0,\n};\nstatic inline void ocfs2_generic_handle_downconvert_action(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_convert_action(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_attach_action(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_schedule_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_downconvert_on_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_drop_osb_locks(struct ocfs2_super *osb);\nstatic int ocfs2_prepare_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\t        struct ocfs2_lock_res *lockres);\nstatic int ocfs2_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_process_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *lockres);\n\nstatic void ocfs2_rename_lock_res_init(struct ocfs2_lock_res *res,\n\t\t\t\t       struct ocfs2_super *osb)\n{\n\t/* Rename lockres doesn't come from a slab so we call init\n\t * once on it manually.  */\n\tocfs2_lock_res_init_once(res);\n\tocfs2_build_lock_name(OCFS2_LOCK_TYPE_RENAME, 0, 0, res->l_name);\n\tocfs2_lock_res_init_common(osb, res, OCFS2_LOCK_TYPE_RENAME,\n\t\t\t\t   &ocfs2_rename_lops, osb);\n}"
  },
  {
    "function_name": "ocfs2_super_lock_res_init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlmglue.c",
    "lines": "642-652",
    "snippet": "static void ocfs2_super_lock_res_init(struct ocfs2_lock_res *res,\n\t\t\t\t      struct ocfs2_super *osb)\n{\n\t/* Superblock lockres doesn't come from a slab so we call init\n\t * once on it manually.  */\n\tocfs2_lock_res_init_once(res);\n\tocfs2_build_lock_name(OCFS2_LOCK_TYPE_SUPER, OCFS2_SUPER_BLOCK_BLKNO,\n\t\t\t      0, res->l_name);\n\tocfs2_lock_res_init_common(osb, res, OCFS2_LOCK_TYPE_SUPER,\n\t\t\t\t   &ocfs2_super_lops, osb);\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"refcounttree.h\"",
      "#include \"quota.h\"",
      "#include \"uptodate.h\"",
      "#include \"super.h\"",
      "#include \"slot_map.h\"",
      "#include \"stackglue.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"heartbeat.h\"",
      "#include \"file.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"dcache.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2_lockingver.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/time.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/kthread.h>",
      "#include <linux/mm.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct ocfs2_super *ocfs2_get_dentry_osb(struct ocfs2_lock_res *lockres);",
      "static struct ocfs2_super *ocfs2_get_inode_osb(struct ocfs2_lock_res *lockres);",
      "static struct ocfs2_super *ocfs2_get_file_osb(struct ocfs2_lock_res *lockres);",
      "static struct ocfs2_super *ocfs2_get_qinfo_osb(struct ocfs2_lock_res *lockres);",
      "static void ocfs2_set_meta_lvb(struct ocfs2_lock_res *lockres);",
      "static void ocfs2_dentry_post_unlock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres);",
      "static void ocfs2_set_qinfo_lvb(struct ocfs2_lock_res *lockres);",
      "static struct ocfs2_lock_res_ops ocfs2_super_lops = {\n\t.flags\t\t= LOCK_TYPE_REQUIRES_REFRESH,\n};",
      "static inline void ocfs2_generic_handle_downconvert_action(struct ocfs2_lock_res *lockres);",
      "static inline void ocfs2_generic_handle_convert_action(struct ocfs2_lock_res *lockres);",
      "static inline void ocfs2_generic_handle_attach_action(struct ocfs2_lock_res *lockres);",
      "static void ocfs2_schedule_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);",
      "static void ocfs2_downconvert_on_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);",
      "static void ocfs2_drop_osb_locks(struct ocfs2_super *osb);",
      "static int ocfs2_prepare_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\t        struct ocfs2_lock_res *lockres);",
      "static int ocfs2_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres);",
      "static void ocfs2_process_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *lockres);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ocfs2_lock_res_init_common",
          "args": [
            "osb",
            "res",
            "OCFS2_LOCK_TYPE_SUPER",
            "&ocfs2_super_lops",
            "osb"
          ],
          "line": 650
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_lock_res_init_common",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlmglue.c",
          "lines": "496-524",
          "snippet": "static void ocfs2_lock_res_init_common(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *res,\n\t\t\t\t       enum ocfs2_lock_type type,\n\t\t\t\t       struct ocfs2_lock_res_ops *ops,\n\t\t\t\t       void *priv)\n{\n\tres->l_type          = type;\n\tres->l_ops           = ops;\n\tres->l_priv          = priv;\n\n\tres->l_level         = DLM_LOCK_IV;\n\tres->l_requested     = DLM_LOCK_IV;\n\tres->l_blocking      = DLM_LOCK_IV;\n\tres->l_action        = OCFS2_AST_INVALID;\n\tres->l_unlock_action = OCFS2_UNLOCK_INVALID;\n\n\tres->l_flags         = OCFS2_LOCK_INITIALIZED;\n\n\tocfs2_add_lockres_tracking(res, osb->osb_dlm_debug);\n\n\tocfs2_init_lock_stats(res);\n#ifdef CONFIG_DEBUG_LOCK_ALLOC\n\tif (type != OCFS2_LOCK_TYPE_OPEN)\n\t\tlockdep_init_map(&res->l_lockdep_map, ocfs2_lock_type_strings[type],\n\t\t\t\t &lockdep_keys[type], 0);\n\telse\n\t\tres->l_lockdep_map.key = NULL;\n#endif\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"refcounttree.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"stackglue.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dcache.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2_lockingver.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/time.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/kthread.h>",
            "#include <linux/mm.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct lock_class_key lockdep_keys[OCFS2_NUM_LOCK_TYPES];",
            "static void ocfs2_drop_osb_locks(struct ocfs2_super *osb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"stackglue.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dcache.h\"\n#include \"alloc.h\"\n#include \"ocfs2_lockingver.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/quotaops.h>\n#include <linux/time.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/pagemap.h>\n#include <linux/kthread.h>\n#include <linux/mm.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstruct lock_class_key lockdep_keys[OCFS2_NUM_LOCK_TYPES];\nstatic void ocfs2_drop_osb_locks(struct ocfs2_super *osb);\n\nstatic void ocfs2_lock_res_init_common(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *res,\n\t\t\t\t       enum ocfs2_lock_type type,\n\t\t\t\t       struct ocfs2_lock_res_ops *ops,\n\t\t\t\t       void *priv)\n{\n\tres->l_type          = type;\n\tres->l_ops           = ops;\n\tres->l_priv          = priv;\n\n\tres->l_level         = DLM_LOCK_IV;\n\tres->l_requested     = DLM_LOCK_IV;\n\tres->l_blocking      = DLM_LOCK_IV;\n\tres->l_action        = OCFS2_AST_INVALID;\n\tres->l_unlock_action = OCFS2_UNLOCK_INVALID;\n\n\tres->l_flags         = OCFS2_LOCK_INITIALIZED;\n\n\tocfs2_add_lockres_tracking(res, osb->osb_dlm_debug);\n\n\tocfs2_init_lock_stats(res);\n#ifdef CONFIG_DEBUG_LOCK_ALLOC\n\tif (type != OCFS2_LOCK_TYPE_OPEN)\n\t\tlockdep_init_map(&res->l_lockdep_map, ocfs2_lock_type_strings[type],\n\t\t\t\t &lockdep_keys[type], 0);\n\telse\n\t\tres->l_lockdep_map.key = NULL;\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_build_lock_name",
          "args": [
            "OCFS2_LOCK_TYPE_SUPER",
            "OCFS2_SUPER_BLOCK_BLKNO",
            "0",
            "res->l_name"
          ],
          "line": 648
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_build_lock_name",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlmglue.c",
          "lines": "393-409",
          "snippet": "static void ocfs2_build_lock_name(enum ocfs2_lock_type type,\n\t\t\t\t  u64 blkno,\n\t\t\t\t  u32 generation,\n\t\t\t\t  char *name)\n{\n\tint len;\n\n\tBUG_ON(type >= OCFS2_NUM_LOCK_TYPES);\n\n\tlen = snprintf(name, OCFS2_LOCK_ID_MAX_LEN, \"%c%s%016llx%08x\",\n\t\t       ocfs2_lock_type_char(type), OCFS2_LOCK_ID_PAD,\n\t\t       (long long)blkno, generation);\n\n\tBUG_ON(len != (OCFS2_LOCK_ID_MAX_LEN - 1));\n\n\tmlog(0, \"built lock resource with name: %s\\n\", name);\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"refcounttree.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"stackglue.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dcache.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2_lockingver.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/time.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/kthread.h>",
            "#include <linux/mm.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ocfs2_downconvert_lock(struct ocfs2_super *osb,\n\t\t\t\t  struct ocfs2_lock_res *lockres,\n\t\t\t\t  int new_level,\n\t\t\t\t  int lvb,\n\t\t\t\t  unsigned int generation);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"stackglue.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dcache.h\"\n#include \"alloc.h\"\n#include \"ocfs2_lockingver.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/quotaops.h>\n#include <linux/time.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/pagemap.h>\n#include <linux/kthread.h>\n#include <linux/mm.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic int ocfs2_downconvert_lock(struct ocfs2_super *osb,\n\t\t\t\t  struct ocfs2_lock_res *lockres,\n\t\t\t\t  int new_level,\n\t\t\t\t  int lvb,\n\t\t\t\t  unsigned int generation);\n\nstatic void ocfs2_build_lock_name(enum ocfs2_lock_type type,\n\t\t\t\t  u64 blkno,\n\t\t\t\t  u32 generation,\n\t\t\t\t  char *name)\n{\n\tint len;\n\n\tBUG_ON(type >= OCFS2_NUM_LOCK_TYPES);\n\n\tlen = snprintf(name, OCFS2_LOCK_ID_MAX_LEN, \"%c%s%016llx%08x\",\n\t\t       ocfs2_lock_type_char(type), OCFS2_LOCK_ID_PAD,\n\t\t       (long long)blkno, generation);\n\n\tBUG_ON(len != (OCFS2_LOCK_ID_MAX_LEN - 1));\n\n\tmlog(0, \"built lock resource with name: %s\\n\", name);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_lock_res_init_once",
          "args": [
            "res"
          ],
          "line": 647
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_lock_res_init_once",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlmglue.c",
          "lines": "526-534",
          "snippet": "void ocfs2_lock_res_init_once(struct ocfs2_lock_res *res)\n{\n\t/* This also clears out the lock status block */\n\tmemset(res, 0, sizeof(struct ocfs2_lock_res));\n\tspin_lock_init(&res->l_lock);\n\tinit_waitqueue_head(&res->l_event);\n\tINIT_LIST_HEAD(&res->l_blocked_list);\n\tINIT_LIST_HEAD(&res->l_mask_waiters);\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"refcounttree.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"stackglue.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dcache.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2_lockingver.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/time.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/kthread.h>",
            "#include <linux/mm.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"stackglue.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dcache.h\"\n#include \"alloc.h\"\n#include \"ocfs2_lockingver.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/quotaops.h>\n#include <linux/time.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/pagemap.h>\n#include <linux/kthread.h>\n#include <linux/mm.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nvoid ocfs2_lock_res_init_once(struct ocfs2_lock_res *res)\n{\n\t/* This also clears out the lock status block */\n\tmemset(res, 0, sizeof(struct ocfs2_lock_res));\n\tspin_lock_init(&res->l_lock);\n\tinit_waitqueue_head(&res->l_event);\n\tINIT_LIST_HEAD(&res->l_blocked_list);\n\tINIT_LIST_HEAD(&res->l_mask_waiters);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"stackglue.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dcache.h\"\n#include \"alloc.h\"\n#include \"ocfs2_lockingver.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/quotaops.h>\n#include <linux/time.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/pagemap.h>\n#include <linux/kthread.h>\n#include <linux/mm.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic struct ocfs2_super *ocfs2_get_dentry_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_inode_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_file_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_qinfo_osb(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_set_meta_lvb(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_dentry_post_unlock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres);\nstatic void ocfs2_set_qinfo_lvb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_lock_res_ops ocfs2_super_lops = {\n\t.flags\t\t= LOCK_TYPE_REQUIRES_REFRESH,\n};\nstatic inline void ocfs2_generic_handle_downconvert_action(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_convert_action(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_attach_action(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_schedule_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_downconvert_on_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_drop_osb_locks(struct ocfs2_super *osb);\nstatic int ocfs2_prepare_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\t        struct ocfs2_lock_res *lockres);\nstatic int ocfs2_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_process_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *lockres);\n\nstatic void ocfs2_super_lock_res_init(struct ocfs2_lock_res *res,\n\t\t\t\t      struct ocfs2_super *osb)\n{\n\t/* Superblock lockres doesn't come from a slab so we call init\n\t * once on it manually.  */\n\tocfs2_lock_res_init_once(res);\n\tocfs2_build_lock_name(OCFS2_LOCK_TYPE_SUPER, OCFS2_SUPER_BLOCK_BLKNO,\n\t\t\t      0, res->l_name);\n\tocfs2_lock_res_init_common(osb, res, OCFS2_LOCK_TYPE_SUPER,\n\t\t\t\t   &ocfs2_super_lops, osb);\n}"
  },
  {
    "function_name": "ocfs2_dentry_lock_res_init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlmglue.c",
    "lines": "602-640",
    "snippet": "void ocfs2_dentry_lock_res_init(struct ocfs2_dentry_lock *dl,\n\t\t\t\tu64 parent, struct inode *inode)\n{\n\tint len;\n\tu64 inode_blkno = OCFS2_I(inode)->ip_blkno;\n\t__be64 inode_blkno_be = cpu_to_be64(inode_blkno);\n\tstruct ocfs2_lock_res *lockres = &dl->dl_lockres;\n\n\tocfs2_lock_res_init_once(lockres);\n\n\t/*\n\t * Unfortunately, the standard lock naming scheme won't work\n\t * here because we have two 16 byte values to use. Instead,\n\t * we'll stuff the inode number as a binary value. We still\n\t * want error prints to show something without garbling the\n\t * display, so drop a null byte in there before the inode\n\t * number. A future version of OCFS2 will likely use all\n\t * binary lock names. The stringified names have been a\n\t * tremendous aid in debugging, but now that the debugfs\n\t * interface exists, we can mangle things there if need be.\n\t *\n\t * NOTE: We also drop the standard \"pad\" value (the total lock\n\t * name size stays the same though - the last part is all\n\t * zeros due to the memset in ocfs2_lock_res_init_once()\n\t */\n\tlen = snprintf(lockres->l_name, OCFS2_DENTRY_LOCK_INO_START,\n\t\t       \"%c%016llx\",\n\t\t       ocfs2_lock_type_char(OCFS2_LOCK_TYPE_DENTRY),\n\t\t       (long long)parent);\n\n\tBUG_ON(len != (OCFS2_DENTRY_LOCK_INO_START - 1));\n\n\tmemcpy(&lockres->l_name[OCFS2_DENTRY_LOCK_INO_START], &inode_blkno_be,\n\t       sizeof(__be64));\n\n\tocfs2_lock_res_init_common(OCFS2_SB(inode->i_sb), lockres,\n\t\t\t\t   OCFS2_LOCK_TYPE_DENTRY, &ocfs2_dentry_lops,\n\t\t\t\t   dl);\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"refcounttree.h\"",
      "#include \"quota.h\"",
      "#include \"uptodate.h\"",
      "#include \"super.h\"",
      "#include \"slot_map.h\"",
      "#include \"stackglue.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"heartbeat.h\"",
      "#include \"file.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"dcache.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2_lockingver.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/time.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/kthread.h>",
      "#include <linux/mm.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct ocfs2_super *ocfs2_get_dentry_osb(struct ocfs2_lock_res *lockres);",
      "static struct ocfs2_super *ocfs2_get_inode_osb(struct ocfs2_lock_res *lockres);",
      "static struct ocfs2_super *ocfs2_get_file_osb(struct ocfs2_lock_res *lockres);",
      "static struct ocfs2_super *ocfs2_get_qinfo_osb(struct ocfs2_lock_res *lockres);",
      "static void ocfs2_set_meta_lvb(struct ocfs2_lock_res *lockres);",
      "static void ocfs2_dentry_post_unlock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres);",
      "static void ocfs2_set_qinfo_lvb(struct ocfs2_lock_res *lockres);",
      "static struct ocfs2_lock_res_ops ocfs2_dentry_lops = {\n\t.get_osb\t= ocfs2_get_dentry_osb,\n\t.post_unlock\t= ocfs2_dentry_post_unlock,\n\t.downconvert_worker = ocfs2_dentry_convert_worker,\n\t.flags\t\t= 0,\n};",
      "static inline void ocfs2_generic_handle_downconvert_action(struct ocfs2_lock_res *lockres);",
      "static inline void ocfs2_generic_handle_convert_action(struct ocfs2_lock_res *lockres);",
      "static inline void ocfs2_generic_handle_attach_action(struct ocfs2_lock_res *lockres);",
      "static void ocfs2_schedule_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);",
      "static void ocfs2_downconvert_on_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);",
      "static int ocfs2_prepare_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\t        struct ocfs2_lock_res *lockres);",
      "static int ocfs2_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres);",
      "static void ocfs2_process_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *lockres);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ocfs2_lock_res_init_common",
          "args": [
            "OCFS2_SB(inode->i_sb)",
            "lockres",
            "OCFS2_LOCK_TYPE_DENTRY",
            "&ocfs2_dentry_lops",
            "dl"
          ],
          "line": 637
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_lock_res_init_common",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlmglue.c",
          "lines": "496-524",
          "snippet": "static void ocfs2_lock_res_init_common(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *res,\n\t\t\t\t       enum ocfs2_lock_type type,\n\t\t\t\t       struct ocfs2_lock_res_ops *ops,\n\t\t\t\t       void *priv)\n{\n\tres->l_type          = type;\n\tres->l_ops           = ops;\n\tres->l_priv          = priv;\n\n\tres->l_level         = DLM_LOCK_IV;\n\tres->l_requested     = DLM_LOCK_IV;\n\tres->l_blocking      = DLM_LOCK_IV;\n\tres->l_action        = OCFS2_AST_INVALID;\n\tres->l_unlock_action = OCFS2_UNLOCK_INVALID;\n\n\tres->l_flags         = OCFS2_LOCK_INITIALIZED;\n\n\tocfs2_add_lockres_tracking(res, osb->osb_dlm_debug);\n\n\tocfs2_init_lock_stats(res);\n#ifdef CONFIG_DEBUG_LOCK_ALLOC\n\tif (type != OCFS2_LOCK_TYPE_OPEN)\n\t\tlockdep_init_map(&res->l_lockdep_map, ocfs2_lock_type_strings[type],\n\t\t\t\t &lockdep_keys[type], 0);\n\telse\n\t\tres->l_lockdep_map.key = NULL;\n#endif\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"refcounttree.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"stackglue.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dcache.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2_lockingver.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/time.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/kthread.h>",
            "#include <linux/mm.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct lock_class_key lockdep_keys[OCFS2_NUM_LOCK_TYPES];",
            "static void ocfs2_drop_osb_locks(struct ocfs2_super *osb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"stackglue.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dcache.h\"\n#include \"alloc.h\"\n#include \"ocfs2_lockingver.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/quotaops.h>\n#include <linux/time.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/pagemap.h>\n#include <linux/kthread.h>\n#include <linux/mm.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstruct lock_class_key lockdep_keys[OCFS2_NUM_LOCK_TYPES];\nstatic void ocfs2_drop_osb_locks(struct ocfs2_super *osb);\n\nstatic void ocfs2_lock_res_init_common(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *res,\n\t\t\t\t       enum ocfs2_lock_type type,\n\t\t\t\t       struct ocfs2_lock_res_ops *ops,\n\t\t\t\t       void *priv)\n{\n\tres->l_type          = type;\n\tres->l_ops           = ops;\n\tres->l_priv          = priv;\n\n\tres->l_level         = DLM_LOCK_IV;\n\tres->l_requested     = DLM_LOCK_IV;\n\tres->l_blocking      = DLM_LOCK_IV;\n\tres->l_action        = OCFS2_AST_INVALID;\n\tres->l_unlock_action = OCFS2_UNLOCK_INVALID;\n\n\tres->l_flags         = OCFS2_LOCK_INITIALIZED;\n\n\tocfs2_add_lockres_tracking(res, osb->osb_dlm_debug);\n\n\tocfs2_init_lock_stats(res);\n#ifdef CONFIG_DEBUG_LOCK_ALLOC\n\tif (type != OCFS2_LOCK_TYPE_OPEN)\n\t\tlockdep_init_map(&res->l_lockdep_map, ocfs2_lock_type_strings[type],\n\t\t\t\t &lockdep_keys[type], 0);\n\telse\n\t\tres->l_lockdep_map.key = NULL;\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "OCFS2_SB",
          "args": [
            "inode->i_sb"
          ],
          "line": 637
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "&lockres->l_name[OCFS2_DENTRY_LOCK_INO_START]",
            "&inode_blkno_be",
            "sizeof(__be64)"
          ],
          "line": 634
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "len != (OCFS2_DENTRY_LOCK_INO_START - 1)"
          ],
          "line": 632
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "lockres->l_name",
            "OCFS2_DENTRY_LOCK_INO_START",
            "\"%c%016llx\"",
            "ocfs2_lock_type_char(OCFS2_LOCK_TYPE_DENTRY)",
            "(long long)parent"
          ],
          "line": 627
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_lock_type_char",
          "args": [
            "OCFS2_LOCK_TYPE_DENTRY"
          ],
          "line": 629
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_lock_type_char",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2_lockid.h",
          "lines": "56-101",
          "snippet": "static inline char ocfs2_lock_type_char(enum ocfs2_lock_type type)\n{\n\tchar c;\n\tswitch (type) {\n\t\tcase OCFS2_LOCK_TYPE_META:\n\t\t\tc = 'M';\n\t\t\tbreak;\n\t\tcase OCFS2_LOCK_TYPE_DATA:\n\t\t\tc = 'D';\n\t\t\tbreak;\n\t\tcase OCFS2_LOCK_TYPE_SUPER:\n\t\t\tc = 'S';\n\t\t\tbreak;\n\t\tcase OCFS2_LOCK_TYPE_RENAME:\n\t\t\tc = 'R';\n\t\t\tbreak;\n\t\tcase OCFS2_LOCK_TYPE_RW:\n\t\t\tc = 'W';\n\t\t\tbreak;\n\t\tcase OCFS2_LOCK_TYPE_DENTRY:\n\t\t\tc = 'N';\n\t\t\tbreak;\n\t\tcase OCFS2_LOCK_TYPE_OPEN:\n\t\t\tc = 'O';\n\t\t\tbreak;\n\t\tcase OCFS2_LOCK_TYPE_FLOCK:\n\t\t\tc = 'F';\n\t\t\tbreak;\n\t\tcase OCFS2_LOCK_TYPE_QINFO:\n\t\t\tc = 'Q';\n\t\t\tbreak;\n\t\tcase OCFS2_LOCK_TYPE_NFS_SYNC:\n\t\t\tc = 'Y';\n\t\t\tbreak;\n\t\tcase OCFS2_LOCK_TYPE_ORPHAN_SCAN:\n\t\t\tc = 'P';\n\t\t\tbreak;\n\t\tcase OCFS2_LOCK_TYPE_REFCOUNT:\n\t\t\tc = 'T';\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tc = '\\0';\n\t}\n\n\treturn c;\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline char ocfs2_lock_type_char(enum ocfs2_lock_type type)\n{\n\tchar c;\n\tswitch (type) {\n\t\tcase OCFS2_LOCK_TYPE_META:\n\t\t\tc = 'M';\n\t\t\tbreak;\n\t\tcase OCFS2_LOCK_TYPE_DATA:\n\t\t\tc = 'D';\n\t\t\tbreak;\n\t\tcase OCFS2_LOCK_TYPE_SUPER:\n\t\t\tc = 'S';\n\t\t\tbreak;\n\t\tcase OCFS2_LOCK_TYPE_RENAME:\n\t\t\tc = 'R';\n\t\t\tbreak;\n\t\tcase OCFS2_LOCK_TYPE_RW:\n\t\t\tc = 'W';\n\t\t\tbreak;\n\t\tcase OCFS2_LOCK_TYPE_DENTRY:\n\t\t\tc = 'N';\n\t\t\tbreak;\n\t\tcase OCFS2_LOCK_TYPE_OPEN:\n\t\t\tc = 'O';\n\t\t\tbreak;\n\t\tcase OCFS2_LOCK_TYPE_FLOCK:\n\t\t\tc = 'F';\n\t\t\tbreak;\n\t\tcase OCFS2_LOCK_TYPE_QINFO:\n\t\t\tc = 'Q';\n\t\t\tbreak;\n\t\tcase OCFS2_LOCK_TYPE_NFS_SYNC:\n\t\t\tc = 'Y';\n\t\t\tbreak;\n\t\tcase OCFS2_LOCK_TYPE_ORPHAN_SCAN:\n\t\t\tc = 'P';\n\t\t\tbreak;\n\t\tcase OCFS2_LOCK_TYPE_REFCOUNT:\n\t\t\tc = 'T';\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tc = '\\0';\n\t}\n\n\treturn c;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_lock_res_init_once",
          "args": [
            "lockres"
          ],
          "line": 610
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_lock_res_init_once",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlmglue.c",
          "lines": "526-534",
          "snippet": "void ocfs2_lock_res_init_once(struct ocfs2_lock_res *res)\n{\n\t/* This also clears out the lock status block */\n\tmemset(res, 0, sizeof(struct ocfs2_lock_res));\n\tspin_lock_init(&res->l_lock);\n\tinit_waitqueue_head(&res->l_event);\n\tINIT_LIST_HEAD(&res->l_blocked_list);\n\tINIT_LIST_HEAD(&res->l_mask_waiters);\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"refcounttree.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"stackglue.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dcache.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2_lockingver.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/time.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/kthread.h>",
            "#include <linux/mm.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"stackglue.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dcache.h\"\n#include \"alloc.h\"\n#include \"ocfs2_lockingver.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/quotaops.h>\n#include <linux/time.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/pagemap.h>\n#include <linux/kthread.h>\n#include <linux/mm.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nvoid ocfs2_lock_res_init_once(struct ocfs2_lock_res *res)\n{\n\t/* This also clears out the lock status block */\n\tmemset(res, 0, sizeof(struct ocfs2_lock_res));\n\tspin_lock_init(&res->l_lock);\n\tinit_waitqueue_head(&res->l_event);\n\tINIT_LIST_HEAD(&res->l_blocked_list);\n\tINIT_LIST_HEAD(&res->l_mask_waiters);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_be64",
          "args": [
            "inode_blkno"
          ],
          "line": 607
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "OCFS2_I",
          "args": [
            "inode"
          ],
          "line": 606
        },
        "resolved": true,
        "details": {
          "function_name": "OCFS2_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/inode.h",
          "lines": "118-121",
          "snippet": "static inline struct ocfs2_inode_info *OCFS2_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ocfs2_inode_info, vfs_inode);\n}",
          "includes": [
            "#include \"extent_map.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extent_map.h\"\n\nstatic inline struct ocfs2_inode_info *OCFS2_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ocfs2_inode_info, vfs_inode);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"stackglue.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dcache.h\"\n#include \"alloc.h\"\n#include \"ocfs2_lockingver.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/quotaops.h>\n#include <linux/time.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/pagemap.h>\n#include <linux/kthread.h>\n#include <linux/mm.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic struct ocfs2_super *ocfs2_get_dentry_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_inode_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_file_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_qinfo_osb(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_set_meta_lvb(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_dentry_post_unlock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres);\nstatic void ocfs2_set_qinfo_lvb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_lock_res_ops ocfs2_dentry_lops = {\n\t.get_osb\t= ocfs2_get_dentry_osb,\n\t.post_unlock\t= ocfs2_dentry_post_unlock,\n\t.downconvert_worker = ocfs2_dentry_convert_worker,\n\t.flags\t\t= 0,\n};\nstatic inline void ocfs2_generic_handle_downconvert_action(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_convert_action(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_attach_action(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_schedule_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_downconvert_on_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic int ocfs2_prepare_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\t        struct ocfs2_lock_res *lockres);\nstatic int ocfs2_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_process_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *lockres);\n\nvoid ocfs2_dentry_lock_res_init(struct ocfs2_dentry_lock *dl,\n\t\t\t\tu64 parent, struct inode *inode)\n{\n\tint len;\n\tu64 inode_blkno = OCFS2_I(inode)->ip_blkno;\n\t__be64 inode_blkno_be = cpu_to_be64(inode_blkno);\n\tstruct ocfs2_lock_res *lockres = &dl->dl_lockres;\n\n\tocfs2_lock_res_init_once(lockres);\n\n\t/*\n\t * Unfortunately, the standard lock naming scheme won't work\n\t * here because we have two 16 byte values to use. Instead,\n\t * we'll stuff the inode number as a binary value. We still\n\t * want error prints to show something without garbling the\n\t * display, so drop a null byte in there before the inode\n\t * number. A future version of OCFS2 will likely use all\n\t * binary lock names. The stringified names have been a\n\t * tremendous aid in debugging, but now that the debugfs\n\t * interface exists, we can mangle things there if need be.\n\t *\n\t * NOTE: We also drop the standard \"pad\" value (the total lock\n\t * name size stays the same though - the last part is all\n\t * zeros due to the memset in ocfs2_lock_res_init_once()\n\t */\n\tlen = snprintf(lockres->l_name, OCFS2_DENTRY_LOCK_INO_START,\n\t\t       \"%c%016llx\",\n\t\t       ocfs2_lock_type_char(OCFS2_LOCK_TYPE_DENTRY),\n\t\t       (long long)parent);\n\n\tBUG_ON(len != (OCFS2_DENTRY_LOCK_INO_START - 1));\n\n\tmemcpy(&lockres->l_name[OCFS2_DENTRY_LOCK_INO_START], &inode_blkno_be,\n\t       sizeof(__be64));\n\n\tocfs2_lock_res_init_common(OCFS2_SB(inode->i_sb), lockres,\n\t\t\t\t   OCFS2_LOCK_TYPE_DENTRY, &ocfs2_dentry_lops,\n\t\t\t\t   dl);\n}"
  },
  {
    "function_name": "ocfs2_get_dentry_osb",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlmglue.c",
    "lines": "595-600",
    "snippet": "static struct ocfs2_super *ocfs2_get_dentry_osb(struct ocfs2_lock_res *lockres)\n{\n\tstruct ocfs2_dentry_lock *dl = lockres->l_priv;\n\n\treturn OCFS2_SB(dl->dl_inode->i_sb);\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"refcounttree.h\"",
      "#include \"quota.h\"",
      "#include \"uptodate.h\"",
      "#include \"super.h\"",
      "#include \"slot_map.h\"",
      "#include \"stackglue.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"heartbeat.h\"",
      "#include \"file.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"dcache.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2_lockingver.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/time.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/kthread.h>",
      "#include <linux/mm.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct ocfs2_super *ocfs2_get_dentry_osb(struct ocfs2_lock_res *lockres);",
      "static struct ocfs2_super *ocfs2_get_inode_osb(struct ocfs2_lock_res *lockres);",
      "static struct ocfs2_super *ocfs2_get_file_osb(struct ocfs2_lock_res *lockres);",
      "static struct ocfs2_super *ocfs2_get_qinfo_osb(struct ocfs2_lock_res *lockres);",
      "static void ocfs2_set_meta_lvb(struct ocfs2_lock_res *lockres);",
      "static void ocfs2_dentry_post_unlock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres);",
      "static void ocfs2_set_qinfo_lvb(struct ocfs2_lock_res *lockres);",
      "static inline void ocfs2_generic_handle_downconvert_action(struct ocfs2_lock_res *lockres);",
      "static inline void ocfs2_generic_handle_convert_action(struct ocfs2_lock_res *lockres);",
      "static inline void ocfs2_generic_handle_attach_action(struct ocfs2_lock_res *lockres);",
      "static void ocfs2_schedule_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);",
      "static void ocfs2_downconvert_on_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);",
      "static int ocfs2_prepare_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\t        struct ocfs2_lock_res *lockres);",
      "static int ocfs2_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres);",
      "static void ocfs2_process_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *lockres);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "OCFS2_SB",
          "args": [
            "dl->dl_inode->i_sb"
          ],
          "line": 599
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"stackglue.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dcache.h\"\n#include \"alloc.h\"\n#include \"ocfs2_lockingver.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/quotaops.h>\n#include <linux/time.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/pagemap.h>\n#include <linux/kthread.h>\n#include <linux/mm.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic struct ocfs2_super *ocfs2_get_dentry_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_inode_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_file_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_qinfo_osb(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_set_meta_lvb(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_dentry_post_unlock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres);\nstatic void ocfs2_set_qinfo_lvb(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_downconvert_action(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_convert_action(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_attach_action(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_schedule_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_downconvert_on_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic int ocfs2_prepare_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\t        struct ocfs2_lock_res *lockres);\nstatic int ocfs2_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_process_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *lockres);\n\nstatic struct ocfs2_super *ocfs2_get_dentry_osb(struct ocfs2_lock_res *lockres)\n{\n\tstruct ocfs2_dentry_lock *dl = lockres->l_priv;\n\n\treturn OCFS2_SB(dl->dl_inode->i_sb);\n}"
  },
  {
    "function_name": "ocfs2_get_dentry_lock_ino",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlmglue.c",
    "lines": "585-593",
    "snippet": "static __u64 ocfs2_get_dentry_lock_ino(struct ocfs2_lock_res *lockres)\n{\n\t__be64 inode_blkno_be;\n\n\tmemcpy(&inode_blkno_be, &lockres->l_name[OCFS2_DENTRY_LOCK_INO_START],\n\t       sizeof(__be64));\n\n\treturn be64_to_cpu(inode_blkno_be);\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"refcounttree.h\"",
      "#include \"quota.h\"",
      "#include \"uptodate.h\"",
      "#include \"super.h\"",
      "#include \"slot_map.h\"",
      "#include \"stackglue.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"heartbeat.h\"",
      "#include \"file.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"dcache.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2_lockingver.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/time.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/kthread.h>",
      "#include <linux/mm.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct ocfs2_super *ocfs2_get_dentry_osb(struct ocfs2_lock_res *lockres);",
      "static struct ocfs2_super *ocfs2_get_inode_osb(struct ocfs2_lock_res *lockres);",
      "static struct ocfs2_super *ocfs2_get_file_osb(struct ocfs2_lock_res *lockres);",
      "static struct ocfs2_super *ocfs2_get_qinfo_osb(struct ocfs2_lock_res *lockres);",
      "static void ocfs2_set_meta_lvb(struct ocfs2_lock_res *lockres);",
      "static void ocfs2_dentry_post_unlock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres);",
      "static void ocfs2_set_qinfo_lvb(struct ocfs2_lock_res *lockres);",
      "static inline void ocfs2_generic_handle_downconvert_action(struct ocfs2_lock_res *lockres);",
      "static inline void ocfs2_generic_handle_convert_action(struct ocfs2_lock_res *lockres);",
      "static inline void ocfs2_generic_handle_attach_action(struct ocfs2_lock_res *lockres);",
      "static void ocfs2_schedule_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);",
      "static void ocfs2_downconvert_on_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);",
      "static int ocfs2_prepare_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\t        struct ocfs2_lock_res *lockres);",
      "static int ocfs2_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres);",
      "static void ocfs2_process_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *lockres);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "be64_to_cpu",
          "args": [
            "inode_blkno_be"
          ],
          "line": 592
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "&inode_blkno_be",
            "&lockres->l_name[OCFS2_DENTRY_LOCK_INO_START]",
            "sizeof(__be64)"
          ],
          "line": 589
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"stackglue.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dcache.h\"\n#include \"alloc.h\"\n#include \"ocfs2_lockingver.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/quotaops.h>\n#include <linux/time.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/pagemap.h>\n#include <linux/kthread.h>\n#include <linux/mm.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic struct ocfs2_super *ocfs2_get_dentry_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_inode_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_file_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_qinfo_osb(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_set_meta_lvb(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_dentry_post_unlock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres);\nstatic void ocfs2_set_qinfo_lvb(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_downconvert_action(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_convert_action(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_attach_action(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_schedule_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_downconvert_on_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic int ocfs2_prepare_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\t        struct ocfs2_lock_res *lockres);\nstatic int ocfs2_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_process_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *lockres);\n\nstatic __u64 ocfs2_get_dentry_lock_ino(struct ocfs2_lock_res *lockres)\n{\n\t__be64 inode_blkno_be;\n\n\tmemcpy(&inode_blkno_be, &lockres->l_name[OCFS2_DENTRY_LOCK_INO_START],\n\t       sizeof(__be64));\n\n\treturn be64_to_cpu(inode_blkno_be);\n}"
  },
  {
    "function_name": "ocfs2_get_file_osb",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlmglue.c",
    "lines": "578-583",
    "snippet": "static struct ocfs2_super *ocfs2_get_file_osb(struct ocfs2_lock_res *lockres)\n{\n\tstruct ocfs2_file_private *fp = lockres->l_priv;\n\n\treturn OCFS2_SB(fp->fp_file->f_mapping->host->i_sb);\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"refcounttree.h\"",
      "#include \"quota.h\"",
      "#include \"uptodate.h\"",
      "#include \"super.h\"",
      "#include \"slot_map.h\"",
      "#include \"stackglue.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"heartbeat.h\"",
      "#include \"file.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"dcache.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2_lockingver.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/time.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/kthread.h>",
      "#include <linux/mm.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct ocfs2_super *ocfs2_get_dentry_osb(struct ocfs2_lock_res *lockres);",
      "static struct ocfs2_super *ocfs2_get_inode_osb(struct ocfs2_lock_res *lockres);",
      "static struct ocfs2_super *ocfs2_get_file_osb(struct ocfs2_lock_res *lockres);",
      "static struct ocfs2_super *ocfs2_get_qinfo_osb(struct ocfs2_lock_res *lockres);",
      "static void ocfs2_set_meta_lvb(struct ocfs2_lock_res *lockres);",
      "static void ocfs2_dentry_post_unlock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres);",
      "static void ocfs2_set_qinfo_lvb(struct ocfs2_lock_res *lockres);",
      "static inline void ocfs2_generic_handle_downconvert_action(struct ocfs2_lock_res *lockres);",
      "static inline void ocfs2_generic_handle_convert_action(struct ocfs2_lock_res *lockres);",
      "static inline void ocfs2_generic_handle_attach_action(struct ocfs2_lock_res *lockres);",
      "static void ocfs2_schedule_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);",
      "static void ocfs2_downconvert_on_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);",
      "static int ocfs2_prepare_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\t        struct ocfs2_lock_res *lockres);",
      "static int ocfs2_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres);",
      "static void ocfs2_process_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *lockres);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "OCFS2_SB",
          "args": [
            "fp->fp_file->f_mapping->host->i_sb"
          ],
          "line": 582
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"stackglue.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dcache.h\"\n#include \"alloc.h\"\n#include \"ocfs2_lockingver.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/quotaops.h>\n#include <linux/time.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/pagemap.h>\n#include <linux/kthread.h>\n#include <linux/mm.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic struct ocfs2_super *ocfs2_get_dentry_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_inode_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_file_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_qinfo_osb(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_set_meta_lvb(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_dentry_post_unlock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres);\nstatic void ocfs2_set_qinfo_lvb(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_downconvert_action(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_convert_action(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_attach_action(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_schedule_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_downconvert_on_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic int ocfs2_prepare_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\t        struct ocfs2_lock_res *lockres);\nstatic int ocfs2_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_process_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *lockres);\n\nstatic struct ocfs2_super *ocfs2_get_file_osb(struct ocfs2_lock_res *lockres)\n{\n\tstruct ocfs2_file_private *fp = lockres->l_priv;\n\n\treturn OCFS2_SB(fp->fp_file->f_mapping->host->i_sb);\n}"
  },
  {
    "function_name": "ocfs2_get_qinfo_osb",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlmglue.c",
    "lines": "571-576",
    "snippet": "static struct ocfs2_super *ocfs2_get_qinfo_osb(struct ocfs2_lock_res *lockres)\n{\n\tstruct ocfs2_mem_dqinfo *info = lockres->l_priv;\n\n\treturn OCFS2_SB(info->dqi_gi.dqi_sb);\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"refcounttree.h\"",
      "#include \"quota.h\"",
      "#include \"uptodate.h\"",
      "#include \"super.h\"",
      "#include \"slot_map.h\"",
      "#include \"stackglue.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"heartbeat.h\"",
      "#include \"file.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"dcache.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2_lockingver.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/time.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/kthread.h>",
      "#include <linux/mm.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct ocfs2_super *ocfs2_get_dentry_osb(struct ocfs2_lock_res *lockres);",
      "static struct ocfs2_super *ocfs2_get_inode_osb(struct ocfs2_lock_res *lockres);",
      "static struct ocfs2_super *ocfs2_get_file_osb(struct ocfs2_lock_res *lockres);",
      "static struct ocfs2_super *ocfs2_get_qinfo_osb(struct ocfs2_lock_res *lockres);",
      "static void ocfs2_set_meta_lvb(struct ocfs2_lock_res *lockres);",
      "static void ocfs2_dentry_post_unlock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres);",
      "static void ocfs2_set_qinfo_lvb(struct ocfs2_lock_res *lockres);",
      "static inline void ocfs2_generic_handle_downconvert_action(struct ocfs2_lock_res *lockres);",
      "static inline void ocfs2_generic_handle_convert_action(struct ocfs2_lock_res *lockres);",
      "static inline void ocfs2_generic_handle_attach_action(struct ocfs2_lock_res *lockres);",
      "static void ocfs2_schedule_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);",
      "static void ocfs2_downconvert_on_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);",
      "static int ocfs2_prepare_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\t        struct ocfs2_lock_res *lockres);",
      "static int ocfs2_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres);",
      "static void ocfs2_process_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *lockres);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "OCFS2_SB",
          "args": [
            "info->dqi_gi.dqi_sb"
          ],
          "line": 575
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"stackglue.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dcache.h\"\n#include \"alloc.h\"\n#include \"ocfs2_lockingver.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/quotaops.h>\n#include <linux/time.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/pagemap.h>\n#include <linux/kthread.h>\n#include <linux/mm.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic struct ocfs2_super *ocfs2_get_dentry_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_inode_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_file_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_qinfo_osb(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_set_meta_lvb(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_dentry_post_unlock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres);\nstatic void ocfs2_set_qinfo_lvb(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_downconvert_action(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_convert_action(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_attach_action(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_schedule_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_downconvert_on_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic int ocfs2_prepare_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\t        struct ocfs2_lock_res *lockres);\nstatic int ocfs2_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_process_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *lockres);\n\nstatic struct ocfs2_super *ocfs2_get_qinfo_osb(struct ocfs2_lock_res *lockres)\n{\n\tstruct ocfs2_mem_dqinfo *info = lockres->l_priv;\n\n\treturn OCFS2_SB(info->dqi_gi.dqi_sb);\n}"
  },
  {
    "function_name": "ocfs2_get_inode_osb",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlmglue.c",
    "lines": "564-569",
    "snippet": "static struct ocfs2_super *ocfs2_get_inode_osb(struct ocfs2_lock_res *lockres)\n{\n\tstruct inode *inode = ocfs2_lock_res_inode(lockres);\n\n\treturn OCFS2_SB(inode->i_sb);\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"refcounttree.h\"",
      "#include \"quota.h\"",
      "#include \"uptodate.h\"",
      "#include \"super.h\"",
      "#include \"slot_map.h\"",
      "#include \"stackglue.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"heartbeat.h\"",
      "#include \"file.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"dcache.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2_lockingver.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/time.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/kthread.h>",
      "#include <linux/mm.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct ocfs2_super *ocfs2_get_dentry_osb(struct ocfs2_lock_res *lockres);",
      "static struct ocfs2_super *ocfs2_get_inode_osb(struct ocfs2_lock_res *lockres);",
      "static struct ocfs2_super *ocfs2_get_file_osb(struct ocfs2_lock_res *lockres);",
      "static struct ocfs2_super *ocfs2_get_qinfo_osb(struct ocfs2_lock_res *lockres);",
      "static void ocfs2_set_meta_lvb(struct ocfs2_lock_res *lockres);",
      "static void ocfs2_dentry_post_unlock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres);",
      "static void ocfs2_set_qinfo_lvb(struct ocfs2_lock_res *lockres);",
      "static inline void ocfs2_generic_handle_downconvert_action(struct ocfs2_lock_res *lockres);",
      "static inline void ocfs2_generic_handle_convert_action(struct ocfs2_lock_res *lockres);",
      "static inline void ocfs2_generic_handle_attach_action(struct ocfs2_lock_res *lockres);",
      "static void ocfs2_schedule_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);",
      "static void ocfs2_downconvert_on_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);",
      "static int ocfs2_prepare_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\t        struct ocfs2_lock_res *lockres);",
      "static int ocfs2_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres);",
      "static void ocfs2_process_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *lockres);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "OCFS2_SB",
          "args": [
            "inode->i_sb"
          ],
          "line": 568
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_lock_res_inode",
          "args": [
            "lockres"
          ],
          "line": 566
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_lock_res_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlmglue.c",
          "lines": "305-310",
          "snippet": "static inline struct inode *ocfs2_lock_res_inode(struct ocfs2_lock_res *lockres)\n{\n\tBUG_ON(!ocfs2_is_inode_lock(lockres));\n\n\treturn (struct inode *) lockres->l_priv;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"refcounttree.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"stackglue.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dcache.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2_lockingver.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/time.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/kthread.h>",
            "#include <linux/mm.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct ocfs2_super *ocfs2_get_dentry_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_inode_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_file_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_qinfo_osb(struct ocfs2_lock_res *lockres);",
            "static void ocfs2_set_meta_lvb(struct ocfs2_lock_res *lockres);",
            "static void ocfs2_dentry_post_unlock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres);",
            "static void ocfs2_set_qinfo_lvb(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_downconvert_action(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_convert_action(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_attach_action(struct ocfs2_lock_res *lockres);",
            "static void ocfs2_schedule_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static void ocfs2_downconvert_on_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static int ocfs2_prepare_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\t        struct ocfs2_lock_res *lockres);",
            "static int ocfs2_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static void ocfs2_process_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *lockres);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"stackglue.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dcache.h\"\n#include \"alloc.h\"\n#include \"ocfs2_lockingver.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/quotaops.h>\n#include <linux/time.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/pagemap.h>\n#include <linux/kthread.h>\n#include <linux/mm.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic struct ocfs2_super *ocfs2_get_dentry_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_inode_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_file_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_qinfo_osb(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_set_meta_lvb(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_dentry_post_unlock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres);\nstatic void ocfs2_set_qinfo_lvb(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_downconvert_action(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_convert_action(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_attach_action(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_schedule_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_downconvert_on_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic int ocfs2_prepare_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\t        struct ocfs2_lock_res *lockres);\nstatic int ocfs2_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_process_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *lockres);\n\nstatic inline struct inode *ocfs2_lock_res_inode(struct ocfs2_lock_res *lockres)\n{\n\tBUG_ON(!ocfs2_is_inode_lock(lockres));\n\n\treturn (struct inode *) lockres->l_priv;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"stackglue.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dcache.h\"\n#include \"alloc.h\"\n#include \"ocfs2_lockingver.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/quotaops.h>\n#include <linux/time.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/pagemap.h>\n#include <linux/kthread.h>\n#include <linux/mm.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic struct ocfs2_super *ocfs2_get_dentry_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_inode_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_file_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_qinfo_osb(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_set_meta_lvb(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_dentry_post_unlock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres);\nstatic void ocfs2_set_qinfo_lvb(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_downconvert_action(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_convert_action(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_attach_action(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_schedule_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_downconvert_on_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic int ocfs2_prepare_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\t        struct ocfs2_lock_res *lockres);\nstatic int ocfs2_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_process_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *lockres);\n\nstatic struct ocfs2_super *ocfs2_get_inode_osb(struct ocfs2_lock_res *lockres)\n{\n\tstruct inode *inode = ocfs2_lock_res_inode(lockres);\n\n\treturn OCFS2_SB(inode->i_sb);\n}"
  },
  {
    "function_name": "ocfs2_inode_lock_res_init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlmglue.c",
    "lines": "536-562",
    "snippet": "void ocfs2_inode_lock_res_init(struct ocfs2_lock_res *res,\n\t\t\t       enum ocfs2_lock_type type,\n\t\t\t       unsigned int generation,\n\t\t\t       struct inode *inode)\n{\n\tstruct ocfs2_lock_res_ops *ops;\n\n\tswitch(type) {\n\t\tcase OCFS2_LOCK_TYPE_RW:\n\t\t\tops = &ocfs2_inode_rw_lops;\n\t\t\tbreak;\n\t\tcase OCFS2_LOCK_TYPE_META:\n\t\t\tops = &ocfs2_inode_inode_lops;\n\t\t\tbreak;\n\t\tcase OCFS2_LOCK_TYPE_OPEN:\n\t\t\tops = &ocfs2_inode_open_lops;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tmlog_bug_on_msg(1, \"type: %d\\n\", type);\n\t\t\tops = NULL; /* thanks, gcc */\n\t\t\tbreak;\n\t};\n\n\tocfs2_build_lock_name(type, OCFS2_I(inode)->ip_blkno,\n\t\t\t      generation, res->l_name);\n\tocfs2_lock_res_init_common(OCFS2_SB(inode->i_sb), res, type, ops, inode);\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"refcounttree.h\"",
      "#include \"quota.h\"",
      "#include \"uptodate.h\"",
      "#include \"super.h\"",
      "#include \"slot_map.h\"",
      "#include \"stackglue.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"heartbeat.h\"",
      "#include \"file.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"dcache.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2_lockingver.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/time.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/kthread.h>",
      "#include <linux/mm.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct ocfs2_lock_res_ops ocfs2_inode_rw_lops = {\n\t.get_osb\t= ocfs2_get_inode_osb,\n\t.flags\t\t= 0,\n};",
      "static struct ocfs2_lock_res_ops ocfs2_inode_inode_lops = {\n\t.get_osb\t= ocfs2_get_inode_osb,\n\t.check_downconvert = ocfs2_check_meta_downconvert,\n\t.set_lvb\t= ocfs2_set_meta_lvb,\n\t.downconvert_worker = ocfs2_data_convert_worker,\n\t.flags\t\t= LOCK_TYPE_REQUIRES_REFRESH|LOCK_TYPE_USES_LVB,\n};",
      "static struct ocfs2_lock_res_ops ocfs2_inode_open_lops = {\n\t.get_osb\t= ocfs2_get_inode_osb,\n\t.flags\t\t= 0,\n};",
      "static int ocfs2_downconvert_lock(struct ocfs2_super *osb,\n\t\t\t\t  struct ocfs2_lock_res *lockres,\n\t\t\t\t  int new_level,\n\t\t\t\t  int lvb,\n\t\t\t\t  unsigned int generation);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ocfs2_lock_res_init_common",
          "args": [
            "OCFS2_SB(inode->i_sb)",
            "res",
            "type",
            "ops",
            "inode"
          ],
          "line": 561
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_lock_res_init_common",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlmglue.c",
          "lines": "496-524",
          "snippet": "static void ocfs2_lock_res_init_common(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *res,\n\t\t\t\t       enum ocfs2_lock_type type,\n\t\t\t\t       struct ocfs2_lock_res_ops *ops,\n\t\t\t\t       void *priv)\n{\n\tres->l_type          = type;\n\tres->l_ops           = ops;\n\tres->l_priv          = priv;\n\n\tres->l_level         = DLM_LOCK_IV;\n\tres->l_requested     = DLM_LOCK_IV;\n\tres->l_blocking      = DLM_LOCK_IV;\n\tres->l_action        = OCFS2_AST_INVALID;\n\tres->l_unlock_action = OCFS2_UNLOCK_INVALID;\n\n\tres->l_flags         = OCFS2_LOCK_INITIALIZED;\n\n\tocfs2_add_lockres_tracking(res, osb->osb_dlm_debug);\n\n\tocfs2_init_lock_stats(res);\n#ifdef CONFIG_DEBUG_LOCK_ALLOC\n\tif (type != OCFS2_LOCK_TYPE_OPEN)\n\t\tlockdep_init_map(&res->l_lockdep_map, ocfs2_lock_type_strings[type],\n\t\t\t\t &lockdep_keys[type], 0);\n\telse\n\t\tres->l_lockdep_map.key = NULL;\n#endif\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"refcounttree.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"stackglue.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dcache.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2_lockingver.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/time.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/kthread.h>",
            "#include <linux/mm.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct lock_class_key lockdep_keys[OCFS2_NUM_LOCK_TYPES];",
            "static void ocfs2_drop_osb_locks(struct ocfs2_super *osb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"stackglue.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dcache.h\"\n#include \"alloc.h\"\n#include \"ocfs2_lockingver.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/quotaops.h>\n#include <linux/time.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/pagemap.h>\n#include <linux/kthread.h>\n#include <linux/mm.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstruct lock_class_key lockdep_keys[OCFS2_NUM_LOCK_TYPES];\nstatic void ocfs2_drop_osb_locks(struct ocfs2_super *osb);\n\nstatic void ocfs2_lock_res_init_common(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *res,\n\t\t\t\t       enum ocfs2_lock_type type,\n\t\t\t\t       struct ocfs2_lock_res_ops *ops,\n\t\t\t\t       void *priv)\n{\n\tres->l_type          = type;\n\tres->l_ops           = ops;\n\tres->l_priv          = priv;\n\n\tres->l_level         = DLM_LOCK_IV;\n\tres->l_requested     = DLM_LOCK_IV;\n\tres->l_blocking      = DLM_LOCK_IV;\n\tres->l_action        = OCFS2_AST_INVALID;\n\tres->l_unlock_action = OCFS2_UNLOCK_INVALID;\n\n\tres->l_flags         = OCFS2_LOCK_INITIALIZED;\n\n\tocfs2_add_lockres_tracking(res, osb->osb_dlm_debug);\n\n\tocfs2_init_lock_stats(res);\n#ifdef CONFIG_DEBUG_LOCK_ALLOC\n\tif (type != OCFS2_LOCK_TYPE_OPEN)\n\t\tlockdep_init_map(&res->l_lockdep_map, ocfs2_lock_type_strings[type],\n\t\t\t\t &lockdep_keys[type], 0);\n\telse\n\t\tres->l_lockdep_map.key = NULL;\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "OCFS2_SB",
          "args": [
            "inode->i_sb"
          ],
          "line": 561
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_build_lock_name",
          "args": [
            "type",
            "OCFS2_I(inode)->ip_blkno",
            "generation",
            "res->l_name"
          ],
          "line": 559
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_build_lock_name",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlmglue.c",
          "lines": "393-409",
          "snippet": "static void ocfs2_build_lock_name(enum ocfs2_lock_type type,\n\t\t\t\t  u64 blkno,\n\t\t\t\t  u32 generation,\n\t\t\t\t  char *name)\n{\n\tint len;\n\n\tBUG_ON(type >= OCFS2_NUM_LOCK_TYPES);\n\n\tlen = snprintf(name, OCFS2_LOCK_ID_MAX_LEN, \"%c%s%016llx%08x\",\n\t\t       ocfs2_lock_type_char(type), OCFS2_LOCK_ID_PAD,\n\t\t       (long long)blkno, generation);\n\n\tBUG_ON(len != (OCFS2_LOCK_ID_MAX_LEN - 1));\n\n\tmlog(0, \"built lock resource with name: %s\\n\", name);\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"refcounttree.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"stackglue.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dcache.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2_lockingver.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/time.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/kthread.h>",
            "#include <linux/mm.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ocfs2_downconvert_lock(struct ocfs2_super *osb,\n\t\t\t\t  struct ocfs2_lock_res *lockres,\n\t\t\t\t  int new_level,\n\t\t\t\t  int lvb,\n\t\t\t\t  unsigned int generation);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"stackglue.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dcache.h\"\n#include \"alloc.h\"\n#include \"ocfs2_lockingver.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/quotaops.h>\n#include <linux/time.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/pagemap.h>\n#include <linux/kthread.h>\n#include <linux/mm.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic int ocfs2_downconvert_lock(struct ocfs2_super *osb,\n\t\t\t\t  struct ocfs2_lock_res *lockres,\n\t\t\t\t  int new_level,\n\t\t\t\t  int lvb,\n\t\t\t\t  unsigned int generation);\n\nstatic void ocfs2_build_lock_name(enum ocfs2_lock_type type,\n\t\t\t\t  u64 blkno,\n\t\t\t\t  u32 generation,\n\t\t\t\t  char *name)\n{\n\tint len;\n\n\tBUG_ON(type >= OCFS2_NUM_LOCK_TYPES);\n\n\tlen = snprintf(name, OCFS2_LOCK_ID_MAX_LEN, \"%c%s%016llx%08x\",\n\t\t       ocfs2_lock_type_char(type), OCFS2_LOCK_ID_PAD,\n\t\t       (long long)blkno, generation);\n\n\tBUG_ON(len != (OCFS2_LOCK_ID_MAX_LEN - 1));\n\n\tmlog(0, \"built lock resource with name: %s\\n\", name);\n}"
        }
      },
      {
        "call_info": {
          "callee": "OCFS2_I",
          "args": [
            "inode"
          ],
          "line": 559
        },
        "resolved": true,
        "details": {
          "function_name": "OCFS2_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/inode.h",
          "lines": "118-121",
          "snippet": "static inline struct ocfs2_inode_info *OCFS2_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ocfs2_inode_info, vfs_inode);\n}",
          "includes": [
            "#include \"extent_map.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extent_map.h\"\n\nstatic inline struct ocfs2_inode_info *OCFS2_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ocfs2_inode_info, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_bug_on_msg",
          "args": [
            "1",
            "\"type: %d\\n\"",
            "type"
          ],
          "line": 554
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"stackglue.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dcache.h\"\n#include \"alloc.h\"\n#include \"ocfs2_lockingver.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/quotaops.h>\n#include <linux/time.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/pagemap.h>\n#include <linux/kthread.h>\n#include <linux/mm.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic struct ocfs2_lock_res_ops ocfs2_inode_rw_lops = {\n\t.get_osb\t= ocfs2_get_inode_osb,\n\t.flags\t\t= 0,\n};\nstatic struct ocfs2_lock_res_ops ocfs2_inode_inode_lops = {\n\t.get_osb\t= ocfs2_get_inode_osb,\n\t.check_downconvert = ocfs2_check_meta_downconvert,\n\t.set_lvb\t= ocfs2_set_meta_lvb,\n\t.downconvert_worker = ocfs2_data_convert_worker,\n\t.flags\t\t= LOCK_TYPE_REQUIRES_REFRESH|LOCK_TYPE_USES_LVB,\n};\nstatic struct ocfs2_lock_res_ops ocfs2_inode_open_lops = {\n\t.get_osb\t= ocfs2_get_inode_osb,\n\t.flags\t\t= 0,\n};\nstatic int ocfs2_downconvert_lock(struct ocfs2_super *osb,\n\t\t\t\t  struct ocfs2_lock_res *lockres,\n\t\t\t\t  int new_level,\n\t\t\t\t  int lvb,\n\t\t\t\t  unsigned int generation);\n\nvoid ocfs2_inode_lock_res_init(struct ocfs2_lock_res *res,\n\t\t\t       enum ocfs2_lock_type type,\n\t\t\t       unsigned int generation,\n\t\t\t       struct inode *inode)\n{\n\tstruct ocfs2_lock_res_ops *ops;\n\n\tswitch(type) {\n\t\tcase OCFS2_LOCK_TYPE_RW:\n\t\t\tops = &ocfs2_inode_rw_lops;\n\t\t\tbreak;\n\t\tcase OCFS2_LOCK_TYPE_META:\n\t\t\tops = &ocfs2_inode_inode_lops;\n\t\t\tbreak;\n\t\tcase OCFS2_LOCK_TYPE_OPEN:\n\t\t\tops = &ocfs2_inode_open_lops;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tmlog_bug_on_msg(1, \"type: %d\\n\", type);\n\t\t\tops = NULL; /* thanks, gcc */\n\t\t\tbreak;\n\t};\n\n\tocfs2_build_lock_name(type, OCFS2_I(inode)->ip_blkno,\n\t\t\t      generation, res->l_name);\n\tocfs2_lock_res_init_common(OCFS2_SB(inode->i_sb), res, type, ops, inode);\n}"
  },
  {
    "function_name": "ocfs2_lock_res_init_once",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlmglue.c",
    "lines": "526-534",
    "snippet": "void ocfs2_lock_res_init_once(struct ocfs2_lock_res *res)\n{\n\t/* This also clears out the lock status block */\n\tmemset(res, 0, sizeof(struct ocfs2_lock_res));\n\tspin_lock_init(&res->l_lock);\n\tinit_waitqueue_head(&res->l_event);\n\tINIT_LIST_HEAD(&res->l_blocked_list);\n\tINIT_LIST_HEAD(&res->l_mask_waiters);\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"refcounttree.h\"",
      "#include \"quota.h\"",
      "#include \"uptodate.h\"",
      "#include \"super.h\"",
      "#include \"slot_map.h\"",
      "#include \"stackglue.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"heartbeat.h\"",
      "#include \"file.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"dcache.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2_lockingver.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/time.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/kthread.h>",
      "#include <linux/mm.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&res->l_mask_waiters"
          ],
          "line": 533
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&res->l_blocked_list"
          ],
          "line": 532
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "init_waitqueue_head",
          "args": [
            "&res->l_event"
          ],
          "line": 531
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock_init",
          "args": [
            "&res->l_lock"
          ],
          "line": 530
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "res",
            "0",
            "sizeof(struct ocfs2_lock_res)"
          ],
          "line": 529
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"stackglue.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dcache.h\"\n#include \"alloc.h\"\n#include \"ocfs2_lockingver.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/quotaops.h>\n#include <linux/time.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/pagemap.h>\n#include <linux/kthread.h>\n#include <linux/mm.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nvoid ocfs2_lock_res_init_once(struct ocfs2_lock_res *res)\n{\n\t/* This also clears out the lock status block */\n\tmemset(res, 0, sizeof(struct ocfs2_lock_res));\n\tspin_lock_init(&res->l_lock);\n\tinit_waitqueue_head(&res->l_event);\n\tINIT_LIST_HEAD(&res->l_blocked_list);\n\tINIT_LIST_HEAD(&res->l_mask_waiters);\n}"
  },
  {
    "function_name": "ocfs2_lock_res_init_common",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlmglue.c",
    "lines": "496-524",
    "snippet": "static void ocfs2_lock_res_init_common(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *res,\n\t\t\t\t       enum ocfs2_lock_type type,\n\t\t\t\t       struct ocfs2_lock_res_ops *ops,\n\t\t\t\t       void *priv)\n{\n\tres->l_type          = type;\n\tres->l_ops           = ops;\n\tres->l_priv          = priv;\n\n\tres->l_level         = DLM_LOCK_IV;\n\tres->l_requested     = DLM_LOCK_IV;\n\tres->l_blocking      = DLM_LOCK_IV;\n\tres->l_action        = OCFS2_AST_INVALID;\n\tres->l_unlock_action = OCFS2_UNLOCK_INVALID;\n\n\tres->l_flags         = OCFS2_LOCK_INITIALIZED;\n\n\tocfs2_add_lockres_tracking(res, osb->osb_dlm_debug);\n\n\tocfs2_init_lock_stats(res);\n#ifdef CONFIG_DEBUG_LOCK_ALLOC\n\tif (type != OCFS2_LOCK_TYPE_OPEN)\n\t\tlockdep_init_map(&res->l_lockdep_map, ocfs2_lock_type_strings[type],\n\t\t\t\t &lockdep_keys[type], 0);\n\telse\n\t\tres->l_lockdep_map.key = NULL;\n#endif\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"refcounttree.h\"",
      "#include \"quota.h\"",
      "#include \"uptodate.h\"",
      "#include \"super.h\"",
      "#include \"slot_map.h\"",
      "#include \"stackglue.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"heartbeat.h\"",
      "#include \"file.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"dcache.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2_lockingver.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/time.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/kthread.h>",
      "#include <linux/mm.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "struct lock_class_key lockdep_keys[OCFS2_NUM_LOCK_TYPES];",
      "static void ocfs2_drop_osb_locks(struct ocfs2_super *osb);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "lockdep_init_map",
          "args": [
            "&res->l_lockdep_map",
            "ocfs2_lock_type_strings[type]",
            "&lockdep_keys[type]",
            "0"
          ],
          "line": 519
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_init_lock_stats",
          "args": [
            "res"
          ],
          "line": 516
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_init_lock_stats",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlmglue.c",
          "lines": "481-483",
          "snippet": "static inline void ocfs2_init_lock_stats(struct ocfs2_lock_res *res)\n{\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"refcounttree.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"stackglue.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dcache.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2_lockingver.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/time.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/kthread.h>",
            "#include <linux/mm.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"stackglue.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dcache.h\"\n#include \"alloc.h\"\n#include \"ocfs2_lockingver.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/quotaops.h>\n#include <linux/time.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/pagemap.h>\n#include <linux/kthread.h>\n#include <linux/mm.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic inline void ocfs2_init_lock_stats(struct ocfs2_lock_res *res)\n{\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_add_lockres_tracking",
          "args": [
            "res",
            "osb->osb_dlm_debug"
          ],
          "line": 514
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_add_lockres_tracking",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlmglue.c",
          "lines": "413-421",
          "snippet": "static void ocfs2_add_lockres_tracking(struct ocfs2_lock_res *res,\n\t\t\t\t       struct ocfs2_dlm_debug *dlm_debug)\n{\n\tmlog(0, \"Add tracking for lockres %s\\n\", res->l_name);\n\n\tspin_lock(&ocfs2_dlm_tracking_lock);\n\tlist_add(&res->l_debug_list, &dlm_debug->d_lockres_tracking);\n\tspin_unlock(&ocfs2_dlm_tracking_lock);\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"refcounttree.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"stackglue.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dcache.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2_lockingver.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/time.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/kthread.h>",
            "#include <linux/mm.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct ocfs2_super *ocfs2_get_dentry_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_inode_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_file_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_qinfo_osb(struct ocfs2_lock_res *lockres);",
            "static void ocfs2_set_meta_lvb(struct ocfs2_lock_res *lockres);",
            "static void ocfs2_dentry_post_unlock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres);",
            "static void ocfs2_set_qinfo_lvb(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_downconvert_action(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_convert_action(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_attach_action(struct ocfs2_lock_res *lockres);",
            "static void ocfs2_schedule_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static void ocfs2_downconvert_on_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static int ocfs2_prepare_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\t        struct ocfs2_lock_res *lockres);",
            "static int ocfs2_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static DEFINE_SPINLOCK(ocfs2_dlm_tracking_lock);",
            "static void ocfs2_process_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *lockres);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"stackglue.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dcache.h\"\n#include \"alloc.h\"\n#include \"ocfs2_lockingver.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/quotaops.h>\n#include <linux/time.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/pagemap.h>\n#include <linux/kthread.h>\n#include <linux/mm.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic struct ocfs2_super *ocfs2_get_dentry_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_inode_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_file_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_qinfo_osb(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_set_meta_lvb(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_dentry_post_unlock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres);\nstatic void ocfs2_set_qinfo_lvb(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_downconvert_action(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_convert_action(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_attach_action(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_schedule_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_downconvert_on_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic int ocfs2_prepare_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\t        struct ocfs2_lock_res *lockres);\nstatic int ocfs2_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic DEFINE_SPINLOCK(ocfs2_dlm_tracking_lock);\nstatic void ocfs2_process_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *lockres);\n\nstatic void ocfs2_add_lockres_tracking(struct ocfs2_lock_res *res,\n\t\t\t\t       struct ocfs2_dlm_debug *dlm_debug)\n{\n\tmlog(0, \"Add tracking for lockres %s\\n\", res->l_name);\n\n\tspin_lock(&ocfs2_dlm_tracking_lock);\n\tlist_add(&res->l_debug_list, &dlm_debug->d_lockres_tracking);\n\tspin_unlock(&ocfs2_dlm_tracking_lock);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"stackglue.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dcache.h\"\n#include \"alloc.h\"\n#include \"ocfs2_lockingver.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/quotaops.h>\n#include <linux/time.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/pagemap.h>\n#include <linux/kthread.h>\n#include <linux/mm.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstruct lock_class_key lockdep_keys[OCFS2_NUM_LOCK_TYPES];\nstatic void ocfs2_drop_osb_locks(struct ocfs2_super *osb);\n\nstatic void ocfs2_lock_res_init_common(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *res,\n\t\t\t\t       enum ocfs2_lock_type type,\n\t\t\t\t       struct ocfs2_lock_res_ops *ops,\n\t\t\t\t       void *priv)\n{\n\tres->l_type          = type;\n\tres->l_ops           = ops;\n\tres->l_priv          = priv;\n\n\tres->l_level         = DLM_LOCK_IV;\n\tres->l_requested     = DLM_LOCK_IV;\n\tres->l_blocking      = DLM_LOCK_IV;\n\tres->l_action        = OCFS2_AST_INVALID;\n\tres->l_unlock_action = OCFS2_UNLOCK_INVALID;\n\n\tres->l_flags         = OCFS2_LOCK_INITIALIZED;\n\n\tocfs2_add_lockres_tracking(res, osb->osb_dlm_debug);\n\n\tocfs2_init_lock_stats(res);\n#ifdef CONFIG_DEBUG_LOCK_ALLOC\n\tif (type != OCFS2_LOCK_TYPE_OPEN)\n\t\tlockdep_init_map(&res->l_lockdep_map, ocfs2_lock_type_strings[type],\n\t\t\t\t &lockdep_keys[type], 0);\n\telse\n\t\tres->l_lockdep_map.key = NULL;\n#endif\n}"
  },
  {
    "function_name": "ocfs2_init_start_time",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlmglue.c",
    "lines": "491-493",
    "snippet": "static inline void ocfs2_init_start_time(struct ocfs2_mask_waiter *mw)\n{\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"refcounttree.h\"",
      "#include \"quota.h\"",
      "#include \"uptodate.h\"",
      "#include \"super.h\"",
      "#include \"slot_map.h\"",
      "#include \"stackglue.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"heartbeat.h\"",
      "#include \"file.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"dcache.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2_lockingver.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/time.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/kthread.h>",
      "#include <linux/mm.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"stackglue.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dcache.h\"\n#include \"alloc.h\"\n#include \"ocfs2_lockingver.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/quotaops.h>\n#include <linux/time.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/pagemap.h>\n#include <linux/kthread.h>\n#include <linux/mm.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic inline void ocfs2_init_start_time(struct ocfs2_mask_waiter *mw)\n{\n}"
  },
  {
    "function_name": "ocfs2_track_lock_refresh",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlmglue.c",
    "lines": "488-490",
    "snippet": "static inline void ocfs2_track_lock_refresh(struct ocfs2_lock_res *lockres)\n{\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"refcounttree.h\"",
      "#include \"quota.h\"",
      "#include \"uptodate.h\"",
      "#include \"super.h\"",
      "#include \"slot_map.h\"",
      "#include \"stackglue.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"heartbeat.h\"",
      "#include \"file.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"dcache.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2_lockingver.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/time.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/kthread.h>",
      "#include <linux/mm.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct ocfs2_super *ocfs2_get_dentry_osb(struct ocfs2_lock_res *lockres);",
      "static struct ocfs2_super *ocfs2_get_inode_osb(struct ocfs2_lock_res *lockres);",
      "static struct ocfs2_super *ocfs2_get_file_osb(struct ocfs2_lock_res *lockres);",
      "static struct ocfs2_super *ocfs2_get_qinfo_osb(struct ocfs2_lock_res *lockres);",
      "static void ocfs2_set_meta_lvb(struct ocfs2_lock_res *lockres);",
      "static void ocfs2_dentry_post_unlock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres);",
      "static void ocfs2_set_qinfo_lvb(struct ocfs2_lock_res *lockres);",
      "static inline void ocfs2_generic_handle_downconvert_action(struct ocfs2_lock_res *lockres);",
      "static inline void ocfs2_generic_handle_convert_action(struct ocfs2_lock_res *lockres);",
      "static inline void ocfs2_generic_handle_attach_action(struct ocfs2_lock_res *lockres);",
      "static void ocfs2_schedule_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);",
      "static void ocfs2_downconvert_on_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);",
      "static int ocfs2_prepare_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\t        struct ocfs2_lock_res *lockres);",
      "static int ocfs2_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres);",
      "static void ocfs2_process_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *lockres);"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"stackglue.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dcache.h\"\n#include \"alloc.h\"\n#include \"ocfs2_lockingver.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/quotaops.h>\n#include <linux/time.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/pagemap.h>\n#include <linux/kthread.h>\n#include <linux/mm.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic struct ocfs2_super *ocfs2_get_dentry_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_inode_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_file_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_qinfo_osb(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_set_meta_lvb(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_dentry_post_unlock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres);\nstatic void ocfs2_set_qinfo_lvb(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_downconvert_action(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_convert_action(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_attach_action(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_schedule_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_downconvert_on_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic int ocfs2_prepare_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\t        struct ocfs2_lock_res *lockres);\nstatic int ocfs2_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_process_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *lockres);\n\nstatic inline void ocfs2_track_lock_refresh(struct ocfs2_lock_res *lockres)\n{\n}"
  },
  {
    "function_name": "ocfs2_update_lock_stats",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlmglue.c",
    "lines": "484-487",
    "snippet": "static inline void ocfs2_update_lock_stats(struct ocfs2_lock_res *res,\n\t\t\t   int level, struct ocfs2_mask_waiter *mw, int ret)\n{\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"refcounttree.h\"",
      "#include \"quota.h\"",
      "#include \"uptodate.h\"",
      "#include \"super.h\"",
      "#include \"slot_map.h\"",
      "#include \"stackglue.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"heartbeat.h\"",
      "#include \"file.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"dcache.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2_lockingver.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/time.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/kthread.h>",
      "#include <linux/mm.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ocfs2_generic_handle_bast(struct ocfs2_lock_res *lockres, int level);",
      "static inline int ocfs2_highest_compat_lock_level(int level);"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"stackglue.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dcache.h\"\n#include \"alloc.h\"\n#include \"ocfs2_lockingver.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/quotaops.h>\n#include <linux/time.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/pagemap.h>\n#include <linux/kthread.h>\n#include <linux/mm.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic int ocfs2_generic_handle_bast(struct ocfs2_lock_res *lockres, int level);\nstatic inline int ocfs2_highest_compat_lock_level(int level);\n\nstatic inline void ocfs2_update_lock_stats(struct ocfs2_lock_res *res,\n\t\t\t   int level, struct ocfs2_mask_waiter *mw, int ret)\n{\n}"
  },
  {
    "function_name": "ocfs2_init_lock_stats",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlmglue.c",
    "lines": "481-483",
    "snippet": "static inline void ocfs2_init_lock_stats(struct ocfs2_lock_res *res)\n{\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"refcounttree.h\"",
      "#include \"quota.h\"",
      "#include \"uptodate.h\"",
      "#include \"super.h\"",
      "#include \"slot_map.h\"",
      "#include \"stackglue.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"heartbeat.h\"",
      "#include \"file.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"dcache.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2_lockingver.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/time.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/kthread.h>",
      "#include <linux/mm.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"stackglue.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dcache.h\"\n#include \"alloc.h\"\n#include \"ocfs2_lockingver.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/quotaops.h>\n#include <linux/time.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/pagemap.h>\n#include <linux/kthread.h>\n#include <linux/mm.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic inline void ocfs2_init_lock_stats(struct ocfs2_lock_res *res)\n{\n}"
  },
  {
    "function_name": "ocfs2_init_start_time",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlmglue.c",
    "lines": "476-479",
    "snippet": "static inline void ocfs2_init_start_time(struct ocfs2_mask_waiter *mw)\n{\n\tmw->mw_lock_start = ktime_get();\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"refcounttree.h\"",
      "#include \"quota.h\"",
      "#include \"uptodate.h\"",
      "#include \"super.h\"",
      "#include \"slot_map.h\"",
      "#include \"stackglue.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"heartbeat.h\"",
      "#include \"file.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"dcache.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2_lockingver.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/time.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/kthread.h>",
      "#include <linux/mm.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ktime_get",
          "args": [],
          "line": 478
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"stackglue.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dcache.h\"\n#include \"alloc.h\"\n#include \"ocfs2_lockingver.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/quotaops.h>\n#include <linux/time.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/pagemap.h>\n#include <linux/kthread.h>\n#include <linux/mm.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic inline void ocfs2_init_start_time(struct ocfs2_mask_waiter *mw)\n{\n\tmw->mw_lock_start = ktime_get();\n}"
  },
  {
    "function_name": "ocfs2_track_lock_refresh",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlmglue.c",
    "lines": "471-474",
    "snippet": "static inline void ocfs2_track_lock_refresh(struct ocfs2_lock_res *lockres)\n{\n\tlockres->l_lock_refresh++;\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"refcounttree.h\"",
      "#include \"quota.h\"",
      "#include \"uptodate.h\"",
      "#include \"super.h\"",
      "#include \"slot_map.h\"",
      "#include \"stackglue.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"heartbeat.h\"",
      "#include \"file.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"dcache.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2_lockingver.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/time.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/kthread.h>",
      "#include <linux/mm.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct ocfs2_super *ocfs2_get_dentry_osb(struct ocfs2_lock_res *lockres);",
      "static struct ocfs2_super *ocfs2_get_inode_osb(struct ocfs2_lock_res *lockres);",
      "static struct ocfs2_super *ocfs2_get_file_osb(struct ocfs2_lock_res *lockres);",
      "static struct ocfs2_super *ocfs2_get_qinfo_osb(struct ocfs2_lock_res *lockres);",
      "static void ocfs2_set_meta_lvb(struct ocfs2_lock_res *lockres);",
      "static void ocfs2_dentry_post_unlock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres);",
      "static void ocfs2_set_qinfo_lvb(struct ocfs2_lock_res *lockres);",
      "static inline void ocfs2_generic_handle_downconvert_action(struct ocfs2_lock_res *lockres);",
      "static inline void ocfs2_generic_handle_convert_action(struct ocfs2_lock_res *lockres);",
      "static inline void ocfs2_generic_handle_attach_action(struct ocfs2_lock_res *lockres);",
      "static void ocfs2_schedule_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);",
      "static void ocfs2_downconvert_on_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);",
      "static int ocfs2_prepare_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\t        struct ocfs2_lock_res *lockres);",
      "static int ocfs2_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres);",
      "static void ocfs2_process_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *lockres);"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"stackglue.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dcache.h\"\n#include \"alloc.h\"\n#include \"ocfs2_lockingver.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/quotaops.h>\n#include <linux/time.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/pagemap.h>\n#include <linux/kthread.h>\n#include <linux/mm.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic struct ocfs2_super *ocfs2_get_dentry_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_inode_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_file_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_qinfo_osb(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_set_meta_lvb(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_dentry_post_unlock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres);\nstatic void ocfs2_set_qinfo_lvb(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_downconvert_action(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_convert_action(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_attach_action(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_schedule_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_downconvert_on_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic int ocfs2_prepare_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\t        struct ocfs2_lock_res *lockres);\nstatic int ocfs2_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_process_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *lockres);\n\nstatic inline void ocfs2_track_lock_refresh(struct ocfs2_lock_res *lockres)\n{\n\tlockres->l_lock_refresh++;\n}"
  },
  {
    "function_name": "ocfs2_update_lock_stats",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlmglue.c",
    "lines": "439-469",
    "snippet": "static void ocfs2_update_lock_stats(struct ocfs2_lock_res *res, int level,\n\t\t\t\t    struct ocfs2_mask_waiter *mw, int ret)\n{\n\tu32 usec;\n\tktime_t kt;\n\tstruct ocfs2_lock_stats *stats;\n\n\tif (level == LKM_PRMODE)\n\t\tstats = &res->l_lock_prmode;\n\telse if (level == LKM_EXMODE)\n\t\tstats = &res->l_lock_exmode;\n\telse\n\t\treturn;\n\n\tkt = ktime_sub(ktime_get(), mw->mw_lock_start);\n\tusec = ktime_to_us(kt);\n\n\tstats->ls_gets++;\n\tstats->ls_total += ktime_to_ns(kt);\n\t/* overflow */\n\tif (unlikely(stats->ls_gets == 0)) {\n\t\tstats->ls_gets++;\n\t\tstats->ls_total = ktime_to_ns(kt);\n\t}\n\n\tif (stats->ls_max < usec)\n\t\tstats->ls_max = usec;\n\n\tif (ret)\n\t\tstats->ls_fail++;\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"refcounttree.h\"",
      "#include \"quota.h\"",
      "#include \"uptodate.h\"",
      "#include \"super.h\"",
      "#include \"slot_map.h\"",
      "#include \"stackglue.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"heartbeat.h\"",
      "#include \"file.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"dcache.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2_lockingver.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/time.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/kthread.h>",
      "#include <linux/mm.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ocfs2_generic_handle_bast(struct ocfs2_lock_res *lockres, int level);",
      "static inline int ocfs2_highest_compat_lock_level(int level);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ktime_to_ns",
          "args": [
            "kt"
          ],
          "line": 461
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "stats->ls_gets == 0"
          ],
          "line": 459
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ktime_to_ns",
          "args": [
            "kt"
          ],
          "line": 457
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ktime_to_us",
          "args": [
            "kt"
          ],
          "line": 454
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ktime_sub",
          "args": [
            "ktime_get()",
            "mw->mw_lock_start"
          ],
          "line": 453
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ktime_get",
          "args": [],
          "line": 453
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"stackglue.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dcache.h\"\n#include \"alloc.h\"\n#include \"ocfs2_lockingver.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/quotaops.h>\n#include <linux/time.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/pagemap.h>\n#include <linux/kthread.h>\n#include <linux/mm.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic int ocfs2_generic_handle_bast(struct ocfs2_lock_res *lockres, int level);\nstatic inline int ocfs2_highest_compat_lock_level(int level);\n\nstatic void ocfs2_update_lock_stats(struct ocfs2_lock_res *res, int level,\n\t\t\t\t    struct ocfs2_mask_waiter *mw, int ret)\n{\n\tu32 usec;\n\tktime_t kt;\n\tstruct ocfs2_lock_stats *stats;\n\n\tif (level == LKM_PRMODE)\n\t\tstats = &res->l_lock_prmode;\n\telse if (level == LKM_EXMODE)\n\t\tstats = &res->l_lock_exmode;\n\telse\n\t\treturn;\n\n\tkt = ktime_sub(ktime_get(), mw->mw_lock_start);\n\tusec = ktime_to_us(kt);\n\n\tstats->ls_gets++;\n\tstats->ls_total += ktime_to_ns(kt);\n\t/* overflow */\n\tif (unlikely(stats->ls_gets == 0)) {\n\t\tstats->ls_gets++;\n\t\tstats->ls_total = ktime_to_ns(kt);\n\t}\n\n\tif (stats->ls_max < usec)\n\t\tstats->ls_max = usec;\n\n\tif (ret)\n\t\tstats->ls_fail++;\n}"
  },
  {
    "function_name": "ocfs2_init_lock_stats",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlmglue.c",
    "lines": "432-437",
    "snippet": "static void ocfs2_init_lock_stats(struct ocfs2_lock_res *res)\n{\n\tres->l_lock_refresh = 0;\n\tmemset(&res->l_lock_prmode, 0, sizeof(struct ocfs2_lock_stats));\n\tmemset(&res->l_lock_exmode, 0, sizeof(struct ocfs2_lock_stats));\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"refcounttree.h\"",
      "#include \"quota.h\"",
      "#include \"uptodate.h\"",
      "#include \"super.h\"",
      "#include \"slot_map.h\"",
      "#include \"stackglue.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"heartbeat.h\"",
      "#include \"file.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"dcache.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2_lockingver.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/time.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/kthread.h>",
      "#include <linux/mm.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&res->l_lock_exmode",
            "0",
            "sizeof(struct ocfs2_lock_stats)"
          ],
          "line": 436
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&res->l_lock_prmode",
            "0",
            "sizeof(struct ocfs2_lock_stats)"
          ],
          "line": 435
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"stackglue.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dcache.h\"\n#include \"alloc.h\"\n#include \"ocfs2_lockingver.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/quotaops.h>\n#include <linux/time.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/pagemap.h>\n#include <linux/kthread.h>\n#include <linux/mm.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic void ocfs2_init_lock_stats(struct ocfs2_lock_res *res)\n{\n\tres->l_lock_refresh = 0;\n\tmemset(&res->l_lock_prmode, 0, sizeof(struct ocfs2_lock_stats));\n\tmemset(&res->l_lock_exmode, 0, sizeof(struct ocfs2_lock_stats));\n}"
  },
  {
    "function_name": "ocfs2_remove_lockres_tracking",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlmglue.c",
    "lines": "423-429",
    "snippet": "static void ocfs2_remove_lockres_tracking(struct ocfs2_lock_res *res)\n{\n\tspin_lock(&ocfs2_dlm_tracking_lock);\n\tif (!list_empty(&res->l_debug_list))\n\t\tlist_del_init(&res->l_debug_list);\n\tspin_unlock(&ocfs2_dlm_tracking_lock);\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"refcounttree.h\"",
      "#include \"quota.h\"",
      "#include \"uptodate.h\"",
      "#include \"super.h\"",
      "#include \"slot_map.h\"",
      "#include \"stackglue.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"heartbeat.h\"",
      "#include \"file.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"dcache.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2_lockingver.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/time.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/kthread.h>",
      "#include <linux/mm.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_SPINLOCK(ocfs2_dlm_tracking_lock);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&ocfs2_dlm_tracking_lock"
          ],
          "line": 428
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_del_init",
          "args": [
            "&res->l_debug_list"
          ],
          "line": 427
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&res->l_debug_list"
          ],
          "line": 426
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_dirty_list_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmthread.c",
          "lines": "505-514",
          "snippet": "static int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/timer.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_flush_asts(struct dlm_ctxt *dlm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/timer.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_flush_asts(struct dlm_ctxt *dlm);\n\nstatic int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&ocfs2_dlm_tracking_lock"
          ],
          "line": 425
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"stackglue.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dcache.h\"\n#include \"alloc.h\"\n#include \"ocfs2_lockingver.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/quotaops.h>\n#include <linux/time.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/pagemap.h>\n#include <linux/kthread.h>\n#include <linux/mm.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic DEFINE_SPINLOCK(ocfs2_dlm_tracking_lock);\n\nstatic void ocfs2_remove_lockres_tracking(struct ocfs2_lock_res *res)\n{\n\tspin_lock(&ocfs2_dlm_tracking_lock);\n\tif (!list_empty(&res->l_debug_list))\n\t\tlist_del_init(&res->l_debug_list);\n\tspin_unlock(&ocfs2_dlm_tracking_lock);\n}"
  },
  {
    "function_name": "ocfs2_add_lockres_tracking",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlmglue.c",
    "lines": "413-421",
    "snippet": "static void ocfs2_add_lockres_tracking(struct ocfs2_lock_res *res,\n\t\t\t\t       struct ocfs2_dlm_debug *dlm_debug)\n{\n\tmlog(0, \"Add tracking for lockres %s\\n\", res->l_name);\n\n\tspin_lock(&ocfs2_dlm_tracking_lock);\n\tlist_add(&res->l_debug_list, &dlm_debug->d_lockres_tracking);\n\tspin_unlock(&ocfs2_dlm_tracking_lock);\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"refcounttree.h\"",
      "#include \"quota.h\"",
      "#include \"uptodate.h\"",
      "#include \"super.h\"",
      "#include \"slot_map.h\"",
      "#include \"stackglue.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"heartbeat.h\"",
      "#include \"file.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"dcache.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2_lockingver.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/time.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/kthread.h>",
      "#include <linux/mm.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct ocfs2_super *ocfs2_get_dentry_osb(struct ocfs2_lock_res *lockres);",
      "static struct ocfs2_super *ocfs2_get_inode_osb(struct ocfs2_lock_res *lockres);",
      "static struct ocfs2_super *ocfs2_get_file_osb(struct ocfs2_lock_res *lockres);",
      "static struct ocfs2_super *ocfs2_get_qinfo_osb(struct ocfs2_lock_res *lockres);",
      "static void ocfs2_set_meta_lvb(struct ocfs2_lock_res *lockres);",
      "static void ocfs2_dentry_post_unlock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres);",
      "static void ocfs2_set_qinfo_lvb(struct ocfs2_lock_res *lockres);",
      "static inline void ocfs2_generic_handle_downconvert_action(struct ocfs2_lock_res *lockres);",
      "static inline void ocfs2_generic_handle_convert_action(struct ocfs2_lock_res *lockres);",
      "static inline void ocfs2_generic_handle_attach_action(struct ocfs2_lock_res *lockres);",
      "static void ocfs2_schedule_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);",
      "static void ocfs2_downconvert_on_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);",
      "static int ocfs2_prepare_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\t        struct ocfs2_lock_res *lockres);",
      "static int ocfs2_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres);",
      "static DEFINE_SPINLOCK(ocfs2_dlm_tracking_lock);",
      "static void ocfs2_process_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *lockres);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&ocfs2_dlm_tracking_lock"
          ],
          "line": 420
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_add",
          "args": [
            "&res->l_debug_list",
            "&dlm_debug->d_lockres_tracking"
          ],
          "line": 419
        },
        "resolved": true,
        "details": {
          "function_name": "simple_xattr_list_add",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xattr.c",
          "lines": "966-972",
          "snippet": "void simple_xattr_list_add(struct simple_xattrs *xattrs,\n\t\t\t   struct simple_xattr *new_xattr)\n{\n\tspin_lock(&xattrs->lock);\n\tlist_add(&new_xattr->list, &xattrs->head);\n\tspin_unlock(&xattrs->lock);\n}",
          "includes": [
            "#include <asm/uaccess.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/audit.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/evm.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/xattr.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/uaccess.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/vmalloc.h>\n#include <linux/audit.h>\n#include <linux/fsnotify.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n#include <linux/evm.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/xattr.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nvoid simple_xattr_list_add(struct simple_xattrs *xattrs,\n\t\t\t   struct simple_xattr *new_xattr)\n{\n\tspin_lock(&xattrs->lock);\n\tlist_add(&new_xattr->list, &xattrs->head);\n\tspin_unlock(&xattrs->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&ocfs2_dlm_tracking_lock"
          ],
          "line": 418
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog",
          "args": [
            "0",
            "\"Add tracking for lockres %s\\n\"",
            "res->l_name"
          ],
          "line": 416
        },
        "resolved": true,
        "details": {
          "function_name": "mlog_show",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/cluster/masklog.c",
          "lines": "107-113",
          "snippet": "static ssize_t mlog_show(struct kobject *obj, struct attribute *attr,\n\t\t\t char *buf)\n{\n\tstruct mlog_attribute *mlog_attr = to_mlog_attr(attr);\n\n\treturn mlog_mask_show(mlog_attr->mask, buf);\n}",
          "includes": [
            "#include \"masklog.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/string.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"masklog.h\"\n#include <asm/uaccess.h>\n#include <linux/string.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n\nstatic ssize_t mlog_show(struct kobject *obj, struct attribute *attr,\n\t\t\t char *buf)\n{\n\tstruct mlog_attribute *mlog_attr = to_mlog_attr(attr);\n\n\treturn mlog_mask_show(mlog_attr->mask, buf);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"stackglue.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dcache.h\"\n#include \"alloc.h\"\n#include \"ocfs2_lockingver.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/quotaops.h>\n#include <linux/time.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/pagemap.h>\n#include <linux/kthread.h>\n#include <linux/mm.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic struct ocfs2_super *ocfs2_get_dentry_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_inode_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_file_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_qinfo_osb(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_set_meta_lvb(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_dentry_post_unlock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres);\nstatic void ocfs2_set_qinfo_lvb(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_downconvert_action(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_convert_action(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_attach_action(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_schedule_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_downconvert_on_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic int ocfs2_prepare_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\t        struct ocfs2_lock_res *lockres);\nstatic int ocfs2_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic DEFINE_SPINLOCK(ocfs2_dlm_tracking_lock);\nstatic void ocfs2_process_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *lockres);\n\nstatic void ocfs2_add_lockres_tracking(struct ocfs2_lock_res *res,\n\t\t\t\t       struct ocfs2_dlm_debug *dlm_debug)\n{\n\tmlog(0, \"Add tracking for lockres %s\\n\", res->l_name);\n\n\tspin_lock(&ocfs2_dlm_tracking_lock);\n\tlist_add(&res->l_debug_list, &dlm_debug->d_lockres_tracking);\n\tspin_unlock(&ocfs2_dlm_tracking_lock);\n}"
  },
  {
    "function_name": "ocfs2_build_lock_name",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlmglue.c",
    "lines": "393-409",
    "snippet": "static void ocfs2_build_lock_name(enum ocfs2_lock_type type,\n\t\t\t\t  u64 blkno,\n\t\t\t\t  u32 generation,\n\t\t\t\t  char *name)\n{\n\tint len;\n\n\tBUG_ON(type >= OCFS2_NUM_LOCK_TYPES);\n\n\tlen = snprintf(name, OCFS2_LOCK_ID_MAX_LEN, \"%c%s%016llx%08x\",\n\t\t       ocfs2_lock_type_char(type), OCFS2_LOCK_ID_PAD,\n\t\t       (long long)blkno, generation);\n\n\tBUG_ON(len != (OCFS2_LOCK_ID_MAX_LEN - 1));\n\n\tmlog(0, \"built lock resource with name: %s\\n\", name);\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"refcounttree.h\"",
      "#include \"quota.h\"",
      "#include \"uptodate.h\"",
      "#include \"super.h\"",
      "#include \"slot_map.h\"",
      "#include \"stackglue.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"heartbeat.h\"",
      "#include \"file.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"dcache.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2_lockingver.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/time.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/kthread.h>",
      "#include <linux/mm.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ocfs2_downconvert_lock(struct ocfs2_super *osb,\n\t\t\t\t  struct ocfs2_lock_res *lockres,\n\t\t\t\t  int new_level,\n\t\t\t\t  int lvb,\n\t\t\t\t  unsigned int generation);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mlog",
          "args": [
            "0",
            "\"built lock resource with name: %s\\n\"",
            "name"
          ],
          "line": 408
        },
        "resolved": true,
        "details": {
          "function_name": "mlog_show",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/cluster/masklog.c",
          "lines": "107-113",
          "snippet": "static ssize_t mlog_show(struct kobject *obj, struct attribute *attr,\n\t\t\t char *buf)\n{\n\tstruct mlog_attribute *mlog_attr = to_mlog_attr(attr);\n\n\treturn mlog_mask_show(mlog_attr->mask, buf);\n}",
          "includes": [
            "#include \"masklog.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/string.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"masklog.h\"\n#include <asm/uaccess.h>\n#include <linux/string.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n\nstatic ssize_t mlog_show(struct kobject *obj, struct attribute *attr,\n\t\t\t char *buf)\n{\n\tstruct mlog_attribute *mlog_attr = to_mlog_attr(attr);\n\n\treturn mlog_mask_show(mlog_attr->mask, buf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "len != (OCFS2_LOCK_ID_MAX_LEN - 1)"
          ],
          "line": 406
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "name",
            "OCFS2_LOCK_ID_MAX_LEN",
            "\"%c%s%016llx%08x\"",
            "ocfs2_lock_type_char(type)",
            "OCFS2_LOCK_ID_PAD",
            "(long long)blkno",
            "generation"
          ],
          "line": 402
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_lock_type_char",
          "args": [
            "type"
          ],
          "line": 403
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_lock_type_char",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2_lockid.h",
          "lines": "56-101",
          "snippet": "static inline char ocfs2_lock_type_char(enum ocfs2_lock_type type)\n{\n\tchar c;\n\tswitch (type) {\n\t\tcase OCFS2_LOCK_TYPE_META:\n\t\t\tc = 'M';\n\t\t\tbreak;\n\t\tcase OCFS2_LOCK_TYPE_DATA:\n\t\t\tc = 'D';\n\t\t\tbreak;\n\t\tcase OCFS2_LOCK_TYPE_SUPER:\n\t\t\tc = 'S';\n\t\t\tbreak;\n\t\tcase OCFS2_LOCK_TYPE_RENAME:\n\t\t\tc = 'R';\n\t\t\tbreak;\n\t\tcase OCFS2_LOCK_TYPE_RW:\n\t\t\tc = 'W';\n\t\t\tbreak;\n\t\tcase OCFS2_LOCK_TYPE_DENTRY:\n\t\t\tc = 'N';\n\t\t\tbreak;\n\t\tcase OCFS2_LOCK_TYPE_OPEN:\n\t\t\tc = 'O';\n\t\t\tbreak;\n\t\tcase OCFS2_LOCK_TYPE_FLOCK:\n\t\t\tc = 'F';\n\t\t\tbreak;\n\t\tcase OCFS2_LOCK_TYPE_QINFO:\n\t\t\tc = 'Q';\n\t\t\tbreak;\n\t\tcase OCFS2_LOCK_TYPE_NFS_SYNC:\n\t\t\tc = 'Y';\n\t\t\tbreak;\n\t\tcase OCFS2_LOCK_TYPE_ORPHAN_SCAN:\n\t\t\tc = 'P';\n\t\t\tbreak;\n\t\tcase OCFS2_LOCK_TYPE_REFCOUNT:\n\t\t\tc = 'T';\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tc = '\\0';\n\t}\n\n\treturn c;\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline char ocfs2_lock_type_char(enum ocfs2_lock_type type)\n{\n\tchar c;\n\tswitch (type) {\n\t\tcase OCFS2_LOCK_TYPE_META:\n\t\t\tc = 'M';\n\t\t\tbreak;\n\t\tcase OCFS2_LOCK_TYPE_DATA:\n\t\t\tc = 'D';\n\t\t\tbreak;\n\t\tcase OCFS2_LOCK_TYPE_SUPER:\n\t\t\tc = 'S';\n\t\t\tbreak;\n\t\tcase OCFS2_LOCK_TYPE_RENAME:\n\t\t\tc = 'R';\n\t\t\tbreak;\n\t\tcase OCFS2_LOCK_TYPE_RW:\n\t\t\tc = 'W';\n\t\t\tbreak;\n\t\tcase OCFS2_LOCK_TYPE_DENTRY:\n\t\t\tc = 'N';\n\t\t\tbreak;\n\t\tcase OCFS2_LOCK_TYPE_OPEN:\n\t\t\tc = 'O';\n\t\t\tbreak;\n\t\tcase OCFS2_LOCK_TYPE_FLOCK:\n\t\t\tc = 'F';\n\t\t\tbreak;\n\t\tcase OCFS2_LOCK_TYPE_QINFO:\n\t\t\tc = 'Q';\n\t\t\tbreak;\n\t\tcase OCFS2_LOCK_TYPE_NFS_SYNC:\n\t\t\tc = 'Y';\n\t\t\tbreak;\n\t\tcase OCFS2_LOCK_TYPE_ORPHAN_SCAN:\n\t\t\tc = 'P';\n\t\t\tbreak;\n\t\tcase OCFS2_LOCK_TYPE_REFCOUNT:\n\t\t\tc = 'T';\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tc = '\\0';\n\t}\n\n\treturn c;\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "type >= OCFS2_NUM_LOCK_TYPES"
          ],
          "line": 400
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"stackglue.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dcache.h\"\n#include \"alloc.h\"\n#include \"ocfs2_lockingver.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/quotaops.h>\n#include <linux/time.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/pagemap.h>\n#include <linux/kthread.h>\n#include <linux/mm.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic int ocfs2_downconvert_lock(struct ocfs2_super *osb,\n\t\t\t\t  struct ocfs2_lock_res *lockres,\n\t\t\t\t  int new_level,\n\t\t\t\t  int lvb,\n\t\t\t\t  unsigned int generation);\n\nstatic void ocfs2_build_lock_name(enum ocfs2_lock_type type,\n\t\t\t\t  u64 blkno,\n\t\t\t\t  u32 generation,\n\t\t\t\t  char *name)\n{\n\tint len;\n\n\tBUG_ON(type >= OCFS2_NUM_LOCK_TYPES);\n\n\tlen = snprintf(name, OCFS2_LOCK_ID_MAX_LEN, \"%c%s%016llx%08x\",\n\t\t       ocfs2_lock_type_char(type), OCFS2_LOCK_ID_PAD,\n\t\t       (long long)blkno, generation);\n\n\tBUG_ON(len != (OCFS2_LOCK_ID_MAX_LEN - 1));\n\n\tmlog(0, \"built lock resource with name: %s\\n\", name);\n}"
  },
  {
    "function_name": "ocfs2_cluster_unlock",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlmglue.c",
    "lines": "349-354",
    "snippet": "static inline void ocfs2_cluster_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres,\n\t\t\t\t\tint level)\n{\n\t__ocfs2_cluster_unlock(osb, lockres, level, _RET_IP_);\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"refcounttree.h\"",
      "#include \"quota.h\"",
      "#include \"uptodate.h\"",
      "#include \"super.h\"",
      "#include \"slot_map.h\"",
      "#include \"stackglue.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"heartbeat.h\"",
      "#include \"file.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"dcache.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2_lockingver.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/time.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/kthread.h>",
      "#include <linux/mm.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct ocfs2_super *ocfs2_get_dentry_osb(struct ocfs2_lock_res *lockres);",
      "static struct ocfs2_super *ocfs2_get_inode_osb(struct ocfs2_lock_res *lockres);",
      "static struct ocfs2_super *ocfs2_get_file_osb(struct ocfs2_lock_res *lockres);",
      "static struct ocfs2_super *ocfs2_get_qinfo_osb(struct ocfs2_lock_res *lockres);",
      "static void ocfs2_set_meta_lvb(struct ocfs2_lock_res *lockres);",
      "static void ocfs2_dentry_post_unlock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres);",
      "static void ocfs2_set_qinfo_lvb(struct ocfs2_lock_res *lockres);",
      "static inline void ocfs2_generic_handle_downconvert_action(struct ocfs2_lock_res *lockres);",
      "static inline void ocfs2_generic_handle_convert_action(struct ocfs2_lock_res *lockres);",
      "static inline void ocfs2_generic_handle_attach_action(struct ocfs2_lock_res *lockres);",
      "static int ocfs2_generic_handle_bast(struct ocfs2_lock_res *lockres, int level);",
      "static void ocfs2_schedule_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);",
      "static void ocfs2_downconvert_on_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);",
      "static void ocfs2_drop_osb_locks(struct ocfs2_super *osb);",
      "static inline int ocfs2_highest_compat_lock_level(int level);",
      "static int ocfs2_prepare_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\t        struct ocfs2_lock_res *lockres);",
      "static int ocfs2_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres);",
      "static void ocfs2_process_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *lockres);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "__ocfs2_cluster_unlock",
          "args": [
            "osb",
            "lockres",
            "level",
            "_RET_IP_"
          ],
          "line": 353
        },
        "resolved": true,
        "details": {
          "function_name": "__ocfs2_cluster_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlmglue.c",
          "lines": "1581-1596",
          "snippet": "static void __ocfs2_cluster_unlock(struct ocfs2_super *osb,\n\t\t\t\t   struct ocfs2_lock_res *lockres,\n\t\t\t\t   int level,\n\t\t\t\t   unsigned long caller_ip)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&lockres->l_lock, flags);\n\tocfs2_dec_holders(lockres, level);\n\tocfs2_downconvert_on_unlock(osb, lockres);\n\tspin_unlock_irqrestore(&lockres->l_lock, flags);\n#ifdef CONFIG_DEBUG_LOCK_ALLOC\n\tif (lockres->l_lockdep_map.key != NULL)\n\t\trwsem_release(&lockres->l_lockdep_map, 1, caller_ip);\n#endif\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"refcounttree.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"stackglue.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dcache.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2_lockingver.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/time.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/kthread.h>",
            "#include <linux/mm.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct ocfs2_super *ocfs2_get_dentry_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_inode_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_file_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_qinfo_osb(struct ocfs2_lock_res *lockres);",
            "static void ocfs2_set_meta_lvb(struct ocfs2_lock_res *lockres);",
            "static void ocfs2_dentry_post_unlock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres);",
            "static void ocfs2_set_qinfo_lvb(struct ocfs2_lock_res *lockres);",
            "static void __ocfs2_cluster_unlock(struct ocfs2_super *osb,\n\t\t\t\t   struct ocfs2_lock_res *lockres,\n\t\t\t\t   int level, unsigned long caller_ip);",
            "static inline void ocfs2_generic_handle_downconvert_action(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_convert_action(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_attach_action(struct ocfs2_lock_res *lockres);",
            "static int ocfs2_generic_handle_bast(struct ocfs2_lock_res *lockres, int level);",
            "static void ocfs2_schedule_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static void ocfs2_downconvert_on_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static void ocfs2_drop_osb_locks(struct ocfs2_super *osb);",
            "static inline int ocfs2_highest_compat_lock_level(int level);",
            "static int ocfs2_prepare_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\t        struct ocfs2_lock_res *lockres);",
            "static int ocfs2_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static void ocfs2_process_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *lockres);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"stackglue.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dcache.h\"\n#include \"alloc.h\"\n#include \"ocfs2_lockingver.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/quotaops.h>\n#include <linux/time.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/pagemap.h>\n#include <linux/kthread.h>\n#include <linux/mm.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic struct ocfs2_super *ocfs2_get_dentry_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_inode_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_file_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_qinfo_osb(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_set_meta_lvb(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_dentry_post_unlock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres);\nstatic void ocfs2_set_qinfo_lvb(struct ocfs2_lock_res *lockres);\nstatic void __ocfs2_cluster_unlock(struct ocfs2_super *osb,\n\t\t\t\t   struct ocfs2_lock_res *lockres,\n\t\t\t\t   int level, unsigned long caller_ip);\nstatic inline void ocfs2_generic_handle_downconvert_action(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_convert_action(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_attach_action(struct ocfs2_lock_res *lockres);\nstatic int ocfs2_generic_handle_bast(struct ocfs2_lock_res *lockres, int level);\nstatic void ocfs2_schedule_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_downconvert_on_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_drop_osb_locks(struct ocfs2_super *osb);\nstatic inline int ocfs2_highest_compat_lock_level(int level);\nstatic int ocfs2_prepare_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\t        struct ocfs2_lock_res *lockres);\nstatic int ocfs2_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_process_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *lockres);\n\nstatic void __ocfs2_cluster_unlock(struct ocfs2_super *osb,\n\t\t\t\t   struct ocfs2_lock_res *lockres,\n\t\t\t\t   int level,\n\t\t\t\t   unsigned long caller_ip)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&lockres->l_lock, flags);\n\tocfs2_dec_holders(lockres, level);\n\tocfs2_downconvert_on_unlock(osb, lockres);\n\tspin_unlock_irqrestore(&lockres->l_lock, flags);\n#ifdef CONFIG_DEBUG_LOCK_ALLOC\n\tif (lockres->l_lockdep_map.key != NULL)\n\t\trwsem_release(&lockres->l_lockdep_map, 1, caller_ip);\n#endif\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"stackglue.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dcache.h\"\n#include \"alloc.h\"\n#include \"ocfs2_lockingver.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/quotaops.h>\n#include <linux/time.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/pagemap.h>\n#include <linux/kthread.h>\n#include <linux/mm.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic struct ocfs2_super *ocfs2_get_dentry_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_inode_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_file_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_qinfo_osb(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_set_meta_lvb(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_dentry_post_unlock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres);\nstatic void ocfs2_set_qinfo_lvb(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_downconvert_action(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_convert_action(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_attach_action(struct ocfs2_lock_res *lockres);\nstatic int ocfs2_generic_handle_bast(struct ocfs2_lock_res *lockres, int level);\nstatic void ocfs2_schedule_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_downconvert_on_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_drop_osb_locks(struct ocfs2_super *osb);\nstatic inline int ocfs2_highest_compat_lock_level(int level);\nstatic int ocfs2_prepare_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\t        struct ocfs2_lock_res *lockres);\nstatic int ocfs2_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_process_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *lockres);\n\nstatic inline void ocfs2_cluster_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres,\n\t\t\t\t\tint level)\n{\n\t__ocfs2_cluster_unlock(osb, lockres, level, _RET_IP_);\n}"
  },
  {
    "function_name": "ocfs2_get_lockres_osb",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlmglue.c",
    "lines": "332-338",
    "snippet": "static inline struct ocfs2_super *ocfs2_get_lockres_osb(struct ocfs2_lock_res *lockres)\n{\n\tif (lockres->l_ops->get_osb)\n\t\treturn lockres->l_ops->get_osb(lockres);\n\n\treturn (struct ocfs2_super *)lockres->l_priv;\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"refcounttree.h\"",
      "#include \"quota.h\"",
      "#include \"uptodate.h\"",
      "#include \"super.h\"",
      "#include \"slot_map.h\"",
      "#include \"stackglue.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"heartbeat.h\"",
      "#include \"file.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"dcache.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2_lockingver.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/time.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/kthread.h>",
      "#include <linux/mm.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct ocfs2_super *ocfs2_get_dentry_osb(struct ocfs2_lock_res *lockres);",
      "static struct ocfs2_super *ocfs2_get_inode_osb(struct ocfs2_lock_res *lockres);",
      "static struct ocfs2_super *ocfs2_get_file_osb(struct ocfs2_lock_res *lockres);",
      "static struct ocfs2_super *ocfs2_get_qinfo_osb(struct ocfs2_lock_res *lockres);",
      "static void ocfs2_set_meta_lvb(struct ocfs2_lock_res *lockres);",
      "static void ocfs2_dentry_post_unlock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres);",
      "static void ocfs2_set_qinfo_lvb(struct ocfs2_lock_res *lockres);",
      "static inline void ocfs2_generic_handle_downconvert_action(struct ocfs2_lock_res *lockres);",
      "static inline void ocfs2_generic_handle_convert_action(struct ocfs2_lock_res *lockres);",
      "static inline void ocfs2_generic_handle_attach_action(struct ocfs2_lock_res *lockres);",
      "static void ocfs2_schedule_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);",
      "static void ocfs2_downconvert_on_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);",
      "static int ocfs2_prepare_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\t        struct ocfs2_lock_res *lockres);",
      "static int ocfs2_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres);",
      "static void ocfs2_process_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *lockres);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "lockres->l_ops->get_osb",
          "args": [
            "lockres"
          ],
          "line": 335
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"stackglue.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dcache.h\"\n#include \"alloc.h\"\n#include \"ocfs2_lockingver.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/quotaops.h>\n#include <linux/time.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/pagemap.h>\n#include <linux/kthread.h>\n#include <linux/mm.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic struct ocfs2_super *ocfs2_get_dentry_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_inode_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_file_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_qinfo_osb(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_set_meta_lvb(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_dentry_post_unlock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres);\nstatic void ocfs2_set_qinfo_lvb(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_downconvert_action(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_convert_action(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_attach_action(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_schedule_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_downconvert_on_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic int ocfs2_prepare_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\t        struct ocfs2_lock_res *lockres);\nstatic int ocfs2_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_process_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *lockres);\n\nstatic inline struct ocfs2_super *ocfs2_get_lockres_osb(struct ocfs2_lock_res *lockres)\n{\n\tif (lockres->l_ops->get_osb)\n\t\treturn lockres->l_ops->get_osb(lockres);\n\n\treturn (struct ocfs2_super *)lockres->l_priv;\n}"
  },
  {
    "function_name": "ocfs2_lock_res_refcount_tree",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlmglue.c",
    "lines": "326-330",
    "snippet": "static inline struct ocfs2_refcount_tree *\nocfs2_lock_res_refcount_tree(struct ocfs2_lock_res *res)\n{\n\treturn container_of(res, struct ocfs2_refcount_tree, rf_lockres);\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"refcounttree.h\"",
      "#include \"quota.h\"",
      "#include \"uptodate.h\"",
      "#include \"super.h\"",
      "#include \"slot_map.h\"",
      "#include \"stackglue.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"heartbeat.h\"",
      "#include \"file.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"dcache.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2_lockingver.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/time.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/kthread.h>",
      "#include <linux/mm.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "res",
            "structocfs2_refcount_tree",
            "rf_lockres"
          ],
          "line": 329
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"stackglue.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dcache.h\"\n#include \"alloc.h\"\n#include \"ocfs2_lockingver.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/quotaops.h>\n#include <linux/time.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/pagemap.h>\n#include <linux/kthread.h>\n#include <linux/mm.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic inline struct ocfs2_refcount_tree *\nocfs2_lock_res_refcount_tree(struct ocfs2_lock_res *res)\n{\n\treturn container_of(res, struct ocfs2_refcount_tree, rf_lockres);\n}"
  },
  {
    "function_name": "ocfs2_lock_res_qinfo",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlmglue.c",
    "lines": "319-324",
    "snippet": "static inline struct ocfs2_mem_dqinfo *ocfs2_lock_res_qinfo(struct ocfs2_lock_res *lockres)\n{\n\tBUG_ON(lockres->l_type != OCFS2_LOCK_TYPE_QINFO);\n\n\treturn (struct ocfs2_mem_dqinfo *)lockres->l_priv;\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"refcounttree.h\"",
      "#include \"quota.h\"",
      "#include \"uptodate.h\"",
      "#include \"super.h\"",
      "#include \"slot_map.h\"",
      "#include \"stackglue.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"heartbeat.h\"",
      "#include \"file.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"dcache.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2_lockingver.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/time.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/kthread.h>",
      "#include <linux/mm.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct ocfs2_super *ocfs2_get_dentry_osb(struct ocfs2_lock_res *lockres);",
      "static struct ocfs2_super *ocfs2_get_inode_osb(struct ocfs2_lock_res *lockres);",
      "static struct ocfs2_super *ocfs2_get_file_osb(struct ocfs2_lock_res *lockres);",
      "static struct ocfs2_super *ocfs2_get_qinfo_osb(struct ocfs2_lock_res *lockres);",
      "static void ocfs2_set_meta_lvb(struct ocfs2_lock_res *lockres);",
      "static void ocfs2_dentry_post_unlock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres);",
      "static void ocfs2_set_qinfo_lvb(struct ocfs2_lock_res *lockres);",
      "static inline void ocfs2_generic_handle_downconvert_action(struct ocfs2_lock_res *lockres);",
      "static inline void ocfs2_generic_handle_convert_action(struct ocfs2_lock_res *lockres);",
      "static inline void ocfs2_generic_handle_attach_action(struct ocfs2_lock_res *lockres);",
      "static void ocfs2_schedule_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);",
      "static void ocfs2_downconvert_on_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);",
      "static int ocfs2_prepare_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\t        struct ocfs2_lock_res *lockres);",
      "static int ocfs2_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres);",
      "static void ocfs2_process_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *lockres);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "lockres->l_type != OCFS2_LOCK_TYPE_QINFO"
          ],
          "line": 321
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"stackglue.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dcache.h\"\n#include \"alloc.h\"\n#include \"ocfs2_lockingver.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/quotaops.h>\n#include <linux/time.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/pagemap.h>\n#include <linux/kthread.h>\n#include <linux/mm.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic struct ocfs2_super *ocfs2_get_dentry_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_inode_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_file_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_qinfo_osb(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_set_meta_lvb(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_dentry_post_unlock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres);\nstatic void ocfs2_set_qinfo_lvb(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_downconvert_action(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_convert_action(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_attach_action(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_schedule_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_downconvert_on_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic int ocfs2_prepare_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\t        struct ocfs2_lock_res *lockres);\nstatic int ocfs2_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_process_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *lockres);\n\nstatic inline struct ocfs2_mem_dqinfo *ocfs2_lock_res_qinfo(struct ocfs2_lock_res *lockres)\n{\n\tBUG_ON(lockres->l_type != OCFS2_LOCK_TYPE_QINFO);\n\n\treturn (struct ocfs2_mem_dqinfo *)lockres->l_priv;\n}"
  },
  {
    "function_name": "ocfs2_lock_res_dl",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlmglue.c",
    "lines": "312-317",
    "snippet": "static inline struct ocfs2_dentry_lock *ocfs2_lock_res_dl(struct ocfs2_lock_res *lockres)\n{\n\tBUG_ON(lockres->l_type != OCFS2_LOCK_TYPE_DENTRY);\n\n\treturn (struct ocfs2_dentry_lock *)lockres->l_priv;\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"refcounttree.h\"",
      "#include \"quota.h\"",
      "#include \"uptodate.h\"",
      "#include \"super.h\"",
      "#include \"slot_map.h\"",
      "#include \"stackglue.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"heartbeat.h\"",
      "#include \"file.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"dcache.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2_lockingver.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/time.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/kthread.h>",
      "#include <linux/mm.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct ocfs2_super *ocfs2_get_dentry_osb(struct ocfs2_lock_res *lockres);",
      "static struct ocfs2_super *ocfs2_get_inode_osb(struct ocfs2_lock_res *lockres);",
      "static struct ocfs2_super *ocfs2_get_file_osb(struct ocfs2_lock_res *lockres);",
      "static struct ocfs2_super *ocfs2_get_qinfo_osb(struct ocfs2_lock_res *lockres);",
      "static void ocfs2_set_meta_lvb(struct ocfs2_lock_res *lockres);",
      "static void ocfs2_dentry_post_unlock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres);",
      "static void ocfs2_set_qinfo_lvb(struct ocfs2_lock_res *lockres);",
      "static inline void ocfs2_generic_handle_downconvert_action(struct ocfs2_lock_res *lockres);",
      "static inline void ocfs2_generic_handle_convert_action(struct ocfs2_lock_res *lockres);",
      "static inline void ocfs2_generic_handle_attach_action(struct ocfs2_lock_res *lockres);",
      "static void ocfs2_schedule_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);",
      "static void ocfs2_downconvert_on_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);",
      "static int ocfs2_prepare_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\t        struct ocfs2_lock_res *lockres);",
      "static int ocfs2_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres);",
      "static void ocfs2_process_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *lockres);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "lockres->l_type != OCFS2_LOCK_TYPE_DENTRY"
          ],
          "line": 314
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"stackglue.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dcache.h\"\n#include \"alloc.h\"\n#include \"ocfs2_lockingver.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/quotaops.h>\n#include <linux/time.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/pagemap.h>\n#include <linux/kthread.h>\n#include <linux/mm.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic struct ocfs2_super *ocfs2_get_dentry_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_inode_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_file_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_qinfo_osb(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_set_meta_lvb(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_dentry_post_unlock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres);\nstatic void ocfs2_set_qinfo_lvb(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_downconvert_action(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_convert_action(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_attach_action(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_schedule_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_downconvert_on_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic int ocfs2_prepare_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\t        struct ocfs2_lock_res *lockres);\nstatic int ocfs2_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_process_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *lockres);\n\nstatic inline struct ocfs2_dentry_lock *ocfs2_lock_res_dl(struct ocfs2_lock_res *lockres)\n{\n\tBUG_ON(lockres->l_type != OCFS2_LOCK_TYPE_DENTRY);\n\n\treturn (struct ocfs2_dentry_lock *)lockres->l_priv;\n}"
  },
  {
    "function_name": "ocfs2_lock_res_inode",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlmglue.c",
    "lines": "305-310",
    "snippet": "static inline struct inode *ocfs2_lock_res_inode(struct ocfs2_lock_res *lockres)\n{\n\tBUG_ON(!ocfs2_is_inode_lock(lockres));\n\n\treturn (struct inode *) lockres->l_priv;\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"refcounttree.h\"",
      "#include \"quota.h\"",
      "#include \"uptodate.h\"",
      "#include \"super.h\"",
      "#include \"slot_map.h\"",
      "#include \"stackglue.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"heartbeat.h\"",
      "#include \"file.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"dcache.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2_lockingver.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/time.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/kthread.h>",
      "#include <linux/mm.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct ocfs2_super *ocfs2_get_dentry_osb(struct ocfs2_lock_res *lockres);",
      "static struct ocfs2_super *ocfs2_get_inode_osb(struct ocfs2_lock_res *lockres);",
      "static struct ocfs2_super *ocfs2_get_file_osb(struct ocfs2_lock_res *lockres);",
      "static struct ocfs2_super *ocfs2_get_qinfo_osb(struct ocfs2_lock_res *lockres);",
      "static void ocfs2_set_meta_lvb(struct ocfs2_lock_res *lockres);",
      "static void ocfs2_dentry_post_unlock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres);",
      "static void ocfs2_set_qinfo_lvb(struct ocfs2_lock_res *lockres);",
      "static inline void ocfs2_generic_handle_downconvert_action(struct ocfs2_lock_res *lockres);",
      "static inline void ocfs2_generic_handle_convert_action(struct ocfs2_lock_res *lockres);",
      "static inline void ocfs2_generic_handle_attach_action(struct ocfs2_lock_res *lockres);",
      "static void ocfs2_schedule_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);",
      "static void ocfs2_downconvert_on_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);",
      "static int ocfs2_prepare_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\t        struct ocfs2_lock_res *lockres);",
      "static int ocfs2_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres);",
      "static void ocfs2_process_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *lockres);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!ocfs2_is_inode_lock(lockres)"
          ],
          "line": 307
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_is_inode_lock",
          "args": [
            "lockres"
          ],
          "line": 307
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_is_inode_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlmglue.c",
          "lines": "293-298",
          "snippet": "static inline int ocfs2_is_inode_lock(struct ocfs2_lock_res *lockres)\n{\n\treturn lockres->l_type == OCFS2_LOCK_TYPE_META ||\n\t\tlockres->l_type == OCFS2_LOCK_TYPE_RW ||\n\t\tlockres->l_type == OCFS2_LOCK_TYPE_OPEN;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"refcounttree.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"stackglue.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dcache.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2_lockingver.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/time.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/kthread.h>",
            "#include <linux/mm.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct ocfs2_super *ocfs2_get_dentry_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_inode_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_file_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_qinfo_osb(struct ocfs2_lock_res *lockres);",
            "static void ocfs2_set_meta_lvb(struct ocfs2_lock_res *lockres);",
            "static void ocfs2_dentry_post_unlock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres);",
            "static void ocfs2_set_qinfo_lvb(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_downconvert_action(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_convert_action(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_attach_action(struct ocfs2_lock_res *lockres);",
            "static void ocfs2_schedule_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static void ocfs2_downconvert_on_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static int ocfs2_prepare_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\t        struct ocfs2_lock_res *lockres);",
            "static int ocfs2_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static void ocfs2_process_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *lockres);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"stackglue.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dcache.h\"\n#include \"alloc.h\"\n#include \"ocfs2_lockingver.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/quotaops.h>\n#include <linux/time.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/pagemap.h>\n#include <linux/kthread.h>\n#include <linux/mm.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic struct ocfs2_super *ocfs2_get_dentry_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_inode_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_file_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_qinfo_osb(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_set_meta_lvb(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_dentry_post_unlock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres);\nstatic void ocfs2_set_qinfo_lvb(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_downconvert_action(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_convert_action(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_attach_action(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_schedule_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_downconvert_on_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic int ocfs2_prepare_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\t        struct ocfs2_lock_res *lockres);\nstatic int ocfs2_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_process_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *lockres);\n\nstatic inline int ocfs2_is_inode_lock(struct ocfs2_lock_res *lockres)\n{\n\treturn lockres->l_type == OCFS2_LOCK_TYPE_META ||\n\t\tlockres->l_type == OCFS2_LOCK_TYPE_RW ||\n\t\tlockres->l_type == OCFS2_LOCK_TYPE_OPEN;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"stackglue.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dcache.h\"\n#include \"alloc.h\"\n#include \"ocfs2_lockingver.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/quotaops.h>\n#include <linux/time.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/pagemap.h>\n#include <linux/kthread.h>\n#include <linux/mm.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic struct ocfs2_super *ocfs2_get_dentry_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_inode_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_file_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_qinfo_osb(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_set_meta_lvb(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_dentry_post_unlock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres);\nstatic void ocfs2_set_qinfo_lvb(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_downconvert_action(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_convert_action(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_attach_action(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_schedule_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_downconvert_on_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic int ocfs2_prepare_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\t        struct ocfs2_lock_res *lockres);\nstatic int ocfs2_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_process_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *lockres);\n\nstatic inline struct inode *ocfs2_lock_res_inode(struct ocfs2_lock_res *lockres)\n{\n\tBUG_ON(!ocfs2_is_inode_lock(lockres));\n\n\treturn (struct inode *) lockres->l_priv;\n}"
  },
  {
    "function_name": "ocfs2_lksb_to_lock_res",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlmglue.c",
    "lines": "300-303",
    "snippet": "static inline struct ocfs2_lock_res *ocfs2_lksb_to_lock_res(struct ocfs2_dlm_lksb *lksb)\n{\n\treturn container_of(lksb, struct ocfs2_lock_res, l_lksb);\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"refcounttree.h\"",
      "#include \"quota.h\"",
      "#include \"uptodate.h\"",
      "#include \"super.h\"",
      "#include \"slot_map.h\"",
      "#include \"stackglue.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"heartbeat.h\"",
      "#include \"file.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"dcache.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2_lockingver.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/time.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/kthread.h>",
      "#include <linux/mm.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "lksb",
            "structocfs2_lock_res",
            "l_lksb"
          ],
          "line": 302
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"stackglue.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dcache.h\"\n#include \"alloc.h\"\n#include \"ocfs2_lockingver.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/quotaops.h>\n#include <linux/time.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/pagemap.h>\n#include <linux/kthread.h>\n#include <linux/mm.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic inline struct ocfs2_lock_res *ocfs2_lksb_to_lock_res(struct ocfs2_dlm_lksb *lksb)\n{\n\treturn container_of(lksb, struct ocfs2_lock_res, l_lksb);\n}"
  },
  {
    "function_name": "ocfs2_is_inode_lock",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlmglue.c",
    "lines": "293-298",
    "snippet": "static inline int ocfs2_is_inode_lock(struct ocfs2_lock_res *lockres)\n{\n\treturn lockres->l_type == OCFS2_LOCK_TYPE_META ||\n\t\tlockres->l_type == OCFS2_LOCK_TYPE_RW ||\n\t\tlockres->l_type == OCFS2_LOCK_TYPE_OPEN;\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"refcounttree.h\"",
      "#include \"quota.h\"",
      "#include \"uptodate.h\"",
      "#include \"super.h\"",
      "#include \"slot_map.h\"",
      "#include \"stackglue.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"heartbeat.h\"",
      "#include \"file.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"dcache.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2_lockingver.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/time.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/kthread.h>",
      "#include <linux/mm.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct ocfs2_super *ocfs2_get_dentry_osb(struct ocfs2_lock_res *lockres);",
      "static struct ocfs2_super *ocfs2_get_inode_osb(struct ocfs2_lock_res *lockres);",
      "static struct ocfs2_super *ocfs2_get_file_osb(struct ocfs2_lock_res *lockres);",
      "static struct ocfs2_super *ocfs2_get_qinfo_osb(struct ocfs2_lock_res *lockres);",
      "static void ocfs2_set_meta_lvb(struct ocfs2_lock_res *lockres);",
      "static void ocfs2_dentry_post_unlock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres);",
      "static void ocfs2_set_qinfo_lvb(struct ocfs2_lock_res *lockres);",
      "static inline void ocfs2_generic_handle_downconvert_action(struct ocfs2_lock_res *lockres);",
      "static inline void ocfs2_generic_handle_convert_action(struct ocfs2_lock_res *lockres);",
      "static inline void ocfs2_generic_handle_attach_action(struct ocfs2_lock_res *lockres);",
      "static void ocfs2_schedule_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);",
      "static void ocfs2_downconvert_on_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);",
      "static int ocfs2_prepare_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\t        struct ocfs2_lock_res *lockres);",
      "static int ocfs2_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres);",
      "static void ocfs2_process_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *lockres);"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"stackglue.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dcache.h\"\n#include \"alloc.h\"\n#include \"ocfs2_lockingver.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/quotaops.h>\n#include <linux/time.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/pagemap.h>\n#include <linux/kthread.h>\n#include <linux/mm.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic struct ocfs2_super *ocfs2_get_dentry_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_inode_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_file_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_qinfo_osb(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_set_meta_lvb(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_dentry_post_unlock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres);\nstatic void ocfs2_set_qinfo_lvb(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_downconvert_action(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_convert_action(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_attach_action(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_schedule_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_downconvert_on_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic int ocfs2_prepare_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\t        struct ocfs2_lock_res *lockres);\nstatic int ocfs2_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_process_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *lockres);\n\nstatic inline int ocfs2_is_inode_lock(struct ocfs2_lock_res *lockres)\n{\n\treturn lockres->l_type == OCFS2_LOCK_TYPE_META ||\n\t\tlockres->l_type == OCFS2_LOCK_TYPE_RW ||\n\t\tlockres->l_type == OCFS2_LOCK_TYPE_OPEN;\n}"
  },
  {
    "function_name": "ocfs2_dump_meta_lvb_info",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlmglue.c",
    "lines": "122-144",
    "snippet": "static void ocfs2_dump_meta_lvb_info(u64 level,\n\t\t\t\t     const char *function,\n\t\t\t\t     unsigned int line,\n\t\t\t\t     struct ocfs2_lock_res *lockres)\n{\n\tstruct ocfs2_meta_lvb *lvb = ocfs2_dlm_lvb(&lockres->l_lksb);\n\n\tmlog(level, \"LVB information for %s (called from %s:%u):\\n\",\n\t     lockres->l_name, function, line);\n\tmlog(level, \"version: %u, clusters: %u, generation: 0x%x\\n\",\n\t     lvb->lvb_version, be32_to_cpu(lvb->lvb_iclusters),\n\t     be32_to_cpu(lvb->lvb_igeneration));\n\tmlog(level, \"size: %llu, uid %u, gid %u, mode 0x%x\\n\",\n\t     (unsigned long long)be64_to_cpu(lvb->lvb_isize),\n\t     be32_to_cpu(lvb->lvb_iuid), be32_to_cpu(lvb->lvb_igid),\n\t     be16_to_cpu(lvb->lvb_imode));\n\tmlog(level, \"nlink %u, atime_packed 0x%llx, ctime_packed 0x%llx, \"\n\t     \"mtime_packed 0x%llx iattr 0x%x\\n\", be16_to_cpu(lvb->lvb_inlink),\n\t     (long long)be64_to_cpu(lvb->lvb_iatime_packed),\n\t     (long long)be64_to_cpu(lvb->lvb_ictime_packed),\n\t     (long long)be64_to_cpu(lvb->lvb_imtime_packed),\n\t     be32_to_cpu(lvb->lvb_iattr));\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"refcounttree.h\"",
      "#include \"quota.h\"",
      "#include \"uptodate.h\"",
      "#include \"super.h\"",
      "#include \"slot_map.h\"",
      "#include \"stackglue.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"heartbeat.h\"",
      "#include \"file.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"dcache.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2_lockingver.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/time.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/kthread.h>",
      "#include <linux/mm.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct ocfs2_super *ocfs2_get_dentry_osb(struct ocfs2_lock_res *lockres);",
      "static struct ocfs2_super *ocfs2_get_inode_osb(struct ocfs2_lock_res *lockres);",
      "static struct ocfs2_super *ocfs2_get_file_osb(struct ocfs2_lock_res *lockres);",
      "static struct ocfs2_super *ocfs2_get_qinfo_osb(struct ocfs2_lock_res *lockres);",
      "static void ocfs2_set_meta_lvb(struct ocfs2_lock_res *lockres);",
      "static void ocfs2_dentry_post_unlock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres);",
      "static void ocfs2_set_qinfo_lvb(struct ocfs2_lock_res *lockres);",
      "static inline void ocfs2_generic_handle_downconvert_action(struct ocfs2_lock_res *lockres);",
      "static inline void ocfs2_generic_handle_convert_action(struct ocfs2_lock_res *lockres);",
      "static inline void ocfs2_generic_handle_attach_action(struct ocfs2_lock_res *lockres);",
      "static int ocfs2_generic_handle_bast(struct ocfs2_lock_res *lockres, int level);",
      "static void ocfs2_schedule_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);",
      "static void ocfs2_downconvert_on_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);",
      "static inline int ocfs2_highest_compat_lock_level(int level);",
      "static int ocfs2_downconvert_lock(struct ocfs2_super *osb,\n\t\t\t\t  struct ocfs2_lock_res *lockres,\n\t\t\t\t  int new_level,\n\t\t\t\t  int lvb,\n\t\t\t\t  unsigned int generation);",
      "static int ocfs2_prepare_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\t        struct ocfs2_lock_res *lockres);",
      "static int ocfs2_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres);",
      "static void ocfs2_process_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *lockres);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mlog",
          "args": [
            "level",
            "\"nlink %u, atime_packed 0x%llx, ctime_packed 0x%llx, \"\n\t     \"mtime_packed 0x%llx iattr 0x%x\\n\"",
            "be16_to_cpu(lvb->lvb_inlink)",
            "(long long)be64_to_cpu(lvb->lvb_iatime_packed)",
            "(long long)be64_to_cpu(lvb->lvb_ictime_packed)",
            "(long long)be64_to_cpu(lvb->lvb_imtime_packed)",
            "be32_to_cpu(lvb->lvb_iattr)"
          ],
          "line": 138
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "lvb->lvb_iattr"
          ],
          "line": 143
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be64_to_cpu",
          "args": [
            "lvb->lvb_imtime_packed"
          ],
          "line": 142
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be64_to_cpu",
          "args": [
            "lvb->lvb_ictime_packed"
          ],
          "line": 141
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be64_to_cpu",
          "args": [
            "lvb->lvb_iatime_packed"
          ],
          "line": 140
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be16_to_cpu",
          "args": [
            "lvb->lvb_inlink"
          ],
          "line": 139
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mlog",
          "args": [
            "level",
            "\"size: %llu, uid %u, gid %u, mode 0x%x\\n\"",
            "(unsigned long long)be64_to_cpu(lvb->lvb_isize)",
            "be32_to_cpu(lvb->lvb_iuid)",
            "be32_to_cpu(lvb->lvb_igid)",
            "be16_to_cpu(lvb->lvb_imode)"
          ],
          "line": 134
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be16_to_cpu",
          "args": [
            "lvb->lvb_imode"
          ],
          "line": 137
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "lvb->lvb_igid"
          ],
          "line": 136
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "lvb->lvb_iuid"
          ],
          "line": 136
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be64_to_cpu",
          "args": [
            "lvb->lvb_isize"
          ],
          "line": 135
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mlog",
          "args": [
            "level",
            "\"version: %u, clusters: %u, generation: 0x%x\\n\"",
            "lvb->lvb_version",
            "be32_to_cpu(lvb->lvb_iclusters)",
            "be32_to_cpu(lvb->lvb_igeneration)"
          ],
          "line": 131
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "lvb->lvb_igeneration"
          ],
          "line": 133
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "lvb->lvb_iclusters"
          ],
          "line": 132
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mlog",
          "args": [
            "level",
            "\"LVB information for %s (called from %s:%u):\\n\"",
            "lockres->l_name",
            "function",
            "line"
          ],
          "line": 129
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_dlm_lvb",
          "args": [
            "&lockres->l_lksb"
          ],
          "line": 127
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_dlm_lvb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/stackglue.c",
          "lines": "279-282",
          "snippet": "void *ocfs2_dlm_lvb(struct ocfs2_dlm_lksb *lksb)\n{\n\treturn active_stack->sp_ops->lock_lvb(lksb);\n}",
          "includes": [
            "#include \"stackglue.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include <linux/sysctl.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/fs.h>",
            "#include <linux/kmod.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/list.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct ocfs2_stack_plugin *active_stack;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"stackglue.h\"\n#include \"ocfs2_fs.h\"\n#include <linux/sysctl.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/fs.h>\n#include <linux/kmod.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/spinlock.h>\n#include <linux/list.h>\n\nstatic struct ocfs2_stack_plugin *active_stack;\n\nvoid *ocfs2_dlm_lvb(struct ocfs2_dlm_lksb *lksb)\n{\n\treturn active_stack->sp_ops->lock_lvb(lksb);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"stackglue.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dcache.h\"\n#include \"alloc.h\"\n#include \"ocfs2_lockingver.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/quotaops.h>\n#include <linux/time.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/pagemap.h>\n#include <linux/kthread.h>\n#include <linux/mm.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic struct ocfs2_super *ocfs2_get_dentry_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_inode_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_file_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_qinfo_osb(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_set_meta_lvb(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_dentry_post_unlock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres);\nstatic void ocfs2_set_qinfo_lvb(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_downconvert_action(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_convert_action(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_attach_action(struct ocfs2_lock_res *lockres);\nstatic int ocfs2_generic_handle_bast(struct ocfs2_lock_res *lockres, int level);\nstatic void ocfs2_schedule_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_downconvert_on_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic inline int ocfs2_highest_compat_lock_level(int level);\nstatic int ocfs2_downconvert_lock(struct ocfs2_super *osb,\n\t\t\t\t  struct ocfs2_lock_res *lockres,\n\t\t\t\t  int new_level,\n\t\t\t\t  int lvb,\n\t\t\t\t  unsigned int generation);\nstatic int ocfs2_prepare_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\t        struct ocfs2_lock_res *lockres);\nstatic int ocfs2_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_process_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *lockres);\n\nstatic void ocfs2_dump_meta_lvb_info(u64 level,\n\t\t\t\t     const char *function,\n\t\t\t\t     unsigned int line,\n\t\t\t\t     struct ocfs2_lock_res *lockres)\n{\n\tstruct ocfs2_meta_lvb *lvb = ocfs2_dlm_lvb(&lockres->l_lksb);\n\n\tmlog(level, \"LVB information for %s (called from %s:%u):\\n\",\n\t     lockres->l_name, function, line);\n\tmlog(level, \"version: %u, clusters: %u, generation: 0x%x\\n\",\n\t     lvb->lvb_version, be32_to_cpu(lvb->lvb_iclusters),\n\t     be32_to_cpu(lvb->lvb_igeneration));\n\tmlog(level, \"size: %llu, uid %u, gid %u, mode 0x%x\\n\",\n\t     (unsigned long long)be64_to_cpu(lvb->lvb_isize),\n\t     be32_to_cpu(lvb->lvb_iuid), be32_to_cpu(lvb->lvb_igid),\n\t     be16_to_cpu(lvb->lvb_imode));\n\tmlog(level, \"nlink %u, atime_packed 0x%llx, ctime_packed 0x%llx, \"\n\t     \"mtime_packed 0x%llx iattr 0x%x\\n\", be16_to_cpu(lvb->lvb_inlink),\n\t     (long long)be64_to_cpu(lvb->lvb_iatime_packed),\n\t     (long long)be64_to_cpu(lvb->lvb_ictime_packed),\n\t     (long long)be64_to_cpu(lvb->lvb_imtime_packed),\n\t     be32_to_cpu(lvb->lvb_iattr));\n}"
  }
]