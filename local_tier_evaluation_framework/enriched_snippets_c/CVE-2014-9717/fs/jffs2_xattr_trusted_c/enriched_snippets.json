[
  {
    "function_name": "ffs2_trusted_listxattr(",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jffs2/xattr_trusted.c",
    "lines": "37-48",
    "snippet": "tatic size_t jffs2_trusted_listxattr(struct dentry *dentry, char *list,\n\t\tsize_t list_size, const char *name, size_t name_len, int type)\n{\n\tsize_t retlen = XATTR_TRUSTED_PREFIX_LEN + name_len + 1;\n\n\tif (list && retlen<=list_size) {\n\t\tstrcpy(list, XATTR_TRUSTED_PREFIX);\n\t\tstrcpy(list + XATTR_TRUSTED_PREFIX_LEN, name);\n\t}\n\n\treturn retlen;\n}",
    "includes": [
      "include \"nodelist.h\"",
      "include <linux/mtd/mtd.h>\n#",
      "include <linux/xattr.h>\n#",
      "include <linux/jffs2.h>\n#",
      "include <linux/fs.h>\n#",
      "include <linux/kernel.h>\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "trcpy(",
          "args": [
            "ist + XATTR_TRUSTED_PREFIX_LEN,",
            "ame)"
          ],
          "line": 44
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trcpy(",
          "args": [
            "ist,",
            "ATTR_TRUSTED_PREFIX)"
          ],
          "line": 43
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "include \"nodelist.h\"\ninclude <linux/mtd/mtd.h>\n#\ninclude <linux/xattr.h>\n#\ninclude <linux/jffs2.h>\n#\ninclude <linux/fs.h>\n#\ninclude <linux/kernel.h>\n#\n\ntatic size_t jffs2_trusted_listxattr(struct dentry *dentry, char *list,\n\t\tsize_t list_size, const char *name, size_t name_len, int type)\n{\n\tsize_t retlen = XATTR_TRUSTED_PREFIX_LEN + name_len + 1;\n\n\tif (list && retlen<=list_size) {\n\t\tstrcpy(list, XATTR_TRUSTED_PREFIX);\n\t\tstrcpy(list + XATTR_TRUSTED_PREFIX_LEN, name);\n\t}\n\n\treturn retlen;\n}"
  },
  {
    "function_name": "ffs2_trusted_setxattr(",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jffs2/xattr_trusted.c",
    "lines": "28-35",
    "snippet": "tatic int jffs2_trusted_setxattr(struct dentry *dentry, const char *name,\n\t\tconst void *buffer, size_t size, int flags, int type)\n{\n\tif (!strcmp(name, \"\"))\n\t\treturn -EINVAL;\n\treturn do_jffs2_setxattr(dentry->d_inode, JFFS2_XPREFIX_TRUSTED,\n\t\t\t\t name, buffer, size, flags);\n}",
    "includes": [
      "include \"nodelist.h\"",
      "include <linux/mtd/mtd.h>\n#",
      "include <linux/xattr.h>\n#",
      "include <linux/jffs2.h>\n#",
      "include <linux/fs.h>\n#",
      "include <linux/kernel.h>\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "o_jffs2_setxattr(",
          "args": [
            "entry->d_inode,",
            "FFS2_XPREFIX_TRUSTED,",
            "ame,",
            "uffer,",
            "ize,",
            "lags)"
          ],
          "line": 33
        },
        "resolved": true,
        "details": {
          "function_name": "o_jffs2_setxattr(",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jffs2/xattr.c",
          "lines": "1086-1198",
          "snippet": "nt do_jffs2_setxattr(struct inode *inode, int xprefix, const char *xname,\n\t\t      const char *buffer, size_t size, int flags)\n{\n\tstruct jffs2_inode_info *f = JFFS2_INODE_INFO(inode);\n\tstruct jffs2_sb_info *c = JFFS2_SB_INFO(inode->i_sb);\n\tstruct jffs2_inode_cache *ic = f->inocache;\n\tstruct jffs2_xattr_datum *xd;\n\tstruct jffs2_xattr_ref *ref, *newref, **pref;\n\tuint32_t length, request;\n\tint rc;\n\n\trc = check_xattr_ref_inode(c, ic);\n\tif (unlikely(rc))\n\t\treturn rc;\n\n\trequest = PAD(sizeof(struct jffs2_raw_xattr) + strlen(xname) + 1 + size);\n\trc = jffs2_reserve_space(c, request, &length,\n\t\t\t\t ALLOC_NORMAL, JFFS2_SUMMARY_XATTR_SIZE);\n\tif (rc) {\n\t\tJFFS2_WARNING(\"jffs2_reserve_space()=%d, request=%u\\n\", rc, request);\n\t\treturn rc;\n\t}\n\n\t/* Find existing xattr */\n\tdown_write(&c->xattr_sem);\n retry:\n\tfor (ref=ic->xref, pref=&ic->xref; ref; pref=&ref->next, ref=ref->next) {\n\t\txd = ref->xd;\n\t\tif (xd->xprefix != xprefix)\n\t\t\tcontinue;\n\t\tif (!xd->xname) {\n\t\t\trc = load_xattr_datum(c, xd);\n\t\t\tif (unlikely(rc > 0)) {\n\t\t\t\t*pref = ref->next;\n\t\t\t\tdelete_xattr_ref(c, ref);\n\t\t\t\tgoto retry;\n\t\t\t} else if (unlikely(rc < 0))\n\t\t\t\tgoto out;\n\t\t}\n\t\tif (!strcmp(xd->xname, xname)) {\n\t\t\tif (flags & XATTR_CREATE) {\n\t\t\t\trc = -EEXIST;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tif (!buffer) {\n\t\t\t\tref->ino = ic->ino;\n\t\t\t\tref->xid = xd->xid;\n\t\t\t\tref->xseqno |= XREF_DELETE_MARKER;\n\t\t\t\trc = save_xattr_ref(c, ref);\n\t\t\t\tif (!rc) {\n\t\t\t\t\t*pref = ref->next;\n\t\t\t\t\tspin_lock(&c->erase_completion_lock);\n\t\t\t\t\tref->next = c->xref_dead_list;\n\t\t\t\t\tc->xref_dead_list = ref;\n\t\t\t\t\tspin_unlock(&c->erase_completion_lock);\n\t\t\t\t\tunrefer_xattr_datum(c, xd);\n\t\t\t\t} else {\n\t\t\t\t\tref->ic = ic;\n\t\t\t\t\tref->xd = xd;\n\t\t\t\t\tref->xseqno &= ~XREF_DELETE_MARKER;\n\t\t\t\t}\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tgoto found;\n\t\t}\n\t}\n\t/* not found */\n\tif (flags & XATTR_REPLACE) {\n\t\trc = -ENODATA;\n\t\tgoto out;\n\t}\n\tif (!buffer) {\n\t\trc = -ENODATA;\n\t\tgoto out;\n\t}\n found:\n\txd = create_xattr_datum(c, xprefix, xname, buffer, size);\n\tif (IS_ERR(xd)) {\n\t\trc = PTR_ERR(xd);\n\t\tgoto out;\n\t}\n\tup_write(&c->xattr_sem);\n\tjffs2_complete_reservation(c);\n\n\t/* create xattr_ref */\n\trequest = PAD(sizeof(struct jffs2_raw_xref));\n\trc = jffs2_reserve_space(c, request, &length,\n\t\t\t\t ALLOC_NORMAL, JFFS2_SUMMARY_XREF_SIZE);\n\tdown_write(&c->xattr_sem);\n\tif (rc) {\n\t\tJFFS2_WARNING(\"jffs2_reserve_space()=%d, request=%u\\n\", rc, request);\n\t\tunrefer_xattr_datum(c, xd);\n\t\tup_write(&c->xattr_sem);\n\t\treturn rc;\n\t}\n\tif (ref)\n\t\t*pref = ref->next;\n\tnewref = create_xattr_ref(c, ic, xd);\n\tif (IS_ERR(newref)) {\n\t\tif (ref) {\n\t\t\tref->next = ic->xref;\n\t\t\tic->xref = ref;\n\t\t}\n\t\trc = PTR_ERR(newref);\n\t\tunrefer_xattr_datum(c, xd);\n\t} else if (ref) {\n\t\tdelete_xattr_ref(c, ref);\n\t}\n out:\n\tup_write(&c->xattr_sem);\n\tjffs2_complete_reservation(c);\n\treturn rc;\n}",
          "includes": [
            "include \"nodelist.h\"\n/",
            "include <linux/mtd/mtd.h>\n#",
            "include <linux/posix_acl_xattr.h>\n#",
            "include <linux/xattr.h>\n#",
            "include <linux/jffs2.h>\n#",
            "include <linux/crc32.h>\n#",
            "include <linux/highmem.h>\n#",
            "include <linux/pagemap.h>\n#",
            "include <linux/time.h>\n#",
            "include <linux/fs.h>\n#",
            "include <linux/slab.h>\n#",
            "include <linux/kernel.h>\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"nodelist.h\"\n/\ninclude <linux/mtd/mtd.h>\n#\ninclude <linux/posix_acl_xattr.h>\n#\ninclude <linux/xattr.h>\n#\ninclude <linux/jffs2.h>\n#\ninclude <linux/crc32.h>\n#\ninclude <linux/highmem.h>\n#\ninclude <linux/pagemap.h>\n#\ninclude <linux/time.h>\n#\ninclude <linux/fs.h>\n#\ninclude <linux/slab.h>\n#\ninclude <linux/kernel.h>\n#\n\nnt do_jffs2_setxattr(struct inode *inode, int xprefix, const char *xname,\n\t\t      const char *buffer, size_t size, int flags)\n{\n\tstruct jffs2_inode_info *f = JFFS2_INODE_INFO(inode);\n\tstruct jffs2_sb_info *c = JFFS2_SB_INFO(inode->i_sb);\n\tstruct jffs2_inode_cache *ic = f->inocache;\n\tstruct jffs2_xattr_datum *xd;\n\tstruct jffs2_xattr_ref *ref, *newref, **pref;\n\tuint32_t length, request;\n\tint rc;\n\n\trc = check_xattr_ref_inode(c, ic);\n\tif (unlikely(rc))\n\t\treturn rc;\n\n\trequest = PAD(sizeof(struct jffs2_raw_xattr) + strlen(xname) + 1 + size);\n\trc = jffs2_reserve_space(c, request, &length,\n\t\t\t\t ALLOC_NORMAL, JFFS2_SUMMARY_XATTR_SIZE);\n\tif (rc) {\n\t\tJFFS2_WARNING(\"jffs2_reserve_space()=%d, request=%u\\n\", rc, request);\n\t\treturn rc;\n\t}\n\n\t/* Find existing xattr */\n\tdown_write(&c->xattr_sem);\n retry:\n\tfor (ref=ic->xref, pref=&ic->xref; ref; pref=&ref->next, ref=ref->next) {\n\t\txd = ref->xd;\n\t\tif (xd->xprefix != xprefix)\n\t\t\tcontinue;\n\t\tif (!xd->xname) {\n\t\t\trc = load_xattr_datum(c, xd);\n\t\t\tif (unlikely(rc > 0)) {\n\t\t\t\t*pref = ref->next;\n\t\t\t\tdelete_xattr_ref(c, ref);\n\t\t\t\tgoto retry;\n\t\t\t} else if (unlikely(rc < 0))\n\t\t\t\tgoto out;\n\t\t}\n\t\tif (!strcmp(xd->xname, xname)) {\n\t\t\tif (flags & XATTR_CREATE) {\n\t\t\t\trc = -EEXIST;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tif (!buffer) {\n\t\t\t\tref->ino = ic->ino;\n\t\t\t\tref->xid = xd->xid;\n\t\t\t\tref->xseqno |= XREF_DELETE_MARKER;\n\t\t\t\trc = save_xattr_ref(c, ref);\n\t\t\t\tif (!rc) {\n\t\t\t\t\t*pref = ref->next;\n\t\t\t\t\tspin_lock(&c->erase_completion_lock);\n\t\t\t\t\tref->next = c->xref_dead_list;\n\t\t\t\t\tc->xref_dead_list = ref;\n\t\t\t\t\tspin_unlock(&c->erase_completion_lock);\n\t\t\t\t\tunrefer_xattr_datum(c, xd);\n\t\t\t\t} else {\n\t\t\t\t\tref->ic = ic;\n\t\t\t\t\tref->xd = xd;\n\t\t\t\t\tref->xseqno &= ~XREF_DELETE_MARKER;\n\t\t\t\t}\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tgoto found;\n\t\t}\n\t}\n\t/* not found */\n\tif (flags & XATTR_REPLACE) {\n\t\trc = -ENODATA;\n\t\tgoto out;\n\t}\n\tif (!buffer) {\n\t\trc = -ENODATA;\n\t\tgoto out;\n\t}\n found:\n\txd = create_xattr_datum(c, xprefix, xname, buffer, size);\n\tif (IS_ERR(xd)) {\n\t\trc = PTR_ERR(xd);\n\t\tgoto out;\n\t}\n\tup_write(&c->xattr_sem);\n\tjffs2_complete_reservation(c);\n\n\t/* create xattr_ref */\n\trequest = PAD(sizeof(struct jffs2_raw_xref));\n\trc = jffs2_reserve_space(c, request, &length,\n\t\t\t\t ALLOC_NORMAL, JFFS2_SUMMARY_XREF_SIZE);\n\tdown_write(&c->xattr_sem);\n\tif (rc) {\n\t\tJFFS2_WARNING(\"jffs2_reserve_space()=%d, request=%u\\n\", rc, request);\n\t\tunrefer_xattr_datum(c, xd);\n\t\tup_write(&c->xattr_sem);\n\t\treturn rc;\n\t}\n\tif (ref)\n\t\t*pref = ref->next;\n\tnewref = create_xattr_ref(c, ic, xd);\n\tif (IS_ERR(newref)) {\n\t\tif (ref) {\n\t\t\tref->next = ic->xref;\n\t\t\tic->xref = ref;\n\t\t}\n\t\trc = PTR_ERR(newref);\n\t\tunrefer_xattr_datum(c, xd);\n\t} else if (ref) {\n\t\tdelete_xattr_ref(c, ref);\n\t}\n out:\n\tup_write(&c->xattr_sem);\n\tjffs2_complete_reservation(c);\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "trcmp(",
          "args": [
            "ame,",
            "\")"
          ],
          "line": 31
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "include \"nodelist.h\"\ninclude <linux/mtd/mtd.h>\n#\ninclude <linux/xattr.h>\n#\ninclude <linux/jffs2.h>\n#\ninclude <linux/fs.h>\n#\ninclude <linux/kernel.h>\n#\n\ntatic int jffs2_trusted_setxattr(struct dentry *dentry, const char *name,\n\t\tconst void *buffer, size_t size, int flags, int type)\n{\n\tif (!strcmp(name, \"\"))\n\t\treturn -EINVAL;\n\treturn do_jffs2_setxattr(dentry->d_inode, JFFS2_XPREFIX_TRUSTED,\n\t\t\t\t name, buffer, size, flags);\n}"
  },
  {
    "function_name": "ffs2_trusted_getxattr(",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jffs2/xattr_trusted.c",
    "lines": "19-26",
    "snippet": "tatic int jffs2_trusted_getxattr(struct dentry *dentry, const char *name,\n\t\tvoid *buffer, size_t size, int type)\n{\n\tif (!strcmp(name, \"\"))\n\t\treturn -EINVAL;\n\treturn do_jffs2_getxattr(dentry->d_inode, JFFS2_XPREFIX_TRUSTED,\n\t\t\t\t name, buffer, size);\n}",
    "includes": [
      "include \"nodelist.h\"",
      "include <linux/mtd/mtd.h>\n#",
      "include <linux/xattr.h>\n#",
      "include <linux/jffs2.h>\n#",
      "include <linux/fs.h>\n#",
      "include <linux/kernel.h>\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "o_jffs2_getxattr(",
          "args": [
            "entry->d_inode,",
            "FFS2_XPREFIX_TRUSTED,",
            "ame,",
            "uffer,",
            "ize)"
          ],
          "line": 24
        },
        "resolved": true,
        "details": {
          "function_name": "o_jffs2_getxattr(",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jffs2/xattr.c",
          "lines": "1024-1084",
          "snippet": "nt do_jffs2_getxattr(struct inode *inode, int xprefix, const char *xname,\n\t\t      char *buffer, size_t size)\n{\n\tstruct jffs2_inode_info *f = JFFS2_INODE_INFO(inode);\n\tstruct jffs2_sb_info *c = JFFS2_SB_INFO(inode->i_sb);\n\tstruct jffs2_inode_cache *ic = f->inocache;\n\tstruct jffs2_xattr_datum *xd;\n\tstruct jffs2_xattr_ref *ref, **pref;\n\tint rc, retry = 0;\n\n\trc = check_xattr_ref_inode(c, ic);\n\tif (unlikely(rc))\n\t\treturn rc;\n\n\tdown_read(&c->xattr_sem);\n retry:\n\tfor (ref=ic->xref, pref=&ic->xref; ref; pref=&ref->next, ref=ref->next) {\n\t\tBUG_ON(ref->ic!=ic);\n\n\t\txd = ref->xd;\n\t\tif (xd->xprefix != xprefix)\n\t\t\tcontinue;\n\t\tif (!xd->xname) {\n\t\t\t/* xdatum is unchached */\n\t\t\tif (!retry) {\n\t\t\t\tretry = 1;\n\t\t\t\tup_read(&c->xattr_sem);\n\t\t\t\tdown_write(&c->xattr_sem);\n\t\t\t\tgoto retry;\n\t\t\t} else {\n\t\t\t\trc = load_xattr_datum(c, xd);\n\t\t\t\tif (unlikely(rc > 0)) {\n\t\t\t\t\t*pref = ref->next;\n\t\t\t\t\tdelete_xattr_ref(c, ref);\n\t\t\t\t\tgoto retry;\n\t\t\t\t} else if (unlikely(rc < 0)) {\n\t\t\t\t\tgoto out;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (!strcmp(xname, xd->xname)) {\n\t\t\trc = xd->value_len;\n\t\t\tif (buffer) {\n\t\t\t\tif (size < rc) {\n\t\t\t\t\trc = -ERANGE;\n\t\t\t\t} else {\n\t\t\t\t\tmemcpy(buffer, xd->xvalue, rc);\n\t\t\t\t}\n\t\t\t}\n\t\t\tgoto out;\n\t\t}\n\t}\n\trc = -ENODATA;\n out:\n\tif (!retry) {\n\t\tup_read(&c->xattr_sem);\n\t} else {\n\t\tup_write(&c->xattr_sem);\n\t}\n\treturn rc;\n}",
          "includes": [
            "include \"nodelist.h\"\n/",
            "include <linux/mtd/mtd.h>\n#",
            "include <linux/posix_acl_xattr.h>\n#",
            "include <linux/xattr.h>\n#",
            "include <linux/jffs2.h>\n#",
            "include <linux/crc32.h>\n#",
            "include <linux/highmem.h>\n#",
            "include <linux/pagemap.h>\n#",
            "include <linux/time.h>\n#",
            "include <linux/fs.h>\n#",
            "include <linux/slab.h>\n#",
            "include <linux/kernel.h>\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"nodelist.h\"\n/\ninclude <linux/mtd/mtd.h>\n#\ninclude <linux/posix_acl_xattr.h>\n#\ninclude <linux/xattr.h>\n#\ninclude <linux/jffs2.h>\n#\ninclude <linux/crc32.h>\n#\ninclude <linux/highmem.h>\n#\ninclude <linux/pagemap.h>\n#\ninclude <linux/time.h>\n#\ninclude <linux/fs.h>\n#\ninclude <linux/slab.h>\n#\ninclude <linux/kernel.h>\n#\n\nnt do_jffs2_getxattr(struct inode *inode, int xprefix, const char *xname,\n\t\t      char *buffer, size_t size)\n{\n\tstruct jffs2_inode_info *f = JFFS2_INODE_INFO(inode);\n\tstruct jffs2_sb_info *c = JFFS2_SB_INFO(inode->i_sb);\n\tstruct jffs2_inode_cache *ic = f->inocache;\n\tstruct jffs2_xattr_datum *xd;\n\tstruct jffs2_xattr_ref *ref, **pref;\n\tint rc, retry = 0;\n\n\trc = check_xattr_ref_inode(c, ic);\n\tif (unlikely(rc))\n\t\treturn rc;\n\n\tdown_read(&c->xattr_sem);\n retry:\n\tfor (ref=ic->xref, pref=&ic->xref; ref; pref=&ref->next, ref=ref->next) {\n\t\tBUG_ON(ref->ic!=ic);\n\n\t\txd = ref->xd;\n\t\tif (xd->xprefix != xprefix)\n\t\t\tcontinue;\n\t\tif (!xd->xname) {\n\t\t\t/* xdatum is unchached */\n\t\t\tif (!retry) {\n\t\t\t\tretry = 1;\n\t\t\t\tup_read(&c->xattr_sem);\n\t\t\t\tdown_write(&c->xattr_sem);\n\t\t\t\tgoto retry;\n\t\t\t} else {\n\t\t\t\trc = load_xattr_datum(c, xd);\n\t\t\t\tif (unlikely(rc > 0)) {\n\t\t\t\t\t*pref = ref->next;\n\t\t\t\t\tdelete_xattr_ref(c, ref);\n\t\t\t\t\tgoto retry;\n\t\t\t\t} else if (unlikely(rc < 0)) {\n\t\t\t\t\tgoto out;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (!strcmp(xname, xd->xname)) {\n\t\t\trc = xd->value_len;\n\t\t\tif (buffer) {\n\t\t\t\tif (size < rc) {\n\t\t\t\t\trc = -ERANGE;\n\t\t\t\t} else {\n\t\t\t\t\tmemcpy(buffer, xd->xvalue, rc);\n\t\t\t\t}\n\t\t\t}\n\t\t\tgoto out;\n\t\t}\n\t}\n\trc = -ENODATA;\n out:\n\tif (!retry) {\n\t\tup_read(&c->xattr_sem);\n\t} else {\n\t\tup_write(&c->xattr_sem);\n\t}\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "trcmp(",
          "args": [
            "ame,",
            "\")"
          ],
          "line": 22
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "include \"nodelist.h\"\ninclude <linux/mtd/mtd.h>\n#\ninclude <linux/xattr.h>\n#\ninclude <linux/jffs2.h>\n#\ninclude <linux/fs.h>\n#\ninclude <linux/kernel.h>\n#\n\ntatic int jffs2_trusted_getxattr(struct dentry *dentry, const char *name,\n\t\tvoid *buffer, size_t size, int type)\n{\n\tif (!strcmp(name, \"\"))\n\t\treturn -EINVAL;\n\treturn do_jffs2_getxattr(dentry->d_inode, JFFS2_XPREFIX_TRUSTED,\n\t\t\t\t name, buffer, size);\n}"
  }
]