[
  {
    "function_name": "udf_get_filelongad",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/udf/directory.c",
    "lines": "221-241",
    "snippet": "struct long_ad *udf_get_filelongad(uint8_t *ptr, int maxoffset, uint32_t *offset, int inc)\n{\n\tstruct long_ad *la;\n\n\tif ((!ptr) || (!offset)) {\n\t\tpr_err(\"%s: invalidparms\\n\", __func__);\n\t\treturn NULL;\n\t}\n\n\tif ((*offset + sizeof(struct long_ad)) > maxoffset)\n\t\treturn NULL;\n\telse {\n\t\tla = (struct long_ad *)ptr;\n\t\tif (la->extLength == 0)\n\t\t\treturn NULL;\n\t}\n\n\tif (inc)\n\t\t*offset += sizeof(struct long_ad);\n\treturn la;\n}",
    "includes": [
      "#include <linux/buffer_head.h>",
      "#include <linux/string.h>",
      "#include <linux/fs.h>",
      "#include \"udf_i.h\"",
      "#include \"udfdecl.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"%s: invalidparms\\n\"",
            "__func__"
          ],
          "line": 226
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/fs.h>\n#include \"udf_i.h\"\n#include \"udfdecl.h\"\n\nstruct long_ad *udf_get_filelongad(uint8_t *ptr, int maxoffset, uint32_t *offset, int inc)\n{\n\tstruct long_ad *la;\n\n\tif ((!ptr) || (!offset)) {\n\t\tpr_err(\"%s: invalidparms\\n\", __func__);\n\t\treturn NULL;\n\t}\n\n\tif ((*offset + sizeof(struct long_ad)) > maxoffset)\n\t\treturn NULL;\n\telse {\n\t\tla = (struct long_ad *)ptr;\n\t\tif (la->extLength == 0)\n\t\t\treturn NULL;\n\t}\n\n\tif (inc)\n\t\t*offset += sizeof(struct long_ad);\n\treturn la;\n}"
  },
  {
    "function_name": "udf_get_fileshortad",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/udf/directory.c",
    "lines": "198-219",
    "snippet": "struct short_ad *udf_get_fileshortad(uint8_t *ptr, int maxoffset, uint32_t *offset,\n\t\t\t      int inc)\n{\n\tstruct short_ad *sa;\n\n\tif ((!ptr) || (!offset)) {\n\t\tpr_err(\"%s: invalidparms\\n\", __func__);\n\t\treturn NULL;\n\t}\n\n\tif ((*offset + sizeof(struct short_ad)) > maxoffset)\n\t\treturn NULL;\n\telse {\n\t\tsa = (struct short_ad *)ptr;\n\t\tif (sa->extLength == 0)\n\t\t\treturn NULL;\n\t}\n\n\tif (inc)\n\t\t*offset += sizeof(struct short_ad);\n\treturn sa;\n}",
    "includes": [
      "#include <linux/buffer_head.h>",
      "#include <linux/string.h>",
      "#include <linux/fs.h>",
      "#include \"udf_i.h\"",
      "#include \"udfdecl.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"%s: invalidparms\\n\"",
            "__func__"
          ],
          "line": 204
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/fs.h>\n#include \"udf_i.h\"\n#include \"udfdecl.h\"\n\nstruct short_ad *udf_get_fileshortad(uint8_t *ptr, int maxoffset, uint32_t *offset,\n\t\t\t      int inc)\n{\n\tstruct short_ad *sa;\n\n\tif ((!ptr) || (!offset)) {\n\t\tpr_err(\"%s: invalidparms\\n\", __func__);\n\t\treturn NULL;\n\t}\n\n\tif ((*offset + sizeof(struct short_ad)) > maxoffset)\n\t\treturn NULL;\n\telse {\n\t\tsa = (struct short_ad *)ptr;\n\t\tif (sa->extLength == 0)\n\t\t\treturn NULL;\n\t}\n\n\tif (inc)\n\t\t*offset += sizeof(struct short_ad);\n\treturn sa;\n}"
  },
  {
    "function_name": "udf_get_fileident",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/udf/directory.c",
    "lines": "157-196",
    "snippet": "struct fileIdentDesc *udf_get_fileident(void *buffer, int bufsize, int *offset)\n{\n\tstruct fileIdentDesc *fi;\n\tint lengthThisIdent;\n\tuint8_t *ptr;\n\tint padlen;\n\n\tif ((!buffer) || (!offset)) {\n\t\tudf_debug(\"invalidparms, buffer=%p, offset=%p\\n\",\n\t\t\t  buffer, offset);\n\t\treturn NULL;\n\t}\n\n\tptr = buffer;\n\n\tif ((*offset > 0) && (*offset < bufsize))\n\t\tptr += *offset;\n\tfi = (struct fileIdentDesc *)ptr;\n\tif (fi->descTag.tagIdent != cpu_to_le16(TAG_IDENT_FID)) {\n\t\tudf_debug(\"0x%x != TAG_IDENT_FID\\n\",\n\t\t\t  le16_to_cpu(fi->descTag.tagIdent));\n\t\tudf_debug(\"offset: %u sizeof: %lu bufsize: %u\\n\",\n\t\t\t  *offset, (unsigned long)sizeof(struct fileIdentDesc),\n\t\t\t  bufsize);\n\t\treturn NULL;\n\t}\n\tif ((*offset + sizeof(struct fileIdentDesc)) > bufsize)\n\t\tlengthThisIdent = sizeof(struct fileIdentDesc);\n\telse\n\t\tlengthThisIdent = sizeof(struct fileIdentDesc) +\n\t\t\tfi->lengthFileIdent + le16_to_cpu(fi->lengthOfImpUse);\n\n\t/* we need to figure padding, too! */\n\tpadlen = lengthThisIdent % UDF_NAME_PAD;\n\tif (padlen)\n\t\tlengthThisIdent += (UDF_NAME_PAD - padlen);\n\t*offset = *offset + lengthThisIdent;\n\n\treturn fi;\n}",
    "includes": [
      "#include <linux/buffer_head.h>",
      "#include <linux/string.h>",
      "#include <linux/fs.h>",
      "#include \"udf_i.h\"",
      "#include \"udfdecl.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "le16_to_cpu",
          "args": [
            "fi->lengthOfImpUse"
          ],
          "line": 187
        },
        "resolved": true,
        "details": {
          "function_name": "sle16_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "48-51",
          "snippet": "static inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "udf_debug",
          "args": [
            "\"offset: %u sizeof: %lu bufsize: %u\\n\"",
            "*offset",
            "(unsigned long)sizeof(struct fileIdentDesc)",
            "bufsize"
          ],
          "line": 178
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "udf_debug",
          "args": [
            "\"0x%x != TAG_IDENT_FID\\n\"",
            "le16_to_cpu(fi->descTag.tagIdent)"
          ],
          "line": 176
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "TAG_IDENT_FID"
          ],
          "line": 175
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "udf_debug",
          "args": [
            "\"invalidparms, buffer=%p, offset=%p\\n\"",
            "buffer",
            "offset"
          ],
          "line": 165
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/fs.h>\n#include \"udf_i.h\"\n#include \"udfdecl.h\"\n\nstruct fileIdentDesc *udf_get_fileident(void *buffer, int bufsize, int *offset)\n{\n\tstruct fileIdentDesc *fi;\n\tint lengthThisIdent;\n\tuint8_t *ptr;\n\tint padlen;\n\n\tif ((!buffer) || (!offset)) {\n\t\tudf_debug(\"invalidparms, buffer=%p, offset=%p\\n\",\n\t\t\t  buffer, offset);\n\t\treturn NULL;\n\t}\n\n\tptr = buffer;\n\n\tif ((*offset > 0) && (*offset < bufsize))\n\t\tptr += *offset;\n\tfi = (struct fileIdentDesc *)ptr;\n\tif (fi->descTag.tagIdent != cpu_to_le16(TAG_IDENT_FID)) {\n\t\tudf_debug(\"0x%x != TAG_IDENT_FID\\n\",\n\t\t\t  le16_to_cpu(fi->descTag.tagIdent));\n\t\tudf_debug(\"offset: %u sizeof: %lu bufsize: %u\\n\",\n\t\t\t  *offset, (unsigned long)sizeof(struct fileIdentDesc),\n\t\t\t  bufsize);\n\t\treturn NULL;\n\t}\n\tif ((*offset + sizeof(struct fileIdentDesc)) > bufsize)\n\t\tlengthThisIdent = sizeof(struct fileIdentDesc);\n\telse\n\t\tlengthThisIdent = sizeof(struct fileIdentDesc) +\n\t\t\tfi->lengthFileIdent + le16_to_cpu(fi->lengthOfImpUse);\n\n\t/* we need to figure padding, too! */\n\tpadlen = lengthThisIdent % UDF_NAME_PAD;\n\tif (padlen)\n\t\tlengthThisIdent += (UDF_NAME_PAD - padlen);\n\t*offset = *offset + lengthThisIdent;\n\n\treturn fi;\n}"
  },
  {
    "function_name": "udf_fileident_read",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/udf/directory.c",
    "lines": "21-155",
    "snippet": "struct fileIdentDesc *udf_fileident_read(struct inode *dir, loff_t *nf_pos,\n\t\t\t\t\t struct udf_fileident_bh *fibh,\n\t\t\t\t\t struct fileIdentDesc *cfi,\n\t\t\t\t\t struct extent_position *epos,\n\t\t\t\t\t struct kernel_lb_addr *eloc, uint32_t *elen,\n\t\t\t\t\t sector_t *offset)\n{\n\tstruct fileIdentDesc *fi;\n\tint i, num, block;\n\tstruct buffer_head *tmp, *bha[16];\n\tstruct udf_inode_info *iinfo = UDF_I(dir);\n\n\tfibh->soffset = fibh->eoffset;\n\n\tif (iinfo->i_alloc_type == ICBTAG_FLAG_AD_IN_ICB) {\n\t\tfi = udf_get_fileident(iinfo->i_ext.i_data -\n\t\t\t\t       (iinfo->i_efe ?\n\t\t\t\t\tsizeof(struct extendedFileEntry) :\n\t\t\t\t\tsizeof(struct fileEntry)),\n\t\t\t\t       dir->i_sb->s_blocksize,\n\t\t\t\t       &(fibh->eoffset));\n\t\tif (!fi)\n\t\t\treturn NULL;\n\n\t\t*nf_pos += fibh->eoffset - fibh->soffset;\n\n\t\tmemcpy((uint8_t *)cfi, (uint8_t *)fi,\n\t\t       sizeof(struct fileIdentDesc));\n\n\t\treturn fi;\n\t}\n\n\tif (fibh->eoffset == dir->i_sb->s_blocksize) {\n\t\tint lextoffset = epos->offset;\n\t\tunsigned char blocksize_bits = dir->i_sb->s_blocksize_bits;\n\n\t\tif (udf_next_aext(dir, epos, eloc, elen, 1) !=\n\t\t    (EXT_RECORDED_ALLOCATED >> 30))\n\t\t\treturn NULL;\n\n\t\tblock = udf_get_lb_pblock(dir->i_sb, eloc, *offset);\n\n\t\t(*offset)++;\n\n\t\tif ((*offset << blocksize_bits) >= *elen)\n\t\t\t*offset = 0;\n\t\telse\n\t\t\tepos->offset = lextoffset;\n\n\t\tbrelse(fibh->sbh);\n\t\tfibh->sbh = fibh->ebh = udf_tread(dir->i_sb, block);\n\t\tif (!fibh->sbh)\n\t\t\treturn NULL;\n\t\tfibh->soffset = fibh->eoffset = 0;\n\n\t\tif (!(*offset & ((16 >> (blocksize_bits - 9)) - 1))) {\n\t\t\ti = 16 >> (blocksize_bits - 9);\n\t\t\tif (i + *offset > (*elen >> blocksize_bits))\n\t\t\t\ti = (*elen >> blocksize_bits)-*offset;\n\t\t\tfor (num = 0; i > 0; i--) {\n\t\t\t\tblock = udf_get_lb_pblock(dir->i_sb, eloc,\n\t\t\t\t\t\t\t  *offset + i);\n\t\t\t\ttmp = udf_tgetblk(dir->i_sb, block);\n\t\t\t\tif (tmp && !buffer_uptodate(tmp) &&\n\t\t\t\t\t\t!buffer_locked(tmp))\n\t\t\t\t\tbha[num++] = tmp;\n\t\t\t\telse\n\t\t\t\t\tbrelse(tmp);\n\t\t\t}\n\t\t\tif (num) {\n\t\t\t\tll_rw_block(READA, num, bha);\n\t\t\t\tfor (i = 0; i < num; i++)\n\t\t\t\t\tbrelse(bha[i]);\n\t\t\t}\n\t\t}\n\t} else if (fibh->sbh != fibh->ebh) {\n\t\tbrelse(fibh->sbh);\n\t\tfibh->sbh = fibh->ebh;\n\t}\n\n\tfi = udf_get_fileident(fibh->sbh->b_data, dir->i_sb->s_blocksize,\n\t\t\t       &(fibh->eoffset));\n\n\tif (!fi)\n\t\treturn NULL;\n\n\t*nf_pos += fibh->eoffset - fibh->soffset;\n\n\tif (fibh->eoffset <= dir->i_sb->s_blocksize) {\n\t\tmemcpy((uint8_t *)cfi, (uint8_t *)fi,\n\t\t       sizeof(struct fileIdentDesc));\n\t} else if (fibh->eoffset > dir->i_sb->s_blocksize) {\n\t\tint lextoffset = epos->offset;\n\n\t\tif (udf_next_aext(dir, epos, eloc, elen, 1) !=\n\t\t    (EXT_RECORDED_ALLOCATED >> 30))\n\t\t\treturn NULL;\n\n\t\tblock = udf_get_lb_pblock(dir->i_sb, eloc, *offset);\n\n\t\t(*offset)++;\n\n\t\tif ((*offset << dir->i_sb->s_blocksize_bits) >= *elen)\n\t\t\t*offset = 0;\n\t\telse\n\t\t\tepos->offset = lextoffset;\n\n\t\tfibh->soffset -= dir->i_sb->s_blocksize;\n\t\tfibh->eoffset -= dir->i_sb->s_blocksize;\n\n\t\tfibh->ebh = udf_tread(dir->i_sb, block);\n\t\tif (!fibh->ebh)\n\t\t\treturn NULL;\n\n\t\tif (sizeof(struct fileIdentDesc) > -fibh->soffset) {\n\t\t\tint fi_len;\n\n\t\t\tmemcpy((uint8_t *)cfi, (uint8_t *)fi, -fibh->soffset);\n\t\t\tmemcpy((uint8_t *)cfi - fibh->soffset,\n\t\t\t       fibh->ebh->b_data,\n\t\t\t       sizeof(struct fileIdentDesc) + fibh->soffset);\n\n\t\t\tfi_len = (sizeof(struct fileIdentDesc) +\n\t\t\t\t  cfi->lengthFileIdent +\n\t\t\t\t  le16_to_cpu(cfi->lengthOfImpUse) + 3) & ~3;\n\n\t\t\t*nf_pos += fi_len - (fibh->eoffset - fibh->soffset);\n\t\t\tfibh->eoffset = fibh->soffset + fi_len;\n\t\t} else {\n\t\t\tmemcpy((uint8_t *)cfi, (uint8_t *)fi,\n\t\t\t       sizeof(struct fileIdentDesc));\n\t\t}\n\t}\n\treturn fi;\n}",
    "includes": [
      "#include <linux/buffer_head.h>",
      "#include <linux/string.h>",
      "#include <linux/fs.h>",
      "#include \"udf_i.h\"",
      "#include \"udfdecl.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "(uint8_t *)cfi",
            "(uint8_t *)fi",
            "sizeof(struct fileIdentDesc)"
          ],
          "line": 150
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le16_to_cpu",
          "args": [
            "cfi->lengthOfImpUse"
          ],
          "line": 145
        },
        "resolved": true,
        "details": {
          "function_name": "sle16_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "48-51",
          "snippet": "static inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "(uint8_t *)cfi - fibh->soffset",
            "fibh->ebh->b_data",
            "sizeof(struct fileIdentDesc) + fibh->soffset"
          ],
          "line": 139
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "(uint8_t *)cfi",
            "(uint8_t *)fi",
            "-fibh->soffset"
          ],
          "line": 138
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "udf_tread",
          "args": [
            "dir->i_sb",
            "block"
          ],
          "line": 131
        },
        "resolved": true,
        "details": {
          "function_name": "udf_tread",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/udf/misc.c",
          "lines": "40-46",
          "snippet": "struct buffer_head *udf_tread(struct super_block *sb, int block)\n{\n\tif (UDF_QUERY_FLAG(sb, UDF_FLAG_VARCONV))\n\t\treturn sb_bread(sb, udf_fixed_to_variable(block));\n\telse\n\t\treturn sb_bread(sb, block);\n}",
          "includes": [
            "#include \"udf_sb.h\"",
            "#include \"udf_i.h\"",
            "#include <linux/crc-itu-t.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include <linux/fs.h>",
            "#include \"udfdecl.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"udf_sb.h\"\n#include \"udf_i.h\"\n#include <linux/crc-itu-t.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/fs.h>\n#include \"udfdecl.h\"\n\nstruct buffer_head *udf_tread(struct super_block *sb, int block)\n{\n\tif (UDF_QUERY_FLAG(sb, UDF_FLAG_VARCONV))\n\t\treturn sb_bread(sb, udf_fixed_to_variable(block));\n\telse\n\t\treturn sb_bread(sb, block);\n}"
        }
      },
      {
        "call_info": {
          "callee": "udf_get_lb_pblock",
          "args": [
            "dir->i_sb",
            "eloc",
            "*offset"
          ],
          "line": 119
        },
        "resolved": true,
        "details": {
          "function_name": "udf_get_lb_pblock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/udf/udfdecl.h",
          "lines": "205-211",
          "snippet": "static inline uint32_t\nudf_get_lb_pblock(struct super_block *sb, struct kernel_lb_addr *loc,\n\t\t  uint32_t offset)\n{\n\treturn udf_get_pblock(sb, loc->logicalBlockNum,\n\t\t\tloc->partitionReferenceNum, offset);\n}",
          "includes": [
            "#include \"udf_i.h\"",
            "#include \"udfend.h\"",
            "#include \"udf_sb.h\"",
            "#include <linux/udf_fs_i.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include \"osta_udf.h\"",
            "#include \"ecma_167.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"udf_i.h\"\n#include \"udfend.h\"\n#include \"udf_sb.h\"\n#include <linux/udf_fs_i.h>\n#include <linux/buffer_head.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include \"osta_udf.h\"\n#include \"ecma_167.h\"\n\nstatic inline uint32_t\nudf_get_lb_pblock(struct super_block *sb, struct kernel_lb_addr *loc,\n\t\t  uint32_t offset)\n{\n\treturn udf_get_pblock(sb, loc->logicalBlockNum,\n\t\t\tloc->partitionReferenceNum, offset);\n}"
        }
      },
      {
        "call_info": {
          "callee": "udf_next_aext",
          "args": [
            "dir",
            "epos",
            "eloc",
            "elen",
            "1"
          ],
          "line": 115
        },
        "resolved": true,
        "details": {
          "function_name": "udf_next_aext",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/udf/inode.c",
          "lines": "2057-2077",
          "snippet": "int8_t udf_next_aext(struct inode *inode, struct extent_position *epos,\n\t\t     struct kernel_lb_addr *eloc, uint32_t *elen, int inc)\n{\n\tint8_t etype;\n\n\twhile ((etype = udf_current_aext(inode, epos, eloc, elen, inc)) ==\n\t       (EXT_NEXT_EXTENT_ALLOCDECS >> 30)) {\n\t\tint block;\n\t\tepos->block = *eloc;\n\t\tepos->offset = sizeof(struct allocExtDesc);\n\t\tbrelse(epos->bh);\n\t\tblock = udf_get_lb_pblock(inode->i_sb, &epos->block, 0);\n\t\tepos->bh = udf_tread(inode->i_sb, block);\n\t\tif (!epos->bh) {\n\t\t\tudf_debug(\"reading block %d failed!\\n\", block);\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\treturn etype;\n}",
          "includes": [
            "#include \"udf_sb.h\"",
            "#include \"udf_i.h\"",
            "#include <linux/aio.h>",
            "#include <linux/mpage.h>",
            "#include <linux/crc-itu-t.h>",
            "#include <linux/slab.h>",
            "#include <linux/writeback.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include \"udfdecl.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int udf_update_inode(struct inode *, int);",
            "static int udf_sync_inode(struct inode *inode);",
            "static int8_t udf_insert_aext(struct inode *, struct extent_position,\n\t\t\t      struct kernel_lb_addr, uint32_t);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"udf_sb.h\"\n#include \"udf_i.h\"\n#include <linux/aio.h>\n#include <linux/mpage.h>\n#include <linux/crc-itu-t.h>\n#include <linux/slab.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include \"udfdecl.h\"\n\nstatic int udf_update_inode(struct inode *, int);\nstatic int udf_sync_inode(struct inode *inode);\nstatic int8_t udf_insert_aext(struct inode *, struct extent_position,\n\t\t\t      struct kernel_lb_addr, uint32_t);\n\nint8_t udf_next_aext(struct inode *inode, struct extent_position *epos,\n\t\t     struct kernel_lb_addr *eloc, uint32_t *elen, int inc)\n{\n\tint8_t etype;\n\n\twhile ((etype = udf_current_aext(inode, epos, eloc, elen, inc)) ==\n\t       (EXT_NEXT_EXTENT_ALLOCDECS >> 30)) {\n\t\tint block;\n\t\tepos->block = *eloc;\n\t\tepos->offset = sizeof(struct allocExtDesc);\n\t\tbrelse(epos->bh);\n\t\tblock = udf_get_lb_pblock(inode->i_sb, &epos->block, 0);\n\t\tepos->bh = udf_tread(inode->i_sb, block);\n\t\tif (!epos->bh) {\n\t\t\tudf_debug(\"reading block %d failed!\\n\", block);\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\treturn etype;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "(uint8_t *)cfi",
            "(uint8_t *)fi",
            "sizeof(struct fileIdentDesc)"
          ],
          "line": 110
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "udf_get_fileident",
          "args": [
            "fibh->sbh->b_data",
            "dir->i_sb->s_blocksize",
            "&(fibh->eoffset)"
          ],
          "line": 101
        },
        "resolved": true,
        "details": {
          "function_name": "udf_get_fileident",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/udf/directory.c",
          "lines": "157-196",
          "snippet": "struct fileIdentDesc *udf_get_fileident(void *buffer, int bufsize, int *offset)\n{\n\tstruct fileIdentDesc *fi;\n\tint lengthThisIdent;\n\tuint8_t *ptr;\n\tint padlen;\n\n\tif ((!buffer) || (!offset)) {\n\t\tudf_debug(\"invalidparms, buffer=%p, offset=%p\\n\",\n\t\t\t  buffer, offset);\n\t\treturn NULL;\n\t}\n\n\tptr = buffer;\n\n\tif ((*offset > 0) && (*offset < bufsize))\n\t\tptr += *offset;\n\tfi = (struct fileIdentDesc *)ptr;\n\tif (fi->descTag.tagIdent != cpu_to_le16(TAG_IDENT_FID)) {\n\t\tudf_debug(\"0x%x != TAG_IDENT_FID\\n\",\n\t\t\t  le16_to_cpu(fi->descTag.tagIdent));\n\t\tudf_debug(\"offset: %u sizeof: %lu bufsize: %u\\n\",\n\t\t\t  *offset, (unsigned long)sizeof(struct fileIdentDesc),\n\t\t\t  bufsize);\n\t\treturn NULL;\n\t}\n\tif ((*offset + sizeof(struct fileIdentDesc)) > bufsize)\n\t\tlengthThisIdent = sizeof(struct fileIdentDesc);\n\telse\n\t\tlengthThisIdent = sizeof(struct fileIdentDesc) +\n\t\t\tfi->lengthFileIdent + le16_to_cpu(fi->lengthOfImpUse);\n\n\t/* we need to figure padding, too! */\n\tpadlen = lengthThisIdent % UDF_NAME_PAD;\n\tif (padlen)\n\t\tlengthThisIdent += (UDF_NAME_PAD - padlen);\n\t*offset = *offset + lengthThisIdent;\n\n\treturn fi;\n}",
          "includes": [
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include <linux/fs.h>",
            "#include \"udf_i.h\"",
            "#include \"udfdecl.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/fs.h>\n#include \"udf_i.h\"\n#include \"udfdecl.h\"\n\nstruct fileIdentDesc *udf_get_fileident(void *buffer, int bufsize, int *offset)\n{\n\tstruct fileIdentDesc *fi;\n\tint lengthThisIdent;\n\tuint8_t *ptr;\n\tint padlen;\n\n\tif ((!buffer) || (!offset)) {\n\t\tudf_debug(\"invalidparms, buffer=%p, offset=%p\\n\",\n\t\t\t  buffer, offset);\n\t\treturn NULL;\n\t}\n\n\tptr = buffer;\n\n\tif ((*offset > 0) && (*offset < bufsize))\n\t\tptr += *offset;\n\tfi = (struct fileIdentDesc *)ptr;\n\tif (fi->descTag.tagIdent != cpu_to_le16(TAG_IDENT_FID)) {\n\t\tudf_debug(\"0x%x != TAG_IDENT_FID\\n\",\n\t\t\t  le16_to_cpu(fi->descTag.tagIdent));\n\t\tudf_debug(\"offset: %u sizeof: %lu bufsize: %u\\n\",\n\t\t\t  *offset, (unsigned long)sizeof(struct fileIdentDesc),\n\t\t\t  bufsize);\n\t\treturn NULL;\n\t}\n\tif ((*offset + sizeof(struct fileIdentDesc)) > bufsize)\n\t\tlengthThisIdent = sizeof(struct fileIdentDesc);\n\telse\n\t\tlengthThisIdent = sizeof(struct fileIdentDesc) +\n\t\t\tfi->lengthFileIdent + le16_to_cpu(fi->lengthOfImpUse);\n\n\t/* we need to figure padding, too! */\n\tpadlen = lengthThisIdent % UDF_NAME_PAD;\n\tif (padlen)\n\t\tlengthThisIdent += (UDF_NAME_PAD - padlen);\n\t*offset = *offset + lengthThisIdent;\n\n\treturn fi;\n}"
        }
      },
      {
        "call_info": {
          "callee": "brelse",
          "args": [
            "fibh->sbh"
          ],
          "line": 97
        },
        "resolved": true,
        "details": {
          "function_name": "__brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1177-1184",
          "snippet": "void __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "ll_rw_block",
          "args": [
            "READA",
            "num",
            "bha"
          ],
          "line": 91
        },
        "resolved": true,
        "details": {
          "function_name": "ll_rw_block",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "3086-3112",
          "snippet": "void ll_rw_block(int rw, int nr, struct buffer_head *bhs[])\n{\n\tint i;\n\n\tfor (i = 0; i < nr; i++) {\n\t\tstruct buffer_head *bh = bhs[i];\n\n\t\tif (!trylock_buffer(bh))\n\t\t\tcontinue;\n\t\tif (rw == WRITE) {\n\t\t\tif (test_clear_buffer_dirty(bh)) {\n\t\t\t\tbh->b_end_io = end_buffer_write_sync;\n\t\t\t\tget_bh(bh);\n\t\t\t\tsubmit_bh(WRITE, bh);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t} else {\n\t\t\tif (!buffer_uptodate(bh)) {\n\t\t\t\tbh->b_end_io = end_buffer_read_sync;\n\t\t\t\tget_bh(bh);\n\t\t\t\tsubmit_bh(rw, bh);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\t\tunlock_buffer(bh);\n\t}\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid ll_rw_block(int rw, int nr, struct buffer_head *bhs[])\n{\n\tint i;\n\n\tfor (i = 0; i < nr; i++) {\n\t\tstruct buffer_head *bh = bhs[i];\n\n\t\tif (!trylock_buffer(bh))\n\t\t\tcontinue;\n\t\tif (rw == WRITE) {\n\t\t\tif (test_clear_buffer_dirty(bh)) {\n\t\t\t\tbh->b_end_io = end_buffer_write_sync;\n\t\t\t\tget_bh(bh);\n\t\t\t\tsubmit_bh(WRITE, bh);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t} else {\n\t\t\tif (!buffer_uptodate(bh)) {\n\t\t\t\tbh->b_end_io = end_buffer_read_sync;\n\t\t\t\tget_bh(bh);\n\t\t\t\tsubmit_bh(rw, bh);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\t\tunlock_buffer(bh);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "buffer_locked",
          "args": [
            "tmp"
          ],
          "line": 85
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "buffer_uptodate",
          "args": [
            "tmp"
          ],
          "line": 84
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_set_buffer_uptodate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/disk-io.c",
          "lines": "3758-3761",
          "snippet": "int btrfs_set_buffer_uptodate(struct extent_buffer *buf)\n{\n\treturn set_extent_buffer_uptodate(buf);\n}",
          "includes": [
            "#include <asm/cpufeature.h>",
            "#include \"qgroup.h\"",
            "#include \"sysfs.h\"",
            "#include \"raid56.h\"",
            "#include \"dev-replace.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"inode-map.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"tree-log.h\"",
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"hash.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/uuid.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/migrate.h>",
            "#include <linux/slab.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/writeback.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/swap.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/cpufeature.h>\n#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"raid56.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <asm/unaligned.h>\n#include <linux/semaphore.h>\n#include <linux/uuid.h>\n#include <linux/ratelimit.h>\n#include <linux/migrate.h>\n#include <linux/slab.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/writeback.h>\n#include <linux/radix-tree.h>\n#include <linux/swap.h>\n#include <linux/scatterlist.h>\n#include <linux/blkdev.h>\n#include <linux/fs.h>\n\nint btrfs_set_buffer_uptodate(struct extent_buffer *buf)\n{\n\treturn set_extent_buffer_uptodate(buf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "udf_tgetblk",
          "args": [
            "dir->i_sb",
            "block"
          ],
          "line": 83
        },
        "resolved": true,
        "details": {
          "function_name": "udf_tgetblk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/udf/misc.c",
          "lines": "32-38",
          "snippet": "struct buffer_head *udf_tgetblk(struct super_block *sb, int block)\n{\n\tif (UDF_QUERY_FLAG(sb, UDF_FLAG_VARCONV))\n\t\treturn sb_getblk(sb, udf_fixed_to_variable(block));\n\telse\n\t\treturn sb_getblk(sb, block);\n}",
          "includes": [
            "#include \"udf_sb.h\"",
            "#include \"udf_i.h\"",
            "#include <linux/crc-itu-t.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include <linux/fs.h>",
            "#include \"udfdecl.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"udf_sb.h\"\n#include \"udf_i.h\"\n#include <linux/crc-itu-t.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/fs.h>\n#include \"udfdecl.h\"\n\nstruct buffer_head *udf_tgetblk(struct super_block *sb, int block)\n{\n\tif (UDF_QUERY_FLAG(sb, UDF_FLAG_VARCONV))\n\t\treturn sb_getblk(sb, udf_fixed_to_variable(block));\n\telse\n\t\treturn sb_getblk(sb, block);\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "(uint8_t *)cfi",
            "(uint8_t *)fi",
            "sizeof(struct fileIdentDesc)"
          ],
          "line": 47
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "UDF_I",
          "args": [
            "dir"
          ],
          "line": 31
        },
        "resolved": true,
        "details": {
          "function_name": "UDF_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/udf/udf_i.h",
          "lines": "57-60",
          "snippet": "static inline struct udf_inode_info *UDF_I(struct inode *inode)\n{\n\treturn list_entry(inode, struct udf_inode_info, vfs_inode);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline struct udf_inode_info *UDF_I(struct inode *inode)\n{\n\treturn list_entry(inode, struct udf_inode_info, vfs_inode);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/fs.h>\n#include \"udf_i.h\"\n#include \"udfdecl.h\"\n\nstruct fileIdentDesc *udf_fileident_read(struct inode *dir, loff_t *nf_pos,\n\t\t\t\t\t struct udf_fileident_bh *fibh,\n\t\t\t\t\t struct fileIdentDesc *cfi,\n\t\t\t\t\t struct extent_position *epos,\n\t\t\t\t\t struct kernel_lb_addr *eloc, uint32_t *elen,\n\t\t\t\t\t sector_t *offset)\n{\n\tstruct fileIdentDesc *fi;\n\tint i, num, block;\n\tstruct buffer_head *tmp, *bha[16];\n\tstruct udf_inode_info *iinfo = UDF_I(dir);\n\n\tfibh->soffset = fibh->eoffset;\n\n\tif (iinfo->i_alloc_type == ICBTAG_FLAG_AD_IN_ICB) {\n\t\tfi = udf_get_fileident(iinfo->i_ext.i_data -\n\t\t\t\t       (iinfo->i_efe ?\n\t\t\t\t\tsizeof(struct extendedFileEntry) :\n\t\t\t\t\tsizeof(struct fileEntry)),\n\t\t\t\t       dir->i_sb->s_blocksize,\n\t\t\t\t       &(fibh->eoffset));\n\t\tif (!fi)\n\t\t\treturn NULL;\n\n\t\t*nf_pos += fibh->eoffset - fibh->soffset;\n\n\t\tmemcpy((uint8_t *)cfi, (uint8_t *)fi,\n\t\t       sizeof(struct fileIdentDesc));\n\n\t\treturn fi;\n\t}\n\n\tif (fibh->eoffset == dir->i_sb->s_blocksize) {\n\t\tint lextoffset = epos->offset;\n\t\tunsigned char blocksize_bits = dir->i_sb->s_blocksize_bits;\n\n\t\tif (udf_next_aext(dir, epos, eloc, elen, 1) !=\n\t\t    (EXT_RECORDED_ALLOCATED >> 30))\n\t\t\treturn NULL;\n\n\t\tblock = udf_get_lb_pblock(dir->i_sb, eloc, *offset);\n\n\t\t(*offset)++;\n\n\t\tif ((*offset << blocksize_bits) >= *elen)\n\t\t\t*offset = 0;\n\t\telse\n\t\t\tepos->offset = lextoffset;\n\n\t\tbrelse(fibh->sbh);\n\t\tfibh->sbh = fibh->ebh = udf_tread(dir->i_sb, block);\n\t\tif (!fibh->sbh)\n\t\t\treturn NULL;\n\t\tfibh->soffset = fibh->eoffset = 0;\n\n\t\tif (!(*offset & ((16 >> (blocksize_bits - 9)) - 1))) {\n\t\t\ti = 16 >> (blocksize_bits - 9);\n\t\t\tif (i + *offset > (*elen >> blocksize_bits))\n\t\t\t\ti = (*elen >> blocksize_bits)-*offset;\n\t\t\tfor (num = 0; i > 0; i--) {\n\t\t\t\tblock = udf_get_lb_pblock(dir->i_sb, eloc,\n\t\t\t\t\t\t\t  *offset + i);\n\t\t\t\ttmp = udf_tgetblk(dir->i_sb, block);\n\t\t\t\tif (tmp && !buffer_uptodate(tmp) &&\n\t\t\t\t\t\t!buffer_locked(tmp))\n\t\t\t\t\tbha[num++] = tmp;\n\t\t\t\telse\n\t\t\t\t\tbrelse(tmp);\n\t\t\t}\n\t\t\tif (num) {\n\t\t\t\tll_rw_block(READA, num, bha);\n\t\t\t\tfor (i = 0; i < num; i++)\n\t\t\t\t\tbrelse(bha[i]);\n\t\t\t}\n\t\t}\n\t} else if (fibh->sbh != fibh->ebh) {\n\t\tbrelse(fibh->sbh);\n\t\tfibh->sbh = fibh->ebh;\n\t}\n\n\tfi = udf_get_fileident(fibh->sbh->b_data, dir->i_sb->s_blocksize,\n\t\t\t       &(fibh->eoffset));\n\n\tif (!fi)\n\t\treturn NULL;\n\n\t*nf_pos += fibh->eoffset - fibh->soffset;\n\n\tif (fibh->eoffset <= dir->i_sb->s_blocksize) {\n\t\tmemcpy((uint8_t *)cfi, (uint8_t *)fi,\n\t\t       sizeof(struct fileIdentDesc));\n\t} else if (fibh->eoffset > dir->i_sb->s_blocksize) {\n\t\tint lextoffset = epos->offset;\n\n\t\tif (udf_next_aext(dir, epos, eloc, elen, 1) !=\n\t\t    (EXT_RECORDED_ALLOCATED >> 30))\n\t\t\treturn NULL;\n\n\t\tblock = udf_get_lb_pblock(dir->i_sb, eloc, *offset);\n\n\t\t(*offset)++;\n\n\t\tif ((*offset << dir->i_sb->s_blocksize_bits) >= *elen)\n\t\t\t*offset = 0;\n\t\telse\n\t\t\tepos->offset = lextoffset;\n\n\t\tfibh->soffset -= dir->i_sb->s_blocksize;\n\t\tfibh->eoffset -= dir->i_sb->s_blocksize;\n\n\t\tfibh->ebh = udf_tread(dir->i_sb, block);\n\t\tif (!fibh->ebh)\n\t\t\treturn NULL;\n\n\t\tif (sizeof(struct fileIdentDesc) > -fibh->soffset) {\n\t\t\tint fi_len;\n\n\t\t\tmemcpy((uint8_t *)cfi, (uint8_t *)fi, -fibh->soffset);\n\t\t\tmemcpy((uint8_t *)cfi - fibh->soffset,\n\t\t\t       fibh->ebh->b_data,\n\t\t\t       sizeof(struct fileIdentDesc) + fibh->soffset);\n\n\t\t\tfi_len = (sizeof(struct fileIdentDesc) +\n\t\t\t\t  cfi->lengthFileIdent +\n\t\t\t\t  le16_to_cpu(cfi->lengthOfImpUse) + 3) & ~3;\n\n\t\t\t*nf_pos += fi_len - (fibh->eoffset - fibh->soffset);\n\t\t\tfibh->eoffset = fibh->soffset + fi_len;\n\t\t} else {\n\t\t\tmemcpy((uint8_t *)cfi, (uint8_t *)fi,\n\t\t\t       sizeof(struct fileIdentDesc));\n\t\t}\n\t}\n\treturn fi;\n}"
  }
]