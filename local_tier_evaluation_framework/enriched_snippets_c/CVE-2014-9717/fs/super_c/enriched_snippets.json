[
  {
    "function_name": "haw_super(",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/super.c",
    "lines": "1365-1395",
    "snippet": "nt thaw_super(struct super_block *sb)\n{\n\tint error;\n\n\tdown_write(&sb->s_umount);\n\tif (sb->s_writers.frozen == SB_UNFROZEN) {\n\t\tup_write(&sb->s_umount);\n\t\treturn -EINVAL;\n\t}\n\n\tif (sb->s_flags & MS_RDONLY)\n\t\tgoto out;\n\n\tif (sb->s_op->unfreeze_fs) {\n\t\terror = sb->s_op->unfreeze_fs(sb);\n\t\tif (error) {\n\t\t\tprintk(KERN_ERR\n\t\t\t\t\"VFS:Filesystem thaw failed\\n\");\n\t\t\tup_write(&sb->s_umount);\n\t\t\treturn error;\n\t\t}\n\t}\n\nout:\n\tsb->s_writers.frozen = SB_UNFROZEN;\n\tsmp_wmb();\n\twake_up(&sb->s_writers.wait_unfrozen);\n\tdeactivate_locked_super(sb);\n\n\treturn 0;\n}",
    "includes": [
      "include \"internal.h\"",
      "include <linux/lockdep.h>\n#",
      "include <linux/fsnotify.h>\n#",
      "include <linux/cleancache.h>\n#",
      "include <linux/rculist_bl.h>\n#",
      "include <linux/backing-dev.h>\n#",
      "include <linux/mutex.h>\n#",
      "include <linux/idr.h>\n#",
      "include <linux/writeback.h>\t\t/* for the emergency remount stuff */\n#",
      "include <linux/security.h>\n#",
      "include <linux/mount.h>\n#",
      "include <linux/blkdev.h>\n#",
      "include <linux/slab.h>\n#",
      "include <linux/export.h>\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "eactivate_locked_super(",
          "args": [
            "b)"
          ],
          "line": 1392
        },
        "resolved": true,
        "details": {
          "function_name": "eactivate_locked_super(",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/super.c",
          "lines": "280-301",
          "snippet": "oid deactivate_locked_super(struct super_block *s)\n{\n\tstruct file_system_type *fs = s->s_type;\n\tif (atomic_dec_and_test(&s->s_active)) {\n\t\tcleancache_invalidate_fs(s);\n\t\tunregister_shrinker(&s->s_shrink);\n\t\tfs->kill_sb(s);\n\n\t\t/*\n\t\t * Since list_lru_destroy() may sleep, we cannot call it from\n\t\t * put_super(), where we hold the sb_lock. Therefore we destroy\n\t\t * the lru lists right now.\n\t\t */\n\t\tlist_lru_destroy(&s->s_dentry_lru);\n\t\tlist_lru_destroy(&s->s_inode_lru);\n\n\t\tput_filesystem(fs);\n\t\tput_super(s);\n\t} else {\n\t\tup_write(&s->s_umount);\n\t}\n}",
          "includes": [
            "include \"internal.h\"",
            "include <linux/lockdep.h>\n#",
            "include <linux/fsnotify.h>\n#",
            "include <linux/cleancache.h>\n#",
            "include <linux/rculist_bl.h>\n#",
            "include <linux/backing-dev.h>\n#",
            "include <linux/mutex.h>\n#",
            "include <linux/idr.h>\n#",
            "include <linux/writeback.h>\t\t/* for the emergency remount stuff */\n#",
            "include <linux/security.h>\n#",
            "include <linux/mount.h>\n#",
            "include <linux/blkdev.h>\n#",
            "include <linux/slab.h>\n#",
            "include <linux/export.h>\n#"
          ],
          "macros_used": [],
          "globals_used": [
            "tatic DEFINE_SPINLOCK(sb_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "include \"internal.h\"\ninclude <linux/lockdep.h>\n#\ninclude <linux/fsnotify.h>\n#\ninclude <linux/cleancache.h>\n#\ninclude <linux/rculist_bl.h>\n#\ninclude <linux/backing-dev.h>\n#\ninclude <linux/mutex.h>\n#\ninclude <linux/idr.h>\n#\ninclude <linux/writeback.h>\t\t/* for the emergency remount stuff */\n#\ninclude <linux/security.h>\n#\ninclude <linux/mount.h>\n#\ninclude <linux/blkdev.h>\n#\ninclude <linux/slab.h>\n#\ninclude <linux/export.h>\n#\n\ntatic DEFINE_SPINLOCK(sb_lock);\n\noid deactivate_locked_super(struct super_block *s)\n{\n\tstruct file_system_type *fs = s->s_type;\n\tif (atomic_dec_and_test(&s->s_active)) {\n\t\tcleancache_invalidate_fs(s);\n\t\tunregister_shrinker(&s->s_shrink);\n\t\tfs->kill_sb(s);\n\n\t\t/*\n\t\t * Since list_lru_destroy() may sleep, we cannot call it from\n\t\t * put_super(), where we hold the sb_lock. Therefore we destroy\n\t\t * the lru lists right now.\n\t\t */\n\t\tlist_lru_destroy(&s->s_dentry_lru);\n\t\tlist_lru_destroy(&s->s_inode_lru);\n\n\t\tput_filesystem(fs);\n\t\tput_super(s);\n\t} else {\n\t\tup_write(&s->s_umount);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ake_up(",
          "args": [
            "sb->s_writers.wait_unfrozen)"
          ],
          "line": 1391
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mp_wmb(",
          "args": [],
          "line": 1390
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "p_write(",
          "args": [
            "sb->s_umount)"
          ],
          "line": 1383
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rintk(",
          "args": [
            "ERN_ERR\n\t\t\t\t\"VFS:Filesystem thaw failed\\n\")"
          ],
          "line": 1381
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "b->s_op->unfreeze_fs",
          "args": [
            "b)"
          ],
          "line": 1379
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "p_write(",
          "args": [
            "sb->s_umount)"
          ],
          "line": 1371
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "own_write(",
          "args": [
            "sb->s_umount)"
          ],
          "line": 1369
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "include \"internal.h\"\ninclude <linux/lockdep.h>\n#\ninclude <linux/fsnotify.h>\n#\ninclude <linux/cleancache.h>\n#\ninclude <linux/rculist_bl.h>\n#\ninclude <linux/backing-dev.h>\n#\ninclude <linux/mutex.h>\n#\ninclude <linux/idr.h>\n#\ninclude <linux/writeback.h>\t\t/* for the emergency remount stuff */\n#\ninclude <linux/security.h>\n#\ninclude <linux/mount.h>\n#\ninclude <linux/blkdev.h>\n#\ninclude <linux/slab.h>\n#\ninclude <linux/export.h>\n#\n\nnt thaw_super(struct super_block *sb)\n{\n\tint error;\n\n\tdown_write(&sb->s_umount);\n\tif (sb->s_writers.frozen == SB_UNFROZEN) {\n\t\tup_write(&sb->s_umount);\n\t\treturn -EINVAL;\n\t}\n\n\tif (sb->s_flags & MS_RDONLY)\n\t\tgoto out;\n\n\tif (sb->s_op->unfreeze_fs) {\n\t\terror = sb->s_op->unfreeze_fs(sb);\n\t\tif (error) {\n\t\t\tprintk(KERN_ERR\n\t\t\t\t\"VFS:Filesystem thaw failed\\n\");\n\t\t\tup_write(&sb->s_umount);\n\t\t\treturn error;\n\t\t}\n\t}\n\nout:\n\tsb->s_writers.frozen = SB_UNFROZEN;\n\tsmp_wmb();\n\twake_up(&sb->s_writers.wait_unfrozen);\n\tdeactivate_locked_super(sb);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "reeze_super(",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/super.c",
    "lines": "1290-1356",
    "snippet": "nt freeze_super(struct super_block *sb)\n{\n\tint ret;\n\n\tatomic_inc(&sb->s_active);\n\tdown_write(&sb->s_umount);\n\tif (sb->s_writers.frozen != SB_UNFROZEN) {\n\t\tdeactivate_locked_super(sb);\n\t\treturn -EBUSY;\n\t}\n\n\tif (!(sb->s_flags & MS_BORN)) {\n\t\tup_write(&sb->s_umount);\n\t\treturn 0;\t/* sic - it's \"nothing to do\" */\n\t}\n\n\tif (sb->s_flags & MS_RDONLY) {\n\t\t/* Nothing to do really... */\n\t\tsb->s_writers.frozen = SB_FREEZE_COMPLETE;\n\t\tup_write(&sb->s_umount);\n\t\treturn 0;\n\t}\n\n\t/* From now on, no new normal writers can start */\n\tsb->s_writers.frozen = SB_FREEZE_WRITE;\n\tsmp_wmb();\n\n\t/* Release s_umount to preserve sb_start_write -> s_umount ordering */\n\tup_write(&sb->s_umount);\n\n\tsb_wait_write(sb, SB_FREEZE_WRITE);\n\n\t/* Now we go and block page faults... */\n\tdown_write(&sb->s_umount);\n\tsb->s_writers.frozen = SB_FREEZE_PAGEFAULT;\n\tsmp_wmb();\n\n\tsb_wait_write(sb, SB_FREEZE_PAGEFAULT);\n\n\t/* All writers are done so after syncing there won't be dirty data */\n\tsync_filesystem(sb);\n\n\t/* Now wait for internal filesystem counter */\n\tsb->s_writers.frozen = SB_FREEZE_FS;\n\tsmp_wmb();\n\tsb_wait_write(sb, SB_FREEZE_FS);\n\n\tif (sb->s_op->freeze_fs) {\n\t\tret = sb->s_op->freeze_fs(sb);\n\t\tif (ret) {\n\t\t\tprintk(KERN_ERR\n\t\t\t\t\"VFS:Filesystem freeze failed\\n\");\n\t\t\tsb->s_writers.frozen = SB_UNFROZEN;\n\t\t\tsmp_wmb();\n\t\t\twake_up(&sb->s_writers.wait_unfrozen);\n\t\t\tdeactivate_locked_super(sb);\n\t\t\treturn ret;\n\t\t}\n\t}\n\t/*\n\t * This is just for debugging purposes so that fs can warn if it\n\t * sees write activity when frozen is set to SB_FREEZE_COMPLETE.\n\t */\n\tsb->s_writers.frozen = SB_FREEZE_COMPLETE;\n\tup_write(&sb->s_umount);\n\treturn 0;\n}",
    "includes": [
      "include \"internal.h\"",
      "include <linux/lockdep.h>\n#",
      "include <linux/fsnotify.h>\n#",
      "include <linux/cleancache.h>\n#",
      "include <linux/rculist_bl.h>\n#",
      "include <linux/backing-dev.h>\n#",
      "include <linux/mutex.h>\n#",
      "include <linux/idr.h>\n#",
      "include <linux/writeback.h>\t\t/* for the emergency remount stuff */\n#",
      "include <linux/security.h>\n#",
      "include <linux/mount.h>\n#",
      "include <linux/blkdev.h>\n#",
      "include <linux/slab.h>\n#",
      "include <linux/export.h>\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "p_write(",
          "args": [
            "sb->s_umount)"
          ],
          "line": 1354
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "eactivate_locked_super(",
          "args": [
            "b)"
          ],
          "line": 1345
        },
        "resolved": true,
        "details": {
          "function_name": "eactivate_locked_super(",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/super.c",
          "lines": "280-301",
          "snippet": "oid deactivate_locked_super(struct super_block *s)\n{\n\tstruct file_system_type *fs = s->s_type;\n\tif (atomic_dec_and_test(&s->s_active)) {\n\t\tcleancache_invalidate_fs(s);\n\t\tunregister_shrinker(&s->s_shrink);\n\t\tfs->kill_sb(s);\n\n\t\t/*\n\t\t * Since list_lru_destroy() may sleep, we cannot call it from\n\t\t * put_super(), where we hold the sb_lock. Therefore we destroy\n\t\t * the lru lists right now.\n\t\t */\n\t\tlist_lru_destroy(&s->s_dentry_lru);\n\t\tlist_lru_destroy(&s->s_inode_lru);\n\n\t\tput_filesystem(fs);\n\t\tput_super(s);\n\t} else {\n\t\tup_write(&s->s_umount);\n\t}\n}",
          "includes": [
            "include \"internal.h\"",
            "include <linux/lockdep.h>\n#",
            "include <linux/fsnotify.h>\n#",
            "include <linux/cleancache.h>\n#",
            "include <linux/rculist_bl.h>\n#",
            "include <linux/backing-dev.h>\n#",
            "include <linux/mutex.h>\n#",
            "include <linux/idr.h>\n#",
            "include <linux/writeback.h>\t\t/* for the emergency remount stuff */\n#",
            "include <linux/security.h>\n#",
            "include <linux/mount.h>\n#",
            "include <linux/blkdev.h>\n#",
            "include <linux/slab.h>\n#",
            "include <linux/export.h>\n#"
          ],
          "macros_used": [],
          "globals_used": [
            "tatic DEFINE_SPINLOCK(sb_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "include \"internal.h\"\ninclude <linux/lockdep.h>\n#\ninclude <linux/fsnotify.h>\n#\ninclude <linux/cleancache.h>\n#\ninclude <linux/rculist_bl.h>\n#\ninclude <linux/backing-dev.h>\n#\ninclude <linux/mutex.h>\n#\ninclude <linux/idr.h>\n#\ninclude <linux/writeback.h>\t\t/* for the emergency remount stuff */\n#\ninclude <linux/security.h>\n#\ninclude <linux/mount.h>\n#\ninclude <linux/blkdev.h>\n#\ninclude <linux/slab.h>\n#\ninclude <linux/export.h>\n#\n\ntatic DEFINE_SPINLOCK(sb_lock);\n\noid deactivate_locked_super(struct super_block *s)\n{\n\tstruct file_system_type *fs = s->s_type;\n\tif (atomic_dec_and_test(&s->s_active)) {\n\t\tcleancache_invalidate_fs(s);\n\t\tunregister_shrinker(&s->s_shrink);\n\t\tfs->kill_sb(s);\n\n\t\t/*\n\t\t * Since list_lru_destroy() may sleep, we cannot call it from\n\t\t * put_super(), where we hold the sb_lock. Therefore we destroy\n\t\t * the lru lists right now.\n\t\t */\n\t\tlist_lru_destroy(&s->s_dentry_lru);\n\t\tlist_lru_destroy(&s->s_inode_lru);\n\n\t\tput_filesystem(fs);\n\t\tput_super(s);\n\t} else {\n\t\tup_write(&s->s_umount);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ake_up(",
          "args": [
            "sb->s_writers.wait_unfrozen)"
          ],
          "line": 1344
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mp_wmb(",
          "args": [],
          "line": 1343
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rintk(",
          "args": [
            "ERN_ERR\n\t\t\t\t\"VFS:Filesystem freeze failed\\n\")"
          ],
          "line": 1340
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "b->s_op->freeze_fs",
          "args": [
            "b)"
          ],
          "line": 1338
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "b_wait_write(",
          "args": [
            "b,",
            "B_FREEZE_FS)"
          ],
          "line": 1335
        },
        "resolved": true,
        "details": {
          "function_name": "b_wait_write(",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/super.c",
          "lines": "1228-1255",
          "snippet": "tatic void sb_wait_write(struct super_block *sb, int level)\n{\n\ts64 writers;\n\n\t/*\n\t * We just cycle-through lockdep here so that it does not complain\n\t * about returning with lock to userspace\n\t */\n\trwsem_acquire(&sb->s_writers.lock_map[level-1], 0, 0, _THIS_IP_);\n\trwsem_release(&sb->s_writers.lock_map[level-1], 1, _THIS_IP_);\n\n\tdo {\n\t\tDEFINE_WAIT(wait);\n\n\t\t/*\n\t\t * We use a barrier in prepare_to_wait() to separate setting\n\t\t * of frozen and checking of the counter\n\t\t */\n\t\tprepare_to_wait(&sb->s_writers.wait, &wait,\n\t\t\t\tTASK_UNINTERRUPTIBLE);\n\n\t\twriters = percpu_counter_sum(&sb->s_writers.counter[level-1]);\n\t\tif (writers)\n\t\t\tschedule();\n\n\t\tfinish_wait(&sb->s_writers.wait, &wait);\n\t} while (writers);\n}",
          "includes": [
            "include \"internal.h\"",
            "include <linux/lockdep.h>\n#",
            "include <linux/fsnotify.h>\n#",
            "include <linux/cleancache.h>\n#",
            "include <linux/rculist_bl.h>\n#",
            "include <linux/backing-dev.h>\n#",
            "include <linux/mutex.h>\n#",
            "include <linux/idr.h>\n#",
            "include <linux/writeback.h>\t\t/* for the emergency remount stuff */\n#",
            "include <linux/security.h>\n#",
            "include <linux/mount.h>\n#",
            "include <linux/blkdev.h>\n#",
            "include <linux/slab.h>\n#",
            "include <linux/export.h>\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"internal.h\"\ninclude <linux/lockdep.h>\n#\ninclude <linux/fsnotify.h>\n#\ninclude <linux/cleancache.h>\n#\ninclude <linux/rculist_bl.h>\n#\ninclude <linux/backing-dev.h>\n#\ninclude <linux/mutex.h>\n#\ninclude <linux/idr.h>\n#\ninclude <linux/writeback.h>\t\t/* for the emergency remount stuff */\n#\ninclude <linux/security.h>\n#\ninclude <linux/mount.h>\n#\ninclude <linux/blkdev.h>\n#\ninclude <linux/slab.h>\n#\ninclude <linux/export.h>\n#\n\ntatic void sb_wait_write(struct super_block *sb, int level)\n{\n\ts64 writers;\n\n\t/*\n\t * We just cycle-through lockdep here so that it does not complain\n\t * about returning with lock to userspace\n\t */\n\trwsem_acquire(&sb->s_writers.lock_map[level-1], 0, 0, _THIS_IP_);\n\trwsem_release(&sb->s_writers.lock_map[level-1], 1, _THIS_IP_);\n\n\tdo {\n\t\tDEFINE_WAIT(wait);\n\n\t\t/*\n\t\t * We use a barrier in prepare_to_wait() to separate setting\n\t\t * of frozen and checking of the counter\n\t\t */\n\t\tprepare_to_wait(&sb->s_writers.wait, &wait,\n\t\t\t\tTASK_UNINTERRUPTIBLE);\n\n\t\twriters = percpu_counter_sum(&sb->s_writers.counter[level-1]);\n\t\tif (writers)\n\t\t\tschedule();\n\n\t\tfinish_wait(&sb->s_writers.wait, &wait);\n\t} while (writers);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mp_wmb(",
          "args": [],
          "line": 1334
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ync_filesystem(",
          "args": [
            "b)"
          ],
          "line": 1330
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mp_wmb(",
          "args": [],
          "line": 1325
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "own_write(",
          "args": [
            "sb->s_umount)"
          ],
          "line": 1323
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "p_write(",
          "args": [
            "sb->s_umount)"
          ],
          "line": 1318
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mp_wmb(",
          "args": [],
          "line": 1315
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "p_write(",
          "args": [
            "sb->s_umount)"
          ],
          "line": 1309
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "p_write(",
          "args": [
            "sb->s_umount)"
          ],
          "line": 1302
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "own_write(",
          "args": [
            "sb->s_umount)"
          ],
          "line": 1295
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tomic_inc(",
          "args": [
            "sb->s_active)"
          ],
          "line": 1294
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "include \"internal.h\"\ninclude <linux/lockdep.h>\n#\ninclude <linux/fsnotify.h>\n#\ninclude <linux/cleancache.h>\n#\ninclude <linux/rculist_bl.h>\n#\ninclude <linux/backing-dev.h>\n#\ninclude <linux/mutex.h>\n#\ninclude <linux/idr.h>\n#\ninclude <linux/writeback.h>\t\t/* for the emergency remount stuff */\n#\ninclude <linux/security.h>\n#\ninclude <linux/mount.h>\n#\ninclude <linux/blkdev.h>\n#\ninclude <linux/slab.h>\n#\ninclude <linux/export.h>\n#\n\nnt freeze_super(struct super_block *sb)\n{\n\tint ret;\n\n\tatomic_inc(&sb->s_active);\n\tdown_write(&sb->s_umount);\n\tif (sb->s_writers.frozen != SB_UNFROZEN) {\n\t\tdeactivate_locked_super(sb);\n\t\treturn -EBUSY;\n\t}\n\n\tif (!(sb->s_flags & MS_BORN)) {\n\t\tup_write(&sb->s_umount);\n\t\treturn 0;\t/* sic - it's \"nothing to do\" */\n\t}\n\n\tif (sb->s_flags & MS_RDONLY) {\n\t\t/* Nothing to do really... */\n\t\tsb->s_writers.frozen = SB_FREEZE_COMPLETE;\n\t\tup_write(&sb->s_umount);\n\t\treturn 0;\n\t}\n\n\t/* From now on, no new normal writers can start */\n\tsb->s_writers.frozen = SB_FREEZE_WRITE;\n\tsmp_wmb();\n\n\t/* Release s_umount to preserve sb_start_write -> s_umount ordering */\n\tup_write(&sb->s_umount);\n\n\tsb_wait_write(sb, SB_FREEZE_WRITE);\n\n\t/* Now we go and block page faults... */\n\tdown_write(&sb->s_umount);\n\tsb->s_writers.frozen = SB_FREEZE_PAGEFAULT;\n\tsmp_wmb();\n\n\tsb_wait_write(sb, SB_FREEZE_PAGEFAULT);\n\n\t/* All writers are done so after syncing there won't be dirty data */\n\tsync_filesystem(sb);\n\n\t/* Now wait for internal filesystem counter */\n\tsb->s_writers.frozen = SB_FREEZE_FS;\n\tsmp_wmb();\n\tsb_wait_write(sb, SB_FREEZE_FS);\n\n\tif (sb->s_op->freeze_fs) {\n\t\tret = sb->s_op->freeze_fs(sb);\n\t\tif (ret) {\n\t\t\tprintk(KERN_ERR\n\t\t\t\t\"VFS:Filesystem freeze failed\\n\");\n\t\t\tsb->s_writers.frozen = SB_UNFROZEN;\n\t\t\tsmp_wmb();\n\t\t\twake_up(&sb->s_writers.wait_unfrozen);\n\t\t\tdeactivate_locked_super(sb);\n\t\t\treturn ret;\n\t\t}\n\t}\n\t/*\n\t * This is just for debugging purposes so that fs can warn if it\n\t * sees write activity when frozen is set to SB_FREEZE_COMPLETE.\n\t */\n\tsb->s_writers.frozen = SB_FREEZE_COMPLETE;\n\tup_write(&sb->s_umount);\n\treturn 0;\n}"
  },
  {
    "function_name": "b_wait_write(",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/super.c",
    "lines": "1228-1255",
    "snippet": "tatic void sb_wait_write(struct super_block *sb, int level)\n{\n\ts64 writers;\n\n\t/*\n\t * We just cycle-through lockdep here so that it does not complain\n\t * about returning with lock to userspace\n\t */\n\trwsem_acquire(&sb->s_writers.lock_map[level-1], 0, 0, _THIS_IP_);\n\trwsem_release(&sb->s_writers.lock_map[level-1], 1, _THIS_IP_);\n\n\tdo {\n\t\tDEFINE_WAIT(wait);\n\n\t\t/*\n\t\t * We use a barrier in prepare_to_wait() to separate setting\n\t\t * of frozen and checking of the counter\n\t\t */\n\t\tprepare_to_wait(&sb->s_writers.wait, &wait,\n\t\t\t\tTASK_UNINTERRUPTIBLE);\n\n\t\twriters = percpu_counter_sum(&sb->s_writers.counter[level-1]);\n\t\tif (writers)\n\t\t\tschedule();\n\n\t\tfinish_wait(&sb->s_writers.wait, &wait);\n\t} while (writers);\n}",
    "includes": [
      "include \"internal.h\"",
      "include <linux/lockdep.h>\n#",
      "include <linux/fsnotify.h>\n#",
      "include <linux/cleancache.h>\n#",
      "include <linux/rculist_bl.h>\n#",
      "include <linux/backing-dev.h>\n#",
      "include <linux/mutex.h>\n#",
      "include <linux/idr.h>\n#",
      "include <linux/writeback.h>\t\t/* for the emergency remount stuff */\n#",
      "include <linux/security.h>\n#",
      "include <linux/mount.h>\n#",
      "include <linux/blkdev.h>\n#",
      "include <linux/slab.h>\n#",
      "include <linux/export.h>\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "inish_wait(",
          "args": [
            "sb->s_writers.wait,",
            "wait)"
          ],
          "line": 1253
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "chedule(",
          "args": [],
          "line": 1251
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ercpu_counter_sum(",
          "args": [
            "sb->s_writers.counter[level-1])"
          ],
          "line": 1249
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "repare_to_wait(",
          "args": [
            "sb->s_writers.wait,",
            "wait,",
            "ASK_UNINTERRUPTIBLE)"
          ],
          "line": 1246
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EFINE_WAIT(",
          "args": [
            "ait)"
          ],
          "line": 1240
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wsem_release(",
          "args": [
            "sb->s_writers.lock_map[level-1],",
            ",",
            "THIS_IP_)"
          ],
          "line": 1237
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wsem_acquire(",
          "args": [
            "sb->s_writers.lock_map[level-1],",
            ",",
            ",",
            "THIS_IP_)"
          ],
          "line": 1236
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "include \"internal.h\"\ninclude <linux/lockdep.h>\n#\ninclude <linux/fsnotify.h>\n#\ninclude <linux/cleancache.h>\n#\ninclude <linux/rculist_bl.h>\n#\ninclude <linux/backing-dev.h>\n#\ninclude <linux/mutex.h>\n#\ninclude <linux/idr.h>\n#\ninclude <linux/writeback.h>\t\t/* for the emergency remount stuff */\n#\ninclude <linux/security.h>\n#\ninclude <linux/mount.h>\n#\ninclude <linux/blkdev.h>\n#\ninclude <linux/slab.h>\n#\ninclude <linux/export.h>\n#\n\ntatic void sb_wait_write(struct super_block *sb, int level)\n{\n\ts64 writers;\n\n\t/*\n\t * We just cycle-through lockdep here so that it does not complain\n\t * about returning with lock to userspace\n\t */\n\trwsem_acquire(&sb->s_writers.lock_map[level-1], 0, 0, _THIS_IP_);\n\trwsem_release(&sb->s_writers.lock_map[level-1], 1, _THIS_IP_);\n\n\tdo {\n\t\tDEFINE_WAIT(wait);\n\n\t\t/*\n\t\t * We use a barrier in prepare_to_wait() to separate setting\n\t\t * of frozen and checking of the counter\n\t\t */\n\t\tprepare_to_wait(&sb->s_writers.wait, &wait,\n\t\t\t\tTASK_UNINTERRUPTIBLE);\n\n\t\twriters = percpu_counter_sum(&sb->s_writers.counter[level-1]);\n\t\tif (writers)\n\t\t\tschedule();\n\n\t\tfinish_wait(&sb->s_writers.wait, &wait);\n\t} while (writers);\n}"
  },
  {
    "function_name": "_sb_start_write(",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/super.c",
    "lines": "1191-1215",
    "snippet": "nt __sb_start_write(struct super_block *sb, int level, bool wait)\n{\nretry:\n\tif (unlikely(sb->s_writers.frozen >= level)) {\n\t\tif (!wait)\n\t\t\treturn 0;\n\t\twait_event(sb->s_writers.wait_unfrozen,\n\t\t\t   sb->s_writers.frozen < level);\n\t}\n\n#ifdef CONFIG_LOCKDEP\n\tacquire_freeze_lock(sb, level, !wait, _RET_IP_);\n#endif\n\tpercpu_counter_inc(&sb->s_writers.counter[level-1]);\n\t/*\n\t * Make sure counter is updated before we check for frozen.\n\t * freeze_super() first sets frozen and then checks the counter.\n\t */\n\tsmp_mb();\n\tif (unlikely(sb->s_writers.frozen >= level)) {\n\t\t__sb_end_write(sb, level);\n\t\tgoto retry;\n\t}\n\treturn 1;\n}",
    "includes": [
      "include \"internal.h\"",
      "include <linux/lockdep.h>\n#",
      "include <linux/fsnotify.h>\n#",
      "include <linux/cleancache.h>\n#",
      "include <linux/rculist_bl.h>\n#",
      "include <linux/backing-dev.h>\n#",
      "include <linux/mutex.h>\n#",
      "include <linux/idr.h>\n#",
      "include <linux/writeback.h>\t\t/* for the emergency remount stuff */\n#",
      "include <linux/security.h>\n#",
      "include <linux/mount.h>\n#",
      "include <linux/blkdev.h>\n#",
      "include <linux/slab.h>\n#",
      "include <linux/export.h>\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "_sb_end_write(",
          "args": [
            "b,",
            "evel)"
          ],
          "line": 1211
        },
        "resolved": true,
        "details": {
          "function_name": "_sb_end_write(",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/super.c",
          "lines": "1147-1158",
          "snippet": "oid __sb_end_write(struct super_block *sb, int level)\n{\n\tpercpu_counter_dec(&sb->s_writers.counter[level-1]);\n\t/*\n\t * Make sure s_writers are updated before we wake up waiters in\n\t * freeze_super().\n\t */\n\tsmp_mb();\n\tif (waitqueue_active(&sb->s_writers.wait))\n\t\twake_up(&sb->s_writers.wait);\n\trwsem_release(&sb->s_writers.lock_map[level-1], 1, _RET_IP_);\n}",
          "includes": [
            "include \"internal.h\"",
            "include <linux/lockdep.h>\n#",
            "include <linux/fsnotify.h>\n#",
            "include <linux/cleancache.h>\n#",
            "include <linux/rculist_bl.h>\n#",
            "include <linux/backing-dev.h>\n#",
            "include <linux/mutex.h>\n#",
            "include <linux/idr.h>\n#",
            "include <linux/writeback.h>\t\t/* for the emergency remount stuff */\n#",
            "include <linux/security.h>\n#",
            "include <linux/mount.h>\n#",
            "include <linux/blkdev.h>\n#",
            "include <linux/slab.h>\n#",
            "include <linux/export.h>\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"internal.h\"\ninclude <linux/lockdep.h>\n#\ninclude <linux/fsnotify.h>\n#\ninclude <linux/cleancache.h>\n#\ninclude <linux/rculist_bl.h>\n#\ninclude <linux/backing-dev.h>\n#\ninclude <linux/mutex.h>\n#\ninclude <linux/idr.h>\n#\ninclude <linux/writeback.h>\t\t/* for the emergency remount stuff */\n#\ninclude <linux/security.h>\n#\ninclude <linux/mount.h>\n#\ninclude <linux/blkdev.h>\n#\ninclude <linux/slab.h>\n#\ninclude <linux/export.h>\n#\n\noid __sb_end_write(struct super_block *sb, int level)\n{\n\tpercpu_counter_dec(&sb->s_writers.counter[level-1]);\n\t/*\n\t * Make sure s_writers are updated before we wake up waiters in\n\t * freeze_super().\n\t */\n\tsmp_mb();\n\tif (waitqueue_active(&sb->s_writers.wait))\n\t\twake_up(&sb->s_writers.wait);\n\trwsem_release(&sb->s_writers.lock_map[level-1], 1, _RET_IP_);\n}"
        }
      },
      {
        "call_info": {
          "callee": "nlikely(",
          "args": [
            "b->s_writers.frozen >= level)"
          ],
          "line": 1210
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mp_mb(",
          "args": [],
          "line": 1209
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ercpu_counter_inc(",
          "args": [
            "sb->s_writers.counter[level-1])"
          ],
          "line": 1204
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cquire_freeze_lock(",
          "args": [
            "b,",
            "evel,",
            "wait,",
            "RET_IP_)"
          ],
          "line": 1202
        },
        "resolved": true,
        "details": {
          "function_name": "cquire_freeze_lock(",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/super.c",
          "lines": "1171-1184",
          "snippet": "tatic void acquire_freeze_lock(struct super_block *sb, int level, bool trylock,\n\t\t\t\tunsigned long ip)\n{\n\tint i;\n\n\tif (!trylock) {\n\t\tfor (i = 0; i < level - 1; i++)\n\t\t\tif (lock_is_held(&sb->s_writers.lock_map[i])) {\n\t\t\t\ttrylock = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t}\n\trwsem_acquire_read(&sb->s_writers.lock_map[level-1], 0, trylock, ip);\n}",
          "includes": [
            "include \"internal.h\"",
            "include <linux/lockdep.h>\n#",
            "include <linux/fsnotify.h>\n#",
            "include <linux/cleancache.h>\n#",
            "include <linux/rculist_bl.h>\n#",
            "include <linux/backing-dev.h>\n#",
            "include <linux/mutex.h>\n#",
            "include <linux/idr.h>\n#",
            "include <linux/writeback.h>\t\t/* for the emergency remount stuff */\n#",
            "include <linux/security.h>\n#",
            "include <linux/mount.h>\n#",
            "include <linux/blkdev.h>\n#",
            "include <linux/slab.h>\n#",
            "include <linux/export.h>\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"internal.h\"\ninclude <linux/lockdep.h>\n#\ninclude <linux/fsnotify.h>\n#\ninclude <linux/cleancache.h>\n#\ninclude <linux/rculist_bl.h>\n#\ninclude <linux/backing-dev.h>\n#\ninclude <linux/mutex.h>\n#\ninclude <linux/idr.h>\n#\ninclude <linux/writeback.h>\t\t/* for the emergency remount stuff */\n#\ninclude <linux/security.h>\n#\ninclude <linux/mount.h>\n#\ninclude <linux/blkdev.h>\n#\ninclude <linux/slab.h>\n#\ninclude <linux/export.h>\n#\n\ntatic void acquire_freeze_lock(struct super_block *sb, int level, bool trylock,\n\t\t\t\tunsigned long ip)\n{\n\tint i;\n\n\tif (!trylock) {\n\t\tfor (i = 0; i < level - 1; i++)\n\t\t\tif (lock_is_held(&sb->s_writers.lock_map[i])) {\n\t\t\t\ttrylock = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t}\n\trwsem_acquire_read(&sb->s_writers.lock_map[level-1], 0, trylock, ip);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ait_event(",
          "args": [
            "b->s_writers.wait_unfrozen,",
            "b->s_writers.frozen < level)"
          ],
          "line": 1197
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nlikely(",
          "args": [
            "b->s_writers.frozen >= level)"
          ],
          "line": 1194
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "include \"internal.h\"\ninclude <linux/lockdep.h>\n#\ninclude <linux/fsnotify.h>\n#\ninclude <linux/cleancache.h>\n#\ninclude <linux/rculist_bl.h>\n#\ninclude <linux/backing-dev.h>\n#\ninclude <linux/mutex.h>\n#\ninclude <linux/idr.h>\n#\ninclude <linux/writeback.h>\t\t/* for the emergency remount stuff */\n#\ninclude <linux/security.h>\n#\ninclude <linux/mount.h>\n#\ninclude <linux/blkdev.h>\n#\ninclude <linux/slab.h>\n#\ninclude <linux/export.h>\n#\n\nnt __sb_start_write(struct super_block *sb, int level, bool wait)\n{\nretry:\n\tif (unlikely(sb->s_writers.frozen >= level)) {\n\t\tif (!wait)\n\t\t\treturn 0;\n\t\twait_event(sb->s_writers.wait_unfrozen,\n\t\t\t   sb->s_writers.frozen < level);\n\t}\n\n#ifdef CONFIG_LOCKDEP\n\tacquire_freeze_lock(sb, level, !wait, _RET_IP_);\n#endif\n\tpercpu_counter_inc(&sb->s_writers.counter[level-1]);\n\t/*\n\t * Make sure counter is updated before we check for frozen.\n\t * freeze_super() first sets frozen and then checks the counter.\n\t */\n\tsmp_mb();\n\tif (unlikely(sb->s_writers.frozen >= level)) {\n\t\t__sb_end_write(sb, level);\n\t\tgoto retry;\n\t}\n\treturn 1;\n}"
  },
  {
    "function_name": "cquire_freeze_lock(",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/super.c",
    "lines": "1171-1184",
    "snippet": "tatic void acquire_freeze_lock(struct super_block *sb, int level, bool trylock,\n\t\t\t\tunsigned long ip)\n{\n\tint i;\n\n\tif (!trylock) {\n\t\tfor (i = 0; i < level - 1; i++)\n\t\t\tif (lock_is_held(&sb->s_writers.lock_map[i])) {\n\t\t\t\ttrylock = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t}\n\trwsem_acquire_read(&sb->s_writers.lock_map[level-1], 0, trylock, ip);\n}",
    "includes": [
      "include \"internal.h\"",
      "include <linux/lockdep.h>\n#",
      "include <linux/fsnotify.h>\n#",
      "include <linux/cleancache.h>\n#",
      "include <linux/rculist_bl.h>\n#",
      "include <linux/backing-dev.h>\n#",
      "include <linux/mutex.h>\n#",
      "include <linux/idr.h>\n#",
      "include <linux/writeback.h>\t\t/* for the emergency remount stuff */\n#",
      "include <linux/security.h>\n#",
      "include <linux/mount.h>\n#",
      "include <linux/blkdev.h>\n#",
      "include <linux/slab.h>\n#",
      "include <linux/export.h>\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "wsem_acquire_read(",
          "args": [
            "sb->s_writers.lock_map[level-1],",
            ",",
            "rylock,",
            "p)"
          ],
          "line": 1183
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ock_is_held(",
          "args": [
            "sb->s_writers.lock_map[i])"
          ],
          "line": 1178
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "include \"internal.h\"\ninclude <linux/lockdep.h>\n#\ninclude <linux/fsnotify.h>\n#\ninclude <linux/cleancache.h>\n#\ninclude <linux/rculist_bl.h>\n#\ninclude <linux/backing-dev.h>\n#\ninclude <linux/mutex.h>\n#\ninclude <linux/idr.h>\n#\ninclude <linux/writeback.h>\t\t/* for the emergency remount stuff */\n#\ninclude <linux/security.h>\n#\ninclude <linux/mount.h>\n#\ninclude <linux/blkdev.h>\n#\ninclude <linux/slab.h>\n#\ninclude <linux/export.h>\n#\n\ntatic void acquire_freeze_lock(struct super_block *sb, int level, bool trylock,\n\t\t\t\tunsigned long ip)\n{\n\tint i;\n\n\tif (!trylock) {\n\t\tfor (i = 0; i < level - 1; i++)\n\t\t\tif (lock_is_held(&sb->s_writers.lock_map[i])) {\n\t\t\t\ttrylock = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t}\n\trwsem_acquire_read(&sb->s_writers.lock_map[level-1], 0, trylock, ip);\n}"
  },
  {
    "function_name": "_sb_end_write(",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/super.c",
    "lines": "1147-1158",
    "snippet": "oid __sb_end_write(struct super_block *sb, int level)\n{\n\tpercpu_counter_dec(&sb->s_writers.counter[level-1]);\n\t/*\n\t * Make sure s_writers are updated before we wake up waiters in\n\t * freeze_super().\n\t */\n\tsmp_mb();\n\tif (waitqueue_active(&sb->s_writers.wait))\n\t\twake_up(&sb->s_writers.wait);\n\trwsem_release(&sb->s_writers.lock_map[level-1], 1, _RET_IP_);\n}",
    "includes": [
      "include \"internal.h\"",
      "include <linux/lockdep.h>\n#",
      "include <linux/fsnotify.h>\n#",
      "include <linux/cleancache.h>\n#",
      "include <linux/rculist_bl.h>\n#",
      "include <linux/backing-dev.h>\n#",
      "include <linux/mutex.h>\n#",
      "include <linux/idr.h>\n#",
      "include <linux/writeback.h>\t\t/* for the emergency remount stuff */\n#",
      "include <linux/security.h>\n#",
      "include <linux/mount.h>\n#",
      "include <linux/blkdev.h>\n#",
      "include <linux/slab.h>\n#",
      "include <linux/export.h>\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "wsem_release(",
          "args": [
            "sb->s_writers.lock_map[level-1],",
            ",",
            "RET_IP_)"
          ],
          "line": 1157
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ake_up(",
          "args": [
            "sb->s_writers.wait)"
          ],
          "line": 1156
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "aitqueue_active(",
          "args": [
            "sb->s_writers.wait)"
          ],
          "line": 1155
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mp_mb(",
          "args": [],
          "line": 1154
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ercpu_counter_dec(",
          "args": [
            "sb->s_writers.counter[level-1])"
          ],
          "line": 1149
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "include \"internal.h\"\ninclude <linux/lockdep.h>\n#\ninclude <linux/fsnotify.h>\n#\ninclude <linux/cleancache.h>\n#\ninclude <linux/rculist_bl.h>\n#\ninclude <linux/backing-dev.h>\n#\ninclude <linux/mutex.h>\n#\ninclude <linux/idr.h>\n#\ninclude <linux/writeback.h>\t\t/* for the emergency remount stuff */\n#\ninclude <linux/security.h>\n#\ninclude <linux/mount.h>\n#\ninclude <linux/blkdev.h>\n#\ninclude <linux/slab.h>\n#\ninclude <linux/export.h>\n#\n\noid __sb_end_write(struct super_block *sb, int level)\n{\n\tpercpu_counter_dec(&sb->s_writers.counter[level-1]);\n\t/*\n\t * Make sure s_writers are updated before we wake up waiters in\n\t * freeze_super().\n\t */\n\tsmp_mb();\n\tif (waitqueue_active(&sb->s_writers.wait))\n\t\twake_up(&sb->s_writers.wait);\n\trwsem_release(&sb->s_writers.lock_map[level-1], 1, _RET_IP_);\n}"
  },
  {
    "function_name": "ount_fs(",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/super.c",
    "lines": "1090-1141",
    "snippet": "truct dentry *\nmount_fs(struct file_system_type *type, int flags, const char *name, void *data)\n{\n\tstruct dentry *root;\n\tstruct super_block *sb;\n\tchar *secdata = NULL;\n\tint error = -ENOMEM;\n\n\tif (data && !(type->fs_flags & FS_BINARY_MOUNTDATA)) {\n\t\tsecdata = alloc_secdata();\n\t\tif (!secdata)\n\t\t\tgoto out;\n\n\t\terror = security_sb_copy_data(data, secdata);\n\t\tif (error)\n\t\t\tgoto out_free_secdata;\n\t}\n\n\troot = type->mount(type, flags, name, data);\n\tif (IS_ERR(root)) {\n\t\terror = PTR_ERR(root);\n\t\tgoto out_free_secdata;\n\t}\n\tsb = root->d_sb;\n\tBUG_ON(!sb);\n\tWARN_ON(!sb->s_bdi);\n\tsb->s_flags |= MS_BORN;\n\n\terror = security_sb_kern_mount(sb, flags, secdata);\n\tif (error)\n\t\tgoto out_sb;\n\n\t/*\n\t * filesystems should never set s_maxbytes larger than MAX_LFS_FILESIZE\n\t * but s_maxbytes was an unsigned long long for many releases. Throw\n\t * this warning for a little while to try and catch filesystems that\n\t * violate this rule.\n\t */\n\tWARN((sb->s_maxbytes < 0), \"%s set sb->s_maxbytes to \"\n\t\t\"negative value (%lld)\\n\", type->name, sb->s_maxbytes);\n\n\tup_write(&sb->s_umount);\n\tfree_secdata(secdata);\n\treturn root;\nout_sb:\n\tdput(root);\n\tdeactivate_locked_super(sb);\nout_free_secdata:\n\tfree_secdata(secdata);\nout:\n\treturn ERR_PTR(error);\n}",
    "includes": [
      "include \"internal.h\"",
      "include <linux/lockdep.h>\n#",
      "include <linux/fsnotify.h>\n#",
      "include <linux/cleancache.h>\n#",
      "include <linux/rculist_bl.h>\n#",
      "include <linux/backing-dev.h>\n#",
      "include <linux/mutex.h>\n#",
      "include <linux/idr.h>\n#",
      "include <linux/writeback.h>\t\t/* for the emergency remount stuff */\n#",
      "include <linux/security.h>\n#",
      "include <linux/mount.h>\n#",
      "include <linux/blkdev.h>\n#",
      "include <linux/slab.h>\n#",
      "include <linux/export.h>\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "RR_PTR(",
          "args": [
            "rror)"
          ],
          "line": 1140
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ree_secdata(",
          "args": [
            "ecdata)"
          ],
          "line": 1138
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "eactivate_locked_super(",
          "args": [
            "b)"
          ],
          "line": 1136
        },
        "resolved": true,
        "details": {
          "function_name": "eactivate_locked_super(",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/super.c",
          "lines": "280-301",
          "snippet": "oid deactivate_locked_super(struct super_block *s)\n{\n\tstruct file_system_type *fs = s->s_type;\n\tif (atomic_dec_and_test(&s->s_active)) {\n\t\tcleancache_invalidate_fs(s);\n\t\tunregister_shrinker(&s->s_shrink);\n\t\tfs->kill_sb(s);\n\n\t\t/*\n\t\t * Since list_lru_destroy() may sleep, we cannot call it from\n\t\t * put_super(), where we hold the sb_lock. Therefore we destroy\n\t\t * the lru lists right now.\n\t\t */\n\t\tlist_lru_destroy(&s->s_dentry_lru);\n\t\tlist_lru_destroy(&s->s_inode_lru);\n\n\t\tput_filesystem(fs);\n\t\tput_super(s);\n\t} else {\n\t\tup_write(&s->s_umount);\n\t}\n}",
          "includes": [
            "include \"internal.h\"",
            "include <linux/lockdep.h>\n#",
            "include <linux/fsnotify.h>\n#",
            "include <linux/cleancache.h>\n#",
            "include <linux/rculist_bl.h>\n#",
            "include <linux/backing-dev.h>\n#",
            "include <linux/mutex.h>\n#",
            "include <linux/idr.h>\n#",
            "include <linux/writeback.h>\t\t/* for the emergency remount stuff */\n#",
            "include <linux/security.h>\n#",
            "include <linux/mount.h>\n#",
            "include <linux/blkdev.h>\n#",
            "include <linux/slab.h>\n#",
            "include <linux/export.h>\n#"
          ],
          "macros_used": [],
          "globals_used": [
            "tatic DEFINE_SPINLOCK(sb_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "include \"internal.h\"\ninclude <linux/lockdep.h>\n#\ninclude <linux/fsnotify.h>\n#\ninclude <linux/cleancache.h>\n#\ninclude <linux/rculist_bl.h>\n#\ninclude <linux/backing-dev.h>\n#\ninclude <linux/mutex.h>\n#\ninclude <linux/idr.h>\n#\ninclude <linux/writeback.h>\t\t/* for the emergency remount stuff */\n#\ninclude <linux/security.h>\n#\ninclude <linux/mount.h>\n#\ninclude <linux/blkdev.h>\n#\ninclude <linux/slab.h>\n#\ninclude <linux/export.h>\n#\n\ntatic DEFINE_SPINLOCK(sb_lock);\n\noid deactivate_locked_super(struct super_block *s)\n{\n\tstruct file_system_type *fs = s->s_type;\n\tif (atomic_dec_and_test(&s->s_active)) {\n\t\tcleancache_invalidate_fs(s);\n\t\tunregister_shrinker(&s->s_shrink);\n\t\tfs->kill_sb(s);\n\n\t\t/*\n\t\t * Since list_lru_destroy() may sleep, we cannot call it from\n\t\t * put_super(), where we hold the sb_lock. Therefore we destroy\n\t\t * the lru lists right now.\n\t\t */\n\t\tlist_lru_destroy(&s->s_dentry_lru);\n\t\tlist_lru_destroy(&s->s_inode_lru);\n\n\t\tput_filesystem(fs);\n\t\tput_super(s);\n\t} else {\n\t\tup_write(&s->s_umount);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "put(",
          "args": [
            "oot)"
          ],
          "line": 1135
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ree_secdata(",
          "args": [
            "ecdata)"
          ],
          "line": 1132
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "p_write(",
          "args": [
            "sb->s_umount)"
          ],
          "line": 1131
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ARN(",
          "args": [
            "sb->s_maxbytes < 0),",
            "%s set sb->s_maxbytes to \"\n\t\t\"negative value (%lld)\\n\",",
            "ype->name,",
            "b->s_maxbytes)"
          ],
          "line": 1128
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ecurity_sb_kern_mount(",
          "args": [
            "b,",
            "lags,",
            "ecdata)"
          ],
          "line": 1118
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ARN_ON(",
          "args": [
            "sb->s_bdi)"
          ],
          "line": 1115
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "UG_ON(",
          "args": [
            "sb)"
          ],
          "line": 1114
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TR_ERR(",
          "args": [
            "oot)"
          ],
          "line": 1110
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ERR(",
          "args": [
            "oot)"
          ],
          "line": 1109
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ype->mount",
          "args": [
            "ype,",
            "lags,",
            "ame,",
            "ata)"
          ],
          "line": 1108
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ecurity_sb_copy_data(",
          "args": [
            "ata,",
            "ecdata)"
          ],
          "line": 1103
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lloc_secdata(",
          "args": [],
          "line": 1099
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "include \"internal.h\"\ninclude <linux/lockdep.h>\n#\ninclude <linux/fsnotify.h>\n#\ninclude <linux/cleancache.h>\n#\ninclude <linux/rculist_bl.h>\n#\ninclude <linux/backing-dev.h>\n#\ninclude <linux/mutex.h>\n#\ninclude <linux/idr.h>\n#\ninclude <linux/writeback.h>\t\t/* for the emergency remount stuff */\n#\ninclude <linux/security.h>\n#\ninclude <linux/mount.h>\n#\ninclude <linux/blkdev.h>\n#\ninclude <linux/slab.h>\n#\ninclude <linux/export.h>\n#\n\ntruct dentry *\nmount_fs(struct file_system_type *type, int flags, const char *name, void *data)\n{\n\tstruct dentry *root;\n\tstruct super_block *sb;\n\tchar *secdata = NULL;\n\tint error = -ENOMEM;\n\n\tif (data && !(type->fs_flags & FS_BINARY_MOUNTDATA)) {\n\t\tsecdata = alloc_secdata();\n\t\tif (!secdata)\n\t\t\tgoto out;\n\n\t\terror = security_sb_copy_data(data, secdata);\n\t\tif (error)\n\t\t\tgoto out_free_secdata;\n\t}\n\n\troot = type->mount(type, flags, name, data);\n\tif (IS_ERR(root)) {\n\t\terror = PTR_ERR(root);\n\t\tgoto out_free_secdata;\n\t}\n\tsb = root->d_sb;\n\tBUG_ON(!sb);\n\tWARN_ON(!sb->s_bdi);\n\tsb->s_flags |= MS_BORN;\n\n\terror = security_sb_kern_mount(sb, flags, secdata);\n\tif (error)\n\t\tgoto out_sb;\n\n\t/*\n\t * filesystems should never set s_maxbytes larger than MAX_LFS_FILESIZE\n\t * but s_maxbytes was an unsigned long long for many releases. Throw\n\t * this warning for a little while to try and catch filesystems that\n\t * violate this rule.\n\t */\n\tWARN((sb->s_maxbytes < 0), \"%s set sb->s_maxbytes to \"\n\t\t\"negative value (%lld)\\n\", type->name, sb->s_maxbytes);\n\n\tup_write(&sb->s_umount);\n\tfree_secdata(secdata);\n\treturn root;\nout_sb:\n\tdput(root);\n\tdeactivate_locked_super(sb);\nout_free_secdata:\n\tfree_secdata(secdata);\nout:\n\treturn ERR_PTR(error);\n}"
  },
  {
    "function_name": "ount_single(",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/super.c",
    "lines": "1066-1087",
    "snippet": "truct dentry *mount_single(struct file_system_type *fs_type,\n\tint flags, void *data,\n\tint (*fill_super)(struct super_block *, void *, int))\n{\n\tstruct super_block *s;\n\tint error;\n\n\ts = sget(fs_type, compare_single, set_anon_super, flags, NULL);\n\tif (IS_ERR(s))\n\t\treturn ERR_CAST(s);\n\tif (!s->s_root) {\n\t\terror = fill_super(s, data, flags & MS_SILENT ? 1 : 0);\n\t\tif (error) {\n\t\t\tdeactivate_locked_super(s);\n\t\t\treturn ERR_PTR(error);\n\t\t}\n\t\ts->s_flags |= MS_ACTIVE;\n\t} else {\n\t\tdo_remount_sb(s, flags, data, 0);\n\t}\n\treturn dget(s->s_root);\n}",
    "includes": [
      "include \"internal.h\"",
      "include <linux/lockdep.h>\n#",
      "include <linux/fsnotify.h>\n#",
      "include <linux/cleancache.h>\n#",
      "include <linux/rculist_bl.h>\n#",
      "include <linux/backing-dev.h>\n#",
      "include <linux/mutex.h>\n#",
      "include <linux/idr.h>\n#",
      "include <linux/writeback.h>\t\t/* for the emergency remount stuff */\n#",
      "include <linux/security.h>\n#",
      "include <linux/mount.h>\n#",
      "include <linux/blkdev.h>\n#",
      "include <linux/slab.h>\n#",
      "include <linux/export.h>\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "get(",
          "args": [
            "->s_root)"
          ],
          "line": 1086
        },
        "resolved": true,
        "details": {
          "function_name": "ing_page_budget(struct ubifs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ubifs/file.c",
          "lines": "214-219",
          "snippet": "elease_existing_page_budget(struct ubifs_info *c)\n{\n\tstruct ubifs_budget_req req = { .dd_growth = c->bi.page_budget};\n\n\tubifs_release_budget(c, &req);\n}\n\nstatic int",
          "includes": [
            "ux/slab.h>\n\nstatic int r",
            "ux/namei.h>\n#include <lin",
            "ux/mount.h>\n#include <lin",
            "ux/aio.h>\n#include <lin",
            "fs.h\"\n#include <lin"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "ux/slab.h>\n\nstatic int r\nux/namei.h>\n#include <lin\nux/mount.h>\n#include <lin\nux/aio.h>\n#include <lin\nfs.h\"\n#include <lin\n\nelease_existing_page_budget(struct ubifs_info *c)\n{\n\tstruct ubifs_budget_req req = { .dd_growth = c->bi.page_budget};\n\n\tubifs_release_budget(c, &req);\n}\n\nstatic int"
        }
      },
      {
        "call_info": {
          "callee": "o_remount_sb(",
          "args": [
            ",",
            "lags,",
            "ata,",
            ")"
          ],
          "line": 1084
        },
        "resolved": true,
        "details": {
          "function_name": "o_remount_sb(",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/super.c",
          "lines": "698-770",
          "snippet": "nt do_remount_sb(struct super_block *sb, int flags, void *data, int force)\n{\n\tint retval;\n\tint remount_ro;\n\n\tif (sb->s_writers.frozen != SB_UNFROZEN)\n\t\treturn -EBUSY;\n\n#ifdef CONFIG_BLOCK\n\tif (!(flags & MS_RDONLY) && bdev_read_only(sb->s_bdev))\n\t\treturn -EACCES;\n#endif\n\n\tremount_ro = (flags & MS_RDONLY) && !(sb->s_flags & MS_RDONLY);\n\n\tif (remount_ro) {\n\t\tif (!hlist_empty(&sb->s_pins)) {\n\t\t\tup_write(&sb->s_umount);\n\t\t\tgroup_pin_kill(&sb->s_pins);\n\t\t\tdown_write(&sb->s_umount);\n\t\t\tif (!sb->s_root)\n\t\t\t\treturn 0;\n\t\t\tif (sb->s_writers.frozen != SB_UNFROZEN)\n\t\t\t\treturn -EBUSY;\n\t\t\tremount_ro = (flags & MS_RDONLY) && !(sb->s_flags & MS_RDONLY);\n\t\t}\n\t}\n\tshrink_dcache_sb(sb);\n\n\t/* If we are remounting RDONLY and current sb is read/write,\n\t   make sure there are no rw files opened */\n\tif (remount_ro) {\n\t\tif (force) {\n\t\t\tsb->s_readonly_remount = 1;\n\t\t\tsmp_wmb();\n\t\t} else {\n\t\t\tretval = sb_prepare_remount_readonly(sb);\n\t\t\tif (retval)\n\t\t\t\treturn retval;\n\t\t}\n\t}\n\n\tif (sb->s_op->remount_fs) {\n\t\tretval = sb->s_op->remount_fs(sb, &flags, data);\n\t\tif (retval) {\n\t\t\tif (!force)\n\t\t\t\tgoto cancel_readonly;\n\t\t\t/* If forced remount, go ahead despite any errors */\n\t\t\tWARN(1, \"forced remount of a %s fs returned %i\\n\",\n\t\t\t     sb->s_type->name, retval);\n\t\t}\n\t}\n\tsb->s_flags = (sb->s_flags & ~MS_RMT_MASK) | (flags & MS_RMT_MASK);\n\t/* Needs to be ordered wrt mnt_is_readonly() */\n\tsmp_wmb();\n\tsb->s_readonly_remount = 0;\n\n\t/*\n\t * Some filesystems modify their metadata via some other path than the\n\t * bdev buffer cache (eg. use a private mapping, or directories in\n\t * pagecache, etc). Also file data modifications go via their own\n\t * mappings. So If we try to mount readonly then copy the filesystem\n\t * from bdev, we could get stale data, so invalidate it to give a best\n\t * effort at coherency.\n\t */\n\tif (remount_ro && sb->s_bdev)\n\t\tinvalidate_bdev(sb->s_bdev);\n\treturn 0;\n\ncancel_readonly:\n\tsb->s_readonly_remount = 0;\n\treturn retval;\n}",
          "includes": [
            "include \"internal.h\"",
            "include <linux/lockdep.h>\n#",
            "include <linux/fsnotify.h>\n#",
            "include <linux/cleancache.h>\n#",
            "include <linux/rculist_bl.h>\n#",
            "include <linux/backing-dev.h>\n#",
            "include <linux/mutex.h>\n#",
            "include <linux/idr.h>\n#",
            "include <linux/writeback.h>\t\t/* for the emergency remount stuff */\n#",
            "include <linux/security.h>\n#",
            "include <linux/mount.h>\n#",
            "include <linux/blkdev.h>\n#",
            "include <linux/slab.h>\n#",
            "include <linux/export.h>\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"internal.h\"\ninclude <linux/lockdep.h>\n#\ninclude <linux/fsnotify.h>\n#\ninclude <linux/cleancache.h>\n#\ninclude <linux/rculist_bl.h>\n#\ninclude <linux/backing-dev.h>\n#\ninclude <linux/mutex.h>\n#\ninclude <linux/idr.h>\n#\ninclude <linux/writeback.h>\t\t/* for the emergency remount stuff */\n#\ninclude <linux/security.h>\n#\ninclude <linux/mount.h>\n#\ninclude <linux/blkdev.h>\n#\ninclude <linux/slab.h>\n#\ninclude <linux/export.h>\n#\n\nnt do_remount_sb(struct super_block *sb, int flags, void *data, int force)\n{\n\tint retval;\n\tint remount_ro;\n\n\tif (sb->s_writers.frozen != SB_UNFROZEN)\n\t\treturn -EBUSY;\n\n#ifdef CONFIG_BLOCK\n\tif (!(flags & MS_RDONLY) && bdev_read_only(sb->s_bdev))\n\t\treturn -EACCES;\n#endif\n\n\tremount_ro = (flags & MS_RDONLY) && !(sb->s_flags & MS_RDONLY);\n\n\tif (remount_ro) {\n\t\tif (!hlist_empty(&sb->s_pins)) {\n\t\t\tup_write(&sb->s_umount);\n\t\t\tgroup_pin_kill(&sb->s_pins);\n\t\t\tdown_write(&sb->s_umount);\n\t\t\tif (!sb->s_root)\n\t\t\t\treturn 0;\n\t\t\tif (sb->s_writers.frozen != SB_UNFROZEN)\n\t\t\t\treturn -EBUSY;\n\t\t\tremount_ro = (flags & MS_RDONLY) && !(sb->s_flags & MS_RDONLY);\n\t\t}\n\t}\n\tshrink_dcache_sb(sb);\n\n\t/* If we are remounting RDONLY and current sb is read/write,\n\t   make sure there are no rw files opened */\n\tif (remount_ro) {\n\t\tif (force) {\n\t\t\tsb->s_readonly_remount = 1;\n\t\t\tsmp_wmb();\n\t\t} else {\n\t\t\tretval = sb_prepare_remount_readonly(sb);\n\t\t\tif (retval)\n\t\t\t\treturn retval;\n\t\t}\n\t}\n\n\tif (sb->s_op->remount_fs) {\n\t\tretval = sb->s_op->remount_fs(sb, &flags, data);\n\t\tif (retval) {\n\t\t\tif (!force)\n\t\t\t\tgoto cancel_readonly;\n\t\t\t/* If forced remount, go ahead despite any errors */\n\t\t\tWARN(1, \"forced remount of a %s fs returned %i\\n\",\n\t\t\t     sb->s_type->name, retval);\n\t\t}\n\t}\n\tsb->s_flags = (sb->s_flags & ~MS_RMT_MASK) | (flags & MS_RMT_MASK);\n\t/* Needs to be ordered wrt mnt_is_readonly() */\n\tsmp_wmb();\n\tsb->s_readonly_remount = 0;\n\n\t/*\n\t * Some filesystems modify their metadata via some other path than the\n\t * bdev buffer cache (eg. use a private mapping, or directories in\n\t * pagecache, etc). Also file data modifications go via their own\n\t * mappings. So If we try to mount readonly then copy the filesystem\n\t * from bdev, we could get stale data, so invalidate it to give a best\n\t * effort at coherency.\n\t */\n\tif (remount_ro && sb->s_bdev)\n\t\tinvalidate_bdev(sb->s_bdev);\n\treturn 0;\n\ncancel_readonly:\n\tsb->s_readonly_remount = 0;\n\treturn retval;\n}"
        }
      },
      {
        "call_info": {
          "callee": "RR_PTR(",
          "args": [
            "rror)"
          ],
          "line": 1080
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "eactivate_locked_super(",
          "args": [
            ")"
          ],
          "line": 1079
        },
        "resolved": true,
        "details": {
          "function_name": "eactivate_locked_super(",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/super.c",
          "lines": "280-301",
          "snippet": "oid deactivate_locked_super(struct super_block *s)\n{\n\tstruct file_system_type *fs = s->s_type;\n\tif (atomic_dec_and_test(&s->s_active)) {\n\t\tcleancache_invalidate_fs(s);\n\t\tunregister_shrinker(&s->s_shrink);\n\t\tfs->kill_sb(s);\n\n\t\t/*\n\t\t * Since list_lru_destroy() may sleep, we cannot call it from\n\t\t * put_super(), where we hold the sb_lock. Therefore we destroy\n\t\t * the lru lists right now.\n\t\t */\n\t\tlist_lru_destroy(&s->s_dentry_lru);\n\t\tlist_lru_destroy(&s->s_inode_lru);\n\n\t\tput_filesystem(fs);\n\t\tput_super(s);\n\t} else {\n\t\tup_write(&s->s_umount);\n\t}\n}",
          "includes": [
            "include \"internal.h\"",
            "include <linux/lockdep.h>\n#",
            "include <linux/fsnotify.h>\n#",
            "include <linux/cleancache.h>\n#",
            "include <linux/rculist_bl.h>\n#",
            "include <linux/backing-dev.h>\n#",
            "include <linux/mutex.h>\n#",
            "include <linux/idr.h>\n#",
            "include <linux/writeback.h>\t\t/* for the emergency remount stuff */\n#",
            "include <linux/security.h>\n#",
            "include <linux/mount.h>\n#",
            "include <linux/blkdev.h>\n#",
            "include <linux/slab.h>\n#",
            "include <linux/export.h>\n#"
          ],
          "macros_used": [],
          "globals_used": [
            "tatic DEFINE_SPINLOCK(sb_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "include \"internal.h\"\ninclude <linux/lockdep.h>\n#\ninclude <linux/fsnotify.h>\n#\ninclude <linux/cleancache.h>\n#\ninclude <linux/rculist_bl.h>\n#\ninclude <linux/backing-dev.h>\n#\ninclude <linux/mutex.h>\n#\ninclude <linux/idr.h>\n#\ninclude <linux/writeback.h>\t\t/* for the emergency remount stuff */\n#\ninclude <linux/security.h>\n#\ninclude <linux/mount.h>\n#\ninclude <linux/blkdev.h>\n#\ninclude <linux/slab.h>\n#\ninclude <linux/export.h>\n#\n\ntatic DEFINE_SPINLOCK(sb_lock);\n\noid deactivate_locked_super(struct super_block *s)\n{\n\tstruct file_system_type *fs = s->s_type;\n\tif (atomic_dec_and_test(&s->s_active)) {\n\t\tcleancache_invalidate_fs(s);\n\t\tunregister_shrinker(&s->s_shrink);\n\t\tfs->kill_sb(s);\n\n\t\t/*\n\t\t * Since list_lru_destroy() may sleep, we cannot call it from\n\t\t * put_super(), where we hold the sb_lock. Therefore we destroy\n\t\t * the lru lists right now.\n\t\t */\n\t\tlist_lru_destroy(&s->s_dentry_lru);\n\t\tlist_lru_destroy(&s->s_inode_lru);\n\n\t\tput_filesystem(fs);\n\t\tput_super(s);\n\t} else {\n\t\tup_write(&s->s_umount);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ill_super(",
          "args": [
            ",",
            "ata,",
            "lags & MS_SILENT ? 1 : 0)"
          ],
          "line": 1077
        },
        "resolved": true,
        "details": {
          "function_name": "_fill_super(stru",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/romfs/super.c",
          "lines": "468-549",
          "snippet": "c int romfs_fill_super(struct super_block *sb, void *data, int silent)\n{\n\tstruct romfs_super_block *rsb;\n\tstruct inode *root;\n\tunsigned long pos, img_size;\n\tconst char *storage;\n\tsize_t len;\n\tint ret;\n\n#ifdef CONFIG_BLOCK\n\tif (!sb->s_mtd) {\n\t\tsb_set_blocksize(sb, ROMBSIZE);\n\t} else {\n\t\tsb->s_blocksize = ROMBSIZE;\n\t\tsb->s_blocksize_bits = blksize_bits(ROMBSIZE);\n\t}\n#endif\n\n\tsb->s_maxbytes = 0xFFFFFFFF;\n\tsb->s_magic = ROMFS_MAGIC;\n\tsb->s_flags |= MS_RDONLY | MS_NOATIME;\n\tsb->s_op = &romfs_super_ops;\n\n\t/* read the image superblock and check it */\n\trsb = kmalloc(512, GFP_KERNEL);\n\tif (!rsb)\n\t\treturn -ENOMEM;\n\n\tsb->s_fs_info = (void *) 512;\n\tret = romfs_dev_read(sb, 0, rsb, 512);\n\tif (ret < 0)\n\t\tgoto error_rsb;\n\n\timg_size = be32_to_cpu(rsb->size);\n\n\tif (sb->s_mtd && img_size > sb->s_mtd->size)\n\t\tgoto error_rsb_inval;\n\n\tsb->s_fs_info = (void *) img_size;\n\n\tif (rsb->word0 != ROMSB_WORD0 || rsb->word1 != ROMSB_WORD1 ||\n\t    img_size < ROMFH_SIZE) {\n\t\tif (!silent)\n\t\t\tpr_warn(\"VFS: Can't find a romfs filesystem on dev %s.\\n\",\n\t\t\t       sb->s_id);\n\t\tgoto error_rsb_inval;\n\t}\n\n\tif (romfs_checksum(rsb, min_t(size_t, img_size, 512))) {\n\t\tpr_err(\"bad initial checksum on dev %s.\\n\", sb->s_id);\n\t\tgoto error_rsb_inval;\n\t}\n\n\tstorage = sb->s_mtd ? \"MTD\" : \"the block layer\";\n\n\tlen = strnlen(rsb->name, ROMFS_MAXFN);\n\tif (!silent)\n\t\tpr_notice(\"Mounting image '%*.*s' through %s\\n\",\n\t\t\t  (unsigned) len, (unsigned) len, rsb->name, storage);\n\n\tkfree(rsb);\n\trsb = NULL;\n\n\t/* find the root directory */\n\tpos = (ROMFH_SIZE + len + 1 + ROMFH_PAD) & ROMFH_MASK;\n\n\troot = romfs_iget(sb, pos);\n\tif (IS_ERR(root))\n\t\treturn PTR_ERR(root);\n\n\tsb->s_root = d_make_root(root);\n\tif (!sb->s_root)\n\t\treturn -ENOMEM;\n\n\treturn 0;\n\nerror_rsb_inval:\n\tret = -EINVAL;\nerror_rsb:\n\tkfree(rsb);\n\treturn ret;\n}\n\n/*",
          "includes": [
            "ude \"internal.h\"\n\nstat",
            "ude <linux/uaccess.h>\n#incl",
            "ude <linux/pagemap.h>\n#incl",
            "ude <linux/highmem.h>\n#incl",
            "ude <linux/ctype.h>\n#incl",
            "ude <linux/mtd/super.h>\n#incl",
            "ude <linux/statfs.h>\n#incl",
            "ude <linux/namei.h>\n#incl",
            "ude <linux/mount.h>\n#incl",
            "ude <linux/parser.h>\n#incl",
            "ude <linux/blkdev.h>\n#incl",
            "ude <linux/init.h>\n#incl",
            "ude <linux/slab.h>\n#incl",
            "ude <linux/time.h>\n#incl",
            "ude <linux/fs.h>\n#incl",
            "ude <linux/string.h>\n#incl",
            "ude <linux/module.h>\n#incl"
          ],
          "macros_used": [],
          "globals_used": [
            "c struct inode *romfs_iget(struct super_block *sb, unsigned long pos);\n\n/*",
            "c const struct super_operations romfs_super_ops = {\n\t.alloc_inode\t= romfs_alloc_inode,\n\t.destroy_inode\t= romfs_destroy_inode,\n\t.statfs\t\t= romfs_statfs,\n\t.remount_fs\t= romfs_remount,\n};\n\n/*"
          ],
          "called_functions": [],
          "contextual_snippet": "ude \"internal.h\"\n\nstat\nude <linux/uaccess.h>\n#incl\nude <linux/pagemap.h>\n#incl\nude <linux/highmem.h>\n#incl\nude <linux/ctype.h>\n#incl\nude <linux/mtd/super.h>\n#incl\nude <linux/statfs.h>\n#incl\nude <linux/namei.h>\n#incl\nude <linux/mount.h>\n#incl\nude <linux/parser.h>\n#incl\nude <linux/blkdev.h>\n#incl\nude <linux/init.h>\n#incl\nude <linux/slab.h>\n#incl\nude <linux/time.h>\n#incl\nude <linux/fs.h>\n#incl\nude <linux/string.h>\n#incl\nude <linux/module.h>\n#incl\n\nc struct inode *romfs_iget(struct super_block *sb, unsigned long pos);\n\n/*;\nc const struct super_operations romfs_super_ops = {\n\t.alloc_inode\t= romfs_alloc_inode,\n\t.destroy_inode\t= romfs_destroy_inode,\n\t.statfs\t\t= romfs_statfs,\n\t.remount_fs\t= romfs_remount,\n};\n\n/*;\n\nc int romfs_fill_super(struct super_block *sb, void *data, int silent)\n{\n\tstruct romfs_super_block *rsb;\n\tstruct inode *root;\n\tunsigned long pos, img_size;\n\tconst char *storage;\n\tsize_t len;\n\tint ret;\n\n#ifdef CONFIG_BLOCK\n\tif (!sb->s_mtd) {\n\t\tsb_set_blocksize(sb, ROMBSIZE);\n\t} else {\n\t\tsb->s_blocksize = ROMBSIZE;\n\t\tsb->s_blocksize_bits = blksize_bits(ROMBSIZE);\n\t}\n#endif\n\n\tsb->s_maxbytes = 0xFFFFFFFF;\n\tsb->s_magic = ROMFS_MAGIC;\n\tsb->s_flags |= MS_RDONLY | MS_NOATIME;\n\tsb->s_op = &romfs_super_ops;\n\n\t/* read the image superblock and check it */\n\trsb = kmalloc(512, GFP_KERNEL);\n\tif (!rsb)\n\t\treturn -ENOMEM;\n\n\tsb->s_fs_info = (void *) 512;\n\tret = romfs_dev_read(sb, 0, rsb, 512);\n\tif (ret < 0)\n\t\tgoto error_rsb;\n\n\timg_size = be32_to_cpu(rsb->size);\n\n\tif (sb->s_mtd && img_size > sb->s_mtd->size)\n\t\tgoto error_rsb_inval;\n\n\tsb->s_fs_info = (void *) img_size;\n\n\tif (rsb->word0 != ROMSB_WORD0 || rsb->word1 != ROMSB_WORD1 ||\n\t    img_size < ROMFH_SIZE) {\n\t\tif (!silent)\n\t\t\tpr_warn(\"VFS: Can't find a romfs filesystem on dev %s.\\n\",\n\t\t\t       sb->s_id);\n\t\tgoto error_rsb_inval;\n\t}\n\n\tif (romfs_checksum(rsb, min_t(size_t, img_size, 512))) {\n\t\tpr_err(\"bad initial checksum on dev %s.\\n\", sb->s_id);\n\t\tgoto error_rsb_inval;\n\t}\n\n\tstorage = sb->s_mtd ? \"MTD\" : \"the block layer\";\n\n\tlen = strnlen(rsb->name, ROMFS_MAXFN);\n\tif (!silent)\n\t\tpr_notice(\"Mounting image '%*.*s' through %s\\n\",\n\t\t\t  (unsigned) len, (unsigned) len, rsb->name, storage);\n\n\tkfree(rsb);\n\trsb = NULL;\n\n\t/* find the root directory */\n\tpos = (ROMFH_SIZE + len + 1 + ROMFH_PAD) & ROMFH_MASK;\n\n\troot = romfs_iget(sb, pos);\n\tif (IS_ERR(root))\n\t\treturn PTR_ERR(root);\n\n\tsb->s_root = d_make_root(root);\n\tif (!sb->s_root)\n\t\treturn -ENOMEM;\n\n\treturn 0;\n\nerror_rsb_inval:\n\tret = -EINVAL;\nerror_rsb:\n\tkfree(rsb);\n\treturn ret;\n}\n\n/*"
        }
      },
      {
        "call_info": {
          "callee": "RR_CAST(",
          "args": [
            ")"
          ],
          "line": 1075
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ERR(",
          "args": [
            ")"
          ],
          "line": 1074
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get(",
          "args": [
            "s_type,",
            "ompare_single,",
            "et_anon_super,",
            "lags,",
            "ULL)"
          ],
          "line": 1073
        },
        "resolved": true,
        "details": {
          "function_name": "get(",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/super.c",
          "lines": "437-486",
          "snippet": "truct super_block *sget(struct file_system_type *type,\n\t\t\tint (*test)(struct super_block *,void *),\n\t\t\tint (*set)(struct super_block *,void *),\n\t\t\tint flags,\n\t\t\tvoid *data)\n{\n\tstruct super_block *s = NULL;\n\tstruct super_block *old;\n\tint err;\n\nretry:\n\tspin_lock(&sb_lock);\n\tif (test) {\n\t\thlist_for_each_entry(old, &type->fs_supers, s_instances) {\n\t\t\tif (!test(old, data))\n\t\t\t\tcontinue;\n\t\t\tif (!grab_super(old))\n\t\t\t\tgoto retry;\n\t\t\tif (s) {\n\t\t\t\tup_write(&s->s_umount);\n\t\t\t\tdestroy_super(s);\n\t\t\t\ts = NULL;\n\t\t\t}\n\t\t\treturn old;\n\t\t}\n\t}\n\tif (!s) {\n\t\tspin_unlock(&sb_lock);\n\t\ts = alloc_super(type, flags);\n\t\tif (!s)\n\t\t\treturn ERR_PTR(-ENOMEM);\n\t\tgoto retry;\n\t}\n\t\t\n\terr = set(s, data);\n\tif (err) {\n\t\tspin_unlock(&sb_lock);\n\t\tup_write(&s->s_umount);\n\t\tdestroy_super(s);\n\t\treturn ERR_PTR(err);\n\t}\n\ts->s_type = type;\n\tstrlcpy(s->s_id, type->name, sizeof(s->s_id));\n\tlist_add_tail(&s->s_list, &super_blocks);\n\thlist_add_head(&s->s_instances, &type->fs_supers);\n\tspin_unlock(&sb_lock);\n\tget_filesystem(type);\n\tregister_shrinker(&s->s_shrink);\n\treturn s;\n}",
          "includes": [
            "include \"internal.h\"",
            "include <linux/lockdep.h>\n#",
            "include <linux/fsnotify.h>\n#",
            "include <linux/cleancache.h>\n#",
            "include <linux/rculist_bl.h>\n#",
            "include <linux/backing-dev.h>\n#",
            "include <linux/mutex.h>\n#",
            "include <linux/idr.h>\n#",
            "include <linux/writeback.h>\t\t/* for the emergency remount stuff */\n#",
            "include <linux/security.h>\n#",
            "include <linux/mount.h>\n#",
            "include <linux/blkdev.h>\n#",
            "include <linux/slab.h>\n#",
            "include <linux/export.h>\n#"
          ],
          "macros_used": [],
          "globals_used": [
            "tatic LIST_HEAD(super_blocks);",
            "tatic DEFINE_SPINLOCK(sb_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "include \"internal.h\"\ninclude <linux/lockdep.h>\n#\ninclude <linux/fsnotify.h>\n#\ninclude <linux/cleancache.h>\n#\ninclude <linux/rculist_bl.h>\n#\ninclude <linux/backing-dev.h>\n#\ninclude <linux/mutex.h>\n#\ninclude <linux/idr.h>\n#\ninclude <linux/writeback.h>\t\t/* for the emergency remount stuff */\n#\ninclude <linux/security.h>\n#\ninclude <linux/mount.h>\n#\ninclude <linux/blkdev.h>\n#\ninclude <linux/slab.h>\n#\ninclude <linux/export.h>\n#\n\ntatic LIST_HEAD(super_blocks);\ntatic DEFINE_SPINLOCK(sb_lock);\n\ntruct super_block *sget(struct file_system_type *type,\n\t\t\tint (*test)(struct super_block *,void *),\n\t\t\tint (*set)(struct super_block *,void *),\n\t\t\tint flags,\n\t\t\tvoid *data)\n{\n\tstruct super_block *s = NULL;\n\tstruct super_block *old;\n\tint err;\n\nretry:\n\tspin_lock(&sb_lock);\n\tif (test) {\n\t\thlist_for_each_entry(old, &type->fs_supers, s_instances) {\n\t\t\tif (!test(old, data))\n\t\t\t\tcontinue;\n\t\t\tif (!grab_super(old))\n\t\t\t\tgoto retry;\n\t\t\tif (s) {\n\t\t\t\tup_write(&s->s_umount);\n\t\t\t\tdestroy_super(s);\n\t\t\t\ts = NULL;\n\t\t\t}\n\t\t\treturn old;\n\t\t}\n\t}\n\tif (!s) {\n\t\tspin_unlock(&sb_lock);\n\t\ts = alloc_super(type, flags);\n\t\tif (!s)\n\t\t\treturn ERR_PTR(-ENOMEM);\n\t\tgoto retry;\n\t}\n\t\t\n\terr = set(s, data);\n\tif (err) {\n\t\tspin_unlock(&sb_lock);\n\t\tup_write(&s->s_umount);\n\t\tdestroy_super(s);\n\t\treturn ERR_PTR(err);\n\t}\n\ts->s_type = type;\n\tstrlcpy(s->s_id, type->name, sizeof(s->s_id));\n\tlist_add_tail(&s->s_list, &super_blocks);\n\thlist_add_head(&s->s_instances, &type->fs_supers);\n\tspin_unlock(&sb_lock);\n\tget_filesystem(type);\n\tregister_shrinker(&s->s_shrink);\n\treturn s;\n}"
        }
      }
    ],
    "contextual_snippet": "include \"internal.h\"\ninclude <linux/lockdep.h>\n#\ninclude <linux/fsnotify.h>\n#\ninclude <linux/cleancache.h>\n#\ninclude <linux/rculist_bl.h>\n#\ninclude <linux/backing-dev.h>\n#\ninclude <linux/mutex.h>\n#\ninclude <linux/idr.h>\n#\ninclude <linux/writeback.h>\t\t/* for the emergency remount stuff */\n#\ninclude <linux/security.h>\n#\ninclude <linux/mount.h>\n#\ninclude <linux/blkdev.h>\n#\ninclude <linux/slab.h>\n#\ninclude <linux/export.h>\n#\n\ntruct dentry *mount_single(struct file_system_type *fs_type,\n\tint flags, void *data,\n\tint (*fill_super)(struct super_block *, void *, int))\n{\n\tstruct super_block *s;\n\tint error;\n\n\ts = sget(fs_type, compare_single, set_anon_super, flags, NULL);\n\tif (IS_ERR(s))\n\t\treturn ERR_CAST(s);\n\tif (!s->s_root) {\n\t\terror = fill_super(s, data, flags & MS_SILENT ? 1 : 0);\n\t\tif (error) {\n\t\t\tdeactivate_locked_super(s);\n\t\t\treturn ERR_PTR(error);\n\t\t}\n\t\ts->s_flags |= MS_ACTIVE;\n\t} else {\n\t\tdo_remount_sb(s, flags, data, 0);\n\t}\n\treturn dget(s->s_root);\n}"
  },
  {
    "function_name": "ompare_single(",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/super.c",
    "lines": "1061-1064",
    "snippet": "tatic int compare_single(struct super_block *s, void *p)\n{\n\treturn 1;\n}",
    "includes": [
      "include \"internal.h\"",
      "include <linux/lockdep.h>\n#",
      "include <linux/fsnotify.h>\n#",
      "include <linux/cleancache.h>\n#",
      "include <linux/rculist_bl.h>\n#",
      "include <linux/backing-dev.h>\n#",
      "include <linux/mutex.h>\n#",
      "include <linux/idr.h>\n#",
      "include <linux/writeback.h>\t\t/* for the emergency remount stuff */\n#",
      "include <linux/security.h>\n#",
      "include <linux/mount.h>\n#",
      "include <linux/blkdev.h>\n#",
      "include <linux/slab.h>\n#",
      "include <linux/export.h>\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "include \"internal.h\"\ninclude <linux/lockdep.h>\n#\ninclude <linux/fsnotify.h>\n#\ninclude <linux/cleancache.h>\n#\ninclude <linux/rculist_bl.h>\n#\ninclude <linux/backing-dev.h>\n#\ninclude <linux/mutex.h>\n#\ninclude <linux/idr.h>\n#\ninclude <linux/writeback.h>\t\t/* for the emergency remount stuff */\n#\ninclude <linux/security.h>\n#\ninclude <linux/mount.h>\n#\ninclude <linux/blkdev.h>\n#\ninclude <linux/slab.h>\n#\ninclude <linux/export.h>\n#\n\ntatic int compare_single(struct super_block *s, void *p)\n{\n\treturn 1;\n}"
  },
  {
    "function_name": "ount_nodev(",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/super.c",
    "lines": "1041-1058",
    "snippet": "truct dentry *mount_nodev(struct file_system_type *fs_type,\n\tint flags, void *data,\n\tint (*fill_super)(struct super_block *, void *, int))\n{\n\tint error;\n\tstruct super_block *s = sget(fs_type, NULL, set_anon_super, flags, NULL);\n\n\tif (IS_ERR(s))\n\t\treturn ERR_CAST(s);\n\n\terror = fill_super(s, data, flags & MS_SILENT ? 1 : 0);\n\tif (error) {\n\t\tdeactivate_locked_super(s);\n\t\treturn ERR_PTR(error);\n\t}\n\ts->s_flags |= MS_ACTIVE;\n\treturn dget(s->s_root);\n}",
    "includes": [
      "include \"internal.h\"",
      "include <linux/lockdep.h>\n#",
      "include <linux/fsnotify.h>\n#",
      "include <linux/cleancache.h>\n#",
      "include <linux/rculist_bl.h>\n#",
      "include <linux/backing-dev.h>\n#",
      "include <linux/mutex.h>\n#",
      "include <linux/idr.h>\n#",
      "include <linux/writeback.h>\t\t/* for the emergency remount stuff */\n#",
      "include <linux/security.h>\n#",
      "include <linux/mount.h>\n#",
      "include <linux/blkdev.h>\n#",
      "include <linux/slab.h>\n#",
      "include <linux/export.h>\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "get(",
          "args": [
            "->s_root)"
          ],
          "line": 1057
        },
        "resolved": true,
        "details": {
          "function_name": "ing_page_budget(struct ubifs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ubifs/file.c",
          "lines": "214-219",
          "snippet": "elease_existing_page_budget(struct ubifs_info *c)\n{\n\tstruct ubifs_budget_req req = { .dd_growth = c->bi.page_budget};\n\n\tubifs_release_budget(c, &req);\n}\n\nstatic int",
          "includes": [
            "ux/slab.h>\n\nstatic int r",
            "ux/namei.h>\n#include <lin",
            "ux/mount.h>\n#include <lin",
            "ux/aio.h>\n#include <lin",
            "fs.h\"\n#include <lin"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "ux/slab.h>\n\nstatic int r\nux/namei.h>\n#include <lin\nux/mount.h>\n#include <lin\nux/aio.h>\n#include <lin\nfs.h\"\n#include <lin\n\nelease_existing_page_budget(struct ubifs_info *c)\n{\n\tstruct ubifs_budget_req req = { .dd_growth = c->bi.page_budget};\n\n\tubifs_release_budget(c, &req);\n}\n\nstatic int"
        }
      },
      {
        "call_info": {
          "callee": "RR_PTR(",
          "args": [
            "rror)"
          ],
          "line": 1054
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "eactivate_locked_super(",
          "args": [
            ")"
          ],
          "line": 1053
        },
        "resolved": true,
        "details": {
          "function_name": "eactivate_locked_super(",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/super.c",
          "lines": "280-301",
          "snippet": "oid deactivate_locked_super(struct super_block *s)\n{\n\tstruct file_system_type *fs = s->s_type;\n\tif (atomic_dec_and_test(&s->s_active)) {\n\t\tcleancache_invalidate_fs(s);\n\t\tunregister_shrinker(&s->s_shrink);\n\t\tfs->kill_sb(s);\n\n\t\t/*\n\t\t * Since list_lru_destroy() may sleep, we cannot call it from\n\t\t * put_super(), where we hold the sb_lock. Therefore we destroy\n\t\t * the lru lists right now.\n\t\t */\n\t\tlist_lru_destroy(&s->s_dentry_lru);\n\t\tlist_lru_destroy(&s->s_inode_lru);\n\n\t\tput_filesystem(fs);\n\t\tput_super(s);\n\t} else {\n\t\tup_write(&s->s_umount);\n\t}\n}",
          "includes": [
            "include \"internal.h\"",
            "include <linux/lockdep.h>\n#",
            "include <linux/fsnotify.h>\n#",
            "include <linux/cleancache.h>\n#",
            "include <linux/rculist_bl.h>\n#",
            "include <linux/backing-dev.h>\n#",
            "include <linux/mutex.h>\n#",
            "include <linux/idr.h>\n#",
            "include <linux/writeback.h>\t\t/* for the emergency remount stuff */\n#",
            "include <linux/security.h>\n#",
            "include <linux/mount.h>\n#",
            "include <linux/blkdev.h>\n#",
            "include <linux/slab.h>\n#",
            "include <linux/export.h>\n#"
          ],
          "macros_used": [],
          "globals_used": [
            "tatic DEFINE_SPINLOCK(sb_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "include \"internal.h\"\ninclude <linux/lockdep.h>\n#\ninclude <linux/fsnotify.h>\n#\ninclude <linux/cleancache.h>\n#\ninclude <linux/rculist_bl.h>\n#\ninclude <linux/backing-dev.h>\n#\ninclude <linux/mutex.h>\n#\ninclude <linux/idr.h>\n#\ninclude <linux/writeback.h>\t\t/* for the emergency remount stuff */\n#\ninclude <linux/security.h>\n#\ninclude <linux/mount.h>\n#\ninclude <linux/blkdev.h>\n#\ninclude <linux/slab.h>\n#\ninclude <linux/export.h>\n#\n\ntatic DEFINE_SPINLOCK(sb_lock);\n\noid deactivate_locked_super(struct super_block *s)\n{\n\tstruct file_system_type *fs = s->s_type;\n\tif (atomic_dec_and_test(&s->s_active)) {\n\t\tcleancache_invalidate_fs(s);\n\t\tunregister_shrinker(&s->s_shrink);\n\t\tfs->kill_sb(s);\n\n\t\t/*\n\t\t * Since list_lru_destroy() may sleep, we cannot call it from\n\t\t * put_super(), where we hold the sb_lock. Therefore we destroy\n\t\t * the lru lists right now.\n\t\t */\n\t\tlist_lru_destroy(&s->s_dentry_lru);\n\t\tlist_lru_destroy(&s->s_inode_lru);\n\n\t\tput_filesystem(fs);\n\t\tput_super(s);\n\t} else {\n\t\tup_write(&s->s_umount);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ill_super(",
          "args": [
            ",",
            "ata,",
            "lags & MS_SILENT ? 1 : 0)"
          ],
          "line": 1051
        },
        "resolved": true,
        "details": {
          "function_name": "_fill_super(stru",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/romfs/super.c",
          "lines": "468-549",
          "snippet": "c int romfs_fill_super(struct super_block *sb, void *data, int silent)\n{\n\tstruct romfs_super_block *rsb;\n\tstruct inode *root;\n\tunsigned long pos, img_size;\n\tconst char *storage;\n\tsize_t len;\n\tint ret;\n\n#ifdef CONFIG_BLOCK\n\tif (!sb->s_mtd) {\n\t\tsb_set_blocksize(sb, ROMBSIZE);\n\t} else {\n\t\tsb->s_blocksize = ROMBSIZE;\n\t\tsb->s_blocksize_bits = blksize_bits(ROMBSIZE);\n\t}\n#endif\n\n\tsb->s_maxbytes = 0xFFFFFFFF;\n\tsb->s_magic = ROMFS_MAGIC;\n\tsb->s_flags |= MS_RDONLY | MS_NOATIME;\n\tsb->s_op = &romfs_super_ops;\n\n\t/* read the image superblock and check it */\n\trsb = kmalloc(512, GFP_KERNEL);\n\tif (!rsb)\n\t\treturn -ENOMEM;\n\n\tsb->s_fs_info = (void *) 512;\n\tret = romfs_dev_read(sb, 0, rsb, 512);\n\tif (ret < 0)\n\t\tgoto error_rsb;\n\n\timg_size = be32_to_cpu(rsb->size);\n\n\tif (sb->s_mtd && img_size > sb->s_mtd->size)\n\t\tgoto error_rsb_inval;\n\n\tsb->s_fs_info = (void *) img_size;\n\n\tif (rsb->word0 != ROMSB_WORD0 || rsb->word1 != ROMSB_WORD1 ||\n\t    img_size < ROMFH_SIZE) {\n\t\tif (!silent)\n\t\t\tpr_warn(\"VFS: Can't find a romfs filesystem on dev %s.\\n\",\n\t\t\t       sb->s_id);\n\t\tgoto error_rsb_inval;\n\t}\n\n\tif (romfs_checksum(rsb, min_t(size_t, img_size, 512))) {\n\t\tpr_err(\"bad initial checksum on dev %s.\\n\", sb->s_id);\n\t\tgoto error_rsb_inval;\n\t}\n\n\tstorage = sb->s_mtd ? \"MTD\" : \"the block layer\";\n\n\tlen = strnlen(rsb->name, ROMFS_MAXFN);\n\tif (!silent)\n\t\tpr_notice(\"Mounting image '%*.*s' through %s\\n\",\n\t\t\t  (unsigned) len, (unsigned) len, rsb->name, storage);\n\n\tkfree(rsb);\n\trsb = NULL;\n\n\t/* find the root directory */\n\tpos = (ROMFH_SIZE + len + 1 + ROMFH_PAD) & ROMFH_MASK;\n\n\troot = romfs_iget(sb, pos);\n\tif (IS_ERR(root))\n\t\treturn PTR_ERR(root);\n\n\tsb->s_root = d_make_root(root);\n\tif (!sb->s_root)\n\t\treturn -ENOMEM;\n\n\treturn 0;\n\nerror_rsb_inval:\n\tret = -EINVAL;\nerror_rsb:\n\tkfree(rsb);\n\treturn ret;\n}\n\n/*",
          "includes": [
            "ude \"internal.h\"\n\nstat",
            "ude <linux/uaccess.h>\n#incl",
            "ude <linux/pagemap.h>\n#incl",
            "ude <linux/highmem.h>\n#incl",
            "ude <linux/ctype.h>\n#incl",
            "ude <linux/mtd/super.h>\n#incl",
            "ude <linux/statfs.h>\n#incl",
            "ude <linux/namei.h>\n#incl",
            "ude <linux/mount.h>\n#incl",
            "ude <linux/parser.h>\n#incl",
            "ude <linux/blkdev.h>\n#incl",
            "ude <linux/init.h>\n#incl",
            "ude <linux/slab.h>\n#incl",
            "ude <linux/time.h>\n#incl",
            "ude <linux/fs.h>\n#incl",
            "ude <linux/string.h>\n#incl",
            "ude <linux/module.h>\n#incl"
          ],
          "macros_used": [],
          "globals_used": [
            "c struct inode *romfs_iget(struct super_block *sb, unsigned long pos);\n\n/*",
            "c const struct super_operations romfs_super_ops = {\n\t.alloc_inode\t= romfs_alloc_inode,\n\t.destroy_inode\t= romfs_destroy_inode,\n\t.statfs\t\t= romfs_statfs,\n\t.remount_fs\t= romfs_remount,\n};\n\n/*"
          ],
          "called_functions": [],
          "contextual_snippet": "ude \"internal.h\"\n\nstat\nude <linux/uaccess.h>\n#incl\nude <linux/pagemap.h>\n#incl\nude <linux/highmem.h>\n#incl\nude <linux/ctype.h>\n#incl\nude <linux/mtd/super.h>\n#incl\nude <linux/statfs.h>\n#incl\nude <linux/namei.h>\n#incl\nude <linux/mount.h>\n#incl\nude <linux/parser.h>\n#incl\nude <linux/blkdev.h>\n#incl\nude <linux/init.h>\n#incl\nude <linux/slab.h>\n#incl\nude <linux/time.h>\n#incl\nude <linux/fs.h>\n#incl\nude <linux/string.h>\n#incl\nude <linux/module.h>\n#incl\n\nc struct inode *romfs_iget(struct super_block *sb, unsigned long pos);\n\n/*;\nc const struct super_operations romfs_super_ops = {\n\t.alloc_inode\t= romfs_alloc_inode,\n\t.destroy_inode\t= romfs_destroy_inode,\n\t.statfs\t\t= romfs_statfs,\n\t.remount_fs\t= romfs_remount,\n};\n\n/*;\n\nc int romfs_fill_super(struct super_block *sb, void *data, int silent)\n{\n\tstruct romfs_super_block *rsb;\n\tstruct inode *root;\n\tunsigned long pos, img_size;\n\tconst char *storage;\n\tsize_t len;\n\tint ret;\n\n#ifdef CONFIG_BLOCK\n\tif (!sb->s_mtd) {\n\t\tsb_set_blocksize(sb, ROMBSIZE);\n\t} else {\n\t\tsb->s_blocksize = ROMBSIZE;\n\t\tsb->s_blocksize_bits = blksize_bits(ROMBSIZE);\n\t}\n#endif\n\n\tsb->s_maxbytes = 0xFFFFFFFF;\n\tsb->s_magic = ROMFS_MAGIC;\n\tsb->s_flags |= MS_RDONLY | MS_NOATIME;\n\tsb->s_op = &romfs_super_ops;\n\n\t/* read the image superblock and check it */\n\trsb = kmalloc(512, GFP_KERNEL);\n\tif (!rsb)\n\t\treturn -ENOMEM;\n\n\tsb->s_fs_info = (void *) 512;\n\tret = romfs_dev_read(sb, 0, rsb, 512);\n\tif (ret < 0)\n\t\tgoto error_rsb;\n\n\timg_size = be32_to_cpu(rsb->size);\n\n\tif (sb->s_mtd && img_size > sb->s_mtd->size)\n\t\tgoto error_rsb_inval;\n\n\tsb->s_fs_info = (void *) img_size;\n\n\tif (rsb->word0 != ROMSB_WORD0 || rsb->word1 != ROMSB_WORD1 ||\n\t    img_size < ROMFH_SIZE) {\n\t\tif (!silent)\n\t\t\tpr_warn(\"VFS: Can't find a romfs filesystem on dev %s.\\n\",\n\t\t\t       sb->s_id);\n\t\tgoto error_rsb_inval;\n\t}\n\n\tif (romfs_checksum(rsb, min_t(size_t, img_size, 512))) {\n\t\tpr_err(\"bad initial checksum on dev %s.\\n\", sb->s_id);\n\t\tgoto error_rsb_inval;\n\t}\n\n\tstorage = sb->s_mtd ? \"MTD\" : \"the block layer\";\n\n\tlen = strnlen(rsb->name, ROMFS_MAXFN);\n\tif (!silent)\n\t\tpr_notice(\"Mounting image '%*.*s' through %s\\n\",\n\t\t\t  (unsigned) len, (unsigned) len, rsb->name, storage);\n\n\tkfree(rsb);\n\trsb = NULL;\n\n\t/* find the root directory */\n\tpos = (ROMFH_SIZE + len + 1 + ROMFH_PAD) & ROMFH_MASK;\n\n\troot = romfs_iget(sb, pos);\n\tif (IS_ERR(root))\n\t\treturn PTR_ERR(root);\n\n\tsb->s_root = d_make_root(root);\n\tif (!sb->s_root)\n\t\treturn -ENOMEM;\n\n\treturn 0;\n\nerror_rsb_inval:\n\tret = -EINVAL;\nerror_rsb:\n\tkfree(rsb);\n\treturn ret;\n}\n\n/*"
        }
      },
      {
        "call_info": {
          "callee": "RR_CAST(",
          "args": [
            ")"
          ],
          "line": 1049
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ERR(",
          "args": [
            ")"
          ],
          "line": 1048
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get(",
          "args": [
            "s_type,",
            "ULL,",
            "et_anon_super,",
            "lags,",
            "ULL)"
          ],
          "line": 1046
        },
        "resolved": true,
        "details": {
          "function_name": "get(",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/super.c",
          "lines": "437-486",
          "snippet": "truct super_block *sget(struct file_system_type *type,\n\t\t\tint (*test)(struct super_block *,void *),\n\t\t\tint (*set)(struct super_block *,void *),\n\t\t\tint flags,\n\t\t\tvoid *data)\n{\n\tstruct super_block *s = NULL;\n\tstruct super_block *old;\n\tint err;\n\nretry:\n\tspin_lock(&sb_lock);\n\tif (test) {\n\t\thlist_for_each_entry(old, &type->fs_supers, s_instances) {\n\t\t\tif (!test(old, data))\n\t\t\t\tcontinue;\n\t\t\tif (!grab_super(old))\n\t\t\t\tgoto retry;\n\t\t\tif (s) {\n\t\t\t\tup_write(&s->s_umount);\n\t\t\t\tdestroy_super(s);\n\t\t\t\ts = NULL;\n\t\t\t}\n\t\t\treturn old;\n\t\t}\n\t}\n\tif (!s) {\n\t\tspin_unlock(&sb_lock);\n\t\ts = alloc_super(type, flags);\n\t\tif (!s)\n\t\t\treturn ERR_PTR(-ENOMEM);\n\t\tgoto retry;\n\t}\n\t\t\n\terr = set(s, data);\n\tif (err) {\n\t\tspin_unlock(&sb_lock);\n\t\tup_write(&s->s_umount);\n\t\tdestroy_super(s);\n\t\treturn ERR_PTR(err);\n\t}\n\ts->s_type = type;\n\tstrlcpy(s->s_id, type->name, sizeof(s->s_id));\n\tlist_add_tail(&s->s_list, &super_blocks);\n\thlist_add_head(&s->s_instances, &type->fs_supers);\n\tspin_unlock(&sb_lock);\n\tget_filesystem(type);\n\tregister_shrinker(&s->s_shrink);\n\treturn s;\n}",
          "includes": [
            "include \"internal.h\"",
            "include <linux/lockdep.h>\n#",
            "include <linux/fsnotify.h>\n#",
            "include <linux/cleancache.h>\n#",
            "include <linux/rculist_bl.h>\n#",
            "include <linux/backing-dev.h>\n#",
            "include <linux/mutex.h>\n#",
            "include <linux/idr.h>\n#",
            "include <linux/writeback.h>\t\t/* for the emergency remount stuff */\n#",
            "include <linux/security.h>\n#",
            "include <linux/mount.h>\n#",
            "include <linux/blkdev.h>\n#",
            "include <linux/slab.h>\n#",
            "include <linux/export.h>\n#"
          ],
          "macros_used": [],
          "globals_used": [
            "tatic LIST_HEAD(super_blocks);",
            "tatic DEFINE_SPINLOCK(sb_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "include \"internal.h\"\ninclude <linux/lockdep.h>\n#\ninclude <linux/fsnotify.h>\n#\ninclude <linux/cleancache.h>\n#\ninclude <linux/rculist_bl.h>\n#\ninclude <linux/backing-dev.h>\n#\ninclude <linux/mutex.h>\n#\ninclude <linux/idr.h>\n#\ninclude <linux/writeback.h>\t\t/* for the emergency remount stuff */\n#\ninclude <linux/security.h>\n#\ninclude <linux/mount.h>\n#\ninclude <linux/blkdev.h>\n#\ninclude <linux/slab.h>\n#\ninclude <linux/export.h>\n#\n\ntatic LIST_HEAD(super_blocks);\ntatic DEFINE_SPINLOCK(sb_lock);\n\ntruct super_block *sget(struct file_system_type *type,\n\t\t\tint (*test)(struct super_block *,void *),\n\t\t\tint (*set)(struct super_block *,void *),\n\t\t\tint flags,\n\t\t\tvoid *data)\n{\n\tstruct super_block *s = NULL;\n\tstruct super_block *old;\n\tint err;\n\nretry:\n\tspin_lock(&sb_lock);\n\tif (test) {\n\t\thlist_for_each_entry(old, &type->fs_supers, s_instances) {\n\t\t\tif (!test(old, data))\n\t\t\t\tcontinue;\n\t\t\tif (!grab_super(old))\n\t\t\t\tgoto retry;\n\t\t\tif (s) {\n\t\t\t\tup_write(&s->s_umount);\n\t\t\t\tdestroy_super(s);\n\t\t\t\ts = NULL;\n\t\t\t}\n\t\t\treturn old;\n\t\t}\n\t}\n\tif (!s) {\n\t\tspin_unlock(&sb_lock);\n\t\ts = alloc_super(type, flags);\n\t\tif (!s)\n\t\t\treturn ERR_PTR(-ENOMEM);\n\t\tgoto retry;\n\t}\n\t\t\n\terr = set(s, data);\n\tif (err) {\n\t\tspin_unlock(&sb_lock);\n\t\tup_write(&s->s_umount);\n\t\tdestroy_super(s);\n\t\treturn ERR_PTR(err);\n\t}\n\ts->s_type = type;\n\tstrlcpy(s->s_id, type->name, sizeof(s->s_id));\n\tlist_add_tail(&s->s_list, &super_blocks);\n\thlist_add_head(&s->s_instances, &type->fs_supers);\n\tspin_unlock(&sb_lock);\n\tget_filesystem(type);\n\tregister_shrinker(&s->s_shrink);\n\treturn s;\n}"
        }
      }
    ],
    "contextual_snippet": "include \"internal.h\"\ninclude <linux/lockdep.h>\n#\ninclude <linux/fsnotify.h>\n#\ninclude <linux/cleancache.h>\n#\ninclude <linux/rculist_bl.h>\n#\ninclude <linux/backing-dev.h>\n#\ninclude <linux/mutex.h>\n#\ninclude <linux/idr.h>\n#\ninclude <linux/writeback.h>\t\t/* for the emergency remount stuff */\n#\ninclude <linux/security.h>\n#\ninclude <linux/mount.h>\n#\ninclude <linux/blkdev.h>\n#\ninclude <linux/slab.h>\n#\ninclude <linux/export.h>\n#\n\ntruct dentry *mount_nodev(struct file_system_type *fs_type,\n\tint flags, void *data,\n\tint (*fill_super)(struct super_block *, void *, int))\n{\n\tint error;\n\tstruct super_block *s = sget(fs_type, NULL, set_anon_super, flags, NULL);\n\n\tif (IS_ERR(s))\n\t\treturn ERR_CAST(s);\n\n\terror = fill_super(s, data, flags & MS_SILENT ? 1 : 0);\n\tif (error) {\n\t\tdeactivate_locked_super(s);\n\t\treturn ERR_PTR(error);\n\t}\n\ts->s_flags |= MS_ACTIVE;\n\treturn dget(s->s_root);\n}"
  },
  {
    "function_name": "ill_block_super(",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/super.c",
    "lines": "1026-1036",
    "snippet": "oid kill_block_super(struct super_block *sb)\n{\n\tstruct block_device *bdev = sb->s_bdev;\n\tfmode_t mode = sb->s_mode;\n\n\tbdev->bd_super = NULL;\n\tgeneric_shutdown_super(sb);\n\tsync_blockdev(bdev);\n\tWARN_ON_ONCE(!(mode & FMODE_EXCL));\n\tblkdev_put(bdev, mode | FMODE_EXCL);\n}",
    "includes": [
      "include \"internal.h\"",
      "include <linux/lockdep.h>\n#",
      "include <linux/fsnotify.h>\n#",
      "include <linux/cleancache.h>\n#",
      "include <linux/rculist_bl.h>\n#",
      "include <linux/backing-dev.h>\n#",
      "include <linux/mutex.h>\n#",
      "include <linux/idr.h>\n#",
      "include <linux/writeback.h>\t\t/* for the emergency remount stuff */\n#",
      "include <linux/security.h>\n#",
      "include <linux/mount.h>\n#",
      "include <linux/blkdev.h>\n#",
      "include <linux/slab.h>\n#",
      "include <linux/export.h>\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "lkdev_put(",
          "args": [
            "dev,",
            "ode | FMODE_EXCL)"
          ],
          "line": 1035
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ARN_ON_ONCE(",
          "args": [
            "(mode & FMODE_EXCL))"
          ],
          "line": 1034
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ync_blockdev(",
          "args": [
            "dev)"
          ],
          "line": 1033
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "eneric_shutdown_super(",
          "args": [
            "b)"
          ],
          "line": 1032
        },
        "resolved": true,
        "details": {
          "function_name": "eneric_shutdown_super(",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/super.c",
          "lines": "393-425",
          "snippet": "oid generic_shutdown_super(struct super_block *sb)\n{\n\tconst struct super_operations *sop = sb->s_op;\n\n\tif (sb->s_root) {\n\t\tshrink_dcache_for_umount(sb);\n\t\tsync_filesystem(sb);\n\t\tsb->s_flags &= ~MS_ACTIVE;\n\n\t\tfsnotify_unmount_inodes(&sb->s_inodes);\n\n\t\tevict_inodes(sb);\n\n\t\tif (sb->s_dio_done_wq) {\n\t\t\tdestroy_workqueue(sb->s_dio_done_wq);\n\t\t\tsb->s_dio_done_wq = NULL;\n\t\t}\n\n\t\tif (sop->put_super)\n\t\t\tsop->put_super(sb);\n\n\t\tif (!list_empty(&sb->s_inodes)) {\n\t\t\tprintk(\"VFS: Busy inodes after unmount of %s. \"\n\t\t\t   \"Self-destruct in 5 seconds.  Have a nice day...\\n\",\n\t\t\t   sb->s_id);\n\t\t}\n\t}\n\tspin_lock(&sb_lock);\n\t/* should be initialized for __put_super_and_need_restart() */\n\thlist_del_init(&sb->s_instances);\n\tspin_unlock(&sb_lock);\n\tup_write(&sb->s_umount);\n}",
          "includes": [
            "include \"internal.h\"",
            "include <linux/lockdep.h>\n#",
            "include <linux/fsnotify.h>\n#",
            "include <linux/cleancache.h>\n#",
            "include <linux/rculist_bl.h>\n#",
            "include <linux/backing-dev.h>\n#",
            "include <linux/mutex.h>\n#",
            "include <linux/idr.h>\n#",
            "include <linux/writeback.h>\t\t/* for the emergency remount stuff */\n#",
            "include <linux/security.h>\n#",
            "include <linux/mount.h>\n#",
            "include <linux/blkdev.h>\n#",
            "include <linux/slab.h>\n#",
            "include <linux/export.h>\n#"
          ],
          "macros_used": [],
          "globals_used": [
            "tatic DEFINE_SPINLOCK(sb_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "include \"internal.h\"\ninclude <linux/lockdep.h>\n#\ninclude <linux/fsnotify.h>\n#\ninclude <linux/cleancache.h>\n#\ninclude <linux/rculist_bl.h>\n#\ninclude <linux/backing-dev.h>\n#\ninclude <linux/mutex.h>\n#\ninclude <linux/idr.h>\n#\ninclude <linux/writeback.h>\t\t/* for the emergency remount stuff */\n#\ninclude <linux/security.h>\n#\ninclude <linux/mount.h>\n#\ninclude <linux/blkdev.h>\n#\ninclude <linux/slab.h>\n#\ninclude <linux/export.h>\n#\n\ntatic DEFINE_SPINLOCK(sb_lock);\n\noid generic_shutdown_super(struct super_block *sb)\n{\n\tconst struct super_operations *sop = sb->s_op;\n\n\tif (sb->s_root) {\n\t\tshrink_dcache_for_umount(sb);\n\t\tsync_filesystem(sb);\n\t\tsb->s_flags &= ~MS_ACTIVE;\n\n\t\tfsnotify_unmount_inodes(&sb->s_inodes);\n\n\t\tevict_inodes(sb);\n\n\t\tif (sb->s_dio_done_wq) {\n\t\t\tdestroy_workqueue(sb->s_dio_done_wq);\n\t\t\tsb->s_dio_done_wq = NULL;\n\t\t}\n\n\t\tif (sop->put_super)\n\t\t\tsop->put_super(sb);\n\n\t\tif (!list_empty(&sb->s_inodes)) {\n\t\t\tprintk(\"VFS: Busy inodes after unmount of %s. \"\n\t\t\t   \"Self-destruct in 5 seconds.  Have a nice day...\\n\",\n\t\t\t   sb->s_id);\n\t\t}\n\t}\n\tspin_lock(&sb_lock);\n\t/* should be initialized for __put_super_and_need_restart() */\n\thlist_del_init(&sb->s_instances);\n\tspin_unlock(&sb_lock);\n\tup_write(&sb->s_umount);\n}"
        }
      }
    ],
    "contextual_snippet": "include \"internal.h\"\ninclude <linux/lockdep.h>\n#\ninclude <linux/fsnotify.h>\n#\ninclude <linux/cleancache.h>\n#\ninclude <linux/rculist_bl.h>\n#\ninclude <linux/backing-dev.h>\n#\ninclude <linux/mutex.h>\n#\ninclude <linux/idr.h>\n#\ninclude <linux/writeback.h>\t\t/* for the emergency remount stuff */\n#\ninclude <linux/security.h>\n#\ninclude <linux/mount.h>\n#\ninclude <linux/blkdev.h>\n#\ninclude <linux/slab.h>\n#\ninclude <linux/export.h>\n#\n\noid kill_block_super(struct super_block *sb)\n{\n\tstruct block_device *bdev = sb->s_bdev;\n\tfmode_t mode = sb->s_mode;\n\n\tbdev->bd_super = NULL;\n\tgeneric_shutdown_super(sb);\n\tsync_blockdev(bdev);\n\tWARN_ON_ONCE(!(mode & FMODE_EXCL));\n\tblkdev_put(bdev, mode | FMODE_EXCL);\n}"
  },
  {
    "function_name": "ount_bdev(",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/super.c",
    "lines": "949-1023",
    "snippet": "truct dentry *mount_bdev(struct file_system_type *fs_type,\n\tint flags, const char *dev_name, void *data,\n\tint (*fill_super)(struct super_block *, void *, int))\n{\n\tstruct block_device *bdev;\n\tstruct super_block *s;\n\tfmode_t mode = FMODE_READ | FMODE_EXCL;\n\tint error = 0;\n\n\tif (!(flags & MS_RDONLY))\n\t\tmode |= FMODE_WRITE;\n\n\tbdev = blkdev_get_by_path(dev_name, mode, fs_type);\n\tif (IS_ERR(bdev))\n\t\treturn ERR_CAST(bdev);\n\n\t/*\n\t * once the super is inserted into the list by sget, s_umount\n\t * will protect the lockfs code from trying to start a snapshot\n\t * while we are mounting\n\t */\n\tmutex_lock(&bdev->bd_fsfreeze_mutex);\n\tif (bdev->bd_fsfreeze_count > 0) {\n\t\tmutex_unlock(&bdev->bd_fsfreeze_mutex);\n\t\terror = -EBUSY;\n\t\tgoto error_bdev;\n\t}\n\ts = sget(fs_type, test_bdev_super, set_bdev_super, flags | MS_NOSEC,\n\t\t bdev);\n\tmutex_unlock(&bdev->bd_fsfreeze_mutex);\n\tif (IS_ERR(s))\n\t\tgoto error_s;\n\n\tif (s->s_root) {\n\t\tif ((flags ^ s->s_flags) & MS_RDONLY) {\n\t\t\tdeactivate_locked_super(s);\n\t\t\terror = -EBUSY;\n\t\t\tgoto error_bdev;\n\t\t}\n\n\t\t/*\n\t\t * s_umount nests inside bd_mutex during\n\t\t * __invalidate_device().  blkdev_put() acquires\n\t\t * bd_mutex and can't be called under s_umount.  Drop\n\t\t * s_umount temporarily.  This is safe as we're\n\t\t * holding an active reference.\n\t\t */\n\t\tup_write(&s->s_umount);\n\t\tblkdev_put(bdev, mode);\n\t\tdown_write(&s->s_umount);\n\t} else {\n\t\tchar b[BDEVNAME_SIZE];\n\n\t\ts->s_mode = mode;\n\t\tstrlcpy(s->s_id, bdevname(bdev, b), sizeof(s->s_id));\n\t\tsb_set_blocksize(s, block_size(bdev));\n\t\terror = fill_super(s, data, flags & MS_SILENT ? 1 : 0);\n\t\tif (error) {\n\t\t\tdeactivate_locked_super(s);\n\t\t\tgoto error;\n\t\t}\n\n\t\ts->s_flags |= MS_ACTIVE;\n\t\tbdev->bd_super = s;\n\t}\n\n\treturn dget(s->s_root);\n\nerror_s:\n\terror = PTR_ERR(s);\nerror_bdev:\n\tblkdev_put(bdev, mode);\nerror:\n\treturn ERR_PTR(error);\n}",
    "includes": [
      "include \"internal.h\"",
      "include <linux/lockdep.h>\n#",
      "include <linux/fsnotify.h>\n#",
      "include <linux/cleancache.h>\n#",
      "include <linux/rculist_bl.h>\n#",
      "include <linux/backing-dev.h>\n#",
      "include <linux/mutex.h>\n#",
      "include <linux/idr.h>\n#",
      "include <linux/writeback.h>\t\t/* for the emergency remount stuff */\n#",
      "include <linux/security.h>\n#",
      "include <linux/mount.h>\n#",
      "include <linux/blkdev.h>\n#",
      "include <linux/slab.h>\n#",
      "include <linux/export.h>\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "RR_PTR(",
          "args": [
            "rror)"
          ],
          "line": 1022
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lkdev_put(",
          "args": [
            "dev,",
            "ode)"
          ],
          "line": 1020
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TR_ERR(",
          "args": [
            ")"
          ],
          "line": 1018
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get(",
          "args": [
            "->s_root)"
          ],
          "line": 1015
        },
        "resolved": true,
        "details": {
          "function_name": "ing_page_budget(struct ubifs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ubifs/file.c",
          "lines": "214-219",
          "snippet": "elease_existing_page_budget(struct ubifs_info *c)\n{\n\tstruct ubifs_budget_req req = { .dd_growth = c->bi.page_budget};\n\n\tubifs_release_budget(c, &req);\n}\n\nstatic int",
          "includes": [
            "ux/slab.h>\n\nstatic int r",
            "ux/namei.h>\n#include <lin",
            "ux/mount.h>\n#include <lin",
            "ux/aio.h>\n#include <lin",
            "fs.h\"\n#include <lin"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "ux/slab.h>\n\nstatic int r\nux/namei.h>\n#include <lin\nux/mount.h>\n#include <lin\nux/aio.h>\n#include <lin\nfs.h\"\n#include <lin\n\nelease_existing_page_budget(struct ubifs_info *c)\n{\n\tstruct ubifs_budget_req req = { .dd_growth = c->bi.page_budget};\n\n\tubifs_release_budget(c, &req);\n}\n\nstatic int"
        }
      },
      {
        "call_info": {
          "callee": "eactivate_locked_super(",
          "args": [
            ")"
          ],
          "line": 1007
        },
        "resolved": true,
        "details": {
          "function_name": "eactivate_locked_super(",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/super.c",
          "lines": "280-301",
          "snippet": "oid deactivate_locked_super(struct super_block *s)\n{\n\tstruct file_system_type *fs = s->s_type;\n\tif (atomic_dec_and_test(&s->s_active)) {\n\t\tcleancache_invalidate_fs(s);\n\t\tunregister_shrinker(&s->s_shrink);\n\t\tfs->kill_sb(s);\n\n\t\t/*\n\t\t * Since list_lru_destroy() may sleep, we cannot call it from\n\t\t * put_super(), where we hold the sb_lock. Therefore we destroy\n\t\t * the lru lists right now.\n\t\t */\n\t\tlist_lru_destroy(&s->s_dentry_lru);\n\t\tlist_lru_destroy(&s->s_inode_lru);\n\n\t\tput_filesystem(fs);\n\t\tput_super(s);\n\t} else {\n\t\tup_write(&s->s_umount);\n\t}\n}",
          "includes": [
            "include \"internal.h\"",
            "include <linux/lockdep.h>\n#",
            "include <linux/fsnotify.h>\n#",
            "include <linux/cleancache.h>\n#",
            "include <linux/rculist_bl.h>\n#",
            "include <linux/backing-dev.h>\n#",
            "include <linux/mutex.h>\n#",
            "include <linux/idr.h>\n#",
            "include <linux/writeback.h>\t\t/* for the emergency remount stuff */\n#",
            "include <linux/security.h>\n#",
            "include <linux/mount.h>\n#",
            "include <linux/blkdev.h>\n#",
            "include <linux/slab.h>\n#",
            "include <linux/export.h>\n#"
          ],
          "macros_used": [],
          "globals_used": [
            "tatic DEFINE_SPINLOCK(sb_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "include \"internal.h\"\ninclude <linux/lockdep.h>\n#\ninclude <linux/fsnotify.h>\n#\ninclude <linux/cleancache.h>\n#\ninclude <linux/rculist_bl.h>\n#\ninclude <linux/backing-dev.h>\n#\ninclude <linux/mutex.h>\n#\ninclude <linux/idr.h>\n#\ninclude <linux/writeback.h>\t\t/* for the emergency remount stuff */\n#\ninclude <linux/security.h>\n#\ninclude <linux/mount.h>\n#\ninclude <linux/blkdev.h>\n#\ninclude <linux/slab.h>\n#\ninclude <linux/export.h>\n#\n\ntatic DEFINE_SPINLOCK(sb_lock);\n\noid deactivate_locked_super(struct super_block *s)\n{\n\tstruct file_system_type *fs = s->s_type;\n\tif (atomic_dec_and_test(&s->s_active)) {\n\t\tcleancache_invalidate_fs(s);\n\t\tunregister_shrinker(&s->s_shrink);\n\t\tfs->kill_sb(s);\n\n\t\t/*\n\t\t * Since list_lru_destroy() may sleep, we cannot call it from\n\t\t * put_super(), where we hold the sb_lock. Therefore we destroy\n\t\t * the lru lists right now.\n\t\t */\n\t\tlist_lru_destroy(&s->s_dentry_lru);\n\t\tlist_lru_destroy(&s->s_inode_lru);\n\n\t\tput_filesystem(fs);\n\t\tput_super(s);\n\t} else {\n\t\tup_write(&s->s_umount);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ill_super(",
          "args": [
            ",",
            "ata,",
            "lags & MS_SILENT ? 1 : 0)"
          ],
          "line": 1005
        },
        "resolved": true,
        "details": {
          "function_name": "_fill_super(stru",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/romfs/super.c",
          "lines": "468-549",
          "snippet": "c int romfs_fill_super(struct super_block *sb, void *data, int silent)\n{\n\tstruct romfs_super_block *rsb;\n\tstruct inode *root;\n\tunsigned long pos, img_size;\n\tconst char *storage;\n\tsize_t len;\n\tint ret;\n\n#ifdef CONFIG_BLOCK\n\tif (!sb->s_mtd) {\n\t\tsb_set_blocksize(sb, ROMBSIZE);\n\t} else {\n\t\tsb->s_blocksize = ROMBSIZE;\n\t\tsb->s_blocksize_bits = blksize_bits(ROMBSIZE);\n\t}\n#endif\n\n\tsb->s_maxbytes = 0xFFFFFFFF;\n\tsb->s_magic = ROMFS_MAGIC;\n\tsb->s_flags |= MS_RDONLY | MS_NOATIME;\n\tsb->s_op = &romfs_super_ops;\n\n\t/* read the image superblock and check it */\n\trsb = kmalloc(512, GFP_KERNEL);\n\tif (!rsb)\n\t\treturn -ENOMEM;\n\n\tsb->s_fs_info = (void *) 512;\n\tret = romfs_dev_read(sb, 0, rsb, 512);\n\tif (ret < 0)\n\t\tgoto error_rsb;\n\n\timg_size = be32_to_cpu(rsb->size);\n\n\tif (sb->s_mtd && img_size > sb->s_mtd->size)\n\t\tgoto error_rsb_inval;\n\n\tsb->s_fs_info = (void *) img_size;\n\n\tif (rsb->word0 != ROMSB_WORD0 || rsb->word1 != ROMSB_WORD1 ||\n\t    img_size < ROMFH_SIZE) {\n\t\tif (!silent)\n\t\t\tpr_warn(\"VFS: Can't find a romfs filesystem on dev %s.\\n\",\n\t\t\t       sb->s_id);\n\t\tgoto error_rsb_inval;\n\t}\n\n\tif (romfs_checksum(rsb, min_t(size_t, img_size, 512))) {\n\t\tpr_err(\"bad initial checksum on dev %s.\\n\", sb->s_id);\n\t\tgoto error_rsb_inval;\n\t}\n\n\tstorage = sb->s_mtd ? \"MTD\" : \"the block layer\";\n\n\tlen = strnlen(rsb->name, ROMFS_MAXFN);\n\tif (!silent)\n\t\tpr_notice(\"Mounting image '%*.*s' through %s\\n\",\n\t\t\t  (unsigned) len, (unsigned) len, rsb->name, storage);\n\n\tkfree(rsb);\n\trsb = NULL;\n\n\t/* find the root directory */\n\tpos = (ROMFH_SIZE + len + 1 + ROMFH_PAD) & ROMFH_MASK;\n\n\troot = romfs_iget(sb, pos);\n\tif (IS_ERR(root))\n\t\treturn PTR_ERR(root);\n\n\tsb->s_root = d_make_root(root);\n\tif (!sb->s_root)\n\t\treturn -ENOMEM;\n\n\treturn 0;\n\nerror_rsb_inval:\n\tret = -EINVAL;\nerror_rsb:\n\tkfree(rsb);\n\treturn ret;\n}\n\n/*",
          "includes": [
            "ude \"internal.h\"\n\nstat",
            "ude <linux/uaccess.h>\n#incl",
            "ude <linux/pagemap.h>\n#incl",
            "ude <linux/highmem.h>\n#incl",
            "ude <linux/ctype.h>\n#incl",
            "ude <linux/mtd/super.h>\n#incl",
            "ude <linux/statfs.h>\n#incl",
            "ude <linux/namei.h>\n#incl",
            "ude <linux/mount.h>\n#incl",
            "ude <linux/parser.h>\n#incl",
            "ude <linux/blkdev.h>\n#incl",
            "ude <linux/init.h>\n#incl",
            "ude <linux/slab.h>\n#incl",
            "ude <linux/time.h>\n#incl",
            "ude <linux/fs.h>\n#incl",
            "ude <linux/string.h>\n#incl",
            "ude <linux/module.h>\n#incl"
          ],
          "macros_used": [],
          "globals_used": [
            "c struct inode *romfs_iget(struct super_block *sb, unsigned long pos);\n\n/*",
            "c const struct super_operations romfs_super_ops = {\n\t.alloc_inode\t= romfs_alloc_inode,\n\t.destroy_inode\t= romfs_destroy_inode,\n\t.statfs\t\t= romfs_statfs,\n\t.remount_fs\t= romfs_remount,\n};\n\n/*"
          ],
          "called_functions": [],
          "contextual_snippet": "ude \"internal.h\"\n\nstat\nude <linux/uaccess.h>\n#incl\nude <linux/pagemap.h>\n#incl\nude <linux/highmem.h>\n#incl\nude <linux/ctype.h>\n#incl\nude <linux/mtd/super.h>\n#incl\nude <linux/statfs.h>\n#incl\nude <linux/namei.h>\n#incl\nude <linux/mount.h>\n#incl\nude <linux/parser.h>\n#incl\nude <linux/blkdev.h>\n#incl\nude <linux/init.h>\n#incl\nude <linux/slab.h>\n#incl\nude <linux/time.h>\n#incl\nude <linux/fs.h>\n#incl\nude <linux/string.h>\n#incl\nude <linux/module.h>\n#incl\n\nc struct inode *romfs_iget(struct super_block *sb, unsigned long pos);\n\n/*;\nc const struct super_operations romfs_super_ops = {\n\t.alloc_inode\t= romfs_alloc_inode,\n\t.destroy_inode\t= romfs_destroy_inode,\n\t.statfs\t\t= romfs_statfs,\n\t.remount_fs\t= romfs_remount,\n};\n\n/*;\n\nc int romfs_fill_super(struct super_block *sb, void *data, int silent)\n{\n\tstruct romfs_super_block *rsb;\n\tstruct inode *root;\n\tunsigned long pos, img_size;\n\tconst char *storage;\n\tsize_t len;\n\tint ret;\n\n#ifdef CONFIG_BLOCK\n\tif (!sb->s_mtd) {\n\t\tsb_set_blocksize(sb, ROMBSIZE);\n\t} else {\n\t\tsb->s_blocksize = ROMBSIZE;\n\t\tsb->s_blocksize_bits = blksize_bits(ROMBSIZE);\n\t}\n#endif\n\n\tsb->s_maxbytes = 0xFFFFFFFF;\n\tsb->s_magic = ROMFS_MAGIC;\n\tsb->s_flags |= MS_RDONLY | MS_NOATIME;\n\tsb->s_op = &romfs_super_ops;\n\n\t/* read the image superblock and check it */\n\trsb = kmalloc(512, GFP_KERNEL);\n\tif (!rsb)\n\t\treturn -ENOMEM;\n\n\tsb->s_fs_info = (void *) 512;\n\tret = romfs_dev_read(sb, 0, rsb, 512);\n\tif (ret < 0)\n\t\tgoto error_rsb;\n\n\timg_size = be32_to_cpu(rsb->size);\n\n\tif (sb->s_mtd && img_size > sb->s_mtd->size)\n\t\tgoto error_rsb_inval;\n\n\tsb->s_fs_info = (void *) img_size;\n\n\tif (rsb->word0 != ROMSB_WORD0 || rsb->word1 != ROMSB_WORD1 ||\n\t    img_size < ROMFH_SIZE) {\n\t\tif (!silent)\n\t\t\tpr_warn(\"VFS: Can't find a romfs filesystem on dev %s.\\n\",\n\t\t\t       sb->s_id);\n\t\tgoto error_rsb_inval;\n\t}\n\n\tif (romfs_checksum(rsb, min_t(size_t, img_size, 512))) {\n\t\tpr_err(\"bad initial checksum on dev %s.\\n\", sb->s_id);\n\t\tgoto error_rsb_inval;\n\t}\n\n\tstorage = sb->s_mtd ? \"MTD\" : \"the block layer\";\n\n\tlen = strnlen(rsb->name, ROMFS_MAXFN);\n\tif (!silent)\n\t\tpr_notice(\"Mounting image '%*.*s' through %s\\n\",\n\t\t\t  (unsigned) len, (unsigned) len, rsb->name, storage);\n\n\tkfree(rsb);\n\trsb = NULL;\n\n\t/* find the root directory */\n\tpos = (ROMFH_SIZE + len + 1 + ROMFH_PAD) & ROMFH_MASK;\n\n\troot = romfs_iget(sb, pos);\n\tif (IS_ERR(root))\n\t\treturn PTR_ERR(root);\n\n\tsb->s_root = d_make_root(root);\n\tif (!sb->s_root)\n\t\treturn -ENOMEM;\n\n\treturn 0;\n\nerror_rsb_inval:\n\tret = -EINVAL;\nerror_rsb:\n\tkfree(rsb);\n\treturn ret;\n}\n\n/*"
        }
      },
      {
        "call_info": {
          "callee": "b_set_blocksize(",
          "args": [
            ",",
            "lock_size(bdev))"
          ],
          "line": 1004
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lock_size(",
          "args": [
            "dev)"
          ],
          "line": 1004
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trlcpy(",
          "args": [
            "->s_id,",
            "devname(bdev, b),",
            "izeof(s->s_id))"
          ],
          "line": 1003
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "devname(",
          "args": [
            "dev,",
            ")"
          ],
          "line": 1003
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "own_write(",
          "args": [
            "s->s_umount)"
          ],
          "line": 998
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lkdev_put(",
          "args": [
            "dev,",
            "ode)"
          ],
          "line": 997
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "p_write(",
          "args": [
            "s->s_umount)"
          ],
          "line": 996
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ERR(",
          "args": [
            ")"
          ],
          "line": 979
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "utex_unlock(",
          "args": [
            "bdev->bd_fsfreeze_mutex)"
          ],
          "line": 978
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get(",
          "args": [
            "s_type,",
            "est_bdev_super,",
            "et_bdev_super,",
            "lags | MS_NOSEC,",
            "dev)"
          ],
          "line": 976
        },
        "resolved": true,
        "details": {
          "function_name": "get(",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/super.c",
          "lines": "437-486",
          "snippet": "truct super_block *sget(struct file_system_type *type,\n\t\t\tint (*test)(struct super_block *,void *),\n\t\t\tint (*set)(struct super_block *,void *),\n\t\t\tint flags,\n\t\t\tvoid *data)\n{\n\tstruct super_block *s = NULL;\n\tstruct super_block *old;\n\tint err;\n\nretry:\n\tspin_lock(&sb_lock);\n\tif (test) {\n\t\thlist_for_each_entry(old, &type->fs_supers, s_instances) {\n\t\t\tif (!test(old, data))\n\t\t\t\tcontinue;\n\t\t\tif (!grab_super(old))\n\t\t\t\tgoto retry;\n\t\t\tif (s) {\n\t\t\t\tup_write(&s->s_umount);\n\t\t\t\tdestroy_super(s);\n\t\t\t\ts = NULL;\n\t\t\t}\n\t\t\treturn old;\n\t\t}\n\t}\n\tif (!s) {\n\t\tspin_unlock(&sb_lock);\n\t\ts = alloc_super(type, flags);\n\t\tif (!s)\n\t\t\treturn ERR_PTR(-ENOMEM);\n\t\tgoto retry;\n\t}\n\t\t\n\terr = set(s, data);\n\tif (err) {\n\t\tspin_unlock(&sb_lock);\n\t\tup_write(&s->s_umount);\n\t\tdestroy_super(s);\n\t\treturn ERR_PTR(err);\n\t}\n\ts->s_type = type;\n\tstrlcpy(s->s_id, type->name, sizeof(s->s_id));\n\tlist_add_tail(&s->s_list, &super_blocks);\n\thlist_add_head(&s->s_instances, &type->fs_supers);\n\tspin_unlock(&sb_lock);\n\tget_filesystem(type);\n\tregister_shrinker(&s->s_shrink);\n\treturn s;\n}",
          "includes": [
            "include \"internal.h\"",
            "include <linux/lockdep.h>\n#",
            "include <linux/fsnotify.h>\n#",
            "include <linux/cleancache.h>\n#",
            "include <linux/rculist_bl.h>\n#",
            "include <linux/backing-dev.h>\n#",
            "include <linux/mutex.h>\n#",
            "include <linux/idr.h>\n#",
            "include <linux/writeback.h>\t\t/* for the emergency remount stuff */\n#",
            "include <linux/security.h>\n#",
            "include <linux/mount.h>\n#",
            "include <linux/blkdev.h>\n#",
            "include <linux/slab.h>\n#",
            "include <linux/export.h>\n#"
          ],
          "macros_used": [],
          "globals_used": [
            "tatic LIST_HEAD(super_blocks);",
            "tatic DEFINE_SPINLOCK(sb_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "include \"internal.h\"\ninclude <linux/lockdep.h>\n#\ninclude <linux/fsnotify.h>\n#\ninclude <linux/cleancache.h>\n#\ninclude <linux/rculist_bl.h>\n#\ninclude <linux/backing-dev.h>\n#\ninclude <linux/mutex.h>\n#\ninclude <linux/idr.h>\n#\ninclude <linux/writeback.h>\t\t/* for the emergency remount stuff */\n#\ninclude <linux/security.h>\n#\ninclude <linux/mount.h>\n#\ninclude <linux/blkdev.h>\n#\ninclude <linux/slab.h>\n#\ninclude <linux/export.h>\n#\n\ntatic LIST_HEAD(super_blocks);\ntatic DEFINE_SPINLOCK(sb_lock);\n\ntruct super_block *sget(struct file_system_type *type,\n\t\t\tint (*test)(struct super_block *,void *),\n\t\t\tint (*set)(struct super_block *,void *),\n\t\t\tint flags,\n\t\t\tvoid *data)\n{\n\tstruct super_block *s = NULL;\n\tstruct super_block *old;\n\tint err;\n\nretry:\n\tspin_lock(&sb_lock);\n\tif (test) {\n\t\thlist_for_each_entry(old, &type->fs_supers, s_instances) {\n\t\t\tif (!test(old, data))\n\t\t\t\tcontinue;\n\t\t\tif (!grab_super(old))\n\t\t\t\tgoto retry;\n\t\t\tif (s) {\n\t\t\t\tup_write(&s->s_umount);\n\t\t\t\tdestroy_super(s);\n\t\t\t\ts = NULL;\n\t\t\t}\n\t\t\treturn old;\n\t\t}\n\t}\n\tif (!s) {\n\t\tspin_unlock(&sb_lock);\n\t\ts = alloc_super(type, flags);\n\t\tif (!s)\n\t\t\treturn ERR_PTR(-ENOMEM);\n\t\tgoto retry;\n\t}\n\t\t\n\terr = set(s, data);\n\tif (err) {\n\t\tspin_unlock(&sb_lock);\n\t\tup_write(&s->s_umount);\n\t\tdestroy_super(s);\n\t\treturn ERR_PTR(err);\n\t}\n\ts->s_type = type;\n\tstrlcpy(s->s_id, type->name, sizeof(s->s_id));\n\tlist_add_tail(&s->s_list, &super_blocks);\n\thlist_add_head(&s->s_instances, &type->fs_supers);\n\tspin_unlock(&sb_lock);\n\tget_filesystem(type);\n\tregister_shrinker(&s->s_shrink);\n\treturn s;\n}"
        }
      },
      {
        "call_info": {
          "callee": "utex_unlock(",
          "args": [
            "bdev->bd_fsfreeze_mutex)"
          ],
          "line": 972
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "utex_lock(",
          "args": [
            "bdev->bd_fsfreeze_mutex)"
          ],
          "line": 970
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RR_CAST(",
          "args": [
            "dev)"
          ],
          "line": 963
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ERR(",
          "args": [
            "dev)"
          ],
          "line": 962
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lkdev_get_by_path(",
          "args": [
            "ev_name,",
            "ode,",
            "s_type)"
          ],
          "line": 961
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "include \"internal.h\"\ninclude <linux/lockdep.h>\n#\ninclude <linux/fsnotify.h>\n#\ninclude <linux/cleancache.h>\n#\ninclude <linux/rculist_bl.h>\n#\ninclude <linux/backing-dev.h>\n#\ninclude <linux/mutex.h>\n#\ninclude <linux/idr.h>\n#\ninclude <linux/writeback.h>\t\t/* for the emergency remount stuff */\n#\ninclude <linux/security.h>\n#\ninclude <linux/mount.h>\n#\ninclude <linux/blkdev.h>\n#\ninclude <linux/slab.h>\n#\ninclude <linux/export.h>\n#\n\ntruct dentry *mount_bdev(struct file_system_type *fs_type,\n\tint flags, const char *dev_name, void *data,\n\tint (*fill_super)(struct super_block *, void *, int))\n{\n\tstruct block_device *bdev;\n\tstruct super_block *s;\n\tfmode_t mode = FMODE_READ | FMODE_EXCL;\n\tint error = 0;\n\n\tif (!(flags & MS_RDONLY))\n\t\tmode |= FMODE_WRITE;\n\n\tbdev = blkdev_get_by_path(dev_name, mode, fs_type);\n\tif (IS_ERR(bdev))\n\t\treturn ERR_CAST(bdev);\n\n\t/*\n\t * once the super is inserted into the list by sget, s_umount\n\t * will protect the lockfs code from trying to start a snapshot\n\t * while we are mounting\n\t */\n\tmutex_lock(&bdev->bd_fsfreeze_mutex);\n\tif (bdev->bd_fsfreeze_count > 0) {\n\t\tmutex_unlock(&bdev->bd_fsfreeze_mutex);\n\t\terror = -EBUSY;\n\t\tgoto error_bdev;\n\t}\n\ts = sget(fs_type, test_bdev_super, set_bdev_super, flags | MS_NOSEC,\n\t\t bdev);\n\tmutex_unlock(&bdev->bd_fsfreeze_mutex);\n\tif (IS_ERR(s))\n\t\tgoto error_s;\n\n\tif (s->s_root) {\n\t\tif ((flags ^ s->s_flags) & MS_RDONLY) {\n\t\t\tdeactivate_locked_super(s);\n\t\t\terror = -EBUSY;\n\t\t\tgoto error_bdev;\n\t\t}\n\n\t\t/*\n\t\t * s_umount nests inside bd_mutex during\n\t\t * __invalidate_device().  blkdev_put() acquires\n\t\t * bd_mutex and can't be called under s_umount.  Drop\n\t\t * s_umount temporarily.  This is safe as we're\n\t\t * holding an active reference.\n\t\t */\n\t\tup_write(&s->s_umount);\n\t\tblkdev_put(bdev, mode);\n\t\tdown_write(&s->s_umount);\n\t} else {\n\t\tchar b[BDEVNAME_SIZE];\n\n\t\ts->s_mode = mode;\n\t\tstrlcpy(s->s_id, bdevname(bdev, b), sizeof(s->s_id));\n\t\tsb_set_blocksize(s, block_size(bdev));\n\t\terror = fill_super(s, data, flags & MS_SILENT ? 1 : 0);\n\t\tif (error) {\n\t\t\tdeactivate_locked_super(s);\n\t\t\tgoto error;\n\t\t}\n\n\t\ts->s_flags |= MS_ACTIVE;\n\t\tbdev->bd_super = s;\n\t}\n\n\treturn dget(s->s_root);\n\nerror_s:\n\terror = PTR_ERR(s);\nerror_bdev:\n\tblkdev_put(bdev, mode);\nerror:\n\treturn ERR_PTR(error);\n}"
  },
  {
    "function_name": "est_bdev_super(",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/super.c",
    "lines": "944-947",
    "snippet": "tatic int test_bdev_super(struct super_block *s, void *data)\n{\n\treturn (void *)s->s_bdev == data;\n}",
    "includes": [
      "include \"internal.h\"",
      "include <linux/lockdep.h>\n#",
      "include <linux/fsnotify.h>\n#",
      "include <linux/cleancache.h>\n#",
      "include <linux/rculist_bl.h>\n#",
      "include <linux/backing-dev.h>\n#",
      "include <linux/mutex.h>\n#",
      "include <linux/idr.h>\n#",
      "include <linux/writeback.h>\t\t/* for the emergency remount stuff */\n#",
      "include <linux/security.h>\n#",
      "include <linux/mount.h>\n#",
      "include <linux/blkdev.h>\n#",
      "include <linux/slab.h>\n#",
      "include <linux/export.h>\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "include \"internal.h\"\ninclude <linux/lockdep.h>\n#\ninclude <linux/fsnotify.h>\n#\ninclude <linux/cleancache.h>\n#\ninclude <linux/rculist_bl.h>\n#\ninclude <linux/backing-dev.h>\n#\ninclude <linux/mutex.h>\n#\ninclude <linux/idr.h>\n#\ninclude <linux/writeback.h>\t\t/* for the emergency remount stuff */\n#\ninclude <linux/security.h>\n#\ninclude <linux/mount.h>\n#\ninclude <linux/blkdev.h>\n#\ninclude <linux/slab.h>\n#\ninclude <linux/export.h>\n#\n\ntatic int test_bdev_super(struct super_block *s, void *data)\n{\n\treturn (void *)s->s_bdev == data;\n}"
  },
  {
    "function_name": "et_bdev_super(",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/super.c",
    "lines": "931-942",
    "snippet": "tatic int set_bdev_super(struct super_block *s, void *data)\n{\n\ts->s_bdev = data;\n\ts->s_dev = s->s_bdev->bd_dev;\n\n\t/*\n\t * We set the bdi here to the queue backing, file systems can\n\t * overwrite this in ->fill_super()\n\t */\n\ts->s_bdi = &bdev_get_queue(s->s_bdev)->backing_dev_info;\n\treturn 0;\n}",
    "includes": [
      "include \"internal.h\"",
      "include <linux/lockdep.h>\n#",
      "include <linux/fsnotify.h>\n#",
      "include <linux/cleancache.h>\n#",
      "include <linux/rculist_bl.h>\n#",
      "include <linux/backing-dev.h>\n#",
      "include <linux/mutex.h>\n#",
      "include <linux/idr.h>\n#",
      "include <linux/writeback.h>\t\t/* for the emergency remount stuff */\n#",
      "include <linux/security.h>\n#",
      "include <linux/mount.h>\n#",
      "include <linux/blkdev.h>\n#",
      "include <linux/slab.h>\n#",
      "include <linux/export.h>\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "dev_get_queue(",
          "args": [
            "->s_bdev)"
          ],
          "line": 940
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "include \"internal.h\"\ninclude <linux/lockdep.h>\n#\ninclude <linux/fsnotify.h>\n#\ninclude <linux/cleancache.h>\n#\ninclude <linux/rculist_bl.h>\n#\ninclude <linux/backing-dev.h>\n#\ninclude <linux/mutex.h>\n#\ninclude <linux/idr.h>\n#\ninclude <linux/writeback.h>\t\t/* for the emergency remount stuff */\n#\ninclude <linux/security.h>\n#\ninclude <linux/mount.h>\n#\ninclude <linux/blkdev.h>\n#\ninclude <linux/slab.h>\n#\ninclude <linux/export.h>\n#\n\ntatic int set_bdev_super(struct super_block *s, void *data)\n{\n\ts->s_bdev = data;\n\ts->s_dev = s->s_bdev->bd_dev;\n\n\t/*\n\t * We set the bdi here to the queue backing, file systems can\n\t * overwrite this in ->fill_super()\n\t */\n\ts->s_bdi = &bdev_get_queue(s->s_bdev)->backing_dev_info;\n\treturn 0;\n}"
  },
  {
    "function_name": "ount_ns(",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/super.c",
    "lines": "905-926",
    "snippet": "truct dentry *mount_ns(struct file_system_type *fs_type, int flags,\n\tvoid *data, int (*fill_super)(struct super_block *, void *, int))\n{\n\tstruct super_block *sb;\n\n\tsb = sget(fs_type, ns_test_super, ns_set_super, flags, data);\n\tif (IS_ERR(sb))\n\t\treturn ERR_CAST(sb);\n\n\tif (!sb->s_root) {\n\t\tint err;\n\t\terr = fill_super(sb, data, flags & MS_SILENT ? 1 : 0);\n\t\tif (err) {\n\t\t\tdeactivate_locked_super(sb);\n\t\t\treturn ERR_PTR(err);\n\t\t}\n\n\t\tsb->s_flags |= MS_ACTIVE;\n\t}\n\n\treturn dget(sb->s_root);\n}",
    "includes": [
      "include \"internal.h\"",
      "include <linux/lockdep.h>\n#",
      "include <linux/fsnotify.h>\n#",
      "include <linux/cleancache.h>\n#",
      "include <linux/rculist_bl.h>\n#",
      "include <linux/backing-dev.h>\n#",
      "include <linux/mutex.h>\n#",
      "include <linux/idr.h>\n#",
      "include <linux/writeback.h>\t\t/* for the emergency remount stuff */\n#",
      "include <linux/security.h>\n#",
      "include <linux/mount.h>\n#",
      "include <linux/blkdev.h>\n#",
      "include <linux/slab.h>\n#",
      "include <linux/export.h>\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "get(",
          "args": [
            "b->s_root)"
          ],
          "line": 925
        },
        "resolved": true,
        "details": {
          "function_name": "ing_page_budget(struct ubifs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ubifs/file.c",
          "lines": "214-219",
          "snippet": "elease_existing_page_budget(struct ubifs_info *c)\n{\n\tstruct ubifs_budget_req req = { .dd_growth = c->bi.page_budget};\n\n\tubifs_release_budget(c, &req);\n}\n\nstatic int",
          "includes": [
            "ux/slab.h>\n\nstatic int r",
            "ux/namei.h>\n#include <lin",
            "ux/mount.h>\n#include <lin",
            "ux/aio.h>\n#include <lin",
            "fs.h\"\n#include <lin"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "ux/slab.h>\n\nstatic int r\nux/namei.h>\n#include <lin\nux/mount.h>\n#include <lin\nux/aio.h>\n#include <lin\nfs.h\"\n#include <lin\n\nelease_existing_page_budget(struct ubifs_info *c)\n{\n\tstruct ubifs_budget_req req = { .dd_growth = c->bi.page_budget};\n\n\tubifs_release_budget(c, &req);\n}\n\nstatic int"
        }
      },
      {
        "call_info": {
          "callee": "RR_PTR(",
          "args": [
            "rr)"
          ],
          "line": 919
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "eactivate_locked_super(",
          "args": [
            "b)"
          ],
          "line": 918
        },
        "resolved": true,
        "details": {
          "function_name": "eactivate_locked_super(",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/super.c",
          "lines": "280-301",
          "snippet": "oid deactivate_locked_super(struct super_block *s)\n{\n\tstruct file_system_type *fs = s->s_type;\n\tif (atomic_dec_and_test(&s->s_active)) {\n\t\tcleancache_invalidate_fs(s);\n\t\tunregister_shrinker(&s->s_shrink);\n\t\tfs->kill_sb(s);\n\n\t\t/*\n\t\t * Since list_lru_destroy() may sleep, we cannot call it from\n\t\t * put_super(), where we hold the sb_lock. Therefore we destroy\n\t\t * the lru lists right now.\n\t\t */\n\t\tlist_lru_destroy(&s->s_dentry_lru);\n\t\tlist_lru_destroy(&s->s_inode_lru);\n\n\t\tput_filesystem(fs);\n\t\tput_super(s);\n\t} else {\n\t\tup_write(&s->s_umount);\n\t}\n}",
          "includes": [
            "include \"internal.h\"",
            "include <linux/lockdep.h>\n#",
            "include <linux/fsnotify.h>\n#",
            "include <linux/cleancache.h>\n#",
            "include <linux/rculist_bl.h>\n#",
            "include <linux/backing-dev.h>\n#",
            "include <linux/mutex.h>\n#",
            "include <linux/idr.h>\n#",
            "include <linux/writeback.h>\t\t/* for the emergency remount stuff */\n#",
            "include <linux/security.h>\n#",
            "include <linux/mount.h>\n#",
            "include <linux/blkdev.h>\n#",
            "include <linux/slab.h>\n#",
            "include <linux/export.h>\n#"
          ],
          "macros_used": [],
          "globals_used": [
            "tatic DEFINE_SPINLOCK(sb_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "include \"internal.h\"\ninclude <linux/lockdep.h>\n#\ninclude <linux/fsnotify.h>\n#\ninclude <linux/cleancache.h>\n#\ninclude <linux/rculist_bl.h>\n#\ninclude <linux/backing-dev.h>\n#\ninclude <linux/mutex.h>\n#\ninclude <linux/idr.h>\n#\ninclude <linux/writeback.h>\t\t/* for the emergency remount stuff */\n#\ninclude <linux/security.h>\n#\ninclude <linux/mount.h>\n#\ninclude <linux/blkdev.h>\n#\ninclude <linux/slab.h>\n#\ninclude <linux/export.h>\n#\n\ntatic DEFINE_SPINLOCK(sb_lock);\n\noid deactivate_locked_super(struct super_block *s)\n{\n\tstruct file_system_type *fs = s->s_type;\n\tif (atomic_dec_and_test(&s->s_active)) {\n\t\tcleancache_invalidate_fs(s);\n\t\tunregister_shrinker(&s->s_shrink);\n\t\tfs->kill_sb(s);\n\n\t\t/*\n\t\t * Since list_lru_destroy() may sleep, we cannot call it from\n\t\t * put_super(), where we hold the sb_lock. Therefore we destroy\n\t\t * the lru lists right now.\n\t\t */\n\t\tlist_lru_destroy(&s->s_dentry_lru);\n\t\tlist_lru_destroy(&s->s_inode_lru);\n\n\t\tput_filesystem(fs);\n\t\tput_super(s);\n\t} else {\n\t\tup_write(&s->s_umount);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ill_super(",
          "args": [
            "b,",
            "ata,",
            "lags & MS_SILENT ? 1 : 0)"
          ],
          "line": 916
        },
        "resolved": true,
        "details": {
          "function_name": "_fill_super(stru",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/romfs/super.c",
          "lines": "468-549",
          "snippet": "c int romfs_fill_super(struct super_block *sb, void *data, int silent)\n{\n\tstruct romfs_super_block *rsb;\n\tstruct inode *root;\n\tunsigned long pos, img_size;\n\tconst char *storage;\n\tsize_t len;\n\tint ret;\n\n#ifdef CONFIG_BLOCK\n\tif (!sb->s_mtd) {\n\t\tsb_set_blocksize(sb, ROMBSIZE);\n\t} else {\n\t\tsb->s_blocksize = ROMBSIZE;\n\t\tsb->s_blocksize_bits = blksize_bits(ROMBSIZE);\n\t}\n#endif\n\n\tsb->s_maxbytes = 0xFFFFFFFF;\n\tsb->s_magic = ROMFS_MAGIC;\n\tsb->s_flags |= MS_RDONLY | MS_NOATIME;\n\tsb->s_op = &romfs_super_ops;\n\n\t/* read the image superblock and check it */\n\trsb = kmalloc(512, GFP_KERNEL);\n\tif (!rsb)\n\t\treturn -ENOMEM;\n\n\tsb->s_fs_info = (void *) 512;\n\tret = romfs_dev_read(sb, 0, rsb, 512);\n\tif (ret < 0)\n\t\tgoto error_rsb;\n\n\timg_size = be32_to_cpu(rsb->size);\n\n\tif (sb->s_mtd && img_size > sb->s_mtd->size)\n\t\tgoto error_rsb_inval;\n\n\tsb->s_fs_info = (void *) img_size;\n\n\tif (rsb->word0 != ROMSB_WORD0 || rsb->word1 != ROMSB_WORD1 ||\n\t    img_size < ROMFH_SIZE) {\n\t\tif (!silent)\n\t\t\tpr_warn(\"VFS: Can't find a romfs filesystem on dev %s.\\n\",\n\t\t\t       sb->s_id);\n\t\tgoto error_rsb_inval;\n\t}\n\n\tif (romfs_checksum(rsb, min_t(size_t, img_size, 512))) {\n\t\tpr_err(\"bad initial checksum on dev %s.\\n\", sb->s_id);\n\t\tgoto error_rsb_inval;\n\t}\n\n\tstorage = sb->s_mtd ? \"MTD\" : \"the block layer\";\n\n\tlen = strnlen(rsb->name, ROMFS_MAXFN);\n\tif (!silent)\n\t\tpr_notice(\"Mounting image '%*.*s' through %s\\n\",\n\t\t\t  (unsigned) len, (unsigned) len, rsb->name, storage);\n\n\tkfree(rsb);\n\trsb = NULL;\n\n\t/* find the root directory */\n\tpos = (ROMFH_SIZE + len + 1 + ROMFH_PAD) & ROMFH_MASK;\n\n\troot = romfs_iget(sb, pos);\n\tif (IS_ERR(root))\n\t\treturn PTR_ERR(root);\n\n\tsb->s_root = d_make_root(root);\n\tif (!sb->s_root)\n\t\treturn -ENOMEM;\n\n\treturn 0;\n\nerror_rsb_inval:\n\tret = -EINVAL;\nerror_rsb:\n\tkfree(rsb);\n\treturn ret;\n}\n\n/*",
          "includes": [
            "ude \"internal.h\"\n\nstat",
            "ude <linux/uaccess.h>\n#incl",
            "ude <linux/pagemap.h>\n#incl",
            "ude <linux/highmem.h>\n#incl",
            "ude <linux/ctype.h>\n#incl",
            "ude <linux/mtd/super.h>\n#incl",
            "ude <linux/statfs.h>\n#incl",
            "ude <linux/namei.h>\n#incl",
            "ude <linux/mount.h>\n#incl",
            "ude <linux/parser.h>\n#incl",
            "ude <linux/blkdev.h>\n#incl",
            "ude <linux/init.h>\n#incl",
            "ude <linux/slab.h>\n#incl",
            "ude <linux/time.h>\n#incl",
            "ude <linux/fs.h>\n#incl",
            "ude <linux/string.h>\n#incl",
            "ude <linux/module.h>\n#incl"
          ],
          "macros_used": [],
          "globals_used": [
            "c struct inode *romfs_iget(struct super_block *sb, unsigned long pos);\n\n/*",
            "c const struct super_operations romfs_super_ops = {\n\t.alloc_inode\t= romfs_alloc_inode,\n\t.destroy_inode\t= romfs_destroy_inode,\n\t.statfs\t\t= romfs_statfs,\n\t.remount_fs\t= romfs_remount,\n};\n\n/*"
          ],
          "called_functions": [],
          "contextual_snippet": "ude \"internal.h\"\n\nstat\nude <linux/uaccess.h>\n#incl\nude <linux/pagemap.h>\n#incl\nude <linux/highmem.h>\n#incl\nude <linux/ctype.h>\n#incl\nude <linux/mtd/super.h>\n#incl\nude <linux/statfs.h>\n#incl\nude <linux/namei.h>\n#incl\nude <linux/mount.h>\n#incl\nude <linux/parser.h>\n#incl\nude <linux/blkdev.h>\n#incl\nude <linux/init.h>\n#incl\nude <linux/slab.h>\n#incl\nude <linux/time.h>\n#incl\nude <linux/fs.h>\n#incl\nude <linux/string.h>\n#incl\nude <linux/module.h>\n#incl\n\nc struct inode *romfs_iget(struct super_block *sb, unsigned long pos);\n\n/*;\nc const struct super_operations romfs_super_ops = {\n\t.alloc_inode\t= romfs_alloc_inode,\n\t.destroy_inode\t= romfs_destroy_inode,\n\t.statfs\t\t= romfs_statfs,\n\t.remount_fs\t= romfs_remount,\n};\n\n/*;\n\nc int romfs_fill_super(struct super_block *sb, void *data, int silent)\n{\n\tstruct romfs_super_block *rsb;\n\tstruct inode *root;\n\tunsigned long pos, img_size;\n\tconst char *storage;\n\tsize_t len;\n\tint ret;\n\n#ifdef CONFIG_BLOCK\n\tif (!sb->s_mtd) {\n\t\tsb_set_blocksize(sb, ROMBSIZE);\n\t} else {\n\t\tsb->s_blocksize = ROMBSIZE;\n\t\tsb->s_blocksize_bits = blksize_bits(ROMBSIZE);\n\t}\n#endif\n\n\tsb->s_maxbytes = 0xFFFFFFFF;\n\tsb->s_magic = ROMFS_MAGIC;\n\tsb->s_flags |= MS_RDONLY | MS_NOATIME;\n\tsb->s_op = &romfs_super_ops;\n\n\t/* read the image superblock and check it */\n\trsb = kmalloc(512, GFP_KERNEL);\n\tif (!rsb)\n\t\treturn -ENOMEM;\n\n\tsb->s_fs_info = (void *) 512;\n\tret = romfs_dev_read(sb, 0, rsb, 512);\n\tif (ret < 0)\n\t\tgoto error_rsb;\n\n\timg_size = be32_to_cpu(rsb->size);\n\n\tif (sb->s_mtd && img_size > sb->s_mtd->size)\n\t\tgoto error_rsb_inval;\n\n\tsb->s_fs_info = (void *) img_size;\n\n\tif (rsb->word0 != ROMSB_WORD0 || rsb->word1 != ROMSB_WORD1 ||\n\t    img_size < ROMFH_SIZE) {\n\t\tif (!silent)\n\t\t\tpr_warn(\"VFS: Can't find a romfs filesystem on dev %s.\\n\",\n\t\t\t       sb->s_id);\n\t\tgoto error_rsb_inval;\n\t}\n\n\tif (romfs_checksum(rsb, min_t(size_t, img_size, 512))) {\n\t\tpr_err(\"bad initial checksum on dev %s.\\n\", sb->s_id);\n\t\tgoto error_rsb_inval;\n\t}\n\n\tstorage = sb->s_mtd ? \"MTD\" : \"the block layer\";\n\n\tlen = strnlen(rsb->name, ROMFS_MAXFN);\n\tif (!silent)\n\t\tpr_notice(\"Mounting image '%*.*s' through %s\\n\",\n\t\t\t  (unsigned) len, (unsigned) len, rsb->name, storage);\n\n\tkfree(rsb);\n\trsb = NULL;\n\n\t/* find the root directory */\n\tpos = (ROMFH_SIZE + len + 1 + ROMFH_PAD) & ROMFH_MASK;\n\n\troot = romfs_iget(sb, pos);\n\tif (IS_ERR(root))\n\t\treturn PTR_ERR(root);\n\n\tsb->s_root = d_make_root(root);\n\tif (!sb->s_root)\n\t\treturn -ENOMEM;\n\n\treturn 0;\n\nerror_rsb_inval:\n\tret = -EINVAL;\nerror_rsb:\n\tkfree(rsb);\n\treturn ret;\n}\n\n/*"
        }
      },
      {
        "call_info": {
          "callee": "RR_CAST(",
          "args": [
            "b)"
          ],
          "line": 912
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ERR(",
          "args": [
            "b)"
          ],
          "line": 911
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get(",
          "args": [
            "s_type,",
            "s_test_super,",
            "s_set_super,",
            "lags,",
            "ata)"
          ],
          "line": 910
        },
        "resolved": true,
        "details": {
          "function_name": "get(",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/super.c",
          "lines": "437-486",
          "snippet": "truct super_block *sget(struct file_system_type *type,\n\t\t\tint (*test)(struct super_block *,void *),\n\t\t\tint (*set)(struct super_block *,void *),\n\t\t\tint flags,\n\t\t\tvoid *data)\n{\n\tstruct super_block *s = NULL;\n\tstruct super_block *old;\n\tint err;\n\nretry:\n\tspin_lock(&sb_lock);\n\tif (test) {\n\t\thlist_for_each_entry(old, &type->fs_supers, s_instances) {\n\t\t\tif (!test(old, data))\n\t\t\t\tcontinue;\n\t\t\tif (!grab_super(old))\n\t\t\t\tgoto retry;\n\t\t\tif (s) {\n\t\t\t\tup_write(&s->s_umount);\n\t\t\t\tdestroy_super(s);\n\t\t\t\ts = NULL;\n\t\t\t}\n\t\t\treturn old;\n\t\t}\n\t}\n\tif (!s) {\n\t\tspin_unlock(&sb_lock);\n\t\ts = alloc_super(type, flags);\n\t\tif (!s)\n\t\t\treturn ERR_PTR(-ENOMEM);\n\t\tgoto retry;\n\t}\n\t\t\n\terr = set(s, data);\n\tif (err) {\n\t\tspin_unlock(&sb_lock);\n\t\tup_write(&s->s_umount);\n\t\tdestroy_super(s);\n\t\treturn ERR_PTR(err);\n\t}\n\ts->s_type = type;\n\tstrlcpy(s->s_id, type->name, sizeof(s->s_id));\n\tlist_add_tail(&s->s_list, &super_blocks);\n\thlist_add_head(&s->s_instances, &type->fs_supers);\n\tspin_unlock(&sb_lock);\n\tget_filesystem(type);\n\tregister_shrinker(&s->s_shrink);\n\treturn s;\n}",
          "includes": [
            "include \"internal.h\"",
            "include <linux/lockdep.h>\n#",
            "include <linux/fsnotify.h>\n#",
            "include <linux/cleancache.h>\n#",
            "include <linux/rculist_bl.h>\n#",
            "include <linux/backing-dev.h>\n#",
            "include <linux/mutex.h>\n#",
            "include <linux/idr.h>\n#",
            "include <linux/writeback.h>\t\t/* for the emergency remount stuff */\n#",
            "include <linux/security.h>\n#",
            "include <linux/mount.h>\n#",
            "include <linux/blkdev.h>\n#",
            "include <linux/slab.h>\n#",
            "include <linux/export.h>\n#"
          ],
          "macros_used": [],
          "globals_used": [
            "tatic LIST_HEAD(super_blocks);",
            "tatic DEFINE_SPINLOCK(sb_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "include \"internal.h\"\ninclude <linux/lockdep.h>\n#\ninclude <linux/fsnotify.h>\n#\ninclude <linux/cleancache.h>\n#\ninclude <linux/rculist_bl.h>\n#\ninclude <linux/backing-dev.h>\n#\ninclude <linux/mutex.h>\n#\ninclude <linux/idr.h>\n#\ninclude <linux/writeback.h>\t\t/* for the emergency remount stuff */\n#\ninclude <linux/security.h>\n#\ninclude <linux/mount.h>\n#\ninclude <linux/blkdev.h>\n#\ninclude <linux/slab.h>\n#\ninclude <linux/export.h>\n#\n\ntatic LIST_HEAD(super_blocks);\ntatic DEFINE_SPINLOCK(sb_lock);\n\ntruct super_block *sget(struct file_system_type *type,\n\t\t\tint (*test)(struct super_block *,void *),\n\t\t\tint (*set)(struct super_block *,void *),\n\t\t\tint flags,\n\t\t\tvoid *data)\n{\n\tstruct super_block *s = NULL;\n\tstruct super_block *old;\n\tint err;\n\nretry:\n\tspin_lock(&sb_lock);\n\tif (test) {\n\t\thlist_for_each_entry(old, &type->fs_supers, s_instances) {\n\t\t\tif (!test(old, data))\n\t\t\t\tcontinue;\n\t\t\tif (!grab_super(old))\n\t\t\t\tgoto retry;\n\t\t\tif (s) {\n\t\t\t\tup_write(&s->s_umount);\n\t\t\t\tdestroy_super(s);\n\t\t\t\ts = NULL;\n\t\t\t}\n\t\t\treturn old;\n\t\t}\n\t}\n\tif (!s) {\n\t\tspin_unlock(&sb_lock);\n\t\ts = alloc_super(type, flags);\n\t\tif (!s)\n\t\t\treturn ERR_PTR(-ENOMEM);\n\t\tgoto retry;\n\t}\n\t\t\n\terr = set(s, data);\n\tif (err) {\n\t\tspin_unlock(&sb_lock);\n\t\tup_write(&s->s_umount);\n\t\tdestroy_super(s);\n\t\treturn ERR_PTR(err);\n\t}\n\ts->s_type = type;\n\tstrlcpy(s->s_id, type->name, sizeof(s->s_id));\n\tlist_add_tail(&s->s_list, &super_blocks);\n\thlist_add_head(&s->s_instances, &type->fs_supers);\n\tspin_unlock(&sb_lock);\n\tget_filesystem(type);\n\tregister_shrinker(&s->s_shrink);\n\treturn s;\n}"
        }
      }
    ],
    "contextual_snippet": "include \"internal.h\"\ninclude <linux/lockdep.h>\n#\ninclude <linux/fsnotify.h>\n#\ninclude <linux/cleancache.h>\n#\ninclude <linux/rculist_bl.h>\n#\ninclude <linux/backing-dev.h>\n#\ninclude <linux/mutex.h>\n#\ninclude <linux/idr.h>\n#\ninclude <linux/writeback.h>\t\t/* for the emergency remount stuff */\n#\ninclude <linux/security.h>\n#\ninclude <linux/mount.h>\n#\ninclude <linux/blkdev.h>\n#\ninclude <linux/slab.h>\n#\ninclude <linux/export.h>\n#\n\ntruct dentry *mount_ns(struct file_system_type *fs_type, int flags,\n\tvoid *data, int (*fill_super)(struct super_block *, void *, int))\n{\n\tstruct super_block *sb;\n\n\tsb = sget(fs_type, ns_test_super, ns_set_super, flags, data);\n\tif (IS_ERR(sb))\n\t\treturn ERR_CAST(sb);\n\n\tif (!sb->s_root) {\n\t\tint err;\n\t\terr = fill_super(sb, data, flags & MS_SILENT ? 1 : 0);\n\t\tif (err) {\n\t\t\tdeactivate_locked_super(sb);\n\t\t\treturn ERR_PTR(err);\n\t\t}\n\n\t\tsb->s_flags |= MS_ACTIVE;\n\t}\n\n\treturn dget(sb->s_root);\n}"
  },
  {
    "function_name": "s_set_super(",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/super.c",
    "lines": "899-903",
    "snippet": "tatic int ns_set_super(struct super_block *sb, void *data)\n{\n\tsb->s_fs_info = data;\n\treturn set_anon_super(sb, NULL);\n}",
    "includes": [
      "include \"internal.h\"",
      "include <linux/lockdep.h>\n#",
      "include <linux/fsnotify.h>\n#",
      "include <linux/cleancache.h>\n#",
      "include <linux/rculist_bl.h>\n#",
      "include <linux/backing-dev.h>\n#",
      "include <linux/mutex.h>\n#",
      "include <linux/idr.h>\n#",
      "include <linux/writeback.h>\t\t/* for the emergency remount stuff */\n#",
      "include <linux/security.h>\n#",
      "include <linux/mount.h>\n#",
      "include <linux/blkdev.h>\n#",
      "include <linux/slab.h>\n#",
      "include <linux/export.h>\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "et_anon_super(",
          "args": [
            "b,",
            "ULL)"
          ],
          "line": 902
        },
        "resolved": true,
        "details": {
          "function_name": "et_anon_super(",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/super.c",
          "lines": "869-872",
          "snippet": "nt set_anon_super(struct super_block *s, void *data)\n{\n\treturn get_anon_bdev(&s->s_dev);\n}",
          "includes": [
            "include \"internal.h\"",
            "include <linux/lockdep.h>\n#",
            "include <linux/fsnotify.h>\n#",
            "include <linux/cleancache.h>\n#",
            "include <linux/rculist_bl.h>\n#",
            "include <linux/backing-dev.h>\n#",
            "include <linux/mutex.h>\n#",
            "include <linux/idr.h>\n#",
            "include <linux/writeback.h>\t\t/* for the emergency remount stuff */\n#",
            "include <linux/security.h>\n#",
            "include <linux/mount.h>\n#",
            "include <linux/blkdev.h>\n#",
            "include <linux/slab.h>\n#",
            "include <linux/export.h>\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"internal.h\"\ninclude <linux/lockdep.h>\n#\ninclude <linux/fsnotify.h>\n#\ninclude <linux/cleancache.h>\n#\ninclude <linux/rculist_bl.h>\n#\ninclude <linux/backing-dev.h>\n#\ninclude <linux/mutex.h>\n#\ninclude <linux/idr.h>\n#\ninclude <linux/writeback.h>\t\t/* for the emergency remount stuff */\n#\ninclude <linux/security.h>\n#\ninclude <linux/mount.h>\n#\ninclude <linux/blkdev.h>\n#\ninclude <linux/slab.h>\n#\ninclude <linux/export.h>\n#\n\nnt set_anon_super(struct super_block *s, void *data)\n{\n\treturn get_anon_bdev(&s->s_dev);\n}"
        }
      }
    ],
    "contextual_snippet": "include \"internal.h\"\ninclude <linux/lockdep.h>\n#\ninclude <linux/fsnotify.h>\n#\ninclude <linux/cleancache.h>\n#\ninclude <linux/rculist_bl.h>\n#\ninclude <linux/backing-dev.h>\n#\ninclude <linux/mutex.h>\n#\ninclude <linux/idr.h>\n#\ninclude <linux/writeback.h>\t\t/* for the emergency remount stuff */\n#\ninclude <linux/security.h>\n#\ninclude <linux/mount.h>\n#\ninclude <linux/blkdev.h>\n#\ninclude <linux/slab.h>\n#\ninclude <linux/export.h>\n#\n\ntatic int ns_set_super(struct super_block *sb, void *data)\n{\n\tsb->s_fs_info = data;\n\treturn set_anon_super(sb, NULL);\n}"
  },
  {
    "function_name": "s_test_super(",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/super.c",
    "lines": "894-897",
    "snippet": "tatic int ns_test_super(struct super_block *sb, void *data)\n{\n\treturn sb->s_fs_info == data;\n}",
    "includes": [
      "include \"internal.h\"",
      "include <linux/lockdep.h>\n#",
      "include <linux/fsnotify.h>\n#",
      "include <linux/cleancache.h>\n#",
      "include <linux/rculist_bl.h>\n#",
      "include <linux/backing-dev.h>\n#",
      "include <linux/mutex.h>\n#",
      "include <linux/idr.h>\n#",
      "include <linux/writeback.h>\t\t/* for the emergency remount stuff */\n#",
      "include <linux/security.h>\n#",
      "include <linux/mount.h>\n#",
      "include <linux/blkdev.h>\n#",
      "include <linux/slab.h>\n#",
      "include <linux/export.h>\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "include \"internal.h\"\ninclude <linux/lockdep.h>\n#\ninclude <linux/fsnotify.h>\n#\ninclude <linux/cleancache.h>\n#\ninclude <linux/rculist_bl.h>\n#\ninclude <linux/backing-dev.h>\n#\ninclude <linux/mutex.h>\n#\ninclude <linux/idr.h>\n#\ninclude <linux/writeback.h>\t\t/* for the emergency remount stuff */\n#\ninclude <linux/security.h>\n#\ninclude <linux/mount.h>\n#\ninclude <linux/blkdev.h>\n#\ninclude <linux/slab.h>\n#\ninclude <linux/export.h>\n#\n\ntatic int ns_test_super(struct super_block *sb, void *data)\n{\n\treturn sb->s_fs_info == data;\n}"
  },
  {
    "function_name": "ill_litter_super(",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/super.c",
    "lines": "885-890",
    "snippet": "oid kill_litter_super(struct super_block *sb)\n{\n\tif (sb->s_root)\n\t\td_genocide(sb->s_root);\n\tkill_anon_super(sb);\n}",
    "includes": [
      "include \"internal.h\"",
      "include <linux/lockdep.h>\n#",
      "include <linux/fsnotify.h>\n#",
      "include <linux/cleancache.h>\n#",
      "include <linux/rculist_bl.h>\n#",
      "include <linux/backing-dev.h>\n#",
      "include <linux/mutex.h>\n#",
      "include <linux/idr.h>\n#",
      "include <linux/writeback.h>\t\t/* for the emergency remount stuff */\n#",
      "include <linux/security.h>\n#",
      "include <linux/mount.h>\n#",
      "include <linux/blkdev.h>\n#",
      "include <linux/slab.h>\n#",
      "include <linux/export.h>\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ill_anon_super(",
          "args": [
            "b)"
          ],
          "line": 889
        },
        "resolved": true,
        "details": {
          "function_name": "ill_anon_super(",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/super.c",
          "lines": "876-881",
          "snippet": "oid kill_anon_super(struct super_block *sb)\n{\n\tdev_t dev = sb->s_dev;\n\tgeneric_shutdown_super(sb);\n\tfree_anon_bdev(dev);\n}",
          "includes": [
            "include \"internal.h\"",
            "include <linux/lockdep.h>\n#",
            "include <linux/fsnotify.h>\n#",
            "include <linux/cleancache.h>\n#",
            "include <linux/rculist_bl.h>\n#",
            "include <linux/backing-dev.h>\n#",
            "include <linux/mutex.h>\n#",
            "include <linux/idr.h>\n#",
            "include <linux/writeback.h>\t\t/* for the emergency remount stuff */\n#",
            "include <linux/security.h>\n#",
            "include <linux/mount.h>\n#",
            "include <linux/blkdev.h>\n#",
            "include <linux/slab.h>\n#",
            "include <linux/export.h>\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"internal.h\"\ninclude <linux/lockdep.h>\n#\ninclude <linux/fsnotify.h>\n#\ninclude <linux/cleancache.h>\n#\ninclude <linux/rculist_bl.h>\n#\ninclude <linux/backing-dev.h>\n#\ninclude <linux/mutex.h>\n#\ninclude <linux/idr.h>\n#\ninclude <linux/writeback.h>\t\t/* for the emergency remount stuff */\n#\ninclude <linux/security.h>\n#\ninclude <linux/mount.h>\n#\ninclude <linux/blkdev.h>\n#\ninclude <linux/slab.h>\n#\ninclude <linux/export.h>\n#\n\noid kill_anon_super(struct super_block *sb)\n{\n\tdev_t dev = sb->s_dev;\n\tgeneric_shutdown_super(sb);\n\tfree_anon_bdev(dev);\n}"
        }
      },
      {
        "call_info": {
          "callee": "_genocide(",
          "args": [
            "b->s_root)"
          ],
          "line": 888
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "include \"internal.h\"\ninclude <linux/lockdep.h>\n#\ninclude <linux/fsnotify.h>\n#\ninclude <linux/cleancache.h>\n#\ninclude <linux/rculist_bl.h>\n#\ninclude <linux/backing-dev.h>\n#\ninclude <linux/mutex.h>\n#\ninclude <linux/idr.h>\n#\ninclude <linux/writeback.h>\t\t/* for the emergency remount stuff */\n#\ninclude <linux/security.h>\n#\ninclude <linux/mount.h>\n#\ninclude <linux/blkdev.h>\n#\ninclude <linux/slab.h>\n#\ninclude <linux/export.h>\n#\n\noid kill_litter_super(struct super_block *sb)\n{\n\tif (sb->s_root)\n\t\td_genocide(sb->s_root);\n\tkill_anon_super(sb);\n}"
  },
  {
    "function_name": "ill_anon_super(",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/super.c",
    "lines": "876-881",
    "snippet": "oid kill_anon_super(struct super_block *sb)\n{\n\tdev_t dev = sb->s_dev;\n\tgeneric_shutdown_super(sb);\n\tfree_anon_bdev(dev);\n}",
    "includes": [
      "include \"internal.h\"",
      "include <linux/lockdep.h>\n#",
      "include <linux/fsnotify.h>\n#",
      "include <linux/cleancache.h>\n#",
      "include <linux/rculist_bl.h>\n#",
      "include <linux/backing-dev.h>\n#",
      "include <linux/mutex.h>\n#",
      "include <linux/idr.h>\n#",
      "include <linux/writeback.h>\t\t/* for the emergency remount stuff */\n#",
      "include <linux/security.h>\n#",
      "include <linux/mount.h>\n#",
      "include <linux/blkdev.h>\n#",
      "include <linux/slab.h>\n#",
      "include <linux/export.h>\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ree_anon_bdev(",
          "args": [
            "ev)"
          ],
          "line": 880
        },
        "resolved": true,
        "details": {
          "function_name": "ree_anon_bdev(",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/super.c",
          "lines": "858-866",
          "snippet": "oid free_anon_bdev(dev_t dev)\n{\n\tint slot = MINOR(dev);\n\tspin_lock(&unnamed_dev_lock);\n\tida_remove(&unnamed_dev_ida, slot);\n\tif (slot < unnamed_dev_start)\n\t\tunnamed_dev_start = slot;\n\tspin_unlock(&unnamed_dev_lock);\n}",
          "includes": [
            "include \"internal.h\"",
            "include <linux/lockdep.h>\n#",
            "include <linux/fsnotify.h>\n#",
            "include <linux/cleancache.h>\n#",
            "include <linux/rculist_bl.h>\n#",
            "include <linux/backing-dev.h>\n#",
            "include <linux/mutex.h>\n#",
            "include <linux/idr.h>\n#",
            "include <linux/writeback.h>\t\t/* for the emergency remount stuff */\n#",
            "include <linux/security.h>\n#",
            "include <linux/mount.h>\n#",
            "include <linux/blkdev.h>\n#",
            "include <linux/slab.h>\n#",
            "include <linux/export.h>\n#"
          ],
          "macros_used": [],
          "globals_used": [
            "tatic DEFINE_IDA(unnamed_dev_ida);",
            "tatic DEFINE_SPINLOCK(unnamed_dev_lock);/",
            "tatic int unnamed_dev_start = 1;"
          ],
          "called_functions": [],
          "contextual_snippet": "include \"internal.h\"\ninclude <linux/lockdep.h>\n#\ninclude <linux/fsnotify.h>\n#\ninclude <linux/cleancache.h>\n#\ninclude <linux/rculist_bl.h>\n#\ninclude <linux/backing-dev.h>\n#\ninclude <linux/mutex.h>\n#\ninclude <linux/idr.h>\n#\ninclude <linux/writeback.h>\t\t/* for the emergency remount stuff */\n#\ninclude <linux/security.h>\n#\ninclude <linux/mount.h>\n#\ninclude <linux/blkdev.h>\n#\ninclude <linux/slab.h>\n#\ninclude <linux/export.h>\n#\n\ntatic DEFINE_IDA(unnamed_dev_ida);\ntatic DEFINE_SPINLOCK(unnamed_dev_lock);/;\ntatic int unnamed_dev_start = 1;\n\noid free_anon_bdev(dev_t dev)\n{\n\tint slot = MINOR(dev);\n\tspin_lock(&unnamed_dev_lock);\n\tida_remove(&unnamed_dev_ida, slot);\n\tif (slot < unnamed_dev_start)\n\t\tunnamed_dev_start = slot;\n\tspin_unlock(&unnamed_dev_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "eneric_shutdown_super(",
          "args": [
            "b)"
          ],
          "line": 879
        },
        "resolved": true,
        "details": {
          "function_name": "eneric_shutdown_super(",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/super.c",
          "lines": "393-425",
          "snippet": "oid generic_shutdown_super(struct super_block *sb)\n{\n\tconst struct super_operations *sop = sb->s_op;\n\n\tif (sb->s_root) {\n\t\tshrink_dcache_for_umount(sb);\n\t\tsync_filesystem(sb);\n\t\tsb->s_flags &= ~MS_ACTIVE;\n\n\t\tfsnotify_unmount_inodes(&sb->s_inodes);\n\n\t\tevict_inodes(sb);\n\n\t\tif (sb->s_dio_done_wq) {\n\t\t\tdestroy_workqueue(sb->s_dio_done_wq);\n\t\t\tsb->s_dio_done_wq = NULL;\n\t\t}\n\n\t\tif (sop->put_super)\n\t\t\tsop->put_super(sb);\n\n\t\tif (!list_empty(&sb->s_inodes)) {\n\t\t\tprintk(\"VFS: Busy inodes after unmount of %s. \"\n\t\t\t   \"Self-destruct in 5 seconds.  Have a nice day...\\n\",\n\t\t\t   sb->s_id);\n\t\t}\n\t}\n\tspin_lock(&sb_lock);\n\t/* should be initialized for __put_super_and_need_restart() */\n\thlist_del_init(&sb->s_instances);\n\tspin_unlock(&sb_lock);\n\tup_write(&sb->s_umount);\n}",
          "includes": [
            "include \"internal.h\"",
            "include <linux/lockdep.h>\n#",
            "include <linux/fsnotify.h>\n#",
            "include <linux/cleancache.h>\n#",
            "include <linux/rculist_bl.h>\n#",
            "include <linux/backing-dev.h>\n#",
            "include <linux/mutex.h>\n#",
            "include <linux/idr.h>\n#",
            "include <linux/writeback.h>\t\t/* for the emergency remount stuff */\n#",
            "include <linux/security.h>\n#",
            "include <linux/mount.h>\n#",
            "include <linux/blkdev.h>\n#",
            "include <linux/slab.h>\n#",
            "include <linux/export.h>\n#"
          ],
          "macros_used": [],
          "globals_used": [
            "tatic DEFINE_SPINLOCK(sb_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "include \"internal.h\"\ninclude <linux/lockdep.h>\n#\ninclude <linux/fsnotify.h>\n#\ninclude <linux/cleancache.h>\n#\ninclude <linux/rculist_bl.h>\n#\ninclude <linux/backing-dev.h>\n#\ninclude <linux/mutex.h>\n#\ninclude <linux/idr.h>\n#\ninclude <linux/writeback.h>\t\t/* for the emergency remount stuff */\n#\ninclude <linux/security.h>\n#\ninclude <linux/mount.h>\n#\ninclude <linux/blkdev.h>\n#\ninclude <linux/slab.h>\n#\ninclude <linux/export.h>\n#\n\ntatic DEFINE_SPINLOCK(sb_lock);\n\noid generic_shutdown_super(struct super_block *sb)\n{\n\tconst struct super_operations *sop = sb->s_op;\n\n\tif (sb->s_root) {\n\t\tshrink_dcache_for_umount(sb);\n\t\tsync_filesystem(sb);\n\t\tsb->s_flags &= ~MS_ACTIVE;\n\n\t\tfsnotify_unmount_inodes(&sb->s_inodes);\n\n\t\tevict_inodes(sb);\n\n\t\tif (sb->s_dio_done_wq) {\n\t\t\tdestroy_workqueue(sb->s_dio_done_wq);\n\t\t\tsb->s_dio_done_wq = NULL;\n\t\t}\n\n\t\tif (sop->put_super)\n\t\t\tsop->put_super(sb);\n\n\t\tif (!list_empty(&sb->s_inodes)) {\n\t\t\tprintk(\"VFS: Busy inodes after unmount of %s. \"\n\t\t\t   \"Self-destruct in 5 seconds.  Have a nice day...\\n\",\n\t\t\t   sb->s_id);\n\t\t}\n\t}\n\tspin_lock(&sb_lock);\n\t/* should be initialized for __put_super_and_need_restart() */\n\thlist_del_init(&sb->s_instances);\n\tspin_unlock(&sb_lock);\n\tup_write(&sb->s_umount);\n}"
        }
      }
    ],
    "contextual_snippet": "include \"internal.h\"\ninclude <linux/lockdep.h>\n#\ninclude <linux/fsnotify.h>\n#\ninclude <linux/cleancache.h>\n#\ninclude <linux/rculist_bl.h>\n#\ninclude <linux/backing-dev.h>\n#\ninclude <linux/mutex.h>\n#\ninclude <linux/idr.h>\n#\ninclude <linux/writeback.h>\t\t/* for the emergency remount stuff */\n#\ninclude <linux/security.h>\n#\ninclude <linux/mount.h>\n#\ninclude <linux/blkdev.h>\n#\ninclude <linux/slab.h>\n#\ninclude <linux/export.h>\n#\n\noid kill_anon_super(struct super_block *sb)\n{\n\tdev_t dev = sb->s_dev;\n\tgeneric_shutdown_super(sb);\n\tfree_anon_bdev(dev);\n}"
  },
  {
    "function_name": "et_anon_super(",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/super.c",
    "lines": "869-872",
    "snippet": "nt set_anon_super(struct super_block *s, void *data)\n{\n\treturn get_anon_bdev(&s->s_dev);\n}",
    "includes": [
      "include \"internal.h\"",
      "include <linux/lockdep.h>\n#",
      "include <linux/fsnotify.h>\n#",
      "include <linux/cleancache.h>\n#",
      "include <linux/rculist_bl.h>\n#",
      "include <linux/backing-dev.h>\n#",
      "include <linux/mutex.h>\n#",
      "include <linux/idr.h>\n#",
      "include <linux/writeback.h>\t\t/* for the emergency remount stuff */\n#",
      "include <linux/security.h>\n#",
      "include <linux/mount.h>\n#",
      "include <linux/blkdev.h>\n#",
      "include <linux/slab.h>\n#",
      "include <linux/export.h>\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "et_anon_bdev(",
          "args": [
            "s->s_dev)"
          ],
          "line": 871
        },
        "resolved": true,
        "details": {
          "function_name": "et_anon_bdev(",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/super.c",
          "lines": "826-855",
          "snippet": "nt get_anon_bdev(dev_t *p)\n{\n\tint dev;\n\tint error;\n\n retry:\n\tif (ida_pre_get(&unnamed_dev_ida, GFP_ATOMIC) == 0)\n\t\treturn -ENOMEM;\n\tspin_lock(&unnamed_dev_lock);\n\terror = ida_get_new_above(&unnamed_dev_ida, unnamed_dev_start, &dev);\n\tif (!error)\n\t\tunnamed_dev_start = dev + 1;\n\tspin_unlock(&unnamed_dev_lock);\n\tif (error == -EAGAIN)\n\t\t/* We raced and lost with another CPU. */\n\t\tgoto retry;\n\telse if (error)\n\t\treturn -EAGAIN;\n\n\tif (dev == (1 << MINORBITS)) {\n\t\tspin_lock(&unnamed_dev_lock);\n\t\tida_remove(&unnamed_dev_ida, dev);\n\t\tif (unnamed_dev_start > dev)\n\t\t\tunnamed_dev_start = dev;\n\t\tspin_unlock(&unnamed_dev_lock);\n\t\treturn -EMFILE;\n\t}\n\t*p = MKDEV(0, dev & MINORMASK);\n\treturn 0;\n}",
          "includes": [
            "include \"internal.h\"",
            "include <linux/lockdep.h>\n#",
            "include <linux/fsnotify.h>\n#",
            "include <linux/cleancache.h>\n#",
            "include <linux/rculist_bl.h>\n#",
            "include <linux/backing-dev.h>\n#",
            "include <linux/mutex.h>\n#",
            "include <linux/idr.h>\n#",
            "include <linux/writeback.h>\t\t/* for the emergency remount stuff */\n#",
            "include <linux/security.h>\n#",
            "include <linux/mount.h>\n#",
            "include <linux/blkdev.h>\n#",
            "include <linux/slab.h>\n#",
            "include <linux/export.h>\n#"
          ],
          "macros_used": [],
          "globals_used": [
            "tatic DEFINE_IDA(unnamed_dev_ida);",
            "tatic DEFINE_SPINLOCK(unnamed_dev_lock);/",
            "tatic int unnamed_dev_start = 1;"
          ],
          "called_functions": [],
          "contextual_snippet": "include \"internal.h\"\ninclude <linux/lockdep.h>\n#\ninclude <linux/fsnotify.h>\n#\ninclude <linux/cleancache.h>\n#\ninclude <linux/rculist_bl.h>\n#\ninclude <linux/backing-dev.h>\n#\ninclude <linux/mutex.h>\n#\ninclude <linux/idr.h>\n#\ninclude <linux/writeback.h>\t\t/* for the emergency remount stuff */\n#\ninclude <linux/security.h>\n#\ninclude <linux/mount.h>\n#\ninclude <linux/blkdev.h>\n#\ninclude <linux/slab.h>\n#\ninclude <linux/export.h>\n#\n\ntatic DEFINE_IDA(unnamed_dev_ida);\ntatic DEFINE_SPINLOCK(unnamed_dev_lock);/;\ntatic int unnamed_dev_start = 1;\n\nnt get_anon_bdev(dev_t *p)\n{\n\tint dev;\n\tint error;\n\n retry:\n\tif (ida_pre_get(&unnamed_dev_ida, GFP_ATOMIC) == 0)\n\t\treturn -ENOMEM;\n\tspin_lock(&unnamed_dev_lock);\n\terror = ida_get_new_above(&unnamed_dev_ida, unnamed_dev_start, &dev);\n\tif (!error)\n\t\tunnamed_dev_start = dev + 1;\n\tspin_unlock(&unnamed_dev_lock);\n\tif (error == -EAGAIN)\n\t\t/* We raced and lost with another CPU. */\n\t\tgoto retry;\n\telse if (error)\n\t\treturn -EAGAIN;\n\n\tif (dev == (1 << MINORBITS)) {\n\t\tspin_lock(&unnamed_dev_lock);\n\t\tida_remove(&unnamed_dev_ida, dev);\n\t\tif (unnamed_dev_start > dev)\n\t\t\tunnamed_dev_start = dev;\n\t\tspin_unlock(&unnamed_dev_lock);\n\t\treturn -EMFILE;\n\t}\n\t*p = MKDEV(0, dev & MINORMASK);\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "include \"internal.h\"\ninclude <linux/lockdep.h>\n#\ninclude <linux/fsnotify.h>\n#\ninclude <linux/cleancache.h>\n#\ninclude <linux/rculist_bl.h>\n#\ninclude <linux/backing-dev.h>\n#\ninclude <linux/mutex.h>\n#\ninclude <linux/idr.h>\n#\ninclude <linux/writeback.h>\t\t/* for the emergency remount stuff */\n#\ninclude <linux/security.h>\n#\ninclude <linux/mount.h>\n#\ninclude <linux/blkdev.h>\n#\ninclude <linux/slab.h>\n#\ninclude <linux/export.h>\n#\n\nnt set_anon_super(struct super_block *s, void *data)\n{\n\treturn get_anon_bdev(&s->s_dev);\n}"
  },
  {
    "function_name": "ree_anon_bdev(",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/super.c",
    "lines": "858-866",
    "snippet": "oid free_anon_bdev(dev_t dev)\n{\n\tint slot = MINOR(dev);\n\tspin_lock(&unnamed_dev_lock);\n\tida_remove(&unnamed_dev_ida, slot);\n\tif (slot < unnamed_dev_start)\n\t\tunnamed_dev_start = slot;\n\tspin_unlock(&unnamed_dev_lock);\n}",
    "includes": [
      "include \"internal.h\"",
      "include <linux/lockdep.h>\n#",
      "include <linux/fsnotify.h>\n#",
      "include <linux/cleancache.h>\n#",
      "include <linux/rculist_bl.h>\n#",
      "include <linux/backing-dev.h>\n#",
      "include <linux/mutex.h>\n#",
      "include <linux/idr.h>\n#",
      "include <linux/writeback.h>\t\t/* for the emergency remount stuff */\n#",
      "include <linux/security.h>\n#",
      "include <linux/mount.h>\n#",
      "include <linux/blkdev.h>\n#",
      "include <linux/slab.h>\n#",
      "include <linux/export.h>\n#"
    ],
    "macros_used": [],
    "globals_used": [
      "tatic DEFINE_IDA(unnamed_dev_ida);",
      "tatic DEFINE_SPINLOCK(unnamed_dev_lock);/",
      "tatic int unnamed_dev_start = 1;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "pin_unlock(",
          "args": [
            "unnamed_dev_lock)"
          ],
          "line": 865
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "da_remove(",
          "args": [
            "unnamed_dev_ida,",
            "lot)"
          ],
          "line": 862
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pin_lock(",
          "args": [
            "unnamed_dev_lock)"
          ],
          "line": 861
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INOR(",
          "args": [
            "ev)"
          ],
          "line": 860
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "include \"internal.h\"\ninclude <linux/lockdep.h>\n#\ninclude <linux/fsnotify.h>\n#\ninclude <linux/cleancache.h>\n#\ninclude <linux/rculist_bl.h>\n#\ninclude <linux/backing-dev.h>\n#\ninclude <linux/mutex.h>\n#\ninclude <linux/idr.h>\n#\ninclude <linux/writeback.h>\t\t/* for the emergency remount stuff */\n#\ninclude <linux/security.h>\n#\ninclude <linux/mount.h>\n#\ninclude <linux/blkdev.h>\n#\ninclude <linux/slab.h>\n#\ninclude <linux/export.h>\n#\n\ntatic DEFINE_IDA(unnamed_dev_ida);\ntatic DEFINE_SPINLOCK(unnamed_dev_lock);/;\ntatic int unnamed_dev_start = 1;\n\noid free_anon_bdev(dev_t dev)\n{\n\tint slot = MINOR(dev);\n\tspin_lock(&unnamed_dev_lock);\n\tida_remove(&unnamed_dev_ida, slot);\n\tif (slot < unnamed_dev_start)\n\t\tunnamed_dev_start = slot;\n\tspin_unlock(&unnamed_dev_lock);\n}"
  },
  {
    "function_name": "et_anon_bdev(",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/super.c",
    "lines": "826-855",
    "snippet": "nt get_anon_bdev(dev_t *p)\n{\n\tint dev;\n\tint error;\n\n retry:\n\tif (ida_pre_get(&unnamed_dev_ida, GFP_ATOMIC) == 0)\n\t\treturn -ENOMEM;\n\tspin_lock(&unnamed_dev_lock);\n\terror = ida_get_new_above(&unnamed_dev_ida, unnamed_dev_start, &dev);\n\tif (!error)\n\t\tunnamed_dev_start = dev + 1;\n\tspin_unlock(&unnamed_dev_lock);\n\tif (error == -EAGAIN)\n\t\t/* We raced and lost with another CPU. */\n\t\tgoto retry;\n\telse if (error)\n\t\treturn -EAGAIN;\n\n\tif (dev == (1 << MINORBITS)) {\n\t\tspin_lock(&unnamed_dev_lock);\n\t\tida_remove(&unnamed_dev_ida, dev);\n\t\tif (unnamed_dev_start > dev)\n\t\t\tunnamed_dev_start = dev;\n\t\tspin_unlock(&unnamed_dev_lock);\n\t\treturn -EMFILE;\n\t}\n\t*p = MKDEV(0, dev & MINORMASK);\n\treturn 0;\n}",
    "includes": [
      "include \"internal.h\"",
      "include <linux/lockdep.h>\n#",
      "include <linux/fsnotify.h>\n#",
      "include <linux/cleancache.h>\n#",
      "include <linux/rculist_bl.h>\n#",
      "include <linux/backing-dev.h>\n#",
      "include <linux/mutex.h>\n#",
      "include <linux/idr.h>\n#",
      "include <linux/writeback.h>\t\t/* for the emergency remount stuff */\n#",
      "include <linux/security.h>\n#",
      "include <linux/mount.h>\n#",
      "include <linux/blkdev.h>\n#",
      "include <linux/slab.h>\n#",
      "include <linux/export.h>\n#"
    ],
    "macros_used": [],
    "globals_used": [
      "tatic DEFINE_IDA(unnamed_dev_ida);",
      "tatic DEFINE_SPINLOCK(unnamed_dev_lock);/",
      "tatic int unnamed_dev_start = 1;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "KDEV(",
          "args": [
            ",",
            "ev & MINORMASK)"
          ],
          "line": 853
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pin_unlock(",
          "args": [
            "unnamed_dev_lock)"
          ],
          "line": 850
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "da_remove(",
          "args": [
            "unnamed_dev_ida,",
            "ev)"
          ],
          "line": 847
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pin_lock(",
          "args": [
            "unnamed_dev_lock)"
          ],
          "line": 846
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pin_unlock(",
          "args": [
            "unnamed_dev_lock)"
          ],
          "line": 838
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "da_get_new_above(",
          "args": [
            "unnamed_dev_ida,",
            "nnamed_dev_start,",
            "dev)"
          ],
          "line": 835
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pin_lock(",
          "args": [
            "unnamed_dev_lock)"
          ],
          "line": 834
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "da_pre_get(",
          "args": [
            "unnamed_dev_ida,",
            "FP_ATOMIC)"
          ],
          "line": 832
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "include \"internal.h\"\ninclude <linux/lockdep.h>\n#\ninclude <linux/fsnotify.h>\n#\ninclude <linux/cleancache.h>\n#\ninclude <linux/rculist_bl.h>\n#\ninclude <linux/backing-dev.h>\n#\ninclude <linux/mutex.h>\n#\ninclude <linux/idr.h>\n#\ninclude <linux/writeback.h>\t\t/* for the emergency remount stuff */\n#\ninclude <linux/security.h>\n#\ninclude <linux/mount.h>\n#\ninclude <linux/blkdev.h>\n#\ninclude <linux/slab.h>\n#\ninclude <linux/export.h>\n#\n\ntatic DEFINE_IDA(unnamed_dev_ida);\ntatic DEFINE_SPINLOCK(unnamed_dev_lock);/;\ntatic int unnamed_dev_start = 1;\n\nnt get_anon_bdev(dev_t *p)\n{\n\tint dev;\n\tint error;\n\n retry:\n\tif (ida_pre_get(&unnamed_dev_ida, GFP_ATOMIC) == 0)\n\t\treturn -ENOMEM;\n\tspin_lock(&unnamed_dev_lock);\n\terror = ida_get_new_above(&unnamed_dev_ida, unnamed_dev_start, &dev);\n\tif (!error)\n\t\tunnamed_dev_start = dev + 1;\n\tspin_unlock(&unnamed_dev_lock);\n\tif (error == -EAGAIN)\n\t\t/* We raced and lost with another CPU. */\n\t\tgoto retry;\n\telse if (error)\n\t\treturn -EAGAIN;\n\n\tif (dev == (1 << MINORBITS)) {\n\t\tspin_lock(&unnamed_dev_lock);\n\t\tida_remove(&unnamed_dev_ida, dev);\n\t\tif (unnamed_dev_start > dev)\n\t\t\tunnamed_dev_start = dev;\n\t\tspin_unlock(&unnamed_dev_lock);\n\t\treturn -EMFILE;\n\t}\n\t*p = MKDEV(0, dev & MINORMASK);\n\treturn 0;\n}"
  },
  {
    "function_name": "mergency_remount(",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/super.c",
    "lines": "803-812",
    "snippet": "oid emergency_remount(void)\n{\n\tstruct work_struct *work;\n\n\twork = kmalloc(sizeof(*work), GFP_ATOMIC);\n\tif (work) {\n\t\tINIT_WORK(work, do_emergency_remount);\n\t\tschedule_work(work);\n\t}\n}",
    "includes": [
      "include \"internal.h\"",
      "include <linux/lockdep.h>\n#",
      "include <linux/fsnotify.h>\n#",
      "include <linux/cleancache.h>\n#",
      "include <linux/rculist_bl.h>\n#",
      "include <linux/backing-dev.h>\n#",
      "include <linux/mutex.h>\n#",
      "include <linux/idr.h>\n#",
      "include <linux/writeback.h>\t\t/* for the emergency remount stuff */\n#",
      "include <linux/security.h>\n#",
      "include <linux/mount.h>\n#",
      "include <linux/blkdev.h>\n#",
      "include <linux/slab.h>\n#",
      "include <linux/export.h>\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "chedule_work(",
          "args": [
            "ork)"
          ],
          "line": 810
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NIT_WORK(",
          "args": [
            "ork,",
            "o_emergency_remount)"
          ],
          "line": 809
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "malloc(",
          "args": [
            "izeof(*work),",
            "FP_ATOMIC)"
          ],
          "line": 807
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "include \"internal.h\"\ninclude <linux/lockdep.h>\n#\ninclude <linux/fsnotify.h>\n#\ninclude <linux/cleancache.h>\n#\ninclude <linux/rculist_bl.h>\n#\ninclude <linux/backing-dev.h>\n#\ninclude <linux/mutex.h>\n#\ninclude <linux/idr.h>\n#\ninclude <linux/writeback.h>\t\t/* for the emergency remount stuff */\n#\ninclude <linux/security.h>\n#\ninclude <linux/mount.h>\n#\ninclude <linux/blkdev.h>\n#\ninclude <linux/slab.h>\n#\ninclude <linux/export.h>\n#\n\noid emergency_remount(void)\n{\n\tstruct work_struct *work;\n\n\twork = kmalloc(sizeof(*work), GFP_ATOMIC);\n\tif (work) {\n\t\tINIT_WORK(work, do_emergency_remount);\n\t\tschedule_work(work);\n\t}\n}"
  },
  {
    "function_name": "o_emergency_remount(",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/super.c",
    "lines": "772-801",
    "snippet": "tatic void do_emergency_remount(struct work_struct *work)\n{\n\tstruct super_block *sb, *p = NULL;\n\n\tspin_lock(&sb_lock);\n\tlist_for_each_entry(sb, &super_blocks, s_list) {\n\t\tif (hlist_unhashed(&sb->s_instances))\n\t\t\tcontinue;\n\t\tsb->s_count++;\n\t\tspin_unlock(&sb_lock);\n\t\tdown_write(&sb->s_umount);\n\t\tif (sb->s_root && sb->s_bdev && (sb->s_flags & MS_BORN) &&\n\t\t    !(sb->s_flags & MS_RDONLY)) {\n\t\t\t/*\n\t\t\t * What lock protects sb->s_flags??\n\t\t\t */\n\t\t\tdo_remount_sb(sb, MS_RDONLY, NULL, 1);\n\t\t}\n\t\tup_write(&sb->s_umount);\n\t\tspin_lock(&sb_lock);\n\t\tif (p)\n\t\t\t__put_super(p);\n\t\tp = sb;\n\t}\n\tif (p)\n\t\t__put_super(p);\n\tspin_unlock(&sb_lock);\n\tkfree(work);\n\tprintk(\"Emergency Remount complete\\n\");\n}",
    "includes": [
      "include \"internal.h\"",
      "include <linux/lockdep.h>\n#",
      "include <linux/fsnotify.h>\n#",
      "include <linux/cleancache.h>\n#",
      "include <linux/rculist_bl.h>\n#",
      "include <linux/backing-dev.h>\n#",
      "include <linux/mutex.h>\n#",
      "include <linux/idr.h>\n#",
      "include <linux/writeback.h>\t\t/* for the emergency remount stuff */\n#",
      "include <linux/security.h>\n#",
      "include <linux/mount.h>\n#",
      "include <linux/blkdev.h>\n#",
      "include <linux/slab.h>\n#",
      "include <linux/export.h>\n#"
    ],
    "macros_used": [],
    "globals_used": [
      "tatic LIST_HEAD(super_blocks);",
      "tatic DEFINE_SPINLOCK(sb_lock);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "rintk(",
          "args": [
            "Emergency Remount complete\\n\")"
          ],
          "line": 800
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free(",
          "args": [
            "ork)"
          ],
          "line": 799
        },
        "resolved": true,
        "details": {
          "function_name": "in_free(",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jffs2/scan.c",
          "lines": "51-60",
          "snippet": "tatic inline int min_free(struct jffs2_sb_info *c)\n{\n\tuint32_t min = 2 * sizeof(struct jffs2_raw_inode);\n#ifdef CONFIG_JFFS2_FS_WRITEBUFFER\n\tif (!jffs2_can_mark_obsolete(c) && min < c->wbuf_pagesize)\n\t\treturn c->wbuf_pagesize;\n#endif\n\treturn min;\n\n}",
          "includes": [
            "include \"debug.h\"",
            "include \"summary.h\"\n#",
            "include \"nodelist.h\"\n#",
            "include <linux/compiler.h>\n#",
            "include <linux/crc32.h>\n#",
            "include <linux/pagemap.h>\n#",
            "include <linux/mtd/mtd.h>\n#",
            "include <linux/slab.h>\n#",
            "include <linux/sched.h>\n#",
            "include <linux/kernel.h>\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"debug.h\"\ninclude \"summary.h\"\n#\ninclude \"nodelist.h\"\n#\ninclude <linux/compiler.h>\n#\ninclude <linux/crc32.h>\n#\ninclude <linux/pagemap.h>\n#\ninclude <linux/mtd/mtd.h>\n#\ninclude <linux/slab.h>\n#\ninclude <linux/sched.h>\n#\ninclude <linux/kernel.h>\n#\n\ntatic inline int min_free(struct jffs2_sb_info *c)\n{\n\tuint32_t min = 2 * sizeof(struct jffs2_raw_inode);\n#ifdef CONFIG_JFFS2_FS_WRITEBUFFER\n\tif (!jffs2_can_mark_obsolete(c) && min < c->wbuf_pagesize)\n\t\treturn c->wbuf_pagesize;\n#endif\n\treturn min;\n\n}"
        }
      },
      {
        "call_info": {
          "callee": "pin_unlock(",
          "args": [
            "sb_lock)"
          ],
          "line": 798
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_put_super(",
          "args": [
            ")"
          ],
          "line": 797
        },
        "resolved": true,
        "details": {
          "function_name": "_put_super(",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/super.c",
          "lines": "246-252",
          "snippet": "tatic void __put_super(struct super_block *sb)\n{\n\tif (!--sb->s_count) {\n\t\tlist_del_init(&sb->s_list);\n\t\tdestroy_super(sb);\n\t}\n}",
          "includes": [
            "include \"internal.h\"",
            "include <linux/lockdep.h>\n#",
            "include <linux/fsnotify.h>\n#",
            "include <linux/cleancache.h>\n#",
            "include <linux/rculist_bl.h>\n#",
            "include <linux/backing-dev.h>\n#",
            "include <linux/mutex.h>\n#",
            "include <linux/idr.h>\n#",
            "include <linux/writeback.h>\t\t/* for the emergency remount stuff */\n#",
            "include <linux/security.h>\n#",
            "include <linux/mount.h>\n#",
            "include <linux/blkdev.h>\n#",
            "include <linux/slab.h>\n#",
            "include <linux/export.h>\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"internal.h\"\ninclude <linux/lockdep.h>\n#\ninclude <linux/fsnotify.h>\n#\ninclude <linux/cleancache.h>\n#\ninclude <linux/rculist_bl.h>\n#\ninclude <linux/backing-dev.h>\n#\ninclude <linux/mutex.h>\n#\ninclude <linux/idr.h>\n#\ninclude <linux/writeback.h>\t\t/* for the emergency remount stuff */\n#\ninclude <linux/security.h>\n#\ninclude <linux/mount.h>\n#\ninclude <linux/blkdev.h>\n#\ninclude <linux/slab.h>\n#\ninclude <linux/export.h>\n#\n\ntatic void __put_super(struct super_block *sb)\n{\n\tif (!--sb->s_count) {\n\t\tlist_del_init(&sb->s_list);\n\t\tdestroy_super(sb);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "pin_lock(",
          "args": [
            "sb_lock)"
          ],
          "line": 791
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "p_write(",
          "args": [
            "sb->s_umount)"
          ],
          "line": 790
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "o_remount_sb(",
          "args": [
            "b,",
            "S_RDONLY,",
            "ULL,",
            ")"
          ],
          "line": 788
        },
        "resolved": true,
        "details": {
          "function_name": "o_remount_sb(",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/super.c",
          "lines": "698-770",
          "snippet": "nt do_remount_sb(struct super_block *sb, int flags, void *data, int force)\n{\n\tint retval;\n\tint remount_ro;\n\n\tif (sb->s_writers.frozen != SB_UNFROZEN)\n\t\treturn -EBUSY;\n\n#ifdef CONFIG_BLOCK\n\tif (!(flags & MS_RDONLY) && bdev_read_only(sb->s_bdev))\n\t\treturn -EACCES;\n#endif\n\n\tremount_ro = (flags & MS_RDONLY) && !(sb->s_flags & MS_RDONLY);\n\n\tif (remount_ro) {\n\t\tif (!hlist_empty(&sb->s_pins)) {\n\t\t\tup_write(&sb->s_umount);\n\t\t\tgroup_pin_kill(&sb->s_pins);\n\t\t\tdown_write(&sb->s_umount);\n\t\t\tif (!sb->s_root)\n\t\t\t\treturn 0;\n\t\t\tif (sb->s_writers.frozen != SB_UNFROZEN)\n\t\t\t\treturn -EBUSY;\n\t\t\tremount_ro = (flags & MS_RDONLY) && !(sb->s_flags & MS_RDONLY);\n\t\t}\n\t}\n\tshrink_dcache_sb(sb);\n\n\t/* If we are remounting RDONLY and current sb is read/write,\n\t   make sure there are no rw files opened */\n\tif (remount_ro) {\n\t\tif (force) {\n\t\t\tsb->s_readonly_remount = 1;\n\t\t\tsmp_wmb();\n\t\t} else {\n\t\t\tretval = sb_prepare_remount_readonly(sb);\n\t\t\tif (retval)\n\t\t\t\treturn retval;\n\t\t}\n\t}\n\n\tif (sb->s_op->remount_fs) {\n\t\tretval = sb->s_op->remount_fs(sb, &flags, data);\n\t\tif (retval) {\n\t\t\tif (!force)\n\t\t\t\tgoto cancel_readonly;\n\t\t\t/* If forced remount, go ahead despite any errors */\n\t\t\tWARN(1, \"forced remount of a %s fs returned %i\\n\",\n\t\t\t     sb->s_type->name, retval);\n\t\t}\n\t}\n\tsb->s_flags = (sb->s_flags & ~MS_RMT_MASK) | (flags & MS_RMT_MASK);\n\t/* Needs to be ordered wrt mnt_is_readonly() */\n\tsmp_wmb();\n\tsb->s_readonly_remount = 0;\n\n\t/*\n\t * Some filesystems modify their metadata via some other path than the\n\t * bdev buffer cache (eg. use a private mapping, or directories in\n\t * pagecache, etc). Also file data modifications go via their own\n\t * mappings. So If we try to mount readonly then copy the filesystem\n\t * from bdev, we could get stale data, so invalidate it to give a best\n\t * effort at coherency.\n\t */\n\tif (remount_ro && sb->s_bdev)\n\t\tinvalidate_bdev(sb->s_bdev);\n\treturn 0;\n\ncancel_readonly:\n\tsb->s_readonly_remount = 0;\n\treturn retval;\n}",
          "includes": [
            "include \"internal.h\"",
            "include <linux/lockdep.h>\n#",
            "include <linux/fsnotify.h>\n#",
            "include <linux/cleancache.h>\n#",
            "include <linux/rculist_bl.h>\n#",
            "include <linux/backing-dev.h>\n#",
            "include <linux/mutex.h>\n#",
            "include <linux/idr.h>\n#",
            "include <linux/writeback.h>\t\t/* for the emergency remount stuff */\n#",
            "include <linux/security.h>\n#",
            "include <linux/mount.h>\n#",
            "include <linux/blkdev.h>\n#",
            "include <linux/slab.h>\n#",
            "include <linux/export.h>\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"internal.h\"\ninclude <linux/lockdep.h>\n#\ninclude <linux/fsnotify.h>\n#\ninclude <linux/cleancache.h>\n#\ninclude <linux/rculist_bl.h>\n#\ninclude <linux/backing-dev.h>\n#\ninclude <linux/mutex.h>\n#\ninclude <linux/idr.h>\n#\ninclude <linux/writeback.h>\t\t/* for the emergency remount stuff */\n#\ninclude <linux/security.h>\n#\ninclude <linux/mount.h>\n#\ninclude <linux/blkdev.h>\n#\ninclude <linux/slab.h>\n#\ninclude <linux/export.h>\n#\n\nnt do_remount_sb(struct super_block *sb, int flags, void *data, int force)\n{\n\tint retval;\n\tint remount_ro;\n\n\tif (sb->s_writers.frozen != SB_UNFROZEN)\n\t\treturn -EBUSY;\n\n#ifdef CONFIG_BLOCK\n\tif (!(flags & MS_RDONLY) && bdev_read_only(sb->s_bdev))\n\t\treturn -EACCES;\n#endif\n\n\tremount_ro = (flags & MS_RDONLY) && !(sb->s_flags & MS_RDONLY);\n\n\tif (remount_ro) {\n\t\tif (!hlist_empty(&sb->s_pins)) {\n\t\t\tup_write(&sb->s_umount);\n\t\t\tgroup_pin_kill(&sb->s_pins);\n\t\t\tdown_write(&sb->s_umount);\n\t\t\tif (!sb->s_root)\n\t\t\t\treturn 0;\n\t\t\tif (sb->s_writers.frozen != SB_UNFROZEN)\n\t\t\t\treturn -EBUSY;\n\t\t\tremount_ro = (flags & MS_RDONLY) && !(sb->s_flags & MS_RDONLY);\n\t\t}\n\t}\n\tshrink_dcache_sb(sb);\n\n\t/* If we are remounting RDONLY and current sb is read/write,\n\t   make sure there are no rw files opened */\n\tif (remount_ro) {\n\t\tif (force) {\n\t\t\tsb->s_readonly_remount = 1;\n\t\t\tsmp_wmb();\n\t\t} else {\n\t\t\tretval = sb_prepare_remount_readonly(sb);\n\t\t\tif (retval)\n\t\t\t\treturn retval;\n\t\t}\n\t}\n\n\tif (sb->s_op->remount_fs) {\n\t\tretval = sb->s_op->remount_fs(sb, &flags, data);\n\t\tif (retval) {\n\t\t\tif (!force)\n\t\t\t\tgoto cancel_readonly;\n\t\t\t/* If forced remount, go ahead despite any errors */\n\t\t\tWARN(1, \"forced remount of a %s fs returned %i\\n\",\n\t\t\t     sb->s_type->name, retval);\n\t\t}\n\t}\n\tsb->s_flags = (sb->s_flags & ~MS_RMT_MASK) | (flags & MS_RMT_MASK);\n\t/* Needs to be ordered wrt mnt_is_readonly() */\n\tsmp_wmb();\n\tsb->s_readonly_remount = 0;\n\n\t/*\n\t * Some filesystems modify their metadata via some other path than the\n\t * bdev buffer cache (eg. use a private mapping, or directories in\n\t * pagecache, etc). Also file data modifications go via their own\n\t * mappings. So If we try to mount readonly then copy the filesystem\n\t * from bdev, we could get stale data, so invalidate it to give a best\n\t * effort at coherency.\n\t */\n\tif (remount_ro && sb->s_bdev)\n\t\tinvalidate_bdev(sb->s_bdev);\n\treturn 0;\n\ncancel_readonly:\n\tsb->s_readonly_remount = 0;\n\treturn retval;\n}"
        }
      },
      {
        "call_info": {
          "callee": "own_write(",
          "args": [
            "sb->s_umount)"
          ],
          "line": 782
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pin_unlock(",
          "args": [
            "sb_lock)"
          ],
          "line": 781
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_unhashed(",
          "args": [
            "sb->s_instances)"
          ],
          "line": 778
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ist_for_each_entry(",
          "args": [
            "b,",
            "super_blocks,",
            "_list)"
          ],
          "line": 777
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pin_lock(",
          "args": [
            "sb_lock)"
          ],
          "line": 776
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "include \"internal.h\"\ninclude <linux/lockdep.h>\n#\ninclude <linux/fsnotify.h>\n#\ninclude <linux/cleancache.h>\n#\ninclude <linux/rculist_bl.h>\n#\ninclude <linux/backing-dev.h>\n#\ninclude <linux/mutex.h>\n#\ninclude <linux/idr.h>\n#\ninclude <linux/writeback.h>\t\t/* for the emergency remount stuff */\n#\ninclude <linux/security.h>\n#\ninclude <linux/mount.h>\n#\ninclude <linux/blkdev.h>\n#\ninclude <linux/slab.h>\n#\ninclude <linux/export.h>\n#\n\ntatic LIST_HEAD(super_blocks);\ntatic DEFINE_SPINLOCK(sb_lock);\n\ntatic void do_emergency_remount(struct work_struct *work)\n{\n\tstruct super_block *sb, *p = NULL;\n\n\tspin_lock(&sb_lock);\n\tlist_for_each_entry(sb, &super_blocks, s_list) {\n\t\tif (hlist_unhashed(&sb->s_instances))\n\t\t\tcontinue;\n\t\tsb->s_count++;\n\t\tspin_unlock(&sb_lock);\n\t\tdown_write(&sb->s_umount);\n\t\tif (sb->s_root && sb->s_bdev && (sb->s_flags & MS_BORN) &&\n\t\t    !(sb->s_flags & MS_RDONLY)) {\n\t\t\t/*\n\t\t\t * What lock protects sb->s_flags??\n\t\t\t */\n\t\t\tdo_remount_sb(sb, MS_RDONLY, NULL, 1);\n\t\t}\n\t\tup_write(&sb->s_umount);\n\t\tspin_lock(&sb_lock);\n\t\tif (p)\n\t\t\t__put_super(p);\n\t\tp = sb;\n\t}\n\tif (p)\n\t\t__put_super(p);\n\tspin_unlock(&sb_lock);\n\tkfree(work);\n\tprintk(\"Emergency Remount complete\\n\");\n}"
  },
  {
    "function_name": "o_remount_sb(",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/super.c",
    "lines": "698-770",
    "snippet": "nt do_remount_sb(struct super_block *sb, int flags, void *data, int force)\n{\n\tint retval;\n\tint remount_ro;\n\n\tif (sb->s_writers.frozen != SB_UNFROZEN)\n\t\treturn -EBUSY;\n\n#ifdef CONFIG_BLOCK\n\tif (!(flags & MS_RDONLY) && bdev_read_only(sb->s_bdev))\n\t\treturn -EACCES;\n#endif\n\n\tremount_ro = (flags & MS_RDONLY) && !(sb->s_flags & MS_RDONLY);\n\n\tif (remount_ro) {\n\t\tif (!hlist_empty(&sb->s_pins)) {\n\t\t\tup_write(&sb->s_umount);\n\t\t\tgroup_pin_kill(&sb->s_pins);\n\t\t\tdown_write(&sb->s_umount);\n\t\t\tif (!sb->s_root)\n\t\t\t\treturn 0;\n\t\t\tif (sb->s_writers.frozen != SB_UNFROZEN)\n\t\t\t\treturn -EBUSY;\n\t\t\tremount_ro = (flags & MS_RDONLY) && !(sb->s_flags & MS_RDONLY);\n\t\t}\n\t}\n\tshrink_dcache_sb(sb);\n\n\t/* If we are remounting RDONLY and current sb is read/write,\n\t   make sure there are no rw files opened */\n\tif (remount_ro) {\n\t\tif (force) {\n\t\t\tsb->s_readonly_remount = 1;\n\t\t\tsmp_wmb();\n\t\t} else {\n\t\t\tretval = sb_prepare_remount_readonly(sb);\n\t\t\tif (retval)\n\t\t\t\treturn retval;\n\t\t}\n\t}\n\n\tif (sb->s_op->remount_fs) {\n\t\tretval = sb->s_op->remount_fs(sb, &flags, data);\n\t\tif (retval) {\n\t\t\tif (!force)\n\t\t\t\tgoto cancel_readonly;\n\t\t\t/* If forced remount, go ahead despite any errors */\n\t\t\tWARN(1, \"forced remount of a %s fs returned %i\\n\",\n\t\t\t     sb->s_type->name, retval);\n\t\t}\n\t}\n\tsb->s_flags = (sb->s_flags & ~MS_RMT_MASK) | (flags & MS_RMT_MASK);\n\t/* Needs to be ordered wrt mnt_is_readonly() */\n\tsmp_wmb();\n\tsb->s_readonly_remount = 0;\n\n\t/*\n\t * Some filesystems modify their metadata via some other path than the\n\t * bdev buffer cache (eg. use a private mapping, or directories in\n\t * pagecache, etc). Also file data modifications go via their own\n\t * mappings. So If we try to mount readonly then copy the filesystem\n\t * from bdev, we could get stale data, so invalidate it to give a best\n\t * effort at coherency.\n\t */\n\tif (remount_ro && sb->s_bdev)\n\t\tinvalidate_bdev(sb->s_bdev);\n\treturn 0;\n\ncancel_readonly:\n\tsb->s_readonly_remount = 0;\n\treturn retval;\n}",
    "includes": [
      "include \"internal.h\"",
      "include <linux/lockdep.h>\n#",
      "include <linux/fsnotify.h>\n#",
      "include <linux/cleancache.h>\n#",
      "include <linux/rculist_bl.h>\n#",
      "include <linux/backing-dev.h>\n#",
      "include <linux/mutex.h>\n#",
      "include <linux/idr.h>\n#",
      "include <linux/writeback.h>\t\t/* for the emergency remount stuff */\n#",
      "include <linux/security.h>\n#",
      "include <linux/mount.h>\n#",
      "include <linux/blkdev.h>\n#",
      "include <linux/slab.h>\n#",
      "include <linux/export.h>\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "nvalidate_bdev(",
          "args": [
            "b->s_bdev)"
          ],
          "line": 764
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mp_wmb(",
          "args": [],
          "line": 752
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ARN(",
          "args": [
            ",",
            "forced remount of a %s fs returned %i\\n\",",
            "b->s_type->name,",
            "etval)"
          ],
          "line": 746
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "b->s_op->remount_fs",
          "args": [
            "b,",
            "flags,",
            "ata)"
          ],
          "line": 741
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "b_prepare_remount_readonly(",
          "args": [
            "b)"
          ],
          "line": 734
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mp_wmb(",
          "args": [],
          "line": 732
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hrink_dcache_sb(",
          "args": [
            "b)"
          ],
          "line": 725
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "own_write(",
          "args": [
            "sb->s_umount)"
          ],
          "line": 717
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "roup_pin_kill(",
          "args": [
            "sb->s_pins)"
          ],
          "line": 716
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "p_write(",
          "args": [
            "sb->s_umount)"
          ],
          "line": 715
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_empty(",
          "args": [
            "sb->s_pins)"
          ],
          "line": 714
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dev_read_only(",
          "args": [
            "b->s_bdev)"
          ],
          "line": 707
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "include \"internal.h\"\ninclude <linux/lockdep.h>\n#\ninclude <linux/fsnotify.h>\n#\ninclude <linux/cleancache.h>\n#\ninclude <linux/rculist_bl.h>\n#\ninclude <linux/backing-dev.h>\n#\ninclude <linux/mutex.h>\n#\ninclude <linux/idr.h>\n#\ninclude <linux/writeback.h>\t\t/* for the emergency remount stuff */\n#\ninclude <linux/security.h>\n#\ninclude <linux/mount.h>\n#\ninclude <linux/blkdev.h>\n#\ninclude <linux/slab.h>\n#\ninclude <linux/export.h>\n#\n\nnt do_remount_sb(struct super_block *sb, int flags, void *data, int force)\n{\n\tint retval;\n\tint remount_ro;\n\n\tif (sb->s_writers.frozen != SB_UNFROZEN)\n\t\treturn -EBUSY;\n\n#ifdef CONFIG_BLOCK\n\tif (!(flags & MS_RDONLY) && bdev_read_only(sb->s_bdev))\n\t\treturn -EACCES;\n#endif\n\n\tremount_ro = (flags & MS_RDONLY) && !(sb->s_flags & MS_RDONLY);\n\n\tif (remount_ro) {\n\t\tif (!hlist_empty(&sb->s_pins)) {\n\t\t\tup_write(&sb->s_umount);\n\t\t\tgroup_pin_kill(&sb->s_pins);\n\t\t\tdown_write(&sb->s_umount);\n\t\t\tif (!sb->s_root)\n\t\t\t\treturn 0;\n\t\t\tif (sb->s_writers.frozen != SB_UNFROZEN)\n\t\t\t\treturn -EBUSY;\n\t\t\tremount_ro = (flags & MS_RDONLY) && !(sb->s_flags & MS_RDONLY);\n\t\t}\n\t}\n\tshrink_dcache_sb(sb);\n\n\t/* If we are remounting RDONLY and current sb is read/write,\n\t   make sure there are no rw files opened */\n\tif (remount_ro) {\n\t\tif (force) {\n\t\t\tsb->s_readonly_remount = 1;\n\t\t\tsmp_wmb();\n\t\t} else {\n\t\t\tretval = sb_prepare_remount_readonly(sb);\n\t\t\tif (retval)\n\t\t\t\treturn retval;\n\t\t}\n\t}\n\n\tif (sb->s_op->remount_fs) {\n\t\tretval = sb->s_op->remount_fs(sb, &flags, data);\n\t\tif (retval) {\n\t\t\tif (!force)\n\t\t\t\tgoto cancel_readonly;\n\t\t\t/* If forced remount, go ahead despite any errors */\n\t\t\tWARN(1, \"forced remount of a %s fs returned %i\\n\",\n\t\t\t     sb->s_type->name, retval);\n\t\t}\n\t}\n\tsb->s_flags = (sb->s_flags & ~MS_RMT_MASK) | (flags & MS_RMT_MASK);\n\t/* Needs to be ordered wrt mnt_is_readonly() */\n\tsmp_wmb();\n\tsb->s_readonly_remount = 0;\n\n\t/*\n\t * Some filesystems modify their metadata via some other path than the\n\t * bdev buffer cache (eg. use a private mapping, or directories in\n\t * pagecache, etc). Also file data modifications go via their own\n\t * mappings. So If we try to mount readonly then copy the filesystem\n\t * from bdev, we could get stale data, so invalidate it to give a best\n\t * effort at coherency.\n\t */\n\tif (remount_ro && sb->s_bdev)\n\t\tinvalidate_bdev(sb->s_bdev);\n\treturn 0;\n\ncancel_readonly:\n\tsb->s_readonly_remount = 0;\n\treturn retval;\n}"
  },
  {
    "function_name": "ser_get_super(",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/super.c",
    "lines": "662-687",
    "snippet": "truct super_block *user_get_super(dev_t dev)\n{\n\tstruct super_block *sb;\n\n\tspin_lock(&sb_lock);\nrescan:\n\tlist_for_each_entry(sb, &super_blocks, s_list) {\n\t\tif (hlist_unhashed(&sb->s_instances))\n\t\t\tcontinue;\n\t\tif (sb->s_dev ==  dev) {\n\t\t\tsb->s_count++;\n\t\t\tspin_unlock(&sb_lock);\n\t\t\tdown_read(&sb->s_umount);\n\t\t\t/* still alive? */\n\t\t\tif (sb->s_root && (sb->s_flags & MS_BORN))\n\t\t\t\treturn sb;\n\t\t\tup_read(&sb->s_umount);\n\t\t\t/* nope, got unmounted */\n\t\t\tspin_lock(&sb_lock);\n\t\t\t__put_super(sb);\n\t\t\tgoto rescan;\n\t\t}\n\t}\n\tspin_unlock(&sb_lock);\n\treturn NULL;\n}",
    "includes": [
      "include \"internal.h\"",
      "include <linux/lockdep.h>\n#",
      "include <linux/fsnotify.h>\n#",
      "include <linux/cleancache.h>\n#",
      "include <linux/rculist_bl.h>\n#",
      "include <linux/backing-dev.h>\n#",
      "include <linux/mutex.h>\n#",
      "include <linux/idr.h>\n#",
      "include <linux/writeback.h>\t\t/* for the emergency remount stuff */\n#",
      "include <linux/security.h>\n#",
      "include <linux/mount.h>\n#",
      "include <linux/blkdev.h>\n#",
      "include <linux/slab.h>\n#",
      "include <linux/export.h>\n#"
    ],
    "macros_used": [],
    "globals_used": [
      "tatic LIST_HEAD(super_blocks);",
      "tatic DEFINE_SPINLOCK(sb_lock);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "pin_unlock(",
          "args": [
            "sb_lock)"
          ],
          "line": 685
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_put_super(",
          "args": [
            "b)"
          ],
          "line": 681
        },
        "resolved": true,
        "details": {
          "function_name": "_put_super(",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/super.c",
          "lines": "246-252",
          "snippet": "tatic void __put_super(struct super_block *sb)\n{\n\tif (!--sb->s_count) {\n\t\tlist_del_init(&sb->s_list);\n\t\tdestroy_super(sb);\n\t}\n}",
          "includes": [
            "include \"internal.h\"",
            "include <linux/lockdep.h>\n#",
            "include <linux/fsnotify.h>\n#",
            "include <linux/cleancache.h>\n#",
            "include <linux/rculist_bl.h>\n#",
            "include <linux/backing-dev.h>\n#",
            "include <linux/mutex.h>\n#",
            "include <linux/idr.h>\n#",
            "include <linux/writeback.h>\t\t/* for the emergency remount stuff */\n#",
            "include <linux/security.h>\n#",
            "include <linux/mount.h>\n#",
            "include <linux/blkdev.h>\n#",
            "include <linux/slab.h>\n#",
            "include <linux/export.h>\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"internal.h\"\ninclude <linux/lockdep.h>\n#\ninclude <linux/fsnotify.h>\n#\ninclude <linux/cleancache.h>\n#\ninclude <linux/rculist_bl.h>\n#\ninclude <linux/backing-dev.h>\n#\ninclude <linux/mutex.h>\n#\ninclude <linux/idr.h>\n#\ninclude <linux/writeback.h>\t\t/* for the emergency remount stuff */\n#\ninclude <linux/security.h>\n#\ninclude <linux/mount.h>\n#\ninclude <linux/blkdev.h>\n#\ninclude <linux/slab.h>\n#\ninclude <linux/export.h>\n#\n\ntatic void __put_super(struct super_block *sb)\n{\n\tif (!--sb->s_count) {\n\t\tlist_del_init(&sb->s_list);\n\t\tdestroy_super(sb);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "pin_lock(",
          "args": [
            "sb_lock)"
          ],
          "line": 680
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "p_read(",
          "args": [
            "sb->s_umount)"
          ],
          "line": 678
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "own_read(",
          "args": [
            "sb->s_umount)"
          ],
          "line": 674
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pin_unlock(",
          "args": [
            "sb_lock)"
          ],
          "line": 673
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_unhashed(",
          "args": [
            "sb->s_instances)"
          ],
          "line": 669
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ist_for_each_entry(",
          "args": [
            "b,",
            "super_blocks,",
            "_list)"
          ],
          "line": 668
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pin_lock(",
          "args": [
            "sb_lock)"
          ],
          "line": 666
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "include \"internal.h\"\ninclude <linux/lockdep.h>\n#\ninclude <linux/fsnotify.h>\n#\ninclude <linux/cleancache.h>\n#\ninclude <linux/rculist_bl.h>\n#\ninclude <linux/backing-dev.h>\n#\ninclude <linux/mutex.h>\n#\ninclude <linux/idr.h>\n#\ninclude <linux/writeback.h>\t\t/* for the emergency remount stuff */\n#\ninclude <linux/security.h>\n#\ninclude <linux/mount.h>\n#\ninclude <linux/blkdev.h>\n#\ninclude <linux/slab.h>\n#\ninclude <linux/export.h>\n#\n\ntatic LIST_HEAD(super_blocks);\ntatic DEFINE_SPINLOCK(sb_lock);\n\ntruct super_block *user_get_super(dev_t dev)\n{\n\tstruct super_block *sb;\n\n\tspin_lock(&sb_lock);\nrescan:\n\tlist_for_each_entry(sb, &super_blocks, s_list) {\n\t\tif (hlist_unhashed(&sb->s_instances))\n\t\t\tcontinue;\n\t\tif (sb->s_dev ==  dev) {\n\t\t\tsb->s_count++;\n\t\t\tspin_unlock(&sb_lock);\n\t\t\tdown_read(&sb->s_umount);\n\t\t\t/* still alive? */\n\t\t\tif (sb->s_root && (sb->s_flags & MS_BORN))\n\t\t\t\treturn sb;\n\t\t\tup_read(&sb->s_umount);\n\t\t\t/* nope, got unmounted */\n\t\t\tspin_lock(&sb_lock);\n\t\t\t__put_super(sb);\n\t\t\tgoto rescan;\n\t\t}\n\t}\n\tspin_unlock(&sb_lock);\n\treturn NULL;\n}"
  },
  {
    "function_name": "et_active_super(",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/super.c",
    "lines": "639-660",
    "snippet": "truct super_block *get_active_super(struct block_device *bdev)\n{\n\tstruct super_block *sb;\n\n\tif (!bdev)\n\t\treturn NULL;\n\nrestart:\n\tspin_lock(&sb_lock);\n\tlist_for_each_entry(sb, &super_blocks, s_list) {\n\t\tif (hlist_unhashed(&sb->s_instances))\n\t\t\tcontinue;\n\t\tif (sb->s_bdev == bdev) {\n\t\t\tif (!grab_super(sb))\n\t\t\t\tgoto restart;\n\t\t\tup_write(&sb->s_umount);\n\t\t\treturn sb;\n\t\t}\n\t}\n\tspin_unlock(&sb_lock);\n\treturn NULL;\n}",
    "includes": [
      "include \"internal.h\"",
      "include <linux/lockdep.h>\n#",
      "include <linux/fsnotify.h>\n#",
      "include <linux/cleancache.h>\n#",
      "include <linux/rculist_bl.h>\n#",
      "include <linux/backing-dev.h>\n#",
      "include <linux/mutex.h>\n#",
      "include <linux/idr.h>\n#",
      "include <linux/writeback.h>\t\t/* for the emergency remount stuff */\n#",
      "include <linux/security.h>\n#",
      "include <linux/mount.h>\n#",
      "include <linux/blkdev.h>\n#",
      "include <linux/slab.h>\n#",
      "include <linux/export.h>\n#"
    ],
    "macros_used": [],
    "globals_used": [
      "tatic LIST_HEAD(super_blocks);",
      "tatic DEFINE_SPINLOCK(sb_lock);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "pin_unlock(",
          "args": [
            "sb_lock)"
          ],
          "line": 658
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "p_write(",
          "args": [
            "sb->s_umount)"
          ],
          "line": 654
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rab_super(",
          "args": [
            "b)"
          ],
          "line": 652
        },
        "resolved": true,
        "details": {
          "function_name": "rab_super(",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/super.c",
          "lines": "336-348",
          "snippet": "tatic int grab_super(struct super_block *s) __releases(sb_lock)\n{\n\ts->s_count++;\n\tspin_unlock(&sb_lock);\n\tdown_write(&s->s_umount);\n\tif ((s->s_flags & MS_BORN) && atomic_inc_not_zero(&s->s_active)) {\n\t\tput_super(s);\n\t\treturn 1;\n\t}\n\tup_write(&s->s_umount);\n\tput_super(s);\n\treturn 0;\n}",
          "includes": [
            "include \"internal.h\"",
            "include <linux/lockdep.h>\n#",
            "include <linux/fsnotify.h>\n#",
            "include <linux/cleancache.h>\n#",
            "include <linux/rculist_bl.h>\n#",
            "include <linux/backing-dev.h>\n#",
            "include <linux/mutex.h>\n#",
            "include <linux/idr.h>\n#",
            "include <linux/writeback.h>\t\t/* for the emergency remount stuff */\n#",
            "include <linux/security.h>\n#",
            "include <linux/mount.h>\n#",
            "include <linux/blkdev.h>\n#",
            "include <linux/slab.h>\n#",
            "include <linux/export.h>\n#"
          ],
          "macros_used": [],
          "globals_used": [
            "tatic DEFINE_SPINLOCK(sb_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "include \"internal.h\"\ninclude <linux/lockdep.h>\n#\ninclude <linux/fsnotify.h>\n#\ninclude <linux/cleancache.h>\n#\ninclude <linux/rculist_bl.h>\n#\ninclude <linux/backing-dev.h>\n#\ninclude <linux/mutex.h>\n#\ninclude <linux/idr.h>\n#\ninclude <linux/writeback.h>\t\t/* for the emergency remount stuff */\n#\ninclude <linux/security.h>\n#\ninclude <linux/mount.h>\n#\ninclude <linux/blkdev.h>\n#\ninclude <linux/slab.h>\n#\ninclude <linux/export.h>\n#\n\ntatic DEFINE_SPINLOCK(sb_lock);\n\ntatic int grab_super(struct super_block *s) __releases(sb_lock)\n{\n\ts->s_count++;\n\tspin_unlock(&sb_lock);\n\tdown_write(&s->s_umount);\n\tif ((s->s_flags & MS_BORN) && atomic_inc_not_zero(&s->s_active)) {\n\t\tput_super(s);\n\t\treturn 1;\n\t}\n\tup_write(&s->s_umount);\n\tput_super(s);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_unhashed(",
          "args": [
            "sb->s_instances)"
          ],
          "line": 649
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ist_for_each_entry(",
          "args": [
            "b,",
            "super_blocks,",
            "_list)"
          ],
          "line": 648
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pin_lock(",
          "args": [
            "sb_lock)"
          ],
          "line": 647
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "include \"internal.h\"\ninclude <linux/lockdep.h>\n#\ninclude <linux/fsnotify.h>\n#\ninclude <linux/cleancache.h>\n#\ninclude <linux/rculist_bl.h>\n#\ninclude <linux/backing-dev.h>\n#\ninclude <linux/mutex.h>\n#\ninclude <linux/idr.h>\n#\ninclude <linux/writeback.h>\t\t/* for the emergency remount stuff */\n#\ninclude <linux/security.h>\n#\ninclude <linux/mount.h>\n#\ninclude <linux/blkdev.h>\n#\ninclude <linux/slab.h>\n#\ninclude <linux/export.h>\n#\n\ntatic LIST_HEAD(super_blocks);\ntatic DEFINE_SPINLOCK(sb_lock);\n\ntruct super_block *get_active_super(struct block_device *bdev)\n{\n\tstruct super_block *sb;\n\n\tif (!bdev)\n\t\treturn NULL;\n\nrestart:\n\tspin_lock(&sb_lock);\n\tlist_for_each_entry(sb, &super_blocks, s_list) {\n\t\tif (hlist_unhashed(&sb->s_instances))\n\t\t\tcontinue;\n\t\tif (sb->s_bdev == bdev) {\n\t\t\tif (!grab_super(sb))\n\t\t\t\tgoto restart;\n\t\t\tup_write(&sb->s_umount);\n\t\t\treturn sb;\n\t\t}\n\t}\n\tspin_unlock(&sb_lock);\n\treturn NULL;\n}"
  },
  {
    "function_name": "et_super_thawed(",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/super.c",
    "lines": "617-628",
    "snippet": "truct super_block *get_super_thawed(struct block_device *bdev)\n{\n\twhile (1) {\n\t\tstruct super_block *s = get_super(bdev);\n\t\tif (!s || s->s_writers.frozen == SB_UNFROZEN)\n\t\t\treturn s;\n\t\tup_read(&s->s_umount);\n\t\twait_event(s->s_writers.wait_unfrozen,\n\t\t\t   s->s_writers.frozen == SB_UNFROZEN);\n\t\tput_super(s);\n\t}\n}",
    "includes": [
      "include \"internal.h\"",
      "include <linux/lockdep.h>\n#",
      "include <linux/fsnotify.h>\n#",
      "include <linux/cleancache.h>\n#",
      "include <linux/rculist_bl.h>\n#",
      "include <linux/backing-dev.h>\n#",
      "include <linux/mutex.h>\n#",
      "include <linux/idr.h>\n#",
      "include <linux/writeback.h>\t\t/* for the emergency remount stuff */\n#",
      "include <linux/security.h>\n#",
      "include <linux/mount.h>\n#",
      "include <linux/blkdev.h>\n#",
      "include <linux/slab.h>\n#",
      "include <linux/export.h>\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ut_super(",
          "args": [
            ")"
          ],
          "line": 626
        },
        "resolved": true,
        "details": {
          "function_name": "ut_super(",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/super.c",
          "lines": "261-266",
          "snippet": "tatic void put_super(struct super_block *sb)\n{\n\tspin_lock(&sb_lock);\n\t__put_super(sb);\n\tspin_unlock(&sb_lock);\n}",
          "includes": [
            "include \"internal.h\"",
            "include <linux/lockdep.h>\n#",
            "include <linux/fsnotify.h>\n#",
            "include <linux/cleancache.h>\n#",
            "include <linux/rculist_bl.h>\n#",
            "include <linux/backing-dev.h>\n#",
            "include <linux/mutex.h>\n#",
            "include <linux/idr.h>\n#",
            "include <linux/writeback.h>\t\t/* for the emergency remount stuff */\n#",
            "include <linux/security.h>\n#",
            "include <linux/mount.h>\n#",
            "include <linux/blkdev.h>\n#",
            "include <linux/slab.h>\n#",
            "include <linux/export.h>\n#"
          ],
          "macros_used": [],
          "globals_used": [
            "tatic DEFINE_SPINLOCK(sb_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "include \"internal.h\"\ninclude <linux/lockdep.h>\n#\ninclude <linux/fsnotify.h>\n#\ninclude <linux/cleancache.h>\n#\ninclude <linux/rculist_bl.h>\n#\ninclude <linux/backing-dev.h>\n#\ninclude <linux/mutex.h>\n#\ninclude <linux/idr.h>\n#\ninclude <linux/writeback.h>\t\t/* for the emergency remount stuff */\n#\ninclude <linux/security.h>\n#\ninclude <linux/mount.h>\n#\ninclude <linux/blkdev.h>\n#\ninclude <linux/slab.h>\n#\ninclude <linux/export.h>\n#\n\ntatic DEFINE_SPINLOCK(sb_lock);\n\ntatic void put_super(struct super_block *sb)\n{\n\tspin_lock(&sb_lock);\n\t__put_super(sb);\n\tspin_unlock(&sb_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ait_event(",
          "args": [
            "->s_writers.wait_unfrozen,",
            "->s_writers.frozen == SB_UNFROZEN)"
          ],
          "line": 624
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "p_read(",
          "args": [
            "s->s_umount)"
          ],
          "line": 623
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "et_super(",
          "args": [
            "dev)"
          ],
          "line": 620
        },
        "resolved": true,
        "details": {
          "function_name": "ser_get_super(",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/super.c",
          "lines": "662-687",
          "snippet": "truct super_block *user_get_super(dev_t dev)\n{\n\tstruct super_block *sb;\n\n\tspin_lock(&sb_lock);\nrescan:\n\tlist_for_each_entry(sb, &super_blocks, s_list) {\n\t\tif (hlist_unhashed(&sb->s_instances))\n\t\t\tcontinue;\n\t\tif (sb->s_dev ==  dev) {\n\t\t\tsb->s_count++;\n\t\t\tspin_unlock(&sb_lock);\n\t\t\tdown_read(&sb->s_umount);\n\t\t\t/* still alive? */\n\t\t\tif (sb->s_root && (sb->s_flags & MS_BORN))\n\t\t\t\treturn sb;\n\t\t\tup_read(&sb->s_umount);\n\t\t\t/* nope, got unmounted */\n\t\t\tspin_lock(&sb_lock);\n\t\t\t__put_super(sb);\n\t\t\tgoto rescan;\n\t\t}\n\t}\n\tspin_unlock(&sb_lock);\n\treturn NULL;\n}",
          "includes": [
            "include \"internal.h\"",
            "include <linux/lockdep.h>\n#",
            "include <linux/fsnotify.h>\n#",
            "include <linux/cleancache.h>\n#",
            "include <linux/rculist_bl.h>\n#",
            "include <linux/backing-dev.h>\n#",
            "include <linux/mutex.h>\n#",
            "include <linux/idr.h>\n#",
            "include <linux/writeback.h>\t\t/* for the emergency remount stuff */\n#",
            "include <linux/security.h>\n#",
            "include <linux/mount.h>\n#",
            "include <linux/blkdev.h>\n#",
            "include <linux/slab.h>\n#",
            "include <linux/export.h>\n#"
          ],
          "macros_used": [],
          "globals_used": [
            "tatic LIST_HEAD(super_blocks);",
            "tatic DEFINE_SPINLOCK(sb_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "include \"internal.h\"\ninclude <linux/lockdep.h>\n#\ninclude <linux/fsnotify.h>\n#\ninclude <linux/cleancache.h>\n#\ninclude <linux/rculist_bl.h>\n#\ninclude <linux/backing-dev.h>\n#\ninclude <linux/mutex.h>\n#\ninclude <linux/idr.h>\n#\ninclude <linux/writeback.h>\t\t/* for the emergency remount stuff */\n#\ninclude <linux/security.h>\n#\ninclude <linux/mount.h>\n#\ninclude <linux/blkdev.h>\n#\ninclude <linux/slab.h>\n#\ninclude <linux/export.h>\n#\n\ntatic LIST_HEAD(super_blocks);\ntatic DEFINE_SPINLOCK(sb_lock);\n\ntruct super_block *user_get_super(dev_t dev)\n{\n\tstruct super_block *sb;\n\n\tspin_lock(&sb_lock);\nrescan:\n\tlist_for_each_entry(sb, &super_blocks, s_list) {\n\t\tif (hlist_unhashed(&sb->s_instances))\n\t\t\tcontinue;\n\t\tif (sb->s_dev ==  dev) {\n\t\t\tsb->s_count++;\n\t\t\tspin_unlock(&sb_lock);\n\t\t\tdown_read(&sb->s_umount);\n\t\t\t/* still alive? */\n\t\t\tif (sb->s_root && (sb->s_flags & MS_BORN))\n\t\t\t\treturn sb;\n\t\t\tup_read(&sb->s_umount);\n\t\t\t/* nope, got unmounted */\n\t\t\tspin_lock(&sb_lock);\n\t\t\t__put_super(sb);\n\t\t\tgoto rescan;\n\t\t}\n\t}\n\tspin_unlock(&sb_lock);\n\treturn NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "include \"internal.h\"\ninclude <linux/lockdep.h>\n#\ninclude <linux/fsnotify.h>\n#\ninclude <linux/cleancache.h>\n#\ninclude <linux/rculist_bl.h>\n#\ninclude <linux/backing-dev.h>\n#\ninclude <linux/mutex.h>\n#\ninclude <linux/idr.h>\n#\ninclude <linux/writeback.h>\t\t/* for the emergency remount stuff */\n#\ninclude <linux/security.h>\n#\ninclude <linux/mount.h>\n#\ninclude <linux/blkdev.h>\n#\ninclude <linux/slab.h>\n#\ninclude <linux/export.h>\n#\n\ntruct super_block *get_super_thawed(struct block_device *bdev)\n{\n\twhile (1) {\n\t\tstruct super_block *s = get_super(bdev);\n\t\tif (!s || s->s_writers.frozen == SB_UNFROZEN)\n\t\t\treturn s;\n\t\tup_read(&s->s_umount);\n\t\twait_event(s->s_writers.wait_unfrozen,\n\t\t\t   s->s_writers.frozen == SB_UNFROZEN);\n\t\tput_super(s);\n\t}\n}"
  },
  {
    "function_name": "et_super(",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/super.c",
    "lines": "576-604",
    "snippet": "truct super_block *get_super(struct block_device *bdev)\n{\n\tstruct super_block *sb;\n\n\tif (!bdev)\n\t\treturn NULL;\n\n\tspin_lock(&sb_lock);\nrescan:\n\tlist_for_each_entry(sb, &super_blocks, s_list) {\n\t\tif (hlist_unhashed(&sb->s_instances))\n\t\t\tcontinue;\n\t\tif (sb->s_bdev == bdev) {\n\t\t\tsb->s_count++;\n\t\t\tspin_unlock(&sb_lock);\n\t\t\tdown_read(&sb->s_umount);\n\t\t\t/* still alive? */\n\t\t\tif (sb->s_root && (sb->s_flags & MS_BORN))\n\t\t\t\treturn sb;\n\t\t\tup_read(&sb->s_umount);\n\t\t\t/* nope, got unmounted */\n\t\t\tspin_lock(&sb_lock);\n\t\t\t__put_super(sb);\n\t\t\tgoto rescan;\n\t\t}\n\t}\n\tspin_unlock(&sb_lock);\n\treturn NULL;\n}",
    "includes": [
      "include \"internal.h\"",
      "include <linux/lockdep.h>\n#",
      "include <linux/fsnotify.h>\n#",
      "include <linux/cleancache.h>\n#",
      "include <linux/rculist_bl.h>\n#",
      "include <linux/backing-dev.h>\n#",
      "include <linux/mutex.h>\n#",
      "include <linux/idr.h>\n#",
      "include <linux/writeback.h>\t\t/* for the emergency remount stuff */\n#",
      "include <linux/security.h>\n#",
      "include <linux/mount.h>\n#",
      "include <linux/blkdev.h>\n#",
      "include <linux/slab.h>\n#",
      "include <linux/export.h>\n#"
    ],
    "macros_used": [],
    "globals_used": [
      "tatic LIST_HEAD(super_blocks);",
      "tatic DEFINE_SPINLOCK(sb_lock);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "pin_unlock(",
          "args": [
            "sb_lock)"
          ],
          "line": 602
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_put_super(",
          "args": [
            "b)"
          ],
          "line": 598
        },
        "resolved": true,
        "details": {
          "function_name": "_put_super(",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/super.c",
          "lines": "246-252",
          "snippet": "tatic void __put_super(struct super_block *sb)\n{\n\tif (!--sb->s_count) {\n\t\tlist_del_init(&sb->s_list);\n\t\tdestroy_super(sb);\n\t}\n}",
          "includes": [
            "include \"internal.h\"",
            "include <linux/lockdep.h>\n#",
            "include <linux/fsnotify.h>\n#",
            "include <linux/cleancache.h>\n#",
            "include <linux/rculist_bl.h>\n#",
            "include <linux/backing-dev.h>\n#",
            "include <linux/mutex.h>\n#",
            "include <linux/idr.h>\n#",
            "include <linux/writeback.h>\t\t/* for the emergency remount stuff */\n#",
            "include <linux/security.h>\n#",
            "include <linux/mount.h>\n#",
            "include <linux/blkdev.h>\n#",
            "include <linux/slab.h>\n#",
            "include <linux/export.h>\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"internal.h\"\ninclude <linux/lockdep.h>\n#\ninclude <linux/fsnotify.h>\n#\ninclude <linux/cleancache.h>\n#\ninclude <linux/rculist_bl.h>\n#\ninclude <linux/backing-dev.h>\n#\ninclude <linux/mutex.h>\n#\ninclude <linux/idr.h>\n#\ninclude <linux/writeback.h>\t\t/* for the emergency remount stuff */\n#\ninclude <linux/security.h>\n#\ninclude <linux/mount.h>\n#\ninclude <linux/blkdev.h>\n#\ninclude <linux/slab.h>\n#\ninclude <linux/export.h>\n#\n\ntatic void __put_super(struct super_block *sb)\n{\n\tif (!--sb->s_count) {\n\t\tlist_del_init(&sb->s_list);\n\t\tdestroy_super(sb);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "pin_lock(",
          "args": [
            "sb_lock)"
          ],
          "line": 597
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "p_read(",
          "args": [
            "sb->s_umount)"
          ],
          "line": 595
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "own_read(",
          "args": [
            "sb->s_umount)"
          ],
          "line": 591
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pin_unlock(",
          "args": [
            "sb_lock)"
          ],
          "line": 590
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_unhashed(",
          "args": [
            "sb->s_instances)"
          ],
          "line": 586
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ist_for_each_entry(",
          "args": [
            "b,",
            "super_blocks,",
            "_list)"
          ],
          "line": 585
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pin_lock(",
          "args": [
            "sb_lock)"
          ],
          "line": 583
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "include \"internal.h\"\ninclude <linux/lockdep.h>\n#\ninclude <linux/fsnotify.h>\n#\ninclude <linux/cleancache.h>\n#\ninclude <linux/rculist_bl.h>\n#\ninclude <linux/backing-dev.h>\n#\ninclude <linux/mutex.h>\n#\ninclude <linux/idr.h>\n#\ninclude <linux/writeback.h>\t\t/* for the emergency remount stuff */\n#\ninclude <linux/security.h>\n#\ninclude <linux/mount.h>\n#\ninclude <linux/blkdev.h>\n#\ninclude <linux/slab.h>\n#\ninclude <linux/export.h>\n#\n\ntatic LIST_HEAD(super_blocks);\ntatic DEFINE_SPINLOCK(sb_lock);\n\ntruct super_block *get_super(struct block_device *bdev)\n{\n\tstruct super_block *sb;\n\n\tif (!bdev)\n\t\treturn NULL;\n\n\tspin_lock(&sb_lock);\nrescan:\n\tlist_for_each_entry(sb, &super_blocks, s_list) {\n\t\tif (hlist_unhashed(&sb->s_instances))\n\t\t\tcontinue;\n\t\tif (sb->s_bdev == bdev) {\n\t\t\tsb->s_count++;\n\t\t\tspin_unlock(&sb_lock);\n\t\t\tdown_read(&sb->s_umount);\n\t\t\t/* still alive? */\n\t\t\tif (sb->s_root && (sb->s_flags & MS_BORN))\n\t\t\t\treturn sb;\n\t\t\tup_read(&sb->s_umount);\n\t\t\t/* nope, got unmounted */\n\t\t\tspin_lock(&sb_lock);\n\t\t\t__put_super(sb);\n\t\t\tgoto rescan;\n\t\t}\n\t}\n\tspin_unlock(&sb_lock);\n\treturn NULL;\n}"
  },
  {
    "function_name": "terate_supers_type(",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/super.c",
    "lines": "541-564",
    "snippet": "oid iterate_supers_type(struct file_system_type *type,\n\tvoid (*f)(struct super_block *, void *), void *arg)\n{\n\tstruct super_block *sb, *p = NULL;\n\n\tspin_lock(&sb_lock);\n\thlist_for_each_entry(sb, &type->fs_supers, s_instances) {\n\t\tsb->s_count++;\n\t\tspin_unlock(&sb_lock);\n\n\t\tdown_read(&sb->s_umount);\n\t\tif (sb->s_root && (sb->s_flags & MS_BORN))\n\t\t\tf(sb, arg);\n\t\tup_read(&sb->s_umount);\n\n\t\tspin_lock(&sb_lock);\n\t\tif (p)\n\t\t\t__put_super(p);\n\t\tp = sb;\n\t}\n\tif (p)\n\t\t__put_super(p);\n\tspin_unlock(&sb_lock);\n}",
    "includes": [
      "include \"internal.h\"",
      "include <linux/lockdep.h>\n#",
      "include <linux/fsnotify.h>\n#",
      "include <linux/cleancache.h>\n#",
      "include <linux/rculist_bl.h>\n#",
      "include <linux/backing-dev.h>\n#",
      "include <linux/mutex.h>\n#",
      "include <linux/idr.h>\n#",
      "include <linux/writeback.h>\t\t/* for the emergency remount stuff */\n#",
      "include <linux/security.h>\n#",
      "include <linux/mount.h>\n#",
      "include <linux/blkdev.h>\n#",
      "include <linux/slab.h>\n#",
      "include <linux/export.h>\n#"
    ],
    "macros_used": [],
    "globals_used": [
      "tatic DEFINE_SPINLOCK(sb_lock);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "pin_unlock(",
          "args": [
            "sb_lock)"
          ],
          "line": 563
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_put_super(",
          "args": [
            ")"
          ],
          "line": 562
        },
        "resolved": true,
        "details": {
          "function_name": "_put_super(",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/super.c",
          "lines": "246-252",
          "snippet": "tatic void __put_super(struct super_block *sb)\n{\n\tif (!--sb->s_count) {\n\t\tlist_del_init(&sb->s_list);\n\t\tdestroy_super(sb);\n\t}\n}",
          "includes": [
            "include \"internal.h\"",
            "include <linux/lockdep.h>\n#",
            "include <linux/fsnotify.h>\n#",
            "include <linux/cleancache.h>\n#",
            "include <linux/rculist_bl.h>\n#",
            "include <linux/backing-dev.h>\n#",
            "include <linux/mutex.h>\n#",
            "include <linux/idr.h>\n#",
            "include <linux/writeback.h>\t\t/* for the emergency remount stuff */\n#",
            "include <linux/security.h>\n#",
            "include <linux/mount.h>\n#",
            "include <linux/blkdev.h>\n#",
            "include <linux/slab.h>\n#",
            "include <linux/export.h>\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"internal.h\"\ninclude <linux/lockdep.h>\n#\ninclude <linux/fsnotify.h>\n#\ninclude <linux/cleancache.h>\n#\ninclude <linux/rculist_bl.h>\n#\ninclude <linux/backing-dev.h>\n#\ninclude <linux/mutex.h>\n#\ninclude <linux/idr.h>\n#\ninclude <linux/writeback.h>\t\t/* for the emergency remount stuff */\n#\ninclude <linux/security.h>\n#\ninclude <linux/mount.h>\n#\ninclude <linux/blkdev.h>\n#\ninclude <linux/slab.h>\n#\ninclude <linux/export.h>\n#\n\ntatic void __put_super(struct super_block *sb)\n{\n\tif (!--sb->s_count) {\n\t\tlist_del_init(&sb->s_list);\n\t\tdestroy_super(sb);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "pin_lock(",
          "args": [
            "sb_lock)"
          ],
          "line": 556
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "p_read(",
          "args": [
            "sb->s_umount)"
          ],
          "line": 554
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "(",
          "args": [
            "b,",
            "rg)"
          ],
          "line": 553
        },
        "resolved": true,
        "details": {
          "function_name": "b_wait_write(",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/super.c",
          "lines": "1228-1255",
          "snippet": "tatic void sb_wait_write(struct super_block *sb, int level)\n{\n\ts64 writers;\n\n\t/*\n\t * We just cycle-through lockdep here so that it does not complain\n\t * about returning with lock to userspace\n\t */\n\trwsem_acquire(&sb->s_writers.lock_map[level-1], 0, 0, _THIS_IP_);\n\trwsem_release(&sb->s_writers.lock_map[level-1], 1, _THIS_IP_);\n\n\tdo {\n\t\tDEFINE_WAIT(wait);\n\n\t\t/*\n\t\t * We use a barrier in prepare_to_wait() to separate setting\n\t\t * of frozen and checking of the counter\n\t\t */\n\t\tprepare_to_wait(&sb->s_writers.wait, &wait,\n\t\t\t\tTASK_UNINTERRUPTIBLE);\n\n\t\twriters = percpu_counter_sum(&sb->s_writers.counter[level-1]);\n\t\tif (writers)\n\t\t\tschedule();\n\n\t\tfinish_wait(&sb->s_writers.wait, &wait);\n\t} while (writers);\n}",
          "includes": [
            "include \"internal.h\"",
            "include <linux/lockdep.h>\n#",
            "include <linux/fsnotify.h>\n#",
            "include <linux/cleancache.h>\n#",
            "include <linux/rculist_bl.h>\n#",
            "include <linux/backing-dev.h>\n#",
            "include <linux/mutex.h>\n#",
            "include <linux/idr.h>\n#",
            "include <linux/writeback.h>\t\t/* for the emergency remount stuff */\n#",
            "include <linux/security.h>\n#",
            "include <linux/mount.h>\n#",
            "include <linux/blkdev.h>\n#",
            "include <linux/slab.h>\n#",
            "include <linux/export.h>\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"internal.h\"\ninclude <linux/lockdep.h>\n#\ninclude <linux/fsnotify.h>\n#\ninclude <linux/cleancache.h>\n#\ninclude <linux/rculist_bl.h>\n#\ninclude <linux/backing-dev.h>\n#\ninclude <linux/mutex.h>\n#\ninclude <linux/idr.h>\n#\ninclude <linux/writeback.h>\t\t/* for the emergency remount stuff */\n#\ninclude <linux/security.h>\n#\ninclude <linux/mount.h>\n#\ninclude <linux/blkdev.h>\n#\ninclude <linux/slab.h>\n#\ninclude <linux/export.h>\n#\n\ntatic void sb_wait_write(struct super_block *sb, int level)\n{\n\ts64 writers;\n\n\t/*\n\t * We just cycle-through lockdep here so that it does not complain\n\t * about returning with lock to userspace\n\t */\n\trwsem_acquire(&sb->s_writers.lock_map[level-1], 0, 0, _THIS_IP_);\n\trwsem_release(&sb->s_writers.lock_map[level-1], 1, _THIS_IP_);\n\n\tdo {\n\t\tDEFINE_WAIT(wait);\n\n\t\t/*\n\t\t * We use a barrier in prepare_to_wait() to separate setting\n\t\t * of frozen and checking of the counter\n\t\t */\n\t\tprepare_to_wait(&sb->s_writers.wait, &wait,\n\t\t\t\tTASK_UNINTERRUPTIBLE);\n\n\t\twriters = percpu_counter_sum(&sb->s_writers.counter[level-1]);\n\t\tif (writers)\n\t\t\tschedule();\n\n\t\tfinish_wait(&sb->s_writers.wait, &wait);\n\t} while (writers);\n}"
        }
      },
      {
        "call_info": {
          "callee": "own_read(",
          "args": [
            "sb->s_umount)"
          ],
          "line": 551
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pin_unlock(",
          "args": [
            "sb_lock)"
          ],
          "line": 549
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_entry(",
          "args": [
            "b,",
            "type->fs_supers,",
            "_instances)"
          ],
          "line": 547
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pin_lock(",
          "args": [
            "sb_lock)"
          ],
          "line": 546
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "include \"internal.h\"\ninclude <linux/lockdep.h>\n#\ninclude <linux/fsnotify.h>\n#\ninclude <linux/cleancache.h>\n#\ninclude <linux/rculist_bl.h>\n#\ninclude <linux/backing-dev.h>\n#\ninclude <linux/mutex.h>\n#\ninclude <linux/idr.h>\n#\ninclude <linux/writeback.h>\t\t/* for the emergency remount stuff */\n#\ninclude <linux/security.h>\n#\ninclude <linux/mount.h>\n#\ninclude <linux/blkdev.h>\n#\ninclude <linux/slab.h>\n#\ninclude <linux/export.h>\n#\n\ntatic DEFINE_SPINLOCK(sb_lock);\n\noid iterate_supers_type(struct file_system_type *type,\n\tvoid (*f)(struct super_block *, void *), void *arg)\n{\n\tstruct super_block *sb, *p = NULL;\n\n\tspin_lock(&sb_lock);\n\thlist_for_each_entry(sb, &type->fs_supers, s_instances) {\n\t\tsb->s_count++;\n\t\tspin_unlock(&sb_lock);\n\n\t\tdown_read(&sb->s_umount);\n\t\tif (sb->s_root && (sb->s_flags & MS_BORN))\n\t\t\tf(sb, arg);\n\t\tup_read(&sb->s_umount);\n\n\t\tspin_lock(&sb_lock);\n\t\tif (p)\n\t\t\t__put_super(p);\n\t\tp = sb;\n\t}\n\tif (p)\n\t\t__put_super(p);\n\tspin_unlock(&sb_lock);\n}"
  },
  {
    "function_name": "terate_supers(",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/super.c",
    "lines": "506-530",
    "snippet": "oid iterate_supers(void (*f)(struct super_block *, void *), void *arg)\n{\n\tstruct super_block *sb, *p = NULL;\n\n\tspin_lock(&sb_lock);\n\tlist_for_each_entry(sb, &super_blocks, s_list) {\n\t\tif (hlist_unhashed(&sb->s_instances))\n\t\t\tcontinue;\n\t\tsb->s_count++;\n\t\tspin_unlock(&sb_lock);\n\n\t\tdown_read(&sb->s_umount);\n\t\tif (sb->s_root && (sb->s_flags & MS_BORN))\n\t\t\tf(sb, arg);\n\t\tup_read(&sb->s_umount);\n\n\t\tspin_lock(&sb_lock);\n\t\tif (p)\n\t\t\t__put_super(p);\n\t\tp = sb;\n\t}\n\tif (p)\n\t\t__put_super(p);\n\tspin_unlock(&sb_lock);\n}",
    "includes": [
      "include \"internal.h\"",
      "include <linux/lockdep.h>\n#",
      "include <linux/fsnotify.h>\n#",
      "include <linux/cleancache.h>\n#",
      "include <linux/rculist_bl.h>\n#",
      "include <linux/backing-dev.h>\n#",
      "include <linux/mutex.h>\n#",
      "include <linux/idr.h>\n#",
      "include <linux/writeback.h>\t\t/* for the emergency remount stuff */\n#",
      "include <linux/security.h>\n#",
      "include <linux/mount.h>\n#",
      "include <linux/blkdev.h>\n#",
      "include <linux/slab.h>\n#",
      "include <linux/export.h>\n#"
    ],
    "macros_used": [],
    "globals_used": [
      "tatic LIST_HEAD(super_blocks);",
      "tatic DEFINE_SPINLOCK(sb_lock);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "pin_unlock(",
          "args": [
            "sb_lock)"
          ],
          "line": 529
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_put_super(",
          "args": [
            ")"
          ],
          "line": 528
        },
        "resolved": true,
        "details": {
          "function_name": "_put_super(",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/super.c",
          "lines": "246-252",
          "snippet": "tatic void __put_super(struct super_block *sb)\n{\n\tif (!--sb->s_count) {\n\t\tlist_del_init(&sb->s_list);\n\t\tdestroy_super(sb);\n\t}\n}",
          "includes": [
            "include \"internal.h\"",
            "include <linux/lockdep.h>\n#",
            "include <linux/fsnotify.h>\n#",
            "include <linux/cleancache.h>\n#",
            "include <linux/rculist_bl.h>\n#",
            "include <linux/backing-dev.h>\n#",
            "include <linux/mutex.h>\n#",
            "include <linux/idr.h>\n#",
            "include <linux/writeback.h>\t\t/* for the emergency remount stuff */\n#",
            "include <linux/security.h>\n#",
            "include <linux/mount.h>\n#",
            "include <linux/blkdev.h>\n#",
            "include <linux/slab.h>\n#",
            "include <linux/export.h>\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"internal.h\"\ninclude <linux/lockdep.h>\n#\ninclude <linux/fsnotify.h>\n#\ninclude <linux/cleancache.h>\n#\ninclude <linux/rculist_bl.h>\n#\ninclude <linux/backing-dev.h>\n#\ninclude <linux/mutex.h>\n#\ninclude <linux/idr.h>\n#\ninclude <linux/writeback.h>\t\t/* for the emergency remount stuff */\n#\ninclude <linux/security.h>\n#\ninclude <linux/mount.h>\n#\ninclude <linux/blkdev.h>\n#\ninclude <linux/slab.h>\n#\ninclude <linux/export.h>\n#\n\ntatic void __put_super(struct super_block *sb)\n{\n\tif (!--sb->s_count) {\n\t\tlist_del_init(&sb->s_list);\n\t\tdestroy_super(sb);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "pin_lock(",
          "args": [
            "sb_lock)"
          ],
          "line": 522
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "p_read(",
          "args": [
            "sb->s_umount)"
          ],
          "line": 520
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "(",
          "args": [
            "b,",
            "rg)"
          ],
          "line": 519
        },
        "resolved": true,
        "details": {
          "function_name": "b_wait_write(",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/super.c",
          "lines": "1228-1255",
          "snippet": "tatic void sb_wait_write(struct super_block *sb, int level)\n{\n\ts64 writers;\n\n\t/*\n\t * We just cycle-through lockdep here so that it does not complain\n\t * about returning with lock to userspace\n\t */\n\trwsem_acquire(&sb->s_writers.lock_map[level-1], 0, 0, _THIS_IP_);\n\trwsem_release(&sb->s_writers.lock_map[level-1], 1, _THIS_IP_);\n\n\tdo {\n\t\tDEFINE_WAIT(wait);\n\n\t\t/*\n\t\t * We use a barrier in prepare_to_wait() to separate setting\n\t\t * of frozen and checking of the counter\n\t\t */\n\t\tprepare_to_wait(&sb->s_writers.wait, &wait,\n\t\t\t\tTASK_UNINTERRUPTIBLE);\n\n\t\twriters = percpu_counter_sum(&sb->s_writers.counter[level-1]);\n\t\tif (writers)\n\t\t\tschedule();\n\n\t\tfinish_wait(&sb->s_writers.wait, &wait);\n\t} while (writers);\n}",
          "includes": [
            "include \"internal.h\"",
            "include <linux/lockdep.h>\n#",
            "include <linux/fsnotify.h>\n#",
            "include <linux/cleancache.h>\n#",
            "include <linux/rculist_bl.h>\n#",
            "include <linux/backing-dev.h>\n#",
            "include <linux/mutex.h>\n#",
            "include <linux/idr.h>\n#",
            "include <linux/writeback.h>\t\t/* for the emergency remount stuff */\n#",
            "include <linux/security.h>\n#",
            "include <linux/mount.h>\n#",
            "include <linux/blkdev.h>\n#",
            "include <linux/slab.h>\n#",
            "include <linux/export.h>\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"internal.h\"\ninclude <linux/lockdep.h>\n#\ninclude <linux/fsnotify.h>\n#\ninclude <linux/cleancache.h>\n#\ninclude <linux/rculist_bl.h>\n#\ninclude <linux/backing-dev.h>\n#\ninclude <linux/mutex.h>\n#\ninclude <linux/idr.h>\n#\ninclude <linux/writeback.h>\t\t/* for the emergency remount stuff */\n#\ninclude <linux/security.h>\n#\ninclude <linux/mount.h>\n#\ninclude <linux/blkdev.h>\n#\ninclude <linux/slab.h>\n#\ninclude <linux/export.h>\n#\n\ntatic void sb_wait_write(struct super_block *sb, int level)\n{\n\ts64 writers;\n\n\t/*\n\t * We just cycle-through lockdep here so that it does not complain\n\t * about returning with lock to userspace\n\t */\n\trwsem_acquire(&sb->s_writers.lock_map[level-1], 0, 0, _THIS_IP_);\n\trwsem_release(&sb->s_writers.lock_map[level-1], 1, _THIS_IP_);\n\n\tdo {\n\t\tDEFINE_WAIT(wait);\n\n\t\t/*\n\t\t * We use a barrier in prepare_to_wait() to separate setting\n\t\t * of frozen and checking of the counter\n\t\t */\n\t\tprepare_to_wait(&sb->s_writers.wait, &wait,\n\t\t\t\tTASK_UNINTERRUPTIBLE);\n\n\t\twriters = percpu_counter_sum(&sb->s_writers.counter[level-1]);\n\t\tif (writers)\n\t\t\tschedule();\n\n\t\tfinish_wait(&sb->s_writers.wait, &wait);\n\t} while (writers);\n}"
        }
      },
      {
        "call_info": {
          "callee": "own_read(",
          "args": [
            "sb->s_umount)"
          ],
          "line": 517
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pin_unlock(",
          "args": [
            "sb_lock)"
          ],
          "line": 515
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_unhashed(",
          "args": [
            "sb->s_instances)"
          ],
          "line": 512
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ist_for_each_entry(",
          "args": [
            "b,",
            "super_blocks,",
            "_list)"
          ],
          "line": 511
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pin_lock(",
          "args": [
            "sb_lock)"
          ],
          "line": 510
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "include \"internal.h\"\ninclude <linux/lockdep.h>\n#\ninclude <linux/fsnotify.h>\n#\ninclude <linux/cleancache.h>\n#\ninclude <linux/rculist_bl.h>\n#\ninclude <linux/backing-dev.h>\n#\ninclude <linux/mutex.h>\n#\ninclude <linux/idr.h>\n#\ninclude <linux/writeback.h>\t\t/* for the emergency remount stuff */\n#\ninclude <linux/security.h>\n#\ninclude <linux/mount.h>\n#\ninclude <linux/blkdev.h>\n#\ninclude <linux/slab.h>\n#\ninclude <linux/export.h>\n#\n\ntatic LIST_HEAD(super_blocks);\ntatic DEFINE_SPINLOCK(sb_lock);\n\noid iterate_supers(void (*f)(struct super_block *, void *), void *arg)\n{\n\tstruct super_block *sb, *p = NULL;\n\n\tspin_lock(&sb_lock);\n\tlist_for_each_entry(sb, &super_blocks, s_list) {\n\t\tif (hlist_unhashed(&sb->s_instances))\n\t\t\tcontinue;\n\t\tsb->s_count++;\n\t\tspin_unlock(&sb_lock);\n\n\t\tdown_read(&sb->s_umount);\n\t\tif (sb->s_root && (sb->s_flags & MS_BORN))\n\t\t\tf(sb, arg);\n\t\tup_read(&sb->s_umount);\n\n\t\tspin_lock(&sb_lock);\n\t\tif (p)\n\t\t\t__put_super(p);\n\t\tp = sb;\n\t}\n\tif (p)\n\t\t__put_super(p);\n\tspin_unlock(&sb_lock);\n}"
  },
  {
    "function_name": "rop_super(",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/super.c",
    "lines": "490-494",
    "snippet": "oid drop_super(struct super_block *sb)\n{\n\tup_read(&sb->s_umount);\n\tput_super(sb);\n}",
    "includes": [
      "include \"internal.h\"",
      "include <linux/lockdep.h>\n#",
      "include <linux/fsnotify.h>\n#",
      "include <linux/cleancache.h>\n#",
      "include <linux/rculist_bl.h>\n#",
      "include <linux/backing-dev.h>\n#",
      "include <linux/mutex.h>\n#",
      "include <linux/idr.h>\n#",
      "include <linux/writeback.h>\t\t/* for the emergency remount stuff */\n#",
      "include <linux/security.h>\n#",
      "include <linux/mount.h>\n#",
      "include <linux/blkdev.h>\n#",
      "include <linux/slab.h>\n#",
      "include <linux/export.h>\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ut_super(",
          "args": [
            "b)"
          ],
          "line": 493
        },
        "resolved": true,
        "details": {
          "function_name": "ut_super(",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/super.c",
          "lines": "261-266",
          "snippet": "tatic void put_super(struct super_block *sb)\n{\n\tspin_lock(&sb_lock);\n\t__put_super(sb);\n\tspin_unlock(&sb_lock);\n}",
          "includes": [
            "include \"internal.h\"",
            "include <linux/lockdep.h>\n#",
            "include <linux/fsnotify.h>\n#",
            "include <linux/cleancache.h>\n#",
            "include <linux/rculist_bl.h>\n#",
            "include <linux/backing-dev.h>\n#",
            "include <linux/mutex.h>\n#",
            "include <linux/idr.h>\n#",
            "include <linux/writeback.h>\t\t/* for the emergency remount stuff */\n#",
            "include <linux/security.h>\n#",
            "include <linux/mount.h>\n#",
            "include <linux/blkdev.h>\n#",
            "include <linux/slab.h>\n#",
            "include <linux/export.h>\n#"
          ],
          "macros_used": [],
          "globals_used": [
            "tatic DEFINE_SPINLOCK(sb_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "include \"internal.h\"\ninclude <linux/lockdep.h>\n#\ninclude <linux/fsnotify.h>\n#\ninclude <linux/cleancache.h>\n#\ninclude <linux/rculist_bl.h>\n#\ninclude <linux/backing-dev.h>\n#\ninclude <linux/mutex.h>\n#\ninclude <linux/idr.h>\n#\ninclude <linux/writeback.h>\t\t/* for the emergency remount stuff */\n#\ninclude <linux/security.h>\n#\ninclude <linux/mount.h>\n#\ninclude <linux/blkdev.h>\n#\ninclude <linux/slab.h>\n#\ninclude <linux/export.h>\n#\n\ntatic DEFINE_SPINLOCK(sb_lock);\n\ntatic void put_super(struct super_block *sb)\n{\n\tspin_lock(&sb_lock);\n\t__put_super(sb);\n\tspin_unlock(&sb_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "p_read(",
          "args": [
            "sb->s_umount)"
          ],
          "line": 492
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "include \"internal.h\"\ninclude <linux/lockdep.h>\n#\ninclude <linux/fsnotify.h>\n#\ninclude <linux/cleancache.h>\n#\ninclude <linux/rculist_bl.h>\n#\ninclude <linux/backing-dev.h>\n#\ninclude <linux/mutex.h>\n#\ninclude <linux/idr.h>\n#\ninclude <linux/writeback.h>\t\t/* for the emergency remount stuff */\n#\ninclude <linux/security.h>\n#\ninclude <linux/mount.h>\n#\ninclude <linux/blkdev.h>\n#\ninclude <linux/slab.h>\n#\ninclude <linux/export.h>\n#\n\noid drop_super(struct super_block *sb)\n{\n\tup_read(&sb->s_umount);\n\tput_super(sb);\n}"
  },
  {
    "function_name": "get(",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/super.c",
    "lines": "437-486",
    "snippet": "truct super_block *sget(struct file_system_type *type,\n\t\t\tint (*test)(struct super_block *,void *),\n\t\t\tint (*set)(struct super_block *,void *),\n\t\t\tint flags,\n\t\t\tvoid *data)\n{\n\tstruct super_block *s = NULL;\n\tstruct super_block *old;\n\tint err;\n\nretry:\n\tspin_lock(&sb_lock);\n\tif (test) {\n\t\thlist_for_each_entry(old, &type->fs_supers, s_instances) {\n\t\t\tif (!test(old, data))\n\t\t\t\tcontinue;\n\t\t\tif (!grab_super(old))\n\t\t\t\tgoto retry;\n\t\t\tif (s) {\n\t\t\t\tup_write(&s->s_umount);\n\t\t\t\tdestroy_super(s);\n\t\t\t\ts = NULL;\n\t\t\t}\n\t\t\treturn old;\n\t\t}\n\t}\n\tif (!s) {\n\t\tspin_unlock(&sb_lock);\n\t\ts = alloc_super(type, flags);\n\t\tif (!s)\n\t\t\treturn ERR_PTR(-ENOMEM);\n\t\tgoto retry;\n\t}\n\t\t\n\terr = set(s, data);\n\tif (err) {\n\t\tspin_unlock(&sb_lock);\n\t\tup_write(&s->s_umount);\n\t\tdestroy_super(s);\n\t\treturn ERR_PTR(err);\n\t}\n\ts->s_type = type;\n\tstrlcpy(s->s_id, type->name, sizeof(s->s_id));\n\tlist_add_tail(&s->s_list, &super_blocks);\n\thlist_add_head(&s->s_instances, &type->fs_supers);\n\tspin_unlock(&sb_lock);\n\tget_filesystem(type);\n\tregister_shrinker(&s->s_shrink);\n\treturn s;\n}",
    "includes": [
      "include \"internal.h\"",
      "include <linux/lockdep.h>\n#",
      "include <linux/fsnotify.h>\n#",
      "include <linux/cleancache.h>\n#",
      "include <linux/rculist_bl.h>\n#",
      "include <linux/backing-dev.h>\n#",
      "include <linux/mutex.h>\n#",
      "include <linux/idr.h>\n#",
      "include <linux/writeback.h>\t\t/* for the emergency remount stuff */\n#",
      "include <linux/security.h>\n#",
      "include <linux/mount.h>\n#",
      "include <linux/blkdev.h>\n#",
      "include <linux/slab.h>\n#",
      "include <linux/export.h>\n#"
    ],
    "macros_used": [],
    "globals_used": [
      "tatic LIST_HEAD(super_blocks);",
      "tatic DEFINE_SPINLOCK(sb_lock);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "egister_shrinker(",
          "args": [
            "s->s_shrink)"
          ],
          "line": 484
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "et_filesystem(",
          "args": [
            "ype)"
          ],
          "line": 483
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pin_unlock(",
          "args": [
            "sb_lock)"
          ],
          "line": 482
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_add_head(",
          "args": [
            "s->s_instances,",
            "type->fs_supers)"
          ],
          "line": 481
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ist_add_tail(",
          "args": [
            "s->s_list,",
            "super_blocks)"
          ],
          "line": 480
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trlcpy(",
          "args": [
            "->s_id,",
            "ype->name,",
            "izeof(s->s_id))"
          ],
          "line": 479
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RR_PTR(",
          "args": [
            "rr)"
          ],
          "line": 476
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "estroy_super(",
          "args": [
            ")"
          ],
          "line": 475
        },
        "resolved": true,
        "details": {
          "function_name": "estroy_super(",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/super.c",
          "lines": "144-156",
          "snippet": "tatic void destroy_super(struct super_block *s)\n{\n\tint i;\n\tlist_lru_destroy(&s->s_dentry_lru);\n\tlist_lru_destroy(&s->s_inode_lru);\n\tfor (i = 0; i < SB_FREEZE_LEVELS; i++)\n\t\tpercpu_counter_destroy(&s->s_writers.counter[i]);\n\tsecurity_sb_free(s);\n\tWARN_ON(!list_empty(&s->s_mounts));\n\tkfree(s->s_subtype);\n\tkfree(s->s_options);\n\tkfree_rcu(s, rcu);\n}",
          "includes": [
            "include \"internal.h\"",
            "include <linux/lockdep.h>\n#",
            "include <linux/fsnotify.h>\n#",
            "include <linux/cleancache.h>\n#",
            "include <linux/rculist_bl.h>\n#",
            "include <linux/backing-dev.h>\n#",
            "include <linux/mutex.h>\n#",
            "include <linux/idr.h>\n#",
            "include <linux/writeback.h>\t\t/* for the emergency remount stuff */\n#",
            "include <linux/security.h>\n#",
            "include <linux/mount.h>\n#",
            "include <linux/blkdev.h>\n#",
            "include <linux/slab.h>\n#",
            "include <linux/export.h>\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"internal.h\"\ninclude <linux/lockdep.h>\n#\ninclude <linux/fsnotify.h>\n#\ninclude <linux/cleancache.h>\n#\ninclude <linux/rculist_bl.h>\n#\ninclude <linux/backing-dev.h>\n#\ninclude <linux/mutex.h>\n#\ninclude <linux/idr.h>\n#\ninclude <linux/writeback.h>\t\t/* for the emergency remount stuff */\n#\ninclude <linux/security.h>\n#\ninclude <linux/mount.h>\n#\ninclude <linux/blkdev.h>\n#\ninclude <linux/slab.h>\n#\ninclude <linux/export.h>\n#\n\ntatic void destroy_super(struct super_block *s)\n{\n\tint i;\n\tlist_lru_destroy(&s->s_dentry_lru);\n\tlist_lru_destroy(&s->s_inode_lru);\n\tfor (i = 0; i < SB_FREEZE_LEVELS; i++)\n\t\tpercpu_counter_destroy(&s->s_writers.counter[i]);\n\tsecurity_sb_free(s);\n\tWARN_ON(!list_empty(&s->s_mounts));\n\tkfree(s->s_subtype);\n\tkfree(s->s_options);\n\tkfree_rcu(s, rcu);\n}"
        }
      },
      {
        "call_info": {
          "callee": "p_write(",
          "args": [
            "s->s_umount)"
          ],
          "line": 474
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pin_unlock(",
          "args": [
            "sb_lock)"
          ],
          "line": 473
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "et(",
          "args": [
            ",",
            "ata)"
          ],
          "line": 471
        },
        "resolved": true,
        "details": {
          "function_name": "_iget(stru",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/romfs/super.c",
          "lines": "295-384",
          "snippet": "c struct inode *romfs_iget(struct super_block *sb, unsigned long pos)\n{\n\tstruct romfs_inode_info *inode;\n\tstruct romfs_inode ri;\n\tstruct inode *i;\n\tunsigned long nlen;\n\tunsigned nextfh;\n\tint ret;\n\tumode_t mode;\n\n\t/* we might have to traverse a chain of \"hard link\" file entries to get\n\t * to the actual file */\n\tfor (;;) {\n\t\tret = romfs_dev_read(sb, pos, &ri, sizeof(ri));\n\t\tif (ret < 0)\n\t\t\tgoto error;\n\n\t\t/* XXX: do romfs_checksum here too (with name) */\n\n\t\tnextfh = be32_to_cpu(ri.next);\n\t\tif ((nextfh & ROMFH_TYPE) != ROMFH_HRD)\n\t\t\tbreak;\n\n\t\tpos = be32_to_cpu(ri.spec) & ROMFH_MASK;\n\t}\n\n\t/* determine the length of the filename */\n\tnlen = romfs_dev_strnlen(sb, pos + ROMFH_SIZE, ROMFS_MAXFN);\n\tif (IS_ERR_VALUE(nlen))\n\t\tgoto eio;\n\n\t/* get an inode for this image position */\n\ti = iget_locked(sb, pos);\n\tif (!i)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tif (!(i->i_state & I_NEW))\n\t\treturn i;\n\n\t/* precalculate the data offset */\n\tinode = ROMFS_I(i);\n\tinode->i_metasize = (ROMFH_SIZE + nlen + 1 + ROMFH_PAD) & ROMFH_MASK;\n\tinode->i_dataoffset = pos + inode->i_metasize;\n\n\tset_nlink(i, 1);\t\t/* Hard to decide.. */\n\ti->i_size = be32_to_cpu(ri.size);\n\ti->i_mtime.tv_sec = i->i_atime.tv_sec = i->i_ctime.tv_sec = 0;\n\ti->i_mtime.tv_nsec = i->i_atime.tv_nsec = i->i_ctime.tv_nsec = 0;\n\n\t/* set up mode and ops */\n\tmode = romfs_modemap[nextfh & ROMFH_TYPE];\n\n\tswitch (nextfh & ROMFH_TYPE) {\n\tcase ROMFH_DIR:\n\t\ti->i_size = ROMFS_I(i)->i_metasize;\n\t\ti->i_op = &romfs_dir_inode_operations;\n\t\ti->i_fop = &romfs_dir_operations;\n\t\tif (nextfh & ROMFH_EXEC)\n\t\t\tmode |= S_IXUGO;\n\t\tbreak;\n\tcase ROMFH_REG:\n\t\ti->i_fop = &romfs_ro_fops;\n\t\ti->i_data.a_ops = &romfs_aops;\n\t\tif (nextfh & ROMFH_EXEC)\n\t\t\tmode |= S_IXUGO;\n\t\tbreak;\n\tcase ROMFH_SYM:\n\t\ti->i_op = &page_symlink_inode_operations;\n\t\ti->i_data.a_ops = &romfs_aops;\n\t\tmode |= S_IRWXUGO;\n\t\tbreak;\n\tdefault:\n\t\t/* depending on MBZ for sock/fifos */\n\t\tnextfh = be32_to_cpu(ri.spec);\n\t\tinit_special_inode(i, mode, MKDEV(nextfh >> 16,\n\t\t\t\t\t\t  nextfh & 0xffff));\n\t\tbreak;\n\t}\n\n\ti->i_mode = mode;\n\n\tunlock_new_inode(i);\n\treturn i;\n\neio:\n\tret = -EIO;\nerror:\n\tpr_err(\"read error for inode 0x%lx\\n\", pos);\n\treturn ERR_PTR(ret);\n}\n\n/*",
          "includes": [
            "ude \"internal.h\"\n\nstat",
            "ude <linux/uaccess.h>\n#incl",
            "ude <linux/pagemap.h>\n#incl",
            "ude <linux/highmem.h>\n#incl",
            "ude <linux/ctype.h>\n#incl",
            "ude <linux/mtd/super.h>\n#incl",
            "ude <linux/statfs.h>\n#incl",
            "ude <linux/namei.h>\n#incl",
            "ude <linux/mount.h>\n#incl",
            "ude <linux/parser.h>\n#incl",
            "ude <linux/blkdev.h>\n#incl",
            "ude <linux/init.h>\n#incl",
            "ude <linux/slab.h>\n#incl",
            "ude <linux/time.h>\n#incl",
            "ude <linux/fs.h>\n#incl",
            "ude <linux/string.h>\n#incl",
            "ude <linux/module.h>\n#incl"
          ],
          "macros_used": [],
          "globals_used": [
            "c const umode_t romfs_modemap[8] = {\n\t0,\t\t\t/* hard link */\n\tS_IFDIR  | 0644,\t/* directory */\n\tS_IFREG  | 0644,\t/* regular file */\n\tS_IFLNK  | 0777,\t/* symlink */\n\tS_IFBLK  | 0600,\t/* blockdev */\n\tS_IFCHR  | 0600,\t/* chardev */\n\tS_IFSOCK | 0644,\t/* socket */\n\tS_IFIFO  | 0644\t\t/* FIFO */\n};\n\nsta",
            "c struct inode *romfs_iget(struct super_block *sb, unsigned long pos);\n\n/*",
            "c const struct address_space_operations romfs_aops = {\n\t.readpage\t= romfs_readpage\n};\n\n/*",
            "c const struct file_operations romfs_dir_operations = {\n\t.read\t\t= generic_read_dir,\n\t.iterate\t= romfs_readdir,\n\t.llseek\t\t= default_llseek,\n};\n\nsta",
            "c const struct inode_operations romfs_dir_inode_operations = {\n\t.lookup\t\t= romfs_lookup,\n};\n\n/*"
          ],
          "called_functions": [],
          "contextual_snippet": "ude \"internal.h\"\n\nstat\nude <linux/uaccess.h>\n#incl\nude <linux/pagemap.h>\n#incl\nude <linux/highmem.h>\n#incl\nude <linux/ctype.h>\n#incl\nude <linux/mtd/super.h>\n#incl\nude <linux/statfs.h>\n#incl\nude <linux/namei.h>\n#incl\nude <linux/mount.h>\n#incl\nude <linux/parser.h>\n#incl\nude <linux/blkdev.h>\n#incl\nude <linux/init.h>\n#incl\nude <linux/slab.h>\n#incl\nude <linux/time.h>\n#incl\nude <linux/fs.h>\n#incl\nude <linux/string.h>\n#incl\nude <linux/module.h>\n#incl\n\nc const umode_t romfs_modemap[8] = {\n\t0,\t\t\t/* hard link */\n\tS_IFDIR  | 0644,\t/* directory */\n\tS_IFREG  | 0644,\t/* regular file */\n\tS_IFLNK  | 0777,\t/* symlink */\n\tS_IFBLK  | 0600,\t/* blockdev */\n\tS_IFCHR  | 0600,\t/* chardev */\n\tS_IFSOCK | 0644,\t/* socket */\n\tS_IFIFO  | 0644\t\t/* FIFO */\n};\n\nsta;\nc struct inode *romfs_iget(struct super_block *sb, unsigned long pos);\n\n/*;\nc const struct address_space_operations romfs_aops = {\n\t.readpage\t= romfs_readpage\n};\n\n/*;\nc const struct file_operations romfs_dir_operations = {\n\t.read\t\t= generic_read_dir,\n\t.iterate\t= romfs_readdir,\n\t.llseek\t\t= default_llseek,\n};\n\nsta;\nc const struct inode_operations romfs_dir_inode_operations = {\n\t.lookup\t\t= romfs_lookup,\n};\n\n/*;\n\nc struct inode *romfs_iget(struct super_block *sb, unsigned long pos)\n{\n\tstruct romfs_inode_info *inode;\n\tstruct romfs_inode ri;\n\tstruct inode *i;\n\tunsigned long nlen;\n\tunsigned nextfh;\n\tint ret;\n\tumode_t mode;\n\n\t/* we might have to traverse a chain of \"hard link\" file entries to get\n\t * to the actual file */\n\tfor (;;) {\n\t\tret = romfs_dev_read(sb, pos, &ri, sizeof(ri));\n\t\tif (ret < 0)\n\t\t\tgoto error;\n\n\t\t/* XXX: do romfs_checksum here too (with name) */\n\n\t\tnextfh = be32_to_cpu(ri.next);\n\t\tif ((nextfh & ROMFH_TYPE) != ROMFH_HRD)\n\t\t\tbreak;\n\n\t\tpos = be32_to_cpu(ri.spec) & ROMFH_MASK;\n\t}\n\n\t/* determine the length of the filename */\n\tnlen = romfs_dev_strnlen(sb, pos + ROMFH_SIZE, ROMFS_MAXFN);\n\tif (IS_ERR_VALUE(nlen))\n\t\tgoto eio;\n\n\t/* get an inode for this image position */\n\ti = iget_locked(sb, pos);\n\tif (!i)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tif (!(i->i_state & I_NEW))\n\t\treturn i;\n\n\t/* precalculate the data offset */\n\tinode = ROMFS_I(i);\n\tinode->i_metasize = (ROMFH_SIZE + nlen + 1 + ROMFH_PAD) & ROMFH_MASK;\n\tinode->i_dataoffset = pos + inode->i_metasize;\n\n\tset_nlink(i, 1);\t\t/* Hard to decide.. */\n\ti->i_size = be32_to_cpu(ri.size);\n\ti->i_mtime.tv_sec = i->i_atime.tv_sec = i->i_ctime.tv_sec = 0;\n\ti->i_mtime.tv_nsec = i->i_atime.tv_nsec = i->i_ctime.tv_nsec = 0;\n\n\t/* set up mode and ops */\n\tmode = romfs_modemap[nextfh & ROMFH_TYPE];\n\n\tswitch (nextfh & ROMFH_TYPE) {\n\tcase ROMFH_DIR:\n\t\ti->i_size = ROMFS_I(i)->i_metasize;\n\t\ti->i_op = &romfs_dir_inode_operations;\n\t\ti->i_fop = &romfs_dir_operations;\n\t\tif (nextfh & ROMFH_EXEC)\n\t\t\tmode |= S_IXUGO;\n\t\tbreak;\n\tcase ROMFH_REG:\n\t\ti->i_fop = &romfs_ro_fops;\n\t\ti->i_data.a_ops = &romfs_aops;\n\t\tif (nextfh & ROMFH_EXEC)\n\t\t\tmode |= S_IXUGO;\n\t\tbreak;\n\tcase ROMFH_SYM:\n\t\ti->i_op = &page_symlink_inode_operations;\n\t\ti->i_data.a_ops = &romfs_aops;\n\t\tmode |= S_IRWXUGO;\n\t\tbreak;\n\tdefault:\n\t\t/* depending on MBZ for sock/fifos */\n\t\tnextfh = be32_to_cpu(ri.spec);\n\t\tinit_special_inode(i, mode, MKDEV(nextfh >> 16,\n\t\t\t\t\t\t  nextfh & 0xffff));\n\t\tbreak;\n\t}\n\n\ti->i_mode = mode;\n\n\tunlock_new_inode(i);\n\treturn i;\n\neio:\n\tret = -EIO;\nerror:\n\tpr_err(\"read error for inode 0x%lx\\n\", pos);\n\treturn ERR_PTR(ret);\n}\n\n/*"
        }
      },
      {
        "call_info": {
          "callee": "RR_PTR(",
          "args": [
            "ENOMEM)"
          ],
          "line": 467
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lloc_super(",
          "args": [
            "ype,",
            "lags)"
          ],
          "line": 465
        },
        "resolved": true,
        "details": {
          "function_name": "lloc_super(",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/super.c",
          "lines": "166-239",
          "snippet": "tatic struct super_block *alloc_super(struct file_system_type *type, int flags)\n{\n\tstruct super_block *s = kzalloc(sizeof(struct super_block),  GFP_USER);\n\tstatic const struct super_operations default_op;\n\tint i;\n\n\tif (!s)\n\t\treturn NULL;\n\n\tINIT_LIST_HEAD(&s->s_mounts);\n\n\tif (security_sb_alloc(s))\n\t\tgoto fail;\n\n\tfor (i = 0; i < SB_FREEZE_LEVELS; i++) {\n\t\tif (percpu_counter_init(&s->s_writers.counter[i], 0,\n\t\t\t\t\tGFP_KERNEL) < 0)\n\t\t\tgoto fail;\n\t\tlockdep_init_map(&s->s_writers.lock_map[i], sb_writers_name[i],\n\t\t\t\t &type->s_writers_key[i], 0);\n\t}\n\tinit_waitqueue_head(&s->s_writers.wait);\n\tinit_waitqueue_head(&s->s_writers.wait_unfrozen);\n\ts->s_bdi = &noop_backing_dev_info;\n\ts->s_flags = flags;\n\tINIT_HLIST_NODE(&s->s_instances);\n\tINIT_HLIST_BL_HEAD(&s->s_anon);\n\tINIT_LIST_HEAD(&s->s_inodes);\n\n\tif (list_lru_init_memcg(&s->s_dentry_lru))\n\t\tgoto fail;\n\tif (list_lru_init_memcg(&s->s_inode_lru))\n\t\tgoto fail;\n\n\tinit_rwsem(&s->s_umount);\n\tlockdep_set_class(&s->s_umount, &type->s_umount_key);\n\t/*\n\t * sget() can have s_umount recursion.\n\t *\n\t * When it cannot find a suitable sb, it allocates a new\n\t * one (this one), and tries again to find a suitable old\n\t * one.\n\t *\n\t * In case that succeeds, it will acquire the s_umount\n\t * lock of the old one. Since these are clearly distrinct\n\t * locks, and this object isn't exposed yet, there's no\n\t * risk of deadlocks.\n\t *\n\t * Annotate this by putting this lock in a different\n\t * subclass.\n\t */\n\tdown_write_nested(&s->s_umount, SINGLE_DEPTH_NESTING);\n\ts->s_count = 1;\n\tatomic_set(&s->s_active, 1);\n\tmutex_init(&s->s_vfs_rename_mutex);\n\tlockdep_set_class(&s->s_vfs_rename_mutex, &type->s_vfs_rename_key);\n\tmutex_init(&s->s_dquot.dqio_mutex);\n\tmutex_init(&s->s_dquot.dqonoff_mutex);\n\ts->s_maxbytes = MAX_NON_LFS;\n\ts->s_op = &default_op;\n\ts->s_time_gran = 1000000000;\n\ts->cleancache_poolid = -1;\n\n\ts->s_shrink.seeks = DEFAULT_SEEKS;\n\ts->s_shrink.scan_objects = super_cache_scan;\n\ts->s_shrink.count_objects = super_cache_count;\n\ts->s_shrink.batch = 1024;\n\ts->s_shrink.flags = SHRINKER_NUMA_AWARE | SHRINKER_MEMCG_AWARE;\n\treturn s;\n\nfail:\n\tdestroy_super(s);\n\treturn NULL;\n}",
          "includes": [
            "include \"internal.h\"",
            "include <linux/lockdep.h>\n#",
            "include <linux/fsnotify.h>\n#",
            "include <linux/cleancache.h>\n#",
            "include <linux/rculist_bl.h>\n#",
            "include <linux/backing-dev.h>\n#",
            "include <linux/mutex.h>\n#",
            "include <linux/idr.h>\n#",
            "include <linux/writeback.h>\t\t/* for the emergency remount stuff */\n#",
            "include <linux/security.h>\n#",
            "include <linux/mount.h>\n#",
            "include <linux/blkdev.h>\n#",
            "include <linux/slab.h>\n#",
            "include <linux/export.h>\n#"
          ],
          "macros_used": [],
          "globals_used": [
            "tatic char *sb_writers_name[SB_FREEZE_LEVELS] = {\n\t\"sb_writers\",\n\t\"sb_pagefaults\",\n\t\"sb_internal\",\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "include \"internal.h\"\ninclude <linux/lockdep.h>\n#\ninclude <linux/fsnotify.h>\n#\ninclude <linux/cleancache.h>\n#\ninclude <linux/rculist_bl.h>\n#\ninclude <linux/backing-dev.h>\n#\ninclude <linux/mutex.h>\n#\ninclude <linux/idr.h>\n#\ninclude <linux/writeback.h>\t\t/* for the emergency remount stuff */\n#\ninclude <linux/security.h>\n#\ninclude <linux/mount.h>\n#\ninclude <linux/blkdev.h>\n#\ninclude <linux/slab.h>\n#\ninclude <linux/export.h>\n#\n\ntatic char *sb_writers_name[SB_FREEZE_LEVELS] = {\n\t\"sb_writers\",\n\t\"sb_pagefaults\",\n\t\"sb_internal\",\n};\n\ntatic struct super_block *alloc_super(struct file_system_type *type, int flags)\n{\n\tstruct super_block *s = kzalloc(sizeof(struct super_block),  GFP_USER);\n\tstatic const struct super_operations default_op;\n\tint i;\n\n\tif (!s)\n\t\treturn NULL;\n\n\tINIT_LIST_HEAD(&s->s_mounts);\n\n\tif (security_sb_alloc(s))\n\t\tgoto fail;\n\n\tfor (i = 0; i < SB_FREEZE_LEVELS; i++) {\n\t\tif (percpu_counter_init(&s->s_writers.counter[i], 0,\n\t\t\t\t\tGFP_KERNEL) < 0)\n\t\t\tgoto fail;\n\t\tlockdep_init_map(&s->s_writers.lock_map[i], sb_writers_name[i],\n\t\t\t\t &type->s_writers_key[i], 0);\n\t}\n\tinit_waitqueue_head(&s->s_writers.wait);\n\tinit_waitqueue_head(&s->s_writers.wait_unfrozen);\n\ts->s_bdi = &noop_backing_dev_info;\n\ts->s_flags = flags;\n\tINIT_HLIST_NODE(&s->s_instances);\n\tINIT_HLIST_BL_HEAD(&s->s_anon);\n\tINIT_LIST_HEAD(&s->s_inodes);\n\n\tif (list_lru_init_memcg(&s->s_dentry_lru))\n\t\tgoto fail;\n\tif (list_lru_init_memcg(&s->s_inode_lru))\n\t\tgoto fail;\n\n\tinit_rwsem(&s->s_umount);\n\tlockdep_set_class(&s->s_umount, &type->s_umount_key);\n\t/*\n\t * sget() can have s_umount recursion.\n\t *\n\t * When it cannot find a suitable sb, it allocates a new\n\t * one (this one), and tries again to find a suitable old\n\t * one.\n\t *\n\t * In case that succeeds, it will acquire the s_umount\n\t * lock of the old one. Since these are clearly distrinct\n\t * locks, and this object isn't exposed yet, there's no\n\t * risk of deadlocks.\n\t *\n\t * Annotate this by putting this lock in a different\n\t * subclass.\n\t */\n\tdown_write_nested(&s->s_umount, SINGLE_DEPTH_NESTING);\n\ts->s_count = 1;\n\tatomic_set(&s->s_active, 1);\n\tmutex_init(&s->s_vfs_rename_mutex);\n\tlockdep_set_class(&s->s_vfs_rename_mutex, &type->s_vfs_rename_key);\n\tmutex_init(&s->s_dquot.dqio_mutex);\n\tmutex_init(&s->s_dquot.dqonoff_mutex);\n\ts->s_maxbytes = MAX_NON_LFS;\n\ts->s_op = &default_op;\n\ts->s_time_gran = 1000000000;\n\ts->cleancache_poolid = -1;\n\n\ts->s_shrink.seeks = DEFAULT_SEEKS;\n\ts->s_shrink.scan_objects = super_cache_scan;\n\ts->s_shrink.count_objects = super_cache_count;\n\ts->s_shrink.batch = 1024;\n\ts->s_shrink.flags = SHRINKER_NUMA_AWARE | SHRINKER_MEMCG_AWARE;\n\treturn s;\n\nfail:\n\tdestroy_super(s);\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pin_unlock(",
          "args": [
            "sb_lock)"
          ],
          "line": 464
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "p_write(",
          "args": [
            "s->s_umount)"
          ],
          "line": 456
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rab_super(",
          "args": [
            "ld)"
          ],
          "line": 453
        },
        "resolved": true,
        "details": {
          "function_name": "rab_super(",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/super.c",
          "lines": "336-348",
          "snippet": "tatic int grab_super(struct super_block *s) __releases(sb_lock)\n{\n\ts->s_count++;\n\tspin_unlock(&sb_lock);\n\tdown_write(&s->s_umount);\n\tif ((s->s_flags & MS_BORN) && atomic_inc_not_zero(&s->s_active)) {\n\t\tput_super(s);\n\t\treturn 1;\n\t}\n\tup_write(&s->s_umount);\n\tput_super(s);\n\treturn 0;\n}",
          "includes": [
            "include \"internal.h\"",
            "include <linux/lockdep.h>\n#",
            "include <linux/fsnotify.h>\n#",
            "include <linux/cleancache.h>\n#",
            "include <linux/rculist_bl.h>\n#",
            "include <linux/backing-dev.h>\n#",
            "include <linux/mutex.h>\n#",
            "include <linux/idr.h>\n#",
            "include <linux/writeback.h>\t\t/* for the emergency remount stuff */\n#",
            "include <linux/security.h>\n#",
            "include <linux/mount.h>\n#",
            "include <linux/blkdev.h>\n#",
            "include <linux/slab.h>\n#",
            "include <linux/export.h>\n#"
          ],
          "macros_used": [],
          "globals_used": [
            "tatic DEFINE_SPINLOCK(sb_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "include \"internal.h\"\ninclude <linux/lockdep.h>\n#\ninclude <linux/fsnotify.h>\n#\ninclude <linux/cleancache.h>\n#\ninclude <linux/rculist_bl.h>\n#\ninclude <linux/backing-dev.h>\n#\ninclude <linux/mutex.h>\n#\ninclude <linux/idr.h>\n#\ninclude <linux/writeback.h>\t\t/* for the emergency remount stuff */\n#\ninclude <linux/security.h>\n#\ninclude <linux/mount.h>\n#\ninclude <linux/blkdev.h>\n#\ninclude <linux/slab.h>\n#\ninclude <linux/export.h>\n#\n\ntatic DEFINE_SPINLOCK(sb_lock);\n\ntatic int grab_super(struct super_block *s) __releases(sb_lock)\n{\n\ts->s_count++;\n\tspin_unlock(&sb_lock);\n\tdown_write(&s->s_umount);\n\tif ((s->s_flags & MS_BORN) && atomic_inc_not_zero(&s->s_active)) {\n\t\tput_super(s);\n\t\treturn 1;\n\t}\n\tup_write(&s->s_umount);\n\tput_super(s);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "est(",
          "args": [
            "ld,",
            "ata)"
          ],
          "line": 451
        },
        "resolved": true,
        "details": {
          "function_name": "sofs_iget5_test(",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/isofs/inode.c",
          "lines": "1443-1450",
          "snippet": "tatic int isofs_iget5_test(struct inode *ino, void *data)\n{\n\tstruct iso_inode_info *i = ISOFS_I(ino);\n\tstruct isofs_iget5_callback_data *d =\n\t\t(struct isofs_iget5_callback_data*)data;\n\treturn (i->i_iget5_block == d->block)\n\t\t&& (i->i_iget5_offset == d->offset);\n}",
          "includes": [
            "include \"zisofs.h\"",
            "include \"isofs.h\"\n#",
            "include <linux/user_namespace.h>",
            "include <linux/mpage.h>\n#",
            "include <linux/parser.h>\n#",
            "include <linux/cdrom.h>\n#",
            "include <linux/statfs.h>\n#",
            "include <linux/ctype.h>\n#",
            "include <linux/nls.h>\n#",
            "include <linux/slab.h>\n#",
            "include <linux/module.h>",
            "include <linux/init.h>\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"zisofs.h\"\ninclude \"isofs.h\"\n#\ninclude <linux/user_namespace.h>\ninclude <linux/mpage.h>\n#\ninclude <linux/parser.h>\n#\ninclude <linux/cdrom.h>\n#\ninclude <linux/statfs.h>\n#\ninclude <linux/ctype.h>\n#\ninclude <linux/nls.h>\n#\ninclude <linux/slab.h>\n#\ninclude <linux/module.h>\ninclude <linux/init.h>\n#\n\ntatic int isofs_iget5_test(struct inode *ino, void *data)\n{\n\tstruct iso_inode_info *i = ISOFS_I(ino);\n\tstruct isofs_iget5_callback_data *d =\n\t\t(struct isofs_iget5_callback_data*)data;\n\treturn (i->i_iget5_block == d->block)\n\t\t&& (i->i_iget5_offset == d->offset);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry(",
          "args": [
            "ld,",
            "type->fs_supers,",
            "_instances)"
          ],
          "line": 450
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pin_lock(",
          "args": [
            "sb_lock)"
          ],
          "line": 448
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "include \"internal.h\"\ninclude <linux/lockdep.h>\n#\ninclude <linux/fsnotify.h>\n#\ninclude <linux/cleancache.h>\n#\ninclude <linux/rculist_bl.h>\n#\ninclude <linux/backing-dev.h>\n#\ninclude <linux/mutex.h>\n#\ninclude <linux/idr.h>\n#\ninclude <linux/writeback.h>\t\t/* for the emergency remount stuff */\n#\ninclude <linux/security.h>\n#\ninclude <linux/mount.h>\n#\ninclude <linux/blkdev.h>\n#\ninclude <linux/slab.h>\n#\ninclude <linux/export.h>\n#\n\ntatic LIST_HEAD(super_blocks);\ntatic DEFINE_SPINLOCK(sb_lock);\n\ntruct super_block *sget(struct file_system_type *type,\n\t\t\tint (*test)(struct super_block *,void *),\n\t\t\tint (*set)(struct super_block *,void *),\n\t\t\tint flags,\n\t\t\tvoid *data)\n{\n\tstruct super_block *s = NULL;\n\tstruct super_block *old;\n\tint err;\n\nretry:\n\tspin_lock(&sb_lock);\n\tif (test) {\n\t\thlist_for_each_entry(old, &type->fs_supers, s_instances) {\n\t\t\tif (!test(old, data))\n\t\t\t\tcontinue;\n\t\t\tif (!grab_super(old))\n\t\t\t\tgoto retry;\n\t\t\tif (s) {\n\t\t\t\tup_write(&s->s_umount);\n\t\t\t\tdestroy_super(s);\n\t\t\t\ts = NULL;\n\t\t\t}\n\t\t\treturn old;\n\t\t}\n\t}\n\tif (!s) {\n\t\tspin_unlock(&sb_lock);\n\t\ts = alloc_super(type, flags);\n\t\tif (!s)\n\t\t\treturn ERR_PTR(-ENOMEM);\n\t\tgoto retry;\n\t}\n\t\t\n\terr = set(s, data);\n\tif (err) {\n\t\tspin_unlock(&sb_lock);\n\t\tup_write(&s->s_umount);\n\t\tdestroy_super(s);\n\t\treturn ERR_PTR(err);\n\t}\n\ts->s_type = type;\n\tstrlcpy(s->s_id, type->name, sizeof(s->s_id));\n\tlist_add_tail(&s->s_list, &super_blocks);\n\thlist_add_head(&s->s_instances, &type->fs_supers);\n\tspin_unlock(&sb_lock);\n\tget_filesystem(type);\n\tregister_shrinker(&s->s_shrink);\n\treturn s;\n}"
  },
  {
    "function_name": "eneric_shutdown_super(",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/super.c",
    "lines": "393-425",
    "snippet": "oid generic_shutdown_super(struct super_block *sb)\n{\n\tconst struct super_operations *sop = sb->s_op;\n\n\tif (sb->s_root) {\n\t\tshrink_dcache_for_umount(sb);\n\t\tsync_filesystem(sb);\n\t\tsb->s_flags &= ~MS_ACTIVE;\n\n\t\tfsnotify_unmount_inodes(&sb->s_inodes);\n\n\t\tevict_inodes(sb);\n\n\t\tif (sb->s_dio_done_wq) {\n\t\t\tdestroy_workqueue(sb->s_dio_done_wq);\n\t\t\tsb->s_dio_done_wq = NULL;\n\t\t}\n\n\t\tif (sop->put_super)\n\t\t\tsop->put_super(sb);\n\n\t\tif (!list_empty(&sb->s_inodes)) {\n\t\t\tprintk(\"VFS: Busy inodes after unmount of %s. \"\n\t\t\t   \"Self-destruct in 5 seconds.  Have a nice day...\\n\",\n\t\t\t   sb->s_id);\n\t\t}\n\t}\n\tspin_lock(&sb_lock);\n\t/* should be initialized for __put_super_and_need_restart() */\n\thlist_del_init(&sb->s_instances);\n\tspin_unlock(&sb_lock);\n\tup_write(&sb->s_umount);\n}",
    "includes": [
      "include \"internal.h\"",
      "include <linux/lockdep.h>\n#",
      "include <linux/fsnotify.h>\n#",
      "include <linux/cleancache.h>\n#",
      "include <linux/rculist_bl.h>\n#",
      "include <linux/backing-dev.h>\n#",
      "include <linux/mutex.h>\n#",
      "include <linux/idr.h>\n#",
      "include <linux/writeback.h>\t\t/* for the emergency remount stuff */\n#",
      "include <linux/security.h>\n#",
      "include <linux/mount.h>\n#",
      "include <linux/blkdev.h>\n#",
      "include <linux/slab.h>\n#",
      "include <linux/export.h>\n#"
    ],
    "macros_used": [],
    "globals_used": [
      "tatic DEFINE_SPINLOCK(sb_lock);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "p_write(",
          "args": [
            "sb->s_umount)"
          ],
          "line": 424
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pin_unlock(",
          "args": [
            "sb_lock)"
          ],
          "line": 423
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_del_init(",
          "args": [
            "sb->s_instances)"
          ],
          "line": 422
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pin_lock(",
          "args": [
            "sb_lock)"
          ],
          "line": 420
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rintk(",
          "args": [
            "VFS: Busy inodes after unmount of %s. \"\n\t\t\t   \"Self-destruct in 5 seconds.  Have a nice day...\\n\",",
            "b->s_id)"
          ],
          "line": 415
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ist_empty(",
          "args": [
            "sb->s_inodes)"
          ],
          "line": 414
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "op->put_super",
          "args": [
            "b)"
          ],
          "line": 412
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "estroy_workqueue(",
          "args": [
            "b->s_dio_done_wq)"
          ],
          "line": 407
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vict_inodes(",
          "args": [
            "b)"
          ],
          "line": 404
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snotify_unmount_inodes(",
          "args": [
            "sb->s_inodes)"
          ],
          "line": 402
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ync_filesystem(",
          "args": [
            "b)"
          ],
          "line": 399
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hrink_dcache_for_umount(",
          "args": [
            "b)"
          ],
          "line": 398
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "include \"internal.h\"\ninclude <linux/lockdep.h>\n#\ninclude <linux/fsnotify.h>\n#\ninclude <linux/cleancache.h>\n#\ninclude <linux/rculist_bl.h>\n#\ninclude <linux/backing-dev.h>\n#\ninclude <linux/mutex.h>\n#\ninclude <linux/idr.h>\n#\ninclude <linux/writeback.h>\t\t/* for the emergency remount stuff */\n#\ninclude <linux/security.h>\n#\ninclude <linux/mount.h>\n#\ninclude <linux/blkdev.h>\n#\ninclude <linux/slab.h>\n#\ninclude <linux/export.h>\n#\n\ntatic DEFINE_SPINLOCK(sb_lock);\n\noid generic_shutdown_super(struct super_block *sb)\n{\n\tconst struct super_operations *sop = sb->s_op;\n\n\tif (sb->s_root) {\n\t\tshrink_dcache_for_umount(sb);\n\t\tsync_filesystem(sb);\n\t\tsb->s_flags &= ~MS_ACTIVE;\n\n\t\tfsnotify_unmount_inodes(&sb->s_inodes);\n\n\t\tevict_inodes(sb);\n\n\t\tif (sb->s_dio_done_wq) {\n\t\t\tdestroy_workqueue(sb->s_dio_done_wq);\n\t\t\tsb->s_dio_done_wq = NULL;\n\t\t}\n\n\t\tif (sop->put_super)\n\t\t\tsop->put_super(sb);\n\n\t\tif (!list_empty(&sb->s_inodes)) {\n\t\t\tprintk(\"VFS: Busy inodes after unmount of %s. \"\n\t\t\t   \"Self-destruct in 5 seconds.  Have a nice day...\\n\",\n\t\t\t   sb->s_id);\n\t\t}\n\t}\n\tspin_lock(&sb_lock);\n\t/* should be initialized for __put_super_and_need_restart() */\n\thlist_del_init(&sb->s_instances);\n\tspin_unlock(&sb_lock);\n\tup_write(&sb->s_umount);\n}"
  },
  {
    "function_name": "rylock_super(",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/super.c",
    "lines": "367-377",
    "snippet": "ool trylock_super(struct super_block *sb)\n{\n\tif (down_read_trylock(&sb->s_umount)) {\n\t\tif (!hlist_unhashed(&sb->s_instances) &&\n\t\t    sb->s_root && (sb->s_flags & MS_BORN))\n\t\t\treturn true;\n\t\tup_read(&sb->s_umount);\n\t}\n\n\treturn false;\n}",
    "includes": [
      "include \"internal.h\"",
      "include <linux/lockdep.h>\n#",
      "include <linux/fsnotify.h>\n#",
      "include <linux/cleancache.h>\n#",
      "include <linux/rculist_bl.h>\n#",
      "include <linux/backing-dev.h>\n#",
      "include <linux/mutex.h>\n#",
      "include <linux/idr.h>\n#",
      "include <linux/writeback.h>\t\t/* for the emergency remount stuff */\n#",
      "include <linux/security.h>\n#",
      "include <linux/mount.h>\n#",
      "include <linux/blkdev.h>\n#",
      "include <linux/slab.h>\n#",
      "include <linux/export.h>\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "p_read(",
          "args": [
            "sb->s_umount)"
          ],
          "line": 373
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_unhashed(",
          "args": [
            "sb->s_instances)"
          ],
          "line": 370
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "own_read_trylock(",
          "args": [
            "sb->s_umount)"
          ],
          "line": 369
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "include \"internal.h\"\ninclude <linux/lockdep.h>\n#\ninclude <linux/fsnotify.h>\n#\ninclude <linux/cleancache.h>\n#\ninclude <linux/rculist_bl.h>\n#\ninclude <linux/backing-dev.h>\n#\ninclude <linux/mutex.h>\n#\ninclude <linux/idr.h>\n#\ninclude <linux/writeback.h>\t\t/* for the emergency remount stuff */\n#\ninclude <linux/security.h>\n#\ninclude <linux/mount.h>\n#\ninclude <linux/blkdev.h>\n#\ninclude <linux/slab.h>\n#\ninclude <linux/export.h>\n#\n\nool trylock_super(struct super_block *sb)\n{\n\tif (down_read_trylock(&sb->s_umount)) {\n\t\tif (!hlist_unhashed(&sb->s_instances) &&\n\t\t    sb->s_root && (sb->s_flags & MS_BORN))\n\t\t\treturn true;\n\t\tup_read(&sb->s_umount);\n\t}\n\n\treturn false;\n}"
  },
  {
    "function_name": "rab_super(",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/super.c",
    "lines": "336-348",
    "snippet": "tatic int grab_super(struct super_block *s) __releases(sb_lock)\n{\n\ts->s_count++;\n\tspin_unlock(&sb_lock);\n\tdown_write(&s->s_umount);\n\tif ((s->s_flags & MS_BORN) && atomic_inc_not_zero(&s->s_active)) {\n\t\tput_super(s);\n\t\treturn 1;\n\t}\n\tup_write(&s->s_umount);\n\tput_super(s);\n\treturn 0;\n}",
    "includes": [
      "include \"internal.h\"",
      "include <linux/lockdep.h>\n#",
      "include <linux/fsnotify.h>\n#",
      "include <linux/cleancache.h>\n#",
      "include <linux/rculist_bl.h>\n#",
      "include <linux/backing-dev.h>\n#",
      "include <linux/mutex.h>\n#",
      "include <linux/idr.h>\n#",
      "include <linux/writeback.h>\t\t/* for the emergency remount stuff */\n#",
      "include <linux/security.h>\n#",
      "include <linux/mount.h>\n#",
      "include <linux/blkdev.h>\n#",
      "include <linux/slab.h>\n#",
      "include <linux/export.h>\n#"
    ],
    "macros_used": [],
    "globals_used": [
      "tatic DEFINE_SPINLOCK(sb_lock);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ut_super(",
          "args": [
            ")"
          ],
          "line": 346
        },
        "resolved": true,
        "details": {
          "function_name": "ut_super(",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/super.c",
          "lines": "261-266",
          "snippet": "tatic void put_super(struct super_block *sb)\n{\n\tspin_lock(&sb_lock);\n\t__put_super(sb);\n\tspin_unlock(&sb_lock);\n}",
          "includes": [
            "include \"internal.h\"",
            "include <linux/lockdep.h>\n#",
            "include <linux/fsnotify.h>\n#",
            "include <linux/cleancache.h>\n#",
            "include <linux/rculist_bl.h>\n#",
            "include <linux/backing-dev.h>\n#",
            "include <linux/mutex.h>\n#",
            "include <linux/idr.h>\n#",
            "include <linux/writeback.h>\t\t/* for the emergency remount stuff */\n#",
            "include <linux/security.h>\n#",
            "include <linux/mount.h>\n#",
            "include <linux/blkdev.h>\n#",
            "include <linux/slab.h>\n#",
            "include <linux/export.h>\n#"
          ],
          "macros_used": [],
          "globals_used": [
            "tatic DEFINE_SPINLOCK(sb_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "include \"internal.h\"\ninclude <linux/lockdep.h>\n#\ninclude <linux/fsnotify.h>\n#\ninclude <linux/cleancache.h>\n#\ninclude <linux/rculist_bl.h>\n#\ninclude <linux/backing-dev.h>\n#\ninclude <linux/mutex.h>\n#\ninclude <linux/idr.h>\n#\ninclude <linux/writeback.h>\t\t/* for the emergency remount stuff */\n#\ninclude <linux/security.h>\n#\ninclude <linux/mount.h>\n#\ninclude <linux/blkdev.h>\n#\ninclude <linux/slab.h>\n#\ninclude <linux/export.h>\n#\n\ntatic DEFINE_SPINLOCK(sb_lock);\n\ntatic void put_super(struct super_block *sb)\n{\n\tspin_lock(&sb_lock);\n\t__put_super(sb);\n\tspin_unlock(&sb_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "p_write(",
          "args": [
            "s->s_umount)"
          ],
          "line": 345
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tomic_inc_not_zero(",
          "args": [
            "s->s_active)"
          ],
          "line": 341
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "own_write(",
          "args": [
            "s->s_umount)"
          ],
          "line": 340
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pin_unlock(",
          "args": [
            "sb_lock)"
          ],
          "line": 339
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_releases(",
          "args": [
            "b_lock)"
          ],
          "line": 336
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "include \"internal.h\"\ninclude <linux/lockdep.h>\n#\ninclude <linux/fsnotify.h>\n#\ninclude <linux/cleancache.h>\n#\ninclude <linux/rculist_bl.h>\n#\ninclude <linux/backing-dev.h>\n#\ninclude <linux/mutex.h>\n#\ninclude <linux/idr.h>\n#\ninclude <linux/writeback.h>\t\t/* for the emergency remount stuff */\n#\ninclude <linux/security.h>\n#\ninclude <linux/mount.h>\n#\ninclude <linux/blkdev.h>\n#\ninclude <linux/slab.h>\n#\ninclude <linux/export.h>\n#\n\ntatic DEFINE_SPINLOCK(sb_lock);\n\ntatic int grab_super(struct super_block *s) __releases(sb_lock)\n{\n\ts->s_count++;\n\tspin_unlock(&sb_lock);\n\tdown_write(&s->s_umount);\n\tif ((s->s_flags & MS_BORN) && atomic_inc_not_zero(&s->s_active)) {\n\t\tput_super(s);\n\t\treturn 1;\n\t}\n\tup_write(&s->s_umount);\n\tput_super(s);\n\treturn 0;\n}"
  },
  {
    "function_name": "eactivate_super(",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/super.c",
    "lines": "313-319",
    "snippet": "oid deactivate_super(struct super_block *s)\n{\n        if (!atomic_add_unless(&s->s_active, -1, 1)) {\n\t\tdown_write(&s->s_umount);\n\t\tdeactivate_locked_super(s);\n\t}\n}",
    "includes": [
      "include \"internal.h\"",
      "include <linux/lockdep.h>\n#",
      "include <linux/fsnotify.h>\n#",
      "include <linux/cleancache.h>\n#",
      "include <linux/rculist_bl.h>\n#",
      "include <linux/backing-dev.h>\n#",
      "include <linux/mutex.h>\n#",
      "include <linux/idr.h>\n#",
      "include <linux/writeback.h>\t\t/* for the emergency remount stuff */\n#",
      "include <linux/security.h>\n#",
      "include <linux/mount.h>\n#",
      "include <linux/blkdev.h>\n#",
      "include <linux/slab.h>\n#",
      "include <linux/export.h>\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "eactivate_locked_super(",
          "args": [
            ")"
          ],
          "line": 317
        },
        "resolved": true,
        "details": {
          "function_name": "eactivate_locked_super(",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/super.c",
          "lines": "280-301",
          "snippet": "oid deactivate_locked_super(struct super_block *s)\n{\n\tstruct file_system_type *fs = s->s_type;\n\tif (atomic_dec_and_test(&s->s_active)) {\n\t\tcleancache_invalidate_fs(s);\n\t\tunregister_shrinker(&s->s_shrink);\n\t\tfs->kill_sb(s);\n\n\t\t/*\n\t\t * Since list_lru_destroy() may sleep, we cannot call it from\n\t\t * put_super(), where we hold the sb_lock. Therefore we destroy\n\t\t * the lru lists right now.\n\t\t */\n\t\tlist_lru_destroy(&s->s_dentry_lru);\n\t\tlist_lru_destroy(&s->s_inode_lru);\n\n\t\tput_filesystem(fs);\n\t\tput_super(s);\n\t} else {\n\t\tup_write(&s->s_umount);\n\t}\n}",
          "includes": [
            "include \"internal.h\"",
            "include <linux/lockdep.h>\n#",
            "include <linux/fsnotify.h>\n#",
            "include <linux/cleancache.h>\n#",
            "include <linux/rculist_bl.h>\n#",
            "include <linux/backing-dev.h>\n#",
            "include <linux/mutex.h>\n#",
            "include <linux/idr.h>\n#",
            "include <linux/writeback.h>\t\t/* for the emergency remount stuff */\n#",
            "include <linux/security.h>\n#",
            "include <linux/mount.h>\n#",
            "include <linux/blkdev.h>\n#",
            "include <linux/slab.h>\n#",
            "include <linux/export.h>\n#"
          ],
          "macros_used": [],
          "globals_used": [
            "tatic DEFINE_SPINLOCK(sb_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "include \"internal.h\"\ninclude <linux/lockdep.h>\n#\ninclude <linux/fsnotify.h>\n#\ninclude <linux/cleancache.h>\n#\ninclude <linux/rculist_bl.h>\n#\ninclude <linux/backing-dev.h>\n#\ninclude <linux/mutex.h>\n#\ninclude <linux/idr.h>\n#\ninclude <linux/writeback.h>\t\t/* for the emergency remount stuff */\n#\ninclude <linux/security.h>\n#\ninclude <linux/mount.h>\n#\ninclude <linux/blkdev.h>\n#\ninclude <linux/slab.h>\n#\ninclude <linux/export.h>\n#\n\ntatic DEFINE_SPINLOCK(sb_lock);\n\noid deactivate_locked_super(struct super_block *s)\n{\n\tstruct file_system_type *fs = s->s_type;\n\tif (atomic_dec_and_test(&s->s_active)) {\n\t\tcleancache_invalidate_fs(s);\n\t\tunregister_shrinker(&s->s_shrink);\n\t\tfs->kill_sb(s);\n\n\t\t/*\n\t\t * Since list_lru_destroy() may sleep, we cannot call it from\n\t\t * put_super(), where we hold the sb_lock. Therefore we destroy\n\t\t * the lru lists right now.\n\t\t */\n\t\tlist_lru_destroy(&s->s_dentry_lru);\n\t\tlist_lru_destroy(&s->s_inode_lru);\n\n\t\tput_filesystem(fs);\n\t\tput_super(s);\n\t} else {\n\t\tup_write(&s->s_umount);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "own_write(",
          "args": [
            "s->s_umount)"
          ],
          "line": 316
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tomic_add_unless(",
          "args": [
            "s->s_active,",
            "1,",
            ")"
          ],
          "line": 315
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "include \"internal.h\"\ninclude <linux/lockdep.h>\n#\ninclude <linux/fsnotify.h>\n#\ninclude <linux/cleancache.h>\n#\ninclude <linux/rculist_bl.h>\n#\ninclude <linux/backing-dev.h>\n#\ninclude <linux/mutex.h>\n#\ninclude <linux/idr.h>\n#\ninclude <linux/writeback.h>\t\t/* for the emergency remount stuff */\n#\ninclude <linux/security.h>\n#\ninclude <linux/mount.h>\n#\ninclude <linux/blkdev.h>\n#\ninclude <linux/slab.h>\n#\ninclude <linux/export.h>\n#\n\noid deactivate_super(struct super_block *s)\n{\n        if (!atomic_add_unless(&s->s_active, -1, 1)) {\n\t\tdown_write(&s->s_umount);\n\t\tdeactivate_locked_super(s);\n\t}\n}"
  },
  {
    "function_name": "eactivate_locked_super(",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/super.c",
    "lines": "280-301",
    "snippet": "oid deactivate_locked_super(struct super_block *s)\n{\n\tstruct file_system_type *fs = s->s_type;\n\tif (atomic_dec_and_test(&s->s_active)) {\n\t\tcleancache_invalidate_fs(s);\n\t\tunregister_shrinker(&s->s_shrink);\n\t\tfs->kill_sb(s);\n\n\t\t/*\n\t\t * Since list_lru_destroy() may sleep, we cannot call it from\n\t\t * put_super(), where we hold the sb_lock. Therefore we destroy\n\t\t * the lru lists right now.\n\t\t */\n\t\tlist_lru_destroy(&s->s_dentry_lru);\n\t\tlist_lru_destroy(&s->s_inode_lru);\n\n\t\tput_filesystem(fs);\n\t\tput_super(s);\n\t} else {\n\t\tup_write(&s->s_umount);\n\t}\n}",
    "includes": [
      "include \"internal.h\"",
      "include <linux/lockdep.h>\n#",
      "include <linux/fsnotify.h>\n#",
      "include <linux/cleancache.h>\n#",
      "include <linux/rculist_bl.h>\n#",
      "include <linux/backing-dev.h>\n#",
      "include <linux/mutex.h>\n#",
      "include <linux/idr.h>\n#",
      "include <linux/writeback.h>\t\t/* for the emergency remount stuff */\n#",
      "include <linux/security.h>\n#",
      "include <linux/mount.h>\n#",
      "include <linux/blkdev.h>\n#",
      "include <linux/slab.h>\n#",
      "include <linux/export.h>\n#"
    ],
    "macros_used": [],
    "globals_used": [
      "tatic DEFINE_SPINLOCK(sb_lock);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "p_write(",
          "args": [
            "s->s_umount)"
          ],
          "line": 299
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ut_super(",
          "args": [
            ")"
          ],
          "line": 297
        },
        "resolved": true,
        "details": {
          "function_name": "ut_super(",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/super.c",
          "lines": "261-266",
          "snippet": "tatic void put_super(struct super_block *sb)\n{\n\tspin_lock(&sb_lock);\n\t__put_super(sb);\n\tspin_unlock(&sb_lock);\n}",
          "includes": [
            "include \"internal.h\"",
            "include <linux/lockdep.h>\n#",
            "include <linux/fsnotify.h>\n#",
            "include <linux/cleancache.h>\n#",
            "include <linux/rculist_bl.h>\n#",
            "include <linux/backing-dev.h>\n#",
            "include <linux/mutex.h>\n#",
            "include <linux/idr.h>\n#",
            "include <linux/writeback.h>\t\t/* for the emergency remount stuff */\n#",
            "include <linux/security.h>\n#",
            "include <linux/mount.h>\n#",
            "include <linux/blkdev.h>\n#",
            "include <linux/slab.h>\n#",
            "include <linux/export.h>\n#"
          ],
          "macros_used": [],
          "globals_used": [
            "tatic DEFINE_SPINLOCK(sb_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "include \"internal.h\"\ninclude <linux/lockdep.h>\n#\ninclude <linux/fsnotify.h>\n#\ninclude <linux/cleancache.h>\n#\ninclude <linux/rculist_bl.h>\n#\ninclude <linux/backing-dev.h>\n#\ninclude <linux/mutex.h>\n#\ninclude <linux/idr.h>\n#\ninclude <linux/writeback.h>\t\t/* for the emergency remount stuff */\n#\ninclude <linux/security.h>\n#\ninclude <linux/mount.h>\n#\ninclude <linux/blkdev.h>\n#\ninclude <linux/slab.h>\n#\ninclude <linux/export.h>\n#\n\ntatic DEFINE_SPINLOCK(sb_lock);\n\ntatic void put_super(struct super_block *sb)\n{\n\tspin_lock(&sb_lock);\n\t__put_super(sb);\n\tspin_unlock(&sb_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ut_filesystem(",
          "args": [
            "s)"
          ],
          "line": 296
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ist_lru_destroy(",
          "args": [
            "s->s_inode_lru)"
          ],
          "line": 294
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ist_lru_destroy(",
          "args": [
            "s->s_dentry_lru)"
          ],
          "line": 293
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "s->kill_sb",
          "args": [
            ")"
          ],
          "line": 286
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nregister_shrinker(",
          "args": [
            "s->s_shrink)"
          ],
          "line": 285
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "leancache_invalidate_fs(",
          "args": [
            ")"
          ],
          "line": 284
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tomic_dec_and_test(",
          "args": [
            "s->s_active)"
          ],
          "line": 283
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "include \"internal.h\"\ninclude <linux/lockdep.h>\n#\ninclude <linux/fsnotify.h>\n#\ninclude <linux/cleancache.h>\n#\ninclude <linux/rculist_bl.h>\n#\ninclude <linux/backing-dev.h>\n#\ninclude <linux/mutex.h>\n#\ninclude <linux/idr.h>\n#\ninclude <linux/writeback.h>\t\t/* for the emergency remount stuff */\n#\ninclude <linux/security.h>\n#\ninclude <linux/mount.h>\n#\ninclude <linux/blkdev.h>\n#\ninclude <linux/slab.h>\n#\ninclude <linux/export.h>\n#\n\ntatic DEFINE_SPINLOCK(sb_lock);\n\noid deactivate_locked_super(struct super_block *s)\n{\n\tstruct file_system_type *fs = s->s_type;\n\tif (atomic_dec_and_test(&s->s_active)) {\n\t\tcleancache_invalidate_fs(s);\n\t\tunregister_shrinker(&s->s_shrink);\n\t\tfs->kill_sb(s);\n\n\t\t/*\n\t\t * Since list_lru_destroy() may sleep, we cannot call it from\n\t\t * put_super(), where we hold the sb_lock. Therefore we destroy\n\t\t * the lru lists right now.\n\t\t */\n\t\tlist_lru_destroy(&s->s_dentry_lru);\n\t\tlist_lru_destroy(&s->s_inode_lru);\n\n\t\tput_filesystem(fs);\n\t\tput_super(s);\n\t} else {\n\t\tup_write(&s->s_umount);\n\t}\n}"
  },
  {
    "function_name": "ut_super(",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/super.c",
    "lines": "261-266",
    "snippet": "tatic void put_super(struct super_block *sb)\n{\n\tspin_lock(&sb_lock);\n\t__put_super(sb);\n\tspin_unlock(&sb_lock);\n}",
    "includes": [
      "include \"internal.h\"",
      "include <linux/lockdep.h>\n#",
      "include <linux/fsnotify.h>\n#",
      "include <linux/cleancache.h>\n#",
      "include <linux/rculist_bl.h>\n#",
      "include <linux/backing-dev.h>\n#",
      "include <linux/mutex.h>\n#",
      "include <linux/idr.h>\n#",
      "include <linux/writeback.h>\t\t/* for the emergency remount stuff */\n#",
      "include <linux/security.h>\n#",
      "include <linux/mount.h>\n#",
      "include <linux/blkdev.h>\n#",
      "include <linux/slab.h>\n#",
      "include <linux/export.h>\n#"
    ],
    "macros_used": [],
    "globals_used": [
      "tatic DEFINE_SPINLOCK(sb_lock);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "pin_unlock(",
          "args": [
            "sb_lock)"
          ],
          "line": 265
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_put_super(",
          "args": [
            "b)"
          ],
          "line": 264
        },
        "resolved": true,
        "details": {
          "function_name": "_put_super(",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/super.c",
          "lines": "246-252",
          "snippet": "tatic void __put_super(struct super_block *sb)\n{\n\tif (!--sb->s_count) {\n\t\tlist_del_init(&sb->s_list);\n\t\tdestroy_super(sb);\n\t}\n}",
          "includes": [
            "include \"internal.h\"",
            "include <linux/lockdep.h>\n#",
            "include <linux/fsnotify.h>\n#",
            "include <linux/cleancache.h>\n#",
            "include <linux/rculist_bl.h>\n#",
            "include <linux/backing-dev.h>\n#",
            "include <linux/mutex.h>\n#",
            "include <linux/idr.h>\n#",
            "include <linux/writeback.h>\t\t/* for the emergency remount stuff */\n#",
            "include <linux/security.h>\n#",
            "include <linux/mount.h>\n#",
            "include <linux/blkdev.h>\n#",
            "include <linux/slab.h>\n#",
            "include <linux/export.h>\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"internal.h\"\ninclude <linux/lockdep.h>\n#\ninclude <linux/fsnotify.h>\n#\ninclude <linux/cleancache.h>\n#\ninclude <linux/rculist_bl.h>\n#\ninclude <linux/backing-dev.h>\n#\ninclude <linux/mutex.h>\n#\ninclude <linux/idr.h>\n#\ninclude <linux/writeback.h>\t\t/* for the emergency remount stuff */\n#\ninclude <linux/security.h>\n#\ninclude <linux/mount.h>\n#\ninclude <linux/blkdev.h>\n#\ninclude <linux/slab.h>\n#\ninclude <linux/export.h>\n#\n\ntatic void __put_super(struct super_block *sb)\n{\n\tif (!--sb->s_count) {\n\t\tlist_del_init(&sb->s_list);\n\t\tdestroy_super(sb);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "pin_lock(",
          "args": [
            "sb_lock)"
          ],
          "line": 263
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "include \"internal.h\"\ninclude <linux/lockdep.h>\n#\ninclude <linux/fsnotify.h>\n#\ninclude <linux/cleancache.h>\n#\ninclude <linux/rculist_bl.h>\n#\ninclude <linux/backing-dev.h>\n#\ninclude <linux/mutex.h>\n#\ninclude <linux/idr.h>\n#\ninclude <linux/writeback.h>\t\t/* for the emergency remount stuff */\n#\ninclude <linux/security.h>\n#\ninclude <linux/mount.h>\n#\ninclude <linux/blkdev.h>\n#\ninclude <linux/slab.h>\n#\ninclude <linux/export.h>\n#\n\ntatic DEFINE_SPINLOCK(sb_lock);\n\ntatic void put_super(struct super_block *sb)\n{\n\tspin_lock(&sb_lock);\n\t__put_super(sb);\n\tspin_unlock(&sb_lock);\n}"
  },
  {
    "function_name": "_put_super(",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/super.c",
    "lines": "246-252",
    "snippet": "tatic void __put_super(struct super_block *sb)\n{\n\tif (!--sb->s_count) {\n\t\tlist_del_init(&sb->s_list);\n\t\tdestroy_super(sb);\n\t}\n}",
    "includes": [
      "include \"internal.h\"",
      "include <linux/lockdep.h>\n#",
      "include <linux/fsnotify.h>\n#",
      "include <linux/cleancache.h>\n#",
      "include <linux/rculist_bl.h>\n#",
      "include <linux/backing-dev.h>\n#",
      "include <linux/mutex.h>\n#",
      "include <linux/idr.h>\n#",
      "include <linux/writeback.h>\t\t/* for the emergency remount stuff */\n#",
      "include <linux/security.h>\n#",
      "include <linux/mount.h>\n#",
      "include <linux/blkdev.h>\n#",
      "include <linux/slab.h>\n#",
      "include <linux/export.h>\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "estroy_super(",
          "args": [
            "b)"
          ],
          "line": 250
        },
        "resolved": true,
        "details": {
          "function_name": "estroy_super(",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/super.c",
          "lines": "144-156",
          "snippet": "tatic void destroy_super(struct super_block *s)\n{\n\tint i;\n\tlist_lru_destroy(&s->s_dentry_lru);\n\tlist_lru_destroy(&s->s_inode_lru);\n\tfor (i = 0; i < SB_FREEZE_LEVELS; i++)\n\t\tpercpu_counter_destroy(&s->s_writers.counter[i]);\n\tsecurity_sb_free(s);\n\tWARN_ON(!list_empty(&s->s_mounts));\n\tkfree(s->s_subtype);\n\tkfree(s->s_options);\n\tkfree_rcu(s, rcu);\n}",
          "includes": [
            "include \"internal.h\"",
            "include <linux/lockdep.h>\n#",
            "include <linux/fsnotify.h>\n#",
            "include <linux/cleancache.h>\n#",
            "include <linux/rculist_bl.h>\n#",
            "include <linux/backing-dev.h>\n#",
            "include <linux/mutex.h>\n#",
            "include <linux/idr.h>\n#",
            "include <linux/writeback.h>\t\t/* for the emergency remount stuff */\n#",
            "include <linux/security.h>\n#",
            "include <linux/mount.h>\n#",
            "include <linux/blkdev.h>\n#",
            "include <linux/slab.h>\n#",
            "include <linux/export.h>\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"internal.h\"\ninclude <linux/lockdep.h>\n#\ninclude <linux/fsnotify.h>\n#\ninclude <linux/cleancache.h>\n#\ninclude <linux/rculist_bl.h>\n#\ninclude <linux/backing-dev.h>\n#\ninclude <linux/mutex.h>\n#\ninclude <linux/idr.h>\n#\ninclude <linux/writeback.h>\t\t/* for the emergency remount stuff */\n#\ninclude <linux/security.h>\n#\ninclude <linux/mount.h>\n#\ninclude <linux/blkdev.h>\n#\ninclude <linux/slab.h>\n#\ninclude <linux/export.h>\n#\n\ntatic void destroy_super(struct super_block *s)\n{\n\tint i;\n\tlist_lru_destroy(&s->s_dentry_lru);\n\tlist_lru_destroy(&s->s_inode_lru);\n\tfor (i = 0; i < SB_FREEZE_LEVELS; i++)\n\t\tpercpu_counter_destroy(&s->s_writers.counter[i]);\n\tsecurity_sb_free(s);\n\tWARN_ON(!list_empty(&s->s_mounts));\n\tkfree(s->s_subtype);\n\tkfree(s->s_options);\n\tkfree_rcu(s, rcu);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ist_del_init(",
          "args": [
            "sb->s_list)"
          ],
          "line": 249
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "include \"internal.h\"\ninclude <linux/lockdep.h>\n#\ninclude <linux/fsnotify.h>\n#\ninclude <linux/cleancache.h>\n#\ninclude <linux/rculist_bl.h>\n#\ninclude <linux/backing-dev.h>\n#\ninclude <linux/mutex.h>\n#\ninclude <linux/idr.h>\n#\ninclude <linux/writeback.h>\t\t/* for the emergency remount stuff */\n#\ninclude <linux/security.h>\n#\ninclude <linux/mount.h>\n#\ninclude <linux/blkdev.h>\n#\ninclude <linux/slab.h>\n#\ninclude <linux/export.h>\n#\n\ntatic void __put_super(struct super_block *sb)\n{\n\tif (!--sb->s_count) {\n\t\tlist_del_init(&sb->s_list);\n\t\tdestroy_super(sb);\n\t}\n}"
  },
  {
    "function_name": "lloc_super(",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/super.c",
    "lines": "166-239",
    "snippet": "tatic struct super_block *alloc_super(struct file_system_type *type, int flags)\n{\n\tstruct super_block *s = kzalloc(sizeof(struct super_block),  GFP_USER);\n\tstatic const struct super_operations default_op;\n\tint i;\n\n\tif (!s)\n\t\treturn NULL;\n\n\tINIT_LIST_HEAD(&s->s_mounts);\n\n\tif (security_sb_alloc(s))\n\t\tgoto fail;\n\n\tfor (i = 0; i < SB_FREEZE_LEVELS; i++) {\n\t\tif (percpu_counter_init(&s->s_writers.counter[i], 0,\n\t\t\t\t\tGFP_KERNEL) < 0)\n\t\t\tgoto fail;\n\t\tlockdep_init_map(&s->s_writers.lock_map[i], sb_writers_name[i],\n\t\t\t\t &type->s_writers_key[i], 0);\n\t}\n\tinit_waitqueue_head(&s->s_writers.wait);\n\tinit_waitqueue_head(&s->s_writers.wait_unfrozen);\n\ts->s_bdi = &noop_backing_dev_info;\n\ts->s_flags = flags;\n\tINIT_HLIST_NODE(&s->s_instances);\n\tINIT_HLIST_BL_HEAD(&s->s_anon);\n\tINIT_LIST_HEAD(&s->s_inodes);\n\n\tif (list_lru_init_memcg(&s->s_dentry_lru))\n\t\tgoto fail;\n\tif (list_lru_init_memcg(&s->s_inode_lru))\n\t\tgoto fail;\n\n\tinit_rwsem(&s->s_umount);\n\tlockdep_set_class(&s->s_umount, &type->s_umount_key);\n\t/*\n\t * sget() can have s_umount recursion.\n\t *\n\t * When it cannot find a suitable sb, it allocates a new\n\t * one (this one), and tries again to find a suitable old\n\t * one.\n\t *\n\t * In case that succeeds, it will acquire the s_umount\n\t * lock of the old one. Since these are clearly distrinct\n\t * locks, and this object isn't exposed yet, there's no\n\t * risk of deadlocks.\n\t *\n\t * Annotate this by putting this lock in a different\n\t * subclass.\n\t */\n\tdown_write_nested(&s->s_umount, SINGLE_DEPTH_NESTING);\n\ts->s_count = 1;\n\tatomic_set(&s->s_active, 1);\n\tmutex_init(&s->s_vfs_rename_mutex);\n\tlockdep_set_class(&s->s_vfs_rename_mutex, &type->s_vfs_rename_key);\n\tmutex_init(&s->s_dquot.dqio_mutex);\n\tmutex_init(&s->s_dquot.dqonoff_mutex);\n\ts->s_maxbytes = MAX_NON_LFS;\n\ts->s_op = &default_op;\n\ts->s_time_gran = 1000000000;\n\ts->cleancache_poolid = -1;\n\n\ts->s_shrink.seeks = DEFAULT_SEEKS;\n\ts->s_shrink.scan_objects = super_cache_scan;\n\ts->s_shrink.count_objects = super_cache_count;\n\ts->s_shrink.batch = 1024;\n\ts->s_shrink.flags = SHRINKER_NUMA_AWARE | SHRINKER_MEMCG_AWARE;\n\treturn s;\n\nfail:\n\tdestroy_super(s);\n\treturn NULL;\n}",
    "includes": [
      "include \"internal.h\"",
      "include <linux/lockdep.h>\n#",
      "include <linux/fsnotify.h>\n#",
      "include <linux/cleancache.h>\n#",
      "include <linux/rculist_bl.h>\n#",
      "include <linux/backing-dev.h>\n#",
      "include <linux/mutex.h>\n#",
      "include <linux/idr.h>\n#",
      "include <linux/writeback.h>\t\t/* for the emergency remount stuff */\n#",
      "include <linux/security.h>\n#",
      "include <linux/mount.h>\n#",
      "include <linux/blkdev.h>\n#",
      "include <linux/slab.h>\n#",
      "include <linux/export.h>\n#"
    ],
    "macros_used": [],
    "globals_used": [
      "tatic char *sb_writers_name[SB_FREEZE_LEVELS] = {\n\t\"sb_writers\",\n\t\"sb_pagefaults\",\n\t\"sb_internal\",\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "estroy_super(",
          "args": [
            ")"
          ],
          "line": 237
        },
        "resolved": true,
        "details": {
          "function_name": "estroy_super(",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/super.c",
          "lines": "144-156",
          "snippet": "tatic void destroy_super(struct super_block *s)\n{\n\tint i;\n\tlist_lru_destroy(&s->s_dentry_lru);\n\tlist_lru_destroy(&s->s_inode_lru);\n\tfor (i = 0; i < SB_FREEZE_LEVELS; i++)\n\t\tpercpu_counter_destroy(&s->s_writers.counter[i]);\n\tsecurity_sb_free(s);\n\tWARN_ON(!list_empty(&s->s_mounts));\n\tkfree(s->s_subtype);\n\tkfree(s->s_options);\n\tkfree_rcu(s, rcu);\n}",
          "includes": [
            "include \"internal.h\"",
            "include <linux/lockdep.h>\n#",
            "include <linux/fsnotify.h>\n#",
            "include <linux/cleancache.h>\n#",
            "include <linux/rculist_bl.h>\n#",
            "include <linux/backing-dev.h>\n#",
            "include <linux/mutex.h>\n#",
            "include <linux/idr.h>\n#",
            "include <linux/writeback.h>\t\t/* for the emergency remount stuff */\n#",
            "include <linux/security.h>\n#",
            "include <linux/mount.h>\n#",
            "include <linux/blkdev.h>\n#",
            "include <linux/slab.h>\n#",
            "include <linux/export.h>\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"internal.h\"\ninclude <linux/lockdep.h>\n#\ninclude <linux/fsnotify.h>\n#\ninclude <linux/cleancache.h>\n#\ninclude <linux/rculist_bl.h>\n#\ninclude <linux/backing-dev.h>\n#\ninclude <linux/mutex.h>\n#\ninclude <linux/idr.h>\n#\ninclude <linux/writeback.h>\t\t/* for the emergency remount stuff */\n#\ninclude <linux/security.h>\n#\ninclude <linux/mount.h>\n#\ninclude <linux/blkdev.h>\n#\ninclude <linux/slab.h>\n#\ninclude <linux/export.h>\n#\n\ntatic void destroy_super(struct super_block *s)\n{\n\tint i;\n\tlist_lru_destroy(&s->s_dentry_lru);\n\tlist_lru_destroy(&s->s_inode_lru);\n\tfor (i = 0; i < SB_FREEZE_LEVELS; i++)\n\t\tpercpu_counter_destroy(&s->s_writers.counter[i]);\n\tsecurity_sb_free(s);\n\tWARN_ON(!list_empty(&s->s_mounts));\n\tkfree(s->s_subtype);\n\tkfree(s->s_options);\n\tkfree_rcu(s, rcu);\n}"
        }
      },
      {
        "call_info": {
          "callee": "utex_init(",
          "args": [
            "s->s_dquot.dqonoff_mutex)"
          ],
          "line": 223
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "utex_init(",
          "args": [
            "s->s_dquot.dqio_mutex)"
          ],
          "line": 222
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ockdep_set_class(",
          "args": [
            "s->s_vfs_rename_mutex,",
            "type->s_vfs_rename_key)"
          ],
          "line": 221
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "utex_init(",
          "args": [
            "s->s_vfs_rename_mutex)"
          ],
          "line": 220
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tomic_set(",
          "args": [
            "s->s_active,",
            ")"
          ],
          "line": 219
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "own_write_nested(",
          "args": [
            "s->s_umount,",
            "INGLE_DEPTH_NESTING)"
          ],
          "line": 217
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ockdep_set_class(",
          "args": [
            "s->s_umount,",
            "type->s_umount_key)"
          ],
          "line": 201
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nit_rwsem(",
          "args": [
            "s->s_umount)"
          ],
          "line": 200
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ist_lru_init_memcg(",
          "args": [
            "s->s_inode_lru)"
          ],
          "line": 197
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ist_lru_init_memcg(",
          "args": [
            "s->s_dentry_lru)"
          ],
          "line": 195
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NIT_LIST_HEAD(",
          "args": [
            "s->s_inodes)"
          ],
          "line": 193
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NIT_HLIST_BL_HEAD(",
          "args": [
            "s->s_anon)"
          ],
          "line": 192
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NIT_HLIST_NODE(",
          "args": [
            "s->s_instances)"
          ],
          "line": 191
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nit_waitqueue_head(",
          "args": [
            "s->s_writers.wait_unfrozen)"
          ],
          "line": 188
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nit_waitqueue_head(",
          "args": [
            "s->s_writers.wait)"
          ],
          "line": 187
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ockdep_init_map(",
          "args": [
            "s->s_writers.lock_map[i],",
            "b_writers_name[i],",
            "type->s_writers_key[i],",
            ")"
          ],
          "line": 184
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ercpu_counter_init(",
          "args": [
            "s->s_writers.counter[i],",
            ",",
            "FP_KERNEL)"
          ],
          "line": 181
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ecurity_sb_alloc(",
          "args": [
            ")"
          ],
          "line": 177
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NIT_LIST_HEAD(",
          "args": [
            "s->s_mounts)"
          ],
          "line": 175
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "zalloc(",
          "args": [
            "izeof(struct super_block),",
            "FP_USER)"
          ],
          "line": 168
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "include \"internal.h\"\ninclude <linux/lockdep.h>\n#\ninclude <linux/fsnotify.h>\n#\ninclude <linux/cleancache.h>\n#\ninclude <linux/rculist_bl.h>\n#\ninclude <linux/backing-dev.h>\n#\ninclude <linux/mutex.h>\n#\ninclude <linux/idr.h>\n#\ninclude <linux/writeback.h>\t\t/* for the emergency remount stuff */\n#\ninclude <linux/security.h>\n#\ninclude <linux/mount.h>\n#\ninclude <linux/blkdev.h>\n#\ninclude <linux/slab.h>\n#\ninclude <linux/export.h>\n#\n\ntatic char *sb_writers_name[SB_FREEZE_LEVELS] = {\n\t\"sb_writers\",\n\t\"sb_pagefaults\",\n\t\"sb_internal\",\n};\n\ntatic struct super_block *alloc_super(struct file_system_type *type, int flags)\n{\n\tstruct super_block *s = kzalloc(sizeof(struct super_block),  GFP_USER);\n\tstatic const struct super_operations default_op;\n\tint i;\n\n\tif (!s)\n\t\treturn NULL;\n\n\tINIT_LIST_HEAD(&s->s_mounts);\n\n\tif (security_sb_alloc(s))\n\t\tgoto fail;\n\n\tfor (i = 0; i < SB_FREEZE_LEVELS; i++) {\n\t\tif (percpu_counter_init(&s->s_writers.counter[i], 0,\n\t\t\t\t\tGFP_KERNEL) < 0)\n\t\t\tgoto fail;\n\t\tlockdep_init_map(&s->s_writers.lock_map[i], sb_writers_name[i],\n\t\t\t\t &type->s_writers_key[i], 0);\n\t}\n\tinit_waitqueue_head(&s->s_writers.wait);\n\tinit_waitqueue_head(&s->s_writers.wait_unfrozen);\n\ts->s_bdi = &noop_backing_dev_info;\n\ts->s_flags = flags;\n\tINIT_HLIST_NODE(&s->s_instances);\n\tINIT_HLIST_BL_HEAD(&s->s_anon);\n\tINIT_LIST_HEAD(&s->s_inodes);\n\n\tif (list_lru_init_memcg(&s->s_dentry_lru))\n\t\tgoto fail;\n\tif (list_lru_init_memcg(&s->s_inode_lru))\n\t\tgoto fail;\n\n\tinit_rwsem(&s->s_umount);\n\tlockdep_set_class(&s->s_umount, &type->s_umount_key);\n\t/*\n\t * sget() can have s_umount recursion.\n\t *\n\t * When it cannot find a suitable sb, it allocates a new\n\t * one (this one), and tries again to find a suitable old\n\t * one.\n\t *\n\t * In case that succeeds, it will acquire the s_umount\n\t * lock of the old one. Since these are clearly distrinct\n\t * locks, and this object isn't exposed yet, there's no\n\t * risk of deadlocks.\n\t *\n\t * Annotate this by putting this lock in a different\n\t * subclass.\n\t */\n\tdown_write_nested(&s->s_umount, SINGLE_DEPTH_NESTING);\n\ts->s_count = 1;\n\tatomic_set(&s->s_active, 1);\n\tmutex_init(&s->s_vfs_rename_mutex);\n\tlockdep_set_class(&s->s_vfs_rename_mutex, &type->s_vfs_rename_key);\n\tmutex_init(&s->s_dquot.dqio_mutex);\n\tmutex_init(&s->s_dquot.dqonoff_mutex);\n\ts->s_maxbytes = MAX_NON_LFS;\n\ts->s_op = &default_op;\n\ts->s_time_gran = 1000000000;\n\ts->cleancache_poolid = -1;\n\n\ts->s_shrink.seeks = DEFAULT_SEEKS;\n\ts->s_shrink.scan_objects = super_cache_scan;\n\ts->s_shrink.count_objects = super_cache_count;\n\ts->s_shrink.batch = 1024;\n\ts->s_shrink.flags = SHRINKER_NUMA_AWARE | SHRINKER_MEMCG_AWARE;\n\treturn s;\n\nfail:\n\tdestroy_super(s);\n\treturn NULL;\n}"
  },
  {
    "function_name": "estroy_super(",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/super.c",
    "lines": "144-156",
    "snippet": "tatic void destroy_super(struct super_block *s)\n{\n\tint i;\n\tlist_lru_destroy(&s->s_dentry_lru);\n\tlist_lru_destroy(&s->s_inode_lru);\n\tfor (i = 0; i < SB_FREEZE_LEVELS; i++)\n\t\tpercpu_counter_destroy(&s->s_writers.counter[i]);\n\tsecurity_sb_free(s);\n\tWARN_ON(!list_empty(&s->s_mounts));\n\tkfree(s->s_subtype);\n\tkfree(s->s_options);\n\tkfree_rcu(s, rcu);\n}",
    "includes": [
      "include \"internal.h\"",
      "include <linux/lockdep.h>\n#",
      "include <linux/fsnotify.h>\n#",
      "include <linux/cleancache.h>\n#",
      "include <linux/rculist_bl.h>\n#",
      "include <linux/backing-dev.h>\n#",
      "include <linux/mutex.h>\n#",
      "include <linux/idr.h>\n#",
      "include <linux/writeback.h>\t\t/* for the emergency remount stuff */\n#",
      "include <linux/security.h>\n#",
      "include <linux/mount.h>\n#",
      "include <linux/blkdev.h>\n#",
      "include <linux/slab.h>\n#",
      "include <linux/export.h>\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "free_rcu(",
          "args": [
            ",",
            "cu)"
          ],
          "line": 155
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free(",
          "args": [
            "->s_options)"
          ],
          "line": 154
        },
        "resolved": true,
        "details": {
          "function_name": "in_free(",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jffs2/scan.c",
          "lines": "51-60",
          "snippet": "tatic inline int min_free(struct jffs2_sb_info *c)\n{\n\tuint32_t min = 2 * sizeof(struct jffs2_raw_inode);\n#ifdef CONFIG_JFFS2_FS_WRITEBUFFER\n\tif (!jffs2_can_mark_obsolete(c) && min < c->wbuf_pagesize)\n\t\treturn c->wbuf_pagesize;\n#endif\n\treturn min;\n\n}",
          "includes": [
            "include \"debug.h\"",
            "include \"summary.h\"\n#",
            "include \"nodelist.h\"\n#",
            "include <linux/compiler.h>\n#",
            "include <linux/crc32.h>\n#",
            "include <linux/pagemap.h>\n#",
            "include <linux/mtd/mtd.h>\n#",
            "include <linux/slab.h>\n#",
            "include <linux/sched.h>\n#",
            "include <linux/kernel.h>\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"debug.h\"\ninclude \"summary.h\"\n#\ninclude \"nodelist.h\"\n#\ninclude <linux/compiler.h>\n#\ninclude <linux/crc32.h>\n#\ninclude <linux/pagemap.h>\n#\ninclude <linux/mtd/mtd.h>\n#\ninclude <linux/slab.h>\n#\ninclude <linux/sched.h>\n#\ninclude <linux/kernel.h>\n#\n\ntatic inline int min_free(struct jffs2_sb_info *c)\n{\n\tuint32_t min = 2 * sizeof(struct jffs2_raw_inode);\n#ifdef CONFIG_JFFS2_FS_WRITEBUFFER\n\tif (!jffs2_can_mark_obsolete(c) && min < c->wbuf_pagesize)\n\t\treturn c->wbuf_pagesize;\n#endif\n\treturn min;\n\n}"
        }
      },
      {
        "call_info": {
          "callee": "ARN_ON(",
          "args": [
            "list_empty(&s->s_mounts))"
          ],
          "line": 152
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ist_empty(",
          "args": [
            "s->s_mounts)"
          ],
          "line": 152
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ecurity_sb_free(",
          "args": [
            ")"
          ],
          "line": 151
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ercpu_counter_destroy(",
          "args": [
            "s->s_writers.counter[i])"
          ],
          "line": 150
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ist_lru_destroy(",
          "args": [
            "s->s_inode_lru)"
          ],
          "line": 148
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ist_lru_destroy(",
          "args": [
            "s->s_dentry_lru)"
          ],
          "line": 147
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "include \"internal.h\"\ninclude <linux/lockdep.h>\n#\ninclude <linux/fsnotify.h>\n#\ninclude <linux/cleancache.h>\n#\ninclude <linux/rculist_bl.h>\n#\ninclude <linux/backing-dev.h>\n#\ninclude <linux/mutex.h>\n#\ninclude <linux/idr.h>\n#\ninclude <linux/writeback.h>\t\t/* for the emergency remount stuff */\n#\ninclude <linux/security.h>\n#\ninclude <linux/mount.h>\n#\ninclude <linux/blkdev.h>\n#\ninclude <linux/slab.h>\n#\ninclude <linux/export.h>\n#\n\ntatic void destroy_super(struct super_block *s)\n{\n\tint i;\n\tlist_lru_destroy(&s->s_dentry_lru);\n\tlist_lru_destroy(&s->s_inode_lru);\n\tfor (i = 0; i < SB_FREEZE_LEVELS; i++)\n\t\tpercpu_counter_destroy(&s->s_writers.counter[i]);\n\tsecurity_sb_free(s);\n\tWARN_ON(!list_empty(&s->s_mounts));\n\tkfree(s->s_subtype);\n\tkfree(s->s_options);\n\tkfree_rcu(s, rcu);\n}"
  },
  {
    "function_name": "uper_cache_count(",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/super.c",
    "lines": "112-136",
    "snippet": "tatic unsigned long super_cache_count(struct shrinker *shrink,\n\t\t\t\t       struct shrink_control *sc)\n{\n\tstruct super_block *sb;\n\tlong\ttotal_objects = 0;\n\n\tsb = container_of(shrink, struct super_block, s_shrink);\n\n\t/*\n\t * Don't call trylock_super as it is a potential\n\t * scalability bottleneck. The counts could get updated\n\t * between super_cache_count and super_cache_scan anyway.\n\t * Call to super_cache_count with shrinker_rwsem held\n\t * ensures the safety of call to list_lru_shrink_count() and\n\t * s_op->nr_cached_objects().\n\t */\n\tif (sb->s_op && sb->s_op->nr_cached_objects)\n\t\ttotal_objects = sb->s_op->nr_cached_objects(sb, sc);\n\n\ttotal_objects += list_lru_shrink_count(&sb->s_dentry_lru, sc);\n\ttotal_objects += list_lru_shrink_count(&sb->s_inode_lru, sc);\n\n\ttotal_objects = vfs_pressure_ratio(total_objects);\n\treturn total_objects;\n}",
    "includes": [
      "include \"internal.h\"",
      "include <linux/lockdep.h>\n#",
      "include <linux/fsnotify.h>\n#",
      "include <linux/cleancache.h>\n#",
      "include <linux/rculist_bl.h>\n#",
      "include <linux/backing-dev.h>\n#",
      "include <linux/mutex.h>\n#",
      "include <linux/idr.h>\n#",
      "include <linux/writeback.h>\t\t/* for the emergency remount stuff */\n#",
      "include <linux/security.h>\n#",
      "include <linux/mount.h>\n#",
      "include <linux/blkdev.h>\n#",
      "include <linux/slab.h>\n#",
      "include <linux/export.h>\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "fs_pressure_ratio(",
          "args": [
            "otal_objects)"
          ],
          "line": 134
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ist_lru_shrink_count(",
          "args": [
            "sb->s_inode_lru,",
            "c)"
          ],
          "line": 132
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ist_lru_shrink_count(",
          "args": [
            "sb->s_dentry_lru,",
            "c)"
          ],
          "line": 131
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "b->s_op->nr_cached_objects",
          "args": [
            "b,",
            "c)"
          ],
          "line": 129
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ontainer_of(",
          "args": [
            "hrink,",
            "truct uper_block,",
            "_shrink)"
          ],
          "line": 118
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "include \"internal.h\"\ninclude <linux/lockdep.h>\n#\ninclude <linux/fsnotify.h>\n#\ninclude <linux/cleancache.h>\n#\ninclude <linux/rculist_bl.h>\n#\ninclude <linux/backing-dev.h>\n#\ninclude <linux/mutex.h>\n#\ninclude <linux/idr.h>\n#\ninclude <linux/writeback.h>\t\t/* for the emergency remount stuff */\n#\ninclude <linux/security.h>\n#\ninclude <linux/mount.h>\n#\ninclude <linux/blkdev.h>\n#\ninclude <linux/slab.h>\n#\ninclude <linux/export.h>\n#\n\ntatic unsigned long super_cache_count(struct shrinker *shrink,\n\t\t\t\t       struct shrink_control *sc)\n{\n\tstruct super_block *sb;\n\tlong\ttotal_objects = 0;\n\n\tsb = container_of(shrink, struct super_block, s_shrink);\n\n\t/*\n\t * Don't call trylock_super as it is a potential\n\t * scalability bottleneck. The counts could get updated\n\t * between super_cache_count and super_cache_scan anyway.\n\t * Call to super_cache_count with shrinker_rwsem held\n\t * ensures the safety of call to list_lru_shrink_count() and\n\t * s_op->nr_cached_objects().\n\t */\n\tif (sb->s_op && sb->s_op->nr_cached_objects)\n\t\ttotal_objects = sb->s_op->nr_cached_objects(sb, sc);\n\n\ttotal_objects += list_lru_shrink_count(&sb->s_dentry_lru, sc);\n\ttotal_objects += list_lru_shrink_count(&sb->s_inode_lru, sc);\n\n\ttotal_objects = vfs_pressure_ratio(total_objects);\n\treturn total_objects;\n}"
  },
  {
    "function_name": "uper_cache_scan(",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/super.c",
    "lines": "55-110",
    "snippet": "tatic unsigned long super_cache_scan(struct shrinker *shrink,\n\t\t\t\t      struct shrink_control *sc)\n{\n\tstruct super_block *sb;\n\tlong\tfs_objects = 0;\n\tlong\ttotal_objects;\n\tlong\tfreed = 0;\n\tlong\tdentries;\n\tlong\tinodes;\n\n\tsb = container_of(shrink, struct super_block, s_shrink);\n\n\t/*\n\t * Deadlock avoidance.  We may hold various FS locks, and we don't want\n\t * to recurse into the FS that called us in clear_inode() and friends..\n\t */\n\tif (!(sc->gfp_mask & __GFP_FS))\n\t\treturn SHRINK_STOP;\n\n\tif (!trylock_super(sb))\n\t\treturn SHRINK_STOP;\n\n\tif (sb->s_op->nr_cached_objects)\n\t\tfs_objects = sb->s_op->nr_cached_objects(sb, sc);\n\n\tinodes = list_lru_shrink_count(&sb->s_inode_lru, sc);\n\tdentries = list_lru_shrink_count(&sb->s_dentry_lru, sc);\n\ttotal_objects = dentries + inodes + fs_objects + 1;\n\tif (!total_objects)\n\t\ttotal_objects = 1;\n\n\t/* proportion the scan between the caches */\n\tdentries = mult_frac(sc->nr_to_scan, dentries, total_objects);\n\tinodes = mult_frac(sc->nr_to_scan, inodes, total_objects);\n\tfs_objects = mult_frac(sc->nr_to_scan, fs_objects, total_objects);\n\n\t/*\n\t * prune the dcache first as the icache is pinned by it, then\n\t * prune the icache, followed by the filesystem specific caches\n\t *\n\t * Ensure that we always scan at least one object - memcg kmem\n\t * accounting uses this to fully empty the caches.\n\t */\n\tsc->nr_to_scan = dentries + 1;\n\tfreed = prune_dcache_sb(sb, sc);\n\tsc->nr_to_scan = inodes + 1;\n\tfreed += prune_icache_sb(sb, sc);\n\n\tif (fs_objects) {\n\t\tsc->nr_to_scan = fs_objects + 1;\n\t\tfreed += sb->s_op->free_cached_objects(sb, sc);\n\t}\n\n\tup_read(&sb->s_umount);\n\treturn freed;\n}",
    "includes": [
      "include \"internal.h\"",
      "include <linux/lockdep.h>\n#",
      "include <linux/fsnotify.h>\n#",
      "include <linux/cleancache.h>\n#",
      "include <linux/rculist_bl.h>\n#",
      "include <linux/backing-dev.h>\n#",
      "include <linux/mutex.h>\n#",
      "include <linux/idr.h>\n#",
      "include <linux/writeback.h>\t\t/* for the emergency remount stuff */\n#",
      "include <linux/security.h>\n#",
      "include <linux/mount.h>\n#",
      "include <linux/blkdev.h>\n#",
      "include <linux/slab.h>\n#",
      "include <linux/export.h>\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "p_read(",
          "args": [
            "sb->s_umount)"
          ],
          "line": 108
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "b->s_op->free_cached_objects",
          "args": [
            "b,",
            "c)"
          ],
          "line": 105
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rune_icache_sb(",
          "args": [
            "b,",
            "c)"
          ],
          "line": 101
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rune_dcache_sb(",
          "args": [
            "b,",
            "c)"
          ],
          "line": 99
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ult_frac(",
          "args": [
            "c->nr_to_scan,",
            "s_objects,",
            "otal_objects)"
          ],
          "line": 89
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ult_frac(",
          "args": [
            "c->nr_to_scan,",
            "nodes,",
            "otal_objects)"
          ],
          "line": 88
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ult_frac(",
          "args": [
            "c->nr_to_scan,",
            "entries,",
            "otal_objects)"
          ],
          "line": 87
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ist_lru_shrink_count(",
          "args": [
            "sb->s_dentry_lru,",
            "c)"
          ],
          "line": 81
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ist_lru_shrink_count(",
          "args": [
            "sb->s_inode_lru,",
            "c)"
          ],
          "line": 80
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "b->s_op->nr_cached_objects",
          "args": [
            "b,",
            "c)"
          ],
          "line": 78
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rylock_super(",
          "args": [
            "b)"
          ],
          "line": 74
        },
        "resolved": true,
        "details": {
          "function_name": "rylock_super(",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/super.c",
          "lines": "367-377",
          "snippet": "ool trylock_super(struct super_block *sb)\n{\n\tif (down_read_trylock(&sb->s_umount)) {\n\t\tif (!hlist_unhashed(&sb->s_instances) &&\n\t\t    sb->s_root && (sb->s_flags & MS_BORN))\n\t\t\treturn true;\n\t\tup_read(&sb->s_umount);\n\t}\n\n\treturn false;\n}",
          "includes": [
            "include \"internal.h\"",
            "include <linux/lockdep.h>\n#",
            "include <linux/fsnotify.h>\n#",
            "include <linux/cleancache.h>\n#",
            "include <linux/rculist_bl.h>\n#",
            "include <linux/backing-dev.h>\n#",
            "include <linux/mutex.h>\n#",
            "include <linux/idr.h>\n#",
            "include <linux/writeback.h>\t\t/* for the emergency remount stuff */\n#",
            "include <linux/security.h>\n#",
            "include <linux/mount.h>\n#",
            "include <linux/blkdev.h>\n#",
            "include <linux/slab.h>\n#",
            "include <linux/export.h>\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"internal.h\"\ninclude <linux/lockdep.h>\n#\ninclude <linux/fsnotify.h>\n#\ninclude <linux/cleancache.h>\n#\ninclude <linux/rculist_bl.h>\n#\ninclude <linux/backing-dev.h>\n#\ninclude <linux/mutex.h>\n#\ninclude <linux/idr.h>\n#\ninclude <linux/writeback.h>\t\t/* for the emergency remount stuff */\n#\ninclude <linux/security.h>\n#\ninclude <linux/mount.h>\n#\ninclude <linux/blkdev.h>\n#\ninclude <linux/slab.h>\n#\ninclude <linux/export.h>\n#\n\nool trylock_super(struct super_block *sb)\n{\n\tif (down_read_trylock(&sb->s_umount)) {\n\t\tif (!hlist_unhashed(&sb->s_instances) &&\n\t\t    sb->s_root && (sb->s_flags & MS_BORN))\n\t\t\treturn true;\n\t\tup_read(&sb->s_umount);\n\t}\n\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ontainer_of(",
          "args": [
            "hrink,",
            "truct uper_block,",
            "_shrink)"
          ],
          "line": 65
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "include \"internal.h\"\ninclude <linux/lockdep.h>\n#\ninclude <linux/fsnotify.h>\n#\ninclude <linux/cleancache.h>\n#\ninclude <linux/rculist_bl.h>\n#\ninclude <linux/backing-dev.h>\n#\ninclude <linux/mutex.h>\n#\ninclude <linux/idr.h>\n#\ninclude <linux/writeback.h>\t\t/* for the emergency remount stuff */\n#\ninclude <linux/security.h>\n#\ninclude <linux/mount.h>\n#\ninclude <linux/blkdev.h>\n#\ninclude <linux/slab.h>\n#\ninclude <linux/export.h>\n#\n\ntatic unsigned long super_cache_scan(struct shrinker *shrink,\n\t\t\t\t      struct shrink_control *sc)\n{\n\tstruct super_block *sb;\n\tlong\tfs_objects = 0;\n\tlong\ttotal_objects;\n\tlong\tfreed = 0;\n\tlong\tdentries;\n\tlong\tinodes;\n\n\tsb = container_of(shrink, struct super_block, s_shrink);\n\n\t/*\n\t * Deadlock avoidance.  We may hold various FS locks, and we don't want\n\t * to recurse into the FS that called us in clear_inode() and friends..\n\t */\n\tif (!(sc->gfp_mask & __GFP_FS))\n\t\treturn SHRINK_STOP;\n\n\tif (!trylock_super(sb))\n\t\treturn SHRINK_STOP;\n\n\tif (sb->s_op->nr_cached_objects)\n\t\tfs_objects = sb->s_op->nr_cached_objects(sb, sc);\n\n\tinodes = list_lru_shrink_count(&sb->s_inode_lru, sc);\n\tdentries = list_lru_shrink_count(&sb->s_dentry_lru, sc);\n\ttotal_objects = dentries + inodes + fs_objects + 1;\n\tif (!total_objects)\n\t\ttotal_objects = 1;\n\n\t/* proportion the scan between the caches */\n\tdentries = mult_frac(sc->nr_to_scan, dentries, total_objects);\n\tinodes = mult_frac(sc->nr_to_scan, inodes, total_objects);\n\tfs_objects = mult_frac(sc->nr_to_scan, fs_objects, total_objects);\n\n\t/*\n\t * prune the dcache first as the icache is pinned by it, then\n\t * prune the icache, followed by the filesystem specific caches\n\t *\n\t * Ensure that we always scan at least one object - memcg kmem\n\t * accounting uses this to fully empty the caches.\n\t */\n\tsc->nr_to_scan = dentries + 1;\n\tfreed = prune_dcache_sb(sb, sc);\n\tsc->nr_to_scan = inodes + 1;\n\tfreed += prune_icache_sb(sb, sc);\n\n\tif (fs_objects) {\n\t\tsc->nr_to_scan = fs_objects + 1;\n\t\tfreed += sb->s_op->free_cached_objects(sb, sc);\n\t}\n\n\tup_read(&sb->s_umount);\n\treturn freed;\n}"
  }
]