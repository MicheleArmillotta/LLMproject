[
  {
    "function_name": "signalfd_show_fdinfo",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/signalfd.c",
    "lines": "233-241",
    "snippet": "static void signalfd_show_fdinfo(struct seq_file *m, struct file *f)\n{\n\tstruct signalfd_ctx *ctx = f->private_data;\n\tsigset_t sigmask;\n\n\tsigmask = ctx->sigmask;\n\tsignotset(&sigmask);\n\trender_sigset_t(m, \"sigmask:\\t\", &sigmask);\n}",
    "includes": [
      "#include <linux/compat.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/signalfd.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/list.h>",
      "#include <linux/signal.h>",
      "#include <linux/kernel.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/fs.h>",
      "#include <linux/init.h>",
      "#include <linux/poll.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "render_sigset_t",
          "args": [
            "m",
            "\"sigmask:\\t\"",
            "&sigmask"
          ],
          "line": 240
        },
        "resolved": true,
        "details": {
          "function_name": "render_sigset_t",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/array.c",
          "lines": "194-214",
          "snippet": "void render_sigset_t(struct seq_file *m, const char *header,\n\t\t\t\tsigset_t *set)\n{\n\tint i;\n\n\tseq_puts(m, header);\n\n\ti = _NSIG;\n\tdo {\n\t\tint x = 0;\n\n\t\ti -= 4;\n\t\tif (sigismember(set, i+1)) x |= 1;\n\t\tif (sigismember(set, i+2)) x |= 2;\n\t\tif (sigismember(set, i+3)) x |= 4;\n\t\tif (sigismember(set, i+4)) x |= 8;\n\t\tseq_printf(m, \"%x\", x);\n\t} while (i >= 4);\n\n\tseq_putc(m, '\\n');\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/processor.h>",
            "#include <asm/pgtable.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/string_helpers.h>",
            "#include <linux/tracehook.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/times.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/highmem.h>",
            "#include <linux/signal.h>",
            "#include <linux/smp.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/mm.h>",
            "#include <linux/io.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/ioport.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/mman.h>",
            "#include <linux/string.h>",
            "#include <linux/tty.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/kernel.h>",
            "#include <linux/time.h>",
            "#include <linux/errno.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/processor.h>\n#include <asm/pgtable.h>\n#include <linux/user_namespace.h>\n#include <linux/string_helpers.h>\n#include <linux/tracehook.h>\n#include <linux/ptrace.h>\n#include <linux/pid_namespace.h>\n#include <linux/seq_file.h>\n#include <linux/delayacct.h>\n#include <linux/rcupdate.h>\n#include <linux/cpuset.h>\n#include <linux/times.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/highmem.h>\n#include <linux/signal.h>\n#include <linux/smp.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/hugetlb.h>\n#include <linux/mm.h>\n#include <linux/io.h>\n#include <linux/uaccess.h>\n#include <linux/ioport.h>\n#include <linux/proc_fs.h>\n#include <linux/mman.h>\n#include <linux/string.h>\n#include <linux/tty.h>\n#include <linux/kernel_stat.h>\n#include <linux/kernel.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <linux/types.h>\n\nvoid render_sigset_t(struct seq_file *m, const char *header,\n\t\t\t\tsigset_t *set)\n{\n\tint i;\n\n\tseq_puts(m, header);\n\n\ti = _NSIG;\n\tdo {\n\t\tint x = 0;\n\n\t\ti -= 4;\n\t\tif (sigismember(set, i+1)) x |= 1;\n\t\tif (sigismember(set, i+2)) x |= 2;\n\t\tif (sigismember(set, i+3)) x |= 4;\n\t\tif (sigismember(set, i+4)) x |= 8;\n\t\tseq_printf(m, \"%x\", x);\n\t} while (i >= 4);\n\n\tseq_putc(m, '\\n');\n}"
        }
      },
      {
        "call_info": {
          "callee": "signotset",
          "args": [
            "&sigmask"
          ],
          "line": 239
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/compat.h>\n#include <linux/proc_fs.h>\n#include <linux/syscalls.h>\n#include <linux/signalfd.h>\n#include <linux/anon_inodes.h>\n#include <linux/list.h>\n#include <linux/signal.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n#include <linux/poll.h>\n#include <linux/file.h>\n\nstatic void signalfd_show_fdinfo(struct seq_file *m, struct file *f)\n{\n\tstruct signalfd_ctx *ctx = f->private_data;\n\tsigset_t sigmask;\n\n\tsigmask = ctx->sigmask;\n\tsignotset(&sigmask);\n\trender_sigset_t(m, \"sigmask:\\t\", &sigmask);\n}"
  },
  {
    "function_name": "signalfd_read",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/signalfd.c",
    "lines": "203-230",
    "snippet": "static ssize_t signalfd_read(struct file *file, char __user *buf, size_t count,\n\t\t\t     loff_t *ppos)\n{\n\tstruct signalfd_ctx *ctx = file->private_data;\n\tstruct signalfd_siginfo __user *siginfo;\n\tint nonblock = file->f_flags & O_NONBLOCK;\n\tssize_t ret, total = 0;\n\tsiginfo_t info;\n\n\tcount /= sizeof(struct signalfd_siginfo);\n\tif (!count)\n\t\treturn -EINVAL;\n\n\tsiginfo = (struct signalfd_siginfo __user *) buf;\n\tdo {\n\t\tret = signalfd_dequeue(ctx, &info, nonblock);\n\t\tif (unlikely(ret <= 0))\n\t\t\tbreak;\n\t\tret = signalfd_copyinfo(siginfo, &info);\n\t\tif (ret < 0)\n\t\t\tbreak;\n\t\tsiginfo++;\n\t\ttotal += ret;\n\t\tnonblock = 1;\n\t} while (--count);\n\n\treturn total ? total: ret;\n}",
    "includes": [
      "#include <linux/compat.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/signalfd.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/list.h>",
      "#include <linux/signal.h>",
      "#include <linux/kernel.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/fs.h>",
      "#include <linux/init.h>",
      "#include <linux/poll.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "signalfd_copyinfo",
          "args": [
            "siginfo",
            "&info"
          ],
          "line": 221
        },
        "resolved": true,
        "details": {
          "function_name": "signalfd_copyinfo",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/signalfd.c",
          "lines": "80-156",
          "snippet": "static int signalfd_copyinfo(struct signalfd_siginfo __user *uinfo,\n\t\t\t     siginfo_t const *kinfo)\n{\n\tlong err;\n\n\tBUILD_BUG_ON(sizeof(struct signalfd_siginfo) != 128);\n\n\t/*\n\t * Unused members should be zero ...\n\t */\n\terr = __clear_user(uinfo, sizeof(*uinfo));\n\n\t/*\n\t * If you change siginfo_t structure, please be sure\n\t * this code is fixed accordingly.\n\t */\n\terr |= __put_user(kinfo->si_signo, &uinfo->ssi_signo);\n\terr |= __put_user(kinfo->si_errno, &uinfo->ssi_errno);\n\terr |= __put_user((short) kinfo->si_code, &uinfo->ssi_code);\n\tswitch (kinfo->si_code & __SI_MASK) {\n\tcase __SI_KILL:\n\t\terr |= __put_user(kinfo->si_pid, &uinfo->ssi_pid);\n\t\terr |= __put_user(kinfo->si_uid, &uinfo->ssi_uid);\n\t\tbreak;\n\tcase __SI_TIMER:\n\t\t err |= __put_user(kinfo->si_tid, &uinfo->ssi_tid);\n\t\t err |= __put_user(kinfo->si_overrun, &uinfo->ssi_overrun);\n\t\t err |= __put_user((long) kinfo->si_ptr, &uinfo->ssi_ptr);\n\t\t err |= __put_user(kinfo->si_int, &uinfo->ssi_int);\n\t\tbreak;\n\tcase __SI_POLL:\n\t\terr |= __put_user(kinfo->si_band, &uinfo->ssi_band);\n\t\terr |= __put_user(kinfo->si_fd, &uinfo->ssi_fd);\n\t\tbreak;\n\tcase __SI_FAULT:\n\t\terr |= __put_user((long) kinfo->si_addr, &uinfo->ssi_addr);\n#ifdef __ARCH_SI_TRAPNO\n\t\terr |= __put_user(kinfo->si_trapno, &uinfo->ssi_trapno);\n#endif\n#ifdef BUS_MCEERR_AO\n\t\t/* \n\t\t * Other callers might not initialize the si_lsb field,\n\t\t * so check explicitly for the right codes here.\n\t\t */\n\t\tif (kinfo->si_code == BUS_MCEERR_AR ||\n\t\t    kinfo->si_code == BUS_MCEERR_AO)\n\t\t\terr |= __put_user((short) kinfo->si_addr_lsb,\n\t\t\t\t\t  &uinfo->ssi_addr_lsb);\n#endif\n\t\tbreak;\n\tcase __SI_CHLD:\n\t\terr |= __put_user(kinfo->si_pid, &uinfo->ssi_pid);\n\t\terr |= __put_user(kinfo->si_uid, &uinfo->ssi_uid);\n\t\terr |= __put_user(kinfo->si_status, &uinfo->ssi_status);\n\t\terr |= __put_user(kinfo->si_utime, &uinfo->ssi_utime);\n\t\terr |= __put_user(kinfo->si_stime, &uinfo->ssi_stime);\n\t\tbreak;\n\tcase __SI_RT: /* This is not generated by the kernel as of now. */\n\tcase __SI_MESGQ: /* But this is */\n\t\terr |= __put_user(kinfo->si_pid, &uinfo->ssi_pid);\n\t\terr |= __put_user(kinfo->si_uid, &uinfo->ssi_uid);\n\t\terr |= __put_user((long) kinfo->si_ptr, &uinfo->ssi_ptr);\n\t\terr |= __put_user(kinfo->si_int, &uinfo->ssi_int);\n\t\tbreak;\n\tdefault:\n\t\t/*\n\t\t * This case catches also the signals queued by sigqueue().\n\t\t */\n\t\terr |= __put_user(kinfo->si_pid, &uinfo->ssi_pid);\n\t\terr |= __put_user(kinfo->si_uid, &uinfo->ssi_uid);\n\t\terr |= __put_user((long) kinfo->si_ptr, &uinfo->ssi_ptr);\n\t\terr |= __put_user(kinfo->si_int, &uinfo->ssi_int);\n\t\tbreak;\n\t}\n\n\treturn err ? -EFAULT: sizeof(*uinfo);\n}",
          "includes": [
            "#include <linux/compat.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/signalfd.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/list.h>",
            "#include <linux/signal.h>",
            "#include <linux/kernel.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/fs.h>",
            "#include <linux/init.h>",
            "#include <linux/poll.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/compat.h>\n#include <linux/proc_fs.h>\n#include <linux/syscalls.h>\n#include <linux/signalfd.h>\n#include <linux/anon_inodes.h>\n#include <linux/list.h>\n#include <linux/signal.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n#include <linux/poll.h>\n#include <linux/file.h>\n\nstatic int signalfd_copyinfo(struct signalfd_siginfo __user *uinfo,\n\t\t\t     siginfo_t const *kinfo)\n{\n\tlong err;\n\n\tBUILD_BUG_ON(sizeof(struct signalfd_siginfo) != 128);\n\n\t/*\n\t * Unused members should be zero ...\n\t */\n\terr = __clear_user(uinfo, sizeof(*uinfo));\n\n\t/*\n\t * If you change siginfo_t structure, please be sure\n\t * this code is fixed accordingly.\n\t */\n\terr |= __put_user(kinfo->si_signo, &uinfo->ssi_signo);\n\terr |= __put_user(kinfo->si_errno, &uinfo->ssi_errno);\n\terr |= __put_user((short) kinfo->si_code, &uinfo->ssi_code);\n\tswitch (kinfo->si_code & __SI_MASK) {\n\tcase __SI_KILL:\n\t\terr |= __put_user(kinfo->si_pid, &uinfo->ssi_pid);\n\t\terr |= __put_user(kinfo->si_uid, &uinfo->ssi_uid);\n\t\tbreak;\n\tcase __SI_TIMER:\n\t\t err |= __put_user(kinfo->si_tid, &uinfo->ssi_tid);\n\t\t err |= __put_user(kinfo->si_overrun, &uinfo->ssi_overrun);\n\t\t err |= __put_user((long) kinfo->si_ptr, &uinfo->ssi_ptr);\n\t\t err |= __put_user(kinfo->si_int, &uinfo->ssi_int);\n\t\tbreak;\n\tcase __SI_POLL:\n\t\terr |= __put_user(kinfo->si_band, &uinfo->ssi_band);\n\t\terr |= __put_user(kinfo->si_fd, &uinfo->ssi_fd);\n\t\tbreak;\n\tcase __SI_FAULT:\n\t\terr |= __put_user((long) kinfo->si_addr, &uinfo->ssi_addr);\n#ifdef __ARCH_SI_TRAPNO\n\t\terr |= __put_user(kinfo->si_trapno, &uinfo->ssi_trapno);\n#endif\n#ifdef BUS_MCEERR_AO\n\t\t/* \n\t\t * Other callers might not initialize the si_lsb field,\n\t\t * so check explicitly for the right codes here.\n\t\t */\n\t\tif (kinfo->si_code == BUS_MCEERR_AR ||\n\t\t    kinfo->si_code == BUS_MCEERR_AO)\n\t\t\terr |= __put_user((short) kinfo->si_addr_lsb,\n\t\t\t\t\t  &uinfo->ssi_addr_lsb);\n#endif\n\t\tbreak;\n\tcase __SI_CHLD:\n\t\terr |= __put_user(kinfo->si_pid, &uinfo->ssi_pid);\n\t\terr |= __put_user(kinfo->si_uid, &uinfo->ssi_uid);\n\t\terr |= __put_user(kinfo->si_status, &uinfo->ssi_status);\n\t\terr |= __put_user(kinfo->si_utime, &uinfo->ssi_utime);\n\t\terr |= __put_user(kinfo->si_stime, &uinfo->ssi_stime);\n\t\tbreak;\n\tcase __SI_RT: /* This is not generated by the kernel as of now. */\n\tcase __SI_MESGQ: /* But this is */\n\t\terr |= __put_user(kinfo->si_pid, &uinfo->ssi_pid);\n\t\terr |= __put_user(kinfo->si_uid, &uinfo->ssi_uid);\n\t\terr |= __put_user((long) kinfo->si_ptr, &uinfo->ssi_ptr);\n\t\terr |= __put_user(kinfo->si_int, &uinfo->ssi_int);\n\t\tbreak;\n\tdefault:\n\t\t/*\n\t\t * This case catches also the signals queued by sigqueue().\n\t\t */\n\t\terr |= __put_user(kinfo->si_pid, &uinfo->ssi_pid);\n\t\terr |= __put_user(kinfo->si_uid, &uinfo->ssi_uid);\n\t\terr |= __put_user((long) kinfo->si_ptr, &uinfo->ssi_ptr);\n\t\terr |= __put_user(kinfo->si_int, &uinfo->ssi_int);\n\t\tbreak;\n\t}\n\n\treturn err ? -EFAULT: sizeof(*uinfo);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "ret <= 0"
          ],
          "line": 219
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "signalfd_dequeue",
          "args": [
            "ctx",
            "&info",
            "nonblock"
          ],
          "line": 218
        },
        "resolved": true,
        "details": {
          "function_name": "signalfd_dequeue",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/signalfd.c",
          "lines": "158-196",
          "snippet": "static ssize_t signalfd_dequeue(struct signalfd_ctx *ctx, siginfo_t *info,\n\t\t\t\tint nonblock)\n{\n\tssize_t ret;\n\tDECLARE_WAITQUEUE(wait, current);\n\n\tspin_lock_irq(&current->sighand->siglock);\n\tret = dequeue_signal(current, &ctx->sigmask, info);\n\tswitch (ret) {\n\tcase 0:\n\t\tif (!nonblock)\n\t\t\tbreak;\n\t\tret = -EAGAIN;\n\tdefault:\n\t\tspin_unlock_irq(&current->sighand->siglock);\n\t\treturn ret;\n\t}\n\n\tadd_wait_queue(&current->sighand->signalfd_wqh, &wait);\n\tfor (;;) {\n\t\tset_current_state(TASK_INTERRUPTIBLE);\n\t\tret = dequeue_signal(current, &ctx->sigmask, info);\n\t\tif (ret != 0)\n\t\t\tbreak;\n\t\tif (signal_pending(current)) {\n\t\t\tret = -ERESTARTSYS;\n\t\t\tbreak;\n\t\t}\n\t\tspin_unlock_irq(&current->sighand->siglock);\n\t\tschedule();\n\t\tspin_lock_irq(&current->sighand->siglock);\n\t}\n\tspin_unlock_irq(&current->sighand->siglock);\n\n\tremove_wait_queue(&current->sighand->signalfd_wqh, &wait);\n\t__set_current_state(TASK_RUNNING);\n\n\treturn ret;\n}",
          "includes": [
            "#include <linux/compat.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/signalfd.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/list.h>",
            "#include <linux/signal.h>",
            "#include <linux/kernel.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/fs.h>",
            "#include <linux/init.h>",
            "#include <linux/poll.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/compat.h>\n#include <linux/proc_fs.h>\n#include <linux/syscalls.h>\n#include <linux/signalfd.h>\n#include <linux/anon_inodes.h>\n#include <linux/list.h>\n#include <linux/signal.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n#include <linux/poll.h>\n#include <linux/file.h>\n\nstatic ssize_t signalfd_dequeue(struct signalfd_ctx *ctx, siginfo_t *info,\n\t\t\t\tint nonblock)\n{\n\tssize_t ret;\n\tDECLARE_WAITQUEUE(wait, current);\n\n\tspin_lock_irq(&current->sighand->siglock);\n\tret = dequeue_signal(current, &ctx->sigmask, info);\n\tswitch (ret) {\n\tcase 0:\n\t\tif (!nonblock)\n\t\t\tbreak;\n\t\tret = -EAGAIN;\n\tdefault:\n\t\tspin_unlock_irq(&current->sighand->siglock);\n\t\treturn ret;\n\t}\n\n\tadd_wait_queue(&current->sighand->signalfd_wqh, &wait);\n\tfor (;;) {\n\t\tset_current_state(TASK_INTERRUPTIBLE);\n\t\tret = dequeue_signal(current, &ctx->sigmask, info);\n\t\tif (ret != 0)\n\t\t\tbreak;\n\t\tif (signal_pending(current)) {\n\t\t\tret = -ERESTARTSYS;\n\t\t\tbreak;\n\t\t}\n\t\tspin_unlock_irq(&current->sighand->siglock);\n\t\tschedule();\n\t\tspin_lock_irq(&current->sighand->siglock);\n\t}\n\tspin_unlock_irq(&current->sighand->siglock);\n\n\tremove_wait_queue(&current->sighand->signalfd_wqh, &wait);\n\t__set_current_state(TASK_RUNNING);\n\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/compat.h>\n#include <linux/proc_fs.h>\n#include <linux/syscalls.h>\n#include <linux/signalfd.h>\n#include <linux/anon_inodes.h>\n#include <linux/list.h>\n#include <linux/signal.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n#include <linux/poll.h>\n#include <linux/file.h>\n\nstatic ssize_t signalfd_read(struct file *file, char __user *buf, size_t count,\n\t\t\t     loff_t *ppos)\n{\n\tstruct signalfd_ctx *ctx = file->private_data;\n\tstruct signalfd_siginfo __user *siginfo;\n\tint nonblock = file->f_flags & O_NONBLOCK;\n\tssize_t ret, total = 0;\n\tsiginfo_t info;\n\n\tcount /= sizeof(struct signalfd_siginfo);\n\tif (!count)\n\t\treturn -EINVAL;\n\n\tsiginfo = (struct signalfd_siginfo __user *) buf;\n\tdo {\n\t\tret = signalfd_dequeue(ctx, &info, nonblock);\n\t\tif (unlikely(ret <= 0))\n\t\t\tbreak;\n\t\tret = signalfd_copyinfo(siginfo, &info);\n\t\tif (ret < 0)\n\t\t\tbreak;\n\t\tsiginfo++;\n\t\ttotal += ret;\n\t\tnonblock = 1;\n\t} while (--count);\n\n\treturn total ? total: ret;\n}"
  },
  {
    "function_name": "signalfd_dequeue",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/signalfd.c",
    "lines": "158-196",
    "snippet": "static ssize_t signalfd_dequeue(struct signalfd_ctx *ctx, siginfo_t *info,\n\t\t\t\tint nonblock)\n{\n\tssize_t ret;\n\tDECLARE_WAITQUEUE(wait, current);\n\n\tspin_lock_irq(&current->sighand->siglock);\n\tret = dequeue_signal(current, &ctx->sigmask, info);\n\tswitch (ret) {\n\tcase 0:\n\t\tif (!nonblock)\n\t\t\tbreak;\n\t\tret = -EAGAIN;\n\tdefault:\n\t\tspin_unlock_irq(&current->sighand->siglock);\n\t\treturn ret;\n\t}\n\n\tadd_wait_queue(&current->sighand->signalfd_wqh, &wait);\n\tfor (;;) {\n\t\tset_current_state(TASK_INTERRUPTIBLE);\n\t\tret = dequeue_signal(current, &ctx->sigmask, info);\n\t\tif (ret != 0)\n\t\t\tbreak;\n\t\tif (signal_pending(current)) {\n\t\t\tret = -ERESTARTSYS;\n\t\t\tbreak;\n\t\t}\n\t\tspin_unlock_irq(&current->sighand->siglock);\n\t\tschedule();\n\t\tspin_lock_irq(&current->sighand->siglock);\n\t}\n\tspin_unlock_irq(&current->sighand->siglock);\n\n\tremove_wait_queue(&current->sighand->signalfd_wqh, &wait);\n\t__set_current_state(TASK_RUNNING);\n\n\treturn ret;\n}",
    "includes": [
      "#include <linux/compat.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/signalfd.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/list.h>",
      "#include <linux/signal.h>",
      "#include <linux/kernel.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/fs.h>",
      "#include <linux/init.h>",
      "#include <linux/poll.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__set_current_state",
          "args": [
            "TASK_RUNNING"
          ],
          "line": 193
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "remove_wait_queue",
          "args": [
            "&current->sighand->signalfd_wqh",
            "&wait"
          ],
          "line": 192
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock_irq",
          "args": [
            "&current->sighand->siglock"
          ],
          "line": 190
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock_irq",
          "args": [
            "&current->sighand->siglock"
          ],
          "line": 188
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "schedule",
          "args": [],
          "line": 187
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock_irq",
          "args": [
            "&current->sighand->siglock"
          ],
          "line": 186
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "signal_pending",
          "args": [
            "current"
          ],
          "line": 182
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dequeue_signal",
          "args": [
            "current",
            "&ctx->sigmask",
            "info"
          ],
          "line": 179
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_current_state",
          "args": [
            "TASK_INTERRUPTIBLE"
          ],
          "line": 178
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "add_wait_queue",
          "args": [
            "&current->sighand->signalfd_wqh",
            "&wait"
          ],
          "line": 176
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock_irq",
          "args": [
            "&current->sighand->siglock"
          ],
          "line": 172
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dequeue_signal",
          "args": [
            "current",
            "&ctx->sigmask",
            "info"
          ],
          "line": 165
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock_irq",
          "args": [
            "&current->sighand->siglock"
          ],
          "line": 164
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DECLARE_WAITQUEUE",
          "args": [
            "wait",
            "current"
          ],
          "line": 162
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/compat.h>\n#include <linux/proc_fs.h>\n#include <linux/syscalls.h>\n#include <linux/signalfd.h>\n#include <linux/anon_inodes.h>\n#include <linux/list.h>\n#include <linux/signal.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n#include <linux/poll.h>\n#include <linux/file.h>\n\nstatic ssize_t signalfd_dequeue(struct signalfd_ctx *ctx, siginfo_t *info,\n\t\t\t\tint nonblock)\n{\n\tssize_t ret;\n\tDECLARE_WAITQUEUE(wait, current);\n\n\tspin_lock_irq(&current->sighand->siglock);\n\tret = dequeue_signal(current, &ctx->sigmask, info);\n\tswitch (ret) {\n\tcase 0:\n\t\tif (!nonblock)\n\t\t\tbreak;\n\t\tret = -EAGAIN;\n\tdefault:\n\t\tspin_unlock_irq(&current->sighand->siglock);\n\t\treturn ret;\n\t}\n\n\tadd_wait_queue(&current->sighand->signalfd_wqh, &wait);\n\tfor (;;) {\n\t\tset_current_state(TASK_INTERRUPTIBLE);\n\t\tret = dequeue_signal(current, &ctx->sigmask, info);\n\t\tif (ret != 0)\n\t\t\tbreak;\n\t\tif (signal_pending(current)) {\n\t\t\tret = -ERESTARTSYS;\n\t\t\tbreak;\n\t\t}\n\t\tspin_unlock_irq(&current->sighand->siglock);\n\t\tschedule();\n\t\tspin_lock_irq(&current->sighand->siglock);\n\t}\n\tspin_unlock_irq(&current->sighand->siglock);\n\n\tremove_wait_queue(&current->sighand->signalfd_wqh, &wait);\n\t__set_current_state(TASK_RUNNING);\n\n\treturn ret;\n}"
  },
  {
    "function_name": "signalfd_copyinfo",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/signalfd.c",
    "lines": "80-156",
    "snippet": "static int signalfd_copyinfo(struct signalfd_siginfo __user *uinfo,\n\t\t\t     siginfo_t const *kinfo)\n{\n\tlong err;\n\n\tBUILD_BUG_ON(sizeof(struct signalfd_siginfo) != 128);\n\n\t/*\n\t * Unused members should be zero ...\n\t */\n\terr = __clear_user(uinfo, sizeof(*uinfo));\n\n\t/*\n\t * If you change siginfo_t structure, please be sure\n\t * this code is fixed accordingly.\n\t */\n\terr |= __put_user(kinfo->si_signo, &uinfo->ssi_signo);\n\terr |= __put_user(kinfo->si_errno, &uinfo->ssi_errno);\n\terr |= __put_user((short) kinfo->si_code, &uinfo->ssi_code);\n\tswitch (kinfo->si_code & __SI_MASK) {\n\tcase __SI_KILL:\n\t\terr |= __put_user(kinfo->si_pid, &uinfo->ssi_pid);\n\t\terr |= __put_user(kinfo->si_uid, &uinfo->ssi_uid);\n\t\tbreak;\n\tcase __SI_TIMER:\n\t\t err |= __put_user(kinfo->si_tid, &uinfo->ssi_tid);\n\t\t err |= __put_user(kinfo->si_overrun, &uinfo->ssi_overrun);\n\t\t err |= __put_user((long) kinfo->si_ptr, &uinfo->ssi_ptr);\n\t\t err |= __put_user(kinfo->si_int, &uinfo->ssi_int);\n\t\tbreak;\n\tcase __SI_POLL:\n\t\terr |= __put_user(kinfo->si_band, &uinfo->ssi_band);\n\t\terr |= __put_user(kinfo->si_fd, &uinfo->ssi_fd);\n\t\tbreak;\n\tcase __SI_FAULT:\n\t\terr |= __put_user((long) kinfo->si_addr, &uinfo->ssi_addr);\n#ifdef __ARCH_SI_TRAPNO\n\t\terr |= __put_user(kinfo->si_trapno, &uinfo->ssi_trapno);\n#endif\n#ifdef BUS_MCEERR_AO\n\t\t/* \n\t\t * Other callers might not initialize the si_lsb field,\n\t\t * so check explicitly for the right codes here.\n\t\t */\n\t\tif (kinfo->si_code == BUS_MCEERR_AR ||\n\t\t    kinfo->si_code == BUS_MCEERR_AO)\n\t\t\terr |= __put_user((short) kinfo->si_addr_lsb,\n\t\t\t\t\t  &uinfo->ssi_addr_lsb);\n#endif\n\t\tbreak;\n\tcase __SI_CHLD:\n\t\terr |= __put_user(kinfo->si_pid, &uinfo->ssi_pid);\n\t\terr |= __put_user(kinfo->si_uid, &uinfo->ssi_uid);\n\t\terr |= __put_user(kinfo->si_status, &uinfo->ssi_status);\n\t\terr |= __put_user(kinfo->si_utime, &uinfo->ssi_utime);\n\t\terr |= __put_user(kinfo->si_stime, &uinfo->ssi_stime);\n\t\tbreak;\n\tcase __SI_RT: /* This is not generated by the kernel as of now. */\n\tcase __SI_MESGQ: /* But this is */\n\t\terr |= __put_user(kinfo->si_pid, &uinfo->ssi_pid);\n\t\terr |= __put_user(kinfo->si_uid, &uinfo->ssi_uid);\n\t\terr |= __put_user((long) kinfo->si_ptr, &uinfo->ssi_ptr);\n\t\terr |= __put_user(kinfo->si_int, &uinfo->ssi_int);\n\t\tbreak;\n\tdefault:\n\t\t/*\n\t\t * This case catches also the signals queued by sigqueue().\n\t\t */\n\t\terr |= __put_user(kinfo->si_pid, &uinfo->ssi_pid);\n\t\terr |= __put_user(kinfo->si_uid, &uinfo->ssi_uid);\n\t\terr |= __put_user((long) kinfo->si_ptr, &uinfo->ssi_ptr);\n\t\terr |= __put_user(kinfo->si_int, &uinfo->ssi_int);\n\t\tbreak;\n\t}\n\n\treturn err ? -EFAULT: sizeof(*uinfo);\n}",
    "includes": [
      "#include <linux/compat.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/signalfd.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/list.h>",
      "#include <linux/signal.h>",
      "#include <linux/kernel.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/fs.h>",
      "#include <linux/init.h>",
      "#include <linux/poll.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__put_user",
          "args": [
            "kinfo->si_int",
            "&uinfo->ssi_int"
          ],
          "line": 151
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__put_user",
          "args": [
            "(long) kinfo->si_ptr",
            "&uinfo->ssi_ptr"
          ],
          "line": 150
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__put_user",
          "args": [
            "kinfo->si_uid",
            "&uinfo->ssi_uid"
          ],
          "line": 149
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__put_user",
          "args": [
            "kinfo->si_pid",
            "&uinfo->ssi_pid"
          ],
          "line": 148
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__put_user",
          "args": [
            "kinfo->si_int",
            "&uinfo->ssi_int"
          ],
          "line": 142
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__put_user",
          "args": [
            "(long) kinfo->si_ptr",
            "&uinfo->ssi_ptr"
          ],
          "line": 141
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__put_user",
          "args": [
            "kinfo->si_uid",
            "&uinfo->ssi_uid"
          ],
          "line": 140
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__put_user",
          "args": [
            "kinfo->si_pid",
            "&uinfo->ssi_pid"
          ],
          "line": 139
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__put_user",
          "args": [
            "kinfo->si_stime",
            "&uinfo->ssi_stime"
          ],
          "line": 135
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__put_user",
          "args": [
            "kinfo->si_utime",
            "&uinfo->ssi_utime"
          ],
          "line": 134
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__put_user",
          "args": [
            "kinfo->si_status",
            "&uinfo->ssi_status"
          ],
          "line": 133
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__put_user",
          "args": [
            "kinfo->si_uid",
            "&uinfo->ssi_uid"
          ],
          "line": 132
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__put_user",
          "args": [
            "kinfo->si_pid",
            "&uinfo->ssi_pid"
          ],
          "line": 131
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__put_user",
          "args": [
            "(short) kinfo->si_addr_lsb",
            "&uinfo->ssi_addr_lsb"
          ],
          "line": 126
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__put_user",
          "args": [
            "kinfo->si_trapno",
            "&uinfo->ssi_trapno"
          ],
          "line": 117
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__put_user",
          "args": [
            "(long) kinfo->si_addr",
            "&uinfo->ssi_addr"
          ],
          "line": 115
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__put_user",
          "args": [
            "kinfo->si_fd",
            "&uinfo->ssi_fd"
          ],
          "line": 112
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__put_user",
          "args": [
            "kinfo->si_band",
            "&uinfo->ssi_band"
          ],
          "line": 111
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__put_user",
          "args": [
            "kinfo->si_int",
            "&uinfo->ssi_int"
          ],
          "line": 108
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__put_user",
          "args": [
            "(long) kinfo->si_ptr",
            "&uinfo->ssi_ptr"
          ],
          "line": 107
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__put_user",
          "args": [
            "kinfo->si_overrun",
            "&uinfo->ssi_overrun"
          ],
          "line": 106
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__put_user",
          "args": [
            "kinfo->si_tid",
            "&uinfo->ssi_tid"
          ],
          "line": 105
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__put_user",
          "args": [
            "kinfo->si_uid",
            "&uinfo->ssi_uid"
          ],
          "line": 102
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__put_user",
          "args": [
            "kinfo->si_pid",
            "&uinfo->ssi_pid"
          ],
          "line": 101
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__put_user",
          "args": [
            "(short) kinfo->si_code",
            "&uinfo->ssi_code"
          ],
          "line": 98
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__put_user",
          "args": [
            "kinfo->si_errno",
            "&uinfo->ssi_errno"
          ],
          "line": 97
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__put_user",
          "args": [
            "kinfo->si_signo",
            "&uinfo->ssi_signo"
          ],
          "line": 96
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__clear_user",
          "args": [
            "uinfo",
            "sizeof(*uinfo)"
          ],
          "line": 90
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUILD_BUG_ON",
          "args": [
            "sizeof(struct signalfd_siginfo) != 128"
          ],
          "line": 85
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/compat.h>\n#include <linux/proc_fs.h>\n#include <linux/syscalls.h>\n#include <linux/signalfd.h>\n#include <linux/anon_inodes.h>\n#include <linux/list.h>\n#include <linux/signal.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n#include <linux/poll.h>\n#include <linux/file.h>\n\nstatic int signalfd_copyinfo(struct signalfd_siginfo __user *uinfo,\n\t\t\t     siginfo_t const *kinfo)\n{\n\tlong err;\n\n\tBUILD_BUG_ON(sizeof(struct signalfd_siginfo) != 128);\n\n\t/*\n\t * Unused members should be zero ...\n\t */\n\terr = __clear_user(uinfo, sizeof(*uinfo));\n\n\t/*\n\t * If you change siginfo_t structure, please be sure\n\t * this code is fixed accordingly.\n\t */\n\terr |= __put_user(kinfo->si_signo, &uinfo->ssi_signo);\n\terr |= __put_user(kinfo->si_errno, &uinfo->ssi_errno);\n\terr |= __put_user((short) kinfo->si_code, &uinfo->ssi_code);\n\tswitch (kinfo->si_code & __SI_MASK) {\n\tcase __SI_KILL:\n\t\terr |= __put_user(kinfo->si_pid, &uinfo->ssi_pid);\n\t\terr |= __put_user(kinfo->si_uid, &uinfo->ssi_uid);\n\t\tbreak;\n\tcase __SI_TIMER:\n\t\t err |= __put_user(kinfo->si_tid, &uinfo->ssi_tid);\n\t\t err |= __put_user(kinfo->si_overrun, &uinfo->ssi_overrun);\n\t\t err |= __put_user((long) kinfo->si_ptr, &uinfo->ssi_ptr);\n\t\t err |= __put_user(kinfo->si_int, &uinfo->ssi_int);\n\t\tbreak;\n\tcase __SI_POLL:\n\t\terr |= __put_user(kinfo->si_band, &uinfo->ssi_band);\n\t\terr |= __put_user(kinfo->si_fd, &uinfo->ssi_fd);\n\t\tbreak;\n\tcase __SI_FAULT:\n\t\terr |= __put_user((long) kinfo->si_addr, &uinfo->ssi_addr);\n#ifdef __ARCH_SI_TRAPNO\n\t\terr |= __put_user(kinfo->si_trapno, &uinfo->ssi_trapno);\n#endif\n#ifdef BUS_MCEERR_AO\n\t\t/* \n\t\t * Other callers might not initialize the si_lsb field,\n\t\t * so check explicitly for the right codes here.\n\t\t */\n\t\tif (kinfo->si_code == BUS_MCEERR_AR ||\n\t\t    kinfo->si_code == BUS_MCEERR_AO)\n\t\t\terr |= __put_user((short) kinfo->si_addr_lsb,\n\t\t\t\t\t  &uinfo->ssi_addr_lsb);\n#endif\n\t\tbreak;\n\tcase __SI_CHLD:\n\t\terr |= __put_user(kinfo->si_pid, &uinfo->ssi_pid);\n\t\terr |= __put_user(kinfo->si_uid, &uinfo->ssi_uid);\n\t\terr |= __put_user(kinfo->si_status, &uinfo->ssi_status);\n\t\terr |= __put_user(kinfo->si_utime, &uinfo->ssi_utime);\n\t\terr |= __put_user(kinfo->si_stime, &uinfo->ssi_stime);\n\t\tbreak;\n\tcase __SI_RT: /* This is not generated by the kernel as of now. */\n\tcase __SI_MESGQ: /* But this is */\n\t\terr |= __put_user(kinfo->si_pid, &uinfo->ssi_pid);\n\t\terr |= __put_user(kinfo->si_uid, &uinfo->ssi_uid);\n\t\terr |= __put_user((long) kinfo->si_ptr, &uinfo->ssi_ptr);\n\t\terr |= __put_user(kinfo->si_int, &uinfo->ssi_int);\n\t\tbreak;\n\tdefault:\n\t\t/*\n\t\t * This case catches also the signals queued by sigqueue().\n\t\t */\n\t\terr |= __put_user(kinfo->si_pid, &uinfo->ssi_pid);\n\t\terr |= __put_user(kinfo->si_uid, &uinfo->ssi_uid);\n\t\terr |= __put_user((long) kinfo->si_ptr, &uinfo->ssi_ptr);\n\t\terr |= __put_user(kinfo->si_int, &uinfo->ssi_int);\n\t\tbreak;\n\t}\n\n\treturn err ? -EFAULT: sizeof(*uinfo);\n}"
  },
  {
    "function_name": "signalfd_poll",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/signalfd.c",
    "lines": "60-75",
    "snippet": "static unsigned int signalfd_poll(struct file *file, poll_table *wait)\n{\n\tstruct signalfd_ctx *ctx = file->private_data;\n\tunsigned int events = 0;\n\n\tpoll_wait(file, &current->sighand->signalfd_wqh, wait);\n\n\tspin_lock_irq(&current->sighand->siglock);\n\tif (next_signal(&current->pending, &ctx->sigmask) ||\n\t    next_signal(&current->signal->shared_pending,\n\t\t\t&ctx->sigmask))\n\t\tevents |= POLLIN;\n\tspin_unlock_irq(&current->sighand->siglock);\n\n\treturn events;\n}",
    "includes": [
      "#include <linux/compat.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/signalfd.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/list.h>",
      "#include <linux/signal.h>",
      "#include <linux/kernel.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/fs.h>",
      "#include <linux/init.h>",
      "#include <linux/poll.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock_irq",
          "args": [
            "&current->sighand->siglock"
          ],
          "line": 72
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "next_signal",
          "args": [
            "&current->signal->shared_pending",
            "&ctx->sigmask"
          ],
          "line": 69
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "next_signal",
          "args": [
            "&current->pending",
            "&ctx->sigmask"
          ],
          "line": 68
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock_irq",
          "args": [
            "&current->sighand->siglock"
          ],
          "line": 67
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "poll_wait",
          "args": [
            "file",
            "&current->sighand->signalfd_wqh",
            "wait"
          ],
          "line": 65
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/compat.h>\n#include <linux/proc_fs.h>\n#include <linux/syscalls.h>\n#include <linux/signalfd.h>\n#include <linux/anon_inodes.h>\n#include <linux/list.h>\n#include <linux/signal.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n#include <linux/poll.h>\n#include <linux/file.h>\n\nstatic unsigned int signalfd_poll(struct file *file, poll_table *wait)\n{\n\tstruct signalfd_ctx *ctx = file->private_data;\n\tunsigned int events = 0;\n\n\tpoll_wait(file, &current->sighand->signalfd_wqh, wait);\n\n\tspin_lock_irq(&current->sighand->siglock);\n\tif (next_signal(&current->pending, &ctx->sigmask) ||\n\t    next_signal(&current->signal->shared_pending,\n\t\t\t&ctx->sigmask))\n\t\tevents |= POLLIN;\n\tspin_unlock_irq(&current->sighand->siglock);\n\n\treturn events;\n}"
  },
  {
    "function_name": "signalfd_release",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/signalfd.c",
    "lines": "54-58",
    "snippet": "static int signalfd_release(struct inode *inode, struct file *file)\n{\n\tkfree(file->private_data);\n\treturn 0;\n}",
    "includes": [
      "#include <linux/compat.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/signalfd.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/list.h>",
      "#include <linux/signal.h>",
      "#include <linux/kernel.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/fs.h>",
      "#include <linux/init.h>",
      "#include <linux/poll.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "file->private_data"
          ],
          "line": 56
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/compat.h>\n#include <linux/proc_fs.h>\n#include <linux/syscalls.h>\n#include <linux/signalfd.h>\n#include <linux/anon_inodes.h>\n#include <linux/list.h>\n#include <linux/signal.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n#include <linux/poll.h>\n#include <linux/file.h>\n\nstatic int signalfd_release(struct inode *inode, struct file *file)\n{\n\tkfree(file->private_data);\n\treturn 0;\n}"
  },
  {
    "function_name": "signalfd_cleanup",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/signalfd.c",
    "lines": "35-48",
    "snippet": "void signalfd_cleanup(struct sighand_struct *sighand)\n{\n\twait_queue_head_t *wqh = &sighand->signalfd_wqh;\n\t/*\n\t * The lockless check can race with remove_wait_queue() in progress,\n\t * but in this case its caller should run under rcu_read_lock() and\n\t * sighand_cachep is SLAB_DESTROY_BY_RCU, we can safely return.\n\t */\n\tif (likely(!waitqueue_active(wqh)))\n\t\treturn;\n\n\t/* wait_queue_t->func(POLLFREE) should do remove_wait_queue() */\n\twake_up_poll(wqh, POLLHUP | POLLFREE);\n}",
    "includes": [
      "#include <linux/compat.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/signalfd.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/list.h>",
      "#include <linux/signal.h>",
      "#include <linux/kernel.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/fs.h>",
      "#include <linux/init.h>",
      "#include <linux/poll.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "wake_up_poll",
          "args": [
            "wqh",
            "POLLHUP | POLLFREE"
          ],
          "line": 47
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "likely",
          "args": [
            "!waitqueue_active(wqh)"
          ],
          "line": 43
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "waitqueue_active",
          "args": [
            "wqh"
          ],
          "line": 43
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/compat.h>\n#include <linux/proc_fs.h>\n#include <linux/syscalls.h>\n#include <linux/signalfd.h>\n#include <linux/anon_inodes.h>\n#include <linux/list.h>\n#include <linux/signal.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n#include <linux/poll.h>\n#include <linux/file.h>\n\nvoid signalfd_cleanup(struct sighand_struct *sighand)\n{\n\twait_queue_head_t *wqh = &sighand->signalfd_wqh;\n\t/*\n\t * The lockless check can race with remove_wait_queue() in progress,\n\t * but in this case its caller should run under rcu_read_lock() and\n\t * sighand_cachep is SLAB_DESTROY_BY_RCU, we can safely return.\n\t */\n\tif (likely(!waitqueue_active(wqh)))\n\t\treturn;\n\n\t/* wait_queue_t->func(POLLFREE) should do remove_wait_queue() */\n\twake_up_poll(wqh, POLLHUP | POLLFREE);\n}"
  }
]