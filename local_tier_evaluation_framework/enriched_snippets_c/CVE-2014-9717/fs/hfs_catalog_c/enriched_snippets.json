[
  {
    "function_name": "hfs_cat_move",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfs/catalog.c",
    "lines": "279-366",
    "snippet": "int hfs_cat_move(u32 cnid, struct inode *src_dir, struct qstr *src_name,\n\t\t struct inode *dst_dir, struct qstr *dst_name)\n{\n\tstruct super_block *sb;\n\tstruct hfs_find_data src_fd, dst_fd;\n\tunion hfs_cat_rec entry;\n\tint entry_size, type;\n\tint err;\n\n\thfs_dbg(CAT_MOD, \"rename_cat: %u - %lu,%s - %lu,%s\\n\",\n\t\tcnid, src_dir->i_ino, src_name->name,\n\t\tdst_dir->i_ino, dst_name->name);\n\tsb = src_dir->i_sb;\n\terr = hfs_find_init(HFS_SB(sb)->cat_tree, &src_fd);\n\tif (err)\n\t\treturn err;\n\tdst_fd = src_fd;\n\n\t/* find the old dir entry and read the data */\n\thfs_cat_build_key(sb, src_fd.search_key, src_dir->i_ino, src_name);\n\terr = hfs_brec_find(&src_fd);\n\tif (err)\n\t\tgoto out;\n\tif (src_fd.entrylength > sizeof(entry) || src_fd.entrylength < 0) {\n\t\terr = -EIO;\n\t\tgoto out;\n\t}\n\n\thfs_bnode_read(src_fd.bnode, &entry, src_fd.entryoffset,\n\t\t\t    src_fd.entrylength);\n\n\t/* create new dir entry with the data from the old entry */\n\thfs_cat_build_key(sb, dst_fd.search_key, dst_dir->i_ino, dst_name);\n\terr = hfs_brec_find(&dst_fd);\n\tif (err != -ENOENT) {\n\t\tif (!err)\n\t\t\terr = -EEXIST;\n\t\tgoto out;\n\t}\n\n\terr = hfs_brec_insert(&dst_fd, &entry, src_fd.entrylength);\n\tif (err)\n\t\tgoto out;\n\tdst_dir->i_size++;\n\tdst_dir->i_mtime = dst_dir->i_ctime = CURRENT_TIME_SEC;\n\tmark_inode_dirty(dst_dir);\n\n\t/* finally remove the old entry */\n\thfs_cat_build_key(sb, src_fd.search_key, src_dir->i_ino, src_name);\n\terr = hfs_brec_find(&src_fd);\n\tif (err)\n\t\tgoto out;\n\terr = hfs_brec_remove(&src_fd);\n\tif (err)\n\t\tgoto out;\n\tsrc_dir->i_size--;\n\tsrc_dir->i_mtime = src_dir->i_ctime = CURRENT_TIME_SEC;\n\tmark_inode_dirty(src_dir);\n\n\ttype = entry.type;\n\tif (type == HFS_CDR_FIL && !(entry.file.Flags & HFS_FIL_THD))\n\t\tgoto out;\n\n\t/* remove old thread entry */\n\thfs_cat_build_key(sb, src_fd.search_key, cnid, NULL);\n\terr = hfs_brec_find(&src_fd);\n\tif (err)\n\t\tgoto out;\n\terr = hfs_brec_remove(&src_fd);\n\tif (err)\n\t\tgoto out;\n\n\t/* create new thread entry */\n\thfs_cat_build_key(sb, dst_fd.search_key, cnid, NULL);\n\tentry_size = hfs_cat_build_thread(sb, &entry, type == HFS_CDR_FIL ? HFS_CDR_FTH : HFS_CDR_THD,\n\t\t\t\t\tdst_dir->i_ino, dst_name);\n\terr = hfs_brec_find(&dst_fd);\n\tif (err != -ENOENT) {\n\t\tif (!err)\n\t\t\terr = -EEXIST;\n\t\tgoto out;\n\t}\n\terr = hfs_brec_insert(&dst_fd, &entry, entry_size);\nout:\n\thfs_bnode_put(dst_fd.bnode);\n\thfs_find_exit(&src_fd);\n\treturn err;\n}",
    "includes": [
      "#include \"btree.h\"",
      "#include \"hfs_fs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "hfs_find_exit",
          "args": [
            "&src_fd"
          ],
          "line": 364
        },
        "resolved": true,
        "details": {
          "function_name": "hfs_find_exit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfs/bfind.c",
          "lines": "31-39",
          "snippet": "void hfs_find_exit(struct hfs_find_data *fd)\n{\n\thfs_bnode_put(fd->bnode);\n\tkfree(fd->search_key);\n\thfs_dbg(BNODE_REFS, \"find_exit: %d (%p)\\n\",\n\t\tfd->tree->cnid, __builtin_return_address(0));\n\tmutex_unlock(&fd->tree->tree_lock);\n\tfd->tree = NULL;\n}",
          "includes": [
            "#include \"btree.h\"",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"btree.h\"\n#include <linux/slab.h>\n\nvoid hfs_find_exit(struct hfs_find_data *fd)\n{\n\thfs_bnode_put(fd->bnode);\n\tkfree(fd->search_key);\n\thfs_dbg(BNODE_REFS, \"find_exit: %d (%p)\\n\",\n\t\tfd->tree->cnid, __builtin_return_address(0));\n\tmutex_unlock(&fd->tree->tree_lock);\n\tfd->tree = NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "hfs_bnode_put",
          "args": [
            "dst_fd.bnode"
          ],
          "line": 363
        },
        "resolved": true,
        "details": {
          "function_name": "hfs_bnode_put",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfs/bnode.c",
          "lines": "458-485",
          "snippet": "void hfs_bnode_put(struct hfs_bnode *node)\n{\n\tif (node) {\n\t\tstruct hfs_btree *tree = node->tree;\n\t\tint i;\n\n\t\thfs_dbg(BNODE_REFS, \"put_node(%d:%d): %d\\n\",\n\t\t\tnode->tree->cnid, node->this,\n\t\t\tatomic_read(&node->refcnt));\n\t\tBUG_ON(!atomic_read(&node->refcnt));\n\t\tif (!atomic_dec_and_lock(&node->refcnt, &tree->hash_lock))\n\t\t\treturn;\n\t\tfor (i = 0; i < tree->pages_per_bnode; i++) {\n\t\t\tif (!node->page[i])\n\t\t\t\tcontinue;\n\t\t\tmark_page_accessed(node->page[i]);\n\t\t}\n\n\t\tif (test_bit(HFS_BNODE_DELETED, &node->flags)) {\n\t\t\thfs_bnode_unhash(node);\n\t\t\tspin_unlock(&tree->hash_lock);\n\t\t\thfs_bmap_free(node);\n\t\t\thfs_bnode_free(node);\n\t\t\treturn;\n\t\t}\n\t\tspin_unlock(&tree->hash_lock);\n\t}\n}",
          "includes": [
            "#include \"btree.h\"",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"btree.h\"\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n\nvoid hfs_bnode_put(struct hfs_bnode *node)\n{\n\tif (node) {\n\t\tstruct hfs_btree *tree = node->tree;\n\t\tint i;\n\n\t\thfs_dbg(BNODE_REFS, \"put_node(%d:%d): %d\\n\",\n\t\t\tnode->tree->cnid, node->this,\n\t\t\tatomic_read(&node->refcnt));\n\t\tBUG_ON(!atomic_read(&node->refcnt));\n\t\tif (!atomic_dec_and_lock(&node->refcnt, &tree->hash_lock))\n\t\t\treturn;\n\t\tfor (i = 0; i < tree->pages_per_bnode; i++) {\n\t\t\tif (!node->page[i])\n\t\t\t\tcontinue;\n\t\t\tmark_page_accessed(node->page[i]);\n\t\t}\n\n\t\tif (test_bit(HFS_BNODE_DELETED, &node->flags)) {\n\t\t\thfs_bnode_unhash(node);\n\t\t\tspin_unlock(&tree->hash_lock);\n\t\t\thfs_bmap_free(node);\n\t\t\thfs_bnode_free(node);\n\t\t\treturn;\n\t\t}\n\t\tspin_unlock(&tree->hash_lock);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "hfs_brec_insert",
          "args": [
            "&dst_fd",
            "&entry",
            "entry_size"
          ],
          "line": 361
        },
        "resolved": true,
        "details": {
          "function_name": "hfs_brec_insert",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfs/brec.c",
          "lines": "64-173",
          "snippet": "int hfs_brec_insert(struct hfs_find_data *fd, void *entry, int entry_len)\n{\n\tstruct hfs_btree *tree;\n\tstruct hfs_bnode *node, *new_node;\n\tint size, key_len, rec;\n\tint data_off, end_off;\n\tint idx_rec_off, data_rec_off, end_rec_off;\n\t__be32 cnid;\n\n\ttree = fd->tree;\n\tif (!fd->bnode) {\n\t\tif (!tree->root)\n\t\t\thfs_btree_inc_height(tree);\n\t\tfd->bnode = hfs_bnode_find(tree, tree->leaf_head);\n\t\tif (IS_ERR(fd->bnode))\n\t\t\treturn PTR_ERR(fd->bnode);\n\t\tfd->record = -1;\n\t}\n\tnew_node = NULL;\n\tkey_len = (fd->search_key->key_len | 1) + 1;\nagain:\n\t/* new record idx and complete record size */\n\trec = fd->record + 1;\n\tsize = key_len + entry_len;\n\n\tnode = fd->bnode;\n\thfs_bnode_dump(node);\n\t/* get last offset */\n\tend_rec_off = tree->node_size - (node->num_recs + 1) * 2;\n\tend_off = hfs_bnode_read_u16(node, end_rec_off);\n\tend_rec_off -= 2;\n\thfs_dbg(BNODE_MOD, \"insert_rec: %d, %d, %d, %d\\n\",\n\t\trec, size, end_off, end_rec_off);\n\tif (size > end_rec_off - end_off) {\n\t\tif (new_node)\n\t\t\tpanic(\"not enough room!\\n\");\n\t\tnew_node = hfs_bnode_split(fd);\n\t\tif (IS_ERR(new_node))\n\t\t\treturn PTR_ERR(new_node);\n\t\tgoto again;\n\t}\n\tif (node->type == HFS_NODE_LEAF) {\n\t\ttree->leaf_count++;\n\t\tmark_inode_dirty(tree->inode);\n\t}\n\tnode->num_recs++;\n\t/* write new last offset */\n\thfs_bnode_write_u16(node, offsetof(struct hfs_bnode_desc, num_recs), node->num_recs);\n\thfs_bnode_write_u16(node, end_rec_off, end_off + size);\n\tdata_off = end_off;\n\tdata_rec_off = end_rec_off + 2;\n\tidx_rec_off = tree->node_size - (rec + 1) * 2;\n\tif (idx_rec_off == data_rec_off)\n\t\tgoto skip;\n\t/* move all following entries */\n\tdo {\n\t\tdata_off = hfs_bnode_read_u16(node, data_rec_off + 2);\n\t\thfs_bnode_write_u16(node, data_rec_off, data_off + size);\n\t\tdata_rec_off += 2;\n\t} while (data_rec_off < idx_rec_off);\n\n\t/* move data away */\n\thfs_bnode_move(node, data_off + size, data_off,\n\t\t       end_off - data_off);\n\nskip:\n\thfs_bnode_write(node, fd->search_key, data_off, key_len);\n\thfs_bnode_write(node, entry, data_off + key_len, entry_len);\n\thfs_bnode_dump(node);\n\n\tif (new_node) {\n\t\t/* update parent key if we inserted a key\n\t\t * at the start of the first node\n\t\t */\n\t\tif (!rec && new_node != node)\n\t\t\thfs_brec_update_parent(fd);\n\n\t\thfs_bnode_put(fd->bnode);\n\t\tif (!new_node->parent) {\n\t\t\thfs_btree_inc_height(tree);\n\t\t\tnew_node->parent = tree->root;\n\t\t}\n\t\tfd->bnode = hfs_bnode_find(tree, new_node->parent);\n\n\t\t/* create index data entry */\n\t\tcnid = cpu_to_be32(new_node->this);\n\t\tentry = &cnid;\n\t\tentry_len = sizeof(cnid);\n\n\t\t/* get index key */\n\t\thfs_bnode_read_key(new_node, fd->search_key, 14);\n\t\t__hfs_brec_find(fd->bnode, fd);\n\n\t\thfs_bnode_put(new_node);\n\t\tnew_node = NULL;\n\n\t\tif (tree->attributes & HFS_TREE_VARIDXKEYS)\n\t\t\tkey_len = fd->search_key->key_len + 1;\n\t\telse {\n\t\t\tfd->search_key->key_len = tree->max_key_len;\n\t\t\tkey_len = tree->max_key_len + 1;\n\t\t}\n\t\tgoto again;\n\t}\n\n\tif (!rec)\n\t\thfs_brec_update_parent(fd);\n\n\treturn 0;\n}",
          "includes": [
            "#include \"btree.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static struct hfs_bnode *hfs_bnode_split(struct hfs_find_data *fd);",
            "static int hfs_brec_update_parent(struct hfs_find_data *fd);",
            "static int hfs_btree_inc_height(struct hfs_btree *tree);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"btree.h\"\n\nstatic struct hfs_bnode *hfs_bnode_split(struct hfs_find_data *fd);\nstatic int hfs_brec_update_parent(struct hfs_find_data *fd);\nstatic int hfs_btree_inc_height(struct hfs_btree *tree);\n\nint hfs_brec_insert(struct hfs_find_data *fd, void *entry, int entry_len)\n{\n\tstruct hfs_btree *tree;\n\tstruct hfs_bnode *node, *new_node;\n\tint size, key_len, rec;\n\tint data_off, end_off;\n\tint idx_rec_off, data_rec_off, end_rec_off;\n\t__be32 cnid;\n\n\ttree = fd->tree;\n\tif (!fd->bnode) {\n\t\tif (!tree->root)\n\t\t\thfs_btree_inc_height(tree);\n\t\tfd->bnode = hfs_bnode_find(tree, tree->leaf_head);\n\t\tif (IS_ERR(fd->bnode))\n\t\t\treturn PTR_ERR(fd->bnode);\n\t\tfd->record = -1;\n\t}\n\tnew_node = NULL;\n\tkey_len = (fd->search_key->key_len | 1) + 1;\nagain:\n\t/* new record idx and complete record size */\n\trec = fd->record + 1;\n\tsize = key_len + entry_len;\n\n\tnode = fd->bnode;\n\thfs_bnode_dump(node);\n\t/* get last offset */\n\tend_rec_off = tree->node_size - (node->num_recs + 1) * 2;\n\tend_off = hfs_bnode_read_u16(node, end_rec_off);\n\tend_rec_off -= 2;\n\thfs_dbg(BNODE_MOD, \"insert_rec: %d, %d, %d, %d\\n\",\n\t\trec, size, end_off, end_rec_off);\n\tif (size > end_rec_off - end_off) {\n\t\tif (new_node)\n\t\t\tpanic(\"not enough room!\\n\");\n\t\tnew_node = hfs_bnode_split(fd);\n\t\tif (IS_ERR(new_node))\n\t\t\treturn PTR_ERR(new_node);\n\t\tgoto again;\n\t}\n\tif (node->type == HFS_NODE_LEAF) {\n\t\ttree->leaf_count++;\n\t\tmark_inode_dirty(tree->inode);\n\t}\n\tnode->num_recs++;\n\t/* write new last offset */\n\thfs_bnode_write_u16(node, offsetof(struct hfs_bnode_desc, num_recs), node->num_recs);\n\thfs_bnode_write_u16(node, end_rec_off, end_off + size);\n\tdata_off = end_off;\n\tdata_rec_off = end_rec_off + 2;\n\tidx_rec_off = tree->node_size - (rec + 1) * 2;\n\tif (idx_rec_off == data_rec_off)\n\t\tgoto skip;\n\t/* move all following entries */\n\tdo {\n\t\tdata_off = hfs_bnode_read_u16(node, data_rec_off + 2);\n\t\thfs_bnode_write_u16(node, data_rec_off, data_off + size);\n\t\tdata_rec_off += 2;\n\t} while (data_rec_off < idx_rec_off);\n\n\t/* move data away */\n\thfs_bnode_move(node, data_off + size, data_off,\n\t\t       end_off - data_off);\n\nskip:\n\thfs_bnode_write(node, fd->search_key, data_off, key_len);\n\thfs_bnode_write(node, entry, data_off + key_len, entry_len);\n\thfs_bnode_dump(node);\n\n\tif (new_node) {\n\t\t/* update parent key if we inserted a key\n\t\t * at the start of the first node\n\t\t */\n\t\tif (!rec && new_node != node)\n\t\t\thfs_brec_update_parent(fd);\n\n\t\thfs_bnode_put(fd->bnode);\n\t\tif (!new_node->parent) {\n\t\t\thfs_btree_inc_height(tree);\n\t\t\tnew_node->parent = tree->root;\n\t\t}\n\t\tfd->bnode = hfs_bnode_find(tree, new_node->parent);\n\n\t\t/* create index data entry */\n\t\tcnid = cpu_to_be32(new_node->this);\n\t\tentry = &cnid;\n\t\tentry_len = sizeof(cnid);\n\n\t\t/* get index key */\n\t\thfs_bnode_read_key(new_node, fd->search_key, 14);\n\t\t__hfs_brec_find(fd->bnode, fd);\n\n\t\thfs_bnode_put(new_node);\n\t\tnew_node = NULL;\n\n\t\tif (tree->attributes & HFS_TREE_VARIDXKEYS)\n\t\t\tkey_len = fd->search_key->key_len + 1;\n\t\telse {\n\t\t\tfd->search_key->key_len = tree->max_key_len;\n\t\t\tkey_len = tree->max_key_len + 1;\n\t\t}\n\t\tgoto again;\n\t}\n\n\tif (!rec)\n\t\thfs_brec_update_parent(fd);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "hfs_brec_find",
          "args": [
            "&dst_fd"
          ],
          "line": 355
        },
        "resolved": true,
        "details": {
          "function_name": "hfs_brec_find",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfs/bfind.c",
          "lines": "94-146",
          "snippet": "int hfs_brec_find(struct hfs_find_data *fd)\n{\n\tstruct hfs_btree *tree;\n\tstruct hfs_bnode *bnode;\n\tu32 nidx, parent;\n\t__be32 data;\n\tint height, res;\n\n\ttree = fd->tree;\n\tif (fd->bnode)\n\t\thfs_bnode_put(fd->bnode);\n\tfd->bnode = NULL;\n\tnidx = tree->root;\n\tif (!nidx)\n\t\treturn -ENOENT;\n\theight = tree->depth;\n\tres = 0;\n\tparent = 0;\n\tfor (;;) {\n\t\tbnode = hfs_bnode_find(tree, nidx);\n\t\tif (IS_ERR(bnode)) {\n\t\t\tres = PTR_ERR(bnode);\n\t\t\tbnode = NULL;\n\t\t\tbreak;\n\t\t}\n\t\tif (bnode->height != height)\n\t\t\tgoto invalid;\n\t\tif (bnode->type != (--height ? HFS_NODE_INDEX : HFS_NODE_LEAF))\n\t\t\tgoto invalid;\n\t\tbnode->parent = parent;\n\n\t\tres = __hfs_brec_find(bnode, fd);\n\t\tif (!height)\n\t\t\tbreak;\n\t\tif (fd->record < 0)\n\t\t\tgoto release;\n\n\t\tparent = nidx;\n\t\thfs_bnode_read(bnode, &data, fd->entryoffset, 4);\n\t\tnidx = be32_to_cpu(data);\n\t\thfs_bnode_put(bnode);\n\t}\n\tfd->bnode = bnode;\n\treturn res;\n\ninvalid:\n\tpr_err(\"inconsistency in B*Tree (%d,%d,%d,%u,%u)\\n\",\n\t       height, bnode->height, bnode->type, nidx, parent);\n\tres = -EIO;\nrelease:\n\thfs_bnode_put(bnode);\n\treturn res;\n}",
          "includes": [
            "#include \"btree.h\"",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"btree.h\"\n#include <linux/slab.h>\n\nint hfs_brec_find(struct hfs_find_data *fd)\n{\n\tstruct hfs_btree *tree;\n\tstruct hfs_bnode *bnode;\n\tu32 nidx, parent;\n\t__be32 data;\n\tint height, res;\n\n\ttree = fd->tree;\n\tif (fd->bnode)\n\t\thfs_bnode_put(fd->bnode);\n\tfd->bnode = NULL;\n\tnidx = tree->root;\n\tif (!nidx)\n\t\treturn -ENOENT;\n\theight = tree->depth;\n\tres = 0;\n\tparent = 0;\n\tfor (;;) {\n\t\tbnode = hfs_bnode_find(tree, nidx);\n\t\tif (IS_ERR(bnode)) {\n\t\t\tres = PTR_ERR(bnode);\n\t\t\tbnode = NULL;\n\t\t\tbreak;\n\t\t}\n\t\tif (bnode->height != height)\n\t\t\tgoto invalid;\n\t\tif (bnode->type != (--height ? HFS_NODE_INDEX : HFS_NODE_LEAF))\n\t\t\tgoto invalid;\n\t\tbnode->parent = parent;\n\n\t\tres = __hfs_brec_find(bnode, fd);\n\t\tif (!height)\n\t\t\tbreak;\n\t\tif (fd->record < 0)\n\t\t\tgoto release;\n\n\t\tparent = nidx;\n\t\thfs_bnode_read(bnode, &data, fd->entryoffset, 4);\n\t\tnidx = be32_to_cpu(data);\n\t\thfs_bnode_put(bnode);\n\t}\n\tfd->bnode = bnode;\n\treturn res;\n\ninvalid:\n\tpr_err(\"inconsistency in B*Tree (%d,%d,%d,%u,%u)\\n\",\n\t       height, bnode->height, bnode->type, nidx, parent);\n\tres = -EIO;\nrelease:\n\thfs_bnode_put(bnode);\n\treturn res;\n}"
        }
      },
      {
        "call_info": {
          "callee": "hfs_cat_build_thread",
          "args": [
            "sb",
            "&entry",
            "type == HFS_CDR_FIL ? HFS_CDR_FTH : HFS_CDR_THD",
            "dst_dir->i_ino",
            "dst_name"
          ],
          "line": 353
        },
        "resolved": true,
        "details": {
          "function_name": "hfs_cat_build_thread",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfs/catalog.c",
          "lines": "65-74",
          "snippet": "static int hfs_cat_build_thread(struct super_block *sb,\n\t\t\t\thfs_cat_rec *rec, int type,\n\t\t\t\tu32 parentid, struct qstr *name)\n{\n\trec->type = type;\n\tmemset(rec->thread.reserved, 0, sizeof(rec->thread.reserved));\n\trec->thread.ParID = cpu_to_be32(parentid);\n\thfs_asc2mac(sb, &rec->thread.CName, name);\n\treturn sizeof(struct hfs_cat_thread);\n}",
          "includes": [
            "#include \"btree.h\"",
            "#include \"hfs_fs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"btree.h\"\n#include \"hfs_fs.h\"\n\nstatic int hfs_cat_build_thread(struct super_block *sb,\n\t\t\t\thfs_cat_rec *rec, int type,\n\t\t\t\tu32 parentid, struct qstr *name)\n{\n\trec->type = type;\n\tmemset(rec->thread.reserved, 0, sizeof(rec->thread.reserved));\n\trec->thread.ParID = cpu_to_be32(parentid);\n\thfs_asc2mac(sb, &rec->thread.CName, name);\n\treturn sizeof(struct hfs_cat_thread);\n}"
        }
      },
      {
        "call_info": {
          "callee": "hfs_cat_build_key",
          "args": [
            "sb",
            "dst_fd.search_key",
            "cnid",
            "NULL"
          ],
          "line": 352
        },
        "resolved": true,
        "details": {
          "function_name": "hfs_cat_build_key",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfs/catalog.c",
          "lines": "23-34",
          "snippet": "void hfs_cat_build_key(struct super_block *sb, btree_key *key, u32 parent, struct qstr *name)\n{\n\tkey->cat.reserved = 0;\n\tkey->cat.ParID = cpu_to_be32(parent);\n\tif (name) {\n\t\thfs_asc2mac(sb, &key->cat.CName, name);\n\t\tkey->key_len = 6 + key->cat.CName.len;\n\t} else {\n\t\tmemset(&key->cat.CName, 0, sizeof(struct hfs_name));\n\t\tkey->key_len = 6;\n\t}\n}",
          "includes": [
            "#include \"btree.h\"",
            "#include \"hfs_fs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"btree.h\"\n#include \"hfs_fs.h\"\n\nvoid hfs_cat_build_key(struct super_block *sb, btree_key *key, u32 parent, struct qstr *name)\n{\n\tkey->cat.reserved = 0;\n\tkey->cat.ParID = cpu_to_be32(parent);\n\tif (name) {\n\t\thfs_asc2mac(sb, &key->cat.CName, name);\n\t\tkey->key_len = 6 + key->cat.CName.len;\n\t} else {\n\t\tmemset(&key->cat.CName, 0, sizeof(struct hfs_name));\n\t\tkey->key_len = 6;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "hfs_brec_remove",
          "args": [
            "&src_fd"
          ],
          "line": 347
        },
        "resolved": true,
        "details": {
          "function_name": "hfs_brec_remove",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfs/brec.c",
          "lines": "175-227",
          "snippet": "int hfs_brec_remove(struct hfs_find_data *fd)\n{\n\tstruct hfs_btree *tree;\n\tstruct hfs_bnode *node, *parent;\n\tint end_off, rec_off, data_off, size;\n\n\ttree = fd->tree;\n\tnode = fd->bnode;\nagain:\n\trec_off = tree->node_size - (fd->record + 2) * 2;\n\tend_off = tree->node_size - (node->num_recs + 1) * 2;\n\n\tif (node->type == HFS_NODE_LEAF) {\n\t\ttree->leaf_count--;\n\t\tmark_inode_dirty(tree->inode);\n\t}\n\thfs_bnode_dump(node);\n\thfs_dbg(BNODE_MOD, \"remove_rec: %d, %d\\n\",\n\t\tfd->record, fd->keylength + fd->entrylength);\n\tif (!--node->num_recs) {\n\t\thfs_bnode_unlink(node);\n\t\tif (!node->parent)\n\t\t\treturn 0;\n\t\tparent = hfs_bnode_find(tree, node->parent);\n\t\tif (IS_ERR(parent))\n\t\t\treturn PTR_ERR(parent);\n\t\thfs_bnode_put(node);\n\t\tnode = fd->bnode = parent;\n\n\t\t__hfs_brec_find(node, fd);\n\t\tgoto again;\n\t}\n\thfs_bnode_write_u16(node, offsetof(struct hfs_bnode_desc, num_recs), node->num_recs);\n\n\tif (rec_off == end_off)\n\t\tgoto skip;\n\tsize = fd->keylength + fd->entrylength;\n\n\tdo {\n\t\tdata_off = hfs_bnode_read_u16(node, rec_off);\n\t\thfs_bnode_write_u16(node, rec_off + 2, data_off - size);\n\t\trec_off -= 2;\n\t} while (rec_off >= end_off);\n\n\t/* fill hole */\n\thfs_bnode_move(node, fd->keyoffset, fd->keyoffset + size,\n\t\t       data_off - fd->keyoffset - size);\nskip:\n\thfs_bnode_dump(node);\n\tif (!fd->record)\n\t\thfs_brec_update_parent(fd);\n\treturn 0;\n}",
          "includes": [
            "#include \"btree.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static struct hfs_bnode *hfs_bnode_split(struct hfs_find_data *fd);",
            "static int hfs_brec_update_parent(struct hfs_find_data *fd);",
            "static int hfs_btree_inc_height(struct hfs_btree *tree);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"btree.h\"\n\nstatic struct hfs_bnode *hfs_bnode_split(struct hfs_find_data *fd);\nstatic int hfs_brec_update_parent(struct hfs_find_data *fd);\nstatic int hfs_btree_inc_height(struct hfs_btree *tree);\n\nint hfs_brec_remove(struct hfs_find_data *fd)\n{\n\tstruct hfs_btree *tree;\n\tstruct hfs_bnode *node, *parent;\n\tint end_off, rec_off, data_off, size;\n\n\ttree = fd->tree;\n\tnode = fd->bnode;\nagain:\n\trec_off = tree->node_size - (fd->record + 2) * 2;\n\tend_off = tree->node_size - (node->num_recs + 1) * 2;\n\n\tif (node->type == HFS_NODE_LEAF) {\n\t\ttree->leaf_count--;\n\t\tmark_inode_dirty(tree->inode);\n\t}\n\thfs_bnode_dump(node);\n\thfs_dbg(BNODE_MOD, \"remove_rec: %d, %d\\n\",\n\t\tfd->record, fd->keylength + fd->entrylength);\n\tif (!--node->num_recs) {\n\t\thfs_bnode_unlink(node);\n\t\tif (!node->parent)\n\t\t\treturn 0;\n\t\tparent = hfs_bnode_find(tree, node->parent);\n\t\tif (IS_ERR(parent))\n\t\t\treturn PTR_ERR(parent);\n\t\thfs_bnode_put(node);\n\t\tnode = fd->bnode = parent;\n\n\t\t__hfs_brec_find(node, fd);\n\t\tgoto again;\n\t}\n\thfs_bnode_write_u16(node, offsetof(struct hfs_bnode_desc, num_recs), node->num_recs);\n\n\tif (rec_off == end_off)\n\t\tgoto skip;\n\tsize = fd->keylength + fd->entrylength;\n\n\tdo {\n\t\tdata_off = hfs_bnode_read_u16(node, rec_off);\n\t\thfs_bnode_write_u16(node, rec_off + 2, data_off - size);\n\t\trec_off -= 2;\n\t} while (rec_off >= end_off);\n\n\t/* fill hole */\n\thfs_bnode_move(node, fd->keyoffset, fd->keyoffset + size,\n\t\t       data_off - fd->keyoffset - size);\nskip:\n\thfs_bnode_dump(node);\n\tif (!fd->record)\n\t\thfs_brec_update_parent(fd);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mark_inode_dirty",
          "args": [
            "src_dir"
          ],
          "line": 336
        },
        "resolved": true,
        "details": {
          "function_name": "block_dump___mark_inode_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fs-writeback.c",
          "lines": "1134-1154",
          "snippet": "static noinline void block_dump___mark_inode_dirty(struct inode *inode)\n{\n\tif (inode->i_ino || strcmp(inode->i_sb->s_id, \"bdev\")) {\n\t\tstruct dentry *dentry;\n\t\tconst char *name = \"?\";\n\n\t\tdentry = d_find_alias(inode);\n\t\tif (dentry) {\n\t\t\tspin_lock(&dentry->d_lock);\n\t\t\tname = (const char *) dentry->d_name.name;\n\t\t}\n\t\tprintk(KERN_DEBUG\n\t\t       \"%s(%d): dirtied inode %lu (%s) on %s\\n\",\n\t\t       current->comm, task_pid_nr(current), inode->i_ino,\n\t\t       name, inode->i_sb->s_id);\n\t\tif (dentry) {\n\t\t\tspin_unlock(&dentry->d_lock);\n\t\t\tdput(dentry);\n\t\t}\n\t}\n}",
          "includes": [
            "#include <trace/events/writeback.h>",
            "#include \"internal.h\"",
            "#include <linux/device.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/writeback.h>\n#include \"internal.h\"\n#include <linux/device.h>\n#include <linux/tracepoint.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nstatic noinline void block_dump___mark_inode_dirty(struct inode *inode)\n{\n\tif (inode->i_ino || strcmp(inode->i_sb->s_id, \"bdev\")) {\n\t\tstruct dentry *dentry;\n\t\tconst char *name = \"?\";\n\n\t\tdentry = d_find_alias(inode);\n\t\tif (dentry) {\n\t\t\tspin_lock(&dentry->d_lock);\n\t\t\tname = (const char *) dentry->d_name.name;\n\t\t}\n\t\tprintk(KERN_DEBUG\n\t\t       \"%s(%d): dirtied inode %lu (%s) on %s\\n\",\n\t\t       current->comm, task_pid_nr(current), inode->i_ino,\n\t\t       name, inode->i_sb->s_id);\n\t\tif (dentry) {\n\t\t\tspin_unlock(&dentry->d_lock);\n\t\t\tdput(dentry);\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "hfs_bnode_read",
          "args": [
            "src_fd.bnode",
            "&entry",
            "src_fd.entryoffset",
            "src_fd.entrylength"
          ],
          "line": 307
        },
        "resolved": true,
        "details": {
          "function_name": "hfs_bnode_read",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfs/bnode.c",
          "lines": "17-27",
          "snippet": "void hfs_bnode_read(struct hfs_bnode *node, void *buf,\n\t\tint off, int len)\n{\n\tstruct page *page;\n\n\toff += node->page_offset;\n\tpage = node->page[0];\n\n\tmemcpy(buf, kmap(page) + off, len);\n\tkunmap(page);\n}",
          "includes": [
            "#include \"btree.h\"",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"btree.h\"\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n\nvoid hfs_bnode_read(struct hfs_bnode *node, void *buf,\n\t\tint off, int len)\n{\n\tstruct page *page;\n\n\toff += node->page_offset;\n\tpage = node->page[0];\n\n\tmemcpy(buf, kmap(page) + off, len);\n\tkunmap(page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "hfs_find_init",
          "args": [
            "HFS_SB(sb)->cat_tree",
            "&src_fd"
          ],
          "line": 292
        },
        "resolved": true,
        "details": {
          "function_name": "hfs_find_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfs/bfind.c",
          "lines": "14-29",
          "snippet": "int hfs_find_init(struct hfs_btree *tree, struct hfs_find_data *fd)\n{\n\tvoid *ptr;\n\n\tfd->tree = tree;\n\tfd->bnode = NULL;\n\tptr = kmalloc(tree->max_key_len * 2 + 4, GFP_KERNEL);\n\tif (!ptr)\n\t\treturn -ENOMEM;\n\tfd->search_key = ptr;\n\tfd->key = ptr + tree->max_key_len + 2;\n\thfs_dbg(BNODE_REFS, \"find_init: %d (%p)\\n\",\n\t\ttree->cnid, __builtin_return_address(0));\n\tmutex_lock(&tree->tree_lock);\n\treturn 0;\n}",
          "includes": [
            "#include \"btree.h\"",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"btree.h\"\n#include <linux/slab.h>\n\nint hfs_find_init(struct hfs_btree *tree, struct hfs_find_data *fd)\n{\n\tvoid *ptr;\n\n\tfd->tree = tree;\n\tfd->bnode = NULL;\n\tptr = kmalloc(tree->max_key_len * 2 + 4, GFP_KERNEL);\n\tif (!ptr)\n\t\treturn -ENOMEM;\n\tfd->search_key = ptr;\n\tfd->key = ptr + tree->max_key_len + 2;\n\thfs_dbg(BNODE_REFS, \"find_init: %d (%p)\\n\",\n\t\ttree->cnid, __builtin_return_address(0));\n\tmutex_lock(&tree->tree_lock);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "HFS_SB",
          "args": [
            "sb"
          ],
          "line": 292
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hfs_dbg",
          "args": [
            "CAT_MOD",
            "\"rename_cat: %u - %lu,%s - %lu,%s\\n\"",
            "cnid",
            "src_dir->i_ino",
            "src_name->name",
            "dst_dir->i_ino",
            "dst_name->name"
          ],
          "line": 288
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"btree.h\"\n#include \"hfs_fs.h\"\n\nint hfs_cat_move(u32 cnid, struct inode *src_dir, struct qstr *src_name,\n\t\t struct inode *dst_dir, struct qstr *dst_name)\n{\n\tstruct super_block *sb;\n\tstruct hfs_find_data src_fd, dst_fd;\n\tunion hfs_cat_rec entry;\n\tint entry_size, type;\n\tint err;\n\n\thfs_dbg(CAT_MOD, \"rename_cat: %u - %lu,%s - %lu,%s\\n\",\n\t\tcnid, src_dir->i_ino, src_name->name,\n\t\tdst_dir->i_ino, dst_name->name);\n\tsb = src_dir->i_sb;\n\terr = hfs_find_init(HFS_SB(sb)->cat_tree, &src_fd);\n\tif (err)\n\t\treturn err;\n\tdst_fd = src_fd;\n\n\t/* find the old dir entry and read the data */\n\thfs_cat_build_key(sb, src_fd.search_key, src_dir->i_ino, src_name);\n\terr = hfs_brec_find(&src_fd);\n\tif (err)\n\t\tgoto out;\n\tif (src_fd.entrylength > sizeof(entry) || src_fd.entrylength < 0) {\n\t\terr = -EIO;\n\t\tgoto out;\n\t}\n\n\thfs_bnode_read(src_fd.bnode, &entry, src_fd.entryoffset,\n\t\t\t    src_fd.entrylength);\n\n\t/* create new dir entry with the data from the old entry */\n\thfs_cat_build_key(sb, dst_fd.search_key, dst_dir->i_ino, dst_name);\n\terr = hfs_brec_find(&dst_fd);\n\tif (err != -ENOENT) {\n\t\tif (!err)\n\t\t\terr = -EEXIST;\n\t\tgoto out;\n\t}\n\n\terr = hfs_brec_insert(&dst_fd, &entry, src_fd.entrylength);\n\tif (err)\n\t\tgoto out;\n\tdst_dir->i_size++;\n\tdst_dir->i_mtime = dst_dir->i_ctime = CURRENT_TIME_SEC;\n\tmark_inode_dirty(dst_dir);\n\n\t/* finally remove the old entry */\n\thfs_cat_build_key(sb, src_fd.search_key, src_dir->i_ino, src_name);\n\terr = hfs_brec_find(&src_fd);\n\tif (err)\n\t\tgoto out;\n\terr = hfs_brec_remove(&src_fd);\n\tif (err)\n\t\tgoto out;\n\tsrc_dir->i_size--;\n\tsrc_dir->i_mtime = src_dir->i_ctime = CURRENT_TIME_SEC;\n\tmark_inode_dirty(src_dir);\n\n\ttype = entry.type;\n\tif (type == HFS_CDR_FIL && !(entry.file.Flags & HFS_FIL_THD))\n\t\tgoto out;\n\n\t/* remove old thread entry */\n\thfs_cat_build_key(sb, src_fd.search_key, cnid, NULL);\n\terr = hfs_brec_find(&src_fd);\n\tif (err)\n\t\tgoto out;\n\terr = hfs_brec_remove(&src_fd);\n\tif (err)\n\t\tgoto out;\n\n\t/* create new thread entry */\n\thfs_cat_build_key(sb, dst_fd.search_key, cnid, NULL);\n\tentry_size = hfs_cat_build_thread(sb, &entry, type == HFS_CDR_FIL ? HFS_CDR_FTH : HFS_CDR_THD,\n\t\t\t\t\tdst_dir->i_ino, dst_name);\n\terr = hfs_brec_find(&dst_fd);\n\tif (err != -ENOENT) {\n\t\tif (!err)\n\t\t\terr = -EEXIST;\n\t\tgoto out;\n\t}\n\terr = hfs_brec_insert(&dst_fd, &entry, entry_size);\nout:\n\thfs_bnode_put(dst_fd.bnode);\n\thfs_find_exit(&src_fd);\n\treturn err;\n}"
  },
  {
    "function_name": "hfs_cat_delete",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfs/catalog.c",
    "lines": "213-270",
    "snippet": "int hfs_cat_delete(u32 cnid, struct inode *dir, struct qstr *str)\n{\n\tstruct super_block *sb;\n\tstruct hfs_find_data fd;\n\tstruct list_head *pos;\n\tint res, type;\n\n\thfs_dbg(CAT_MOD, \"delete_cat: %s,%u\\n\", str ? str->name : NULL, cnid);\n\tsb = dir->i_sb;\n\tres = hfs_find_init(HFS_SB(sb)->cat_tree, &fd);\n\tif (res)\n\t\treturn res;\n\n\thfs_cat_build_key(sb, fd.search_key, dir->i_ino, str);\n\tres = hfs_brec_find(&fd);\n\tif (res)\n\t\tgoto out;\n\n\ttype = hfs_bnode_read_u8(fd.bnode, fd.entryoffset);\n\tif (type == HFS_CDR_FIL) {\n\t\tstruct hfs_cat_file file;\n\t\thfs_bnode_read(fd.bnode, &file, fd.entryoffset, sizeof(file));\n\t\tif (be32_to_cpu(file.FlNum) == cnid) {\n#if 0\n\t\t\thfs_free_fork(sb, &file, HFS_FK_DATA);\n#endif\n\t\t\thfs_free_fork(sb, &file, HFS_FK_RSRC);\n\t\t}\n\t}\n\n\tlist_for_each(pos, &HFS_I(dir)->open_dir_list) {\n\t\tstruct hfs_readdir_data *rd =\n\t\t\tlist_entry(pos, struct hfs_readdir_data, list);\n\t\tif (fd.tree->keycmp(fd.search_key, (void *)&rd->key) < 0)\n\t\t\trd->file->f_pos--;\n\t}\n\n\tres = hfs_brec_remove(&fd);\n\tif (res)\n\t\tgoto out;\n\n\thfs_cat_build_key(sb, fd.search_key, cnid, NULL);\n\tres = hfs_brec_find(&fd);\n\tif (!res) {\n\t\tres = hfs_brec_remove(&fd);\n\t\tif (res)\n\t\t\tgoto out;\n\t}\n\n\tdir->i_size--;\n\tdir->i_mtime = dir->i_ctime = CURRENT_TIME_SEC;\n\tmark_inode_dirty(dir);\n\tres = 0;\nout:\n\thfs_find_exit(&fd);\n\n\treturn res;\n}",
    "includes": [
      "#include \"btree.h\"",
      "#include \"hfs_fs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "hfs_find_exit",
          "args": [
            "&fd"
          ],
          "line": 267
        },
        "resolved": true,
        "details": {
          "function_name": "hfs_find_exit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfs/bfind.c",
          "lines": "31-39",
          "snippet": "void hfs_find_exit(struct hfs_find_data *fd)\n{\n\thfs_bnode_put(fd->bnode);\n\tkfree(fd->search_key);\n\thfs_dbg(BNODE_REFS, \"find_exit: %d (%p)\\n\",\n\t\tfd->tree->cnid, __builtin_return_address(0));\n\tmutex_unlock(&fd->tree->tree_lock);\n\tfd->tree = NULL;\n}",
          "includes": [
            "#include \"btree.h\"",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"btree.h\"\n#include <linux/slab.h>\n\nvoid hfs_find_exit(struct hfs_find_data *fd)\n{\n\thfs_bnode_put(fd->bnode);\n\tkfree(fd->search_key);\n\thfs_dbg(BNODE_REFS, \"find_exit: %d (%p)\\n\",\n\t\tfd->tree->cnid, __builtin_return_address(0));\n\tmutex_unlock(&fd->tree->tree_lock);\n\tfd->tree = NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mark_inode_dirty",
          "args": [
            "dir"
          ],
          "line": 264
        },
        "resolved": true,
        "details": {
          "function_name": "block_dump___mark_inode_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fs-writeback.c",
          "lines": "1134-1154",
          "snippet": "static noinline void block_dump___mark_inode_dirty(struct inode *inode)\n{\n\tif (inode->i_ino || strcmp(inode->i_sb->s_id, \"bdev\")) {\n\t\tstruct dentry *dentry;\n\t\tconst char *name = \"?\";\n\n\t\tdentry = d_find_alias(inode);\n\t\tif (dentry) {\n\t\t\tspin_lock(&dentry->d_lock);\n\t\t\tname = (const char *) dentry->d_name.name;\n\t\t}\n\t\tprintk(KERN_DEBUG\n\t\t       \"%s(%d): dirtied inode %lu (%s) on %s\\n\",\n\t\t       current->comm, task_pid_nr(current), inode->i_ino,\n\t\t       name, inode->i_sb->s_id);\n\t\tif (dentry) {\n\t\t\tspin_unlock(&dentry->d_lock);\n\t\t\tdput(dentry);\n\t\t}\n\t}\n}",
          "includes": [
            "#include <trace/events/writeback.h>",
            "#include \"internal.h\"",
            "#include <linux/device.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/writeback.h>\n#include \"internal.h\"\n#include <linux/device.h>\n#include <linux/tracepoint.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nstatic noinline void block_dump___mark_inode_dirty(struct inode *inode)\n{\n\tif (inode->i_ino || strcmp(inode->i_sb->s_id, \"bdev\")) {\n\t\tstruct dentry *dentry;\n\t\tconst char *name = \"?\";\n\n\t\tdentry = d_find_alias(inode);\n\t\tif (dentry) {\n\t\t\tspin_lock(&dentry->d_lock);\n\t\t\tname = (const char *) dentry->d_name.name;\n\t\t}\n\t\tprintk(KERN_DEBUG\n\t\t       \"%s(%d): dirtied inode %lu (%s) on %s\\n\",\n\t\t       current->comm, task_pid_nr(current), inode->i_ino,\n\t\t       name, inode->i_sb->s_id);\n\t\tif (dentry) {\n\t\t\tspin_unlock(&dentry->d_lock);\n\t\t\tdput(dentry);\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "hfs_brec_remove",
          "args": [
            "&fd"
          ],
          "line": 257
        },
        "resolved": true,
        "details": {
          "function_name": "hfs_brec_remove",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfs/brec.c",
          "lines": "175-227",
          "snippet": "int hfs_brec_remove(struct hfs_find_data *fd)\n{\n\tstruct hfs_btree *tree;\n\tstruct hfs_bnode *node, *parent;\n\tint end_off, rec_off, data_off, size;\n\n\ttree = fd->tree;\n\tnode = fd->bnode;\nagain:\n\trec_off = tree->node_size - (fd->record + 2) * 2;\n\tend_off = tree->node_size - (node->num_recs + 1) * 2;\n\n\tif (node->type == HFS_NODE_LEAF) {\n\t\ttree->leaf_count--;\n\t\tmark_inode_dirty(tree->inode);\n\t}\n\thfs_bnode_dump(node);\n\thfs_dbg(BNODE_MOD, \"remove_rec: %d, %d\\n\",\n\t\tfd->record, fd->keylength + fd->entrylength);\n\tif (!--node->num_recs) {\n\t\thfs_bnode_unlink(node);\n\t\tif (!node->parent)\n\t\t\treturn 0;\n\t\tparent = hfs_bnode_find(tree, node->parent);\n\t\tif (IS_ERR(parent))\n\t\t\treturn PTR_ERR(parent);\n\t\thfs_bnode_put(node);\n\t\tnode = fd->bnode = parent;\n\n\t\t__hfs_brec_find(node, fd);\n\t\tgoto again;\n\t}\n\thfs_bnode_write_u16(node, offsetof(struct hfs_bnode_desc, num_recs), node->num_recs);\n\n\tif (rec_off == end_off)\n\t\tgoto skip;\n\tsize = fd->keylength + fd->entrylength;\n\n\tdo {\n\t\tdata_off = hfs_bnode_read_u16(node, rec_off);\n\t\thfs_bnode_write_u16(node, rec_off + 2, data_off - size);\n\t\trec_off -= 2;\n\t} while (rec_off >= end_off);\n\n\t/* fill hole */\n\thfs_bnode_move(node, fd->keyoffset, fd->keyoffset + size,\n\t\t       data_off - fd->keyoffset - size);\nskip:\n\thfs_bnode_dump(node);\n\tif (!fd->record)\n\t\thfs_brec_update_parent(fd);\n\treturn 0;\n}",
          "includes": [
            "#include \"btree.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static struct hfs_bnode *hfs_bnode_split(struct hfs_find_data *fd);",
            "static int hfs_brec_update_parent(struct hfs_find_data *fd);",
            "static int hfs_btree_inc_height(struct hfs_btree *tree);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"btree.h\"\n\nstatic struct hfs_bnode *hfs_bnode_split(struct hfs_find_data *fd);\nstatic int hfs_brec_update_parent(struct hfs_find_data *fd);\nstatic int hfs_btree_inc_height(struct hfs_btree *tree);\n\nint hfs_brec_remove(struct hfs_find_data *fd)\n{\n\tstruct hfs_btree *tree;\n\tstruct hfs_bnode *node, *parent;\n\tint end_off, rec_off, data_off, size;\n\n\ttree = fd->tree;\n\tnode = fd->bnode;\nagain:\n\trec_off = tree->node_size - (fd->record + 2) * 2;\n\tend_off = tree->node_size - (node->num_recs + 1) * 2;\n\n\tif (node->type == HFS_NODE_LEAF) {\n\t\ttree->leaf_count--;\n\t\tmark_inode_dirty(tree->inode);\n\t}\n\thfs_bnode_dump(node);\n\thfs_dbg(BNODE_MOD, \"remove_rec: %d, %d\\n\",\n\t\tfd->record, fd->keylength + fd->entrylength);\n\tif (!--node->num_recs) {\n\t\thfs_bnode_unlink(node);\n\t\tif (!node->parent)\n\t\t\treturn 0;\n\t\tparent = hfs_bnode_find(tree, node->parent);\n\t\tif (IS_ERR(parent))\n\t\t\treturn PTR_ERR(parent);\n\t\thfs_bnode_put(node);\n\t\tnode = fd->bnode = parent;\n\n\t\t__hfs_brec_find(node, fd);\n\t\tgoto again;\n\t}\n\thfs_bnode_write_u16(node, offsetof(struct hfs_bnode_desc, num_recs), node->num_recs);\n\n\tif (rec_off == end_off)\n\t\tgoto skip;\n\tsize = fd->keylength + fd->entrylength;\n\n\tdo {\n\t\tdata_off = hfs_bnode_read_u16(node, rec_off);\n\t\thfs_bnode_write_u16(node, rec_off + 2, data_off - size);\n\t\trec_off -= 2;\n\t} while (rec_off >= end_off);\n\n\t/* fill hole */\n\thfs_bnode_move(node, fd->keyoffset, fd->keyoffset + size,\n\t\t       data_off - fd->keyoffset - size);\nskip:\n\thfs_bnode_dump(node);\n\tif (!fd->record)\n\t\thfs_brec_update_parent(fd);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "hfs_brec_find",
          "args": [
            "&fd"
          ],
          "line": 255
        },
        "resolved": true,
        "details": {
          "function_name": "hfs_brec_find",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfs/bfind.c",
          "lines": "94-146",
          "snippet": "int hfs_brec_find(struct hfs_find_data *fd)\n{\n\tstruct hfs_btree *tree;\n\tstruct hfs_bnode *bnode;\n\tu32 nidx, parent;\n\t__be32 data;\n\tint height, res;\n\n\ttree = fd->tree;\n\tif (fd->bnode)\n\t\thfs_bnode_put(fd->bnode);\n\tfd->bnode = NULL;\n\tnidx = tree->root;\n\tif (!nidx)\n\t\treturn -ENOENT;\n\theight = tree->depth;\n\tres = 0;\n\tparent = 0;\n\tfor (;;) {\n\t\tbnode = hfs_bnode_find(tree, nidx);\n\t\tif (IS_ERR(bnode)) {\n\t\t\tres = PTR_ERR(bnode);\n\t\t\tbnode = NULL;\n\t\t\tbreak;\n\t\t}\n\t\tif (bnode->height != height)\n\t\t\tgoto invalid;\n\t\tif (bnode->type != (--height ? HFS_NODE_INDEX : HFS_NODE_LEAF))\n\t\t\tgoto invalid;\n\t\tbnode->parent = parent;\n\n\t\tres = __hfs_brec_find(bnode, fd);\n\t\tif (!height)\n\t\t\tbreak;\n\t\tif (fd->record < 0)\n\t\t\tgoto release;\n\n\t\tparent = nidx;\n\t\thfs_bnode_read(bnode, &data, fd->entryoffset, 4);\n\t\tnidx = be32_to_cpu(data);\n\t\thfs_bnode_put(bnode);\n\t}\n\tfd->bnode = bnode;\n\treturn res;\n\ninvalid:\n\tpr_err(\"inconsistency in B*Tree (%d,%d,%d,%u,%u)\\n\",\n\t       height, bnode->height, bnode->type, nidx, parent);\n\tres = -EIO;\nrelease:\n\thfs_bnode_put(bnode);\n\treturn res;\n}",
          "includes": [
            "#include \"btree.h\"",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"btree.h\"\n#include <linux/slab.h>\n\nint hfs_brec_find(struct hfs_find_data *fd)\n{\n\tstruct hfs_btree *tree;\n\tstruct hfs_bnode *bnode;\n\tu32 nidx, parent;\n\t__be32 data;\n\tint height, res;\n\n\ttree = fd->tree;\n\tif (fd->bnode)\n\t\thfs_bnode_put(fd->bnode);\n\tfd->bnode = NULL;\n\tnidx = tree->root;\n\tif (!nidx)\n\t\treturn -ENOENT;\n\theight = tree->depth;\n\tres = 0;\n\tparent = 0;\n\tfor (;;) {\n\t\tbnode = hfs_bnode_find(tree, nidx);\n\t\tif (IS_ERR(bnode)) {\n\t\t\tres = PTR_ERR(bnode);\n\t\t\tbnode = NULL;\n\t\t\tbreak;\n\t\t}\n\t\tif (bnode->height != height)\n\t\t\tgoto invalid;\n\t\tif (bnode->type != (--height ? HFS_NODE_INDEX : HFS_NODE_LEAF))\n\t\t\tgoto invalid;\n\t\tbnode->parent = parent;\n\n\t\tres = __hfs_brec_find(bnode, fd);\n\t\tif (!height)\n\t\t\tbreak;\n\t\tif (fd->record < 0)\n\t\t\tgoto release;\n\n\t\tparent = nidx;\n\t\thfs_bnode_read(bnode, &data, fd->entryoffset, 4);\n\t\tnidx = be32_to_cpu(data);\n\t\thfs_bnode_put(bnode);\n\t}\n\tfd->bnode = bnode;\n\treturn res;\n\ninvalid:\n\tpr_err(\"inconsistency in B*Tree (%d,%d,%d,%u,%u)\\n\",\n\t       height, bnode->height, bnode->type, nidx, parent);\n\tres = -EIO;\nrelease:\n\thfs_bnode_put(bnode);\n\treturn res;\n}"
        }
      },
      {
        "call_info": {
          "callee": "hfs_cat_build_key",
          "args": [
            "sb",
            "fd.search_key",
            "cnid",
            "NULL"
          ],
          "line": 254
        },
        "resolved": true,
        "details": {
          "function_name": "hfs_cat_build_key",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfs/catalog.c",
          "lines": "23-34",
          "snippet": "void hfs_cat_build_key(struct super_block *sb, btree_key *key, u32 parent, struct qstr *name)\n{\n\tkey->cat.reserved = 0;\n\tkey->cat.ParID = cpu_to_be32(parent);\n\tif (name) {\n\t\thfs_asc2mac(sb, &key->cat.CName, name);\n\t\tkey->key_len = 6 + key->cat.CName.len;\n\t} else {\n\t\tmemset(&key->cat.CName, 0, sizeof(struct hfs_name));\n\t\tkey->key_len = 6;\n\t}\n}",
          "includes": [
            "#include \"btree.h\"",
            "#include \"hfs_fs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"btree.h\"\n#include \"hfs_fs.h\"\n\nvoid hfs_cat_build_key(struct super_block *sb, btree_key *key, u32 parent, struct qstr *name)\n{\n\tkey->cat.reserved = 0;\n\tkey->cat.ParID = cpu_to_be32(parent);\n\tif (name) {\n\t\thfs_asc2mac(sb, &key->cat.CName, name);\n\t\tkey->key_len = 6 + key->cat.CName.len;\n\t} else {\n\t\tmemset(&key->cat.CName, 0, sizeof(struct hfs_name));\n\t\tkey->key_len = 6;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "fd.tree->keycmp",
          "args": [
            "fd.search_key",
            "(void *)&rd->key"
          ],
          "line": 246
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_entry",
          "args": [
            "pos",
            "structhfs_readdir_data",
            "list"
          ],
          "line": 245
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each",
          "args": [
            "pos",
            "&HFS_I(dir)->open_dir_list"
          ],
          "line": 243
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HFS_I",
          "args": [
            "dir"
          ],
          "line": 243
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hfs_free_fork",
          "args": [
            "sb",
            "&file",
            "HFS_FK_RSRC"
          ],
          "line": 239
        },
        "resolved": true,
        "details": {
          "function_name": "hfs_free_fork",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfs/extent.c",
          "lines": "283-327",
          "snippet": "int hfs_free_fork(struct super_block *sb, struct hfs_cat_file *file, int type)\n{\n\tstruct hfs_find_data fd;\n\tu32 total_blocks, blocks, start;\n\tu32 cnid = be32_to_cpu(file->FlNum);\n\tstruct hfs_extent *extent;\n\tint res, i;\n\n\tif (type == HFS_FK_DATA) {\n\t\ttotal_blocks = be32_to_cpu(file->PyLen);\n\t\textent = file->ExtRec;\n\t} else {\n\t\ttotal_blocks = be32_to_cpu(file->RPyLen);\n\t\textent = file->RExtRec;\n\t}\n\ttotal_blocks /= HFS_SB(sb)->alloc_blksz;\n\tif (!total_blocks)\n\t\treturn 0;\n\n\tblocks = 0;\n\tfor (i = 0; i < 3; extent++, i++)\n\t\tblocks += be16_to_cpu(extent[i].count);\n\n\tres = hfs_free_extents(sb, extent, blocks, blocks);\n\tif (res)\n\t\treturn res;\n\tif (total_blocks == blocks)\n\t\treturn 0;\n\n\tres = hfs_find_init(HFS_SB(sb)->ext_tree, &fd);\n\tif (res)\n\t\treturn res;\n\tdo {\n\t\tres = __hfs_ext_read_extent(&fd, extent, cnid, total_blocks, type);\n\t\tif (res)\n\t\t\tbreak;\n\t\tstart = be16_to_cpu(fd.key->ext.FABN);\n\t\thfs_free_extents(sb, extent, total_blocks - start, total_blocks);\n\t\thfs_brec_remove(&fd);\n\t\ttotal_blocks = start;\n\t} while (total_blocks > blocks);\n\thfs_find_exit(&fd);\n\n\treturn res;\n}",
          "includes": [
            "#include \"btree.h\"",
            "#include \"hfs_fs.h\"",
            "#include <linux/pagemap.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"btree.h\"\n#include \"hfs_fs.h\"\n#include <linux/pagemap.h>\n\nint hfs_free_fork(struct super_block *sb, struct hfs_cat_file *file, int type)\n{\n\tstruct hfs_find_data fd;\n\tu32 total_blocks, blocks, start;\n\tu32 cnid = be32_to_cpu(file->FlNum);\n\tstruct hfs_extent *extent;\n\tint res, i;\n\n\tif (type == HFS_FK_DATA) {\n\t\ttotal_blocks = be32_to_cpu(file->PyLen);\n\t\textent = file->ExtRec;\n\t} else {\n\t\ttotal_blocks = be32_to_cpu(file->RPyLen);\n\t\textent = file->RExtRec;\n\t}\n\ttotal_blocks /= HFS_SB(sb)->alloc_blksz;\n\tif (!total_blocks)\n\t\treturn 0;\n\n\tblocks = 0;\n\tfor (i = 0; i < 3; extent++, i++)\n\t\tblocks += be16_to_cpu(extent[i].count);\n\n\tres = hfs_free_extents(sb, extent, blocks, blocks);\n\tif (res)\n\t\treturn res;\n\tif (total_blocks == blocks)\n\t\treturn 0;\n\n\tres = hfs_find_init(HFS_SB(sb)->ext_tree, &fd);\n\tif (res)\n\t\treturn res;\n\tdo {\n\t\tres = __hfs_ext_read_extent(&fd, extent, cnid, total_blocks, type);\n\t\tif (res)\n\t\t\tbreak;\n\t\tstart = be16_to_cpu(fd.key->ext.FABN);\n\t\thfs_free_extents(sb, extent, total_blocks - start, total_blocks);\n\t\thfs_brec_remove(&fd);\n\t\ttotal_blocks = start;\n\t} while (total_blocks > blocks);\n\thfs_find_exit(&fd);\n\n\treturn res;\n}"
        }
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "file.FlNum"
          ],
          "line": 235
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hfs_bnode_read",
          "args": [
            "fd.bnode",
            "&file",
            "fd.entryoffset",
            "sizeof(file)"
          ],
          "line": 234
        },
        "resolved": true,
        "details": {
          "function_name": "hfs_bnode_read",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfs/bnode.c",
          "lines": "17-27",
          "snippet": "void hfs_bnode_read(struct hfs_bnode *node, void *buf,\n\t\tint off, int len)\n{\n\tstruct page *page;\n\n\toff += node->page_offset;\n\tpage = node->page[0];\n\n\tmemcpy(buf, kmap(page) + off, len);\n\tkunmap(page);\n}",
          "includes": [
            "#include \"btree.h\"",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"btree.h\"\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n\nvoid hfs_bnode_read(struct hfs_bnode *node, void *buf,\n\t\tint off, int len)\n{\n\tstruct page *page;\n\n\toff += node->page_offset;\n\tpage = node->page[0];\n\n\tmemcpy(buf, kmap(page) + off, len);\n\tkunmap(page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "hfs_bnode_read_u8",
          "args": [
            "fd.bnode",
            "fd.entryoffset"
          ],
          "line": 231
        },
        "resolved": true,
        "details": {
          "function_name": "hfs_bnode_read_u8",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfs/bnode.c",
          "lines": "37-43",
          "snippet": "u8 hfs_bnode_read_u8(struct hfs_bnode *node, int off)\n{\n\tu8 data;\n\t// optimize later...\n\thfs_bnode_read(node, &data, off, 1);\n\treturn data;\n}",
          "includes": [
            "#include \"btree.h\"",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"btree.h\"\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n\nu8 hfs_bnode_read_u8(struct hfs_bnode *node, int off)\n{\n\tu8 data;\n\t// optimize later...\n\thfs_bnode_read(node, &data, off, 1);\n\treturn data;\n}"
        }
      },
      {
        "call_info": {
          "callee": "hfs_find_init",
          "args": [
            "HFS_SB(sb)->cat_tree",
            "&fd"
          ],
          "line": 222
        },
        "resolved": true,
        "details": {
          "function_name": "hfs_find_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfs/bfind.c",
          "lines": "14-29",
          "snippet": "int hfs_find_init(struct hfs_btree *tree, struct hfs_find_data *fd)\n{\n\tvoid *ptr;\n\n\tfd->tree = tree;\n\tfd->bnode = NULL;\n\tptr = kmalloc(tree->max_key_len * 2 + 4, GFP_KERNEL);\n\tif (!ptr)\n\t\treturn -ENOMEM;\n\tfd->search_key = ptr;\n\tfd->key = ptr + tree->max_key_len + 2;\n\thfs_dbg(BNODE_REFS, \"find_init: %d (%p)\\n\",\n\t\ttree->cnid, __builtin_return_address(0));\n\tmutex_lock(&tree->tree_lock);\n\treturn 0;\n}",
          "includes": [
            "#include \"btree.h\"",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"btree.h\"\n#include <linux/slab.h>\n\nint hfs_find_init(struct hfs_btree *tree, struct hfs_find_data *fd)\n{\n\tvoid *ptr;\n\n\tfd->tree = tree;\n\tfd->bnode = NULL;\n\tptr = kmalloc(tree->max_key_len * 2 + 4, GFP_KERNEL);\n\tif (!ptr)\n\t\treturn -ENOMEM;\n\tfd->search_key = ptr;\n\tfd->key = ptr + tree->max_key_len + 2;\n\thfs_dbg(BNODE_REFS, \"find_init: %d (%p)\\n\",\n\t\ttree->cnid, __builtin_return_address(0));\n\tmutex_lock(&tree->tree_lock);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "HFS_SB",
          "args": [
            "sb"
          ],
          "line": 222
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hfs_dbg",
          "args": [
            "CAT_MOD",
            "\"delete_cat: %s,%u\\n\"",
            "str ? str->name : NULL",
            "cnid"
          ],
          "line": 220
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"btree.h\"\n#include \"hfs_fs.h\"\n\nint hfs_cat_delete(u32 cnid, struct inode *dir, struct qstr *str)\n{\n\tstruct super_block *sb;\n\tstruct hfs_find_data fd;\n\tstruct list_head *pos;\n\tint res, type;\n\n\thfs_dbg(CAT_MOD, \"delete_cat: %s,%u\\n\", str ? str->name : NULL, cnid);\n\tsb = dir->i_sb;\n\tres = hfs_find_init(HFS_SB(sb)->cat_tree, &fd);\n\tif (res)\n\t\treturn res;\n\n\thfs_cat_build_key(sb, fd.search_key, dir->i_ino, str);\n\tres = hfs_brec_find(&fd);\n\tif (res)\n\t\tgoto out;\n\n\ttype = hfs_bnode_read_u8(fd.bnode, fd.entryoffset);\n\tif (type == HFS_CDR_FIL) {\n\t\tstruct hfs_cat_file file;\n\t\thfs_bnode_read(fd.bnode, &file, fd.entryoffset, sizeof(file));\n\t\tif (be32_to_cpu(file.FlNum) == cnid) {\n#if 0\n\t\t\thfs_free_fork(sb, &file, HFS_FK_DATA);\n#endif\n\t\t\thfs_free_fork(sb, &file, HFS_FK_RSRC);\n\t\t}\n\t}\n\n\tlist_for_each(pos, &HFS_I(dir)->open_dir_list) {\n\t\tstruct hfs_readdir_data *rd =\n\t\t\tlist_entry(pos, struct hfs_readdir_data, list);\n\t\tif (fd.tree->keycmp(fd.search_key, (void *)&rd->key) < 0)\n\t\t\trd->file->f_pos--;\n\t}\n\n\tres = hfs_brec_remove(&fd);\n\tif (res)\n\t\tgoto out;\n\n\thfs_cat_build_key(sb, fd.search_key, cnid, NULL);\n\tres = hfs_brec_find(&fd);\n\tif (!res) {\n\t\tres = hfs_brec_remove(&fd);\n\t\tif (res)\n\t\t\tgoto out;\n\t}\n\n\tdir->i_size--;\n\tdir->i_mtime = dir->i_ctime = CURRENT_TIME_SEC;\n\tmark_inode_dirty(dir);\n\tres = 0;\nout:\n\thfs_find_exit(&fd);\n\n\treturn res;\n}"
  },
  {
    "function_name": "hfs_cat_find_brec",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfs/catalog.c",
    "lines": "179-204",
    "snippet": "int hfs_cat_find_brec(struct super_block *sb, u32 cnid,\n\t\t      struct hfs_find_data *fd)\n{\n\thfs_cat_rec rec;\n\tint res, len, type;\n\n\thfs_cat_build_key(sb, fd->search_key, cnid, NULL);\n\tres = hfs_brec_read(fd, &rec, sizeof(rec));\n\tif (res)\n\t\treturn res;\n\n\ttype = rec.type;\n\tif (type != HFS_CDR_THD && type != HFS_CDR_FTH) {\n\t\tpr_err(\"found bad thread record in catalog\\n\");\n\t\treturn -EIO;\n\t}\n\n\tfd->search_key->cat.ParID = rec.thread.ParID;\n\tlen = fd->search_key->cat.CName.len = rec.thread.CName.len;\n\tif (len > HFS_NAMELEN) {\n\t\tpr_err(\"bad catalog namelength\\n\");\n\t\treturn -EIO;\n\t}\n\tmemcpy(fd->search_key->cat.CName.name, rec.thread.CName.name, len);\n\treturn hfs_brec_find(fd);\n}",
    "includes": [
      "#include \"btree.h\"",
      "#include \"hfs_fs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "hfs_brec_find",
          "args": [
            "fd"
          ],
          "line": 203
        },
        "resolved": true,
        "details": {
          "function_name": "hfs_brec_find",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfs/bfind.c",
          "lines": "94-146",
          "snippet": "int hfs_brec_find(struct hfs_find_data *fd)\n{\n\tstruct hfs_btree *tree;\n\tstruct hfs_bnode *bnode;\n\tu32 nidx, parent;\n\t__be32 data;\n\tint height, res;\n\n\ttree = fd->tree;\n\tif (fd->bnode)\n\t\thfs_bnode_put(fd->bnode);\n\tfd->bnode = NULL;\n\tnidx = tree->root;\n\tif (!nidx)\n\t\treturn -ENOENT;\n\theight = tree->depth;\n\tres = 0;\n\tparent = 0;\n\tfor (;;) {\n\t\tbnode = hfs_bnode_find(tree, nidx);\n\t\tif (IS_ERR(bnode)) {\n\t\t\tres = PTR_ERR(bnode);\n\t\t\tbnode = NULL;\n\t\t\tbreak;\n\t\t}\n\t\tif (bnode->height != height)\n\t\t\tgoto invalid;\n\t\tif (bnode->type != (--height ? HFS_NODE_INDEX : HFS_NODE_LEAF))\n\t\t\tgoto invalid;\n\t\tbnode->parent = parent;\n\n\t\tres = __hfs_brec_find(bnode, fd);\n\t\tif (!height)\n\t\t\tbreak;\n\t\tif (fd->record < 0)\n\t\t\tgoto release;\n\n\t\tparent = nidx;\n\t\thfs_bnode_read(bnode, &data, fd->entryoffset, 4);\n\t\tnidx = be32_to_cpu(data);\n\t\thfs_bnode_put(bnode);\n\t}\n\tfd->bnode = bnode;\n\treturn res;\n\ninvalid:\n\tpr_err(\"inconsistency in B*Tree (%d,%d,%d,%u,%u)\\n\",\n\t       height, bnode->height, bnode->type, nidx, parent);\n\tres = -EIO;\nrelease:\n\thfs_bnode_put(bnode);\n\treturn res;\n}",
          "includes": [
            "#include \"btree.h\"",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"btree.h\"\n#include <linux/slab.h>\n\nint hfs_brec_find(struct hfs_find_data *fd)\n{\n\tstruct hfs_btree *tree;\n\tstruct hfs_bnode *bnode;\n\tu32 nidx, parent;\n\t__be32 data;\n\tint height, res;\n\n\ttree = fd->tree;\n\tif (fd->bnode)\n\t\thfs_bnode_put(fd->bnode);\n\tfd->bnode = NULL;\n\tnidx = tree->root;\n\tif (!nidx)\n\t\treturn -ENOENT;\n\theight = tree->depth;\n\tres = 0;\n\tparent = 0;\n\tfor (;;) {\n\t\tbnode = hfs_bnode_find(tree, nidx);\n\t\tif (IS_ERR(bnode)) {\n\t\t\tres = PTR_ERR(bnode);\n\t\t\tbnode = NULL;\n\t\t\tbreak;\n\t\t}\n\t\tif (bnode->height != height)\n\t\t\tgoto invalid;\n\t\tif (bnode->type != (--height ? HFS_NODE_INDEX : HFS_NODE_LEAF))\n\t\t\tgoto invalid;\n\t\tbnode->parent = parent;\n\n\t\tres = __hfs_brec_find(bnode, fd);\n\t\tif (!height)\n\t\t\tbreak;\n\t\tif (fd->record < 0)\n\t\t\tgoto release;\n\n\t\tparent = nidx;\n\t\thfs_bnode_read(bnode, &data, fd->entryoffset, 4);\n\t\tnidx = be32_to_cpu(data);\n\t\thfs_bnode_put(bnode);\n\t}\n\tfd->bnode = bnode;\n\treturn res;\n\ninvalid:\n\tpr_err(\"inconsistency in B*Tree (%d,%d,%d,%u,%u)\\n\",\n\t       height, bnode->height, bnode->type, nidx, parent);\n\tres = -EIO;\nrelease:\n\thfs_bnode_put(bnode);\n\treturn res;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "fd->search_key->cat.CName.name",
            "rec.thread.CName.name",
            "len"
          ],
          "line": 202
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"bad catalog namelength\\n\""
          ],
          "line": 199
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"found bad thread record in catalog\\n\""
          ],
          "line": 192
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hfs_brec_read",
          "args": [
            "fd",
            "&rec",
            "sizeof(rec)"
          ],
          "line": 186
        },
        "resolved": true,
        "details": {
          "function_name": "hfs_brec_read",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfs/bfind.c",
          "lines": "148-159",
          "snippet": "int hfs_brec_read(struct hfs_find_data *fd, void *rec, int rec_len)\n{\n\tint res;\n\n\tres = hfs_brec_find(fd);\n\tif (res)\n\t\treturn res;\n\tif (fd->entrylength > rec_len)\n\t\treturn -EINVAL;\n\thfs_bnode_read(fd->bnode, rec, fd->entryoffset, fd->entrylength);\n\treturn 0;\n}",
          "includes": [
            "#include \"btree.h\"",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"btree.h\"\n#include <linux/slab.h>\n\nint hfs_brec_read(struct hfs_find_data *fd, void *rec, int rec_len)\n{\n\tint res;\n\n\tres = hfs_brec_find(fd);\n\tif (res)\n\t\treturn res;\n\tif (fd->entrylength > rec_len)\n\t\treturn -EINVAL;\n\thfs_bnode_read(fd->bnode, rec, fd->entryoffset, fd->entrylength);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "hfs_cat_build_key",
          "args": [
            "sb",
            "fd->search_key",
            "cnid",
            "NULL"
          ],
          "line": 185
        },
        "resolved": true,
        "details": {
          "function_name": "hfs_cat_build_key",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfs/catalog.c",
          "lines": "23-34",
          "snippet": "void hfs_cat_build_key(struct super_block *sb, btree_key *key, u32 parent, struct qstr *name)\n{\n\tkey->cat.reserved = 0;\n\tkey->cat.ParID = cpu_to_be32(parent);\n\tif (name) {\n\t\thfs_asc2mac(sb, &key->cat.CName, name);\n\t\tkey->key_len = 6 + key->cat.CName.len;\n\t} else {\n\t\tmemset(&key->cat.CName, 0, sizeof(struct hfs_name));\n\t\tkey->key_len = 6;\n\t}\n}",
          "includes": [
            "#include \"btree.h\"",
            "#include \"hfs_fs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"btree.h\"\n#include \"hfs_fs.h\"\n\nvoid hfs_cat_build_key(struct super_block *sb, btree_key *key, u32 parent, struct qstr *name)\n{\n\tkey->cat.reserved = 0;\n\tkey->cat.ParID = cpu_to_be32(parent);\n\tif (name) {\n\t\thfs_asc2mac(sb, &key->cat.CName, name);\n\t\tkey->key_len = 6 + key->cat.CName.len;\n\t} else {\n\t\tmemset(&key->cat.CName, 0, sizeof(struct hfs_name));\n\t\tkey->key_len = 6;\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"btree.h\"\n#include \"hfs_fs.h\"\n\nint hfs_cat_find_brec(struct super_block *sb, u32 cnid,\n\t\t      struct hfs_find_data *fd)\n{\n\thfs_cat_rec rec;\n\tint res, len, type;\n\n\thfs_cat_build_key(sb, fd->search_key, cnid, NULL);\n\tres = hfs_brec_read(fd, &rec, sizeof(rec));\n\tif (res)\n\t\treturn res;\n\n\ttype = rec.type;\n\tif (type != HFS_CDR_THD && type != HFS_CDR_FTH) {\n\t\tpr_err(\"found bad thread record in catalog\\n\");\n\t\treturn -EIO;\n\t}\n\n\tfd->search_key->cat.ParID = rec.thread.ParID;\n\tlen = fd->search_key->cat.CName.len = rec.thread.CName.len;\n\tif (len > HFS_NAMELEN) {\n\t\tpr_err(\"bad catalog namelength\\n\");\n\t\treturn -EIO;\n\t}\n\tmemcpy(fd->search_key->cat.CName.name, rec.thread.CName.name, len);\n\treturn hfs_brec_find(fd);\n}"
  },
  {
    "function_name": "hfs_cat_keycmp",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfs/catalog.c",
    "lines": "163-175",
    "snippet": "int hfs_cat_keycmp(const btree_key *key1, const btree_key *key2)\n{\n\t__be32 k1p, k2p;\n\n\tk1p = key1->cat.ParID;\n\tk2p = key2->cat.ParID;\n\n\tif (k1p != k2p)\n\t\treturn be32_to_cpu(k1p) < be32_to_cpu(k2p) ? -1 : 1;\n\n\treturn hfs_strcmp(key1->cat.CName.name, key1->cat.CName.len,\n\t\t\t  key2->cat.CName.name, key2->cat.CName.len);\n}",
    "includes": [
      "#include \"btree.h\"",
      "#include \"hfs_fs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "hfs_strcmp",
          "args": [
            "key1->cat.CName.name",
            "key1->cat.CName.len",
            "key2->cat.CName.name",
            "key2->cat.CName.len"
          ],
          "line": 173
        },
        "resolved": true,
        "details": {
          "function_name": "hfs_strcmp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfs/string.c",
          "lines": "76-89",
          "snippet": "int hfs_strcmp(const unsigned char *s1, unsigned int len1,\n\t       const unsigned char *s2, unsigned int len2)\n{\n\tint len, tmp;\n\n\tlen = (len1 > len2) ? len2 : len1;\n\n\twhile (len--) {\n\t\ttmp = (int)caseorder[*(s1++)] - (int)caseorder[*(s2++)];\n\t\tif (tmp)\n\t\t\treturn tmp;\n\t}\n\treturn len1 - len2;\n}",
          "includes": [
            "#include <linux/dcache.h>",
            "#include \"hfs_fs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static unsigned char caseorder[256] = {\n\t0x00,0x01,0x02,0x03,0x04,0x05,0x06,0x07,0x08,0x09,0x0A,0x0B,0x0C,0x0D,0x0E,0x0F,\n\t0x10,0x11,0x12,0x13,0x14,0x15,0x16,0x17,0x18,0x19,0x1A,0x1B,0x1C,0x1D,0x1E,0x1F,\n\t0x20,0x22,0x23,0x28,0x29,0x2A,0x2B,0x2C,0x2F,0x30,0x31,0x32,0x33,0x34,0x35,0x36,\n\t0x37,0x38,0x39,0x3A,0x3B,0x3C,0x3D,0x3E,0x3F,0x40,0x41,0x42,0x43,0x44,0x45,0x46,\n\t0x47,0x48,0x57,0x59,0x5D,0x5F,0x66,0x68,0x6A,0x6C,0x72,0x74,0x76,0x78,0x7A,0x7E,\n\t0x8C,0x8E,0x90,0x92,0x95,0x97,0x9E,0xA0,0xA2,0xA4,0xA7,0xA9,0xAA,0xAB,0xAC,0xAD,\n\t0x4E,0x48,0x57,0x59,0x5D,0x5F,0x66,0x68,0x6A,0x6C,0x72,0x74,0x76,0x78,0x7A,0x7E,\n\t0x8C,0x8E,0x90,0x92,0x95,0x97,0x9E,0xA0,0xA2,0xA4,0xA7,0xAF,0xB0,0xB1,0xB2,0xB3,\n\t0x4A,0x4C,0x5A,0x60,0x7B,0x7F,0x98,0x4F,0x49,0x51,0x4A,0x4B,0x4C,0x5A,0x60,0x63,\n\t0x64,0x65,0x6E,0x6F,0x70,0x71,0x7B,0x84,0x85,0x86,0x7F,0x80,0x9A,0x9B,0x9C,0x98,\n\t0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0x94,0xBB,0xBC,0xBD,0xBE,0xBF,0xC0,0x4D,0x81,\n\t0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0x55,0x8A,0xCC,0x4D,0x81,\n\t0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0x26,0x27,0xD4,0x20,0x49,0x4B,0x80,0x82,0x82,\n\t0xD5,0xD6,0x24,0x25,0x2D,0x2E,0xD7,0xD8,0xA6,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF,\n\t0xE0,0xE1,0xE2,0xE3,0xE4,0xE5,0xE6,0xE7,0xE8,0xE9,0xEA,0xEB,0xEC,0xED,0xEE,0xEF,\n\t0xF0,0xF1,0xF2,0xF3,0xF4,0xF5,0xF6,0xF7,0xF8,0xF9,0xFA,0xFB,0xFC,0xFD,0xFE,0xFF\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/dcache.h>\n#include \"hfs_fs.h\"\n\nstatic unsigned char caseorder[256] = {\n\t0x00,0x01,0x02,0x03,0x04,0x05,0x06,0x07,0x08,0x09,0x0A,0x0B,0x0C,0x0D,0x0E,0x0F,\n\t0x10,0x11,0x12,0x13,0x14,0x15,0x16,0x17,0x18,0x19,0x1A,0x1B,0x1C,0x1D,0x1E,0x1F,\n\t0x20,0x22,0x23,0x28,0x29,0x2A,0x2B,0x2C,0x2F,0x30,0x31,0x32,0x33,0x34,0x35,0x36,\n\t0x37,0x38,0x39,0x3A,0x3B,0x3C,0x3D,0x3E,0x3F,0x40,0x41,0x42,0x43,0x44,0x45,0x46,\n\t0x47,0x48,0x57,0x59,0x5D,0x5F,0x66,0x68,0x6A,0x6C,0x72,0x74,0x76,0x78,0x7A,0x7E,\n\t0x8C,0x8E,0x90,0x92,0x95,0x97,0x9E,0xA0,0xA2,0xA4,0xA7,0xA9,0xAA,0xAB,0xAC,0xAD,\n\t0x4E,0x48,0x57,0x59,0x5D,0x5F,0x66,0x68,0x6A,0x6C,0x72,0x74,0x76,0x78,0x7A,0x7E,\n\t0x8C,0x8E,0x90,0x92,0x95,0x97,0x9E,0xA0,0xA2,0xA4,0xA7,0xAF,0xB0,0xB1,0xB2,0xB3,\n\t0x4A,0x4C,0x5A,0x60,0x7B,0x7F,0x98,0x4F,0x49,0x51,0x4A,0x4B,0x4C,0x5A,0x60,0x63,\n\t0x64,0x65,0x6E,0x6F,0x70,0x71,0x7B,0x84,0x85,0x86,0x7F,0x80,0x9A,0x9B,0x9C,0x98,\n\t0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0x94,0xBB,0xBC,0xBD,0xBE,0xBF,0xC0,0x4D,0x81,\n\t0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0x55,0x8A,0xCC,0x4D,0x81,\n\t0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0x26,0x27,0xD4,0x20,0x49,0x4B,0x80,0x82,0x82,\n\t0xD5,0xD6,0x24,0x25,0x2D,0x2E,0xD7,0xD8,0xA6,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF,\n\t0xE0,0xE1,0xE2,0xE3,0xE4,0xE5,0xE6,0xE7,0xE8,0xE9,0xEA,0xEB,0xEC,0xED,0xEE,0xEF,\n\t0xF0,0xF1,0xF2,0xF3,0xF4,0xF5,0xF6,0xF7,0xF8,0xF9,0xFA,0xFB,0xFC,0xFD,0xFE,0xFF\n};\n\nint hfs_strcmp(const unsigned char *s1, unsigned int len1,\n\t       const unsigned char *s2, unsigned int len2)\n{\n\tint len, tmp;\n\n\tlen = (len1 > len2) ? len2 : len1;\n\n\twhile (len--) {\n\t\ttmp = (int)caseorder[*(s1++)] - (int)caseorder[*(s2++)];\n\t\tif (tmp)\n\t\t\treturn tmp;\n\t}\n\treturn len1 - len2;\n}"
        }
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "k2p"
          ],
          "line": 171
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "k1p"
          ],
          "line": 171
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"btree.h\"\n#include \"hfs_fs.h\"\n\nint hfs_cat_keycmp(const btree_key *key1, const btree_key *key2)\n{\n\t__be32 k1p, k2p;\n\n\tk1p = key1->cat.ParID;\n\tk2p = key2->cat.ParID;\n\n\tif (k1p != k2p)\n\t\treturn be32_to_cpu(k1p) < be32_to_cpu(k2p) ? -1 : 1;\n\n\treturn hfs_strcmp(key1->cat.CName.name, key1->cat.CName.len,\n\t\t\t  key2->cat.CName.name, key2->cat.CName.len);\n}"
  },
  {
    "function_name": "hfs_cat_create",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfs/catalog.c",
    "lines": "82-140",
    "snippet": "int hfs_cat_create(u32 cnid, struct inode *dir, struct qstr *str, struct inode *inode)\n{\n\tstruct hfs_find_data fd;\n\tstruct super_block *sb;\n\tunion hfs_cat_rec entry;\n\tint entry_size;\n\tint err;\n\n\thfs_dbg(CAT_MOD, \"create_cat: %s,%u(%d)\\n\",\n\t\tstr->name, cnid, inode->i_nlink);\n\tif (dir->i_size >= HFS_MAX_VALENCE)\n\t\treturn -ENOSPC;\n\n\tsb = dir->i_sb;\n\terr = hfs_find_init(HFS_SB(sb)->cat_tree, &fd);\n\tif (err)\n\t\treturn err;\n\n\thfs_cat_build_key(sb, fd.search_key, cnid, NULL);\n\tentry_size = hfs_cat_build_thread(sb, &entry, S_ISDIR(inode->i_mode) ?\n\t\t\tHFS_CDR_THD : HFS_CDR_FTH,\n\t\t\tdir->i_ino, str);\n\terr = hfs_brec_find(&fd);\n\tif (err != -ENOENT) {\n\t\tif (!err)\n\t\t\terr = -EEXIST;\n\t\tgoto err2;\n\t}\n\terr = hfs_brec_insert(&fd, &entry, entry_size);\n\tif (err)\n\t\tgoto err2;\n\n\thfs_cat_build_key(sb, fd.search_key, dir->i_ino, str);\n\tentry_size = hfs_cat_build_record(&entry, cnid, inode);\n\terr = hfs_brec_find(&fd);\n\tif (err != -ENOENT) {\n\t\t/* panic? */\n\t\tif (!err)\n\t\t\terr = -EEXIST;\n\t\tgoto err1;\n\t}\n\terr = hfs_brec_insert(&fd, &entry, entry_size);\n\tif (err)\n\t\tgoto err1;\n\n\tdir->i_size++;\n\tdir->i_mtime = dir->i_ctime = CURRENT_TIME_SEC;\n\tmark_inode_dirty(dir);\n\thfs_find_exit(&fd);\n\treturn 0;\n\nerr1:\n\thfs_cat_build_key(sb, fd.search_key, cnid, NULL);\n\tif (!hfs_brec_find(&fd))\n\t\thfs_brec_remove(&fd);\nerr2:\n\thfs_find_exit(&fd);\n\treturn err;\n}",
    "includes": [
      "#include \"btree.h\"",
      "#include \"hfs_fs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "hfs_find_exit",
          "args": [
            "&fd"
          ],
          "line": 138
        },
        "resolved": true,
        "details": {
          "function_name": "hfs_find_exit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfs/bfind.c",
          "lines": "31-39",
          "snippet": "void hfs_find_exit(struct hfs_find_data *fd)\n{\n\thfs_bnode_put(fd->bnode);\n\tkfree(fd->search_key);\n\thfs_dbg(BNODE_REFS, \"find_exit: %d (%p)\\n\",\n\t\tfd->tree->cnid, __builtin_return_address(0));\n\tmutex_unlock(&fd->tree->tree_lock);\n\tfd->tree = NULL;\n}",
          "includes": [
            "#include \"btree.h\"",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"btree.h\"\n#include <linux/slab.h>\n\nvoid hfs_find_exit(struct hfs_find_data *fd)\n{\n\thfs_bnode_put(fd->bnode);\n\tkfree(fd->search_key);\n\thfs_dbg(BNODE_REFS, \"find_exit: %d (%p)\\n\",\n\t\tfd->tree->cnid, __builtin_return_address(0));\n\tmutex_unlock(&fd->tree->tree_lock);\n\tfd->tree = NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "hfs_brec_remove",
          "args": [
            "&fd"
          ],
          "line": 136
        },
        "resolved": true,
        "details": {
          "function_name": "hfs_brec_remove",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfs/brec.c",
          "lines": "175-227",
          "snippet": "int hfs_brec_remove(struct hfs_find_data *fd)\n{\n\tstruct hfs_btree *tree;\n\tstruct hfs_bnode *node, *parent;\n\tint end_off, rec_off, data_off, size;\n\n\ttree = fd->tree;\n\tnode = fd->bnode;\nagain:\n\trec_off = tree->node_size - (fd->record + 2) * 2;\n\tend_off = tree->node_size - (node->num_recs + 1) * 2;\n\n\tif (node->type == HFS_NODE_LEAF) {\n\t\ttree->leaf_count--;\n\t\tmark_inode_dirty(tree->inode);\n\t}\n\thfs_bnode_dump(node);\n\thfs_dbg(BNODE_MOD, \"remove_rec: %d, %d\\n\",\n\t\tfd->record, fd->keylength + fd->entrylength);\n\tif (!--node->num_recs) {\n\t\thfs_bnode_unlink(node);\n\t\tif (!node->parent)\n\t\t\treturn 0;\n\t\tparent = hfs_bnode_find(tree, node->parent);\n\t\tif (IS_ERR(parent))\n\t\t\treturn PTR_ERR(parent);\n\t\thfs_bnode_put(node);\n\t\tnode = fd->bnode = parent;\n\n\t\t__hfs_brec_find(node, fd);\n\t\tgoto again;\n\t}\n\thfs_bnode_write_u16(node, offsetof(struct hfs_bnode_desc, num_recs), node->num_recs);\n\n\tif (rec_off == end_off)\n\t\tgoto skip;\n\tsize = fd->keylength + fd->entrylength;\n\n\tdo {\n\t\tdata_off = hfs_bnode_read_u16(node, rec_off);\n\t\thfs_bnode_write_u16(node, rec_off + 2, data_off - size);\n\t\trec_off -= 2;\n\t} while (rec_off >= end_off);\n\n\t/* fill hole */\n\thfs_bnode_move(node, fd->keyoffset, fd->keyoffset + size,\n\t\t       data_off - fd->keyoffset - size);\nskip:\n\thfs_bnode_dump(node);\n\tif (!fd->record)\n\t\thfs_brec_update_parent(fd);\n\treturn 0;\n}",
          "includes": [
            "#include \"btree.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static struct hfs_bnode *hfs_bnode_split(struct hfs_find_data *fd);",
            "static int hfs_brec_update_parent(struct hfs_find_data *fd);",
            "static int hfs_btree_inc_height(struct hfs_btree *tree);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"btree.h\"\n\nstatic struct hfs_bnode *hfs_bnode_split(struct hfs_find_data *fd);\nstatic int hfs_brec_update_parent(struct hfs_find_data *fd);\nstatic int hfs_btree_inc_height(struct hfs_btree *tree);\n\nint hfs_brec_remove(struct hfs_find_data *fd)\n{\n\tstruct hfs_btree *tree;\n\tstruct hfs_bnode *node, *parent;\n\tint end_off, rec_off, data_off, size;\n\n\ttree = fd->tree;\n\tnode = fd->bnode;\nagain:\n\trec_off = tree->node_size - (fd->record + 2) * 2;\n\tend_off = tree->node_size - (node->num_recs + 1) * 2;\n\n\tif (node->type == HFS_NODE_LEAF) {\n\t\ttree->leaf_count--;\n\t\tmark_inode_dirty(tree->inode);\n\t}\n\thfs_bnode_dump(node);\n\thfs_dbg(BNODE_MOD, \"remove_rec: %d, %d\\n\",\n\t\tfd->record, fd->keylength + fd->entrylength);\n\tif (!--node->num_recs) {\n\t\thfs_bnode_unlink(node);\n\t\tif (!node->parent)\n\t\t\treturn 0;\n\t\tparent = hfs_bnode_find(tree, node->parent);\n\t\tif (IS_ERR(parent))\n\t\t\treturn PTR_ERR(parent);\n\t\thfs_bnode_put(node);\n\t\tnode = fd->bnode = parent;\n\n\t\t__hfs_brec_find(node, fd);\n\t\tgoto again;\n\t}\n\thfs_bnode_write_u16(node, offsetof(struct hfs_bnode_desc, num_recs), node->num_recs);\n\n\tif (rec_off == end_off)\n\t\tgoto skip;\n\tsize = fd->keylength + fd->entrylength;\n\n\tdo {\n\t\tdata_off = hfs_bnode_read_u16(node, rec_off);\n\t\thfs_bnode_write_u16(node, rec_off + 2, data_off - size);\n\t\trec_off -= 2;\n\t} while (rec_off >= end_off);\n\n\t/* fill hole */\n\thfs_bnode_move(node, fd->keyoffset, fd->keyoffset + size,\n\t\t       data_off - fd->keyoffset - size);\nskip:\n\thfs_bnode_dump(node);\n\tif (!fd->record)\n\t\thfs_brec_update_parent(fd);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "hfs_brec_find",
          "args": [
            "&fd"
          ],
          "line": 135
        },
        "resolved": true,
        "details": {
          "function_name": "hfs_brec_find",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfs/bfind.c",
          "lines": "94-146",
          "snippet": "int hfs_brec_find(struct hfs_find_data *fd)\n{\n\tstruct hfs_btree *tree;\n\tstruct hfs_bnode *bnode;\n\tu32 nidx, parent;\n\t__be32 data;\n\tint height, res;\n\n\ttree = fd->tree;\n\tif (fd->bnode)\n\t\thfs_bnode_put(fd->bnode);\n\tfd->bnode = NULL;\n\tnidx = tree->root;\n\tif (!nidx)\n\t\treturn -ENOENT;\n\theight = tree->depth;\n\tres = 0;\n\tparent = 0;\n\tfor (;;) {\n\t\tbnode = hfs_bnode_find(tree, nidx);\n\t\tif (IS_ERR(bnode)) {\n\t\t\tres = PTR_ERR(bnode);\n\t\t\tbnode = NULL;\n\t\t\tbreak;\n\t\t}\n\t\tif (bnode->height != height)\n\t\t\tgoto invalid;\n\t\tif (bnode->type != (--height ? HFS_NODE_INDEX : HFS_NODE_LEAF))\n\t\t\tgoto invalid;\n\t\tbnode->parent = parent;\n\n\t\tres = __hfs_brec_find(bnode, fd);\n\t\tif (!height)\n\t\t\tbreak;\n\t\tif (fd->record < 0)\n\t\t\tgoto release;\n\n\t\tparent = nidx;\n\t\thfs_bnode_read(bnode, &data, fd->entryoffset, 4);\n\t\tnidx = be32_to_cpu(data);\n\t\thfs_bnode_put(bnode);\n\t}\n\tfd->bnode = bnode;\n\treturn res;\n\ninvalid:\n\tpr_err(\"inconsistency in B*Tree (%d,%d,%d,%u,%u)\\n\",\n\t       height, bnode->height, bnode->type, nidx, parent);\n\tres = -EIO;\nrelease:\n\thfs_bnode_put(bnode);\n\treturn res;\n}",
          "includes": [
            "#include \"btree.h\"",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"btree.h\"\n#include <linux/slab.h>\n\nint hfs_brec_find(struct hfs_find_data *fd)\n{\n\tstruct hfs_btree *tree;\n\tstruct hfs_bnode *bnode;\n\tu32 nidx, parent;\n\t__be32 data;\n\tint height, res;\n\n\ttree = fd->tree;\n\tif (fd->bnode)\n\t\thfs_bnode_put(fd->bnode);\n\tfd->bnode = NULL;\n\tnidx = tree->root;\n\tif (!nidx)\n\t\treturn -ENOENT;\n\theight = tree->depth;\n\tres = 0;\n\tparent = 0;\n\tfor (;;) {\n\t\tbnode = hfs_bnode_find(tree, nidx);\n\t\tif (IS_ERR(bnode)) {\n\t\t\tres = PTR_ERR(bnode);\n\t\t\tbnode = NULL;\n\t\t\tbreak;\n\t\t}\n\t\tif (bnode->height != height)\n\t\t\tgoto invalid;\n\t\tif (bnode->type != (--height ? HFS_NODE_INDEX : HFS_NODE_LEAF))\n\t\t\tgoto invalid;\n\t\tbnode->parent = parent;\n\n\t\tres = __hfs_brec_find(bnode, fd);\n\t\tif (!height)\n\t\t\tbreak;\n\t\tif (fd->record < 0)\n\t\t\tgoto release;\n\n\t\tparent = nidx;\n\t\thfs_bnode_read(bnode, &data, fd->entryoffset, 4);\n\t\tnidx = be32_to_cpu(data);\n\t\thfs_bnode_put(bnode);\n\t}\n\tfd->bnode = bnode;\n\treturn res;\n\ninvalid:\n\tpr_err(\"inconsistency in B*Tree (%d,%d,%d,%u,%u)\\n\",\n\t       height, bnode->height, bnode->type, nidx, parent);\n\tres = -EIO;\nrelease:\n\thfs_bnode_put(bnode);\n\treturn res;\n}"
        }
      },
      {
        "call_info": {
          "callee": "hfs_cat_build_key",
          "args": [
            "sb",
            "fd.search_key",
            "cnid",
            "NULL"
          ],
          "line": 134
        },
        "resolved": true,
        "details": {
          "function_name": "hfs_cat_build_key",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfs/catalog.c",
          "lines": "23-34",
          "snippet": "void hfs_cat_build_key(struct super_block *sb, btree_key *key, u32 parent, struct qstr *name)\n{\n\tkey->cat.reserved = 0;\n\tkey->cat.ParID = cpu_to_be32(parent);\n\tif (name) {\n\t\thfs_asc2mac(sb, &key->cat.CName, name);\n\t\tkey->key_len = 6 + key->cat.CName.len;\n\t} else {\n\t\tmemset(&key->cat.CName, 0, sizeof(struct hfs_name));\n\t\tkey->key_len = 6;\n\t}\n}",
          "includes": [
            "#include \"btree.h\"",
            "#include \"hfs_fs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"btree.h\"\n#include \"hfs_fs.h\"\n\nvoid hfs_cat_build_key(struct super_block *sb, btree_key *key, u32 parent, struct qstr *name)\n{\n\tkey->cat.reserved = 0;\n\tkey->cat.ParID = cpu_to_be32(parent);\n\tif (name) {\n\t\thfs_asc2mac(sb, &key->cat.CName, name);\n\t\tkey->key_len = 6 + key->cat.CName.len;\n\t} else {\n\t\tmemset(&key->cat.CName, 0, sizeof(struct hfs_name));\n\t\tkey->key_len = 6;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "mark_inode_dirty",
          "args": [
            "dir"
          ],
          "line": 129
        },
        "resolved": true,
        "details": {
          "function_name": "block_dump___mark_inode_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fs-writeback.c",
          "lines": "1134-1154",
          "snippet": "static noinline void block_dump___mark_inode_dirty(struct inode *inode)\n{\n\tif (inode->i_ino || strcmp(inode->i_sb->s_id, \"bdev\")) {\n\t\tstruct dentry *dentry;\n\t\tconst char *name = \"?\";\n\n\t\tdentry = d_find_alias(inode);\n\t\tif (dentry) {\n\t\t\tspin_lock(&dentry->d_lock);\n\t\t\tname = (const char *) dentry->d_name.name;\n\t\t}\n\t\tprintk(KERN_DEBUG\n\t\t       \"%s(%d): dirtied inode %lu (%s) on %s\\n\",\n\t\t       current->comm, task_pid_nr(current), inode->i_ino,\n\t\t       name, inode->i_sb->s_id);\n\t\tif (dentry) {\n\t\t\tspin_unlock(&dentry->d_lock);\n\t\t\tdput(dentry);\n\t\t}\n\t}\n}",
          "includes": [
            "#include <trace/events/writeback.h>",
            "#include \"internal.h\"",
            "#include <linux/device.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/writeback.h>\n#include \"internal.h\"\n#include <linux/device.h>\n#include <linux/tracepoint.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nstatic noinline void block_dump___mark_inode_dirty(struct inode *inode)\n{\n\tif (inode->i_ino || strcmp(inode->i_sb->s_id, \"bdev\")) {\n\t\tstruct dentry *dentry;\n\t\tconst char *name = \"?\";\n\n\t\tdentry = d_find_alias(inode);\n\t\tif (dentry) {\n\t\t\tspin_lock(&dentry->d_lock);\n\t\t\tname = (const char *) dentry->d_name.name;\n\t\t}\n\t\tprintk(KERN_DEBUG\n\t\t       \"%s(%d): dirtied inode %lu (%s) on %s\\n\",\n\t\t       current->comm, task_pid_nr(current), inode->i_ino,\n\t\t       name, inode->i_sb->s_id);\n\t\tif (dentry) {\n\t\t\tspin_unlock(&dentry->d_lock);\n\t\t\tdput(dentry);\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "hfs_brec_insert",
          "args": [
            "&fd",
            "&entry",
            "entry_size"
          ],
          "line": 123
        },
        "resolved": true,
        "details": {
          "function_name": "hfs_brec_insert",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfs/brec.c",
          "lines": "64-173",
          "snippet": "int hfs_brec_insert(struct hfs_find_data *fd, void *entry, int entry_len)\n{\n\tstruct hfs_btree *tree;\n\tstruct hfs_bnode *node, *new_node;\n\tint size, key_len, rec;\n\tint data_off, end_off;\n\tint idx_rec_off, data_rec_off, end_rec_off;\n\t__be32 cnid;\n\n\ttree = fd->tree;\n\tif (!fd->bnode) {\n\t\tif (!tree->root)\n\t\t\thfs_btree_inc_height(tree);\n\t\tfd->bnode = hfs_bnode_find(tree, tree->leaf_head);\n\t\tif (IS_ERR(fd->bnode))\n\t\t\treturn PTR_ERR(fd->bnode);\n\t\tfd->record = -1;\n\t}\n\tnew_node = NULL;\n\tkey_len = (fd->search_key->key_len | 1) + 1;\nagain:\n\t/* new record idx and complete record size */\n\trec = fd->record + 1;\n\tsize = key_len + entry_len;\n\n\tnode = fd->bnode;\n\thfs_bnode_dump(node);\n\t/* get last offset */\n\tend_rec_off = tree->node_size - (node->num_recs + 1) * 2;\n\tend_off = hfs_bnode_read_u16(node, end_rec_off);\n\tend_rec_off -= 2;\n\thfs_dbg(BNODE_MOD, \"insert_rec: %d, %d, %d, %d\\n\",\n\t\trec, size, end_off, end_rec_off);\n\tif (size > end_rec_off - end_off) {\n\t\tif (new_node)\n\t\t\tpanic(\"not enough room!\\n\");\n\t\tnew_node = hfs_bnode_split(fd);\n\t\tif (IS_ERR(new_node))\n\t\t\treturn PTR_ERR(new_node);\n\t\tgoto again;\n\t}\n\tif (node->type == HFS_NODE_LEAF) {\n\t\ttree->leaf_count++;\n\t\tmark_inode_dirty(tree->inode);\n\t}\n\tnode->num_recs++;\n\t/* write new last offset */\n\thfs_bnode_write_u16(node, offsetof(struct hfs_bnode_desc, num_recs), node->num_recs);\n\thfs_bnode_write_u16(node, end_rec_off, end_off + size);\n\tdata_off = end_off;\n\tdata_rec_off = end_rec_off + 2;\n\tidx_rec_off = tree->node_size - (rec + 1) * 2;\n\tif (idx_rec_off == data_rec_off)\n\t\tgoto skip;\n\t/* move all following entries */\n\tdo {\n\t\tdata_off = hfs_bnode_read_u16(node, data_rec_off + 2);\n\t\thfs_bnode_write_u16(node, data_rec_off, data_off + size);\n\t\tdata_rec_off += 2;\n\t} while (data_rec_off < idx_rec_off);\n\n\t/* move data away */\n\thfs_bnode_move(node, data_off + size, data_off,\n\t\t       end_off - data_off);\n\nskip:\n\thfs_bnode_write(node, fd->search_key, data_off, key_len);\n\thfs_bnode_write(node, entry, data_off + key_len, entry_len);\n\thfs_bnode_dump(node);\n\n\tif (new_node) {\n\t\t/* update parent key if we inserted a key\n\t\t * at the start of the first node\n\t\t */\n\t\tif (!rec && new_node != node)\n\t\t\thfs_brec_update_parent(fd);\n\n\t\thfs_bnode_put(fd->bnode);\n\t\tif (!new_node->parent) {\n\t\t\thfs_btree_inc_height(tree);\n\t\t\tnew_node->parent = tree->root;\n\t\t}\n\t\tfd->bnode = hfs_bnode_find(tree, new_node->parent);\n\n\t\t/* create index data entry */\n\t\tcnid = cpu_to_be32(new_node->this);\n\t\tentry = &cnid;\n\t\tentry_len = sizeof(cnid);\n\n\t\t/* get index key */\n\t\thfs_bnode_read_key(new_node, fd->search_key, 14);\n\t\t__hfs_brec_find(fd->bnode, fd);\n\n\t\thfs_bnode_put(new_node);\n\t\tnew_node = NULL;\n\n\t\tif (tree->attributes & HFS_TREE_VARIDXKEYS)\n\t\t\tkey_len = fd->search_key->key_len + 1;\n\t\telse {\n\t\t\tfd->search_key->key_len = tree->max_key_len;\n\t\t\tkey_len = tree->max_key_len + 1;\n\t\t}\n\t\tgoto again;\n\t}\n\n\tif (!rec)\n\t\thfs_brec_update_parent(fd);\n\n\treturn 0;\n}",
          "includes": [
            "#include \"btree.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static struct hfs_bnode *hfs_bnode_split(struct hfs_find_data *fd);",
            "static int hfs_brec_update_parent(struct hfs_find_data *fd);",
            "static int hfs_btree_inc_height(struct hfs_btree *tree);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"btree.h\"\n\nstatic struct hfs_bnode *hfs_bnode_split(struct hfs_find_data *fd);\nstatic int hfs_brec_update_parent(struct hfs_find_data *fd);\nstatic int hfs_btree_inc_height(struct hfs_btree *tree);\n\nint hfs_brec_insert(struct hfs_find_data *fd, void *entry, int entry_len)\n{\n\tstruct hfs_btree *tree;\n\tstruct hfs_bnode *node, *new_node;\n\tint size, key_len, rec;\n\tint data_off, end_off;\n\tint idx_rec_off, data_rec_off, end_rec_off;\n\t__be32 cnid;\n\n\ttree = fd->tree;\n\tif (!fd->bnode) {\n\t\tif (!tree->root)\n\t\t\thfs_btree_inc_height(tree);\n\t\tfd->bnode = hfs_bnode_find(tree, tree->leaf_head);\n\t\tif (IS_ERR(fd->bnode))\n\t\t\treturn PTR_ERR(fd->bnode);\n\t\tfd->record = -1;\n\t}\n\tnew_node = NULL;\n\tkey_len = (fd->search_key->key_len | 1) + 1;\nagain:\n\t/* new record idx and complete record size */\n\trec = fd->record + 1;\n\tsize = key_len + entry_len;\n\n\tnode = fd->bnode;\n\thfs_bnode_dump(node);\n\t/* get last offset */\n\tend_rec_off = tree->node_size - (node->num_recs + 1) * 2;\n\tend_off = hfs_bnode_read_u16(node, end_rec_off);\n\tend_rec_off -= 2;\n\thfs_dbg(BNODE_MOD, \"insert_rec: %d, %d, %d, %d\\n\",\n\t\trec, size, end_off, end_rec_off);\n\tif (size > end_rec_off - end_off) {\n\t\tif (new_node)\n\t\t\tpanic(\"not enough room!\\n\");\n\t\tnew_node = hfs_bnode_split(fd);\n\t\tif (IS_ERR(new_node))\n\t\t\treturn PTR_ERR(new_node);\n\t\tgoto again;\n\t}\n\tif (node->type == HFS_NODE_LEAF) {\n\t\ttree->leaf_count++;\n\t\tmark_inode_dirty(tree->inode);\n\t}\n\tnode->num_recs++;\n\t/* write new last offset */\n\thfs_bnode_write_u16(node, offsetof(struct hfs_bnode_desc, num_recs), node->num_recs);\n\thfs_bnode_write_u16(node, end_rec_off, end_off + size);\n\tdata_off = end_off;\n\tdata_rec_off = end_rec_off + 2;\n\tidx_rec_off = tree->node_size - (rec + 1) * 2;\n\tif (idx_rec_off == data_rec_off)\n\t\tgoto skip;\n\t/* move all following entries */\n\tdo {\n\t\tdata_off = hfs_bnode_read_u16(node, data_rec_off + 2);\n\t\thfs_bnode_write_u16(node, data_rec_off, data_off + size);\n\t\tdata_rec_off += 2;\n\t} while (data_rec_off < idx_rec_off);\n\n\t/* move data away */\n\thfs_bnode_move(node, data_off + size, data_off,\n\t\t       end_off - data_off);\n\nskip:\n\thfs_bnode_write(node, fd->search_key, data_off, key_len);\n\thfs_bnode_write(node, entry, data_off + key_len, entry_len);\n\thfs_bnode_dump(node);\n\n\tif (new_node) {\n\t\t/* update parent key if we inserted a key\n\t\t * at the start of the first node\n\t\t */\n\t\tif (!rec && new_node != node)\n\t\t\thfs_brec_update_parent(fd);\n\n\t\thfs_bnode_put(fd->bnode);\n\t\tif (!new_node->parent) {\n\t\t\thfs_btree_inc_height(tree);\n\t\t\tnew_node->parent = tree->root;\n\t\t}\n\t\tfd->bnode = hfs_bnode_find(tree, new_node->parent);\n\n\t\t/* create index data entry */\n\t\tcnid = cpu_to_be32(new_node->this);\n\t\tentry = &cnid;\n\t\tentry_len = sizeof(cnid);\n\n\t\t/* get index key */\n\t\thfs_bnode_read_key(new_node, fd->search_key, 14);\n\t\t__hfs_brec_find(fd->bnode, fd);\n\n\t\thfs_bnode_put(new_node);\n\t\tnew_node = NULL;\n\n\t\tif (tree->attributes & HFS_TREE_VARIDXKEYS)\n\t\t\tkey_len = fd->search_key->key_len + 1;\n\t\telse {\n\t\t\tfd->search_key->key_len = tree->max_key_len;\n\t\t\tkey_len = tree->max_key_len + 1;\n\t\t}\n\t\tgoto again;\n\t}\n\n\tif (!rec)\n\t\thfs_brec_update_parent(fd);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "hfs_cat_build_record",
          "args": [
            "&entry",
            "cnid",
            "inode"
          ],
          "line": 115
        },
        "resolved": true,
        "details": {
          "function_name": "hfs_cat_build_record",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfs/catalog.c",
          "lines": "36-63",
          "snippet": "static int hfs_cat_build_record(hfs_cat_rec *rec, u32 cnid, struct inode *inode)\n{\n\t__be32 mtime = hfs_mtime();\n\n\tmemset(rec, 0, sizeof(*rec));\n\tif (S_ISDIR(inode->i_mode)) {\n\t\trec->type = HFS_CDR_DIR;\n\t\trec->dir.DirID = cpu_to_be32(cnid);\n\t\trec->dir.CrDat = mtime;\n\t\trec->dir.MdDat = mtime;\n\t\trec->dir.BkDat = 0;\n\t\trec->dir.UsrInfo.frView = cpu_to_be16(0xff);\n\t\treturn sizeof(struct hfs_cat_dir);\n\t} else {\n\t\t/* init some fields for the file record */\n\t\trec->type = HFS_CDR_FIL;\n\t\trec->file.Flags = HFS_FIL_USED | HFS_FIL_THD;\n\t\tif (!(inode->i_mode & S_IWUSR))\n\t\t\trec->file.Flags |= HFS_FIL_LOCK;\n\t\trec->file.FlNum = cpu_to_be32(cnid);\n\t\trec->file.CrDat = mtime;\n\t\trec->file.MdDat = mtime;\n\t\trec->file.BkDat = 0;\n\t\trec->file.UsrWds.fdType = HFS_SB(inode->i_sb)->s_type;\n\t\trec->file.UsrWds.fdCreator = HFS_SB(inode->i_sb)->s_creator;\n\t\treturn sizeof(struct hfs_cat_file);\n\t}\n}",
          "includes": [
            "#include \"btree.h\"",
            "#include \"hfs_fs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"btree.h\"\n#include \"hfs_fs.h\"\n\nstatic int hfs_cat_build_record(hfs_cat_rec *rec, u32 cnid, struct inode *inode)\n{\n\t__be32 mtime = hfs_mtime();\n\n\tmemset(rec, 0, sizeof(*rec));\n\tif (S_ISDIR(inode->i_mode)) {\n\t\trec->type = HFS_CDR_DIR;\n\t\trec->dir.DirID = cpu_to_be32(cnid);\n\t\trec->dir.CrDat = mtime;\n\t\trec->dir.MdDat = mtime;\n\t\trec->dir.BkDat = 0;\n\t\trec->dir.UsrInfo.frView = cpu_to_be16(0xff);\n\t\treturn sizeof(struct hfs_cat_dir);\n\t} else {\n\t\t/* init some fields for the file record */\n\t\trec->type = HFS_CDR_FIL;\n\t\trec->file.Flags = HFS_FIL_USED | HFS_FIL_THD;\n\t\tif (!(inode->i_mode & S_IWUSR))\n\t\t\trec->file.Flags |= HFS_FIL_LOCK;\n\t\trec->file.FlNum = cpu_to_be32(cnid);\n\t\trec->file.CrDat = mtime;\n\t\trec->file.MdDat = mtime;\n\t\trec->file.BkDat = 0;\n\t\trec->file.UsrWds.fdType = HFS_SB(inode->i_sb)->s_type;\n\t\trec->file.UsrWds.fdCreator = HFS_SB(inode->i_sb)->s_creator;\n\t\treturn sizeof(struct hfs_cat_file);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "hfs_cat_build_thread",
          "args": [
            "sb",
            "&entry",
            "S_ISDIR(inode->i_mode) ?\n\t\t\tHFS_CDR_THD : HFS_CDR_FTH",
            "dir->i_ino",
            "str"
          ],
          "line": 101
        },
        "resolved": true,
        "details": {
          "function_name": "hfs_cat_build_thread",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfs/catalog.c",
          "lines": "65-74",
          "snippet": "static int hfs_cat_build_thread(struct super_block *sb,\n\t\t\t\thfs_cat_rec *rec, int type,\n\t\t\t\tu32 parentid, struct qstr *name)\n{\n\trec->type = type;\n\tmemset(rec->thread.reserved, 0, sizeof(rec->thread.reserved));\n\trec->thread.ParID = cpu_to_be32(parentid);\n\thfs_asc2mac(sb, &rec->thread.CName, name);\n\treturn sizeof(struct hfs_cat_thread);\n}",
          "includes": [
            "#include \"btree.h\"",
            "#include \"hfs_fs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"btree.h\"\n#include \"hfs_fs.h\"\n\nstatic int hfs_cat_build_thread(struct super_block *sb,\n\t\t\t\thfs_cat_rec *rec, int type,\n\t\t\t\tu32 parentid, struct qstr *name)\n{\n\trec->type = type;\n\tmemset(rec->thread.reserved, 0, sizeof(rec->thread.reserved));\n\trec->thread.ParID = cpu_to_be32(parentid);\n\thfs_asc2mac(sb, &rec->thread.CName, name);\n\treturn sizeof(struct hfs_cat_thread);\n}"
        }
      },
      {
        "call_info": {
          "callee": "S_ISDIR",
          "args": [
            "inode->i_mode"
          ],
          "line": 101
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hfs_find_init",
          "args": [
            "HFS_SB(sb)->cat_tree",
            "&fd"
          ],
          "line": 96
        },
        "resolved": true,
        "details": {
          "function_name": "hfs_find_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfs/bfind.c",
          "lines": "14-29",
          "snippet": "int hfs_find_init(struct hfs_btree *tree, struct hfs_find_data *fd)\n{\n\tvoid *ptr;\n\n\tfd->tree = tree;\n\tfd->bnode = NULL;\n\tptr = kmalloc(tree->max_key_len * 2 + 4, GFP_KERNEL);\n\tif (!ptr)\n\t\treturn -ENOMEM;\n\tfd->search_key = ptr;\n\tfd->key = ptr + tree->max_key_len + 2;\n\thfs_dbg(BNODE_REFS, \"find_init: %d (%p)\\n\",\n\t\ttree->cnid, __builtin_return_address(0));\n\tmutex_lock(&tree->tree_lock);\n\treturn 0;\n}",
          "includes": [
            "#include \"btree.h\"",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"btree.h\"\n#include <linux/slab.h>\n\nint hfs_find_init(struct hfs_btree *tree, struct hfs_find_data *fd)\n{\n\tvoid *ptr;\n\n\tfd->tree = tree;\n\tfd->bnode = NULL;\n\tptr = kmalloc(tree->max_key_len * 2 + 4, GFP_KERNEL);\n\tif (!ptr)\n\t\treturn -ENOMEM;\n\tfd->search_key = ptr;\n\tfd->key = ptr + tree->max_key_len + 2;\n\thfs_dbg(BNODE_REFS, \"find_init: %d (%p)\\n\",\n\t\ttree->cnid, __builtin_return_address(0));\n\tmutex_lock(&tree->tree_lock);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "HFS_SB",
          "args": [
            "sb"
          ],
          "line": 96
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hfs_dbg",
          "args": [
            "CAT_MOD",
            "\"create_cat: %s,%u(%d)\\n\"",
            "str->name",
            "cnid",
            "inode->i_nlink"
          ],
          "line": 90
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"btree.h\"\n#include \"hfs_fs.h\"\n\nint hfs_cat_create(u32 cnid, struct inode *dir, struct qstr *str, struct inode *inode)\n{\n\tstruct hfs_find_data fd;\n\tstruct super_block *sb;\n\tunion hfs_cat_rec entry;\n\tint entry_size;\n\tint err;\n\n\thfs_dbg(CAT_MOD, \"create_cat: %s,%u(%d)\\n\",\n\t\tstr->name, cnid, inode->i_nlink);\n\tif (dir->i_size >= HFS_MAX_VALENCE)\n\t\treturn -ENOSPC;\n\n\tsb = dir->i_sb;\n\terr = hfs_find_init(HFS_SB(sb)->cat_tree, &fd);\n\tif (err)\n\t\treturn err;\n\n\thfs_cat_build_key(sb, fd.search_key, cnid, NULL);\n\tentry_size = hfs_cat_build_thread(sb, &entry, S_ISDIR(inode->i_mode) ?\n\t\t\tHFS_CDR_THD : HFS_CDR_FTH,\n\t\t\tdir->i_ino, str);\n\terr = hfs_brec_find(&fd);\n\tif (err != -ENOENT) {\n\t\tif (!err)\n\t\t\terr = -EEXIST;\n\t\tgoto err2;\n\t}\n\terr = hfs_brec_insert(&fd, &entry, entry_size);\n\tif (err)\n\t\tgoto err2;\n\n\thfs_cat_build_key(sb, fd.search_key, dir->i_ino, str);\n\tentry_size = hfs_cat_build_record(&entry, cnid, inode);\n\terr = hfs_brec_find(&fd);\n\tif (err != -ENOENT) {\n\t\t/* panic? */\n\t\tif (!err)\n\t\t\terr = -EEXIST;\n\t\tgoto err1;\n\t}\n\terr = hfs_brec_insert(&fd, &entry, entry_size);\n\tif (err)\n\t\tgoto err1;\n\n\tdir->i_size++;\n\tdir->i_mtime = dir->i_ctime = CURRENT_TIME_SEC;\n\tmark_inode_dirty(dir);\n\thfs_find_exit(&fd);\n\treturn 0;\n\nerr1:\n\thfs_cat_build_key(sb, fd.search_key, cnid, NULL);\n\tif (!hfs_brec_find(&fd))\n\t\thfs_brec_remove(&fd);\nerr2:\n\thfs_find_exit(&fd);\n\treturn err;\n}"
  },
  {
    "function_name": "hfs_cat_build_thread",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfs/catalog.c",
    "lines": "65-74",
    "snippet": "static int hfs_cat_build_thread(struct super_block *sb,\n\t\t\t\thfs_cat_rec *rec, int type,\n\t\t\t\tu32 parentid, struct qstr *name)\n{\n\trec->type = type;\n\tmemset(rec->thread.reserved, 0, sizeof(rec->thread.reserved));\n\trec->thread.ParID = cpu_to_be32(parentid);\n\thfs_asc2mac(sb, &rec->thread.CName, name);\n\treturn sizeof(struct hfs_cat_thread);\n}",
    "includes": [
      "#include \"btree.h\"",
      "#include \"hfs_fs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "hfs_asc2mac",
          "args": [
            "sb",
            "&rec->thread.CName",
            "name"
          ],
          "line": 72
        },
        "resolved": true,
        "details": {
          "function_name": "hfs_asc2mac",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfs/trans.c",
          "lines": "97-150",
          "snippet": "void hfs_asc2mac(struct super_block *sb, struct hfs_name *out, struct qstr *in)\n{\n\tstruct nls_table *nls_disk = HFS_SB(sb)->nls_disk;\n\tstruct nls_table *nls_io = HFS_SB(sb)->nls_io;\n\tconst char *src;\n\tchar *dst;\n\tint srclen, dstlen, size;\n\n\tsrc = in->name;\n\tsrclen = in->len;\n\tdst = out->name;\n\tdstlen = HFS_NAMELEN;\n\tif (nls_io) {\n\t\twchar_t ch;\n\n\t\twhile (srclen > 0) {\n\t\t\tsize = nls_io->char2uni(src, srclen, &ch);\n\t\t\tif (size < 0) {\n\t\t\t\tch = '?';\n\t\t\t\tsize = 1;\n\t\t\t}\n\t\t\tsrc += size;\n\t\t\tsrclen -= size;\n\t\t\tif (ch == ':')\n\t\t\t\tch = '/';\n\t\t\tif (nls_disk) {\n\t\t\t\tsize = nls_disk->uni2char(ch, dst, dstlen);\n\t\t\t\tif (size < 0) {\n\t\t\t\t\tif (size == -ENAMETOOLONG)\n\t\t\t\t\t\tgoto out;\n\t\t\t\t\t*dst = '?';\n\t\t\t\t\tsize = 1;\n\t\t\t\t}\n\t\t\t\tdst += size;\n\t\t\t\tdstlen -= size;\n\t\t\t} else {\n\t\t\t\t*dst++ = ch > 0xff ? '?' : ch;\n\t\t\t\tdstlen--;\n\t\t\t}\n\t\t}\n\t} else {\n\t\tchar ch;\n\n\t\tif (dstlen > srclen)\n\t\t\tdstlen = srclen;\n\t\twhile (--dstlen >= 0)\n\t\t\t*dst++ = (ch = *src++) == ':' ? '/' : ch;\n\t}\nout:\n\tout->len = dst - (char *)out->name;\n\tdstlen = HFS_NAMELEN - out->len;\n\twhile (--dstlen >= 0)\n\t\t*dst++ = 0;\n}",
          "includes": [
            "#include \"hfs_fs.h\"",
            "#include <linux/nls.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hfs_fs.h\"\n#include <linux/nls.h>\n#include <linux/types.h>\n\nvoid hfs_asc2mac(struct super_block *sb, struct hfs_name *out, struct qstr *in)\n{\n\tstruct nls_table *nls_disk = HFS_SB(sb)->nls_disk;\n\tstruct nls_table *nls_io = HFS_SB(sb)->nls_io;\n\tconst char *src;\n\tchar *dst;\n\tint srclen, dstlen, size;\n\n\tsrc = in->name;\n\tsrclen = in->len;\n\tdst = out->name;\n\tdstlen = HFS_NAMELEN;\n\tif (nls_io) {\n\t\twchar_t ch;\n\n\t\twhile (srclen > 0) {\n\t\t\tsize = nls_io->char2uni(src, srclen, &ch);\n\t\t\tif (size < 0) {\n\t\t\t\tch = '?';\n\t\t\t\tsize = 1;\n\t\t\t}\n\t\t\tsrc += size;\n\t\t\tsrclen -= size;\n\t\t\tif (ch == ':')\n\t\t\t\tch = '/';\n\t\t\tif (nls_disk) {\n\t\t\t\tsize = nls_disk->uni2char(ch, dst, dstlen);\n\t\t\t\tif (size < 0) {\n\t\t\t\t\tif (size == -ENAMETOOLONG)\n\t\t\t\t\t\tgoto out;\n\t\t\t\t\t*dst = '?';\n\t\t\t\t\tsize = 1;\n\t\t\t\t}\n\t\t\t\tdst += size;\n\t\t\t\tdstlen -= size;\n\t\t\t} else {\n\t\t\t\t*dst++ = ch > 0xff ? '?' : ch;\n\t\t\t\tdstlen--;\n\t\t\t}\n\t\t}\n\t} else {\n\t\tchar ch;\n\n\t\tif (dstlen > srclen)\n\t\t\tdstlen = srclen;\n\t\twhile (--dstlen >= 0)\n\t\t\t*dst++ = (ch = *src++) == ':' ? '/' : ch;\n\t}\nout:\n\tout->len = dst - (char *)out->name;\n\tdstlen = HFS_NAMELEN - out->len;\n\twhile (--dstlen >= 0)\n\t\t*dst++ = 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "parentid"
          ],
          "line": 71
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "rec->thread.reserved",
            "0",
            "sizeof(rec->thread.reserved)"
          ],
          "line": 70
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"btree.h\"\n#include \"hfs_fs.h\"\n\nstatic int hfs_cat_build_thread(struct super_block *sb,\n\t\t\t\thfs_cat_rec *rec, int type,\n\t\t\t\tu32 parentid, struct qstr *name)\n{\n\trec->type = type;\n\tmemset(rec->thread.reserved, 0, sizeof(rec->thread.reserved));\n\trec->thread.ParID = cpu_to_be32(parentid);\n\thfs_asc2mac(sb, &rec->thread.CName, name);\n\treturn sizeof(struct hfs_cat_thread);\n}"
  },
  {
    "function_name": "hfs_cat_build_record",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfs/catalog.c",
    "lines": "36-63",
    "snippet": "static int hfs_cat_build_record(hfs_cat_rec *rec, u32 cnid, struct inode *inode)\n{\n\t__be32 mtime = hfs_mtime();\n\n\tmemset(rec, 0, sizeof(*rec));\n\tif (S_ISDIR(inode->i_mode)) {\n\t\trec->type = HFS_CDR_DIR;\n\t\trec->dir.DirID = cpu_to_be32(cnid);\n\t\trec->dir.CrDat = mtime;\n\t\trec->dir.MdDat = mtime;\n\t\trec->dir.BkDat = 0;\n\t\trec->dir.UsrInfo.frView = cpu_to_be16(0xff);\n\t\treturn sizeof(struct hfs_cat_dir);\n\t} else {\n\t\t/* init some fields for the file record */\n\t\trec->type = HFS_CDR_FIL;\n\t\trec->file.Flags = HFS_FIL_USED | HFS_FIL_THD;\n\t\tif (!(inode->i_mode & S_IWUSR))\n\t\t\trec->file.Flags |= HFS_FIL_LOCK;\n\t\trec->file.FlNum = cpu_to_be32(cnid);\n\t\trec->file.CrDat = mtime;\n\t\trec->file.MdDat = mtime;\n\t\trec->file.BkDat = 0;\n\t\trec->file.UsrWds.fdType = HFS_SB(inode->i_sb)->s_type;\n\t\trec->file.UsrWds.fdCreator = HFS_SB(inode->i_sb)->s_creator;\n\t\treturn sizeof(struct hfs_cat_file);\n\t}\n}",
    "includes": [
      "#include \"btree.h\"",
      "#include \"hfs_fs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "HFS_SB",
          "args": [
            "inode->i_sb"
          ],
          "line": 60
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HFS_SB",
          "args": [
            "inode->i_sb"
          ],
          "line": 59
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "cnid"
          ],
          "line": 55
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be16",
          "args": [
            "0xff"
          ],
          "line": 47
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "cnid"
          ],
          "line": 43
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISDIR",
          "args": [
            "inode->i_mode"
          ],
          "line": 41
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "rec",
            "0",
            "sizeof(*rec)"
          ],
          "line": 40
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hfs_mtime",
          "args": [],
          "line": 38
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"btree.h\"\n#include \"hfs_fs.h\"\n\nstatic int hfs_cat_build_record(hfs_cat_rec *rec, u32 cnid, struct inode *inode)\n{\n\t__be32 mtime = hfs_mtime();\n\n\tmemset(rec, 0, sizeof(*rec));\n\tif (S_ISDIR(inode->i_mode)) {\n\t\trec->type = HFS_CDR_DIR;\n\t\trec->dir.DirID = cpu_to_be32(cnid);\n\t\trec->dir.CrDat = mtime;\n\t\trec->dir.MdDat = mtime;\n\t\trec->dir.BkDat = 0;\n\t\trec->dir.UsrInfo.frView = cpu_to_be16(0xff);\n\t\treturn sizeof(struct hfs_cat_dir);\n\t} else {\n\t\t/* init some fields for the file record */\n\t\trec->type = HFS_CDR_FIL;\n\t\trec->file.Flags = HFS_FIL_USED | HFS_FIL_THD;\n\t\tif (!(inode->i_mode & S_IWUSR))\n\t\t\trec->file.Flags |= HFS_FIL_LOCK;\n\t\trec->file.FlNum = cpu_to_be32(cnid);\n\t\trec->file.CrDat = mtime;\n\t\trec->file.MdDat = mtime;\n\t\trec->file.BkDat = 0;\n\t\trec->file.UsrWds.fdType = HFS_SB(inode->i_sb)->s_type;\n\t\trec->file.UsrWds.fdCreator = HFS_SB(inode->i_sb)->s_creator;\n\t\treturn sizeof(struct hfs_cat_file);\n\t}\n}"
  },
  {
    "function_name": "hfs_cat_build_key",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfs/catalog.c",
    "lines": "23-34",
    "snippet": "void hfs_cat_build_key(struct super_block *sb, btree_key *key, u32 parent, struct qstr *name)\n{\n\tkey->cat.reserved = 0;\n\tkey->cat.ParID = cpu_to_be32(parent);\n\tif (name) {\n\t\thfs_asc2mac(sb, &key->cat.CName, name);\n\t\tkey->key_len = 6 + key->cat.CName.len;\n\t} else {\n\t\tmemset(&key->cat.CName, 0, sizeof(struct hfs_name));\n\t\tkey->key_len = 6;\n\t}\n}",
    "includes": [
      "#include \"btree.h\"",
      "#include \"hfs_fs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&key->cat.CName",
            "0",
            "sizeof(struct hfs_name)"
          ],
          "line": 31
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hfs_asc2mac",
          "args": [
            "sb",
            "&key->cat.CName",
            "name"
          ],
          "line": 28
        },
        "resolved": true,
        "details": {
          "function_name": "hfs_asc2mac",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfs/trans.c",
          "lines": "97-150",
          "snippet": "void hfs_asc2mac(struct super_block *sb, struct hfs_name *out, struct qstr *in)\n{\n\tstruct nls_table *nls_disk = HFS_SB(sb)->nls_disk;\n\tstruct nls_table *nls_io = HFS_SB(sb)->nls_io;\n\tconst char *src;\n\tchar *dst;\n\tint srclen, dstlen, size;\n\n\tsrc = in->name;\n\tsrclen = in->len;\n\tdst = out->name;\n\tdstlen = HFS_NAMELEN;\n\tif (nls_io) {\n\t\twchar_t ch;\n\n\t\twhile (srclen > 0) {\n\t\t\tsize = nls_io->char2uni(src, srclen, &ch);\n\t\t\tif (size < 0) {\n\t\t\t\tch = '?';\n\t\t\t\tsize = 1;\n\t\t\t}\n\t\t\tsrc += size;\n\t\t\tsrclen -= size;\n\t\t\tif (ch == ':')\n\t\t\t\tch = '/';\n\t\t\tif (nls_disk) {\n\t\t\t\tsize = nls_disk->uni2char(ch, dst, dstlen);\n\t\t\t\tif (size < 0) {\n\t\t\t\t\tif (size == -ENAMETOOLONG)\n\t\t\t\t\t\tgoto out;\n\t\t\t\t\t*dst = '?';\n\t\t\t\t\tsize = 1;\n\t\t\t\t}\n\t\t\t\tdst += size;\n\t\t\t\tdstlen -= size;\n\t\t\t} else {\n\t\t\t\t*dst++ = ch > 0xff ? '?' : ch;\n\t\t\t\tdstlen--;\n\t\t\t}\n\t\t}\n\t} else {\n\t\tchar ch;\n\n\t\tif (dstlen > srclen)\n\t\t\tdstlen = srclen;\n\t\twhile (--dstlen >= 0)\n\t\t\t*dst++ = (ch = *src++) == ':' ? '/' : ch;\n\t}\nout:\n\tout->len = dst - (char *)out->name;\n\tdstlen = HFS_NAMELEN - out->len;\n\twhile (--dstlen >= 0)\n\t\t*dst++ = 0;\n}",
          "includes": [
            "#include \"hfs_fs.h\"",
            "#include <linux/nls.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hfs_fs.h\"\n#include <linux/nls.h>\n#include <linux/types.h>\n\nvoid hfs_asc2mac(struct super_block *sb, struct hfs_name *out, struct qstr *in)\n{\n\tstruct nls_table *nls_disk = HFS_SB(sb)->nls_disk;\n\tstruct nls_table *nls_io = HFS_SB(sb)->nls_io;\n\tconst char *src;\n\tchar *dst;\n\tint srclen, dstlen, size;\n\n\tsrc = in->name;\n\tsrclen = in->len;\n\tdst = out->name;\n\tdstlen = HFS_NAMELEN;\n\tif (nls_io) {\n\t\twchar_t ch;\n\n\t\twhile (srclen > 0) {\n\t\t\tsize = nls_io->char2uni(src, srclen, &ch);\n\t\t\tif (size < 0) {\n\t\t\t\tch = '?';\n\t\t\t\tsize = 1;\n\t\t\t}\n\t\t\tsrc += size;\n\t\t\tsrclen -= size;\n\t\t\tif (ch == ':')\n\t\t\t\tch = '/';\n\t\t\tif (nls_disk) {\n\t\t\t\tsize = nls_disk->uni2char(ch, dst, dstlen);\n\t\t\t\tif (size < 0) {\n\t\t\t\t\tif (size == -ENAMETOOLONG)\n\t\t\t\t\t\tgoto out;\n\t\t\t\t\t*dst = '?';\n\t\t\t\t\tsize = 1;\n\t\t\t\t}\n\t\t\t\tdst += size;\n\t\t\t\tdstlen -= size;\n\t\t\t} else {\n\t\t\t\t*dst++ = ch > 0xff ? '?' : ch;\n\t\t\t\tdstlen--;\n\t\t\t}\n\t\t}\n\t} else {\n\t\tchar ch;\n\n\t\tif (dstlen > srclen)\n\t\t\tdstlen = srclen;\n\t\twhile (--dstlen >= 0)\n\t\t\t*dst++ = (ch = *src++) == ':' ? '/' : ch;\n\t}\nout:\n\tout->len = dst - (char *)out->name;\n\tdstlen = HFS_NAMELEN - out->len;\n\twhile (--dstlen >= 0)\n\t\t*dst++ = 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "parent"
          ],
          "line": 26
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"btree.h\"\n#include \"hfs_fs.h\"\n\nvoid hfs_cat_build_key(struct super_block *sb, btree_key *key, u32 parent, struct qstr *name)\n{\n\tkey->cat.reserved = 0;\n\tkey->cat.ParID = cpu_to_be32(parent);\n\tif (name) {\n\t\thfs_asc2mac(sb, &key->cat.CName, name);\n\t\tkey->key_len = 6 + key->cat.CName.len;\n\t} else {\n\t\tmemset(&key->cat.CName, 0, sizeof(struct hfs_name));\n\t\tkey->key_len = 6;\n\t}\n}"
  }
]