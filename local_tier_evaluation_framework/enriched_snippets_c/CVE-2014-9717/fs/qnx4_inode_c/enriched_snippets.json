[
  {
    "function_name": "exit_qnx4_fs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/qnx4/inode.c",
    "lines": "417-421",
    "snippet": "static void __exit exit_qnx4_fs(void)\n{\n\tunregister_filesystem(&qnx4_fs_type);\n\tdestroy_inodecache();\n}",
    "includes": [
      "#include \"qnx4.h\"",
      "#include <linux/statfs.h>",
      "#include <linux/writeback.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/highuid.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct file_system_type qnx4_fs_type = {\n\t.owner\t\t= THIS_MODULE,\n\t.name\t\t= \"qnx4\",\n\t.mount\t\t= qnx4_mount,\n\t.kill_sb\t= qnx4_kill_sb,\n\t.fs_flags\t= FS_REQUIRES_DEV,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "destroy_inodecache",
          "args": [],
          "line": 420
        },
        "resolved": true,
        "details": {
          "function_name": "destroy_inodecache",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/qnx4/inode.c",
          "lines": "374-382",
          "snippet": "static void destroy_inodecache(void)\n{\n\t/*\n\t * Make sure all delayed rcu free inodes are flushed before we\n\t * destroy cache.\n\t */\n\trcu_barrier();\n\tkmem_cache_destroy(qnx4_inode_cachep);\n}",
          "includes": [
            "#include \"qnx4.h\"",
            "#include <linux/statfs.h>",
            "#include <linux/writeback.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highuid.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kmem_cache *qnx4_inode_cachep;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"qnx4.h\"\n#include <linux/statfs.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n#include <linux/highuid.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nstatic struct kmem_cache *qnx4_inode_cachep;\n\nstatic void destroy_inodecache(void)\n{\n\t/*\n\t * Make sure all delayed rcu free inodes are flushed before we\n\t * destroy cache.\n\t */\n\trcu_barrier();\n\tkmem_cache_destroy(qnx4_inode_cachep);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unregister_filesystem",
          "args": [
            "&qnx4_fs_type"
          ],
          "line": 419
        },
        "resolved": true,
        "details": {
          "function_name": "unregister_filesystem",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/filesystems.c",
          "lines": "101-120",
          "snippet": "int unregister_filesystem(struct file_system_type * fs)\n{\n\tstruct file_system_type ** tmp;\n\n\twrite_lock(&file_systems_lock);\n\ttmp = &file_systems;\n\twhile (*tmp) {\n\t\tif (fs == *tmp) {\n\t\t\t*tmp = fs->next;\n\t\t\tfs->next = NULL;\n\t\t\twrite_unlock(&file_systems_lock);\n\t\t\tsynchronize_rcu();\n\t\t\treturn 0;\n\t\t}\n\t\ttmp = &(*tmp)->next;\n\t}\n\twrite_unlock(&file_systems_lock);\n\n\treturn -EINVAL;\n}",
          "includes": [
            "#include <asm/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/kmod.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct file_system_type *file_systems;",
            "static DEFINE_RWLOCK(file_systems_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/uaccess.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kmod.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n\nstatic struct file_system_type *file_systems;\nstatic DEFINE_RWLOCK(file_systems_lock);\n\nint unregister_filesystem(struct file_system_type * fs)\n{\n\tstruct file_system_type ** tmp;\n\n\twrite_lock(&file_systems_lock);\n\ttmp = &file_systems;\n\twhile (*tmp) {\n\t\tif (fs == *tmp) {\n\t\t\t*tmp = fs->next;\n\t\t\tfs->next = NULL;\n\t\t\twrite_unlock(&file_systems_lock);\n\t\t\tsynchronize_rcu();\n\t\t\treturn 0;\n\t\t}\n\t\ttmp = &(*tmp)->next;\n\t}\n\twrite_unlock(&file_systems_lock);\n\n\treturn -EINVAL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"qnx4.h\"\n#include <linux/statfs.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n#include <linux/highuid.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nstatic struct file_system_type qnx4_fs_type = {\n\t.owner\t\t= THIS_MODULE,\n\t.name\t\t= \"qnx4\",\n\t.mount\t\t= qnx4_mount,\n\t.kill_sb\t= qnx4_kill_sb,\n\t.fs_flags\t= FS_REQUIRES_DEV,\n};\n\nstatic void __exit exit_qnx4_fs(void)\n{\n\tunregister_filesystem(&qnx4_fs_type);\n\tdestroy_inodecache();\n}"
  },
  {
    "function_name": "init_qnx4_fs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/qnx4/inode.c",
    "lines": "399-415",
    "snippet": "static int __init init_qnx4_fs(void)\n{\n\tint err;\n\n\terr = init_inodecache();\n\tif (err)\n\t\treturn err;\n\n\terr = register_filesystem(&qnx4_fs_type);\n\tif (err) {\n\t\tdestroy_inodecache();\n\t\treturn err;\n\t}\n\n\tprintk(KERN_INFO \"QNX4 filesystem 0.2.3 registered.\\n\");\n\treturn 0;\n}",
    "includes": [
      "#include \"qnx4.h\"",
      "#include <linux/statfs.h>",
      "#include <linux/writeback.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/highuid.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct file_system_type qnx4_fs_type = {\n\t.owner\t\t= THIS_MODULE,\n\t.name\t\t= \"qnx4\",\n\t.mount\t\t= qnx4_mount,\n\t.kill_sb\t= qnx4_kill_sb,\n\t.fs_flags\t= FS_REQUIRES_DEV,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_INFO \"QNX4 filesystem 0.2.3 registered.\\n\""
          ],
          "line": 413
        },
        "resolved": true,
        "details": {
          "function_name": "compat_printk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/compat.c",
          "lines": "59-69",
          "snippet": "int compat_printk(const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\tif (!compat_log)\n\t\treturn 0;\n\tva_start(ap, fmt);\n\tret = vprintk(fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/ioctls.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/aio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/mm.h>",
            "#include <linux/poll.h>",
            "#include <linux/signal.h>",
            "#include <linux/highmem.h>",
            "#include <linux/security.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/personality.h>",
            "#include <linux/highuid.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/dirent.h>",
            "#include <linux/ctype.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/nfs4_mount.h>",
            "#include <linux/ncp_mount.h>",
            "#include <linux/init.h>",
            "#include <linux/ioctl.h>",
            "#include <linux/vfs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/namei.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/errno.h>",
            "#include <linux/compat.h>",
            "#include <linux/linkage.h>",
            "#include <linux/kernel.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int compat_log = 1;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/ioctls.h>\n#include <asm/mmu_context.h>\n#include <asm/uaccess.h>\n#include <linux/aio.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/fs_struct.h>\n#include <linux/mm.h>\n#include <linux/poll.h>\n#include <linux/signal.h>\n#include <linux/highmem.h>\n#include <linux/security.h>\n#include <linux/tsacct_kern.h>\n#include <linux/rwsem.h>\n#include <linux/personality.h>\n#include <linux/highuid.h>\n#include <linux/fsnotify.h>\n#include <linux/dirent.h>\n#include <linux/ctype.h>\n#include <linux/syscalls.h>\n#include <linux/nfs4_mount.h>\n#include <linux/ncp_mount.h>\n#include <linux/init.h>\n#include <linux/ioctl.h>\n#include <linux/vfs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/namei.h>\n#include <linux/fcntl.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <linux/compat.h>\n#include <linux/linkage.h>\n#include <linux/kernel.h>\n#include <linux/stddef.h>\n\nint compat_log = 1;\n\nint compat_printk(const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\tif (!compat_log)\n\t\treturn 0;\n\tva_start(ap, fmt);\n\tret = vprintk(fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "destroy_inodecache",
          "args": [],
          "line": 409
        },
        "resolved": true,
        "details": {
          "function_name": "destroy_inodecache",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/qnx4/inode.c",
          "lines": "374-382",
          "snippet": "static void destroy_inodecache(void)\n{\n\t/*\n\t * Make sure all delayed rcu free inodes are flushed before we\n\t * destroy cache.\n\t */\n\trcu_barrier();\n\tkmem_cache_destroy(qnx4_inode_cachep);\n}",
          "includes": [
            "#include \"qnx4.h\"",
            "#include <linux/statfs.h>",
            "#include <linux/writeback.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highuid.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kmem_cache *qnx4_inode_cachep;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"qnx4.h\"\n#include <linux/statfs.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n#include <linux/highuid.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nstatic struct kmem_cache *qnx4_inode_cachep;\n\nstatic void destroy_inodecache(void)\n{\n\t/*\n\t * Make sure all delayed rcu free inodes are flushed before we\n\t * destroy cache.\n\t */\n\trcu_barrier();\n\tkmem_cache_destroy(qnx4_inode_cachep);\n}"
        }
      },
      {
        "call_info": {
          "callee": "register_filesystem",
          "args": [
            "&qnx4_fs_type"
          ],
          "line": 407
        },
        "resolved": true,
        "details": {
          "function_name": "unregister_filesystem",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/filesystems.c",
          "lines": "101-120",
          "snippet": "int unregister_filesystem(struct file_system_type * fs)\n{\n\tstruct file_system_type ** tmp;\n\n\twrite_lock(&file_systems_lock);\n\ttmp = &file_systems;\n\twhile (*tmp) {\n\t\tif (fs == *tmp) {\n\t\t\t*tmp = fs->next;\n\t\t\tfs->next = NULL;\n\t\t\twrite_unlock(&file_systems_lock);\n\t\t\tsynchronize_rcu();\n\t\t\treturn 0;\n\t\t}\n\t\ttmp = &(*tmp)->next;\n\t}\n\twrite_unlock(&file_systems_lock);\n\n\treturn -EINVAL;\n}",
          "includes": [
            "#include <asm/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/kmod.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct file_system_type *file_systems;",
            "static DEFINE_RWLOCK(file_systems_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/uaccess.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kmod.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n\nstatic struct file_system_type *file_systems;\nstatic DEFINE_RWLOCK(file_systems_lock);\n\nint unregister_filesystem(struct file_system_type * fs)\n{\n\tstruct file_system_type ** tmp;\n\n\twrite_lock(&file_systems_lock);\n\ttmp = &file_systems;\n\twhile (*tmp) {\n\t\tif (fs == *tmp) {\n\t\t\t*tmp = fs->next;\n\t\t\tfs->next = NULL;\n\t\t\twrite_unlock(&file_systems_lock);\n\t\t\tsynchronize_rcu();\n\t\t\treturn 0;\n\t\t}\n\t\ttmp = &(*tmp)->next;\n\t}\n\twrite_unlock(&file_systems_lock);\n\n\treturn -EINVAL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "init_inodecache",
          "args": [],
          "line": 403
        },
        "resolved": true,
        "details": {
          "function_name": "init_inodecache",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/qnx4/inode.c",
          "lines": "362-372",
          "snippet": "static int init_inodecache(void)\n{\n\tqnx4_inode_cachep = kmem_cache_create(\"qnx4_inode_cache\",\n\t\t\t\t\t     sizeof(struct qnx4_inode_info),\n\t\t\t\t\t     0, (SLAB_RECLAIM_ACCOUNT|\n\t\t\t\t\t\tSLAB_MEM_SPREAD),\n\t\t\t\t\t     init_once);\n\tif (qnx4_inode_cachep == NULL)\n\t\treturn -ENOMEM;\n\treturn 0;\n}",
          "includes": [
            "#include \"qnx4.h\"",
            "#include <linux/statfs.h>",
            "#include <linux/writeback.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highuid.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kmem_cache *qnx4_inode_cachep;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"qnx4.h\"\n#include <linux/statfs.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n#include <linux/highuid.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nstatic struct kmem_cache *qnx4_inode_cachep;\n\nstatic int init_inodecache(void)\n{\n\tqnx4_inode_cachep = kmem_cache_create(\"qnx4_inode_cache\",\n\t\t\t\t\t     sizeof(struct qnx4_inode_info),\n\t\t\t\t\t     0, (SLAB_RECLAIM_ACCOUNT|\n\t\t\t\t\t\tSLAB_MEM_SPREAD),\n\t\t\t\t\t     init_once);\n\tif (qnx4_inode_cachep == NULL)\n\t\treturn -ENOMEM;\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"qnx4.h\"\n#include <linux/statfs.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n#include <linux/highuid.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nstatic struct file_system_type qnx4_fs_type = {\n\t.owner\t\t= THIS_MODULE,\n\t.name\t\t= \"qnx4\",\n\t.mount\t\t= qnx4_mount,\n\t.kill_sb\t= qnx4_kill_sb,\n\t.fs_flags\t= FS_REQUIRES_DEV,\n};\n\nstatic int __init init_qnx4_fs(void)\n{\n\tint err;\n\n\terr = init_inodecache();\n\tif (err)\n\t\treturn err;\n\n\terr = register_filesystem(&qnx4_fs_type);\n\tif (err) {\n\t\tdestroy_inodecache();\n\t\treturn err;\n\t}\n\n\tprintk(KERN_INFO \"QNX4 filesystem 0.2.3 registered.\\n\");\n\treturn 0;\n}"
  },
  {
    "function_name": "qnx4_mount",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/qnx4/inode.c",
    "lines": "384-388",
    "snippet": "static struct dentry *qnx4_mount(struct file_system_type *fs_type,\n\tint flags, const char *dev_name, void *data)\n{\n\treturn mount_bdev(fs_type, flags, dev_name, data, qnx4_fill_super);\n}",
    "includes": [
      "#include \"qnx4.h\"",
      "#include <linux/statfs.h>",
      "#include <linux/writeback.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/highuid.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int qnx4_remount(struct super_block *sb, int *flags, char *data);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mount_bdev",
          "args": [
            "fs_type",
            "flags",
            "dev_name",
            "data",
            "qnx4_fill_super"
          ],
          "line": 387
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"qnx4.h\"\n#include <linux/statfs.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n#include <linux/highuid.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nstatic int qnx4_remount(struct super_block *sb, int *flags, char *data);\n\nstatic struct dentry *qnx4_mount(struct file_system_type *fs_type,\n\tint flags, const char *dev_name, void *data)\n{\n\treturn mount_bdev(fs_type, flags, dev_name, data, qnx4_fill_super);\n}"
  },
  {
    "function_name": "destroy_inodecache",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/qnx4/inode.c",
    "lines": "374-382",
    "snippet": "static void destroy_inodecache(void)\n{\n\t/*\n\t * Make sure all delayed rcu free inodes are flushed before we\n\t * destroy cache.\n\t */\n\trcu_barrier();\n\tkmem_cache_destroy(qnx4_inode_cachep);\n}",
    "includes": [
      "#include \"qnx4.h\"",
      "#include <linux/statfs.h>",
      "#include <linux/writeback.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/highuid.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct kmem_cache *qnx4_inode_cachep;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kmem_cache_destroy",
          "args": [
            "qnx4_inode_cachep"
          ],
          "line": 381
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_barrier",
          "args": [],
          "line": 380
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"qnx4.h\"\n#include <linux/statfs.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n#include <linux/highuid.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nstatic struct kmem_cache *qnx4_inode_cachep;\n\nstatic void destroy_inodecache(void)\n{\n\t/*\n\t * Make sure all delayed rcu free inodes are flushed before we\n\t * destroy cache.\n\t */\n\trcu_barrier();\n\tkmem_cache_destroy(qnx4_inode_cachep);\n}"
  },
  {
    "function_name": "init_inodecache",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/qnx4/inode.c",
    "lines": "362-372",
    "snippet": "static int init_inodecache(void)\n{\n\tqnx4_inode_cachep = kmem_cache_create(\"qnx4_inode_cache\",\n\t\t\t\t\t     sizeof(struct qnx4_inode_info),\n\t\t\t\t\t     0, (SLAB_RECLAIM_ACCOUNT|\n\t\t\t\t\t\tSLAB_MEM_SPREAD),\n\t\t\t\t\t     init_once);\n\tif (qnx4_inode_cachep == NULL)\n\t\treturn -ENOMEM;\n\treturn 0;\n}",
    "includes": [
      "#include \"qnx4.h\"",
      "#include <linux/statfs.h>",
      "#include <linux/writeback.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/highuid.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct kmem_cache *qnx4_inode_cachep;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kmem_cache_create",
          "args": [
            "\"qnx4_inode_cache\"",
            "sizeof(struct qnx4_inode_info)",
            "0",
            "(SLAB_RECLAIM_ACCOUNT|\n\t\t\t\t\t\tSLAB_MEM_SPREAD)",
            "init_once"
          ],
          "line": 364
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"qnx4.h\"\n#include <linux/statfs.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n#include <linux/highuid.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nstatic struct kmem_cache *qnx4_inode_cachep;\n\nstatic int init_inodecache(void)\n{\n\tqnx4_inode_cachep = kmem_cache_create(\"qnx4_inode_cache\",\n\t\t\t\t\t     sizeof(struct qnx4_inode_info),\n\t\t\t\t\t     0, (SLAB_RECLAIM_ACCOUNT|\n\t\t\t\t\t\tSLAB_MEM_SPREAD),\n\t\t\t\t\t     init_once);\n\tif (qnx4_inode_cachep == NULL)\n\t\treturn -ENOMEM;\n\treturn 0;\n}"
  },
  {
    "function_name": "init_once",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/qnx4/inode.c",
    "lines": "355-360",
    "snippet": "static void init_once(void *foo)\n{\n\tstruct qnx4_inode_info *ei = (struct qnx4_inode_info *) foo;\n\n\tinode_init_once(&ei->vfs_inode);\n}",
    "includes": [
      "#include \"qnx4.h\"",
      "#include <linux/statfs.h>",
      "#include <linux/writeback.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/highuid.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "inode_init_once",
          "args": [
            "&ei->vfs_inode"
          ],
          "line": 359
        },
        "resolved": true,
        "details": {
          "function_name": "inode_init_once",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "355-367",
          "snippet": "void inode_init_once(struct inode *inode)\n{\n\tmemset(inode, 0, sizeof(*inode));\n\tINIT_HLIST_NODE(&inode->i_hash);\n\tINIT_LIST_HEAD(&inode->i_devices);\n\tINIT_LIST_HEAD(&inode->i_wb_list);\n\tINIT_LIST_HEAD(&inode->i_lru);\n\taddress_space_init_once(&inode->i_data);\n\ti_size_ordered_init(inode);\n#ifdef CONFIG_FSNOTIFY\n\tINIT_HLIST_HEAD(&inode->i_fsnotify_marks);\n#endif\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid inode_init_once(struct inode *inode)\n{\n\tmemset(inode, 0, sizeof(*inode));\n\tINIT_HLIST_NODE(&inode->i_hash);\n\tINIT_LIST_HEAD(&inode->i_devices);\n\tINIT_LIST_HEAD(&inode->i_wb_list);\n\tINIT_LIST_HEAD(&inode->i_lru);\n\taddress_space_init_once(&inode->i_data);\n\ti_size_ordered_init(inode);\n#ifdef CONFIG_FSNOTIFY\n\tINIT_HLIST_HEAD(&inode->i_fsnotify_marks);\n#endif\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"qnx4.h\"\n#include <linux/statfs.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n#include <linux/highuid.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nstatic void init_once(void *foo)\n{\n\tstruct qnx4_inode_info *ei = (struct qnx4_inode_info *) foo;\n\n\tinode_init_once(&ei->vfs_inode);\n}"
  },
  {
    "function_name": "qnx4_destroy_inode",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/qnx4/inode.c",
    "lines": "350-353",
    "snippet": "static void qnx4_destroy_inode(struct inode *inode)\n{\n\tcall_rcu(&inode->i_rcu, qnx4_i_callback);\n}",
    "includes": [
      "#include \"qnx4.h\"",
      "#include <linux/statfs.h>",
      "#include <linux/writeback.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/highuid.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void qnx4_destroy_inode(struct inode *inode);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "call_rcu",
          "args": [
            "&inode->i_rcu",
            "qnx4_i_callback"
          ],
          "line": 352
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"qnx4.h\"\n#include <linux/statfs.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n#include <linux/highuid.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nstatic void qnx4_destroy_inode(struct inode *inode);\n\nstatic void qnx4_destroy_inode(struct inode *inode)\n{\n\tcall_rcu(&inode->i_rcu, qnx4_i_callback);\n}"
  },
  {
    "function_name": "qnx4_i_callback",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/qnx4/inode.c",
    "lines": "344-348",
    "snippet": "static void qnx4_i_callback(struct rcu_head *head)\n{\n\tstruct inode *inode = container_of(head, struct inode, i_rcu);\n\tkmem_cache_free(qnx4_inode_cachep, qnx4_i(inode));\n}",
    "includes": [
      "#include \"qnx4.h\"",
      "#include <linux/statfs.h>",
      "#include <linux/writeback.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/highuid.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void qnx4_destroy_inode(struct inode *inode);",
      "static struct kmem_cache *qnx4_inode_cachep;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kmem_cache_free",
          "args": [
            "qnx4_inode_cachep",
            "qnx4_i(inode)"
          ],
          "line": 347
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "qnx4_i",
          "args": [
            "inode"
          ],
          "line": 347
        },
        "resolved": true,
        "details": {
          "function_name": "qnx4_i_callback",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/qnx4/inode.c",
          "lines": "344-348",
          "snippet": "static void qnx4_i_callback(struct rcu_head *head)\n{\n\tstruct inode *inode = container_of(head, struct inode, i_rcu);\n\tkmem_cache_free(qnx4_inode_cachep, qnx4_i(inode));\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "head",
            "structinode",
            "i_rcu"
          ],
          "line": 346
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"qnx4.h\"\n#include <linux/statfs.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n#include <linux/highuid.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nstatic void qnx4_destroy_inode(struct inode *inode);\nstatic struct kmem_cache *qnx4_inode_cachep;\n\nstatic void qnx4_i_callback(struct rcu_head *head)\n{\n\tstruct inode *inode = container_of(head, struct inode, i_rcu);\n\tkmem_cache_free(qnx4_inode_cachep, qnx4_i(inode));\n}"
  },
  {
    "function_name": "qnx4_alloc_inode",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/qnx4/inode.c",
    "lines": "335-342",
    "snippet": "static struct inode *qnx4_alloc_inode(struct super_block *sb)\n{\n\tstruct qnx4_inode_info *ei;\n\tei = kmem_cache_alloc(qnx4_inode_cachep, GFP_KERNEL);\n\tif (!ei)\n\t\treturn NULL;\n\treturn &ei->vfs_inode;\n}",
    "includes": [
      "#include \"qnx4.h\"",
      "#include <linux/statfs.h>",
      "#include <linux/writeback.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/highuid.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct inode *qnx4_alloc_inode(struct super_block *sb);",
      "static void qnx4_destroy_inode(struct inode *inode);",
      "static struct kmem_cache *qnx4_inode_cachep;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kmem_cache_alloc",
          "args": [
            "qnx4_inode_cachep",
            "GFP_KERNEL"
          ],
          "line": 338
        },
        "resolved": true,
        "details": {
          "function_name": "f2fs_kmem_cache_alloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "1064-1076",
          "snippet": "static inline void *f2fs_kmem_cache_alloc(struct kmem_cache *cachep,\n\t\t\t\t\t\tgfp_t flags)\n{\n\tvoid *entry;\nretry:\n\tentry = kmem_cache_alloc(cachep, flags);\n\tif (!entry) {\n\t\tcond_resched();\n\t\tgoto retry;\n\t}\n\n\treturn entry;\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline void *f2fs_kmem_cache_alloc(struct kmem_cache *cachep,\n\t\t\t\t\t\tgfp_t flags)\n{\n\tvoid *entry;\nretry:\n\tentry = kmem_cache_alloc(cachep, flags);\n\tif (!entry) {\n\t\tcond_resched();\n\t\tgoto retry;\n\t}\n\n\treturn entry;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"qnx4.h\"\n#include <linux/statfs.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n#include <linux/highuid.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nstatic struct inode *qnx4_alloc_inode(struct super_block *sb);\nstatic void qnx4_destroy_inode(struct inode *inode);\nstatic struct kmem_cache *qnx4_inode_cachep;\n\nstatic struct inode *qnx4_alloc_inode(struct super_block *sb)\n{\n\tstruct qnx4_inode_info *ei;\n\tei = kmem_cache_alloc(qnx4_inode_cachep, GFP_KERNEL);\n\tif (!ei)\n\t\treturn NULL;\n\treturn &ei->vfs_inode;\n}"
  },
  {
    "function_name": "qnx4_iget",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/qnx4/inode.c",
    "lines": "260-331",
    "snippet": "struct inode *qnx4_iget(struct super_block *sb, unsigned long ino)\n{\n\tstruct buffer_head *bh;\n\tstruct qnx4_inode_entry *raw_inode;\n\tint block;\n\tstruct qnx4_inode_entry *qnx4_inode;\n\tstruct inode *inode;\n\n\tinode = iget_locked(sb, ino);\n\tif (!inode)\n\t\treturn ERR_PTR(-ENOMEM);\n\tif (!(inode->i_state & I_NEW))\n\t\treturn inode;\n\n\tqnx4_inode = qnx4_raw_inode(inode);\n\tinode->i_mode = 0;\n\n\tQNX4DEBUG((KERN_INFO \"reading inode : [%d]\\n\", ino));\n\tif (!ino) {\n\t\tprintk(KERN_ERR \"qnx4: bad inode number on dev %s: %lu is \"\n\t\t\t\t\"out of range\\n\",\n\t\t       sb->s_id, ino);\n\t\tiget_failed(inode);\n\t\treturn ERR_PTR(-EIO);\n\t}\n\tblock = ino / QNX4_INODES_PER_BLOCK;\n\n\tif (!(bh = sb_bread(sb, block))) {\n\t\tprintk(KERN_ERR \"qnx4: major problem: unable to read inode from dev \"\n\t\t       \"%s\\n\", sb->s_id);\n\t\tiget_failed(inode);\n\t\treturn ERR_PTR(-EIO);\n\t}\n\traw_inode = ((struct qnx4_inode_entry *) bh->b_data) +\n\t    (ino % QNX4_INODES_PER_BLOCK);\n\n\tinode->i_mode    = le16_to_cpu(raw_inode->di_mode);\n\ti_uid_write(inode, (uid_t)le16_to_cpu(raw_inode->di_uid));\n\ti_gid_write(inode, (gid_t)le16_to_cpu(raw_inode->di_gid));\n\tset_nlink(inode, le16_to_cpu(raw_inode->di_nlink));\n\tinode->i_size    = le32_to_cpu(raw_inode->di_size);\n\tinode->i_mtime.tv_sec   = le32_to_cpu(raw_inode->di_mtime);\n\tinode->i_mtime.tv_nsec = 0;\n\tinode->i_atime.tv_sec   = le32_to_cpu(raw_inode->di_atime);\n\tinode->i_atime.tv_nsec = 0;\n\tinode->i_ctime.tv_sec   = le32_to_cpu(raw_inode->di_ctime);\n\tinode->i_ctime.tv_nsec = 0;\n\tinode->i_blocks  = le32_to_cpu(raw_inode->di_first_xtnt.xtnt_size);\n\n\tmemcpy(qnx4_inode, raw_inode, QNX4_DIR_ENTRY_SIZE);\n\tif (S_ISREG(inode->i_mode)) {\n\t\tinode->i_fop = &generic_ro_fops;\n\t\tinode->i_mapping->a_ops = &qnx4_aops;\n\t\tqnx4_i(inode)->mmu_private = inode->i_size;\n\t} else if (S_ISDIR(inode->i_mode)) {\n\t\tinode->i_op = &qnx4_dir_inode_operations;\n\t\tinode->i_fop = &qnx4_dir_operations;\n\t} else if (S_ISLNK(inode->i_mode)) {\n\t\tinode->i_op = &page_symlink_inode_operations;\n\t\tinode->i_mapping->a_ops = &qnx4_aops;\n\t\tqnx4_i(inode)->mmu_private = inode->i_size;\n\t} else {\n\t\tprintk(KERN_ERR \"qnx4: bad inode %lu on dev %s\\n\",\n\t\t\tino, sb->s_id);\n\t\tiget_failed(inode);\n\t\tbrelse(bh);\n\t\treturn ERR_PTR(-EIO);\n\t}\n\tbrelse(bh);\n\tunlock_new_inode(inode);\n\treturn inode;\n}",
    "includes": [
      "#include \"qnx4.h\"",
      "#include <linux/statfs.h>",
      "#include <linux/writeback.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/highuid.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct inode *qnx4_alloc_inode(struct super_block *sb);",
      "static void qnx4_destroy_inode(struct inode *inode);",
      "static const struct address_space_operations qnx4_aops = {\n\t.readpage\t= qnx4_readpage,\n\t.bmap\t\t= qnx4_bmap\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "unlock_new_inode",
          "args": [
            "inode"
          ],
          "line": 329
        },
        "resolved": true,
        "details": {
          "function_name": "unlock_new_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "924-933",
          "snippet": "void unlock_new_inode(struct inode *inode)\n{\n\tlockdep_annotate_inode_mutex_key(inode);\n\tspin_lock(&inode->i_lock);\n\tWARN_ON(!(inode->i_state & I_NEW));\n\tinode->i_state &= ~I_NEW;\n\tsmp_mb();\n\twake_up_bit(&inode->i_state, __I_NEW);\n\tspin_unlock(&inode->i_lock);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid unlock_new_inode(struct inode *inode)\n{\n\tlockdep_annotate_inode_mutex_key(inode);\n\tspin_lock(&inode->i_lock);\n\tWARN_ON(!(inode->i_state & I_NEW));\n\tinode->i_state &= ~I_NEW;\n\tsmp_mb();\n\twake_up_bit(&inode->i_state, __I_NEW);\n\tspin_unlock(&inode->i_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "brelse",
          "args": [
            "bh"
          ],
          "line": 328
        },
        "resolved": true,
        "details": {
          "function_name": "__brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1177-1184",
          "snippet": "void __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-EIO"
          ],
          "line": 326
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "iget_failed",
          "args": [
            "inode"
          ],
          "line": 324
        },
        "resolved": true,
        "details": {
          "function_name": "iget_failed",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/bad_inode.c",
          "lines": "208-213",
          "snippet": "void iget_failed(struct inode *inode)\n{\n\tmake_bad_inode(inode);\n\tunlock_new_inode(inode);\n\tiput(inode);\n}",
          "includes": [
            "#include <linux/poll.h>",
            "#include <linux/namei.h>",
            "#include <linux/time.h>",
            "#include <linux/stat.h>",
            "#include <linux/export.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/poll.h>\n#include <linux/namei.h>\n#include <linux/time.h>\n#include <linux/stat.h>\n#include <linux/export.h>\n#include <linux/fs.h>\n\nvoid iget_failed(struct inode *inode)\n{\n\tmake_bad_inode(inode);\n\tunlock_new_inode(inode);\n\tiput(inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_ERR \"qnx4: bad inode %lu on dev %s\\n\"",
            "ino",
            "sb->s_id"
          ],
          "line": 322
        },
        "resolved": true,
        "details": {
          "function_name": "compat_printk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/compat.c",
          "lines": "59-69",
          "snippet": "int compat_printk(const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\tif (!compat_log)\n\t\treturn 0;\n\tva_start(ap, fmt);\n\tret = vprintk(fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/ioctls.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/aio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/mm.h>",
            "#include <linux/poll.h>",
            "#include <linux/signal.h>",
            "#include <linux/highmem.h>",
            "#include <linux/security.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/personality.h>",
            "#include <linux/highuid.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/dirent.h>",
            "#include <linux/ctype.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/nfs4_mount.h>",
            "#include <linux/ncp_mount.h>",
            "#include <linux/init.h>",
            "#include <linux/ioctl.h>",
            "#include <linux/vfs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/namei.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/errno.h>",
            "#include <linux/compat.h>",
            "#include <linux/linkage.h>",
            "#include <linux/kernel.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int compat_log = 1;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/ioctls.h>\n#include <asm/mmu_context.h>\n#include <asm/uaccess.h>\n#include <linux/aio.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/fs_struct.h>\n#include <linux/mm.h>\n#include <linux/poll.h>\n#include <linux/signal.h>\n#include <linux/highmem.h>\n#include <linux/security.h>\n#include <linux/tsacct_kern.h>\n#include <linux/rwsem.h>\n#include <linux/personality.h>\n#include <linux/highuid.h>\n#include <linux/fsnotify.h>\n#include <linux/dirent.h>\n#include <linux/ctype.h>\n#include <linux/syscalls.h>\n#include <linux/nfs4_mount.h>\n#include <linux/ncp_mount.h>\n#include <linux/init.h>\n#include <linux/ioctl.h>\n#include <linux/vfs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/namei.h>\n#include <linux/fcntl.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <linux/compat.h>\n#include <linux/linkage.h>\n#include <linux/kernel.h>\n#include <linux/stddef.h>\n\nint compat_log = 1;\n\nint compat_printk(const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\tif (!compat_log)\n\t\treturn 0;\n\tva_start(ap, fmt);\n\tret = vprintk(fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "qnx4_i",
          "args": [
            "inode"
          ],
          "line": 320
        },
        "resolved": true,
        "details": {
          "function_name": "qnx4_i_callback",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/qnx4/inode.c",
          "lines": "344-348",
          "snippet": "static void qnx4_i_callback(struct rcu_head *head)\n{\n\tstruct inode *inode = container_of(head, struct inode, i_rcu);\n\tkmem_cache_free(qnx4_inode_cachep, qnx4_i(inode));\n}",
          "includes": [
            "#include \"qnx4.h\"",
            "#include <linux/statfs.h>",
            "#include <linux/writeback.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highuid.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void qnx4_destroy_inode(struct inode *inode);",
            "static struct kmem_cache *qnx4_inode_cachep;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"qnx4.h\"\n#include <linux/statfs.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n#include <linux/highuid.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nstatic void qnx4_destroy_inode(struct inode *inode);\nstatic struct kmem_cache *qnx4_inode_cachep;\n\nstatic void qnx4_i_callback(struct rcu_head *head)\n{\n\tstruct inode *inode = container_of(head, struct inode, i_rcu);\n\tkmem_cache_free(qnx4_inode_cachep, qnx4_i(inode));\n}"
        }
      },
      {
        "call_info": {
          "callee": "S_ISLNK",
          "args": [
            "inode->i_mode"
          ],
          "line": 317
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISDIR",
          "args": [
            "inode->i_mode"
          ],
          "line": 314
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISREG",
          "args": [
            "inode->i_mode"
          ],
          "line": 310
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "qnx4_inode",
            "raw_inode",
            "QNX4_DIR_ENTRY_SIZE"
          ],
          "line": 309
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "raw_inode->di_first_xtnt.xtnt_size"
          ],
          "line": 307
        },
        "resolved": true,
        "details": {
          "function_name": "sle32_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "53-56",
          "snippet": "static inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_nlink",
          "args": [
            "inode",
            "le16_to_cpu(raw_inode->di_nlink)"
          ],
          "line": 299
        },
        "resolved": true,
        "details": {
          "function_name": "set_nlink",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "305-316",
          "snippet": "void set_nlink(struct inode *inode, unsigned int nlink)\n{\n\tif (!nlink) {\n\t\tclear_nlink(inode);\n\t} else {\n\t\t/* Yes, some filesystems do change nlink from zero to one */\n\t\tif (inode->i_nlink == 0)\n\t\t\tatomic_long_dec(&inode->i_sb->s_remove_count);\n\n\t\tinode->__i_nlink = nlink;\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid set_nlink(struct inode *inode, unsigned int nlink)\n{\n\tif (!nlink) {\n\t\tclear_nlink(inode);\n\t} else {\n\t\t/* Yes, some filesystems do change nlink from zero to one */\n\t\tif (inode->i_nlink == 0)\n\t\t\tatomic_long_dec(&inode->i_sb->s_remove_count);\n\n\t\tinode->__i_nlink = nlink;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "le16_to_cpu",
          "args": [
            "raw_inode->di_nlink"
          ],
          "line": 299
        },
        "resolved": true,
        "details": {
          "function_name": "sle16_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "48-51",
          "snippet": "static inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "i_gid_write",
          "args": [
            "inode",
            "(gid_t)le16_to_cpu(raw_inode->di_gid)"
          ],
          "line": 298
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "i_uid_write",
          "args": [
            "inode",
            "(uid_t)le16_to_cpu(raw_inode->di_uid)"
          ],
          "line": 297
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-EIO"
          ],
          "line": 291
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sb_bread",
          "args": [
            "sb",
            "block"
          ],
          "line": 287
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-EIO"
          ],
          "line": 283
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "QNX4DEBUG",
          "args": [
            "(KERN_INFO \"reading inode : [%d]\\n\", ino)"
          ],
          "line": 277
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "qnx4_raw_inode",
          "args": [
            "inode"
          ],
          "line": 274
        },
        "resolved": true,
        "details": {
          "function_name": "qnx4_raw_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/qnx4/qnx4.h",
          "lines": "42-45",
          "snippet": "static inline struct qnx4_inode_entry *qnx4_raw_inode(struct inode *inode)\n{\n\treturn &qnx4_i(inode)->raw;\n}",
          "includes": [
            "#include <linux/qnx4_fs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/qnx4_fs.h>\n#include <linux/fs.h>\n\nstatic inline struct qnx4_inode_entry *qnx4_raw_inode(struct inode *inode)\n{\n\treturn &qnx4_i(inode)->raw;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-ENOMEM"
          ],
          "line": 270
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "iget_locked",
          "args": [
            "sb",
            "ino"
          ],
          "line": 268
        },
        "resolved": true,
        "details": {
          "function_name": "iget_locked",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "1063-1109",
          "snippet": "struct inode *iget_locked(struct super_block *sb, unsigned long ino)\n{\n\tstruct hlist_head *head = inode_hashtable + hash(sb, ino);\n\tstruct inode *inode;\n\n\tspin_lock(&inode_hash_lock);\n\tinode = find_inode_fast(sb, head, ino);\n\tspin_unlock(&inode_hash_lock);\n\tif (inode) {\n\t\twait_on_inode(inode);\n\t\treturn inode;\n\t}\n\n\tinode = alloc_inode(sb);\n\tif (inode) {\n\t\tstruct inode *old;\n\n\t\tspin_lock(&inode_hash_lock);\n\t\t/* We released the lock, so.. */\n\t\told = find_inode_fast(sb, head, ino);\n\t\tif (!old) {\n\t\t\tinode->i_ino = ino;\n\t\t\tspin_lock(&inode->i_lock);\n\t\t\tinode->i_state = I_NEW;\n\t\t\thlist_add_head(&inode->i_hash, head);\n\t\t\tspin_unlock(&inode->i_lock);\n\t\t\tinode_sb_list_add(inode);\n\t\t\tspin_unlock(&inode_hash_lock);\n\n\t\t\t/* Return the locked inode with I_NEW set, the\n\t\t\t * caller is responsible for filling in the contents\n\t\t\t */\n\t\t\treturn inode;\n\t\t}\n\n\t\t/*\n\t\t * Uhhuh, somebody else created the same inode under\n\t\t * us. Use the old inode instead of the one we just\n\t\t * allocated.\n\t\t */\n\t\tspin_unlock(&inode_hash_lock);\n\t\tdestroy_inode(inode);\n\t\tinode = old;\n\t\twait_on_inode(inode);\n\t}\n\treturn inode;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct hlist_head *inode_hashtable",
            "static __cacheline_aligned_in_smp DEFINE_SPINLOCK(inode_hash_lock);",
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic struct hlist_head *inode_hashtable;\nstatic __cacheline_aligned_in_smp DEFINE_SPINLOCK(inode_hash_lock);\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nstruct inode *iget_locked(struct super_block *sb, unsigned long ino)\n{\n\tstruct hlist_head *head = inode_hashtable + hash(sb, ino);\n\tstruct inode *inode;\n\n\tspin_lock(&inode_hash_lock);\n\tinode = find_inode_fast(sb, head, ino);\n\tspin_unlock(&inode_hash_lock);\n\tif (inode) {\n\t\twait_on_inode(inode);\n\t\treturn inode;\n\t}\n\n\tinode = alloc_inode(sb);\n\tif (inode) {\n\t\tstruct inode *old;\n\n\t\tspin_lock(&inode_hash_lock);\n\t\t/* We released the lock, so.. */\n\t\told = find_inode_fast(sb, head, ino);\n\t\tif (!old) {\n\t\t\tinode->i_ino = ino;\n\t\t\tspin_lock(&inode->i_lock);\n\t\t\tinode->i_state = I_NEW;\n\t\t\thlist_add_head(&inode->i_hash, head);\n\t\t\tspin_unlock(&inode->i_lock);\n\t\t\tinode_sb_list_add(inode);\n\t\t\tspin_unlock(&inode_hash_lock);\n\n\t\t\t/* Return the locked inode with I_NEW set, the\n\t\t\t * caller is responsible for filling in the contents\n\t\t\t */\n\t\t\treturn inode;\n\t\t}\n\n\t\t/*\n\t\t * Uhhuh, somebody else created the same inode under\n\t\t * us. Use the old inode instead of the one we just\n\t\t * allocated.\n\t\t */\n\t\tspin_unlock(&inode_hash_lock);\n\t\tdestroy_inode(inode);\n\t\tinode = old;\n\t\twait_on_inode(inode);\n\t}\n\treturn inode;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"qnx4.h\"\n#include <linux/statfs.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n#include <linux/highuid.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nstatic struct inode *qnx4_alloc_inode(struct super_block *sb);\nstatic void qnx4_destroy_inode(struct inode *inode);\nstatic const struct address_space_operations qnx4_aops = {\n\t.readpage\t= qnx4_readpage,\n\t.bmap\t\t= qnx4_bmap\n};\n\nstruct inode *qnx4_iget(struct super_block *sb, unsigned long ino)\n{\n\tstruct buffer_head *bh;\n\tstruct qnx4_inode_entry *raw_inode;\n\tint block;\n\tstruct qnx4_inode_entry *qnx4_inode;\n\tstruct inode *inode;\n\n\tinode = iget_locked(sb, ino);\n\tif (!inode)\n\t\treturn ERR_PTR(-ENOMEM);\n\tif (!(inode->i_state & I_NEW))\n\t\treturn inode;\n\n\tqnx4_inode = qnx4_raw_inode(inode);\n\tinode->i_mode = 0;\n\n\tQNX4DEBUG((KERN_INFO \"reading inode : [%d]\\n\", ino));\n\tif (!ino) {\n\t\tprintk(KERN_ERR \"qnx4: bad inode number on dev %s: %lu is \"\n\t\t\t\t\"out of range\\n\",\n\t\t       sb->s_id, ino);\n\t\tiget_failed(inode);\n\t\treturn ERR_PTR(-EIO);\n\t}\n\tblock = ino / QNX4_INODES_PER_BLOCK;\n\n\tif (!(bh = sb_bread(sb, block))) {\n\t\tprintk(KERN_ERR \"qnx4: major problem: unable to read inode from dev \"\n\t\t       \"%s\\n\", sb->s_id);\n\t\tiget_failed(inode);\n\t\treturn ERR_PTR(-EIO);\n\t}\n\traw_inode = ((struct qnx4_inode_entry *) bh->b_data) +\n\t    (ino % QNX4_INODES_PER_BLOCK);\n\n\tinode->i_mode    = le16_to_cpu(raw_inode->di_mode);\n\ti_uid_write(inode, (uid_t)le16_to_cpu(raw_inode->di_uid));\n\ti_gid_write(inode, (gid_t)le16_to_cpu(raw_inode->di_gid));\n\tset_nlink(inode, le16_to_cpu(raw_inode->di_nlink));\n\tinode->i_size    = le32_to_cpu(raw_inode->di_size);\n\tinode->i_mtime.tv_sec   = le32_to_cpu(raw_inode->di_mtime);\n\tinode->i_mtime.tv_nsec = 0;\n\tinode->i_atime.tv_sec   = le32_to_cpu(raw_inode->di_atime);\n\tinode->i_atime.tv_nsec = 0;\n\tinode->i_ctime.tv_sec   = le32_to_cpu(raw_inode->di_ctime);\n\tinode->i_ctime.tv_nsec = 0;\n\tinode->i_blocks  = le32_to_cpu(raw_inode->di_first_xtnt.xtnt_size);\n\n\tmemcpy(qnx4_inode, raw_inode, QNX4_DIR_ENTRY_SIZE);\n\tif (S_ISREG(inode->i_mode)) {\n\t\tinode->i_fop = &generic_ro_fops;\n\t\tinode->i_mapping->a_ops = &qnx4_aops;\n\t\tqnx4_i(inode)->mmu_private = inode->i_size;\n\t} else if (S_ISDIR(inode->i_mode)) {\n\t\tinode->i_op = &qnx4_dir_inode_operations;\n\t\tinode->i_fop = &qnx4_dir_operations;\n\t} else if (S_ISLNK(inode->i_mode)) {\n\t\tinode->i_op = &page_symlink_inode_operations;\n\t\tinode->i_mapping->a_ops = &qnx4_aops;\n\t\tqnx4_i(inode)->mmu_private = inode->i_size;\n\t} else {\n\t\tprintk(KERN_ERR \"qnx4: bad inode %lu on dev %s\\n\",\n\t\t\tino, sb->s_id);\n\t\tiget_failed(inode);\n\t\tbrelse(bh);\n\t\treturn ERR_PTR(-EIO);\n\t}\n\tbrelse(bh);\n\tunlock_new_inode(inode);\n\treturn inode;\n}"
  },
  {
    "function_name": "qnx4_bmap",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/qnx4/inode.c",
    "lines": "251-254",
    "snippet": "static sector_t qnx4_bmap(struct address_space *mapping, sector_t block)\n{\n\treturn generic_block_bmap(mapping,block,qnx4_get_block);\n}",
    "includes": [
      "#include \"qnx4.h\"",
      "#include <linux/statfs.h>",
      "#include <linux/writeback.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/highuid.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "generic_block_bmap",
          "args": [
            "mapping",
            "block",
            "qnx4_get_block"
          ],
          "line": 253
        },
        "resolved": true,
        "details": {
          "function_name": "generic_block_bmap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "2924-2934",
          "snippet": "sector_t generic_block_bmap(struct address_space *mapping, sector_t block,\n\t\t\t    get_block_t *get_block)\n{\n\tstruct buffer_head tmp;\n\tstruct inode *inode = mapping->host;\n\ttmp.b_state = 0;\n\ttmp.b_blocknr = 0;\n\ttmp.b_size = 1 << inode->i_blkbits;\n\tget_block(inode, block, &tmp, 0);\n\treturn tmp.b_blocknr;\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nsector_t generic_block_bmap(struct address_space *mapping, sector_t block,\n\t\t\t    get_block_t *get_block)\n{\n\tstruct buffer_head tmp;\n\tstruct inode *inode = mapping->host;\n\ttmp.b_state = 0;\n\ttmp.b_blocknr = 0;\n\ttmp.b_size = 1 << inode->i_blkbits;\n\tget_block(inode, block, &tmp, 0);\n\treturn tmp.b_blocknr;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"qnx4.h\"\n#include <linux/statfs.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n#include <linux/highuid.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nstatic sector_t qnx4_bmap(struct address_space *mapping, sector_t block)\n{\n\treturn generic_block_bmap(mapping,block,qnx4_get_block);\n}"
  },
  {
    "function_name": "qnx4_readpage",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/qnx4/inode.c",
    "lines": "246-249",
    "snippet": "static int qnx4_readpage(struct file *file, struct page *page)\n{\n\treturn block_read_full_page(page,qnx4_get_block);\n}",
    "includes": [
      "#include \"qnx4.h\"",
      "#include <linux/statfs.h>",
      "#include <linux/writeback.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/highuid.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "block_read_full_page",
          "args": [
            "page",
            "qnx4_get_block"
          ],
          "line": 248
        },
        "resolved": true,
        "details": {
          "function_name": "block_read_full_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "2159-2242",
          "snippet": "int block_read_full_page(struct page *page, get_block_t *get_block)\n{\n\tstruct inode *inode = page->mapping->host;\n\tsector_t iblock, lblock;\n\tstruct buffer_head *bh, *head, *arr[MAX_BUF_PER_PAGE];\n\tunsigned int blocksize, bbits;\n\tint nr, i;\n\tint fully_mapped = 1;\n\n\thead = create_page_buffers(page, inode, 0);\n\tblocksize = head->b_size;\n\tbbits = block_size_bits(blocksize);\n\n\tiblock = (sector_t)page->index << (PAGE_CACHE_SHIFT - bbits);\n\tlblock = (i_size_read(inode)+blocksize-1) >> bbits;\n\tbh = head;\n\tnr = 0;\n\ti = 0;\n\n\tdo {\n\t\tif (buffer_uptodate(bh))\n\t\t\tcontinue;\n\n\t\tif (!buffer_mapped(bh)) {\n\t\t\tint err = 0;\n\n\t\t\tfully_mapped = 0;\n\t\t\tif (iblock < lblock) {\n\t\t\t\tWARN_ON(bh->b_size != blocksize);\n\t\t\t\terr = get_block(inode, iblock, bh, 0);\n\t\t\t\tif (err)\n\t\t\t\t\tSetPageError(page);\n\t\t\t}\n\t\t\tif (!buffer_mapped(bh)) {\n\t\t\t\tzero_user(page, i * blocksize, blocksize);\n\t\t\t\tif (!err)\n\t\t\t\t\tset_buffer_uptodate(bh);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t/*\n\t\t\t * get_block() might have updated the buffer\n\t\t\t * synchronously\n\t\t\t */\n\t\t\tif (buffer_uptodate(bh))\n\t\t\t\tcontinue;\n\t\t}\n\t\tarr[nr++] = bh;\n\t} while (i++, iblock++, (bh = bh->b_this_page) != head);\n\n\tif (fully_mapped)\n\t\tSetPageMappedToDisk(page);\n\n\tif (!nr) {\n\t\t/*\n\t\t * All buffers are uptodate - we can set the page uptodate\n\t\t * as well. But not if get_block() returned an error.\n\t\t */\n\t\tif (!PageError(page))\n\t\t\tSetPageUptodate(page);\n\t\tunlock_page(page);\n\t\treturn 0;\n\t}\n\n\t/* Stage two: lock the buffers */\n\tfor (i = 0; i < nr; i++) {\n\t\tbh = arr[i];\n\t\tlock_buffer(bh);\n\t\tmark_buffer_async_read(bh);\n\t}\n\n\t/*\n\t * Stage 3: start the IO.  Check for uptodateness\n\t * inside the buffer lock in case another process reading\n\t * the underlying blockdev brought it uptodate (the sct fix).\n\t */\n\tfor (i = 0; i < nr; i++) {\n\t\tbh = arr[i];\n\t\tif (buffer_uptodate(bh))\n\t\t\tend_buffer_async_read(bh, 1);\n\t\telse\n\t\t\tsubmit_bh(READ, bh);\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nint block_read_full_page(struct page *page, get_block_t *get_block)\n{\n\tstruct inode *inode = page->mapping->host;\n\tsector_t iblock, lblock;\n\tstruct buffer_head *bh, *head, *arr[MAX_BUF_PER_PAGE];\n\tunsigned int blocksize, bbits;\n\tint nr, i;\n\tint fully_mapped = 1;\n\n\thead = create_page_buffers(page, inode, 0);\n\tblocksize = head->b_size;\n\tbbits = block_size_bits(blocksize);\n\n\tiblock = (sector_t)page->index << (PAGE_CACHE_SHIFT - bbits);\n\tlblock = (i_size_read(inode)+blocksize-1) >> bbits;\n\tbh = head;\n\tnr = 0;\n\ti = 0;\n\n\tdo {\n\t\tif (buffer_uptodate(bh))\n\t\t\tcontinue;\n\n\t\tif (!buffer_mapped(bh)) {\n\t\t\tint err = 0;\n\n\t\t\tfully_mapped = 0;\n\t\t\tif (iblock < lblock) {\n\t\t\t\tWARN_ON(bh->b_size != blocksize);\n\t\t\t\terr = get_block(inode, iblock, bh, 0);\n\t\t\t\tif (err)\n\t\t\t\t\tSetPageError(page);\n\t\t\t}\n\t\t\tif (!buffer_mapped(bh)) {\n\t\t\t\tzero_user(page, i * blocksize, blocksize);\n\t\t\t\tif (!err)\n\t\t\t\t\tset_buffer_uptodate(bh);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t/*\n\t\t\t * get_block() might have updated the buffer\n\t\t\t * synchronously\n\t\t\t */\n\t\t\tif (buffer_uptodate(bh))\n\t\t\t\tcontinue;\n\t\t}\n\t\tarr[nr++] = bh;\n\t} while (i++, iblock++, (bh = bh->b_this_page) != head);\n\n\tif (fully_mapped)\n\t\tSetPageMappedToDisk(page);\n\n\tif (!nr) {\n\t\t/*\n\t\t * All buffers are uptodate - we can set the page uptodate\n\t\t * as well. But not if get_block() returned an error.\n\t\t */\n\t\tif (!PageError(page))\n\t\t\tSetPageUptodate(page);\n\t\tunlock_page(page);\n\t\treturn 0;\n\t}\n\n\t/* Stage two: lock the buffers */\n\tfor (i = 0; i < nr; i++) {\n\t\tbh = arr[i];\n\t\tlock_buffer(bh);\n\t\tmark_buffer_async_read(bh);\n\t}\n\n\t/*\n\t * Stage 3: start the IO.  Check for uptodateness\n\t * inside the buffer lock in case another process reading\n\t * the underlying blockdev brought it uptodate (the sct fix).\n\t */\n\tfor (i = 0; i < nr; i++) {\n\t\tbh = arr[i];\n\t\tif (buffer_uptodate(bh))\n\t\t\tend_buffer_async_read(bh, 1);\n\t\telse\n\t\t\tsubmit_bh(READ, bh);\n\t}\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"qnx4.h\"\n#include <linux/statfs.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n#include <linux/highuid.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nstatic int qnx4_readpage(struct file *file, struct page *page)\n{\n\treturn block_read_full_page(page,qnx4_get_block);\n}"
  },
  {
    "function_name": "qnx4_kill_sb",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/qnx4/inode.c",
    "lines": "236-244",
    "snippet": "static void qnx4_kill_sb(struct super_block *sb)\n{\n\tstruct qnx4_sb_info *qs = qnx4_sb(sb);\n\tkill_block_super(sb);\n\tif (qs) {\n\t\tkfree(qs->BitMap);\n\t\tkfree(qs);\n\t}\n}",
    "includes": [
      "#include \"qnx4.h\"",
      "#include <linux/statfs.h>",
      "#include <linux/writeback.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/highuid.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct inode *qnx4_alloc_inode(struct super_block *sb);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "qs"
          ],
          "line": 242
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "qs->BitMap"
          ],
          "line": 241
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kill_block_super",
          "args": [
            "sb"
          ],
          "line": 239
        },
        "resolved": true,
        "details": {
          "function_name": "ecryptfs_kill_block_super",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ecryptfs/main.c",
          "lines": "629-638",
          "snippet": "static void ecryptfs_kill_block_super(struct super_block *sb)\n{\n\tstruct ecryptfs_sb_info *sb_info = ecryptfs_superblock_to_private(sb);\n\tkill_anon_super(sb);\n\tif (!sb_info)\n\t\treturn;\n\tecryptfs_destroy_mount_crypt_stat(&sb_info->mount_crypt_stat);\n\tbdi_destroy(&sb_info->bdi);\n\tkmem_cache_free(ecryptfs_sb_info_cache, sb_info);\n}",
          "includes": [
            "#include \"ecryptfs_kernel.h\"",
            "#include <linux/magic.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs_stack.h>",
            "#include <linux/parser.h>",
            "#include <linux/key.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/crypto.h>",
            "#include <linux/skbuff.h>",
            "#include <linux/namei.h>",
            "#include <linux/module.h>",
            "#include <linux/file.h>",
            "#include <linux/dcache.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct kmem_cache *ecryptfs_sb_info_cache;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ecryptfs_kernel.h\"\n#include <linux/magic.h>\n#include <linux/slab.h>\n#include <linux/fs_stack.h>\n#include <linux/parser.h>\n#include <linux/key.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/crypto.h>\n#include <linux/skbuff.h>\n#include <linux/namei.h>\n#include <linux/module.h>\n#include <linux/file.h>\n#include <linux/dcache.h>\n\nstruct kmem_cache *ecryptfs_sb_info_cache;\n\nstatic void ecryptfs_kill_block_super(struct super_block *sb)\n{\n\tstruct ecryptfs_sb_info *sb_info = ecryptfs_superblock_to_private(sb);\n\tkill_anon_super(sb);\n\tif (!sb_info)\n\t\treturn;\n\tecryptfs_destroy_mount_crypt_stat(&sb_info->mount_crypt_stat);\n\tbdi_destroy(&sb_info->bdi);\n\tkmem_cache_free(ecryptfs_sb_info_cache, sb_info);\n}"
        }
      },
      {
        "call_info": {
          "callee": "qnx4_sb",
          "args": [
            "sb"
          ],
          "line": 238
        },
        "resolved": true,
        "details": {
          "function_name": "qnx4_sb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/qnx4/qnx4.h",
          "lines": "32-35",
          "snippet": "static inline struct qnx4_sb_info *qnx4_sb(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include <linux/qnx4_fs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern struct inode *qnx4_iget(struct super_block *, unsigned long);",
            "extern unsigned long qnx4_count_free_blocks(struct super_block *sb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/qnx4_fs.h>\n#include <linux/fs.h>\n\nextern struct inode *qnx4_iget(struct super_block *, unsigned long);\nextern unsigned long qnx4_count_free_blocks(struct super_block *sb);\n\nstatic inline struct qnx4_sb_info *qnx4_sb(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"qnx4.h\"\n#include <linux/statfs.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n#include <linux/highuid.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nstatic struct inode *qnx4_alloc_inode(struct super_block *sb);\n\nstatic void qnx4_kill_sb(struct super_block *sb)\n{\n\tstruct qnx4_sb_info *qs = qnx4_sb(sb);\n\tkill_block_super(sb);\n\tif (qs) {\n\t\tkfree(qs->BitMap);\n\t\tkfree(qs);\n\t}\n}"
  },
  {
    "function_name": "qnx4_fill_super",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/qnx4/inode.c",
    "lines": "186-234",
    "snippet": "static int qnx4_fill_super(struct super_block *s, void *data, int silent)\n{\n\tstruct buffer_head *bh;\n\tstruct inode *root;\n\tconst char *errmsg;\n\tstruct qnx4_sb_info *qs;\n\n\tqs = kzalloc(sizeof(struct qnx4_sb_info), GFP_KERNEL);\n\tif (!qs)\n\t\treturn -ENOMEM;\n\ts->s_fs_info = qs;\n\n\tsb_set_blocksize(s, QNX4_BLOCK_SIZE);\n\n\ts->s_op = &qnx4_sops;\n\ts->s_magic = QNX4_SUPER_MAGIC;\n\ts->s_flags |= MS_RDONLY;\t/* Yup, read-only yet */\n\n\t/* Check the superblock signature. Since the qnx4 code is\n\t   dangerous, we should leave as quickly as possible\n\t   if we don't belong here... */\n\tbh = sb_bread(s, 1);\n\tif (!bh) {\n\t\tprintk(KERN_ERR \"qnx4: unable to read the superblock\\n\");\n\t\treturn -EINVAL;\n\t}\n\n \t/* check before allocating dentries, inodes, .. */\n\terrmsg = qnx4_checkroot(s, (struct qnx4_super_block *) bh->b_data);\n\tbrelse(bh);\n\tif (errmsg != NULL) {\n \t\tif (!silent)\n\t\t\tprintk(KERN_ERR \"qnx4: %s\\n\", errmsg);\n\t\treturn -EINVAL;\n\t}\n\n \t/* does root not have inode number QNX4_ROOT_INO ?? */\n\troot = qnx4_iget(s, QNX4_ROOT_INO * QNX4_INODES_PER_BLOCK);\n\tif (IS_ERR(root)) {\n\t\tprintk(KERN_ERR \"qnx4: get inode failed\\n\");\n\t\treturn PTR_ERR(root);\n \t}\n\n \ts->s_root = d_make_root(root);\n \tif (s->s_root == NULL)\n \t\treturn -ENOMEM;\n\n\treturn 0;\n}",
    "includes": [
      "#include \"qnx4.h\"",
      "#include <linux/statfs.h>",
      "#include <linux/writeback.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/highuid.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static const struct super_operations qnx4_sops;",
      "static void qnx4_destroy_inode(struct inode *inode);",
      "static int qnx4_remount(struct super_block *sb, int *flags, char *data);",
      "static const struct super_operations qnx4_sops =\n{\n\t.alloc_inode\t= qnx4_alloc_inode,\n\t.destroy_inode\t= qnx4_destroy_inode,\n\t.statfs\t\t= qnx4_statfs,\n\t.remount_fs\t= qnx4_remount,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "d_make_root",
          "args": [
            "root"
          ],
          "line": 229
        },
        "resolved": true,
        "details": {
          "function_name": "d_make_root",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "1857-1871",
          "snippet": "struct dentry *d_make_root(struct inode *root_inode)\n{\n\tstruct dentry *res = NULL;\n\n\tif (root_inode) {\n\t\tstatic const struct qstr name = QSTR_INIT(\"/\", 1);\n\n\t\tres = __d_alloc(root_inode->i_sb, &name);\n\t\tif (res)\n\t\t\td_instantiate(res, root_inode);\n\t\telse\n\t\t\tiput(root_inode);\n\t}\n\treturn res;\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nstruct dentry *d_make_root(struct inode *root_inode)\n{\n\tstruct dentry *res = NULL;\n\n\tif (root_inode) {\n\t\tstatic const struct qstr name = QSTR_INIT(\"/\", 1);\n\n\t\tres = __d_alloc(root_inode->i_sb, &name);\n\t\tif (res)\n\t\t\td_instantiate(res, root_inode);\n\t\telse\n\t\t\tiput(root_inode);\n\t}\n\treturn res;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "root"
          ],
          "line": 226
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_ERR \"qnx4: get inode failed\\n\""
          ],
          "line": 225
        },
        "resolved": true,
        "details": {
          "function_name": "compat_printk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/compat.c",
          "lines": "59-69",
          "snippet": "int compat_printk(const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\tif (!compat_log)\n\t\treturn 0;\n\tva_start(ap, fmt);\n\tret = vprintk(fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/ioctls.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/aio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/mm.h>",
            "#include <linux/poll.h>",
            "#include <linux/signal.h>",
            "#include <linux/highmem.h>",
            "#include <linux/security.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/personality.h>",
            "#include <linux/highuid.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/dirent.h>",
            "#include <linux/ctype.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/nfs4_mount.h>",
            "#include <linux/ncp_mount.h>",
            "#include <linux/init.h>",
            "#include <linux/ioctl.h>",
            "#include <linux/vfs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/namei.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/errno.h>",
            "#include <linux/compat.h>",
            "#include <linux/linkage.h>",
            "#include <linux/kernel.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int compat_log = 1;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/ioctls.h>\n#include <asm/mmu_context.h>\n#include <asm/uaccess.h>\n#include <linux/aio.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/fs_struct.h>\n#include <linux/mm.h>\n#include <linux/poll.h>\n#include <linux/signal.h>\n#include <linux/highmem.h>\n#include <linux/security.h>\n#include <linux/tsacct_kern.h>\n#include <linux/rwsem.h>\n#include <linux/personality.h>\n#include <linux/highuid.h>\n#include <linux/fsnotify.h>\n#include <linux/dirent.h>\n#include <linux/ctype.h>\n#include <linux/syscalls.h>\n#include <linux/nfs4_mount.h>\n#include <linux/ncp_mount.h>\n#include <linux/init.h>\n#include <linux/ioctl.h>\n#include <linux/vfs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/namei.h>\n#include <linux/fcntl.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <linux/compat.h>\n#include <linux/linkage.h>\n#include <linux/kernel.h>\n#include <linux/stddef.h>\n\nint compat_log = 1;\n\nint compat_printk(const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\tif (!compat_log)\n\t\treturn 0;\n\tva_start(ap, fmt);\n\tret = vprintk(fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "root"
          ],
          "line": 224
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "qnx4_iget",
          "args": [
            "s",
            "QNX4_ROOT_INO * QNX4_INODES_PER_BLOCK"
          ],
          "line": 223
        },
        "resolved": true,
        "details": {
          "function_name": "qnx4_iget",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/qnx4/inode.c",
          "lines": "260-331",
          "snippet": "struct inode *qnx4_iget(struct super_block *sb, unsigned long ino)\n{\n\tstruct buffer_head *bh;\n\tstruct qnx4_inode_entry *raw_inode;\n\tint block;\n\tstruct qnx4_inode_entry *qnx4_inode;\n\tstruct inode *inode;\n\n\tinode = iget_locked(sb, ino);\n\tif (!inode)\n\t\treturn ERR_PTR(-ENOMEM);\n\tif (!(inode->i_state & I_NEW))\n\t\treturn inode;\n\n\tqnx4_inode = qnx4_raw_inode(inode);\n\tinode->i_mode = 0;\n\n\tQNX4DEBUG((KERN_INFO \"reading inode : [%d]\\n\", ino));\n\tif (!ino) {\n\t\tprintk(KERN_ERR \"qnx4: bad inode number on dev %s: %lu is \"\n\t\t\t\t\"out of range\\n\",\n\t\t       sb->s_id, ino);\n\t\tiget_failed(inode);\n\t\treturn ERR_PTR(-EIO);\n\t}\n\tblock = ino / QNX4_INODES_PER_BLOCK;\n\n\tif (!(bh = sb_bread(sb, block))) {\n\t\tprintk(KERN_ERR \"qnx4: major problem: unable to read inode from dev \"\n\t\t       \"%s\\n\", sb->s_id);\n\t\tiget_failed(inode);\n\t\treturn ERR_PTR(-EIO);\n\t}\n\traw_inode = ((struct qnx4_inode_entry *) bh->b_data) +\n\t    (ino % QNX4_INODES_PER_BLOCK);\n\n\tinode->i_mode    = le16_to_cpu(raw_inode->di_mode);\n\ti_uid_write(inode, (uid_t)le16_to_cpu(raw_inode->di_uid));\n\ti_gid_write(inode, (gid_t)le16_to_cpu(raw_inode->di_gid));\n\tset_nlink(inode, le16_to_cpu(raw_inode->di_nlink));\n\tinode->i_size    = le32_to_cpu(raw_inode->di_size);\n\tinode->i_mtime.tv_sec   = le32_to_cpu(raw_inode->di_mtime);\n\tinode->i_mtime.tv_nsec = 0;\n\tinode->i_atime.tv_sec   = le32_to_cpu(raw_inode->di_atime);\n\tinode->i_atime.tv_nsec = 0;\n\tinode->i_ctime.tv_sec   = le32_to_cpu(raw_inode->di_ctime);\n\tinode->i_ctime.tv_nsec = 0;\n\tinode->i_blocks  = le32_to_cpu(raw_inode->di_first_xtnt.xtnt_size);\n\n\tmemcpy(qnx4_inode, raw_inode, QNX4_DIR_ENTRY_SIZE);\n\tif (S_ISREG(inode->i_mode)) {\n\t\tinode->i_fop = &generic_ro_fops;\n\t\tinode->i_mapping->a_ops = &qnx4_aops;\n\t\tqnx4_i(inode)->mmu_private = inode->i_size;\n\t} else if (S_ISDIR(inode->i_mode)) {\n\t\tinode->i_op = &qnx4_dir_inode_operations;\n\t\tinode->i_fop = &qnx4_dir_operations;\n\t} else if (S_ISLNK(inode->i_mode)) {\n\t\tinode->i_op = &page_symlink_inode_operations;\n\t\tinode->i_mapping->a_ops = &qnx4_aops;\n\t\tqnx4_i(inode)->mmu_private = inode->i_size;\n\t} else {\n\t\tprintk(KERN_ERR \"qnx4: bad inode %lu on dev %s\\n\",\n\t\t\tino, sb->s_id);\n\t\tiget_failed(inode);\n\t\tbrelse(bh);\n\t\treturn ERR_PTR(-EIO);\n\t}\n\tbrelse(bh);\n\tunlock_new_inode(inode);\n\treturn inode;\n}",
          "includes": [
            "#include \"qnx4.h\"",
            "#include <linux/statfs.h>",
            "#include <linux/writeback.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highuid.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct inode *qnx4_alloc_inode(struct super_block *sb);",
            "static void qnx4_destroy_inode(struct inode *inode);",
            "static const struct address_space_operations qnx4_aops = {\n\t.readpage\t= qnx4_readpage,\n\t.bmap\t\t= qnx4_bmap\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"qnx4.h\"\n#include <linux/statfs.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n#include <linux/highuid.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nstatic struct inode *qnx4_alloc_inode(struct super_block *sb);\nstatic void qnx4_destroy_inode(struct inode *inode);\nstatic const struct address_space_operations qnx4_aops = {\n\t.readpage\t= qnx4_readpage,\n\t.bmap\t\t= qnx4_bmap\n};\n\nstruct inode *qnx4_iget(struct super_block *sb, unsigned long ino)\n{\n\tstruct buffer_head *bh;\n\tstruct qnx4_inode_entry *raw_inode;\n\tint block;\n\tstruct qnx4_inode_entry *qnx4_inode;\n\tstruct inode *inode;\n\n\tinode = iget_locked(sb, ino);\n\tif (!inode)\n\t\treturn ERR_PTR(-ENOMEM);\n\tif (!(inode->i_state & I_NEW))\n\t\treturn inode;\n\n\tqnx4_inode = qnx4_raw_inode(inode);\n\tinode->i_mode = 0;\n\n\tQNX4DEBUG((KERN_INFO \"reading inode : [%d]\\n\", ino));\n\tif (!ino) {\n\t\tprintk(KERN_ERR \"qnx4: bad inode number on dev %s: %lu is \"\n\t\t\t\t\"out of range\\n\",\n\t\t       sb->s_id, ino);\n\t\tiget_failed(inode);\n\t\treturn ERR_PTR(-EIO);\n\t}\n\tblock = ino / QNX4_INODES_PER_BLOCK;\n\n\tif (!(bh = sb_bread(sb, block))) {\n\t\tprintk(KERN_ERR \"qnx4: major problem: unable to read inode from dev \"\n\t\t       \"%s\\n\", sb->s_id);\n\t\tiget_failed(inode);\n\t\treturn ERR_PTR(-EIO);\n\t}\n\traw_inode = ((struct qnx4_inode_entry *) bh->b_data) +\n\t    (ino % QNX4_INODES_PER_BLOCK);\n\n\tinode->i_mode    = le16_to_cpu(raw_inode->di_mode);\n\ti_uid_write(inode, (uid_t)le16_to_cpu(raw_inode->di_uid));\n\ti_gid_write(inode, (gid_t)le16_to_cpu(raw_inode->di_gid));\n\tset_nlink(inode, le16_to_cpu(raw_inode->di_nlink));\n\tinode->i_size    = le32_to_cpu(raw_inode->di_size);\n\tinode->i_mtime.tv_sec   = le32_to_cpu(raw_inode->di_mtime);\n\tinode->i_mtime.tv_nsec = 0;\n\tinode->i_atime.tv_sec   = le32_to_cpu(raw_inode->di_atime);\n\tinode->i_atime.tv_nsec = 0;\n\tinode->i_ctime.tv_sec   = le32_to_cpu(raw_inode->di_ctime);\n\tinode->i_ctime.tv_nsec = 0;\n\tinode->i_blocks  = le32_to_cpu(raw_inode->di_first_xtnt.xtnt_size);\n\n\tmemcpy(qnx4_inode, raw_inode, QNX4_DIR_ENTRY_SIZE);\n\tif (S_ISREG(inode->i_mode)) {\n\t\tinode->i_fop = &generic_ro_fops;\n\t\tinode->i_mapping->a_ops = &qnx4_aops;\n\t\tqnx4_i(inode)->mmu_private = inode->i_size;\n\t} else if (S_ISDIR(inode->i_mode)) {\n\t\tinode->i_op = &qnx4_dir_inode_operations;\n\t\tinode->i_fop = &qnx4_dir_operations;\n\t} else if (S_ISLNK(inode->i_mode)) {\n\t\tinode->i_op = &page_symlink_inode_operations;\n\t\tinode->i_mapping->a_ops = &qnx4_aops;\n\t\tqnx4_i(inode)->mmu_private = inode->i_size;\n\t} else {\n\t\tprintk(KERN_ERR \"qnx4: bad inode %lu on dev %s\\n\",\n\t\t\tino, sb->s_id);\n\t\tiget_failed(inode);\n\t\tbrelse(bh);\n\t\treturn ERR_PTR(-EIO);\n\t}\n\tbrelse(bh);\n\tunlock_new_inode(inode);\n\treturn inode;\n}"
        }
      },
      {
        "call_info": {
          "callee": "brelse",
          "args": [
            "bh"
          ],
          "line": 215
        },
        "resolved": true,
        "details": {
          "function_name": "__brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1177-1184",
          "snippet": "void __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "qnx4_checkroot",
          "args": [
            "s",
            "(struct qnx4_super_block *) bh->b_data"
          ],
          "line": 214
        },
        "resolved": true,
        "details": {
          "function_name": "qnx4_checkroot",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/qnx4/inode.c",
          "lines": "150-184",
          "snippet": "static const char *qnx4_checkroot(struct super_block *sb,\n\t\t\t\t  struct qnx4_super_block *s)\n{\n\tstruct buffer_head *bh;\n\tstruct qnx4_inode_entry *rootdir;\n\tint rd, rl;\n\tint i, j;\n\n\tif (s->RootDir.di_fname[0] != '/' || s->RootDir.di_fname[1] != '\\0')\n\t\treturn \"no qnx4 filesystem (no root dir).\";\n\tQNX4DEBUG((KERN_NOTICE \"QNX4 filesystem found on dev %s.\\n\", sb->s_id));\n\trd = le32_to_cpu(s->RootDir.di_first_xtnt.xtnt_blk) - 1;\n\trl = le32_to_cpu(s->RootDir.di_first_xtnt.xtnt_size);\n\tfor (j = 0; j < rl; j++) {\n\t\tbh = sb_bread(sb, rd + j);\t/* root dir, first block */\n\t\tif (bh == NULL)\n\t\t\treturn \"unable to read root entry.\";\n\t\trootdir = (struct qnx4_inode_entry *) bh->b_data;\n\t\tfor (i = 0; i < QNX4_INODES_PER_BLOCK; i++, rootdir++) {\n\t\t\tQNX4DEBUG((KERN_INFO \"rootdir entry found : [%s]\\n\", rootdir->di_fname));\n\t\t\tif (strcmp(rootdir->di_fname, QNX4_BMNAME) != 0)\n\t\t\t\tcontinue;\n\t\t\tqnx4_sb(sb)->BitMap = kmemdup(rootdir,\n\t\t\t\t\t\t      sizeof(struct qnx4_inode_entry),\n\t\t\t\t\t\t      GFP_KERNEL);\n\t\t\tbrelse(bh);\n\t\t\tif (!qnx4_sb(sb)->BitMap)\n\t\t\t\treturn \"not enough memory for bitmap inode\";\n\t\t\t/* keep bitmap inode known */\n\t\t\treturn NULL;\n\t\t}\n\t\tbrelse(bh);\n\t}\n\treturn \"bitmap file not found.\";\n}",
          "includes": [
            "#include \"qnx4.h\"",
            "#include <linux/statfs.h>",
            "#include <linux/writeback.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highuid.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [
            "#define QNX4_BMNAME   \".bitmap\""
          ],
          "globals_used": [
            "static struct inode *qnx4_alloc_inode(struct super_block *sb);",
            "static void qnx4_destroy_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"qnx4.h\"\n#include <linux/statfs.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n#include <linux/highuid.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\n#define QNX4_BMNAME   \".bitmap\"\n\nstatic struct inode *qnx4_alloc_inode(struct super_block *sb);\nstatic void qnx4_destroy_inode(struct inode *inode);\n\nstatic const char *qnx4_checkroot(struct super_block *sb,\n\t\t\t\t  struct qnx4_super_block *s)\n{\n\tstruct buffer_head *bh;\n\tstruct qnx4_inode_entry *rootdir;\n\tint rd, rl;\n\tint i, j;\n\n\tif (s->RootDir.di_fname[0] != '/' || s->RootDir.di_fname[1] != '\\0')\n\t\treturn \"no qnx4 filesystem (no root dir).\";\n\tQNX4DEBUG((KERN_NOTICE \"QNX4 filesystem found on dev %s.\\n\", sb->s_id));\n\trd = le32_to_cpu(s->RootDir.di_first_xtnt.xtnt_blk) - 1;\n\trl = le32_to_cpu(s->RootDir.di_first_xtnt.xtnt_size);\n\tfor (j = 0; j < rl; j++) {\n\t\tbh = sb_bread(sb, rd + j);\t/* root dir, first block */\n\t\tif (bh == NULL)\n\t\t\treturn \"unable to read root entry.\";\n\t\trootdir = (struct qnx4_inode_entry *) bh->b_data;\n\t\tfor (i = 0; i < QNX4_INODES_PER_BLOCK; i++, rootdir++) {\n\t\t\tQNX4DEBUG((KERN_INFO \"rootdir entry found : [%s]\\n\", rootdir->di_fname));\n\t\t\tif (strcmp(rootdir->di_fname, QNX4_BMNAME) != 0)\n\t\t\t\tcontinue;\n\t\t\tqnx4_sb(sb)->BitMap = kmemdup(rootdir,\n\t\t\t\t\t\t      sizeof(struct qnx4_inode_entry),\n\t\t\t\t\t\t      GFP_KERNEL);\n\t\t\tbrelse(bh);\n\t\t\tif (!qnx4_sb(sb)->BitMap)\n\t\t\t\treturn \"not enough memory for bitmap inode\";\n\t\t\t/* keep bitmap inode known */\n\t\t\treturn NULL;\n\t\t}\n\t\tbrelse(bh);\n\t}\n\treturn \"bitmap file not found.\";\n}"
        }
      },
      {
        "call_info": {
          "callee": "sb_bread",
          "args": [
            "s",
            "1"
          ],
          "line": 207
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sb_set_blocksize",
          "args": [
            "s",
            "QNX4_BLOCK_SIZE"
          ],
          "line": 198
        },
        "resolved": true,
        "details": {
          "function_name": "sb_set_blocksize",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/block_dev.c",
          "lines": "116-125",
          "snippet": "int sb_set_blocksize(struct super_block *sb, int size)\n{\n\tif (set_blocksize(sb->s_bdev, size))\n\t\treturn 0;\n\t/* If we get here, we know size is power of two\n\t * and it's value is between 512 and PAGE_SIZE */\n\tsb->s_blocksize = size;\n\tsb->s_blocksize_bits = blksize_bits(size);\n\treturn sb->s_blocksize;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/aio.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/log2.h>",
            "#include <linux/namei.h>",
            "#include <linux/uio.h>",
            "#include <linux/mount.h>",
            "#include <linux/mpage.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/swap.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkpg.h>",
            "#include <linux/module.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/highmem.h>",
            "#include <linux/device_cgroup.h>",
            "#include <linux/major.h>",
            "#include <linux/kmod.h>",
            "#include <linux/slab.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <linux/aio.h>\n#include <linux/cleancache.h>\n#include <linux/log2.h>\n#include <linux/namei.h>\n#include <linux/uio.h>\n#include <linux/mount.h>\n#include <linux/mpage.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/swap.h>\n#include <linux/buffer_head.h>\n#include <linux/magic.h>\n#include <linux/blkpg.h>\n#include <linux/module.h>\n#include <linux/blkdev.h>\n#include <linux/highmem.h>\n#include <linux/device_cgroup.h>\n#include <linux/major.h>\n#include <linux/kmod.h>\n#include <linux/slab.h>\n#include <linux/fcntl.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n\nint sb_set_blocksize(struct super_block *sb, int size)\n{\n\tif (set_blocksize(sb->s_bdev, size))\n\t\treturn 0;\n\t/* If we get here, we know size is power of two\n\t * and it's value is between 512 and PAGE_SIZE */\n\tsb->s_blocksize = size;\n\tsb->s_blocksize_bits = blksize_bits(size);\n\treturn sb->s_blocksize;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "sizeof(struct qnx4_sb_info)",
            "GFP_KERNEL"
          ],
          "line": 193
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"qnx4.h\"\n#include <linux/statfs.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n#include <linux/highuid.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nstatic const struct super_operations qnx4_sops;\nstatic void qnx4_destroy_inode(struct inode *inode);\nstatic int qnx4_remount(struct super_block *sb, int *flags, char *data);\nstatic const struct super_operations qnx4_sops =\n{\n\t.alloc_inode\t= qnx4_alloc_inode,\n\t.destroy_inode\t= qnx4_destroy_inode,\n\t.statfs\t\t= qnx4_statfs,\n\t.remount_fs\t= qnx4_remount,\n};\n\nstatic int qnx4_fill_super(struct super_block *s, void *data, int silent)\n{\n\tstruct buffer_head *bh;\n\tstruct inode *root;\n\tconst char *errmsg;\n\tstruct qnx4_sb_info *qs;\n\n\tqs = kzalloc(sizeof(struct qnx4_sb_info), GFP_KERNEL);\n\tif (!qs)\n\t\treturn -ENOMEM;\n\ts->s_fs_info = qs;\n\n\tsb_set_blocksize(s, QNX4_BLOCK_SIZE);\n\n\ts->s_op = &qnx4_sops;\n\ts->s_magic = QNX4_SUPER_MAGIC;\n\ts->s_flags |= MS_RDONLY;\t/* Yup, read-only yet */\n\n\t/* Check the superblock signature. Since the qnx4 code is\n\t   dangerous, we should leave as quickly as possible\n\t   if we don't belong here... */\n\tbh = sb_bread(s, 1);\n\tif (!bh) {\n\t\tprintk(KERN_ERR \"qnx4: unable to read the superblock\\n\");\n\t\treturn -EINVAL;\n\t}\n\n \t/* check before allocating dentries, inodes, .. */\n\terrmsg = qnx4_checkroot(s, (struct qnx4_super_block *) bh->b_data);\n\tbrelse(bh);\n\tif (errmsg != NULL) {\n \t\tif (!silent)\n\t\t\tprintk(KERN_ERR \"qnx4: %s\\n\", errmsg);\n\t\treturn -EINVAL;\n\t}\n\n \t/* does root not have inode number QNX4_ROOT_INO ?? */\n\troot = qnx4_iget(s, QNX4_ROOT_INO * QNX4_INODES_PER_BLOCK);\n\tif (IS_ERR(root)) {\n\t\tprintk(KERN_ERR \"qnx4: get inode failed\\n\");\n\t\treturn PTR_ERR(root);\n \t}\n\n \ts->s_root = d_make_root(root);\n \tif (s->s_root == NULL)\n \t\treturn -ENOMEM;\n\n\treturn 0;\n}"
  },
  {
    "function_name": "qnx4_checkroot",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/qnx4/inode.c",
    "lines": "150-184",
    "snippet": "static const char *qnx4_checkroot(struct super_block *sb,\n\t\t\t\t  struct qnx4_super_block *s)\n{\n\tstruct buffer_head *bh;\n\tstruct qnx4_inode_entry *rootdir;\n\tint rd, rl;\n\tint i, j;\n\n\tif (s->RootDir.di_fname[0] != '/' || s->RootDir.di_fname[1] != '\\0')\n\t\treturn \"no qnx4 filesystem (no root dir).\";\n\tQNX4DEBUG((KERN_NOTICE \"QNX4 filesystem found on dev %s.\\n\", sb->s_id));\n\trd = le32_to_cpu(s->RootDir.di_first_xtnt.xtnt_blk) - 1;\n\trl = le32_to_cpu(s->RootDir.di_first_xtnt.xtnt_size);\n\tfor (j = 0; j < rl; j++) {\n\t\tbh = sb_bread(sb, rd + j);\t/* root dir, first block */\n\t\tif (bh == NULL)\n\t\t\treturn \"unable to read root entry.\";\n\t\trootdir = (struct qnx4_inode_entry *) bh->b_data;\n\t\tfor (i = 0; i < QNX4_INODES_PER_BLOCK; i++, rootdir++) {\n\t\t\tQNX4DEBUG((KERN_INFO \"rootdir entry found : [%s]\\n\", rootdir->di_fname));\n\t\t\tif (strcmp(rootdir->di_fname, QNX4_BMNAME) != 0)\n\t\t\t\tcontinue;\n\t\t\tqnx4_sb(sb)->BitMap = kmemdup(rootdir,\n\t\t\t\t\t\t      sizeof(struct qnx4_inode_entry),\n\t\t\t\t\t\t      GFP_KERNEL);\n\t\t\tbrelse(bh);\n\t\t\tif (!qnx4_sb(sb)->BitMap)\n\t\t\t\treturn \"not enough memory for bitmap inode\";\n\t\t\t/* keep bitmap inode known */\n\t\t\treturn NULL;\n\t\t}\n\t\tbrelse(bh);\n\t}\n\treturn \"bitmap file not found.\";\n}",
    "includes": [
      "#include \"qnx4.h\"",
      "#include <linux/statfs.h>",
      "#include <linux/writeback.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/highuid.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [
      "#define QNX4_BMNAME   \".bitmap\""
    ],
    "globals_used": [
      "static struct inode *qnx4_alloc_inode(struct super_block *sb);",
      "static void qnx4_destroy_inode(struct inode *inode);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "brelse",
          "args": [
            "bh"
          ],
          "line": 181
        },
        "resolved": true,
        "details": {
          "function_name": "__brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1177-1184",
          "snippet": "void __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "qnx4_sb",
          "args": [
            "sb"
          ],
          "line": 176
        },
        "resolved": true,
        "details": {
          "function_name": "qnx4_sb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/qnx4/qnx4.h",
          "lines": "32-35",
          "snippet": "static inline struct qnx4_sb_info *qnx4_sb(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include <linux/qnx4_fs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern struct inode *qnx4_iget(struct super_block *, unsigned long);",
            "extern unsigned long qnx4_count_free_blocks(struct super_block *sb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/qnx4_fs.h>\n#include <linux/fs.h>\n\nextern struct inode *qnx4_iget(struct super_block *, unsigned long);\nextern unsigned long qnx4_count_free_blocks(struct super_block *sb);\n\nstatic inline struct qnx4_sb_info *qnx4_sb(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kmemdup",
          "args": [
            "rootdir",
            "sizeof(struct qnx4_inode_entry)",
            "GFP_KERNEL"
          ],
          "line": 172
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "rootdir->di_fname",
            "QNX4_BMNAME"
          ],
          "line": 170
        },
        "resolved": true,
        "details": {
          "function_name": "strcmp_prefix",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xattr.c",
          "lines": "667-675",
          "snippet": "static const char *\nstrcmp_prefix(const char *a, const char *a_prefix)\n{\n\twhile (*a_prefix && *a == *a_prefix) {\n\t\ta++;\n\t\ta_prefix++;\n\t}\n\treturn *a_prefix ? NULL : a;\n}",
          "includes": [
            "#include <asm/uaccess.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/audit.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/evm.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/xattr.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/uaccess.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/vmalloc.h>\n#include <linux/audit.h>\n#include <linux/fsnotify.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n#include <linux/evm.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/xattr.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic const char *\nstrcmp_prefix(const char *a, const char *a_prefix)\n{\n\twhile (*a_prefix && *a == *a_prefix) {\n\t\ta++;\n\t\ta_prefix++;\n\t}\n\treturn *a_prefix ? NULL : a;\n}"
        }
      },
      {
        "call_info": {
          "callee": "QNX4DEBUG",
          "args": [
            "(KERN_INFO \"rootdir entry found : [%s]\\n\", rootdir->di_fname)"
          ],
          "line": 169
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sb_bread",
          "args": [
            "sb",
            "rd + j"
          ],
          "line": 164
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "s->RootDir.di_first_xtnt.xtnt_size"
          ],
          "line": 162
        },
        "resolved": true,
        "details": {
          "function_name": "sle32_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "53-56",
          "snippet": "static inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "QNX4DEBUG",
          "args": [
            "(KERN_NOTICE \"QNX4 filesystem found on dev %s.\\n\", sb->s_id)"
          ],
          "line": 160
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"qnx4.h\"\n#include <linux/statfs.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n#include <linux/highuid.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\n#define QNX4_BMNAME   \".bitmap\"\n\nstatic struct inode *qnx4_alloc_inode(struct super_block *sb);\nstatic void qnx4_destroy_inode(struct inode *inode);\n\nstatic const char *qnx4_checkroot(struct super_block *sb,\n\t\t\t\t  struct qnx4_super_block *s)\n{\n\tstruct buffer_head *bh;\n\tstruct qnx4_inode_entry *rootdir;\n\tint rd, rl;\n\tint i, j;\n\n\tif (s->RootDir.di_fname[0] != '/' || s->RootDir.di_fname[1] != '\\0')\n\t\treturn \"no qnx4 filesystem (no root dir).\";\n\tQNX4DEBUG((KERN_NOTICE \"QNX4 filesystem found on dev %s.\\n\", sb->s_id));\n\trd = le32_to_cpu(s->RootDir.di_first_xtnt.xtnt_blk) - 1;\n\trl = le32_to_cpu(s->RootDir.di_first_xtnt.xtnt_size);\n\tfor (j = 0; j < rl; j++) {\n\t\tbh = sb_bread(sb, rd + j);\t/* root dir, first block */\n\t\tif (bh == NULL)\n\t\t\treturn \"unable to read root entry.\";\n\t\trootdir = (struct qnx4_inode_entry *) bh->b_data;\n\t\tfor (i = 0; i < QNX4_INODES_PER_BLOCK; i++, rootdir++) {\n\t\t\tQNX4DEBUG((KERN_INFO \"rootdir entry found : [%s]\\n\", rootdir->di_fname));\n\t\t\tif (strcmp(rootdir->di_fname, QNX4_BMNAME) != 0)\n\t\t\t\tcontinue;\n\t\t\tqnx4_sb(sb)->BitMap = kmemdup(rootdir,\n\t\t\t\t\t\t      sizeof(struct qnx4_inode_entry),\n\t\t\t\t\t\t      GFP_KERNEL);\n\t\t\tbrelse(bh);\n\t\t\tif (!qnx4_sb(sb)->BitMap)\n\t\t\t\treturn \"not enough memory for bitmap inode\";\n\t\t\t/* keep bitmap inode known */\n\t\t\treturn NULL;\n\t\t}\n\t\tbrelse(bh);\n\t}\n\treturn \"bitmap file not found.\";\n}"
  },
  {
    "function_name": "qnx4_statfs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/qnx4/inode.c",
    "lines": "128-143",
    "snippet": "static int qnx4_statfs(struct dentry *dentry, struct kstatfs *buf)\n{\n\tstruct super_block *sb = dentry->d_sb;\n\tu64 id = huge_encode_dev(sb->s_bdev->bd_dev);\n\n\tbuf->f_type    = sb->s_magic;\n\tbuf->f_bsize   = sb->s_blocksize;\n\tbuf->f_blocks  = le32_to_cpu(qnx4_sb(sb)->BitMap->di_size) * 8;\n\tbuf->f_bfree   = qnx4_count_free_blocks(sb);\n\tbuf->f_bavail  = buf->f_bfree;\n\tbuf->f_namelen = QNX4_NAME_MAX;\n\tbuf->f_fsid.val[0] = (u32)id;\n\tbuf->f_fsid.val[1] = (u32)(id >> 32);\n\n\treturn 0;\n}",
    "includes": [
      "#include \"qnx4.h\"",
      "#include <linux/statfs.h>",
      "#include <linux/writeback.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/highuid.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct inode *qnx4_alloc_inode(struct super_block *sb);",
      "static int qnx4_statfs(struct dentry *, struct kstatfs *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "",
          "args": [
            "id >> 32"
          ],
          "line": 140
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "qnx4_count_free_blocks",
          "args": [
            "sb"
          ],
          "line": 136
        },
        "resolved": true,
        "details": {
          "function_name": "qnx4_count_free_blocks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/qnx4/bitmap.c",
          "lines": "20-44",
          "snippet": "unsigned long qnx4_count_free_blocks(struct super_block *sb)\n{\n\tint start = le32_to_cpu(qnx4_sb(sb)->BitMap->di_first_xtnt.xtnt_blk) - 1;\n\tint total = 0;\n\tint total_free = 0;\n\tint offset = 0;\n\tint size = le32_to_cpu(qnx4_sb(sb)->BitMap->di_size);\n\tstruct buffer_head *bh;\n\n\twhile (total < size) {\n\t\tint bytes = min(size - total, QNX4_BLOCK_SIZE);\n\n\t\tif ((bh = sb_bread(sb, start + offset)) == NULL) {\n\t\t\tprintk(KERN_ERR \"qnx4: I/O error in counting free blocks\\n\");\n\t\t\tbreak;\n\t\t}\n\t\ttotal_free += bytes * BITS_PER_BYTE -\n\t\t\t\tmemweight(bh->b_data, bytes);\n\t\tbrelse(bh);\n\t\ttotal += bytes;\n\t\toffset++;\n\t}\n\n\treturn total_free;\n}",
          "includes": [
            "#include \"qnx4.h\"",
            "#include <linux/bitops.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"qnx4.h\"\n#include <linux/bitops.h>\n#include <linux/buffer_head.h>\n\nunsigned long qnx4_count_free_blocks(struct super_block *sb)\n{\n\tint start = le32_to_cpu(qnx4_sb(sb)->BitMap->di_first_xtnt.xtnt_blk) - 1;\n\tint total = 0;\n\tint total_free = 0;\n\tint offset = 0;\n\tint size = le32_to_cpu(qnx4_sb(sb)->BitMap->di_size);\n\tstruct buffer_head *bh;\n\n\twhile (total < size) {\n\t\tint bytes = min(size - total, QNX4_BLOCK_SIZE);\n\n\t\tif ((bh = sb_bread(sb, start + offset)) == NULL) {\n\t\t\tprintk(KERN_ERR \"qnx4: I/O error in counting free blocks\\n\");\n\t\t\tbreak;\n\t\t}\n\t\ttotal_free += bytes * BITS_PER_BYTE -\n\t\t\t\tmemweight(bh->b_data, bytes);\n\t\tbrelse(bh);\n\t\ttotal += bytes;\n\t\toffset++;\n\t}\n\n\treturn total_free;\n}"
        }
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "qnx4_sb(sb)->BitMap->di_size"
          ],
          "line": 135
        },
        "resolved": true,
        "details": {
          "function_name": "sle32_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "53-56",
          "snippet": "static inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "qnx4_sb",
          "args": [
            "sb"
          ],
          "line": 135
        },
        "resolved": true,
        "details": {
          "function_name": "qnx4_sb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/qnx4/qnx4.h",
          "lines": "32-35",
          "snippet": "static inline struct qnx4_sb_info *qnx4_sb(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include <linux/qnx4_fs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern struct inode *qnx4_iget(struct super_block *, unsigned long);",
            "extern unsigned long qnx4_count_free_blocks(struct super_block *sb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/qnx4_fs.h>\n#include <linux/fs.h>\n\nextern struct inode *qnx4_iget(struct super_block *, unsigned long);\nextern unsigned long qnx4_count_free_blocks(struct super_block *sb);\n\nstatic inline struct qnx4_sb_info *qnx4_sb(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      },
      {
        "call_info": {
          "callee": "huge_encode_dev",
          "args": [
            "sb->s_bdev->bd_dev"
          ],
          "line": 131
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"qnx4.h\"\n#include <linux/statfs.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n#include <linux/highuid.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nstatic struct inode *qnx4_alloc_inode(struct super_block *sb);\nstatic int qnx4_statfs(struct dentry *, struct kstatfs *);\n\nstatic int qnx4_statfs(struct dentry *dentry, struct kstatfs *buf)\n{\n\tstruct super_block *sb = dentry->d_sb;\n\tu64 id = huge_encode_dev(sb->s_bdev->bd_dev);\n\n\tbuf->f_type    = sb->s_magic;\n\tbuf->f_bsize   = sb->s_blocksize;\n\tbuf->f_blocks  = le32_to_cpu(qnx4_sb(sb)->BitMap->di_size) * 8;\n\tbuf->f_bfree   = qnx4_count_free_blocks(sb);\n\tbuf->f_bavail  = buf->f_bfree;\n\tbuf->f_namelen = QNX4_NAME_MAX;\n\tbuf->f_fsid.val[0] = (u32)id;\n\tbuf->f_fsid.val[1] = (u32)(id >> 32);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "qnx4_block_map",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/qnx4/inode.c",
    "lines": "77-126",
    "snippet": "unsigned long qnx4_block_map( struct inode *inode, long iblock )\n{\n\tint ix;\n\tlong i_xblk;\n\tstruct buffer_head *bh = NULL;\n\tstruct qnx4_xblk *xblk = NULL;\n\tstruct qnx4_inode_entry *qnx4_inode = qnx4_raw_inode(inode);\n\tu16 nxtnt = le16_to_cpu(qnx4_inode->di_num_xtnts);\n\tu32 offset = iblock;\n\tu32 block = try_extent(&qnx4_inode->di_first_xtnt, &offset);\n\n\tif (block) {\n\t\t// iblock is in the first extent. This is easy.\n\t} else {\n\t\t// iblock is beyond first extent. We have to follow the extent chain.\n\t\ti_xblk = le32_to_cpu(qnx4_inode->di_xblk);\n\t\tix = 0;\n\t\twhile ( --nxtnt > 0 ) {\n\t\t\tif ( ix == 0 ) {\n\t\t\t\t// read next xtnt block.\n\t\t\t\tbh = sb_bread(inode->i_sb, i_xblk - 1);\n\t\t\t\tif ( !bh ) {\n\t\t\t\t\tQNX4DEBUG((KERN_ERR \"qnx4: I/O error reading xtnt block [%ld])\\n\", i_xblk - 1));\n\t\t\t\t\treturn -EIO;\n\t\t\t\t}\n\t\t\t\txblk = (struct qnx4_xblk*)bh->b_data;\n\t\t\t\tif ( memcmp( xblk->xblk_signature, \"IamXblk\", 7 ) ) {\n\t\t\t\t\tQNX4DEBUG((KERN_ERR \"qnx4: block at %ld is not a valid xtnt\\n\", qnx4_inode->i_xblk));\n\t\t\t\t\treturn -EIO;\n\t\t\t\t}\n\t\t\t}\n\t\t\tblock = try_extent(&xblk->xblk_xtnts[ix], &offset);\n\t\t\tif (block) {\n\t\t\t\t// got it!\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif ( ++ix >= xblk->xblk_num_xtnts ) {\n\t\t\t\ti_xblk = le32_to_cpu(xblk->xblk_next_xblk);\n\t\t\t\tix = 0;\n\t\t\t\tbrelse( bh );\n\t\t\t\tbh = NULL;\n\t\t\t}\n\t\t}\n\t\tif ( bh )\n\t\t\tbrelse( bh );\n\t}\n\n\tQNX4DEBUG((KERN_INFO \"qnx4: mapping block %ld of inode %ld = %ld\\n\",iblock,inode->i_ino,block));\n\treturn block;\n}",
    "includes": [
      "#include \"qnx4.h\"",
      "#include <linux/statfs.h>",
      "#include <linux/writeback.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/highuid.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void qnx4_destroy_inode(struct inode *inode);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "QNX4DEBUG",
          "args": [
            "(KERN_INFO \"qnx4: mapping block %ld of inode %ld = %ld\\n\",iblock,inode->i_ino,block)"
          ],
          "line": 124
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "brelse",
          "args": [
            "bh"
          ],
          "line": 121
        },
        "resolved": true,
        "details": {
          "function_name": "__brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1177-1184",
          "snippet": "void __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "xblk->xblk_next_xblk"
          ],
          "line": 114
        },
        "resolved": true,
        "details": {
          "function_name": "sle32_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "53-56",
          "snippet": "static inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "try_extent",
          "args": [
            "&xblk->xblk_xtnts[ix]",
            "&offset"
          ],
          "line": 108
        },
        "resolved": true,
        "details": {
          "function_name": "try_extent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/qnx4/inode.c",
          "lines": "68-75",
          "snippet": "static inline u32 try_extent(qnx4_xtnt_t *extent, u32 *offset)\n{\n\tu32 size = le32_to_cpu(extent->xtnt_size);\n\tif (*offset < size)\n\t\treturn le32_to_cpu(extent->xtnt_blk) + *offset - 1;\n\t*offset -= size;\n\treturn 0;\n}",
          "includes": [
            "#include \"qnx4.h\"",
            "#include <linux/statfs.h>",
            "#include <linux/writeback.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highuid.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"qnx4.h\"\n#include <linux/statfs.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n#include <linux/highuid.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nstatic inline u32 try_extent(qnx4_xtnt_t *extent, u32 *offset)\n{\n\tu32 size = le32_to_cpu(extent->xtnt_size);\n\tif (*offset < size)\n\t\treturn le32_to_cpu(extent->xtnt_blk) + *offset - 1;\n\t*offset -= size;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "QNX4DEBUG",
          "args": [
            "(KERN_ERR \"qnx4: block at %ld is not a valid xtnt\\n\", qnx4_inode->i_xblk)"
          ],
          "line": 104
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcmp",
          "args": [
            "xblk->xblk_signature",
            "\"IamXblk\"",
            "7"
          ],
          "line": 103
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "QNX4DEBUG",
          "args": [
            "(KERN_ERR \"qnx4: I/O error reading xtnt block [%ld])\\n\", i_xblk - 1)"
          ],
          "line": 99
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sb_bread",
          "args": [
            "inode->i_sb",
            "i_xblk - 1"
          ],
          "line": 97
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le16_to_cpu",
          "args": [
            "qnx4_inode->di_num_xtnts"
          ],
          "line": 84
        },
        "resolved": true,
        "details": {
          "function_name": "sle16_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "48-51",
          "snippet": "static inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "qnx4_raw_inode",
          "args": [
            "inode"
          ],
          "line": 83
        },
        "resolved": true,
        "details": {
          "function_name": "qnx4_raw_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/qnx4/qnx4.h",
          "lines": "42-45",
          "snippet": "static inline struct qnx4_inode_entry *qnx4_raw_inode(struct inode *inode)\n{\n\treturn &qnx4_i(inode)->raw;\n}",
          "includes": [
            "#include <linux/qnx4_fs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/qnx4_fs.h>\n#include <linux/fs.h>\n\nstatic inline struct qnx4_inode_entry *qnx4_raw_inode(struct inode *inode)\n{\n\treturn &qnx4_i(inode)->raw;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"qnx4.h\"\n#include <linux/statfs.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n#include <linux/highuid.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nstatic void qnx4_destroy_inode(struct inode *inode);\n\nunsigned long qnx4_block_map( struct inode *inode, long iblock )\n{\n\tint ix;\n\tlong i_xblk;\n\tstruct buffer_head *bh = NULL;\n\tstruct qnx4_xblk *xblk = NULL;\n\tstruct qnx4_inode_entry *qnx4_inode = qnx4_raw_inode(inode);\n\tu16 nxtnt = le16_to_cpu(qnx4_inode->di_num_xtnts);\n\tu32 offset = iblock;\n\tu32 block = try_extent(&qnx4_inode->di_first_xtnt, &offset);\n\n\tif (block) {\n\t\t// iblock is in the first extent. This is easy.\n\t} else {\n\t\t// iblock is beyond first extent. We have to follow the extent chain.\n\t\ti_xblk = le32_to_cpu(qnx4_inode->di_xblk);\n\t\tix = 0;\n\t\twhile ( --nxtnt > 0 ) {\n\t\t\tif ( ix == 0 ) {\n\t\t\t\t// read next xtnt block.\n\t\t\t\tbh = sb_bread(inode->i_sb, i_xblk - 1);\n\t\t\t\tif ( !bh ) {\n\t\t\t\t\tQNX4DEBUG((KERN_ERR \"qnx4: I/O error reading xtnt block [%ld])\\n\", i_xblk - 1));\n\t\t\t\t\treturn -EIO;\n\t\t\t\t}\n\t\t\t\txblk = (struct qnx4_xblk*)bh->b_data;\n\t\t\t\tif ( memcmp( xblk->xblk_signature, \"IamXblk\", 7 ) ) {\n\t\t\t\t\tQNX4DEBUG((KERN_ERR \"qnx4: block at %ld is not a valid xtnt\\n\", qnx4_inode->i_xblk));\n\t\t\t\t\treturn -EIO;\n\t\t\t\t}\n\t\t\t}\n\t\t\tblock = try_extent(&xblk->xblk_xtnts[ix], &offset);\n\t\t\tif (block) {\n\t\t\t\t// got it!\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif ( ++ix >= xblk->xblk_num_xtnts ) {\n\t\t\t\ti_xblk = le32_to_cpu(xblk->xblk_next_xblk);\n\t\t\t\tix = 0;\n\t\t\t\tbrelse( bh );\n\t\t\t\tbh = NULL;\n\t\t\t}\n\t\t}\n\t\tif ( bh )\n\t\t\tbrelse( bh );\n\t}\n\n\tQNX4DEBUG((KERN_INFO \"qnx4: mapping block %ld of inode %ld = %ld\\n\",iblock,inode->i_ino,block));\n\treturn block;\n}"
  },
  {
    "function_name": "try_extent",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/qnx4/inode.c",
    "lines": "68-75",
    "snippet": "static inline u32 try_extent(qnx4_xtnt_t *extent, u32 *offset)\n{\n\tu32 size = le32_to_cpu(extent->xtnt_size);\n\tif (*offset < size)\n\t\treturn le32_to_cpu(extent->xtnt_blk) + *offset - 1;\n\t*offset -= size;\n\treturn 0;\n}",
    "includes": [
      "#include \"qnx4.h\"",
      "#include <linux/statfs.h>",
      "#include <linux/writeback.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/highuid.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "extent->xtnt_blk"
          ],
          "line": 72
        },
        "resolved": true,
        "details": {
          "function_name": "sle32_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "53-56",
          "snippet": "static inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"qnx4.h\"\n#include <linux/statfs.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n#include <linux/highuid.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nstatic inline u32 try_extent(qnx4_xtnt_t *extent, u32 *offset)\n{\n\tu32 size = le32_to_cpu(extent->xtnt_size);\n\tif (*offset < size)\n\t\treturn le32_to_cpu(extent->xtnt_blk) + *offset - 1;\n\t*offset -= size;\n\treturn 0;\n}"
  },
  {
    "function_name": "qnx4_get_block",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/qnx4/inode.c",
    "lines": "54-66",
    "snippet": "static int qnx4_get_block( struct inode *inode, sector_t iblock, struct buffer_head *bh, int create )\n{\n\tunsigned long phys;\n\n\tQNX4DEBUG((KERN_INFO \"qnx4: qnx4_get_block inode=[%ld] iblock=[%ld]\\n\",inode->i_ino,iblock));\n\n\tphys = qnx4_block_map( inode, iblock );\n\tif ( phys ) {\n\t\t// logical block is before EOF\n\t\tmap_bh(bh, inode->i_sb, phys);\n\t}\n\treturn 0;\n}",
    "includes": [
      "#include \"qnx4.h\"",
      "#include <linux/statfs.h>",
      "#include <linux/writeback.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/highuid.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void qnx4_destroy_inode(struct inode *inode);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "map_bh",
          "args": [
            "bh",
            "inode->i_sb",
            "phys"
          ],
          "line": 63
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "qnx4_block_map",
          "args": [
            "inode",
            "iblock"
          ],
          "line": 60
        },
        "resolved": true,
        "details": {
          "function_name": "qnx4_block_map",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/qnx4/inode.c",
          "lines": "77-126",
          "snippet": "unsigned long qnx4_block_map( struct inode *inode, long iblock )\n{\n\tint ix;\n\tlong i_xblk;\n\tstruct buffer_head *bh = NULL;\n\tstruct qnx4_xblk *xblk = NULL;\n\tstruct qnx4_inode_entry *qnx4_inode = qnx4_raw_inode(inode);\n\tu16 nxtnt = le16_to_cpu(qnx4_inode->di_num_xtnts);\n\tu32 offset = iblock;\n\tu32 block = try_extent(&qnx4_inode->di_first_xtnt, &offset);\n\n\tif (block) {\n\t\t// iblock is in the first extent. This is easy.\n\t} else {\n\t\t// iblock is beyond first extent. We have to follow the extent chain.\n\t\ti_xblk = le32_to_cpu(qnx4_inode->di_xblk);\n\t\tix = 0;\n\t\twhile ( --nxtnt > 0 ) {\n\t\t\tif ( ix == 0 ) {\n\t\t\t\t// read next xtnt block.\n\t\t\t\tbh = sb_bread(inode->i_sb, i_xblk - 1);\n\t\t\t\tif ( !bh ) {\n\t\t\t\t\tQNX4DEBUG((KERN_ERR \"qnx4: I/O error reading xtnt block [%ld])\\n\", i_xblk - 1));\n\t\t\t\t\treturn -EIO;\n\t\t\t\t}\n\t\t\t\txblk = (struct qnx4_xblk*)bh->b_data;\n\t\t\t\tif ( memcmp( xblk->xblk_signature, \"IamXblk\", 7 ) ) {\n\t\t\t\t\tQNX4DEBUG((KERN_ERR \"qnx4: block at %ld is not a valid xtnt\\n\", qnx4_inode->i_xblk));\n\t\t\t\t\treturn -EIO;\n\t\t\t\t}\n\t\t\t}\n\t\t\tblock = try_extent(&xblk->xblk_xtnts[ix], &offset);\n\t\t\tif (block) {\n\t\t\t\t// got it!\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif ( ++ix >= xblk->xblk_num_xtnts ) {\n\t\t\t\ti_xblk = le32_to_cpu(xblk->xblk_next_xblk);\n\t\t\t\tix = 0;\n\t\t\t\tbrelse( bh );\n\t\t\t\tbh = NULL;\n\t\t\t}\n\t\t}\n\t\tif ( bh )\n\t\t\tbrelse( bh );\n\t}\n\n\tQNX4DEBUG((KERN_INFO \"qnx4: mapping block %ld of inode %ld = %ld\\n\",iblock,inode->i_ino,block));\n\treturn block;\n}",
          "includes": [
            "#include \"qnx4.h\"",
            "#include <linux/statfs.h>",
            "#include <linux/writeback.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highuid.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void qnx4_destroy_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"qnx4.h\"\n#include <linux/statfs.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n#include <linux/highuid.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nstatic void qnx4_destroy_inode(struct inode *inode);\n\nunsigned long qnx4_block_map( struct inode *inode, long iblock )\n{\n\tint ix;\n\tlong i_xblk;\n\tstruct buffer_head *bh = NULL;\n\tstruct qnx4_xblk *xblk = NULL;\n\tstruct qnx4_inode_entry *qnx4_inode = qnx4_raw_inode(inode);\n\tu16 nxtnt = le16_to_cpu(qnx4_inode->di_num_xtnts);\n\tu32 offset = iblock;\n\tu32 block = try_extent(&qnx4_inode->di_first_xtnt, &offset);\n\n\tif (block) {\n\t\t// iblock is in the first extent. This is easy.\n\t} else {\n\t\t// iblock is beyond first extent. We have to follow the extent chain.\n\t\ti_xblk = le32_to_cpu(qnx4_inode->di_xblk);\n\t\tix = 0;\n\t\twhile ( --nxtnt > 0 ) {\n\t\t\tif ( ix == 0 ) {\n\t\t\t\t// read next xtnt block.\n\t\t\t\tbh = sb_bread(inode->i_sb, i_xblk - 1);\n\t\t\t\tif ( !bh ) {\n\t\t\t\t\tQNX4DEBUG((KERN_ERR \"qnx4: I/O error reading xtnt block [%ld])\\n\", i_xblk - 1));\n\t\t\t\t\treturn -EIO;\n\t\t\t\t}\n\t\t\t\txblk = (struct qnx4_xblk*)bh->b_data;\n\t\t\t\tif ( memcmp( xblk->xblk_signature, \"IamXblk\", 7 ) ) {\n\t\t\t\t\tQNX4DEBUG((KERN_ERR \"qnx4: block at %ld is not a valid xtnt\\n\", qnx4_inode->i_xblk));\n\t\t\t\t\treturn -EIO;\n\t\t\t\t}\n\t\t\t}\n\t\t\tblock = try_extent(&xblk->xblk_xtnts[ix], &offset);\n\t\t\tif (block) {\n\t\t\t\t// got it!\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif ( ++ix >= xblk->xblk_num_xtnts ) {\n\t\t\t\ti_xblk = le32_to_cpu(xblk->xblk_next_xblk);\n\t\t\t\tix = 0;\n\t\t\t\tbrelse( bh );\n\t\t\t\tbh = NULL;\n\t\t\t}\n\t\t}\n\t\tif ( bh )\n\t\t\tbrelse( bh );\n\t}\n\n\tQNX4DEBUG((KERN_INFO \"qnx4: mapping block %ld of inode %ld = %ld\\n\",iblock,inode->i_ino,block));\n\treturn block;\n}"
        }
      },
      {
        "call_info": {
          "callee": "QNX4DEBUG",
          "args": [
            "(KERN_INFO \"qnx4: qnx4_get_block inode=[%ld] iblock=[%ld]\\n\",inode->i_ino,iblock)"
          ],
          "line": 58
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"qnx4.h\"\n#include <linux/statfs.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n#include <linux/highuid.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nstatic void qnx4_destroy_inode(struct inode *inode);\n\nstatic int qnx4_get_block( struct inode *inode, sector_t iblock, struct buffer_head *bh, int create )\n{\n\tunsigned long phys;\n\n\tQNX4DEBUG((KERN_INFO \"qnx4: qnx4_get_block inode=[%ld] iblock=[%ld]\\n\",inode->i_ino,iblock));\n\n\tphys = qnx4_block_map( inode, iblock );\n\tif ( phys ) {\n\t\t// logical block is before EOF\n\t\tmap_bh(bh, inode->i_sb, phys);\n\t}\n\treturn 0;\n}"
  },
  {
    "function_name": "qnx4_remount",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/qnx4/inode.c",
    "lines": "43-52",
    "snippet": "static int qnx4_remount(struct super_block *sb, int *flags, char *data)\n{\n\tstruct qnx4_sb_info *qs;\n\n\tsync_filesystem(sb);\n\tqs = qnx4_sb(sb);\n\tqs->Version = QNX4_VERSION;\n\t*flags |= MS_RDONLY;\n\treturn 0;\n}",
    "includes": [
      "#include \"qnx4.h\"",
      "#include <linux/statfs.h>",
      "#include <linux/writeback.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/highuid.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [
      "#define QNX4_VERSION  4"
    ],
    "globals_used": [
      "static struct inode *qnx4_alloc_inode(struct super_block *sb);",
      "static int qnx4_remount(struct super_block *sb, int *flags, char *data);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "qnx4_sb",
          "args": [
            "sb"
          ],
          "line": 48
        },
        "resolved": true,
        "details": {
          "function_name": "qnx4_sb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/qnx4/qnx4.h",
          "lines": "32-35",
          "snippet": "static inline struct qnx4_sb_info *qnx4_sb(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include <linux/qnx4_fs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern struct inode *qnx4_iget(struct super_block *, unsigned long);",
            "extern unsigned long qnx4_count_free_blocks(struct super_block *sb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/qnx4_fs.h>\n#include <linux/fs.h>\n\nextern struct inode *qnx4_iget(struct super_block *, unsigned long);\nextern unsigned long qnx4_count_free_blocks(struct super_block *sb);\n\nstatic inline struct qnx4_sb_info *qnx4_sb(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sync_filesystem",
          "args": [
            "sb"
          ],
          "line": 47
        },
        "resolved": true,
        "details": {
          "function_name": "sync_filesystem",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/sync.c",
          "lines": "47-67",
          "snippet": "int sync_filesystem(struct super_block *sb)\n{\n\tint ret;\n\n\t/*\n\t * We need to be protected against the filesystem going from\n\t * r/o to r/w or vice versa.\n\t */\n\tWARN_ON(!rwsem_is_locked(&sb->s_umount));\n\n\t/*\n\t * No point in syncing out anything if the filesystem is read-only.\n\t */\n\tif (sb->s_flags & MS_RDONLY)\n\t\treturn 0;\n\n\tret = __sync_filesystem(sb, 0);\n\tif (ret < 0)\n\t\treturn ret;\n\treturn __sync_filesystem(sb, 1);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/backing-dev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/linkage.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/writeback.h>",
            "#include <linux/sched.h>",
            "#include <linux/namei.h>",
            "#include <linux/export.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/backing-dev.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/linkage.h>\n#include <linux/syscalls.h>\n#include <linux/writeback.h>\n#include <linux/sched.h>\n#include <linux/namei.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/kernel.h>\n\nint sync_filesystem(struct super_block *sb)\n{\n\tint ret;\n\n\t/*\n\t * We need to be protected against the filesystem going from\n\t * r/o to r/w or vice versa.\n\t */\n\tWARN_ON(!rwsem_is_locked(&sb->s_umount));\n\n\t/*\n\t * No point in syncing out anything if the filesystem is read-only.\n\t */\n\tif (sb->s_flags & MS_RDONLY)\n\t\treturn 0;\n\n\tret = __sync_filesystem(sb, 0);\n\tif (ret < 0)\n\t\treturn ret;\n\treturn __sync_filesystem(sb, 1);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"qnx4.h\"\n#include <linux/statfs.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n#include <linux/highuid.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\n#define QNX4_VERSION  4\n\nstatic struct inode *qnx4_alloc_inode(struct super_block *sb);\nstatic int qnx4_remount(struct super_block *sb, int *flags, char *data);\n\nstatic int qnx4_remount(struct super_block *sb, int *flags, char *data)\n{\n\tstruct qnx4_sb_info *qs;\n\n\tsync_filesystem(sb);\n\tqs = qnx4_sb(sb);\n\tqs->Version = QNX4_VERSION;\n\t*flags |= MS_RDONLY;\n\treturn 0;\n}"
  }
]