[
  {
    "function_name": "pstore_timefunc",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/pstore/platform.c",
    "lines": "536-544",
    "snippet": "static void pstore_timefunc(unsigned long dummy)\n{\n\tif (pstore_new_entry) {\n\t\tpstore_new_entry = 0;\n\t\tschedule_work(&pstore_work);\n\t}\n\n\tmod_timer(&pstore_timer, jiffies + msecs_to_jiffies(pstore_update_ms));\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/workqueue.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/slab.h>",
      "#include <linux/timer.h>",
      "#include <linux/string.h>",
      "#include <linux/zlib.h>",
      "#include <linux/pstore.h>",
      "#include <linux/module.h>",
      "#include <linux/console.h>",
      "#include <linux/kmsg_dump.h>",
      "#include <linux/init.h>",
      "#include <linux/errno.h>",
      "#include <linux/types.h>",
      "#include <linux/atomic.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int pstore_update_ms = -1;",
      "static int pstore_new_entry;",
      "static void pstore_timefunc(unsigned long);",
      "static DEFINE_TIMER(pstore_timer, pstore_timefunc, 0, 0);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mod_timer",
          "args": [
            "&pstore_timer",
            "jiffies + msecs_to_jiffies(pstore_update_ms)"
          ],
          "line": 543
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "msecs_to_jiffies",
          "args": [
            "pstore_update_ms"
          ],
          "line": 543
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "schedule_work",
          "args": [
            "&pstore_work"
          ],
          "line": 540
        },
        "resolved": true,
        "details": {
          "function_name": "nfs_direct_write_schedule_work",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/direct.c",
          "lines": "755-771",
          "snippet": "static void nfs_direct_write_schedule_work(struct work_struct *work)\n{\n\tstruct nfs_direct_req *dreq = container_of(work, struct nfs_direct_req, work);\n\tint flags = dreq->flags;\n\n\tdreq->flags = 0;\n\tswitch (flags) {\n\t\tcase NFS_ODIRECT_DO_COMMIT:\n\t\t\tnfs_direct_commit_schedule(dreq);\n\t\t\tbreak;\n\t\tcase NFS_ODIRECT_RESCHED_WRITES:\n\t\t\tnfs_direct_write_reschedule(dreq);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tnfs_direct_complete(dreq, true);\n\t}\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"iostat.h\"",
            "#include \"internal.h\"",
            "#include <linux/atomic.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/nfs_page.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/slab.h>",
            "#include <linux/kref.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/file.h>",
            "#include <linux/kernel.h>",
            "#include <linux/sched.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [
            "#define NFS_ODIRECT_RESCHED_WRITES\t(2)\t/* write verification failed */",
            "#define NFS_ODIRECT_DO_COMMIT\t\t(1)\t/* an unstable reply was received */"
          ],
          "globals_used": [
            "static void nfs_direct_write_schedule_work(struct work_struct *work);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"iostat.h\"\n#include \"internal.h\"\n#include <linux/atomic.h>\n#include <asm/uaccess.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_fs.h>\n#include <linux/module.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/slab.h>\n#include <linux/kref.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/kernel.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n\n#define NFS_ODIRECT_RESCHED_WRITES\t(2)\t/* write verification failed */\n#define NFS_ODIRECT_DO_COMMIT\t\t(1)\t/* an unstable reply was received */\n\nstatic void nfs_direct_write_schedule_work(struct work_struct *work);\n\nstatic void nfs_direct_write_schedule_work(struct work_struct *work)\n{\n\tstruct nfs_direct_req *dreq = container_of(work, struct nfs_direct_req, work);\n\tint flags = dreq->flags;\n\n\tdreq->flags = 0;\n\tswitch (flags) {\n\t\tcase NFS_ODIRECT_DO_COMMIT:\n\t\t\tnfs_direct_commit_schedule(dreq);\n\t\t\tbreak;\n\t\tcase NFS_ODIRECT_RESCHED_WRITES:\n\t\t\tnfs_direct_write_reschedule(dreq);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tnfs_direct_complete(dreq, true);\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/workqueue.h>\n#include <linux/jiffies.h>\n#include <linux/hardirq.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/timer.h>\n#include <linux/string.h>\n#include <linux/zlib.h>\n#include <linux/pstore.h>\n#include <linux/module.h>\n#include <linux/console.h>\n#include <linux/kmsg_dump.h>\n#include <linux/init.h>\n#include <linux/errno.h>\n#include <linux/types.h>\n#include <linux/atomic.h>\n\nstatic int pstore_update_ms = -1;\nstatic int pstore_new_entry;\nstatic void pstore_timefunc(unsigned long);\nstatic DEFINE_TIMER(pstore_timer, pstore_timefunc, 0, 0);\n\nstatic void pstore_timefunc(unsigned long dummy)\n{\n\tif (pstore_new_entry) {\n\t\tpstore_new_entry = 0;\n\t\tschedule_work(&pstore_work);\n\t}\n\n\tmod_timer(&pstore_timer, jiffies + msecs_to_jiffies(pstore_update_ms));\n}"
  },
  {
    "function_name": "pstore_dowork",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/pstore/platform.c",
    "lines": "531-534",
    "snippet": "static void pstore_dowork(struct work_struct *work)\n{\n\tpstore_get_records(1);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/workqueue.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/slab.h>",
      "#include <linux/timer.h>",
      "#include <linux/string.h>",
      "#include <linux/zlib.h>",
      "#include <linux/pstore.h>",
      "#include <linux/module.h>",
      "#include <linux/console.h>",
      "#include <linux/kmsg_dump.h>",
      "#include <linux/init.h>",
      "#include <linux/errno.h>",
      "#include <linux/types.h>",
      "#include <linux/atomic.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void pstore_dowork(struct work_struct *);",
      "static DECLARE_WORK(pstore_work, pstore_dowork);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "pstore_get_records",
          "args": [
            "1"
          ],
          "line": 533
        },
        "resolved": true,
        "details": {
          "function_name": "pstore_get_records",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/pstore/platform.c",
          "lines": "471-529",
          "snippet": "void pstore_get_records(int quiet)\n{\n\tstruct pstore_info *psi = psinfo;\n\tchar\t\t\t*buf = NULL;\n\tssize_t\t\t\tsize;\n\tu64\t\t\tid;\n\tint\t\t\tcount;\n\tenum pstore_type_id\ttype;\n\tstruct timespec\t\ttime;\n\tint\t\t\tfailed = 0, rc;\n\tbool\t\t\tcompressed;\n\tint\t\t\tunzipped_len = -1;\n\n\tif (!psi)\n\t\treturn;\n\n\tmutex_lock(&psi->read_mutex);\n\tif (psi->open && psi->open(psi))\n\t\tgoto out;\n\n\twhile ((size = psi->read(&id, &type, &count, &time, &buf, &compressed,\n\t\t\t\tpsi)) > 0) {\n\t\tif (compressed && (type == PSTORE_TYPE_DMESG)) {\n\t\t\tif (big_oops_buf)\n\t\t\t\tunzipped_len = pstore_decompress(buf,\n\t\t\t\t\t\t\tbig_oops_buf, size,\n\t\t\t\t\t\t\tbig_oops_buf_sz);\n\n\t\t\tif (unzipped_len > 0) {\n\t\t\t\tkfree(buf);\n\t\t\t\tbuf = big_oops_buf;\n\t\t\t\tsize = unzipped_len;\n\t\t\t\tcompressed = false;\n\t\t\t} else {\n\t\t\t\tpr_err(\"decompression failed;returned %d\\n\",\n\t\t\t\t       unzipped_len);\n\t\t\t\tcompressed = true;\n\t\t\t}\n\t\t}\n\t\trc = pstore_mkfile(type, psi->name, id, count, buf,\n\t\t\t\t  compressed, (size_t)size, time, psi);\n\t\tif (unzipped_len < 0) {\n\t\t\t/* Free buffer other than big oops */\n\t\t\tkfree(buf);\n\t\t\tbuf = NULL;\n\t\t} else\n\t\t\tunzipped_len = -1;\n\t\tif (rc && (rc != -EEXIST || !quiet))\n\t\t\tfailed++;\n\t}\n\tif (psi->close)\n\t\tpsi->close(psi);\nout:\n\tmutex_unlock(&psi->read_mutex);\n\n\tif (failed)\n\t\tpr_warn(\"failed to load %d record(s) from '%s'\\n\",\n\t\t\tfailed, psi->name);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/timer.h>",
            "#include <linux/string.h>",
            "#include <linux/zlib.h>",
            "#include <linux/pstore.h>",
            "#include <linux/module.h>",
            "#include <linux/console.h>",
            "#include <linux/kmsg_dump.h>",
            "#include <linux/init.h>",
            "#include <linux/errno.h>",
            "#include <linux/types.h>",
            "#include <linux/atomic.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct pstore_info *psinfo;",
            "static char *big_oops_buf;",
            "static size_t big_oops_buf_sz;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/workqueue.h>\n#include <linux/jiffies.h>\n#include <linux/hardirq.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/timer.h>\n#include <linux/string.h>\n#include <linux/zlib.h>\n#include <linux/pstore.h>\n#include <linux/module.h>\n#include <linux/console.h>\n#include <linux/kmsg_dump.h>\n#include <linux/init.h>\n#include <linux/errno.h>\n#include <linux/types.h>\n#include <linux/atomic.h>\n\nstruct pstore_info *psinfo;\nstatic char *big_oops_buf;\nstatic size_t big_oops_buf_sz;\n\nvoid pstore_get_records(int quiet)\n{\n\tstruct pstore_info *psi = psinfo;\n\tchar\t\t\t*buf = NULL;\n\tssize_t\t\t\tsize;\n\tu64\t\t\tid;\n\tint\t\t\tcount;\n\tenum pstore_type_id\ttype;\n\tstruct timespec\t\ttime;\n\tint\t\t\tfailed = 0, rc;\n\tbool\t\t\tcompressed;\n\tint\t\t\tunzipped_len = -1;\n\n\tif (!psi)\n\t\treturn;\n\n\tmutex_lock(&psi->read_mutex);\n\tif (psi->open && psi->open(psi))\n\t\tgoto out;\n\n\twhile ((size = psi->read(&id, &type, &count, &time, &buf, &compressed,\n\t\t\t\tpsi)) > 0) {\n\t\tif (compressed && (type == PSTORE_TYPE_DMESG)) {\n\t\t\tif (big_oops_buf)\n\t\t\t\tunzipped_len = pstore_decompress(buf,\n\t\t\t\t\t\t\tbig_oops_buf, size,\n\t\t\t\t\t\t\tbig_oops_buf_sz);\n\n\t\t\tif (unzipped_len > 0) {\n\t\t\t\tkfree(buf);\n\t\t\t\tbuf = big_oops_buf;\n\t\t\t\tsize = unzipped_len;\n\t\t\t\tcompressed = false;\n\t\t\t} else {\n\t\t\t\tpr_err(\"decompression failed;returned %d\\n\",\n\t\t\t\t       unzipped_len);\n\t\t\t\tcompressed = true;\n\t\t\t}\n\t\t}\n\t\trc = pstore_mkfile(type, psi->name, id, count, buf,\n\t\t\t\t  compressed, (size_t)size, time, psi);\n\t\tif (unzipped_len < 0) {\n\t\t\t/* Free buffer other than big oops */\n\t\t\tkfree(buf);\n\t\t\tbuf = NULL;\n\t\t} else\n\t\t\tunzipped_len = -1;\n\t\tif (rc && (rc != -EEXIST || !quiet))\n\t\t\tfailed++;\n\t}\n\tif (psi->close)\n\t\tpsi->close(psi);\nout:\n\tmutex_unlock(&psi->read_mutex);\n\n\tif (failed)\n\t\tpr_warn(\"failed to load %d record(s) from '%s'\\n\",\n\t\t\tfailed, psi->name);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/workqueue.h>\n#include <linux/jiffies.h>\n#include <linux/hardirq.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/timer.h>\n#include <linux/string.h>\n#include <linux/zlib.h>\n#include <linux/pstore.h>\n#include <linux/module.h>\n#include <linux/console.h>\n#include <linux/kmsg_dump.h>\n#include <linux/init.h>\n#include <linux/errno.h>\n#include <linux/types.h>\n#include <linux/atomic.h>\n\nstatic void pstore_dowork(struct work_struct *);\nstatic DECLARE_WORK(pstore_work, pstore_dowork);\n\nstatic void pstore_dowork(struct work_struct *work)\n{\n\tpstore_get_records(1);\n}"
  },
  {
    "function_name": "pstore_get_records",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/pstore/platform.c",
    "lines": "471-529",
    "snippet": "void pstore_get_records(int quiet)\n{\n\tstruct pstore_info *psi = psinfo;\n\tchar\t\t\t*buf = NULL;\n\tssize_t\t\t\tsize;\n\tu64\t\t\tid;\n\tint\t\t\tcount;\n\tenum pstore_type_id\ttype;\n\tstruct timespec\t\ttime;\n\tint\t\t\tfailed = 0, rc;\n\tbool\t\t\tcompressed;\n\tint\t\t\tunzipped_len = -1;\n\n\tif (!psi)\n\t\treturn;\n\n\tmutex_lock(&psi->read_mutex);\n\tif (psi->open && psi->open(psi))\n\t\tgoto out;\n\n\twhile ((size = psi->read(&id, &type, &count, &time, &buf, &compressed,\n\t\t\t\tpsi)) > 0) {\n\t\tif (compressed && (type == PSTORE_TYPE_DMESG)) {\n\t\t\tif (big_oops_buf)\n\t\t\t\tunzipped_len = pstore_decompress(buf,\n\t\t\t\t\t\t\tbig_oops_buf, size,\n\t\t\t\t\t\t\tbig_oops_buf_sz);\n\n\t\t\tif (unzipped_len > 0) {\n\t\t\t\tkfree(buf);\n\t\t\t\tbuf = big_oops_buf;\n\t\t\t\tsize = unzipped_len;\n\t\t\t\tcompressed = false;\n\t\t\t} else {\n\t\t\t\tpr_err(\"decompression failed;returned %d\\n\",\n\t\t\t\t       unzipped_len);\n\t\t\t\tcompressed = true;\n\t\t\t}\n\t\t}\n\t\trc = pstore_mkfile(type, psi->name, id, count, buf,\n\t\t\t\t  compressed, (size_t)size, time, psi);\n\t\tif (unzipped_len < 0) {\n\t\t\t/* Free buffer other than big oops */\n\t\t\tkfree(buf);\n\t\t\tbuf = NULL;\n\t\t} else\n\t\t\tunzipped_len = -1;\n\t\tif (rc && (rc != -EEXIST || !quiet))\n\t\t\tfailed++;\n\t}\n\tif (psi->close)\n\t\tpsi->close(psi);\nout:\n\tmutex_unlock(&psi->read_mutex);\n\n\tif (failed)\n\t\tpr_warn(\"failed to load %d record(s) from '%s'\\n\",\n\t\t\tfailed, psi->name);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/workqueue.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/slab.h>",
      "#include <linux/timer.h>",
      "#include <linux/string.h>",
      "#include <linux/zlib.h>",
      "#include <linux/pstore.h>",
      "#include <linux/module.h>",
      "#include <linux/console.h>",
      "#include <linux/kmsg_dump.h>",
      "#include <linux/init.h>",
      "#include <linux/errno.h>",
      "#include <linux/types.h>",
      "#include <linux/atomic.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "struct pstore_info *psinfo;",
      "static char *big_oops_buf;",
      "static size_t big_oops_buf_sz;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"failed to load %d record(s) from '%s'\\n\"",
            "failed",
            "psi->name"
          ],
          "line": 527
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&psi->read_mutex"
          ],
          "line": 524
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "psi->close",
          "args": [
            "psi"
          ],
          "line": 522
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "buf"
          ],
          "line": 514
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pstore_mkfile",
          "args": [
            "type",
            "psi->name",
            "id",
            "count",
            "buf",
            "compressed",
            "(size_t)size",
            "time",
            "psi"
          ],
          "line": 510
        },
        "resolved": true,
        "details": {
          "function_name": "pstore_mkfile",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/pstore/inode.c",
          "lines": "300-408",
          "snippet": "int pstore_mkfile(enum pstore_type_id type, char *psname, u64 id, int count,\n\t\t  char *data, bool compressed, size_t size,\n\t\t  struct timespec time, struct pstore_info *psi)\n{\n\tstruct dentry\t\t*root = pstore_sb->s_root;\n\tstruct dentry\t\t*dentry;\n\tstruct inode\t\t*inode;\n\tint\t\t\trc = 0;\n\tchar\t\t\tname[PSTORE_NAMELEN];\n\tstruct pstore_private\t*private, *pos;\n\tunsigned long\t\tflags;\n\n\tspin_lock_irqsave(&allpstore_lock, flags);\n\tlist_for_each_entry(pos, &allpstore, list) {\n\t\tif (pos->type == type &&\n\t\t    pos->id == id &&\n\t\t    pos->psi == psi) {\n\t\t\trc = -EEXIST;\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock_irqrestore(&allpstore_lock, flags);\n\tif (rc)\n\t\treturn rc;\n\n\trc = -ENOMEM;\n\tinode = pstore_get_inode(pstore_sb);\n\tif (!inode)\n\t\tgoto fail;\n\tinode->i_mode = S_IFREG | 0444;\n\tinode->i_fop = &pstore_file_operations;\n\tprivate = kmalloc(sizeof *private + size, GFP_KERNEL);\n\tif (!private)\n\t\tgoto fail_alloc;\n\tprivate->type = type;\n\tprivate->id = id;\n\tprivate->count = count;\n\tprivate->psi = psi;\n\n\tswitch (type) {\n\tcase PSTORE_TYPE_DMESG:\n\t\tscnprintf(name, sizeof(name), \"dmesg-%s-%lld%s\",\n\t\t\t  psname, id, compressed ? \".enc.z\" : \"\");\n\t\tbreak;\n\tcase PSTORE_TYPE_CONSOLE:\n\t\tscnprintf(name, sizeof(name), \"console-%s-%lld\", psname, id);\n\t\tbreak;\n\tcase PSTORE_TYPE_FTRACE:\n\t\tscnprintf(name, sizeof(name), \"ftrace-%s-%lld\", psname, id);\n\t\tbreak;\n\tcase PSTORE_TYPE_MCE:\n\t\tscnprintf(name, sizeof(name), \"mce-%s-%lld\", psname, id);\n\t\tbreak;\n\tcase PSTORE_TYPE_PPC_RTAS:\n\t\tscnprintf(name, sizeof(name), \"rtas-%s-%lld\", psname, id);\n\t\tbreak;\n\tcase PSTORE_TYPE_PPC_OF:\n\t\tscnprintf(name, sizeof(name), \"powerpc-ofw-%s-%lld\",\n\t\t\t  psname, id);\n\t\tbreak;\n\tcase PSTORE_TYPE_PPC_COMMON:\n\t\tscnprintf(name, sizeof(name), \"powerpc-common-%s-%lld\",\n\t\t\t  psname, id);\n\t\tbreak;\n\tcase PSTORE_TYPE_PMSG:\n\t\tscnprintf(name, sizeof(name), \"pmsg-%s-%lld\", psname, id);\n\t\tbreak;\n\tcase PSTORE_TYPE_UNKNOWN:\n\t\tscnprintf(name, sizeof(name), \"unknown-%s-%lld\", psname, id);\n\t\tbreak;\n\tdefault:\n\t\tscnprintf(name, sizeof(name), \"type%d-%s-%lld\",\n\t\t\t  type, psname, id);\n\t\tbreak;\n\t}\n\n\tmutex_lock(&root->d_inode->i_mutex);\n\n\tdentry = d_alloc_name(root, name);\n\tif (!dentry)\n\t\tgoto fail_lockedalloc;\n\n\tmemcpy(private->data, data, size);\n\tinode->i_size = private->size = size;\n\n\tinode->i_private = private;\n\n\tif (time.tv_sec)\n\t\tinode->i_mtime = inode->i_ctime = time;\n\n\td_add(dentry, inode);\n\n\tspin_lock_irqsave(&allpstore_lock, flags);\n\tlist_add(&private->list, &allpstore);\n\tspin_unlock_irqrestore(&allpstore_lock, flags);\n\n\tmutex_unlock(&root->d_inode->i_mutex);\n\n\treturn 0;\n\nfail_lockedalloc:\n\tmutex_unlock(&root->d_inode->i_mutex);\n\tkfree(private);\nfail_alloc:\n\tiput(inode);\n\nfail:\n\treturn rc;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/syslog.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/pstore.h>",
            "#include <linux/magic.h>",
            "#include <linux/sched.h>",
            "#include <linux/parser.h>",
            "#include <linux/ramfs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mount.h>",
            "#include <linux/string.h>",
            "#include <linux/list.h>",
            "#include <linux/init.h>",
            "#include <linux/time.h>",
            "#include <linux/highmem.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [
            "#define\tPSTORE_NAMELEN\t64"
          ],
          "globals_used": [
            "static DEFINE_SPINLOCK(allpstore_lock);",
            "static LIST_HEAD(allpstore);",
            "static const struct file_operations pstore_file_operations = {\n\t.open\t\t= pstore_file_open,\n\t.read\t\t= pstore_file_read,\n\t.llseek\t\t= pstore_file_llseek,\n\t.release\t= seq_release,\n};",
            "static struct super_block *pstore_sb;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/syslog.h>\n#include <linux/uaccess.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/pstore.h>\n#include <linux/magic.h>\n#include <linux/sched.h>\n#include <linux/parser.h>\n#include <linux/ramfs.h>\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n#include <linux/string.h>\n#include <linux/list.h>\n#include <linux/init.h>\n#include <linux/time.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\n#define\tPSTORE_NAMELEN\t64\n\nstatic DEFINE_SPINLOCK(allpstore_lock);\nstatic LIST_HEAD(allpstore);\nstatic const struct file_operations pstore_file_operations = {\n\t.open\t\t= pstore_file_open,\n\t.read\t\t= pstore_file_read,\n\t.llseek\t\t= pstore_file_llseek,\n\t.release\t= seq_release,\n};\nstatic struct super_block *pstore_sb;\n\nint pstore_mkfile(enum pstore_type_id type, char *psname, u64 id, int count,\n\t\t  char *data, bool compressed, size_t size,\n\t\t  struct timespec time, struct pstore_info *psi)\n{\n\tstruct dentry\t\t*root = pstore_sb->s_root;\n\tstruct dentry\t\t*dentry;\n\tstruct inode\t\t*inode;\n\tint\t\t\trc = 0;\n\tchar\t\t\tname[PSTORE_NAMELEN];\n\tstruct pstore_private\t*private, *pos;\n\tunsigned long\t\tflags;\n\n\tspin_lock_irqsave(&allpstore_lock, flags);\n\tlist_for_each_entry(pos, &allpstore, list) {\n\t\tif (pos->type == type &&\n\t\t    pos->id == id &&\n\t\t    pos->psi == psi) {\n\t\t\trc = -EEXIST;\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock_irqrestore(&allpstore_lock, flags);\n\tif (rc)\n\t\treturn rc;\n\n\trc = -ENOMEM;\n\tinode = pstore_get_inode(pstore_sb);\n\tif (!inode)\n\t\tgoto fail;\n\tinode->i_mode = S_IFREG | 0444;\n\tinode->i_fop = &pstore_file_operations;\n\tprivate = kmalloc(sizeof *private + size, GFP_KERNEL);\n\tif (!private)\n\t\tgoto fail_alloc;\n\tprivate->type = type;\n\tprivate->id = id;\n\tprivate->count = count;\n\tprivate->psi = psi;\n\n\tswitch (type) {\n\tcase PSTORE_TYPE_DMESG:\n\t\tscnprintf(name, sizeof(name), \"dmesg-%s-%lld%s\",\n\t\t\t  psname, id, compressed ? \".enc.z\" : \"\");\n\t\tbreak;\n\tcase PSTORE_TYPE_CONSOLE:\n\t\tscnprintf(name, sizeof(name), \"console-%s-%lld\", psname, id);\n\t\tbreak;\n\tcase PSTORE_TYPE_FTRACE:\n\t\tscnprintf(name, sizeof(name), \"ftrace-%s-%lld\", psname, id);\n\t\tbreak;\n\tcase PSTORE_TYPE_MCE:\n\t\tscnprintf(name, sizeof(name), \"mce-%s-%lld\", psname, id);\n\t\tbreak;\n\tcase PSTORE_TYPE_PPC_RTAS:\n\t\tscnprintf(name, sizeof(name), \"rtas-%s-%lld\", psname, id);\n\t\tbreak;\n\tcase PSTORE_TYPE_PPC_OF:\n\t\tscnprintf(name, sizeof(name), \"powerpc-ofw-%s-%lld\",\n\t\t\t  psname, id);\n\t\tbreak;\n\tcase PSTORE_TYPE_PPC_COMMON:\n\t\tscnprintf(name, sizeof(name), \"powerpc-common-%s-%lld\",\n\t\t\t  psname, id);\n\t\tbreak;\n\tcase PSTORE_TYPE_PMSG:\n\t\tscnprintf(name, sizeof(name), \"pmsg-%s-%lld\", psname, id);\n\t\tbreak;\n\tcase PSTORE_TYPE_UNKNOWN:\n\t\tscnprintf(name, sizeof(name), \"unknown-%s-%lld\", psname, id);\n\t\tbreak;\n\tdefault:\n\t\tscnprintf(name, sizeof(name), \"type%d-%s-%lld\",\n\t\t\t  type, psname, id);\n\t\tbreak;\n\t}\n\n\tmutex_lock(&root->d_inode->i_mutex);\n\n\tdentry = d_alloc_name(root, name);\n\tif (!dentry)\n\t\tgoto fail_lockedalloc;\n\n\tmemcpy(private->data, data, size);\n\tinode->i_size = private->size = size;\n\n\tinode->i_private = private;\n\n\tif (time.tv_sec)\n\t\tinode->i_mtime = inode->i_ctime = time;\n\n\td_add(dentry, inode);\n\n\tspin_lock_irqsave(&allpstore_lock, flags);\n\tlist_add(&private->list, &allpstore);\n\tspin_unlock_irqrestore(&allpstore_lock, flags);\n\n\tmutex_unlock(&root->d_inode->i_mutex);\n\n\treturn 0;\n\nfail_lockedalloc:\n\tmutex_unlock(&root->d_inode->i_mutex);\n\tkfree(private);\nfail_alloc:\n\tiput(inode);\n\nfail:\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"decompression failed;returned %d\\n\"",
            "unzipped_len"
          ],
          "line": 505
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "buf"
          ],
          "line": 500
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pstore_decompress",
          "args": [
            "buf",
            "big_oops_buf",
            "size",
            "big_oops_buf_sz"
          ],
          "line": 495
        },
        "resolved": true,
        "details": {
          "function_name": "pstore_decompress",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/pstore/platform.c",
          "lines": "168-195",
          "snippet": "static int pstore_decompress(void *in, void *out, size_t inlen, size_t outlen)\n{\n\tint err, ret;\n\n\tret = -EIO;\n\terr = zlib_inflateInit2(&stream, WINDOW_BITS);\n\tif (err != Z_OK)\n\t\tgoto error;\n\n\tstream.next_in = in;\n\tstream.avail_in = inlen;\n\tstream.total_in = 0;\n\tstream.next_out = out;\n\tstream.avail_out = outlen;\n\tstream.total_out = 0;\n\n\terr = zlib_inflate(&stream, Z_FINISH);\n\tif (err != Z_STREAM_END)\n\t\tgoto error;\n\n\terr = zlib_inflateEnd(&stream);\n\tif (err != Z_OK)\n\t\tgoto error;\n\n\tret = stream.total_out;\nerror:\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/timer.h>",
            "#include <linux/string.h>",
            "#include <linux/zlib.h>",
            "#include <linux/pstore.h>",
            "#include <linux/module.h>",
            "#include <linux/console.h>",
            "#include <linux/kmsg_dump.h>",
            "#include <linux/init.h>",
            "#include <linux/errno.h>",
            "#include <linux/types.h>",
            "#include <linux/atomic.h>"
          ],
          "macros_used": [
            "#define WINDOW_BITS 12"
          ],
          "globals_used": [
            "static struct z_stream_s stream;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/workqueue.h>\n#include <linux/jiffies.h>\n#include <linux/hardirq.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/timer.h>\n#include <linux/string.h>\n#include <linux/zlib.h>\n#include <linux/pstore.h>\n#include <linux/module.h>\n#include <linux/console.h>\n#include <linux/kmsg_dump.h>\n#include <linux/init.h>\n#include <linux/errno.h>\n#include <linux/types.h>\n#include <linux/atomic.h>\n\n#define WINDOW_BITS 12\n\nstatic struct z_stream_s stream;\n\nstatic int pstore_decompress(void *in, void *out, size_t inlen, size_t outlen)\n{\n\tint err, ret;\n\n\tret = -EIO;\n\terr = zlib_inflateInit2(&stream, WINDOW_BITS);\n\tif (err != Z_OK)\n\t\tgoto error;\n\n\tstream.next_in = in;\n\tstream.avail_in = inlen;\n\tstream.total_in = 0;\n\tstream.next_out = out;\n\tstream.avail_out = outlen;\n\tstream.total_out = 0;\n\n\terr = zlib_inflate(&stream, Z_FINISH);\n\tif (err != Z_STREAM_END)\n\t\tgoto error;\n\n\terr = zlib_inflateEnd(&stream);\n\tif (err != Z_OK)\n\t\tgoto error;\n\n\tret = stream.total_out;\nerror:\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "psi->read",
          "args": [
            "&id",
            "&type",
            "&count",
            "&time",
            "&buf",
            "&compressed",
            "psi"
          ],
          "line": 491
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "psi->open",
          "args": [
            "psi"
          ],
          "line": 488
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&psi->read_mutex"
          ],
          "line": 487
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/workqueue.h>\n#include <linux/jiffies.h>\n#include <linux/hardirq.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/timer.h>\n#include <linux/string.h>\n#include <linux/zlib.h>\n#include <linux/pstore.h>\n#include <linux/module.h>\n#include <linux/console.h>\n#include <linux/kmsg_dump.h>\n#include <linux/init.h>\n#include <linux/errno.h>\n#include <linux/types.h>\n#include <linux/atomic.h>\n\nstruct pstore_info *psinfo;\nstatic char *big_oops_buf;\nstatic size_t big_oops_buf_sz;\n\nvoid pstore_get_records(int quiet)\n{\n\tstruct pstore_info *psi = psinfo;\n\tchar\t\t\t*buf = NULL;\n\tssize_t\t\t\tsize;\n\tu64\t\t\tid;\n\tint\t\t\tcount;\n\tenum pstore_type_id\ttype;\n\tstruct timespec\t\ttime;\n\tint\t\t\tfailed = 0, rc;\n\tbool\t\t\tcompressed;\n\tint\t\t\tunzipped_len = -1;\n\n\tif (!psi)\n\t\treturn;\n\n\tmutex_lock(&psi->read_mutex);\n\tif (psi->open && psi->open(psi))\n\t\tgoto out;\n\n\twhile ((size = psi->read(&id, &type, &count, &time, &buf, &compressed,\n\t\t\t\tpsi)) > 0) {\n\t\tif (compressed && (type == PSTORE_TYPE_DMESG)) {\n\t\t\tif (big_oops_buf)\n\t\t\t\tunzipped_len = pstore_decompress(buf,\n\t\t\t\t\t\t\tbig_oops_buf, size,\n\t\t\t\t\t\t\tbig_oops_buf_sz);\n\n\t\t\tif (unzipped_len > 0) {\n\t\t\t\tkfree(buf);\n\t\t\t\tbuf = big_oops_buf;\n\t\t\t\tsize = unzipped_len;\n\t\t\t\tcompressed = false;\n\t\t\t} else {\n\t\t\t\tpr_err(\"decompression failed;returned %d\\n\",\n\t\t\t\t       unzipped_len);\n\t\t\t\tcompressed = true;\n\t\t\t}\n\t\t}\n\t\trc = pstore_mkfile(type, psi->name, id, count, buf,\n\t\t\t\t  compressed, (size_t)size, time, psi);\n\t\tif (unzipped_len < 0) {\n\t\t\t/* Free buffer other than big oops */\n\t\t\tkfree(buf);\n\t\t\tbuf = NULL;\n\t\t} else\n\t\t\tunzipped_len = -1;\n\t\tif (rc && (rc != -EEXIST || !quiet))\n\t\t\tfailed++;\n\t}\n\tif (psi->close)\n\t\tpsi->close(psi);\nout:\n\tmutex_unlock(&psi->read_mutex);\n\n\tif (failed)\n\t\tpr_warn(\"failed to load %d record(s) from '%s'\\n\",\n\t\t\tfailed, psi->name);\n}"
  },
  {
    "function_name": "pstore_register",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/pstore/platform.c",
    "lines": "416-462",
    "snippet": "int pstore_register(struct pstore_info *psi)\n{\n\tstruct module *owner = psi->owner;\n\n\tif (backend && strcmp(backend, psi->name))\n\t\treturn -EPERM;\n\n\tspin_lock(&pstore_lock);\n\tif (psinfo) {\n\t\tspin_unlock(&pstore_lock);\n\t\treturn -EBUSY;\n\t}\n\n\tif (!psi->write)\n\t\tpsi->write = pstore_write_compat;\n\tpsinfo = psi;\n\tmutex_init(&psinfo->read_mutex);\n\tspin_unlock(&pstore_lock);\n\n\tif (owner && !try_module_get(owner)) {\n\t\tpsinfo = NULL;\n\t\treturn -EINVAL;\n\t}\n\n\tallocate_buf_for_compression();\n\n\tif (pstore_is_mounted())\n\t\tpstore_get_records(0);\n\n\tkmsg_dump_register(&pstore_dumper);\n\n\tif ((psi->flags & PSTORE_FLAGS_FRAGILE) == 0) {\n\t\tpstore_register_console();\n\t\tpstore_register_ftrace();\n\t\tpstore_register_pmsg();\n\t}\n\n\tif (pstore_update_ms >= 0) {\n\t\tpstore_timer.expires = jiffies +\n\t\t\tmsecs_to_jiffies(pstore_update_ms);\n\t\tadd_timer(&pstore_timer);\n\t}\n\n\tpr_info(\"Registered %s as persistent store backend\\n\", psi->name);\n\n\treturn 0;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/workqueue.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/slab.h>",
      "#include <linux/timer.h>",
      "#include <linux/string.h>",
      "#include <linux/zlib.h>",
      "#include <linux/pstore.h>",
      "#include <linux/module.h>",
      "#include <linux/console.h>",
      "#include <linux/kmsg_dump.h>",
      "#include <linux/init.h>",
      "#include <linux/errno.h>",
      "#include <linux/types.h>",
      "#include <linux/atomic.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int pstore_update_ms = -1;",
      "static DEFINE_SPINLOCK(pstore_lock);",
      "struct pstore_info *psinfo;",
      "static char *backend;",
      "static struct kmsg_dumper pstore_dumper = {\n\t.dump = pstore_dump,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "pr_info",
          "args": [
            "\"Registered %s as persistent store backend\\n\"",
            "psi->name"
          ],
          "line": 459
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "add_timer",
          "args": [
            "&pstore_timer"
          ],
          "line": 456
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "msecs_to_jiffies",
          "args": [
            "pstore_update_ms"
          ],
          "line": 455
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pstore_register_pmsg",
          "args": [],
          "line": 450
        },
        "resolved": true,
        "details": {
          "function_name": "pstore_register_pmsg",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/pstore/internal.h",
          "lines": "51-51",
          "snippet": "static inline void pstore_register_pmsg(void) {}",
          "includes": [
            "#include <linux/pstore.h>",
            "#include <linux/time.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/pstore.h>\n#include <linux/time.h>\n#include <linux/types.h>\n\nstatic inline void pstore_register_pmsg(void) {}"
        }
      },
      {
        "call_info": {
          "callee": "pstore_register_ftrace",
          "args": [],
          "line": 449
        },
        "resolved": true,
        "details": {
          "function_name": "pstore_register_ftrace",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/pstore/ftrace.c",
          "lines": "107-131",
          "snippet": "void pstore_register_ftrace(void)\n{\n\tstruct dentry *dir;\n\tstruct dentry *file;\n\n\tif (!psinfo->write_buf)\n\t\treturn;\n\n\tdir = debugfs_create_dir(\"pstore\", NULL);\n\tif (!dir) {\n\t\tpr_err(\"%s: unable to create pstore directory\\n\", __func__);\n\t\treturn;\n\t}\n\n\tfile = debugfs_create_file(\"record_ftrace\", 0600, dir, NULL,\n\t\t\t\t   &pstore_knob_fops);\n\tif (!file) {\n\t\tpr_err(\"%s: unable to create record_ftrace file\\n\", __func__);\n\t\tgoto err_file;\n\t}\n\n\treturn;\nerr_file:\n\tdebugfs_remove(dir);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/barrier.h>",
            "#include <linux/cache.h>",
            "#include <linux/err.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/fs.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/mutex.h>",
            "#include <linux/types.h>",
            "#include <linux/atomic.h>",
            "#include <linux/smp.h>",
            "#include <linux/percpu.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/compiler.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct file_operations pstore_knob_fops = {\n\t.open\t= simple_open,\n\t.read\t= pstore_ftrace_knob_read,\n\t.write\t= pstore_ftrace_knob_write,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/barrier.h>\n#include <linux/cache.h>\n#include <linux/err.h>\n#include <linux/debugfs.h>\n#include <linux/fs.h>\n#include <linux/ftrace.h>\n#include <linux/mutex.h>\n#include <linux/types.h>\n#include <linux/atomic.h>\n#include <linux/smp.h>\n#include <linux/percpu.h>\n#include <linux/irqflags.h>\n#include <linux/compiler.h>\n#include <linux/kernel.h>\n\nstatic const struct file_operations pstore_knob_fops = {\n\t.open\t= simple_open,\n\t.read\t= pstore_ftrace_knob_read,\n\t.write\t= pstore_ftrace_knob_write,\n};\n\nvoid pstore_register_ftrace(void)\n{\n\tstruct dentry *dir;\n\tstruct dentry *file;\n\n\tif (!psinfo->write_buf)\n\t\treturn;\n\n\tdir = debugfs_create_dir(\"pstore\", NULL);\n\tif (!dir) {\n\t\tpr_err(\"%s: unable to create pstore directory\\n\", __func__);\n\t\treturn;\n\t}\n\n\tfile = debugfs_create_file(\"record_ftrace\", 0600, dir, NULL,\n\t\t\t\t   &pstore_knob_fops);\n\tif (!file) {\n\t\tpr_err(\"%s: unable to create record_ftrace file\\n\", __func__);\n\t\tgoto err_file;\n\t}\n\n\treturn;\nerr_file:\n\tdebugfs_remove(dir);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pstore_register_console",
          "args": [],
          "line": 448
        },
        "resolved": true,
        "details": {
          "function_name": "pstore_register_console",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/pstore/platform.c",
          "lines": "394-394",
          "snippet": "static void pstore_register_console(void) {}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/timer.h>",
            "#include <linux/string.h>",
            "#include <linux/zlib.h>",
            "#include <linux/pstore.h>",
            "#include <linux/module.h>",
            "#include <linux/console.h>",
            "#include <linux/kmsg_dump.h>",
            "#include <linux/init.h>",
            "#include <linux/errno.h>",
            "#include <linux/types.h>",
            "#include <linux/atomic.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/workqueue.h>\n#include <linux/jiffies.h>\n#include <linux/hardirq.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/timer.h>\n#include <linux/string.h>\n#include <linux/zlib.h>\n#include <linux/pstore.h>\n#include <linux/module.h>\n#include <linux/console.h>\n#include <linux/kmsg_dump.h>\n#include <linux/init.h>\n#include <linux/errno.h>\n#include <linux/types.h>\n#include <linux/atomic.h>\n\nstatic void pstore_register_console(void) {}"
        }
      },
      {
        "call_info": {
          "callee": "kmsg_dump_register",
          "args": [
            "&pstore_dumper"
          ],
          "line": 445
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pstore_get_records",
          "args": [
            "0"
          ],
          "line": 443
        },
        "resolved": true,
        "details": {
          "function_name": "pstore_get_records",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/pstore/platform.c",
          "lines": "471-529",
          "snippet": "void pstore_get_records(int quiet)\n{\n\tstruct pstore_info *psi = psinfo;\n\tchar\t\t\t*buf = NULL;\n\tssize_t\t\t\tsize;\n\tu64\t\t\tid;\n\tint\t\t\tcount;\n\tenum pstore_type_id\ttype;\n\tstruct timespec\t\ttime;\n\tint\t\t\tfailed = 0, rc;\n\tbool\t\t\tcompressed;\n\tint\t\t\tunzipped_len = -1;\n\n\tif (!psi)\n\t\treturn;\n\n\tmutex_lock(&psi->read_mutex);\n\tif (psi->open && psi->open(psi))\n\t\tgoto out;\n\n\twhile ((size = psi->read(&id, &type, &count, &time, &buf, &compressed,\n\t\t\t\tpsi)) > 0) {\n\t\tif (compressed && (type == PSTORE_TYPE_DMESG)) {\n\t\t\tif (big_oops_buf)\n\t\t\t\tunzipped_len = pstore_decompress(buf,\n\t\t\t\t\t\t\tbig_oops_buf, size,\n\t\t\t\t\t\t\tbig_oops_buf_sz);\n\n\t\t\tif (unzipped_len > 0) {\n\t\t\t\tkfree(buf);\n\t\t\t\tbuf = big_oops_buf;\n\t\t\t\tsize = unzipped_len;\n\t\t\t\tcompressed = false;\n\t\t\t} else {\n\t\t\t\tpr_err(\"decompression failed;returned %d\\n\",\n\t\t\t\t       unzipped_len);\n\t\t\t\tcompressed = true;\n\t\t\t}\n\t\t}\n\t\trc = pstore_mkfile(type, psi->name, id, count, buf,\n\t\t\t\t  compressed, (size_t)size, time, psi);\n\t\tif (unzipped_len < 0) {\n\t\t\t/* Free buffer other than big oops */\n\t\t\tkfree(buf);\n\t\t\tbuf = NULL;\n\t\t} else\n\t\t\tunzipped_len = -1;\n\t\tif (rc && (rc != -EEXIST || !quiet))\n\t\t\tfailed++;\n\t}\n\tif (psi->close)\n\t\tpsi->close(psi);\nout:\n\tmutex_unlock(&psi->read_mutex);\n\n\tif (failed)\n\t\tpr_warn(\"failed to load %d record(s) from '%s'\\n\",\n\t\t\tfailed, psi->name);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/timer.h>",
            "#include <linux/string.h>",
            "#include <linux/zlib.h>",
            "#include <linux/pstore.h>",
            "#include <linux/module.h>",
            "#include <linux/console.h>",
            "#include <linux/kmsg_dump.h>",
            "#include <linux/init.h>",
            "#include <linux/errno.h>",
            "#include <linux/types.h>",
            "#include <linux/atomic.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct pstore_info *psinfo;",
            "static char *big_oops_buf;",
            "static size_t big_oops_buf_sz;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/workqueue.h>\n#include <linux/jiffies.h>\n#include <linux/hardirq.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/timer.h>\n#include <linux/string.h>\n#include <linux/zlib.h>\n#include <linux/pstore.h>\n#include <linux/module.h>\n#include <linux/console.h>\n#include <linux/kmsg_dump.h>\n#include <linux/init.h>\n#include <linux/errno.h>\n#include <linux/types.h>\n#include <linux/atomic.h>\n\nstruct pstore_info *psinfo;\nstatic char *big_oops_buf;\nstatic size_t big_oops_buf_sz;\n\nvoid pstore_get_records(int quiet)\n{\n\tstruct pstore_info *psi = psinfo;\n\tchar\t\t\t*buf = NULL;\n\tssize_t\t\t\tsize;\n\tu64\t\t\tid;\n\tint\t\t\tcount;\n\tenum pstore_type_id\ttype;\n\tstruct timespec\t\ttime;\n\tint\t\t\tfailed = 0, rc;\n\tbool\t\t\tcompressed;\n\tint\t\t\tunzipped_len = -1;\n\n\tif (!psi)\n\t\treturn;\n\n\tmutex_lock(&psi->read_mutex);\n\tif (psi->open && psi->open(psi))\n\t\tgoto out;\n\n\twhile ((size = psi->read(&id, &type, &count, &time, &buf, &compressed,\n\t\t\t\tpsi)) > 0) {\n\t\tif (compressed && (type == PSTORE_TYPE_DMESG)) {\n\t\t\tif (big_oops_buf)\n\t\t\t\tunzipped_len = pstore_decompress(buf,\n\t\t\t\t\t\t\tbig_oops_buf, size,\n\t\t\t\t\t\t\tbig_oops_buf_sz);\n\n\t\t\tif (unzipped_len > 0) {\n\t\t\t\tkfree(buf);\n\t\t\t\tbuf = big_oops_buf;\n\t\t\t\tsize = unzipped_len;\n\t\t\t\tcompressed = false;\n\t\t\t} else {\n\t\t\t\tpr_err(\"decompression failed;returned %d\\n\",\n\t\t\t\t       unzipped_len);\n\t\t\t\tcompressed = true;\n\t\t\t}\n\t\t}\n\t\trc = pstore_mkfile(type, psi->name, id, count, buf,\n\t\t\t\t  compressed, (size_t)size, time, psi);\n\t\tif (unzipped_len < 0) {\n\t\t\t/* Free buffer other than big oops */\n\t\t\tkfree(buf);\n\t\t\tbuf = NULL;\n\t\t} else\n\t\t\tunzipped_len = -1;\n\t\tif (rc && (rc != -EEXIST || !quiet))\n\t\t\tfailed++;\n\t}\n\tif (psi->close)\n\t\tpsi->close(psi);\nout:\n\tmutex_unlock(&psi->read_mutex);\n\n\tif (failed)\n\t\tpr_warn(\"failed to load %d record(s) from '%s'\\n\",\n\t\t\tfailed, psi->name);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pstore_is_mounted",
          "args": [],
          "line": 442
        },
        "resolved": true,
        "details": {
          "function_name": "pstore_is_mounted",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/pstore/inode.c",
          "lines": "290-293",
          "snippet": "int pstore_is_mounted(void)\n{\n\treturn pstore_sb != NULL;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/syslog.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/pstore.h>",
            "#include <linux/magic.h>",
            "#include <linux/sched.h>",
            "#include <linux/parser.h>",
            "#include <linux/ramfs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mount.h>",
            "#include <linux/string.h>",
            "#include <linux/list.h>",
            "#include <linux/init.h>",
            "#include <linux/time.h>",
            "#include <linux/highmem.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct super_block *pstore_sb;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/syslog.h>\n#include <linux/uaccess.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/pstore.h>\n#include <linux/magic.h>\n#include <linux/sched.h>\n#include <linux/parser.h>\n#include <linux/ramfs.h>\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n#include <linux/string.h>\n#include <linux/list.h>\n#include <linux/init.h>\n#include <linux/time.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic struct super_block *pstore_sb;\n\nint pstore_is_mounted(void)\n{\n\treturn pstore_sb != NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "allocate_buf_for_compression",
          "args": [],
          "line": 440
        },
        "resolved": true,
        "details": {
          "function_name": "allocate_buf_for_compression",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/pstore/platform.c",
          "lines": "197-238",
          "snippet": "static void allocate_buf_for_compression(void)\n{\n\tsize_t size;\n\tsize_t cmpr;\n\n\tswitch (psinfo->bufsize) {\n\t/* buffer range for efivars */\n\tcase 1000 ... 2000:\n\t\tcmpr = 56;\n\t\tbreak;\n\tcase 2001 ... 3000:\n\t\tcmpr = 54;\n\t\tbreak;\n\tcase 3001 ... 3999:\n\t\tcmpr = 52;\n\t\tbreak;\n\t/* buffer range for nvram, erst */\n\tcase 4000 ... 10000:\n\t\tcmpr = 45;\n\t\tbreak;\n\tdefault:\n\t\tcmpr = 60;\n\t\tbreak;\n\t}\n\n\tbig_oops_buf_sz = (psinfo->bufsize * 100) / cmpr;\n\tbig_oops_buf = kmalloc(big_oops_buf_sz, GFP_KERNEL);\n\tif (big_oops_buf) {\n\t\tsize = max(zlib_deflate_workspacesize(WINDOW_BITS, MEM_LEVEL),\n\t\t\tzlib_inflate_workspacesize());\n\t\tstream.workspace = kmalloc(size, GFP_KERNEL);\n\t\tif (!stream.workspace) {\n\t\t\tpr_err(\"No memory for compression workspace; skipping compression\\n\");\n\t\t\tkfree(big_oops_buf);\n\t\t\tbig_oops_buf = NULL;\n\t\t}\n\t} else {\n\t\tpr_err(\"No memory for uncompressed data; skipping compression\\n\");\n\t\tstream.workspace = NULL;\n\t}\n\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/timer.h>",
            "#include <linux/string.h>",
            "#include <linux/zlib.h>",
            "#include <linux/pstore.h>",
            "#include <linux/module.h>",
            "#include <linux/console.h>",
            "#include <linux/kmsg_dump.h>",
            "#include <linux/init.h>",
            "#include <linux/errno.h>",
            "#include <linux/types.h>",
            "#include <linux/atomic.h>"
          ],
          "macros_used": [
            "#define MEM_LEVEL 4",
            "#define WINDOW_BITS 12"
          ],
          "globals_used": [
            "struct pstore_info *psinfo;",
            "static struct z_stream_s stream;",
            "static char *big_oops_buf;",
            "static size_t big_oops_buf_sz;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/workqueue.h>\n#include <linux/jiffies.h>\n#include <linux/hardirq.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/timer.h>\n#include <linux/string.h>\n#include <linux/zlib.h>\n#include <linux/pstore.h>\n#include <linux/module.h>\n#include <linux/console.h>\n#include <linux/kmsg_dump.h>\n#include <linux/init.h>\n#include <linux/errno.h>\n#include <linux/types.h>\n#include <linux/atomic.h>\n\n#define MEM_LEVEL 4\n#define WINDOW_BITS 12\n\nstruct pstore_info *psinfo;\nstatic struct z_stream_s stream;\nstatic char *big_oops_buf;\nstatic size_t big_oops_buf_sz;\n\nstatic void allocate_buf_for_compression(void)\n{\n\tsize_t size;\n\tsize_t cmpr;\n\n\tswitch (psinfo->bufsize) {\n\t/* buffer range for efivars */\n\tcase 1000 ... 2000:\n\t\tcmpr = 56;\n\t\tbreak;\n\tcase 2001 ... 3000:\n\t\tcmpr = 54;\n\t\tbreak;\n\tcase 3001 ... 3999:\n\t\tcmpr = 52;\n\t\tbreak;\n\t/* buffer range for nvram, erst */\n\tcase 4000 ... 10000:\n\t\tcmpr = 45;\n\t\tbreak;\n\tdefault:\n\t\tcmpr = 60;\n\t\tbreak;\n\t}\n\n\tbig_oops_buf_sz = (psinfo->bufsize * 100) / cmpr;\n\tbig_oops_buf = kmalloc(big_oops_buf_sz, GFP_KERNEL);\n\tif (big_oops_buf) {\n\t\tsize = max(zlib_deflate_workspacesize(WINDOW_BITS, MEM_LEVEL),\n\t\t\tzlib_inflate_workspacesize());\n\t\tstream.workspace = kmalloc(size, GFP_KERNEL);\n\t\tif (!stream.workspace) {\n\t\t\tpr_err(\"No memory for compression workspace; skipping compression\\n\");\n\t\t\tkfree(big_oops_buf);\n\t\t\tbig_oops_buf = NULL;\n\t\t}\n\t} else {\n\t\tpr_err(\"No memory for uncompressed data; skipping compression\\n\");\n\t\tstream.workspace = NULL;\n\t}\n\n}"
        }
      },
      {
        "call_info": {
          "callee": "try_module_get",
          "args": [
            "owner"
          ],
          "line": 435
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&pstore_lock"
          ],
          "line": 433
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_init",
          "args": [
            "&psinfo->read_mutex"
          ],
          "line": 432
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&pstore_lock"
          ],
          "line": 423
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "backend",
            "psi->name"
          ],
          "line": 420
        },
        "resolved": true,
        "details": {
          "function_name": "strcmp_prefix",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xattr.c",
          "lines": "667-675",
          "snippet": "static const char *\nstrcmp_prefix(const char *a, const char *a_prefix)\n{\n\twhile (*a_prefix && *a == *a_prefix) {\n\t\ta++;\n\t\ta_prefix++;\n\t}\n\treturn *a_prefix ? NULL : a;\n}",
          "includes": [
            "#include <asm/uaccess.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/audit.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/evm.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/xattr.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/uaccess.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/vmalloc.h>\n#include <linux/audit.h>\n#include <linux/fsnotify.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n#include <linux/evm.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/xattr.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic const char *\nstrcmp_prefix(const char *a, const char *a_prefix)\n{\n\twhile (*a_prefix && *a == *a_prefix) {\n\t\ta++;\n\t\ta_prefix++;\n\t}\n\treturn *a_prefix ? NULL : a;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/workqueue.h>\n#include <linux/jiffies.h>\n#include <linux/hardirq.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/timer.h>\n#include <linux/string.h>\n#include <linux/zlib.h>\n#include <linux/pstore.h>\n#include <linux/module.h>\n#include <linux/console.h>\n#include <linux/kmsg_dump.h>\n#include <linux/init.h>\n#include <linux/errno.h>\n#include <linux/types.h>\n#include <linux/atomic.h>\n\nstatic int pstore_update_ms = -1;\nstatic DEFINE_SPINLOCK(pstore_lock);\nstruct pstore_info *psinfo;\nstatic char *backend;\nstatic struct kmsg_dumper pstore_dumper = {\n\t.dump = pstore_dump,\n};\n\nint pstore_register(struct pstore_info *psi)\n{\n\tstruct module *owner = psi->owner;\n\n\tif (backend && strcmp(backend, psi->name))\n\t\treturn -EPERM;\n\n\tspin_lock(&pstore_lock);\n\tif (psinfo) {\n\t\tspin_unlock(&pstore_lock);\n\t\treturn -EBUSY;\n\t}\n\n\tif (!psi->write)\n\t\tpsi->write = pstore_write_compat;\n\tpsinfo = psi;\n\tmutex_init(&psinfo->read_mutex);\n\tspin_unlock(&pstore_lock);\n\n\tif (owner && !try_module_get(owner)) {\n\t\tpsinfo = NULL;\n\t\treturn -EINVAL;\n\t}\n\n\tallocate_buf_for_compression();\n\n\tif (pstore_is_mounted())\n\t\tpstore_get_records(0);\n\n\tkmsg_dump_register(&pstore_dumper);\n\n\tif ((psi->flags & PSTORE_FLAGS_FRAGILE) == 0) {\n\t\tpstore_register_console();\n\t\tpstore_register_ftrace();\n\t\tpstore_register_pmsg();\n\t}\n\n\tif (pstore_update_ms >= 0) {\n\t\tpstore_timer.expires = jiffies +\n\t\t\tmsecs_to_jiffies(pstore_update_ms);\n\t\tadd_timer(&pstore_timer);\n\t}\n\n\tpr_info(\"Registered %s as persistent store backend\\n\", psi->name);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "pstore_write_compat",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/pstore/platform.c",
    "lines": "397-405",
    "snippet": "static int pstore_write_compat(enum pstore_type_id type,\n\t\t\t       enum kmsg_dump_reason reason,\n\t\t\t       u64 *id, unsigned int part, int count,\n\t\t\t       bool compressed, size_t size,\n\t\t\t       struct pstore_info *psi)\n{\n\treturn psi->write_buf(type, reason, id, part, psinfo->buf, compressed,\n\t\t\t     size, psi);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/workqueue.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/slab.h>",
      "#include <linux/timer.h>",
      "#include <linux/string.h>",
      "#include <linux/zlib.h>",
      "#include <linux/pstore.h>",
      "#include <linux/module.h>",
      "#include <linux/console.h>",
      "#include <linux/kmsg_dump.h>",
      "#include <linux/init.h>",
      "#include <linux/errno.h>",
      "#include <linux/types.h>",
      "#include <linux/atomic.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "struct pstore_info *psinfo;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "psi->write_buf",
          "args": [
            "type",
            "reason",
            "id",
            "part",
            "psinfo->buf",
            "compressed",
            "size",
            "psi"
          ],
          "line": 403
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/workqueue.h>\n#include <linux/jiffies.h>\n#include <linux/hardirq.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/timer.h>\n#include <linux/string.h>\n#include <linux/zlib.h>\n#include <linux/pstore.h>\n#include <linux/module.h>\n#include <linux/console.h>\n#include <linux/kmsg_dump.h>\n#include <linux/init.h>\n#include <linux/errno.h>\n#include <linux/types.h>\n#include <linux/atomic.h>\n\nstruct pstore_info *psinfo;\n\nstatic int pstore_write_compat(enum pstore_type_id type,\n\t\t\t       enum kmsg_dump_reason reason,\n\t\t\t       u64 *id, unsigned int part, int count,\n\t\t\t       bool compressed, size_t size,\n\t\t\t       struct pstore_info *psi)\n{\n\treturn psi->write_buf(type, reason, id, part, psinfo->buf, compressed,\n\t\t\t     size, psi);\n}"
  },
  {
    "function_name": "pstore_register_console",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/pstore/platform.c",
    "lines": "394-394",
    "snippet": "static void pstore_register_console(void) {}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/workqueue.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/slab.h>",
      "#include <linux/timer.h>",
      "#include <linux/string.h>",
      "#include <linux/zlib.h>",
      "#include <linux/pstore.h>",
      "#include <linux/module.h>",
      "#include <linux/console.h>",
      "#include <linux/kmsg_dump.h>",
      "#include <linux/init.h>",
      "#include <linux/errno.h>",
      "#include <linux/types.h>",
      "#include <linux/atomic.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/workqueue.h>\n#include <linux/jiffies.h>\n#include <linux/hardirq.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/timer.h>\n#include <linux/string.h>\n#include <linux/zlib.h>\n#include <linux/pstore.h>\n#include <linux/module.h>\n#include <linux/console.h>\n#include <linux/kmsg_dump.h>\n#include <linux/init.h>\n#include <linux/errno.h>\n#include <linux/types.h>\n#include <linux/atomic.h>\n\nstatic void pstore_register_console(void) {}"
  },
  {
    "function_name": "pstore_register_console",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/pstore/platform.c",
    "lines": "389-392",
    "snippet": "static void pstore_register_console(void)\n{\n\tregister_console(&pstore_console);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/workqueue.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/slab.h>",
      "#include <linux/timer.h>",
      "#include <linux/string.h>",
      "#include <linux/zlib.h>",
      "#include <linux/pstore.h>",
      "#include <linux/module.h>",
      "#include <linux/console.h>",
      "#include <linux/kmsg_dump.h>",
      "#include <linux/init.h>",
      "#include <linux/errno.h>",
      "#include <linux/types.h>",
      "#include <linux/atomic.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "register_console",
          "args": [
            "&pstore_console"
          ],
          "line": 391
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/workqueue.h>\n#include <linux/jiffies.h>\n#include <linux/hardirq.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/timer.h>\n#include <linux/string.h>\n#include <linux/zlib.h>\n#include <linux/pstore.h>\n#include <linux/module.h>\n#include <linux/console.h>\n#include <linux/kmsg_dump.h>\n#include <linux/init.h>\n#include <linux/errno.h>\n#include <linux/types.h>\n#include <linux/atomic.h>\n\nstatic void pstore_register_console(void)\n{\n\tregister_console(&pstore_console);\n}"
  },
  {
    "function_name": "pstore_console_write",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/pstore/platform.c",
    "lines": "357-380",
    "snippet": "static void pstore_console_write(struct console *con, const char *s, unsigned c)\n{\n\tconst char *e = s + c;\n\n\twhile (s < e) {\n\t\tunsigned long flags;\n\t\tu64 id;\n\n\t\tif (c > psinfo->bufsize)\n\t\t\tc = psinfo->bufsize;\n\n\t\tif (oops_in_progress) {\n\t\t\tif (!spin_trylock_irqsave(&psinfo->buf_lock, flags))\n\t\t\t\tbreak;\n\t\t} else {\n\t\t\tspin_lock_irqsave(&psinfo->buf_lock, flags);\n\t\t}\n\t\tmemcpy(psinfo->buf, s, c);\n\t\tpsinfo->write(PSTORE_TYPE_CONSOLE, 0, &id, 0, 0, 0, c, psinfo);\n\t\tspin_unlock_irqrestore(&psinfo->buf_lock, flags);\n\t\ts += c;\n\t\tc = e - s;\n\t}\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/workqueue.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/slab.h>",
      "#include <linux/timer.h>",
      "#include <linux/string.h>",
      "#include <linux/zlib.h>",
      "#include <linux/pstore.h>",
      "#include <linux/module.h>",
      "#include <linux/console.h>",
      "#include <linux/kmsg_dump.h>",
      "#include <linux/init.h>",
      "#include <linux/errno.h>",
      "#include <linux/types.h>",
      "#include <linux/atomic.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "struct pstore_info *psinfo;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock_irqrestore",
          "args": [
            "&psinfo->buf_lock",
            "flags"
          ],
          "line": 376
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "psinfo->write",
          "args": [
            "PSTORE_TYPE_CONSOLE",
            "0",
            "&id",
            "0",
            "0",
            "0",
            "c",
            "psinfo"
          ],
          "line": 375
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "psinfo->buf",
            "s",
            "c"
          ],
          "line": 374
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock_irqsave",
          "args": [
            "&psinfo->buf_lock",
            "flags"
          ],
          "line": 372
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_trylock_irqsave",
          "args": [
            "&psinfo->buf_lock",
            "flags"
          ],
          "line": 369
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/workqueue.h>\n#include <linux/jiffies.h>\n#include <linux/hardirq.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/timer.h>\n#include <linux/string.h>\n#include <linux/zlib.h>\n#include <linux/pstore.h>\n#include <linux/module.h>\n#include <linux/console.h>\n#include <linux/kmsg_dump.h>\n#include <linux/init.h>\n#include <linux/errno.h>\n#include <linux/types.h>\n#include <linux/atomic.h>\n\nstruct pstore_info *psinfo;\n\nstatic void pstore_console_write(struct console *con, const char *s, unsigned c)\n{\n\tconst char *e = s + c;\n\n\twhile (s < e) {\n\t\tunsigned long flags;\n\t\tu64 id;\n\n\t\tif (c > psinfo->bufsize)\n\t\t\tc = psinfo->bufsize;\n\n\t\tif (oops_in_progress) {\n\t\t\tif (!spin_trylock_irqsave(&psinfo->buf_lock, flags))\n\t\t\t\tbreak;\n\t\t} else {\n\t\t\tspin_lock_irqsave(&psinfo->buf_lock, flags);\n\t\t}\n\t\tmemcpy(psinfo->buf, s, c);\n\t\tpsinfo->write(PSTORE_TYPE_CONSOLE, 0, &id, 0, 0, 0, c, psinfo);\n\t\tspin_unlock_irqrestore(&psinfo->buf_lock, flags);\n\t\ts += c;\n\t\tc = e - s;\n\t}\n}"
  },
  {
    "function_name": "pstore_dump",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/pstore/platform.c",
    "lines": "271-350",
    "snippet": "static void pstore_dump(struct kmsg_dumper *dumper,\n\t\t\tenum kmsg_dump_reason reason)\n{\n\tunsigned long\ttotal = 0;\n\tconst char\t*why;\n\tu64\t\tid;\n\tunsigned int\tpart = 1;\n\tunsigned long\tflags = 0;\n\tint\t\tis_locked = 0;\n\tint\t\tret;\n\n\twhy = get_reason_str(reason);\n\n\tif (pstore_cannot_block_path(reason)) {\n\t\tis_locked = spin_trylock_irqsave(&psinfo->buf_lock, flags);\n\t\tif (!is_locked) {\n\t\t\tpr_err(\"pstore dump routine blocked in %s path, may corrupt error record\\n\"\n\t\t\t\t       , in_nmi() ? \"NMI\" : why);\n\t\t}\n\t} else\n\t\tspin_lock_irqsave(&psinfo->buf_lock, flags);\n\toopscount++;\n\twhile (total < kmsg_bytes) {\n\t\tchar *dst;\n\t\tunsigned long size;\n\t\tint hsize;\n\t\tint zipped_len = -1;\n\t\tsize_t len;\n\t\tbool compressed;\n\t\tsize_t total_len;\n\n\t\tif (big_oops_buf) {\n\t\t\tdst = big_oops_buf;\n\t\t\thsize = sprintf(dst, \"%s#%d Part%u\\n\", why,\n\t\t\t\t\t\t\toopscount, part);\n\t\t\tsize = big_oops_buf_sz - hsize;\n\n\t\t\tif (!kmsg_dump_get_buffer(dumper, true, dst + hsize,\n\t\t\t\t\t\t\t\tsize, &len))\n\t\t\t\tbreak;\n\n\t\t\tzipped_len = pstore_compress(dst, psinfo->buf,\n\t\t\t\t\t\thsize + len, psinfo->bufsize);\n\n\t\t\tif (zipped_len > 0) {\n\t\t\t\tcompressed = true;\n\t\t\t\ttotal_len = zipped_len;\n\t\t\t} else {\n\t\t\t\tcompressed = false;\n\t\t\t\ttotal_len = copy_kmsg_to_buffer(hsize, len);\n\t\t\t}\n\t\t} else {\n\t\t\tdst = psinfo->buf;\n\t\t\thsize = sprintf(dst, \"%s#%d Part%u\\n\", why, oopscount,\n\t\t\t\t\t\t\t\t\tpart);\n\t\t\tsize = psinfo->bufsize - hsize;\n\t\t\tdst += hsize;\n\n\t\t\tif (!kmsg_dump_get_buffer(dumper, true, dst,\n\t\t\t\t\t\t\t\tsize, &len))\n\t\t\t\tbreak;\n\n\t\t\tcompressed = false;\n\t\t\ttotal_len = hsize + len;\n\t\t}\n\n\t\tret = psinfo->write(PSTORE_TYPE_DMESG, reason, &id, part,\n\t\t\t\t    oopscount, compressed, total_len, psinfo);\n\t\tif (ret == 0 && reason == KMSG_DUMP_OOPS && pstore_is_mounted())\n\t\t\tpstore_new_entry = 1;\n\n\t\ttotal += total_len;\n\t\tpart++;\n\t}\n\tif (pstore_cannot_block_path(reason)) {\n\t\tif (is_locked)\n\t\t\tspin_unlock_irqrestore(&psinfo->buf_lock, flags);\n\t} else\n\t\tspin_unlock_irqrestore(&psinfo->buf_lock, flags);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/workqueue.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/slab.h>",
      "#include <linux/timer.h>",
      "#include <linux/string.h>",
      "#include <linux/zlib.h>",
      "#include <linux/pstore.h>",
      "#include <linux/module.h>",
      "#include <linux/console.h>",
      "#include <linux/kmsg_dump.h>",
      "#include <linux/init.h>",
      "#include <linux/errno.h>",
      "#include <linux/types.h>",
      "#include <linux/atomic.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int pstore_new_entry;",
      "struct pstore_info *psinfo;",
      "static char *big_oops_buf;",
      "static size_t big_oops_buf_sz;",
      "static unsigned long kmsg_bytes = 10240;",
      "static int\toopscount;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock_irqrestore",
          "args": [
            "&psinfo->buf_lock",
            "flags"
          ],
          "line": 349
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock_irqrestore",
          "args": [
            "&psinfo->buf_lock",
            "flags"
          ],
          "line": 347
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pstore_cannot_block_path",
          "args": [
            "reason"
          ],
          "line": 345
        },
        "resolved": true,
        "details": {
          "function_name": "pstore_cannot_block_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/pstore/platform.c",
          "lines": "111-129",
          "snippet": "bool pstore_cannot_block_path(enum kmsg_dump_reason reason)\n{\n\t/*\n\t * In case of NMI path, pstore shouldn't be blocked\n\t * regardless of reason.\n\t */\n\tif (in_nmi())\n\t\treturn true;\n\n\tswitch (reason) {\n\t/* In panic case, other cpus are stopped by smp_send_stop(). */\n\tcase KMSG_DUMP_PANIC:\n\t/* Emergency restart shouldn't be blocked by spin lock. */\n\tcase KMSG_DUMP_EMERG:\n\t\treturn true;\n\tdefault:\n\t\treturn false;\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/timer.h>",
            "#include <linux/string.h>",
            "#include <linux/zlib.h>",
            "#include <linux/pstore.h>",
            "#include <linux/module.h>",
            "#include <linux/console.h>",
            "#include <linux/kmsg_dump.h>",
            "#include <linux/init.h>",
            "#include <linux/errno.h>",
            "#include <linux/types.h>",
            "#include <linux/atomic.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/workqueue.h>\n#include <linux/jiffies.h>\n#include <linux/hardirq.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/timer.h>\n#include <linux/string.h>\n#include <linux/zlib.h>\n#include <linux/pstore.h>\n#include <linux/module.h>\n#include <linux/console.h>\n#include <linux/kmsg_dump.h>\n#include <linux/init.h>\n#include <linux/errno.h>\n#include <linux/types.h>\n#include <linux/atomic.h>\n\nbool pstore_cannot_block_path(enum kmsg_dump_reason reason)\n{\n\t/*\n\t * In case of NMI path, pstore shouldn't be blocked\n\t * regardless of reason.\n\t */\n\tif (in_nmi())\n\t\treturn true;\n\n\tswitch (reason) {\n\t/* In panic case, other cpus are stopped by smp_send_stop(). */\n\tcase KMSG_DUMP_PANIC:\n\t/* Emergency restart shouldn't be blocked by spin lock. */\n\tcase KMSG_DUMP_EMERG:\n\t\treturn true;\n\tdefault:\n\t\treturn false;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "pstore_is_mounted",
          "args": [],
          "line": 339
        },
        "resolved": true,
        "details": {
          "function_name": "pstore_is_mounted",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/pstore/inode.c",
          "lines": "290-293",
          "snippet": "int pstore_is_mounted(void)\n{\n\treturn pstore_sb != NULL;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/syslog.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/pstore.h>",
            "#include <linux/magic.h>",
            "#include <linux/sched.h>",
            "#include <linux/parser.h>",
            "#include <linux/ramfs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mount.h>",
            "#include <linux/string.h>",
            "#include <linux/list.h>",
            "#include <linux/init.h>",
            "#include <linux/time.h>",
            "#include <linux/highmem.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct super_block *pstore_sb;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/syslog.h>\n#include <linux/uaccess.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/pstore.h>\n#include <linux/magic.h>\n#include <linux/sched.h>\n#include <linux/parser.h>\n#include <linux/ramfs.h>\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n#include <linux/string.h>\n#include <linux/list.h>\n#include <linux/init.h>\n#include <linux/time.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic struct super_block *pstore_sb;\n\nint pstore_is_mounted(void)\n{\n\treturn pstore_sb != NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "psinfo->write",
          "args": [
            "PSTORE_TYPE_DMESG",
            "reason",
            "&id",
            "part",
            "oopscount",
            "compressed",
            "total_len",
            "psinfo"
          ],
          "line": 337
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmsg_dump_get_buffer",
          "args": [
            "dumper",
            "true",
            "dst",
            "size",
            "&len"
          ],
          "line": 329
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "dst",
            "\"%s#%d Part%u\\n\"",
            "why",
            "oopscount",
            "part"
          ],
          "line": 324
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "copy_kmsg_to_buffer",
          "args": [
            "hsize",
            "len"
          ],
          "line": 320
        },
        "resolved": true,
        "details": {
          "function_name": "copy_kmsg_to_buffer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/pstore/platform.c",
          "lines": "247-264",
          "snippet": "static size_t copy_kmsg_to_buffer(int hsize, size_t len)\n{\n\tsize_t total_len;\n\tsize_t diff;\n\n\ttotal_len = hsize + len;\n\n\tif (total_len > psinfo->bufsize) {\n\t\tdiff = total_len - psinfo->bufsize + hsize;\n\t\tmemcpy(psinfo->buf, big_oops_buf, hsize);\n\t\tmemcpy(psinfo->buf + hsize, big_oops_buf + diff,\n\t\t\t\t\tpsinfo->bufsize - hsize);\n\t\ttotal_len = psinfo->bufsize;\n\t} else\n\t\tmemcpy(psinfo->buf, big_oops_buf, total_len);\n\n\treturn total_len;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/timer.h>",
            "#include <linux/string.h>",
            "#include <linux/zlib.h>",
            "#include <linux/pstore.h>",
            "#include <linux/module.h>",
            "#include <linux/console.h>",
            "#include <linux/kmsg_dump.h>",
            "#include <linux/init.h>",
            "#include <linux/errno.h>",
            "#include <linux/types.h>",
            "#include <linux/atomic.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct pstore_info *psinfo;",
            "static char *big_oops_buf;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/workqueue.h>\n#include <linux/jiffies.h>\n#include <linux/hardirq.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/timer.h>\n#include <linux/string.h>\n#include <linux/zlib.h>\n#include <linux/pstore.h>\n#include <linux/module.h>\n#include <linux/console.h>\n#include <linux/kmsg_dump.h>\n#include <linux/init.h>\n#include <linux/errno.h>\n#include <linux/types.h>\n#include <linux/atomic.h>\n\nstruct pstore_info *psinfo;\nstatic char *big_oops_buf;\n\nstatic size_t copy_kmsg_to_buffer(int hsize, size_t len)\n{\n\tsize_t total_len;\n\tsize_t diff;\n\n\ttotal_len = hsize + len;\n\n\tif (total_len > psinfo->bufsize) {\n\t\tdiff = total_len - psinfo->bufsize + hsize;\n\t\tmemcpy(psinfo->buf, big_oops_buf, hsize);\n\t\tmemcpy(psinfo->buf + hsize, big_oops_buf + diff,\n\t\t\t\t\tpsinfo->bufsize - hsize);\n\t\ttotal_len = psinfo->bufsize;\n\t} else\n\t\tmemcpy(psinfo->buf, big_oops_buf, total_len);\n\n\treturn total_len;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pstore_compress",
          "args": [
            "dst",
            "psinfo->buf",
            "hsize + len",
            "psinfo->bufsize"
          ],
          "line": 312
        },
        "resolved": true,
        "details": {
          "function_name": "pstore_compress",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/pstore/platform.c",
          "lines": "133-165",
          "snippet": "static int pstore_compress(const void *in, void *out, size_t inlen,\n\t\t\t\t\t\t\tsize_t outlen)\n{\n\tint err, ret;\n\n\tret = -EIO;\n\terr = zlib_deflateInit2(&stream, COMPR_LEVEL, Z_DEFLATED, WINDOW_BITS,\n\t\t\t\t\t\tMEM_LEVEL, Z_DEFAULT_STRATEGY);\n\tif (err != Z_OK)\n\t\tgoto error;\n\n\tstream.next_in = in;\n\tstream.avail_in = inlen;\n\tstream.total_in = 0;\n\tstream.next_out = out;\n\tstream.avail_out = outlen;\n\tstream.total_out = 0;\n\n\terr = zlib_deflate(&stream, Z_FINISH);\n\tif (err != Z_STREAM_END)\n\t\tgoto error;\n\n\terr = zlib_deflateEnd(&stream);\n\tif (err != Z_OK)\n\t\tgoto error;\n\n\tif (stream.total_out >= stream.total_in)\n\t\tgoto error;\n\n\tret = stream.total_out;\nerror:\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/timer.h>",
            "#include <linux/string.h>",
            "#include <linux/zlib.h>",
            "#include <linux/pstore.h>",
            "#include <linux/module.h>",
            "#include <linux/console.h>",
            "#include <linux/kmsg_dump.h>",
            "#include <linux/init.h>",
            "#include <linux/errno.h>",
            "#include <linux/types.h>",
            "#include <linux/atomic.h>"
          ],
          "macros_used": [
            "#define MEM_LEVEL 4",
            "#define WINDOW_BITS 12",
            "#define COMPR_LEVEL 6"
          ],
          "globals_used": [
            "static struct z_stream_s stream;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/workqueue.h>\n#include <linux/jiffies.h>\n#include <linux/hardirq.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/timer.h>\n#include <linux/string.h>\n#include <linux/zlib.h>\n#include <linux/pstore.h>\n#include <linux/module.h>\n#include <linux/console.h>\n#include <linux/kmsg_dump.h>\n#include <linux/init.h>\n#include <linux/errno.h>\n#include <linux/types.h>\n#include <linux/atomic.h>\n\n#define MEM_LEVEL 4\n#define WINDOW_BITS 12\n#define COMPR_LEVEL 6\n\nstatic struct z_stream_s stream;\n\nstatic int pstore_compress(const void *in, void *out, size_t inlen,\n\t\t\t\t\t\t\tsize_t outlen)\n{\n\tint err, ret;\n\n\tret = -EIO;\n\terr = zlib_deflateInit2(&stream, COMPR_LEVEL, Z_DEFLATED, WINDOW_BITS,\n\t\t\t\t\t\tMEM_LEVEL, Z_DEFAULT_STRATEGY);\n\tif (err != Z_OK)\n\t\tgoto error;\n\n\tstream.next_in = in;\n\tstream.avail_in = inlen;\n\tstream.total_in = 0;\n\tstream.next_out = out;\n\tstream.avail_out = outlen;\n\tstream.total_out = 0;\n\n\terr = zlib_deflate(&stream, Z_FINISH);\n\tif (err != Z_STREAM_END)\n\t\tgoto error;\n\n\terr = zlib_deflateEnd(&stream);\n\tif (err != Z_OK)\n\t\tgoto error;\n\n\tif (stream.total_out >= stream.total_in)\n\t\tgoto error;\n\n\tret = stream.total_out;\nerror:\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kmsg_dump_get_buffer",
          "args": [
            "dumper",
            "true",
            "dst + hsize",
            "size",
            "&len"
          ],
          "line": 308
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "dst",
            "\"%s#%d Part%u\\n\"",
            "why",
            "oopscount",
            "part"
          ],
          "line": 304
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock_irqsave",
          "args": [
            "&psinfo->buf_lock",
            "flags"
          ],
          "line": 291
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"pstore dump routine blocked in %s path, may corrupt error record\\n\"",
            "in_nmi() ? \"NMI\" : why"
          ],
          "line": 287
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "in_nmi",
          "args": [],
          "line": 288
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_trylock_irqsave",
          "args": [
            "&psinfo->buf_lock",
            "flags"
          ],
          "line": 285
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_reason_str",
          "args": [
            "reason"
          ],
          "line": 282
        },
        "resolved": true,
        "details": {
          "function_name": "get_reason_str",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/pstore/platform.c",
          "lines": "91-109",
          "snippet": "static const char *get_reason_str(enum kmsg_dump_reason reason)\n{\n\tswitch (reason) {\n\tcase KMSG_DUMP_PANIC:\n\t\treturn \"Panic\";\n\tcase KMSG_DUMP_OOPS:\n\t\treturn \"Oops\";\n\tcase KMSG_DUMP_EMERG:\n\t\treturn \"Emergency\";\n\tcase KMSG_DUMP_RESTART:\n\t\treturn \"Restart\";\n\tcase KMSG_DUMP_HALT:\n\t\treturn \"Halt\";\n\tcase KMSG_DUMP_POWEROFF:\n\t\treturn \"Poweroff\";\n\tdefault:\n\t\treturn \"Unknown\";\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/timer.h>",
            "#include <linux/string.h>",
            "#include <linux/zlib.h>",
            "#include <linux/pstore.h>",
            "#include <linux/module.h>",
            "#include <linux/console.h>",
            "#include <linux/kmsg_dump.h>",
            "#include <linux/init.h>",
            "#include <linux/errno.h>",
            "#include <linux/types.h>",
            "#include <linux/atomic.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/workqueue.h>\n#include <linux/jiffies.h>\n#include <linux/hardirq.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/timer.h>\n#include <linux/string.h>\n#include <linux/zlib.h>\n#include <linux/pstore.h>\n#include <linux/module.h>\n#include <linux/console.h>\n#include <linux/kmsg_dump.h>\n#include <linux/init.h>\n#include <linux/errno.h>\n#include <linux/types.h>\n#include <linux/atomic.h>\n\nstatic const char *get_reason_str(enum kmsg_dump_reason reason)\n{\n\tswitch (reason) {\n\tcase KMSG_DUMP_PANIC:\n\t\treturn \"Panic\";\n\tcase KMSG_DUMP_OOPS:\n\t\treturn \"Oops\";\n\tcase KMSG_DUMP_EMERG:\n\t\treturn \"Emergency\";\n\tcase KMSG_DUMP_RESTART:\n\t\treturn \"Restart\";\n\tcase KMSG_DUMP_HALT:\n\t\treturn \"Halt\";\n\tcase KMSG_DUMP_POWEROFF:\n\t\treturn \"Poweroff\";\n\tdefault:\n\t\treturn \"Unknown\";\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/workqueue.h>\n#include <linux/jiffies.h>\n#include <linux/hardirq.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/timer.h>\n#include <linux/string.h>\n#include <linux/zlib.h>\n#include <linux/pstore.h>\n#include <linux/module.h>\n#include <linux/console.h>\n#include <linux/kmsg_dump.h>\n#include <linux/init.h>\n#include <linux/errno.h>\n#include <linux/types.h>\n#include <linux/atomic.h>\n\nstatic int pstore_new_entry;\nstruct pstore_info *psinfo;\nstatic char *big_oops_buf;\nstatic size_t big_oops_buf_sz;\nstatic unsigned long kmsg_bytes = 10240;\nstatic int\toopscount;\n\nstatic void pstore_dump(struct kmsg_dumper *dumper,\n\t\t\tenum kmsg_dump_reason reason)\n{\n\tunsigned long\ttotal = 0;\n\tconst char\t*why;\n\tu64\t\tid;\n\tunsigned int\tpart = 1;\n\tunsigned long\tflags = 0;\n\tint\t\tis_locked = 0;\n\tint\t\tret;\n\n\twhy = get_reason_str(reason);\n\n\tif (pstore_cannot_block_path(reason)) {\n\t\tis_locked = spin_trylock_irqsave(&psinfo->buf_lock, flags);\n\t\tif (!is_locked) {\n\t\t\tpr_err(\"pstore dump routine blocked in %s path, may corrupt error record\\n\"\n\t\t\t\t       , in_nmi() ? \"NMI\" : why);\n\t\t}\n\t} else\n\t\tspin_lock_irqsave(&psinfo->buf_lock, flags);\n\toopscount++;\n\twhile (total < kmsg_bytes) {\n\t\tchar *dst;\n\t\tunsigned long size;\n\t\tint hsize;\n\t\tint zipped_len = -1;\n\t\tsize_t len;\n\t\tbool compressed;\n\t\tsize_t total_len;\n\n\t\tif (big_oops_buf) {\n\t\t\tdst = big_oops_buf;\n\t\t\thsize = sprintf(dst, \"%s#%d Part%u\\n\", why,\n\t\t\t\t\t\t\toopscount, part);\n\t\t\tsize = big_oops_buf_sz - hsize;\n\n\t\t\tif (!kmsg_dump_get_buffer(dumper, true, dst + hsize,\n\t\t\t\t\t\t\t\tsize, &len))\n\t\t\t\tbreak;\n\n\t\t\tzipped_len = pstore_compress(dst, psinfo->buf,\n\t\t\t\t\t\thsize + len, psinfo->bufsize);\n\n\t\t\tif (zipped_len > 0) {\n\t\t\t\tcompressed = true;\n\t\t\t\ttotal_len = zipped_len;\n\t\t\t} else {\n\t\t\t\tcompressed = false;\n\t\t\t\ttotal_len = copy_kmsg_to_buffer(hsize, len);\n\t\t\t}\n\t\t} else {\n\t\t\tdst = psinfo->buf;\n\t\t\thsize = sprintf(dst, \"%s#%d Part%u\\n\", why, oopscount,\n\t\t\t\t\t\t\t\t\tpart);\n\t\t\tsize = psinfo->bufsize - hsize;\n\t\t\tdst += hsize;\n\n\t\t\tif (!kmsg_dump_get_buffer(dumper, true, dst,\n\t\t\t\t\t\t\t\tsize, &len))\n\t\t\t\tbreak;\n\n\t\t\tcompressed = false;\n\t\t\ttotal_len = hsize + len;\n\t\t}\n\n\t\tret = psinfo->write(PSTORE_TYPE_DMESG, reason, &id, part,\n\t\t\t\t    oopscount, compressed, total_len, psinfo);\n\t\tif (ret == 0 && reason == KMSG_DUMP_OOPS && pstore_is_mounted())\n\t\t\tpstore_new_entry = 1;\n\n\t\ttotal += total_len;\n\t\tpart++;\n\t}\n\tif (pstore_cannot_block_path(reason)) {\n\t\tif (is_locked)\n\t\t\tspin_unlock_irqrestore(&psinfo->buf_lock, flags);\n\t} else\n\t\tspin_unlock_irqrestore(&psinfo->buf_lock, flags);\n}"
  },
  {
    "function_name": "copy_kmsg_to_buffer",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/pstore/platform.c",
    "lines": "247-264",
    "snippet": "static size_t copy_kmsg_to_buffer(int hsize, size_t len)\n{\n\tsize_t total_len;\n\tsize_t diff;\n\n\ttotal_len = hsize + len;\n\n\tif (total_len > psinfo->bufsize) {\n\t\tdiff = total_len - psinfo->bufsize + hsize;\n\t\tmemcpy(psinfo->buf, big_oops_buf, hsize);\n\t\tmemcpy(psinfo->buf + hsize, big_oops_buf + diff,\n\t\t\t\t\tpsinfo->bufsize - hsize);\n\t\ttotal_len = psinfo->bufsize;\n\t} else\n\t\tmemcpy(psinfo->buf, big_oops_buf, total_len);\n\n\treturn total_len;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/workqueue.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/slab.h>",
      "#include <linux/timer.h>",
      "#include <linux/string.h>",
      "#include <linux/zlib.h>",
      "#include <linux/pstore.h>",
      "#include <linux/module.h>",
      "#include <linux/console.h>",
      "#include <linux/kmsg_dump.h>",
      "#include <linux/init.h>",
      "#include <linux/errno.h>",
      "#include <linux/types.h>",
      "#include <linux/atomic.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "struct pstore_info *psinfo;",
      "static char *big_oops_buf;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "psinfo->buf",
            "big_oops_buf",
            "total_len"
          ],
          "line": 261
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "psinfo->buf + hsize",
            "big_oops_buf + diff",
            "psinfo->bufsize - hsize"
          ],
          "line": 257
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "psinfo->buf",
            "big_oops_buf",
            "hsize"
          ],
          "line": 256
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/workqueue.h>\n#include <linux/jiffies.h>\n#include <linux/hardirq.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/timer.h>\n#include <linux/string.h>\n#include <linux/zlib.h>\n#include <linux/pstore.h>\n#include <linux/module.h>\n#include <linux/console.h>\n#include <linux/kmsg_dump.h>\n#include <linux/init.h>\n#include <linux/errno.h>\n#include <linux/types.h>\n#include <linux/atomic.h>\n\nstruct pstore_info *psinfo;\nstatic char *big_oops_buf;\n\nstatic size_t copy_kmsg_to_buffer(int hsize, size_t len)\n{\n\tsize_t total_len;\n\tsize_t diff;\n\n\ttotal_len = hsize + len;\n\n\tif (total_len > psinfo->bufsize) {\n\t\tdiff = total_len - psinfo->bufsize + hsize;\n\t\tmemcpy(psinfo->buf, big_oops_buf, hsize);\n\t\tmemcpy(psinfo->buf + hsize, big_oops_buf + diff,\n\t\t\t\t\tpsinfo->bufsize - hsize);\n\t\ttotal_len = psinfo->bufsize;\n\t} else\n\t\tmemcpy(psinfo->buf, big_oops_buf, total_len);\n\n\treturn total_len;\n}"
  },
  {
    "function_name": "allocate_buf_for_compression",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/pstore/platform.c",
    "lines": "197-238",
    "snippet": "static void allocate_buf_for_compression(void)\n{\n\tsize_t size;\n\tsize_t cmpr;\n\n\tswitch (psinfo->bufsize) {\n\t/* buffer range for efivars */\n\tcase 1000 ... 2000:\n\t\tcmpr = 56;\n\t\tbreak;\n\tcase 2001 ... 3000:\n\t\tcmpr = 54;\n\t\tbreak;\n\tcase 3001 ... 3999:\n\t\tcmpr = 52;\n\t\tbreak;\n\t/* buffer range for nvram, erst */\n\tcase 4000 ... 10000:\n\t\tcmpr = 45;\n\t\tbreak;\n\tdefault:\n\t\tcmpr = 60;\n\t\tbreak;\n\t}\n\n\tbig_oops_buf_sz = (psinfo->bufsize * 100) / cmpr;\n\tbig_oops_buf = kmalloc(big_oops_buf_sz, GFP_KERNEL);\n\tif (big_oops_buf) {\n\t\tsize = max(zlib_deflate_workspacesize(WINDOW_BITS, MEM_LEVEL),\n\t\t\tzlib_inflate_workspacesize());\n\t\tstream.workspace = kmalloc(size, GFP_KERNEL);\n\t\tif (!stream.workspace) {\n\t\t\tpr_err(\"No memory for compression workspace; skipping compression\\n\");\n\t\t\tkfree(big_oops_buf);\n\t\t\tbig_oops_buf = NULL;\n\t\t}\n\t} else {\n\t\tpr_err(\"No memory for uncompressed data; skipping compression\\n\");\n\t\tstream.workspace = NULL;\n\t}\n\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/workqueue.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/slab.h>",
      "#include <linux/timer.h>",
      "#include <linux/string.h>",
      "#include <linux/zlib.h>",
      "#include <linux/pstore.h>",
      "#include <linux/module.h>",
      "#include <linux/console.h>",
      "#include <linux/kmsg_dump.h>",
      "#include <linux/init.h>",
      "#include <linux/errno.h>",
      "#include <linux/types.h>",
      "#include <linux/atomic.h>"
    ],
    "macros_used": [
      "#define MEM_LEVEL 4",
      "#define WINDOW_BITS 12"
    ],
    "globals_used": [
      "struct pstore_info *psinfo;",
      "static struct z_stream_s stream;",
      "static char *big_oops_buf;",
      "static size_t big_oops_buf_sz;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"No memory for uncompressed data; skipping compression\\n\""
          ],
          "line": 234
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "big_oops_buf"
          ],
          "line": 230
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"No memory for compression workspace; skipping compression\\n\""
          ],
          "line": 229
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmalloc",
          "args": [
            "size",
            "GFP_KERNEL"
          ],
          "line": 227
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_dx_dir_kmalloc_leaves",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
          "lines": "2534-2546",
          "snippet": "static struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}"
        }
      },
      {
        "call_info": {
          "callee": "max",
          "args": [
            "zlib_deflate_workspacesize(WINDOW_BITS, MEM_LEVEL)",
            "zlib_inflate_workspacesize()"
          ],
          "line": 225
        },
        "resolved": true,
        "details": {
          "function_name": "max_select_fd",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/select.c",
          "lines": "342-382",
          "snippet": "static int max_select_fd(unsigned long n, fd_set_bits *fds)\n{\n\tunsigned long *open_fds;\n\tunsigned long set;\n\tint max;\n\tstruct fdtable *fdt;\n\n\t/* handle last in-complete long-word first */\n\tset = ~(~0UL << (n & (BITS_PER_LONG-1)));\n\tn /= BITS_PER_LONG;\n\tfdt = files_fdtable(current->files);\n\topen_fds = fdt->open_fds + n;\n\tmax = 0;\n\tif (set) {\n\t\tset &= BITS(fds, n);\n\t\tif (set) {\n\t\t\tif (!(set & ~*open_fds))\n\t\t\t\tgoto get_max;\n\t\t\treturn -EBADF;\n\t\t}\n\t}\n\twhile (n) {\n\t\topen_fds--;\n\t\tn--;\n\t\tset = BITS(fds, n);\n\t\tif (!set)\n\t\t\tcontinue;\n\t\tif (set & ~*open_fds)\n\t\t\treturn -EBADF;\n\t\tif (max)\n\t\t\tcontinue;\nget_max:\n\t\tdo {\n\t\t\tmax++;\n\t\t\tset >>= 1;\n\t\t} while (set);\n\t\tmax += n * BITS_PER_LONG;\n\t}\n\n\treturn max;\n}",
          "includes": [
            "#include <asm/uaccess.h>",
            "#include <net/busy_poll.h>",
            "#include <linux/freezer.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/fs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/personality.h> /* for STICKY_TIMEOUTS */",
            "#include <linux/poll.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/uaccess.h>\n#include <net/busy_poll.h>\n#include <linux/freezer.h>\n#include <linux/sched/rt.h>\n#include <linux/hrtimer.h>\n#include <linux/rcupdate.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/personality.h> /* for STICKY_TIMEOUTS */\n#include <linux/poll.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n\nstatic int max_select_fd(unsigned long n, fd_set_bits *fds)\n{\n\tunsigned long *open_fds;\n\tunsigned long set;\n\tint max;\n\tstruct fdtable *fdt;\n\n\t/* handle last in-complete long-word first */\n\tset = ~(~0UL << (n & (BITS_PER_LONG-1)));\n\tn /= BITS_PER_LONG;\n\tfdt = files_fdtable(current->files);\n\topen_fds = fdt->open_fds + n;\n\tmax = 0;\n\tif (set) {\n\t\tset &= BITS(fds, n);\n\t\tif (set) {\n\t\t\tif (!(set & ~*open_fds))\n\t\t\t\tgoto get_max;\n\t\t\treturn -EBADF;\n\t\t}\n\t}\n\twhile (n) {\n\t\topen_fds--;\n\t\tn--;\n\t\tset = BITS(fds, n);\n\t\tif (!set)\n\t\t\tcontinue;\n\t\tif (set & ~*open_fds)\n\t\t\treturn -EBADF;\n\t\tif (max)\n\t\t\tcontinue;\nget_max:\n\t\tdo {\n\t\t\tmax++;\n\t\t\tset >>= 1;\n\t\t} while (set);\n\t\tmax += n * BITS_PER_LONG;\n\t}\n\n\treturn max;\n}"
        }
      },
      {
        "call_info": {
          "callee": "zlib_inflate_workspacesize",
          "args": [],
          "line": 226
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "zlib_deflate_workspacesize",
          "args": [
            "WINDOW_BITS",
            "MEM_LEVEL"
          ],
          "line": 225
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/workqueue.h>\n#include <linux/jiffies.h>\n#include <linux/hardirq.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/timer.h>\n#include <linux/string.h>\n#include <linux/zlib.h>\n#include <linux/pstore.h>\n#include <linux/module.h>\n#include <linux/console.h>\n#include <linux/kmsg_dump.h>\n#include <linux/init.h>\n#include <linux/errno.h>\n#include <linux/types.h>\n#include <linux/atomic.h>\n\n#define MEM_LEVEL 4\n#define WINDOW_BITS 12\n\nstruct pstore_info *psinfo;\nstatic struct z_stream_s stream;\nstatic char *big_oops_buf;\nstatic size_t big_oops_buf_sz;\n\nstatic void allocate_buf_for_compression(void)\n{\n\tsize_t size;\n\tsize_t cmpr;\n\n\tswitch (psinfo->bufsize) {\n\t/* buffer range for efivars */\n\tcase 1000 ... 2000:\n\t\tcmpr = 56;\n\t\tbreak;\n\tcase 2001 ... 3000:\n\t\tcmpr = 54;\n\t\tbreak;\n\tcase 3001 ... 3999:\n\t\tcmpr = 52;\n\t\tbreak;\n\t/* buffer range for nvram, erst */\n\tcase 4000 ... 10000:\n\t\tcmpr = 45;\n\t\tbreak;\n\tdefault:\n\t\tcmpr = 60;\n\t\tbreak;\n\t}\n\n\tbig_oops_buf_sz = (psinfo->bufsize * 100) / cmpr;\n\tbig_oops_buf = kmalloc(big_oops_buf_sz, GFP_KERNEL);\n\tif (big_oops_buf) {\n\t\tsize = max(zlib_deflate_workspacesize(WINDOW_BITS, MEM_LEVEL),\n\t\t\tzlib_inflate_workspacesize());\n\t\tstream.workspace = kmalloc(size, GFP_KERNEL);\n\t\tif (!stream.workspace) {\n\t\t\tpr_err(\"No memory for compression workspace; skipping compression\\n\");\n\t\t\tkfree(big_oops_buf);\n\t\t\tbig_oops_buf = NULL;\n\t\t}\n\t} else {\n\t\tpr_err(\"No memory for uncompressed data; skipping compression\\n\");\n\t\tstream.workspace = NULL;\n\t}\n\n}"
  },
  {
    "function_name": "pstore_decompress",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/pstore/platform.c",
    "lines": "168-195",
    "snippet": "static int pstore_decompress(void *in, void *out, size_t inlen, size_t outlen)\n{\n\tint err, ret;\n\n\tret = -EIO;\n\terr = zlib_inflateInit2(&stream, WINDOW_BITS);\n\tif (err != Z_OK)\n\t\tgoto error;\n\n\tstream.next_in = in;\n\tstream.avail_in = inlen;\n\tstream.total_in = 0;\n\tstream.next_out = out;\n\tstream.avail_out = outlen;\n\tstream.total_out = 0;\n\n\terr = zlib_inflate(&stream, Z_FINISH);\n\tif (err != Z_STREAM_END)\n\t\tgoto error;\n\n\terr = zlib_inflateEnd(&stream);\n\tif (err != Z_OK)\n\t\tgoto error;\n\n\tret = stream.total_out;\nerror:\n\treturn ret;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/workqueue.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/slab.h>",
      "#include <linux/timer.h>",
      "#include <linux/string.h>",
      "#include <linux/zlib.h>",
      "#include <linux/pstore.h>",
      "#include <linux/module.h>",
      "#include <linux/console.h>",
      "#include <linux/kmsg_dump.h>",
      "#include <linux/init.h>",
      "#include <linux/errno.h>",
      "#include <linux/types.h>",
      "#include <linux/atomic.h>"
    ],
    "macros_used": [
      "#define WINDOW_BITS 12"
    ],
    "globals_used": [
      "static struct z_stream_s stream;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "zlib_inflateEnd",
          "args": [
            "&stream"
          ],
          "line": 188
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "zlib_inflate",
          "args": [
            "&stream",
            "Z_FINISH"
          ],
          "line": 184
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "zlib_inflateInit2",
          "args": [
            "&stream",
            "WINDOW_BITS"
          ],
          "line": 173
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/workqueue.h>\n#include <linux/jiffies.h>\n#include <linux/hardirq.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/timer.h>\n#include <linux/string.h>\n#include <linux/zlib.h>\n#include <linux/pstore.h>\n#include <linux/module.h>\n#include <linux/console.h>\n#include <linux/kmsg_dump.h>\n#include <linux/init.h>\n#include <linux/errno.h>\n#include <linux/types.h>\n#include <linux/atomic.h>\n\n#define WINDOW_BITS 12\n\nstatic struct z_stream_s stream;\n\nstatic int pstore_decompress(void *in, void *out, size_t inlen, size_t outlen)\n{\n\tint err, ret;\n\n\tret = -EIO;\n\terr = zlib_inflateInit2(&stream, WINDOW_BITS);\n\tif (err != Z_OK)\n\t\tgoto error;\n\n\tstream.next_in = in;\n\tstream.avail_in = inlen;\n\tstream.total_in = 0;\n\tstream.next_out = out;\n\tstream.avail_out = outlen;\n\tstream.total_out = 0;\n\n\terr = zlib_inflate(&stream, Z_FINISH);\n\tif (err != Z_STREAM_END)\n\t\tgoto error;\n\n\terr = zlib_inflateEnd(&stream);\n\tif (err != Z_OK)\n\t\tgoto error;\n\n\tret = stream.total_out;\nerror:\n\treturn ret;\n}"
  },
  {
    "function_name": "pstore_compress",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/pstore/platform.c",
    "lines": "133-165",
    "snippet": "static int pstore_compress(const void *in, void *out, size_t inlen,\n\t\t\t\t\t\t\tsize_t outlen)\n{\n\tint err, ret;\n\n\tret = -EIO;\n\terr = zlib_deflateInit2(&stream, COMPR_LEVEL, Z_DEFLATED, WINDOW_BITS,\n\t\t\t\t\t\tMEM_LEVEL, Z_DEFAULT_STRATEGY);\n\tif (err != Z_OK)\n\t\tgoto error;\n\n\tstream.next_in = in;\n\tstream.avail_in = inlen;\n\tstream.total_in = 0;\n\tstream.next_out = out;\n\tstream.avail_out = outlen;\n\tstream.total_out = 0;\n\n\terr = zlib_deflate(&stream, Z_FINISH);\n\tif (err != Z_STREAM_END)\n\t\tgoto error;\n\n\terr = zlib_deflateEnd(&stream);\n\tif (err != Z_OK)\n\t\tgoto error;\n\n\tif (stream.total_out >= stream.total_in)\n\t\tgoto error;\n\n\tret = stream.total_out;\nerror:\n\treturn ret;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/workqueue.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/slab.h>",
      "#include <linux/timer.h>",
      "#include <linux/string.h>",
      "#include <linux/zlib.h>",
      "#include <linux/pstore.h>",
      "#include <linux/module.h>",
      "#include <linux/console.h>",
      "#include <linux/kmsg_dump.h>",
      "#include <linux/init.h>",
      "#include <linux/errno.h>",
      "#include <linux/types.h>",
      "#include <linux/atomic.h>"
    ],
    "macros_used": [
      "#define MEM_LEVEL 4",
      "#define WINDOW_BITS 12",
      "#define COMPR_LEVEL 6"
    ],
    "globals_used": [
      "static struct z_stream_s stream;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "zlib_deflateEnd",
          "args": [
            "&stream"
          ],
          "line": 155
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "zlib_deflate",
          "args": [
            "&stream",
            "Z_FINISH"
          ],
          "line": 151
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "zlib_deflateInit2",
          "args": [
            "&stream",
            "COMPR_LEVEL",
            "Z_DEFLATED",
            "WINDOW_BITS",
            "MEM_LEVEL",
            "Z_DEFAULT_STRATEGY"
          ],
          "line": 139
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/workqueue.h>\n#include <linux/jiffies.h>\n#include <linux/hardirq.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/timer.h>\n#include <linux/string.h>\n#include <linux/zlib.h>\n#include <linux/pstore.h>\n#include <linux/module.h>\n#include <linux/console.h>\n#include <linux/kmsg_dump.h>\n#include <linux/init.h>\n#include <linux/errno.h>\n#include <linux/types.h>\n#include <linux/atomic.h>\n\n#define MEM_LEVEL 4\n#define WINDOW_BITS 12\n#define COMPR_LEVEL 6\n\nstatic struct z_stream_s stream;\n\nstatic int pstore_compress(const void *in, void *out, size_t inlen,\n\t\t\t\t\t\t\tsize_t outlen)\n{\n\tint err, ret;\n\n\tret = -EIO;\n\terr = zlib_deflateInit2(&stream, COMPR_LEVEL, Z_DEFLATED, WINDOW_BITS,\n\t\t\t\t\t\tMEM_LEVEL, Z_DEFAULT_STRATEGY);\n\tif (err != Z_OK)\n\t\tgoto error;\n\n\tstream.next_in = in;\n\tstream.avail_in = inlen;\n\tstream.total_in = 0;\n\tstream.next_out = out;\n\tstream.avail_out = outlen;\n\tstream.total_out = 0;\n\n\terr = zlib_deflate(&stream, Z_FINISH);\n\tif (err != Z_STREAM_END)\n\t\tgoto error;\n\n\terr = zlib_deflateEnd(&stream);\n\tif (err != Z_OK)\n\t\tgoto error;\n\n\tif (stream.total_out >= stream.total_in)\n\t\tgoto error;\n\n\tret = stream.total_out;\nerror:\n\treturn ret;\n}"
  },
  {
    "function_name": "pstore_cannot_block_path",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/pstore/platform.c",
    "lines": "111-129",
    "snippet": "bool pstore_cannot_block_path(enum kmsg_dump_reason reason)\n{\n\t/*\n\t * In case of NMI path, pstore shouldn't be blocked\n\t * regardless of reason.\n\t */\n\tif (in_nmi())\n\t\treturn true;\n\n\tswitch (reason) {\n\t/* In panic case, other cpus are stopped by smp_send_stop(). */\n\tcase KMSG_DUMP_PANIC:\n\t/* Emergency restart shouldn't be blocked by spin lock. */\n\tcase KMSG_DUMP_EMERG:\n\t\treturn true;\n\tdefault:\n\t\treturn false;\n\t}\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/workqueue.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/slab.h>",
      "#include <linux/timer.h>",
      "#include <linux/string.h>",
      "#include <linux/zlib.h>",
      "#include <linux/pstore.h>",
      "#include <linux/module.h>",
      "#include <linux/console.h>",
      "#include <linux/kmsg_dump.h>",
      "#include <linux/init.h>",
      "#include <linux/errno.h>",
      "#include <linux/types.h>",
      "#include <linux/atomic.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "in_nmi",
          "args": [],
          "line": 117
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/workqueue.h>\n#include <linux/jiffies.h>\n#include <linux/hardirq.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/timer.h>\n#include <linux/string.h>\n#include <linux/zlib.h>\n#include <linux/pstore.h>\n#include <linux/module.h>\n#include <linux/console.h>\n#include <linux/kmsg_dump.h>\n#include <linux/init.h>\n#include <linux/errno.h>\n#include <linux/types.h>\n#include <linux/atomic.h>\n\nbool pstore_cannot_block_path(enum kmsg_dump_reason reason)\n{\n\t/*\n\t * In case of NMI path, pstore shouldn't be blocked\n\t * regardless of reason.\n\t */\n\tif (in_nmi())\n\t\treturn true;\n\n\tswitch (reason) {\n\t/* In panic case, other cpus are stopped by smp_send_stop(). */\n\tcase KMSG_DUMP_PANIC:\n\t/* Emergency restart shouldn't be blocked by spin lock. */\n\tcase KMSG_DUMP_EMERG:\n\t\treturn true;\n\tdefault:\n\t\treturn false;\n\t}\n}"
  },
  {
    "function_name": "get_reason_str",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/pstore/platform.c",
    "lines": "91-109",
    "snippet": "static const char *get_reason_str(enum kmsg_dump_reason reason)\n{\n\tswitch (reason) {\n\tcase KMSG_DUMP_PANIC:\n\t\treturn \"Panic\";\n\tcase KMSG_DUMP_OOPS:\n\t\treturn \"Oops\";\n\tcase KMSG_DUMP_EMERG:\n\t\treturn \"Emergency\";\n\tcase KMSG_DUMP_RESTART:\n\t\treturn \"Restart\";\n\tcase KMSG_DUMP_HALT:\n\t\treturn \"Halt\";\n\tcase KMSG_DUMP_POWEROFF:\n\t\treturn \"Poweroff\";\n\tdefault:\n\t\treturn \"Unknown\";\n\t}\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/workqueue.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/slab.h>",
      "#include <linux/timer.h>",
      "#include <linux/string.h>",
      "#include <linux/zlib.h>",
      "#include <linux/pstore.h>",
      "#include <linux/module.h>",
      "#include <linux/console.h>",
      "#include <linux/kmsg_dump.h>",
      "#include <linux/init.h>",
      "#include <linux/errno.h>",
      "#include <linux/types.h>",
      "#include <linux/atomic.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/workqueue.h>\n#include <linux/jiffies.h>\n#include <linux/hardirq.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/timer.h>\n#include <linux/string.h>\n#include <linux/zlib.h>\n#include <linux/pstore.h>\n#include <linux/module.h>\n#include <linux/console.h>\n#include <linux/kmsg_dump.h>\n#include <linux/init.h>\n#include <linux/errno.h>\n#include <linux/types.h>\n#include <linux/atomic.h>\n\nstatic const char *get_reason_str(enum kmsg_dump_reason reason)\n{\n\tswitch (reason) {\n\tcase KMSG_DUMP_PANIC:\n\t\treturn \"Panic\";\n\tcase KMSG_DUMP_OOPS:\n\t\treturn \"Oops\";\n\tcase KMSG_DUMP_EMERG:\n\t\treturn \"Emergency\";\n\tcase KMSG_DUMP_RESTART:\n\t\treturn \"Restart\";\n\tcase KMSG_DUMP_HALT:\n\t\treturn \"Halt\";\n\tcase KMSG_DUMP_POWEROFF:\n\t\treturn \"Poweroff\";\n\tdefault:\n\t\treturn \"Unknown\";\n\t}\n}"
  },
  {
    "function_name": "pstore_set_kmsg_bytes",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/pstore/platform.c",
    "lines": "83-86",
    "snippet": "void pstore_set_kmsg_bytes(int bytes)\n{\n\tkmsg_bytes = bytes;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/workqueue.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/slab.h>",
      "#include <linux/timer.h>",
      "#include <linux/string.h>",
      "#include <linux/zlib.h>",
      "#include <linux/pstore.h>",
      "#include <linux/module.h>",
      "#include <linux/console.h>",
      "#include <linux/kmsg_dump.h>",
      "#include <linux/init.h>",
      "#include <linux/errno.h>",
      "#include <linux/types.h>",
      "#include <linux/atomic.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static unsigned long kmsg_bytes = 10240;"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/workqueue.h>\n#include <linux/jiffies.h>\n#include <linux/hardirq.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/timer.h>\n#include <linux/string.h>\n#include <linux/zlib.h>\n#include <linux/pstore.h>\n#include <linux/module.h>\n#include <linux/console.h>\n#include <linux/kmsg_dump.h>\n#include <linux/init.h>\n#include <linux/errno.h>\n#include <linux/types.h>\n#include <linux/atomic.h>\n\nstatic unsigned long kmsg_bytes = 10240;\n\nvoid pstore_set_kmsg_bytes(int bytes)\n{\n\tkmsg_bytes = bytes;\n}"
  }
]