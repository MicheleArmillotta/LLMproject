[
  {
    "function_name": "gfs2_fiemap",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/inode.c",
    "lines": "1880-1920",
    "snippet": "static int gfs2_fiemap(struct inode *inode, struct fiemap_extent_info *fieinfo,\n\t\t       u64 start, u64 len)\n{\n\tstruct gfs2_inode *ip = GFS2_I(inode);\n\tstruct gfs2_holder gh;\n\tint ret;\n\n\tret = fiemap_check_flags(fieinfo, FIEMAP_FLAG_SYNC);\n\tif (ret)\n\t\treturn ret;\n\n\tmutex_lock(&inode->i_mutex);\n\n\tret = gfs2_glock_nq_init(ip->i_gl, LM_ST_SHARED, 0, &gh);\n\tif (ret)\n\t\tgoto out;\n\n\tif (gfs2_is_stuffed(ip)) {\n\t\tu64 phys = ip->i_no_addr << inode->i_blkbits;\n\t\tu64 size = i_size_read(inode);\n\t\tu32 flags = FIEMAP_EXTENT_LAST|FIEMAP_EXTENT_NOT_ALIGNED|\n\t\t\t    FIEMAP_EXTENT_DATA_INLINE;\n\t\tphys += sizeof(struct gfs2_dinode);\n\t\tphys += start;\n\t\tif (start + len > size)\n\t\t\tlen = size - start;\n\t\tif (start < size)\n\t\t\tret = fiemap_fill_next_extent(fieinfo, start, phys,\n\t\t\t\t\t\t      len, flags);\n\t\tif (ret == 1)\n\t\t\tret = 0;\n\t} else {\n\t\tret = __generic_block_fiemap(inode, fieinfo, start, len,\n\t\t\t\t\t     gfs2_block_map);\n\t}\n\n\tgfs2_glock_dq_uninit(&gh);\nout:\n\tmutex_unlock(&inode->i_mutex);\n\treturn ret;\n}",
    "includes": [
      "#include \"glops.h\"",
      "#include \"super.h\"",
      "#include \"util.h\"",
      "#include \"trans.h\"",
      "#include \"rgrp.h\"",
      "#include \"quota.h\"",
      "#include \"meta_io.h\"",
      "#include \"inode.h\"",
      "#include \"glock.h\"",
      "#include \"xattr.h\"",
      "#include \"dir.h\"",
      "#include \"bmap.h\"",
      "#include \"acl.h\"",
      "#include \"incore.h\"",
      "#include \"gfs2.h\"",
      "#include <asm/uaccess.h>",
      "#include <linux/security.h>",
      "#include <linux/fiemap.h>",
      "#include <linux/crc32.h>",
      "#include <linux/gfs2_ondisk.h>",
      "#include <linux/posix_acl.h>",
      "#include <linux/xattr.h>",
      "#include <linux/mm.h>",
      "#include <linux/namei.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/completion.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&inode->i_mutex"
          ],
          "line": 1918
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gfs2_glock_dq_uninit",
          "args": [
            "&gh"
          ],
          "line": 1916
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_glock_dq_uninit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/glock.c",
          "lines": "1110-1114",
          "snippet": "void gfs2_glock_dq_uninit(struct gfs2_holder *gh)\n{\n\tgfs2_glock_dq(gh);\n\tgfs2_holder_uninit(gh);\n}",
          "includes": [
            "#include \"trace_gfs2.h\"",
            "#include \"bmap.h\"",
            "#include \"util.h\"",
            "#include \"super.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"lops.h\"",
            "#include \"inode.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/lockref.h>",
            "#include <linux/list_sort.h>",
            "#include <linux/percpu.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/seq_file.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/module.h>",
            "#include <linux/wait.h>",
            "#include <linux/list.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/jhash.h>",
            "#include <linux/sort.h>",
            "#include <linux/delay.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"bmap.h\"\n#include \"util.h\"\n#include \"super.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"lops.h\"\n#include \"inode.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/lockref.h>\n#include <linux/list_sort.h>\n#include <linux/percpu.h>\n#include <linux/bit_spinlock.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/jiffies.h>\n#include <linux/workqueue.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <asm/uaccess.h>\n#include <linux/module.h>\n#include <linux/wait.h>\n#include <linux/list.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/kallsyms.h>\n#include <linux/jhash.h>\n#include <linux/sort.h>\n#include <linux/delay.h>\n#include <linux/buffer_head.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nvoid gfs2_glock_dq_uninit(struct gfs2_holder *gh)\n{\n\tgfs2_glock_dq(gh);\n\tgfs2_holder_uninit(gh);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__generic_block_fiemap",
          "args": [
            "inode",
            "fieinfo",
            "start",
            "len",
            "gfs2_block_map"
          ],
          "line": 1912
        },
        "resolved": true,
        "details": {
          "function_name": "__generic_block_fiemap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ioctl.c",
          "lines": "250-394",
          "snippet": "int __generic_block_fiemap(struct inode *inode,\n\t\t\t   struct fiemap_extent_info *fieinfo, loff_t start,\n\t\t\t   loff_t len, get_block_t *get_block)\n{\n\tstruct buffer_head map_bh;\n\tsector_t start_blk, last_blk;\n\tloff_t isize = i_size_read(inode);\n\tu64 logical = 0, phys = 0, size = 0;\n\tu32 flags = FIEMAP_EXTENT_MERGED;\n\tbool past_eof = false, whole_file = false;\n\tint ret = 0;\n\n\tret = fiemap_check_flags(fieinfo, FIEMAP_FLAG_SYNC);\n\tif (ret)\n\t\treturn ret;\n\n\t/*\n\t * Either the i_mutex or other appropriate locking needs to be held\n\t * since we expect isize to not change at all through the duration of\n\t * this call.\n\t */\n\tif (len >= isize) {\n\t\twhole_file = true;\n\t\tlen = isize;\n\t}\n\n\t/*\n\t * Some filesystems can't deal with being asked to map less than\n\t * blocksize, so make sure our len is at least block length.\n\t */\n\tif (logical_to_blk(inode, len) == 0)\n\t\tlen = blk_to_logical(inode, 1);\n\n\tstart_blk = logical_to_blk(inode, start);\n\tlast_blk = logical_to_blk(inode, start + len - 1);\n\n\tdo {\n\t\t/*\n\t\t * we set b_size to the total size we want so it will map as\n\t\t * many contiguous blocks as possible at once\n\t\t */\n\t\tmemset(&map_bh, 0, sizeof(struct buffer_head));\n\t\tmap_bh.b_size = len;\n\n\t\tret = get_block(inode, start_blk, &map_bh, 0);\n\t\tif (ret)\n\t\t\tbreak;\n\n\t\t/* HOLE */\n\t\tif (!buffer_mapped(&map_bh)) {\n\t\t\tstart_blk++;\n\n\t\t\t/*\n\t\t\t * We want to handle the case where there is an\n\t\t\t * allocated block at the front of the file, and then\n\t\t\t * nothing but holes up to the end of the file properly,\n\t\t\t * to make sure that extent at the front gets properly\n\t\t\t * marked with FIEMAP_EXTENT_LAST\n\t\t\t */\n\t\t\tif (!past_eof &&\n\t\t\t    blk_to_logical(inode, start_blk) >= isize)\n\t\t\t\tpast_eof = 1;\n\n\t\t\t/*\n\t\t\t * First hole after going past the EOF, this is our\n\t\t\t * last extent\n\t\t\t */\n\t\t\tif (past_eof && size) {\n\t\t\t\tflags = FIEMAP_EXTENT_MERGED|FIEMAP_EXTENT_LAST;\n\t\t\t\tret = fiemap_fill_next_extent(fieinfo, logical,\n\t\t\t\t\t\t\t      phys, size,\n\t\t\t\t\t\t\t      flags);\n\t\t\t} else if (size) {\n\t\t\t\tret = fiemap_fill_next_extent(fieinfo, logical,\n\t\t\t\t\t\t\t      phys, size, flags);\n\t\t\t\tsize = 0;\n\t\t\t}\n\n\t\t\t/* if we have holes up to/past EOF then we're done */\n\t\t\tif (start_blk > last_blk || past_eof || ret)\n\t\t\t\tbreak;\n\t\t} else {\n\t\t\t/*\n\t\t\t * We have gone over the length of what we wanted to\n\t\t\t * map, and it wasn't the entire file, so add the extent\n\t\t\t * we got last time and exit.\n\t\t\t *\n\t\t\t * This is for the case where say we want to map all the\n\t\t\t * way up to the second to the last block in a file, but\n\t\t\t * the last block is a hole, making the second to last\n\t\t\t * block FIEMAP_EXTENT_LAST.  In this case we want to\n\t\t\t * see if there is a hole after the second to last block\n\t\t\t * so we can mark it properly.  If we found data after\n\t\t\t * we exceeded the length we were requesting, then we\n\t\t\t * are good to go, just add the extent to the fieinfo\n\t\t\t * and break\n\t\t\t */\n\t\t\tif (start_blk > last_blk && !whole_file) {\n\t\t\t\tret = fiemap_fill_next_extent(fieinfo, logical,\n\t\t\t\t\t\t\t      phys, size,\n\t\t\t\t\t\t\t      flags);\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * if size != 0 then we know we already have an extent\n\t\t\t * to add, so add it.\n\t\t\t */\n\t\t\tif (size) {\n\t\t\t\tret = fiemap_fill_next_extent(fieinfo, logical,\n\t\t\t\t\t\t\t      phys, size,\n\t\t\t\t\t\t\t      flags);\n\t\t\t\tif (ret)\n\t\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tlogical = blk_to_logical(inode, start_blk);\n\t\t\tphys = blk_to_logical(inode, map_bh.b_blocknr);\n\t\t\tsize = map_bh.b_size;\n\t\t\tflags = FIEMAP_EXTENT_MERGED;\n\n\t\t\tstart_blk += logical_to_blk(inode, size);\n\n\t\t\t/*\n\t\t\t * If we are past the EOF, then we need to make sure as\n\t\t\t * soon as we find a hole that the last extent we found\n\t\t\t * is marked with FIEMAP_EXTENT_LAST\n\t\t\t */\n\t\t\tif (!past_eof && logical + size >= isize)\n\t\t\t\tpast_eof = true;\n\t\t}\n\t\tcond_resched();\n\t\tif (fatal_signal_pending(current)) {\n\t\t\tret = -EINTR;\n\t\t\tbreak;\n\t\t}\n\n\t} while (1);\n\n\t/* If ret is 1 then we just hit the end of the extent array */\n\tif (ret == 1)\n\t\tret = 0;\n\n\treturn ret;\n}",
          "includes": [
            "#include <asm/ioctls.h>",
            "#include <linux/falloc.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/writeback.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/export.h>",
            "#include <linux/security.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>",
            "#include <linux/mm.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/ioctls.h>\n#include <linux/falloc.h>\n#include <linux/buffer_head.h>\n#include <linux/writeback.h>\n#include <linux/uaccess.h>\n#include <linux/export.h>\n#include <linux/security.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n#include <linux/mm.h>\n#include <linux/syscalls.h>\n\nint __generic_block_fiemap(struct inode *inode,\n\t\t\t   struct fiemap_extent_info *fieinfo, loff_t start,\n\t\t\t   loff_t len, get_block_t *get_block)\n{\n\tstruct buffer_head map_bh;\n\tsector_t start_blk, last_blk;\n\tloff_t isize = i_size_read(inode);\n\tu64 logical = 0, phys = 0, size = 0;\n\tu32 flags = FIEMAP_EXTENT_MERGED;\n\tbool past_eof = false, whole_file = false;\n\tint ret = 0;\n\n\tret = fiemap_check_flags(fieinfo, FIEMAP_FLAG_SYNC);\n\tif (ret)\n\t\treturn ret;\n\n\t/*\n\t * Either the i_mutex or other appropriate locking needs to be held\n\t * since we expect isize to not change at all through the duration of\n\t * this call.\n\t */\n\tif (len >= isize) {\n\t\twhole_file = true;\n\t\tlen = isize;\n\t}\n\n\t/*\n\t * Some filesystems can't deal with being asked to map less than\n\t * blocksize, so make sure our len is at least block length.\n\t */\n\tif (logical_to_blk(inode, len) == 0)\n\t\tlen = blk_to_logical(inode, 1);\n\n\tstart_blk = logical_to_blk(inode, start);\n\tlast_blk = logical_to_blk(inode, start + len - 1);\n\n\tdo {\n\t\t/*\n\t\t * we set b_size to the total size we want so it will map as\n\t\t * many contiguous blocks as possible at once\n\t\t */\n\t\tmemset(&map_bh, 0, sizeof(struct buffer_head));\n\t\tmap_bh.b_size = len;\n\n\t\tret = get_block(inode, start_blk, &map_bh, 0);\n\t\tif (ret)\n\t\t\tbreak;\n\n\t\t/* HOLE */\n\t\tif (!buffer_mapped(&map_bh)) {\n\t\t\tstart_blk++;\n\n\t\t\t/*\n\t\t\t * We want to handle the case where there is an\n\t\t\t * allocated block at the front of the file, and then\n\t\t\t * nothing but holes up to the end of the file properly,\n\t\t\t * to make sure that extent at the front gets properly\n\t\t\t * marked with FIEMAP_EXTENT_LAST\n\t\t\t */\n\t\t\tif (!past_eof &&\n\t\t\t    blk_to_logical(inode, start_blk) >= isize)\n\t\t\t\tpast_eof = 1;\n\n\t\t\t/*\n\t\t\t * First hole after going past the EOF, this is our\n\t\t\t * last extent\n\t\t\t */\n\t\t\tif (past_eof && size) {\n\t\t\t\tflags = FIEMAP_EXTENT_MERGED|FIEMAP_EXTENT_LAST;\n\t\t\t\tret = fiemap_fill_next_extent(fieinfo, logical,\n\t\t\t\t\t\t\t      phys, size,\n\t\t\t\t\t\t\t      flags);\n\t\t\t} else if (size) {\n\t\t\t\tret = fiemap_fill_next_extent(fieinfo, logical,\n\t\t\t\t\t\t\t      phys, size, flags);\n\t\t\t\tsize = 0;\n\t\t\t}\n\n\t\t\t/* if we have holes up to/past EOF then we're done */\n\t\t\tif (start_blk > last_blk || past_eof || ret)\n\t\t\t\tbreak;\n\t\t} else {\n\t\t\t/*\n\t\t\t * We have gone over the length of what we wanted to\n\t\t\t * map, and it wasn't the entire file, so add the extent\n\t\t\t * we got last time and exit.\n\t\t\t *\n\t\t\t * This is for the case where say we want to map all the\n\t\t\t * way up to the second to the last block in a file, but\n\t\t\t * the last block is a hole, making the second to last\n\t\t\t * block FIEMAP_EXTENT_LAST.  In this case we want to\n\t\t\t * see if there is a hole after the second to last block\n\t\t\t * so we can mark it properly.  If we found data after\n\t\t\t * we exceeded the length we were requesting, then we\n\t\t\t * are good to go, just add the extent to the fieinfo\n\t\t\t * and break\n\t\t\t */\n\t\t\tif (start_blk > last_blk && !whole_file) {\n\t\t\t\tret = fiemap_fill_next_extent(fieinfo, logical,\n\t\t\t\t\t\t\t      phys, size,\n\t\t\t\t\t\t\t      flags);\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * if size != 0 then we know we already have an extent\n\t\t\t * to add, so add it.\n\t\t\t */\n\t\t\tif (size) {\n\t\t\t\tret = fiemap_fill_next_extent(fieinfo, logical,\n\t\t\t\t\t\t\t      phys, size,\n\t\t\t\t\t\t\t      flags);\n\t\t\t\tif (ret)\n\t\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tlogical = blk_to_logical(inode, start_blk);\n\t\t\tphys = blk_to_logical(inode, map_bh.b_blocknr);\n\t\t\tsize = map_bh.b_size;\n\t\t\tflags = FIEMAP_EXTENT_MERGED;\n\n\t\t\tstart_blk += logical_to_blk(inode, size);\n\n\t\t\t/*\n\t\t\t * If we are past the EOF, then we need to make sure as\n\t\t\t * soon as we find a hole that the last extent we found\n\t\t\t * is marked with FIEMAP_EXTENT_LAST\n\t\t\t */\n\t\t\tif (!past_eof && logical + size >= isize)\n\t\t\t\tpast_eof = true;\n\t\t}\n\t\tcond_resched();\n\t\tif (fatal_signal_pending(current)) {\n\t\t\tret = -EINTR;\n\t\t\tbreak;\n\t\t}\n\n\t} while (1);\n\n\t/* If ret is 1 then we just hit the end of the extent array */\n\tif (ret == 1)\n\t\tret = 0;\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fiemap_fill_next_extent",
          "args": [
            "fieinfo",
            "start",
            "phys",
            "len",
            "flags"
          ],
          "line": 1907
        },
        "resolved": true,
        "details": {
          "function_name": "fiemap_fill_next_extent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ioctl.c",
          "lines": "85-121",
          "snippet": "int fiemap_fill_next_extent(struct fiemap_extent_info *fieinfo, u64 logical,\n\t\t\t    u64 phys, u64 len, u32 flags)\n{\n\tstruct fiemap_extent extent;\n\tstruct fiemap_extent __user *dest = fieinfo->fi_extents_start;\n\n\t/* only count the extents */\n\tif (fieinfo->fi_extents_max == 0) {\n\t\tfieinfo->fi_extents_mapped++;\n\t\treturn (flags & FIEMAP_EXTENT_LAST) ? 1 : 0;\n\t}\n\n\tif (fieinfo->fi_extents_mapped >= fieinfo->fi_extents_max)\n\t\treturn 1;\n\n\tif (flags & SET_UNKNOWN_FLAGS)\n\t\tflags |= FIEMAP_EXTENT_UNKNOWN;\n\tif (flags & SET_NO_UNMOUNTED_IO_FLAGS)\n\t\tflags |= FIEMAP_EXTENT_ENCODED;\n\tif (flags & SET_NOT_ALIGNED_FLAGS)\n\t\tflags |= FIEMAP_EXTENT_NOT_ALIGNED;\n\n\tmemset(&extent, 0, sizeof(extent));\n\textent.fe_logical = logical;\n\textent.fe_physical = phys;\n\textent.fe_length = len;\n\textent.fe_flags = flags;\n\n\tdest += fieinfo->fi_extents_mapped;\n\tif (copy_to_user(dest, &extent, sizeof(extent)))\n\t\treturn -EFAULT;\n\n\tfieinfo->fi_extents_mapped++;\n\tif (fieinfo->fi_extents_mapped == fieinfo->fi_extents_max)\n\t\treturn 1;\n\treturn (flags & FIEMAP_EXTENT_LAST) ? 1 : 0;\n}",
          "includes": [
            "#include <asm/ioctls.h>",
            "#include <linux/falloc.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/writeback.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/export.h>",
            "#include <linux/security.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>",
            "#include <linux/mm.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [
            "#define SET_NOT_ALIGNED_FLAGS\t(FIEMAP_EXTENT_DATA_TAIL|FIEMAP_EXTENT_DATA_INLINE)",
            "#define SET_NO_UNMOUNTED_IO_FLAGS\t(FIEMAP_EXTENT_DATA_ENCRYPTED)",
            "#define SET_UNKNOWN_FLAGS\t(FIEMAP_EXTENT_DELALLOC)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/ioctls.h>\n#include <linux/falloc.h>\n#include <linux/buffer_head.h>\n#include <linux/writeback.h>\n#include <linux/uaccess.h>\n#include <linux/export.h>\n#include <linux/security.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n#include <linux/mm.h>\n#include <linux/syscalls.h>\n\n#define SET_NOT_ALIGNED_FLAGS\t(FIEMAP_EXTENT_DATA_TAIL|FIEMAP_EXTENT_DATA_INLINE)\n#define SET_NO_UNMOUNTED_IO_FLAGS\t(FIEMAP_EXTENT_DATA_ENCRYPTED)\n#define SET_UNKNOWN_FLAGS\t(FIEMAP_EXTENT_DELALLOC)\n\nint fiemap_fill_next_extent(struct fiemap_extent_info *fieinfo, u64 logical,\n\t\t\t    u64 phys, u64 len, u32 flags)\n{\n\tstruct fiemap_extent extent;\n\tstruct fiemap_extent __user *dest = fieinfo->fi_extents_start;\n\n\t/* only count the extents */\n\tif (fieinfo->fi_extents_max == 0) {\n\t\tfieinfo->fi_extents_mapped++;\n\t\treturn (flags & FIEMAP_EXTENT_LAST) ? 1 : 0;\n\t}\n\n\tif (fieinfo->fi_extents_mapped >= fieinfo->fi_extents_max)\n\t\treturn 1;\n\n\tif (flags & SET_UNKNOWN_FLAGS)\n\t\tflags |= FIEMAP_EXTENT_UNKNOWN;\n\tif (flags & SET_NO_UNMOUNTED_IO_FLAGS)\n\t\tflags |= FIEMAP_EXTENT_ENCODED;\n\tif (flags & SET_NOT_ALIGNED_FLAGS)\n\t\tflags |= FIEMAP_EXTENT_NOT_ALIGNED;\n\n\tmemset(&extent, 0, sizeof(extent));\n\textent.fe_logical = logical;\n\textent.fe_physical = phys;\n\textent.fe_length = len;\n\textent.fe_flags = flags;\n\n\tdest += fieinfo->fi_extents_mapped;\n\tif (copy_to_user(dest, &extent, sizeof(extent)))\n\t\treturn -EFAULT;\n\n\tfieinfo->fi_extents_mapped++;\n\tif (fieinfo->fi_extents_mapped == fieinfo->fi_extents_max)\n\t\treturn 1;\n\treturn (flags & FIEMAP_EXTENT_LAST) ? 1 : 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "i_size_read",
          "args": [
            "inode"
          ],
          "line": 1899
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gfs2_is_stuffed",
          "args": [
            "ip"
          ],
          "line": 1897
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_is_stuffed",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/inode.h",
          "lines": "23-26",
          "snippet": "static inline int gfs2_is_stuffed(const struct gfs2_inode *ip)\n{\n\treturn !ip->i_height;\n}",
          "includes": [
            "#include \"util.h\"",
            "#include <linux/mm.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include <linux/mm.h>\n#include <linux/buffer_head.h>\n#include <linux/fs.h>\n\nstatic inline int gfs2_is_stuffed(const struct gfs2_inode *ip)\n{\n\treturn !ip->i_height;\n}"
        }
      },
      {
        "call_info": {
          "callee": "gfs2_glock_nq_init",
          "args": [
            "ip->i_gl",
            "LM_ST_SHARED",
            "0",
            "&gh"
          ],
          "line": 1893
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_glock_nq_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/glock.h",
          "lines": "204-230",
          "snippet": "extern __printf(2, 3)\nvoid gfs2_print_dbg(struct seq_file *seq, const char *fmt, ...);\n\n/**\n * gfs2_glock_nq_init - initialize a holder and enqueue it on a glock\n * @gl: the glock\n * @state: the state we're requesting\n * @flags: the modifier flags\n * @gh: the holder structure\n *\n * Returns: 0, GLR_*, or errno\n */\n\nstatic inline int gfs2_glock_nq_init(struct gfs2_glock *gl,\n\t\t\t\t     unsigned int state, int flags,\n\t\t\t\t     struct gfs2_holder *gh)\n{\n\tint error;\n\n\tgfs2_holder_init(gl, state, flags, gh);\n\n\terror = gfs2_glock_nq(gh);\n\tif (error)\n\t\tgfs2_holder_uninit(gh);\n\n\treturn error;\n}",
          "includes": [
            "#include \"incore.h\"",
            "#include <linux/parser.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"incore.h\"\n#include <linux/parser.h>\n#include <linux/sched.h>\n\nextern __printf(2, 3)\nvoid gfs2_print_dbg(struct seq_file *seq, const char *fmt, ...);\n\n/**\n * gfs2_glock_nq_init - initialize a holder and enqueue it on a glock\n * @gl: the glock\n * @state: the state we're requesting\n * @flags: the modifier flags\n * @gh: the holder structure\n *\n * Returns: 0, GLR_*, or errno\n */\n\nstatic inline int gfs2_glock_nq_init(struct gfs2_glock *gl,\n\t\t\t\t     unsigned int state, int flags,\n\t\t\t\t     struct gfs2_holder *gh)\n{\n\tint error;\n\n\tgfs2_holder_init(gl, state, flags, gh);\n\n\terror = gfs2_glock_nq(gh);\n\tif (error)\n\t\tgfs2_holder_uninit(gh);\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&inode->i_mutex"
          ],
          "line": 1891
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fiemap_check_flags",
          "args": [
            "fieinfo",
            "FIEMAP_FLAG_SYNC"
          ],
          "line": 1887
        },
        "resolved": true,
        "details": {
          "function_name": "fiemap_check_flags",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ioctl.c",
          "lines": "138-148",
          "snippet": "int fiemap_check_flags(struct fiemap_extent_info *fieinfo, u32 fs_flags)\n{\n\tu32 incompat_flags;\n\n\tincompat_flags = fieinfo->fi_flags & ~(FIEMAP_FLAGS_COMPAT & fs_flags);\n\tif (incompat_flags) {\n\t\tfieinfo->fi_flags = incompat_flags;\n\t\treturn -EBADR;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include <asm/ioctls.h>",
            "#include <linux/falloc.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/writeback.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/export.h>",
            "#include <linux/security.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>",
            "#include <linux/mm.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/ioctls.h>\n#include <linux/falloc.h>\n#include <linux/buffer_head.h>\n#include <linux/writeback.h>\n#include <linux/uaccess.h>\n#include <linux/export.h>\n#include <linux/security.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n#include <linux/mm.h>\n#include <linux/syscalls.h>\n\nint fiemap_check_flags(struct fiemap_extent_info *fieinfo, u32 fs_flags)\n{\n\tu32 incompat_flags;\n\n\tincompat_flags = fieinfo->fi_flags & ~(FIEMAP_FLAGS_COMPAT & fs_flags);\n\tif (incompat_flags) {\n\t\tfieinfo->fi_flags = incompat_flags;\n\t\treturn -EBADR;\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "GFS2_I",
          "args": [
            "inode"
          ],
          "line": 1883
        },
        "resolved": true,
        "details": {
          "function_name": "GFS2_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/incore.h",
          "lines": "408-411",
          "snippet": "static inline struct gfs2_inode *GFS2_I(struct inode *inode)\n{\n\treturn container_of(inode, struct gfs2_inode, i_inode);\n}",
          "includes": [
            "#include <linux/lockref.h>",
            "#include <linux/percpu.h>",
            "#include <linux/ktime.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/completion.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/dlm.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/kobject.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/lockref.h>\n#include <linux/percpu.h>\n#include <linux/ktime.h>\n#include <linux/rbtree.h>\n#include <linux/completion.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/buffer_head.h>\n#include <linux/dlm.h>\n#include <linux/workqueue.h>\n#include <linux/kobject.h>\n#include <linux/fs.h>\n\nstatic inline struct gfs2_inode *GFS2_I(struct inode *inode)\n{\n\treturn container_of(inode, struct gfs2_inode, i_inode);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"glops.h\"\n#include \"super.h\"\n#include \"util.h\"\n#include \"trans.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"xattr.h\"\n#include \"dir.h\"\n#include \"bmap.h\"\n#include \"acl.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <asm/uaccess.h>\n#include <linux/security.h>\n#include <linux/fiemap.h>\n#include <linux/crc32.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/posix_acl.h>\n#include <linux/xattr.h>\n#include <linux/mm.h>\n#include <linux/namei.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nstatic int gfs2_fiemap(struct inode *inode, struct fiemap_extent_info *fieinfo,\n\t\t       u64 start, u64 len)\n{\n\tstruct gfs2_inode *ip = GFS2_I(inode);\n\tstruct gfs2_holder gh;\n\tint ret;\n\n\tret = fiemap_check_flags(fieinfo, FIEMAP_FLAG_SYNC);\n\tif (ret)\n\t\treturn ret;\n\n\tmutex_lock(&inode->i_mutex);\n\n\tret = gfs2_glock_nq_init(ip->i_gl, LM_ST_SHARED, 0, &gh);\n\tif (ret)\n\t\tgoto out;\n\n\tif (gfs2_is_stuffed(ip)) {\n\t\tu64 phys = ip->i_no_addr << inode->i_blkbits;\n\t\tu64 size = i_size_read(inode);\n\t\tu32 flags = FIEMAP_EXTENT_LAST|FIEMAP_EXTENT_NOT_ALIGNED|\n\t\t\t    FIEMAP_EXTENT_DATA_INLINE;\n\t\tphys += sizeof(struct gfs2_dinode);\n\t\tphys += start;\n\t\tif (start + len > size)\n\t\t\tlen = size - start;\n\t\tif (start < size)\n\t\t\tret = fiemap_fill_next_extent(fieinfo, start, phys,\n\t\t\t\t\t\t      len, flags);\n\t\tif (ret == 1)\n\t\t\tret = 0;\n\t} else {\n\t\tret = __generic_block_fiemap(inode, fieinfo, start, len,\n\t\t\t\t\t     gfs2_block_map);\n\t}\n\n\tgfs2_glock_dq_uninit(&gh);\nout:\n\tmutex_unlock(&inode->i_mutex);\n\treturn ret;\n}"
  },
  {
    "function_name": "gfs2_removexattr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/inode.c",
    "lines": "1861-1878",
    "snippet": "static int gfs2_removexattr(struct dentry *dentry, const char *name)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tstruct gfs2_inode *ip = GFS2_I(inode);\n\tstruct gfs2_holder gh;\n\tint ret;\n\n\tgfs2_holder_init(ip->i_gl, LM_ST_EXCLUSIVE, 0, &gh);\n\tret = gfs2_glock_nq(&gh);\n\tif (ret == 0) {\n\t\tret = gfs2_rs_alloc(ip);\n\t\tif (ret == 0)\n\t\t\tret = generic_removexattr(dentry, name);\n\t\tgfs2_glock_dq(&gh);\n\t}\n\tgfs2_holder_uninit(&gh);\n\treturn ret;\n}",
    "includes": [
      "#include \"glops.h\"",
      "#include \"super.h\"",
      "#include \"util.h\"",
      "#include \"trans.h\"",
      "#include \"rgrp.h\"",
      "#include \"quota.h\"",
      "#include \"meta_io.h\"",
      "#include \"inode.h\"",
      "#include \"glock.h\"",
      "#include \"xattr.h\"",
      "#include \"dir.h\"",
      "#include \"bmap.h\"",
      "#include \"acl.h\"",
      "#include \"incore.h\"",
      "#include \"gfs2.h\"",
      "#include <asm/uaccess.h>",
      "#include <linux/security.h>",
      "#include <linux/fiemap.h>",
      "#include <linux/crc32.h>",
      "#include <linux/gfs2_ondisk.h>",
      "#include <linux/posix_acl.h>",
      "#include <linux/xattr.h>",
      "#include <linux/mm.h>",
      "#include <linux/namei.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/completion.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "gfs2_holder_uninit",
          "args": [
            "&gh"
          ],
          "line": 1876
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_holder_uninit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/glock.c",
          "lines": "841-847",
          "snippet": "void gfs2_holder_uninit(struct gfs2_holder *gh)\n{\n\tput_pid(gh->gh_owner_pid);\n\tgfs2_glock_put(gh->gh_gl);\n\tgh->gh_gl = NULL;\n\tgh->gh_ip = 0;\n}",
          "includes": [
            "#include \"trace_gfs2.h\"",
            "#include \"bmap.h\"",
            "#include \"util.h\"",
            "#include \"super.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"lops.h\"",
            "#include \"inode.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/lockref.h>",
            "#include <linux/list_sort.h>",
            "#include <linux/percpu.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/seq_file.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/module.h>",
            "#include <linux/wait.h>",
            "#include <linux/list.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/jhash.h>",
            "#include <linux/sort.h>",
            "#include <linux/delay.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"bmap.h\"\n#include \"util.h\"\n#include \"super.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"lops.h\"\n#include \"inode.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/lockref.h>\n#include <linux/list_sort.h>\n#include <linux/percpu.h>\n#include <linux/bit_spinlock.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/jiffies.h>\n#include <linux/workqueue.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <asm/uaccess.h>\n#include <linux/module.h>\n#include <linux/wait.h>\n#include <linux/list.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/kallsyms.h>\n#include <linux/jhash.h>\n#include <linux/sort.h>\n#include <linux/delay.h>\n#include <linux/buffer_head.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nvoid gfs2_holder_uninit(struct gfs2_holder *gh)\n{\n\tput_pid(gh->gh_owner_pid);\n\tgfs2_glock_put(gh->gh_gl);\n\tgh->gh_gl = NULL;\n\tgh->gh_ip = 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "gfs2_glock_dq",
          "args": [
            "&gh"
          ],
          "line": 1874
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_glock_dq_uninit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/glock.c",
          "lines": "1110-1114",
          "snippet": "void gfs2_glock_dq_uninit(struct gfs2_holder *gh)\n{\n\tgfs2_glock_dq(gh);\n\tgfs2_holder_uninit(gh);\n}",
          "includes": [
            "#include \"trace_gfs2.h\"",
            "#include \"bmap.h\"",
            "#include \"util.h\"",
            "#include \"super.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"lops.h\"",
            "#include \"inode.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/lockref.h>",
            "#include <linux/list_sort.h>",
            "#include <linux/percpu.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/seq_file.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/module.h>",
            "#include <linux/wait.h>",
            "#include <linux/list.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/jhash.h>",
            "#include <linux/sort.h>",
            "#include <linux/delay.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"bmap.h\"\n#include \"util.h\"\n#include \"super.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"lops.h\"\n#include \"inode.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/lockref.h>\n#include <linux/list_sort.h>\n#include <linux/percpu.h>\n#include <linux/bit_spinlock.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/jiffies.h>\n#include <linux/workqueue.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <asm/uaccess.h>\n#include <linux/module.h>\n#include <linux/wait.h>\n#include <linux/list.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/kallsyms.h>\n#include <linux/jhash.h>\n#include <linux/sort.h>\n#include <linux/delay.h>\n#include <linux/buffer_head.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nvoid gfs2_glock_dq_uninit(struct gfs2_holder *gh)\n{\n\tgfs2_glock_dq(gh);\n\tgfs2_holder_uninit(gh);\n}"
        }
      },
      {
        "call_info": {
          "callee": "generic_removexattr",
          "args": [
            "dentry",
            "name"
          ],
          "line": 1873
        },
        "resolved": true,
        "details": {
          "function_name": "generic_removexattr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xattr.c",
          "lines": "777-787",
          "snippet": "int\ngeneric_removexattr(struct dentry *dentry, const char *name)\n{\n\tconst struct xattr_handler *handler;\n\n\thandler = xattr_resolve_name(dentry->d_sb->s_xattr, &name);\n\tif (!handler)\n\t\treturn -EOPNOTSUPP;\n\treturn handler->set(dentry, name, NULL, 0,\n\t\t\t    XATTR_REPLACE, handler->flags);\n}",
          "includes": [
            "#include <asm/uaccess.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/audit.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/evm.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/xattr.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/uaccess.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/vmalloc.h>\n#include <linux/audit.h>\n#include <linux/fsnotify.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n#include <linux/evm.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/xattr.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nint\ngeneric_removexattr(struct dentry *dentry, const char *name)\n{\n\tconst struct xattr_handler *handler;\n\n\thandler = xattr_resolve_name(dentry->d_sb->s_xattr, &name);\n\tif (!handler)\n\t\treturn -EOPNOTSUPP;\n\treturn handler->set(dentry, name, NULL, 0,\n\t\t\t    XATTR_REPLACE, handler->flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "gfs2_rs_alloc",
          "args": [
            "ip"
          ],
          "line": 1871
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_rs_alloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/rgrp.c",
          "lines": "602-620",
          "snippet": "int gfs2_rs_alloc(struct gfs2_inode *ip)\n{\n\tint error = 0;\n\n\tdown_write(&ip->i_rw_mutex);\n\tif (ip->i_res)\n\t\tgoto out;\n\n\tip->i_res = kmem_cache_zalloc(gfs2_rsrv_cachep, GFP_NOFS);\n\tif (!ip->i_res) {\n\t\terror = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tRB_CLEAR_NODE(&ip->i_res->rs_node);\nout:\n\tup_write(&ip->i_rw_mutex);\n\treturn error;\n}",
          "includes": [
            "#include \"trace_gfs2.h\"",
            "#include \"inode.h\"",
            "#include \"log.h\"",
            "#include \"util.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"lops.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/random.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/fs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"inode.h\"\n#include \"log.h\"\n#include \"util.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"lops.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/random.h>\n#include <linux/rbtree.h>\n#include <linux/blkdev.h>\n#include <linux/prefetch.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/fs.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nint gfs2_rs_alloc(struct gfs2_inode *ip)\n{\n\tint error = 0;\n\n\tdown_write(&ip->i_rw_mutex);\n\tif (ip->i_res)\n\t\tgoto out;\n\n\tip->i_res = kmem_cache_zalloc(gfs2_rsrv_cachep, GFP_NOFS);\n\tif (!ip->i_res) {\n\t\terror = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tRB_CLEAR_NODE(&ip->i_res->rs_node);\nout:\n\tup_write(&ip->i_rw_mutex);\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "gfs2_glock_nq",
          "args": [
            "&gh"
          ],
          "line": 1869
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_glock_nq",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/glock.c",
          "lines": "1006-1034",
          "snippet": "int gfs2_glock_nq(struct gfs2_holder *gh)\n{\n\tstruct gfs2_glock *gl = gh->gh_gl;\n\tstruct gfs2_sbd *sdp = gl->gl_sbd;\n\tint error = 0;\n\n\tif (unlikely(test_bit(SDF_SHUTDOWN, &sdp->sd_flags)))\n\t\treturn -EIO;\n\n\tif (test_bit(GLF_LRU, &gl->gl_flags))\n\t\tgfs2_glock_remove_from_lru(gl);\n\n\tspin_lock(&gl->gl_spin);\n\tadd_to_queue(gh);\n\tif (unlikely((LM_FLAG_NOEXP & gh->gh_flags) &&\n\t\t     test_and_clear_bit(GLF_FROZEN, &gl->gl_flags))) {\n\t\tset_bit(GLF_REPLY_PENDING, &gl->gl_flags);\n\t\tgl->gl_lockref.count++;\n\t\tif (queue_delayed_work(glock_workqueue, &gl->gl_work, 0) == 0)\n\t\t\tgl->gl_lockref.count--;\n\t}\n\trun_queue(gl, 1);\n\tspin_unlock(&gl->gl_spin);\n\n\tif (!(gh->gh_flags & GL_ASYNC))\n\t\terror = gfs2_glock_wait(gh);\n\n\treturn error;\n}",
          "includes": [
            "#include \"trace_gfs2.h\"",
            "#include \"bmap.h\"",
            "#include \"util.h\"",
            "#include \"super.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"lops.h\"",
            "#include \"inode.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/lockref.h>",
            "#include <linux/list_sort.h>",
            "#include <linux/percpu.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/seq_file.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/module.h>",
            "#include <linux/wait.h>",
            "#include <linux/list.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/jhash.h>",
            "#include <linux/sort.h>",
            "#include <linux/delay.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct workqueue_struct *glock_workqueue;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"bmap.h\"\n#include \"util.h\"\n#include \"super.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"lops.h\"\n#include \"inode.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/lockref.h>\n#include <linux/list_sort.h>\n#include <linux/percpu.h>\n#include <linux/bit_spinlock.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/jiffies.h>\n#include <linux/workqueue.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <asm/uaccess.h>\n#include <linux/module.h>\n#include <linux/wait.h>\n#include <linux/list.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/kallsyms.h>\n#include <linux/jhash.h>\n#include <linux/sort.h>\n#include <linux/delay.h>\n#include <linux/buffer_head.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic struct workqueue_struct *glock_workqueue;\n\nint gfs2_glock_nq(struct gfs2_holder *gh)\n{\n\tstruct gfs2_glock *gl = gh->gh_gl;\n\tstruct gfs2_sbd *sdp = gl->gl_sbd;\n\tint error = 0;\n\n\tif (unlikely(test_bit(SDF_SHUTDOWN, &sdp->sd_flags)))\n\t\treturn -EIO;\n\n\tif (test_bit(GLF_LRU, &gl->gl_flags))\n\t\tgfs2_glock_remove_from_lru(gl);\n\n\tspin_lock(&gl->gl_spin);\n\tadd_to_queue(gh);\n\tif (unlikely((LM_FLAG_NOEXP & gh->gh_flags) &&\n\t\t     test_and_clear_bit(GLF_FROZEN, &gl->gl_flags))) {\n\t\tset_bit(GLF_REPLY_PENDING, &gl->gl_flags);\n\t\tgl->gl_lockref.count++;\n\t\tif (queue_delayed_work(glock_workqueue, &gl->gl_work, 0) == 0)\n\t\t\tgl->gl_lockref.count--;\n\t}\n\trun_queue(gl, 1);\n\tspin_unlock(&gl->gl_spin);\n\n\tif (!(gh->gh_flags & GL_ASYNC))\n\t\terror = gfs2_glock_wait(gh);\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "gfs2_holder_init",
          "args": [
            "ip->i_gl",
            "LM_ST_EXCLUSIVE",
            "0",
            "&gh"
          ],
          "line": 1868
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_holder_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/glock.c",
          "lines": "801-813",
          "snippet": "void gfs2_holder_init(struct gfs2_glock *gl, unsigned int state, unsigned flags,\n\t\t      struct gfs2_holder *gh)\n{\n\tINIT_LIST_HEAD(&gh->gh_list);\n\tgh->gh_gl = gl;\n\tgh->gh_ip = _RET_IP_;\n\tgh->gh_owner_pid = get_pid(task_pid(current));\n\tgh->gh_state = state;\n\tgh->gh_flags = flags;\n\tgh->gh_error = 0;\n\tgh->gh_iflags = 0;\n\tgfs2_glock_hold(gl);\n}",
          "includes": [
            "#include \"trace_gfs2.h\"",
            "#include \"bmap.h\"",
            "#include \"util.h\"",
            "#include \"super.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"lops.h\"",
            "#include \"inode.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/lockref.h>",
            "#include <linux/list_sort.h>",
            "#include <linux/percpu.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/seq_file.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/module.h>",
            "#include <linux/wait.h>",
            "#include <linux/list.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/jhash.h>",
            "#include <linux/sort.h>",
            "#include <linux/delay.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"bmap.h\"\n#include \"util.h\"\n#include \"super.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"lops.h\"\n#include \"inode.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/lockref.h>\n#include <linux/list_sort.h>\n#include <linux/percpu.h>\n#include <linux/bit_spinlock.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/jiffies.h>\n#include <linux/workqueue.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <asm/uaccess.h>\n#include <linux/module.h>\n#include <linux/wait.h>\n#include <linux/list.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/kallsyms.h>\n#include <linux/jhash.h>\n#include <linux/sort.h>\n#include <linux/delay.h>\n#include <linux/buffer_head.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nvoid gfs2_holder_init(struct gfs2_glock *gl, unsigned int state, unsigned flags,\n\t\t      struct gfs2_holder *gh)\n{\n\tINIT_LIST_HEAD(&gh->gh_list);\n\tgh->gh_gl = gl;\n\tgh->gh_ip = _RET_IP_;\n\tgh->gh_owner_pid = get_pid(task_pid(current));\n\tgh->gh_state = state;\n\tgh->gh_flags = flags;\n\tgh->gh_error = 0;\n\tgh->gh_iflags = 0;\n\tgfs2_glock_hold(gl);\n}"
        }
      },
      {
        "call_info": {
          "callee": "GFS2_I",
          "args": [
            "inode"
          ],
          "line": 1864
        },
        "resolved": true,
        "details": {
          "function_name": "GFS2_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/incore.h",
          "lines": "408-411",
          "snippet": "static inline struct gfs2_inode *GFS2_I(struct inode *inode)\n{\n\treturn container_of(inode, struct gfs2_inode, i_inode);\n}",
          "includes": [
            "#include <linux/lockref.h>",
            "#include <linux/percpu.h>",
            "#include <linux/ktime.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/completion.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/dlm.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/kobject.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/lockref.h>\n#include <linux/percpu.h>\n#include <linux/ktime.h>\n#include <linux/rbtree.h>\n#include <linux/completion.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/buffer_head.h>\n#include <linux/dlm.h>\n#include <linux/workqueue.h>\n#include <linux/kobject.h>\n#include <linux/fs.h>\n\nstatic inline struct gfs2_inode *GFS2_I(struct inode *inode)\n{\n\treturn container_of(inode, struct gfs2_inode, i_inode);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"glops.h\"\n#include \"super.h\"\n#include \"util.h\"\n#include \"trans.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"xattr.h\"\n#include \"dir.h\"\n#include \"bmap.h\"\n#include \"acl.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <asm/uaccess.h>\n#include <linux/security.h>\n#include <linux/fiemap.h>\n#include <linux/crc32.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/posix_acl.h>\n#include <linux/xattr.h>\n#include <linux/mm.h>\n#include <linux/namei.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nstatic int gfs2_removexattr(struct dentry *dentry, const char *name)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tstruct gfs2_inode *ip = GFS2_I(inode);\n\tstruct gfs2_holder gh;\n\tint ret;\n\n\tgfs2_holder_init(ip->i_gl, LM_ST_EXCLUSIVE, 0, &gh);\n\tret = gfs2_glock_nq(&gh);\n\tif (ret == 0) {\n\t\tret = gfs2_rs_alloc(ip);\n\t\tif (ret == 0)\n\t\t\tret = generic_removexattr(dentry, name);\n\t\tgfs2_glock_dq(&gh);\n\t}\n\tgfs2_holder_uninit(&gh);\n\treturn ret;\n}"
  },
  {
    "function_name": "gfs2_getxattr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/inode.c",
    "lines": "1839-1859",
    "snippet": "static ssize_t gfs2_getxattr(struct dentry *dentry, const char *name,\n\t\t\t     void *data, size_t size)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tstruct gfs2_inode *ip = GFS2_I(inode);\n\tstruct gfs2_holder gh;\n\tint ret;\n\n\t/* For selinux during lookup */\n\tif (gfs2_glock_is_locked_by_me(ip->i_gl))\n\t\treturn generic_getxattr(dentry, name, data, size);\n\n\tgfs2_holder_init(ip->i_gl, LM_ST_SHARED, LM_FLAG_ANY, &gh);\n\tret = gfs2_glock_nq(&gh);\n\tif (ret == 0) {\n\t\tret = generic_getxattr(dentry, name, data, size);\n\t\tgfs2_glock_dq(&gh);\n\t}\n\tgfs2_holder_uninit(&gh);\n\treturn ret;\n}",
    "includes": [
      "#include \"glops.h\"",
      "#include \"super.h\"",
      "#include \"util.h\"",
      "#include \"trans.h\"",
      "#include \"rgrp.h\"",
      "#include \"quota.h\"",
      "#include \"meta_io.h\"",
      "#include \"inode.h\"",
      "#include \"glock.h\"",
      "#include \"xattr.h\"",
      "#include \"dir.h\"",
      "#include \"bmap.h\"",
      "#include \"acl.h\"",
      "#include \"incore.h\"",
      "#include \"gfs2.h\"",
      "#include <asm/uaccess.h>",
      "#include <linux/security.h>",
      "#include <linux/fiemap.h>",
      "#include <linux/crc32.h>",
      "#include <linux/gfs2_ondisk.h>",
      "#include <linux/posix_acl.h>",
      "#include <linux/xattr.h>",
      "#include <linux/mm.h>",
      "#include <linux/namei.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/completion.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "gfs2_holder_uninit",
          "args": [
            "&gh"
          ],
          "line": 1857
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_holder_uninit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/glock.c",
          "lines": "841-847",
          "snippet": "void gfs2_holder_uninit(struct gfs2_holder *gh)\n{\n\tput_pid(gh->gh_owner_pid);\n\tgfs2_glock_put(gh->gh_gl);\n\tgh->gh_gl = NULL;\n\tgh->gh_ip = 0;\n}",
          "includes": [
            "#include \"trace_gfs2.h\"",
            "#include \"bmap.h\"",
            "#include \"util.h\"",
            "#include \"super.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"lops.h\"",
            "#include \"inode.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/lockref.h>",
            "#include <linux/list_sort.h>",
            "#include <linux/percpu.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/seq_file.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/module.h>",
            "#include <linux/wait.h>",
            "#include <linux/list.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/jhash.h>",
            "#include <linux/sort.h>",
            "#include <linux/delay.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"bmap.h\"\n#include \"util.h\"\n#include \"super.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"lops.h\"\n#include \"inode.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/lockref.h>\n#include <linux/list_sort.h>\n#include <linux/percpu.h>\n#include <linux/bit_spinlock.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/jiffies.h>\n#include <linux/workqueue.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <asm/uaccess.h>\n#include <linux/module.h>\n#include <linux/wait.h>\n#include <linux/list.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/kallsyms.h>\n#include <linux/jhash.h>\n#include <linux/sort.h>\n#include <linux/delay.h>\n#include <linux/buffer_head.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nvoid gfs2_holder_uninit(struct gfs2_holder *gh)\n{\n\tput_pid(gh->gh_owner_pid);\n\tgfs2_glock_put(gh->gh_gl);\n\tgh->gh_gl = NULL;\n\tgh->gh_ip = 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "gfs2_glock_dq",
          "args": [
            "&gh"
          ],
          "line": 1855
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_glock_dq_uninit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/glock.c",
          "lines": "1110-1114",
          "snippet": "void gfs2_glock_dq_uninit(struct gfs2_holder *gh)\n{\n\tgfs2_glock_dq(gh);\n\tgfs2_holder_uninit(gh);\n}",
          "includes": [
            "#include \"trace_gfs2.h\"",
            "#include \"bmap.h\"",
            "#include \"util.h\"",
            "#include \"super.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"lops.h\"",
            "#include \"inode.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/lockref.h>",
            "#include <linux/list_sort.h>",
            "#include <linux/percpu.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/seq_file.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/module.h>",
            "#include <linux/wait.h>",
            "#include <linux/list.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/jhash.h>",
            "#include <linux/sort.h>",
            "#include <linux/delay.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"bmap.h\"\n#include \"util.h\"\n#include \"super.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"lops.h\"\n#include \"inode.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/lockref.h>\n#include <linux/list_sort.h>\n#include <linux/percpu.h>\n#include <linux/bit_spinlock.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/jiffies.h>\n#include <linux/workqueue.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <asm/uaccess.h>\n#include <linux/module.h>\n#include <linux/wait.h>\n#include <linux/list.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/kallsyms.h>\n#include <linux/jhash.h>\n#include <linux/sort.h>\n#include <linux/delay.h>\n#include <linux/buffer_head.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nvoid gfs2_glock_dq_uninit(struct gfs2_holder *gh)\n{\n\tgfs2_glock_dq(gh);\n\tgfs2_holder_uninit(gh);\n}"
        }
      },
      {
        "call_info": {
          "callee": "generic_getxattr",
          "args": [
            "dentry",
            "name",
            "data",
            "size"
          ],
          "line": 1854
        },
        "resolved": true,
        "details": {
          "function_name": "generic_getxattr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xattr.c",
          "lines": "715-724",
          "snippet": "ssize_t\ngeneric_getxattr(struct dentry *dentry, const char *name, void *buffer, size_t size)\n{\n\tconst struct xattr_handler *handler;\n\n\thandler = xattr_resolve_name(dentry->d_sb->s_xattr, &name);\n\tif (!handler)\n\t\treturn -EOPNOTSUPP;\n\treturn handler->get(dentry, name, buffer, size, handler->flags);\n}",
          "includes": [
            "#include <asm/uaccess.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/audit.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/evm.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/xattr.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/uaccess.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/vmalloc.h>\n#include <linux/audit.h>\n#include <linux/fsnotify.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n#include <linux/evm.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/xattr.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nssize_t\ngeneric_getxattr(struct dentry *dentry, const char *name, void *buffer, size_t size)\n{\n\tconst struct xattr_handler *handler;\n\n\thandler = xattr_resolve_name(dentry->d_sb->s_xattr, &name);\n\tif (!handler)\n\t\treturn -EOPNOTSUPP;\n\treturn handler->get(dentry, name, buffer, size, handler->flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "gfs2_glock_nq",
          "args": [
            "&gh"
          ],
          "line": 1852
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_glock_nq",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/glock.c",
          "lines": "1006-1034",
          "snippet": "int gfs2_glock_nq(struct gfs2_holder *gh)\n{\n\tstruct gfs2_glock *gl = gh->gh_gl;\n\tstruct gfs2_sbd *sdp = gl->gl_sbd;\n\tint error = 0;\n\n\tif (unlikely(test_bit(SDF_SHUTDOWN, &sdp->sd_flags)))\n\t\treturn -EIO;\n\n\tif (test_bit(GLF_LRU, &gl->gl_flags))\n\t\tgfs2_glock_remove_from_lru(gl);\n\n\tspin_lock(&gl->gl_spin);\n\tadd_to_queue(gh);\n\tif (unlikely((LM_FLAG_NOEXP & gh->gh_flags) &&\n\t\t     test_and_clear_bit(GLF_FROZEN, &gl->gl_flags))) {\n\t\tset_bit(GLF_REPLY_PENDING, &gl->gl_flags);\n\t\tgl->gl_lockref.count++;\n\t\tif (queue_delayed_work(glock_workqueue, &gl->gl_work, 0) == 0)\n\t\t\tgl->gl_lockref.count--;\n\t}\n\trun_queue(gl, 1);\n\tspin_unlock(&gl->gl_spin);\n\n\tif (!(gh->gh_flags & GL_ASYNC))\n\t\terror = gfs2_glock_wait(gh);\n\n\treturn error;\n}",
          "includes": [
            "#include \"trace_gfs2.h\"",
            "#include \"bmap.h\"",
            "#include \"util.h\"",
            "#include \"super.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"lops.h\"",
            "#include \"inode.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/lockref.h>",
            "#include <linux/list_sort.h>",
            "#include <linux/percpu.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/seq_file.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/module.h>",
            "#include <linux/wait.h>",
            "#include <linux/list.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/jhash.h>",
            "#include <linux/sort.h>",
            "#include <linux/delay.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct workqueue_struct *glock_workqueue;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"bmap.h\"\n#include \"util.h\"\n#include \"super.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"lops.h\"\n#include \"inode.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/lockref.h>\n#include <linux/list_sort.h>\n#include <linux/percpu.h>\n#include <linux/bit_spinlock.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/jiffies.h>\n#include <linux/workqueue.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <asm/uaccess.h>\n#include <linux/module.h>\n#include <linux/wait.h>\n#include <linux/list.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/kallsyms.h>\n#include <linux/jhash.h>\n#include <linux/sort.h>\n#include <linux/delay.h>\n#include <linux/buffer_head.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic struct workqueue_struct *glock_workqueue;\n\nint gfs2_glock_nq(struct gfs2_holder *gh)\n{\n\tstruct gfs2_glock *gl = gh->gh_gl;\n\tstruct gfs2_sbd *sdp = gl->gl_sbd;\n\tint error = 0;\n\n\tif (unlikely(test_bit(SDF_SHUTDOWN, &sdp->sd_flags)))\n\t\treturn -EIO;\n\n\tif (test_bit(GLF_LRU, &gl->gl_flags))\n\t\tgfs2_glock_remove_from_lru(gl);\n\n\tspin_lock(&gl->gl_spin);\n\tadd_to_queue(gh);\n\tif (unlikely((LM_FLAG_NOEXP & gh->gh_flags) &&\n\t\t     test_and_clear_bit(GLF_FROZEN, &gl->gl_flags))) {\n\t\tset_bit(GLF_REPLY_PENDING, &gl->gl_flags);\n\t\tgl->gl_lockref.count++;\n\t\tif (queue_delayed_work(glock_workqueue, &gl->gl_work, 0) == 0)\n\t\t\tgl->gl_lockref.count--;\n\t}\n\trun_queue(gl, 1);\n\tspin_unlock(&gl->gl_spin);\n\n\tif (!(gh->gh_flags & GL_ASYNC))\n\t\terror = gfs2_glock_wait(gh);\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "gfs2_holder_init",
          "args": [
            "ip->i_gl",
            "LM_ST_SHARED",
            "LM_FLAG_ANY",
            "&gh"
          ],
          "line": 1851
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_holder_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/glock.c",
          "lines": "801-813",
          "snippet": "void gfs2_holder_init(struct gfs2_glock *gl, unsigned int state, unsigned flags,\n\t\t      struct gfs2_holder *gh)\n{\n\tINIT_LIST_HEAD(&gh->gh_list);\n\tgh->gh_gl = gl;\n\tgh->gh_ip = _RET_IP_;\n\tgh->gh_owner_pid = get_pid(task_pid(current));\n\tgh->gh_state = state;\n\tgh->gh_flags = flags;\n\tgh->gh_error = 0;\n\tgh->gh_iflags = 0;\n\tgfs2_glock_hold(gl);\n}",
          "includes": [
            "#include \"trace_gfs2.h\"",
            "#include \"bmap.h\"",
            "#include \"util.h\"",
            "#include \"super.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"lops.h\"",
            "#include \"inode.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/lockref.h>",
            "#include <linux/list_sort.h>",
            "#include <linux/percpu.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/seq_file.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/module.h>",
            "#include <linux/wait.h>",
            "#include <linux/list.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/jhash.h>",
            "#include <linux/sort.h>",
            "#include <linux/delay.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"bmap.h\"\n#include \"util.h\"\n#include \"super.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"lops.h\"\n#include \"inode.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/lockref.h>\n#include <linux/list_sort.h>\n#include <linux/percpu.h>\n#include <linux/bit_spinlock.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/jiffies.h>\n#include <linux/workqueue.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <asm/uaccess.h>\n#include <linux/module.h>\n#include <linux/wait.h>\n#include <linux/list.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/kallsyms.h>\n#include <linux/jhash.h>\n#include <linux/sort.h>\n#include <linux/delay.h>\n#include <linux/buffer_head.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nvoid gfs2_holder_init(struct gfs2_glock *gl, unsigned int state, unsigned flags,\n\t\t      struct gfs2_holder *gh)\n{\n\tINIT_LIST_HEAD(&gh->gh_list);\n\tgh->gh_gl = gl;\n\tgh->gh_ip = _RET_IP_;\n\tgh->gh_owner_pid = get_pid(task_pid(current));\n\tgh->gh_state = state;\n\tgh->gh_flags = flags;\n\tgh->gh_error = 0;\n\tgh->gh_iflags = 0;\n\tgfs2_glock_hold(gl);\n}"
        }
      },
      {
        "call_info": {
          "callee": "gfs2_glock_is_locked_by_me",
          "args": [
            "ip->i_gl"
          ],
          "line": 1848
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_glock_is_locked_by_me",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/glock.h",
          "lines": "138-157",
          "snippet": "static inline struct gfs2_holder *gfs2_glock_is_locked_by_me(struct gfs2_glock *gl)\n{\n\tstruct gfs2_holder *gh;\n\tstruct pid *pid;\n\n\t/* Look in glock's list of holders for one with current task as owner */\n\tspin_lock(&gl->gl_spin);\n\tpid = task_pid(current);\n\tlist_for_each_entry(gh, &gl->gl_holders, gh_list) {\n\t\tif (!test_bit(HIF_HOLDER, &gh->gh_iflags))\n\t\t\tbreak;\n\t\tif (gh->gh_owner_pid == pid)\n\t\t\tgoto out;\n\t}\n\tgh = NULL;\nout:\n\tspin_unlock(&gl->gl_spin);\n\n\treturn gh;\n}",
          "includes": [
            "#include \"incore.h\"",
            "#include <linux/parser.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"incore.h\"\n#include <linux/parser.h>\n#include <linux/sched.h>\n\nstatic inline struct gfs2_holder *gfs2_glock_is_locked_by_me(struct gfs2_glock *gl)\n{\n\tstruct gfs2_holder *gh;\n\tstruct pid *pid;\n\n\t/* Look in glock's list of holders for one with current task as owner */\n\tspin_lock(&gl->gl_spin);\n\tpid = task_pid(current);\n\tlist_for_each_entry(gh, &gl->gl_holders, gh_list) {\n\t\tif (!test_bit(HIF_HOLDER, &gh->gh_iflags))\n\t\t\tbreak;\n\t\tif (gh->gh_owner_pid == pid)\n\t\t\tgoto out;\n\t}\n\tgh = NULL;\nout:\n\tspin_unlock(&gl->gl_spin);\n\n\treturn gh;\n}"
        }
      },
      {
        "call_info": {
          "callee": "GFS2_I",
          "args": [
            "inode"
          ],
          "line": 1843
        },
        "resolved": true,
        "details": {
          "function_name": "GFS2_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/incore.h",
          "lines": "408-411",
          "snippet": "static inline struct gfs2_inode *GFS2_I(struct inode *inode)\n{\n\treturn container_of(inode, struct gfs2_inode, i_inode);\n}",
          "includes": [
            "#include <linux/lockref.h>",
            "#include <linux/percpu.h>",
            "#include <linux/ktime.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/completion.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/dlm.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/kobject.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/lockref.h>\n#include <linux/percpu.h>\n#include <linux/ktime.h>\n#include <linux/rbtree.h>\n#include <linux/completion.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/buffer_head.h>\n#include <linux/dlm.h>\n#include <linux/workqueue.h>\n#include <linux/kobject.h>\n#include <linux/fs.h>\n\nstatic inline struct gfs2_inode *GFS2_I(struct inode *inode)\n{\n\treturn container_of(inode, struct gfs2_inode, i_inode);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"glops.h\"\n#include \"super.h\"\n#include \"util.h\"\n#include \"trans.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"xattr.h\"\n#include \"dir.h\"\n#include \"bmap.h\"\n#include \"acl.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <asm/uaccess.h>\n#include <linux/security.h>\n#include <linux/fiemap.h>\n#include <linux/crc32.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/posix_acl.h>\n#include <linux/xattr.h>\n#include <linux/mm.h>\n#include <linux/namei.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nstatic ssize_t gfs2_getxattr(struct dentry *dentry, const char *name,\n\t\t\t     void *data, size_t size)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tstruct gfs2_inode *ip = GFS2_I(inode);\n\tstruct gfs2_holder gh;\n\tint ret;\n\n\t/* For selinux during lookup */\n\tif (gfs2_glock_is_locked_by_me(ip->i_gl))\n\t\treturn generic_getxattr(dentry, name, data, size);\n\n\tgfs2_holder_init(ip->i_gl, LM_ST_SHARED, LM_FLAG_ANY, &gh);\n\tret = gfs2_glock_nq(&gh);\n\tif (ret == 0) {\n\t\tret = generic_getxattr(dentry, name, data, size);\n\t\tgfs2_glock_dq(&gh);\n\t}\n\tgfs2_holder_uninit(&gh);\n\treturn ret;\n}"
  },
  {
    "function_name": "gfs2_setxattr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/inode.c",
    "lines": "1819-1837",
    "snippet": "static int gfs2_setxattr(struct dentry *dentry, const char *name,\n\t\t\t const void *data, size_t size, int flags)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tstruct gfs2_inode *ip = GFS2_I(inode);\n\tstruct gfs2_holder gh;\n\tint ret;\n\n\tgfs2_holder_init(ip->i_gl, LM_ST_EXCLUSIVE, 0, &gh);\n\tret = gfs2_glock_nq(&gh);\n\tif (ret == 0) {\n\t\tret = gfs2_rs_alloc(ip);\n\t\tif (ret == 0)\n\t\t\tret = generic_setxattr(dentry, name, data, size, flags);\n\t\tgfs2_glock_dq(&gh);\n\t}\n\tgfs2_holder_uninit(&gh);\n\treturn ret;\n}",
    "includes": [
      "#include \"glops.h\"",
      "#include \"super.h\"",
      "#include \"util.h\"",
      "#include \"trans.h\"",
      "#include \"rgrp.h\"",
      "#include \"quota.h\"",
      "#include \"meta_io.h\"",
      "#include \"inode.h\"",
      "#include \"glock.h\"",
      "#include \"xattr.h\"",
      "#include \"dir.h\"",
      "#include \"bmap.h\"",
      "#include \"acl.h\"",
      "#include \"incore.h\"",
      "#include \"gfs2.h\"",
      "#include <asm/uaccess.h>",
      "#include <linux/security.h>",
      "#include <linux/fiemap.h>",
      "#include <linux/crc32.h>",
      "#include <linux/gfs2_ondisk.h>",
      "#include <linux/posix_acl.h>",
      "#include <linux/xattr.h>",
      "#include <linux/mm.h>",
      "#include <linux/namei.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/completion.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "gfs2_holder_uninit",
          "args": [
            "&gh"
          ],
          "line": 1835
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_holder_uninit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/glock.c",
          "lines": "841-847",
          "snippet": "void gfs2_holder_uninit(struct gfs2_holder *gh)\n{\n\tput_pid(gh->gh_owner_pid);\n\tgfs2_glock_put(gh->gh_gl);\n\tgh->gh_gl = NULL;\n\tgh->gh_ip = 0;\n}",
          "includes": [
            "#include \"trace_gfs2.h\"",
            "#include \"bmap.h\"",
            "#include \"util.h\"",
            "#include \"super.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"lops.h\"",
            "#include \"inode.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/lockref.h>",
            "#include <linux/list_sort.h>",
            "#include <linux/percpu.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/seq_file.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/module.h>",
            "#include <linux/wait.h>",
            "#include <linux/list.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/jhash.h>",
            "#include <linux/sort.h>",
            "#include <linux/delay.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"bmap.h\"\n#include \"util.h\"\n#include \"super.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"lops.h\"\n#include \"inode.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/lockref.h>\n#include <linux/list_sort.h>\n#include <linux/percpu.h>\n#include <linux/bit_spinlock.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/jiffies.h>\n#include <linux/workqueue.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <asm/uaccess.h>\n#include <linux/module.h>\n#include <linux/wait.h>\n#include <linux/list.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/kallsyms.h>\n#include <linux/jhash.h>\n#include <linux/sort.h>\n#include <linux/delay.h>\n#include <linux/buffer_head.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nvoid gfs2_holder_uninit(struct gfs2_holder *gh)\n{\n\tput_pid(gh->gh_owner_pid);\n\tgfs2_glock_put(gh->gh_gl);\n\tgh->gh_gl = NULL;\n\tgh->gh_ip = 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "gfs2_glock_dq",
          "args": [
            "&gh"
          ],
          "line": 1833
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_glock_dq_uninit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/glock.c",
          "lines": "1110-1114",
          "snippet": "void gfs2_glock_dq_uninit(struct gfs2_holder *gh)\n{\n\tgfs2_glock_dq(gh);\n\tgfs2_holder_uninit(gh);\n}",
          "includes": [
            "#include \"trace_gfs2.h\"",
            "#include \"bmap.h\"",
            "#include \"util.h\"",
            "#include \"super.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"lops.h\"",
            "#include \"inode.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/lockref.h>",
            "#include <linux/list_sort.h>",
            "#include <linux/percpu.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/seq_file.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/module.h>",
            "#include <linux/wait.h>",
            "#include <linux/list.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/jhash.h>",
            "#include <linux/sort.h>",
            "#include <linux/delay.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"bmap.h\"\n#include \"util.h\"\n#include \"super.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"lops.h\"\n#include \"inode.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/lockref.h>\n#include <linux/list_sort.h>\n#include <linux/percpu.h>\n#include <linux/bit_spinlock.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/jiffies.h>\n#include <linux/workqueue.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <asm/uaccess.h>\n#include <linux/module.h>\n#include <linux/wait.h>\n#include <linux/list.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/kallsyms.h>\n#include <linux/jhash.h>\n#include <linux/sort.h>\n#include <linux/delay.h>\n#include <linux/buffer_head.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nvoid gfs2_glock_dq_uninit(struct gfs2_holder *gh)\n{\n\tgfs2_glock_dq(gh);\n\tgfs2_holder_uninit(gh);\n}"
        }
      },
      {
        "call_info": {
          "callee": "generic_setxattr",
          "args": [
            "dentry",
            "name",
            "data",
            "size",
            "flags"
          ],
          "line": 1832
        },
        "resolved": true,
        "details": {
          "function_name": "generic_setxattr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xattr.c",
          "lines": "760-771",
          "snippet": "int\ngeneric_setxattr(struct dentry *dentry, const char *name, const void *value, size_t size, int flags)\n{\n\tconst struct xattr_handler *handler;\n\n\tif (size == 0)\n\t\tvalue = \"\";  /* empty EA, do not remove */\n\thandler = xattr_resolve_name(dentry->d_sb->s_xattr, &name);\n\tif (!handler)\n\t\treturn -EOPNOTSUPP;\n\treturn handler->set(dentry, name, value, size, flags, handler->flags);\n}",
          "includes": [
            "#include <asm/uaccess.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/audit.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/evm.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/xattr.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/uaccess.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/vmalloc.h>\n#include <linux/audit.h>\n#include <linux/fsnotify.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n#include <linux/evm.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/xattr.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nint\ngeneric_setxattr(struct dentry *dentry, const char *name, const void *value, size_t size, int flags)\n{\n\tconst struct xattr_handler *handler;\n\n\tif (size == 0)\n\t\tvalue = \"\";  /* empty EA, do not remove */\n\thandler = xattr_resolve_name(dentry->d_sb->s_xattr, &name);\n\tif (!handler)\n\t\treturn -EOPNOTSUPP;\n\treturn handler->set(dentry, name, value, size, flags, handler->flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "gfs2_rs_alloc",
          "args": [
            "ip"
          ],
          "line": 1830
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_rs_alloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/rgrp.c",
          "lines": "602-620",
          "snippet": "int gfs2_rs_alloc(struct gfs2_inode *ip)\n{\n\tint error = 0;\n\n\tdown_write(&ip->i_rw_mutex);\n\tif (ip->i_res)\n\t\tgoto out;\n\n\tip->i_res = kmem_cache_zalloc(gfs2_rsrv_cachep, GFP_NOFS);\n\tif (!ip->i_res) {\n\t\terror = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tRB_CLEAR_NODE(&ip->i_res->rs_node);\nout:\n\tup_write(&ip->i_rw_mutex);\n\treturn error;\n}",
          "includes": [
            "#include \"trace_gfs2.h\"",
            "#include \"inode.h\"",
            "#include \"log.h\"",
            "#include \"util.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"lops.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/random.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/fs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"inode.h\"\n#include \"log.h\"\n#include \"util.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"lops.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/random.h>\n#include <linux/rbtree.h>\n#include <linux/blkdev.h>\n#include <linux/prefetch.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/fs.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nint gfs2_rs_alloc(struct gfs2_inode *ip)\n{\n\tint error = 0;\n\n\tdown_write(&ip->i_rw_mutex);\n\tif (ip->i_res)\n\t\tgoto out;\n\n\tip->i_res = kmem_cache_zalloc(gfs2_rsrv_cachep, GFP_NOFS);\n\tif (!ip->i_res) {\n\t\terror = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tRB_CLEAR_NODE(&ip->i_res->rs_node);\nout:\n\tup_write(&ip->i_rw_mutex);\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "gfs2_glock_nq",
          "args": [
            "&gh"
          ],
          "line": 1828
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_glock_nq",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/glock.c",
          "lines": "1006-1034",
          "snippet": "int gfs2_glock_nq(struct gfs2_holder *gh)\n{\n\tstruct gfs2_glock *gl = gh->gh_gl;\n\tstruct gfs2_sbd *sdp = gl->gl_sbd;\n\tint error = 0;\n\n\tif (unlikely(test_bit(SDF_SHUTDOWN, &sdp->sd_flags)))\n\t\treturn -EIO;\n\n\tif (test_bit(GLF_LRU, &gl->gl_flags))\n\t\tgfs2_glock_remove_from_lru(gl);\n\n\tspin_lock(&gl->gl_spin);\n\tadd_to_queue(gh);\n\tif (unlikely((LM_FLAG_NOEXP & gh->gh_flags) &&\n\t\t     test_and_clear_bit(GLF_FROZEN, &gl->gl_flags))) {\n\t\tset_bit(GLF_REPLY_PENDING, &gl->gl_flags);\n\t\tgl->gl_lockref.count++;\n\t\tif (queue_delayed_work(glock_workqueue, &gl->gl_work, 0) == 0)\n\t\t\tgl->gl_lockref.count--;\n\t}\n\trun_queue(gl, 1);\n\tspin_unlock(&gl->gl_spin);\n\n\tif (!(gh->gh_flags & GL_ASYNC))\n\t\terror = gfs2_glock_wait(gh);\n\n\treturn error;\n}",
          "includes": [
            "#include \"trace_gfs2.h\"",
            "#include \"bmap.h\"",
            "#include \"util.h\"",
            "#include \"super.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"lops.h\"",
            "#include \"inode.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/lockref.h>",
            "#include <linux/list_sort.h>",
            "#include <linux/percpu.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/seq_file.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/module.h>",
            "#include <linux/wait.h>",
            "#include <linux/list.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/jhash.h>",
            "#include <linux/sort.h>",
            "#include <linux/delay.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct workqueue_struct *glock_workqueue;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"bmap.h\"\n#include \"util.h\"\n#include \"super.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"lops.h\"\n#include \"inode.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/lockref.h>\n#include <linux/list_sort.h>\n#include <linux/percpu.h>\n#include <linux/bit_spinlock.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/jiffies.h>\n#include <linux/workqueue.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <asm/uaccess.h>\n#include <linux/module.h>\n#include <linux/wait.h>\n#include <linux/list.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/kallsyms.h>\n#include <linux/jhash.h>\n#include <linux/sort.h>\n#include <linux/delay.h>\n#include <linux/buffer_head.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic struct workqueue_struct *glock_workqueue;\n\nint gfs2_glock_nq(struct gfs2_holder *gh)\n{\n\tstruct gfs2_glock *gl = gh->gh_gl;\n\tstruct gfs2_sbd *sdp = gl->gl_sbd;\n\tint error = 0;\n\n\tif (unlikely(test_bit(SDF_SHUTDOWN, &sdp->sd_flags)))\n\t\treturn -EIO;\n\n\tif (test_bit(GLF_LRU, &gl->gl_flags))\n\t\tgfs2_glock_remove_from_lru(gl);\n\n\tspin_lock(&gl->gl_spin);\n\tadd_to_queue(gh);\n\tif (unlikely((LM_FLAG_NOEXP & gh->gh_flags) &&\n\t\t     test_and_clear_bit(GLF_FROZEN, &gl->gl_flags))) {\n\t\tset_bit(GLF_REPLY_PENDING, &gl->gl_flags);\n\t\tgl->gl_lockref.count++;\n\t\tif (queue_delayed_work(glock_workqueue, &gl->gl_work, 0) == 0)\n\t\t\tgl->gl_lockref.count--;\n\t}\n\trun_queue(gl, 1);\n\tspin_unlock(&gl->gl_spin);\n\n\tif (!(gh->gh_flags & GL_ASYNC))\n\t\terror = gfs2_glock_wait(gh);\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "gfs2_holder_init",
          "args": [
            "ip->i_gl",
            "LM_ST_EXCLUSIVE",
            "0",
            "&gh"
          ],
          "line": 1827
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_holder_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/glock.c",
          "lines": "801-813",
          "snippet": "void gfs2_holder_init(struct gfs2_glock *gl, unsigned int state, unsigned flags,\n\t\t      struct gfs2_holder *gh)\n{\n\tINIT_LIST_HEAD(&gh->gh_list);\n\tgh->gh_gl = gl;\n\tgh->gh_ip = _RET_IP_;\n\tgh->gh_owner_pid = get_pid(task_pid(current));\n\tgh->gh_state = state;\n\tgh->gh_flags = flags;\n\tgh->gh_error = 0;\n\tgh->gh_iflags = 0;\n\tgfs2_glock_hold(gl);\n}",
          "includes": [
            "#include \"trace_gfs2.h\"",
            "#include \"bmap.h\"",
            "#include \"util.h\"",
            "#include \"super.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"lops.h\"",
            "#include \"inode.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/lockref.h>",
            "#include <linux/list_sort.h>",
            "#include <linux/percpu.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/seq_file.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/module.h>",
            "#include <linux/wait.h>",
            "#include <linux/list.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/jhash.h>",
            "#include <linux/sort.h>",
            "#include <linux/delay.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"bmap.h\"\n#include \"util.h\"\n#include \"super.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"lops.h\"\n#include \"inode.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/lockref.h>\n#include <linux/list_sort.h>\n#include <linux/percpu.h>\n#include <linux/bit_spinlock.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/jiffies.h>\n#include <linux/workqueue.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <asm/uaccess.h>\n#include <linux/module.h>\n#include <linux/wait.h>\n#include <linux/list.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/kallsyms.h>\n#include <linux/jhash.h>\n#include <linux/sort.h>\n#include <linux/delay.h>\n#include <linux/buffer_head.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nvoid gfs2_holder_init(struct gfs2_glock *gl, unsigned int state, unsigned flags,\n\t\t      struct gfs2_holder *gh)\n{\n\tINIT_LIST_HEAD(&gh->gh_list);\n\tgh->gh_gl = gl;\n\tgh->gh_ip = _RET_IP_;\n\tgh->gh_owner_pid = get_pid(task_pid(current));\n\tgh->gh_state = state;\n\tgh->gh_flags = flags;\n\tgh->gh_error = 0;\n\tgh->gh_iflags = 0;\n\tgfs2_glock_hold(gl);\n}"
        }
      },
      {
        "call_info": {
          "callee": "GFS2_I",
          "args": [
            "inode"
          ],
          "line": 1823
        },
        "resolved": true,
        "details": {
          "function_name": "GFS2_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/incore.h",
          "lines": "408-411",
          "snippet": "static inline struct gfs2_inode *GFS2_I(struct inode *inode)\n{\n\treturn container_of(inode, struct gfs2_inode, i_inode);\n}",
          "includes": [
            "#include <linux/lockref.h>",
            "#include <linux/percpu.h>",
            "#include <linux/ktime.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/completion.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/dlm.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/kobject.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/lockref.h>\n#include <linux/percpu.h>\n#include <linux/ktime.h>\n#include <linux/rbtree.h>\n#include <linux/completion.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/buffer_head.h>\n#include <linux/dlm.h>\n#include <linux/workqueue.h>\n#include <linux/kobject.h>\n#include <linux/fs.h>\n\nstatic inline struct gfs2_inode *GFS2_I(struct inode *inode)\n{\n\treturn container_of(inode, struct gfs2_inode, i_inode);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"glops.h\"\n#include \"super.h\"\n#include \"util.h\"\n#include \"trans.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"xattr.h\"\n#include \"dir.h\"\n#include \"bmap.h\"\n#include \"acl.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <asm/uaccess.h>\n#include <linux/security.h>\n#include <linux/fiemap.h>\n#include <linux/crc32.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/posix_acl.h>\n#include <linux/xattr.h>\n#include <linux/mm.h>\n#include <linux/namei.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nstatic int gfs2_setxattr(struct dentry *dentry, const char *name,\n\t\t\t const void *data, size_t size, int flags)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tstruct gfs2_inode *ip = GFS2_I(inode);\n\tstruct gfs2_holder gh;\n\tint ret;\n\n\tgfs2_holder_init(ip->i_gl, LM_ST_EXCLUSIVE, 0, &gh);\n\tret = gfs2_glock_nq(&gh);\n\tif (ret == 0) {\n\t\tret = gfs2_rs_alloc(ip);\n\t\tif (ret == 0)\n\t\t\tret = generic_setxattr(dentry, name, data, size, flags);\n\t\tgfs2_glock_dq(&gh);\n\t}\n\tgfs2_holder_uninit(&gh);\n\treturn ret;\n}"
  },
  {
    "function_name": "gfs2_getattr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/inode.c",
    "lines": "1796-1817",
    "snippet": "static int gfs2_getattr(struct vfsmount *mnt, struct dentry *dentry,\n\t\t\tstruct kstat *stat)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tstruct gfs2_inode *ip = GFS2_I(inode);\n\tstruct gfs2_holder gh;\n\tint error;\n\tint unlock = 0;\n\n\tif (gfs2_glock_is_locked_by_me(ip->i_gl) == NULL) {\n\t\terror = gfs2_glock_nq_init(ip->i_gl, LM_ST_SHARED, LM_FLAG_ANY, &gh);\n\t\tif (error)\n\t\t\treturn error;\n\t\tunlock = 1;\n\t}\n\n\tgeneric_fillattr(inode, stat);\n\tif (unlock)\n\t\tgfs2_glock_dq_uninit(&gh);\n\n\treturn 0;\n}",
    "includes": [
      "#include \"glops.h\"",
      "#include \"super.h\"",
      "#include \"util.h\"",
      "#include \"trans.h\"",
      "#include \"rgrp.h\"",
      "#include \"quota.h\"",
      "#include \"meta_io.h\"",
      "#include \"inode.h\"",
      "#include \"glock.h\"",
      "#include \"xattr.h\"",
      "#include \"dir.h\"",
      "#include \"bmap.h\"",
      "#include \"acl.h\"",
      "#include \"incore.h\"",
      "#include \"gfs2.h\"",
      "#include <asm/uaccess.h>",
      "#include <linux/security.h>",
      "#include <linux/fiemap.h>",
      "#include <linux/crc32.h>",
      "#include <linux/gfs2_ondisk.h>",
      "#include <linux/posix_acl.h>",
      "#include <linux/xattr.h>",
      "#include <linux/mm.h>",
      "#include <linux/namei.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/completion.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "gfs2_glock_dq_uninit",
          "args": [
            "&gh"
          ],
          "line": 1814
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_glock_dq_uninit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/glock.c",
          "lines": "1110-1114",
          "snippet": "void gfs2_glock_dq_uninit(struct gfs2_holder *gh)\n{\n\tgfs2_glock_dq(gh);\n\tgfs2_holder_uninit(gh);\n}",
          "includes": [
            "#include \"trace_gfs2.h\"",
            "#include \"bmap.h\"",
            "#include \"util.h\"",
            "#include \"super.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"lops.h\"",
            "#include \"inode.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/lockref.h>",
            "#include <linux/list_sort.h>",
            "#include <linux/percpu.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/seq_file.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/module.h>",
            "#include <linux/wait.h>",
            "#include <linux/list.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/jhash.h>",
            "#include <linux/sort.h>",
            "#include <linux/delay.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"bmap.h\"\n#include \"util.h\"\n#include \"super.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"lops.h\"\n#include \"inode.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/lockref.h>\n#include <linux/list_sort.h>\n#include <linux/percpu.h>\n#include <linux/bit_spinlock.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/jiffies.h>\n#include <linux/workqueue.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <asm/uaccess.h>\n#include <linux/module.h>\n#include <linux/wait.h>\n#include <linux/list.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/kallsyms.h>\n#include <linux/jhash.h>\n#include <linux/sort.h>\n#include <linux/delay.h>\n#include <linux/buffer_head.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nvoid gfs2_glock_dq_uninit(struct gfs2_holder *gh)\n{\n\tgfs2_glock_dq(gh);\n\tgfs2_holder_uninit(gh);\n}"
        }
      },
      {
        "call_info": {
          "callee": "generic_fillattr",
          "args": [
            "inode",
            "stat"
          ],
          "line": 1812
        },
        "resolved": true,
        "details": {
          "function_name": "generic_fillattr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/stat.c",
          "lines": "21-36",
          "snippet": "void generic_fillattr(struct inode *inode, struct kstat *stat)\n{\n\tstat->dev = inode->i_sb->s_dev;\n\tstat->ino = inode->i_ino;\n\tstat->mode = inode->i_mode;\n\tstat->nlink = inode->i_nlink;\n\tstat->uid = inode->i_uid;\n\tstat->gid = inode->i_gid;\n\tstat->rdev = inode->i_rdev;\n\tstat->size = i_size_read(inode);\n\tstat->atime = inode->i_atime;\n\tstat->mtime = inode->i_mtime;\n\tstat->ctime = inode->i_ctime;\n\tstat->blksize = (1 << inode->i_blkbits);\n\tstat->blocks = inode->i_blocks;\n}",
          "includes": [
            "#include <asm/unistd.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/highuid.h>",
            "#include <linux/file.h>",
            "#include <linux/errno.h>",
            "#include <linux/mm.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/unistd.h>\n#include <asm/uaccess.h>\n#include <linux/pagemap.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/highuid.h>\n#include <linux/file.h>\n#include <linux/errno.h>\n#include <linux/mm.h>\n#include <linux/export.h>\n\nvoid generic_fillattr(struct inode *inode, struct kstat *stat)\n{\n\tstat->dev = inode->i_sb->s_dev;\n\tstat->ino = inode->i_ino;\n\tstat->mode = inode->i_mode;\n\tstat->nlink = inode->i_nlink;\n\tstat->uid = inode->i_uid;\n\tstat->gid = inode->i_gid;\n\tstat->rdev = inode->i_rdev;\n\tstat->size = i_size_read(inode);\n\tstat->atime = inode->i_atime;\n\tstat->mtime = inode->i_mtime;\n\tstat->ctime = inode->i_ctime;\n\tstat->blksize = (1 << inode->i_blkbits);\n\tstat->blocks = inode->i_blocks;\n}"
        }
      },
      {
        "call_info": {
          "callee": "gfs2_glock_nq_init",
          "args": [
            "ip->i_gl",
            "LM_ST_SHARED",
            "LM_FLAG_ANY",
            "&gh"
          ],
          "line": 1806
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_glock_nq_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/glock.h",
          "lines": "204-230",
          "snippet": "extern __printf(2, 3)\nvoid gfs2_print_dbg(struct seq_file *seq, const char *fmt, ...);\n\n/**\n * gfs2_glock_nq_init - initialize a holder and enqueue it on a glock\n * @gl: the glock\n * @state: the state we're requesting\n * @flags: the modifier flags\n * @gh: the holder structure\n *\n * Returns: 0, GLR_*, or errno\n */\n\nstatic inline int gfs2_glock_nq_init(struct gfs2_glock *gl,\n\t\t\t\t     unsigned int state, int flags,\n\t\t\t\t     struct gfs2_holder *gh)\n{\n\tint error;\n\n\tgfs2_holder_init(gl, state, flags, gh);\n\n\terror = gfs2_glock_nq(gh);\n\tif (error)\n\t\tgfs2_holder_uninit(gh);\n\n\treturn error;\n}",
          "includes": [
            "#include \"incore.h\"",
            "#include <linux/parser.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"incore.h\"\n#include <linux/parser.h>\n#include <linux/sched.h>\n\nextern __printf(2, 3)\nvoid gfs2_print_dbg(struct seq_file *seq, const char *fmt, ...);\n\n/**\n * gfs2_glock_nq_init - initialize a holder and enqueue it on a glock\n * @gl: the glock\n * @state: the state we're requesting\n * @flags: the modifier flags\n * @gh: the holder structure\n *\n * Returns: 0, GLR_*, or errno\n */\n\nstatic inline int gfs2_glock_nq_init(struct gfs2_glock *gl,\n\t\t\t\t     unsigned int state, int flags,\n\t\t\t\t     struct gfs2_holder *gh)\n{\n\tint error;\n\n\tgfs2_holder_init(gl, state, flags, gh);\n\n\terror = gfs2_glock_nq(gh);\n\tif (error)\n\t\tgfs2_holder_uninit(gh);\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "gfs2_glock_is_locked_by_me",
          "args": [
            "ip->i_gl"
          ],
          "line": 1805
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_glock_is_locked_by_me",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/glock.h",
          "lines": "138-157",
          "snippet": "static inline struct gfs2_holder *gfs2_glock_is_locked_by_me(struct gfs2_glock *gl)\n{\n\tstruct gfs2_holder *gh;\n\tstruct pid *pid;\n\n\t/* Look in glock's list of holders for one with current task as owner */\n\tspin_lock(&gl->gl_spin);\n\tpid = task_pid(current);\n\tlist_for_each_entry(gh, &gl->gl_holders, gh_list) {\n\t\tif (!test_bit(HIF_HOLDER, &gh->gh_iflags))\n\t\t\tbreak;\n\t\tif (gh->gh_owner_pid == pid)\n\t\t\tgoto out;\n\t}\n\tgh = NULL;\nout:\n\tspin_unlock(&gl->gl_spin);\n\n\treturn gh;\n}",
          "includes": [
            "#include \"incore.h\"",
            "#include <linux/parser.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"incore.h\"\n#include <linux/parser.h>\n#include <linux/sched.h>\n\nstatic inline struct gfs2_holder *gfs2_glock_is_locked_by_me(struct gfs2_glock *gl)\n{\n\tstruct gfs2_holder *gh;\n\tstruct pid *pid;\n\n\t/* Look in glock's list of holders for one with current task as owner */\n\tspin_lock(&gl->gl_spin);\n\tpid = task_pid(current);\n\tlist_for_each_entry(gh, &gl->gl_holders, gh_list) {\n\t\tif (!test_bit(HIF_HOLDER, &gh->gh_iflags))\n\t\t\tbreak;\n\t\tif (gh->gh_owner_pid == pid)\n\t\t\tgoto out;\n\t}\n\tgh = NULL;\nout:\n\tspin_unlock(&gl->gl_spin);\n\n\treturn gh;\n}"
        }
      },
      {
        "call_info": {
          "callee": "GFS2_I",
          "args": [
            "inode"
          ],
          "line": 1800
        },
        "resolved": true,
        "details": {
          "function_name": "GFS2_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/incore.h",
          "lines": "408-411",
          "snippet": "static inline struct gfs2_inode *GFS2_I(struct inode *inode)\n{\n\treturn container_of(inode, struct gfs2_inode, i_inode);\n}",
          "includes": [
            "#include <linux/lockref.h>",
            "#include <linux/percpu.h>",
            "#include <linux/ktime.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/completion.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/dlm.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/kobject.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/lockref.h>\n#include <linux/percpu.h>\n#include <linux/ktime.h>\n#include <linux/rbtree.h>\n#include <linux/completion.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/buffer_head.h>\n#include <linux/dlm.h>\n#include <linux/workqueue.h>\n#include <linux/kobject.h>\n#include <linux/fs.h>\n\nstatic inline struct gfs2_inode *GFS2_I(struct inode *inode)\n{\n\treturn container_of(inode, struct gfs2_inode, i_inode);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"glops.h\"\n#include \"super.h\"\n#include \"util.h\"\n#include \"trans.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"xattr.h\"\n#include \"dir.h\"\n#include \"bmap.h\"\n#include \"acl.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <asm/uaccess.h>\n#include <linux/security.h>\n#include <linux/fiemap.h>\n#include <linux/crc32.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/posix_acl.h>\n#include <linux/xattr.h>\n#include <linux/mm.h>\n#include <linux/namei.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nstatic int gfs2_getattr(struct vfsmount *mnt, struct dentry *dentry,\n\t\t\tstruct kstat *stat)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tstruct gfs2_inode *ip = GFS2_I(inode);\n\tstruct gfs2_holder gh;\n\tint error;\n\tint unlock = 0;\n\n\tif (gfs2_glock_is_locked_by_me(ip->i_gl) == NULL) {\n\t\terror = gfs2_glock_nq_init(ip->i_gl, LM_ST_SHARED, LM_FLAG_ANY, &gh);\n\t\tif (error)\n\t\t\treturn error;\n\t\tunlock = 1;\n\t}\n\n\tgeneric_fillattr(inode, stat);\n\tif (unlock)\n\t\tgfs2_glock_dq_uninit(&gh);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "gfs2_setattr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/inode.c",
    "lines": "1741-1779",
    "snippet": "static int gfs2_setattr(struct dentry *dentry, struct iattr *attr)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tstruct gfs2_inode *ip = GFS2_I(inode);\n\tstruct gfs2_holder i_gh;\n\tint error;\n\n\terror = gfs2_rs_alloc(ip);\n\tif (error)\n\t\treturn error;\n\n\terror = gfs2_glock_nq_init(ip->i_gl, LM_ST_EXCLUSIVE, 0, &i_gh);\n\tif (error)\n\t\treturn error;\n\n\terror = -EPERM;\n\tif (IS_IMMUTABLE(inode) || IS_APPEND(inode))\n\t\tgoto out;\n\n\terror = inode_change_ok(inode, attr);\n\tif (error)\n\t\tgoto out;\n\n\tif (attr->ia_valid & ATTR_SIZE)\n\t\terror = gfs2_setattr_size(inode, attr->ia_size);\n\telse if (attr->ia_valid & (ATTR_UID | ATTR_GID))\n\t\terror = setattr_chown(inode, attr);\n\telse {\n\t\terror = gfs2_setattr_simple(inode, attr);\n\t\tif (!error && attr->ia_valid & ATTR_MODE)\n\t\t\terror = posix_acl_chmod(inode, inode->i_mode);\n\t}\n\nout:\n\tif (!error)\n\t\tmark_inode_dirty(inode);\n\tgfs2_glock_dq_uninit(&i_gh);\n\treturn error;\n}",
    "includes": [
      "#include \"glops.h\"",
      "#include \"super.h\"",
      "#include \"util.h\"",
      "#include \"trans.h\"",
      "#include \"rgrp.h\"",
      "#include \"quota.h\"",
      "#include \"meta_io.h\"",
      "#include \"inode.h\"",
      "#include \"glock.h\"",
      "#include \"xattr.h\"",
      "#include \"dir.h\"",
      "#include \"bmap.h\"",
      "#include \"acl.h\"",
      "#include \"incore.h\"",
      "#include \"gfs2.h\"",
      "#include <asm/uaccess.h>",
      "#include <linux/security.h>",
      "#include <linux/fiemap.h>",
      "#include <linux/crc32.h>",
      "#include <linux/gfs2_ondisk.h>",
      "#include <linux/posix_acl.h>",
      "#include <linux/xattr.h>",
      "#include <linux/mm.h>",
      "#include <linux/namei.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/completion.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "gfs2_glock_dq_uninit",
          "args": [
            "&i_gh"
          ],
          "line": 1777
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_glock_dq_uninit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/glock.c",
          "lines": "1110-1114",
          "snippet": "void gfs2_glock_dq_uninit(struct gfs2_holder *gh)\n{\n\tgfs2_glock_dq(gh);\n\tgfs2_holder_uninit(gh);\n}",
          "includes": [
            "#include \"trace_gfs2.h\"",
            "#include \"bmap.h\"",
            "#include \"util.h\"",
            "#include \"super.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"lops.h\"",
            "#include \"inode.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/lockref.h>",
            "#include <linux/list_sort.h>",
            "#include <linux/percpu.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/seq_file.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/module.h>",
            "#include <linux/wait.h>",
            "#include <linux/list.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/jhash.h>",
            "#include <linux/sort.h>",
            "#include <linux/delay.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"bmap.h\"\n#include \"util.h\"\n#include \"super.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"lops.h\"\n#include \"inode.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/lockref.h>\n#include <linux/list_sort.h>\n#include <linux/percpu.h>\n#include <linux/bit_spinlock.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/jiffies.h>\n#include <linux/workqueue.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <asm/uaccess.h>\n#include <linux/module.h>\n#include <linux/wait.h>\n#include <linux/list.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/kallsyms.h>\n#include <linux/jhash.h>\n#include <linux/sort.h>\n#include <linux/delay.h>\n#include <linux/buffer_head.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nvoid gfs2_glock_dq_uninit(struct gfs2_holder *gh)\n{\n\tgfs2_glock_dq(gh);\n\tgfs2_holder_uninit(gh);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mark_inode_dirty",
          "args": [
            "inode"
          ],
          "line": 1776
        },
        "resolved": true,
        "details": {
          "function_name": "block_dump___mark_inode_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fs-writeback.c",
          "lines": "1134-1154",
          "snippet": "static noinline void block_dump___mark_inode_dirty(struct inode *inode)\n{\n\tif (inode->i_ino || strcmp(inode->i_sb->s_id, \"bdev\")) {\n\t\tstruct dentry *dentry;\n\t\tconst char *name = \"?\";\n\n\t\tdentry = d_find_alias(inode);\n\t\tif (dentry) {\n\t\t\tspin_lock(&dentry->d_lock);\n\t\t\tname = (const char *) dentry->d_name.name;\n\t\t}\n\t\tprintk(KERN_DEBUG\n\t\t       \"%s(%d): dirtied inode %lu (%s) on %s\\n\",\n\t\t       current->comm, task_pid_nr(current), inode->i_ino,\n\t\t       name, inode->i_sb->s_id);\n\t\tif (dentry) {\n\t\t\tspin_unlock(&dentry->d_lock);\n\t\t\tdput(dentry);\n\t\t}\n\t}\n}",
          "includes": [
            "#include <trace/events/writeback.h>",
            "#include \"internal.h\"",
            "#include <linux/device.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/writeback.h>\n#include \"internal.h\"\n#include <linux/device.h>\n#include <linux/tracepoint.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nstatic noinline void block_dump___mark_inode_dirty(struct inode *inode)\n{\n\tif (inode->i_ino || strcmp(inode->i_sb->s_id, \"bdev\")) {\n\t\tstruct dentry *dentry;\n\t\tconst char *name = \"?\";\n\n\t\tdentry = d_find_alias(inode);\n\t\tif (dentry) {\n\t\t\tspin_lock(&dentry->d_lock);\n\t\t\tname = (const char *) dentry->d_name.name;\n\t\t}\n\t\tprintk(KERN_DEBUG\n\t\t       \"%s(%d): dirtied inode %lu (%s) on %s\\n\",\n\t\t       current->comm, task_pid_nr(current), inode->i_ino,\n\t\t       name, inode->i_sb->s_id);\n\t\tif (dentry) {\n\t\t\tspin_unlock(&dentry->d_lock);\n\t\t\tdput(dentry);\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "posix_acl_chmod",
          "args": [
            "inode",
            "inode->i_mode"
          ],
          "line": 1771
        },
        "resolved": true,
        "details": {
          "function_name": "posix_acl_chmod",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/posix_acl.c",
          "lines": "518-542",
          "snippet": "int\nposix_acl_chmod(struct inode *inode, umode_t mode)\n{\n\tstruct posix_acl *acl;\n\tint ret = 0;\n\n\tif (!IS_POSIXACL(inode))\n\t\treturn 0;\n\tif (!inode->i_op->set_acl)\n\t\treturn -EOPNOTSUPP;\n\n\tacl = get_acl(inode, ACL_TYPE_ACCESS);\n\tif (IS_ERR_OR_NULL(acl)) {\n\t\tif (acl == ERR_PTR(-EOPNOTSUPP))\n\t\t\treturn 0;\n\t\treturn PTR_ERR(acl);\n\t}\n\n\tret = __posix_acl_chmod(&acl, GFP_KERNEL, mode);\n\tif (ret)\n\t\treturn ret;\n\tret = inode->i_op->set_acl(inode, acl, ACL_TYPE_ACCESS);\n\tposix_acl_release(acl);\n\treturn ret;\n}",
          "includes": [
            "#include <linux/user_namespace.h>",
            "#include <linux/export.h>",
            "#include <linux/xattr.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/sched.h>",
            "#include <linux/fs.h>",
            "#include <linux/atomic.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/user_namespace.h>\n#include <linux/export.h>\n#include <linux/xattr.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/posix_acl.h>\n#include <linux/sched.h>\n#include <linux/fs.h>\n#include <linux/atomic.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nint\nposix_acl_chmod(struct inode *inode, umode_t mode)\n{\n\tstruct posix_acl *acl;\n\tint ret = 0;\n\n\tif (!IS_POSIXACL(inode))\n\t\treturn 0;\n\tif (!inode->i_op->set_acl)\n\t\treturn -EOPNOTSUPP;\n\n\tacl = get_acl(inode, ACL_TYPE_ACCESS);\n\tif (IS_ERR_OR_NULL(acl)) {\n\t\tif (acl == ERR_PTR(-EOPNOTSUPP))\n\t\t\treturn 0;\n\t\treturn PTR_ERR(acl);\n\t}\n\n\tret = __posix_acl_chmod(&acl, GFP_KERNEL, mode);\n\tif (ret)\n\t\treturn ret;\n\tret = inode->i_op->set_acl(inode, acl, ACL_TYPE_ACCESS);\n\tposix_acl_release(acl);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "gfs2_setattr_simple",
          "args": [
            "inode",
            "attr"
          ],
          "line": 1769
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_setattr_simple",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/inode.c",
          "lines": "1649-1663",
          "snippet": "int gfs2_setattr_simple(struct inode *inode, struct iattr *attr)\n{\n\tint error;\n\n\tif (current->journal_info)\n\t\treturn __gfs2_setattr_simple(inode, attr);\n\n\terror = gfs2_trans_begin(GFS2_SB(inode), RES_DINODE, 0);\n\tif (error)\n\t\treturn error;\n\n\terror = __gfs2_setattr_simple(inode, attr);\n\tgfs2_trans_end(GFS2_SB(inode));\n\treturn error;\n}",
          "includes": [
            "#include \"glops.h\"",
            "#include \"super.h\"",
            "#include \"util.h\"",
            "#include \"trans.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"inode.h\"",
            "#include \"glock.h\"",
            "#include \"xattr.h\"",
            "#include \"dir.h\"",
            "#include \"bmap.h\"",
            "#include \"acl.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/security.h>",
            "#include <linux/fiemap.h>",
            "#include <linux/crc32.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/xattr.h>",
            "#include <linux/mm.h>",
            "#include <linux/namei.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glops.h\"\n#include \"super.h\"\n#include \"util.h\"\n#include \"trans.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"xattr.h\"\n#include \"dir.h\"\n#include \"bmap.h\"\n#include \"acl.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <asm/uaccess.h>\n#include <linux/security.h>\n#include <linux/fiemap.h>\n#include <linux/crc32.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/posix_acl.h>\n#include <linux/xattr.h>\n#include <linux/mm.h>\n#include <linux/namei.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nint gfs2_setattr_simple(struct inode *inode, struct iattr *attr)\n{\n\tint error;\n\n\tif (current->journal_info)\n\t\treturn __gfs2_setattr_simple(inode, attr);\n\n\terror = gfs2_trans_begin(GFS2_SB(inode), RES_DINODE, 0);\n\tif (error)\n\t\treturn error;\n\n\terror = __gfs2_setattr_simple(inode, attr);\n\tgfs2_trans_end(GFS2_SB(inode));\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "setattr_chown",
          "args": [
            "inode",
            "attr"
          ],
          "line": 1767
        },
        "resolved": true,
        "details": {
          "function_name": "setattr_chown",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/inode.c",
          "lines": "1665-1728",
          "snippet": "static int setattr_chown(struct inode *inode, struct iattr *attr)\n{\n\tstruct gfs2_inode *ip = GFS2_I(inode);\n\tstruct gfs2_sbd *sdp = GFS2_SB(inode);\n\tkuid_t ouid, nuid;\n\tkgid_t ogid, ngid;\n\tint error;\n\n\touid = inode->i_uid;\n\togid = inode->i_gid;\n\tnuid = attr->ia_uid;\n\tngid = attr->ia_gid;\n\n\tif (!(attr->ia_valid & ATTR_UID) || uid_eq(ouid, nuid))\n\t\touid = nuid = NO_UID_QUOTA_CHANGE;\n\tif (!(attr->ia_valid & ATTR_GID) || gid_eq(ogid, ngid))\n\t\togid = ngid = NO_GID_QUOTA_CHANGE;\n\n\terror = get_write_access(inode);\n\tif (error)\n\t\treturn error;\n\n\terror = gfs2_rs_alloc(ip);\n\tif (error)\n\t\tgoto out;\n\n\terror = gfs2_rindex_update(sdp);\n\tif (error)\n\t\tgoto out;\n\n\terror = gfs2_quota_lock(ip, nuid, ngid);\n\tif (error)\n\t\tgoto out;\n\n\tif (!uid_eq(ouid, NO_UID_QUOTA_CHANGE) ||\n\t    !gid_eq(ogid, NO_GID_QUOTA_CHANGE)) {\n\t\terror = gfs2_quota_check(ip, nuid, ngid);\n\t\tif (error)\n\t\t\tgoto out_gunlock_q;\n\t}\n\n\terror = gfs2_trans_begin(sdp, RES_DINODE + 2 * RES_QUOTA, 0);\n\tif (error)\n\t\tgoto out_gunlock_q;\n\n\terror = gfs2_setattr_simple(inode, attr);\n\tif (error)\n\t\tgoto out_end_trans;\n\n\tif (!uid_eq(ouid, NO_UID_QUOTA_CHANGE) ||\n\t    !gid_eq(ogid, NO_GID_QUOTA_CHANGE)) {\n\t\tu64 blocks = gfs2_get_inode_blocks(&ip->i_inode);\n\t\tgfs2_quota_change(ip, -blocks, ouid, ogid);\n\t\tgfs2_quota_change(ip, blocks, nuid, ngid);\n\t}\n\nout_end_trans:\n\tgfs2_trans_end(sdp);\nout_gunlock_q:\n\tgfs2_quota_unlock(ip);\nout:\n\tput_write_access(inode);\n\treturn error;\n}",
          "includes": [
            "#include \"glops.h\"",
            "#include \"super.h\"",
            "#include \"util.h\"",
            "#include \"trans.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"inode.h\"",
            "#include \"glock.h\"",
            "#include \"xattr.h\"",
            "#include \"dir.h\"",
            "#include \"bmap.h\"",
            "#include \"acl.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/security.h>",
            "#include <linux/fiemap.h>",
            "#include <linux/crc32.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/xattr.h>",
            "#include <linux/mm.h>",
            "#include <linux/namei.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glops.h\"\n#include \"super.h\"\n#include \"util.h\"\n#include \"trans.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"xattr.h\"\n#include \"dir.h\"\n#include \"bmap.h\"\n#include \"acl.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <asm/uaccess.h>\n#include <linux/security.h>\n#include <linux/fiemap.h>\n#include <linux/crc32.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/posix_acl.h>\n#include <linux/xattr.h>\n#include <linux/mm.h>\n#include <linux/namei.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nstatic int setattr_chown(struct inode *inode, struct iattr *attr)\n{\n\tstruct gfs2_inode *ip = GFS2_I(inode);\n\tstruct gfs2_sbd *sdp = GFS2_SB(inode);\n\tkuid_t ouid, nuid;\n\tkgid_t ogid, ngid;\n\tint error;\n\n\touid = inode->i_uid;\n\togid = inode->i_gid;\n\tnuid = attr->ia_uid;\n\tngid = attr->ia_gid;\n\n\tif (!(attr->ia_valid & ATTR_UID) || uid_eq(ouid, nuid))\n\t\touid = nuid = NO_UID_QUOTA_CHANGE;\n\tif (!(attr->ia_valid & ATTR_GID) || gid_eq(ogid, ngid))\n\t\togid = ngid = NO_GID_QUOTA_CHANGE;\n\n\terror = get_write_access(inode);\n\tif (error)\n\t\treturn error;\n\n\terror = gfs2_rs_alloc(ip);\n\tif (error)\n\t\tgoto out;\n\n\terror = gfs2_rindex_update(sdp);\n\tif (error)\n\t\tgoto out;\n\n\terror = gfs2_quota_lock(ip, nuid, ngid);\n\tif (error)\n\t\tgoto out;\n\n\tif (!uid_eq(ouid, NO_UID_QUOTA_CHANGE) ||\n\t    !gid_eq(ogid, NO_GID_QUOTA_CHANGE)) {\n\t\terror = gfs2_quota_check(ip, nuid, ngid);\n\t\tif (error)\n\t\t\tgoto out_gunlock_q;\n\t}\n\n\terror = gfs2_trans_begin(sdp, RES_DINODE + 2 * RES_QUOTA, 0);\n\tif (error)\n\t\tgoto out_gunlock_q;\n\n\terror = gfs2_setattr_simple(inode, attr);\n\tif (error)\n\t\tgoto out_end_trans;\n\n\tif (!uid_eq(ouid, NO_UID_QUOTA_CHANGE) ||\n\t    !gid_eq(ogid, NO_GID_QUOTA_CHANGE)) {\n\t\tu64 blocks = gfs2_get_inode_blocks(&ip->i_inode);\n\t\tgfs2_quota_change(ip, -blocks, ouid, ogid);\n\t\tgfs2_quota_change(ip, blocks, nuid, ngid);\n\t}\n\nout_end_trans:\n\tgfs2_trans_end(sdp);\nout_gunlock_q:\n\tgfs2_quota_unlock(ip);\nout:\n\tput_write_access(inode);\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "gfs2_setattr_size",
          "args": [
            "inode",
            "attr->ia_size"
          ],
          "line": 1765
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_setattr_size",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/bmap.c",
          "lines": "1282-1315",
          "snippet": "int gfs2_setattr_size(struct inode *inode, u64 newsize)\n{\n\tstruct gfs2_inode *ip = GFS2_I(inode);\n\tint ret;\n\tu64 oldsize;\n\n\tBUG_ON(!S_ISREG(inode->i_mode));\n\n\tret = inode_newsize_ok(inode, newsize);\n\tif (ret)\n\t\treturn ret;\n\n\tret = get_write_access(inode);\n\tif (ret)\n\t\treturn ret;\n\n\tinode_dio_wait(inode);\n\n\tret = gfs2_rs_alloc(ip);\n\tif (ret)\n\t\tgoto out;\n\n\toldsize = inode->i_size;\n\tif (newsize >= oldsize) {\n\t\tret = do_grow(inode, newsize);\n\t\tgoto out;\n\t}\n\n\tgfs2_rs_deltree(ip->i_res);\n\tret = do_shrink(inode, oldsize, newsize);\nout:\n\tput_write_access(inode);\n\treturn ret;\n}",
          "includes": [
            "#include \"trace_gfs2.h\"",
            "#include \"util.h\"",
            "#include \"dir.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"log.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"inode.h\"",
            "#include \"glock.h\"",
            "#include \"bmap.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/crc32.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"util.h\"\n#include \"dir.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"log.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/crc32.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n\nint gfs2_setattr_size(struct inode *inode, u64 newsize)\n{\n\tstruct gfs2_inode *ip = GFS2_I(inode);\n\tint ret;\n\tu64 oldsize;\n\n\tBUG_ON(!S_ISREG(inode->i_mode));\n\n\tret = inode_newsize_ok(inode, newsize);\n\tif (ret)\n\t\treturn ret;\n\n\tret = get_write_access(inode);\n\tif (ret)\n\t\treturn ret;\n\n\tinode_dio_wait(inode);\n\n\tret = gfs2_rs_alloc(ip);\n\tif (ret)\n\t\tgoto out;\n\n\toldsize = inode->i_size;\n\tif (newsize >= oldsize) {\n\t\tret = do_grow(inode, newsize);\n\t\tgoto out;\n\t}\n\n\tgfs2_rs_deltree(ip->i_res);\n\tret = do_shrink(inode, oldsize, newsize);\nout:\n\tput_write_access(inode);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "inode_change_ok",
          "args": [
            "inode",
            "attr"
          ],
          "line": 1760
        },
        "resolved": true,
        "details": {
          "function_name": "inode_change_ok",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/attr.c",
          "lines": "31-81",
          "snippet": "int inode_change_ok(const struct inode *inode, struct iattr *attr)\n{\n\tunsigned int ia_valid = attr->ia_valid;\n\n\t/*\n\t * First check size constraints.  These can't be overriden using\n\t * ATTR_FORCE.\n\t */\n\tif (ia_valid & ATTR_SIZE) {\n\t\tint error = inode_newsize_ok(inode, attr->ia_size);\n\t\tif (error)\n\t\t\treturn error;\n\t}\n\n\t/* If force is set do it anyway. */\n\tif (ia_valid & ATTR_FORCE)\n\t\treturn 0;\n\n\t/* Make sure a caller can chown. */\n\tif ((ia_valid & ATTR_UID) &&\n\t    (!uid_eq(current_fsuid(), inode->i_uid) ||\n\t     !uid_eq(attr->ia_uid, inode->i_uid)) &&\n\t    !capable_wrt_inode_uidgid(inode, CAP_CHOWN))\n\t\treturn -EPERM;\n\n\t/* Make sure caller can chgrp. */\n\tif ((ia_valid & ATTR_GID) &&\n\t    (!uid_eq(current_fsuid(), inode->i_uid) ||\n\t    (!in_group_p(attr->ia_gid) && !gid_eq(attr->ia_gid, inode->i_gid))) &&\n\t    !capable_wrt_inode_uidgid(inode, CAP_CHOWN))\n\t\treturn -EPERM;\n\n\t/* Make sure a caller can chmod. */\n\tif (ia_valid & ATTR_MODE) {\n\t\tif (!inode_owner_or_capable(inode))\n\t\t\treturn -EPERM;\n\t\t/* Also check the setgid bit! */\n\t\tif (!in_group_p((ia_valid & ATTR_GID) ? attr->ia_gid :\n\t\t\t\tinode->i_gid) &&\n\t\t    !capable_wrt_inode_uidgid(inode, CAP_FSETID))\n\t\t\tattr->ia_mode &= ~S_ISGID;\n\t}\n\n\t/* Check for setting the inode time. */\n\tif (ia_valid & (ATTR_MTIME_SET | ATTR_ATIME_SET | ATTR_TIMES_SET)) {\n\t\tif (!inode_owner_or_capable(inode))\n\t\t\treturn -EPERM;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include <linux/ima.h>",
            "#include <linux/evm.h>",
            "#include <linux/security.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/capability.h>",
            "#include <linux/string.h>",
            "#include <linux/mm.h>",
            "#include <linux/time.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ima.h>\n#include <linux/evm.h>\n#include <linux/security.h>\n#include <linux/fcntl.h>\n#include <linux/fsnotify.h>\n#include <linux/capability.h>\n#include <linux/string.h>\n#include <linux/mm.h>\n#include <linux/time.h>\n#include <linux/export.h>\n\nint inode_change_ok(const struct inode *inode, struct iattr *attr)\n{\n\tunsigned int ia_valid = attr->ia_valid;\n\n\t/*\n\t * First check size constraints.  These can't be overriden using\n\t * ATTR_FORCE.\n\t */\n\tif (ia_valid & ATTR_SIZE) {\n\t\tint error = inode_newsize_ok(inode, attr->ia_size);\n\t\tif (error)\n\t\t\treturn error;\n\t}\n\n\t/* If force is set do it anyway. */\n\tif (ia_valid & ATTR_FORCE)\n\t\treturn 0;\n\n\t/* Make sure a caller can chown. */\n\tif ((ia_valid & ATTR_UID) &&\n\t    (!uid_eq(current_fsuid(), inode->i_uid) ||\n\t     !uid_eq(attr->ia_uid, inode->i_uid)) &&\n\t    !capable_wrt_inode_uidgid(inode, CAP_CHOWN))\n\t\treturn -EPERM;\n\n\t/* Make sure caller can chgrp. */\n\tif ((ia_valid & ATTR_GID) &&\n\t    (!uid_eq(current_fsuid(), inode->i_uid) ||\n\t    (!in_group_p(attr->ia_gid) && !gid_eq(attr->ia_gid, inode->i_gid))) &&\n\t    !capable_wrt_inode_uidgid(inode, CAP_CHOWN))\n\t\treturn -EPERM;\n\n\t/* Make sure a caller can chmod. */\n\tif (ia_valid & ATTR_MODE) {\n\t\tif (!inode_owner_or_capable(inode))\n\t\t\treturn -EPERM;\n\t\t/* Also check the setgid bit! */\n\t\tif (!in_group_p((ia_valid & ATTR_GID) ? attr->ia_gid :\n\t\t\t\tinode->i_gid) &&\n\t\t    !capable_wrt_inode_uidgid(inode, CAP_FSETID))\n\t\t\tattr->ia_mode &= ~S_ISGID;\n\t}\n\n\t/* Check for setting the inode time. */\n\tif (ia_valid & (ATTR_MTIME_SET | ATTR_ATIME_SET | ATTR_TIMES_SET)) {\n\t\tif (!inode_owner_or_capable(inode))\n\t\t\treturn -EPERM;\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_APPEND",
          "args": [
            "inode"
          ],
          "line": 1757
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_IMMUTABLE",
          "args": [
            "inode"
          ],
          "line": 1757
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gfs2_glock_nq_init",
          "args": [
            "ip->i_gl",
            "LM_ST_EXCLUSIVE",
            "0",
            "&i_gh"
          ],
          "line": 1752
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_glock_nq_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/glock.h",
          "lines": "204-230",
          "snippet": "extern __printf(2, 3)\nvoid gfs2_print_dbg(struct seq_file *seq, const char *fmt, ...);\n\n/**\n * gfs2_glock_nq_init - initialize a holder and enqueue it on a glock\n * @gl: the glock\n * @state: the state we're requesting\n * @flags: the modifier flags\n * @gh: the holder structure\n *\n * Returns: 0, GLR_*, or errno\n */\n\nstatic inline int gfs2_glock_nq_init(struct gfs2_glock *gl,\n\t\t\t\t     unsigned int state, int flags,\n\t\t\t\t     struct gfs2_holder *gh)\n{\n\tint error;\n\n\tgfs2_holder_init(gl, state, flags, gh);\n\n\terror = gfs2_glock_nq(gh);\n\tif (error)\n\t\tgfs2_holder_uninit(gh);\n\n\treturn error;\n}",
          "includes": [
            "#include \"incore.h\"",
            "#include <linux/parser.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"incore.h\"\n#include <linux/parser.h>\n#include <linux/sched.h>\n\nextern __printf(2, 3)\nvoid gfs2_print_dbg(struct seq_file *seq, const char *fmt, ...);\n\n/**\n * gfs2_glock_nq_init - initialize a holder and enqueue it on a glock\n * @gl: the glock\n * @state: the state we're requesting\n * @flags: the modifier flags\n * @gh: the holder structure\n *\n * Returns: 0, GLR_*, or errno\n */\n\nstatic inline int gfs2_glock_nq_init(struct gfs2_glock *gl,\n\t\t\t\t     unsigned int state, int flags,\n\t\t\t\t     struct gfs2_holder *gh)\n{\n\tint error;\n\n\tgfs2_holder_init(gl, state, flags, gh);\n\n\terror = gfs2_glock_nq(gh);\n\tif (error)\n\t\tgfs2_holder_uninit(gh);\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "gfs2_rs_alloc",
          "args": [
            "ip"
          ],
          "line": 1748
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_rs_alloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/rgrp.c",
          "lines": "602-620",
          "snippet": "int gfs2_rs_alloc(struct gfs2_inode *ip)\n{\n\tint error = 0;\n\n\tdown_write(&ip->i_rw_mutex);\n\tif (ip->i_res)\n\t\tgoto out;\n\n\tip->i_res = kmem_cache_zalloc(gfs2_rsrv_cachep, GFP_NOFS);\n\tif (!ip->i_res) {\n\t\terror = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tRB_CLEAR_NODE(&ip->i_res->rs_node);\nout:\n\tup_write(&ip->i_rw_mutex);\n\treturn error;\n}",
          "includes": [
            "#include \"trace_gfs2.h\"",
            "#include \"inode.h\"",
            "#include \"log.h\"",
            "#include \"util.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"lops.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/random.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/fs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"inode.h\"\n#include \"log.h\"\n#include \"util.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"lops.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/random.h>\n#include <linux/rbtree.h>\n#include <linux/blkdev.h>\n#include <linux/prefetch.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/fs.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nint gfs2_rs_alloc(struct gfs2_inode *ip)\n{\n\tint error = 0;\n\n\tdown_write(&ip->i_rw_mutex);\n\tif (ip->i_res)\n\t\tgoto out;\n\n\tip->i_res = kmem_cache_zalloc(gfs2_rsrv_cachep, GFP_NOFS);\n\tif (!ip->i_res) {\n\t\terror = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tRB_CLEAR_NODE(&ip->i_res->rs_node);\nout:\n\tup_write(&ip->i_rw_mutex);\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "GFS2_I",
          "args": [
            "inode"
          ],
          "line": 1744
        },
        "resolved": true,
        "details": {
          "function_name": "GFS2_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/incore.h",
          "lines": "408-411",
          "snippet": "static inline struct gfs2_inode *GFS2_I(struct inode *inode)\n{\n\treturn container_of(inode, struct gfs2_inode, i_inode);\n}",
          "includes": [
            "#include <linux/lockref.h>",
            "#include <linux/percpu.h>",
            "#include <linux/ktime.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/completion.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/dlm.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/kobject.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/lockref.h>\n#include <linux/percpu.h>\n#include <linux/ktime.h>\n#include <linux/rbtree.h>\n#include <linux/completion.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/buffer_head.h>\n#include <linux/dlm.h>\n#include <linux/workqueue.h>\n#include <linux/kobject.h>\n#include <linux/fs.h>\n\nstatic inline struct gfs2_inode *GFS2_I(struct inode *inode)\n{\n\treturn container_of(inode, struct gfs2_inode, i_inode);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"glops.h\"\n#include \"super.h\"\n#include \"util.h\"\n#include \"trans.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"xattr.h\"\n#include \"dir.h\"\n#include \"bmap.h\"\n#include \"acl.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <asm/uaccess.h>\n#include <linux/security.h>\n#include <linux/fiemap.h>\n#include <linux/crc32.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/posix_acl.h>\n#include <linux/xattr.h>\n#include <linux/mm.h>\n#include <linux/namei.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nstatic int gfs2_setattr(struct dentry *dentry, struct iattr *attr)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tstruct gfs2_inode *ip = GFS2_I(inode);\n\tstruct gfs2_holder i_gh;\n\tint error;\n\n\terror = gfs2_rs_alloc(ip);\n\tif (error)\n\t\treturn error;\n\n\terror = gfs2_glock_nq_init(ip->i_gl, LM_ST_EXCLUSIVE, 0, &i_gh);\n\tif (error)\n\t\treturn error;\n\n\terror = -EPERM;\n\tif (IS_IMMUTABLE(inode) || IS_APPEND(inode))\n\t\tgoto out;\n\n\terror = inode_change_ok(inode, attr);\n\tif (error)\n\t\tgoto out;\n\n\tif (attr->ia_valid & ATTR_SIZE)\n\t\terror = gfs2_setattr_size(inode, attr->ia_size);\n\telse if (attr->ia_valid & (ATTR_UID | ATTR_GID))\n\t\terror = setattr_chown(inode, attr);\n\telse {\n\t\terror = gfs2_setattr_simple(inode, attr);\n\t\tif (!error && attr->ia_valid & ATTR_MODE)\n\t\t\terror = posix_acl_chmod(inode, inode->i_mode);\n\t}\n\nout:\n\tif (!error)\n\t\tmark_inode_dirty(inode);\n\tgfs2_glock_dq_uninit(&i_gh);\n\treturn error;\n}"
  },
  {
    "function_name": "setattr_chown",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/inode.c",
    "lines": "1665-1728",
    "snippet": "static int setattr_chown(struct inode *inode, struct iattr *attr)\n{\n\tstruct gfs2_inode *ip = GFS2_I(inode);\n\tstruct gfs2_sbd *sdp = GFS2_SB(inode);\n\tkuid_t ouid, nuid;\n\tkgid_t ogid, ngid;\n\tint error;\n\n\touid = inode->i_uid;\n\togid = inode->i_gid;\n\tnuid = attr->ia_uid;\n\tngid = attr->ia_gid;\n\n\tif (!(attr->ia_valid & ATTR_UID) || uid_eq(ouid, nuid))\n\t\touid = nuid = NO_UID_QUOTA_CHANGE;\n\tif (!(attr->ia_valid & ATTR_GID) || gid_eq(ogid, ngid))\n\t\togid = ngid = NO_GID_QUOTA_CHANGE;\n\n\terror = get_write_access(inode);\n\tif (error)\n\t\treturn error;\n\n\terror = gfs2_rs_alloc(ip);\n\tif (error)\n\t\tgoto out;\n\n\terror = gfs2_rindex_update(sdp);\n\tif (error)\n\t\tgoto out;\n\n\terror = gfs2_quota_lock(ip, nuid, ngid);\n\tif (error)\n\t\tgoto out;\n\n\tif (!uid_eq(ouid, NO_UID_QUOTA_CHANGE) ||\n\t    !gid_eq(ogid, NO_GID_QUOTA_CHANGE)) {\n\t\terror = gfs2_quota_check(ip, nuid, ngid);\n\t\tif (error)\n\t\t\tgoto out_gunlock_q;\n\t}\n\n\terror = gfs2_trans_begin(sdp, RES_DINODE + 2 * RES_QUOTA, 0);\n\tif (error)\n\t\tgoto out_gunlock_q;\n\n\terror = gfs2_setattr_simple(inode, attr);\n\tif (error)\n\t\tgoto out_end_trans;\n\n\tif (!uid_eq(ouid, NO_UID_QUOTA_CHANGE) ||\n\t    !gid_eq(ogid, NO_GID_QUOTA_CHANGE)) {\n\t\tu64 blocks = gfs2_get_inode_blocks(&ip->i_inode);\n\t\tgfs2_quota_change(ip, -blocks, ouid, ogid);\n\t\tgfs2_quota_change(ip, blocks, nuid, ngid);\n\t}\n\nout_end_trans:\n\tgfs2_trans_end(sdp);\nout_gunlock_q:\n\tgfs2_quota_unlock(ip);\nout:\n\tput_write_access(inode);\n\treturn error;\n}",
    "includes": [
      "#include \"glops.h\"",
      "#include \"super.h\"",
      "#include \"util.h\"",
      "#include \"trans.h\"",
      "#include \"rgrp.h\"",
      "#include \"quota.h\"",
      "#include \"meta_io.h\"",
      "#include \"inode.h\"",
      "#include \"glock.h\"",
      "#include \"xattr.h\"",
      "#include \"dir.h\"",
      "#include \"bmap.h\"",
      "#include \"acl.h\"",
      "#include \"incore.h\"",
      "#include \"gfs2.h\"",
      "#include <asm/uaccess.h>",
      "#include <linux/security.h>",
      "#include <linux/fiemap.h>",
      "#include <linux/crc32.h>",
      "#include <linux/gfs2_ondisk.h>",
      "#include <linux/posix_acl.h>",
      "#include <linux/xattr.h>",
      "#include <linux/mm.h>",
      "#include <linux/namei.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/completion.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "put_write_access",
          "args": [
            "inode"
          ],
          "line": 1726
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gfs2_quota_unlock",
          "args": [
            "ip"
          ],
          "line": 1724
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_quota_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/quota.c",
          "lines": "1033-1081",
          "snippet": "void gfs2_quota_unlock(struct gfs2_inode *ip)\n{\n\tstruct gfs2_sbd *sdp = GFS2_SB(&ip->i_inode);\n\tstruct gfs2_quota_data *qda[4];\n\tunsigned int count = 0;\n\tunsigned int x;\n\tint found;\n\n\tif (!test_and_clear_bit(GIF_QD_LOCKED, &ip->i_flags))\n\t\tgoto out;\n\n\tfor (x = 0; x < ip->i_res->rs_qa_qd_num; x++) {\n\t\tstruct gfs2_quota_data *qd;\n\t\tint sync;\n\n\t\tqd = ip->i_res->rs_qa_qd[x];\n\t\tsync = need_sync(qd);\n\n\t\tgfs2_glock_dq_uninit(&ip->i_res->rs_qa_qd_ghs[x]);\n\t\tif (!sync)\n\t\t\tcontinue;\n\n\t\tspin_lock(&qd_lock);\n\t\tfound = qd_check_sync(sdp, qd, NULL);\n\t\tspin_unlock(&qd_lock);\n\n\t\tif (!found)\n\t\t\tcontinue;\n\n\t\tgfs2_assert_warn(sdp, qd->qd_change_sync);\n\t\tif (bh_get(qd)) {\n\t\t\tclear_bit(QDF_LOCKED, &qd->qd_flags);\n\t\t\tslot_put(qd);\n\t\t\tqd_put(qd);\n\t\t\tcontinue;\n\t\t}\n\n\t\tqda[count++] = qd;\n\t}\n\n\tif (count) {\n\t\tdo_sync(count, qda);\n\t\tfor (x = 0; x < count; x++)\n\t\t\tqd_unlock(qda[x]);\n\t}\n\nout:\n\tgfs2_quota_unhold(ip);\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"inode.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"log.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"bmap.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/jhash.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/lockref.h>",
            "#include <linux/dqblk_xfs.h>",
            "#include <linux/quota.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/bio.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_SPINLOCK(qd_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"inode.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"log.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/vmalloc.h>\n#include <linux/jhash.h>\n#include <linux/bit_spinlock.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/list_lru.h>\n#include <linux/lockref.h>\n#include <linux/dqblk_xfs.h>\n#include <linux/quota.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/bio.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic DEFINE_SPINLOCK(qd_lock);\n\nvoid gfs2_quota_unlock(struct gfs2_inode *ip)\n{\n\tstruct gfs2_sbd *sdp = GFS2_SB(&ip->i_inode);\n\tstruct gfs2_quota_data *qda[4];\n\tunsigned int count = 0;\n\tunsigned int x;\n\tint found;\n\n\tif (!test_and_clear_bit(GIF_QD_LOCKED, &ip->i_flags))\n\t\tgoto out;\n\n\tfor (x = 0; x < ip->i_res->rs_qa_qd_num; x++) {\n\t\tstruct gfs2_quota_data *qd;\n\t\tint sync;\n\n\t\tqd = ip->i_res->rs_qa_qd[x];\n\t\tsync = need_sync(qd);\n\n\t\tgfs2_glock_dq_uninit(&ip->i_res->rs_qa_qd_ghs[x]);\n\t\tif (!sync)\n\t\t\tcontinue;\n\n\t\tspin_lock(&qd_lock);\n\t\tfound = qd_check_sync(sdp, qd, NULL);\n\t\tspin_unlock(&qd_lock);\n\n\t\tif (!found)\n\t\t\tcontinue;\n\n\t\tgfs2_assert_warn(sdp, qd->qd_change_sync);\n\t\tif (bh_get(qd)) {\n\t\t\tclear_bit(QDF_LOCKED, &qd->qd_flags);\n\t\t\tslot_put(qd);\n\t\t\tqd_put(qd);\n\t\t\tcontinue;\n\t\t}\n\n\t\tqda[count++] = qd;\n\t}\n\n\tif (count) {\n\t\tdo_sync(count, qda);\n\t\tfor (x = 0; x < count; x++)\n\t\t\tqd_unlock(qda[x]);\n\t}\n\nout:\n\tgfs2_quota_unhold(ip);\n}"
        }
      },
      {
        "call_info": {
          "callee": "gfs2_trans_end",
          "args": [
            "sdp"
          ],
          "line": 1722
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_trans_end",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/trans.c",
          "lines": "88-123",
          "snippet": "void gfs2_trans_end(struct gfs2_sbd *sdp)\n{\n\tstruct gfs2_trans *tr = current->journal_info;\n\ts64 nbuf;\n\tint alloced = tr->tr_alloced;\n\n\tBUG_ON(!tr);\n\tcurrent->journal_info = NULL;\n\n\tif (!tr->tr_touched) {\n\t\tgfs2_log_release(sdp, tr->tr_reserved);\n\t\tif (alloced) {\n\t\t\tkfree(tr);\n\t\t\tsb_end_intwrite(sdp->sd_vfs);\n\t\t}\n\t\treturn;\n\t}\n\n\tnbuf = tr->tr_num_buf_new + tr->tr_num_databuf_new;\n\tnbuf -= tr->tr_num_buf_rm;\n\tnbuf -= tr->tr_num_databuf_rm;\n\n\tif (gfs2_assert_withdraw(sdp, (nbuf <= tr->tr_blocks) &&\n\t\t\t\t       (tr->tr_num_revoke <= tr->tr_revokes)))\n\t\tgfs2_print_trans(tr);\n\n\tgfs2_log_commit(sdp, tr);\n\tif (alloced && !tr->tr_attached)\n\t\t\tkfree(tr);\n\tup_read(&sdp->sd_log_flush_lock);\n\n\tif (sdp->sd_vfs->s_flags & MS_SYNCHRONOUS)\n\t\tgfs2_log_flush(sdp, NULL, NORMAL_FLUSH);\n\tif (alloced)\n\t\tsb_end_intwrite(sdp->sd_vfs);\n}",
          "includes": [
            "#include \"trace_gfs2.h\"",
            "#include \"util.h\"",
            "#include \"trans.h\"",
            "#include \"meta_io.h\"",
            "#include \"lops.h\"",
            "#include \"log.h\"",
            "#include \"inode.h\"",
            "#include \"glock.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"util.h\"\n#include \"trans.h\"\n#include \"meta_io.h\"\n#include \"lops.h\"\n#include \"log.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/gfs2_ondisk.h>\n#include <linux/kallsyms.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nvoid gfs2_trans_end(struct gfs2_sbd *sdp)\n{\n\tstruct gfs2_trans *tr = current->journal_info;\n\ts64 nbuf;\n\tint alloced = tr->tr_alloced;\n\n\tBUG_ON(!tr);\n\tcurrent->journal_info = NULL;\n\n\tif (!tr->tr_touched) {\n\t\tgfs2_log_release(sdp, tr->tr_reserved);\n\t\tif (alloced) {\n\t\t\tkfree(tr);\n\t\t\tsb_end_intwrite(sdp->sd_vfs);\n\t\t}\n\t\treturn;\n\t}\n\n\tnbuf = tr->tr_num_buf_new + tr->tr_num_databuf_new;\n\tnbuf -= tr->tr_num_buf_rm;\n\tnbuf -= tr->tr_num_databuf_rm;\n\n\tif (gfs2_assert_withdraw(sdp, (nbuf <= tr->tr_blocks) &&\n\t\t\t\t       (tr->tr_num_revoke <= tr->tr_revokes)))\n\t\tgfs2_print_trans(tr);\n\n\tgfs2_log_commit(sdp, tr);\n\tif (alloced && !tr->tr_attached)\n\t\t\tkfree(tr);\n\tup_read(&sdp->sd_log_flush_lock);\n\n\tif (sdp->sd_vfs->s_flags & MS_SYNCHRONOUS)\n\t\tgfs2_log_flush(sdp, NULL, NORMAL_FLUSH);\n\tif (alloced)\n\t\tsb_end_intwrite(sdp->sd_vfs);\n}"
        }
      },
      {
        "call_info": {
          "callee": "gfs2_quota_change",
          "args": [
            "ip",
            "blocks",
            "nuid",
            "ngid"
          ],
          "line": 1718
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_quota_change",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/quota.c",
          "lines": "1145-1164",
          "snippet": "void gfs2_quota_change(struct gfs2_inode *ip, s64 change,\n\t\t       kuid_t uid, kgid_t gid)\n{\n\tstruct gfs2_quota_data *qd;\n\tunsigned int x;\n\n\tif (gfs2_assert_warn(GFS2_SB(&ip->i_inode), change))\n\t\treturn;\n\tif (ip->i_diskflags & GFS2_DIF_SYSTEM)\n\t\treturn;\n\n\tfor (x = 0; x < ip->i_res->rs_qa_qd_num; x++) {\n\t\tqd = ip->i_res->rs_qa_qd[x];\n\n\t\tif (qid_eq(qd->qd_id, make_kqid_uid(uid)) ||\n\t\t    qid_eq(qd->qd_id, make_kqid_gid(gid))) {\n\t\t\tdo_qc(qd, change);\n\t\t}\n\t}\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"inode.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"log.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"bmap.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/jhash.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/lockref.h>",
            "#include <linux/dqblk_xfs.h>",
            "#include <linux/quota.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/bio.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"inode.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"log.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/vmalloc.h>\n#include <linux/jhash.h>\n#include <linux/bit_spinlock.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/list_lru.h>\n#include <linux/lockref.h>\n#include <linux/dqblk_xfs.h>\n#include <linux/quota.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/bio.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nvoid gfs2_quota_change(struct gfs2_inode *ip, s64 change,\n\t\t       kuid_t uid, kgid_t gid)\n{\n\tstruct gfs2_quota_data *qd;\n\tunsigned int x;\n\n\tif (gfs2_assert_warn(GFS2_SB(&ip->i_inode), change))\n\t\treturn;\n\tif (ip->i_diskflags & GFS2_DIF_SYSTEM)\n\t\treturn;\n\n\tfor (x = 0; x < ip->i_res->rs_qa_qd_num; x++) {\n\t\tqd = ip->i_res->rs_qa_qd[x];\n\n\t\tif (qid_eq(qd->qd_id, make_kqid_uid(uid)) ||\n\t\t    qid_eq(qd->qd_id, make_kqid_gid(gid))) {\n\t\t\tdo_qc(qd, change);\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "gfs2_get_inode_blocks",
          "args": [
            "&ip->i_inode"
          ],
          "line": 1716
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_get_inode_blocks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/inode.h",
          "lines": "56-60",
          "snippet": "static inline u64 gfs2_get_inode_blocks(const struct inode *inode)\n{\n\treturn inode->i_blocks >>\n\t\t(GFS2_SB(inode)->sd_sb.sb_bsize_shift - GFS2_BASIC_BLOCK_SHIFT);\n}",
          "includes": [
            "#include \"util.h\"",
            "#include <linux/mm.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include <linux/mm.h>\n#include <linux/buffer_head.h>\n#include <linux/fs.h>\n\nstatic inline u64 gfs2_get_inode_blocks(const struct inode *inode)\n{\n\treturn inode->i_blocks >>\n\t\t(GFS2_SB(inode)->sd_sb.sb_bsize_shift - GFS2_BASIC_BLOCK_SHIFT);\n}"
        }
      },
      {
        "call_info": {
          "callee": "gid_eq",
          "args": [
            "ogid",
            "NO_GID_QUOTA_CHANGE"
          ],
          "line": 1715
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "uid_eq",
          "args": [
            "ouid",
            "NO_UID_QUOTA_CHANGE"
          ],
          "line": 1714
        },
        "resolved": true,
        "details": {
          "function_name": "uuid_equal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/uuid.c",
          "lines": "59-63",
          "snippet": "int\nuuid_equal(uuid_t *uuid1, uuid_t *uuid2)\n{\n\treturn memcmp(uuid1, uuid2, sizeof(uuid_t)) ? 0 : 1;\n}",
          "includes": [
            "#include <xfs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <xfs.h>\n\nint\nuuid_equal(uuid_t *uuid1, uuid_t *uuid2)\n{\n\treturn memcmp(uuid1, uuid2, sizeof(uuid_t)) ? 0 : 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "gfs2_setattr_simple",
          "args": [
            "inode",
            "attr"
          ],
          "line": 1710
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_setattr_simple",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/inode.c",
          "lines": "1649-1663",
          "snippet": "int gfs2_setattr_simple(struct inode *inode, struct iattr *attr)\n{\n\tint error;\n\n\tif (current->journal_info)\n\t\treturn __gfs2_setattr_simple(inode, attr);\n\n\terror = gfs2_trans_begin(GFS2_SB(inode), RES_DINODE, 0);\n\tif (error)\n\t\treturn error;\n\n\terror = __gfs2_setattr_simple(inode, attr);\n\tgfs2_trans_end(GFS2_SB(inode));\n\treturn error;\n}",
          "includes": [
            "#include \"glops.h\"",
            "#include \"super.h\"",
            "#include \"util.h\"",
            "#include \"trans.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"inode.h\"",
            "#include \"glock.h\"",
            "#include \"xattr.h\"",
            "#include \"dir.h\"",
            "#include \"bmap.h\"",
            "#include \"acl.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/security.h>",
            "#include <linux/fiemap.h>",
            "#include <linux/crc32.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/xattr.h>",
            "#include <linux/mm.h>",
            "#include <linux/namei.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glops.h\"\n#include \"super.h\"\n#include \"util.h\"\n#include \"trans.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"xattr.h\"\n#include \"dir.h\"\n#include \"bmap.h\"\n#include \"acl.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <asm/uaccess.h>\n#include <linux/security.h>\n#include <linux/fiemap.h>\n#include <linux/crc32.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/posix_acl.h>\n#include <linux/xattr.h>\n#include <linux/mm.h>\n#include <linux/namei.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nint gfs2_setattr_simple(struct inode *inode, struct iattr *attr)\n{\n\tint error;\n\n\tif (current->journal_info)\n\t\treturn __gfs2_setattr_simple(inode, attr);\n\n\terror = gfs2_trans_begin(GFS2_SB(inode), RES_DINODE, 0);\n\tif (error)\n\t\treturn error;\n\n\terror = __gfs2_setattr_simple(inode, attr);\n\tgfs2_trans_end(GFS2_SB(inode));\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "gfs2_trans_begin",
          "args": [
            "sdp",
            "RES_DINODE + 2 * RES_QUOTA",
            "0"
          ],
          "line": 1706
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_trans_begin",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/trans.c",
          "lines": "31-75",
          "snippet": "int gfs2_trans_begin(struct gfs2_sbd *sdp, unsigned int blocks,\n\t\t     unsigned int revokes)\n{\n\tstruct gfs2_trans *tr;\n\tint error;\n\n\tBUG_ON(current->journal_info);\n\tBUG_ON(blocks == 0 && revokes == 0);\n\n\tif (!test_bit(SDF_JOURNAL_LIVE, &sdp->sd_flags))\n\t\treturn -EROFS;\n\n\ttr = kzalloc(sizeof(struct gfs2_trans), GFP_NOFS);\n\tif (!tr)\n\t\treturn -ENOMEM;\n\n\ttr->tr_ip = _RET_IP_;\n\ttr->tr_blocks = blocks;\n\ttr->tr_revokes = revokes;\n\ttr->tr_reserved = 1;\n\ttr->tr_alloced = 1;\n\tif (blocks)\n\t\ttr->tr_reserved += 6 + blocks;\n\tif (revokes)\n\t\ttr->tr_reserved += gfs2_struct2blk(sdp, revokes,\n\t\t\t\t\t\t   sizeof(u64));\n\tINIT_LIST_HEAD(&tr->tr_databuf);\n\tINIT_LIST_HEAD(&tr->tr_buf);\n\n\tsb_start_intwrite(sdp->sd_vfs);\n\n\terror = gfs2_log_reserve(sdp, tr->tr_reserved);\n\tif (error)\n\t\tgoto fail;\n\n\tcurrent->journal_info = tr;\n\n\treturn 0;\n\nfail:\n\tsb_end_intwrite(sdp->sd_vfs);\n\tkfree(tr);\n\n\treturn error;\n}",
          "includes": [
            "#include \"trace_gfs2.h\"",
            "#include \"util.h\"",
            "#include \"trans.h\"",
            "#include \"meta_io.h\"",
            "#include \"lops.h\"",
            "#include \"log.h\"",
            "#include \"inode.h\"",
            "#include \"glock.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"util.h\"\n#include \"trans.h\"\n#include \"meta_io.h\"\n#include \"lops.h\"\n#include \"log.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/gfs2_ondisk.h>\n#include <linux/kallsyms.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nint gfs2_trans_begin(struct gfs2_sbd *sdp, unsigned int blocks,\n\t\t     unsigned int revokes)\n{\n\tstruct gfs2_trans *tr;\n\tint error;\n\n\tBUG_ON(current->journal_info);\n\tBUG_ON(blocks == 0 && revokes == 0);\n\n\tif (!test_bit(SDF_JOURNAL_LIVE, &sdp->sd_flags))\n\t\treturn -EROFS;\n\n\ttr = kzalloc(sizeof(struct gfs2_trans), GFP_NOFS);\n\tif (!tr)\n\t\treturn -ENOMEM;\n\n\ttr->tr_ip = _RET_IP_;\n\ttr->tr_blocks = blocks;\n\ttr->tr_revokes = revokes;\n\ttr->tr_reserved = 1;\n\ttr->tr_alloced = 1;\n\tif (blocks)\n\t\ttr->tr_reserved += 6 + blocks;\n\tif (revokes)\n\t\ttr->tr_reserved += gfs2_struct2blk(sdp, revokes,\n\t\t\t\t\t\t   sizeof(u64));\n\tINIT_LIST_HEAD(&tr->tr_databuf);\n\tINIT_LIST_HEAD(&tr->tr_buf);\n\n\tsb_start_intwrite(sdp->sd_vfs);\n\n\terror = gfs2_log_reserve(sdp, tr->tr_reserved);\n\tif (error)\n\t\tgoto fail;\n\n\tcurrent->journal_info = tr;\n\n\treturn 0;\n\nfail:\n\tsb_end_intwrite(sdp->sd_vfs);\n\tkfree(tr);\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "gfs2_quota_check",
          "args": [
            "ip",
            "nuid",
            "ngid"
          ],
          "line": 1701
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_quota_check",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/quota.c",
          "lines": "1097-1143",
          "snippet": "int gfs2_quota_check(struct gfs2_inode *ip, kuid_t uid, kgid_t gid)\n{\n\tstruct gfs2_sbd *sdp = GFS2_SB(&ip->i_inode);\n\tstruct gfs2_quota_data *qd;\n\ts64 value;\n\tunsigned int x;\n\tint error = 0;\n\n\tif (!test_bit(GIF_QD_LOCKED, &ip->i_flags))\n\t\treturn 0;\n\n        if (sdp->sd_args.ar_quota != GFS2_QUOTA_ON)\n                return 0;\n\n\tfor (x = 0; x < ip->i_res->rs_qa_qd_num; x++) {\n\t\tqd = ip->i_res->rs_qa_qd[x];\n\n\t\tif (!(qid_eq(qd->qd_id, make_kqid_uid(uid)) ||\n\t\t      qid_eq(qd->qd_id, make_kqid_gid(gid))))\n\t\t\tcontinue;\n\n\t\tvalue = (s64)be64_to_cpu(qd->qd_qb.qb_value);\n\t\tspin_lock(&qd_lock);\n\t\tvalue += qd->qd_change;\n\t\tspin_unlock(&qd_lock);\n\n\t\tif (be64_to_cpu(qd->qd_qb.qb_limit) && (s64)be64_to_cpu(qd->qd_qb.qb_limit) < value) {\n\t\t\tprint_message(qd, \"exceeded\");\n\t\t\tquota_send_warning(qd->qd_id,\n\t\t\t\t\t   sdp->sd_vfs->s_dev, QUOTA_NL_BHARDWARN);\n\n\t\t\terror = -EDQUOT;\n\t\t\tbreak;\n\t\t} else if (be64_to_cpu(qd->qd_qb.qb_warn) &&\n\t\t\t   (s64)be64_to_cpu(qd->qd_qb.qb_warn) < value &&\n\t\t\t   time_after_eq(jiffies, qd->qd_last_warn +\n\t\t\t\t\t gfs2_tune_get(sdp,\n\t\t\t\t\t\tgt_quota_warn_period) * HZ)) {\n\t\t\tquota_send_warning(qd->qd_id,\n\t\t\t\t\t   sdp->sd_vfs->s_dev, QUOTA_NL_BSOFTWARN);\n\t\t\terror = print_message(qd, \"warning\");\n\t\t\tqd->qd_last_warn = jiffies;\n\t\t}\n\t}\n\n\treturn error;\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"inode.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"log.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"bmap.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/jhash.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/lockref.h>",
            "#include <linux/dqblk_xfs.h>",
            "#include <linux/quota.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/bio.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_SPINLOCK(qd_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"inode.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"log.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/vmalloc.h>\n#include <linux/jhash.h>\n#include <linux/bit_spinlock.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/list_lru.h>\n#include <linux/lockref.h>\n#include <linux/dqblk_xfs.h>\n#include <linux/quota.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/bio.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic DEFINE_SPINLOCK(qd_lock);\n\nint gfs2_quota_check(struct gfs2_inode *ip, kuid_t uid, kgid_t gid)\n{\n\tstruct gfs2_sbd *sdp = GFS2_SB(&ip->i_inode);\n\tstruct gfs2_quota_data *qd;\n\ts64 value;\n\tunsigned int x;\n\tint error = 0;\n\n\tif (!test_bit(GIF_QD_LOCKED, &ip->i_flags))\n\t\treturn 0;\n\n        if (sdp->sd_args.ar_quota != GFS2_QUOTA_ON)\n                return 0;\n\n\tfor (x = 0; x < ip->i_res->rs_qa_qd_num; x++) {\n\t\tqd = ip->i_res->rs_qa_qd[x];\n\n\t\tif (!(qid_eq(qd->qd_id, make_kqid_uid(uid)) ||\n\t\t      qid_eq(qd->qd_id, make_kqid_gid(gid))))\n\t\t\tcontinue;\n\n\t\tvalue = (s64)be64_to_cpu(qd->qd_qb.qb_value);\n\t\tspin_lock(&qd_lock);\n\t\tvalue += qd->qd_change;\n\t\tspin_unlock(&qd_lock);\n\n\t\tif (be64_to_cpu(qd->qd_qb.qb_limit) && (s64)be64_to_cpu(qd->qd_qb.qb_limit) < value) {\n\t\t\tprint_message(qd, \"exceeded\");\n\t\t\tquota_send_warning(qd->qd_id,\n\t\t\t\t\t   sdp->sd_vfs->s_dev, QUOTA_NL_BHARDWARN);\n\n\t\t\terror = -EDQUOT;\n\t\t\tbreak;\n\t\t} else if (be64_to_cpu(qd->qd_qb.qb_warn) &&\n\t\t\t   (s64)be64_to_cpu(qd->qd_qb.qb_warn) < value &&\n\t\t\t   time_after_eq(jiffies, qd->qd_last_warn +\n\t\t\t\t\t gfs2_tune_get(sdp,\n\t\t\t\t\t\tgt_quota_warn_period) * HZ)) {\n\t\t\tquota_send_warning(qd->qd_id,\n\t\t\t\t\t   sdp->sd_vfs->s_dev, QUOTA_NL_BSOFTWARN);\n\t\t\terror = print_message(qd, \"warning\");\n\t\t\tqd->qd_last_warn = jiffies;\n\t\t}\n\t}\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "gid_eq",
          "args": [
            "ogid",
            "NO_GID_QUOTA_CHANGE"
          ],
          "line": 1700
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gfs2_quota_lock",
          "args": [
            "ip",
            "nuid",
            "ngid"
          ],
          "line": 1695
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_quota_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/quota.c",
          "lines": "958-995",
          "snippet": "int gfs2_quota_lock(struct gfs2_inode *ip, kuid_t uid, kgid_t gid)\n{\n\tstruct gfs2_sbd *sdp = GFS2_SB(&ip->i_inode);\n\tstruct gfs2_quota_data *qd;\n\tunsigned int x;\n\tint error = 0;\n\n\terror = gfs2_quota_hold(ip, uid, gid);\n\tif (error)\n\t\treturn error;\n\n\tif (capable(CAP_SYS_RESOURCE) ||\n\t    sdp->sd_args.ar_quota != GFS2_QUOTA_ON)\n\t\treturn 0;\n\n\tsort(ip->i_res->rs_qa_qd, ip->i_res->rs_qa_qd_num,\n\t     sizeof(struct gfs2_quota_data *), sort_qd, NULL);\n\n\tfor (x = 0; x < ip->i_res->rs_qa_qd_num; x++) {\n\t\tint force = NO_FORCE;\n\t\tqd = ip->i_res->rs_qa_qd[x];\n\t\tif (test_and_clear_bit(QDF_REFRESH, &qd->qd_flags))\n\t\t\tforce = FORCE;\n\t\terror = do_glock(qd, force, &ip->i_res->rs_qa_qd_ghs[x]);\n\t\tif (error)\n\t\t\tbreak;\n\t}\n\n\tif (!error)\n\t\tset_bit(GIF_QD_LOCKED, &ip->i_flags);\n\telse {\n\t\twhile (x--)\n\t\t\tgfs2_glock_dq_uninit(&ip->i_res->rs_qa_qd_ghs[x]);\n\t\tgfs2_quota_unhold(ip);\n\t}\n\n\treturn error;\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"inode.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"log.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"bmap.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/jhash.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/lockref.h>",
            "#include <linux/dqblk_xfs.h>",
            "#include <linux/quota.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/bio.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"inode.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"log.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/vmalloc.h>\n#include <linux/jhash.h>\n#include <linux/bit_spinlock.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/list_lru.h>\n#include <linux/lockref.h>\n#include <linux/dqblk_xfs.h>\n#include <linux/quota.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/bio.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nint gfs2_quota_lock(struct gfs2_inode *ip, kuid_t uid, kgid_t gid)\n{\n\tstruct gfs2_sbd *sdp = GFS2_SB(&ip->i_inode);\n\tstruct gfs2_quota_data *qd;\n\tunsigned int x;\n\tint error = 0;\n\n\terror = gfs2_quota_hold(ip, uid, gid);\n\tif (error)\n\t\treturn error;\n\n\tif (capable(CAP_SYS_RESOURCE) ||\n\t    sdp->sd_args.ar_quota != GFS2_QUOTA_ON)\n\t\treturn 0;\n\n\tsort(ip->i_res->rs_qa_qd, ip->i_res->rs_qa_qd_num,\n\t     sizeof(struct gfs2_quota_data *), sort_qd, NULL);\n\n\tfor (x = 0; x < ip->i_res->rs_qa_qd_num; x++) {\n\t\tint force = NO_FORCE;\n\t\tqd = ip->i_res->rs_qa_qd[x];\n\t\tif (test_and_clear_bit(QDF_REFRESH, &qd->qd_flags))\n\t\t\tforce = FORCE;\n\t\terror = do_glock(qd, force, &ip->i_res->rs_qa_qd_ghs[x]);\n\t\tif (error)\n\t\t\tbreak;\n\t}\n\n\tif (!error)\n\t\tset_bit(GIF_QD_LOCKED, &ip->i_flags);\n\telse {\n\t\twhile (x--)\n\t\t\tgfs2_glock_dq_uninit(&ip->i_res->rs_qa_qd_ghs[x]);\n\t\tgfs2_quota_unhold(ip);\n\t}\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "gfs2_rindex_update",
          "args": [
            "sdp"
          ],
          "line": 1691
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_rindex_update",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/rgrp.c",
          "lines": "1029-1052",
          "snippet": "int gfs2_rindex_update(struct gfs2_sbd *sdp)\n{\n\tstruct gfs2_inode *ip = GFS2_I(sdp->sd_rindex);\n\tstruct gfs2_glock *gl = ip->i_gl;\n\tstruct gfs2_holder ri_gh;\n\tint error = 0;\n\tint unlock_required = 0;\n\n\t/* Read new copy from disk if we don't have the latest */\n\tif (!sdp->sd_rindex_uptodate) {\n\t\tif (!gfs2_glock_is_locked_by_me(gl)) {\n\t\t\terror = gfs2_glock_nq_init(gl, LM_ST_SHARED, 0, &ri_gh);\n\t\t\tif (error)\n\t\t\t\treturn error;\n\t\t\tunlock_required = 1;\n\t\t}\n\t\tif (!sdp->sd_rindex_uptodate)\n\t\t\terror = gfs2_ri_update(ip);\n\t\tif (unlock_required)\n\t\t\tgfs2_glock_dq_uninit(&ri_gh);\n\t}\n\n\treturn error;\n}",
          "includes": [
            "#include \"trace_gfs2.h\"",
            "#include \"inode.h\"",
            "#include \"log.h\"",
            "#include \"util.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"lops.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/random.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/fs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"inode.h\"\n#include \"log.h\"\n#include \"util.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"lops.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/random.h>\n#include <linux/rbtree.h>\n#include <linux/blkdev.h>\n#include <linux/prefetch.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/fs.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nint gfs2_rindex_update(struct gfs2_sbd *sdp)\n{\n\tstruct gfs2_inode *ip = GFS2_I(sdp->sd_rindex);\n\tstruct gfs2_glock *gl = ip->i_gl;\n\tstruct gfs2_holder ri_gh;\n\tint error = 0;\n\tint unlock_required = 0;\n\n\t/* Read new copy from disk if we don't have the latest */\n\tif (!sdp->sd_rindex_uptodate) {\n\t\tif (!gfs2_glock_is_locked_by_me(gl)) {\n\t\t\terror = gfs2_glock_nq_init(gl, LM_ST_SHARED, 0, &ri_gh);\n\t\t\tif (error)\n\t\t\t\treturn error;\n\t\t\tunlock_required = 1;\n\t\t}\n\t\tif (!sdp->sd_rindex_uptodate)\n\t\t\terror = gfs2_ri_update(ip);\n\t\tif (unlock_required)\n\t\t\tgfs2_glock_dq_uninit(&ri_gh);\n\t}\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "gfs2_rs_alloc",
          "args": [
            "ip"
          ],
          "line": 1687
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_rs_alloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/rgrp.c",
          "lines": "602-620",
          "snippet": "int gfs2_rs_alloc(struct gfs2_inode *ip)\n{\n\tint error = 0;\n\n\tdown_write(&ip->i_rw_mutex);\n\tif (ip->i_res)\n\t\tgoto out;\n\n\tip->i_res = kmem_cache_zalloc(gfs2_rsrv_cachep, GFP_NOFS);\n\tif (!ip->i_res) {\n\t\terror = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tRB_CLEAR_NODE(&ip->i_res->rs_node);\nout:\n\tup_write(&ip->i_rw_mutex);\n\treturn error;\n}",
          "includes": [
            "#include \"trace_gfs2.h\"",
            "#include \"inode.h\"",
            "#include \"log.h\"",
            "#include \"util.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"lops.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/random.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/fs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"inode.h\"\n#include \"log.h\"\n#include \"util.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"lops.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/random.h>\n#include <linux/rbtree.h>\n#include <linux/blkdev.h>\n#include <linux/prefetch.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/fs.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nint gfs2_rs_alloc(struct gfs2_inode *ip)\n{\n\tint error = 0;\n\n\tdown_write(&ip->i_rw_mutex);\n\tif (ip->i_res)\n\t\tgoto out;\n\n\tip->i_res = kmem_cache_zalloc(gfs2_rsrv_cachep, GFP_NOFS);\n\tif (!ip->i_res) {\n\t\terror = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tRB_CLEAR_NODE(&ip->i_res->rs_node);\nout:\n\tup_write(&ip->i_rw_mutex);\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_write_access",
          "args": [
            "inode"
          ],
          "line": 1683
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gid_eq",
          "args": [
            "ogid",
            "ngid"
          ],
          "line": 1680
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GFS2_SB",
          "args": [
            "inode"
          ],
          "line": 1668
        },
        "resolved": true,
        "details": {
          "function_name": "GFS2_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/incore.h",
          "lines": "413-416",
          "snippet": "static inline struct gfs2_sbd *GFS2_SB(const struct inode *inode)\n{\n\treturn inode->i_sb->s_fs_info;\n}",
          "includes": [
            "#include <linux/lockref.h>",
            "#include <linux/percpu.h>",
            "#include <linux/ktime.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/completion.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/dlm.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/kobject.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/lockref.h>\n#include <linux/percpu.h>\n#include <linux/ktime.h>\n#include <linux/rbtree.h>\n#include <linux/completion.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/buffer_head.h>\n#include <linux/dlm.h>\n#include <linux/workqueue.h>\n#include <linux/kobject.h>\n#include <linux/fs.h>\n\nstatic inline struct gfs2_sbd *GFS2_SB(const struct inode *inode)\n{\n\treturn inode->i_sb->s_fs_info;\n}"
        }
      },
      {
        "call_info": {
          "callee": "GFS2_I",
          "args": [
            "inode"
          ],
          "line": 1667
        },
        "resolved": true,
        "details": {
          "function_name": "GFS2_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/incore.h",
          "lines": "408-411",
          "snippet": "static inline struct gfs2_inode *GFS2_I(struct inode *inode)\n{\n\treturn container_of(inode, struct gfs2_inode, i_inode);\n}",
          "includes": [
            "#include <linux/lockref.h>",
            "#include <linux/percpu.h>",
            "#include <linux/ktime.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/completion.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/dlm.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/kobject.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/lockref.h>\n#include <linux/percpu.h>\n#include <linux/ktime.h>\n#include <linux/rbtree.h>\n#include <linux/completion.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/buffer_head.h>\n#include <linux/dlm.h>\n#include <linux/workqueue.h>\n#include <linux/kobject.h>\n#include <linux/fs.h>\n\nstatic inline struct gfs2_inode *GFS2_I(struct inode *inode)\n{\n\treturn container_of(inode, struct gfs2_inode, i_inode);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"glops.h\"\n#include \"super.h\"\n#include \"util.h\"\n#include \"trans.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"xattr.h\"\n#include \"dir.h\"\n#include \"bmap.h\"\n#include \"acl.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <asm/uaccess.h>\n#include <linux/security.h>\n#include <linux/fiemap.h>\n#include <linux/crc32.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/posix_acl.h>\n#include <linux/xattr.h>\n#include <linux/mm.h>\n#include <linux/namei.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nstatic int setattr_chown(struct inode *inode, struct iattr *attr)\n{\n\tstruct gfs2_inode *ip = GFS2_I(inode);\n\tstruct gfs2_sbd *sdp = GFS2_SB(inode);\n\tkuid_t ouid, nuid;\n\tkgid_t ogid, ngid;\n\tint error;\n\n\touid = inode->i_uid;\n\togid = inode->i_gid;\n\tnuid = attr->ia_uid;\n\tngid = attr->ia_gid;\n\n\tif (!(attr->ia_valid & ATTR_UID) || uid_eq(ouid, nuid))\n\t\touid = nuid = NO_UID_QUOTA_CHANGE;\n\tif (!(attr->ia_valid & ATTR_GID) || gid_eq(ogid, ngid))\n\t\togid = ngid = NO_GID_QUOTA_CHANGE;\n\n\terror = get_write_access(inode);\n\tif (error)\n\t\treturn error;\n\n\terror = gfs2_rs_alloc(ip);\n\tif (error)\n\t\tgoto out;\n\n\terror = gfs2_rindex_update(sdp);\n\tif (error)\n\t\tgoto out;\n\n\terror = gfs2_quota_lock(ip, nuid, ngid);\n\tif (error)\n\t\tgoto out;\n\n\tif (!uid_eq(ouid, NO_UID_QUOTA_CHANGE) ||\n\t    !gid_eq(ogid, NO_GID_QUOTA_CHANGE)) {\n\t\terror = gfs2_quota_check(ip, nuid, ngid);\n\t\tif (error)\n\t\t\tgoto out_gunlock_q;\n\t}\n\n\terror = gfs2_trans_begin(sdp, RES_DINODE + 2 * RES_QUOTA, 0);\n\tif (error)\n\t\tgoto out_gunlock_q;\n\n\terror = gfs2_setattr_simple(inode, attr);\n\tif (error)\n\t\tgoto out_end_trans;\n\n\tif (!uid_eq(ouid, NO_UID_QUOTA_CHANGE) ||\n\t    !gid_eq(ogid, NO_GID_QUOTA_CHANGE)) {\n\t\tu64 blocks = gfs2_get_inode_blocks(&ip->i_inode);\n\t\tgfs2_quota_change(ip, -blocks, ouid, ogid);\n\t\tgfs2_quota_change(ip, blocks, nuid, ngid);\n\t}\n\nout_end_trans:\n\tgfs2_trans_end(sdp);\nout_gunlock_q:\n\tgfs2_quota_unlock(ip);\nout:\n\tput_write_access(inode);\n\treturn error;\n}"
  },
  {
    "function_name": "gfs2_setattr_simple",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/inode.c",
    "lines": "1649-1663",
    "snippet": "int gfs2_setattr_simple(struct inode *inode, struct iattr *attr)\n{\n\tint error;\n\n\tif (current->journal_info)\n\t\treturn __gfs2_setattr_simple(inode, attr);\n\n\terror = gfs2_trans_begin(GFS2_SB(inode), RES_DINODE, 0);\n\tif (error)\n\t\treturn error;\n\n\terror = __gfs2_setattr_simple(inode, attr);\n\tgfs2_trans_end(GFS2_SB(inode));\n\treturn error;\n}",
    "includes": [
      "#include \"glops.h\"",
      "#include \"super.h\"",
      "#include \"util.h\"",
      "#include \"trans.h\"",
      "#include \"rgrp.h\"",
      "#include \"quota.h\"",
      "#include \"meta_io.h\"",
      "#include \"inode.h\"",
      "#include \"glock.h\"",
      "#include \"xattr.h\"",
      "#include \"dir.h\"",
      "#include \"bmap.h\"",
      "#include \"acl.h\"",
      "#include \"incore.h\"",
      "#include \"gfs2.h\"",
      "#include <asm/uaccess.h>",
      "#include <linux/security.h>",
      "#include <linux/fiemap.h>",
      "#include <linux/crc32.h>",
      "#include <linux/gfs2_ondisk.h>",
      "#include <linux/posix_acl.h>",
      "#include <linux/xattr.h>",
      "#include <linux/mm.h>",
      "#include <linux/namei.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/completion.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "gfs2_trans_end",
          "args": [
            "GFS2_SB(inode)"
          ],
          "line": 1661
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_trans_end",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/trans.c",
          "lines": "88-123",
          "snippet": "void gfs2_trans_end(struct gfs2_sbd *sdp)\n{\n\tstruct gfs2_trans *tr = current->journal_info;\n\ts64 nbuf;\n\tint alloced = tr->tr_alloced;\n\n\tBUG_ON(!tr);\n\tcurrent->journal_info = NULL;\n\n\tif (!tr->tr_touched) {\n\t\tgfs2_log_release(sdp, tr->tr_reserved);\n\t\tif (alloced) {\n\t\t\tkfree(tr);\n\t\t\tsb_end_intwrite(sdp->sd_vfs);\n\t\t}\n\t\treturn;\n\t}\n\n\tnbuf = tr->tr_num_buf_new + tr->tr_num_databuf_new;\n\tnbuf -= tr->tr_num_buf_rm;\n\tnbuf -= tr->tr_num_databuf_rm;\n\n\tif (gfs2_assert_withdraw(sdp, (nbuf <= tr->tr_blocks) &&\n\t\t\t\t       (tr->tr_num_revoke <= tr->tr_revokes)))\n\t\tgfs2_print_trans(tr);\n\n\tgfs2_log_commit(sdp, tr);\n\tif (alloced && !tr->tr_attached)\n\t\t\tkfree(tr);\n\tup_read(&sdp->sd_log_flush_lock);\n\n\tif (sdp->sd_vfs->s_flags & MS_SYNCHRONOUS)\n\t\tgfs2_log_flush(sdp, NULL, NORMAL_FLUSH);\n\tif (alloced)\n\t\tsb_end_intwrite(sdp->sd_vfs);\n}",
          "includes": [
            "#include \"trace_gfs2.h\"",
            "#include \"util.h\"",
            "#include \"trans.h\"",
            "#include \"meta_io.h\"",
            "#include \"lops.h\"",
            "#include \"log.h\"",
            "#include \"inode.h\"",
            "#include \"glock.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"util.h\"\n#include \"trans.h\"\n#include \"meta_io.h\"\n#include \"lops.h\"\n#include \"log.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/gfs2_ondisk.h>\n#include <linux/kallsyms.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nvoid gfs2_trans_end(struct gfs2_sbd *sdp)\n{\n\tstruct gfs2_trans *tr = current->journal_info;\n\ts64 nbuf;\n\tint alloced = tr->tr_alloced;\n\n\tBUG_ON(!tr);\n\tcurrent->journal_info = NULL;\n\n\tif (!tr->tr_touched) {\n\t\tgfs2_log_release(sdp, tr->tr_reserved);\n\t\tif (alloced) {\n\t\t\tkfree(tr);\n\t\t\tsb_end_intwrite(sdp->sd_vfs);\n\t\t}\n\t\treturn;\n\t}\n\n\tnbuf = tr->tr_num_buf_new + tr->tr_num_databuf_new;\n\tnbuf -= tr->tr_num_buf_rm;\n\tnbuf -= tr->tr_num_databuf_rm;\n\n\tif (gfs2_assert_withdraw(sdp, (nbuf <= tr->tr_blocks) &&\n\t\t\t\t       (tr->tr_num_revoke <= tr->tr_revokes)))\n\t\tgfs2_print_trans(tr);\n\n\tgfs2_log_commit(sdp, tr);\n\tif (alloced && !tr->tr_attached)\n\t\t\tkfree(tr);\n\tup_read(&sdp->sd_log_flush_lock);\n\n\tif (sdp->sd_vfs->s_flags & MS_SYNCHRONOUS)\n\t\tgfs2_log_flush(sdp, NULL, NORMAL_FLUSH);\n\tif (alloced)\n\t\tsb_end_intwrite(sdp->sd_vfs);\n}"
        }
      },
      {
        "call_info": {
          "callee": "GFS2_SB",
          "args": [
            "inode"
          ],
          "line": 1661
        },
        "resolved": true,
        "details": {
          "function_name": "GFS2_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/incore.h",
          "lines": "413-416",
          "snippet": "static inline struct gfs2_sbd *GFS2_SB(const struct inode *inode)\n{\n\treturn inode->i_sb->s_fs_info;\n}",
          "includes": [
            "#include <linux/lockref.h>",
            "#include <linux/percpu.h>",
            "#include <linux/ktime.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/completion.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/dlm.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/kobject.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/lockref.h>\n#include <linux/percpu.h>\n#include <linux/ktime.h>\n#include <linux/rbtree.h>\n#include <linux/completion.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/buffer_head.h>\n#include <linux/dlm.h>\n#include <linux/workqueue.h>\n#include <linux/kobject.h>\n#include <linux/fs.h>\n\nstatic inline struct gfs2_sbd *GFS2_SB(const struct inode *inode)\n{\n\treturn inode->i_sb->s_fs_info;\n}"
        }
      },
      {
        "call_info": {
          "callee": "__gfs2_setattr_simple",
          "args": [
            "inode",
            "attr"
          ],
          "line": 1660
        },
        "resolved": true,
        "details": {
          "function_name": "__gfs2_setattr_simple",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/inode.c",
          "lines": "1634-1639",
          "snippet": "static int __gfs2_setattr_simple(struct inode *inode, struct iattr *attr)\n{\n\tsetattr_copy(inode, attr);\n\tmark_inode_dirty(inode);\n\treturn 0;\n}",
          "includes": [
            "#include \"glops.h\"",
            "#include \"super.h\"",
            "#include \"util.h\"",
            "#include \"trans.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"inode.h\"",
            "#include \"glock.h\"",
            "#include \"xattr.h\"",
            "#include \"dir.h\"",
            "#include \"bmap.h\"",
            "#include \"acl.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/security.h>",
            "#include <linux/fiemap.h>",
            "#include <linux/crc32.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/xattr.h>",
            "#include <linux/mm.h>",
            "#include <linux/namei.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glops.h\"\n#include \"super.h\"\n#include \"util.h\"\n#include \"trans.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"xattr.h\"\n#include \"dir.h\"\n#include \"bmap.h\"\n#include \"acl.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <asm/uaccess.h>\n#include <linux/security.h>\n#include <linux/fiemap.h>\n#include <linux/crc32.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/posix_acl.h>\n#include <linux/xattr.h>\n#include <linux/mm.h>\n#include <linux/namei.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nstatic int __gfs2_setattr_simple(struct inode *inode, struct iattr *attr)\n{\n\tsetattr_copy(inode, attr);\n\tmark_inode_dirty(inode);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "gfs2_trans_begin",
          "args": [
            "GFS2_SB(inode)",
            "RES_DINODE",
            "0"
          ],
          "line": 1656
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_trans_begin",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/trans.c",
          "lines": "31-75",
          "snippet": "int gfs2_trans_begin(struct gfs2_sbd *sdp, unsigned int blocks,\n\t\t     unsigned int revokes)\n{\n\tstruct gfs2_trans *tr;\n\tint error;\n\n\tBUG_ON(current->journal_info);\n\tBUG_ON(blocks == 0 && revokes == 0);\n\n\tif (!test_bit(SDF_JOURNAL_LIVE, &sdp->sd_flags))\n\t\treturn -EROFS;\n\n\ttr = kzalloc(sizeof(struct gfs2_trans), GFP_NOFS);\n\tif (!tr)\n\t\treturn -ENOMEM;\n\n\ttr->tr_ip = _RET_IP_;\n\ttr->tr_blocks = blocks;\n\ttr->tr_revokes = revokes;\n\ttr->tr_reserved = 1;\n\ttr->tr_alloced = 1;\n\tif (blocks)\n\t\ttr->tr_reserved += 6 + blocks;\n\tif (revokes)\n\t\ttr->tr_reserved += gfs2_struct2blk(sdp, revokes,\n\t\t\t\t\t\t   sizeof(u64));\n\tINIT_LIST_HEAD(&tr->tr_databuf);\n\tINIT_LIST_HEAD(&tr->tr_buf);\n\n\tsb_start_intwrite(sdp->sd_vfs);\n\n\terror = gfs2_log_reserve(sdp, tr->tr_reserved);\n\tif (error)\n\t\tgoto fail;\n\n\tcurrent->journal_info = tr;\n\n\treturn 0;\n\nfail:\n\tsb_end_intwrite(sdp->sd_vfs);\n\tkfree(tr);\n\n\treturn error;\n}",
          "includes": [
            "#include \"trace_gfs2.h\"",
            "#include \"util.h\"",
            "#include \"trans.h\"",
            "#include \"meta_io.h\"",
            "#include \"lops.h\"",
            "#include \"log.h\"",
            "#include \"inode.h\"",
            "#include \"glock.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"util.h\"\n#include \"trans.h\"\n#include \"meta_io.h\"\n#include \"lops.h\"\n#include \"log.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/gfs2_ondisk.h>\n#include <linux/kallsyms.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nint gfs2_trans_begin(struct gfs2_sbd *sdp, unsigned int blocks,\n\t\t     unsigned int revokes)\n{\n\tstruct gfs2_trans *tr;\n\tint error;\n\n\tBUG_ON(current->journal_info);\n\tBUG_ON(blocks == 0 && revokes == 0);\n\n\tif (!test_bit(SDF_JOURNAL_LIVE, &sdp->sd_flags))\n\t\treturn -EROFS;\n\n\ttr = kzalloc(sizeof(struct gfs2_trans), GFP_NOFS);\n\tif (!tr)\n\t\treturn -ENOMEM;\n\n\ttr->tr_ip = _RET_IP_;\n\ttr->tr_blocks = blocks;\n\ttr->tr_revokes = revokes;\n\ttr->tr_reserved = 1;\n\ttr->tr_alloced = 1;\n\tif (blocks)\n\t\ttr->tr_reserved += 6 + blocks;\n\tif (revokes)\n\t\ttr->tr_reserved += gfs2_struct2blk(sdp, revokes,\n\t\t\t\t\t\t   sizeof(u64));\n\tINIT_LIST_HEAD(&tr->tr_databuf);\n\tINIT_LIST_HEAD(&tr->tr_buf);\n\n\tsb_start_intwrite(sdp->sd_vfs);\n\n\terror = gfs2_log_reserve(sdp, tr->tr_reserved);\n\tif (error)\n\t\tgoto fail;\n\n\tcurrent->journal_info = tr;\n\n\treturn 0;\n\nfail:\n\tsb_end_intwrite(sdp->sd_vfs);\n\tkfree(tr);\n\n\treturn error;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"glops.h\"\n#include \"super.h\"\n#include \"util.h\"\n#include \"trans.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"xattr.h\"\n#include \"dir.h\"\n#include \"bmap.h\"\n#include \"acl.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <asm/uaccess.h>\n#include <linux/security.h>\n#include <linux/fiemap.h>\n#include <linux/crc32.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/posix_acl.h>\n#include <linux/xattr.h>\n#include <linux/mm.h>\n#include <linux/namei.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nint gfs2_setattr_simple(struct inode *inode, struct iattr *attr)\n{\n\tint error;\n\n\tif (current->journal_info)\n\t\treturn __gfs2_setattr_simple(inode, attr);\n\n\terror = gfs2_trans_begin(GFS2_SB(inode), RES_DINODE, 0);\n\tif (error)\n\t\treturn error;\n\n\terror = __gfs2_setattr_simple(inode, attr);\n\tgfs2_trans_end(GFS2_SB(inode));\n\treturn error;\n}"
  },
  {
    "function_name": "__gfs2_setattr_simple",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/inode.c",
    "lines": "1634-1639",
    "snippet": "static int __gfs2_setattr_simple(struct inode *inode, struct iattr *attr)\n{\n\tsetattr_copy(inode, attr);\n\tmark_inode_dirty(inode);\n\treturn 0;\n}",
    "includes": [
      "#include \"glops.h\"",
      "#include \"super.h\"",
      "#include \"util.h\"",
      "#include \"trans.h\"",
      "#include \"rgrp.h\"",
      "#include \"quota.h\"",
      "#include \"meta_io.h\"",
      "#include \"inode.h\"",
      "#include \"glock.h\"",
      "#include \"xattr.h\"",
      "#include \"dir.h\"",
      "#include \"bmap.h\"",
      "#include \"acl.h\"",
      "#include \"incore.h\"",
      "#include \"gfs2.h\"",
      "#include <asm/uaccess.h>",
      "#include <linux/security.h>",
      "#include <linux/fiemap.h>",
      "#include <linux/crc32.h>",
      "#include <linux/gfs2_ondisk.h>",
      "#include <linux/posix_acl.h>",
      "#include <linux/xattr.h>",
      "#include <linux/mm.h>",
      "#include <linux/namei.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/completion.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mark_inode_dirty",
          "args": [
            "inode"
          ],
          "line": 1637
        },
        "resolved": true,
        "details": {
          "function_name": "block_dump___mark_inode_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fs-writeback.c",
          "lines": "1134-1154",
          "snippet": "static noinline void block_dump___mark_inode_dirty(struct inode *inode)\n{\n\tif (inode->i_ino || strcmp(inode->i_sb->s_id, \"bdev\")) {\n\t\tstruct dentry *dentry;\n\t\tconst char *name = \"?\";\n\n\t\tdentry = d_find_alias(inode);\n\t\tif (dentry) {\n\t\t\tspin_lock(&dentry->d_lock);\n\t\t\tname = (const char *) dentry->d_name.name;\n\t\t}\n\t\tprintk(KERN_DEBUG\n\t\t       \"%s(%d): dirtied inode %lu (%s) on %s\\n\",\n\t\t       current->comm, task_pid_nr(current), inode->i_ino,\n\t\t       name, inode->i_sb->s_id);\n\t\tif (dentry) {\n\t\t\tspin_unlock(&dentry->d_lock);\n\t\t\tdput(dentry);\n\t\t}\n\t}\n}",
          "includes": [
            "#include <trace/events/writeback.h>",
            "#include \"internal.h\"",
            "#include <linux/device.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/writeback.h>\n#include \"internal.h\"\n#include <linux/device.h>\n#include <linux/tracepoint.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nstatic noinline void block_dump___mark_inode_dirty(struct inode *inode)\n{\n\tif (inode->i_ino || strcmp(inode->i_sb->s_id, \"bdev\")) {\n\t\tstruct dentry *dentry;\n\t\tconst char *name = \"?\";\n\n\t\tdentry = d_find_alias(inode);\n\t\tif (dentry) {\n\t\t\tspin_lock(&dentry->d_lock);\n\t\t\tname = (const char *) dentry->d_name.name;\n\t\t}\n\t\tprintk(KERN_DEBUG\n\t\t       \"%s(%d): dirtied inode %lu (%s) on %s\\n\",\n\t\t       current->comm, task_pid_nr(current), inode->i_ino,\n\t\t       name, inode->i_sb->s_id);\n\t\tif (dentry) {\n\t\t\tspin_unlock(&dentry->d_lock);\n\t\t\tdput(dentry);\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "setattr_copy",
          "args": [
            "inode",
            "attr"
          ],
          "line": 1636
        },
        "resolved": true,
        "details": {
          "function_name": "setattr_copy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/attr.c",
          "lines": "142-167",
          "snippet": "void setattr_copy(struct inode *inode, const struct iattr *attr)\n{\n\tunsigned int ia_valid = attr->ia_valid;\n\n\tif (ia_valid & ATTR_UID)\n\t\tinode->i_uid = attr->ia_uid;\n\tif (ia_valid & ATTR_GID)\n\t\tinode->i_gid = attr->ia_gid;\n\tif (ia_valid & ATTR_ATIME)\n\t\tinode->i_atime = timespec_trunc(attr->ia_atime,\n\t\t\t\t\t\tinode->i_sb->s_time_gran);\n\tif (ia_valid & ATTR_MTIME)\n\t\tinode->i_mtime = timespec_trunc(attr->ia_mtime,\n\t\t\t\t\t\tinode->i_sb->s_time_gran);\n\tif (ia_valid & ATTR_CTIME)\n\t\tinode->i_ctime = timespec_trunc(attr->ia_ctime,\n\t\t\t\t\t\tinode->i_sb->s_time_gran);\n\tif (ia_valid & ATTR_MODE) {\n\t\tumode_t mode = attr->ia_mode;\n\n\t\tif (!in_group_p(inode->i_gid) &&\n\t\t    !capable_wrt_inode_uidgid(inode, CAP_FSETID))\n\t\t\tmode &= ~S_ISGID;\n\t\tinode->i_mode = mode;\n\t}\n}",
          "includes": [
            "#include <linux/ima.h>",
            "#include <linux/evm.h>",
            "#include <linux/security.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/capability.h>",
            "#include <linux/string.h>",
            "#include <linux/mm.h>",
            "#include <linux/time.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ima.h>\n#include <linux/evm.h>\n#include <linux/security.h>\n#include <linux/fcntl.h>\n#include <linux/fsnotify.h>\n#include <linux/capability.h>\n#include <linux/string.h>\n#include <linux/mm.h>\n#include <linux/time.h>\n#include <linux/export.h>\n\nvoid setattr_copy(struct inode *inode, const struct iattr *attr)\n{\n\tunsigned int ia_valid = attr->ia_valid;\n\n\tif (ia_valid & ATTR_UID)\n\t\tinode->i_uid = attr->ia_uid;\n\tif (ia_valid & ATTR_GID)\n\t\tinode->i_gid = attr->ia_gid;\n\tif (ia_valid & ATTR_ATIME)\n\t\tinode->i_atime = timespec_trunc(attr->ia_atime,\n\t\t\t\t\t\tinode->i_sb->s_time_gran);\n\tif (ia_valid & ATTR_MTIME)\n\t\tinode->i_mtime = timespec_trunc(attr->ia_mtime,\n\t\t\t\t\t\tinode->i_sb->s_time_gran);\n\tif (ia_valid & ATTR_CTIME)\n\t\tinode->i_ctime = timespec_trunc(attr->ia_ctime,\n\t\t\t\t\t\tinode->i_sb->s_time_gran);\n\tif (ia_valid & ATTR_MODE) {\n\t\tumode_t mode = attr->ia_mode;\n\n\t\tif (!in_group_p(inode->i_gid) &&\n\t\t    !capable_wrt_inode_uidgid(inode, CAP_FSETID))\n\t\t\tmode &= ~S_ISGID;\n\t\tinode->i_mode = mode;\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"glops.h\"\n#include \"super.h\"\n#include \"util.h\"\n#include \"trans.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"xattr.h\"\n#include \"dir.h\"\n#include \"bmap.h\"\n#include \"acl.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <asm/uaccess.h>\n#include <linux/security.h>\n#include <linux/fiemap.h>\n#include <linux/crc32.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/posix_acl.h>\n#include <linux/xattr.h>\n#include <linux/mm.h>\n#include <linux/namei.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nstatic int __gfs2_setattr_simple(struct inode *inode, struct iattr *attr)\n{\n\tsetattr_copy(inode, attr);\n\tmark_inode_dirty(inode);\n\treturn 0;\n}"
  },
  {
    "function_name": "gfs2_permission",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/inode.c",
    "lines": "1606-1632",
    "snippet": "int gfs2_permission(struct inode *inode, int mask)\n{\n\tstruct gfs2_inode *ip;\n\tstruct gfs2_holder i_gh;\n\tint error;\n\tint unlock = 0;\n\n\n\tip = GFS2_I(inode);\n\tif (gfs2_glock_is_locked_by_me(ip->i_gl) == NULL) {\n\t\tif (mask & MAY_NOT_BLOCK)\n\t\t\treturn -ECHILD;\n\t\terror = gfs2_glock_nq_init(ip->i_gl, LM_ST_SHARED, LM_FLAG_ANY, &i_gh);\n\t\tif (error)\n\t\t\treturn error;\n\t\tunlock = 1;\n\t}\n\n\tif ((mask & MAY_WRITE) && IS_IMMUTABLE(inode))\n\t\terror = -EACCES;\n\telse\n\t\terror = generic_permission(inode, mask);\n\tif (unlock)\n\t\tgfs2_glock_dq_uninit(&i_gh);\n\n\treturn error;\n}",
    "includes": [
      "#include \"glops.h\"",
      "#include \"super.h\"",
      "#include \"util.h\"",
      "#include \"trans.h\"",
      "#include \"rgrp.h\"",
      "#include \"quota.h\"",
      "#include \"meta_io.h\"",
      "#include \"inode.h\"",
      "#include \"glock.h\"",
      "#include \"xattr.h\"",
      "#include \"dir.h\"",
      "#include \"bmap.h\"",
      "#include \"acl.h\"",
      "#include \"incore.h\"",
      "#include \"gfs2.h\"",
      "#include <asm/uaccess.h>",
      "#include <linux/security.h>",
      "#include <linux/fiemap.h>",
      "#include <linux/crc32.h>",
      "#include <linux/gfs2_ondisk.h>",
      "#include <linux/posix_acl.h>",
      "#include <linux/xattr.h>",
      "#include <linux/mm.h>",
      "#include <linux/namei.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/completion.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "gfs2_glock_dq_uninit",
          "args": [
            "&i_gh"
          ],
          "line": 1629
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_glock_dq_uninit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/glock.c",
          "lines": "1110-1114",
          "snippet": "void gfs2_glock_dq_uninit(struct gfs2_holder *gh)\n{\n\tgfs2_glock_dq(gh);\n\tgfs2_holder_uninit(gh);\n}",
          "includes": [
            "#include \"trace_gfs2.h\"",
            "#include \"bmap.h\"",
            "#include \"util.h\"",
            "#include \"super.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"lops.h\"",
            "#include \"inode.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/lockref.h>",
            "#include <linux/list_sort.h>",
            "#include <linux/percpu.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/seq_file.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/module.h>",
            "#include <linux/wait.h>",
            "#include <linux/list.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/jhash.h>",
            "#include <linux/sort.h>",
            "#include <linux/delay.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"bmap.h\"\n#include \"util.h\"\n#include \"super.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"lops.h\"\n#include \"inode.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/lockref.h>\n#include <linux/list_sort.h>\n#include <linux/percpu.h>\n#include <linux/bit_spinlock.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/jiffies.h>\n#include <linux/workqueue.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <asm/uaccess.h>\n#include <linux/module.h>\n#include <linux/wait.h>\n#include <linux/list.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/kallsyms.h>\n#include <linux/jhash.h>\n#include <linux/sort.h>\n#include <linux/delay.h>\n#include <linux/buffer_head.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nvoid gfs2_glock_dq_uninit(struct gfs2_holder *gh)\n{\n\tgfs2_glock_dq(gh);\n\tgfs2_holder_uninit(gh);\n}"
        }
      },
      {
        "call_info": {
          "callee": "generic_permission",
          "args": [
            "inode",
            "mask"
          ],
          "line": 1627
        },
        "resolved": true,
        "details": {
          "function_name": "generic_permission",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namei.c",
          "lines": "329-368",
          "snippet": "int generic_permission(struct inode *inode, int mask)\n{\n\tint ret;\n\n\t/*\n\t * Do the basic permission checks.\n\t */\n\tret = acl_permission_check(inode, mask);\n\tif (ret != -EACCES)\n\t\treturn ret;\n\n\tif (S_ISDIR(inode->i_mode)) {\n\t\t/* DACs are overridable for directories */\n\t\tif (capable_wrt_inode_uidgid(inode, CAP_DAC_OVERRIDE))\n\t\t\treturn 0;\n\t\tif (!(mask & MAY_WRITE))\n\t\t\tif (capable_wrt_inode_uidgid(inode,\n\t\t\t\t\t\t     CAP_DAC_READ_SEARCH))\n\t\t\t\treturn 0;\n\t\treturn -EACCES;\n\t}\n\t/*\n\t * Read/write DACs are always overridable.\n\t * Executable DACs are overridable when there is\n\t * at least one exec bit set.\n\t */\n\tif (!(mask & MAY_EXEC) || (inode->i_mode & S_IXUGO))\n\t\tif (capable_wrt_inode_uidgid(inode, CAP_DAC_OVERRIDE))\n\t\t\treturn 0;\n\n\t/*\n\t * Searching includes executable on directories, else just read.\n\t */\n\tmask &= MAY_READ | MAY_WRITE | MAY_EXEC;\n\tif (mask == MAY_READ)\n\t\tif (capable_wrt_inode_uidgid(inode, CAP_DAC_READ_SEARCH))\n\t\t\treturn 0;\n\n\treturn -EACCES;\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/hash.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/device_cgroup.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>",
            "#include <linux/audit.h>",
            "#include <linux/mount.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/ima.h>",
            "#include <linux/security.h>",
            "#include <linux/personality.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <linux/hash.h>\n#include <linux/posix_acl.h>\n#include <linux/fs_struct.h>\n#include <linux/device_cgroup.h>\n#include <linux/fcntl.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n#include <linux/audit.h>\n#include <linux/mount.h>\n#include <linux/syscalls.h>\n#include <linux/ima.h>\n#include <linux/security.h>\n#include <linux/personality.h>\n#include <linux/fsnotify.h>\n#include <linux/pagemap.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n#include <linux/init.h>\n\nint generic_permission(struct inode *inode, int mask)\n{\n\tint ret;\n\n\t/*\n\t * Do the basic permission checks.\n\t */\n\tret = acl_permission_check(inode, mask);\n\tif (ret != -EACCES)\n\t\treturn ret;\n\n\tif (S_ISDIR(inode->i_mode)) {\n\t\t/* DACs are overridable for directories */\n\t\tif (capable_wrt_inode_uidgid(inode, CAP_DAC_OVERRIDE))\n\t\t\treturn 0;\n\t\tif (!(mask & MAY_WRITE))\n\t\t\tif (capable_wrt_inode_uidgid(inode,\n\t\t\t\t\t\t     CAP_DAC_READ_SEARCH))\n\t\t\t\treturn 0;\n\t\treturn -EACCES;\n\t}\n\t/*\n\t * Read/write DACs are always overridable.\n\t * Executable DACs are overridable when there is\n\t * at least one exec bit set.\n\t */\n\tif (!(mask & MAY_EXEC) || (inode->i_mode & S_IXUGO))\n\t\tif (capable_wrt_inode_uidgid(inode, CAP_DAC_OVERRIDE))\n\t\t\treturn 0;\n\n\t/*\n\t * Searching includes executable on directories, else just read.\n\t */\n\tmask &= MAY_READ | MAY_WRITE | MAY_EXEC;\n\tif (mask == MAY_READ)\n\t\tif (capable_wrt_inode_uidgid(inode, CAP_DAC_READ_SEARCH))\n\t\t\treturn 0;\n\n\treturn -EACCES;\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_IMMUTABLE",
          "args": [
            "inode"
          ],
          "line": 1624
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gfs2_glock_nq_init",
          "args": [
            "ip->i_gl",
            "LM_ST_SHARED",
            "LM_FLAG_ANY",
            "&i_gh"
          ],
          "line": 1618
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_glock_nq_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/glock.h",
          "lines": "204-230",
          "snippet": "extern __printf(2, 3)\nvoid gfs2_print_dbg(struct seq_file *seq, const char *fmt, ...);\n\n/**\n * gfs2_glock_nq_init - initialize a holder and enqueue it on a glock\n * @gl: the glock\n * @state: the state we're requesting\n * @flags: the modifier flags\n * @gh: the holder structure\n *\n * Returns: 0, GLR_*, or errno\n */\n\nstatic inline int gfs2_glock_nq_init(struct gfs2_glock *gl,\n\t\t\t\t     unsigned int state, int flags,\n\t\t\t\t     struct gfs2_holder *gh)\n{\n\tint error;\n\n\tgfs2_holder_init(gl, state, flags, gh);\n\n\terror = gfs2_glock_nq(gh);\n\tif (error)\n\t\tgfs2_holder_uninit(gh);\n\n\treturn error;\n}",
          "includes": [
            "#include \"incore.h\"",
            "#include <linux/parser.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"incore.h\"\n#include <linux/parser.h>\n#include <linux/sched.h>\n\nextern __printf(2, 3)\nvoid gfs2_print_dbg(struct seq_file *seq, const char *fmt, ...);\n\n/**\n * gfs2_glock_nq_init - initialize a holder and enqueue it on a glock\n * @gl: the glock\n * @state: the state we're requesting\n * @flags: the modifier flags\n * @gh: the holder structure\n *\n * Returns: 0, GLR_*, or errno\n */\n\nstatic inline int gfs2_glock_nq_init(struct gfs2_glock *gl,\n\t\t\t\t     unsigned int state, int flags,\n\t\t\t\t     struct gfs2_holder *gh)\n{\n\tint error;\n\n\tgfs2_holder_init(gl, state, flags, gh);\n\n\terror = gfs2_glock_nq(gh);\n\tif (error)\n\t\tgfs2_holder_uninit(gh);\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "gfs2_glock_is_locked_by_me",
          "args": [
            "ip->i_gl"
          ],
          "line": 1615
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_glock_is_locked_by_me",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/glock.h",
          "lines": "138-157",
          "snippet": "static inline struct gfs2_holder *gfs2_glock_is_locked_by_me(struct gfs2_glock *gl)\n{\n\tstruct gfs2_holder *gh;\n\tstruct pid *pid;\n\n\t/* Look in glock's list of holders for one with current task as owner */\n\tspin_lock(&gl->gl_spin);\n\tpid = task_pid(current);\n\tlist_for_each_entry(gh, &gl->gl_holders, gh_list) {\n\t\tif (!test_bit(HIF_HOLDER, &gh->gh_iflags))\n\t\t\tbreak;\n\t\tif (gh->gh_owner_pid == pid)\n\t\t\tgoto out;\n\t}\n\tgh = NULL;\nout:\n\tspin_unlock(&gl->gl_spin);\n\n\treturn gh;\n}",
          "includes": [
            "#include \"incore.h\"",
            "#include <linux/parser.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"incore.h\"\n#include <linux/parser.h>\n#include <linux/sched.h>\n\nstatic inline struct gfs2_holder *gfs2_glock_is_locked_by_me(struct gfs2_glock *gl)\n{\n\tstruct gfs2_holder *gh;\n\tstruct pid *pid;\n\n\t/* Look in glock's list of holders for one with current task as owner */\n\tspin_lock(&gl->gl_spin);\n\tpid = task_pid(current);\n\tlist_for_each_entry(gh, &gl->gl_holders, gh_list) {\n\t\tif (!test_bit(HIF_HOLDER, &gh->gh_iflags))\n\t\t\tbreak;\n\t\tif (gh->gh_owner_pid == pid)\n\t\t\tgoto out;\n\t}\n\tgh = NULL;\nout:\n\tspin_unlock(&gl->gl_spin);\n\n\treturn gh;\n}"
        }
      },
      {
        "call_info": {
          "callee": "GFS2_I",
          "args": [
            "inode"
          ],
          "line": 1614
        },
        "resolved": true,
        "details": {
          "function_name": "GFS2_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/incore.h",
          "lines": "408-411",
          "snippet": "static inline struct gfs2_inode *GFS2_I(struct inode *inode)\n{\n\treturn container_of(inode, struct gfs2_inode, i_inode);\n}",
          "includes": [
            "#include <linux/lockref.h>",
            "#include <linux/percpu.h>",
            "#include <linux/ktime.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/completion.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/dlm.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/kobject.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/lockref.h>\n#include <linux/percpu.h>\n#include <linux/ktime.h>\n#include <linux/rbtree.h>\n#include <linux/completion.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/buffer_head.h>\n#include <linux/dlm.h>\n#include <linux/workqueue.h>\n#include <linux/kobject.h>\n#include <linux/fs.h>\n\nstatic inline struct gfs2_inode *GFS2_I(struct inode *inode)\n{\n\treturn container_of(inode, struct gfs2_inode, i_inode);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"glops.h\"\n#include \"super.h\"\n#include \"util.h\"\n#include \"trans.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"xattr.h\"\n#include \"dir.h\"\n#include \"bmap.h\"\n#include \"acl.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <asm/uaccess.h>\n#include <linux/security.h>\n#include <linux/fiemap.h>\n#include <linux/crc32.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/posix_acl.h>\n#include <linux/xattr.h>\n#include <linux/mm.h>\n#include <linux/namei.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nint gfs2_permission(struct inode *inode, int mask)\n{\n\tstruct gfs2_inode *ip;\n\tstruct gfs2_holder i_gh;\n\tint error;\n\tint unlock = 0;\n\n\n\tip = GFS2_I(inode);\n\tif (gfs2_glock_is_locked_by_me(ip->i_gl) == NULL) {\n\t\tif (mask & MAY_NOT_BLOCK)\n\t\t\treturn -ECHILD;\n\t\terror = gfs2_glock_nq_init(ip->i_gl, LM_ST_SHARED, LM_FLAG_ANY, &i_gh);\n\t\tif (error)\n\t\t\treturn error;\n\t\tunlock = 1;\n\t}\n\n\tif ((mask & MAY_WRITE) && IS_IMMUTABLE(inode))\n\t\terror = -EACCES;\n\telse\n\t\terror = generic_permission(inode, mask);\n\tif (unlock)\n\t\tgfs2_glock_dq_uninit(&i_gh);\n\n\treturn error;\n}"
  },
  {
    "function_name": "gfs2_follow_link",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/inode.c",
    "lines": "1551-1591",
    "snippet": "static void *gfs2_follow_link(struct dentry *dentry, struct nameidata *nd)\n{\n\tstruct gfs2_inode *ip = GFS2_I(dentry->d_inode);\n\tstruct gfs2_holder i_gh;\n\tstruct buffer_head *dibh;\n\tunsigned int size;\n\tchar *buf;\n\tint error;\n\n\tgfs2_holder_init(ip->i_gl, LM_ST_SHARED, 0, &i_gh);\n\terror = gfs2_glock_nq(&i_gh);\n\tif (error) {\n\t\tgfs2_holder_uninit(&i_gh);\n\t\tnd_set_link(nd, ERR_PTR(error));\n\t\treturn NULL;\n\t}\n\n\tsize = (unsigned int)i_size_read(&ip->i_inode);\n\tif (size == 0) {\n\t\tgfs2_consist_inode(ip);\n\t\tbuf = ERR_PTR(-EIO);\n\t\tgoto out;\n\t}\n\n\terror = gfs2_meta_inode_buffer(ip, &dibh);\n\tif (error) {\n\t\tbuf = ERR_PTR(error);\n\t\tgoto out;\n\t}\n\n\tbuf = kzalloc(size + 1, GFP_NOFS);\n\tif (!buf)\n\t\tbuf = ERR_PTR(-ENOMEM);\n\telse\n\t\tmemcpy(buf, dibh->b_data + sizeof(struct gfs2_dinode), size);\n\tbrelse(dibh);\nout:\n\tgfs2_glock_dq_uninit(&i_gh);\n\tnd_set_link(nd, buf);\n\treturn NULL;\n}",
    "includes": [
      "#include \"glops.h\"",
      "#include \"super.h\"",
      "#include \"util.h\"",
      "#include \"trans.h\"",
      "#include \"rgrp.h\"",
      "#include \"quota.h\"",
      "#include \"meta_io.h\"",
      "#include \"inode.h\"",
      "#include \"glock.h\"",
      "#include \"xattr.h\"",
      "#include \"dir.h\"",
      "#include \"bmap.h\"",
      "#include \"acl.h\"",
      "#include \"incore.h\"",
      "#include \"gfs2.h\"",
      "#include <asm/uaccess.h>",
      "#include <linux/security.h>",
      "#include <linux/fiemap.h>",
      "#include <linux/crc32.h>",
      "#include <linux/gfs2_ondisk.h>",
      "#include <linux/posix_acl.h>",
      "#include <linux/xattr.h>",
      "#include <linux/mm.h>",
      "#include <linux/namei.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/completion.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "nd_set_link",
          "args": [
            "nd",
            "buf"
          ],
          "line": 1589
        },
        "resolved": true,
        "details": {
          "function_name": "nd_set_link",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namei.c",
          "lines": "717-720",
          "snippet": "void nd_set_link(struct nameidata *nd, char *path)\n{\n\tnd->saved_names[nd->depth] = path;\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/hash.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/device_cgroup.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>",
            "#include <linux/audit.h>",
            "#include <linux/mount.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/ima.h>",
            "#include <linux/security.h>",
            "#include <linux/personality.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int link_path_walk(const char *, struct nameidata *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <linux/hash.h>\n#include <linux/posix_acl.h>\n#include <linux/fs_struct.h>\n#include <linux/device_cgroup.h>\n#include <linux/fcntl.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n#include <linux/audit.h>\n#include <linux/mount.h>\n#include <linux/syscalls.h>\n#include <linux/ima.h>\n#include <linux/security.h>\n#include <linux/personality.h>\n#include <linux/fsnotify.h>\n#include <linux/pagemap.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n#include <linux/init.h>\n\nstatic int link_path_walk(const char *, struct nameidata *);\n\nvoid nd_set_link(struct nameidata *nd, char *path)\n{\n\tnd->saved_names[nd->depth] = path;\n}"
        }
      },
      {
        "call_info": {
          "callee": "gfs2_glock_dq_uninit",
          "args": [
            "&i_gh"
          ],
          "line": 1588
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_glock_dq_uninit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/glock.c",
          "lines": "1110-1114",
          "snippet": "void gfs2_glock_dq_uninit(struct gfs2_holder *gh)\n{\n\tgfs2_glock_dq(gh);\n\tgfs2_holder_uninit(gh);\n}",
          "includes": [
            "#include \"trace_gfs2.h\"",
            "#include \"bmap.h\"",
            "#include \"util.h\"",
            "#include \"super.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"lops.h\"",
            "#include \"inode.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/lockref.h>",
            "#include <linux/list_sort.h>",
            "#include <linux/percpu.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/seq_file.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/module.h>",
            "#include <linux/wait.h>",
            "#include <linux/list.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/jhash.h>",
            "#include <linux/sort.h>",
            "#include <linux/delay.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"bmap.h\"\n#include \"util.h\"\n#include \"super.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"lops.h\"\n#include \"inode.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/lockref.h>\n#include <linux/list_sort.h>\n#include <linux/percpu.h>\n#include <linux/bit_spinlock.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/jiffies.h>\n#include <linux/workqueue.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <asm/uaccess.h>\n#include <linux/module.h>\n#include <linux/wait.h>\n#include <linux/list.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/kallsyms.h>\n#include <linux/jhash.h>\n#include <linux/sort.h>\n#include <linux/delay.h>\n#include <linux/buffer_head.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nvoid gfs2_glock_dq_uninit(struct gfs2_holder *gh)\n{\n\tgfs2_glock_dq(gh);\n\tgfs2_holder_uninit(gh);\n}"
        }
      },
      {
        "call_info": {
          "callee": "brelse",
          "args": [
            "dibh"
          ],
          "line": 1586
        },
        "resolved": true,
        "details": {
          "function_name": "__brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1177-1184",
          "snippet": "void __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "buf",
            "dibh->b_data + sizeof(struct gfs2_dinode)",
            "size"
          ],
          "line": 1585
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-ENOMEM"
          ],
          "line": 1583
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "size + 1",
            "GFP_NOFS"
          ],
          "line": 1581
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "error"
          ],
          "line": 1577
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gfs2_meta_inode_buffer",
          "args": [
            "ip",
            "&dibh"
          ],
          "line": 1575
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_meta_inode_buffer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/meta_io.h",
          "lines": "66-70",
          "snippet": "static inline int gfs2_meta_inode_buffer(struct gfs2_inode *ip,\n\t\t\t\t\t struct buffer_head **bhp)\n{\n\treturn gfs2_meta_indirect_buffer(ip, 0, ip->i_no_addr, bhp);\n}",
          "includes": [
            "#include \"incore.h\"",
            "#include <linux/string.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"incore.h\"\n#include <linux/string.h>\n#include <linux/buffer_head.h>\n\nstatic inline int gfs2_meta_inode_buffer(struct gfs2_inode *ip,\n\t\t\t\t\t struct buffer_head **bhp)\n{\n\treturn gfs2_meta_indirect_buffer(ip, 0, ip->i_no_addr, bhp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-EIO"
          ],
          "line": 1571
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gfs2_consist_inode",
          "args": [
            "ip"
          ],
          "line": 1570
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "i_size_read",
          "args": [
            "&ip->i_inode"
          ],
          "line": 1568
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "error"
          ],
          "line": 1564
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gfs2_holder_uninit",
          "args": [
            "&i_gh"
          ],
          "line": 1563
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_holder_uninit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/glock.c",
          "lines": "841-847",
          "snippet": "void gfs2_holder_uninit(struct gfs2_holder *gh)\n{\n\tput_pid(gh->gh_owner_pid);\n\tgfs2_glock_put(gh->gh_gl);\n\tgh->gh_gl = NULL;\n\tgh->gh_ip = 0;\n}",
          "includes": [
            "#include \"trace_gfs2.h\"",
            "#include \"bmap.h\"",
            "#include \"util.h\"",
            "#include \"super.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"lops.h\"",
            "#include \"inode.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/lockref.h>",
            "#include <linux/list_sort.h>",
            "#include <linux/percpu.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/seq_file.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/module.h>",
            "#include <linux/wait.h>",
            "#include <linux/list.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/jhash.h>",
            "#include <linux/sort.h>",
            "#include <linux/delay.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"bmap.h\"\n#include \"util.h\"\n#include \"super.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"lops.h\"\n#include \"inode.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/lockref.h>\n#include <linux/list_sort.h>\n#include <linux/percpu.h>\n#include <linux/bit_spinlock.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/jiffies.h>\n#include <linux/workqueue.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <asm/uaccess.h>\n#include <linux/module.h>\n#include <linux/wait.h>\n#include <linux/list.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/kallsyms.h>\n#include <linux/jhash.h>\n#include <linux/sort.h>\n#include <linux/delay.h>\n#include <linux/buffer_head.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nvoid gfs2_holder_uninit(struct gfs2_holder *gh)\n{\n\tput_pid(gh->gh_owner_pid);\n\tgfs2_glock_put(gh->gh_gl);\n\tgh->gh_gl = NULL;\n\tgh->gh_ip = 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "gfs2_glock_nq",
          "args": [
            "&i_gh"
          ],
          "line": 1561
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_glock_nq",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/glock.c",
          "lines": "1006-1034",
          "snippet": "int gfs2_glock_nq(struct gfs2_holder *gh)\n{\n\tstruct gfs2_glock *gl = gh->gh_gl;\n\tstruct gfs2_sbd *sdp = gl->gl_sbd;\n\tint error = 0;\n\n\tif (unlikely(test_bit(SDF_SHUTDOWN, &sdp->sd_flags)))\n\t\treturn -EIO;\n\n\tif (test_bit(GLF_LRU, &gl->gl_flags))\n\t\tgfs2_glock_remove_from_lru(gl);\n\n\tspin_lock(&gl->gl_spin);\n\tadd_to_queue(gh);\n\tif (unlikely((LM_FLAG_NOEXP & gh->gh_flags) &&\n\t\t     test_and_clear_bit(GLF_FROZEN, &gl->gl_flags))) {\n\t\tset_bit(GLF_REPLY_PENDING, &gl->gl_flags);\n\t\tgl->gl_lockref.count++;\n\t\tif (queue_delayed_work(glock_workqueue, &gl->gl_work, 0) == 0)\n\t\t\tgl->gl_lockref.count--;\n\t}\n\trun_queue(gl, 1);\n\tspin_unlock(&gl->gl_spin);\n\n\tif (!(gh->gh_flags & GL_ASYNC))\n\t\terror = gfs2_glock_wait(gh);\n\n\treturn error;\n}",
          "includes": [
            "#include \"trace_gfs2.h\"",
            "#include \"bmap.h\"",
            "#include \"util.h\"",
            "#include \"super.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"lops.h\"",
            "#include \"inode.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/lockref.h>",
            "#include <linux/list_sort.h>",
            "#include <linux/percpu.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/seq_file.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/module.h>",
            "#include <linux/wait.h>",
            "#include <linux/list.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/jhash.h>",
            "#include <linux/sort.h>",
            "#include <linux/delay.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct workqueue_struct *glock_workqueue;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"bmap.h\"\n#include \"util.h\"\n#include \"super.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"lops.h\"\n#include \"inode.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/lockref.h>\n#include <linux/list_sort.h>\n#include <linux/percpu.h>\n#include <linux/bit_spinlock.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/jiffies.h>\n#include <linux/workqueue.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <asm/uaccess.h>\n#include <linux/module.h>\n#include <linux/wait.h>\n#include <linux/list.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/kallsyms.h>\n#include <linux/jhash.h>\n#include <linux/sort.h>\n#include <linux/delay.h>\n#include <linux/buffer_head.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic struct workqueue_struct *glock_workqueue;\n\nint gfs2_glock_nq(struct gfs2_holder *gh)\n{\n\tstruct gfs2_glock *gl = gh->gh_gl;\n\tstruct gfs2_sbd *sdp = gl->gl_sbd;\n\tint error = 0;\n\n\tif (unlikely(test_bit(SDF_SHUTDOWN, &sdp->sd_flags)))\n\t\treturn -EIO;\n\n\tif (test_bit(GLF_LRU, &gl->gl_flags))\n\t\tgfs2_glock_remove_from_lru(gl);\n\n\tspin_lock(&gl->gl_spin);\n\tadd_to_queue(gh);\n\tif (unlikely((LM_FLAG_NOEXP & gh->gh_flags) &&\n\t\t     test_and_clear_bit(GLF_FROZEN, &gl->gl_flags))) {\n\t\tset_bit(GLF_REPLY_PENDING, &gl->gl_flags);\n\t\tgl->gl_lockref.count++;\n\t\tif (queue_delayed_work(glock_workqueue, &gl->gl_work, 0) == 0)\n\t\t\tgl->gl_lockref.count--;\n\t}\n\trun_queue(gl, 1);\n\tspin_unlock(&gl->gl_spin);\n\n\tif (!(gh->gh_flags & GL_ASYNC))\n\t\terror = gfs2_glock_wait(gh);\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "gfs2_holder_init",
          "args": [
            "ip->i_gl",
            "LM_ST_SHARED",
            "0",
            "&i_gh"
          ],
          "line": 1560
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_holder_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/glock.c",
          "lines": "801-813",
          "snippet": "void gfs2_holder_init(struct gfs2_glock *gl, unsigned int state, unsigned flags,\n\t\t      struct gfs2_holder *gh)\n{\n\tINIT_LIST_HEAD(&gh->gh_list);\n\tgh->gh_gl = gl;\n\tgh->gh_ip = _RET_IP_;\n\tgh->gh_owner_pid = get_pid(task_pid(current));\n\tgh->gh_state = state;\n\tgh->gh_flags = flags;\n\tgh->gh_error = 0;\n\tgh->gh_iflags = 0;\n\tgfs2_glock_hold(gl);\n}",
          "includes": [
            "#include \"trace_gfs2.h\"",
            "#include \"bmap.h\"",
            "#include \"util.h\"",
            "#include \"super.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"lops.h\"",
            "#include \"inode.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/lockref.h>",
            "#include <linux/list_sort.h>",
            "#include <linux/percpu.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/seq_file.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/module.h>",
            "#include <linux/wait.h>",
            "#include <linux/list.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/jhash.h>",
            "#include <linux/sort.h>",
            "#include <linux/delay.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"bmap.h\"\n#include \"util.h\"\n#include \"super.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"lops.h\"\n#include \"inode.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/lockref.h>\n#include <linux/list_sort.h>\n#include <linux/percpu.h>\n#include <linux/bit_spinlock.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/jiffies.h>\n#include <linux/workqueue.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <asm/uaccess.h>\n#include <linux/module.h>\n#include <linux/wait.h>\n#include <linux/list.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/kallsyms.h>\n#include <linux/jhash.h>\n#include <linux/sort.h>\n#include <linux/delay.h>\n#include <linux/buffer_head.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nvoid gfs2_holder_init(struct gfs2_glock *gl, unsigned int state, unsigned flags,\n\t\t      struct gfs2_holder *gh)\n{\n\tINIT_LIST_HEAD(&gh->gh_list);\n\tgh->gh_gl = gl;\n\tgh->gh_ip = _RET_IP_;\n\tgh->gh_owner_pid = get_pid(task_pid(current));\n\tgh->gh_state = state;\n\tgh->gh_flags = flags;\n\tgh->gh_error = 0;\n\tgh->gh_iflags = 0;\n\tgfs2_glock_hold(gl);\n}"
        }
      },
      {
        "call_info": {
          "callee": "GFS2_I",
          "args": [
            "dentry->d_inode"
          ],
          "line": 1553
        },
        "resolved": true,
        "details": {
          "function_name": "GFS2_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/incore.h",
          "lines": "408-411",
          "snippet": "static inline struct gfs2_inode *GFS2_I(struct inode *inode)\n{\n\treturn container_of(inode, struct gfs2_inode, i_inode);\n}",
          "includes": [
            "#include <linux/lockref.h>",
            "#include <linux/percpu.h>",
            "#include <linux/ktime.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/completion.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/dlm.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/kobject.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/lockref.h>\n#include <linux/percpu.h>\n#include <linux/ktime.h>\n#include <linux/rbtree.h>\n#include <linux/completion.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/buffer_head.h>\n#include <linux/dlm.h>\n#include <linux/workqueue.h>\n#include <linux/kobject.h>\n#include <linux/fs.h>\n\nstatic inline struct gfs2_inode *GFS2_I(struct inode *inode)\n{\n\treturn container_of(inode, struct gfs2_inode, i_inode);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"glops.h\"\n#include \"super.h\"\n#include \"util.h\"\n#include \"trans.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"xattr.h\"\n#include \"dir.h\"\n#include \"bmap.h\"\n#include \"acl.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <asm/uaccess.h>\n#include <linux/security.h>\n#include <linux/fiemap.h>\n#include <linux/crc32.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/posix_acl.h>\n#include <linux/xattr.h>\n#include <linux/mm.h>\n#include <linux/namei.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nstatic void *gfs2_follow_link(struct dentry *dentry, struct nameidata *nd)\n{\n\tstruct gfs2_inode *ip = GFS2_I(dentry->d_inode);\n\tstruct gfs2_holder i_gh;\n\tstruct buffer_head *dibh;\n\tunsigned int size;\n\tchar *buf;\n\tint error;\n\n\tgfs2_holder_init(ip->i_gl, LM_ST_SHARED, 0, &i_gh);\n\terror = gfs2_glock_nq(&i_gh);\n\tif (error) {\n\t\tgfs2_holder_uninit(&i_gh);\n\t\tnd_set_link(nd, ERR_PTR(error));\n\t\treturn NULL;\n\t}\n\n\tsize = (unsigned int)i_size_read(&ip->i_inode);\n\tif (size == 0) {\n\t\tgfs2_consist_inode(ip);\n\t\tbuf = ERR_PTR(-EIO);\n\t\tgoto out;\n\t}\n\n\terror = gfs2_meta_inode_buffer(ip, &dibh);\n\tif (error) {\n\t\tbuf = ERR_PTR(error);\n\t\tgoto out;\n\t}\n\n\tbuf = kzalloc(size + 1, GFP_NOFS);\n\tif (!buf)\n\t\tbuf = ERR_PTR(-ENOMEM);\n\telse\n\t\tmemcpy(buf, dibh->b_data + sizeof(struct gfs2_dinode), size);\n\tbrelse(dibh);\nout:\n\tgfs2_glock_dq_uninit(&i_gh);\n\tnd_set_link(nd, buf);\n\treturn NULL;\n}"
  },
  {
    "function_name": "gfs2_rename",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/inode.c",
    "lines": "1319-1539",
    "snippet": "static int gfs2_rename(struct inode *odir, struct dentry *odentry,\n\t\t       struct inode *ndir, struct dentry *ndentry)\n{\n\tstruct gfs2_inode *odip = GFS2_I(odir);\n\tstruct gfs2_inode *ndip = GFS2_I(ndir);\n\tstruct gfs2_inode *ip = GFS2_I(odentry->d_inode);\n\tstruct gfs2_inode *nip = NULL;\n\tstruct gfs2_sbd *sdp = GFS2_SB(odir);\n\tstruct gfs2_holder ghs[5], r_gh = { .gh_gl = NULL, };\n\tstruct gfs2_rgrpd *nrgd;\n\tunsigned int num_gh;\n\tint dir_rename = 0;\n\tstruct gfs2_diradd da = { .nr_blocks = 0, .save_loc = 0, };\n\tunsigned int x;\n\tint error;\n\n\tif (ndentry->d_inode) {\n\t\tnip = GFS2_I(ndentry->d_inode);\n\t\tif (ip == nip)\n\t\t\treturn 0;\n\t}\n\n\terror = gfs2_rindex_update(sdp);\n\tif (error)\n\t\treturn error;\n\n\terror = gfs2_rs_alloc(ndip);\n\tif (error)\n\t\treturn error;\n\n\tif (odip != ndip) {\n\t\terror = gfs2_glock_nq_init(sdp->sd_rename_gl, LM_ST_EXCLUSIVE,\n\t\t\t\t\t   0, &r_gh);\n\t\tif (error)\n\t\t\tgoto out;\n\n\t\tif (S_ISDIR(ip->i_inode.i_mode)) {\n\t\t\tdir_rename = 1;\n\t\t\t/* don't move a dirctory into it's subdir */\n\t\t\terror = gfs2_ok_to_move(ip, ndip);\n\t\t\tif (error)\n\t\t\t\tgoto out_gunlock_r;\n\t\t}\n\t}\n\n\tnum_gh = 1;\n\tgfs2_holder_init(odip->i_gl, LM_ST_EXCLUSIVE, 0, ghs);\n\tif (odip != ndip) {\n\t\tgfs2_holder_init(ndip->i_gl, LM_ST_EXCLUSIVE, 0, ghs + num_gh);\n\t\tnum_gh++;\n\t}\n\tgfs2_holder_init(ip->i_gl, LM_ST_EXCLUSIVE, 0, ghs + num_gh);\n\tnum_gh++;\n\n\tif (nip) {\n\t\tgfs2_holder_init(nip->i_gl, LM_ST_EXCLUSIVE, 0, ghs + num_gh);\n\t\tnum_gh++;\n\t\t/* grab the resource lock for unlink flag twiddling \n\t\t * this is the case of the target file already existing\n\t\t * so we unlink before doing the rename\n\t\t */\n\t\tnrgd = gfs2_blk2rgrpd(sdp, nip->i_no_addr, 1);\n\t\tif (nrgd)\n\t\t\tgfs2_holder_init(nrgd->rd_gl, LM_ST_EXCLUSIVE, 0, ghs + num_gh++);\n\t}\n\n\tfor (x = 0; x < num_gh; x++) {\n\t\terror = gfs2_glock_nq(ghs + x);\n\t\tif (error)\n\t\t\tgoto out_gunlock;\n\t}\n\n\terror = -ENOENT;\n\tif (ip->i_inode.i_nlink == 0)\n\t\tgoto out_gunlock;\n\n\t/* Check out the old directory */\n\n\terror = gfs2_unlink_ok(odip, &odentry->d_name, ip);\n\tif (error)\n\t\tgoto out_gunlock;\n\n\t/* Check out the new directory */\n\n\tif (nip) {\n\t\terror = gfs2_unlink_ok(ndip, &ndentry->d_name, nip);\n\t\tif (error)\n\t\t\tgoto out_gunlock;\n\n\t\tif (nip->i_inode.i_nlink == 0) {\n\t\t\terror = -EAGAIN;\n\t\t\tgoto out_gunlock;\n\t\t}\n\n\t\tif (S_ISDIR(nip->i_inode.i_mode)) {\n\t\t\tif (nip->i_entries < 2) {\n\t\t\t\tgfs2_consist_inode(nip);\n\t\t\t\terror = -EIO;\n\t\t\t\tgoto out_gunlock;\n\t\t\t}\n\t\t\tif (nip->i_entries > 2) {\n\t\t\t\terror = -ENOTEMPTY;\n\t\t\t\tgoto out_gunlock;\n\t\t\t}\n\t\t}\n\t} else {\n\t\terror = gfs2_permission(ndir, MAY_WRITE | MAY_EXEC);\n\t\tif (error)\n\t\t\tgoto out_gunlock;\n\n\t\terror = gfs2_dir_check(ndir, &ndentry->d_name, NULL);\n\t\tswitch (error) {\n\t\tcase -ENOENT:\n\t\t\terror = 0;\n\t\t\tbreak;\n\t\tcase 0:\n\t\t\terror = -EEXIST;\n\t\tdefault:\n\t\t\tgoto out_gunlock;\n\t\t};\n\n\t\tif (odip != ndip) {\n\t\t\tif (!ndip->i_inode.i_nlink) {\n\t\t\t\terror = -ENOENT;\n\t\t\t\tgoto out_gunlock;\n\t\t\t}\n\t\t\tif (ndip->i_entries == (u32)-1) {\n\t\t\t\terror = -EFBIG;\n\t\t\t\tgoto out_gunlock;\n\t\t\t}\n\t\t\tif (S_ISDIR(ip->i_inode.i_mode) &&\n\t\t\t    ndip->i_inode.i_nlink == (u32)-1) {\n\t\t\t\terror = -EMLINK;\n\t\t\t\tgoto out_gunlock;\n\t\t\t}\n\t\t}\n\t}\n\n\t/* Check out the dir to be renamed */\n\n\tif (dir_rename) {\n\t\terror = gfs2_permission(odentry->d_inode, MAY_WRITE);\n\t\tif (error)\n\t\t\tgoto out_gunlock;\n\t}\n\n\tif (nip == NULL) {\n\t\terror = gfs2_diradd_alloc_required(ndir, &ndentry->d_name, &da);\n\t\tif (error)\n\t\t\tgoto out_gunlock;\n\t}\n\n\tif (da.nr_blocks) {\n\t\tstruct gfs2_alloc_parms ap = { .target = da.nr_blocks, };\n\t\terror = gfs2_quota_lock_check(ndip);\n\t\tif (error)\n\t\t\tgoto out_gunlock;\n\n\t\terror = gfs2_inplace_reserve(ndip, &ap);\n\t\tif (error)\n\t\t\tgoto out_gunlock_q;\n\n\t\terror = gfs2_trans_begin(sdp, gfs2_trans_da_blks(ndip, &da, 4) +\n\t\t\t\t\t 4 * RES_LEAF + 4, 0);\n\t\tif (error)\n\t\t\tgoto out_ipreserv;\n\t} else {\n\t\terror = gfs2_trans_begin(sdp, 4 * RES_DINODE +\n\t\t\t\t\t 5 * RES_LEAF + 4, 0);\n\t\tif (error)\n\t\t\tgoto out_gunlock;\n\t}\n\n\t/* Remove the target file, if it exists */\n\n\tif (nip)\n\t\terror = gfs2_unlink_inode(ndip, ndentry);\n\n\tif (dir_rename) {\n\t\terror = gfs2_dir_mvino(ip, &gfs2_qdotdot, ndip, DT_DIR);\n\t\tif (error)\n\t\t\tgoto out_end_trans;\n\t} else {\n\t\tstruct buffer_head *dibh;\n\t\terror = gfs2_meta_inode_buffer(ip, &dibh);\n\t\tif (error)\n\t\t\tgoto out_end_trans;\n\t\tip->i_inode.i_ctime = CURRENT_TIME;\n\t\tgfs2_trans_add_meta(ip->i_gl, dibh);\n\t\tgfs2_dinode_out(ip, dibh->b_data);\n\t\tbrelse(dibh);\n\t}\n\n\terror = gfs2_dir_del(odip, odentry);\n\tif (error)\n\t\tgoto out_end_trans;\n\n\terror = gfs2_dir_add(ndir, &ndentry->d_name, ip, &da);\n\tif (error)\n\t\tgoto out_end_trans;\n\nout_end_trans:\n\tgfs2_trans_end(sdp);\nout_ipreserv:\n\tif (da.nr_blocks)\n\t\tgfs2_inplace_release(ndip);\nout_gunlock_q:\n\tif (da.nr_blocks)\n\t\tgfs2_quota_unlock(ndip);\nout_gunlock:\n\tgfs2_dir_no_add(&da);\n\twhile (x--) {\n\t\tgfs2_glock_dq(ghs + x);\n\t\tgfs2_holder_uninit(ghs + x);\n\t}\nout_gunlock_r:\n\tif (r_gh.gh_gl)\n\t\tgfs2_glock_dq_uninit(&r_gh);\nout:\n\treturn error;\n}",
    "includes": [
      "#include \"glops.h\"",
      "#include \"super.h\"",
      "#include \"util.h\"",
      "#include \"trans.h\"",
      "#include \"rgrp.h\"",
      "#include \"quota.h\"",
      "#include \"meta_io.h\"",
      "#include \"inode.h\"",
      "#include \"glock.h\"",
      "#include \"xattr.h\"",
      "#include \"dir.h\"",
      "#include \"bmap.h\"",
      "#include \"acl.h\"",
      "#include \"incore.h\"",
      "#include \"gfs2.h\"",
      "#include <asm/uaccess.h>",
      "#include <linux/security.h>",
      "#include <linux/fiemap.h>",
      "#include <linux/crc32.h>",
      "#include <linux/gfs2_ondisk.h>",
      "#include <linux/posix_acl.h>",
      "#include <linux/xattr.h>",
      "#include <linux/mm.h>",
      "#include <linux/namei.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/completion.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "gfs2_glock_dq_uninit",
          "args": [
            "&r_gh"
          ],
          "line": 1536
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_glock_dq_uninit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/glock.c",
          "lines": "1110-1114",
          "snippet": "void gfs2_glock_dq_uninit(struct gfs2_holder *gh)\n{\n\tgfs2_glock_dq(gh);\n\tgfs2_holder_uninit(gh);\n}",
          "includes": [
            "#include \"trace_gfs2.h\"",
            "#include \"bmap.h\"",
            "#include \"util.h\"",
            "#include \"super.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"lops.h\"",
            "#include \"inode.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/lockref.h>",
            "#include <linux/list_sort.h>",
            "#include <linux/percpu.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/seq_file.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/module.h>",
            "#include <linux/wait.h>",
            "#include <linux/list.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/jhash.h>",
            "#include <linux/sort.h>",
            "#include <linux/delay.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"bmap.h\"\n#include \"util.h\"\n#include \"super.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"lops.h\"\n#include \"inode.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/lockref.h>\n#include <linux/list_sort.h>\n#include <linux/percpu.h>\n#include <linux/bit_spinlock.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/jiffies.h>\n#include <linux/workqueue.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <asm/uaccess.h>\n#include <linux/module.h>\n#include <linux/wait.h>\n#include <linux/list.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/kallsyms.h>\n#include <linux/jhash.h>\n#include <linux/sort.h>\n#include <linux/delay.h>\n#include <linux/buffer_head.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nvoid gfs2_glock_dq_uninit(struct gfs2_holder *gh)\n{\n\tgfs2_glock_dq(gh);\n\tgfs2_holder_uninit(gh);\n}"
        }
      },
      {
        "call_info": {
          "callee": "gfs2_holder_uninit",
          "args": [
            "ghs + x"
          ],
          "line": 1532
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_holder_uninit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/glock.c",
          "lines": "841-847",
          "snippet": "void gfs2_holder_uninit(struct gfs2_holder *gh)\n{\n\tput_pid(gh->gh_owner_pid);\n\tgfs2_glock_put(gh->gh_gl);\n\tgh->gh_gl = NULL;\n\tgh->gh_ip = 0;\n}",
          "includes": [
            "#include \"trace_gfs2.h\"",
            "#include \"bmap.h\"",
            "#include \"util.h\"",
            "#include \"super.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"lops.h\"",
            "#include \"inode.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/lockref.h>",
            "#include <linux/list_sort.h>",
            "#include <linux/percpu.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/seq_file.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/module.h>",
            "#include <linux/wait.h>",
            "#include <linux/list.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/jhash.h>",
            "#include <linux/sort.h>",
            "#include <linux/delay.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"bmap.h\"\n#include \"util.h\"\n#include \"super.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"lops.h\"\n#include \"inode.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/lockref.h>\n#include <linux/list_sort.h>\n#include <linux/percpu.h>\n#include <linux/bit_spinlock.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/jiffies.h>\n#include <linux/workqueue.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <asm/uaccess.h>\n#include <linux/module.h>\n#include <linux/wait.h>\n#include <linux/list.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/kallsyms.h>\n#include <linux/jhash.h>\n#include <linux/sort.h>\n#include <linux/delay.h>\n#include <linux/buffer_head.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nvoid gfs2_holder_uninit(struct gfs2_holder *gh)\n{\n\tput_pid(gh->gh_owner_pid);\n\tgfs2_glock_put(gh->gh_gl);\n\tgh->gh_gl = NULL;\n\tgh->gh_ip = 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "gfs2_dir_no_add",
          "args": [
            "&da"
          ],
          "line": 1529
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_dir_no_add",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/dir.h",
          "lines": "36-41",
          "snippet": "static inline void gfs2_dir_no_add(struct gfs2_diradd *da)\n{\n\tif (da->bh)\n\t\tbrelse(da->bh);\n\tda->bh = NULL;\n}",
          "includes": [
            "#include <linux/crc32.h>",
            "#include <linux/dcache.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/crc32.h>\n#include <linux/dcache.h>\n\nstatic inline void gfs2_dir_no_add(struct gfs2_diradd *da)\n{\n\tif (da->bh)\n\t\tbrelse(da->bh);\n\tda->bh = NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "gfs2_quota_unlock",
          "args": [
            "ndip"
          ],
          "line": 1527
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_quota_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/quota.c",
          "lines": "1033-1081",
          "snippet": "void gfs2_quota_unlock(struct gfs2_inode *ip)\n{\n\tstruct gfs2_sbd *sdp = GFS2_SB(&ip->i_inode);\n\tstruct gfs2_quota_data *qda[4];\n\tunsigned int count = 0;\n\tunsigned int x;\n\tint found;\n\n\tif (!test_and_clear_bit(GIF_QD_LOCKED, &ip->i_flags))\n\t\tgoto out;\n\n\tfor (x = 0; x < ip->i_res->rs_qa_qd_num; x++) {\n\t\tstruct gfs2_quota_data *qd;\n\t\tint sync;\n\n\t\tqd = ip->i_res->rs_qa_qd[x];\n\t\tsync = need_sync(qd);\n\n\t\tgfs2_glock_dq_uninit(&ip->i_res->rs_qa_qd_ghs[x]);\n\t\tif (!sync)\n\t\t\tcontinue;\n\n\t\tspin_lock(&qd_lock);\n\t\tfound = qd_check_sync(sdp, qd, NULL);\n\t\tspin_unlock(&qd_lock);\n\n\t\tif (!found)\n\t\t\tcontinue;\n\n\t\tgfs2_assert_warn(sdp, qd->qd_change_sync);\n\t\tif (bh_get(qd)) {\n\t\t\tclear_bit(QDF_LOCKED, &qd->qd_flags);\n\t\t\tslot_put(qd);\n\t\t\tqd_put(qd);\n\t\t\tcontinue;\n\t\t}\n\n\t\tqda[count++] = qd;\n\t}\n\n\tif (count) {\n\t\tdo_sync(count, qda);\n\t\tfor (x = 0; x < count; x++)\n\t\t\tqd_unlock(qda[x]);\n\t}\n\nout:\n\tgfs2_quota_unhold(ip);\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"inode.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"log.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"bmap.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/jhash.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/lockref.h>",
            "#include <linux/dqblk_xfs.h>",
            "#include <linux/quota.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/bio.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_SPINLOCK(qd_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"inode.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"log.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/vmalloc.h>\n#include <linux/jhash.h>\n#include <linux/bit_spinlock.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/list_lru.h>\n#include <linux/lockref.h>\n#include <linux/dqblk_xfs.h>\n#include <linux/quota.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/bio.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic DEFINE_SPINLOCK(qd_lock);\n\nvoid gfs2_quota_unlock(struct gfs2_inode *ip)\n{\n\tstruct gfs2_sbd *sdp = GFS2_SB(&ip->i_inode);\n\tstruct gfs2_quota_data *qda[4];\n\tunsigned int count = 0;\n\tunsigned int x;\n\tint found;\n\n\tif (!test_and_clear_bit(GIF_QD_LOCKED, &ip->i_flags))\n\t\tgoto out;\n\n\tfor (x = 0; x < ip->i_res->rs_qa_qd_num; x++) {\n\t\tstruct gfs2_quota_data *qd;\n\t\tint sync;\n\n\t\tqd = ip->i_res->rs_qa_qd[x];\n\t\tsync = need_sync(qd);\n\n\t\tgfs2_glock_dq_uninit(&ip->i_res->rs_qa_qd_ghs[x]);\n\t\tif (!sync)\n\t\t\tcontinue;\n\n\t\tspin_lock(&qd_lock);\n\t\tfound = qd_check_sync(sdp, qd, NULL);\n\t\tspin_unlock(&qd_lock);\n\n\t\tif (!found)\n\t\t\tcontinue;\n\n\t\tgfs2_assert_warn(sdp, qd->qd_change_sync);\n\t\tif (bh_get(qd)) {\n\t\t\tclear_bit(QDF_LOCKED, &qd->qd_flags);\n\t\t\tslot_put(qd);\n\t\t\tqd_put(qd);\n\t\t\tcontinue;\n\t\t}\n\n\t\tqda[count++] = qd;\n\t}\n\n\tif (count) {\n\t\tdo_sync(count, qda);\n\t\tfor (x = 0; x < count; x++)\n\t\t\tqd_unlock(qda[x]);\n\t}\n\nout:\n\tgfs2_quota_unhold(ip);\n}"
        }
      },
      {
        "call_info": {
          "callee": "gfs2_inplace_release",
          "args": [
            "ndip"
          ],
          "line": 1524
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_inplace_release",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/rgrp.c",
          "lines": "2081-2087",
          "snippet": "void gfs2_inplace_release(struct gfs2_inode *ip)\n{\n\tstruct gfs2_blkreserv *rs = ip->i_res;\n\n\tif (rs->rs_rgd_gh.gh_gl)\n\t\tgfs2_glock_dq_uninit(&rs->rs_rgd_gh);\n}",
          "includes": [
            "#include \"trace_gfs2.h\"",
            "#include \"inode.h\"",
            "#include \"log.h\"",
            "#include \"util.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"lops.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/random.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/fs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"inode.h\"\n#include \"log.h\"\n#include \"util.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"lops.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/random.h>\n#include <linux/rbtree.h>\n#include <linux/blkdev.h>\n#include <linux/prefetch.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/fs.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nvoid gfs2_inplace_release(struct gfs2_inode *ip)\n{\n\tstruct gfs2_blkreserv *rs = ip->i_res;\n\n\tif (rs->rs_rgd_gh.gh_gl)\n\t\tgfs2_glock_dq_uninit(&rs->rs_rgd_gh);\n}"
        }
      },
      {
        "call_info": {
          "callee": "gfs2_trans_end",
          "args": [
            "sdp"
          ],
          "line": 1521
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_trans_end",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/trans.c",
          "lines": "88-123",
          "snippet": "void gfs2_trans_end(struct gfs2_sbd *sdp)\n{\n\tstruct gfs2_trans *tr = current->journal_info;\n\ts64 nbuf;\n\tint alloced = tr->tr_alloced;\n\n\tBUG_ON(!tr);\n\tcurrent->journal_info = NULL;\n\n\tif (!tr->tr_touched) {\n\t\tgfs2_log_release(sdp, tr->tr_reserved);\n\t\tif (alloced) {\n\t\t\tkfree(tr);\n\t\t\tsb_end_intwrite(sdp->sd_vfs);\n\t\t}\n\t\treturn;\n\t}\n\n\tnbuf = tr->tr_num_buf_new + tr->tr_num_databuf_new;\n\tnbuf -= tr->tr_num_buf_rm;\n\tnbuf -= tr->tr_num_databuf_rm;\n\n\tif (gfs2_assert_withdraw(sdp, (nbuf <= tr->tr_blocks) &&\n\t\t\t\t       (tr->tr_num_revoke <= tr->tr_revokes)))\n\t\tgfs2_print_trans(tr);\n\n\tgfs2_log_commit(sdp, tr);\n\tif (alloced && !tr->tr_attached)\n\t\t\tkfree(tr);\n\tup_read(&sdp->sd_log_flush_lock);\n\n\tif (sdp->sd_vfs->s_flags & MS_SYNCHRONOUS)\n\t\tgfs2_log_flush(sdp, NULL, NORMAL_FLUSH);\n\tif (alloced)\n\t\tsb_end_intwrite(sdp->sd_vfs);\n}",
          "includes": [
            "#include \"trace_gfs2.h\"",
            "#include \"util.h\"",
            "#include \"trans.h\"",
            "#include \"meta_io.h\"",
            "#include \"lops.h\"",
            "#include \"log.h\"",
            "#include \"inode.h\"",
            "#include \"glock.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"util.h\"\n#include \"trans.h\"\n#include \"meta_io.h\"\n#include \"lops.h\"\n#include \"log.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/gfs2_ondisk.h>\n#include <linux/kallsyms.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nvoid gfs2_trans_end(struct gfs2_sbd *sdp)\n{\n\tstruct gfs2_trans *tr = current->journal_info;\n\ts64 nbuf;\n\tint alloced = tr->tr_alloced;\n\n\tBUG_ON(!tr);\n\tcurrent->journal_info = NULL;\n\n\tif (!tr->tr_touched) {\n\t\tgfs2_log_release(sdp, tr->tr_reserved);\n\t\tif (alloced) {\n\t\t\tkfree(tr);\n\t\t\tsb_end_intwrite(sdp->sd_vfs);\n\t\t}\n\t\treturn;\n\t}\n\n\tnbuf = tr->tr_num_buf_new + tr->tr_num_databuf_new;\n\tnbuf -= tr->tr_num_buf_rm;\n\tnbuf -= tr->tr_num_databuf_rm;\n\n\tif (gfs2_assert_withdraw(sdp, (nbuf <= tr->tr_blocks) &&\n\t\t\t\t       (tr->tr_num_revoke <= tr->tr_revokes)))\n\t\tgfs2_print_trans(tr);\n\n\tgfs2_log_commit(sdp, tr);\n\tif (alloced && !tr->tr_attached)\n\t\t\tkfree(tr);\n\tup_read(&sdp->sd_log_flush_lock);\n\n\tif (sdp->sd_vfs->s_flags & MS_SYNCHRONOUS)\n\t\tgfs2_log_flush(sdp, NULL, NORMAL_FLUSH);\n\tif (alloced)\n\t\tsb_end_intwrite(sdp->sd_vfs);\n}"
        }
      },
      {
        "call_info": {
          "callee": "gfs2_dir_add",
          "args": [
            "ndir",
            "&ndentry->d_name",
            "ip",
            "&da"
          ],
          "line": 1516
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_dir_add",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/dir.c",
          "lines": "1693-1761",
          "snippet": "int gfs2_dir_add(struct inode *inode, const struct qstr *name,\n\t\t const struct gfs2_inode *nip, struct gfs2_diradd *da)\n{\n\tstruct gfs2_inode *ip = GFS2_I(inode);\n\tstruct buffer_head *bh = da->bh;\n\tstruct gfs2_dirent *dent = da->dent;\n\tstruct timespec tv;\n\tstruct gfs2_leaf *leaf;\n\tint error;\n\n\twhile(1) {\n\t\tif (da->bh == NULL) {\n\t\t\tdent = gfs2_dirent_search(inode, name,\n\t\t\t\t\t\t  gfs2_dirent_find_space, &bh);\n\t\t}\n\t\tif (dent) {\n\t\t\tif (IS_ERR(dent))\n\t\t\t\treturn PTR_ERR(dent);\n\t\t\tdent = gfs2_init_dirent(inode, dent, name, bh);\n\t\t\tgfs2_inum_out(nip, dent);\n\t\t\tdent->de_type = cpu_to_be16(IF2DT(nip->i_inode.i_mode));\n\t\t\tdent->de_rahead = cpu_to_be16(gfs2_inode_ra_len(nip));\n\t\t\ttv = CURRENT_TIME;\n\t\t\tif (ip->i_diskflags & GFS2_DIF_EXHASH) {\n\t\t\t\tleaf = (struct gfs2_leaf *)bh->b_data;\n\t\t\t\tbe16_add_cpu(&leaf->lf_entries, 1);\n\t\t\t\tleaf->lf_nsec = cpu_to_be32(tv.tv_nsec);\n\t\t\t\tleaf->lf_sec = cpu_to_be64(tv.tv_sec);\n\t\t\t}\n\t\t\tda->dent = NULL;\n\t\t\tda->bh = NULL;\n\t\t\tbrelse(bh);\n\t\t\tip->i_entries++;\n\t\t\tip->i_inode.i_mtime = ip->i_inode.i_ctime = tv;\n\t\t\tif (S_ISDIR(nip->i_inode.i_mode))\n\t\t\t\tinc_nlink(&ip->i_inode);\n\t\t\tmark_inode_dirty(inode);\n\t\t\terror = 0;\n\t\t\tbreak;\n\t\t}\n\t\tif (!(ip->i_diskflags & GFS2_DIF_EXHASH)) {\n\t\t\terror = dir_make_exhash(inode);\n\t\t\tif (error)\n\t\t\t\tbreak;\n\t\t\tcontinue;\n\t\t}\n\t\terror = dir_split_leaf(inode, name);\n\t\tif (error == 0)\n\t\t\tcontinue;\n\t\tif (error < 0)\n\t\t\tbreak;\n\t\tif (ip->i_depth < GFS2_DIR_MAX_DEPTH) {\n\t\t\terror = dir_double_exhash(ip);\n\t\t\tif (error)\n\t\t\t\tbreak;\n\t\t\terror = dir_split_leaf(inode, name);\n\t\t\tif (error < 0)\n\t\t\t\tbreak;\n\t\t\tif (error == 0)\n\t\t\t\tcontinue;\n\t\t}\n\t\terror = dir_new_leaf(inode, name);\n\t\tif (!error)\n\t\t\tcontinue;\n\t\terror = -ENOSPC;\n\t\tbreak;\n\t}\n\treturn error;\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"bmap.h\"",
            "#include \"trans.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"inode.h\"",
            "#include \"glock.h\"",
            "#include \"dir.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/crc32.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/sort.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"bmap.h\"\n#include \"trans.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"dir.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/vmalloc.h>\n#include <linux/crc32.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/sort.h>\n#include <linux/buffer_head.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nint gfs2_dir_add(struct inode *inode, const struct qstr *name,\n\t\t const struct gfs2_inode *nip, struct gfs2_diradd *da)\n{\n\tstruct gfs2_inode *ip = GFS2_I(inode);\n\tstruct buffer_head *bh = da->bh;\n\tstruct gfs2_dirent *dent = da->dent;\n\tstruct timespec tv;\n\tstruct gfs2_leaf *leaf;\n\tint error;\n\n\twhile(1) {\n\t\tif (da->bh == NULL) {\n\t\t\tdent = gfs2_dirent_search(inode, name,\n\t\t\t\t\t\t  gfs2_dirent_find_space, &bh);\n\t\t}\n\t\tif (dent) {\n\t\t\tif (IS_ERR(dent))\n\t\t\t\treturn PTR_ERR(dent);\n\t\t\tdent = gfs2_init_dirent(inode, dent, name, bh);\n\t\t\tgfs2_inum_out(nip, dent);\n\t\t\tdent->de_type = cpu_to_be16(IF2DT(nip->i_inode.i_mode));\n\t\t\tdent->de_rahead = cpu_to_be16(gfs2_inode_ra_len(nip));\n\t\t\ttv = CURRENT_TIME;\n\t\t\tif (ip->i_diskflags & GFS2_DIF_EXHASH) {\n\t\t\t\tleaf = (struct gfs2_leaf *)bh->b_data;\n\t\t\t\tbe16_add_cpu(&leaf->lf_entries, 1);\n\t\t\t\tleaf->lf_nsec = cpu_to_be32(tv.tv_nsec);\n\t\t\t\tleaf->lf_sec = cpu_to_be64(tv.tv_sec);\n\t\t\t}\n\t\t\tda->dent = NULL;\n\t\t\tda->bh = NULL;\n\t\t\tbrelse(bh);\n\t\t\tip->i_entries++;\n\t\t\tip->i_inode.i_mtime = ip->i_inode.i_ctime = tv;\n\t\t\tif (S_ISDIR(nip->i_inode.i_mode))\n\t\t\t\tinc_nlink(&ip->i_inode);\n\t\t\tmark_inode_dirty(inode);\n\t\t\terror = 0;\n\t\t\tbreak;\n\t\t}\n\t\tif (!(ip->i_diskflags & GFS2_DIF_EXHASH)) {\n\t\t\terror = dir_make_exhash(inode);\n\t\t\tif (error)\n\t\t\t\tbreak;\n\t\t\tcontinue;\n\t\t}\n\t\terror = dir_split_leaf(inode, name);\n\t\tif (error == 0)\n\t\t\tcontinue;\n\t\tif (error < 0)\n\t\t\tbreak;\n\t\tif (ip->i_depth < GFS2_DIR_MAX_DEPTH) {\n\t\t\terror = dir_double_exhash(ip);\n\t\t\tif (error)\n\t\t\t\tbreak;\n\t\t\terror = dir_split_leaf(inode, name);\n\t\t\tif (error < 0)\n\t\t\t\tbreak;\n\t\t\tif (error == 0)\n\t\t\t\tcontinue;\n\t\t}\n\t\terror = dir_new_leaf(inode, name);\n\t\tif (!error)\n\t\t\tcontinue;\n\t\terror = -ENOSPC;\n\t\tbreak;\n\t}\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "gfs2_dir_del",
          "args": [
            "odip",
            "odentry"
          ],
          "line": 1512
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_dir_del",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/dir.c",
          "lines": "1772-1817",
          "snippet": "int gfs2_dir_del(struct gfs2_inode *dip, const struct dentry *dentry)\n{\n\tconst struct qstr *name = &dentry->d_name;\n\tstruct gfs2_dirent *dent, *prev = NULL;\n\tstruct buffer_head *bh;\n\tstruct timespec tv = CURRENT_TIME;\n\n\t/* Returns _either_ the entry (if its first in block) or the\n\t   previous entry otherwise */\n\tdent = gfs2_dirent_search(&dip->i_inode, name, gfs2_dirent_prev, &bh);\n\tif (!dent) {\n\t\tgfs2_consist_inode(dip);\n\t\treturn -EIO;\n\t}\n\tif (IS_ERR(dent)) {\n\t\tgfs2_consist_inode(dip);\n\t\treturn PTR_ERR(dent);\n\t}\n\t/* If not first in block, adjust pointers accordingly */\n\tif (gfs2_dirent_find(dent, name, NULL) == 0) {\n\t\tprev = dent;\n\t\tdent = (struct gfs2_dirent *)((char *)dent + be16_to_cpu(prev->de_rec_len));\n\t}\n\n\tdirent_del(dip, bh, prev, dent);\n\tif (dip->i_diskflags & GFS2_DIF_EXHASH) {\n\t\tstruct gfs2_leaf *leaf = (struct gfs2_leaf *)bh->b_data;\n\t\tu16 entries = be16_to_cpu(leaf->lf_entries);\n\t\tif (!entries)\n\t\t\tgfs2_consist_inode(dip);\n\t\tleaf->lf_entries = cpu_to_be16(--entries);\n\t\tleaf->lf_nsec = cpu_to_be32(tv.tv_nsec);\n\t\tleaf->lf_sec = cpu_to_be64(tv.tv_sec);\n\t}\n\tbrelse(bh);\n\n\tif (!dip->i_entries)\n\t\tgfs2_consist_inode(dip);\n\tdip->i_entries--;\n\tdip->i_inode.i_mtime = dip->i_inode.i_ctime = tv;\n\tif (d_is_dir(dentry))\n\t\tdrop_nlink(&dip->i_inode);\n\tmark_inode_dirty(&dip->i_inode);\n\n\treturn 0;\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"bmap.h\"",
            "#include \"trans.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"inode.h\"",
            "#include \"glock.h\"",
            "#include \"dir.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/crc32.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/sort.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"bmap.h\"\n#include \"trans.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"dir.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/vmalloc.h>\n#include <linux/crc32.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/sort.h>\n#include <linux/buffer_head.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nint gfs2_dir_del(struct gfs2_inode *dip, const struct dentry *dentry)\n{\n\tconst struct qstr *name = &dentry->d_name;\n\tstruct gfs2_dirent *dent, *prev = NULL;\n\tstruct buffer_head *bh;\n\tstruct timespec tv = CURRENT_TIME;\n\n\t/* Returns _either_ the entry (if its first in block) or the\n\t   previous entry otherwise */\n\tdent = gfs2_dirent_search(&dip->i_inode, name, gfs2_dirent_prev, &bh);\n\tif (!dent) {\n\t\tgfs2_consist_inode(dip);\n\t\treturn -EIO;\n\t}\n\tif (IS_ERR(dent)) {\n\t\tgfs2_consist_inode(dip);\n\t\treturn PTR_ERR(dent);\n\t}\n\t/* If not first in block, adjust pointers accordingly */\n\tif (gfs2_dirent_find(dent, name, NULL) == 0) {\n\t\tprev = dent;\n\t\tdent = (struct gfs2_dirent *)((char *)dent + be16_to_cpu(prev->de_rec_len));\n\t}\n\n\tdirent_del(dip, bh, prev, dent);\n\tif (dip->i_diskflags & GFS2_DIF_EXHASH) {\n\t\tstruct gfs2_leaf *leaf = (struct gfs2_leaf *)bh->b_data;\n\t\tu16 entries = be16_to_cpu(leaf->lf_entries);\n\t\tif (!entries)\n\t\t\tgfs2_consist_inode(dip);\n\t\tleaf->lf_entries = cpu_to_be16(--entries);\n\t\tleaf->lf_nsec = cpu_to_be32(tv.tv_nsec);\n\t\tleaf->lf_sec = cpu_to_be64(tv.tv_sec);\n\t}\n\tbrelse(bh);\n\n\tif (!dip->i_entries)\n\t\tgfs2_consist_inode(dip);\n\tdip->i_entries--;\n\tdip->i_inode.i_mtime = dip->i_inode.i_ctime = tv;\n\tif (d_is_dir(dentry))\n\t\tdrop_nlink(&dip->i_inode);\n\tmark_inode_dirty(&dip->i_inode);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "brelse",
          "args": [
            "dibh"
          ],
          "line": 1509
        },
        "resolved": true,
        "details": {
          "function_name": "__brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1177-1184",
          "snippet": "void __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "gfs2_dinode_out",
          "args": [
            "ip",
            "dibh->b_data"
          ],
          "line": 1508
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_dinode_out",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/super.c",
          "lines": "696-731",
          "snippet": "void gfs2_dinode_out(const struct gfs2_inode *ip, void *buf)\n{\n\tstruct gfs2_dinode *str = buf;\n\n\tstr->di_header.mh_magic = cpu_to_be32(GFS2_MAGIC);\n\tstr->di_header.mh_type = cpu_to_be32(GFS2_METATYPE_DI);\n\tstr->di_header.mh_format = cpu_to_be32(GFS2_FORMAT_DI);\n\tstr->di_num.no_addr = cpu_to_be64(ip->i_no_addr);\n\tstr->di_num.no_formal_ino = cpu_to_be64(ip->i_no_formal_ino);\n\tstr->di_mode = cpu_to_be32(ip->i_inode.i_mode);\n\tstr->di_uid = cpu_to_be32(i_uid_read(&ip->i_inode));\n\tstr->di_gid = cpu_to_be32(i_gid_read(&ip->i_inode));\n\tstr->di_nlink = cpu_to_be32(ip->i_inode.i_nlink);\n\tstr->di_size = cpu_to_be64(i_size_read(&ip->i_inode));\n\tstr->di_blocks = cpu_to_be64(gfs2_get_inode_blocks(&ip->i_inode));\n\tstr->di_atime = cpu_to_be64(ip->i_inode.i_atime.tv_sec);\n\tstr->di_mtime = cpu_to_be64(ip->i_inode.i_mtime.tv_sec);\n\tstr->di_ctime = cpu_to_be64(ip->i_inode.i_ctime.tv_sec);\n\n\tstr->di_goal_meta = cpu_to_be64(ip->i_goal);\n\tstr->di_goal_data = cpu_to_be64(ip->i_goal);\n\tstr->di_generation = cpu_to_be64(ip->i_generation);\n\n\tstr->di_flags = cpu_to_be32(ip->i_diskflags);\n\tstr->di_height = cpu_to_be16(ip->i_height);\n\tstr->di_payload_format = cpu_to_be32(S_ISDIR(ip->i_inode.i_mode) &&\n\t\t\t\t\t     !(ip->i_diskflags & GFS2_DIF_EXHASH) ?\n\t\t\t\t\t     GFS2_FORMAT_DE : 0);\n\tstr->di_depth = cpu_to_be16(ip->i_depth);\n\tstr->di_entries = cpu_to_be32(ip->i_entries);\n\n\tstr->di_eattr = cpu_to_be64(ip->i_eattr);\n\tstr->di_atime_nsec = cpu_to_be32(ip->i_inode.i_atime.tv_nsec);\n\tstr->di_mtime_nsec = cpu_to_be32(ip->i_inode.i_mtime.tv_nsec);\n\tstr->di_ctime_nsec = cpu_to_be32(ip->i_inode.i_ctime.tv_nsec);\n}",
          "includes": [
            "#include \"xattr.h\"",
            "#include \"sys.h\"",
            "#include \"util.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"recovery.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"log.h\"",
            "#include \"inode.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"dir.h\"",
            "#include \"bmap.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/kernel.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/wait.h>",
            "#include <linux/time.h>",
            "#include <linux/crc32.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/mount.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/statfs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/bio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xattr.h\"\n#include \"sys.h\"\n#include \"util.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"recovery.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"log.h\"\n#include \"inode.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"dir.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/kernel.h>\n#include <linux/backing-dev.h>\n#include <linux/writeback.h>\n#include <linux/wait.h>\n#include <linux/time.h>\n#include <linux/crc32.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/mount.h>\n#include <linux/seq_file.h>\n#include <linux/statfs.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/bio.h>\n\nvoid gfs2_dinode_out(const struct gfs2_inode *ip, void *buf)\n{\n\tstruct gfs2_dinode *str = buf;\n\n\tstr->di_header.mh_magic = cpu_to_be32(GFS2_MAGIC);\n\tstr->di_header.mh_type = cpu_to_be32(GFS2_METATYPE_DI);\n\tstr->di_header.mh_format = cpu_to_be32(GFS2_FORMAT_DI);\n\tstr->di_num.no_addr = cpu_to_be64(ip->i_no_addr);\n\tstr->di_num.no_formal_ino = cpu_to_be64(ip->i_no_formal_ino);\n\tstr->di_mode = cpu_to_be32(ip->i_inode.i_mode);\n\tstr->di_uid = cpu_to_be32(i_uid_read(&ip->i_inode));\n\tstr->di_gid = cpu_to_be32(i_gid_read(&ip->i_inode));\n\tstr->di_nlink = cpu_to_be32(ip->i_inode.i_nlink);\n\tstr->di_size = cpu_to_be64(i_size_read(&ip->i_inode));\n\tstr->di_blocks = cpu_to_be64(gfs2_get_inode_blocks(&ip->i_inode));\n\tstr->di_atime = cpu_to_be64(ip->i_inode.i_atime.tv_sec);\n\tstr->di_mtime = cpu_to_be64(ip->i_inode.i_mtime.tv_sec);\n\tstr->di_ctime = cpu_to_be64(ip->i_inode.i_ctime.tv_sec);\n\n\tstr->di_goal_meta = cpu_to_be64(ip->i_goal);\n\tstr->di_goal_data = cpu_to_be64(ip->i_goal);\n\tstr->di_generation = cpu_to_be64(ip->i_generation);\n\n\tstr->di_flags = cpu_to_be32(ip->i_diskflags);\n\tstr->di_height = cpu_to_be16(ip->i_height);\n\tstr->di_payload_format = cpu_to_be32(S_ISDIR(ip->i_inode.i_mode) &&\n\t\t\t\t\t     !(ip->i_diskflags & GFS2_DIF_EXHASH) ?\n\t\t\t\t\t     GFS2_FORMAT_DE : 0);\n\tstr->di_depth = cpu_to_be16(ip->i_depth);\n\tstr->di_entries = cpu_to_be32(ip->i_entries);\n\n\tstr->di_eattr = cpu_to_be64(ip->i_eattr);\n\tstr->di_atime_nsec = cpu_to_be32(ip->i_inode.i_atime.tv_nsec);\n\tstr->di_mtime_nsec = cpu_to_be32(ip->i_inode.i_mtime.tv_nsec);\n\tstr->di_ctime_nsec = cpu_to_be32(ip->i_inode.i_ctime.tv_nsec);\n}"
        }
      },
      {
        "call_info": {
          "callee": "gfs2_trans_add_meta",
          "args": [
            "ip->i_gl",
            "dibh"
          ],
          "line": 1507
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_trans_add_meta",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/trans.c",
          "lines": "224-247",
          "snippet": "void gfs2_trans_add_meta(struct gfs2_glock *gl, struct buffer_head *bh)\n{\n\n\tstruct gfs2_sbd *sdp = gl->gl_sbd;\n\tstruct gfs2_bufdata *bd;\n\n\tlock_buffer(bh);\n\tgfs2_log_lock(sdp);\n\tbd = bh->b_private;\n\tif (bd == NULL) {\n\t\tgfs2_log_unlock(sdp);\n\t\tunlock_buffer(bh);\n\t\tlock_page(bh->b_page);\n\t\tif (bh->b_private == NULL)\n\t\t\tbd = gfs2_alloc_bufdata(gl, bh, &gfs2_buf_lops);\n\t\tunlock_page(bh->b_page);\n\t\tlock_buffer(bh);\n\t\tgfs2_log_lock(sdp);\n\t}\n\tgfs2_assert(sdp, bd->bd_gl == gl);\n\tmeta_lo_add(sdp, bd);\n\tgfs2_log_unlock(sdp);\n\tunlock_buffer(bh);\n}",
          "includes": [
            "#include \"trace_gfs2.h\"",
            "#include \"util.h\"",
            "#include \"trans.h\"",
            "#include \"meta_io.h\"",
            "#include \"lops.h\"",
            "#include \"log.h\"",
            "#include \"inode.h\"",
            "#include \"glock.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"util.h\"\n#include \"trans.h\"\n#include \"meta_io.h\"\n#include \"lops.h\"\n#include \"log.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/gfs2_ondisk.h>\n#include <linux/kallsyms.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nvoid gfs2_trans_add_meta(struct gfs2_glock *gl, struct buffer_head *bh)\n{\n\n\tstruct gfs2_sbd *sdp = gl->gl_sbd;\n\tstruct gfs2_bufdata *bd;\n\n\tlock_buffer(bh);\n\tgfs2_log_lock(sdp);\n\tbd = bh->b_private;\n\tif (bd == NULL) {\n\t\tgfs2_log_unlock(sdp);\n\t\tunlock_buffer(bh);\n\t\tlock_page(bh->b_page);\n\t\tif (bh->b_private == NULL)\n\t\t\tbd = gfs2_alloc_bufdata(gl, bh, &gfs2_buf_lops);\n\t\tunlock_page(bh->b_page);\n\t\tlock_buffer(bh);\n\t\tgfs2_log_lock(sdp);\n\t}\n\tgfs2_assert(sdp, bd->bd_gl == gl);\n\tmeta_lo_add(sdp, bd);\n\tgfs2_log_unlock(sdp);\n\tunlock_buffer(bh);\n}"
        }
      },
      {
        "call_info": {
          "callee": "gfs2_meta_inode_buffer",
          "args": [
            "ip",
            "&dibh"
          ],
          "line": 1503
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_meta_inode_buffer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/meta_io.h",
          "lines": "66-70",
          "snippet": "static inline int gfs2_meta_inode_buffer(struct gfs2_inode *ip,\n\t\t\t\t\t struct buffer_head **bhp)\n{\n\treturn gfs2_meta_indirect_buffer(ip, 0, ip->i_no_addr, bhp);\n}",
          "includes": [
            "#include \"incore.h\"",
            "#include <linux/string.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"incore.h\"\n#include <linux/string.h>\n#include <linux/buffer_head.h>\n\nstatic inline int gfs2_meta_inode_buffer(struct gfs2_inode *ip,\n\t\t\t\t\t struct buffer_head **bhp)\n{\n\treturn gfs2_meta_indirect_buffer(ip, 0, ip->i_no_addr, bhp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "gfs2_dir_mvino",
          "args": [
            "ip",
            "&gfs2_qdotdot",
            "ndip",
            "DT_DIR"
          ],
          "line": 1498
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_dir_mvino",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/dir.c",
          "lines": "1832-1863",
          "snippet": "int gfs2_dir_mvino(struct gfs2_inode *dip, const struct qstr *filename,\n\t\t   const struct gfs2_inode *nip, unsigned int new_type)\n{\n\tstruct buffer_head *bh;\n\tstruct gfs2_dirent *dent;\n\tint error;\n\n\tdent = gfs2_dirent_search(&dip->i_inode, filename, gfs2_dirent_find, &bh);\n\tif (!dent) {\n\t\tgfs2_consist_inode(dip);\n\t\treturn -EIO;\n\t}\n\tif (IS_ERR(dent))\n\t\treturn PTR_ERR(dent);\n\n\tgfs2_trans_add_meta(dip->i_gl, bh);\n\tgfs2_inum_out(nip, dent);\n\tdent->de_type = cpu_to_be16(new_type);\n\n\tif (dip->i_diskflags & GFS2_DIF_EXHASH) {\n\t\tbrelse(bh);\n\t\terror = gfs2_meta_inode_buffer(dip, &bh);\n\t\tif (error)\n\t\t\treturn error;\n\t\tgfs2_trans_add_meta(dip->i_gl, bh);\n\t}\n\n\tdip->i_inode.i_mtime = dip->i_inode.i_ctime = CURRENT_TIME;\n\tgfs2_dinode_out(dip, bh->b_data);\n\tbrelse(bh);\n\treturn 0;\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"bmap.h\"",
            "#include \"trans.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"inode.h\"",
            "#include \"glock.h\"",
            "#include \"dir.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/crc32.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/sort.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"bmap.h\"\n#include \"trans.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"dir.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/vmalloc.h>\n#include <linux/crc32.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/sort.h>\n#include <linux/buffer_head.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nint gfs2_dir_mvino(struct gfs2_inode *dip, const struct qstr *filename,\n\t\t   const struct gfs2_inode *nip, unsigned int new_type)\n{\n\tstruct buffer_head *bh;\n\tstruct gfs2_dirent *dent;\n\tint error;\n\n\tdent = gfs2_dirent_search(&dip->i_inode, filename, gfs2_dirent_find, &bh);\n\tif (!dent) {\n\t\tgfs2_consist_inode(dip);\n\t\treturn -EIO;\n\t}\n\tif (IS_ERR(dent))\n\t\treturn PTR_ERR(dent);\n\n\tgfs2_trans_add_meta(dip->i_gl, bh);\n\tgfs2_inum_out(nip, dent);\n\tdent->de_type = cpu_to_be16(new_type);\n\n\tif (dip->i_diskflags & GFS2_DIF_EXHASH) {\n\t\tbrelse(bh);\n\t\terror = gfs2_meta_inode_buffer(dip, &bh);\n\t\tif (error)\n\t\t\treturn error;\n\t\tgfs2_trans_add_meta(dip->i_gl, bh);\n\t}\n\n\tdip->i_inode.i_mtime = dip->i_inode.i_ctime = CURRENT_TIME;\n\tgfs2_dinode_out(dip, bh->b_data);\n\tbrelse(bh);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "gfs2_unlink_inode",
          "args": [
            "ndip",
            "ndentry"
          ],
          "line": 1495
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_unlink_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/inode.c",
          "lines": "1055-1076",
          "snippet": "static int gfs2_unlink_inode(struct gfs2_inode *dip,\n\t\t\t     const struct dentry *dentry)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tstruct gfs2_inode *ip = GFS2_I(inode);\n\tint error;\n\n\terror = gfs2_dir_del(dip, dentry);\n\tif (error)\n\t\treturn error;\n\n\tip->i_entries = 0;\n\tinode->i_ctime = CURRENT_TIME;\n\tif (S_ISDIR(inode->i_mode))\n\t\tclear_nlink(inode);\n\telse\n\t\tdrop_nlink(inode);\n\tmark_inode_dirty(inode);\n\tif (inode->i_nlink == 0)\n\t\tgfs2_unlink_di(inode);\n\treturn 0;\n}",
          "includes": [
            "#include \"glops.h\"",
            "#include \"super.h\"",
            "#include \"util.h\"",
            "#include \"trans.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"inode.h\"",
            "#include \"glock.h\"",
            "#include \"xattr.h\"",
            "#include \"dir.h\"",
            "#include \"bmap.h\"",
            "#include \"acl.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/security.h>",
            "#include <linux/fiemap.h>",
            "#include <linux/crc32.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/xattr.h>",
            "#include <linux/mm.h>",
            "#include <linux/namei.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glops.h\"\n#include \"super.h\"\n#include \"util.h\"\n#include \"trans.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"xattr.h\"\n#include \"dir.h\"\n#include \"bmap.h\"\n#include \"acl.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <asm/uaccess.h>\n#include <linux/security.h>\n#include <linux/fiemap.h>\n#include <linux/crc32.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/posix_acl.h>\n#include <linux/xattr.h>\n#include <linux/mm.h>\n#include <linux/namei.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nstatic int gfs2_unlink_inode(struct gfs2_inode *dip,\n\t\t\t     const struct dentry *dentry)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tstruct gfs2_inode *ip = GFS2_I(inode);\n\tint error;\n\n\terror = gfs2_dir_del(dip, dentry);\n\tif (error)\n\t\treturn error;\n\n\tip->i_entries = 0;\n\tinode->i_ctime = CURRENT_TIME;\n\tif (S_ISDIR(inode->i_mode))\n\t\tclear_nlink(inode);\n\telse\n\t\tdrop_nlink(inode);\n\tmark_inode_dirty(inode);\n\tif (inode->i_nlink == 0)\n\t\tgfs2_unlink_di(inode);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "gfs2_trans_begin",
          "args": [
            "sdp",
            "4 * RES_DINODE +\n\t\t\t\t\t 5 * RES_LEAF + 4",
            "0"
          ],
          "line": 1486
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_trans_begin",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/trans.c",
          "lines": "31-75",
          "snippet": "int gfs2_trans_begin(struct gfs2_sbd *sdp, unsigned int blocks,\n\t\t     unsigned int revokes)\n{\n\tstruct gfs2_trans *tr;\n\tint error;\n\n\tBUG_ON(current->journal_info);\n\tBUG_ON(blocks == 0 && revokes == 0);\n\n\tif (!test_bit(SDF_JOURNAL_LIVE, &sdp->sd_flags))\n\t\treturn -EROFS;\n\n\ttr = kzalloc(sizeof(struct gfs2_trans), GFP_NOFS);\n\tif (!tr)\n\t\treturn -ENOMEM;\n\n\ttr->tr_ip = _RET_IP_;\n\ttr->tr_blocks = blocks;\n\ttr->tr_revokes = revokes;\n\ttr->tr_reserved = 1;\n\ttr->tr_alloced = 1;\n\tif (blocks)\n\t\ttr->tr_reserved += 6 + blocks;\n\tif (revokes)\n\t\ttr->tr_reserved += gfs2_struct2blk(sdp, revokes,\n\t\t\t\t\t\t   sizeof(u64));\n\tINIT_LIST_HEAD(&tr->tr_databuf);\n\tINIT_LIST_HEAD(&tr->tr_buf);\n\n\tsb_start_intwrite(sdp->sd_vfs);\n\n\terror = gfs2_log_reserve(sdp, tr->tr_reserved);\n\tif (error)\n\t\tgoto fail;\n\n\tcurrent->journal_info = tr;\n\n\treturn 0;\n\nfail:\n\tsb_end_intwrite(sdp->sd_vfs);\n\tkfree(tr);\n\n\treturn error;\n}",
          "includes": [
            "#include \"trace_gfs2.h\"",
            "#include \"util.h\"",
            "#include \"trans.h\"",
            "#include \"meta_io.h\"",
            "#include \"lops.h\"",
            "#include \"log.h\"",
            "#include \"inode.h\"",
            "#include \"glock.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"util.h\"\n#include \"trans.h\"\n#include \"meta_io.h\"\n#include \"lops.h\"\n#include \"log.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/gfs2_ondisk.h>\n#include <linux/kallsyms.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nint gfs2_trans_begin(struct gfs2_sbd *sdp, unsigned int blocks,\n\t\t     unsigned int revokes)\n{\n\tstruct gfs2_trans *tr;\n\tint error;\n\n\tBUG_ON(current->journal_info);\n\tBUG_ON(blocks == 0 && revokes == 0);\n\n\tif (!test_bit(SDF_JOURNAL_LIVE, &sdp->sd_flags))\n\t\treturn -EROFS;\n\n\ttr = kzalloc(sizeof(struct gfs2_trans), GFP_NOFS);\n\tif (!tr)\n\t\treturn -ENOMEM;\n\n\ttr->tr_ip = _RET_IP_;\n\ttr->tr_blocks = blocks;\n\ttr->tr_revokes = revokes;\n\ttr->tr_reserved = 1;\n\ttr->tr_alloced = 1;\n\tif (blocks)\n\t\ttr->tr_reserved += 6 + blocks;\n\tif (revokes)\n\t\ttr->tr_reserved += gfs2_struct2blk(sdp, revokes,\n\t\t\t\t\t\t   sizeof(u64));\n\tINIT_LIST_HEAD(&tr->tr_databuf);\n\tINIT_LIST_HEAD(&tr->tr_buf);\n\n\tsb_start_intwrite(sdp->sd_vfs);\n\n\terror = gfs2_log_reserve(sdp, tr->tr_reserved);\n\tif (error)\n\t\tgoto fail;\n\n\tcurrent->journal_info = tr;\n\n\treturn 0;\n\nfail:\n\tsb_end_intwrite(sdp->sd_vfs);\n\tkfree(tr);\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "gfs2_trans_da_blks",
          "args": [
            "ndip",
            "&da",
            "4"
          ],
          "line": 1481
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_trans_da_blks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/inode.c",
          "lines": "512-518",
          "snippet": "static unsigned gfs2_trans_da_blks(const struct gfs2_inode *dip,\n\t\t\t\t   const struct gfs2_diradd *da,\n\t\t\t\t   unsigned nr_inodes)\n{\n\treturn da->nr_blocks + gfs2_rg_blocks(dip, da->nr_blocks) +\n\t       (nr_inodes * RES_DINODE) + RES_QUOTA + RES_STATFS;\n}",
          "includes": [
            "#include \"glops.h\"",
            "#include \"super.h\"",
            "#include \"util.h\"",
            "#include \"trans.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"inode.h\"",
            "#include \"glock.h\"",
            "#include \"xattr.h\"",
            "#include \"dir.h\"",
            "#include \"bmap.h\"",
            "#include \"acl.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/security.h>",
            "#include <linux/fiemap.h>",
            "#include <linux/crc32.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/xattr.h>",
            "#include <linux/mm.h>",
            "#include <linux/namei.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glops.h\"\n#include \"super.h\"\n#include \"util.h\"\n#include \"trans.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"xattr.h\"\n#include \"dir.h\"\n#include \"bmap.h\"\n#include \"acl.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <asm/uaccess.h>\n#include <linux/security.h>\n#include <linux/fiemap.h>\n#include <linux/crc32.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/posix_acl.h>\n#include <linux/xattr.h>\n#include <linux/mm.h>\n#include <linux/namei.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nstatic unsigned gfs2_trans_da_blks(const struct gfs2_inode *dip,\n\t\t\t\t   const struct gfs2_diradd *da,\n\t\t\t\t   unsigned nr_inodes)\n{\n\treturn da->nr_blocks + gfs2_rg_blocks(dip, da->nr_blocks) +\n\t       (nr_inodes * RES_DINODE) + RES_QUOTA + RES_STATFS;\n}"
        }
      },
      {
        "call_info": {
          "callee": "gfs2_inplace_reserve",
          "args": [
            "ndip",
            "&ap"
          ],
          "line": 1477
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_inplace_reserve",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/rgrp.c",
          "lines": "1952-2072",
          "snippet": "int gfs2_inplace_reserve(struct gfs2_inode *ip, const struct gfs2_alloc_parms *ap)\n{\n\tstruct gfs2_sbd *sdp = GFS2_SB(&ip->i_inode);\n\tstruct gfs2_rgrpd *begin = NULL;\n\tstruct gfs2_blkreserv *rs = ip->i_res;\n\tint error = 0, rg_locked, flags = 0;\n\tu64 last_unlinked = NO_BLOCK;\n\tint loops = 0;\n\tu32 skip = 0;\n\n\tif (sdp->sd_args.ar_rgrplvb)\n\t\tflags |= GL_SKIP;\n\tif (gfs2_assert_warn(sdp, ap->target))\n\t\treturn -EINVAL;\n\tif (gfs2_rs_active(rs)) {\n\t\tbegin = rs->rs_rbm.rgd;\n\t} else if (ip->i_rgd && rgrp_contains_block(ip->i_rgd, ip->i_goal)) {\n\t\trs->rs_rbm.rgd = begin = ip->i_rgd;\n\t} else {\n\t\tcheck_and_update_goal(ip);\n\t\trs->rs_rbm.rgd = begin = gfs2_blk2rgrpd(sdp, ip->i_goal, 1);\n\t}\n\tif (S_ISDIR(ip->i_inode.i_mode) && (ap->aflags & GFS2_AF_ORLOV))\n\t\tskip = gfs2_orlov_skip(ip);\n\tif (rs->rs_rbm.rgd == NULL)\n\t\treturn -EBADSLT;\n\n\twhile (loops < 3) {\n\t\trg_locked = 1;\n\n\t\tif (!gfs2_glock_is_locked_by_me(rs->rs_rbm.rgd->rd_gl)) {\n\t\t\trg_locked = 0;\n\t\t\tif (skip && skip--)\n\t\t\t\tgoto next_rgrp;\n\t\t\tif (!gfs2_rs_active(rs)) {\n\t\t\t\tif (loops == 0 &&\n\t\t\t\t    !fast_to_acquire(rs->rs_rbm.rgd))\n\t\t\t\t\tgoto next_rgrp;\n\t\t\t\tif ((loops < 2) &&\n\t\t\t\t    gfs2_rgrp_used_recently(rs, 1000) &&\n\t\t\t\t    gfs2_rgrp_congested(rs->rs_rbm.rgd, loops))\n\t\t\t\t\tgoto next_rgrp;\n\t\t\t}\n\t\t\terror = gfs2_glock_nq_init(rs->rs_rbm.rgd->rd_gl,\n\t\t\t\t\t\t   LM_ST_EXCLUSIVE, flags,\n\t\t\t\t\t\t   &rs->rs_rgd_gh);\n\t\t\tif (unlikely(error))\n\t\t\t\treturn error;\n\t\t\tif (!gfs2_rs_active(rs) && (loops < 2) &&\n\t\t\t    gfs2_rgrp_congested(rs->rs_rbm.rgd, loops))\n\t\t\t\tgoto skip_rgrp;\n\t\t\tif (sdp->sd_args.ar_rgrplvb) {\n\t\t\t\terror = update_rgrp_lvb(rs->rs_rbm.rgd);\n\t\t\t\tif (unlikely(error)) {\n\t\t\t\t\tgfs2_glock_dq_uninit(&rs->rs_rgd_gh);\n\t\t\t\t\treturn error;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t/* Skip unuseable resource groups */\n\t\tif ((rs->rs_rbm.rgd->rd_flags & (GFS2_RGF_NOALLOC |\n\t\t\t\t\t\t GFS2_RDF_ERROR)) ||\n\t\t    (ap->target > rs->rs_rbm.rgd->rd_extfail_pt))\n\t\t\tgoto skip_rgrp;\n\n\t\tif (sdp->sd_args.ar_rgrplvb)\n\t\t\tgfs2_rgrp_bh_get(rs->rs_rbm.rgd);\n\n\t\t/* Get a reservation if we don't already have one */\n\t\tif (!gfs2_rs_active(rs))\n\t\t\trg_mblk_search(rs->rs_rbm.rgd, ip, ap);\n\n\t\t/* Skip rgrps when we can't get a reservation on first pass */\n\t\tif (!gfs2_rs_active(rs) && (loops < 1))\n\t\t\tgoto check_rgrp;\n\n\t\t/* If rgrp has enough free space, use it */\n\t\tif (rs->rs_rbm.rgd->rd_free_clone >= ap->target) {\n\t\t\tip->i_rgd = rs->rs_rbm.rgd;\n\t\t\treturn 0;\n\t\t}\n\ncheck_rgrp:\n\t\t/* Check for unlinked inodes which can be reclaimed */\n\t\tif (rs->rs_rbm.rgd->rd_flags & GFS2_RDF_CHECK)\n\t\t\ttry_rgrp_unlink(rs->rs_rbm.rgd, &last_unlinked,\n\t\t\t\t\tip->i_no_addr);\nskip_rgrp:\n\t\t/* Drop reservation, if we couldn't use reserved rgrp */\n\t\tif (gfs2_rs_active(rs))\n\t\t\tgfs2_rs_deltree(rs);\n\n\t\t/* Unlock rgrp if required */\n\t\tif (!rg_locked)\n\t\t\tgfs2_glock_dq_uninit(&rs->rs_rgd_gh);\nnext_rgrp:\n\t\t/* Find the next rgrp, and continue looking */\n\t\tif (gfs2_select_rgrp(&rs->rs_rbm.rgd, begin))\n\t\t\tcontinue;\n\t\tif (skip)\n\t\t\tcontinue;\n\n\t\t/* If we've scanned all the rgrps, but found no free blocks\n\t\t * then this checks for some less likely conditions before\n\t\t * trying again.\n\t\t */\n\t\tloops++;\n\t\t/* Check that fs hasn't grown if writing to rindex */\n\t\tif (ip == GFS2_I(sdp->sd_rindex) && !sdp->sd_rindex_uptodate) {\n\t\t\terror = gfs2_ri_update(ip);\n\t\t\tif (error)\n\t\t\t\treturn error;\n\t\t}\n\t\t/* Flushing the log may release space */\n\t\tif (loops == 2)\n\t\t\tgfs2_log_flush(sdp, NULL, NORMAL_FLUSH);\n\t}\n\n\treturn -ENOSPC;\n}",
          "includes": [
            "#include \"trace_gfs2.h\"",
            "#include \"inode.h\"",
            "#include \"log.h\"",
            "#include \"util.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"lops.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/random.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/fs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [
            "#define NO_BLOCK ((u64)~0)"
          ],
          "globals_used": [
            "static int gfs2_rbm_find(struct gfs2_rbm *rbm, u8 state, u32 *minext,\n\t\t\t const struct gfs2_inode *ip, bool nowrap,\n\t\t\t const struct gfs2_alloc_parms *ap);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"inode.h\"\n#include \"log.h\"\n#include \"util.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"lops.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/random.h>\n#include <linux/rbtree.h>\n#include <linux/blkdev.h>\n#include <linux/prefetch.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/fs.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\n#define NO_BLOCK ((u64)~0)\n\nstatic int gfs2_rbm_find(struct gfs2_rbm *rbm, u8 state, u32 *minext,\n\t\t\t const struct gfs2_inode *ip, bool nowrap,\n\t\t\t const struct gfs2_alloc_parms *ap);\n\nint gfs2_inplace_reserve(struct gfs2_inode *ip, const struct gfs2_alloc_parms *ap)\n{\n\tstruct gfs2_sbd *sdp = GFS2_SB(&ip->i_inode);\n\tstruct gfs2_rgrpd *begin = NULL;\n\tstruct gfs2_blkreserv *rs = ip->i_res;\n\tint error = 0, rg_locked, flags = 0;\n\tu64 last_unlinked = NO_BLOCK;\n\tint loops = 0;\n\tu32 skip = 0;\n\n\tif (sdp->sd_args.ar_rgrplvb)\n\t\tflags |= GL_SKIP;\n\tif (gfs2_assert_warn(sdp, ap->target))\n\t\treturn -EINVAL;\n\tif (gfs2_rs_active(rs)) {\n\t\tbegin = rs->rs_rbm.rgd;\n\t} else if (ip->i_rgd && rgrp_contains_block(ip->i_rgd, ip->i_goal)) {\n\t\trs->rs_rbm.rgd = begin = ip->i_rgd;\n\t} else {\n\t\tcheck_and_update_goal(ip);\n\t\trs->rs_rbm.rgd = begin = gfs2_blk2rgrpd(sdp, ip->i_goal, 1);\n\t}\n\tif (S_ISDIR(ip->i_inode.i_mode) && (ap->aflags & GFS2_AF_ORLOV))\n\t\tskip = gfs2_orlov_skip(ip);\n\tif (rs->rs_rbm.rgd == NULL)\n\t\treturn -EBADSLT;\n\n\twhile (loops < 3) {\n\t\trg_locked = 1;\n\n\t\tif (!gfs2_glock_is_locked_by_me(rs->rs_rbm.rgd->rd_gl)) {\n\t\t\trg_locked = 0;\n\t\t\tif (skip && skip--)\n\t\t\t\tgoto next_rgrp;\n\t\t\tif (!gfs2_rs_active(rs)) {\n\t\t\t\tif (loops == 0 &&\n\t\t\t\t    !fast_to_acquire(rs->rs_rbm.rgd))\n\t\t\t\t\tgoto next_rgrp;\n\t\t\t\tif ((loops < 2) &&\n\t\t\t\t    gfs2_rgrp_used_recently(rs, 1000) &&\n\t\t\t\t    gfs2_rgrp_congested(rs->rs_rbm.rgd, loops))\n\t\t\t\t\tgoto next_rgrp;\n\t\t\t}\n\t\t\terror = gfs2_glock_nq_init(rs->rs_rbm.rgd->rd_gl,\n\t\t\t\t\t\t   LM_ST_EXCLUSIVE, flags,\n\t\t\t\t\t\t   &rs->rs_rgd_gh);\n\t\t\tif (unlikely(error))\n\t\t\t\treturn error;\n\t\t\tif (!gfs2_rs_active(rs) && (loops < 2) &&\n\t\t\t    gfs2_rgrp_congested(rs->rs_rbm.rgd, loops))\n\t\t\t\tgoto skip_rgrp;\n\t\t\tif (sdp->sd_args.ar_rgrplvb) {\n\t\t\t\terror = update_rgrp_lvb(rs->rs_rbm.rgd);\n\t\t\t\tif (unlikely(error)) {\n\t\t\t\t\tgfs2_glock_dq_uninit(&rs->rs_rgd_gh);\n\t\t\t\t\treturn error;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t/* Skip unuseable resource groups */\n\t\tif ((rs->rs_rbm.rgd->rd_flags & (GFS2_RGF_NOALLOC |\n\t\t\t\t\t\t GFS2_RDF_ERROR)) ||\n\t\t    (ap->target > rs->rs_rbm.rgd->rd_extfail_pt))\n\t\t\tgoto skip_rgrp;\n\n\t\tif (sdp->sd_args.ar_rgrplvb)\n\t\t\tgfs2_rgrp_bh_get(rs->rs_rbm.rgd);\n\n\t\t/* Get a reservation if we don't already have one */\n\t\tif (!gfs2_rs_active(rs))\n\t\t\trg_mblk_search(rs->rs_rbm.rgd, ip, ap);\n\n\t\t/* Skip rgrps when we can't get a reservation on first pass */\n\t\tif (!gfs2_rs_active(rs) && (loops < 1))\n\t\t\tgoto check_rgrp;\n\n\t\t/* If rgrp has enough free space, use it */\n\t\tif (rs->rs_rbm.rgd->rd_free_clone >= ap->target) {\n\t\t\tip->i_rgd = rs->rs_rbm.rgd;\n\t\t\treturn 0;\n\t\t}\n\ncheck_rgrp:\n\t\t/* Check for unlinked inodes which can be reclaimed */\n\t\tif (rs->rs_rbm.rgd->rd_flags & GFS2_RDF_CHECK)\n\t\t\ttry_rgrp_unlink(rs->rs_rbm.rgd, &last_unlinked,\n\t\t\t\t\tip->i_no_addr);\nskip_rgrp:\n\t\t/* Drop reservation, if we couldn't use reserved rgrp */\n\t\tif (gfs2_rs_active(rs))\n\t\t\tgfs2_rs_deltree(rs);\n\n\t\t/* Unlock rgrp if required */\n\t\tif (!rg_locked)\n\t\t\tgfs2_glock_dq_uninit(&rs->rs_rgd_gh);\nnext_rgrp:\n\t\t/* Find the next rgrp, and continue looking */\n\t\tif (gfs2_select_rgrp(&rs->rs_rbm.rgd, begin))\n\t\t\tcontinue;\n\t\tif (skip)\n\t\t\tcontinue;\n\n\t\t/* If we've scanned all the rgrps, but found no free blocks\n\t\t * then this checks for some less likely conditions before\n\t\t * trying again.\n\t\t */\n\t\tloops++;\n\t\t/* Check that fs hasn't grown if writing to rindex */\n\t\tif (ip == GFS2_I(sdp->sd_rindex) && !sdp->sd_rindex_uptodate) {\n\t\t\terror = gfs2_ri_update(ip);\n\t\t\tif (error)\n\t\t\t\treturn error;\n\t\t}\n\t\t/* Flushing the log may release space */\n\t\tif (loops == 2)\n\t\t\tgfs2_log_flush(sdp, NULL, NORMAL_FLUSH);\n\t}\n\n\treturn -ENOSPC;\n}"
        }
      },
      {
        "call_info": {
          "callee": "gfs2_quota_lock_check",
          "args": [
            "ndip"
          ],
          "line": 1473
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_quota_lock_check",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/quota.h",
          "lines": "40-55",
          "snippet": "static inline int gfs2_quota_lock_check(struct gfs2_inode *ip)\n{\n\tstruct gfs2_sbd *sdp = GFS2_SB(&ip->i_inode);\n\tint ret;\n\tif (sdp->sd_args.ar_quota == GFS2_QUOTA_OFF)\n\t\treturn 0;\n\tret = gfs2_quota_lock(ip, NO_UID_QUOTA_CHANGE, NO_GID_QUOTA_CHANGE);\n\tif (ret)\n\t\treturn ret;\n\tif (sdp->sd_args.ar_quota != GFS2_QUOTA_ON)\n\t\treturn 0;\n\tret = gfs2_quota_check(ip, ip->i_inode.i_uid, ip->i_inode.i_gid);\n\tif (ret)\n\t\tgfs2_quota_unlock(ip);\n\treturn ret;\n}",
          "includes": [
            "#include <linux/list_lru.h>"
          ],
          "macros_used": [
            "#define NO_GID_QUOTA_CHANGE INVALID_GID",
            "#define NO_UID_QUOTA_CHANGE INVALID_UID"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/list_lru.h>\n\n#define NO_GID_QUOTA_CHANGE INVALID_GID\n#define NO_UID_QUOTA_CHANGE INVALID_UID\n\nstatic inline int gfs2_quota_lock_check(struct gfs2_inode *ip)\n{\n\tstruct gfs2_sbd *sdp = GFS2_SB(&ip->i_inode);\n\tint ret;\n\tif (sdp->sd_args.ar_quota == GFS2_QUOTA_OFF)\n\t\treturn 0;\n\tret = gfs2_quota_lock(ip, NO_UID_QUOTA_CHANGE, NO_GID_QUOTA_CHANGE);\n\tif (ret)\n\t\treturn ret;\n\tif (sdp->sd_args.ar_quota != GFS2_QUOTA_ON)\n\t\treturn 0;\n\tret = gfs2_quota_check(ip, ip->i_inode.i_uid, ip->i_inode.i_gid);\n\tif (ret)\n\t\tgfs2_quota_unlock(ip);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "gfs2_diradd_alloc_required",
          "args": [
            "ndir",
            "&ndentry->d_name",
            "&da"
          ],
          "line": 1466
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_diradd_alloc_required",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/dir.c",
          "lines": "2058-2089",
          "snippet": "int gfs2_diradd_alloc_required(struct inode *inode, const struct qstr *name,\n\t\t\t       struct gfs2_diradd *da)\n{\n\tstruct gfs2_inode *ip = GFS2_I(inode);\n\tstruct gfs2_sbd *sdp = GFS2_SB(inode);\n\tconst unsigned int extra = sizeof(struct gfs2_dinode) - sizeof(struct gfs2_leaf);\n\tstruct gfs2_dirent *dent;\n\tstruct buffer_head *bh;\n\n\tda->nr_blocks = 0;\n\tda->bh = NULL;\n\tda->dent = NULL;\n\n\tdent = gfs2_dirent_search(inode, name, gfs2_dirent_find_space, &bh);\n\tif (!dent) {\n\t\tda->nr_blocks = sdp->sd_max_dirres;\n\t\tif (!(ip->i_diskflags & GFS2_DIF_EXHASH) &&\n\t\t    (GFS2_DIRENT_SIZE(name->len) < extra))\n\t\t\tda->nr_blocks = 1;\n\t\treturn 0;\n\t}\n\tif (IS_ERR(dent))\n\t\treturn PTR_ERR(dent);\n\n\tif (da->save_loc) {\n\t\tda->bh = bh;\n\t\tda->dent = dent;\n\t} else {\n\t\tbrelse(bh);\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"bmap.h\"",
            "#include \"trans.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"inode.h\"",
            "#include \"glock.h\"",
            "#include \"dir.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/crc32.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/sort.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"bmap.h\"\n#include \"trans.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"dir.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/vmalloc.h>\n#include <linux/crc32.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/sort.h>\n#include <linux/buffer_head.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nint gfs2_diradd_alloc_required(struct inode *inode, const struct qstr *name,\n\t\t\t       struct gfs2_diradd *da)\n{\n\tstruct gfs2_inode *ip = GFS2_I(inode);\n\tstruct gfs2_sbd *sdp = GFS2_SB(inode);\n\tconst unsigned int extra = sizeof(struct gfs2_dinode) - sizeof(struct gfs2_leaf);\n\tstruct gfs2_dirent *dent;\n\tstruct buffer_head *bh;\n\n\tda->nr_blocks = 0;\n\tda->bh = NULL;\n\tda->dent = NULL;\n\n\tdent = gfs2_dirent_search(inode, name, gfs2_dirent_find_space, &bh);\n\tif (!dent) {\n\t\tda->nr_blocks = sdp->sd_max_dirres;\n\t\tif (!(ip->i_diskflags & GFS2_DIF_EXHASH) &&\n\t\t    (GFS2_DIRENT_SIZE(name->len) < extra))\n\t\t\tda->nr_blocks = 1;\n\t\treturn 0;\n\t}\n\tif (IS_ERR(dent))\n\t\treturn PTR_ERR(dent);\n\n\tif (da->save_loc) {\n\t\tda->bh = bh;\n\t\tda->dent = dent;\n\t} else {\n\t\tbrelse(bh);\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "gfs2_permission",
          "args": [
            "odentry->d_inode",
            "MAY_WRITE"
          ],
          "line": 1460
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_permission",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/inode.c",
          "lines": "1606-1632",
          "snippet": "int gfs2_permission(struct inode *inode, int mask)\n{\n\tstruct gfs2_inode *ip;\n\tstruct gfs2_holder i_gh;\n\tint error;\n\tint unlock = 0;\n\n\n\tip = GFS2_I(inode);\n\tif (gfs2_glock_is_locked_by_me(ip->i_gl) == NULL) {\n\t\tif (mask & MAY_NOT_BLOCK)\n\t\t\treturn -ECHILD;\n\t\terror = gfs2_glock_nq_init(ip->i_gl, LM_ST_SHARED, LM_FLAG_ANY, &i_gh);\n\t\tif (error)\n\t\t\treturn error;\n\t\tunlock = 1;\n\t}\n\n\tif ((mask & MAY_WRITE) && IS_IMMUTABLE(inode))\n\t\terror = -EACCES;\n\telse\n\t\terror = generic_permission(inode, mask);\n\tif (unlock)\n\t\tgfs2_glock_dq_uninit(&i_gh);\n\n\treturn error;\n}",
          "includes": [
            "#include \"glops.h\"",
            "#include \"super.h\"",
            "#include \"util.h\"",
            "#include \"trans.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"inode.h\"",
            "#include \"glock.h\"",
            "#include \"xattr.h\"",
            "#include \"dir.h\"",
            "#include \"bmap.h\"",
            "#include \"acl.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/security.h>",
            "#include <linux/fiemap.h>",
            "#include <linux/crc32.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/xattr.h>",
            "#include <linux/mm.h>",
            "#include <linux/namei.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glops.h\"\n#include \"super.h\"\n#include \"util.h\"\n#include \"trans.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"xattr.h\"\n#include \"dir.h\"\n#include \"bmap.h\"\n#include \"acl.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <asm/uaccess.h>\n#include <linux/security.h>\n#include <linux/fiemap.h>\n#include <linux/crc32.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/posix_acl.h>\n#include <linux/xattr.h>\n#include <linux/mm.h>\n#include <linux/namei.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nint gfs2_permission(struct inode *inode, int mask)\n{\n\tstruct gfs2_inode *ip;\n\tstruct gfs2_holder i_gh;\n\tint error;\n\tint unlock = 0;\n\n\n\tip = GFS2_I(inode);\n\tif (gfs2_glock_is_locked_by_me(ip->i_gl) == NULL) {\n\t\tif (mask & MAY_NOT_BLOCK)\n\t\t\treturn -ECHILD;\n\t\terror = gfs2_glock_nq_init(ip->i_gl, LM_ST_SHARED, LM_FLAG_ANY, &i_gh);\n\t\tif (error)\n\t\t\treturn error;\n\t\tunlock = 1;\n\t}\n\n\tif ((mask & MAY_WRITE) && IS_IMMUTABLE(inode))\n\t\terror = -EACCES;\n\telse\n\t\terror = generic_permission(inode, mask);\n\tif (unlock)\n\t\tgfs2_glock_dq_uninit(&i_gh);\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "S_ISDIR",
          "args": [
            "ip->i_inode.i_mode"
          ],
          "line": 1449
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gfs2_dir_check",
          "args": [
            "ndir",
            "&ndentry->d_name",
            "NULL"
          ],
          "line": 1429
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_dir_check",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/dir.c",
          "lines": "1571-1600",
          "snippet": "int gfs2_dir_check(struct inode *dir, const struct qstr *name,\n\t\t   const struct gfs2_inode *ip)\n{\n\tstruct buffer_head *bh;\n\tstruct gfs2_dirent *dent;\n\tint ret = -ENOENT;\n\n\tdent = gfs2_dirent_search(dir, name, gfs2_dirent_find, &bh);\n\tif (dent) {\n\t\tif (IS_ERR(dent))\n\t\t\treturn PTR_ERR(dent);\n\t\tif (ip) {\n\t\t\tif (be64_to_cpu(dent->de_inum.no_addr) != ip->i_no_addr)\n\t\t\t\tgoto out;\n\t\t\tif (be64_to_cpu(dent->de_inum.no_formal_ino) !=\n\t\t\t    ip->i_no_formal_ino)\n\t\t\t\tgoto out;\n\t\t\tif (unlikely(IF2DT(ip->i_inode.i_mode) !=\n\t\t\t    be16_to_cpu(dent->de_type))) {\n\t\t\t\tgfs2_consist_inode(GFS2_I(dir));\n\t\t\t\tret = -EIO;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\t\tret = 0;\nout:\n\t\tbrelse(bh);\n\t}\n\treturn ret;\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"bmap.h\"",
            "#include \"trans.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"inode.h\"",
            "#include \"glock.h\"",
            "#include \"dir.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/crc32.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/sort.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"bmap.h\"\n#include \"trans.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"dir.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/vmalloc.h>\n#include <linux/crc32.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/sort.h>\n#include <linux/buffer_head.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nint gfs2_dir_check(struct inode *dir, const struct qstr *name,\n\t\t   const struct gfs2_inode *ip)\n{\n\tstruct buffer_head *bh;\n\tstruct gfs2_dirent *dent;\n\tint ret = -ENOENT;\n\n\tdent = gfs2_dirent_search(dir, name, gfs2_dirent_find, &bh);\n\tif (dent) {\n\t\tif (IS_ERR(dent))\n\t\t\treturn PTR_ERR(dent);\n\t\tif (ip) {\n\t\t\tif (be64_to_cpu(dent->de_inum.no_addr) != ip->i_no_addr)\n\t\t\t\tgoto out;\n\t\t\tif (be64_to_cpu(dent->de_inum.no_formal_ino) !=\n\t\t\t    ip->i_no_formal_ino)\n\t\t\t\tgoto out;\n\t\t\tif (unlikely(IF2DT(ip->i_inode.i_mode) !=\n\t\t\t    be16_to_cpu(dent->de_type))) {\n\t\t\t\tgfs2_consist_inode(GFS2_I(dir));\n\t\t\t\tret = -EIO;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\t\tret = 0;\nout:\n\t\tbrelse(bh);\n\t}\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "gfs2_consist_inode",
          "args": [
            "nip"
          ],
          "line": 1415
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISDIR",
          "args": [
            "nip->i_inode.i_mode"
          ],
          "line": 1413
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gfs2_unlink_ok",
          "args": [
            "ndip",
            "&ndentry->d_name",
            "nip"
          ],
          "line": 1404
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_unlink_ok",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/inode.c",
          "lines": "1020-1041",
          "snippet": "static int gfs2_unlink_ok(struct gfs2_inode *dip, const struct qstr *name,\n\t\t\t  const struct gfs2_inode *ip)\n{\n\tint error;\n\n\tif (IS_IMMUTABLE(&ip->i_inode) || IS_APPEND(&ip->i_inode))\n\t\treturn -EPERM;\n\n\tif ((dip->i_inode.i_mode & S_ISVTX) &&\n\t    !uid_eq(dip->i_inode.i_uid, current_fsuid()) &&\n\t    !uid_eq(ip->i_inode.i_uid, current_fsuid()) && !capable(CAP_FOWNER))\n\t\treturn -EPERM;\n\n\tif (IS_APPEND(&dip->i_inode))\n\t\treturn -EPERM;\n\n\terror = gfs2_permission(&dip->i_inode, MAY_WRITE | MAY_EXEC);\n\tif (error)\n\t\treturn error;\n\n\treturn gfs2_dir_check(&dip->i_inode, name, ip);\n}",
          "includes": [
            "#include \"glops.h\"",
            "#include \"super.h\"",
            "#include \"util.h\"",
            "#include \"trans.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"inode.h\"",
            "#include \"glock.h\"",
            "#include \"xattr.h\"",
            "#include \"dir.h\"",
            "#include \"bmap.h\"",
            "#include \"acl.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/security.h>",
            "#include <linux/fiemap.h>",
            "#include <linux/crc32.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/xattr.h>",
            "#include <linux/mm.h>",
            "#include <linux/namei.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glops.h\"\n#include \"super.h\"\n#include \"util.h\"\n#include \"trans.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"xattr.h\"\n#include \"dir.h\"\n#include \"bmap.h\"\n#include \"acl.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <asm/uaccess.h>\n#include <linux/security.h>\n#include <linux/fiemap.h>\n#include <linux/crc32.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/posix_acl.h>\n#include <linux/xattr.h>\n#include <linux/mm.h>\n#include <linux/namei.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nstatic int gfs2_unlink_ok(struct gfs2_inode *dip, const struct qstr *name,\n\t\t\t  const struct gfs2_inode *ip)\n{\n\tint error;\n\n\tif (IS_IMMUTABLE(&ip->i_inode) || IS_APPEND(&ip->i_inode))\n\t\treturn -EPERM;\n\n\tif ((dip->i_inode.i_mode & S_ISVTX) &&\n\t    !uid_eq(dip->i_inode.i_uid, current_fsuid()) &&\n\t    !uid_eq(ip->i_inode.i_uid, current_fsuid()) && !capable(CAP_FOWNER))\n\t\treturn -EPERM;\n\n\tif (IS_APPEND(&dip->i_inode))\n\t\treturn -EPERM;\n\n\terror = gfs2_permission(&dip->i_inode, MAY_WRITE | MAY_EXEC);\n\tif (error)\n\t\treturn error;\n\n\treturn gfs2_dir_check(&dip->i_inode, name, ip);\n}"
        }
      },
      {
        "call_info": {
          "callee": "gfs2_glock_nq",
          "args": [
            "ghs + x"
          ],
          "line": 1386
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_glock_nq",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/glock.c",
          "lines": "1006-1034",
          "snippet": "int gfs2_glock_nq(struct gfs2_holder *gh)\n{\n\tstruct gfs2_glock *gl = gh->gh_gl;\n\tstruct gfs2_sbd *sdp = gl->gl_sbd;\n\tint error = 0;\n\n\tif (unlikely(test_bit(SDF_SHUTDOWN, &sdp->sd_flags)))\n\t\treturn -EIO;\n\n\tif (test_bit(GLF_LRU, &gl->gl_flags))\n\t\tgfs2_glock_remove_from_lru(gl);\n\n\tspin_lock(&gl->gl_spin);\n\tadd_to_queue(gh);\n\tif (unlikely((LM_FLAG_NOEXP & gh->gh_flags) &&\n\t\t     test_and_clear_bit(GLF_FROZEN, &gl->gl_flags))) {\n\t\tset_bit(GLF_REPLY_PENDING, &gl->gl_flags);\n\t\tgl->gl_lockref.count++;\n\t\tif (queue_delayed_work(glock_workqueue, &gl->gl_work, 0) == 0)\n\t\t\tgl->gl_lockref.count--;\n\t}\n\trun_queue(gl, 1);\n\tspin_unlock(&gl->gl_spin);\n\n\tif (!(gh->gh_flags & GL_ASYNC))\n\t\terror = gfs2_glock_wait(gh);\n\n\treturn error;\n}",
          "includes": [
            "#include \"trace_gfs2.h\"",
            "#include \"bmap.h\"",
            "#include \"util.h\"",
            "#include \"super.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"lops.h\"",
            "#include \"inode.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/lockref.h>",
            "#include <linux/list_sort.h>",
            "#include <linux/percpu.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/seq_file.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/module.h>",
            "#include <linux/wait.h>",
            "#include <linux/list.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/jhash.h>",
            "#include <linux/sort.h>",
            "#include <linux/delay.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct workqueue_struct *glock_workqueue;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"bmap.h\"\n#include \"util.h\"\n#include \"super.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"lops.h\"\n#include \"inode.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/lockref.h>\n#include <linux/list_sort.h>\n#include <linux/percpu.h>\n#include <linux/bit_spinlock.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/jiffies.h>\n#include <linux/workqueue.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <asm/uaccess.h>\n#include <linux/module.h>\n#include <linux/wait.h>\n#include <linux/list.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/kallsyms.h>\n#include <linux/jhash.h>\n#include <linux/sort.h>\n#include <linux/delay.h>\n#include <linux/buffer_head.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic struct workqueue_struct *glock_workqueue;\n\nint gfs2_glock_nq(struct gfs2_holder *gh)\n{\n\tstruct gfs2_glock *gl = gh->gh_gl;\n\tstruct gfs2_sbd *sdp = gl->gl_sbd;\n\tint error = 0;\n\n\tif (unlikely(test_bit(SDF_SHUTDOWN, &sdp->sd_flags)))\n\t\treturn -EIO;\n\n\tif (test_bit(GLF_LRU, &gl->gl_flags))\n\t\tgfs2_glock_remove_from_lru(gl);\n\n\tspin_lock(&gl->gl_spin);\n\tadd_to_queue(gh);\n\tif (unlikely((LM_FLAG_NOEXP & gh->gh_flags) &&\n\t\t     test_and_clear_bit(GLF_FROZEN, &gl->gl_flags))) {\n\t\tset_bit(GLF_REPLY_PENDING, &gl->gl_flags);\n\t\tgl->gl_lockref.count++;\n\t\tif (queue_delayed_work(glock_workqueue, &gl->gl_work, 0) == 0)\n\t\t\tgl->gl_lockref.count--;\n\t}\n\trun_queue(gl, 1);\n\tspin_unlock(&gl->gl_spin);\n\n\tif (!(gh->gh_flags & GL_ASYNC))\n\t\terror = gfs2_glock_wait(gh);\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "gfs2_holder_init",
          "args": [
            "nrgd->rd_gl",
            "LM_ST_EXCLUSIVE",
            "0",
            "ghs + num_gh++"
          ],
          "line": 1382
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_holder_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/glock.c",
          "lines": "801-813",
          "snippet": "void gfs2_holder_init(struct gfs2_glock *gl, unsigned int state, unsigned flags,\n\t\t      struct gfs2_holder *gh)\n{\n\tINIT_LIST_HEAD(&gh->gh_list);\n\tgh->gh_gl = gl;\n\tgh->gh_ip = _RET_IP_;\n\tgh->gh_owner_pid = get_pid(task_pid(current));\n\tgh->gh_state = state;\n\tgh->gh_flags = flags;\n\tgh->gh_error = 0;\n\tgh->gh_iflags = 0;\n\tgfs2_glock_hold(gl);\n}",
          "includes": [
            "#include \"trace_gfs2.h\"",
            "#include \"bmap.h\"",
            "#include \"util.h\"",
            "#include \"super.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"lops.h\"",
            "#include \"inode.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/lockref.h>",
            "#include <linux/list_sort.h>",
            "#include <linux/percpu.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/seq_file.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/module.h>",
            "#include <linux/wait.h>",
            "#include <linux/list.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/jhash.h>",
            "#include <linux/sort.h>",
            "#include <linux/delay.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"bmap.h\"\n#include \"util.h\"\n#include \"super.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"lops.h\"\n#include \"inode.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/lockref.h>\n#include <linux/list_sort.h>\n#include <linux/percpu.h>\n#include <linux/bit_spinlock.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/jiffies.h>\n#include <linux/workqueue.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <asm/uaccess.h>\n#include <linux/module.h>\n#include <linux/wait.h>\n#include <linux/list.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/kallsyms.h>\n#include <linux/jhash.h>\n#include <linux/sort.h>\n#include <linux/delay.h>\n#include <linux/buffer_head.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nvoid gfs2_holder_init(struct gfs2_glock *gl, unsigned int state, unsigned flags,\n\t\t      struct gfs2_holder *gh)\n{\n\tINIT_LIST_HEAD(&gh->gh_list);\n\tgh->gh_gl = gl;\n\tgh->gh_ip = _RET_IP_;\n\tgh->gh_owner_pid = get_pid(task_pid(current));\n\tgh->gh_state = state;\n\tgh->gh_flags = flags;\n\tgh->gh_error = 0;\n\tgh->gh_iflags = 0;\n\tgfs2_glock_hold(gl);\n}"
        }
      },
      {
        "call_info": {
          "callee": "gfs2_blk2rgrpd",
          "args": [
            "sdp",
            "nip->i_no_addr",
            "1"
          ],
          "line": 1380
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_blk2rgrpd",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/rgrp.c",
          "lines": "503-532",
          "snippet": "struct gfs2_rgrpd *gfs2_blk2rgrpd(struct gfs2_sbd *sdp, u64 blk, bool exact)\n{\n\tstruct rb_node *n, *next;\n\tstruct gfs2_rgrpd *cur;\n\n\tspin_lock(&sdp->sd_rindex_spin);\n\tn = sdp->sd_rindex_tree.rb_node;\n\twhile (n) {\n\t\tcur = rb_entry(n, struct gfs2_rgrpd, rd_node);\n\t\tnext = NULL;\n\t\tif (blk < cur->rd_addr)\n\t\t\tnext = n->rb_left;\n\t\telse if (blk >= cur->rd_data0 + cur->rd_data)\n\t\t\tnext = n->rb_right;\n\t\tif (next == NULL) {\n\t\t\tspin_unlock(&sdp->sd_rindex_spin);\n\t\t\tif (exact) {\n\t\t\t\tif (blk < cur->rd_addr)\n\t\t\t\t\treturn NULL;\n\t\t\t\tif (blk >= cur->rd_data0 + cur->rd_data)\n\t\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\treturn cur;\n\t\t}\n\t\tn = next;\n\t}\n\tspin_unlock(&sdp->sd_rindex_spin);\n\n\treturn NULL;\n}",
          "includes": [
            "#include \"trace_gfs2.h\"",
            "#include \"inode.h\"",
            "#include \"log.h\"",
            "#include \"util.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"lops.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/random.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/fs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"inode.h\"\n#include \"log.h\"\n#include \"util.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"lops.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/random.h>\n#include <linux/rbtree.h>\n#include <linux/blkdev.h>\n#include <linux/prefetch.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/fs.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nstruct gfs2_rgrpd *gfs2_blk2rgrpd(struct gfs2_sbd *sdp, u64 blk, bool exact)\n{\n\tstruct rb_node *n, *next;\n\tstruct gfs2_rgrpd *cur;\n\n\tspin_lock(&sdp->sd_rindex_spin);\n\tn = sdp->sd_rindex_tree.rb_node;\n\twhile (n) {\n\t\tcur = rb_entry(n, struct gfs2_rgrpd, rd_node);\n\t\tnext = NULL;\n\t\tif (blk < cur->rd_addr)\n\t\t\tnext = n->rb_left;\n\t\telse if (blk >= cur->rd_data0 + cur->rd_data)\n\t\t\tnext = n->rb_right;\n\t\tif (next == NULL) {\n\t\t\tspin_unlock(&sdp->sd_rindex_spin);\n\t\t\tif (exact) {\n\t\t\t\tif (blk < cur->rd_addr)\n\t\t\t\t\treturn NULL;\n\t\t\t\tif (blk >= cur->rd_data0 + cur->rd_data)\n\t\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\treturn cur;\n\t\t}\n\t\tn = next;\n\t}\n\tspin_unlock(&sdp->sd_rindex_spin);\n\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "gfs2_ok_to_move",
          "args": [
            "ip",
            "ndip"
          ],
          "line": 1358
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_ok_to_move",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/inode.c",
          "lines": "1271-1307",
          "snippet": "static int gfs2_ok_to_move(struct gfs2_inode *this, struct gfs2_inode *to)\n{\n\tstruct inode *dir = &to->i_inode;\n\tstruct super_block *sb = dir->i_sb;\n\tstruct inode *tmp;\n\tint error = 0;\n\n\tigrab(dir);\n\n\tfor (;;) {\n\t\tif (dir == &this->i_inode) {\n\t\t\terror = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\t\tif (dir == sb->s_root->d_inode) {\n\t\t\terror = 0;\n\t\t\tbreak;\n\t\t}\n\n\t\ttmp = gfs2_lookupi(dir, &gfs2_qdotdot, 1);\n\t\tif (!tmp) {\n\t\t\terror = -ENOENT;\n\t\t\tbreak;\n\t\t}\n\t\tif (IS_ERR(tmp)) {\n\t\t\terror = PTR_ERR(tmp);\n\t\t\tbreak;\n\t\t}\n\n\t\tiput(dir);\n\t\tdir = tmp;\n\t}\n\n\tiput(dir);\n\n\treturn error;\n}",
          "includes": [
            "#include \"glops.h\"",
            "#include \"super.h\"",
            "#include \"util.h\"",
            "#include \"trans.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"inode.h\"",
            "#include \"glock.h\"",
            "#include \"xattr.h\"",
            "#include \"dir.h\"",
            "#include \"bmap.h\"",
            "#include \"acl.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/security.h>",
            "#include <linux/fiemap.h>",
            "#include <linux/crc32.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/xattr.h>",
            "#include <linux/mm.h>",
            "#include <linux/namei.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glops.h\"\n#include \"super.h\"\n#include \"util.h\"\n#include \"trans.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"xattr.h\"\n#include \"dir.h\"\n#include \"bmap.h\"\n#include \"acl.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <asm/uaccess.h>\n#include <linux/security.h>\n#include <linux/fiemap.h>\n#include <linux/crc32.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/posix_acl.h>\n#include <linux/xattr.h>\n#include <linux/mm.h>\n#include <linux/namei.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nstatic int gfs2_ok_to_move(struct gfs2_inode *this, struct gfs2_inode *to)\n{\n\tstruct inode *dir = &to->i_inode;\n\tstruct super_block *sb = dir->i_sb;\n\tstruct inode *tmp;\n\tint error = 0;\n\n\tigrab(dir);\n\n\tfor (;;) {\n\t\tif (dir == &this->i_inode) {\n\t\t\terror = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\t\tif (dir == sb->s_root->d_inode) {\n\t\t\terror = 0;\n\t\t\tbreak;\n\t\t}\n\n\t\ttmp = gfs2_lookupi(dir, &gfs2_qdotdot, 1);\n\t\tif (!tmp) {\n\t\t\terror = -ENOENT;\n\t\t\tbreak;\n\t\t}\n\t\tif (IS_ERR(tmp)) {\n\t\t\terror = PTR_ERR(tmp);\n\t\t\tbreak;\n\t\t}\n\n\t\tiput(dir);\n\t\tdir = tmp;\n\t}\n\n\tiput(dir);\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "S_ISDIR",
          "args": [
            "ip->i_inode.i_mode"
          ],
          "line": 1355
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gfs2_glock_nq_init",
          "args": [
            "sdp->sd_rename_gl",
            "LM_ST_EXCLUSIVE",
            "0",
            "&r_gh"
          ],
          "line": 1350
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_glock_nq_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/glock.h",
          "lines": "204-230",
          "snippet": "extern __printf(2, 3)\nvoid gfs2_print_dbg(struct seq_file *seq, const char *fmt, ...);\n\n/**\n * gfs2_glock_nq_init - initialize a holder and enqueue it on a glock\n * @gl: the glock\n * @state: the state we're requesting\n * @flags: the modifier flags\n * @gh: the holder structure\n *\n * Returns: 0, GLR_*, or errno\n */\n\nstatic inline int gfs2_glock_nq_init(struct gfs2_glock *gl,\n\t\t\t\t     unsigned int state, int flags,\n\t\t\t\t     struct gfs2_holder *gh)\n{\n\tint error;\n\n\tgfs2_holder_init(gl, state, flags, gh);\n\n\terror = gfs2_glock_nq(gh);\n\tif (error)\n\t\tgfs2_holder_uninit(gh);\n\n\treturn error;\n}",
          "includes": [
            "#include \"incore.h\"",
            "#include <linux/parser.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"incore.h\"\n#include <linux/parser.h>\n#include <linux/sched.h>\n\nextern __printf(2, 3)\nvoid gfs2_print_dbg(struct seq_file *seq, const char *fmt, ...);\n\n/**\n * gfs2_glock_nq_init - initialize a holder and enqueue it on a glock\n * @gl: the glock\n * @state: the state we're requesting\n * @flags: the modifier flags\n * @gh: the holder structure\n *\n * Returns: 0, GLR_*, or errno\n */\n\nstatic inline int gfs2_glock_nq_init(struct gfs2_glock *gl,\n\t\t\t\t     unsigned int state, int flags,\n\t\t\t\t     struct gfs2_holder *gh)\n{\n\tint error;\n\n\tgfs2_holder_init(gl, state, flags, gh);\n\n\terror = gfs2_glock_nq(gh);\n\tif (error)\n\t\tgfs2_holder_uninit(gh);\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "gfs2_rs_alloc",
          "args": [
            "ndip"
          ],
          "line": 1345
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_rs_alloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/rgrp.c",
          "lines": "602-620",
          "snippet": "int gfs2_rs_alloc(struct gfs2_inode *ip)\n{\n\tint error = 0;\n\n\tdown_write(&ip->i_rw_mutex);\n\tif (ip->i_res)\n\t\tgoto out;\n\n\tip->i_res = kmem_cache_zalloc(gfs2_rsrv_cachep, GFP_NOFS);\n\tif (!ip->i_res) {\n\t\terror = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tRB_CLEAR_NODE(&ip->i_res->rs_node);\nout:\n\tup_write(&ip->i_rw_mutex);\n\treturn error;\n}",
          "includes": [
            "#include \"trace_gfs2.h\"",
            "#include \"inode.h\"",
            "#include \"log.h\"",
            "#include \"util.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"lops.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/random.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/fs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"inode.h\"\n#include \"log.h\"\n#include \"util.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"lops.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/random.h>\n#include <linux/rbtree.h>\n#include <linux/blkdev.h>\n#include <linux/prefetch.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/fs.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nint gfs2_rs_alloc(struct gfs2_inode *ip)\n{\n\tint error = 0;\n\n\tdown_write(&ip->i_rw_mutex);\n\tif (ip->i_res)\n\t\tgoto out;\n\n\tip->i_res = kmem_cache_zalloc(gfs2_rsrv_cachep, GFP_NOFS);\n\tif (!ip->i_res) {\n\t\terror = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tRB_CLEAR_NODE(&ip->i_res->rs_node);\nout:\n\tup_write(&ip->i_rw_mutex);\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "gfs2_rindex_update",
          "args": [
            "sdp"
          ],
          "line": 1341
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_rindex_update",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/rgrp.c",
          "lines": "1029-1052",
          "snippet": "int gfs2_rindex_update(struct gfs2_sbd *sdp)\n{\n\tstruct gfs2_inode *ip = GFS2_I(sdp->sd_rindex);\n\tstruct gfs2_glock *gl = ip->i_gl;\n\tstruct gfs2_holder ri_gh;\n\tint error = 0;\n\tint unlock_required = 0;\n\n\t/* Read new copy from disk if we don't have the latest */\n\tif (!sdp->sd_rindex_uptodate) {\n\t\tif (!gfs2_glock_is_locked_by_me(gl)) {\n\t\t\terror = gfs2_glock_nq_init(gl, LM_ST_SHARED, 0, &ri_gh);\n\t\t\tif (error)\n\t\t\t\treturn error;\n\t\t\tunlock_required = 1;\n\t\t}\n\t\tif (!sdp->sd_rindex_uptodate)\n\t\t\terror = gfs2_ri_update(ip);\n\t\tif (unlock_required)\n\t\t\tgfs2_glock_dq_uninit(&ri_gh);\n\t}\n\n\treturn error;\n}",
          "includes": [
            "#include \"trace_gfs2.h\"",
            "#include \"inode.h\"",
            "#include \"log.h\"",
            "#include \"util.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"lops.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/random.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/fs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"inode.h\"\n#include \"log.h\"\n#include \"util.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"lops.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/random.h>\n#include <linux/rbtree.h>\n#include <linux/blkdev.h>\n#include <linux/prefetch.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/fs.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nint gfs2_rindex_update(struct gfs2_sbd *sdp)\n{\n\tstruct gfs2_inode *ip = GFS2_I(sdp->sd_rindex);\n\tstruct gfs2_glock *gl = ip->i_gl;\n\tstruct gfs2_holder ri_gh;\n\tint error = 0;\n\tint unlock_required = 0;\n\n\t/* Read new copy from disk if we don't have the latest */\n\tif (!sdp->sd_rindex_uptodate) {\n\t\tif (!gfs2_glock_is_locked_by_me(gl)) {\n\t\t\terror = gfs2_glock_nq_init(gl, LM_ST_SHARED, 0, &ri_gh);\n\t\t\tif (error)\n\t\t\t\treturn error;\n\t\t\tunlock_required = 1;\n\t\t}\n\t\tif (!sdp->sd_rindex_uptodate)\n\t\t\terror = gfs2_ri_update(ip);\n\t\tif (unlock_required)\n\t\t\tgfs2_glock_dq_uninit(&ri_gh);\n\t}\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "GFS2_I",
          "args": [
            "ndentry->d_inode"
          ],
          "line": 1336
        },
        "resolved": true,
        "details": {
          "function_name": "GFS2_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/incore.h",
          "lines": "408-411",
          "snippet": "static inline struct gfs2_inode *GFS2_I(struct inode *inode)\n{\n\treturn container_of(inode, struct gfs2_inode, i_inode);\n}",
          "includes": [
            "#include <linux/lockref.h>",
            "#include <linux/percpu.h>",
            "#include <linux/ktime.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/completion.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/dlm.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/kobject.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/lockref.h>\n#include <linux/percpu.h>\n#include <linux/ktime.h>\n#include <linux/rbtree.h>\n#include <linux/completion.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/buffer_head.h>\n#include <linux/dlm.h>\n#include <linux/workqueue.h>\n#include <linux/kobject.h>\n#include <linux/fs.h>\n\nstatic inline struct gfs2_inode *GFS2_I(struct inode *inode)\n{\n\treturn container_of(inode, struct gfs2_inode, i_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "GFS2_SB",
          "args": [
            "odir"
          ],
          "line": 1326
        },
        "resolved": true,
        "details": {
          "function_name": "GFS2_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/incore.h",
          "lines": "413-416",
          "snippet": "static inline struct gfs2_sbd *GFS2_SB(const struct inode *inode)\n{\n\treturn inode->i_sb->s_fs_info;\n}",
          "includes": [
            "#include <linux/lockref.h>",
            "#include <linux/percpu.h>",
            "#include <linux/ktime.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/completion.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/dlm.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/kobject.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/lockref.h>\n#include <linux/percpu.h>\n#include <linux/ktime.h>\n#include <linux/rbtree.h>\n#include <linux/completion.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/buffer_head.h>\n#include <linux/dlm.h>\n#include <linux/workqueue.h>\n#include <linux/kobject.h>\n#include <linux/fs.h>\n\nstatic inline struct gfs2_sbd *GFS2_SB(const struct inode *inode)\n{\n\treturn inode->i_sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"glops.h\"\n#include \"super.h\"\n#include \"util.h\"\n#include \"trans.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"xattr.h\"\n#include \"dir.h\"\n#include \"bmap.h\"\n#include \"acl.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <asm/uaccess.h>\n#include <linux/security.h>\n#include <linux/fiemap.h>\n#include <linux/crc32.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/posix_acl.h>\n#include <linux/xattr.h>\n#include <linux/mm.h>\n#include <linux/namei.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nstatic int gfs2_rename(struct inode *odir, struct dentry *odentry,\n\t\t       struct inode *ndir, struct dentry *ndentry)\n{\n\tstruct gfs2_inode *odip = GFS2_I(odir);\n\tstruct gfs2_inode *ndip = GFS2_I(ndir);\n\tstruct gfs2_inode *ip = GFS2_I(odentry->d_inode);\n\tstruct gfs2_inode *nip = NULL;\n\tstruct gfs2_sbd *sdp = GFS2_SB(odir);\n\tstruct gfs2_holder ghs[5], r_gh = { .gh_gl = NULL, };\n\tstruct gfs2_rgrpd *nrgd;\n\tunsigned int num_gh;\n\tint dir_rename = 0;\n\tstruct gfs2_diradd da = { .nr_blocks = 0, .save_loc = 0, };\n\tunsigned int x;\n\tint error;\n\n\tif (ndentry->d_inode) {\n\t\tnip = GFS2_I(ndentry->d_inode);\n\t\tif (ip == nip)\n\t\t\treturn 0;\n\t}\n\n\terror = gfs2_rindex_update(sdp);\n\tif (error)\n\t\treturn error;\n\n\terror = gfs2_rs_alloc(ndip);\n\tif (error)\n\t\treturn error;\n\n\tif (odip != ndip) {\n\t\terror = gfs2_glock_nq_init(sdp->sd_rename_gl, LM_ST_EXCLUSIVE,\n\t\t\t\t\t   0, &r_gh);\n\t\tif (error)\n\t\t\tgoto out;\n\n\t\tif (S_ISDIR(ip->i_inode.i_mode)) {\n\t\t\tdir_rename = 1;\n\t\t\t/* don't move a dirctory into it's subdir */\n\t\t\terror = gfs2_ok_to_move(ip, ndip);\n\t\t\tif (error)\n\t\t\t\tgoto out_gunlock_r;\n\t\t}\n\t}\n\n\tnum_gh = 1;\n\tgfs2_holder_init(odip->i_gl, LM_ST_EXCLUSIVE, 0, ghs);\n\tif (odip != ndip) {\n\t\tgfs2_holder_init(ndip->i_gl, LM_ST_EXCLUSIVE, 0, ghs + num_gh);\n\t\tnum_gh++;\n\t}\n\tgfs2_holder_init(ip->i_gl, LM_ST_EXCLUSIVE, 0, ghs + num_gh);\n\tnum_gh++;\n\n\tif (nip) {\n\t\tgfs2_holder_init(nip->i_gl, LM_ST_EXCLUSIVE, 0, ghs + num_gh);\n\t\tnum_gh++;\n\t\t/* grab the resource lock for unlink flag twiddling \n\t\t * this is the case of the target file already existing\n\t\t * so we unlink before doing the rename\n\t\t */\n\t\tnrgd = gfs2_blk2rgrpd(sdp, nip->i_no_addr, 1);\n\t\tif (nrgd)\n\t\t\tgfs2_holder_init(nrgd->rd_gl, LM_ST_EXCLUSIVE, 0, ghs + num_gh++);\n\t}\n\n\tfor (x = 0; x < num_gh; x++) {\n\t\terror = gfs2_glock_nq(ghs + x);\n\t\tif (error)\n\t\t\tgoto out_gunlock;\n\t}\n\n\terror = -ENOENT;\n\tif (ip->i_inode.i_nlink == 0)\n\t\tgoto out_gunlock;\n\n\t/* Check out the old directory */\n\n\terror = gfs2_unlink_ok(odip, &odentry->d_name, ip);\n\tif (error)\n\t\tgoto out_gunlock;\n\n\t/* Check out the new directory */\n\n\tif (nip) {\n\t\terror = gfs2_unlink_ok(ndip, &ndentry->d_name, nip);\n\t\tif (error)\n\t\t\tgoto out_gunlock;\n\n\t\tif (nip->i_inode.i_nlink == 0) {\n\t\t\terror = -EAGAIN;\n\t\t\tgoto out_gunlock;\n\t\t}\n\n\t\tif (S_ISDIR(nip->i_inode.i_mode)) {\n\t\t\tif (nip->i_entries < 2) {\n\t\t\t\tgfs2_consist_inode(nip);\n\t\t\t\terror = -EIO;\n\t\t\t\tgoto out_gunlock;\n\t\t\t}\n\t\t\tif (nip->i_entries > 2) {\n\t\t\t\terror = -ENOTEMPTY;\n\t\t\t\tgoto out_gunlock;\n\t\t\t}\n\t\t}\n\t} else {\n\t\terror = gfs2_permission(ndir, MAY_WRITE | MAY_EXEC);\n\t\tif (error)\n\t\t\tgoto out_gunlock;\n\n\t\terror = gfs2_dir_check(ndir, &ndentry->d_name, NULL);\n\t\tswitch (error) {\n\t\tcase -ENOENT:\n\t\t\terror = 0;\n\t\t\tbreak;\n\t\tcase 0:\n\t\t\terror = -EEXIST;\n\t\tdefault:\n\t\t\tgoto out_gunlock;\n\t\t};\n\n\t\tif (odip != ndip) {\n\t\t\tif (!ndip->i_inode.i_nlink) {\n\t\t\t\terror = -ENOENT;\n\t\t\t\tgoto out_gunlock;\n\t\t\t}\n\t\t\tif (ndip->i_entries == (u32)-1) {\n\t\t\t\terror = -EFBIG;\n\t\t\t\tgoto out_gunlock;\n\t\t\t}\n\t\t\tif (S_ISDIR(ip->i_inode.i_mode) &&\n\t\t\t    ndip->i_inode.i_nlink == (u32)-1) {\n\t\t\t\terror = -EMLINK;\n\t\t\t\tgoto out_gunlock;\n\t\t\t}\n\t\t}\n\t}\n\n\t/* Check out the dir to be renamed */\n\n\tif (dir_rename) {\n\t\terror = gfs2_permission(odentry->d_inode, MAY_WRITE);\n\t\tif (error)\n\t\t\tgoto out_gunlock;\n\t}\n\n\tif (nip == NULL) {\n\t\terror = gfs2_diradd_alloc_required(ndir, &ndentry->d_name, &da);\n\t\tif (error)\n\t\t\tgoto out_gunlock;\n\t}\n\n\tif (da.nr_blocks) {\n\t\tstruct gfs2_alloc_parms ap = { .target = da.nr_blocks, };\n\t\terror = gfs2_quota_lock_check(ndip);\n\t\tif (error)\n\t\t\tgoto out_gunlock;\n\n\t\terror = gfs2_inplace_reserve(ndip, &ap);\n\t\tif (error)\n\t\t\tgoto out_gunlock_q;\n\n\t\terror = gfs2_trans_begin(sdp, gfs2_trans_da_blks(ndip, &da, 4) +\n\t\t\t\t\t 4 * RES_LEAF + 4, 0);\n\t\tif (error)\n\t\t\tgoto out_ipreserv;\n\t} else {\n\t\terror = gfs2_trans_begin(sdp, 4 * RES_DINODE +\n\t\t\t\t\t 5 * RES_LEAF + 4, 0);\n\t\tif (error)\n\t\t\tgoto out_gunlock;\n\t}\n\n\t/* Remove the target file, if it exists */\n\n\tif (nip)\n\t\terror = gfs2_unlink_inode(ndip, ndentry);\n\n\tif (dir_rename) {\n\t\terror = gfs2_dir_mvino(ip, &gfs2_qdotdot, ndip, DT_DIR);\n\t\tif (error)\n\t\t\tgoto out_end_trans;\n\t} else {\n\t\tstruct buffer_head *dibh;\n\t\terror = gfs2_meta_inode_buffer(ip, &dibh);\n\t\tif (error)\n\t\t\tgoto out_end_trans;\n\t\tip->i_inode.i_ctime = CURRENT_TIME;\n\t\tgfs2_trans_add_meta(ip->i_gl, dibh);\n\t\tgfs2_dinode_out(ip, dibh->b_data);\n\t\tbrelse(dibh);\n\t}\n\n\terror = gfs2_dir_del(odip, odentry);\n\tif (error)\n\t\tgoto out_end_trans;\n\n\terror = gfs2_dir_add(ndir, &ndentry->d_name, ip, &da);\n\tif (error)\n\t\tgoto out_end_trans;\n\nout_end_trans:\n\tgfs2_trans_end(sdp);\nout_ipreserv:\n\tif (da.nr_blocks)\n\t\tgfs2_inplace_release(ndip);\nout_gunlock_q:\n\tif (da.nr_blocks)\n\t\tgfs2_quota_unlock(ndip);\nout_gunlock:\n\tgfs2_dir_no_add(&da);\n\twhile (x--) {\n\t\tgfs2_glock_dq(ghs + x);\n\t\tgfs2_holder_uninit(ghs + x);\n\t}\nout_gunlock_r:\n\tif (r_gh.gh_gl)\n\t\tgfs2_glock_dq_uninit(&r_gh);\nout:\n\treturn error;\n}"
  },
  {
    "function_name": "gfs2_ok_to_move",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/inode.c",
    "lines": "1271-1307",
    "snippet": "static int gfs2_ok_to_move(struct gfs2_inode *this, struct gfs2_inode *to)\n{\n\tstruct inode *dir = &to->i_inode;\n\tstruct super_block *sb = dir->i_sb;\n\tstruct inode *tmp;\n\tint error = 0;\n\n\tigrab(dir);\n\n\tfor (;;) {\n\t\tif (dir == &this->i_inode) {\n\t\t\terror = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\t\tif (dir == sb->s_root->d_inode) {\n\t\t\terror = 0;\n\t\t\tbreak;\n\t\t}\n\n\t\ttmp = gfs2_lookupi(dir, &gfs2_qdotdot, 1);\n\t\tif (!tmp) {\n\t\t\terror = -ENOENT;\n\t\t\tbreak;\n\t\t}\n\t\tif (IS_ERR(tmp)) {\n\t\t\terror = PTR_ERR(tmp);\n\t\t\tbreak;\n\t\t}\n\n\t\tiput(dir);\n\t\tdir = tmp;\n\t}\n\n\tiput(dir);\n\n\treturn error;\n}",
    "includes": [
      "#include \"glops.h\"",
      "#include \"super.h\"",
      "#include \"util.h\"",
      "#include \"trans.h\"",
      "#include \"rgrp.h\"",
      "#include \"quota.h\"",
      "#include \"meta_io.h\"",
      "#include \"inode.h\"",
      "#include \"glock.h\"",
      "#include \"xattr.h\"",
      "#include \"dir.h\"",
      "#include \"bmap.h\"",
      "#include \"acl.h\"",
      "#include \"incore.h\"",
      "#include \"gfs2.h\"",
      "#include <asm/uaccess.h>",
      "#include <linux/security.h>",
      "#include <linux/fiemap.h>",
      "#include <linux/crc32.h>",
      "#include <linux/gfs2_ondisk.h>",
      "#include <linux/posix_acl.h>",
      "#include <linux/xattr.h>",
      "#include <linux/mm.h>",
      "#include <linux/namei.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/completion.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "iput",
          "args": [
            "dir"
          ],
          "line": 1304
        },
        "resolved": true,
        "details": {
          "function_name": "iput",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "1471-1488",
          "snippet": "void iput(struct inode *inode)\n{\n\tif (!inode)\n\t\treturn;\n\tBUG_ON(inode->i_state & I_CLEAR);\nretry:\n\tif (atomic_dec_and_lock(&inode->i_count, &inode->i_lock)) {\n\t\tif (inode->i_nlink && (inode->i_state & I_DIRTY_TIME)) {\n\t\t\tatomic_inc(&inode->i_count);\n\t\t\tinode->i_state &= ~I_DIRTY_TIME;\n\t\t\tspin_unlock(&inode->i_lock);\n\t\t\ttrace_writeback_lazytime_iput(inode);\n\t\t\tmark_inode_dirty_sync(inode);\n\t\t\tgoto retry;\n\t\t}\n\t\tiput_final(inode);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid iput(struct inode *inode)\n{\n\tif (!inode)\n\t\treturn;\n\tBUG_ON(inode->i_state & I_CLEAR);\nretry:\n\tif (atomic_dec_and_lock(&inode->i_count, &inode->i_lock)) {\n\t\tif (inode->i_nlink && (inode->i_state & I_DIRTY_TIME)) {\n\t\t\tatomic_inc(&inode->i_count);\n\t\t\tinode->i_state &= ~I_DIRTY_TIME;\n\t\t\tspin_unlock(&inode->i_lock);\n\t\t\ttrace_writeback_lazytime_iput(inode);\n\t\t\tmark_inode_dirty_sync(inode);\n\t\t\tgoto retry;\n\t\t}\n\t\tiput_final(inode);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "tmp"
          ],
          "line": 1296
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "tmp"
          ],
          "line": 1295
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gfs2_lookupi",
          "args": [
            "dir",
            "&gfs2_qdotdot",
            "1"
          ],
          "line": 1290
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_lookupi",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/inode.c",
          "lines": "283-325",
          "snippet": "struct inode *gfs2_lookupi(struct inode *dir, const struct qstr *name,\n\t\t\t   int is_root)\n{\n\tstruct super_block *sb = dir->i_sb;\n\tstruct gfs2_inode *dip = GFS2_I(dir);\n\tstruct gfs2_holder d_gh;\n\tint error = 0;\n\tstruct inode *inode = NULL;\n\tint unlock = 0;\n\n\tif (!name->len || name->len > GFS2_FNAMESIZE)\n\t\treturn ERR_PTR(-ENAMETOOLONG);\n\n\tif ((name->len == 1 && memcmp(name->name, \".\", 1) == 0) ||\n\t    (name->len == 2 && memcmp(name->name, \"..\", 2) == 0 &&\n\t     dir == sb->s_root->d_inode)) {\n\t\tigrab(dir);\n\t\treturn dir;\n\t}\n\n\tif (gfs2_glock_is_locked_by_me(dip->i_gl) == NULL) {\n\t\terror = gfs2_glock_nq_init(dip->i_gl, LM_ST_SHARED, 0, &d_gh);\n\t\tif (error)\n\t\t\treturn ERR_PTR(error);\n\t\tunlock = 1;\n\t}\n\n\tif (!is_root) {\n\t\terror = gfs2_permission(dir, MAY_EXEC);\n\t\tif (error)\n\t\t\tgoto out;\n\t}\n\n\tinode = gfs2_dir_search(dir, name, false);\n\tif (IS_ERR(inode))\n\t\terror = PTR_ERR(inode);\nout:\n\tif (unlock)\n\t\tgfs2_glock_dq_uninit(&d_gh);\n\tif (error == -ENOENT)\n\t\treturn NULL;\n\treturn inode ? inode : ERR_PTR(error);\n}",
          "includes": [
            "#include \"glops.h\"",
            "#include \"super.h\"",
            "#include \"util.h\"",
            "#include \"trans.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"inode.h\"",
            "#include \"glock.h\"",
            "#include \"xattr.h\"",
            "#include \"dir.h\"",
            "#include \"bmap.h\"",
            "#include \"acl.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/security.h>",
            "#include <linux/fiemap.h>",
            "#include <linux/crc32.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/xattr.h>",
            "#include <linux/mm.h>",
            "#include <linux/namei.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glops.h\"\n#include \"super.h\"\n#include \"util.h\"\n#include \"trans.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"xattr.h\"\n#include \"dir.h\"\n#include \"bmap.h\"\n#include \"acl.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <asm/uaccess.h>\n#include <linux/security.h>\n#include <linux/fiemap.h>\n#include <linux/crc32.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/posix_acl.h>\n#include <linux/xattr.h>\n#include <linux/mm.h>\n#include <linux/namei.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nstruct inode *gfs2_lookupi(struct inode *dir, const struct qstr *name,\n\t\t\t   int is_root)\n{\n\tstruct super_block *sb = dir->i_sb;\n\tstruct gfs2_inode *dip = GFS2_I(dir);\n\tstruct gfs2_holder d_gh;\n\tint error = 0;\n\tstruct inode *inode = NULL;\n\tint unlock = 0;\n\n\tif (!name->len || name->len > GFS2_FNAMESIZE)\n\t\treturn ERR_PTR(-ENAMETOOLONG);\n\n\tif ((name->len == 1 && memcmp(name->name, \".\", 1) == 0) ||\n\t    (name->len == 2 && memcmp(name->name, \"..\", 2) == 0 &&\n\t     dir == sb->s_root->d_inode)) {\n\t\tigrab(dir);\n\t\treturn dir;\n\t}\n\n\tif (gfs2_glock_is_locked_by_me(dip->i_gl) == NULL) {\n\t\terror = gfs2_glock_nq_init(dip->i_gl, LM_ST_SHARED, 0, &d_gh);\n\t\tif (error)\n\t\t\treturn ERR_PTR(error);\n\t\tunlock = 1;\n\t}\n\n\tif (!is_root) {\n\t\terror = gfs2_permission(dir, MAY_EXEC);\n\t\tif (error)\n\t\t\tgoto out;\n\t}\n\n\tinode = gfs2_dir_search(dir, name, false);\n\tif (IS_ERR(inode))\n\t\terror = PTR_ERR(inode);\nout:\n\tif (unlock)\n\t\tgfs2_glock_dq_uninit(&d_gh);\n\tif (error == -ENOENT)\n\t\treturn NULL;\n\treturn inode ? inode : ERR_PTR(error);\n}"
        }
      },
      {
        "call_info": {
          "callee": "igrab",
          "args": [
            "dir"
          ],
          "line": 1278
        },
        "resolved": true,
        "details": {
          "function_name": "igrab",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "1173-1189",
          "snippet": "struct inode *igrab(struct inode *inode)\n{\n\tspin_lock(&inode->i_lock);\n\tif (!(inode->i_state & (I_FREEING|I_WILL_FREE))) {\n\t\t__iget(inode);\n\t\tspin_unlock(&inode->i_lock);\n\t} else {\n\t\tspin_unlock(&inode->i_lock);\n\t\t/*\n\t\t * Handle the case where s_op->clear_inode is not been\n\t\t * called yet, and somebody is calling igrab\n\t\t * while the inode is getting freed.\n\t\t */\n\t\tinode = NULL;\n\t}\n\treturn inode;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nstruct inode *igrab(struct inode *inode)\n{\n\tspin_lock(&inode->i_lock);\n\tif (!(inode->i_state & (I_FREEING|I_WILL_FREE))) {\n\t\t__iget(inode);\n\t\tspin_unlock(&inode->i_lock);\n\t} else {\n\t\tspin_unlock(&inode->i_lock);\n\t\t/*\n\t\t * Handle the case where s_op->clear_inode is not been\n\t\t * called yet, and somebody is calling igrab\n\t\t * while the inode is getting freed.\n\t\t */\n\t\tinode = NULL;\n\t}\n\treturn inode;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"glops.h\"\n#include \"super.h\"\n#include \"util.h\"\n#include \"trans.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"xattr.h\"\n#include \"dir.h\"\n#include \"bmap.h\"\n#include \"acl.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <asm/uaccess.h>\n#include <linux/security.h>\n#include <linux/fiemap.h>\n#include <linux/crc32.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/posix_acl.h>\n#include <linux/xattr.h>\n#include <linux/mm.h>\n#include <linux/namei.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nstatic int gfs2_ok_to_move(struct gfs2_inode *this, struct gfs2_inode *to)\n{\n\tstruct inode *dir = &to->i_inode;\n\tstruct super_block *sb = dir->i_sb;\n\tstruct inode *tmp;\n\tint error = 0;\n\n\tigrab(dir);\n\n\tfor (;;) {\n\t\tif (dir == &this->i_inode) {\n\t\t\terror = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\t\tif (dir == sb->s_root->d_inode) {\n\t\t\terror = 0;\n\t\t\tbreak;\n\t\t}\n\n\t\ttmp = gfs2_lookupi(dir, &gfs2_qdotdot, 1);\n\t\tif (!tmp) {\n\t\t\terror = -ENOENT;\n\t\t\tbreak;\n\t\t}\n\t\tif (IS_ERR(tmp)) {\n\t\t\terror = PTR_ERR(tmp);\n\t\t\tbreak;\n\t\t}\n\n\t\tiput(dir);\n\t\tdir = tmp;\n\t}\n\n\tiput(dir);\n\n\treturn error;\n}"
  },
  {
    "function_name": "gfs2_atomic_open",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/inode.c",
    "lines": "1229-1258",
    "snippet": "static int gfs2_atomic_open(struct inode *dir, struct dentry *dentry,\n                            struct file *file, unsigned flags,\n                            umode_t mode, int *opened)\n{\n\tstruct dentry *d;\n\tbool excl = !!(flags & O_EXCL);\n\n\tif (!d_unhashed(dentry))\n\t\tgoto skip_lookup;\n\n\td = __gfs2_lookup(dir, dentry, file, opened);\n\tif (IS_ERR(d))\n\t\treturn PTR_ERR(d);\n\tif (d != NULL)\n\t\tdentry = d;\n\tif (dentry->d_inode) {\n\t\tif (!(*opened & FILE_OPENED))\n\t\t\treturn finish_no_open(file, d);\n\t\tdput(d);\n\t\treturn 0;\n\t}\n\n\tBUG_ON(d != NULL);\n\nskip_lookup:\n\tif (!(flags & O_CREAT))\n\t\treturn -ENOENT;\n\n\treturn gfs2_create_inode(dir, dentry, file, S_IFREG | mode, 0, NULL, 0, excl, opened);\n}",
    "includes": [
      "#include \"glops.h\"",
      "#include \"super.h\"",
      "#include \"util.h\"",
      "#include \"trans.h\"",
      "#include \"rgrp.h\"",
      "#include \"quota.h\"",
      "#include \"meta_io.h\"",
      "#include \"inode.h\"",
      "#include \"glock.h\"",
      "#include \"xattr.h\"",
      "#include \"dir.h\"",
      "#include \"bmap.h\"",
      "#include \"acl.h\"",
      "#include \"incore.h\"",
      "#include \"gfs2.h\"",
      "#include <asm/uaccess.h>",
      "#include <linux/security.h>",
      "#include <linux/fiemap.h>",
      "#include <linux/crc32.h>",
      "#include <linux/gfs2_ondisk.h>",
      "#include <linux/posix_acl.h>",
      "#include <linux/xattr.h>",
      "#include <linux/mm.h>",
      "#include <linux/namei.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/completion.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "gfs2_create_inode",
          "args": [
            "dir",
            "dentry",
            "file",
            "S_IFREG | mode",
            "0",
            "NULL",
            "0",
            "excl",
            "opened"
          ],
          "line": 1257
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_create_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/inode.c",
          "lines": "584-800",
          "snippet": "static int gfs2_create_inode(struct inode *dir, struct dentry *dentry,\n\t\t\t     struct file *file,\n\t\t\t     umode_t mode, dev_t dev, const char *symname,\n\t\t\t     unsigned int size, int excl, int *opened)\n{\n\tconst struct qstr *name = &dentry->d_name;\n\tstruct posix_acl *default_acl, *acl;\n\tstruct gfs2_holder ghs[2];\n\tstruct inode *inode = NULL;\n\tstruct gfs2_inode *dip = GFS2_I(dir), *ip;\n\tstruct gfs2_sbd *sdp = GFS2_SB(&dip->i_inode);\n\tstruct gfs2_glock *io_gl;\n\tint error, free_vfs_inode = 0;\n\tu32 aflags = 0;\n\tunsigned blocks = 1;\n\tstruct gfs2_diradd da = { .bh = NULL, .save_loc = 1, };\n\n\tif (!name->len || name->len > GFS2_FNAMESIZE)\n\t\treturn -ENAMETOOLONG;\n\n\terror = gfs2_rs_alloc(dip);\n\tif (error)\n\t\treturn error;\n\n\terror = gfs2_rindex_update(sdp);\n\tif (error)\n\t\treturn error;\n\n\terror = gfs2_glock_nq_init(dip->i_gl, LM_ST_EXCLUSIVE, 0, ghs);\n\tif (error)\n\t\tgoto fail;\n\n\terror = create_ok(dip, name, mode);\n\tif (error)\n\t\tgoto fail_gunlock;\n\n\tinode = gfs2_dir_search(dir, &dentry->d_name, !S_ISREG(mode) || excl);\n\terror = PTR_ERR(inode);\n\tif (!IS_ERR(inode)) {\n\t\tif (S_ISDIR(inode->i_mode)) {\n\t\t\tiput(inode);\n\t\t\tinode = ERR_PTR(-EISDIR);\n\t\t\tgoto fail_gunlock;\n\t\t}\n\t\td_instantiate(dentry, inode);\n\t\terror = 0;\n\t\tif (file) {\n\t\t\tif (S_ISREG(inode->i_mode))\n\t\t\t\terror = finish_open(file, dentry, gfs2_open_common, opened);\n\t\t\telse\n\t\t\t\terror = finish_no_open(file, NULL);\n\t\t}\n\t\tgfs2_glock_dq_uninit(ghs);\n\t\treturn error;\n\t} else if (error != -ENOENT) {\n\t\tgoto fail_gunlock;\n\t}\n\n\terror = gfs2_diradd_alloc_required(dir, name, &da);\n\tif (error < 0)\n\t\tgoto fail_gunlock;\n\n\tinode = new_inode(sdp->sd_vfs);\n\terror = -ENOMEM;\n\tif (!inode)\n\t\tgoto fail_gunlock;\n\n\terror = posix_acl_create(dir, &mode, &default_acl, &acl);\n\tif (error)\n\t\tgoto fail_free_vfs_inode;\n\n\tip = GFS2_I(inode);\n\terror = gfs2_rs_alloc(ip);\n\tif (error)\n\t\tgoto fail_free_acls;\n\n\tinode->i_mode = mode;\n\tset_nlink(inode, S_ISDIR(mode) ? 2 : 1);\n\tinode->i_rdev = dev;\n\tinode->i_size = size;\n\tinode->i_atime = inode->i_mtime = inode->i_ctime = CURRENT_TIME;\n\tgfs2_set_inode_blocks(inode, 1);\n\tmunge_mode_uid_gid(dip, inode);\n\tcheck_and_update_goal(dip);\n\tip->i_goal = dip->i_goal;\n\tip->i_diskflags = 0;\n\tip->i_eattr = 0;\n\tip->i_height = 0;\n\tip->i_depth = 0;\n\tip->i_entries = 0;\n\n\tswitch(mode & S_IFMT) {\n\tcase S_IFREG:\n\t\tif ((dip->i_diskflags & GFS2_DIF_INHERIT_JDATA) ||\n\t\t    gfs2_tune_get(sdp, gt_new_files_jdata))\n\t\t\tip->i_diskflags |= GFS2_DIF_JDATA;\n\t\tgfs2_set_aops(inode);\n\t\tbreak;\n\tcase S_IFDIR:\n\t\tip->i_diskflags |= (dip->i_diskflags & GFS2_DIF_INHERIT_JDATA);\n\t\tip->i_diskflags |= GFS2_DIF_JDATA;\n\t\tip->i_entries = 2;\n\t\tbreak;\n\t}\n\tgfs2_set_inode_flags(inode);\n\n\tif ((GFS2_I(sdp->sd_root_dir->d_inode) == dip) ||\n\t    (dip->i_diskflags & GFS2_DIF_TOPDIR))\n\t\taflags |= GFS2_AF_ORLOV;\n\n\tif (default_acl || acl)\n\t\tblocks++;\n\n\terror = alloc_dinode(ip, aflags, &blocks);\n\tif (error)\n\t\tgoto fail_free_inode;\n\n\tgfs2_set_inode_blocks(inode, blocks);\n\n\terror = gfs2_glock_get(sdp, ip->i_no_addr, &gfs2_inode_glops, CREATE, &ip->i_gl);\n\tif (error)\n\t\tgoto fail_free_inode;\n\n\tip->i_gl->gl_object = ip;\n\terror = gfs2_glock_nq_init(ip->i_gl, LM_ST_EXCLUSIVE, GL_SKIP, ghs + 1);\n\tif (error)\n\t\tgoto fail_free_inode;\n\n\terror = gfs2_trans_begin(sdp, blocks, 0);\n\tif (error)\n\t\tgoto fail_gunlock2;\n\n\tif (blocks > 1) {\n\t\tip->i_eattr = ip->i_no_addr + 1;\n\t\tgfs2_init_xattr(ip);\n\t}\n\tinit_dinode(dip, ip, symname);\n\tgfs2_trans_end(sdp);\n\n\terror = gfs2_glock_get(sdp, ip->i_no_addr, &gfs2_iopen_glops, CREATE, &io_gl);\n\tif (error)\n\t\tgoto fail_gunlock2;\n\n\terror = gfs2_glock_nq_init(io_gl, LM_ST_SHARED, GL_EXACT, &ip->i_iopen_gh);\n\tif (error)\n\t\tgoto fail_gunlock2;\n\n\tip->i_iopen_gh.gh_gl->gl_object = ip;\n\tgfs2_glock_put(io_gl);\n\tgfs2_set_iop(inode);\n\tinsert_inode_hash(inode);\n\n\tif (default_acl) {\n\t\terror = gfs2_set_acl(inode, default_acl, ACL_TYPE_DEFAULT);\n\t\tposix_acl_release(default_acl);\n\t}\n\tif (acl) {\n\t\tif (!error)\n\t\t\terror = gfs2_set_acl(inode, acl, ACL_TYPE_ACCESS);\n\t\tposix_acl_release(acl);\n\t}\n\n\tif (error)\n\t\tgoto fail_gunlock3;\n\n\terror = security_inode_init_security(&ip->i_inode, &dip->i_inode, name,\n\t\t\t\t\t     &gfs2_initxattrs, NULL);\n\tif (error)\n\t\tgoto fail_gunlock3;\n\n\terror = link_dinode(dip, name, ip, &da);\n\tif (error)\n\t\tgoto fail_gunlock3;\n\n\tmark_inode_dirty(inode);\n\td_instantiate(dentry, inode);\n\tif (file) {\n\t\t*opened |= FILE_CREATED;\n\t\terror = finish_open(file, dentry, gfs2_open_common, opened);\n\t}\n\tgfs2_glock_dq_uninit(ghs);\n\tgfs2_glock_dq_uninit(ghs + 1);\n\treturn error;\n\nfail_gunlock3:\n\tgfs2_glock_dq_uninit(ghs + 1);\n\tif (ip->i_gl)\n\t\tgfs2_glock_put(ip->i_gl);\n\tgoto fail_gunlock;\n\nfail_gunlock2:\n\tgfs2_glock_dq_uninit(ghs + 1);\nfail_free_inode:\n\tif (ip->i_gl)\n\t\tgfs2_glock_put(ip->i_gl);\n\tgfs2_rs_delete(ip, NULL);\nfail_free_acls:\n\tif (default_acl)\n\t\tposix_acl_release(default_acl);\n\tif (acl)\n\t\tposix_acl_release(acl);\nfail_free_vfs_inode:\n\tfree_vfs_inode = 1;\nfail_gunlock:\n\tgfs2_dir_no_add(&da);\n\tgfs2_glock_dq_uninit(ghs);\n\tif (inode && !IS_ERR(inode)) {\n\t\tclear_nlink(inode);\n\t\tif (!free_vfs_inode)\n\t\t\tmark_inode_dirty(inode);\n\t\tset_bit(free_vfs_inode ? GIF_FREE_VFS_INODE : GIF_ALLOC_FAILED,\n\t\t\t&GFS2_I(inode)->i_flags);\n\t\tiput(inode);\n\t}\nfail:\n\treturn error;\n}",
          "includes": [
            "#include \"glops.h\"",
            "#include \"super.h\"",
            "#include \"util.h\"",
            "#include \"trans.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"inode.h\"",
            "#include \"glock.h\"",
            "#include \"xattr.h\"",
            "#include \"dir.h\"",
            "#include \"bmap.h\"",
            "#include \"acl.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/security.h>",
            "#include <linux/fiemap.h>",
            "#include <linux/crc32.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/xattr.h>",
            "#include <linux/mm.h>",
            "#include <linux/namei.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glops.h\"\n#include \"super.h\"\n#include \"util.h\"\n#include \"trans.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"xattr.h\"\n#include \"dir.h\"\n#include \"bmap.h\"\n#include \"acl.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <asm/uaccess.h>\n#include <linux/security.h>\n#include <linux/fiemap.h>\n#include <linux/crc32.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/posix_acl.h>\n#include <linux/xattr.h>\n#include <linux/mm.h>\n#include <linux/namei.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nstatic int gfs2_create_inode(struct inode *dir, struct dentry *dentry,\n\t\t\t     struct file *file,\n\t\t\t     umode_t mode, dev_t dev, const char *symname,\n\t\t\t     unsigned int size, int excl, int *opened)\n{\n\tconst struct qstr *name = &dentry->d_name;\n\tstruct posix_acl *default_acl, *acl;\n\tstruct gfs2_holder ghs[2];\n\tstruct inode *inode = NULL;\n\tstruct gfs2_inode *dip = GFS2_I(dir), *ip;\n\tstruct gfs2_sbd *sdp = GFS2_SB(&dip->i_inode);\n\tstruct gfs2_glock *io_gl;\n\tint error, free_vfs_inode = 0;\n\tu32 aflags = 0;\n\tunsigned blocks = 1;\n\tstruct gfs2_diradd da = { .bh = NULL, .save_loc = 1, };\n\n\tif (!name->len || name->len > GFS2_FNAMESIZE)\n\t\treturn -ENAMETOOLONG;\n\n\terror = gfs2_rs_alloc(dip);\n\tif (error)\n\t\treturn error;\n\n\terror = gfs2_rindex_update(sdp);\n\tif (error)\n\t\treturn error;\n\n\terror = gfs2_glock_nq_init(dip->i_gl, LM_ST_EXCLUSIVE, 0, ghs);\n\tif (error)\n\t\tgoto fail;\n\n\terror = create_ok(dip, name, mode);\n\tif (error)\n\t\tgoto fail_gunlock;\n\n\tinode = gfs2_dir_search(dir, &dentry->d_name, !S_ISREG(mode) || excl);\n\terror = PTR_ERR(inode);\n\tif (!IS_ERR(inode)) {\n\t\tif (S_ISDIR(inode->i_mode)) {\n\t\t\tiput(inode);\n\t\t\tinode = ERR_PTR(-EISDIR);\n\t\t\tgoto fail_gunlock;\n\t\t}\n\t\td_instantiate(dentry, inode);\n\t\terror = 0;\n\t\tif (file) {\n\t\t\tif (S_ISREG(inode->i_mode))\n\t\t\t\terror = finish_open(file, dentry, gfs2_open_common, opened);\n\t\t\telse\n\t\t\t\terror = finish_no_open(file, NULL);\n\t\t}\n\t\tgfs2_glock_dq_uninit(ghs);\n\t\treturn error;\n\t} else if (error != -ENOENT) {\n\t\tgoto fail_gunlock;\n\t}\n\n\terror = gfs2_diradd_alloc_required(dir, name, &da);\n\tif (error < 0)\n\t\tgoto fail_gunlock;\n\n\tinode = new_inode(sdp->sd_vfs);\n\terror = -ENOMEM;\n\tif (!inode)\n\t\tgoto fail_gunlock;\n\n\terror = posix_acl_create(dir, &mode, &default_acl, &acl);\n\tif (error)\n\t\tgoto fail_free_vfs_inode;\n\n\tip = GFS2_I(inode);\n\terror = gfs2_rs_alloc(ip);\n\tif (error)\n\t\tgoto fail_free_acls;\n\n\tinode->i_mode = mode;\n\tset_nlink(inode, S_ISDIR(mode) ? 2 : 1);\n\tinode->i_rdev = dev;\n\tinode->i_size = size;\n\tinode->i_atime = inode->i_mtime = inode->i_ctime = CURRENT_TIME;\n\tgfs2_set_inode_blocks(inode, 1);\n\tmunge_mode_uid_gid(dip, inode);\n\tcheck_and_update_goal(dip);\n\tip->i_goal = dip->i_goal;\n\tip->i_diskflags = 0;\n\tip->i_eattr = 0;\n\tip->i_height = 0;\n\tip->i_depth = 0;\n\tip->i_entries = 0;\n\n\tswitch(mode & S_IFMT) {\n\tcase S_IFREG:\n\t\tif ((dip->i_diskflags & GFS2_DIF_INHERIT_JDATA) ||\n\t\t    gfs2_tune_get(sdp, gt_new_files_jdata))\n\t\t\tip->i_diskflags |= GFS2_DIF_JDATA;\n\t\tgfs2_set_aops(inode);\n\t\tbreak;\n\tcase S_IFDIR:\n\t\tip->i_diskflags |= (dip->i_diskflags & GFS2_DIF_INHERIT_JDATA);\n\t\tip->i_diskflags |= GFS2_DIF_JDATA;\n\t\tip->i_entries = 2;\n\t\tbreak;\n\t}\n\tgfs2_set_inode_flags(inode);\n\n\tif ((GFS2_I(sdp->sd_root_dir->d_inode) == dip) ||\n\t    (dip->i_diskflags & GFS2_DIF_TOPDIR))\n\t\taflags |= GFS2_AF_ORLOV;\n\n\tif (default_acl || acl)\n\t\tblocks++;\n\n\terror = alloc_dinode(ip, aflags, &blocks);\n\tif (error)\n\t\tgoto fail_free_inode;\n\n\tgfs2_set_inode_blocks(inode, blocks);\n\n\terror = gfs2_glock_get(sdp, ip->i_no_addr, &gfs2_inode_glops, CREATE, &ip->i_gl);\n\tif (error)\n\t\tgoto fail_free_inode;\n\n\tip->i_gl->gl_object = ip;\n\terror = gfs2_glock_nq_init(ip->i_gl, LM_ST_EXCLUSIVE, GL_SKIP, ghs + 1);\n\tif (error)\n\t\tgoto fail_free_inode;\n\n\terror = gfs2_trans_begin(sdp, blocks, 0);\n\tif (error)\n\t\tgoto fail_gunlock2;\n\n\tif (blocks > 1) {\n\t\tip->i_eattr = ip->i_no_addr + 1;\n\t\tgfs2_init_xattr(ip);\n\t}\n\tinit_dinode(dip, ip, symname);\n\tgfs2_trans_end(sdp);\n\n\terror = gfs2_glock_get(sdp, ip->i_no_addr, &gfs2_iopen_glops, CREATE, &io_gl);\n\tif (error)\n\t\tgoto fail_gunlock2;\n\n\terror = gfs2_glock_nq_init(io_gl, LM_ST_SHARED, GL_EXACT, &ip->i_iopen_gh);\n\tif (error)\n\t\tgoto fail_gunlock2;\n\n\tip->i_iopen_gh.gh_gl->gl_object = ip;\n\tgfs2_glock_put(io_gl);\n\tgfs2_set_iop(inode);\n\tinsert_inode_hash(inode);\n\n\tif (default_acl) {\n\t\terror = gfs2_set_acl(inode, default_acl, ACL_TYPE_DEFAULT);\n\t\tposix_acl_release(default_acl);\n\t}\n\tif (acl) {\n\t\tif (!error)\n\t\t\terror = gfs2_set_acl(inode, acl, ACL_TYPE_ACCESS);\n\t\tposix_acl_release(acl);\n\t}\n\n\tif (error)\n\t\tgoto fail_gunlock3;\n\n\terror = security_inode_init_security(&ip->i_inode, &dip->i_inode, name,\n\t\t\t\t\t     &gfs2_initxattrs, NULL);\n\tif (error)\n\t\tgoto fail_gunlock3;\n\n\terror = link_dinode(dip, name, ip, &da);\n\tif (error)\n\t\tgoto fail_gunlock3;\n\n\tmark_inode_dirty(inode);\n\td_instantiate(dentry, inode);\n\tif (file) {\n\t\t*opened |= FILE_CREATED;\n\t\terror = finish_open(file, dentry, gfs2_open_common, opened);\n\t}\n\tgfs2_glock_dq_uninit(ghs);\n\tgfs2_glock_dq_uninit(ghs + 1);\n\treturn error;\n\nfail_gunlock3:\n\tgfs2_glock_dq_uninit(ghs + 1);\n\tif (ip->i_gl)\n\t\tgfs2_glock_put(ip->i_gl);\n\tgoto fail_gunlock;\n\nfail_gunlock2:\n\tgfs2_glock_dq_uninit(ghs + 1);\nfail_free_inode:\n\tif (ip->i_gl)\n\t\tgfs2_glock_put(ip->i_gl);\n\tgfs2_rs_delete(ip, NULL);\nfail_free_acls:\n\tif (default_acl)\n\t\tposix_acl_release(default_acl);\n\tif (acl)\n\t\tposix_acl_release(acl);\nfail_free_vfs_inode:\n\tfree_vfs_inode = 1;\nfail_gunlock:\n\tgfs2_dir_no_add(&da);\n\tgfs2_glock_dq_uninit(ghs);\n\tif (inode && !IS_ERR(inode)) {\n\t\tclear_nlink(inode);\n\t\tif (!free_vfs_inode)\n\t\t\tmark_inode_dirty(inode);\n\t\tset_bit(free_vfs_inode ? GIF_FREE_VFS_INODE : GIF_ALLOC_FAILED,\n\t\t\t&GFS2_I(inode)->i_flags);\n\t\tiput(inode);\n\t}\nfail:\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "d != NULL"
          ],
          "line": 1251
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dput",
          "args": [
            "d"
          ],
          "line": 1247
        },
        "resolved": true,
        "details": {
          "function_name": "dput",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "726-762",
          "snippet": "void dput(struct dentry *dentry)\n{\n\tif (unlikely(!dentry))\n\t\treturn;\n\nrepeat:\n\trcu_read_lock();\n\tif (likely(fast_dput(dentry))) {\n\t\trcu_read_unlock();\n\t\treturn;\n\t}\n\n\t/* Slow case: now with the dentry lock held */\n\trcu_read_unlock();\n\n\t/* Unreachable? Get rid of it */\n\tif (unlikely(d_unhashed(dentry)))\n\t\tgoto kill_it;\n\n\tif (unlikely(dentry->d_flags & DCACHE_OP_DELETE)) {\n\t\tif (dentry->d_op->d_delete(dentry))\n\t\t\tgoto kill_it;\n\t}\n\n\tif (!(dentry->d_flags & DCACHE_REFERENCED))\n\t\tdentry->d_flags |= DCACHE_REFERENCED;\n\tdentry_lru_add(dentry);\n\n\tdentry->d_lockref.count--;\n\tspin_unlock(&dentry->d_lock);\n\treturn;\n\nkill_it:\n\tdentry = dentry_kill(dentry);\n\tif (dentry)\n\t\tgoto repeat;\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nvoid dput(struct dentry *dentry)\n{\n\tif (unlikely(!dentry))\n\t\treturn;\n\nrepeat:\n\trcu_read_lock();\n\tif (likely(fast_dput(dentry))) {\n\t\trcu_read_unlock();\n\t\treturn;\n\t}\n\n\t/* Slow case: now with the dentry lock held */\n\trcu_read_unlock();\n\n\t/* Unreachable? Get rid of it */\n\tif (unlikely(d_unhashed(dentry)))\n\t\tgoto kill_it;\n\n\tif (unlikely(dentry->d_flags & DCACHE_OP_DELETE)) {\n\t\tif (dentry->d_op->d_delete(dentry))\n\t\t\tgoto kill_it;\n\t}\n\n\tif (!(dentry->d_flags & DCACHE_REFERENCED))\n\t\tdentry->d_flags |= DCACHE_REFERENCED;\n\tdentry_lru_add(dentry);\n\n\tdentry->d_lockref.count--;\n\tspin_unlock(&dentry->d_lock);\n\treturn;\n\nkill_it:\n\tdentry = dentry_kill(dentry);\n\tif (dentry)\n\t\tgoto repeat;\n}"
        }
      },
      {
        "call_info": {
          "callee": "finish_no_open",
          "args": [
            "file",
            "d"
          ],
          "line": 1246
        },
        "resolved": true,
        "details": {
          "function_name": "finish_no_open",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/open.c",
          "lines": "814-818",
          "snippet": "int finish_no_open(struct file *file, struct dentry *dentry)\n{\n\tfile->f_path.dentry = dentry;\n\treturn 1;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/compat.h>",
            "#include <linux/dnotify.h>",
            "#include <linux/ima.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/falloc.h>",
            "#include <linux/audit.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/personality.h>",
            "#include <linux/fs.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/mount.h>",
            "#include <linux/security.h>",
            "#include <linux/securebits.h>",
            "#include <linux/capability.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/namei.h>",
            "#include <linux/tty.h>",
            "#include <linux/module.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/compat.h>\n#include <linux/dnotify.h>\n#include <linux/ima.h>\n#include <linux/fs_struct.h>\n#include <linux/falloc.h>\n#include <linux/audit.h>\n#include <linux/rcupdate.h>\n#include <linux/syscalls.h>\n#include <linux/pagemap.h>\n#include <linux/personality.h>\n#include <linux/fs.h>\n#include <asm/uaccess.h>\n#include <linux/slab.h>\n#include <linux/fcntl.h>\n#include <linux/mount.h>\n#include <linux/security.h>\n#include <linux/securebits.h>\n#include <linux/capability.h>\n#include <linux/backing-dev.h>\n#include <linux/namei.h>\n#include <linux/tty.h>\n#include <linux/module.h>\n#include <linux/fsnotify.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n\nint finish_no_open(struct file *file, struct dentry *dentry)\n{\n\tfile->f_path.dentry = dentry;\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "d"
          ],
          "line": 1241
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "d"
          ],
          "line": 1240
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__gfs2_lookup",
          "args": [
            "dir",
            "dentry",
            "file",
            "opened"
          ],
          "line": 1239
        },
        "resolved": true,
        "details": {
          "function_name": "__gfs2_lookup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/inode.c",
          "lines": "828-866",
          "snippet": "static struct dentry *__gfs2_lookup(struct inode *dir, struct dentry *dentry,\n\t\t\t\t    struct file *file, int *opened)\n{\n\tstruct inode *inode;\n\tstruct dentry *d;\n\tstruct gfs2_holder gh;\n\tstruct gfs2_glock *gl;\n\tint error;\n\n\tinode = gfs2_lookupi(dir, &dentry->d_name, 0);\n\tif (inode == NULL) {\n\t\td_add(dentry, NULL);\n\t\treturn NULL;\n\t}\n\tif (IS_ERR(inode))\n\t\treturn ERR_CAST(inode);\n\n\tgl = GFS2_I(inode)->i_gl;\n\terror = gfs2_glock_nq_init(gl, LM_ST_SHARED, LM_FLAG_ANY, &gh);\n\tif (error) {\n\t\tiput(inode);\n\t\treturn ERR_PTR(error);\n\t}\n\n\td = d_splice_alias(inode, dentry);\n\tif (IS_ERR(d)) {\n\t\tgfs2_glock_dq_uninit(&gh);\n\t\treturn d;\n\t}\n\tif (file && S_ISREG(inode->i_mode))\n\t\terror = finish_open(file, dentry, gfs2_open_common, opened);\n\n\tgfs2_glock_dq_uninit(&gh);\n\tif (error) {\n\t\tdput(d);\n\t\treturn ERR_PTR(error);\n\t}\n\treturn d;\n}",
          "includes": [
            "#include \"glops.h\"",
            "#include \"super.h\"",
            "#include \"util.h\"",
            "#include \"trans.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"inode.h\"",
            "#include \"glock.h\"",
            "#include \"xattr.h\"",
            "#include \"dir.h\"",
            "#include \"bmap.h\"",
            "#include \"acl.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/security.h>",
            "#include <linux/fiemap.h>",
            "#include <linux/crc32.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/xattr.h>",
            "#include <linux/mm.h>",
            "#include <linux/namei.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glops.h\"\n#include \"super.h\"\n#include \"util.h\"\n#include \"trans.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"xattr.h\"\n#include \"dir.h\"\n#include \"bmap.h\"\n#include \"acl.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <asm/uaccess.h>\n#include <linux/security.h>\n#include <linux/fiemap.h>\n#include <linux/crc32.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/posix_acl.h>\n#include <linux/xattr.h>\n#include <linux/mm.h>\n#include <linux/namei.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nstatic struct dentry *__gfs2_lookup(struct inode *dir, struct dentry *dentry,\n\t\t\t\t    struct file *file, int *opened)\n{\n\tstruct inode *inode;\n\tstruct dentry *d;\n\tstruct gfs2_holder gh;\n\tstruct gfs2_glock *gl;\n\tint error;\n\n\tinode = gfs2_lookupi(dir, &dentry->d_name, 0);\n\tif (inode == NULL) {\n\t\td_add(dentry, NULL);\n\t\treturn NULL;\n\t}\n\tif (IS_ERR(inode))\n\t\treturn ERR_CAST(inode);\n\n\tgl = GFS2_I(inode)->i_gl;\n\terror = gfs2_glock_nq_init(gl, LM_ST_SHARED, LM_FLAG_ANY, &gh);\n\tif (error) {\n\t\tiput(inode);\n\t\treturn ERR_PTR(error);\n\t}\n\n\td = d_splice_alias(inode, dentry);\n\tif (IS_ERR(d)) {\n\t\tgfs2_glock_dq_uninit(&gh);\n\t\treturn d;\n\t}\n\tif (file && S_ISREG(inode->i_mode))\n\t\terror = finish_open(file, dentry, gfs2_open_common, opened);\n\n\tgfs2_glock_dq_uninit(&gh);\n\tif (error) {\n\t\tdput(d);\n\t\treturn ERR_PTR(error);\n\t}\n\treturn d;\n}"
        }
      },
      {
        "call_info": {
          "callee": "d_unhashed",
          "args": [
            "dentry"
          ],
          "line": 1236
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"glops.h\"\n#include \"super.h\"\n#include \"util.h\"\n#include \"trans.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"xattr.h\"\n#include \"dir.h\"\n#include \"bmap.h\"\n#include \"acl.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <asm/uaccess.h>\n#include <linux/security.h>\n#include <linux/fiemap.h>\n#include <linux/crc32.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/posix_acl.h>\n#include <linux/xattr.h>\n#include <linux/mm.h>\n#include <linux/namei.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nstatic int gfs2_atomic_open(struct inode *dir, struct dentry *dentry,\n                            struct file *file, unsigned flags,\n                            umode_t mode, int *opened)\n{\n\tstruct dentry *d;\n\tbool excl = !!(flags & O_EXCL);\n\n\tif (!d_unhashed(dentry))\n\t\tgoto skip_lookup;\n\n\td = __gfs2_lookup(dir, dentry, file, opened);\n\tif (IS_ERR(d))\n\t\treturn PTR_ERR(d);\n\tif (d != NULL)\n\t\tdentry = d;\n\tif (dentry->d_inode) {\n\t\tif (!(*opened & FILE_OPENED))\n\t\t\treturn finish_no_open(file, d);\n\t\tdput(d);\n\t\treturn 0;\n\t}\n\n\tBUG_ON(d != NULL);\n\nskip_lookup:\n\tif (!(flags & O_CREAT))\n\t\treturn -ENOENT;\n\n\treturn gfs2_create_inode(dir, dentry, file, S_IFREG | mode, 0, NULL, 0, excl, opened);\n}"
  },
  {
    "function_name": "gfs2_mknod",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/inode.c",
    "lines": "1211-1215",
    "snippet": "static int gfs2_mknod(struct inode *dir, struct dentry *dentry, umode_t mode,\n\t\t      dev_t dev)\n{\n\treturn gfs2_create_inode(dir, dentry, NULL, mode, dev, NULL, 0, 0, NULL);\n}",
    "includes": [
      "#include \"glops.h\"",
      "#include \"super.h\"",
      "#include \"util.h\"",
      "#include \"trans.h\"",
      "#include \"rgrp.h\"",
      "#include \"quota.h\"",
      "#include \"meta_io.h\"",
      "#include \"inode.h\"",
      "#include \"glock.h\"",
      "#include \"xattr.h\"",
      "#include \"dir.h\"",
      "#include \"bmap.h\"",
      "#include \"acl.h\"",
      "#include \"incore.h\"",
      "#include \"gfs2.h\"",
      "#include <asm/uaccess.h>",
      "#include <linux/security.h>",
      "#include <linux/fiemap.h>",
      "#include <linux/crc32.h>",
      "#include <linux/gfs2_ondisk.h>",
      "#include <linux/posix_acl.h>",
      "#include <linux/xattr.h>",
      "#include <linux/mm.h>",
      "#include <linux/namei.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/completion.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "gfs2_create_inode",
          "args": [
            "dir",
            "dentry",
            "NULL",
            "mode",
            "dev",
            "NULL",
            "0",
            "0",
            "NULL"
          ],
          "line": 1214
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_create_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/inode.c",
          "lines": "584-800",
          "snippet": "static int gfs2_create_inode(struct inode *dir, struct dentry *dentry,\n\t\t\t     struct file *file,\n\t\t\t     umode_t mode, dev_t dev, const char *symname,\n\t\t\t     unsigned int size, int excl, int *opened)\n{\n\tconst struct qstr *name = &dentry->d_name;\n\tstruct posix_acl *default_acl, *acl;\n\tstruct gfs2_holder ghs[2];\n\tstruct inode *inode = NULL;\n\tstruct gfs2_inode *dip = GFS2_I(dir), *ip;\n\tstruct gfs2_sbd *sdp = GFS2_SB(&dip->i_inode);\n\tstruct gfs2_glock *io_gl;\n\tint error, free_vfs_inode = 0;\n\tu32 aflags = 0;\n\tunsigned blocks = 1;\n\tstruct gfs2_diradd da = { .bh = NULL, .save_loc = 1, };\n\n\tif (!name->len || name->len > GFS2_FNAMESIZE)\n\t\treturn -ENAMETOOLONG;\n\n\terror = gfs2_rs_alloc(dip);\n\tif (error)\n\t\treturn error;\n\n\terror = gfs2_rindex_update(sdp);\n\tif (error)\n\t\treturn error;\n\n\terror = gfs2_glock_nq_init(dip->i_gl, LM_ST_EXCLUSIVE, 0, ghs);\n\tif (error)\n\t\tgoto fail;\n\n\terror = create_ok(dip, name, mode);\n\tif (error)\n\t\tgoto fail_gunlock;\n\n\tinode = gfs2_dir_search(dir, &dentry->d_name, !S_ISREG(mode) || excl);\n\terror = PTR_ERR(inode);\n\tif (!IS_ERR(inode)) {\n\t\tif (S_ISDIR(inode->i_mode)) {\n\t\t\tiput(inode);\n\t\t\tinode = ERR_PTR(-EISDIR);\n\t\t\tgoto fail_gunlock;\n\t\t}\n\t\td_instantiate(dentry, inode);\n\t\terror = 0;\n\t\tif (file) {\n\t\t\tif (S_ISREG(inode->i_mode))\n\t\t\t\terror = finish_open(file, dentry, gfs2_open_common, opened);\n\t\t\telse\n\t\t\t\terror = finish_no_open(file, NULL);\n\t\t}\n\t\tgfs2_glock_dq_uninit(ghs);\n\t\treturn error;\n\t} else if (error != -ENOENT) {\n\t\tgoto fail_gunlock;\n\t}\n\n\terror = gfs2_diradd_alloc_required(dir, name, &da);\n\tif (error < 0)\n\t\tgoto fail_gunlock;\n\n\tinode = new_inode(sdp->sd_vfs);\n\terror = -ENOMEM;\n\tif (!inode)\n\t\tgoto fail_gunlock;\n\n\terror = posix_acl_create(dir, &mode, &default_acl, &acl);\n\tif (error)\n\t\tgoto fail_free_vfs_inode;\n\n\tip = GFS2_I(inode);\n\terror = gfs2_rs_alloc(ip);\n\tif (error)\n\t\tgoto fail_free_acls;\n\n\tinode->i_mode = mode;\n\tset_nlink(inode, S_ISDIR(mode) ? 2 : 1);\n\tinode->i_rdev = dev;\n\tinode->i_size = size;\n\tinode->i_atime = inode->i_mtime = inode->i_ctime = CURRENT_TIME;\n\tgfs2_set_inode_blocks(inode, 1);\n\tmunge_mode_uid_gid(dip, inode);\n\tcheck_and_update_goal(dip);\n\tip->i_goal = dip->i_goal;\n\tip->i_diskflags = 0;\n\tip->i_eattr = 0;\n\tip->i_height = 0;\n\tip->i_depth = 0;\n\tip->i_entries = 0;\n\n\tswitch(mode & S_IFMT) {\n\tcase S_IFREG:\n\t\tif ((dip->i_diskflags & GFS2_DIF_INHERIT_JDATA) ||\n\t\t    gfs2_tune_get(sdp, gt_new_files_jdata))\n\t\t\tip->i_diskflags |= GFS2_DIF_JDATA;\n\t\tgfs2_set_aops(inode);\n\t\tbreak;\n\tcase S_IFDIR:\n\t\tip->i_diskflags |= (dip->i_diskflags & GFS2_DIF_INHERIT_JDATA);\n\t\tip->i_diskflags |= GFS2_DIF_JDATA;\n\t\tip->i_entries = 2;\n\t\tbreak;\n\t}\n\tgfs2_set_inode_flags(inode);\n\n\tif ((GFS2_I(sdp->sd_root_dir->d_inode) == dip) ||\n\t    (dip->i_diskflags & GFS2_DIF_TOPDIR))\n\t\taflags |= GFS2_AF_ORLOV;\n\n\tif (default_acl || acl)\n\t\tblocks++;\n\n\terror = alloc_dinode(ip, aflags, &blocks);\n\tif (error)\n\t\tgoto fail_free_inode;\n\n\tgfs2_set_inode_blocks(inode, blocks);\n\n\terror = gfs2_glock_get(sdp, ip->i_no_addr, &gfs2_inode_glops, CREATE, &ip->i_gl);\n\tif (error)\n\t\tgoto fail_free_inode;\n\n\tip->i_gl->gl_object = ip;\n\terror = gfs2_glock_nq_init(ip->i_gl, LM_ST_EXCLUSIVE, GL_SKIP, ghs + 1);\n\tif (error)\n\t\tgoto fail_free_inode;\n\n\terror = gfs2_trans_begin(sdp, blocks, 0);\n\tif (error)\n\t\tgoto fail_gunlock2;\n\n\tif (blocks > 1) {\n\t\tip->i_eattr = ip->i_no_addr + 1;\n\t\tgfs2_init_xattr(ip);\n\t}\n\tinit_dinode(dip, ip, symname);\n\tgfs2_trans_end(sdp);\n\n\terror = gfs2_glock_get(sdp, ip->i_no_addr, &gfs2_iopen_glops, CREATE, &io_gl);\n\tif (error)\n\t\tgoto fail_gunlock2;\n\n\terror = gfs2_glock_nq_init(io_gl, LM_ST_SHARED, GL_EXACT, &ip->i_iopen_gh);\n\tif (error)\n\t\tgoto fail_gunlock2;\n\n\tip->i_iopen_gh.gh_gl->gl_object = ip;\n\tgfs2_glock_put(io_gl);\n\tgfs2_set_iop(inode);\n\tinsert_inode_hash(inode);\n\n\tif (default_acl) {\n\t\terror = gfs2_set_acl(inode, default_acl, ACL_TYPE_DEFAULT);\n\t\tposix_acl_release(default_acl);\n\t}\n\tif (acl) {\n\t\tif (!error)\n\t\t\terror = gfs2_set_acl(inode, acl, ACL_TYPE_ACCESS);\n\t\tposix_acl_release(acl);\n\t}\n\n\tif (error)\n\t\tgoto fail_gunlock3;\n\n\terror = security_inode_init_security(&ip->i_inode, &dip->i_inode, name,\n\t\t\t\t\t     &gfs2_initxattrs, NULL);\n\tif (error)\n\t\tgoto fail_gunlock3;\n\n\terror = link_dinode(dip, name, ip, &da);\n\tif (error)\n\t\tgoto fail_gunlock3;\n\n\tmark_inode_dirty(inode);\n\td_instantiate(dentry, inode);\n\tif (file) {\n\t\t*opened |= FILE_CREATED;\n\t\terror = finish_open(file, dentry, gfs2_open_common, opened);\n\t}\n\tgfs2_glock_dq_uninit(ghs);\n\tgfs2_glock_dq_uninit(ghs + 1);\n\treturn error;\n\nfail_gunlock3:\n\tgfs2_glock_dq_uninit(ghs + 1);\n\tif (ip->i_gl)\n\t\tgfs2_glock_put(ip->i_gl);\n\tgoto fail_gunlock;\n\nfail_gunlock2:\n\tgfs2_glock_dq_uninit(ghs + 1);\nfail_free_inode:\n\tif (ip->i_gl)\n\t\tgfs2_glock_put(ip->i_gl);\n\tgfs2_rs_delete(ip, NULL);\nfail_free_acls:\n\tif (default_acl)\n\t\tposix_acl_release(default_acl);\n\tif (acl)\n\t\tposix_acl_release(acl);\nfail_free_vfs_inode:\n\tfree_vfs_inode = 1;\nfail_gunlock:\n\tgfs2_dir_no_add(&da);\n\tgfs2_glock_dq_uninit(ghs);\n\tif (inode && !IS_ERR(inode)) {\n\t\tclear_nlink(inode);\n\t\tif (!free_vfs_inode)\n\t\t\tmark_inode_dirty(inode);\n\t\tset_bit(free_vfs_inode ? GIF_FREE_VFS_INODE : GIF_ALLOC_FAILED,\n\t\t\t&GFS2_I(inode)->i_flags);\n\t\tiput(inode);\n\t}\nfail:\n\treturn error;\n}",
          "includes": [
            "#include \"glops.h\"",
            "#include \"super.h\"",
            "#include \"util.h\"",
            "#include \"trans.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"inode.h\"",
            "#include \"glock.h\"",
            "#include \"xattr.h\"",
            "#include \"dir.h\"",
            "#include \"bmap.h\"",
            "#include \"acl.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/security.h>",
            "#include <linux/fiemap.h>",
            "#include <linux/crc32.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/xattr.h>",
            "#include <linux/mm.h>",
            "#include <linux/namei.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glops.h\"\n#include \"super.h\"\n#include \"util.h\"\n#include \"trans.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"xattr.h\"\n#include \"dir.h\"\n#include \"bmap.h\"\n#include \"acl.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <asm/uaccess.h>\n#include <linux/security.h>\n#include <linux/fiemap.h>\n#include <linux/crc32.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/posix_acl.h>\n#include <linux/xattr.h>\n#include <linux/mm.h>\n#include <linux/namei.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nstatic int gfs2_create_inode(struct inode *dir, struct dentry *dentry,\n\t\t\t     struct file *file,\n\t\t\t     umode_t mode, dev_t dev, const char *symname,\n\t\t\t     unsigned int size, int excl, int *opened)\n{\n\tconst struct qstr *name = &dentry->d_name;\n\tstruct posix_acl *default_acl, *acl;\n\tstruct gfs2_holder ghs[2];\n\tstruct inode *inode = NULL;\n\tstruct gfs2_inode *dip = GFS2_I(dir), *ip;\n\tstruct gfs2_sbd *sdp = GFS2_SB(&dip->i_inode);\n\tstruct gfs2_glock *io_gl;\n\tint error, free_vfs_inode = 0;\n\tu32 aflags = 0;\n\tunsigned blocks = 1;\n\tstruct gfs2_diradd da = { .bh = NULL, .save_loc = 1, };\n\n\tif (!name->len || name->len > GFS2_FNAMESIZE)\n\t\treturn -ENAMETOOLONG;\n\n\terror = gfs2_rs_alloc(dip);\n\tif (error)\n\t\treturn error;\n\n\terror = gfs2_rindex_update(sdp);\n\tif (error)\n\t\treturn error;\n\n\terror = gfs2_glock_nq_init(dip->i_gl, LM_ST_EXCLUSIVE, 0, ghs);\n\tif (error)\n\t\tgoto fail;\n\n\terror = create_ok(dip, name, mode);\n\tif (error)\n\t\tgoto fail_gunlock;\n\n\tinode = gfs2_dir_search(dir, &dentry->d_name, !S_ISREG(mode) || excl);\n\terror = PTR_ERR(inode);\n\tif (!IS_ERR(inode)) {\n\t\tif (S_ISDIR(inode->i_mode)) {\n\t\t\tiput(inode);\n\t\t\tinode = ERR_PTR(-EISDIR);\n\t\t\tgoto fail_gunlock;\n\t\t}\n\t\td_instantiate(dentry, inode);\n\t\terror = 0;\n\t\tif (file) {\n\t\t\tif (S_ISREG(inode->i_mode))\n\t\t\t\terror = finish_open(file, dentry, gfs2_open_common, opened);\n\t\t\telse\n\t\t\t\terror = finish_no_open(file, NULL);\n\t\t}\n\t\tgfs2_glock_dq_uninit(ghs);\n\t\treturn error;\n\t} else if (error != -ENOENT) {\n\t\tgoto fail_gunlock;\n\t}\n\n\terror = gfs2_diradd_alloc_required(dir, name, &da);\n\tif (error < 0)\n\t\tgoto fail_gunlock;\n\n\tinode = new_inode(sdp->sd_vfs);\n\terror = -ENOMEM;\n\tif (!inode)\n\t\tgoto fail_gunlock;\n\n\terror = posix_acl_create(dir, &mode, &default_acl, &acl);\n\tif (error)\n\t\tgoto fail_free_vfs_inode;\n\n\tip = GFS2_I(inode);\n\terror = gfs2_rs_alloc(ip);\n\tif (error)\n\t\tgoto fail_free_acls;\n\n\tinode->i_mode = mode;\n\tset_nlink(inode, S_ISDIR(mode) ? 2 : 1);\n\tinode->i_rdev = dev;\n\tinode->i_size = size;\n\tinode->i_atime = inode->i_mtime = inode->i_ctime = CURRENT_TIME;\n\tgfs2_set_inode_blocks(inode, 1);\n\tmunge_mode_uid_gid(dip, inode);\n\tcheck_and_update_goal(dip);\n\tip->i_goal = dip->i_goal;\n\tip->i_diskflags = 0;\n\tip->i_eattr = 0;\n\tip->i_height = 0;\n\tip->i_depth = 0;\n\tip->i_entries = 0;\n\n\tswitch(mode & S_IFMT) {\n\tcase S_IFREG:\n\t\tif ((dip->i_diskflags & GFS2_DIF_INHERIT_JDATA) ||\n\t\t    gfs2_tune_get(sdp, gt_new_files_jdata))\n\t\t\tip->i_diskflags |= GFS2_DIF_JDATA;\n\t\tgfs2_set_aops(inode);\n\t\tbreak;\n\tcase S_IFDIR:\n\t\tip->i_diskflags |= (dip->i_diskflags & GFS2_DIF_INHERIT_JDATA);\n\t\tip->i_diskflags |= GFS2_DIF_JDATA;\n\t\tip->i_entries = 2;\n\t\tbreak;\n\t}\n\tgfs2_set_inode_flags(inode);\n\n\tif ((GFS2_I(sdp->sd_root_dir->d_inode) == dip) ||\n\t    (dip->i_diskflags & GFS2_DIF_TOPDIR))\n\t\taflags |= GFS2_AF_ORLOV;\n\n\tif (default_acl || acl)\n\t\tblocks++;\n\n\terror = alloc_dinode(ip, aflags, &blocks);\n\tif (error)\n\t\tgoto fail_free_inode;\n\n\tgfs2_set_inode_blocks(inode, blocks);\n\n\terror = gfs2_glock_get(sdp, ip->i_no_addr, &gfs2_inode_glops, CREATE, &ip->i_gl);\n\tif (error)\n\t\tgoto fail_free_inode;\n\n\tip->i_gl->gl_object = ip;\n\terror = gfs2_glock_nq_init(ip->i_gl, LM_ST_EXCLUSIVE, GL_SKIP, ghs + 1);\n\tif (error)\n\t\tgoto fail_free_inode;\n\n\terror = gfs2_trans_begin(sdp, blocks, 0);\n\tif (error)\n\t\tgoto fail_gunlock2;\n\n\tif (blocks > 1) {\n\t\tip->i_eattr = ip->i_no_addr + 1;\n\t\tgfs2_init_xattr(ip);\n\t}\n\tinit_dinode(dip, ip, symname);\n\tgfs2_trans_end(sdp);\n\n\terror = gfs2_glock_get(sdp, ip->i_no_addr, &gfs2_iopen_glops, CREATE, &io_gl);\n\tif (error)\n\t\tgoto fail_gunlock2;\n\n\terror = gfs2_glock_nq_init(io_gl, LM_ST_SHARED, GL_EXACT, &ip->i_iopen_gh);\n\tif (error)\n\t\tgoto fail_gunlock2;\n\n\tip->i_iopen_gh.gh_gl->gl_object = ip;\n\tgfs2_glock_put(io_gl);\n\tgfs2_set_iop(inode);\n\tinsert_inode_hash(inode);\n\n\tif (default_acl) {\n\t\terror = gfs2_set_acl(inode, default_acl, ACL_TYPE_DEFAULT);\n\t\tposix_acl_release(default_acl);\n\t}\n\tif (acl) {\n\t\tif (!error)\n\t\t\terror = gfs2_set_acl(inode, acl, ACL_TYPE_ACCESS);\n\t\tposix_acl_release(acl);\n\t}\n\n\tif (error)\n\t\tgoto fail_gunlock3;\n\n\terror = security_inode_init_security(&ip->i_inode, &dip->i_inode, name,\n\t\t\t\t\t     &gfs2_initxattrs, NULL);\n\tif (error)\n\t\tgoto fail_gunlock3;\n\n\terror = link_dinode(dip, name, ip, &da);\n\tif (error)\n\t\tgoto fail_gunlock3;\n\n\tmark_inode_dirty(inode);\n\td_instantiate(dentry, inode);\n\tif (file) {\n\t\t*opened |= FILE_CREATED;\n\t\terror = finish_open(file, dentry, gfs2_open_common, opened);\n\t}\n\tgfs2_glock_dq_uninit(ghs);\n\tgfs2_glock_dq_uninit(ghs + 1);\n\treturn error;\n\nfail_gunlock3:\n\tgfs2_glock_dq_uninit(ghs + 1);\n\tif (ip->i_gl)\n\t\tgfs2_glock_put(ip->i_gl);\n\tgoto fail_gunlock;\n\nfail_gunlock2:\n\tgfs2_glock_dq_uninit(ghs + 1);\nfail_free_inode:\n\tif (ip->i_gl)\n\t\tgfs2_glock_put(ip->i_gl);\n\tgfs2_rs_delete(ip, NULL);\nfail_free_acls:\n\tif (default_acl)\n\t\tposix_acl_release(default_acl);\n\tif (acl)\n\t\tposix_acl_release(acl);\nfail_free_vfs_inode:\n\tfree_vfs_inode = 1;\nfail_gunlock:\n\tgfs2_dir_no_add(&da);\n\tgfs2_glock_dq_uninit(ghs);\n\tif (inode && !IS_ERR(inode)) {\n\t\tclear_nlink(inode);\n\t\tif (!free_vfs_inode)\n\t\t\tmark_inode_dirty(inode);\n\t\tset_bit(free_vfs_inode ? GIF_FREE_VFS_INODE : GIF_ALLOC_FAILED,\n\t\t\t&GFS2_I(inode)->i_flags);\n\t\tiput(inode);\n\t}\nfail:\n\treturn error;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"glops.h\"\n#include \"super.h\"\n#include \"util.h\"\n#include \"trans.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"xattr.h\"\n#include \"dir.h\"\n#include \"bmap.h\"\n#include \"acl.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <asm/uaccess.h>\n#include <linux/security.h>\n#include <linux/fiemap.h>\n#include <linux/crc32.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/posix_acl.h>\n#include <linux/xattr.h>\n#include <linux/mm.h>\n#include <linux/namei.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nstatic int gfs2_mknod(struct inode *dir, struct dentry *dentry, umode_t mode,\n\t\t      dev_t dev)\n{\n\treturn gfs2_create_inode(dir, dentry, NULL, mode, dev, NULL, 0, 0, NULL);\n}"
  },
  {
    "function_name": "gfs2_mkdir",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/inode.c",
    "lines": "1195-1200",
    "snippet": "static int gfs2_mkdir(struct inode *dir, struct dentry *dentry, umode_t mode)\n{\n\tstruct gfs2_sbd *sdp = GFS2_SB(dir);\n\tunsigned dsize = sdp->sd_sb.sb_bsize - sizeof(struct gfs2_dinode);\n\treturn gfs2_create_inode(dir, dentry, NULL, S_IFDIR | mode, 0, NULL, dsize, 0, NULL);\n}",
    "includes": [
      "#include \"glops.h\"",
      "#include \"super.h\"",
      "#include \"util.h\"",
      "#include \"trans.h\"",
      "#include \"rgrp.h\"",
      "#include \"quota.h\"",
      "#include \"meta_io.h\"",
      "#include \"inode.h\"",
      "#include \"glock.h\"",
      "#include \"xattr.h\"",
      "#include \"dir.h\"",
      "#include \"bmap.h\"",
      "#include \"acl.h\"",
      "#include \"incore.h\"",
      "#include \"gfs2.h\"",
      "#include <asm/uaccess.h>",
      "#include <linux/security.h>",
      "#include <linux/fiemap.h>",
      "#include <linux/crc32.h>",
      "#include <linux/gfs2_ondisk.h>",
      "#include <linux/posix_acl.h>",
      "#include <linux/xattr.h>",
      "#include <linux/mm.h>",
      "#include <linux/namei.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/completion.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "gfs2_create_inode",
          "args": [
            "dir",
            "dentry",
            "NULL",
            "S_IFDIR | mode",
            "0",
            "NULL",
            "dsize",
            "0",
            "NULL"
          ],
          "line": 1199
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_create_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/inode.c",
          "lines": "584-800",
          "snippet": "static int gfs2_create_inode(struct inode *dir, struct dentry *dentry,\n\t\t\t     struct file *file,\n\t\t\t     umode_t mode, dev_t dev, const char *symname,\n\t\t\t     unsigned int size, int excl, int *opened)\n{\n\tconst struct qstr *name = &dentry->d_name;\n\tstruct posix_acl *default_acl, *acl;\n\tstruct gfs2_holder ghs[2];\n\tstruct inode *inode = NULL;\n\tstruct gfs2_inode *dip = GFS2_I(dir), *ip;\n\tstruct gfs2_sbd *sdp = GFS2_SB(&dip->i_inode);\n\tstruct gfs2_glock *io_gl;\n\tint error, free_vfs_inode = 0;\n\tu32 aflags = 0;\n\tunsigned blocks = 1;\n\tstruct gfs2_diradd da = { .bh = NULL, .save_loc = 1, };\n\n\tif (!name->len || name->len > GFS2_FNAMESIZE)\n\t\treturn -ENAMETOOLONG;\n\n\terror = gfs2_rs_alloc(dip);\n\tif (error)\n\t\treturn error;\n\n\terror = gfs2_rindex_update(sdp);\n\tif (error)\n\t\treturn error;\n\n\terror = gfs2_glock_nq_init(dip->i_gl, LM_ST_EXCLUSIVE, 0, ghs);\n\tif (error)\n\t\tgoto fail;\n\n\terror = create_ok(dip, name, mode);\n\tif (error)\n\t\tgoto fail_gunlock;\n\n\tinode = gfs2_dir_search(dir, &dentry->d_name, !S_ISREG(mode) || excl);\n\terror = PTR_ERR(inode);\n\tif (!IS_ERR(inode)) {\n\t\tif (S_ISDIR(inode->i_mode)) {\n\t\t\tiput(inode);\n\t\t\tinode = ERR_PTR(-EISDIR);\n\t\t\tgoto fail_gunlock;\n\t\t}\n\t\td_instantiate(dentry, inode);\n\t\terror = 0;\n\t\tif (file) {\n\t\t\tif (S_ISREG(inode->i_mode))\n\t\t\t\terror = finish_open(file, dentry, gfs2_open_common, opened);\n\t\t\telse\n\t\t\t\terror = finish_no_open(file, NULL);\n\t\t}\n\t\tgfs2_glock_dq_uninit(ghs);\n\t\treturn error;\n\t} else if (error != -ENOENT) {\n\t\tgoto fail_gunlock;\n\t}\n\n\terror = gfs2_diradd_alloc_required(dir, name, &da);\n\tif (error < 0)\n\t\tgoto fail_gunlock;\n\n\tinode = new_inode(sdp->sd_vfs);\n\terror = -ENOMEM;\n\tif (!inode)\n\t\tgoto fail_gunlock;\n\n\terror = posix_acl_create(dir, &mode, &default_acl, &acl);\n\tif (error)\n\t\tgoto fail_free_vfs_inode;\n\n\tip = GFS2_I(inode);\n\terror = gfs2_rs_alloc(ip);\n\tif (error)\n\t\tgoto fail_free_acls;\n\n\tinode->i_mode = mode;\n\tset_nlink(inode, S_ISDIR(mode) ? 2 : 1);\n\tinode->i_rdev = dev;\n\tinode->i_size = size;\n\tinode->i_atime = inode->i_mtime = inode->i_ctime = CURRENT_TIME;\n\tgfs2_set_inode_blocks(inode, 1);\n\tmunge_mode_uid_gid(dip, inode);\n\tcheck_and_update_goal(dip);\n\tip->i_goal = dip->i_goal;\n\tip->i_diskflags = 0;\n\tip->i_eattr = 0;\n\tip->i_height = 0;\n\tip->i_depth = 0;\n\tip->i_entries = 0;\n\n\tswitch(mode & S_IFMT) {\n\tcase S_IFREG:\n\t\tif ((dip->i_diskflags & GFS2_DIF_INHERIT_JDATA) ||\n\t\t    gfs2_tune_get(sdp, gt_new_files_jdata))\n\t\t\tip->i_diskflags |= GFS2_DIF_JDATA;\n\t\tgfs2_set_aops(inode);\n\t\tbreak;\n\tcase S_IFDIR:\n\t\tip->i_diskflags |= (dip->i_diskflags & GFS2_DIF_INHERIT_JDATA);\n\t\tip->i_diskflags |= GFS2_DIF_JDATA;\n\t\tip->i_entries = 2;\n\t\tbreak;\n\t}\n\tgfs2_set_inode_flags(inode);\n\n\tif ((GFS2_I(sdp->sd_root_dir->d_inode) == dip) ||\n\t    (dip->i_diskflags & GFS2_DIF_TOPDIR))\n\t\taflags |= GFS2_AF_ORLOV;\n\n\tif (default_acl || acl)\n\t\tblocks++;\n\n\terror = alloc_dinode(ip, aflags, &blocks);\n\tif (error)\n\t\tgoto fail_free_inode;\n\n\tgfs2_set_inode_blocks(inode, blocks);\n\n\terror = gfs2_glock_get(sdp, ip->i_no_addr, &gfs2_inode_glops, CREATE, &ip->i_gl);\n\tif (error)\n\t\tgoto fail_free_inode;\n\n\tip->i_gl->gl_object = ip;\n\terror = gfs2_glock_nq_init(ip->i_gl, LM_ST_EXCLUSIVE, GL_SKIP, ghs + 1);\n\tif (error)\n\t\tgoto fail_free_inode;\n\n\terror = gfs2_trans_begin(sdp, blocks, 0);\n\tif (error)\n\t\tgoto fail_gunlock2;\n\n\tif (blocks > 1) {\n\t\tip->i_eattr = ip->i_no_addr + 1;\n\t\tgfs2_init_xattr(ip);\n\t}\n\tinit_dinode(dip, ip, symname);\n\tgfs2_trans_end(sdp);\n\n\terror = gfs2_glock_get(sdp, ip->i_no_addr, &gfs2_iopen_glops, CREATE, &io_gl);\n\tif (error)\n\t\tgoto fail_gunlock2;\n\n\terror = gfs2_glock_nq_init(io_gl, LM_ST_SHARED, GL_EXACT, &ip->i_iopen_gh);\n\tif (error)\n\t\tgoto fail_gunlock2;\n\n\tip->i_iopen_gh.gh_gl->gl_object = ip;\n\tgfs2_glock_put(io_gl);\n\tgfs2_set_iop(inode);\n\tinsert_inode_hash(inode);\n\n\tif (default_acl) {\n\t\terror = gfs2_set_acl(inode, default_acl, ACL_TYPE_DEFAULT);\n\t\tposix_acl_release(default_acl);\n\t}\n\tif (acl) {\n\t\tif (!error)\n\t\t\terror = gfs2_set_acl(inode, acl, ACL_TYPE_ACCESS);\n\t\tposix_acl_release(acl);\n\t}\n\n\tif (error)\n\t\tgoto fail_gunlock3;\n\n\terror = security_inode_init_security(&ip->i_inode, &dip->i_inode, name,\n\t\t\t\t\t     &gfs2_initxattrs, NULL);\n\tif (error)\n\t\tgoto fail_gunlock3;\n\n\terror = link_dinode(dip, name, ip, &da);\n\tif (error)\n\t\tgoto fail_gunlock3;\n\n\tmark_inode_dirty(inode);\n\td_instantiate(dentry, inode);\n\tif (file) {\n\t\t*opened |= FILE_CREATED;\n\t\terror = finish_open(file, dentry, gfs2_open_common, opened);\n\t}\n\tgfs2_glock_dq_uninit(ghs);\n\tgfs2_glock_dq_uninit(ghs + 1);\n\treturn error;\n\nfail_gunlock3:\n\tgfs2_glock_dq_uninit(ghs + 1);\n\tif (ip->i_gl)\n\t\tgfs2_glock_put(ip->i_gl);\n\tgoto fail_gunlock;\n\nfail_gunlock2:\n\tgfs2_glock_dq_uninit(ghs + 1);\nfail_free_inode:\n\tif (ip->i_gl)\n\t\tgfs2_glock_put(ip->i_gl);\n\tgfs2_rs_delete(ip, NULL);\nfail_free_acls:\n\tif (default_acl)\n\t\tposix_acl_release(default_acl);\n\tif (acl)\n\t\tposix_acl_release(acl);\nfail_free_vfs_inode:\n\tfree_vfs_inode = 1;\nfail_gunlock:\n\tgfs2_dir_no_add(&da);\n\tgfs2_glock_dq_uninit(ghs);\n\tif (inode && !IS_ERR(inode)) {\n\t\tclear_nlink(inode);\n\t\tif (!free_vfs_inode)\n\t\t\tmark_inode_dirty(inode);\n\t\tset_bit(free_vfs_inode ? GIF_FREE_VFS_INODE : GIF_ALLOC_FAILED,\n\t\t\t&GFS2_I(inode)->i_flags);\n\t\tiput(inode);\n\t}\nfail:\n\treturn error;\n}",
          "includes": [
            "#include \"glops.h\"",
            "#include \"super.h\"",
            "#include \"util.h\"",
            "#include \"trans.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"inode.h\"",
            "#include \"glock.h\"",
            "#include \"xattr.h\"",
            "#include \"dir.h\"",
            "#include \"bmap.h\"",
            "#include \"acl.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/security.h>",
            "#include <linux/fiemap.h>",
            "#include <linux/crc32.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/xattr.h>",
            "#include <linux/mm.h>",
            "#include <linux/namei.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glops.h\"\n#include \"super.h\"\n#include \"util.h\"\n#include \"trans.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"xattr.h\"\n#include \"dir.h\"\n#include \"bmap.h\"\n#include \"acl.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <asm/uaccess.h>\n#include <linux/security.h>\n#include <linux/fiemap.h>\n#include <linux/crc32.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/posix_acl.h>\n#include <linux/xattr.h>\n#include <linux/mm.h>\n#include <linux/namei.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nstatic int gfs2_create_inode(struct inode *dir, struct dentry *dentry,\n\t\t\t     struct file *file,\n\t\t\t     umode_t mode, dev_t dev, const char *symname,\n\t\t\t     unsigned int size, int excl, int *opened)\n{\n\tconst struct qstr *name = &dentry->d_name;\n\tstruct posix_acl *default_acl, *acl;\n\tstruct gfs2_holder ghs[2];\n\tstruct inode *inode = NULL;\n\tstruct gfs2_inode *dip = GFS2_I(dir), *ip;\n\tstruct gfs2_sbd *sdp = GFS2_SB(&dip->i_inode);\n\tstruct gfs2_glock *io_gl;\n\tint error, free_vfs_inode = 0;\n\tu32 aflags = 0;\n\tunsigned blocks = 1;\n\tstruct gfs2_diradd da = { .bh = NULL, .save_loc = 1, };\n\n\tif (!name->len || name->len > GFS2_FNAMESIZE)\n\t\treturn -ENAMETOOLONG;\n\n\terror = gfs2_rs_alloc(dip);\n\tif (error)\n\t\treturn error;\n\n\terror = gfs2_rindex_update(sdp);\n\tif (error)\n\t\treturn error;\n\n\terror = gfs2_glock_nq_init(dip->i_gl, LM_ST_EXCLUSIVE, 0, ghs);\n\tif (error)\n\t\tgoto fail;\n\n\terror = create_ok(dip, name, mode);\n\tif (error)\n\t\tgoto fail_gunlock;\n\n\tinode = gfs2_dir_search(dir, &dentry->d_name, !S_ISREG(mode) || excl);\n\terror = PTR_ERR(inode);\n\tif (!IS_ERR(inode)) {\n\t\tif (S_ISDIR(inode->i_mode)) {\n\t\t\tiput(inode);\n\t\t\tinode = ERR_PTR(-EISDIR);\n\t\t\tgoto fail_gunlock;\n\t\t}\n\t\td_instantiate(dentry, inode);\n\t\terror = 0;\n\t\tif (file) {\n\t\t\tif (S_ISREG(inode->i_mode))\n\t\t\t\terror = finish_open(file, dentry, gfs2_open_common, opened);\n\t\t\telse\n\t\t\t\terror = finish_no_open(file, NULL);\n\t\t}\n\t\tgfs2_glock_dq_uninit(ghs);\n\t\treturn error;\n\t} else if (error != -ENOENT) {\n\t\tgoto fail_gunlock;\n\t}\n\n\terror = gfs2_diradd_alloc_required(dir, name, &da);\n\tif (error < 0)\n\t\tgoto fail_gunlock;\n\n\tinode = new_inode(sdp->sd_vfs);\n\terror = -ENOMEM;\n\tif (!inode)\n\t\tgoto fail_gunlock;\n\n\terror = posix_acl_create(dir, &mode, &default_acl, &acl);\n\tif (error)\n\t\tgoto fail_free_vfs_inode;\n\n\tip = GFS2_I(inode);\n\terror = gfs2_rs_alloc(ip);\n\tif (error)\n\t\tgoto fail_free_acls;\n\n\tinode->i_mode = mode;\n\tset_nlink(inode, S_ISDIR(mode) ? 2 : 1);\n\tinode->i_rdev = dev;\n\tinode->i_size = size;\n\tinode->i_atime = inode->i_mtime = inode->i_ctime = CURRENT_TIME;\n\tgfs2_set_inode_blocks(inode, 1);\n\tmunge_mode_uid_gid(dip, inode);\n\tcheck_and_update_goal(dip);\n\tip->i_goal = dip->i_goal;\n\tip->i_diskflags = 0;\n\tip->i_eattr = 0;\n\tip->i_height = 0;\n\tip->i_depth = 0;\n\tip->i_entries = 0;\n\n\tswitch(mode & S_IFMT) {\n\tcase S_IFREG:\n\t\tif ((dip->i_diskflags & GFS2_DIF_INHERIT_JDATA) ||\n\t\t    gfs2_tune_get(sdp, gt_new_files_jdata))\n\t\t\tip->i_diskflags |= GFS2_DIF_JDATA;\n\t\tgfs2_set_aops(inode);\n\t\tbreak;\n\tcase S_IFDIR:\n\t\tip->i_diskflags |= (dip->i_diskflags & GFS2_DIF_INHERIT_JDATA);\n\t\tip->i_diskflags |= GFS2_DIF_JDATA;\n\t\tip->i_entries = 2;\n\t\tbreak;\n\t}\n\tgfs2_set_inode_flags(inode);\n\n\tif ((GFS2_I(sdp->sd_root_dir->d_inode) == dip) ||\n\t    (dip->i_diskflags & GFS2_DIF_TOPDIR))\n\t\taflags |= GFS2_AF_ORLOV;\n\n\tif (default_acl || acl)\n\t\tblocks++;\n\n\terror = alloc_dinode(ip, aflags, &blocks);\n\tif (error)\n\t\tgoto fail_free_inode;\n\n\tgfs2_set_inode_blocks(inode, blocks);\n\n\terror = gfs2_glock_get(sdp, ip->i_no_addr, &gfs2_inode_glops, CREATE, &ip->i_gl);\n\tif (error)\n\t\tgoto fail_free_inode;\n\n\tip->i_gl->gl_object = ip;\n\terror = gfs2_glock_nq_init(ip->i_gl, LM_ST_EXCLUSIVE, GL_SKIP, ghs + 1);\n\tif (error)\n\t\tgoto fail_free_inode;\n\n\terror = gfs2_trans_begin(sdp, blocks, 0);\n\tif (error)\n\t\tgoto fail_gunlock2;\n\n\tif (blocks > 1) {\n\t\tip->i_eattr = ip->i_no_addr + 1;\n\t\tgfs2_init_xattr(ip);\n\t}\n\tinit_dinode(dip, ip, symname);\n\tgfs2_trans_end(sdp);\n\n\terror = gfs2_glock_get(sdp, ip->i_no_addr, &gfs2_iopen_glops, CREATE, &io_gl);\n\tif (error)\n\t\tgoto fail_gunlock2;\n\n\terror = gfs2_glock_nq_init(io_gl, LM_ST_SHARED, GL_EXACT, &ip->i_iopen_gh);\n\tif (error)\n\t\tgoto fail_gunlock2;\n\n\tip->i_iopen_gh.gh_gl->gl_object = ip;\n\tgfs2_glock_put(io_gl);\n\tgfs2_set_iop(inode);\n\tinsert_inode_hash(inode);\n\n\tif (default_acl) {\n\t\terror = gfs2_set_acl(inode, default_acl, ACL_TYPE_DEFAULT);\n\t\tposix_acl_release(default_acl);\n\t}\n\tif (acl) {\n\t\tif (!error)\n\t\t\terror = gfs2_set_acl(inode, acl, ACL_TYPE_ACCESS);\n\t\tposix_acl_release(acl);\n\t}\n\n\tif (error)\n\t\tgoto fail_gunlock3;\n\n\terror = security_inode_init_security(&ip->i_inode, &dip->i_inode, name,\n\t\t\t\t\t     &gfs2_initxattrs, NULL);\n\tif (error)\n\t\tgoto fail_gunlock3;\n\n\terror = link_dinode(dip, name, ip, &da);\n\tif (error)\n\t\tgoto fail_gunlock3;\n\n\tmark_inode_dirty(inode);\n\td_instantiate(dentry, inode);\n\tif (file) {\n\t\t*opened |= FILE_CREATED;\n\t\terror = finish_open(file, dentry, gfs2_open_common, opened);\n\t}\n\tgfs2_glock_dq_uninit(ghs);\n\tgfs2_glock_dq_uninit(ghs + 1);\n\treturn error;\n\nfail_gunlock3:\n\tgfs2_glock_dq_uninit(ghs + 1);\n\tif (ip->i_gl)\n\t\tgfs2_glock_put(ip->i_gl);\n\tgoto fail_gunlock;\n\nfail_gunlock2:\n\tgfs2_glock_dq_uninit(ghs + 1);\nfail_free_inode:\n\tif (ip->i_gl)\n\t\tgfs2_glock_put(ip->i_gl);\n\tgfs2_rs_delete(ip, NULL);\nfail_free_acls:\n\tif (default_acl)\n\t\tposix_acl_release(default_acl);\n\tif (acl)\n\t\tposix_acl_release(acl);\nfail_free_vfs_inode:\n\tfree_vfs_inode = 1;\nfail_gunlock:\n\tgfs2_dir_no_add(&da);\n\tgfs2_glock_dq_uninit(ghs);\n\tif (inode && !IS_ERR(inode)) {\n\t\tclear_nlink(inode);\n\t\tif (!free_vfs_inode)\n\t\t\tmark_inode_dirty(inode);\n\t\tset_bit(free_vfs_inode ? GIF_FREE_VFS_INODE : GIF_ALLOC_FAILED,\n\t\t\t&GFS2_I(inode)->i_flags);\n\t\tiput(inode);\n\t}\nfail:\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "GFS2_SB",
          "args": [
            "dir"
          ],
          "line": 1197
        },
        "resolved": true,
        "details": {
          "function_name": "GFS2_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/incore.h",
          "lines": "413-416",
          "snippet": "static inline struct gfs2_sbd *GFS2_SB(const struct inode *inode)\n{\n\treturn inode->i_sb->s_fs_info;\n}",
          "includes": [
            "#include <linux/lockref.h>",
            "#include <linux/percpu.h>",
            "#include <linux/ktime.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/completion.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/dlm.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/kobject.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/lockref.h>\n#include <linux/percpu.h>\n#include <linux/ktime.h>\n#include <linux/rbtree.h>\n#include <linux/completion.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/buffer_head.h>\n#include <linux/dlm.h>\n#include <linux/workqueue.h>\n#include <linux/kobject.h>\n#include <linux/fs.h>\n\nstatic inline struct gfs2_sbd *GFS2_SB(const struct inode *inode)\n{\n\treturn inode->i_sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"glops.h\"\n#include \"super.h\"\n#include \"util.h\"\n#include \"trans.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"xattr.h\"\n#include \"dir.h\"\n#include \"bmap.h\"\n#include \"acl.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <asm/uaccess.h>\n#include <linux/security.h>\n#include <linux/fiemap.h>\n#include <linux/crc32.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/posix_acl.h>\n#include <linux/xattr.h>\n#include <linux/mm.h>\n#include <linux/namei.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nstatic int gfs2_mkdir(struct inode *dir, struct dentry *dentry, umode_t mode)\n{\n\tstruct gfs2_sbd *sdp = GFS2_SB(dir);\n\tunsigned dsize = sdp->sd_sb.sb_bsize - sizeof(struct gfs2_dinode);\n\treturn gfs2_create_inode(dir, dentry, NULL, S_IFDIR | mode, 0, NULL, dsize, 0, NULL);\n}"
  },
  {
    "function_name": "gfs2_symlink",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/inode.c",
    "lines": "1173-1184",
    "snippet": "static int gfs2_symlink(struct inode *dir, struct dentry *dentry,\n\t\t\tconst char *symname)\n{\n\tstruct gfs2_sbd *sdp = GFS2_SB(dir);\n\tunsigned int size;\n\n\tsize = strlen(symname);\n\tif (size > sdp->sd_sb.sb_bsize - sizeof(struct gfs2_dinode) - 1)\n\t\treturn -ENAMETOOLONG;\n\n\treturn gfs2_create_inode(dir, dentry, NULL, S_IFLNK | S_IRWXUGO, 0, symname, size, 0, NULL);\n}",
    "includes": [
      "#include \"glops.h\"",
      "#include \"super.h\"",
      "#include \"util.h\"",
      "#include \"trans.h\"",
      "#include \"rgrp.h\"",
      "#include \"quota.h\"",
      "#include \"meta_io.h\"",
      "#include \"inode.h\"",
      "#include \"glock.h\"",
      "#include \"xattr.h\"",
      "#include \"dir.h\"",
      "#include \"bmap.h\"",
      "#include \"acl.h\"",
      "#include \"incore.h\"",
      "#include \"gfs2.h\"",
      "#include <asm/uaccess.h>",
      "#include <linux/security.h>",
      "#include <linux/fiemap.h>",
      "#include <linux/crc32.h>",
      "#include <linux/gfs2_ondisk.h>",
      "#include <linux/posix_acl.h>",
      "#include <linux/xattr.h>",
      "#include <linux/mm.h>",
      "#include <linux/namei.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/completion.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "gfs2_create_inode",
          "args": [
            "dir",
            "dentry",
            "NULL",
            "S_IFLNK | S_IRWXUGO",
            "0",
            "symname",
            "size",
            "0",
            "NULL"
          ],
          "line": 1183
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_create_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/inode.c",
          "lines": "584-800",
          "snippet": "static int gfs2_create_inode(struct inode *dir, struct dentry *dentry,\n\t\t\t     struct file *file,\n\t\t\t     umode_t mode, dev_t dev, const char *symname,\n\t\t\t     unsigned int size, int excl, int *opened)\n{\n\tconst struct qstr *name = &dentry->d_name;\n\tstruct posix_acl *default_acl, *acl;\n\tstruct gfs2_holder ghs[2];\n\tstruct inode *inode = NULL;\n\tstruct gfs2_inode *dip = GFS2_I(dir), *ip;\n\tstruct gfs2_sbd *sdp = GFS2_SB(&dip->i_inode);\n\tstruct gfs2_glock *io_gl;\n\tint error, free_vfs_inode = 0;\n\tu32 aflags = 0;\n\tunsigned blocks = 1;\n\tstruct gfs2_diradd da = { .bh = NULL, .save_loc = 1, };\n\n\tif (!name->len || name->len > GFS2_FNAMESIZE)\n\t\treturn -ENAMETOOLONG;\n\n\terror = gfs2_rs_alloc(dip);\n\tif (error)\n\t\treturn error;\n\n\terror = gfs2_rindex_update(sdp);\n\tif (error)\n\t\treturn error;\n\n\terror = gfs2_glock_nq_init(dip->i_gl, LM_ST_EXCLUSIVE, 0, ghs);\n\tif (error)\n\t\tgoto fail;\n\n\terror = create_ok(dip, name, mode);\n\tif (error)\n\t\tgoto fail_gunlock;\n\n\tinode = gfs2_dir_search(dir, &dentry->d_name, !S_ISREG(mode) || excl);\n\terror = PTR_ERR(inode);\n\tif (!IS_ERR(inode)) {\n\t\tif (S_ISDIR(inode->i_mode)) {\n\t\t\tiput(inode);\n\t\t\tinode = ERR_PTR(-EISDIR);\n\t\t\tgoto fail_gunlock;\n\t\t}\n\t\td_instantiate(dentry, inode);\n\t\terror = 0;\n\t\tif (file) {\n\t\t\tif (S_ISREG(inode->i_mode))\n\t\t\t\terror = finish_open(file, dentry, gfs2_open_common, opened);\n\t\t\telse\n\t\t\t\terror = finish_no_open(file, NULL);\n\t\t}\n\t\tgfs2_glock_dq_uninit(ghs);\n\t\treturn error;\n\t} else if (error != -ENOENT) {\n\t\tgoto fail_gunlock;\n\t}\n\n\terror = gfs2_diradd_alloc_required(dir, name, &da);\n\tif (error < 0)\n\t\tgoto fail_gunlock;\n\n\tinode = new_inode(sdp->sd_vfs);\n\terror = -ENOMEM;\n\tif (!inode)\n\t\tgoto fail_gunlock;\n\n\terror = posix_acl_create(dir, &mode, &default_acl, &acl);\n\tif (error)\n\t\tgoto fail_free_vfs_inode;\n\n\tip = GFS2_I(inode);\n\terror = gfs2_rs_alloc(ip);\n\tif (error)\n\t\tgoto fail_free_acls;\n\n\tinode->i_mode = mode;\n\tset_nlink(inode, S_ISDIR(mode) ? 2 : 1);\n\tinode->i_rdev = dev;\n\tinode->i_size = size;\n\tinode->i_atime = inode->i_mtime = inode->i_ctime = CURRENT_TIME;\n\tgfs2_set_inode_blocks(inode, 1);\n\tmunge_mode_uid_gid(dip, inode);\n\tcheck_and_update_goal(dip);\n\tip->i_goal = dip->i_goal;\n\tip->i_diskflags = 0;\n\tip->i_eattr = 0;\n\tip->i_height = 0;\n\tip->i_depth = 0;\n\tip->i_entries = 0;\n\n\tswitch(mode & S_IFMT) {\n\tcase S_IFREG:\n\t\tif ((dip->i_diskflags & GFS2_DIF_INHERIT_JDATA) ||\n\t\t    gfs2_tune_get(sdp, gt_new_files_jdata))\n\t\t\tip->i_diskflags |= GFS2_DIF_JDATA;\n\t\tgfs2_set_aops(inode);\n\t\tbreak;\n\tcase S_IFDIR:\n\t\tip->i_diskflags |= (dip->i_diskflags & GFS2_DIF_INHERIT_JDATA);\n\t\tip->i_diskflags |= GFS2_DIF_JDATA;\n\t\tip->i_entries = 2;\n\t\tbreak;\n\t}\n\tgfs2_set_inode_flags(inode);\n\n\tif ((GFS2_I(sdp->sd_root_dir->d_inode) == dip) ||\n\t    (dip->i_diskflags & GFS2_DIF_TOPDIR))\n\t\taflags |= GFS2_AF_ORLOV;\n\n\tif (default_acl || acl)\n\t\tblocks++;\n\n\terror = alloc_dinode(ip, aflags, &blocks);\n\tif (error)\n\t\tgoto fail_free_inode;\n\n\tgfs2_set_inode_blocks(inode, blocks);\n\n\terror = gfs2_glock_get(sdp, ip->i_no_addr, &gfs2_inode_glops, CREATE, &ip->i_gl);\n\tif (error)\n\t\tgoto fail_free_inode;\n\n\tip->i_gl->gl_object = ip;\n\terror = gfs2_glock_nq_init(ip->i_gl, LM_ST_EXCLUSIVE, GL_SKIP, ghs + 1);\n\tif (error)\n\t\tgoto fail_free_inode;\n\n\terror = gfs2_trans_begin(sdp, blocks, 0);\n\tif (error)\n\t\tgoto fail_gunlock2;\n\n\tif (blocks > 1) {\n\t\tip->i_eattr = ip->i_no_addr + 1;\n\t\tgfs2_init_xattr(ip);\n\t}\n\tinit_dinode(dip, ip, symname);\n\tgfs2_trans_end(sdp);\n\n\terror = gfs2_glock_get(sdp, ip->i_no_addr, &gfs2_iopen_glops, CREATE, &io_gl);\n\tif (error)\n\t\tgoto fail_gunlock2;\n\n\terror = gfs2_glock_nq_init(io_gl, LM_ST_SHARED, GL_EXACT, &ip->i_iopen_gh);\n\tif (error)\n\t\tgoto fail_gunlock2;\n\n\tip->i_iopen_gh.gh_gl->gl_object = ip;\n\tgfs2_glock_put(io_gl);\n\tgfs2_set_iop(inode);\n\tinsert_inode_hash(inode);\n\n\tif (default_acl) {\n\t\terror = gfs2_set_acl(inode, default_acl, ACL_TYPE_DEFAULT);\n\t\tposix_acl_release(default_acl);\n\t}\n\tif (acl) {\n\t\tif (!error)\n\t\t\terror = gfs2_set_acl(inode, acl, ACL_TYPE_ACCESS);\n\t\tposix_acl_release(acl);\n\t}\n\n\tif (error)\n\t\tgoto fail_gunlock3;\n\n\terror = security_inode_init_security(&ip->i_inode, &dip->i_inode, name,\n\t\t\t\t\t     &gfs2_initxattrs, NULL);\n\tif (error)\n\t\tgoto fail_gunlock3;\n\n\terror = link_dinode(dip, name, ip, &da);\n\tif (error)\n\t\tgoto fail_gunlock3;\n\n\tmark_inode_dirty(inode);\n\td_instantiate(dentry, inode);\n\tif (file) {\n\t\t*opened |= FILE_CREATED;\n\t\terror = finish_open(file, dentry, gfs2_open_common, opened);\n\t}\n\tgfs2_glock_dq_uninit(ghs);\n\tgfs2_glock_dq_uninit(ghs + 1);\n\treturn error;\n\nfail_gunlock3:\n\tgfs2_glock_dq_uninit(ghs + 1);\n\tif (ip->i_gl)\n\t\tgfs2_glock_put(ip->i_gl);\n\tgoto fail_gunlock;\n\nfail_gunlock2:\n\tgfs2_glock_dq_uninit(ghs + 1);\nfail_free_inode:\n\tif (ip->i_gl)\n\t\tgfs2_glock_put(ip->i_gl);\n\tgfs2_rs_delete(ip, NULL);\nfail_free_acls:\n\tif (default_acl)\n\t\tposix_acl_release(default_acl);\n\tif (acl)\n\t\tposix_acl_release(acl);\nfail_free_vfs_inode:\n\tfree_vfs_inode = 1;\nfail_gunlock:\n\tgfs2_dir_no_add(&da);\n\tgfs2_glock_dq_uninit(ghs);\n\tif (inode && !IS_ERR(inode)) {\n\t\tclear_nlink(inode);\n\t\tif (!free_vfs_inode)\n\t\t\tmark_inode_dirty(inode);\n\t\tset_bit(free_vfs_inode ? GIF_FREE_VFS_INODE : GIF_ALLOC_FAILED,\n\t\t\t&GFS2_I(inode)->i_flags);\n\t\tiput(inode);\n\t}\nfail:\n\treturn error;\n}",
          "includes": [
            "#include \"glops.h\"",
            "#include \"super.h\"",
            "#include \"util.h\"",
            "#include \"trans.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"inode.h\"",
            "#include \"glock.h\"",
            "#include \"xattr.h\"",
            "#include \"dir.h\"",
            "#include \"bmap.h\"",
            "#include \"acl.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/security.h>",
            "#include <linux/fiemap.h>",
            "#include <linux/crc32.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/xattr.h>",
            "#include <linux/mm.h>",
            "#include <linux/namei.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glops.h\"\n#include \"super.h\"\n#include \"util.h\"\n#include \"trans.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"xattr.h\"\n#include \"dir.h\"\n#include \"bmap.h\"\n#include \"acl.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <asm/uaccess.h>\n#include <linux/security.h>\n#include <linux/fiemap.h>\n#include <linux/crc32.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/posix_acl.h>\n#include <linux/xattr.h>\n#include <linux/mm.h>\n#include <linux/namei.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nstatic int gfs2_create_inode(struct inode *dir, struct dentry *dentry,\n\t\t\t     struct file *file,\n\t\t\t     umode_t mode, dev_t dev, const char *symname,\n\t\t\t     unsigned int size, int excl, int *opened)\n{\n\tconst struct qstr *name = &dentry->d_name;\n\tstruct posix_acl *default_acl, *acl;\n\tstruct gfs2_holder ghs[2];\n\tstruct inode *inode = NULL;\n\tstruct gfs2_inode *dip = GFS2_I(dir), *ip;\n\tstruct gfs2_sbd *sdp = GFS2_SB(&dip->i_inode);\n\tstruct gfs2_glock *io_gl;\n\tint error, free_vfs_inode = 0;\n\tu32 aflags = 0;\n\tunsigned blocks = 1;\n\tstruct gfs2_diradd da = { .bh = NULL, .save_loc = 1, };\n\n\tif (!name->len || name->len > GFS2_FNAMESIZE)\n\t\treturn -ENAMETOOLONG;\n\n\terror = gfs2_rs_alloc(dip);\n\tif (error)\n\t\treturn error;\n\n\terror = gfs2_rindex_update(sdp);\n\tif (error)\n\t\treturn error;\n\n\terror = gfs2_glock_nq_init(dip->i_gl, LM_ST_EXCLUSIVE, 0, ghs);\n\tif (error)\n\t\tgoto fail;\n\n\terror = create_ok(dip, name, mode);\n\tif (error)\n\t\tgoto fail_gunlock;\n\n\tinode = gfs2_dir_search(dir, &dentry->d_name, !S_ISREG(mode) || excl);\n\terror = PTR_ERR(inode);\n\tif (!IS_ERR(inode)) {\n\t\tif (S_ISDIR(inode->i_mode)) {\n\t\t\tiput(inode);\n\t\t\tinode = ERR_PTR(-EISDIR);\n\t\t\tgoto fail_gunlock;\n\t\t}\n\t\td_instantiate(dentry, inode);\n\t\terror = 0;\n\t\tif (file) {\n\t\t\tif (S_ISREG(inode->i_mode))\n\t\t\t\terror = finish_open(file, dentry, gfs2_open_common, opened);\n\t\t\telse\n\t\t\t\terror = finish_no_open(file, NULL);\n\t\t}\n\t\tgfs2_glock_dq_uninit(ghs);\n\t\treturn error;\n\t} else if (error != -ENOENT) {\n\t\tgoto fail_gunlock;\n\t}\n\n\terror = gfs2_diradd_alloc_required(dir, name, &da);\n\tif (error < 0)\n\t\tgoto fail_gunlock;\n\n\tinode = new_inode(sdp->sd_vfs);\n\terror = -ENOMEM;\n\tif (!inode)\n\t\tgoto fail_gunlock;\n\n\terror = posix_acl_create(dir, &mode, &default_acl, &acl);\n\tif (error)\n\t\tgoto fail_free_vfs_inode;\n\n\tip = GFS2_I(inode);\n\terror = gfs2_rs_alloc(ip);\n\tif (error)\n\t\tgoto fail_free_acls;\n\n\tinode->i_mode = mode;\n\tset_nlink(inode, S_ISDIR(mode) ? 2 : 1);\n\tinode->i_rdev = dev;\n\tinode->i_size = size;\n\tinode->i_atime = inode->i_mtime = inode->i_ctime = CURRENT_TIME;\n\tgfs2_set_inode_blocks(inode, 1);\n\tmunge_mode_uid_gid(dip, inode);\n\tcheck_and_update_goal(dip);\n\tip->i_goal = dip->i_goal;\n\tip->i_diskflags = 0;\n\tip->i_eattr = 0;\n\tip->i_height = 0;\n\tip->i_depth = 0;\n\tip->i_entries = 0;\n\n\tswitch(mode & S_IFMT) {\n\tcase S_IFREG:\n\t\tif ((dip->i_diskflags & GFS2_DIF_INHERIT_JDATA) ||\n\t\t    gfs2_tune_get(sdp, gt_new_files_jdata))\n\t\t\tip->i_diskflags |= GFS2_DIF_JDATA;\n\t\tgfs2_set_aops(inode);\n\t\tbreak;\n\tcase S_IFDIR:\n\t\tip->i_diskflags |= (dip->i_diskflags & GFS2_DIF_INHERIT_JDATA);\n\t\tip->i_diskflags |= GFS2_DIF_JDATA;\n\t\tip->i_entries = 2;\n\t\tbreak;\n\t}\n\tgfs2_set_inode_flags(inode);\n\n\tif ((GFS2_I(sdp->sd_root_dir->d_inode) == dip) ||\n\t    (dip->i_diskflags & GFS2_DIF_TOPDIR))\n\t\taflags |= GFS2_AF_ORLOV;\n\n\tif (default_acl || acl)\n\t\tblocks++;\n\n\terror = alloc_dinode(ip, aflags, &blocks);\n\tif (error)\n\t\tgoto fail_free_inode;\n\n\tgfs2_set_inode_blocks(inode, blocks);\n\n\terror = gfs2_glock_get(sdp, ip->i_no_addr, &gfs2_inode_glops, CREATE, &ip->i_gl);\n\tif (error)\n\t\tgoto fail_free_inode;\n\n\tip->i_gl->gl_object = ip;\n\terror = gfs2_glock_nq_init(ip->i_gl, LM_ST_EXCLUSIVE, GL_SKIP, ghs + 1);\n\tif (error)\n\t\tgoto fail_free_inode;\n\n\terror = gfs2_trans_begin(sdp, blocks, 0);\n\tif (error)\n\t\tgoto fail_gunlock2;\n\n\tif (blocks > 1) {\n\t\tip->i_eattr = ip->i_no_addr + 1;\n\t\tgfs2_init_xattr(ip);\n\t}\n\tinit_dinode(dip, ip, symname);\n\tgfs2_trans_end(sdp);\n\n\terror = gfs2_glock_get(sdp, ip->i_no_addr, &gfs2_iopen_glops, CREATE, &io_gl);\n\tif (error)\n\t\tgoto fail_gunlock2;\n\n\terror = gfs2_glock_nq_init(io_gl, LM_ST_SHARED, GL_EXACT, &ip->i_iopen_gh);\n\tif (error)\n\t\tgoto fail_gunlock2;\n\n\tip->i_iopen_gh.gh_gl->gl_object = ip;\n\tgfs2_glock_put(io_gl);\n\tgfs2_set_iop(inode);\n\tinsert_inode_hash(inode);\n\n\tif (default_acl) {\n\t\terror = gfs2_set_acl(inode, default_acl, ACL_TYPE_DEFAULT);\n\t\tposix_acl_release(default_acl);\n\t}\n\tif (acl) {\n\t\tif (!error)\n\t\t\terror = gfs2_set_acl(inode, acl, ACL_TYPE_ACCESS);\n\t\tposix_acl_release(acl);\n\t}\n\n\tif (error)\n\t\tgoto fail_gunlock3;\n\n\terror = security_inode_init_security(&ip->i_inode, &dip->i_inode, name,\n\t\t\t\t\t     &gfs2_initxattrs, NULL);\n\tif (error)\n\t\tgoto fail_gunlock3;\n\n\terror = link_dinode(dip, name, ip, &da);\n\tif (error)\n\t\tgoto fail_gunlock3;\n\n\tmark_inode_dirty(inode);\n\td_instantiate(dentry, inode);\n\tif (file) {\n\t\t*opened |= FILE_CREATED;\n\t\terror = finish_open(file, dentry, gfs2_open_common, opened);\n\t}\n\tgfs2_glock_dq_uninit(ghs);\n\tgfs2_glock_dq_uninit(ghs + 1);\n\treturn error;\n\nfail_gunlock3:\n\tgfs2_glock_dq_uninit(ghs + 1);\n\tif (ip->i_gl)\n\t\tgfs2_glock_put(ip->i_gl);\n\tgoto fail_gunlock;\n\nfail_gunlock2:\n\tgfs2_glock_dq_uninit(ghs + 1);\nfail_free_inode:\n\tif (ip->i_gl)\n\t\tgfs2_glock_put(ip->i_gl);\n\tgfs2_rs_delete(ip, NULL);\nfail_free_acls:\n\tif (default_acl)\n\t\tposix_acl_release(default_acl);\n\tif (acl)\n\t\tposix_acl_release(acl);\nfail_free_vfs_inode:\n\tfree_vfs_inode = 1;\nfail_gunlock:\n\tgfs2_dir_no_add(&da);\n\tgfs2_glock_dq_uninit(ghs);\n\tif (inode && !IS_ERR(inode)) {\n\t\tclear_nlink(inode);\n\t\tif (!free_vfs_inode)\n\t\t\tmark_inode_dirty(inode);\n\t\tset_bit(free_vfs_inode ? GIF_FREE_VFS_INODE : GIF_ALLOC_FAILED,\n\t\t\t&GFS2_I(inode)->i_flags);\n\t\tiput(inode);\n\t}\nfail:\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "symname"
          ],
          "line": 1179
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_ea_strlen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/xattr.c",
          "lines": "351-363",
          "snippet": "static inline unsigned int gfs2_ea_strlen(struct gfs2_ea_header *ea)\n{\n\tswitch (ea->ea_type) {\n\tcase GFS2_EATYPE_USR:\n\t\treturn 5 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SYS:\n\t\treturn 7 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SECURITY:\n\t\treturn 9 + ea->ea_name_len + 1;\n\tdefault:\n\t\treturn 0;\n\t}\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"trans.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"inode.h\"",
            "#include \"glock.h\"",
            "#include \"xattr.h\"",
            "#include \"acl.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/xattr.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"trans.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"xattr.h\"\n#include \"acl.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <asm/uaccess.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/xattr.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nstatic inline unsigned int gfs2_ea_strlen(struct gfs2_ea_header *ea)\n{\n\tswitch (ea->ea_type) {\n\tcase GFS2_EATYPE_USR:\n\t\treturn 5 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SYS:\n\t\treturn 7 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SECURITY:\n\t\treturn 9 + ea->ea_name_len + 1;\n\tdefault:\n\t\treturn 0;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "GFS2_SB",
          "args": [
            "dir"
          ],
          "line": 1176
        },
        "resolved": true,
        "details": {
          "function_name": "GFS2_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/incore.h",
          "lines": "413-416",
          "snippet": "static inline struct gfs2_sbd *GFS2_SB(const struct inode *inode)\n{\n\treturn inode->i_sb->s_fs_info;\n}",
          "includes": [
            "#include <linux/lockref.h>",
            "#include <linux/percpu.h>",
            "#include <linux/ktime.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/completion.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/dlm.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/kobject.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/lockref.h>\n#include <linux/percpu.h>\n#include <linux/ktime.h>\n#include <linux/rbtree.h>\n#include <linux/completion.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/buffer_head.h>\n#include <linux/dlm.h>\n#include <linux/workqueue.h>\n#include <linux/kobject.h>\n#include <linux/fs.h>\n\nstatic inline struct gfs2_sbd *GFS2_SB(const struct inode *inode)\n{\n\treturn inode->i_sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"glops.h\"\n#include \"super.h\"\n#include \"util.h\"\n#include \"trans.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"xattr.h\"\n#include \"dir.h\"\n#include \"bmap.h\"\n#include \"acl.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <asm/uaccess.h>\n#include <linux/security.h>\n#include <linux/fiemap.h>\n#include <linux/crc32.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/posix_acl.h>\n#include <linux/xattr.h>\n#include <linux/mm.h>\n#include <linux/namei.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nstatic int gfs2_symlink(struct inode *dir, struct dentry *dentry,\n\t\t\tconst char *symname)\n{\n\tstruct gfs2_sbd *sdp = GFS2_SB(dir);\n\tunsigned int size;\n\n\tsize = strlen(symname);\n\tif (size > sdp->sd_sb.sb_bsize - sizeof(struct gfs2_dinode) - 1)\n\t\treturn -ENAMETOOLONG;\n\n\treturn gfs2_create_inode(dir, dentry, NULL, S_IFLNK | S_IRWXUGO, 0, symname, size, 0, NULL);\n}"
  },
  {
    "function_name": "gfs2_unlink",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/inode.c",
    "lines": "1090-1162",
    "snippet": "static int gfs2_unlink(struct inode *dir, struct dentry *dentry)\n{\n\tstruct gfs2_inode *dip = GFS2_I(dir);\n\tstruct gfs2_sbd *sdp = GFS2_SB(dir);\n\tstruct inode *inode = dentry->d_inode;\n\tstruct gfs2_inode *ip = GFS2_I(inode);\n\tstruct gfs2_holder ghs[3];\n\tstruct gfs2_rgrpd *rgd;\n\tint error;\n\n\terror = gfs2_rindex_update(sdp);\n\tif (error)\n\t\treturn error;\n\n\terror = -EROFS;\n\n\tgfs2_holder_init(dip->i_gl, LM_ST_EXCLUSIVE, 0, ghs);\n\tgfs2_holder_init(ip->i_gl,  LM_ST_EXCLUSIVE, 0, ghs + 1);\n\n\trgd = gfs2_blk2rgrpd(sdp, ip->i_no_addr, 1);\n\tif (!rgd)\n\t\tgoto out_inodes;\n\n\tgfs2_holder_init(rgd->rd_gl, LM_ST_EXCLUSIVE, 0, ghs + 2);\n\n\n\terror = gfs2_glock_nq(ghs); /* parent */\n\tif (error)\n\t\tgoto out_parent;\n\n\terror = gfs2_glock_nq(ghs + 1); /* child */\n\tif (error)\n\t\tgoto out_child;\n\n\terror = -ENOENT;\n\tif (inode->i_nlink == 0)\n\t\tgoto out_rgrp;\n\n\tif (S_ISDIR(inode->i_mode)) {\n\t\terror = -ENOTEMPTY;\n\t\tif (ip->i_entries > 2 || inode->i_nlink > 2)\n\t\t\tgoto out_rgrp;\n\t}\n\n\terror = gfs2_glock_nq(ghs + 2); /* rgrp */\n\tif (error)\n\t\tgoto out_rgrp;\n\n\terror = gfs2_unlink_ok(dip, &dentry->d_name, ip);\n\tif (error)\n\t\tgoto out_gunlock;\n\n\terror = gfs2_trans_begin(sdp, 2*RES_DINODE + 3*RES_LEAF + RES_RG_BIT, 0);\n\tif (error)\n\t\tgoto out_end_trans;\n\n\terror = gfs2_unlink_inode(dip, dentry);\n\nout_end_trans:\n\tgfs2_trans_end(sdp);\nout_gunlock:\n\tgfs2_glock_dq(ghs + 2);\nout_rgrp:\n\tgfs2_glock_dq(ghs + 1);\nout_child:\n\tgfs2_glock_dq(ghs);\nout_parent:\n\tgfs2_holder_uninit(ghs + 2);\nout_inodes:\n\tgfs2_holder_uninit(ghs + 1);\n\tgfs2_holder_uninit(ghs);\n\treturn error;\n}",
    "includes": [
      "#include \"glops.h\"",
      "#include \"super.h\"",
      "#include \"util.h\"",
      "#include \"trans.h\"",
      "#include \"rgrp.h\"",
      "#include \"quota.h\"",
      "#include \"meta_io.h\"",
      "#include \"inode.h\"",
      "#include \"glock.h\"",
      "#include \"xattr.h\"",
      "#include \"dir.h\"",
      "#include \"bmap.h\"",
      "#include \"acl.h\"",
      "#include \"incore.h\"",
      "#include \"gfs2.h\"",
      "#include <asm/uaccess.h>",
      "#include <linux/security.h>",
      "#include <linux/fiemap.h>",
      "#include <linux/crc32.h>",
      "#include <linux/gfs2_ondisk.h>",
      "#include <linux/posix_acl.h>",
      "#include <linux/xattr.h>",
      "#include <linux/mm.h>",
      "#include <linux/namei.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/completion.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "gfs2_holder_uninit",
          "args": [
            "ghs"
          ],
          "line": 1160
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_holder_uninit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/glock.c",
          "lines": "841-847",
          "snippet": "void gfs2_holder_uninit(struct gfs2_holder *gh)\n{\n\tput_pid(gh->gh_owner_pid);\n\tgfs2_glock_put(gh->gh_gl);\n\tgh->gh_gl = NULL;\n\tgh->gh_ip = 0;\n}",
          "includes": [
            "#include \"trace_gfs2.h\"",
            "#include \"bmap.h\"",
            "#include \"util.h\"",
            "#include \"super.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"lops.h\"",
            "#include \"inode.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/lockref.h>",
            "#include <linux/list_sort.h>",
            "#include <linux/percpu.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/seq_file.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/module.h>",
            "#include <linux/wait.h>",
            "#include <linux/list.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/jhash.h>",
            "#include <linux/sort.h>",
            "#include <linux/delay.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"bmap.h\"\n#include \"util.h\"\n#include \"super.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"lops.h\"\n#include \"inode.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/lockref.h>\n#include <linux/list_sort.h>\n#include <linux/percpu.h>\n#include <linux/bit_spinlock.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/jiffies.h>\n#include <linux/workqueue.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <asm/uaccess.h>\n#include <linux/module.h>\n#include <linux/wait.h>\n#include <linux/list.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/kallsyms.h>\n#include <linux/jhash.h>\n#include <linux/sort.h>\n#include <linux/delay.h>\n#include <linux/buffer_head.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nvoid gfs2_holder_uninit(struct gfs2_holder *gh)\n{\n\tput_pid(gh->gh_owner_pid);\n\tgfs2_glock_put(gh->gh_gl);\n\tgh->gh_gl = NULL;\n\tgh->gh_ip = 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "gfs2_glock_dq",
          "args": [
            "ghs"
          ],
          "line": 1155
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_glock_dq_uninit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/glock.c",
          "lines": "1110-1114",
          "snippet": "void gfs2_glock_dq_uninit(struct gfs2_holder *gh)\n{\n\tgfs2_glock_dq(gh);\n\tgfs2_holder_uninit(gh);\n}",
          "includes": [
            "#include \"trace_gfs2.h\"",
            "#include \"bmap.h\"",
            "#include \"util.h\"",
            "#include \"super.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"lops.h\"",
            "#include \"inode.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/lockref.h>",
            "#include <linux/list_sort.h>",
            "#include <linux/percpu.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/seq_file.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/module.h>",
            "#include <linux/wait.h>",
            "#include <linux/list.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/jhash.h>",
            "#include <linux/sort.h>",
            "#include <linux/delay.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"bmap.h\"\n#include \"util.h\"\n#include \"super.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"lops.h\"\n#include \"inode.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/lockref.h>\n#include <linux/list_sort.h>\n#include <linux/percpu.h>\n#include <linux/bit_spinlock.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/jiffies.h>\n#include <linux/workqueue.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <asm/uaccess.h>\n#include <linux/module.h>\n#include <linux/wait.h>\n#include <linux/list.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/kallsyms.h>\n#include <linux/jhash.h>\n#include <linux/sort.h>\n#include <linux/delay.h>\n#include <linux/buffer_head.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nvoid gfs2_glock_dq_uninit(struct gfs2_holder *gh)\n{\n\tgfs2_glock_dq(gh);\n\tgfs2_holder_uninit(gh);\n}"
        }
      },
      {
        "call_info": {
          "callee": "gfs2_trans_end",
          "args": [
            "sdp"
          ],
          "line": 1149
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_trans_end",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/trans.c",
          "lines": "88-123",
          "snippet": "void gfs2_trans_end(struct gfs2_sbd *sdp)\n{\n\tstruct gfs2_trans *tr = current->journal_info;\n\ts64 nbuf;\n\tint alloced = tr->tr_alloced;\n\n\tBUG_ON(!tr);\n\tcurrent->journal_info = NULL;\n\n\tif (!tr->tr_touched) {\n\t\tgfs2_log_release(sdp, tr->tr_reserved);\n\t\tif (alloced) {\n\t\t\tkfree(tr);\n\t\t\tsb_end_intwrite(sdp->sd_vfs);\n\t\t}\n\t\treturn;\n\t}\n\n\tnbuf = tr->tr_num_buf_new + tr->tr_num_databuf_new;\n\tnbuf -= tr->tr_num_buf_rm;\n\tnbuf -= tr->tr_num_databuf_rm;\n\n\tif (gfs2_assert_withdraw(sdp, (nbuf <= tr->tr_blocks) &&\n\t\t\t\t       (tr->tr_num_revoke <= tr->tr_revokes)))\n\t\tgfs2_print_trans(tr);\n\n\tgfs2_log_commit(sdp, tr);\n\tif (alloced && !tr->tr_attached)\n\t\t\tkfree(tr);\n\tup_read(&sdp->sd_log_flush_lock);\n\n\tif (sdp->sd_vfs->s_flags & MS_SYNCHRONOUS)\n\t\tgfs2_log_flush(sdp, NULL, NORMAL_FLUSH);\n\tif (alloced)\n\t\tsb_end_intwrite(sdp->sd_vfs);\n}",
          "includes": [
            "#include \"trace_gfs2.h\"",
            "#include \"util.h\"",
            "#include \"trans.h\"",
            "#include \"meta_io.h\"",
            "#include \"lops.h\"",
            "#include \"log.h\"",
            "#include \"inode.h\"",
            "#include \"glock.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"util.h\"\n#include \"trans.h\"\n#include \"meta_io.h\"\n#include \"lops.h\"\n#include \"log.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/gfs2_ondisk.h>\n#include <linux/kallsyms.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nvoid gfs2_trans_end(struct gfs2_sbd *sdp)\n{\n\tstruct gfs2_trans *tr = current->journal_info;\n\ts64 nbuf;\n\tint alloced = tr->tr_alloced;\n\n\tBUG_ON(!tr);\n\tcurrent->journal_info = NULL;\n\n\tif (!tr->tr_touched) {\n\t\tgfs2_log_release(sdp, tr->tr_reserved);\n\t\tif (alloced) {\n\t\t\tkfree(tr);\n\t\t\tsb_end_intwrite(sdp->sd_vfs);\n\t\t}\n\t\treturn;\n\t}\n\n\tnbuf = tr->tr_num_buf_new + tr->tr_num_databuf_new;\n\tnbuf -= tr->tr_num_buf_rm;\n\tnbuf -= tr->tr_num_databuf_rm;\n\n\tif (gfs2_assert_withdraw(sdp, (nbuf <= tr->tr_blocks) &&\n\t\t\t\t       (tr->tr_num_revoke <= tr->tr_revokes)))\n\t\tgfs2_print_trans(tr);\n\n\tgfs2_log_commit(sdp, tr);\n\tif (alloced && !tr->tr_attached)\n\t\t\tkfree(tr);\n\tup_read(&sdp->sd_log_flush_lock);\n\n\tif (sdp->sd_vfs->s_flags & MS_SYNCHRONOUS)\n\t\tgfs2_log_flush(sdp, NULL, NORMAL_FLUSH);\n\tif (alloced)\n\t\tsb_end_intwrite(sdp->sd_vfs);\n}"
        }
      },
      {
        "call_info": {
          "callee": "gfs2_unlink_inode",
          "args": [
            "dip",
            "dentry"
          ],
          "line": 1146
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_unlink_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/inode.c",
          "lines": "1055-1076",
          "snippet": "static int gfs2_unlink_inode(struct gfs2_inode *dip,\n\t\t\t     const struct dentry *dentry)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tstruct gfs2_inode *ip = GFS2_I(inode);\n\tint error;\n\n\terror = gfs2_dir_del(dip, dentry);\n\tif (error)\n\t\treturn error;\n\n\tip->i_entries = 0;\n\tinode->i_ctime = CURRENT_TIME;\n\tif (S_ISDIR(inode->i_mode))\n\t\tclear_nlink(inode);\n\telse\n\t\tdrop_nlink(inode);\n\tmark_inode_dirty(inode);\n\tif (inode->i_nlink == 0)\n\t\tgfs2_unlink_di(inode);\n\treturn 0;\n}",
          "includes": [
            "#include \"glops.h\"",
            "#include \"super.h\"",
            "#include \"util.h\"",
            "#include \"trans.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"inode.h\"",
            "#include \"glock.h\"",
            "#include \"xattr.h\"",
            "#include \"dir.h\"",
            "#include \"bmap.h\"",
            "#include \"acl.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/security.h>",
            "#include <linux/fiemap.h>",
            "#include <linux/crc32.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/xattr.h>",
            "#include <linux/mm.h>",
            "#include <linux/namei.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glops.h\"\n#include \"super.h\"\n#include \"util.h\"\n#include \"trans.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"xattr.h\"\n#include \"dir.h\"\n#include \"bmap.h\"\n#include \"acl.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <asm/uaccess.h>\n#include <linux/security.h>\n#include <linux/fiemap.h>\n#include <linux/crc32.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/posix_acl.h>\n#include <linux/xattr.h>\n#include <linux/mm.h>\n#include <linux/namei.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nstatic int gfs2_unlink_inode(struct gfs2_inode *dip,\n\t\t\t     const struct dentry *dentry)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tstruct gfs2_inode *ip = GFS2_I(inode);\n\tint error;\n\n\terror = gfs2_dir_del(dip, dentry);\n\tif (error)\n\t\treturn error;\n\n\tip->i_entries = 0;\n\tinode->i_ctime = CURRENT_TIME;\n\tif (S_ISDIR(inode->i_mode))\n\t\tclear_nlink(inode);\n\telse\n\t\tdrop_nlink(inode);\n\tmark_inode_dirty(inode);\n\tif (inode->i_nlink == 0)\n\t\tgfs2_unlink_di(inode);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "gfs2_trans_begin",
          "args": [
            "sdp",
            "2*RES_DINODE + 3*RES_LEAF + RES_RG_BIT",
            "0"
          ],
          "line": 1142
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_trans_begin",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/trans.c",
          "lines": "31-75",
          "snippet": "int gfs2_trans_begin(struct gfs2_sbd *sdp, unsigned int blocks,\n\t\t     unsigned int revokes)\n{\n\tstruct gfs2_trans *tr;\n\tint error;\n\n\tBUG_ON(current->journal_info);\n\tBUG_ON(blocks == 0 && revokes == 0);\n\n\tif (!test_bit(SDF_JOURNAL_LIVE, &sdp->sd_flags))\n\t\treturn -EROFS;\n\n\ttr = kzalloc(sizeof(struct gfs2_trans), GFP_NOFS);\n\tif (!tr)\n\t\treturn -ENOMEM;\n\n\ttr->tr_ip = _RET_IP_;\n\ttr->tr_blocks = blocks;\n\ttr->tr_revokes = revokes;\n\ttr->tr_reserved = 1;\n\ttr->tr_alloced = 1;\n\tif (blocks)\n\t\ttr->tr_reserved += 6 + blocks;\n\tif (revokes)\n\t\ttr->tr_reserved += gfs2_struct2blk(sdp, revokes,\n\t\t\t\t\t\t   sizeof(u64));\n\tINIT_LIST_HEAD(&tr->tr_databuf);\n\tINIT_LIST_HEAD(&tr->tr_buf);\n\n\tsb_start_intwrite(sdp->sd_vfs);\n\n\terror = gfs2_log_reserve(sdp, tr->tr_reserved);\n\tif (error)\n\t\tgoto fail;\n\n\tcurrent->journal_info = tr;\n\n\treturn 0;\n\nfail:\n\tsb_end_intwrite(sdp->sd_vfs);\n\tkfree(tr);\n\n\treturn error;\n}",
          "includes": [
            "#include \"trace_gfs2.h\"",
            "#include \"util.h\"",
            "#include \"trans.h\"",
            "#include \"meta_io.h\"",
            "#include \"lops.h\"",
            "#include \"log.h\"",
            "#include \"inode.h\"",
            "#include \"glock.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"util.h\"\n#include \"trans.h\"\n#include \"meta_io.h\"\n#include \"lops.h\"\n#include \"log.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/gfs2_ondisk.h>\n#include <linux/kallsyms.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nint gfs2_trans_begin(struct gfs2_sbd *sdp, unsigned int blocks,\n\t\t     unsigned int revokes)\n{\n\tstruct gfs2_trans *tr;\n\tint error;\n\n\tBUG_ON(current->journal_info);\n\tBUG_ON(blocks == 0 && revokes == 0);\n\n\tif (!test_bit(SDF_JOURNAL_LIVE, &sdp->sd_flags))\n\t\treturn -EROFS;\n\n\ttr = kzalloc(sizeof(struct gfs2_trans), GFP_NOFS);\n\tif (!tr)\n\t\treturn -ENOMEM;\n\n\ttr->tr_ip = _RET_IP_;\n\ttr->tr_blocks = blocks;\n\ttr->tr_revokes = revokes;\n\ttr->tr_reserved = 1;\n\ttr->tr_alloced = 1;\n\tif (blocks)\n\t\ttr->tr_reserved += 6 + blocks;\n\tif (revokes)\n\t\ttr->tr_reserved += gfs2_struct2blk(sdp, revokes,\n\t\t\t\t\t\t   sizeof(u64));\n\tINIT_LIST_HEAD(&tr->tr_databuf);\n\tINIT_LIST_HEAD(&tr->tr_buf);\n\n\tsb_start_intwrite(sdp->sd_vfs);\n\n\terror = gfs2_log_reserve(sdp, tr->tr_reserved);\n\tif (error)\n\t\tgoto fail;\n\n\tcurrent->journal_info = tr;\n\n\treturn 0;\n\nfail:\n\tsb_end_intwrite(sdp->sd_vfs);\n\tkfree(tr);\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "gfs2_unlink_ok",
          "args": [
            "dip",
            "&dentry->d_name",
            "ip"
          ],
          "line": 1138
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_unlink_ok",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/inode.c",
          "lines": "1020-1041",
          "snippet": "static int gfs2_unlink_ok(struct gfs2_inode *dip, const struct qstr *name,\n\t\t\t  const struct gfs2_inode *ip)\n{\n\tint error;\n\n\tif (IS_IMMUTABLE(&ip->i_inode) || IS_APPEND(&ip->i_inode))\n\t\treturn -EPERM;\n\n\tif ((dip->i_inode.i_mode & S_ISVTX) &&\n\t    !uid_eq(dip->i_inode.i_uid, current_fsuid()) &&\n\t    !uid_eq(ip->i_inode.i_uid, current_fsuid()) && !capable(CAP_FOWNER))\n\t\treturn -EPERM;\n\n\tif (IS_APPEND(&dip->i_inode))\n\t\treturn -EPERM;\n\n\terror = gfs2_permission(&dip->i_inode, MAY_WRITE | MAY_EXEC);\n\tif (error)\n\t\treturn error;\n\n\treturn gfs2_dir_check(&dip->i_inode, name, ip);\n}",
          "includes": [
            "#include \"glops.h\"",
            "#include \"super.h\"",
            "#include \"util.h\"",
            "#include \"trans.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"inode.h\"",
            "#include \"glock.h\"",
            "#include \"xattr.h\"",
            "#include \"dir.h\"",
            "#include \"bmap.h\"",
            "#include \"acl.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/security.h>",
            "#include <linux/fiemap.h>",
            "#include <linux/crc32.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/xattr.h>",
            "#include <linux/mm.h>",
            "#include <linux/namei.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glops.h\"\n#include \"super.h\"\n#include \"util.h\"\n#include \"trans.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"xattr.h\"\n#include \"dir.h\"\n#include \"bmap.h\"\n#include \"acl.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <asm/uaccess.h>\n#include <linux/security.h>\n#include <linux/fiemap.h>\n#include <linux/crc32.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/posix_acl.h>\n#include <linux/xattr.h>\n#include <linux/mm.h>\n#include <linux/namei.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nstatic int gfs2_unlink_ok(struct gfs2_inode *dip, const struct qstr *name,\n\t\t\t  const struct gfs2_inode *ip)\n{\n\tint error;\n\n\tif (IS_IMMUTABLE(&ip->i_inode) || IS_APPEND(&ip->i_inode))\n\t\treturn -EPERM;\n\n\tif ((dip->i_inode.i_mode & S_ISVTX) &&\n\t    !uid_eq(dip->i_inode.i_uid, current_fsuid()) &&\n\t    !uid_eq(ip->i_inode.i_uid, current_fsuid()) && !capable(CAP_FOWNER))\n\t\treturn -EPERM;\n\n\tif (IS_APPEND(&dip->i_inode))\n\t\treturn -EPERM;\n\n\terror = gfs2_permission(&dip->i_inode, MAY_WRITE | MAY_EXEC);\n\tif (error)\n\t\treturn error;\n\n\treturn gfs2_dir_check(&dip->i_inode, name, ip);\n}"
        }
      },
      {
        "call_info": {
          "callee": "gfs2_glock_nq",
          "args": [
            "ghs + 2"
          ],
          "line": 1134
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_glock_nq",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/glock.c",
          "lines": "1006-1034",
          "snippet": "int gfs2_glock_nq(struct gfs2_holder *gh)\n{\n\tstruct gfs2_glock *gl = gh->gh_gl;\n\tstruct gfs2_sbd *sdp = gl->gl_sbd;\n\tint error = 0;\n\n\tif (unlikely(test_bit(SDF_SHUTDOWN, &sdp->sd_flags)))\n\t\treturn -EIO;\n\n\tif (test_bit(GLF_LRU, &gl->gl_flags))\n\t\tgfs2_glock_remove_from_lru(gl);\n\n\tspin_lock(&gl->gl_spin);\n\tadd_to_queue(gh);\n\tif (unlikely((LM_FLAG_NOEXP & gh->gh_flags) &&\n\t\t     test_and_clear_bit(GLF_FROZEN, &gl->gl_flags))) {\n\t\tset_bit(GLF_REPLY_PENDING, &gl->gl_flags);\n\t\tgl->gl_lockref.count++;\n\t\tif (queue_delayed_work(glock_workqueue, &gl->gl_work, 0) == 0)\n\t\t\tgl->gl_lockref.count--;\n\t}\n\trun_queue(gl, 1);\n\tspin_unlock(&gl->gl_spin);\n\n\tif (!(gh->gh_flags & GL_ASYNC))\n\t\terror = gfs2_glock_wait(gh);\n\n\treturn error;\n}",
          "includes": [
            "#include \"trace_gfs2.h\"",
            "#include \"bmap.h\"",
            "#include \"util.h\"",
            "#include \"super.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"lops.h\"",
            "#include \"inode.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/lockref.h>",
            "#include <linux/list_sort.h>",
            "#include <linux/percpu.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/seq_file.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/module.h>",
            "#include <linux/wait.h>",
            "#include <linux/list.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/jhash.h>",
            "#include <linux/sort.h>",
            "#include <linux/delay.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct workqueue_struct *glock_workqueue;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"bmap.h\"\n#include \"util.h\"\n#include \"super.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"lops.h\"\n#include \"inode.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/lockref.h>\n#include <linux/list_sort.h>\n#include <linux/percpu.h>\n#include <linux/bit_spinlock.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/jiffies.h>\n#include <linux/workqueue.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <asm/uaccess.h>\n#include <linux/module.h>\n#include <linux/wait.h>\n#include <linux/list.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/kallsyms.h>\n#include <linux/jhash.h>\n#include <linux/sort.h>\n#include <linux/delay.h>\n#include <linux/buffer_head.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic struct workqueue_struct *glock_workqueue;\n\nint gfs2_glock_nq(struct gfs2_holder *gh)\n{\n\tstruct gfs2_glock *gl = gh->gh_gl;\n\tstruct gfs2_sbd *sdp = gl->gl_sbd;\n\tint error = 0;\n\n\tif (unlikely(test_bit(SDF_SHUTDOWN, &sdp->sd_flags)))\n\t\treturn -EIO;\n\n\tif (test_bit(GLF_LRU, &gl->gl_flags))\n\t\tgfs2_glock_remove_from_lru(gl);\n\n\tspin_lock(&gl->gl_spin);\n\tadd_to_queue(gh);\n\tif (unlikely((LM_FLAG_NOEXP & gh->gh_flags) &&\n\t\t     test_and_clear_bit(GLF_FROZEN, &gl->gl_flags))) {\n\t\tset_bit(GLF_REPLY_PENDING, &gl->gl_flags);\n\t\tgl->gl_lockref.count++;\n\t\tif (queue_delayed_work(glock_workqueue, &gl->gl_work, 0) == 0)\n\t\t\tgl->gl_lockref.count--;\n\t}\n\trun_queue(gl, 1);\n\tspin_unlock(&gl->gl_spin);\n\n\tif (!(gh->gh_flags & GL_ASYNC))\n\t\terror = gfs2_glock_wait(gh);\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "S_ISDIR",
          "args": [
            "inode->i_mode"
          ],
          "line": 1128
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gfs2_holder_init",
          "args": [
            "rgd->rd_gl",
            "LM_ST_EXCLUSIVE",
            "0",
            "ghs + 2"
          ],
          "line": 1113
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_holder_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/glock.c",
          "lines": "801-813",
          "snippet": "void gfs2_holder_init(struct gfs2_glock *gl, unsigned int state, unsigned flags,\n\t\t      struct gfs2_holder *gh)\n{\n\tINIT_LIST_HEAD(&gh->gh_list);\n\tgh->gh_gl = gl;\n\tgh->gh_ip = _RET_IP_;\n\tgh->gh_owner_pid = get_pid(task_pid(current));\n\tgh->gh_state = state;\n\tgh->gh_flags = flags;\n\tgh->gh_error = 0;\n\tgh->gh_iflags = 0;\n\tgfs2_glock_hold(gl);\n}",
          "includes": [
            "#include \"trace_gfs2.h\"",
            "#include \"bmap.h\"",
            "#include \"util.h\"",
            "#include \"super.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"lops.h\"",
            "#include \"inode.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/lockref.h>",
            "#include <linux/list_sort.h>",
            "#include <linux/percpu.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/seq_file.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/module.h>",
            "#include <linux/wait.h>",
            "#include <linux/list.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/jhash.h>",
            "#include <linux/sort.h>",
            "#include <linux/delay.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"bmap.h\"\n#include \"util.h\"\n#include \"super.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"lops.h\"\n#include \"inode.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/lockref.h>\n#include <linux/list_sort.h>\n#include <linux/percpu.h>\n#include <linux/bit_spinlock.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/jiffies.h>\n#include <linux/workqueue.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <asm/uaccess.h>\n#include <linux/module.h>\n#include <linux/wait.h>\n#include <linux/list.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/kallsyms.h>\n#include <linux/jhash.h>\n#include <linux/sort.h>\n#include <linux/delay.h>\n#include <linux/buffer_head.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nvoid gfs2_holder_init(struct gfs2_glock *gl, unsigned int state, unsigned flags,\n\t\t      struct gfs2_holder *gh)\n{\n\tINIT_LIST_HEAD(&gh->gh_list);\n\tgh->gh_gl = gl;\n\tgh->gh_ip = _RET_IP_;\n\tgh->gh_owner_pid = get_pid(task_pid(current));\n\tgh->gh_state = state;\n\tgh->gh_flags = flags;\n\tgh->gh_error = 0;\n\tgh->gh_iflags = 0;\n\tgfs2_glock_hold(gl);\n}"
        }
      },
      {
        "call_info": {
          "callee": "gfs2_blk2rgrpd",
          "args": [
            "sdp",
            "ip->i_no_addr",
            "1"
          ],
          "line": 1109
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_blk2rgrpd",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/rgrp.c",
          "lines": "503-532",
          "snippet": "struct gfs2_rgrpd *gfs2_blk2rgrpd(struct gfs2_sbd *sdp, u64 blk, bool exact)\n{\n\tstruct rb_node *n, *next;\n\tstruct gfs2_rgrpd *cur;\n\n\tspin_lock(&sdp->sd_rindex_spin);\n\tn = sdp->sd_rindex_tree.rb_node;\n\twhile (n) {\n\t\tcur = rb_entry(n, struct gfs2_rgrpd, rd_node);\n\t\tnext = NULL;\n\t\tif (blk < cur->rd_addr)\n\t\t\tnext = n->rb_left;\n\t\telse if (blk >= cur->rd_data0 + cur->rd_data)\n\t\t\tnext = n->rb_right;\n\t\tif (next == NULL) {\n\t\t\tspin_unlock(&sdp->sd_rindex_spin);\n\t\t\tif (exact) {\n\t\t\t\tif (blk < cur->rd_addr)\n\t\t\t\t\treturn NULL;\n\t\t\t\tif (blk >= cur->rd_data0 + cur->rd_data)\n\t\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\treturn cur;\n\t\t}\n\t\tn = next;\n\t}\n\tspin_unlock(&sdp->sd_rindex_spin);\n\n\treturn NULL;\n}",
          "includes": [
            "#include \"trace_gfs2.h\"",
            "#include \"inode.h\"",
            "#include \"log.h\"",
            "#include \"util.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"lops.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/random.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/fs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"inode.h\"\n#include \"log.h\"\n#include \"util.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"lops.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/random.h>\n#include <linux/rbtree.h>\n#include <linux/blkdev.h>\n#include <linux/prefetch.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/fs.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nstruct gfs2_rgrpd *gfs2_blk2rgrpd(struct gfs2_sbd *sdp, u64 blk, bool exact)\n{\n\tstruct rb_node *n, *next;\n\tstruct gfs2_rgrpd *cur;\n\n\tspin_lock(&sdp->sd_rindex_spin);\n\tn = sdp->sd_rindex_tree.rb_node;\n\twhile (n) {\n\t\tcur = rb_entry(n, struct gfs2_rgrpd, rd_node);\n\t\tnext = NULL;\n\t\tif (blk < cur->rd_addr)\n\t\t\tnext = n->rb_left;\n\t\telse if (blk >= cur->rd_data0 + cur->rd_data)\n\t\t\tnext = n->rb_right;\n\t\tif (next == NULL) {\n\t\t\tspin_unlock(&sdp->sd_rindex_spin);\n\t\t\tif (exact) {\n\t\t\t\tif (blk < cur->rd_addr)\n\t\t\t\t\treturn NULL;\n\t\t\t\tif (blk >= cur->rd_data0 + cur->rd_data)\n\t\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\treturn cur;\n\t\t}\n\t\tn = next;\n\t}\n\tspin_unlock(&sdp->sd_rindex_spin);\n\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "gfs2_rindex_update",
          "args": [
            "sdp"
          ],
          "line": 1100
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_rindex_update",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/rgrp.c",
          "lines": "1029-1052",
          "snippet": "int gfs2_rindex_update(struct gfs2_sbd *sdp)\n{\n\tstruct gfs2_inode *ip = GFS2_I(sdp->sd_rindex);\n\tstruct gfs2_glock *gl = ip->i_gl;\n\tstruct gfs2_holder ri_gh;\n\tint error = 0;\n\tint unlock_required = 0;\n\n\t/* Read new copy from disk if we don't have the latest */\n\tif (!sdp->sd_rindex_uptodate) {\n\t\tif (!gfs2_glock_is_locked_by_me(gl)) {\n\t\t\terror = gfs2_glock_nq_init(gl, LM_ST_SHARED, 0, &ri_gh);\n\t\t\tif (error)\n\t\t\t\treturn error;\n\t\t\tunlock_required = 1;\n\t\t}\n\t\tif (!sdp->sd_rindex_uptodate)\n\t\t\terror = gfs2_ri_update(ip);\n\t\tif (unlock_required)\n\t\t\tgfs2_glock_dq_uninit(&ri_gh);\n\t}\n\n\treturn error;\n}",
          "includes": [
            "#include \"trace_gfs2.h\"",
            "#include \"inode.h\"",
            "#include \"log.h\"",
            "#include \"util.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"lops.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/random.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/fs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"inode.h\"\n#include \"log.h\"\n#include \"util.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"lops.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/random.h>\n#include <linux/rbtree.h>\n#include <linux/blkdev.h>\n#include <linux/prefetch.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/fs.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nint gfs2_rindex_update(struct gfs2_sbd *sdp)\n{\n\tstruct gfs2_inode *ip = GFS2_I(sdp->sd_rindex);\n\tstruct gfs2_glock *gl = ip->i_gl;\n\tstruct gfs2_holder ri_gh;\n\tint error = 0;\n\tint unlock_required = 0;\n\n\t/* Read new copy from disk if we don't have the latest */\n\tif (!sdp->sd_rindex_uptodate) {\n\t\tif (!gfs2_glock_is_locked_by_me(gl)) {\n\t\t\terror = gfs2_glock_nq_init(gl, LM_ST_SHARED, 0, &ri_gh);\n\t\t\tif (error)\n\t\t\t\treturn error;\n\t\t\tunlock_required = 1;\n\t\t}\n\t\tif (!sdp->sd_rindex_uptodate)\n\t\t\terror = gfs2_ri_update(ip);\n\t\tif (unlock_required)\n\t\t\tgfs2_glock_dq_uninit(&ri_gh);\n\t}\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "GFS2_I",
          "args": [
            "inode"
          ],
          "line": 1095
        },
        "resolved": true,
        "details": {
          "function_name": "GFS2_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/incore.h",
          "lines": "408-411",
          "snippet": "static inline struct gfs2_inode *GFS2_I(struct inode *inode)\n{\n\treturn container_of(inode, struct gfs2_inode, i_inode);\n}",
          "includes": [
            "#include <linux/lockref.h>",
            "#include <linux/percpu.h>",
            "#include <linux/ktime.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/completion.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/dlm.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/kobject.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/lockref.h>\n#include <linux/percpu.h>\n#include <linux/ktime.h>\n#include <linux/rbtree.h>\n#include <linux/completion.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/buffer_head.h>\n#include <linux/dlm.h>\n#include <linux/workqueue.h>\n#include <linux/kobject.h>\n#include <linux/fs.h>\n\nstatic inline struct gfs2_inode *GFS2_I(struct inode *inode)\n{\n\treturn container_of(inode, struct gfs2_inode, i_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "GFS2_SB",
          "args": [
            "dir"
          ],
          "line": 1093
        },
        "resolved": true,
        "details": {
          "function_name": "GFS2_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/incore.h",
          "lines": "413-416",
          "snippet": "static inline struct gfs2_sbd *GFS2_SB(const struct inode *inode)\n{\n\treturn inode->i_sb->s_fs_info;\n}",
          "includes": [
            "#include <linux/lockref.h>",
            "#include <linux/percpu.h>",
            "#include <linux/ktime.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/completion.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/dlm.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/kobject.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/lockref.h>\n#include <linux/percpu.h>\n#include <linux/ktime.h>\n#include <linux/rbtree.h>\n#include <linux/completion.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/buffer_head.h>\n#include <linux/dlm.h>\n#include <linux/workqueue.h>\n#include <linux/kobject.h>\n#include <linux/fs.h>\n\nstatic inline struct gfs2_sbd *GFS2_SB(const struct inode *inode)\n{\n\treturn inode->i_sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"glops.h\"\n#include \"super.h\"\n#include \"util.h\"\n#include \"trans.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"xattr.h\"\n#include \"dir.h\"\n#include \"bmap.h\"\n#include \"acl.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <asm/uaccess.h>\n#include <linux/security.h>\n#include <linux/fiemap.h>\n#include <linux/crc32.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/posix_acl.h>\n#include <linux/xattr.h>\n#include <linux/mm.h>\n#include <linux/namei.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nstatic int gfs2_unlink(struct inode *dir, struct dentry *dentry)\n{\n\tstruct gfs2_inode *dip = GFS2_I(dir);\n\tstruct gfs2_sbd *sdp = GFS2_SB(dir);\n\tstruct inode *inode = dentry->d_inode;\n\tstruct gfs2_inode *ip = GFS2_I(inode);\n\tstruct gfs2_holder ghs[3];\n\tstruct gfs2_rgrpd *rgd;\n\tint error;\n\n\terror = gfs2_rindex_update(sdp);\n\tif (error)\n\t\treturn error;\n\n\terror = -EROFS;\n\n\tgfs2_holder_init(dip->i_gl, LM_ST_EXCLUSIVE, 0, ghs);\n\tgfs2_holder_init(ip->i_gl,  LM_ST_EXCLUSIVE, 0, ghs + 1);\n\n\trgd = gfs2_blk2rgrpd(sdp, ip->i_no_addr, 1);\n\tif (!rgd)\n\t\tgoto out_inodes;\n\n\tgfs2_holder_init(rgd->rd_gl, LM_ST_EXCLUSIVE, 0, ghs + 2);\n\n\n\terror = gfs2_glock_nq(ghs); /* parent */\n\tif (error)\n\t\tgoto out_parent;\n\n\terror = gfs2_glock_nq(ghs + 1); /* child */\n\tif (error)\n\t\tgoto out_child;\n\n\terror = -ENOENT;\n\tif (inode->i_nlink == 0)\n\t\tgoto out_rgrp;\n\n\tif (S_ISDIR(inode->i_mode)) {\n\t\terror = -ENOTEMPTY;\n\t\tif (ip->i_entries > 2 || inode->i_nlink > 2)\n\t\t\tgoto out_rgrp;\n\t}\n\n\terror = gfs2_glock_nq(ghs + 2); /* rgrp */\n\tif (error)\n\t\tgoto out_rgrp;\n\n\terror = gfs2_unlink_ok(dip, &dentry->d_name, ip);\n\tif (error)\n\t\tgoto out_gunlock;\n\n\terror = gfs2_trans_begin(sdp, 2*RES_DINODE + 3*RES_LEAF + RES_RG_BIT, 0);\n\tif (error)\n\t\tgoto out_end_trans;\n\n\terror = gfs2_unlink_inode(dip, dentry);\n\nout_end_trans:\n\tgfs2_trans_end(sdp);\nout_gunlock:\n\tgfs2_glock_dq(ghs + 2);\nout_rgrp:\n\tgfs2_glock_dq(ghs + 1);\nout_child:\n\tgfs2_glock_dq(ghs);\nout_parent:\n\tgfs2_holder_uninit(ghs + 2);\nout_inodes:\n\tgfs2_holder_uninit(ghs + 1);\n\tgfs2_holder_uninit(ghs);\n\treturn error;\n}"
  },
  {
    "function_name": "gfs2_unlink_inode",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/inode.c",
    "lines": "1055-1076",
    "snippet": "static int gfs2_unlink_inode(struct gfs2_inode *dip,\n\t\t\t     const struct dentry *dentry)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tstruct gfs2_inode *ip = GFS2_I(inode);\n\tint error;\n\n\terror = gfs2_dir_del(dip, dentry);\n\tif (error)\n\t\treturn error;\n\n\tip->i_entries = 0;\n\tinode->i_ctime = CURRENT_TIME;\n\tif (S_ISDIR(inode->i_mode))\n\t\tclear_nlink(inode);\n\telse\n\t\tdrop_nlink(inode);\n\tmark_inode_dirty(inode);\n\tif (inode->i_nlink == 0)\n\t\tgfs2_unlink_di(inode);\n\treturn 0;\n}",
    "includes": [
      "#include \"glops.h\"",
      "#include \"super.h\"",
      "#include \"util.h\"",
      "#include \"trans.h\"",
      "#include \"rgrp.h\"",
      "#include \"quota.h\"",
      "#include \"meta_io.h\"",
      "#include \"inode.h\"",
      "#include \"glock.h\"",
      "#include \"xattr.h\"",
      "#include \"dir.h\"",
      "#include \"bmap.h\"",
      "#include \"acl.h\"",
      "#include \"incore.h\"",
      "#include \"gfs2.h\"",
      "#include <asm/uaccess.h>",
      "#include <linux/security.h>",
      "#include <linux/fiemap.h>",
      "#include <linux/crc32.h>",
      "#include <linux/gfs2_ondisk.h>",
      "#include <linux/posix_acl.h>",
      "#include <linux/xattr.h>",
      "#include <linux/mm.h>",
      "#include <linux/namei.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/completion.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "gfs2_unlink_di",
          "args": [
            "inode"
          ],
          "line": 1074
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_unlink_di",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/rgrp.c",
          "lines": "2433-2448",
          "snippet": "void gfs2_unlink_di(struct inode *inode)\n{\n\tstruct gfs2_inode *ip = GFS2_I(inode);\n\tstruct gfs2_sbd *sdp = GFS2_SB(inode);\n\tstruct gfs2_rgrpd *rgd;\n\tu64 blkno = ip->i_no_addr;\n\n\trgd = rgblk_free(sdp, blkno, 1, GFS2_BLKST_UNLINKED);\n\tif (!rgd)\n\t\treturn;\n\ttrace_gfs2_block_alloc(ip, rgd, blkno, 1, GFS2_BLKST_UNLINKED);\n\tgfs2_trans_add_meta(rgd->rd_gl, rgd->rd_bits[0].bi_bh);\n\tgfs2_rgrp_out(rgd, rgd->rd_bits[0].bi_bh->b_data);\n\tgfs2_rgrp_ondisk2lvb(rgd->rd_rgl, rgd->rd_bits[0].bi_bh->b_data);\n\tupdate_rgrp_lvb_unlinked(rgd, 1);\n}",
          "includes": [
            "#include \"trace_gfs2.h\"",
            "#include \"inode.h\"",
            "#include \"log.h\"",
            "#include \"util.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"lops.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/random.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/fs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"inode.h\"\n#include \"log.h\"\n#include \"util.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"lops.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/random.h>\n#include <linux/rbtree.h>\n#include <linux/blkdev.h>\n#include <linux/prefetch.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/fs.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nvoid gfs2_unlink_di(struct inode *inode)\n{\n\tstruct gfs2_inode *ip = GFS2_I(inode);\n\tstruct gfs2_sbd *sdp = GFS2_SB(inode);\n\tstruct gfs2_rgrpd *rgd;\n\tu64 blkno = ip->i_no_addr;\n\n\trgd = rgblk_free(sdp, blkno, 1, GFS2_BLKST_UNLINKED);\n\tif (!rgd)\n\t\treturn;\n\ttrace_gfs2_block_alloc(ip, rgd, blkno, 1, GFS2_BLKST_UNLINKED);\n\tgfs2_trans_add_meta(rgd->rd_gl, rgd->rd_bits[0].bi_bh);\n\tgfs2_rgrp_out(rgd, rgd->rd_bits[0].bi_bh->b_data);\n\tgfs2_rgrp_ondisk2lvb(rgd->rd_rgl, rgd->rd_bits[0].bi_bh->b_data);\n\tupdate_rgrp_lvb_unlinked(rgd, 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mark_inode_dirty",
          "args": [
            "inode"
          ],
          "line": 1072
        },
        "resolved": true,
        "details": {
          "function_name": "block_dump___mark_inode_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fs-writeback.c",
          "lines": "1134-1154",
          "snippet": "static noinline void block_dump___mark_inode_dirty(struct inode *inode)\n{\n\tif (inode->i_ino || strcmp(inode->i_sb->s_id, \"bdev\")) {\n\t\tstruct dentry *dentry;\n\t\tconst char *name = \"?\";\n\n\t\tdentry = d_find_alias(inode);\n\t\tif (dentry) {\n\t\t\tspin_lock(&dentry->d_lock);\n\t\t\tname = (const char *) dentry->d_name.name;\n\t\t}\n\t\tprintk(KERN_DEBUG\n\t\t       \"%s(%d): dirtied inode %lu (%s) on %s\\n\",\n\t\t       current->comm, task_pid_nr(current), inode->i_ino,\n\t\t       name, inode->i_sb->s_id);\n\t\tif (dentry) {\n\t\t\tspin_unlock(&dentry->d_lock);\n\t\t\tdput(dentry);\n\t\t}\n\t}\n}",
          "includes": [
            "#include <trace/events/writeback.h>",
            "#include \"internal.h\"",
            "#include <linux/device.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/writeback.h>\n#include \"internal.h\"\n#include <linux/device.h>\n#include <linux/tracepoint.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nstatic noinline void block_dump___mark_inode_dirty(struct inode *inode)\n{\n\tif (inode->i_ino || strcmp(inode->i_sb->s_id, \"bdev\")) {\n\t\tstruct dentry *dentry;\n\t\tconst char *name = \"?\";\n\n\t\tdentry = d_find_alias(inode);\n\t\tif (dentry) {\n\t\t\tspin_lock(&dentry->d_lock);\n\t\t\tname = (const char *) dentry->d_name.name;\n\t\t}\n\t\tprintk(KERN_DEBUG\n\t\t       \"%s(%d): dirtied inode %lu (%s) on %s\\n\",\n\t\t       current->comm, task_pid_nr(current), inode->i_ino,\n\t\t       name, inode->i_sb->s_id);\n\t\tif (dentry) {\n\t\t\tspin_unlock(&dentry->d_lock);\n\t\t\tdput(dentry);\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "drop_nlink",
          "args": [
            "inode"
          ],
          "line": 1071
        },
        "resolved": true,
        "details": {
          "function_name": "drop_nlink",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "271-277",
          "snippet": "void drop_nlink(struct inode *inode)\n{\n\tWARN_ON(inode->i_nlink == 0);\n\tinode->__i_nlink--;\n\tif (!inode->i_nlink)\n\t\tatomic_long_inc(&inode->i_sb->s_remove_count);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid drop_nlink(struct inode *inode)\n{\n\tWARN_ON(inode->i_nlink == 0);\n\tinode->__i_nlink--;\n\tif (!inode->i_nlink)\n\t\tatomic_long_inc(&inode->i_sb->s_remove_count);\n}"
        }
      },
      {
        "call_info": {
          "callee": "clear_nlink",
          "args": [
            "inode"
          ],
          "line": 1069
        },
        "resolved": true,
        "details": {
          "function_name": "clear_nlink",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "288-294",
          "snippet": "void clear_nlink(struct inode *inode)\n{\n\tif (inode->i_nlink) {\n\t\tinode->__i_nlink = 0;\n\t\tatomic_long_inc(&inode->i_sb->s_remove_count);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid clear_nlink(struct inode *inode)\n{\n\tif (inode->i_nlink) {\n\t\tinode->__i_nlink = 0;\n\t\tatomic_long_inc(&inode->i_sb->s_remove_count);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "S_ISDIR",
          "args": [
            "inode->i_mode"
          ],
          "line": 1068
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gfs2_dir_del",
          "args": [
            "dip",
            "dentry"
          ],
          "line": 1062
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_dir_del",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/dir.c",
          "lines": "1772-1817",
          "snippet": "int gfs2_dir_del(struct gfs2_inode *dip, const struct dentry *dentry)\n{\n\tconst struct qstr *name = &dentry->d_name;\n\tstruct gfs2_dirent *dent, *prev = NULL;\n\tstruct buffer_head *bh;\n\tstruct timespec tv = CURRENT_TIME;\n\n\t/* Returns _either_ the entry (if its first in block) or the\n\t   previous entry otherwise */\n\tdent = gfs2_dirent_search(&dip->i_inode, name, gfs2_dirent_prev, &bh);\n\tif (!dent) {\n\t\tgfs2_consist_inode(dip);\n\t\treturn -EIO;\n\t}\n\tif (IS_ERR(dent)) {\n\t\tgfs2_consist_inode(dip);\n\t\treturn PTR_ERR(dent);\n\t}\n\t/* If not first in block, adjust pointers accordingly */\n\tif (gfs2_dirent_find(dent, name, NULL) == 0) {\n\t\tprev = dent;\n\t\tdent = (struct gfs2_dirent *)((char *)dent + be16_to_cpu(prev->de_rec_len));\n\t}\n\n\tdirent_del(dip, bh, prev, dent);\n\tif (dip->i_diskflags & GFS2_DIF_EXHASH) {\n\t\tstruct gfs2_leaf *leaf = (struct gfs2_leaf *)bh->b_data;\n\t\tu16 entries = be16_to_cpu(leaf->lf_entries);\n\t\tif (!entries)\n\t\t\tgfs2_consist_inode(dip);\n\t\tleaf->lf_entries = cpu_to_be16(--entries);\n\t\tleaf->lf_nsec = cpu_to_be32(tv.tv_nsec);\n\t\tleaf->lf_sec = cpu_to_be64(tv.tv_sec);\n\t}\n\tbrelse(bh);\n\n\tif (!dip->i_entries)\n\t\tgfs2_consist_inode(dip);\n\tdip->i_entries--;\n\tdip->i_inode.i_mtime = dip->i_inode.i_ctime = tv;\n\tif (d_is_dir(dentry))\n\t\tdrop_nlink(&dip->i_inode);\n\tmark_inode_dirty(&dip->i_inode);\n\n\treturn 0;\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"bmap.h\"",
            "#include \"trans.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"inode.h\"",
            "#include \"glock.h\"",
            "#include \"dir.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/crc32.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/sort.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"bmap.h\"\n#include \"trans.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"dir.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/vmalloc.h>\n#include <linux/crc32.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/sort.h>\n#include <linux/buffer_head.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nint gfs2_dir_del(struct gfs2_inode *dip, const struct dentry *dentry)\n{\n\tconst struct qstr *name = &dentry->d_name;\n\tstruct gfs2_dirent *dent, *prev = NULL;\n\tstruct buffer_head *bh;\n\tstruct timespec tv = CURRENT_TIME;\n\n\t/* Returns _either_ the entry (if its first in block) or the\n\t   previous entry otherwise */\n\tdent = gfs2_dirent_search(&dip->i_inode, name, gfs2_dirent_prev, &bh);\n\tif (!dent) {\n\t\tgfs2_consist_inode(dip);\n\t\treturn -EIO;\n\t}\n\tif (IS_ERR(dent)) {\n\t\tgfs2_consist_inode(dip);\n\t\treturn PTR_ERR(dent);\n\t}\n\t/* If not first in block, adjust pointers accordingly */\n\tif (gfs2_dirent_find(dent, name, NULL) == 0) {\n\t\tprev = dent;\n\t\tdent = (struct gfs2_dirent *)((char *)dent + be16_to_cpu(prev->de_rec_len));\n\t}\n\n\tdirent_del(dip, bh, prev, dent);\n\tif (dip->i_diskflags & GFS2_DIF_EXHASH) {\n\t\tstruct gfs2_leaf *leaf = (struct gfs2_leaf *)bh->b_data;\n\t\tu16 entries = be16_to_cpu(leaf->lf_entries);\n\t\tif (!entries)\n\t\t\tgfs2_consist_inode(dip);\n\t\tleaf->lf_entries = cpu_to_be16(--entries);\n\t\tleaf->lf_nsec = cpu_to_be32(tv.tv_nsec);\n\t\tleaf->lf_sec = cpu_to_be64(tv.tv_sec);\n\t}\n\tbrelse(bh);\n\n\tif (!dip->i_entries)\n\t\tgfs2_consist_inode(dip);\n\tdip->i_entries--;\n\tdip->i_inode.i_mtime = dip->i_inode.i_ctime = tv;\n\tif (d_is_dir(dentry))\n\t\tdrop_nlink(&dip->i_inode);\n\tmark_inode_dirty(&dip->i_inode);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "GFS2_I",
          "args": [
            "inode"
          ],
          "line": 1059
        },
        "resolved": true,
        "details": {
          "function_name": "GFS2_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/incore.h",
          "lines": "408-411",
          "snippet": "static inline struct gfs2_inode *GFS2_I(struct inode *inode)\n{\n\treturn container_of(inode, struct gfs2_inode, i_inode);\n}",
          "includes": [
            "#include <linux/lockref.h>",
            "#include <linux/percpu.h>",
            "#include <linux/ktime.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/completion.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/dlm.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/kobject.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/lockref.h>\n#include <linux/percpu.h>\n#include <linux/ktime.h>\n#include <linux/rbtree.h>\n#include <linux/completion.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/buffer_head.h>\n#include <linux/dlm.h>\n#include <linux/workqueue.h>\n#include <linux/kobject.h>\n#include <linux/fs.h>\n\nstatic inline struct gfs2_inode *GFS2_I(struct inode *inode)\n{\n\treturn container_of(inode, struct gfs2_inode, i_inode);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"glops.h\"\n#include \"super.h\"\n#include \"util.h\"\n#include \"trans.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"xattr.h\"\n#include \"dir.h\"\n#include \"bmap.h\"\n#include \"acl.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <asm/uaccess.h>\n#include <linux/security.h>\n#include <linux/fiemap.h>\n#include <linux/crc32.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/posix_acl.h>\n#include <linux/xattr.h>\n#include <linux/mm.h>\n#include <linux/namei.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nstatic int gfs2_unlink_inode(struct gfs2_inode *dip,\n\t\t\t     const struct dentry *dentry)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tstruct gfs2_inode *ip = GFS2_I(inode);\n\tint error;\n\n\terror = gfs2_dir_del(dip, dentry);\n\tif (error)\n\t\treturn error;\n\n\tip->i_entries = 0;\n\tinode->i_ctime = CURRENT_TIME;\n\tif (S_ISDIR(inode->i_mode))\n\t\tclear_nlink(inode);\n\telse\n\t\tdrop_nlink(inode);\n\tmark_inode_dirty(inode);\n\tif (inode->i_nlink == 0)\n\t\tgfs2_unlink_di(inode);\n\treturn 0;\n}"
  },
  {
    "function_name": "gfs2_unlink_ok",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/inode.c",
    "lines": "1020-1041",
    "snippet": "static int gfs2_unlink_ok(struct gfs2_inode *dip, const struct qstr *name,\n\t\t\t  const struct gfs2_inode *ip)\n{\n\tint error;\n\n\tif (IS_IMMUTABLE(&ip->i_inode) || IS_APPEND(&ip->i_inode))\n\t\treturn -EPERM;\n\n\tif ((dip->i_inode.i_mode & S_ISVTX) &&\n\t    !uid_eq(dip->i_inode.i_uid, current_fsuid()) &&\n\t    !uid_eq(ip->i_inode.i_uid, current_fsuid()) && !capable(CAP_FOWNER))\n\t\treturn -EPERM;\n\n\tif (IS_APPEND(&dip->i_inode))\n\t\treturn -EPERM;\n\n\terror = gfs2_permission(&dip->i_inode, MAY_WRITE | MAY_EXEC);\n\tif (error)\n\t\treturn error;\n\n\treturn gfs2_dir_check(&dip->i_inode, name, ip);\n}",
    "includes": [
      "#include \"glops.h\"",
      "#include \"super.h\"",
      "#include \"util.h\"",
      "#include \"trans.h\"",
      "#include \"rgrp.h\"",
      "#include \"quota.h\"",
      "#include \"meta_io.h\"",
      "#include \"inode.h\"",
      "#include \"glock.h\"",
      "#include \"xattr.h\"",
      "#include \"dir.h\"",
      "#include \"bmap.h\"",
      "#include \"acl.h\"",
      "#include \"incore.h\"",
      "#include \"gfs2.h\"",
      "#include <asm/uaccess.h>",
      "#include <linux/security.h>",
      "#include <linux/fiemap.h>",
      "#include <linux/crc32.h>",
      "#include <linux/gfs2_ondisk.h>",
      "#include <linux/posix_acl.h>",
      "#include <linux/xattr.h>",
      "#include <linux/mm.h>",
      "#include <linux/namei.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/completion.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "gfs2_dir_check",
          "args": [
            "&dip->i_inode",
            "name",
            "ip"
          ],
          "line": 1040
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_dir_check",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/dir.c",
          "lines": "1571-1600",
          "snippet": "int gfs2_dir_check(struct inode *dir, const struct qstr *name,\n\t\t   const struct gfs2_inode *ip)\n{\n\tstruct buffer_head *bh;\n\tstruct gfs2_dirent *dent;\n\tint ret = -ENOENT;\n\n\tdent = gfs2_dirent_search(dir, name, gfs2_dirent_find, &bh);\n\tif (dent) {\n\t\tif (IS_ERR(dent))\n\t\t\treturn PTR_ERR(dent);\n\t\tif (ip) {\n\t\t\tif (be64_to_cpu(dent->de_inum.no_addr) != ip->i_no_addr)\n\t\t\t\tgoto out;\n\t\t\tif (be64_to_cpu(dent->de_inum.no_formal_ino) !=\n\t\t\t    ip->i_no_formal_ino)\n\t\t\t\tgoto out;\n\t\t\tif (unlikely(IF2DT(ip->i_inode.i_mode) !=\n\t\t\t    be16_to_cpu(dent->de_type))) {\n\t\t\t\tgfs2_consist_inode(GFS2_I(dir));\n\t\t\t\tret = -EIO;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\t\tret = 0;\nout:\n\t\tbrelse(bh);\n\t}\n\treturn ret;\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"bmap.h\"",
            "#include \"trans.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"inode.h\"",
            "#include \"glock.h\"",
            "#include \"dir.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/crc32.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/sort.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"bmap.h\"\n#include \"trans.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"dir.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/vmalloc.h>\n#include <linux/crc32.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/sort.h>\n#include <linux/buffer_head.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nint gfs2_dir_check(struct inode *dir, const struct qstr *name,\n\t\t   const struct gfs2_inode *ip)\n{\n\tstruct buffer_head *bh;\n\tstruct gfs2_dirent *dent;\n\tint ret = -ENOENT;\n\n\tdent = gfs2_dirent_search(dir, name, gfs2_dirent_find, &bh);\n\tif (dent) {\n\t\tif (IS_ERR(dent))\n\t\t\treturn PTR_ERR(dent);\n\t\tif (ip) {\n\t\t\tif (be64_to_cpu(dent->de_inum.no_addr) != ip->i_no_addr)\n\t\t\t\tgoto out;\n\t\t\tif (be64_to_cpu(dent->de_inum.no_formal_ino) !=\n\t\t\t    ip->i_no_formal_ino)\n\t\t\t\tgoto out;\n\t\t\tif (unlikely(IF2DT(ip->i_inode.i_mode) !=\n\t\t\t    be16_to_cpu(dent->de_type))) {\n\t\t\t\tgfs2_consist_inode(GFS2_I(dir));\n\t\t\t\tret = -EIO;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\t\tret = 0;\nout:\n\t\tbrelse(bh);\n\t}\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "gfs2_permission",
          "args": [
            "&dip->i_inode",
            "MAY_WRITE | MAY_EXEC"
          ],
          "line": 1036
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_permission",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/inode.c",
          "lines": "1606-1632",
          "snippet": "int gfs2_permission(struct inode *inode, int mask)\n{\n\tstruct gfs2_inode *ip;\n\tstruct gfs2_holder i_gh;\n\tint error;\n\tint unlock = 0;\n\n\n\tip = GFS2_I(inode);\n\tif (gfs2_glock_is_locked_by_me(ip->i_gl) == NULL) {\n\t\tif (mask & MAY_NOT_BLOCK)\n\t\t\treturn -ECHILD;\n\t\terror = gfs2_glock_nq_init(ip->i_gl, LM_ST_SHARED, LM_FLAG_ANY, &i_gh);\n\t\tif (error)\n\t\t\treturn error;\n\t\tunlock = 1;\n\t}\n\n\tif ((mask & MAY_WRITE) && IS_IMMUTABLE(inode))\n\t\terror = -EACCES;\n\telse\n\t\terror = generic_permission(inode, mask);\n\tif (unlock)\n\t\tgfs2_glock_dq_uninit(&i_gh);\n\n\treturn error;\n}",
          "includes": [
            "#include \"glops.h\"",
            "#include \"super.h\"",
            "#include \"util.h\"",
            "#include \"trans.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"inode.h\"",
            "#include \"glock.h\"",
            "#include \"xattr.h\"",
            "#include \"dir.h\"",
            "#include \"bmap.h\"",
            "#include \"acl.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/security.h>",
            "#include <linux/fiemap.h>",
            "#include <linux/crc32.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/xattr.h>",
            "#include <linux/mm.h>",
            "#include <linux/namei.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glops.h\"\n#include \"super.h\"\n#include \"util.h\"\n#include \"trans.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"xattr.h\"\n#include \"dir.h\"\n#include \"bmap.h\"\n#include \"acl.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <asm/uaccess.h>\n#include <linux/security.h>\n#include <linux/fiemap.h>\n#include <linux/crc32.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/posix_acl.h>\n#include <linux/xattr.h>\n#include <linux/mm.h>\n#include <linux/namei.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nint gfs2_permission(struct inode *inode, int mask)\n{\n\tstruct gfs2_inode *ip;\n\tstruct gfs2_holder i_gh;\n\tint error;\n\tint unlock = 0;\n\n\n\tip = GFS2_I(inode);\n\tif (gfs2_glock_is_locked_by_me(ip->i_gl) == NULL) {\n\t\tif (mask & MAY_NOT_BLOCK)\n\t\t\treturn -ECHILD;\n\t\terror = gfs2_glock_nq_init(ip->i_gl, LM_ST_SHARED, LM_FLAG_ANY, &i_gh);\n\t\tif (error)\n\t\t\treturn error;\n\t\tunlock = 1;\n\t}\n\n\tif ((mask & MAY_WRITE) && IS_IMMUTABLE(inode))\n\t\terror = -EACCES;\n\telse\n\t\terror = generic_permission(inode, mask);\n\tif (unlock)\n\t\tgfs2_glock_dq_uninit(&i_gh);\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_APPEND",
          "args": [
            "&dip->i_inode"
          ],
          "line": 1033
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "capable",
          "args": [
            "CAP_FOWNER"
          ],
          "line": 1030
        },
        "resolved": true,
        "details": {
          "function_name": "inode_owner_or_capable",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "1901-1912",
          "snippet": "bool inode_owner_or_capable(const struct inode *inode)\n{\n\tstruct user_namespace *ns;\n\n\tif (uid_eq(current_fsuid(), inode->i_uid))\n\t\treturn true;\n\n\tns = current_user_ns();\n\tif (ns_capable(ns, CAP_FOWNER) && kuid_has_mapping(ns, inode->i_uid))\n\t\treturn true;\n\treturn false;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nbool inode_owner_or_capable(const struct inode *inode)\n{\n\tstruct user_namespace *ns;\n\n\tif (uid_eq(current_fsuid(), inode->i_uid))\n\t\treturn true;\n\n\tns = current_user_ns();\n\tif (ns_capable(ns, CAP_FOWNER) && kuid_has_mapping(ns, inode->i_uid))\n\t\treturn true;\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "uid_eq",
          "args": [
            "ip->i_inode.i_uid",
            "current_fsuid()"
          ],
          "line": 1030
        },
        "resolved": true,
        "details": {
          "function_name": "uuid_equal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/uuid.c",
          "lines": "59-63",
          "snippet": "int\nuuid_equal(uuid_t *uuid1, uuid_t *uuid2)\n{\n\treturn memcmp(uuid1, uuid2, sizeof(uuid_t)) ? 0 : 1;\n}",
          "includes": [
            "#include <xfs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <xfs.h>\n\nint\nuuid_equal(uuid_t *uuid1, uuid_t *uuid2)\n{\n\treturn memcmp(uuid1, uuid2, sizeof(uuid_t)) ? 0 : 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "current_fsuid",
          "args": [],
          "line": 1030
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "current_fsuid",
          "args": [],
          "line": 1029
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_APPEND",
          "args": [
            "&ip->i_inode"
          ],
          "line": 1025
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_IMMUTABLE",
          "args": [
            "&ip->i_inode"
          ],
          "line": 1025
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"glops.h\"\n#include \"super.h\"\n#include \"util.h\"\n#include \"trans.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"xattr.h\"\n#include \"dir.h\"\n#include \"bmap.h\"\n#include \"acl.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <asm/uaccess.h>\n#include <linux/security.h>\n#include <linux/fiemap.h>\n#include <linux/crc32.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/posix_acl.h>\n#include <linux/xattr.h>\n#include <linux/mm.h>\n#include <linux/namei.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nstatic int gfs2_unlink_ok(struct gfs2_inode *dip, const struct qstr *name,\n\t\t\t  const struct gfs2_inode *ip)\n{\n\tint error;\n\n\tif (IS_IMMUTABLE(&ip->i_inode) || IS_APPEND(&ip->i_inode))\n\t\treturn -EPERM;\n\n\tif ((dip->i_inode.i_mode & S_ISVTX) &&\n\t    !uid_eq(dip->i_inode.i_uid, current_fsuid()) &&\n\t    !uid_eq(ip->i_inode.i_uid, current_fsuid()) && !capable(CAP_FOWNER))\n\t\treturn -EPERM;\n\n\tif (IS_APPEND(&dip->i_inode))\n\t\treturn -EPERM;\n\n\terror = gfs2_permission(&dip->i_inode, MAY_WRITE | MAY_EXEC);\n\tif (error)\n\t\treturn error;\n\n\treturn gfs2_dir_check(&dip->i_inode, name, ip);\n}"
  },
  {
    "function_name": "gfs2_link",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/inode.c",
    "lines": "886-1007",
    "snippet": "static int gfs2_link(struct dentry *old_dentry, struct inode *dir,\n\t\t     struct dentry *dentry)\n{\n\tstruct gfs2_inode *dip = GFS2_I(dir);\n\tstruct gfs2_sbd *sdp = GFS2_SB(dir);\n\tstruct inode *inode = old_dentry->d_inode;\n\tstruct gfs2_inode *ip = GFS2_I(inode);\n\tstruct gfs2_holder ghs[2];\n\tstruct buffer_head *dibh;\n\tstruct gfs2_diradd da = { .bh = NULL, .save_loc = 1, };\n\tint error;\n\n\tif (S_ISDIR(inode->i_mode))\n\t\treturn -EPERM;\n\n\terror = gfs2_rs_alloc(dip);\n\tif (error)\n\t\treturn error;\n\n\tgfs2_holder_init(dip->i_gl, LM_ST_EXCLUSIVE, 0, ghs);\n\tgfs2_holder_init(ip->i_gl, LM_ST_EXCLUSIVE, 0, ghs + 1);\n\n\terror = gfs2_glock_nq(ghs); /* parent */\n\tif (error)\n\t\tgoto out_parent;\n\n\terror = gfs2_glock_nq(ghs + 1); /* child */\n\tif (error)\n\t\tgoto out_child;\n\n\terror = -ENOENT;\n\tif (inode->i_nlink == 0)\n\t\tgoto out_gunlock;\n\n\terror = gfs2_permission(dir, MAY_WRITE | MAY_EXEC);\n\tif (error)\n\t\tgoto out_gunlock;\n\n\terror = gfs2_dir_check(dir, &dentry->d_name, NULL);\n\tswitch (error) {\n\tcase -ENOENT:\n\t\tbreak;\n\tcase 0:\n\t\terror = -EEXIST;\n\tdefault:\n\t\tgoto out_gunlock;\n\t}\n\n\terror = -EINVAL;\n\tif (!dip->i_inode.i_nlink)\n\t\tgoto out_gunlock;\n\terror = -EFBIG;\n\tif (dip->i_entries == (u32)-1)\n\t\tgoto out_gunlock;\n\terror = -EPERM;\n\tif (IS_IMMUTABLE(inode) || IS_APPEND(inode))\n\t\tgoto out_gunlock;\n\terror = -EINVAL;\n\tif (!ip->i_inode.i_nlink)\n\t\tgoto out_gunlock;\n\terror = -EMLINK;\n\tif (ip->i_inode.i_nlink == (u32)-1)\n\t\tgoto out_gunlock;\n\n\terror = gfs2_diradd_alloc_required(dir, &dentry->d_name, &da);\n\tif (error < 0)\n\t\tgoto out_gunlock;\n\n\tif (da.nr_blocks) {\n\t\tstruct gfs2_alloc_parms ap = { .target = da.nr_blocks, };\n\t\terror = gfs2_quota_lock_check(dip);\n\t\tif (error)\n\t\t\tgoto out_gunlock;\n\n\t\terror = gfs2_inplace_reserve(dip, &ap);\n\t\tif (error)\n\t\t\tgoto out_gunlock_q;\n\n\t\terror = gfs2_trans_begin(sdp, gfs2_trans_da_blks(dip, &da, 2), 0);\n\t\tif (error)\n\t\t\tgoto out_ipres;\n\t} else {\n\t\terror = gfs2_trans_begin(sdp, 2 * RES_DINODE + RES_LEAF, 0);\n\t\tif (error)\n\t\t\tgoto out_ipres;\n\t}\n\n\terror = gfs2_meta_inode_buffer(ip, &dibh);\n\tif (error)\n\t\tgoto out_end_trans;\n\n\terror = gfs2_dir_add(dir, &dentry->d_name, ip, &da);\n\tif (error)\n\t\tgoto out_brelse;\n\n\tgfs2_trans_add_meta(ip->i_gl, dibh);\n\tinc_nlink(&ip->i_inode);\n\tip->i_inode.i_ctime = CURRENT_TIME;\n\tihold(inode);\n\td_instantiate(dentry, inode);\n\tmark_inode_dirty(inode);\n\nout_brelse:\n\tbrelse(dibh);\nout_end_trans:\n\tgfs2_trans_end(sdp);\nout_ipres:\n\tif (da.nr_blocks)\n\t\tgfs2_inplace_release(dip);\nout_gunlock_q:\n\tif (da.nr_blocks)\n\t\tgfs2_quota_unlock(dip);\nout_gunlock:\n\tgfs2_dir_no_add(&da);\n\tgfs2_glock_dq(ghs + 1);\nout_child:\n\tgfs2_glock_dq(ghs);\nout_parent:\n\tgfs2_holder_uninit(ghs);\n\tgfs2_holder_uninit(ghs + 1);\n\treturn error;\n}",
    "includes": [
      "#include \"glops.h\"",
      "#include \"super.h\"",
      "#include \"util.h\"",
      "#include \"trans.h\"",
      "#include \"rgrp.h\"",
      "#include \"quota.h\"",
      "#include \"meta_io.h\"",
      "#include \"inode.h\"",
      "#include \"glock.h\"",
      "#include \"xattr.h\"",
      "#include \"dir.h\"",
      "#include \"bmap.h\"",
      "#include \"acl.h\"",
      "#include \"incore.h\"",
      "#include \"gfs2.h\"",
      "#include <asm/uaccess.h>",
      "#include <linux/security.h>",
      "#include <linux/fiemap.h>",
      "#include <linux/crc32.h>",
      "#include <linux/gfs2_ondisk.h>",
      "#include <linux/posix_acl.h>",
      "#include <linux/xattr.h>",
      "#include <linux/mm.h>",
      "#include <linux/namei.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/completion.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "gfs2_holder_uninit",
          "args": [
            "ghs + 1"
          ],
          "line": 1005
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_holder_uninit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/glock.c",
          "lines": "841-847",
          "snippet": "void gfs2_holder_uninit(struct gfs2_holder *gh)\n{\n\tput_pid(gh->gh_owner_pid);\n\tgfs2_glock_put(gh->gh_gl);\n\tgh->gh_gl = NULL;\n\tgh->gh_ip = 0;\n}",
          "includes": [
            "#include \"trace_gfs2.h\"",
            "#include \"bmap.h\"",
            "#include \"util.h\"",
            "#include \"super.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"lops.h\"",
            "#include \"inode.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/lockref.h>",
            "#include <linux/list_sort.h>",
            "#include <linux/percpu.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/seq_file.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/module.h>",
            "#include <linux/wait.h>",
            "#include <linux/list.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/jhash.h>",
            "#include <linux/sort.h>",
            "#include <linux/delay.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"bmap.h\"\n#include \"util.h\"\n#include \"super.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"lops.h\"\n#include \"inode.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/lockref.h>\n#include <linux/list_sort.h>\n#include <linux/percpu.h>\n#include <linux/bit_spinlock.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/jiffies.h>\n#include <linux/workqueue.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <asm/uaccess.h>\n#include <linux/module.h>\n#include <linux/wait.h>\n#include <linux/list.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/kallsyms.h>\n#include <linux/jhash.h>\n#include <linux/sort.h>\n#include <linux/delay.h>\n#include <linux/buffer_head.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nvoid gfs2_holder_uninit(struct gfs2_holder *gh)\n{\n\tput_pid(gh->gh_owner_pid);\n\tgfs2_glock_put(gh->gh_gl);\n\tgh->gh_gl = NULL;\n\tgh->gh_ip = 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "gfs2_glock_dq",
          "args": [
            "ghs"
          ],
          "line": 1002
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_glock_dq_uninit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/glock.c",
          "lines": "1110-1114",
          "snippet": "void gfs2_glock_dq_uninit(struct gfs2_holder *gh)\n{\n\tgfs2_glock_dq(gh);\n\tgfs2_holder_uninit(gh);\n}",
          "includes": [
            "#include \"trace_gfs2.h\"",
            "#include \"bmap.h\"",
            "#include \"util.h\"",
            "#include \"super.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"lops.h\"",
            "#include \"inode.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/lockref.h>",
            "#include <linux/list_sort.h>",
            "#include <linux/percpu.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/seq_file.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/module.h>",
            "#include <linux/wait.h>",
            "#include <linux/list.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/jhash.h>",
            "#include <linux/sort.h>",
            "#include <linux/delay.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"bmap.h\"\n#include \"util.h\"\n#include \"super.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"lops.h\"\n#include \"inode.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/lockref.h>\n#include <linux/list_sort.h>\n#include <linux/percpu.h>\n#include <linux/bit_spinlock.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/jiffies.h>\n#include <linux/workqueue.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <asm/uaccess.h>\n#include <linux/module.h>\n#include <linux/wait.h>\n#include <linux/list.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/kallsyms.h>\n#include <linux/jhash.h>\n#include <linux/sort.h>\n#include <linux/delay.h>\n#include <linux/buffer_head.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nvoid gfs2_glock_dq_uninit(struct gfs2_holder *gh)\n{\n\tgfs2_glock_dq(gh);\n\tgfs2_holder_uninit(gh);\n}"
        }
      },
      {
        "call_info": {
          "callee": "gfs2_dir_no_add",
          "args": [
            "&da"
          ],
          "line": 999
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_dir_no_add",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/dir.h",
          "lines": "36-41",
          "snippet": "static inline void gfs2_dir_no_add(struct gfs2_diradd *da)\n{\n\tif (da->bh)\n\t\tbrelse(da->bh);\n\tda->bh = NULL;\n}",
          "includes": [
            "#include <linux/crc32.h>",
            "#include <linux/dcache.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/crc32.h>\n#include <linux/dcache.h>\n\nstatic inline void gfs2_dir_no_add(struct gfs2_diradd *da)\n{\n\tif (da->bh)\n\t\tbrelse(da->bh);\n\tda->bh = NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "gfs2_quota_unlock",
          "args": [
            "dip"
          ],
          "line": 997
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_quota_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/quota.c",
          "lines": "1033-1081",
          "snippet": "void gfs2_quota_unlock(struct gfs2_inode *ip)\n{\n\tstruct gfs2_sbd *sdp = GFS2_SB(&ip->i_inode);\n\tstruct gfs2_quota_data *qda[4];\n\tunsigned int count = 0;\n\tunsigned int x;\n\tint found;\n\n\tif (!test_and_clear_bit(GIF_QD_LOCKED, &ip->i_flags))\n\t\tgoto out;\n\n\tfor (x = 0; x < ip->i_res->rs_qa_qd_num; x++) {\n\t\tstruct gfs2_quota_data *qd;\n\t\tint sync;\n\n\t\tqd = ip->i_res->rs_qa_qd[x];\n\t\tsync = need_sync(qd);\n\n\t\tgfs2_glock_dq_uninit(&ip->i_res->rs_qa_qd_ghs[x]);\n\t\tif (!sync)\n\t\t\tcontinue;\n\n\t\tspin_lock(&qd_lock);\n\t\tfound = qd_check_sync(sdp, qd, NULL);\n\t\tspin_unlock(&qd_lock);\n\n\t\tif (!found)\n\t\t\tcontinue;\n\n\t\tgfs2_assert_warn(sdp, qd->qd_change_sync);\n\t\tif (bh_get(qd)) {\n\t\t\tclear_bit(QDF_LOCKED, &qd->qd_flags);\n\t\t\tslot_put(qd);\n\t\t\tqd_put(qd);\n\t\t\tcontinue;\n\t\t}\n\n\t\tqda[count++] = qd;\n\t}\n\n\tif (count) {\n\t\tdo_sync(count, qda);\n\t\tfor (x = 0; x < count; x++)\n\t\t\tqd_unlock(qda[x]);\n\t}\n\nout:\n\tgfs2_quota_unhold(ip);\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"inode.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"log.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"bmap.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/jhash.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/lockref.h>",
            "#include <linux/dqblk_xfs.h>",
            "#include <linux/quota.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/bio.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_SPINLOCK(qd_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"inode.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"log.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/vmalloc.h>\n#include <linux/jhash.h>\n#include <linux/bit_spinlock.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/list_lru.h>\n#include <linux/lockref.h>\n#include <linux/dqblk_xfs.h>\n#include <linux/quota.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/bio.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic DEFINE_SPINLOCK(qd_lock);\n\nvoid gfs2_quota_unlock(struct gfs2_inode *ip)\n{\n\tstruct gfs2_sbd *sdp = GFS2_SB(&ip->i_inode);\n\tstruct gfs2_quota_data *qda[4];\n\tunsigned int count = 0;\n\tunsigned int x;\n\tint found;\n\n\tif (!test_and_clear_bit(GIF_QD_LOCKED, &ip->i_flags))\n\t\tgoto out;\n\n\tfor (x = 0; x < ip->i_res->rs_qa_qd_num; x++) {\n\t\tstruct gfs2_quota_data *qd;\n\t\tint sync;\n\n\t\tqd = ip->i_res->rs_qa_qd[x];\n\t\tsync = need_sync(qd);\n\n\t\tgfs2_glock_dq_uninit(&ip->i_res->rs_qa_qd_ghs[x]);\n\t\tif (!sync)\n\t\t\tcontinue;\n\n\t\tspin_lock(&qd_lock);\n\t\tfound = qd_check_sync(sdp, qd, NULL);\n\t\tspin_unlock(&qd_lock);\n\n\t\tif (!found)\n\t\t\tcontinue;\n\n\t\tgfs2_assert_warn(sdp, qd->qd_change_sync);\n\t\tif (bh_get(qd)) {\n\t\t\tclear_bit(QDF_LOCKED, &qd->qd_flags);\n\t\t\tslot_put(qd);\n\t\t\tqd_put(qd);\n\t\t\tcontinue;\n\t\t}\n\n\t\tqda[count++] = qd;\n\t}\n\n\tif (count) {\n\t\tdo_sync(count, qda);\n\t\tfor (x = 0; x < count; x++)\n\t\t\tqd_unlock(qda[x]);\n\t}\n\nout:\n\tgfs2_quota_unhold(ip);\n}"
        }
      },
      {
        "call_info": {
          "callee": "gfs2_inplace_release",
          "args": [
            "dip"
          ],
          "line": 994
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_inplace_release",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/rgrp.c",
          "lines": "2081-2087",
          "snippet": "void gfs2_inplace_release(struct gfs2_inode *ip)\n{\n\tstruct gfs2_blkreserv *rs = ip->i_res;\n\n\tif (rs->rs_rgd_gh.gh_gl)\n\t\tgfs2_glock_dq_uninit(&rs->rs_rgd_gh);\n}",
          "includes": [
            "#include \"trace_gfs2.h\"",
            "#include \"inode.h\"",
            "#include \"log.h\"",
            "#include \"util.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"lops.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/random.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/fs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"inode.h\"\n#include \"log.h\"\n#include \"util.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"lops.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/random.h>\n#include <linux/rbtree.h>\n#include <linux/blkdev.h>\n#include <linux/prefetch.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/fs.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nvoid gfs2_inplace_release(struct gfs2_inode *ip)\n{\n\tstruct gfs2_blkreserv *rs = ip->i_res;\n\n\tif (rs->rs_rgd_gh.gh_gl)\n\t\tgfs2_glock_dq_uninit(&rs->rs_rgd_gh);\n}"
        }
      },
      {
        "call_info": {
          "callee": "gfs2_trans_end",
          "args": [
            "sdp"
          ],
          "line": 991
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_trans_end",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/trans.c",
          "lines": "88-123",
          "snippet": "void gfs2_trans_end(struct gfs2_sbd *sdp)\n{\n\tstruct gfs2_trans *tr = current->journal_info;\n\ts64 nbuf;\n\tint alloced = tr->tr_alloced;\n\n\tBUG_ON(!tr);\n\tcurrent->journal_info = NULL;\n\n\tif (!tr->tr_touched) {\n\t\tgfs2_log_release(sdp, tr->tr_reserved);\n\t\tif (alloced) {\n\t\t\tkfree(tr);\n\t\t\tsb_end_intwrite(sdp->sd_vfs);\n\t\t}\n\t\treturn;\n\t}\n\n\tnbuf = tr->tr_num_buf_new + tr->tr_num_databuf_new;\n\tnbuf -= tr->tr_num_buf_rm;\n\tnbuf -= tr->tr_num_databuf_rm;\n\n\tif (gfs2_assert_withdraw(sdp, (nbuf <= tr->tr_blocks) &&\n\t\t\t\t       (tr->tr_num_revoke <= tr->tr_revokes)))\n\t\tgfs2_print_trans(tr);\n\n\tgfs2_log_commit(sdp, tr);\n\tif (alloced && !tr->tr_attached)\n\t\t\tkfree(tr);\n\tup_read(&sdp->sd_log_flush_lock);\n\n\tif (sdp->sd_vfs->s_flags & MS_SYNCHRONOUS)\n\t\tgfs2_log_flush(sdp, NULL, NORMAL_FLUSH);\n\tif (alloced)\n\t\tsb_end_intwrite(sdp->sd_vfs);\n}",
          "includes": [
            "#include \"trace_gfs2.h\"",
            "#include \"util.h\"",
            "#include \"trans.h\"",
            "#include \"meta_io.h\"",
            "#include \"lops.h\"",
            "#include \"log.h\"",
            "#include \"inode.h\"",
            "#include \"glock.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"util.h\"\n#include \"trans.h\"\n#include \"meta_io.h\"\n#include \"lops.h\"\n#include \"log.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/gfs2_ondisk.h>\n#include <linux/kallsyms.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nvoid gfs2_trans_end(struct gfs2_sbd *sdp)\n{\n\tstruct gfs2_trans *tr = current->journal_info;\n\ts64 nbuf;\n\tint alloced = tr->tr_alloced;\n\n\tBUG_ON(!tr);\n\tcurrent->journal_info = NULL;\n\n\tif (!tr->tr_touched) {\n\t\tgfs2_log_release(sdp, tr->tr_reserved);\n\t\tif (alloced) {\n\t\t\tkfree(tr);\n\t\t\tsb_end_intwrite(sdp->sd_vfs);\n\t\t}\n\t\treturn;\n\t}\n\n\tnbuf = tr->tr_num_buf_new + tr->tr_num_databuf_new;\n\tnbuf -= tr->tr_num_buf_rm;\n\tnbuf -= tr->tr_num_databuf_rm;\n\n\tif (gfs2_assert_withdraw(sdp, (nbuf <= tr->tr_blocks) &&\n\t\t\t\t       (tr->tr_num_revoke <= tr->tr_revokes)))\n\t\tgfs2_print_trans(tr);\n\n\tgfs2_log_commit(sdp, tr);\n\tif (alloced && !tr->tr_attached)\n\t\t\tkfree(tr);\n\tup_read(&sdp->sd_log_flush_lock);\n\n\tif (sdp->sd_vfs->s_flags & MS_SYNCHRONOUS)\n\t\tgfs2_log_flush(sdp, NULL, NORMAL_FLUSH);\n\tif (alloced)\n\t\tsb_end_intwrite(sdp->sd_vfs);\n}"
        }
      },
      {
        "call_info": {
          "callee": "brelse",
          "args": [
            "dibh"
          ],
          "line": 989
        },
        "resolved": true,
        "details": {
          "function_name": "__brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1177-1184",
          "snippet": "void __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "mark_inode_dirty",
          "args": [
            "inode"
          ],
          "line": 986
        },
        "resolved": true,
        "details": {
          "function_name": "block_dump___mark_inode_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fs-writeback.c",
          "lines": "1134-1154",
          "snippet": "static noinline void block_dump___mark_inode_dirty(struct inode *inode)\n{\n\tif (inode->i_ino || strcmp(inode->i_sb->s_id, \"bdev\")) {\n\t\tstruct dentry *dentry;\n\t\tconst char *name = \"?\";\n\n\t\tdentry = d_find_alias(inode);\n\t\tif (dentry) {\n\t\t\tspin_lock(&dentry->d_lock);\n\t\t\tname = (const char *) dentry->d_name.name;\n\t\t}\n\t\tprintk(KERN_DEBUG\n\t\t       \"%s(%d): dirtied inode %lu (%s) on %s\\n\",\n\t\t       current->comm, task_pid_nr(current), inode->i_ino,\n\t\t       name, inode->i_sb->s_id);\n\t\tif (dentry) {\n\t\t\tspin_unlock(&dentry->d_lock);\n\t\t\tdput(dentry);\n\t\t}\n\t}\n}",
          "includes": [
            "#include <trace/events/writeback.h>",
            "#include \"internal.h\"",
            "#include <linux/device.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/writeback.h>\n#include \"internal.h\"\n#include <linux/device.h>\n#include <linux/tracepoint.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nstatic noinline void block_dump___mark_inode_dirty(struct inode *inode)\n{\n\tif (inode->i_ino || strcmp(inode->i_sb->s_id, \"bdev\")) {\n\t\tstruct dentry *dentry;\n\t\tconst char *name = \"?\";\n\n\t\tdentry = d_find_alias(inode);\n\t\tif (dentry) {\n\t\t\tspin_lock(&dentry->d_lock);\n\t\t\tname = (const char *) dentry->d_name.name;\n\t\t}\n\t\tprintk(KERN_DEBUG\n\t\t       \"%s(%d): dirtied inode %lu (%s) on %s\\n\",\n\t\t       current->comm, task_pid_nr(current), inode->i_ino,\n\t\t       name, inode->i_sb->s_id);\n\t\tif (dentry) {\n\t\t\tspin_unlock(&dentry->d_lock);\n\t\t\tdput(dentry);\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "d_instantiate",
          "args": [
            "dentry",
            "inode"
          ],
          "line": 985
        },
        "resolved": true,
        "details": {
          "function_name": "d_instantiate_no_diralias",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "1839-1854",
          "snippet": "int d_instantiate_no_diralias(struct dentry *entry, struct inode *inode)\n{\n\tBUG_ON(!hlist_unhashed(&entry->d_u.d_alias));\n\n\tspin_lock(&inode->i_lock);\n\tif (S_ISDIR(inode->i_mode) && !hlist_empty(&inode->i_dentry)) {\n\t\tspin_unlock(&inode->i_lock);\n\t\tiput(inode);\n\t\treturn -EBUSY;\n\t}\n\t__d_instantiate(entry, inode);\n\tspin_unlock(&inode->i_lock);\n\tsecurity_d_instantiate(entry, inode);\n\n\treturn 0;\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nint d_instantiate_no_diralias(struct dentry *entry, struct inode *inode)\n{\n\tBUG_ON(!hlist_unhashed(&entry->d_u.d_alias));\n\n\tspin_lock(&inode->i_lock);\n\tif (S_ISDIR(inode->i_mode) && !hlist_empty(&inode->i_dentry)) {\n\t\tspin_unlock(&inode->i_lock);\n\t\tiput(inode);\n\t\treturn -EBUSY;\n\t}\n\t__d_instantiate(entry, inode);\n\tspin_unlock(&inode->i_lock);\n\tsecurity_d_instantiate(entry, inode);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ihold",
          "args": [
            "inode"
          ],
          "line": 984
        },
        "resolved": true,
        "details": {
          "function_name": "ihold",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "388-391",
          "snippet": "void ihold(struct inode *inode)\n{\n\tWARN_ON(atomic_inc_return(&inode->i_count) < 2);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid ihold(struct inode *inode)\n{\n\tWARN_ON(atomic_inc_return(&inode->i_count) < 2);\n}"
        }
      },
      {
        "call_info": {
          "callee": "inc_nlink",
          "args": [
            "&ip->i_inode"
          ],
          "line": 982
        },
        "resolved": true,
        "details": {
          "function_name": "inc_nlink",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "327-335",
          "snippet": "void inc_nlink(struct inode *inode)\n{\n\tif (unlikely(inode->i_nlink == 0)) {\n\t\tWARN_ON(!(inode->i_state & I_LINKABLE));\n\t\tatomic_long_dec(&inode->i_sb->s_remove_count);\n\t}\n\n\tinode->__i_nlink++;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid inc_nlink(struct inode *inode)\n{\n\tif (unlikely(inode->i_nlink == 0)) {\n\t\tWARN_ON(!(inode->i_state & I_LINKABLE));\n\t\tatomic_long_dec(&inode->i_sb->s_remove_count);\n\t}\n\n\tinode->__i_nlink++;\n}"
        }
      },
      {
        "call_info": {
          "callee": "gfs2_trans_add_meta",
          "args": [
            "ip->i_gl",
            "dibh"
          ],
          "line": 981
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_trans_add_meta",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/trans.c",
          "lines": "224-247",
          "snippet": "void gfs2_trans_add_meta(struct gfs2_glock *gl, struct buffer_head *bh)\n{\n\n\tstruct gfs2_sbd *sdp = gl->gl_sbd;\n\tstruct gfs2_bufdata *bd;\n\n\tlock_buffer(bh);\n\tgfs2_log_lock(sdp);\n\tbd = bh->b_private;\n\tif (bd == NULL) {\n\t\tgfs2_log_unlock(sdp);\n\t\tunlock_buffer(bh);\n\t\tlock_page(bh->b_page);\n\t\tif (bh->b_private == NULL)\n\t\t\tbd = gfs2_alloc_bufdata(gl, bh, &gfs2_buf_lops);\n\t\tunlock_page(bh->b_page);\n\t\tlock_buffer(bh);\n\t\tgfs2_log_lock(sdp);\n\t}\n\tgfs2_assert(sdp, bd->bd_gl == gl);\n\tmeta_lo_add(sdp, bd);\n\tgfs2_log_unlock(sdp);\n\tunlock_buffer(bh);\n}",
          "includes": [
            "#include \"trace_gfs2.h\"",
            "#include \"util.h\"",
            "#include \"trans.h\"",
            "#include \"meta_io.h\"",
            "#include \"lops.h\"",
            "#include \"log.h\"",
            "#include \"inode.h\"",
            "#include \"glock.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"util.h\"\n#include \"trans.h\"\n#include \"meta_io.h\"\n#include \"lops.h\"\n#include \"log.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/gfs2_ondisk.h>\n#include <linux/kallsyms.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nvoid gfs2_trans_add_meta(struct gfs2_glock *gl, struct buffer_head *bh)\n{\n\n\tstruct gfs2_sbd *sdp = gl->gl_sbd;\n\tstruct gfs2_bufdata *bd;\n\n\tlock_buffer(bh);\n\tgfs2_log_lock(sdp);\n\tbd = bh->b_private;\n\tif (bd == NULL) {\n\t\tgfs2_log_unlock(sdp);\n\t\tunlock_buffer(bh);\n\t\tlock_page(bh->b_page);\n\t\tif (bh->b_private == NULL)\n\t\t\tbd = gfs2_alloc_bufdata(gl, bh, &gfs2_buf_lops);\n\t\tunlock_page(bh->b_page);\n\t\tlock_buffer(bh);\n\t\tgfs2_log_lock(sdp);\n\t}\n\tgfs2_assert(sdp, bd->bd_gl == gl);\n\tmeta_lo_add(sdp, bd);\n\tgfs2_log_unlock(sdp);\n\tunlock_buffer(bh);\n}"
        }
      },
      {
        "call_info": {
          "callee": "gfs2_dir_add",
          "args": [
            "dir",
            "&dentry->d_name",
            "ip",
            "&da"
          ],
          "line": 977
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_dir_add",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/dir.c",
          "lines": "1693-1761",
          "snippet": "int gfs2_dir_add(struct inode *inode, const struct qstr *name,\n\t\t const struct gfs2_inode *nip, struct gfs2_diradd *da)\n{\n\tstruct gfs2_inode *ip = GFS2_I(inode);\n\tstruct buffer_head *bh = da->bh;\n\tstruct gfs2_dirent *dent = da->dent;\n\tstruct timespec tv;\n\tstruct gfs2_leaf *leaf;\n\tint error;\n\n\twhile(1) {\n\t\tif (da->bh == NULL) {\n\t\t\tdent = gfs2_dirent_search(inode, name,\n\t\t\t\t\t\t  gfs2_dirent_find_space, &bh);\n\t\t}\n\t\tif (dent) {\n\t\t\tif (IS_ERR(dent))\n\t\t\t\treturn PTR_ERR(dent);\n\t\t\tdent = gfs2_init_dirent(inode, dent, name, bh);\n\t\t\tgfs2_inum_out(nip, dent);\n\t\t\tdent->de_type = cpu_to_be16(IF2DT(nip->i_inode.i_mode));\n\t\t\tdent->de_rahead = cpu_to_be16(gfs2_inode_ra_len(nip));\n\t\t\ttv = CURRENT_TIME;\n\t\t\tif (ip->i_diskflags & GFS2_DIF_EXHASH) {\n\t\t\t\tleaf = (struct gfs2_leaf *)bh->b_data;\n\t\t\t\tbe16_add_cpu(&leaf->lf_entries, 1);\n\t\t\t\tleaf->lf_nsec = cpu_to_be32(tv.tv_nsec);\n\t\t\t\tleaf->lf_sec = cpu_to_be64(tv.tv_sec);\n\t\t\t}\n\t\t\tda->dent = NULL;\n\t\t\tda->bh = NULL;\n\t\t\tbrelse(bh);\n\t\t\tip->i_entries++;\n\t\t\tip->i_inode.i_mtime = ip->i_inode.i_ctime = tv;\n\t\t\tif (S_ISDIR(nip->i_inode.i_mode))\n\t\t\t\tinc_nlink(&ip->i_inode);\n\t\t\tmark_inode_dirty(inode);\n\t\t\terror = 0;\n\t\t\tbreak;\n\t\t}\n\t\tif (!(ip->i_diskflags & GFS2_DIF_EXHASH)) {\n\t\t\terror = dir_make_exhash(inode);\n\t\t\tif (error)\n\t\t\t\tbreak;\n\t\t\tcontinue;\n\t\t}\n\t\terror = dir_split_leaf(inode, name);\n\t\tif (error == 0)\n\t\t\tcontinue;\n\t\tif (error < 0)\n\t\t\tbreak;\n\t\tif (ip->i_depth < GFS2_DIR_MAX_DEPTH) {\n\t\t\terror = dir_double_exhash(ip);\n\t\t\tif (error)\n\t\t\t\tbreak;\n\t\t\terror = dir_split_leaf(inode, name);\n\t\t\tif (error < 0)\n\t\t\t\tbreak;\n\t\t\tif (error == 0)\n\t\t\t\tcontinue;\n\t\t}\n\t\terror = dir_new_leaf(inode, name);\n\t\tif (!error)\n\t\t\tcontinue;\n\t\terror = -ENOSPC;\n\t\tbreak;\n\t}\n\treturn error;\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"bmap.h\"",
            "#include \"trans.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"inode.h\"",
            "#include \"glock.h\"",
            "#include \"dir.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/crc32.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/sort.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"bmap.h\"\n#include \"trans.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"dir.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/vmalloc.h>\n#include <linux/crc32.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/sort.h>\n#include <linux/buffer_head.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nint gfs2_dir_add(struct inode *inode, const struct qstr *name,\n\t\t const struct gfs2_inode *nip, struct gfs2_diradd *da)\n{\n\tstruct gfs2_inode *ip = GFS2_I(inode);\n\tstruct buffer_head *bh = da->bh;\n\tstruct gfs2_dirent *dent = da->dent;\n\tstruct timespec tv;\n\tstruct gfs2_leaf *leaf;\n\tint error;\n\n\twhile(1) {\n\t\tif (da->bh == NULL) {\n\t\t\tdent = gfs2_dirent_search(inode, name,\n\t\t\t\t\t\t  gfs2_dirent_find_space, &bh);\n\t\t}\n\t\tif (dent) {\n\t\t\tif (IS_ERR(dent))\n\t\t\t\treturn PTR_ERR(dent);\n\t\t\tdent = gfs2_init_dirent(inode, dent, name, bh);\n\t\t\tgfs2_inum_out(nip, dent);\n\t\t\tdent->de_type = cpu_to_be16(IF2DT(nip->i_inode.i_mode));\n\t\t\tdent->de_rahead = cpu_to_be16(gfs2_inode_ra_len(nip));\n\t\t\ttv = CURRENT_TIME;\n\t\t\tif (ip->i_diskflags & GFS2_DIF_EXHASH) {\n\t\t\t\tleaf = (struct gfs2_leaf *)bh->b_data;\n\t\t\t\tbe16_add_cpu(&leaf->lf_entries, 1);\n\t\t\t\tleaf->lf_nsec = cpu_to_be32(tv.tv_nsec);\n\t\t\t\tleaf->lf_sec = cpu_to_be64(tv.tv_sec);\n\t\t\t}\n\t\t\tda->dent = NULL;\n\t\t\tda->bh = NULL;\n\t\t\tbrelse(bh);\n\t\t\tip->i_entries++;\n\t\t\tip->i_inode.i_mtime = ip->i_inode.i_ctime = tv;\n\t\t\tif (S_ISDIR(nip->i_inode.i_mode))\n\t\t\t\tinc_nlink(&ip->i_inode);\n\t\t\tmark_inode_dirty(inode);\n\t\t\terror = 0;\n\t\t\tbreak;\n\t\t}\n\t\tif (!(ip->i_diskflags & GFS2_DIF_EXHASH)) {\n\t\t\terror = dir_make_exhash(inode);\n\t\t\tif (error)\n\t\t\t\tbreak;\n\t\t\tcontinue;\n\t\t}\n\t\terror = dir_split_leaf(inode, name);\n\t\tif (error == 0)\n\t\t\tcontinue;\n\t\tif (error < 0)\n\t\t\tbreak;\n\t\tif (ip->i_depth < GFS2_DIR_MAX_DEPTH) {\n\t\t\terror = dir_double_exhash(ip);\n\t\t\tif (error)\n\t\t\t\tbreak;\n\t\t\terror = dir_split_leaf(inode, name);\n\t\t\tif (error < 0)\n\t\t\t\tbreak;\n\t\t\tif (error == 0)\n\t\t\t\tcontinue;\n\t\t}\n\t\terror = dir_new_leaf(inode, name);\n\t\tif (!error)\n\t\t\tcontinue;\n\t\terror = -ENOSPC;\n\t\tbreak;\n\t}\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "gfs2_meta_inode_buffer",
          "args": [
            "ip",
            "&dibh"
          ],
          "line": 973
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_meta_inode_buffer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/meta_io.h",
          "lines": "66-70",
          "snippet": "static inline int gfs2_meta_inode_buffer(struct gfs2_inode *ip,\n\t\t\t\t\t struct buffer_head **bhp)\n{\n\treturn gfs2_meta_indirect_buffer(ip, 0, ip->i_no_addr, bhp);\n}",
          "includes": [
            "#include \"incore.h\"",
            "#include <linux/string.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"incore.h\"\n#include <linux/string.h>\n#include <linux/buffer_head.h>\n\nstatic inline int gfs2_meta_inode_buffer(struct gfs2_inode *ip,\n\t\t\t\t\t struct buffer_head **bhp)\n{\n\treturn gfs2_meta_indirect_buffer(ip, 0, ip->i_no_addr, bhp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "gfs2_trans_begin",
          "args": [
            "sdp",
            "2 * RES_DINODE + RES_LEAF",
            "0"
          ],
          "line": 968
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_trans_begin",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/trans.c",
          "lines": "31-75",
          "snippet": "int gfs2_trans_begin(struct gfs2_sbd *sdp, unsigned int blocks,\n\t\t     unsigned int revokes)\n{\n\tstruct gfs2_trans *tr;\n\tint error;\n\n\tBUG_ON(current->journal_info);\n\tBUG_ON(blocks == 0 && revokes == 0);\n\n\tif (!test_bit(SDF_JOURNAL_LIVE, &sdp->sd_flags))\n\t\treturn -EROFS;\n\n\ttr = kzalloc(sizeof(struct gfs2_trans), GFP_NOFS);\n\tif (!tr)\n\t\treturn -ENOMEM;\n\n\ttr->tr_ip = _RET_IP_;\n\ttr->tr_blocks = blocks;\n\ttr->tr_revokes = revokes;\n\ttr->tr_reserved = 1;\n\ttr->tr_alloced = 1;\n\tif (blocks)\n\t\ttr->tr_reserved += 6 + blocks;\n\tif (revokes)\n\t\ttr->tr_reserved += gfs2_struct2blk(sdp, revokes,\n\t\t\t\t\t\t   sizeof(u64));\n\tINIT_LIST_HEAD(&tr->tr_databuf);\n\tINIT_LIST_HEAD(&tr->tr_buf);\n\n\tsb_start_intwrite(sdp->sd_vfs);\n\n\terror = gfs2_log_reserve(sdp, tr->tr_reserved);\n\tif (error)\n\t\tgoto fail;\n\n\tcurrent->journal_info = tr;\n\n\treturn 0;\n\nfail:\n\tsb_end_intwrite(sdp->sd_vfs);\n\tkfree(tr);\n\n\treturn error;\n}",
          "includes": [
            "#include \"trace_gfs2.h\"",
            "#include \"util.h\"",
            "#include \"trans.h\"",
            "#include \"meta_io.h\"",
            "#include \"lops.h\"",
            "#include \"log.h\"",
            "#include \"inode.h\"",
            "#include \"glock.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"util.h\"\n#include \"trans.h\"\n#include \"meta_io.h\"\n#include \"lops.h\"\n#include \"log.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/gfs2_ondisk.h>\n#include <linux/kallsyms.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nint gfs2_trans_begin(struct gfs2_sbd *sdp, unsigned int blocks,\n\t\t     unsigned int revokes)\n{\n\tstruct gfs2_trans *tr;\n\tint error;\n\n\tBUG_ON(current->journal_info);\n\tBUG_ON(blocks == 0 && revokes == 0);\n\n\tif (!test_bit(SDF_JOURNAL_LIVE, &sdp->sd_flags))\n\t\treturn -EROFS;\n\n\ttr = kzalloc(sizeof(struct gfs2_trans), GFP_NOFS);\n\tif (!tr)\n\t\treturn -ENOMEM;\n\n\ttr->tr_ip = _RET_IP_;\n\ttr->tr_blocks = blocks;\n\ttr->tr_revokes = revokes;\n\ttr->tr_reserved = 1;\n\ttr->tr_alloced = 1;\n\tif (blocks)\n\t\ttr->tr_reserved += 6 + blocks;\n\tif (revokes)\n\t\ttr->tr_reserved += gfs2_struct2blk(sdp, revokes,\n\t\t\t\t\t\t   sizeof(u64));\n\tINIT_LIST_HEAD(&tr->tr_databuf);\n\tINIT_LIST_HEAD(&tr->tr_buf);\n\n\tsb_start_intwrite(sdp->sd_vfs);\n\n\terror = gfs2_log_reserve(sdp, tr->tr_reserved);\n\tif (error)\n\t\tgoto fail;\n\n\tcurrent->journal_info = tr;\n\n\treturn 0;\n\nfail:\n\tsb_end_intwrite(sdp->sd_vfs);\n\tkfree(tr);\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "gfs2_trans_da_blks",
          "args": [
            "dip",
            "&da",
            "2"
          ],
          "line": 964
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_trans_da_blks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/inode.c",
          "lines": "512-518",
          "snippet": "static unsigned gfs2_trans_da_blks(const struct gfs2_inode *dip,\n\t\t\t\t   const struct gfs2_diradd *da,\n\t\t\t\t   unsigned nr_inodes)\n{\n\treturn da->nr_blocks + gfs2_rg_blocks(dip, da->nr_blocks) +\n\t       (nr_inodes * RES_DINODE) + RES_QUOTA + RES_STATFS;\n}",
          "includes": [
            "#include \"glops.h\"",
            "#include \"super.h\"",
            "#include \"util.h\"",
            "#include \"trans.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"inode.h\"",
            "#include \"glock.h\"",
            "#include \"xattr.h\"",
            "#include \"dir.h\"",
            "#include \"bmap.h\"",
            "#include \"acl.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/security.h>",
            "#include <linux/fiemap.h>",
            "#include <linux/crc32.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/xattr.h>",
            "#include <linux/mm.h>",
            "#include <linux/namei.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glops.h\"\n#include \"super.h\"\n#include \"util.h\"\n#include \"trans.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"xattr.h\"\n#include \"dir.h\"\n#include \"bmap.h\"\n#include \"acl.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <asm/uaccess.h>\n#include <linux/security.h>\n#include <linux/fiemap.h>\n#include <linux/crc32.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/posix_acl.h>\n#include <linux/xattr.h>\n#include <linux/mm.h>\n#include <linux/namei.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nstatic unsigned gfs2_trans_da_blks(const struct gfs2_inode *dip,\n\t\t\t\t   const struct gfs2_diradd *da,\n\t\t\t\t   unsigned nr_inodes)\n{\n\treturn da->nr_blocks + gfs2_rg_blocks(dip, da->nr_blocks) +\n\t       (nr_inodes * RES_DINODE) + RES_QUOTA + RES_STATFS;\n}"
        }
      },
      {
        "call_info": {
          "callee": "gfs2_inplace_reserve",
          "args": [
            "dip",
            "&ap"
          ],
          "line": 960
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_inplace_reserve",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/rgrp.c",
          "lines": "1952-2072",
          "snippet": "int gfs2_inplace_reserve(struct gfs2_inode *ip, const struct gfs2_alloc_parms *ap)\n{\n\tstruct gfs2_sbd *sdp = GFS2_SB(&ip->i_inode);\n\tstruct gfs2_rgrpd *begin = NULL;\n\tstruct gfs2_blkreserv *rs = ip->i_res;\n\tint error = 0, rg_locked, flags = 0;\n\tu64 last_unlinked = NO_BLOCK;\n\tint loops = 0;\n\tu32 skip = 0;\n\n\tif (sdp->sd_args.ar_rgrplvb)\n\t\tflags |= GL_SKIP;\n\tif (gfs2_assert_warn(sdp, ap->target))\n\t\treturn -EINVAL;\n\tif (gfs2_rs_active(rs)) {\n\t\tbegin = rs->rs_rbm.rgd;\n\t} else if (ip->i_rgd && rgrp_contains_block(ip->i_rgd, ip->i_goal)) {\n\t\trs->rs_rbm.rgd = begin = ip->i_rgd;\n\t} else {\n\t\tcheck_and_update_goal(ip);\n\t\trs->rs_rbm.rgd = begin = gfs2_blk2rgrpd(sdp, ip->i_goal, 1);\n\t}\n\tif (S_ISDIR(ip->i_inode.i_mode) && (ap->aflags & GFS2_AF_ORLOV))\n\t\tskip = gfs2_orlov_skip(ip);\n\tif (rs->rs_rbm.rgd == NULL)\n\t\treturn -EBADSLT;\n\n\twhile (loops < 3) {\n\t\trg_locked = 1;\n\n\t\tif (!gfs2_glock_is_locked_by_me(rs->rs_rbm.rgd->rd_gl)) {\n\t\t\trg_locked = 0;\n\t\t\tif (skip && skip--)\n\t\t\t\tgoto next_rgrp;\n\t\t\tif (!gfs2_rs_active(rs)) {\n\t\t\t\tif (loops == 0 &&\n\t\t\t\t    !fast_to_acquire(rs->rs_rbm.rgd))\n\t\t\t\t\tgoto next_rgrp;\n\t\t\t\tif ((loops < 2) &&\n\t\t\t\t    gfs2_rgrp_used_recently(rs, 1000) &&\n\t\t\t\t    gfs2_rgrp_congested(rs->rs_rbm.rgd, loops))\n\t\t\t\t\tgoto next_rgrp;\n\t\t\t}\n\t\t\terror = gfs2_glock_nq_init(rs->rs_rbm.rgd->rd_gl,\n\t\t\t\t\t\t   LM_ST_EXCLUSIVE, flags,\n\t\t\t\t\t\t   &rs->rs_rgd_gh);\n\t\t\tif (unlikely(error))\n\t\t\t\treturn error;\n\t\t\tif (!gfs2_rs_active(rs) && (loops < 2) &&\n\t\t\t    gfs2_rgrp_congested(rs->rs_rbm.rgd, loops))\n\t\t\t\tgoto skip_rgrp;\n\t\t\tif (sdp->sd_args.ar_rgrplvb) {\n\t\t\t\terror = update_rgrp_lvb(rs->rs_rbm.rgd);\n\t\t\t\tif (unlikely(error)) {\n\t\t\t\t\tgfs2_glock_dq_uninit(&rs->rs_rgd_gh);\n\t\t\t\t\treturn error;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t/* Skip unuseable resource groups */\n\t\tif ((rs->rs_rbm.rgd->rd_flags & (GFS2_RGF_NOALLOC |\n\t\t\t\t\t\t GFS2_RDF_ERROR)) ||\n\t\t    (ap->target > rs->rs_rbm.rgd->rd_extfail_pt))\n\t\t\tgoto skip_rgrp;\n\n\t\tif (sdp->sd_args.ar_rgrplvb)\n\t\t\tgfs2_rgrp_bh_get(rs->rs_rbm.rgd);\n\n\t\t/* Get a reservation if we don't already have one */\n\t\tif (!gfs2_rs_active(rs))\n\t\t\trg_mblk_search(rs->rs_rbm.rgd, ip, ap);\n\n\t\t/* Skip rgrps when we can't get a reservation on first pass */\n\t\tif (!gfs2_rs_active(rs) && (loops < 1))\n\t\t\tgoto check_rgrp;\n\n\t\t/* If rgrp has enough free space, use it */\n\t\tif (rs->rs_rbm.rgd->rd_free_clone >= ap->target) {\n\t\t\tip->i_rgd = rs->rs_rbm.rgd;\n\t\t\treturn 0;\n\t\t}\n\ncheck_rgrp:\n\t\t/* Check for unlinked inodes which can be reclaimed */\n\t\tif (rs->rs_rbm.rgd->rd_flags & GFS2_RDF_CHECK)\n\t\t\ttry_rgrp_unlink(rs->rs_rbm.rgd, &last_unlinked,\n\t\t\t\t\tip->i_no_addr);\nskip_rgrp:\n\t\t/* Drop reservation, if we couldn't use reserved rgrp */\n\t\tif (gfs2_rs_active(rs))\n\t\t\tgfs2_rs_deltree(rs);\n\n\t\t/* Unlock rgrp if required */\n\t\tif (!rg_locked)\n\t\t\tgfs2_glock_dq_uninit(&rs->rs_rgd_gh);\nnext_rgrp:\n\t\t/* Find the next rgrp, and continue looking */\n\t\tif (gfs2_select_rgrp(&rs->rs_rbm.rgd, begin))\n\t\t\tcontinue;\n\t\tif (skip)\n\t\t\tcontinue;\n\n\t\t/* If we've scanned all the rgrps, but found no free blocks\n\t\t * then this checks for some less likely conditions before\n\t\t * trying again.\n\t\t */\n\t\tloops++;\n\t\t/* Check that fs hasn't grown if writing to rindex */\n\t\tif (ip == GFS2_I(sdp->sd_rindex) && !sdp->sd_rindex_uptodate) {\n\t\t\terror = gfs2_ri_update(ip);\n\t\t\tif (error)\n\t\t\t\treturn error;\n\t\t}\n\t\t/* Flushing the log may release space */\n\t\tif (loops == 2)\n\t\t\tgfs2_log_flush(sdp, NULL, NORMAL_FLUSH);\n\t}\n\n\treturn -ENOSPC;\n}",
          "includes": [
            "#include \"trace_gfs2.h\"",
            "#include \"inode.h\"",
            "#include \"log.h\"",
            "#include \"util.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"lops.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/random.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/fs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [
            "#define NO_BLOCK ((u64)~0)"
          ],
          "globals_used": [
            "static int gfs2_rbm_find(struct gfs2_rbm *rbm, u8 state, u32 *minext,\n\t\t\t const struct gfs2_inode *ip, bool nowrap,\n\t\t\t const struct gfs2_alloc_parms *ap);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"inode.h\"\n#include \"log.h\"\n#include \"util.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"lops.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/random.h>\n#include <linux/rbtree.h>\n#include <linux/blkdev.h>\n#include <linux/prefetch.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/fs.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\n#define NO_BLOCK ((u64)~0)\n\nstatic int gfs2_rbm_find(struct gfs2_rbm *rbm, u8 state, u32 *minext,\n\t\t\t const struct gfs2_inode *ip, bool nowrap,\n\t\t\t const struct gfs2_alloc_parms *ap);\n\nint gfs2_inplace_reserve(struct gfs2_inode *ip, const struct gfs2_alloc_parms *ap)\n{\n\tstruct gfs2_sbd *sdp = GFS2_SB(&ip->i_inode);\n\tstruct gfs2_rgrpd *begin = NULL;\n\tstruct gfs2_blkreserv *rs = ip->i_res;\n\tint error = 0, rg_locked, flags = 0;\n\tu64 last_unlinked = NO_BLOCK;\n\tint loops = 0;\n\tu32 skip = 0;\n\n\tif (sdp->sd_args.ar_rgrplvb)\n\t\tflags |= GL_SKIP;\n\tif (gfs2_assert_warn(sdp, ap->target))\n\t\treturn -EINVAL;\n\tif (gfs2_rs_active(rs)) {\n\t\tbegin = rs->rs_rbm.rgd;\n\t} else if (ip->i_rgd && rgrp_contains_block(ip->i_rgd, ip->i_goal)) {\n\t\trs->rs_rbm.rgd = begin = ip->i_rgd;\n\t} else {\n\t\tcheck_and_update_goal(ip);\n\t\trs->rs_rbm.rgd = begin = gfs2_blk2rgrpd(sdp, ip->i_goal, 1);\n\t}\n\tif (S_ISDIR(ip->i_inode.i_mode) && (ap->aflags & GFS2_AF_ORLOV))\n\t\tskip = gfs2_orlov_skip(ip);\n\tif (rs->rs_rbm.rgd == NULL)\n\t\treturn -EBADSLT;\n\n\twhile (loops < 3) {\n\t\trg_locked = 1;\n\n\t\tif (!gfs2_glock_is_locked_by_me(rs->rs_rbm.rgd->rd_gl)) {\n\t\t\trg_locked = 0;\n\t\t\tif (skip && skip--)\n\t\t\t\tgoto next_rgrp;\n\t\t\tif (!gfs2_rs_active(rs)) {\n\t\t\t\tif (loops == 0 &&\n\t\t\t\t    !fast_to_acquire(rs->rs_rbm.rgd))\n\t\t\t\t\tgoto next_rgrp;\n\t\t\t\tif ((loops < 2) &&\n\t\t\t\t    gfs2_rgrp_used_recently(rs, 1000) &&\n\t\t\t\t    gfs2_rgrp_congested(rs->rs_rbm.rgd, loops))\n\t\t\t\t\tgoto next_rgrp;\n\t\t\t}\n\t\t\terror = gfs2_glock_nq_init(rs->rs_rbm.rgd->rd_gl,\n\t\t\t\t\t\t   LM_ST_EXCLUSIVE, flags,\n\t\t\t\t\t\t   &rs->rs_rgd_gh);\n\t\t\tif (unlikely(error))\n\t\t\t\treturn error;\n\t\t\tif (!gfs2_rs_active(rs) && (loops < 2) &&\n\t\t\t    gfs2_rgrp_congested(rs->rs_rbm.rgd, loops))\n\t\t\t\tgoto skip_rgrp;\n\t\t\tif (sdp->sd_args.ar_rgrplvb) {\n\t\t\t\terror = update_rgrp_lvb(rs->rs_rbm.rgd);\n\t\t\t\tif (unlikely(error)) {\n\t\t\t\t\tgfs2_glock_dq_uninit(&rs->rs_rgd_gh);\n\t\t\t\t\treturn error;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t/* Skip unuseable resource groups */\n\t\tif ((rs->rs_rbm.rgd->rd_flags & (GFS2_RGF_NOALLOC |\n\t\t\t\t\t\t GFS2_RDF_ERROR)) ||\n\t\t    (ap->target > rs->rs_rbm.rgd->rd_extfail_pt))\n\t\t\tgoto skip_rgrp;\n\n\t\tif (sdp->sd_args.ar_rgrplvb)\n\t\t\tgfs2_rgrp_bh_get(rs->rs_rbm.rgd);\n\n\t\t/* Get a reservation if we don't already have one */\n\t\tif (!gfs2_rs_active(rs))\n\t\t\trg_mblk_search(rs->rs_rbm.rgd, ip, ap);\n\n\t\t/* Skip rgrps when we can't get a reservation on first pass */\n\t\tif (!gfs2_rs_active(rs) && (loops < 1))\n\t\t\tgoto check_rgrp;\n\n\t\t/* If rgrp has enough free space, use it */\n\t\tif (rs->rs_rbm.rgd->rd_free_clone >= ap->target) {\n\t\t\tip->i_rgd = rs->rs_rbm.rgd;\n\t\t\treturn 0;\n\t\t}\n\ncheck_rgrp:\n\t\t/* Check for unlinked inodes which can be reclaimed */\n\t\tif (rs->rs_rbm.rgd->rd_flags & GFS2_RDF_CHECK)\n\t\t\ttry_rgrp_unlink(rs->rs_rbm.rgd, &last_unlinked,\n\t\t\t\t\tip->i_no_addr);\nskip_rgrp:\n\t\t/* Drop reservation, if we couldn't use reserved rgrp */\n\t\tif (gfs2_rs_active(rs))\n\t\t\tgfs2_rs_deltree(rs);\n\n\t\t/* Unlock rgrp if required */\n\t\tif (!rg_locked)\n\t\t\tgfs2_glock_dq_uninit(&rs->rs_rgd_gh);\nnext_rgrp:\n\t\t/* Find the next rgrp, and continue looking */\n\t\tif (gfs2_select_rgrp(&rs->rs_rbm.rgd, begin))\n\t\t\tcontinue;\n\t\tif (skip)\n\t\t\tcontinue;\n\n\t\t/* If we've scanned all the rgrps, but found no free blocks\n\t\t * then this checks for some less likely conditions before\n\t\t * trying again.\n\t\t */\n\t\tloops++;\n\t\t/* Check that fs hasn't grown if writing to rindex */\n\t\tif (ip == GFS2_I(sdp->sd_rindex) && !sdp->sd_rindex_uptodate) {\n\t\t\terror = gfs2_ri_update(ip);\n\t\t\tif (error)\n\t\t\t\treturn error;\n\t\t}\n\t\t/* Flushing the log may release space */\n\t\tif (loops == 2)\n\t\t\tgfs2_log_flush(sdp, NULL, NORMAL_FLUSH);\n\t}\n\n\treturn -ENOSPC;\n}"
        }
      },
      {
        "call_info": {
          "callee": "gfs2_quota_lock_check",
          "args": [
            "dip"
          ],
          "line": 956
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_quota_lock_check",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/quota.h",
          "lines": "40-55",
          "snippet": "static inline int gfs2_quota_lock_check(struct gfs2_inode *ip)\n{\n\tstruct gfs2_sbd *sdp = GFS2_SB(&ip->i_inode);\n\tint ret;\n\tif (sdp->sd_args.ar_quota == GFS2_QUOTA_OFF)\n\t\treturn 0;\n\tret = gfs2_quota_lock(ip, NO_UID_QUOTA_CHANGE, NO_GID_QUOTA_CHANGE);\n\tif (ret)\n\t\treturn ret;\n\tif (sdp->sd_args.ar_quota != GFS2_QUOTA_ON)\n\t\treturn 0;\n\tret = gfs2_quota_check(ip, ip->i_inode.i_uid, ip->i_inode.i_gid);\n\tif (ret)\n\t\tgfs2_quota_unlock(ip);\n\treturn ret;\n}",
          "includes": [
            "#include <linux/list_lru.h>"
          ],
          "macros_used": [
            "#define NO_GID_QUOTA_CHANGE INVALID_GID",
            "#define NO_UID_QUOTA_CHANGE INVALID_UID"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/list_lru.h>\n\n#define NO_GID_QUOTA_CHANGE INVALID_GID\n#define NO_UID_QUOTA_CHANGE INVALID_UID\n\nstatic inline int gfs2_quota_lock_check(struct gfs2_inode *ip)\n{\n\tstruct gfs2_sbd *sdp = GFS2_SB(&ip->i_inode);\n\tint ret;\n\tif (sdp->sd_args.ar_quota == GFS2_QUOTA_OFF)\n\t\treturn 0;\n\tret = gfs2_quota_lock(ip, NO_UID_QUOTA_CHANGE, NO_GID_QUOTA_CHANGE);\n\tif (ret)\n\t\treturn ret;\n\tif (sdp->sd_args.ar_quota != GFS2_QUOTA_ON)\n\t\treturn 0;\n\tret = gfs2_quota_check(ip, ip->i_inode.i_uid, ip->i_inode.i_gid);\n\tif (ret)\n\t\tgfs2_quota_unlock(ip);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "gfs2_diradd_alloc_required",
          "args": [
            "dir",
            "&dentry->d_name",
            "&da"
          ],
          "line": 950
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_diradd_alloc_required",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/dir.c",
          "lines": "2058-2089",
          "snippet": "int gfs2_diradd_alloc_required(struct inode *inode, const struct qstr *name,\n\t\t\t       struct gfs2_diradd *da)\n{\n\tstruct gfs2_inode *ip = GFS2_I(inode);\n\tstruct gfs2_sbd *sdp = GFS2_SB(inode);\n\tconst unsigned int extra = sizeof(struct gfs2_dinode) - sizeof(struct gfs2_leaf);\n\tstruct gfs2_dirent *dent;\n\tstruct buffer_head *bh;\n\n\tda->nr_blocks = 0;\n\tda->bh = NULL;\n\tda->dent = NULL;\n\n\tdent = gfs2_dirent_search(inode, name, gfs2_dirent_find_space, &bh);\n\tif (!dent) {\n\t\tda->nr_blocks = sdp->sd_max_dirres;\n\t\tif (!(ip->i_diskflags & GFS2_DIF_EXHASH) &&\n\t\t    (GFS2_DIRENT_SIZE(name->len) < extra))\n\t\t\tda->nr_blocks = 1;\n\t\treturn 0;\n\t}\n\tif (IS_ERR(dent))\n\t\treturn PTR_ERR(dent);\n\n\tif (da->save_loc) {\n\t\tda->bh = bh;\n\t\tda->dent = dent;\n\t} else {\n\t\tbrelse(bh);\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"bmap.h\"",
            "#include \"trans.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"inode.h\"",
            "#include \"glock.h\"",
            "#include \"dir.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/crc32.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/sort.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"bmap.h\"\n#include \"trans.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"dir.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/vmalloc.h>\n#include <linux/crc32.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/sort.h>\n#include <linux/buffer_head.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nint gfs2_diradd_alloc_required(struct inode *inode, const struct qstr *name,\n\t\t\t       struct gfs2_diradd *da)\n{\n\tstruct gfs2_inode *ip = GFS2_I(inode);\n\tstruct gfs2_sbd *sdp = GFS2_SB(inode);\n\tconst unsigned int extra = sizeof(struct gfs2_dinode) - sizeof(struct gfs2_leaf);\n\tstruct gfs2_dirent *dent;\n\tstruct buffer_head *bh;\n\n\tda->nr_blocks = 0;\n\tda->bh = NULL;\n\tda->dent = NULL;\n\n\tdent = gfs2_dirent_search(inode, name, gfs2_dirent_find_space, &bh);\n\tif (!dent) {\n\t\tda->nr_blocks = sdp->sd_max_dirres;\n\t\tif (!(ip->i_diskflags & GFS2_DIF_EXHASH) &&\n\t\t    (GFS2_DIRENT_SIZE(name->len) < extra))\n\t\t\tda->nr_blocks = 1;\n\t\treturn 0;\n\t}\n\tif (IS_ERR(dent))\n\t\treturn PTR_ERR(dent);\n\n\tif (da->save_loc) {\n\t\tda->bh = bh;\n\t\tda->dent = dent;\n\t} else {\n\t\tbrelse(bh);\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_APPEND",
          "args": [
            "inode"
          ],
          "line": 941
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_IMMUTABLE",
          "args": [
            "inode"
          ],
          "line": 941
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gfs2_dir_check",
          "args": [
            "dir",
            "&dentry->d_name",
            "NULL"
          ],
          "line": 924
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_dir_check",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/dir.c",
          "lines": "1571-1600",
          "snippet": "int gfs2_dir_check(struct inode *dir, const struct qstr *name,\n\t\t   const struct gfs2_inode *ip)\n{\n\tstruct buffer_head *bh;\n\tstruct gfs2_dirent *dent;\n\tint ret = -ENOENT;\n\n\tdent = gfs2_dirent_search(dir, name, gfs2_dirent_find, &bh);\n\tif (dent) {\n\t\tif (IS_ERR(dent))\n\t\t\treturn PTR_ERR(dent);\n\t\tif (ip) {\n\t\t\tif (be64_to_cpu(dent->de_inum.no_addr) != ip->i_no_addr)\n\t\t\t\tgoto out;\n\t\t\tif (be64_to_cpu(dent->de_inum.no_formal_ino) !=\n\t\t\t    ip->i_no_formal_ino)\n\t\t\t\tgoto out;\n\t\t\tif (unlikely(IF2DT(ip->i_inode.i_mode) !=\n\t\t\t    be16_to_cpu(dent->de_type))) {\n\t\t\t\tgfs2_consist_inode(GFS2_I(dir));\n\t\t\t\tret = -EIO;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\t\tret = 0;\nout:\n\t\tbrelse(bh);\n\t}\n\treturn ret;\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"bmap.h\"",
            "#include \"trans.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"inode.h\"",
            "#include \"glock.h\"",
            "#include \"dir.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/crc32.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/sort.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"bmap.h\"\n#include \"trans.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"dir.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/vmalloc.h>\n#include <linux/crc32.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/sort.h>\n#include <linux/buffer_head.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nint gfs2_dir_check(struct inode *dir, const struct qstr *name,\n\t\t   const struct gfs2_inode *ip)\n{\n\tstruct buffer_head *bh;\n\tstruct gfs2_dirent *dent;\n\tint ret = -ENOENT;\n\n\tdent = gfs2_dirent_search(dir, name, gfs2_dirent_find, &bh);\n\tif (dent) {\n\t\tif (IS_ERR(dent))\n\t\t\treturn PTR_ERR(dent);\n\t\tif (ip) {\n\t\t\tif (be64_to_cpu(dent->de_inum.no_addr) != ip->i_no_addr)\n\t\t\t\tgoto out;\n\t\t\tif (be64_to_cpu(dent->de_inum.no_formal_ino) !=\n\t\t\t    ip->i_no_formal_ino)\n\t\t\t\tgoto out;\n\t\t\tif (unlikely(IF2DT(ip->i_inode.i_mode) !=\n\t\t\t    be16_to_cpu(dent->de_type))) {\n\t\t\t\tgfs2_consist_inode(GFS2_I(dir));\n\t\t\t\tret = -EIO;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\t\tret = 0;\nout:\n\t\tbrelse(bh);\n\t}\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "gfs2_permission",
          "args": [
            "dir",
            "MAY_WRITE | MAY_EXEC"
          ],
          "line": 920
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_permission",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/inode.c",
          "lines": "1606-1632",
          "snippet": "int gfs2_permission(struct inode *inode, int mask)\n{\n\tstruct gfs2_inode *ip;\n\tstruct gfs2_holder i_gh;\n\tint error;\n\tint unlock = 0;\n\n\n\tip = GFS2_I(inode);\n\tif (gfs2_glock_is_locked_by_me(ip->i_gl) == NULL) {\n\t\tif (mask & MAY_NOT_BLOCK)\n\t\t\treturn -ECHILD;\n\t\terror = gfs2_glock_nq_init(ip->i_gl, LM_ST_SHARED, LM_FLAG_ANY, &i_gh);\n\t\tif (error)\n\t\t\treturn error;\n\t\tunlock = 1;\n\t}\n\n\tif ((mask & MAY_WRITE) && IS_IMMUTABLE(inode))\n\t\terror = -EACCES;\n\telse\n\t\terror = generic_permission(inode, mask);\n\tif (unlock)\n\t\tgfs2_glock_dq_uninit(&i_gh);\n\n\treturn error;\n}",
          "includes": [
            "#include \"glops.h\"",
            "#include \"super.h\"",
            "#include \"util.h\"",
            "#include \"trans.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"inode.h\"",
            "#include \"glock.h\"",
            "#include \"xattr.h\"",
            "#include \"dir.h\"",
            "#include \"bmap.h\"",
            "#include \"acl.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/security.h>",
            "#include <linux/fiemap.h>",
            "#include <linux/crc32.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/xattr.h>",
            "#include <linux/mm.h>",
            "#include <linux/namei.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glops.h\"\n#include \"super.h\"\n#include \"util.h\"\n#include \"trans.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"xattr.h\"\n#include \"dir.h\"\n#include \"bmap.h\"\n#include \"acl.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <asm/uaccess.h>\n#include <linux/security.h>\n#include <linux/fiemap.h>\n#include <linux/crc32.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/posix_acl.h>\n#include <linux/xattr.h>\n#include <linux/mm.h>\n#include <linux/namei.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nint gfs2_permission(struct inode *inode, int mask)\n{\n\tstruct gfs2_inode *ip;\n\tstruct gfs2_holder i_gh;\n\tint error;\n\tint unlock = 0;\n\n\n\tip = GFS2_I(inode);\n\tif (gfs2_glock_is_locked_by_me(ip->i_gl) == NULL) {\n\t\tif (mask & MAY_NOT_BLOCK)\n\t\t\treturn -ECHILD;\n\t\terror = gfs2_glock_nq_init(ip->i_gl, LM_ST_SHARED, LM_FLAG_ANY, &i_gh);\n\t\tif (error)\n\t\t\treturn error;\n\t\tunlock = 1;\n\t}\n\n\tif ((mask & MAY_WRITE) && IS_IMMUTABLE(inode))\n\t\terror = -EACCES;\n\telse\n\t\terror = generic_permission(inode, mask);\n\tif (unlock)\n\t\tgfs2_glock_dq_uninit(&i_gh);\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "gfs2_glock_nq",
          "args": [
            "ghs + 1"
          ],
          "line": 912
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_glock_nq",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/glock.c",
          "lines": "1006-1034",
          "snippet": "int gfs2_glock_nq(struct gfs2_holder *gh)\n{\n\tstruct gfs2_glock *gl = gh->gh_gl;\n\tstruct gfs2_sbd *sdp = gl->gl_sbd;\n\tint error = 0;\n\n\tif (unlikely(test_bit(SDF_SHUTDOWN, &sdp->sd_flags)))\n\t\treturn -EIO;\n\n\tif (test_bit(GLF_LRU, &gl->gl_flags))\n\t\tgfs2_glock_remove_from_lru(gl);\n\n\tspin_lock(&gl->gl_spin);\n\tadd_to_queue(gh);\n\tif (unlikely((LM_FLAG_NOEXP & gh->gh_flags) &&\n\t\t     test_and_clear_bit(GLF_FROZEN, &gl->gl_flags))) {\n\t\tset_bit(GLF_REPLY_PENDING, &gl->gl_flags);\n\t\tgl->gl_lockref.count++;\n\t\tif (queue_delayed_work(glock_workqueue, &gl->gl_work, 0) == 0)\n\t\t\tgl->gl_lockref.count--;\n\t}\n\trun_queue(gl, 1);\n\tspin_unlock(&gl->gl_spin);\n\n\tif (!(gh->gh_flags & GL_ASYNC))\n\t\terror = gfs2_glock_wait(gh);\n\n\treturn error;\n}",
          "includes": [
            "#include \"trace_gfs2.h\"",
            "#include \"bmap.h\"",
            "#include \"util.h\"",
            "#include \"super.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"lops.h\"",
            "#include \"inode.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/lockref.h>",
            "#include <linux/list_sort.h>",
            "#include <linux/percpu.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/seq_file.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/module.h>",
            "#include <linux/wait.h>",
            "#include <linux/list.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/jhash.h>",
            "#include <linux/sort.h>",
            "#include <linux/delay.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct workqueue_struct *glock_workqueue;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"bmap.h\"\n#include \"util.h\"\n#include \"super.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"lops.h\"\n#include \"inode.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/lockref.h>\n#include <linux/list_sort.h>\n#include <linux/percpu.h>\n#include <linux/bit_spinlock.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/jiffies.h>\n#include <linux/workqueue.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <asm/uaccess.h>\n#include <linux/module.h>\n#include <linux/wait.h>\n#include <linux/list.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/kallsyms.h>\n#include <linux/jhash.h>\n#include <linux/sort.h>\n#include <linux/delay.h>\n#include <linux/buffer_head.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic struct workqueue_struct *glock_workqueue;\n\nint gfs2_glock_nq(struct gfs2_holder *gh)\n{\n\tstruct gfs2_glock *gl = gh->gh_gl;\n\tstruct gfs2_sbd *sdp = gl->gl_sbd;\n\tint error = 0;\n\n\tif (unlikely(test_bit(SDF_SHUTDOWN, &sdp->sd_flags)))\n\t\treturn -EIO;\n\n\tif (test_bit(GLF_LRU, &gl->gl_flags))\n\t\tgfs2_glock_remove_from_lru(gl);\n\n\tspin_lock(&gl->gl_spin);\n\tadd_to_queue(gh);\n\tif (unlikely((LM_FLAG_NOEXP & gh->gh_flags) &&\n\t\t     test_and_clear_bit(GLF_FROZEN, &gl->gl_flags))) {\n\t\tset_bit(GLF_REPLY_PENDING, &gl->gl_flags);\n\t\tgl->gl_lockref.count++;\n\t\tif (queue_delayed_work(glock_workqueue, &gl->gl_work, 0) == 0)\n\t\t\tgl->gl_lockref.count--;\n\t}\n\trun_queue(gl, 1);\n\tspin_unlock(&gl->gl_spin);\n\n\tif (!(gh->gh_flags & GL_ASYNC))\n\t\terror = gfs2_glock_wait(gh);\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "gfs2_holder_init",
          "args": [
            "ip->i_gl",
            "LM_ST_EXCLUSIVE",
            "0",
            "ghs + 1"
          ],
          "line": 906
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_holder_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/glock.c",
          "lines": "801-813",
          "snippet": "void gfs2_holder_init(struct gfs2_glock *gl, unsigned int state, unsigned flags,\n\t\t      struct gfs2_holder *gh)\n{\n\tINIT_LIST_HEAD(&gh->gh_list);\n\tgh->gh_gl = gl;\n\tgh->gh_ip = _RET_IP_;\n\tgh->gh_owner_pid = get_pid(task_pid(current));\n\tgh->gh_state = state;\n\tgh->gh_flags = flags;\n\tgh->gh_error = 0;\n\tgh->gh_iflags = 0;\n\tgfs2_glock_hold(gl);\n}",
          "includes": [
            "#include \"trace_gfs2.h\"",
            "#include \"bmap.h\"",
            "#include \"util.h\"",
            "#include \"super.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"lops.h\"",
            "#include \"inode.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/lockref.h>",
            "#include <linux/list_sort.h>",
            "#include <linux/percpu.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/seq_file.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/module.h>",
            "#include <linux/wait.h>",
            "#include <linux/list.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/jhash.h>",
            "#include <linux/sort.h>",
            "#include <linux/delay.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"bmap.h\"\n#include \"util.h\"\n#include \"super.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"lops.h\"\n#include \"inode.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/lockref.h>\n#include <linux/list_sort.h>\n#include <linux/percpu.h>\n#include <linux/bit_spinlock.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/jiffies.h>\n#include <linux/workqueue.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <asm/uaccess.h>\n#include <linux/module.h>\n#include <linux/wait.h>\n#include <linux/list.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/kallsyms.h>\n#include <linux/jhash.h>\n#include <linux/sort.h>\n#include <linux/delay.h>\n#include <linux/buffer_head.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nvoid gfs2_holder_init(struct gfs2_glock *gl, unsigned int state, unsigned flags,\n\t\t      struct gfs2_holder *gh)\n{\n\tINIT_LIST_HEAD(&gh->gh_list);\n\tgh->gh_gl = gl;\n\tgh->gh_ip = _RET_IP_;\n\tgh->gh_owner_pid = get_pid(task_pid(current));\n\tgh->gh_state = state;\n\tgh->gh_flags = flags;\n\tgh->gh_error = 0;\n\tgh->gh_iflags = 0;\n\tgfs2_glock_hold(gl);\n}"
        }
      },
      {
        "call_info": {
          "callee": "gfs2_rs_alloc",
          "args": [
            "dip"
          ],
          "line": 901
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_rs_alloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/rgrp.c",
          "lines": "602-620",
          "snippet": "int gfs2_rs_alloc(struct gfs2_inode *ip)\n{\n\tint error = 0;\n\n\tdown_write(&ip->i_rw_mutex);\n\tif (ip->i_res)\n\t\tgoto out;\n\n\tip->i_res = kmem_cache_zalloc(gfs2_rsrv_cachep, GFP_NOFS);\n\tif (!ip->i_res) {\n\t\terror = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tRB_CLEAR_NODE(&ip->i_res->rs_node);\nout:\n\tup_write(&ip->i_rw_mutex);\n\treturn error;\n}",
          "includes": [
            "#include \"trace_gfs2.h\"",
            "#include \"inode.h\"",
            "#include \"log.h\"",
            "#include \"util.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"lops.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/random.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/fs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"inode.h\"\n#include \"log.h\"\n#include \"util.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"lops.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/random.h>\n#include <linux/rbtree.h>\n#include <linux/blkdev.h>\n#include <linux/prefetch.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/fs.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nint gfs2_rs_alloc(struct gfs2_inode *ip)\n{\n\tint error = 0;\n\n\tdown_write(&ip->i_rw_mutex);\n\tif (ip->i_res)\n\t\tgoto out;\n\n\tip->i_res = kmem_cache_zalloc(gfs2_rsrv_cachep, GFP_NOFS);\n\tif (!ip->i_res) {\n\t\terror = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tRB_CLEAR_NODE(&ip->i_res->rs_node);\nout:\n\tup_write(&ip->i_rw_mutex);\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "S_ISDIR",
          "args": [
            "inode->i_mode"
          ],
          "line": 898
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GFS2_I",
          "args": [
            "inode"
          ],
          "line": 892
        },
        "resolved": true,
        "details": {
          "function_name": "GFS2_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/incore.h",
          "lines": "408-411",
          "snippet": "static inline struct gfs2_inode *GFS2_I(struct inode *inode)\n{\n\treturn container_of(inode, struct gfs2_inode, i_inode);\n}",
          "includes": [
            "#include <linux/lockref.h>",
            "#include <linux/percpu.h>",
            "#include <linux/ktime.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/completion.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/dlm.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/kobject.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/lockref.h>\n#include <linux/percpu.h>\n#include <linux/ktime.h>\n#include <linux/rbtree.h>\n#include <linux/completion.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/buffer_head.h>\n#include <linux/dlm.h>\n#include <linux/workqueue.h>\n#include <linux/kobject.h>\n#include <linux/fs.h>\n\nstatic inline struct gfs2_inode *GFS2_I(struct inode *inode)\n{\n\treturn container_of(inode, struct gfs2_inode, i_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "GFS2_SB",
          "args": [
            "dir"
          ],
          "line": 890
        },
        "resolved": true,
        "details": {
          "function_name": "GFS2_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/incore.h",
          "lines": "413-416",
          "snippet": "static inline struct gfs2_sbd *GFS2_SB(const struct inode *inode)\n{\n\treturn inode->i_sb->s_fs_info;\n}",
          "includes": [
            "#include <linux/lockref.h>",
            "#include <linux/percpu.h>",
            "#include <linux/ktime.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/completion.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/dlm.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/kobject.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/lockref.h>\n#include <linux/percpu.h>\n#include <linux/ktime.h>\n#include <linux/rbtree.h>\n#include <linux/completion.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/buffer_head.h>\n#include <linux/dlm.h>\n#include <linux/workqueue.h>\n#include <linux/kobject.h>\n#include <linux/fs.h>\n\nstatic inline struct gfs2_sbd *GFS2_SB(const struct inode *inode)\n{\n\treturn inode->i_sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"glops.h\"\n#include \"super.h\"\n#include \"util.h\"\n#include \"trans.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"xattr.h\"\n#include \"dir.h\"\n#include \"bmap.h\"\n#include \"acl.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <asm/uaccess.h>\n#include <linux/security.h>\n#include <linux/fiemap.h>\n#include <linux/crc32.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/posix_acl.h>\n#include <linux/xattr.h>\n#include <linux/mm.h>\n#include <linux/namei.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nstatic int gfs2_link(struct dentry *old_dentry, struct inode *dir,\n\t\t     struct dentry *dentry)\n{\n\tstruct gfs2_inode *dip = GFS2_I(dir);\n\tstruct gfs2_sbd *sdp = GFS2_SB(dir);\n\tstruct inode *inode = old_dentry->d_inode;\n\tstruct gfs2_inode *ip = GFS2_I(inode);\n\tstruct gfs2_holder ghs[2];\n\tstruct buffer_head *dibh;\n\tstruct gfs2_diradd da = { .bh = NULL, .save_loc = 1, };\n\tint error;\n\n\tif (S_ISDIR(inode->i_mode))\n\t\treturn -EPERM;\n\n\terror = gfs2_rs_alloc(dip);\n\tif (error)\n\t\treturn error;\n\n\tgfs2_holder_init(dip->i_gl, LM_ST_EXCLUSIVE, 0, ghs);\n\tgfs2_holder_init(ip->i_gl, LM_ST_EXCLUSIVE, 0, ghs + 1);\n\n\terror = gfs2_glock_nq(ghs); /* parent */\n\tif (error)\n\t\tgoto out_parent;\n\n\terror = gfs2_glock_nq(ghs + 1); /* child */\n\tif (error)\n\t\tgoto out_child;\n\n\terror = -ENOENT;\n\tif (inode->i_nlink == 0)\n\t\tgoto out_gunlock;\n\n\terror = gfs2_permission(dir, MAY_WRITE | MAY_EXEC);\n\tif (error)\n\t\tgoto out_gunlock;\n\n\terror = gfs2_dir_check(dir, &dentry->d_name, NULL);\n\tswitch (error) {\n\tcase -ENOENT:\n\t\tbreak;\n\tcase 0:\n\t\terror = -EEXIST;\n\tdefault:\n\t\tgoto out_gunlock;\n\t}\n\n\terror = -EINVAL;\n\tif (!dip->i_inode.i_nlink)\n\t\tgoto out_gunlock;\n\terror = -EFBIG;\n\tif (dip->i_entries == (u32)-1)\n\t\tgoto out_gunlock;\n\terror = -EPERM;\n\tif (IS_IMMUTABLE(inode) || IS_APPEND(inode))\n\t\tgoto out_gunlock;\n\terror = -EINVAL;\n\tif (!ip->i_inode.i_nlink)\n\t\tgoto out_gunlock;\n\terror = -EMLINK;\n\tif (ip->i_inode.i_nlink == (u32)-1)\n\t\tgoto out_gunlock;\n\n\terror = gfs2_diradd_alloc_required(dir, &dentry->d_name, &da);\n\tif (error < 0)\n\t\tgoto out_gunlock;\n\n\tif (da.nr_blocks) {\n\t\tstruct gfs2_alloc_parms ap = { .target = da.nr_blocks, };\n\t\terror = gfs2_quota_lock_check(dip);\n\t\tif (error)\n\t\t\tgoto out_gunlock;\n\n\t\terror = gfs2_inplace_reserve(dip, &ap);\n\t\tif (error)\n\t\t\tgoto out_gunlock_q;\n\n\t\terror = gfs2_trans_begin(sdp, gfs2_trans_da_blks(dip, &da, 2), 0);\n\t\tif (error)\n\t\t\tgoto out_ipres;\n\t} else {\n\t\terror = gfs2_trans_begin(sdp, 2 * RES_DINODE + RES_LEAF, 0);\n\t\tif (error)\n\t\t\tgoto out_ipres;\n\t}\n\n\terror = gfs2_meta_inode_buffer(ip, &dibh);\n\tif (error)\n\t\tgoto out_end_trans;\n\n\terror = gfs2_dir_add(dir, &dentry->d_name, ip, &da);\n\tif (error)\n\t\tgoto out_brelse;\n\n\tgfs2_trans_add_meta(ip->i_gl, dibh);\n\tinc_nlink(&ip->i_inode);\n\tip->i_inode.i_ctime = CURRENT_TIME;\n\tihold(inode);\n\td_instantiate(dentry, inode);\n\tmark_inode_dirty(inode);\n\nout_brelse:\n\tbrelse(dibh);\nout_end_trans:\n\tgfs2_trans_end(sdp);\nout_ipres:\n\tif (da.nr_blocks)\n\t\tgfs2_inplace_release(dip);\nout_gunlock_q:\n\tif (da.nr_blocks)\n\t\tgfs2_quota_unlock(dip);\nout_gunlock:\n\tgfs2_dir_no_add(&da);\n\tgfs2_glock_dq(ghs + 1);\nout_child:\n\tgfs2_glock_dq(ghs);\nout_parent:\n\tgfs2_holder_uninit(ghs);\n\tgfs2_holder_uninit(ghs + 1);\n\treturn error;\n}"
  },
  {
    "function_name": "gfs2_lookup",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/inode.c",
    "lines": "868-872",
    "snippet": "static struct dentry *gfs2_lookup(struct inode *dir, struct dentry *dentry,\n\t\t\t\t  unsigned flags)\n{\n\treturn __gfs2_lookup(dir, dentry, NULL, NULL);\n}",
    "includes": [
      "#include \"glops.h\"",
      "#include \"super.h\"",
      "#include \"util.h\"",
      "#include \"trans.h\"",
      "#include \"rgrp.h\"",
      "#include \"quota.h\"",
      "#include \"meta_io.h\"",
      "#include \"inode.h\"",
      "#include \"glock.h\"",
      "#include \"xattr.h\"",
      "#include \"dir.h\"",
      "#include \"bmap.h\"",
      "#include \"acl.h\"",
      "#include \"incore.h\"",
      "#include \"gfs2.h\"",
      "#include <asm/uaccess.h>",
      "#include <linux/security.h>",
      "#include <linux/fiemap.h>",
      "#include <linux/crc32.h>",
      "#include <linux/gfs2_ondisk.h>",
      "#include <linux/posix_acl.h>",
      "#include <linux/xattr.h>",
      "#include <linux/mm.h>",
      "#include <linux/namei.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/completion.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__gfs2_lookup",
          "args": [
            "dir",
            "dentry",
            "NULL",
            "NULL"
          ],
          "line": 871
        },
        "resolved": true,
        "details": {
          "function_name": "__gfs2_lookup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/inode.c",
          "lines": "828-866",
          "snippet": "static struct dentry *__gfs2_lookup(struct inode *dir, struct dentry *dentry,\n\t\t\t\t    struct file *file, int *opened)\n{\n\tstruct inode *inode;\n\tstruct dentry *d;\n\tstruct gfs2_holder gh;\n\tstruct gfs2_glock *gl;\n\tint error;\n\n\tinode = gfs2_lookupi(dir, &dentry->d_name, 0);\n\tif (inode == NULL) {\n\t\td_add(dentry, NULL);\n\t\treturn NULL;\n\t}\n\tif (IS_ERR(inode))\n\t\treturn ERR_CAST(inode);\n\n\tgl = GFS2_I(inode)->i_gl;\n\terror = gfs2_glock_nq_init(gl, LM_ST_SHARED, LM_FLAG_ANY, &gh);\n\tif (error) {\n\t\tiput(inode);\n\t\treturn ERR_PTR(error);\n\t}\n\n\td = d_splice_alias(inode, dentry);\n\tif (IS_ERR(d)) {\n\t\tgfs2_glock_dq_uninit(&gh);\n\t\treturn d;\n\t}\n\tif (file && S_ISREG(inode->i_mode))\n\t\terror = finish_open(file, dentry, gfs2_open_common, opened);\n\n\tgfs2_glock_dq_uninit(&gh);\n\tif (error) {\n\t\tdput(d);\n\t\treturn ERR_PTR(error);\n\t}\n\treturn d;\n}",
          "includes": [
            "#include \"glops.h\"",
            "#include \"super.h\"",
            "#include \"util.h\"",
            "#include \"trans.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"inode.h\"",
            "#include \"glock.h\"",
            "#include \"xattr.h\"",
            "#include \"dir.h\"",
            "#include \"bmap.h\"",
            "#include \"acl.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/security.h>",
            "#include <linux/fiemap.h>",
            "#include <linux/crc32.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/xattr.h>",
            "#include <linux/mm.h>",
            "#include <linux/namei.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glops.h\"\n#include \"super.h\"\n#include \"util.h\"\n#include \"trans.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"xattr.h\"\n#include \"dir.h\"\n#include \"bmap.h\"\n#include \"acl.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <asm/uaccess.h>\n#include <linux/security.h>\n#include <linux/fiemap.h>\n#include <linux/crc32.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/posix_acl.h>\n#include <linux/xattr.h>\n#include <linux/mm.h>\n#include <linux/namei.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nstatic struct dentry *__gfs2_lookup(struct inode *dir, struct dentry *dentry,\n\t\t\t\t    struct file *file, int *opened)\n{\n\tstruct inode *inode;\n\tstruct dentry *d;\n\tstruct gfs2_holder gh;\n\tstruct gfs2_glock *gl;\n\tint error;\n\n\tinode = gfs2_lookupi(dir, &dentry->d_name, 0);\n\tif (inode == NULL) {\n\t\td_add(dentry, NULL);\n\t\treturn NULL;\n\t}\n\tif (IS_ERR(inode))\n\t\treturn ERR_CAST(inode);\n\n\tgl = GFS2_I(inode)->i_gl;\n\terror = gfs2_glock_nq_init(gl, LM_ST_SHARED, LM_FLAG_ANY, &gh);\n\tif (error) {\n\t\tiput(inode);\n\t\treturn ERR_PTR(error);\n\t}\n\n\td = d_splice_alias(inode, dentry);\n\tif (IS_ERR(d)) {\n\t\tgfs2_glock_dq_uninit(&gh);\n\t\treturn d;\n\t}\n\tif (file && S_ISREG(inode->i_mode))\n\t\terror = finish_open(file, dentry, gfs2_open_common, opened);\n\n\tgfs2_glock_dq_uninit(&gh);\n\tif (error) {\n\t\tdput(d);\n\t\treturn ERR_PTR(error);\n\t}\n\treturn d;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"glops.h\"\n#include \"super.h\"\n#include \"util.h\"\n#include \"trans.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"xattr.h\"\n#include \"dir.h\"\n#include \"bmap.h\"\n#include \"acl.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <asm/uaccess.h>\n#include <linux/security.h>\n#include <linux/fiemap.h>\n#include <linux/crc32.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/posix_acl.h>\n#include <linux/xattr.h>\n#include <linux/mm.h>\n#include <linux/namei.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nstatic struct dentry *gfs2_lookup(struct inode *dir, struct dentry *dentry,\n\t\t\t\t  unsigned flags)\n{\n\treturn __gfs2_lookup(dir, dentry, NULL, NULL);\n}"
  },
  {
    "function_name": "__gfs2_lookup",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/inode.c",
    "lines": "828-866",
    "snippet": "static struct dentry *__gfs2_lookup(struct inode *dir, struct dentry *dentry,\n\t\t\t\t    struct file *file, int *opened)\n{\n\tstruct inode *inode;\n\tstruct dentry *d;\n\tstruct gfs2_holder gh;\n\tstruct gfs2_glock *gl;\n\tint error;\n\n\tinode = gfs2_lookupi(dir, &dentry->d_name, 0);\n\tif (inode == NULL) {\n\t\td_add(dentry, NULL);\n\t\treturn NULL;\n\t}\n\tif (IS_ERR(inode))\n\t\treturn ERR_CAST(inode);\n\n\tgl = GFS2_I(inode)->i_gl;\n\terror = gfs2_glock_nq_init(gl, LM_ST_SHARED, LM_FLAG_ANY, &gh);\n\tif (error) {\n\t\tiput(inode);\n\t\treturn ERR_PTR(error);\n\t}\n\n\td = d_splice_alias(inode, dentry);\n\tif (IS_ERR(d)) {\n\t\tgfs2_glock_dq_uninit(&gh);\n\t\treturn d;\n\t}\n\tif (file && S_ISREG(inode->i_mode))\n\t\terror = finish_open(file, dentry, gfs2_open_common, opened);\n\n\tgfs2_glock_dq_uninit(&gh);\n\tif (error) {\n\t\tdput(d);\n\t\treturn ERR_PTR(error);\n\t}\n\treturn d;\n}",
    "includes": [
      "#include \"glops.h\"",
      "#include \"super.h\"",
      "#include \"util.h\"",
      "#include \"trans.h\"",
      "#include \"rgrp.h\"",
      "#include \"quota.h\"",
      "#include \"meta_io.h\"",
      "#include \"inode.h\"",
      "#include \"glock.h\"",
      "#include \"xattr.h\"",
      "#include \"dir.h\"",
      "#include \"bmap.h\"",
      "#include \"acl.h\"",
      "#include \"incore.h\"",
      "#include \"gfs2.h\"",
      "#include <asm/uaccess.h>",
      "#include <linux/security.h>",
      "#include <linux/fiemap.h>",
      "#include <linux/crc32.h>",
      "#include <linux/gfs2_ondisk.h>",
      "#include <linux/posix_acl.h>",
      "#include <linux/xattr.h>",
      "#include <linux/mm.h>",
      "#include <linux/namei.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/completion.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "error"
          ],
          "line": 863
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dput",
          "args": [
            "d"
          ],
          "line": 862
        },
        "resolved": true,
        "details": {
          "function_name": "dput",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "726-762",
          "snippet": "void dput(struct dentry *dentry)\n{\n\tif (unlikely(!dentry))\n\t\treturn;\n\nrepeat:\n\trcu_read_lock();\n\tif (likely(fast_dput(dentry))) {\n\t\trcu_read_unlock();\n\t\treturn;\n\t}\n\n\t/* Slow case: now with the dentry lock held */\n\trcu_read_unlock();\n\n\t/* Unreachable? Get rid of it */\n\tif (unlikely(d_unhashed(dentry)))\n\t\tgoto kill_it;\n\n\tif (unlikely(dentry->d_flags & DCACHE_OP_DELETE)) {\n\t\tif (dentry->d_op->d_delete(dentry))\n\t\t\tgoto kill_it;\n\t}\n\n\tif (!(dentry->d_flags & DCACHE_REFERENCED))\n\t\tdentry->d_flags |= DCACHE_REFERENCED;\n\tdentry_lru_add(dentry);\n\n\tdentry->d_lockref.count--;\n\tspin_unlock(&dentry->d_lock);\n\treturn;\n\nkill_it:\n\tdentry = dentry_kill(dentry);\n\tif (dentry)\n\t\tgoto repeat;\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nvoid dput(struct dentry *dentry)\n{\n\tif (unlikely(!dentry))\n\t\treturn;\n\nrepeat:\n\trcu_read_lock();\n\tif (likely(fast_dput(dentry))) {\n\t\trcu_read_unlock();\n\t\treturn;\n\t}\n\n\t/* Slow case: now with the dentry lock held */\n\trcu_read_unlock();\n\n\t/* Unreachable? Get rid of it */\n\tif (unlikely(d_unhashed(dentry)))\n\t\tgoto kill_it;\n\n\tif (unlikely(dentry->d_flags & DCACHE_OP_DELETE)) {\n\t\tif (dentry->d_op->d_delete(dentry))\n\t\t\tgoto kill_it;\n\t}\n\n\tif (!(dentry->d_flags & DCACHE_REFERENCED))\n\t\tdentry->d_flags |= DCACHE_REFERENCED;\n\tdentry_lru_add(dentry);\n\n\tdentry->d_lockref.count--;\n\tspin_unlock(&dentry->d_lock);\n\treturn;\n\nkill_it:\n\tdentry = dentry_kill(dentry);\n\tif (dentry)\n\t\tgoto repeat;\n}"
        }
      },
      {
        "call_info": {
          "callee": "gfs2_glock_dq_uninit",
          "args": [
            "&gh"
          ],
          "line": 860
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_glock_dq_uninit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/glock.c",
          "lines": "1110-1114",
          "snippet": "void gfs2_glock_dq_uninit(struct gfs2_holder *gh)\n{\n\tgfs2_glock_dq(gh);\n\tgfs2_holder_uninit(gh);\n}",
          "includes": [
            "#include \"trace_gfs2.h\"",
            "#include \"bmap.h\"",
            "#include \"util.h\"",
            "#include \"super.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"lops.h\"",
            "#include \"inode.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/lockref.h>",
            "#include <linux/list_sort.h>",
            "#include <linux/percpu.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/seq_file.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/module.h>",
            "#include <linux/wait.h>",
            "#include <linux/list.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/jhash.h>",
            "#include <linux/sort.h>",
            "#include <linux/delay.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"bmap.h\"\n#include \"util.h\"\n#include \"super.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"lops.h\"\n#include \"inode.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/lockref.h>\n#include <linux/list_sort.h>\n#include <linux/percpu.h>\n#include <linux/bit_spinlock.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/jiffies.h>\n#include <linux/workqueue.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <asm/uaccess.h>\n#include <linux/module.h>\n#include <linux/wait.h>\n#include <linux/list.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/kallsyms.h>\n#include <linux/jhash.h>\n#include <linux/sort.h>\n#include <linux/delay.h>\n#include <linux/buffer_head.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nvoid gfs2_glock_dq_uninit(struct gfs2_holder *gh)\n{\n\tgfs2_glock_dq(gh);\n\tgfs2_holder_uninit(gh);\n}"
        }
      },
      {
        "call_info": {
          "callee": "finish_open",
          "args": [
            "file",
            "dentry",
            "gfs2_open_common",
            "opened"
          ],
          "line": 858
        },
        "resolved": true,
        "details": {
          "function_name": "finish_open",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/open.c",
          "lines": "784-797",
          "snippet": "int finish_open(struct file *file, struct dentry *dentry,\n\t\tint (*open)(struct inode *, struct file *),\n\t\tint *opened)\n{\n\tint error;\n\tBUG_ON(*opened & FILE_OPENED); /* once it's opened, it's opened */\n\n\tfile->f_path.dentry = dentry;\n\terror = do_dentry_open(file, open, current_cred());\n\tif (!error)\n\t\t*opened |= FILE_OPENED;\n\n\treturn error;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/compat.h>",
            "#include <linux/dnotify.h>",
            "#include <linux/ima.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/falloc.h>",
            "#include <linux/audit.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/personality.h>",
            "#include <linux/fs.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/mount.h>",
            "#include <linux/security.h>",
            "#include <linux/securebits.h>",
            "#include <linux/capability.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/namei.h>",
            "#include <linux/tty.h>",
            "#include <linux/module.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/compat.h>\n#include <linux/dnotify.h>\n#include <linux/ima.h>\n#include <linux/fs_struct.h>\n#include <linux/falloc.h>\n#include <linux/audit.h>\n#include <linux/rcupdate.h>\n#include <linux/syscalls.h>\n#include <linux/pagemap.h>\n#include <linux/personality.h>\n#include <linux/fs.h>\n#include <asm/uaccess.h>\n#include <linux/slab.h>\n#include <linux/fcntl.h>\n#include <linux/mount.h>\n#include <linux/security.h>\n#include <linux/securebits.h>\n#include <linux/capability.h>\n#include <linux/backing-dev.h>\n#include <linux/namei.h>\n#include <linux/tty.h>\n#include <linux/module.h>\n#include <linux/fsnotify.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n\nint finish_open(struct file *file, struct dentry *dentry,\n\t\tint (*open)(struct inode *, struct file *),\n\t\tint *opened)\n{\n\tint error;\n\tBUG_ON(*opened & FILE_OPENED); /* once it's opened, it's opened */\n\n\tfile->f_path.dentry = dentry;\n\terror = do_dentry_open(file, open, current_cred());\n\tif (!error)\n\t\t*opened |= FILE_OPENED;\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "S_ISREG",
          "args": [
            "inode->i_mode"
          ],
          "line": 857
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "d"
          ],
          "line": 853
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "d_splice_alias",
          "args": [
            "inode",
            "dentry"
          ],
          "line": 852
        },
        "resolved": true,
        "details": {
          "function_name": "d_splice_alias",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "2741-2792",
          "snippet": "struct dentry *d_splice_alias(struct inode *inode, struct dentry *dentry)\n{\n\tif (IS_ERR(inode))\n\t\treturn ERR_CAST(inode);\n\n\tBUG_ON(!d_unhashed(dentry));\n\n\tif (!inode) {\n\t\t__d_instantiate(dentry, NULL);\n\t\tgoto out;\n\t}\n\tspin_lock(&inode->i_lock);\n\tif (S_ISDIR(inode->i_mode)) {\n\t\tstruct dentry *new = __d_find_any_alias(inode);\n\t\tif (unlikely(new)) {\n\t\t\twrite_seqlock(&rename_lock);\n\t\t\tif (unlikely(d_ancestor(new, dentry))) {\n\t\t\t\twrite_sequnlock(&rename_lock);\n\t\t\t\tspin_unlock(&inode->i_lock);\n\t\t\t\tdput(new);\n\t\t\t\tnew = ERR_PTR(-ELOOP);\n\t\t\t\tpr_warn_ratelimited(\n\t\t\t\t\t\"VFS: Lookup of '%s' in %s %s\"\n\t\t\t\t\t\" would have caused loop\\n\",\n\t\t\t\t\tdentry->d_name.name,\n\t\t\t\t\tinode->i_sb->s_type->name,\n\t\t\t\t\tinode->i_sb->s_id);\n\t\t\t} else if (!IS_ROOT(new)) {\n\t\t\t\tint err = __d_unalias(inode, dentry, new);\n\t\t\t\twrite_sequnlock(&rename_lock);\n\t\t\t\tif (err) {\n\t\t\t\t\tdput(new);\n\t\t\t\t\tnew = ERR_PTR(err);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t__d_move(new, dentry, false);\n\t\t\t\twrite_sequnlock(&rename_lock);\n\t\t\t\tspin_unlock(&inode->i_lock);\n\t\t\t\tsecurity_d_instantiate(new, inode);\n\t\t\t}\n\t\t\tiput(inode);\n\t\t\treturn new;\n\t\t}\n\t}\n\t/* already taking inode->i_lock, so d_add() by hand */\n\t__d_instantiate(dentry, inode);\n\tspin_unlock(&inode->i_lock);\nout:\n\tsecurity_d_instantiate(dentry, inode);\n\td_rehash(dentry);\n\treturn NULL;\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "__cacheline_aligned_in_smp DEFINE_SEQLOCK(rename_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\n__cacheline_aligned_in_smp DEFINE_SEQLOCK(rename_lock);\n\nstruct dentry *d_splice_alias(struct inode *inode, struct dentry *dentry)\n{\n\tif (IS_ERR(inode))\n\t\treturn ERR_CAST(inode);\n\n\tBUG_ON(!d_unhashed(dentry));\n\n\tif (!inode) {\n\t\t__d_instantiate(dentry, NULL);\n\t\tgoto out;\n\t}\n\tspin_lock(&inode->i_lock);\n\tif (S_ISDIR(inode->i_mode)) {\n\t\tstruct dentry *new = __d_find_any_alias(inode);\n\t\tif (unlikely(new)) {\n\t\t\twrite_seqlock(&rename_lock);\n\t\t\tif (unlikely(d_ancestor(new, dentry))) {\n\t\t\t\twrite_sequnlock(&rename_lock);\n\t\t\t\tspin_unlock(&inode->i_lock);\n\t\t\t\tdput(new);\n\t\t\t\tnew = ERR_PTR(-ELOOP);\n\t\t\t\tpr_warn_ratelimited(\n\t\t\t\t\t\"VFS: Lookup of '%s' in %s %s\"\n\t\t\t\t\t\" would have caused loop\\n\",\n\t\t\t\t\tdentry->d_name.name,\n\t\t\t\t\tinode->i_sb->s_type->name,\n\t\t\t\t\tinode->i_sb->s_id);\n\t\t\t} else if (!IS_ROOT(new)) {\n\t\t\t\tint err = __d_unalias(inode, dentry, new);\n\t\t\t\twrite_sequnlock(&rename_lock);\n\t\t\t\tif (err) {\n\t\t\t\t\tdput(new);\n\t\t\t\t\tnew = ERR_PTR(err);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t__d_move(new, dentry, false);\n\t\t\t\twrite_sequnlock(&rename_lock);\n\t\t\t\tspin_unlock(&inode->i_lock);\n\t\t\t\tsecurity_d_instantiate(new, inode);\n\t\t\t}\n\t\t\tiput(inode);\n\t\t\treturn new;\n\t\t}\n\t}\n\t/* already taking inode->i_lock, so d_add() by hand */\n\t__d_instantiate(dentry, inode);\n\tspin_unlock(&inode->i_lock);\nout:\n\tsecurity_d_instantiate(dentry, inode);\n\td_rehash(dentry);\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "error"
          ],
          "line": 849
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "iput",
          "args": [
            "inode"
          ],
          "line": 848
        },
        "resolved": true,
        "details": {
          "function_name": "iput",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "1471-1488",
          "snippet": "void iput(struct inode *inode)\n{\n\tif (!inode)\n\t\treturn;\n\tBUG_ON(inode->i_state & I_CLEAR);\nretry:\n\tif (atomic_dec_and_lock(&inode->i_count, &inode->i_lock)) {\n\t\tif (inode->i_nlink && (inode->i_state & I_DIRTY_TIME)) {\n\t\t\tatomic_inc(&inode->i_count);\n\t\t\tinode->i_state &= ~I_DIRTY_TIME;\n\t\t\tspin_unlock(&inode->i_lock);\n\t\t\ttrace_writeback_lazytime_iput(inode);\n\t\t\tmark_inode_dirty_sync(inode);\n\t\t\tgoto retry;\n\t\t}\n\t\tiput_final(inode);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid iput(struct inode *inode)\n{\n\tif (!inode)\n\t\treturn;\n\tBUG_ON(inode->i_state & I_CLEAR);\nretry:\n\tif (atomic_dec_and_lock(&inode->i_count, &inode->i_lock)) {\n\t\tif (inode->i_nlink && (inode->i_state & I_DIRTY_TIME)) {\n\t\t\tatomic_inc(&inode->i_count);\n\t\t\tinode->i_state &= ~I_DIRTY_TIME;\n\t\t\tspin_unlock(&inode->i_lock);\n\t\t\ttrace_writeback_lazytime_iput(inode);\n\t\t\tmark_inode_dirty_sync(inode);\n\t\t\tgoto retry;\n\t\t}\n\t\tiput_final(inode);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "gfs2_glock_nq_init",
          "args": [
            "gl",
            "LM_ST_SHARED",
            "LM_FLAG_ANY",
            "&gh"
          ],
          "line": 846
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_glock_nq_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/glock.h",
          "lines": "204-230",
          "snippet": "extern __printf(2, 3)\nvoid gfs2_print_dbg(struct seq_file *seq, const char *fmt, ...);\n\n/**\n * gfs2_glock_nq_init - initialize a holder and enqueue it on a glock\n * @gl: the glock\n * @state: the state we're requesting\n * @flags: the modifier flags\n * @gh: the holder structure\n *\n * Returns: 0, GLR_*, or errno\n */\n\nstatic inline int gfs2_glock_nq_init(struct gfs2_glock *gl,\n\t\t\t\t     unsigned int state, int flags,\n\t\t\t\t     struct gfs2_holder *gh)\n{\n\tint error;\n\n\tgfs2_holder_init(gl, state, flags, gh);\n\n\terror = gfs2_glock_nq(gh);\n\tif (error)\n\t\tgfs2_holder_uninit(gh);\n\n\treturn error;\n}",
          "includes": [
            "#include \"incore.h\"",
            "#include <linux/parser.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"incore.h\"\n#include <linux/parser.h>\n#include <linux/sched.h>\n\nextern __printf(2, 3)\nvoid gfs2_print_dbg(struct seq_file *seq, const char *fmt, ...);\n\n/**\n * gfs2_glock_nq_init - initialize a holder and enqueue it on a glock\n * @gl: the glock\n * @state: the state we're requesting\n * @flags: the modifier flags\n * @gh: the holder structure\n *\n * Returns: 0, GLR_*, or errno\n */\n\nstatic inline int gfs2_glock_nq_init(struct gfs2_glock *gl,\n\t\t\t\t     unsigned int state, int flags,\n\t\t\t\t     struct gfs2_holder *gh)\n{\n\tint error;\n\n\tgfs2_holder_init(gl, state, flags, gh);\n\n\terror = gfs2_glock_nq(gh);\n\tif (error)\n\t\tgfs2_holder_uninit(gh);\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "GFS2_I",
          "args": [
            "inode"
          ],
          "line": 845
        },
        "resolved": true,
        "details": {
          "function_name": "GFS2_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/incore.h",
          "lines": "408-411",
          "snippet": "static inline struct gfs2_inode *GFS2_I(struct inode *inode)\n{\n\treturn container_of(inode, struct gfs2_inode, i_inode);\n}",
          "includes": [
            "#include <linux/lockref.h>",
            "#include <linux/percpu.h>",
            "#include <linux/ktime.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/completion.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/dlm.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/kobject.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/lockref.h>\n#include <linux/percpu.h>\n#include <linux/ktime.h>\n#include <linux/rbtree.h>\n#include <linux/completion.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/buffer_head.h>\n#include <linux/dlm.h>\n#include <linux/workqueue.h>\n#include <linux/kobject.h>\n#include <linux/fs.h>\n\nstatic inline struct gfs2_inode *GFS2_I(struct inode *inode)\n{\n\treturn container_of(inode, struct gfs2_inode, i_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERR_CAST",
          "args": [
            "inode"
          ],
          "line": 843
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "inode"
          ],
          "line": 842
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "d_add",
          "args": [
            "dentry",
            "NULL"
          ],
          "line": 839
        },
        "resolved": true,
        "details": {
          "function_name": "v9fs_fid_add",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/9p/fid.c",
          "lines": "49-54",
          "snippet": "void v9fs_fid_add(struct dentry *dentry, struct p9_fid *fid)\n{\n\tspin_lock(&dentry->d_lock);\n\t__add_fid(dentry, fid);\n\tspin_unlock(&dentry->d_lock);\n}",
          "includes": [
            "#include \"fid.h\"",
            "#include \"v9fs_vfs.h\"",
            "#include \"v9fs.h\"",
            "#include <net/9p/client.h>",
            "#include <net/9p/9p.h>",
            "#include <linux/idr.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/errno.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fid.h\"\n#include \"v9fs_vfs.h\"\n#include \"v9fs.h\"\n#include <net/9p/client.h>\n#include <net/9p/9p.h>\n#include <linux/idr.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n#include <linux/module.h>\n\nvoid v9fs_fid_add(struct dentry *dentry, struct p9_fid *fid)\n{\n\tspin_lock(&dentry->d_lock);\n\t__add_fid(dentry, fid);\n\tspin_unlock(&dentry->d_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "gfs2_lookupi",
          "args": [
            "dir",
            "&dentry->d_name",
            "0"
          ],
          "line": 837
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_lookupi",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/inode.c",
          "lines": "283-325",
          "snippet": "struct inode *gfs2_lookupi(struct inode *dir, const struct qstr *name,\n\t\t\t   int is_root)\n{\n\tstruct super_block *sb = dir->i_sb;\n\tstruct gfs2_inode *dip = GFS2_I(dir);\n\tstruct gfs2_holder d_gh;\n\tint error = 0;\n\tstruct inode *inode = NULL;\n\tint unlock = 0;\n\n\tif (!name->len || name->len > GFS2_FNAMESIZE)\n\t\treturn ERR_PTR(-ENAMETOOLONG);\n\n\tif ((name->len == 1 && memcmp(name->name, \".\", 1) == 0) ||\n\t    (name->len == 2 && memcmp(name->name, \"..\", 2) == 0 &&\n\t     dir == sb->s_root->d_inode)) {\n\t\tigrab(dir);\n\t\treturn dir;\n\t}\n\n\tif (gfs2_glock_is_locked_by_me(dip->i_gl) == NULL) {\n\t\terror = gfs2_glock_nq_init(dip->i_gl, LM_ST_SHARED, 0, &d_gh);\n\t\tif (error)\n\t\t\treturn ERR_PTR(error);\n\t\tunlock = 1;\n\t}\n\n\tif (!is_root) {\n\t\terror = gfs2_permission(dir, MAY_EXEC);\n\t\tif (error)\n\t\t\tgoto out;\n\t}\n\n\tinode = gfs2_dir_search(dir, name, false);\n\tif (IS_ERR(inode))\n\t\terror = PTR_ERR(inode);\nout:\n\tif (unlock)\n\t\tgfs2_glock_dq_uninit(&d_gh);\n\tif (error == -ENOENT)\n\t\treturn NULL;\n\treturn inode ? inode : ERR_PTR(error);\n}",
          "includes": [
            "#include \"glops.h\"",
            "#include \"super.h\"",
            "#include \"util.h\"",
            "#include \"trans.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"inode.h\"",
            "#include \"glock.h\"",
            "#include \"xattr.h\"",
            "#include \"dir.h\"",
            "#include \"bmap.h\"",
            "#include \"acl.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/security.h>",
            "#include <linux/fiemap.h>",
            "#include <linux/crc32.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/xattr.h>",
            "#include <linux/mm.h>",
            "#include <linux/namei.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glops.h\"\n#include \"super.h\"\n#include \"util.h\"\n#include \"trans.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"xattr.h\"\n#include \"dir.h\"\n#include \"bmap.h\"\n#include \"acl.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <asm/uaccess.h>\n#include <linux/security.h>\n#include <linux/fiemap.h>\n#include <linux/crc32.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/posix_acl.h>\n#include <linux/xattr.h>\n#include <linux/mm.h>\n#include <linux/namei.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nstruct inode *gfs2_lookupi(struct inode *dir, const struct qstr *name,\n\t\t\t   int is_root)\n{\n\tstruct super_block *sb = dir->i_sb;\n\tstruct gfs2_inode *dip = GFS2_I(dir);\n\tstruct gfs2_holder d_gh;\n\tint error = 0;\n\tstruct inode *inode = NULL;\n\tint unlock = 0;\n\n\tif (!name->len || name->len > GFS2_FNAMESIZE)\n\t\treturn ERR_PTR(-ENAMETOOLONG);\n\n\tif ((name->len == 1 && memcmp(name->name, \".\", 1) == 0) ||\n\t    (name->len == 2 && memcmp(name->name, \"..\", 2) == 0 &&\n\t     dir == sb->s_root->d_inode)) {\n\t\tigrab(dir);\n\t\treturn dir;\n\t}\n\n\tif (gfs2_glock_is_locked_by_me(dip->i_gl) == NULL) {\n\t\terror = gfs2_glock_nq_init(dip->i_gl, LM_ST_SHARED, 0, &d_gh);\n\t\tif (error)\n\t\t\treturn ERR_PTR(error);\n\t\tunlock = 1;\n\t}\n\n\tif (!is_root) {\n\t\terror = gfs2_permission(dir, MAY_EXEC);\n\t\tif (error)\n\t\t\tgoto out;\n\t}\n\n\tinode = gfs2_dir_search(dir, name, false);\n\tif (IS_ERR(inode))\n\t\terror = PTR_ERR(inode);\nout:\n\tif (unlock)\n\t\tgfs2_glock_dq_uninit(&d_gh);\n\tif (error == -ENOENT)\n\t\treturn NULL;\n\treturn inode ? inode : ERR_PTR(error);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"glops.h\"\n#include \"super.h\"\n#include \"util.h\"\n#include \"trans.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"xattr.h\"\n#include \"dir.h\"\n#include \"bmap.h\"\n#include \"acl.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <asm/uaccess.h>\n#include <linux/security.h>\n#include <linux/fiemap.h>\n#include <linux/crc32.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/posix_acl.h>\n#include <linux/xattr.h>\n#include <linux/mm.h>\n#include <linux/namei.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nstatic struct dentry *__gfs2_lookup(struct inode *dir, struct dentry *dentry,\n\t\t\t\t    struct file *file, int *opened)\n{\n\tstruct inode *inode;\n\tstruct dentry *d;\n\tstruct gfs2_holder gh;\n\tstruct gfs2_glock *gl;\n\tint error;\n\n\tinode = gfs2_lookupi(dir, &dentry->d_name, 0);\n\tif (inode == NULL) {\n\t\td_add(dentry, NULL);\n\t\treturn NULL;\n\t}\n\tif (IS_ERR(inode))\n\t\treturn ERR_CAST(inode);\n\n\tgl = GFS2_I(inode)->i_gl;\n\terror = gfs2_glock_nq_init(gl, LM_ST_SHARED, LM_FLAG_ANY, &gh);\n\tif (error) {\n\t\tiput(inode);\n\t\treturn ERR_PTR(error);\n\t}\n\n\td = d_splice_alias(inode, dentry);\n\tif (IS_ERR(d)) {\n\t\tgfs2_glock_dq_uninit(&gh);\n\t\treturn d;\n\t}\n\tif (file && S_ISREG(inode->i_mode))\n\t\terror = finish_open(file, dentry, gfs2_open_common, opened);\n\n\tgfs2_glock_dq_uninit(&gh);\n\tif (error) {\n\t\tdput(d);\n\t\treturn ERR_PTR(error);\n\t}\n\treturn d;\n}"
  },
  {
    "function_name": "gfs2_create",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/inode.c",
    "lines": "811-815",
    "snippet": "static int gfs2_create(struct inode *dir, struct dentry *dentry,\n\t\t       umode_t mode, bool excl)\n{\n\treturn gfs2_create_inode(dir, dentry, NULL, S_IFREG | mode, 0, NULL, 0, excl, NULL);\n}",
    "includes": [
      "#include \"glops.h\"",
      "#include \"super.h\"",
      "#include \"util.h\"",
      "#include \"trans.h\"",
      "#include \"rgrp.h\"",
      "#include \"quota.h\"",
      "#include \"meta_io.h\"",
      "#include \"inode.h\"",
      "#include \"glock.h\"",
      "#include \"xattr.h\"",
      "#include \"dir.h\"",
      "#include \"bmap.h\"",
      "#include \"acl.h\"",
      "#include \"incore.h\"",
      "#include \"gfs2.h\"",
      "#include <asm/uaccess.h>",
      "#include <linux/security.h>",
      "#include <linux/fiemap.h>",
      "#include <linux/crc32.h>",
      "#include <linux/gfs2_ondisk.h>",
      "#include <linux/posix_acl.h>",
      "#include <linux/xattr.h>",
      "#include <linux/mm.h>",
      "#include <linux/namei.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/completion.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "gfs2_create_inode",
          "args": [
            "dir",
            "dentry",
            "NULL",
            "S_IFREG | mode",
            "0",
            "NULL",
            "0",
            "excl",
            "NULL"
          ],
          "line": 814
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_create_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/inode.c",
          "lines": "584-800",
          "snippet": "static int gfs2_create_inode(struct inode *dir, struct dentry *dentry,\n\t\t\t     struct file *file,\n\t\t\t     umode_t mode, dev_t dev, const char *symname,\n\t\t\t     unsigned int size, int excl, int *opened)\n{\n\tconst struct qstr *name = &dentry->d_name;\n\tstruct posix_acl *default_acl, *acl;\n\tstruct gfs2_holder ghs[2];\n\tstruct inode *inode = NULL;\n\tstruct gfs2_inode *dip = GFS2_I(dir), *ip;\n\tstruct gfs2_sbd *sdp = GFS2_SB(&dip->i_inode);\n\tstruct gfs2_glock *io_gl;\n\tint error, free_vfs_inode = 0;\n\tu32 aflags = 0;\n\tunsigned blocks = 1;\n\tstruct gfs2_diradd da = { .bh = NULL, .save_loc = 1, };\n\n\tif (!name->len || name->len > GFS2_FNAMESIZE)\n\t\treturn -ENAMETOOLONG;\n\n\terror = gfs2_rs_alloc(dip);\n\tif (error)\n\t\treturn error;\n\n\terror = gfs2_rindex_update(sdp);\n\tif (error)\n\t\treturn error;\n\n\terror = gfs2_glock_nq_init(dip->i_gl, LM_ST_EXCLUSIVE, 0, ghs);\n\tif (error)\n\t\tgoto fail;\n\n\terror = create_ok(dip, name, mode);\n\tif (error)\n\t\tgoto fail_gunlock;\n\n\tinode = gfs2_dir_search(dir, &dentry->d_name, !S_ISREG(mode) || excl);\n\terror = PTR_ERR(inode);\n\tif (!IS_ERR(inode)) {\n\t\tif (S_ISDIR(inode->i_mode)) {\n\t\t\tiput(inode);\n\t\t\tinode = ERR_PTR(-EISDIR);\n\t\t\tgoto fail_gunlock;\n\t\t}\n\t\td_instantiate(dentry, inode);\n\t\terror = 0;\n\t\tif (file) {\n\t\t\tif (S_ISREG(inode->i_mode))\n\t\t\t\terror = finish_open(file, dentry, gfs2_open_common, opened);\n\t\t\telse\n\t\t\t\terror = finish_no_open(file, NULL);\n\t\t}\n\t\tgfs2_glock_dq_uninit(ghs);\n\t\treturn error;\n\t} else if (error != -ENOENT) {\n\t\tgoto fail_gunlock;\n\t}\n\n\terror = gfs2_diradd_alloc_required(dir, name, &da);\n\tif (error < 0)\n\t\tgoto fail_gunlock;\n\n\tinode = new_inode(sdp->sd_vfs);\n\terror = -ENOMEM;\n\tif (!inode)\n\t\tgoto fail_gunlock;\n\n\terror = posix_acl_create(dir, &mode, &default_acl, &acl);\n\tif (error)\n\t\tgoto fail_free_vfs_inode;\n\n\tip = GFS2_I(inode);\n\terror = gfs2_rs_alloc(ip);\n\tif (error)\n\t\tgoto fail_free_acls;\n\n\tinode->i_mode = mode;\n\tset_nlink(inode, S_ISDIR(mode) ? 2 : 1);\n\tinode->i_rdev = dev;\n\tinode->i_size = size;\n\tinode->i_atime = inode->i_mtime = inode->i_ctime = CURRENT_TIME;\n\tgfs2_set_inode_blocks(inode, 1);\n\tmunge_mode_uid_gid(dip, inode);\n\tcheck_and_update_goal(dip);\n\tip->i_goal = dip->i_goal;\n\tip->i_diskflags = 0;\n\tip->i_eattr = 0;\n\tip->i_height = 0;\n\tip->i_depth = 0;\n\tip->i_entries = 0;\n\n\tswitch(mode & S_IFMT) {\n\tcase S_IFREG:\n\t\tif ((dip->i_diskflags & GFS2_DIF_INHERIT_JDATA) ||\n\t\t    gfs2_tune_get(sdp, gt_new_files_jdata))\n\t\t\tip->i_diskflags |= GFS2_DIF_JDATA;\n\t\tgfs2_set_aops(inode);\n\t\tbreak;\n\tcase S_IFDIR:\n\t\tip->i_diskflags |= (dip->i_diskflags & GFS2_DIF_INHERIT_JDATA);\n\t\tip->i_diskflags |= GFS2_DIF_JDATA;\n\t\tip->i_entries = 2;\n\t\tbreak;\n\t}\n\tgfs2_set_inode_flags(inode);\n\n\tif ((GFS2_I(sdp->sd_root_dir->d_inode) == dip) ||\n\t    (dip->i_diskflags & GFS2_DIF_TOPDIR))\n\t\taflags |= GFS2_AF_ORLOV;\n\n\tif (default_acl || acl)\n\t\tblocks++;\n\n\terror = alloc_dinode(ip, aflags, &blocks);\n\tif (error)\n\t\tgoto fail_free_inode;\n\n\tgfs2_set_inode_blocks(inode, blocks);\n\n\terror = gfs2_glock_get(sdp, ip->i_no_addr, &gfs2_inode_glops, CREATE, &ip->i_gl);\n\tif (error)\n\t\tgoto fail_free_inode;\n\n\tip->i_gl->gl_object = ip;\n\terror = gfs2_glock_nq_init(ip->i_gl, LM_ST_EXCLUSIVE, GL_SKIP, ghs + 1);\n\tif (error)\n\t\tgoto fail_free_inode;\n\n\terror = gfs2_trans_begin(sdp, blocks, 0);\n\tif (error)\n\t\tgoto fail_gunlock2;\n\n\tif (blocks > 1) {\n\t\tip->i_eattr = ip->i_no_addr + 1;\n\t\tgfs2_init_xattr(ip);\n\t}\n\tinit_dinode(dip, ip, symname);\n\tgfs2_trans_end(sdp);\n\n\terror = gfs2_glock_get(sdp, ip->i_no_addr, &gfs2_iopen_glops, CREATE, &io_gl);\n\tif (error)\n\t\tgoto fail_gunlock2;\n\n\terror = gfs2_glock_nq_init(io_gl, LM_ST_SHARED, GL_EXACT, &ip->i_iopen_gh);\n\tif (error)\n\t\tgoto fail_gunlock2;\n\n\tip->i_iopen_gh.gh_gl->gl_object = ip;\n\tgfs2_glock_put(io_gl);\n\tgfs2_set_iop(inode);\n\tinsert_inode_hash(inode);\n\n\tif (default_acl) {\n\t\terror = gfs2_set_acl(inode, default_acl, ACL_TYPE_DEFAULT);\n\t\tposix_acl_release(default_acl);\n\t}\n\tif (acl) {\n\t\tif (!error)\n\t\t\terror = gfs2_set_acl(inode, acl, ACL_TYPE_ACCESS);\n\t\tposix_acl_release(acl);\n\t}\n\n\tif (error)\n\t\tgoto fail_gunlock3;\n\n\terror = security_inode_init_security(&ip->i_inode, &dip->i_inode, name,\n\t\t\t\t\t     &gfs2_initxattrs, NULL);\n\tif (error)\n\t\tgoto fail_gunlock3;\n\n\terror = link_dinode(dip, name, ip, &da);\n\tif (error)\n\t\tgoto fail_gunlock3;\n\n\tmark_inode_dirty(inode);\n\td_instantiate(dentry, inode);\n\tif (file) {\n\t\t*opened |= FILE_CREATED;\n\t\terror = finish_open(file, dentry, gfs2_open_common, opened);\n\t}\n\tgfs2_glock_dq_uninit(ghs);\n\tgfs2_glock_dq_uninit(ghs + 1);\n\treturn error;\n\nfail_gunlock3:\n\tgfs2_glock_dq_uninit(ghs + 1);\n\tif (ip->i_gl)\n\t\tgfs2_glock_put(ip->i_gl);\n\tgoto fail_gunlock;\n\nfail_gunlock2:\n\tgfs2_glock_dq_uninit(ghs + 1);\nfail_free_inode:\n\tif (ip->i_gl)\n\t\tgfs2_glock_put(ip->i_gl);\n\tgfs2_rs_delete(ip, NULL);\nfail_free_acls:\n\tif (default_acl)\n\t\tposix_acl_release(default_acl);\n\tif (acl)\n\t\tposix_acl_release(acl);\nfail_free_vfs_inode:\n\tfree_vfs_inode = 1;\nfail_gunlock:\n\tgfs2_dir_no_add(&da);\n\tgfs2_glock_dq_uninit(ghs);\n\tif (inode && !IS_ERR(inode)) {\n\t\tclear_nlink(inode);\n\t\tif (!free_vfs_inode)\n\t\t\tmark_inode_dirty(inode);\n\t\tset_bit(free_vfs_inode ? GIF_FREE_VFS_INODE : GIF_ALLOC_FAILED,\n\t\t\t&GFS2_I(inode)->i_flags);\n\t\tiput(inode);\n\t}\nfail:\n\treturn error;\n}",
          "includes": [
            "#include \"glops.h\"",
            "#include \"super.h\"",
            "#include \"util.h\"",
            "#include \"trans.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"inode.h\"",
            "#include \"glock.h\"",
            "#include \"xattr.h\"",
            "#include \"dir.h\"",
            "#include \"bmap.h\"",
            "#include \"acl.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/security.h>",
            "#include <linux/fiemap.h>",
            "#include <linux/crc32.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/xattr.h>",
            "#include <linux/mm.h>",
            "#include <linux/namei.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glops.h\"\n#include \"super.h\"\n#include \"util.h\"\n#include \"trans.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"xattr.h\"\n#include \"dir.h\"\n#include \"bmap.h\"\n#include \"acl.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <asm/uaccess.h>\n#include <linux/security.h>\n#include <linux/fiemap.h>\n#include <linux/crc32.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/posix_acl.h>\n#include <linux/xattr.h>\n#include <linux/mm.h>\n#include <linux/namei.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nstatic int gfs2_create_inode(struct inode *dir, struct dentry *dentry,\n\t\t\t     struct file *file,\n\t\t\t     umode_t mode, dev_t dev, const char *symname,\n\t\t\t     unsigned int size, int excl, int *opened)\n{\n\tconst struct qstr *name = &dentry->d_name;\n\tstruct posix_acl *default_acl, *acl;\n\tstruct gfs2_holder ghs[2];\n\tstruct inode *inode = NULL;\n\tstruct gfs2_inode *dip = GFS2_I(dir), *ip;\n\tstruct gfs2_sbd *sdp = GFS2_SB(&dip->i_inode);\n\tstruct gfs2_glock *io_gl;\n\tint error, free_vfs_inode = 0;\n\tu32 aflags = 0;\n\tunsigned blocks = 1;\n\tstruct gfs2_diradd da = { .bh = NULL, .save_loc = 1, };\n\n\tif (!name->len || name->len > GFS2_FNAMESIZE)\n\t\treturn -ENAMETOOLONG;\n\n\terror = gfs2_rs_alloc(dip);\n\tif (error)\n\t\treturn error;\n\n\terror = gfs2_rindex_update(sdp);\n\tif (error)\n\t\treturn error;\n\n\terror = gfs2_glock_nq_init(dip->i_gl, LM_ST_EXCLUSIVE, 0, ghs);\n\tif (error)\n\t\tgoto fail;\n\n\terror = create_ok(dip, name, mode);\n\tif (error)\n\t\tgoto fail_gunlock;\n\n\tinode = gfs2_dir_search(dir, &dentry->d_name, !S_ISREG(mode) || excl);\n\terror = PTR_ERR(inode);\n\tif (!IS_ERR(inode)) {\n\t\tif (S_ISDIR(inode->i_mode)) {\n\t\t\tiput(inode);\n\t\t\tinode = ERR_PTR(-EISDIR);\n\t\t\tgoto fail_gunlock;\n\t\t}\n\t\td_instantiate(dentry, inode);\n\t\terror = 0;\n\t\tif (file) {\n\t\t\tif (S_ISREG(inode->i_mode))\n\t\t\t\terror = finish_open(file, dentry, gfs2_open_common, opened);\n\t\t\telse\n\t\t\t\terror = finish_no_open(file, NULL);\n\t\t}\n\t\tgfs2_glock_dq_uninit(ghs);\n\t\treturn error;\n\t} else if (error != -ENOENT) {\n\t\tgoto fail_gunlock;\n\t}\n\n\terror = gfs2_diradd_alloc_required(dir, name, &da);\n\tif (error < 0)\n\t\tgoto fail_gunlock;\n\n\tinode = new_inode(sdp->sd_vfs);\n\terror = -ENOMEM;\n\tif (!inode)\n\t\tgoto fail_gunlock;\n\n\terror = posix_acl_create(dir, &mode, &default_acl, &acl);\n\tif (error)\n\t\tgoto fail_free_vfs_inode;\n\n\tip = GFS2_I(inode);\n\terror = gfs2_rs_alloc(ip);\n\tif (error)\n\t\tgoto fail_free_acls;\n\n\tinode->i_mode = mode;\n\tset_nlink(inode, S_ISDIR(mode) ? 2 : 1);\n\tinode->i_rdev = dev;\n\tinode->i_size = size;\n\tinode->i_atime = inode->i_mtime = inode->i_ctime = CURRENT_TIME;\n\tgfs2_set_inode_blocks(inode, 1);\n\tmunge_mode_uid_gid(dip, inode);\n\tcheck_and_update_goal(dip);\n\tip->i_goal = dip->i_goal;\n\tip->i_diskflags = 0;\n\tip->i_eattr = 0;\n\tip->i_height = 0;\n\tip->i_depth = 0;\n\tip->i_entries = 0;\n\n\tswitch(mode & S_IFMT) {\n\tcase S_IFREG:\n\t\tif ((dip->i_diskflags & GFS2_DIF_INHERIT_JDATA) ||\n\t\t    gfs2_tune_get(sdp, gt_new_files_jdata))\n\t\t\tip->i_diskflags |= GFS2_DIF_JDATA;\n\t\tgfs2_set_aops(inode);\n\t\tbreak;\n\tcase S_IFDIR:\n\t\tip->i_diskflags |= (dip->i_diskflags & GFS2_DIF_INHERIT_JDATA);\n\t\tip->i_diskflags |= GFS2_DIF_JDATA;\n\t\tip->i_entries = 2;\n\t\tbreak;\n\t}\n\tgfs2_set_inode_flags(inode);\n\n\tif ((GFS2_I(sdp->sd_root_dir->d_inode) == dip) ||\n\t    (dip->i_diskflags & GFS2_DIF_TOPDIR))\n\t\taflags |= GFS2_AF_ORLOV;\n\n\tif (default_acl || acl)\n\t\tblocks++;\n\n\terror = alloc_dinode(ip, aflags, &blocks);\n\tif (error)\n\t\tgoto fail_free_inode;\n\n\tgfs2_set_inode_blocks(inode, blocks);\n\n\terror = gfs2_glock_get(sdp, ip->i_no_addr, &gfs2_inode_glops, CREATE, &ip->i_gl);\n\tif (error)\n\t\tgoto fail_free_inode;\n\n\tip->i_gl->gl_object = ip;\n\terror = gfs2_glock_nq_init(ip->i_gl, LM_ST_EXCLUSIVE, GL_SKIP, ghs + 1);\n\tif (error)\n\t\tgoto fail_free_inode;\n\n\terror = gfs2_trans_begin(sdp, blocks, 0);\n\tif (error)\n\t\tgoto fail_gunlock2;\n\n\tif (blocks > 1) {\n\t\tip->i_eattr = ip->i_no_addr + 1;\n\t\tgfs2_init_xattr(ip);\n\t}\n\tinit_dinode(dip, ip, symname);\n\tgfs2_trans_end(sdp);\n\n\terror = gfs2_glock_get(sdp, ip->i_no_addr, &gfs2_iopen_glops, CREATE, &io_gl);\n\tif (error)\n\t\tgoto fail_gunlock2;\n\n\terror = gfs2_glock_nq_init(io_gl, LM_ST_SHARED, GL_EXACT, &ip->i_iopen_gh);\n\tif (error)\n\t\tgoto fail_gunlock2;\n\n\tip->i_iopen_gh.gh_gl->gl_object = ip;\n\tgfs2_glock_put(io_gl);\n\tgfs2_set_iop(inode);\n\tinsert_inode_hash(inode);\n\n\tif (default_acl) {\n\t\terror = gfs2_set_acl(inode, default_acl, ACL_TYPE_DEFAULT);\n\t\tposix_acl_release(default_acl);\n\t}\n\tif (acl) {\n\t\tif (!error)\n\t\t\terror = gfs2_set_acl(inode, acl, ACL_TYPE_ACCESS);\n\t\tposix_acl_release(acl);\n\t}\n\n\tif (error)\n\t\tgoto fail_gunlock3;\n\n\terror = security_inode_init_security(&ip->i_inode, &dip->i_inode, name,\n\t\t\t\t\t     &gfs2_initxattrs, NULL);\n\tif (error)\n\t\tgoto fail_gunlock3;\n\n\terror = link_dinode(dip, name, ip, &da);\n\tif (error)\n\t\tgoto fail_gunlock3;\n\n\tmark_inode_dirty(inode);\n\td_instantiate(dentry, inode);\n\tif (file) {\n\t\t*opened |= FILE_CREATED;\n\t\terror = finish_open(file, dentry, gfs2_open_common, opened);\n\t}\n\tgfs2_glock_dq_uninit(ghs);\n\tgfs2_glock_dq_uninit(ghs + 1);\n\treturn error;\n\nfail_gunlock3:\n\tgfs2_glock_dq_uninit(ghs + 1);\n\tif (ip->i_gl)\n\t\tgfs2_glock_put(ip->i_gl);\n\tgoto fail_gunlock;\n\nfail_gunlock2:\n\tgfs2_glock_dq_uninit(ghs + 1);\nfail_free_inode:\n\tif (ip->i_gl)\n\t\tgfs2_glock_put(ip->i_gl);\n\tgfs2_rs_delete(ip, NULL);\nfail_free_acls:\n\tif (default_acl)\n\t\tposix_acl_release(default_acl);\n\tif (acl)\n\t\tposix_acl_release(acl);\nfail_free_vfs_inode:\n\tfree_vfs_inode = 1;\nfail_gunlock:\n\tgfs2_dir_no_add(&da);\n\tgfs2_glock_dq_uninit(ghs);\n\tif (inode && !IS_ERR(inode)) {\n\t\tclear_nlink(inode);\n\t\tif (!free_vfs_inode)\n\t\t\tmark_inode_dirty(inode);\n\t\tset_bit(free_vfs_inode ? GIF_FREE_VFS_INODE : GIF_ALLOC_FAILED,\n\t\t\t&GFS2_I(inode)->i_flags);\n\t\tiput(inode);\n\t}\nfail:\n\treturn error;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"glops.h\"\n#include \"super.h\"\n#include \"util.h\"\n#include \"trans.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"xattr.h\"\n#include \"dir.h\"\n#include \"bmap.h\"\n#include \"acl.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <asm/uaccess.h>\n#include <linux/security.h>\n#include <linux/fiemap.h>\n#include <linux/crc32.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/posix_acl.h>\n#include <linux/xattr.h>\n#include <linux/mm.h>\n#include <linux/namei.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nstatic int gfs2_create(struct inode *dir, struct dentry *dentry,\n\t\t       umode_t mode, bool excl)\n{\n\treturn gfs2_create_inode(dir, dentry, NULL, S_IFREG | mode, 0, NULL, 0, excl, NULL);\n}"
  },
  {
    "function_name": "gfs2_create_inode",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/inode.c",
    "lines": "584-800",
    "snippet": "static int gfs2_create_inode(struct inode *dir, struct dentry *dentry,\n\t\t\t     struct file *file,\n\t\t\t     umode_t mode, dev_t dev, const char *symname,\n\t\t\t     unsigned int size, int excl, int *opened)\n{\n\tconst struct qstr *name = &dentry->d_name;\n\tstruct posix_acl *default_acl, *acl;\n\tstruct gfs2_holder ghs[2];\n\tstruct inode *inode = NULL;\n\tstruct gfs2_inode *dip = GFS2_I(dir), *ip;\n\tstruct gfs2_sbd *sdp = GFS2_SB(&dip->i_inode);\n\tstruct gfs2_glock *io_gl;\n\tint error, free_vfs_inode = 0;\n\tu32 aflags = 0;\n\tunsigned blocks = 1;\n\tstruct gfs2_diradd da = { .bh = NULL, .save_loc = 1, };\n\n\tif (!name->len || name->len > GFS2_FNAMESIZE)\n\t\treturn -ENAMETOOLONG;\n\n\terror = gfs2_rs_alloc(dip);\n\tif (error)\n\t\treturn error;\n\n\terror = gfs2_rindex_update(sdp);\n\tif (error)\n\t\treturn error;\n\n\terror = gfs2_glock_nq_init(dip->i_gl, LM_ST_EXCLUSIVE, 0, ghs);\n\tif (error)\n\t\tgoto fail;\n\n\terror = create_ok(dip, name, mode);\n\tif (error)\n\t\tgoto fail_gunlock;\n\n\tinode = gfs2_dir_search(dir, &dentry->d_name, !S_ISREG(mode) || excl);\n\terror = PTR_ERR(inode);\n\tif (!IS_ERR(inode)) {\n\t\tif (S_ISDIR(inode->i_mode)) {\n\t\t\tiput(inode);\n\t\t\tinode = ERR_PTR(-EISDIR);\n\t\t\tgoto fail_gunlock;\n\t\t}\n\t\td_instantiate(dentry, inode);\n\t\terror = 0;\n\t\tif (file) {\n\t\t\tif (S_ISREG(inode->i_mode))\n\t\t\t\terror = finish_open(file, dentry, gfs2_open_common, opened);\n\t\t\telse\n\t\t\t\terror = finish_no_open(file, NULL);\n\t\t}\n\t\tgfs2_glock_dq_uninit(ghs);\n\t\treturn error;\n\t} else if (error != -ENOENT) {\n\t\tgoto fail_gunlock;\n\t}\n\n\terror = gfs2_diradd_alloc_required(dir, name, &da);\n\tif (error < 0)\n\t\tgoto fail_gunlock;\n\n\tinode = new_inode(sdp->sd_vfs);\n\terror = -ENOMEM;\n\tif (!inode)\n\t\tgoto fail_gunlock;\n\n\terror = posix_acl_create(dir, &mode, &default_acl, &acl);\n\tif (error)\n\t\tgoto fail_free_vfs_inode;\n\n\tip = GFS2_I(inode);\n\terror = gfs2_rs_alloc(ip);\n\tif (error)\n\t\tgoto fail_free_acls;\n\n\tinode->i_mode = mode;\n\tset_nlink(inode, S_ISDIR(mode) ? 2 : 1);\n\tinode->i_rdev = dev;\n\tinode->i_size = size;\n\tinode->i_atime = inode->i_mtime = inode->i_ctime = CURRENT_TIME;\n\tgfs2_set_inode_blocks(inode, 1);\n\tmunge_mode_uid_gid(dip, inode);\n\tcheck_and_update_goal(dip);\n\tip->i_goal = dip->i_goal;\n\tip->i_diskflags = 0;\n\tip->i_eattr = 0;\n\tip->i_height = 0;\n\tip->i_depth = 0;\n\tip->i_entries = 0;\n\n\tswitch(mode & S_IFMT) {\n\tcase S_IFREG:\n\t\tif ((dip->i_diskflags & GFS2_DIF_INHERIT_JDATA) ||\n\t\t    gfs2_tune_get(sdp, gt_new_files_jdata))\n\t\t\tip->i_diskflags |= GFS2_DIF_JDATA;\n\t\tgfs2_set_aops(inode);\n\t\tbreak;\n\tcase S_IFDIR:\n\t\tip->i_diskflags |= (dip->i_diskflags & GFS2_DIF_INHERIT_JDATA);\n\t\tip->i_diskflags |= GFS2_DIF_JDATA;\n\t\tip->i_entries = 2;\n\t\tbreak;\n\t}\n\tgfs2_set_inode_flags(inode);\n\n\tif ((GFS2_I(sdp->sd_root_dir->d_inode) == dip) ||\n\t    (dip->i_diskflags & GFS2_DIF_TOPDIR))\n\t\taflags |= GFS2_AF_ORLOV;\n\n\tif (default_acl || acl)\n\t\tblocks++;\n\n\terror = alloc_dinode(ip, aflags, &blocks);\n\tif (error)\n\t\tgoto fail_free_inode;\n\n\tgfs2_set_inode_blocks(inode, blocks);\n\n\terror = gfs2_glock_get(sdp, ip->i_no_addr, &gfs2_inode_glops, CREATE, &ip->i_gl);\n\tif (error)\n\t\tgoto fail_free_inode;\n\n\tip->i_gl->gl_object = ip;\n\terror = gfs2_glock_nq_init(ip->i_gl, LM_ST_EXCLUSIVE, GL_SKIP, ghs + 1);\n\tif (error)\n\t\tgoto fail_free_inode;\n\n\terror = gfs2_trans_begin(sdp, blocks, 0);\n\tif (error)\n\t\tgoto fail_gunlock2;\n\n\tif (blocks > 1) {\n\t\tip->i_eattr = ip->i_no_addr + 1;\n\t\tgfs2_init_xattr(ip);\n\t}\n\tinit_dinode(dip, ip, symname);\n\tgfs2_trans_end(sdp);\n\n\terror = gfs2_glock_get(sdp, ip->i_no_addr, &gfs2_iopen_glops, CREATE, &io_gl);\n\tif (error)\n\t\tgoto fail_gunlock2;\n\n\terror = gfs2_glock_nq_init(io_gl, LM_ST_SHARED, GL_EXACT, &ip->i_iopen_gh);\n\tif (error)\n\t\tgoto fail_gunlock2;\n\n\tip->i_iopen_gh.gh_gl->gl_object = ip;\n\tgfs2_glock_put(io_gl);\n\tgfs2_set_iop(inode);\n\tinsert_inode_hash(inode);\n\n\tif (default_acl) {\n\t\terror = gfs2_set_acl(inode, default_acl, ACL_TYPE_DEFAULT);\n\t\tposix_acl_release(default_acl);\n\t}\n\tif (acl) {\n\t\tif (!error)\n\t\t\terror = gfs2_set_acl(inode, acl, ACL_TYPE_ACCESS);\n\t\tposix_acl_release(acl);\n\t}\n\n\tif (error)\n\t\tgoto fail_gunlock3;\n\n\terror = security_inode_init_security(&ip->i_inode, &dip->i_inode, name,\n\t\t\t\t\t     &gfs2_initxattrs, NULL);\n\tif (error)\n\t\tgoto fail_gunlock3;\n\n\terror = link_dinode(dip, name, ip, &da);\n\tif (error)\n\t\tgoto fail_gunlock3;\n\n\tmark_inode_dirty(inode);\n\td_instantiate(dentry, inode);\n\tif (file) {\n\t\t*opened |= FILE_CREATED;\n\t\terror = finish_open(file, dentry, gfs2_open_common, opened);\n\t}\n\tgfs2_glock_dq_uninit(ghs);\n\tgfs2_glock_dq_uninit(ghs + 1);\n\treturn error;\n\nfail_gunlock3:\n\tgfs2_glock_dq_uninit(ghs + 1);\n\tif (ip->i_gl)\n\t\tgfs2_glock_put(ip->i_gl);\n\tgoto fail_gunlock;\n\nfail_gunlock2:\n\tgfs2_glock_dq_uninit(ghs + 1);\nfail_free_inode:\n\tif (ip->i_gl)\n\t\tgfs2_glock_put(ip->i_gl);\n\tgfs2_rs_delete(ip, NULL);\nfail_free_acls:\n\tif (default_acl)\n\t\tposix_acl_release(default_acl);\n\tif (acl)\n\t\tposix_acl_release(acl);\nfail_free_vfs_inode:\n\tfree_vfs_inode = 1;\nfail_gunlock:\n\tgfs2_dir_no_add(&da);\n\tgfs2_glock_dq_uninit(ghs);\n\tif (inode && !IS_ERR(inode)) {\n\t\tclear_nlink(inode);\n\t\tif (!free_vfs_inode)\n\t\t\tmark_inode_dirty(inode);\n\t\tset_bit(free_vfs_inode ? GIF_FREE_VFS_INODE : GIF_ALLOC_FAILED,\n\t\t\t&GFS2_I(inode)->i_flags);\n\t\tiput(inode);\n\t}\nfail:\n\treturn error;\n}",
    "includes": [
      "#include \"glops.h\"",
      "#include \"super.h\"",
      "#include \"util.h\"",
      "#include \"trans.h\"",
      "#include \"rgrp.h\"",
      "#include \"quota.h\"",
      "#include \"meta_io.h\"",
      "#include \"inode.h\"",
      "#include \"glock.h\"",
      "#include \"xattr.h\"",
      "#include \"dir.h\"",
      "#include \"bmap.h\"",
      "#include \"acl.h\"",
      "#include \"incore.h\"",
      "#include \"gfs2.h\"",
      "#include <asm/uaccess.h>",
      "#include <linux/security.h>",
      "#include <linux/fiemap.h>",
      "#include <linux/crc32.h>",
      "#include <linux/gfs2_ondisk.h>",
      "#include <linux/posix_acl.h>",
      "#include <linux/xattr.h>",
      "#include <linux/mm.h>",
      "#include <linux/namei.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/completion.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "iput",
          "args": [
            "inode"
          ],
          "line": 796
        },
        "resolved": true,
        "details": {
          "function_name": "iput",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "1471-1488",
          "snippet": "void iput(struct inode *inode)\n{\n\tif (!inode)\n\t\treturn;\n\tBUG_ON(inode->i_state & I_CLEAR);\nretry:\n\tif (atomic_dec_and_lock(&inode->i_count, &inode->i_lock)) {\n\t\tif (inode->i_nlink && (inode->i_state & I_DIRTY_TIME)) {\n\t\t\tatomic_inc(&inode->i_count);\n\t\t\tinode->i_state &= ~I_DIRTY_TIME;\n\t\t\tspin_unlock(&inode->i_lock);\n\t\t\ttrace_writeback_lazytime_iput(inode);\n\t\t\tmark_inode_dirty_sync(inode);\n\t\t\tgoto retry;\n\t\t}\n\t\tiput_final(inode);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid iput(struct inode *inode)\n{\n\tif (!inode)\n\t\treturn;\n\tBUG_ON(inode->i_state & I_CLEAR);\nretry:\n\tif (atomic_dec_and_lock(&inode->i_count, &inode->i_lock)) {\n\t\tif (inode->i_nlink && (inode->i_state & I_DIRTY_TIME)) {\n\t\t\tatomic_inc(&inode->i_count);\n\t\t\tinode->i_state &= ~I_DIRTY_TIME;\n\t\t\tspin_unlock(&inode->i_lock);\n\t\t\ttrace_writeback_lazytime_iput(inode);\n\t\t\tmark_inode_dirty_sync(inode);\n\t\t\tgoto retry;\n\t\t}\n\t\tiput_final(inode);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_bit",
          "args": [
            "free_vfs_inode ? GIF_FREE_VFS_INODE : GIF_ALLOC_FAILED",
            "&GFS2_I(inode)->i_flags"
          ],
          "line": 794
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_set_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "886-890",
          "snippet": "static inline void ocfs2_set_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_set_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\nstatic inline void ocfs2_set_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_set_bit(bit, bitmap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "GFS2_I",
          "args": [
            "inode"
          ],
          "line": 795
        },
        "resolved": true,
        "details": {
          "function_name": "GFS2_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/incore.h",
          "lines": "408-411",
          "snippet": "static inline struct gfs2_inode *GFS2_I(struct inode *inode)\n{\n\treturn container_of(inode, struct gfs2_inode, i_inode);\n}",
          "includes": [
            "#include <linux/lockref.h>",
            "#include <linux/percpu.h>",
            "#include <linux/ktime.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/completion.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/dlm.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/kobject.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/lockref.h>\n#include <linux/percpu.h>\n#include <linux/ktime.h>\n#include <linux/rbtree.h>\n#include <linux/completion.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/buffer_head.h>\n#include <linux/dlm.h>\n#include <linux/workqueue.h>\n#include <linux/kobject.h>\n#include <linux/fs.h>\n\nstatic inline struct gfs2_inode *GFS2_I(struct inode *inode)\n{\n\treturn container_of(inode, struct gfs2_inode, i_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mark_inode_dirty",
          "args": [
            "inode"
          ],
          "line": 793
        },
        "resolved": true,
        "details": {
          "function_name": "block_dump___mark_inode_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fs-writeback.c",
          "lines": "1134-1154",
          "snippet": "static noinline void block_dump___mark_inode_dirty(struct inode *inode)\n{\n\tif (inode->i_ino || strcmp(inode->i_sb->s_id, \"bdev\")) {\n\t\tstruct dentry *dentry;\n\t\tconst char *name = \"?\";\n\n\t\tdentry = d_find_alias(inode);\n\t\tif (dentry) {\n\t\t\tspin_lock(&dentry->d_lock);\n\t\t\tname = (const char *) dentry->d_name.name;\n\t\t}\n\t\tprintk(KERN_DEBUG\n\t\t       \"%s(%d): dirtied inode %lu (%s) on %s\\n\",\n\t\t       current->comm, task_pid_nr(current), inode->i_ino,\n\t\t       name, inode->i_sb->s_id);\n\t\tif (dentry) {\n\t\t\tspin_unlock(&dentry->d_lock);\n\t\t\tdput(dentry);\n\t\t}\n\t}\n}",
          "includes": [
            "#include <trace/events/writeback.h>",
            "#include \"internal.h\"",
            "#include <linux/device.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/writeback.h>\n#include \"internal.h\"\n#include <linux/device.h>\n#include <linux/tracepoint.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nstatic noinline void block_dump___mark_inode_dirty(struct inode *inode)\n{\n\tif (inode->i_ino || strcmp(inode->i_sb->s_id, \"bdev\")) {\n\t\tstruct dentry *dentry;\n\t\tconst char *name = \"?\";\n\n\t\tdentry = d_find_alias(inode);\n\t\tif (dentry) {\n\t\t\tspin_lock(&dentry->d_lock);\n\t\t\tname = (const char *) dentry->d_name.name;\n\t\t}\n\t\tprintk(KERN_DEBUG\n\t\t       \"%s(%d): dirtied inode %lu (%s) on %s\\n\",\n\t\t       current->comm, task_pid_nr(current), inode->i_ino,\n\t\t       name, inode->i_sb->s_id);\n\t\tif (dentry) {\n\t\t\tspin_unlock(&dentry->d_lock);\n\t\t\tdput(dentry);\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "clear_nlink",
          "args": [
            "inode"
          ],
          "line": 791
        },
        "resolved": true,
        "details": {
          "function_name": "clear_nlink",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "288-294",
          "snippet": "void clear_nlink(struct inode *inode)\n{\n\tif (inode->i_nlink) {\n\t\tinode->__i_nlink = 0;\n\t\tatomic_long_inc(&inode->i_sb->s_remove_count);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid clear_nlink(struct inode *inode)\n{\n\tif (inode->i_nlink) {\n\t\tinode->__i_nlink = 0;\n\t\tatomic_long_inc(&inode->i_sb->s_remove_count);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "inode"
          ],
          "line": 790
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gfs2_glock_dq_uninit",
          "args": [
            "ghs"
          ],
          "line": 789
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_glock_dq_uninit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/glock.c",
          "lines": "1110-1114",
          "snippet": "void gfs2_glock_dq_uninit(struct gfs2_holder *gh)\n{\n\tgfs2_glock_dq(gh);\n\tgfs2_holder_uninit(gh);\n}",
          "includes": [
            "#include \"trace_gfs2.h\"",
            "#include \"bmap.h\"",
            "#include \"util.h\"",
            "#include \"super.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"lops.h\"",
            "#include \"inode.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/lockref.h>",
            "#include <linux/list_sort.h>",
            "#include <linux/percpu.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/seq_file.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/module.h>",
            "#include <linux/wait.h>",
            "#include <linux/list.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/jhash.h>",
            "#include <linux/sort.h>",
            "#include <linux/delay.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"bmap.h\"\n#include \"util.h\"\n#include \"super.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"lops.h\"\n#include \"inode.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/lockref.h>\n#include <linux/list_sort.h>\n#include <linux/percpu.h>\n#include <linux/bit_spinlock.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/jiffies.h>\n#include <linux/workqueue.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <asm/uaccess.h>\n#include <linux/module.h>\n#include <linux/wait.h>\n#include <linux/list.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/kallsyms.h>\n#include <linux/jhash.h>\n#include <linux/sort.h>\n#include <linux/delay.h>\n#include <linux/buffer_head.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nvoid gfs2_glock_dq_uninit(struct gfs2_holder *gh)\n{\n\tgfs2_glock_dq(gh);\n\tgfs2_holder_uninit(gh);\n}"
        }
      },
      {
        "call_info": {
          "callee": "gfs2_dir_no_add",
          "args": [
            "&da"
          ],
          "line": 788
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_dir_no_add",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/dir.h",
          "lines": "36-41",
          "snippet": "static inline void gfs2_dir_no_add(struct gfs2_diradd *da)\n{\n\tif (da->bh)\n\t\tbrelse(da->bh);\n\tda->bh = NULL;\n}",
          "includes": [
            "#include <linux/crc32.h>",
            "#include <linux/dcache.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/crc32.h>\n#include <linux/dcache.h>\n\nstatic inline void gfs2_dir_no_add(struct gfs2_diradd *da)\n{\n\tif (da->bh)\n\t\tbrelse(da->bh);\n\tda->bh = NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "posix_acl_release",
          "args": [
            "acl"
          ],
          "line": 784
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "posix_acl_release",
          "args": [
            "default_acl"
          ],
          "line": 782
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gfs2_rs_delete",
          "args": [
            "ip",
            "NULL"
          ],
          "line": 779
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_rs_delete",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/rgrp.c",
          "lines": "686-696",
          "snippet": "void gfs2_rs_delete(struct gfs2_inode *ip, atomic_t *wcount)\n{\n\tdown_write(&ip->i_rw_mutex);\n\tif (ip->i_res && ((wcount == NULL) || (atomic_read(wcount) <= 1))) {\n\t\tgfs2_rs_deltree(ip->i_res);\n\t\tBUG_ON(ip->i_res->rs_free);\n\t\tkmem_cache_free(gfs2_rsrv_cachep, ip->i_res);\n\t\tip->i_res = NULL;\n\t}\n\tup_write(&ip->i_rw_mutex);\n}",
          "includes": [
            "#include \"trace_gfs2.h\"",
            "#include \"inode.h\"",
            "#include \"log.h\"",
            "#include \"util.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"lops.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/random.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/fs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"inode.h\"\n#include \"log.h\"\n#include \"util.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"lops.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/random.h>\n#include <linux/rbtree.h>\n#include <linux/blkdev.h>\n#include <linux/prefetch.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/fs.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nvoid gfs2_rs_delete(struct gfs2_inode *ip, atomic_t *wcount)\n{\n\tdown_write(&ip->i_rw_mutex);\n\tif (ip->i_res && ((wcount == NULL) || (atomic_read(wcount) <= 1))) {\n\t\tgfs2_rs_deltree(ip->i_res);\n\t\tBUG_ON(ip->i_res->rs_free);\n\t\tkmem_cache_free(gfs2_rsrv_cachep, ip->i_res);\n\t\tip->i_res = NULL;\n\t}\n\tup_write(&ip->i_rw_mutex);\n}"
        }
      },
      {
        "call_info": {
          "callee": "gfs2_glock_put",
          "args": [
            "ip->i_gl"
          ],
          "line": 778
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_glock_put",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/glock.c",
          "lines": "193-212",
          "snippet": "void gfs2_glock_put(struct gfs2_glock *gl)\n{\n\tstruct gfs2_sbd *sdp = gl->gl_sbd;\n\tstruct address_space *mapping = gfs2_glock2aspace(gl);\n\n\tif (lockref_put_or_lock(&gl->gl_lockref))\n\t\treturn;\n\n\tlockref_mark_dead(&gl->gl_lockref);\n\n\tgfs2_glock_remove_from_lru(gl);\n\tspin_unlock(&gl->gl_lockref.lock);\n\tspin_lock_bucket(gl->gl_hash);\n\thlist_bl_del_rcu(&gl->gl_list);\n\tspin_unlock_bucket(gl->gl_hash);\n\tGLOCK_BUG_ON(gl, !list_empty(&gl->gl_holders));\n\tGLOCK_BUG_ON(gl, mapping && mapping->nrpages);\n\ttrace_gfs2_glock_put(gl);\n\tsdp->sd_lockstruct.ls_ops->lm_put_lock(gl);\n}",
          "includes": [
            "#include \"trace_gfs2.h\"",
            "#include \"bmap.h\"",
            "#include \"util.h\"",
            "#include \"super.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"lops.h\"",
            "#include \"inode.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/lockref.h>",
            "#include <linux/list_sort.h>",
            "#include <linux/percpu.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/seq_file.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/module.h>",
            "#include <linux/wait.h>",
            "#include <linux/list.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/jhash.h>",
            "#include <linux/sort.h>",
            "#include <linux/delay.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"bmap.h\"\n#include \"util.h\"\n#include \"super.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"lops.h\"\n#include \"inode.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/lockref.h>\n#include <linux/list_sort.h>\n#include <linux/percpu.h>\n#include <linux/bit_spinlock.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/jiffies.h>\n#include <linux/workqueue.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <asm/uaccess.h>\n#include <linux/module.h>\n#include <linux/wait.h>\n#include <linux/list.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/kallsyms.h>\n#include <linux/jhash.h>\n#include <linux/sort.h>\n#include <linux/delay.h>\n#include <linux/buffer_head.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nvoid gfs2_glock_put(struct gfs2_glock *gl)\n{\n\tstruct gfs2_sbd *sdp = gl->gl_sbd;\n\tstruct address_space *mapping = gfs2_glock2aspace(gl);\n\n\tif (lockref_put_or_lock(&gl->gl_lockref))\n\t\treturn;\n\n\tlockref_mark_dead(&gl->gl_lockref);\n\n\tgfs2_glock_remove_from_lru(gl);\n\tspin_unlock(&gl->gl_lockref.lock);\n\tspin_lock_bucket(gl->gl_hash);\n\thlist_bl_del_rcu(&gl->gl_list);\n\tspin_unlock_bucket(gl->gl_hash);\n\tGLOCK_BUG_ON(gl, !list_empty(&gl->gl_holders));\n\tGLOCK_BUG_ON(gl, mapping && mapping->nrpages);\n\ttrace_gfs2_glock_put(gl);\n\tsdp->sd_lockstruct.ls_ops->lm_put_lock(gl);\n}"
        }
      },
      {
        "call_info": {
          "callee": "finish_open",
          "args": [
            "file",
            "dentry",
            "gfs2_open_common",
            "opened"
          ],
          "line": 762
        },
        "resolved": true,
        "details": {
          "function_name": "finish_open",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/open.c",
          "lines": "784-797",
          "snippet": "int finish_open(struct file *file, struct dentry *dentry,\n\t\tint (*open)(struct inode *, struct file *),\n\t\tint *opened)\n{\n\tint error;\n\tBUG_ON(*opened & FILE_OPENED); /* once it's opened, it's opened */\n\n\tfile->f_path.dentry = dentry;\n\terror = do_dentry_open(file, open, current_cred());\n\tif (!error)\n\t\t*opened |= FILE_OPENED;\n\n\treturn error;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/compat.h>",
            "#include <linux/dnotify.h>",
            "#include <linux/ima.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/falloc.h>",
            "#include <linux/audit.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/personality.h>",
            "#include <linux/fs.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/mount.h>",
            "#include <linux/security.h>",
            "#include <linux/securebits.h>",
            "#include <linux/capability.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/namei.h>",
            "#include <linux/tty.h>",
            "#include <linux/module.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/compat.h>\n#include <linux/dnotify.h>\n#include <linux/ima.h>\n#include <linux/fs_struct.h>\n#include <linux/falloc.h>\n#include <linux/audit.h>\n#include <linux/rcupdate.h>\n#include <linux/syscalls.h>\n#include <linux/pagemap.h>\n#include <linux/personality.h>\n#include <linux/fs.h>\n#include <asm/uaccess.h>\n#include <linux/slab.h>\n#include <linux/fcntl.h>\n#include <linux/mount.h>\n#include <linux/security.h>\n#include <linux/securebits.h>\n#include <linux/capability.h>\n#include <linux/backing-dev.h>\n#include <linux/namei.h>\n#include <linux/tty.h>\n#include <linux/module.h>\n#include <linux/fsnotify.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n\nint finish_open(struct file *file, struct dentry *dentry,\n\t\tint (*open)(struct inode *, struct file *),\n\t\tint *opened)\n{\n\tint error;\n\tBUG_ON(*opened & FILE_OPENED); /* once it's opened, it's opened */\n\n\tfile->f_path.dentry = dentry;\n\terror = do_dentry_open(file, open, current_cred());\n\tif (!error)\n\t\t*opened |= FILE_OPENED;\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "d_instantiate",
          "args": [
            "dentry",
            "inode"
          ],
          "line": 759
        },
        "resolved": true,
        "details": {
          "function_name": "d_instantiate_no_diralias",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "1839-1854",
          "snippet": "int d_instantiate_no_diralias(struct dentry *entry, struct inode *inode)\n{\n\tBUG_ON(!hlist_unhashed(&entry->d_u.d_alias));\n\n\tspin_lock(&inode->i_lock);\n\tif (S_ISDIR(inode->i_mode) && !hlist_empty(&inode->i_dentry)) {\n\t\tspin_unlock(&inode->i_lock);\n\t\tiput(inode);\n\t\treturn -EBUSY;\n\t}\n\t__d_instantiate(entry, inode);\n\tspin_unlock(&inode->i_lock);\n\tsecurity_d_instantiate(entry, inode);\n\n\treturn 0;\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nint d_instantiate_no_diralias(struct dentry *entry, struct inode *inode)\n{\n\tBUG_ON(!hlist_unhashed(&entry->d_u.d_alias));\n\n\tspin_lock(&inode->i_lock);\n\tif (S_ISDIR(inode->i_mode) && !hlist_empty(&inode->i_dentry)) {\n\t\tspin_unlock(&inode->i_lock);\n\t\tiput(inode);\n\t\treturn -EBUSY;\n\t}\n\t__d_instantiate(entry, inode);\n\tspin_unlock(&inode->i_lock);\n\tsecurity_d_instantiate(entry, inode);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "link_dinode",
          "args": [
            "dip",
            "name",
            "ip",
            "&da"
          ],
          "line": 754
        },
        "resolved": true,
        "details": {
          "function_name": "link_dinode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/inode.c",
          "lines": "520-553",
          "snippet": "static int link_dinode(struct gfs2_inode *dip, const struct qstr *name,\n\t\t       struct gfs2_inode *ip, struct gfs2_diradd *da)\n{\n\tstruct gfs2_sbd *sdp = GFS2_SB(&dip->i_inode);\n\tstruct gfs2_alloc_parms ap = { .target = da->nr_blocks, };\n\tint error;\n\n\tif (da->nr_blocks) {\n\t\terror = gfs2_quota_lock_check(dip);\n\t\tif (error)\n\t\t\tgoto fail_quota_locks;\n\n\t\terror = gfs2_inplace_reserve(dip, &ap);\n\t\tif (error)\n\t\t\tgoto fail_quota_locks;\n\n\t\terror = gfs2_trans_begin(sdp, gfs2_trans_da_blks(dip, da, 2), 0);\n\t\tif (error)\n\t\t\tgoto fail_ipreserv;\n\t} else {\n\t\terror = gfs2_trans_begin(sdp, RES_LEAF + 2 * RES_DINODE, 0);\n\t\tif (error)\n\t\t\tgoto fail_quota_locks;\n\t}\n\n\terror = gfs2_dir_add(&dip->i_inode, name, ip, da);\n\n\tgfs2_trans_end(sdp);\nfail_ipreserv:\n\tgfs2_inplace_release(dip);\nfail_quota_locks:\n\tgfs2_quota_unlock(dip);\n\treturn error;\n}",
          "includes": [
            "#include \"glops.h\"",
            "#include \"super.h\"",
            "#include \"util.h\"",
            "#include \"trans.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"inode.h\"",
            "#include \"glock.h\"",
            "#include \"xattr.h\"",
            "#include \"dir.h\"",
            "#include \"bmap.h\"",
            "#include \"acl.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/security.h>",
            "#include <linux/fiemap.h>",
            "#include <linux/crc32.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/xattr.h>",
            "#include <linux/mm.h>",
            "#include <linux/namei.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glops.h\"\n#include \"super.h\"\n#include \"util.h\"\n#include \"trans.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"xattr.h\"\n#include \"dir.h\"\n#include \"bmap.h\"\n#include \"acl.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <asm/uaccess.h>\n#include <linux/security.h>\n#include <linux/fiemap.h>\n#include <linux/crc32.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/posix_acl.h>\n#include <linux/xattr.h>\n#include <linux/mm.h>\n#include <linux/namei.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nstatic int link_dinode(struct gfs2_inode *dip, const struct qstr *name,\n\t\t       struct gfs2_inode *ip, struct gfs2_diradd *da)\n{\n\tstruct gfs2_sbd *sdp = GFS2_SB(&dip->i_inode);\n\tstruct gfs2_alloc_parms ap = { .target = da->nr_blocks, };\n\tint error;\n\n\tif (da->nr_blocks) {\n\t\terror = gfs2_quota_lock_check(dip);\n\t\tif (error)\n\t\t\tgoto fail_quota_locks;\n\n\t\terror = gfs2_inplace_reserve(dip, &ap);\n\t\tif (error)\n\t\t\tgoto fail_quota_locks;\n\n\t\terror = gfs2_trans_begin(sdp, gfs2_trans_da_blks(dip, da, 2), 0);\n\t\tif (error)\n\t\t\tgoto fail_ipreserv;\n\t} else {\n\t\terror = gfs2_trans_begin(sdp, RES_LEAF + 2 * RES_DINODE, 0);\n\t\tif (error)\n\t\t\tgoto fail_quota_locks;\n\t}\n\n\terror = gfs2_dir_add(&dip->i_inode, name, ip, da);\n\n\tgfs2_trans_end(sdp);\nfail_ipreserv:\n\tgfs2_inplace_release(dip);\nfail_quota_locks:\n\tgfs2_quota_unlock(dip);\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "security_inode_init_security",
          "args": [
            "&ip->i_inode",
            "&dip->i_inode",
            "name",
            "&gfs2_initxattrs",
            "NULL"
          ],
          "line": 749
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "posix_acl_release",
          "args": [
            "acl"
          ],
          "line": 743
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gfs2_set_acl",
          "args": [
            "inode",
            "acl",
            "ACL_TYPE_ACCESS"
          ],
          "line": 742
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_set_acl",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/acl.c",
          "lines": "67-121",
          "snippet": "int gfs2_set_acl(struct inode *inode, struct posix_acl *acl, int type)\n{\n\tint error;\n\tint len;\n\tchar *data;\n\tconst char *name = gfs2_acl_name(type);\n\n\tBUG_ON(name == NULL);\n\n\tif (acl && acl->a_count > GFS2_ACL_MAX_ENTRIES(GFS2_SB(inode)))\n\t\treturn -E2BIG;\n\n\tif (type == ACL_TYPE_ACCESS) {\n\t\tumode_t mode = inode->i_mode;\n\n\t\terror = posix_acl_equiv_mode(acl, &mode);\n\t\tif (error < 0)\n\t\t\treturn error;\n\n\t\tif (error == 0)\n\t\t\tacl = NULL;\n\n\t\tif (mode != inode->i_mode) {\n\t\t\tinode->i_mode = mode;\n\t\t\tmark_inode_dirty(inode);\n\t\t}\n\t}\n\n\tif (acl) {\n\t\tlen = posix_acl_to_xattr(&init_user_ns, acl, NULL, 0);\n\t\tif (len == 0)\n\t\t\treturn 0;\n\t\tdata = kmalloc(len, GFP_NOFS);\n\t\tif (data == NULL)\n\t\t\treturn -ENOMEM;\n\t\terror = posix_acl_to_xattr(&init_user_ns, acl, data, len);\n\t\tif (error < 0)\n\t\t\tgoto out;\n\t} else {\n\t\tdata = NULL;\n\t\tlen = 0;\n\t}\n\n\terror = __gfs2_xattr_set(inode, name, data, len, 0, GFS2_EATYPE_SYS);\n\tif (error)\n\t\tgoto out;\n\n\tif (acl)\n\t\tset_cached_acl(inode, type, acl);\n\telse\n\t\tforget_cached_acl(inode, type);\nout:\n\tkfree(data);\n\treturn error;\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"trans.h\"",
            "#include \"meta_io.h\"",
            "#include \"inode.h\"",
            "#include \"glock.h\"",
            "#include \"xattr.h\"",
            "#include \"acl.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/xattr.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"trans.h\"\n#include \"meta_io.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"xattr.h\"\n#include \"acl.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/gfs2_ondisk.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/posix_acl.h>\n#include <linux/xattr.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nint gfs2_set_acl(struct inode *inode, struct posix_acl *acl, int type)\n{\n\tint error;\n\tint len;\n\tchar *data;\n\tconst char *name = gfs2_acl_name(type);\n\n\tBUG_ON(name == NULL);\n\n\tif (acl && acl->a_count > GFS2_ACL_MAX_ENTRIES(GFS2_SB(inode)))\n\t\treturn -E2BIG;\n\n\tif (type == ACL_TYPE_ACCESS) {\n\t\tumode_t mode = inode->i_mode;\n\n\t\terror = posix_acl_equiv_mode(acl, &mode);\n\t\tif (error < 0)\n\t\t\treturn error;\n\n\t\tif (error == 0)\n\t\t\tacl = NULL;\n\n\t\tif (mode != inode->i_mode) {\n\t\t\tinode->i_mode = mode;\n\t\t\tmark_inode_dirty(inode);\n\t\t}\n\t}\n\n\tif (acl) {\n\t\tlen = posix_acl_to_xattr(&init_user_ns, acl, NULL, 0);\n\t\tif (len == 0)\n\t\t\treturn 0;\n\t\tdata = kmalloc(len, GFP_NOFS);\n\t\tif (data == NULL)\n\t\t\treturn -ENOMEM;\n\t\terror = posix_acl_to_xattr(&init_user_ns, acl, data, len);\n\t\tif (error < 0)\n\t\t\tgoto out;\n\t} else {\n\t\tdata = NULL;\n\t\tlen = 0;\n\t}\n\n\terror = __gfs2_xattr_set(inode, name, data, len, 0, GFS2_EATYPE_SYS);\n\tif (error)\n\t\tgoto out;\n\n\tif (acl)\n\t\tset_cached_acl(inode, type, acl);\n\telse\n\t\tforget_cached_acl(inode, type);\nout:\n\tkfree(data);\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "posix_acl_release",
          "args": [
            "default_acl"
          ],
          "line": 738
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "insert_inode_hash",
          "args": [
            "inode"
          ],
          "line": 734
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_insert_inode_hash",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/btrfs_inode.h",
          "lines": "213-218",
          "snippet": "static inline void btrfs_insert_inode_hash(struct inode *inode)\n{\n\tunsigned long h = btrfs_inode_hash(inode->i_ino, BTRFS_I(inode)->root);\n\n\t__insert_inode_hash(inode, h);\n}",
          "includes": [
            "#include \"delayed-inode.h\"",
            "#include \"ordered-data.h\"",
            "#include \"extent_io.h\"",
            "#include \"extent_map.h\"",
            "#include <linux/hash.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"delayed-inode.h\"\n#include \"ordered-data.h\"\n#include \"extent_io.h\"\n#include \"extent_map.h\"\n#include <linux/hash.h>\n\nstatic inline void btrfs_insert_inode_hash(struct inode *inode)\n{\n\tunsigned long h = btrfs_inode_hash(inode->i_ino, BTRFS_I(inode)->root);\n\n\t__insert_inode_hash(inode, h);\n}"
        }
      },
      {
        "call_info": {
          "callee": "gfs2_set_iop",
          "args": [
            "inode"
          ],
          "line": 733
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_set_iop",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/inode.c",
          "lines": "105-128",
          "snippet": "static void gfs2_set_iop(struct inode *inode)\n{\n\tstruct gfs2_sbd *sdp = GFS2_SB(inode);\n\tumode_t mode = inode->i_mode;\n\n\tif (S_ISREG(mode)) {\n\t\tinode->i_op = &gfs2_file_iops;\n\t\tif (gfs2_localflocks(sdp))\n\t\t\tinode->i_fop = &gfs2_file_fops_nolock;\n\t\telse\n\t\t\tinode->i_fop = &gfs2_file_fops;\n\t} else if (S_ISDIR(mode)) {\n\t\tinode->i_op = &gfs2_dir_iops;\n\t\tif (gfs2_localflocks(sdp))\n\t\t\tinode->i_fop = &gfs2_dir_fops_nolock;\n\t\telse\n\t\t\tinode->i_fop = &gfs2_dir_fops;\n\t} else if (S_ISLNK(mode)) {\n\t\tinode->i_op = &gfs2_symlink_iops;\n\t} else {\n\t\tinode->i_op = &gfs2_file_iops;\n\t\tinit_special_inode(inode, inode->i_mode, inode->i_rdev);\n\t}\n}",
          "includes": [
            "#include \"glops.h\"",
            "#include \"super.h\"",
            "#include \"util.h\"",
            "#include \"trans.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"inode.h\"",
            "#include \"glock.h\"",
            "#include \"xattr.h\"",
            "#include \"dir.h\"",
            "#include \"bmap.h\"",
            "#include \"acl.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/security.h>",
            "#include <linux/fiemap.h>",
            "#include <linux/crc32.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/xattr.h>",
            "#include <linux/mm.h>",
            "#include <linux/namei.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "const struct inode_operations gfs2_file_iops = {\n\t.permission = gfs2_permission,\n\t.setattr = gfs2_setattr,\n\t.getattr = gfs2_getattr,\n\t.setxattr = gfs2_setxattr,\n\t.getxattr = gfs2_getxattr,\n\t.listxattr = gfs2_listxattr,\n\t.removexattr = gfs2_removexattr,\n\t.fiemap = gfs2_fiemap,\n\t.get_acl = gfs2_get_acl,\n\t.set_acl = gfs2_set_acl,\n};",
            "const struct inode_operations gfs2_dir_iops = {\n\t.create = gfs2_create,\n\t.lookup = gfs2_lookup,\n\t.link = gfs2_link,\n\t.unlink = gfs2_unlink,\n\t.symlink = gfs2_symlink,\n\t.mkdir = gfs2_mkdir,\n\t.rmdir = gfs2_unlink,\n\t.mknod = gfs2_mknod,\n\t.rename = gfs2_rename,\n\t.permission = gfs2_permission,\n\t.setattr = gfs2_setattr,\n\t.getattr = gfs2_getattr,\n\t.setxattr = gfs2_setxattr,\n\t.getxattr = gfs2_getxattr,\n\t.listxattr = gfs2_listxattr,\n\t.removexattr = gfs2_removexattr,\n\t.fiemap = gfs2_fiemap,\n\t.get_acl = gfs2_get_acl,\n\t.set_acl = gfs2_set_acl,\n\t.atomic_open = gfs2_atomic_open,\n};",
            "const struct inode_operations gfs2_symlink_iops = {\n\t.readlink = generic_readlink,\n\t.follow_link = gfs2_follow_link,\n\t.put_link = kfree_put_link,\n\t.permission = gfs2_permission,\n\t.setattr = gfs2_setattr,\n\t.getattr = gfs2_getattr,\n\t.setxattr = gfs2_setxattr,\n\t.getxattr = gfs2_getxattr,\n\t.listxattr = gfs2_listxattr,\n\t.removexattr = gfs2_removexattr,\n\t.fiemap = gfs2_fiemap,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"glops.h\"\n#include \"super.h\"\n#include \"util.h\"\n#include \"trans.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"xattr.h\"\n#include \"dir.h\"\n#include \"bmap.h\"\n#include \"acl.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <asm/uaccess.h>\n#include <linux/security.h>\n#include <linux/fiemap.h>\n#include <linux/crc32.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/posix_acl.h>\n#include <linux/xattr.h>\n#include <linux/mm.h>\n#include <linux/namei.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nconst struct inode_operations gfs2_file_iops = {\n\t.permission = gfs2_permission,\n\t.setattr = gfs2_setattr,\n\t.getattr = gfs2_getattr,\n\t.setxattr = gfs2_setxattr,\n\t.getxattr = gfs2_getxattr,\n\t.listxattr = gfs2_listxattr,\n\t.removexattr = gfs2_removexattr,\n\t.fiemap = gfs2_fiemap,\n\t.get_acl = gfs2_get_acl,\n\t.set_acl = gfs2_set_acl,\n};\nconst struct inode_operations gfs2_dir_iops = {\n\t.create = gfs2_create,\n\t.lookup = gfs2_lookup,\n\t.link = gfs2_link,\n\t.unlink = gfs2_unlink,\n\t.symlink = gfs2_symlink,\n\t.mkdir = gfs2_mkdir,\n\t.rmdir = gfs2_unlink,\n\t.mknod = gfs2_mknod,\n\t.rename = gfs2_rename,\n\t.permission = gfs2_permission,\n\t.setattr = gfs2_setattr,\n\t.getattr = gfs2_getattr,\n\t.setxattr = gfs2_setxattr,\n\t.getxattr = gfs2_getxattr,\n\t.listxattr = gfs2_listxattr,\n\t.removexattr = gfs2_removexattr,\n\t.fiemap = gfs2_fiemap,\n\t.get_acl = gfs2_get_acl,\n\t.set_acl = gfs2_set_acl,\n\t.atomic_open = gfs2_atomic_open,\n};\nconst struct inode_operations gfs2_symlink_iops = {\n\t.readlink = generic_readlink,\n\t.follow_link = gfs2_follow_link,\n\t.put_link = kfree_put_link,\n\t.permission = gfs2_permission,\n\t.setattr = gfs2_setattr,\n\t.getattr = gfs2_getattr,\n\t.setxattr = gfs2_setxattr,\n\t.getxattr = gfs2_getxattr,\n\t.listxattr = gfs2_listxattr,\n\t.removexattr = gfs2_removexattr,\n\t.fiemap = gfs2_fiemap,\n};\n\nstatic void gfs2_set_iop(struct inode *inode)\n{\n\tstruct gfs2_sbd *sdp = GFS2_SB(inode);\n\tumode_t mode = inode->i_mode;\n\n\tif (S_ISREG(mode)) {\n\t\tinode->i_op = &gfs2_file_iops;\n\t\tif (gfs2_localflocks(sdp))\n\t\t\tinode->i_fop = &gfs2_file_fops_nolock;\n\t\telse\n\t\t\tinode->i_fop = &gfs2_file_fops;\n\t} else if (S_ISDIR(mode)) {\n\t\tinode->i_op = &gfs2_dir_iops;\n\t\tif (gfs2_localflocks(sdp))\n\t\t\tinode->i_fop = &gfs2_dir_fops_nolock;\n\t\telse\n\t\t\tinode->i_fop = &gfs2_dir_fops;\n\t} else if (S_ISLNK(mode)) {\n\t\tinode->i_op = &gfs2_symlink_iops;\n\t} else {\n\t\tinode->i_op = &gfs2_file_iops;\n\t\tinit_special_inode(inode, inode->i_mode, inode->i_rdev);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "gfs2_glock_nq_init",
          "args": [
            "io_gl",
            "LM_ST_SHARED",
            "GL_EXACT",
            "&ip->i_iopen_gh"
          ],
          "line": 727
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_glock_nq_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/glock.h",
          "lines": "204-230",
          "snippet": "extern __printf(2, 3)\nvoid gfs2_print_dbg(struct seq_file *seq, const char *fmt, ...);\n\n/**\n * gfs2_glock_nq_init - initialize a holder and enqueue it on a glock\n * @gl: the glock\n * @state: the state we're requesting\n * @flags: the modifier flags\n * @gh: the holder structure\n *\n * Returns: 0, GLR_*, or errno\n */\n\nstatic inline int gfs2_glock_nq_init(struct gfs2_glock *gl,\n\t\t\t\t     unsigned int state, int flags,\n\t\t\t\t     struct gfs2_holder *gh)\n{\n\tint error;\n\n\tgfs2_holder_init(gl, state, flags, gh);\n\n\terror = gfs2_glock_nq(gh);\n\tif (error)\n\t\tgfs2_holder_uninit(gh);\n\n\treturn error;\n}",
          "includes": [
            "#include \"incore.h\"",
            "#include <linux/parser.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"incore.h\"\n#include <linux/parser.h>\n#include <linux/sched.h>\n\nextern __printf(2, 3)\nvoid gfs2_print_dbg(struct seq_file *seq, const char *fmt, ...);\n\n/**\n * gfs2_glock_nq_init - initialize a holder and enqueue it on a glock\n * @gl: the glock\n * @state: the state we're requesting\n * @flags: the modifier flags\n * @gh: the holder structure\n *\n * Returns: 0, GLR_*, or errno\n */\n\nstatic inline int gfs2_glock_nq_init(struct gfs2_glock *gl,\n\t\t\t\t     unsigned int state, int flags,\n\t\t\t\t     struct gfs2_holder *gh)\n{\n\tint error;\n\n\tgfs2_holder_init(gl, state, flags, gh);\n\n\terror = gfs2_glock_nq(gh);\n\tif (error)\n\t\tgfs2_holder_uninit(gh);\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "gfs2_glock_get",
          "args": [
            "sdp",
            "ip->i_no_addr",
            "&gfs2_iopen_glops",
            "CREATE",
            "&io_gl"
          ],
          "line": 723
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_glock_get",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/glock.c",
          "lines": "702-790",
          "snippet": "int gfs2_glock_get(struct gfs2_sbd *sdp, u64 number,\n\t\t   const struct gfs2_glock_operations *glops, int create,\n\t\t   struct gfs2_glock **glp)\n{\n\tstruct super_block *s = sdp->sd_vfs;\n\tstruct lm_lockname name = { .ln_number = number, .ln_type = glops->go_type };\n\tstruct gfs2_glock *gl, *tmp;\n\tunsigned int hash = gl_hash(sdp, &name);\n\tstruct address_space *mapping;\n\tstruct kmem_cache *cachep;\n\n\trcu_read_lock();\n\tgl = search_bucket(hash, sdp, &name);\n\trcu_read_unlock();\n\n\t*glp = gl;\n\tif (gl)\n\t\treturn 0;\n\tif (!create)\n\t\treturn -ENOENT;\n\n\tif (glops->go_flags & GLOF_ASPACE)\n\t\tcachep = gfs2_glock_aspace_cachep;\n\telse\n\t\tcachep = gfs2_glock_cachep;\n\tgl = kmem_cache_alloc(cachep, GFP_NOFS);\n\tif (!gl)\n\t\treturn -ENOMEM;\n\n\tmemset(&gl->gl_lksb, 0, sizeof(struct dlm_lksb));\n\n\tif (glops->go_flags & GLOF_LVB) {\n\t\tgl->gl_lksb.sb_lvbptr = kzalloc(GFS2_MIN_LVB_SIZE, GFP_NOFS);\n\t\tif (!gl->gl_lksb.sb_lvbptr) {\n\t\t\tkmem_cache_free(cachep, gl);\n\t\t\treturn -ENOMEM;\n\t\t}\n\t}\n\n\tatomic_inc(&sdp->sd_glock_disposal);\n\tgl->gl_sbd = sdp;\n\tgl->gl_flags = 0;\n\tgl->gl_name = name;\n\tgl->gl_lockref.count = 1;\n\tgl->gl_state = LM_ST_UNLOCKED;\n\tgl->gl_target = LM_ST_UNLOCKED;\n\tgl->gl_demote_state = LM_ST_EXCLUSIVE;\n\tgl->gl_hash = hash;\n\tgl->gl_ops = glops;\n\tgl->gl_dstamp = ktime_set(0, 0);\n\tpreempt_disable();\n\t/* We use the global stats to estimate the initial per-glock stats */\n\tgl->gl_stats = this_cpu_ptr(sdp->sd_lkstats)->lkstats[glops->go_type];\n\tpreempt_enable();\n\tgl->gl_stats.stats[GFS2_LKS_DCOUNT] = 0;\n\tgl->gl_stats.stats[GFS2_LKS_QCOUNT] = 0;\n\tgl->gl_tchange = jiffies;\n\tgl->gl_object = NULL;\n\tgl->gl_hold_time = GL_GLOCK_DFT_HOLD;\n\tINIT_DELAYED_WORK(&gl->gl_work, glock_work_func);\n\tINIT_WORK(&gl->gl_delete, delete_work_func);\n\n\tmapping = gfs2_glock2aspace(gl);\n\tif (mapping) {\n                mapping->a_ops = &gfs2_meta_aops;\n\t\tmapping->host = s->s_bdev->bd_inode;\n\t\tmapping->flags = 0;\n\t\tmapping_set_gfp_mask(mapping, GFP_NOFS);\n\t\tmapping->private_data = NULL;\n\t\tmapping->writeback_index = 0;\n\t}\n\n\tspin_lock_bucket(hash);\n\ttmp = search_bucket(hash, sdp, &name);\n\tif (tmp) {\n\t\tspin_unlock_bucket(hash);\n\t\tkfree(gl->gl_lksb.sb_lvbptr);\n\t\tkmem_cache_free(cachep, gl);\n\t\tatomic_dec(&sdp->sd_glock_disposal);\n\t\tgl = tmp;\n\t} else {\n\t\thlist_bl_add_head_rcu(&gl->gl_list, &gl_hash_table[hash]);\n\t\tspin_unlock_bucket(hash);\n\t}\n\n\t*glp = gl;\n\n\treturn 0;\n}",
          "includes": [
            "#include \"trace_gfs2.h\"",
            "#include \"bmap.h\"",
            "#include \"util.h\"",
            "#include \"super.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"lops.h\"",
            "#include \"inode.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/lockref.h>",
            "#include <linux/list_sort.h>",
            "#include <linux/percpu.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/seq_file.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/module.h>",
            "#include <linux/wait.h>",
            "#include <linux/list.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/jhash.h>",
            "#include <linux/sort.h>",
            "#include <linux/delay.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct hlist_bl_head gl_hash_table[GFS2_GL_HASH_SIZE];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"bmap.h\"\n#include \"util.h\"\n#include \"super.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"lops.h\"\n#include \"inode.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/lockref.h>\n#include <linux/list_sort.h>\n#include <linux/percpu.h>\n#include <linux/bit_spinlock.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/jiffies.h>\n#include <linux/workqueue.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <asm/uaccess.h>\n#include <linux/module.h>\n#include <linux/wait.h>\n#include <linux/list.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/kallsyms.h>\n#include <linux/jhash.h>\n#include <linux/sort.h>\n#include <linux/delay.h>\n#include <linux/buffer_head.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic struct hlist_bl_head gl_hash_table[GFS2_GL_HASH_SIZE];\n\nint gfs2_glock_get(struct gfs2_sbd *sdp, u64 number,\n\t\t   const struct gfs2_glock_operations *glops, int create,\n\t\t   struct gfs2_glock **glp)\n{\n\tstruct super_block *s = sdp->sd_vfs;\n\tstruct lm_lockname name = { .ln_number = number, .ln_type = glops->go_type };\n\tstruct gfs2_glock *gl, *tmp;\n\tunsigned int hash = gl_hash(sdp, &name);\n\tstruct address_space *mapping;\n\tstruct kmem_cache *cachep;\n\n\trcu_read_lock();\n\tgl = search_bucket(hash, sdp, &name);\n\trcu_read_unlock();\n\n\t*glp = gl;\n\tif (gl)\n\t\treturn 0;\n\tif (!create)\n\t\treturn -ENOENT;\n\n\tif (glops->go_flags & GLOF_ASPACE)\n\t\tcachep = gfs2_glock_aspace_cachep;\n\telse\n\t\tcachep = gfs2_glock_cachep;\n\tgl = kmem_cache_alloc(cachep, GFP_NOFS);\n\tif (!gl)\n\t\treturn -ENOMEM;\n\n\tmemset(&gl->gl_lksb, 0, sizeof(struct dlm_lksb));\n\n\tif (glops->go_flags & GLOF_LVB) {\n\t\tgl->gl_lksb.sb_lvbptr = kzalloc(GFS2_MIN_LVB_SIZE, GFP_NOFS);\n\t\tif (!gl->gl_lksb.sb_lvbptr) {\n\t\t\tkmem_cache_free(cachep, gl);\n\t\t\treturn -ENOMEM;\n\t\t}\n\t}\n\n\tatomic_inc(&sdp->sd_glock_disposal);\n\tgl->gl_sbd = sdp;\n\tgl->gl_flags = 0;\n\tgl->gl_name = name;\n\tgl->gl_lockref.count = 1;\n\tgl->gl_state = LM_ST_UNLOCKED;\n\tgl->gl_target = LM_ST_UNLOCKED;\n\tgl->gl_demote_state = LM_ST_EXCLUSIVE;\n\tgl->gl_hash = hash;\n\tgl->gl_ops = glops;\n\tgl->gl_dstamp = ktime_set(0, 0);\n\tpreempt_disable();\n\t/* We use the global stats to estimate the initial per-glock stats */\n\tgl->gl_stats = this_cpu_ptr(sdp->sd_lkstats)->lkstats[glops->go_type];\n\tpreempt_enable();\n\tgl->gl_stats.stats[GFS2_LKS_DCOUNT] = 0;\n\tgl->gl_stats.stats[GFS2_LKS_QCOUNT] = 0;\n\tgl->gl_tchange = jiffies;\n\tgl->gl_object = NULL;\n\tgl->gl_hold_time = GL_GLOCK_DFT_HOLD;\n\tINIT_DELAYED_WORK(&gl->gl_work, glock_work_func);\n\tINIT_WORK(&gl->gl_delete, delete_work_func);\n\n\tmapping = gfs2_glock2aspace(gl);\n\tif (mapping) {\n                mapping->a_ops = &gfs2_meta_aops;\n\t\tmapping->host = s->s_bdev->bd_inode;\n\t\tmapping->flags = 0;\n\t\tmapping_set_gfp_mask(mapping, GFP_NOFS);\n\t\tmapping->private_data = NULL;\n\t\tmapping->writeback_index = 0;\n\t}\n\n\tspin_lock_bucket(hash);\n\ttmp = search_bucket(hash, sdp, &name);\n\tif (tmp) {\n\t\tspin_unlock_bucket(hash);\n\t\tkfree(gl->gl_lksb.sb_lvbptr);\n\t\tkmem_cache_free(cachep, gl);\n\t\tatomic_dec(&sdp->sd_glock_disposal);\n\t\tgl = tmp;\n\t} else {\n\t\thlist_bl_add_head_rcu(&gl->gl_list, &gl_hash_table[hash]);\n\t\tspin_unlock_bucket(hash);\n\t}\n\n\t*glp = gl;\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "gfs2_trans_end",
          "args": [
            "sdp"
          ],
          "line": 721
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_trans_end",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/trans.c",
          "lines": "88-123",
          "snippet": "void gfs2_trans_end(struct gfs2_sbd *sdp)\n{\n\tstruct gfs2_trans *tr = current->journal_info;\n\ts64 nbuf;\n\tint alloced = tr->tr_alloced;\n\n\tBUG_ON(!tr);\n\tcurrent->journal_info = NULL;\n\n\tif (!tr->tr_touched) {\n\t\tgfs2_log_release(sdp, tr->tr_reserved);\n\t\tif (alloced) {\n\t\t\tkfree(tr);\n\t\t\tsb_end_intwrite(sdp->sd_vfs);\n\t\t}\n\t\treturn;\n\t}\n\n\tnbuf = tr->tr_num_buf_new + tr->tr_num_databuf_new;\n\tnbuf -= tr->tr_num_buf_rm;\n\tnbuf -= tr->tr_num_databuf_rm;\n\n\tif (gfs2_assert_withdraw(sdp, (nbuf <= tr->tr_blocks) &&\n\t\t\t\t       (tr->tr_num_revoke <= tr->tr_revokes)))\n\t\tgfs2_print_trans(tr);\n\n\tgfs2_log_commit(sdp, tr);\n\tif (alloced && !tr->tr_attached)\n\t\t\tkfree(tr);\n\tup_read(&sdp->sd_log_flush_lock);\n\n\tif (sdp->sd_vfs->s_flags & MS_SYNCHRONOUS)\n\t\tgfs2_log_flush(sdp, NULL, NORMAL_FLUSH);\n\tif (alloced)\n\t\tsb_end_intwrite(sdp->sd_vfs);\n}",
          "includes": [
            "#include \"trace_gfs2.h\"",
            "#include \"util.h\"",
            "#include \"trans.h\"",
            "#include \"meta_io.h\"",
            "#include \"lops.h\"",
            "#include \"log.h\"",
            "#include \"inode.h\"",
            "#include \"glock.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"util.h\"\n#include \"trans.h\"\n#include \"meta_io.h\"\n#include \"lops.h\"\n#include \"log.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/gfs2_ondisk.h>\n#include <linux/kallsyms.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nvoid gfs2_trans_end(struct gfs2_sbd *sdp)\n{\n\tstruct gfs2_trans *tr = current->journal_info;\n\ts64 nbuf;\n\tint alloced = tr->tr_alloced;\n\n\tBUG_ON(!tr);\n\tcurrent->journal_info = NULL;\n\n\tif (!tr->tr_touched) {\n\t\tgfs2_log_release(sdp, tr->tr_reserved);\n\t\tif (alloced) {\n\t\t\tkfree(tr);\n\t\t\tsb_end_intwrite(sdp->sd_vfs);\n\t\t}\n\t\treturn;\n\t}\n\n\tnbuf = tr->tr_num_buf_new + tr->tr_num_databuf_new;\n\tnbuf -= tr->tr_num_buf_rm;\n\tnbuf -= tr->tr_num_databuf_rm;\n\n\tif (gfs2_assert_withdraw(sdp, (nbuf <= tr->tr_blocks) &&\n\t\t\t\t       (tr->tr_num_revoke <= tr->tr_revokes)))\n\t\tgfs2_print_trans(tr);\n\n\tgfs2_log_commit(sdp, tr);\n\tif (alloced && !tr->tr_attached)\n\t\t\tkfree(tr);\n\tup_read(&sdp->sd_log_flush_lock);\n\n\tif (sdp->sd_vfs->s_flags & MS_SYNCHRONOUS)\n\t\tgfs2_log_flush(sdp, NULL, NORMAL_FLUSH);\n\tif (alloced)\n\t\tsb_end_intwrite(sdp->sd_vfs);\n}"
        }
      },
      {
        "call_info": {
          "callee": "init_dinode",
          "args": [
            "dip",
            "ip",
            "symname"
          ],
          "line": 720
        },
        "resolved": true,
        "details": {
          "function_name": "init_dinode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/inode.c",
          "lines": "465-496",
          "snippet": "static void init_dinode(struct gfs2_inode *dip, struct gfs2_inode *ip,\n\t\t\tconst char *symname)\n{\n\tstruct gfs2_dinode *di;\n\tstruct buffer_head *dibh;\n\n\tdibh = gfs2_meta_new(ip->i_gl, ip->i_no_addr);\n\tgfs2_trans_add_meta(ip->i_gl, dibh);\n\tdi = (struct gfs2_dinode *)dibh->b_data;\n\tgfs2_dinode_out(ip, di);\n\n\tdi->di_major = cpu_to_be32(MAJOR(ip->i_inode.i_rdev));\n\tdi->di_minor = cpu_to_be32(MINOR(ip->i_inode.i_rdev));\n\tdi->__pad1 = 0;\n\tdi->__pad2 = 0;\n\tdi->__pad3 = 0;\n\tmemset(&di->__pad4, 0, sizeof(di->__pad4));\n\tmemset(&di->di_reserved, 0, sizeof(di->di_reserved));\n\tgfs2_buffer_clear_tail(dibh, sizeof(struct gfs2_dinode));\n\n\tswitch(ip->i_inode.i_mode & S_IFMT) {\n\tcase S_IFDIR:\n\t\tgfs2_init_dir(dibh, dip);\n\t\tbreak;\n\tcase S_IFLNK:\n\t\tmemcpy(dibh->b_data + sizeof(struct gfs2_dinode), symname, ip->i_inode.i_size);\n\t\tbreak;\n\t}\n\n\tset_buffer_uptodate(dibh);\n\tbrelse(dibh);\n}",
          "includes": [
            "#include \"glops.h\"",
            "#include \"super.h\"",
            "#include \"util.h\"",
            "#include \"trans.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"inode.h\"",
            "#include \"glock.h\"",
            "#include \"xattr.h\"",
            "#include \"dir.h\"",
            "#include \"bmap.h\"",
            "#include \"acl.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/security.h>",
            "#include <linux/fiemap.h>",
            "#include <linux/crc32.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/xattr.h>",
            "#include <linux/mm.h>",
            "#include <linux/namei.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glops.h\"\n#include \"super.h\"\n#include \"util.h\"\n#include \"trans.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"xattr.h\"\n#include \"dir.h\"\n#include \"bmap.h\"\n#include \"acl.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <asm/uaccess.h>\n#include <linux/security.h>\n#include <linux/fiemap.h>\n#include <linux/crc32.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/posix_acl.h>\n#include <linux/xattr.h>\n#include <linux/mm.h>\n#include <linux/namei.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nstatic void init_dinode(struct gfs2_inode *dip, struct gfs2_inode *ip,\n\t\t\tconst char *symname)\n{\n\tstruct gfs2_dinode *di;\n\tstruct buffer_head *dibh;\n\n\tdibh = gfs2_meta_new(ip->i_gl, ip->i_no_addr);\n\tgfs2_trans_add_meta(ip->i_gl, dibh);\n\tdi = (struct gfs2_dinode *)dibh->b_data;\n\tgfs2_dinode_out(ip, di);\n\n\tdi->di_major = cpu_to_be32(MAJOR(ip->i_inode.i_rdev));\n\tdi->di_minor = cpu_to_be32(MINOR(ip->i_inode.i_rdev));\n\tdi->__pad1 = 0;\n\tdi->__pad2 = 0;\n\tdi->__pad3 = 0;\n\tmemset(&di->__pad4, 0, sizeof(di->__pad4));\n\tmemset(&di->di_reserved, 0, sizeof(di->di_reserved));\n\tgfs2_buffer_clear_tail(dibh, sizeof(struct gfs2_dinode));\n\n\tswitch(ip->i_inode.i_mode & S_IFMT) {\n\tcase S_IFDIR:\n\t\tgfs2_init_dir(dibh, dip);\n\t\tbreak;\n\tcase S_IFLNK:\n\t\tmemcpy(dibh->b_data + sizeof(struct gfs2_dinode), symname, ip->i_inode.i_size);\n\t\tbreak;\n\t}\n\n\tset_buffer_uptodate(dibh);\n\tbrelse(dibh);\n}"
        }
      },
      {
        "call_info": {
          "callee": "gfs2_init_xattr",
          "args": [
            "ip"
          ],
          "line": 718
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_init_xattr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/inode.c",
          "lines": "437-454",
          "snippet": "static void gfs2_init_xattr(struct gfs2_inode *ip)\n{\n\tstruct gfs2_sbd *sdp = GFS2_SB(&ip->i_inode);\n\tstruct buffer_head *bh;\n\tstruct gfs2_ea_header *ea;\n\n\tbh = gfs2_meta_new(ip->i_gl, ip->i_eattr);\n\tgfs2_trans_add_meta(ip->i_gl, bh);\n\tgfs2_metatype_set(bh, GFS2_METATYPE_EA, GFS2_FORMAT_EA);\n\tgfs2_buffer_clear_tail(bh, sizeof(struct gfs2_meta_header));\n\n\tea = GFS2_EA_BH2FIRST(bh);\n\tea->ea_rec_len = cpu_to_be32(sdp->sd_jbsize);\n\tea->ea_type = GFS2_EATYPE_UNUSED;\n\tea->ea_flags = GFS2_EAFLAG_LAST;\n\n\tbrelse(bh);\n}",
          "includes": [
            "#include \"glops.h\"",
            "#include \"super.h\"",
            "#include \"util.h\"",
            "#include \"trans.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"inode.h\"",
            "#include \"glock.h\"",
            "#include \"xattr.h\"",
            "#include \"dir.h\"",
            "#include \"bmap.h\"",
            "#include \"acl.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/security.h>",
            "#include <linux/fiemap.h>",
            "#include <linux/crc32.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/xattr.h>",
            "#include <linux/mm.h>",
            "#include <linux/namei.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glops.h\"\n#include \"super.h\"\n#include \"util.h\"\n#include \"trans.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"xattr.h\"\n#include \"dir.h\"\n#include \"bmap.h\"\n#include \"acl.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <asm/uaccess.h>\n#include <linux/security.h>\n#include <linux/fiemap.h>\n#include <linux/crc32.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/posix_acl.h>\n#include <linux/xattr.h>\n#include <linux/mm.h>\n#include <linux/namei.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nstatic void gfs2_init_xattr(struct gfs2_inode *ip)\n{\n\tstruct gfs2_sbd *sdp = GFS2_SB(&ip->i_inode);\n\tstruct buffer_head *bh;\n\tstruct gfs2_ea_header *ea;\n\n\tbh = gfs2_meta_new(ip->i_gl, ip->i_eattr);\n\tgfs2_trans_add_meta(ip->i_gl, bh);\n\tgfs2_metatype_set(bh, GFS2_METATYPE_EA, GFS2_FORMAT_EA);\n\tgfs2_buffer_clear_tail(bh, sizeof(struct gfs2_meta_header));\n\n\tea = GFS2_EA_BH2FIRST(bh);\n\tea->ea_rec_len = cpu_to_be32(sdp->sd_jbsize);\n\tea->ea_type = GFS2_EATYPE_UNUSED;\n\tea->ea_flags = GFS2_EAFLAG_LAST;\n\n\tbrelse(bh);\n}"
        }
      },
      {
        "call_info": {
          "callee": "gfs2_trans_begin",
          "args": [
            "sdp",
            "blocks",
            "0"
          ],
          "line": 712
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_trans_begin",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/trans.c",
          "lines": "31-75",
          "snippet": "int gfs2_trans_begin(struct gfs2_sbd *sdp, unsigned int blocks,\n\t\t     unsigned int revokes)\n{\n\tstruct gfs2_trans *tr;\n\tint error;\n\n\tBUG_ON(current->journal_info);\n\tBUG_ON(blocks == 0 && revokes == 0);\n\n\tif (!test_bit(SDF_JOURNAL_LIVE, &sdp->sd_flags))\n\t\treturn -EROFS;\n\n\ttr = kzalloc(sizeof(struct gfs2_trans), GFP_NOFS);\n\tif (!tr)\n\t\treturn -ENOMEM;\n\n\ttr->tr_ip = _RET_IP_;\n\ttr->tr_blocks = blocks;\n\ttr->tr_revokes = revokes;\n\ttr->tr_reserved = 1;\n\ttr->tr_alloced = 1;\n\tif (blocks)\n\t\ttr->tr_reserved += 6 + blocks;\n\tif (revokes)\n\t\ttr->tr_reserved += gfs2_struct2blk(sdp, revokes,\n\t\t\t\t\t\t   sizeof(u64));\n\tINIT_LIST_HEAD(&tr->tr_databuf);\n\tINIT_LIST_HEAD(&tr->tr_buf);\n\n\tsb_start_intwrite(sdp->sd_vfs);\n\n\terror = gfs2_log_reserve(sdp, tr->tr_reserved);\n\tif (error)\n\t\tgoto fail;\n\n\tcurrent->journal_info = tr;\n\n\treturn 0;\n\nfail:\n\tsb_end_intwrite(sdp->sd_vfs);\n\tkfree(tr);\n\n\treturn error;\n}",
          "includes": [
            "#include \"trace_gfs2.h\"",
            "#include \"util.h\"",
            "#include \"trans.h\"",
            "#include \"meta_io.h\"",
            "#include \"lops.h\"",
            "#include \"log.h\"",
            "#include \"inode.h\"",
            "#include \"glock.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"util.h\"\n#include \"trans.h\"\n#include \"meta_io.h\"\n#include \"lops.h\"\n#include \"log.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/gfs2_ondisk.h>\n#include <linux/kallsyms.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nint gfs2_trans_begin(struct gfs2_sbd *sdp, unsigned int blocks,\n\t\t     unsigned int revokes)\n{\n\tstruct gfs2_trans *tr;\n\tint error;\n\n\tBUG_ON(current->journal_info);\n\tBUG_ON(blocks == 0 && revokes == 0);\n\n\tif (!test_bit(SDF_JOURNAL_LIVE, &sdp->sd_flags))\n\t\treturn -EROFS;\n\n\ttr = kzalloc(sizeof(struct gfs2_trans), GFP_NOFS);\n\tif (!tr)\n\t\treturn -ENOMEM;\n\n\ttr->tr_ip = _RET_IP_;\n\ttr->tr_blocks = blocks;\n\ttr->tr_revokes = revokes;\n\ttr->tr_reserved = 1;\n\ttr->tr_alloced = 1;\n\tif (blocks)\n\t\ttr->tr_reserved += 6 + blocks;\n\tif (revokes)\n\t\ttr->tr_reserved += gfs2_struct2blk(sdp, revokes,\n\t\t\t\t\t\t   sizeof(u64));\n\tINIT_LIST_HEAD(&tr->tr_databuf);\n\tINIT_LIST_HEAD(&tr->tr_buf);\n\n\tsb_start_intwrite(sdp->sd_vfs);\n\n\terror = gfs2_log_reserve(sdp, tr->tr_reserved);\n\tif (error)\n\t\tgoto fail;\n\n\tcurrent->journal_info = tr;\n\n\treturn 0;\n\nfail:\n\tsb_end_intwrite(sdp->sd_vfs);\n\tkfree(tr);\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "gfs2_set_inode_blocks",
          "args": [
            "inode",
            "blocks"
          ],
          "line": 701
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_set_inode_blocks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/inode.h",
          "lines": "50-54",
          "snippet": "static inline void gfs2_set_inode_blocks(struct inode *inode, u64 blocks)\n{\n\tinode->i_blocks = blocks <<\n\t\t(GFS2_SB(inode)->sd_sb.sb_bsize_shift - GFS2_BASIC_BLOCK_SHIFT);\n}",
          "includes": [
            "#include \"util.h\"",
            "#include <linux/mm.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include <linux/mm.h>\n#include <linux/buffer_head.h>\n#include <linux/fs.h>\n\nstatic inline void gfs2_set_inode_blocks(struct inode *inode, u64 blocks)\n{\n\tinode->i_blocks = blocks <<\n\t\t(GFS2_SB(inode)->sd_sb.sb_bsize_shift - GFS2_BASIC_BLOCK_SHIFT);\n}"
        }
      },
      {
        "call_info": {
          "callee": "alloc_dinode",
          "args": [
            "ip",
            "aflags",
            "&blocks"
          ],
          "line": 697
        },
        "resolved": true,
        "details": {
          "function_name": "alloc_dinode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/inode.c",
          "lines": "379-410",
          "snippet": "static int alloc_dinode(struct gfs2_inode *ip, u32 flags, unsigned *dblocks)\n{\n\tstruct gfs2_sbd *sdp = GFS2_SB(&ip->i_inode);\n\tstruct gfs2_alloc_parms ap = { .target = *dblocks, .aflags = flags, };\n\tint error;\n\n\terror = gfs2_quota_lock_check(ip);\n\tif (error)\n\t\tgoto out;\n\n\terror = gfs2_inplace_reserve(ip, &ap);\n\tif (error)\n\t\tgoto out_quota;\n\n\terror = gfs2_trans_begin(sdp, (*dblocks * RES_RG_BIT) + RES_STATFS + RES_QUOTA, 0);\n\tif (error)\n\t\tgoto out_ipreserv;\n\n\terror = gfs2_alloc_blocks(ip, &ip->i_no_addr, dblocks, 1, &ip->i_generation);\n\tip->i_no_formal_ino = ip->i_generation;\n\tip->i_inode.i_ino = ip->i_no_addr;\n\tip->i_goal = ip->i_no_addr;\n\n\tgfs2_trans_end(sdp);\n\nout_ipreserv:\n\tgfs2_inplace_release(ip);\nout_quota:\n\tgfs2_quota_unlock(ip);\nout:\n\treturn error;\n}",
          "includes": [
            "#include \"glops.h\"",
            "#include \"super.h\"",
            "#include \"util.h\"",
            "#include \"trans.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"inode.h\"",
            "#include \"glock.h\"",
            "#include \"xattr.h\"",
            "#include \"dir.h\"",
            "#include \"bmap.h\"",
            "#include \"acl.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/security.h>",
            "#include <linux/fiemap.h>",
            "#include <linux/crc32.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/xattr.h>",
            "#include <linux/mm.h>",
            "#include <linux/namei.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glops.h\"\n#include \"super.h\"\n#include \"util.h\"\n#include \"trans.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"xattr.h\"\n#include \"dir.h\"\n#include \"bmap.h\"\n#include \"acl.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <asm/uaccess.h>\n#include <linux/security.h>\n#include <linux/fiemap.h>\n#include <linux/crc32.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/posix_acl.h>\n#include <linux/xattr.h>\n#include <linux/mm.h>\n#include <linux/namei.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nstatic int alloc_dinode(struct gfs2_inode *ip, u32 flags, unsigned *dblocks)\n{\n\tstruct gfs2_sbd *sdp = GFS2_SB(&ip->i_inode);\n\tstruct gfs2_alloc_parms ap = { .target = *dblocks, .aflags = flags, };\n\tint error;\n\n\terror = gfs2_quota_lock_check(ip);\n\tif (error)\n\t\tgoto out;\n\n\terror = gfs2_inplace_reserve(ip, &ap);\n\tif (error)\n\t\tgoto out_quota;\n\n\terror = gfs2_trans_begin(sdp, (*dblocks * RES_RG_BIT) + RES_STATFS + RES_QUOTA, 0);\n\tif (error)\n\t\tgoto out_ipreserv;\n\n\terror = gfs2_alloc_blocks(ip, &ip->i_no_addr, dblocks, 1, &ip->i_generation);\n\tip->i_no_formal_ino = ip->i_generation;\n\tip->i_inode.i_ino = ip->i_no_addr;\n\tip->i_goal = ip->i_no_addr;\n\n\tgfs2_trans_end(sdp);\n\nout_ipreserv:\n\tgfs2_inplace_release(ip);\nout_quota:\n\tgfs2_quota_unlock(ip);\nout:\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "gfs2_set_inode_flags",
          "args": [
            "inode"
          ],
          "line": 688
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_set_inode_flags",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/file.c",
          "lines": "177-194",
          "snippet": "void gfs2_set_inode_flags(struct inode *inode)\n{\n\tstruct gfs2_inode *ip = GFS2_I(inode);\n\tunsigned int flags = inode->i_flags;\n\n\tflags &= ~(S_SYNC|S_APPEND|S_IMMUTABLE|S_NOATIME|S_DIRSYNC|S_NOSEC);\n\tif ((ip->i_eattr == 0) && !is_sxid(inode->i_mode))\n\t\tinode->i_flags |= S_NOSEC;\n\tif (ip->i_diskflags & GFS2_DIF_IMMUTABLE)\n\t\tflags |= S_IMMUTABLE;\n\tif (ip->i_diskflags & GFS2_DIF_APPENDONLY)\n\t\tflags |= S_APPEND;\n\tif (ip->i_diskflags & GFS2_DIF_NOATIME)\n\t\tflags |= S_NOATIME;\n\tif (ip->i_diskflags & GFS2_DIF_SYNC)\n\t\tflags |= S_SYNC;\n\tinode->i_flags = flags;\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"trans.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"log.h\"",
            "#include \"inode.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"dir.h\"",
            "#include \"bmap.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/delay.h>",
            "#include <linux/aio.h>",
            "#include <linux/dlm_plock.h>",
            "#include <linux/dlm.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/writeback.h>",
            "#include <linux/crc32.h>",
            "#include <linux/swap.h>",
            "#include <linux/falloc.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/fs.h>",
            "#include <linux/mount.h>",
            "#include <linux/mm.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/uio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"trans.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"log.h\"\n#include \"inode.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"dir.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/delay.h>\n#include <linux/aio.h>\n#include <linux/dlm_plock.h>\n#include <linux/dlm.h>\n#include <asm/uaccess.h>\n#include <linux/writeback.h>\n#include <linux/crc32.h>\n#include <linux/swap.h>\n#include <linux/falloc.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/fs.h>\n#include <linux/mount.h>\n#include <linux/mm.h>\n#include <linux/blkdev.h>\n#include <linux/uio.h>\n#include <linux/pagemap.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nvoid gfs2_set_inode_flags(struct inode *inode)\n{\n\tstruct gfs2_inode *ip = GFS2_I(inode);\n\tunsigned int flags = inode->i_flags;\n\n\tflags &= ~(S_SYNC|S_APPEND|S_IMMUTABLE|S_NOATIME|S_DIRSYNC|S_NOSEC);\n\tif ((ip->i_eattr == 0) && !is_sxid(inode->i_mode))\n\t\tinode->i_flags |= S_NOSEC;\n\tif (ip->i_diskflags & GFS2_DIF_IMMUTABLE)\n\t\tflags |= S_IMMUTABLE;\n\tif (ip->i_diskflags & GFS2_DIF_APPENDONLY)\n\t\tflags |= S_APPEND;\n\tif (ip->i_diskflags & GFS2_DIF_NOATIME)\n\t\tflags |= S_NOATIME;\n\tif (ip->i_diskflags & GFS2_DIF_SYNC)\n\t\tflags |= S_SYNC;\n\tinode->i_flags = flags;\n}"
        }
      },
      {
        "call_info": {
          "callee": "gfs2_set_aops",
          "args": [
            "inode"
          ],
          "line": 680
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_set_aops",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/aops.c",
          "lines": "1218-1230",
          "snippet": "void gfs2_set_aops(struct inode *inode)\n{\n\tstruct gfs2_inode *ip = GFS2_I(inode);\n\n\tif (gfs2_is_writeback(ip))\n\t\tinode->i_mapping->a_ops = &gfs2_writeback_aops;\n\telse if (gfs2_is_ordered(ip))\n\t\tinode->i_mapping->a_ops = &gfs2_ordered_aops;\n\telse if (gfs2_is_jdata(ip))\n\t\tinode->i_mapping->a_ops = &gfs2_jdata_aops;\n\telse\n\t\tBUG();\n}",
          "includes": [
            "#include \"glops.h\"",
            "#include \"util.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"trans.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"log.h\"",
            "#include \"inode.h\"",
            "#include \"glock.h\"",
            "#include \"bmap.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/aio.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/swap.h>",
            "#include <linux/writeback.h>",
            "#include <linux/fs.h>",
            "#include <linux/mpage.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct address_space_operations gfs2_writeback_aops = {\n\t.writepage = gfs2_writepage,\n\t.writepages = gfs2_writepages,\n\t.readpage = gfs2_readpage,\n\t.readpages = gfs2_readpages,\n\t.write_begin = gfs2_write_begin,\n\t.write_end = gfs2_write_end,\n\t.bmap = gfs2_bmap,\n\t.invalidatepage = gfs2_invalidatepage,\n\t.releasepage = gfs2_releasepage,\n\t.direct_IO = gfs2_direct_IO,\n\t.migratepage = buffer_migrate_page,\n\t.is_partially_uptodate = block_is_partially_uptodate,\n\t.error_remove_page = generic_error_remove_page,\n};",
            "static const struct address_space_operations gfs2_ordered_aops = {\n\t.writepage = gfs2_writepage,\n\t.writepages = gfs2_writepages,\n\t.readpage = gfs2_readpage,\n\t.readpages = gfs2_readpages,\n\t.write_begin = gfs2_write_begin,\n\t.write_end = gfs2_write_end,\n\t.set_page_dirty = gfs2_set_page_dirty,\n\t.bmap = gfs2_bmap,\n\t.invalidatepage = gfs2_invalidatepage,\n\t.releasepage = gfs2_releasepage,\n\t.direct_IO = gfs2_direct_IO,\n\t.migratepage = buffer_migrate_page,\n\t.is_partially_uptodate = block_is_partially_uptodate,\n\t.error_remove_page = generic_error_remove_page,\n};",
            "static const struct address_space_operations gfs2_jdata_aops = {\n\t.writepage = gfs2_jdata_writepage,\n\t.writepages = gfs2_jdata_writepages,\n\t.readpage = gfs2_readpage,\n\t.readpages = gfs2_readpages,\n\t.write_begin = gfs2_write_begin,\n\t.write_end = gfs2_write_end,\n\t.set_page_dirty = gfs2_set_page_dirty,\n\t.bmap = gfs2_bmap,\n\t.invalidatepage = gfs2_invalidatepage,\n\t.releasepage = gfs2_releasepage,\n\t.is_partially_uptodate = block_is_partially_uptodate,\n\t.error_remove_page = generic_error_remove_page,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"glops.h\"\n#include \"util.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"trans.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"log.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <trace/events/writeback.h>\n#include <linux/aio.h>\n#include <linux/backing-dev.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/swap.h>\n#include <linux/writeback.h>\n#include <linux/fs.h>\n#include <linux/mpage.h>\n#include <linux/pagevec.h>\n#include <linux/pagemap.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic const struct address_space_operations gfs2_writeback_aops = {\n\t.writepage = gfs2_writepage,\n\t.writepages = gfs2_writepages,\n\t.readpage = gfs2_readpage,\n\t.readpages = gfs2_readpages,\n\t.write_begin = gfs2_write_begin,\n\t.write_end = gfs2_write_end,\n\t.bmap = gfs2_bmap,\n\t.invalidatepage = gfs2_invalidatepage,\n\t.releasepage = gfs2_releasepage,\n\t.direct_IO = gfs2_direct_IO,\n\t.migratepage = buffer_migrate_page,\n\t.is_partially_uptodate = block_is_partially_uptodate,\n\t.error_remove_page = generic_error_remove_page,\n};\nstatic const struct address_space_operations gfs2_ordered_aops = {\n\t.writepage = gfs2_writepage,\n\t.writepages = gfs2_writepages,\n\t.readpage = gfs2_readpage,\n\t.readpages = gfs2_readpages,\n\t.write_begin = gfs2_write_begin,\n\t.write_end = gfs2_write_end,\n\t.set_page_dirty = gfs2_set_page_dirty,\n\t.bmap = gfs2_bmap,\n\t.invalidatepage = gfs2_invalidatepage,\n\t.releasepage = gfs2_releasepage,\n\t.direct_IO = gfs2_direct_IO,\n\t.migratepage = buffer_migrate_page,\n\t.is_partially_uptodate = block_is_partially_uptodate,\n\t.error_remove_page = generic_error_remove_page,\n};\nstatic const struct address_space_operations gfs2_jdata_aops = {\n\t.writepage = gfs2_jdata_writepage,\n\t.writepages = gfs2_jdata_writepages,\n\t.readpage = gfs2_readpage,\n\t.readpages = gfs2_readpages,\n\t.write_begin = gfs2_write_begin,\n\t.write_end = gfs2_write_end,\n\t.set_page_dirty = gfs2_set_page_dirty,\n\t.bmap = gfs2_bmap,\n\t.invalidatepage = gfs2_invalidatepage,\n\t.releasepage = gfs2_releasepage,\n\t.is_partially_uptodate = block_is_partially_uptodate,\n\t.error_remove_page = generic_error_remove_page,\n};\n\nvoid gfs2_set_aops(struct inode *inode)\n{\n\tstruct gfs2_inode *ip = GFS2_I(inode);\n\n\tif (gfs2_is_writeback(ip))\n\t\tinode->i_mapping->a_ops = &gfs2_writeback_aops;\n\telse if (gfs2_is_ordered(ip))\n\t\tinode->i_mapping->a_ops = &gfs2_ordered_aops;\n\telse if (gfs2_is_jdata(ip))\n\t\tinode->i_mapping->a_ops = &gfs2_jdata_aops;\n\telse\n\t\tBUG();\n}"
        }
      },
      {
        "call_info": {
          "callee": "gfs2_tune_get",
          "args": [
            "sdp",
            "gt_new_files_jdata"
          ],
          "line": 678
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_tune_get_i",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/util.h",
          "lines": "155-163",
          "snippet": "static inline unsigned int gfs2_tune_get_i(struct gfs2_tune *gt,\n\t\t\t\t\t   unsigned int *p)\n{\n\tunsigned int x;\n\tspin_lock(&gt->gt_spin);\n\tx = *p;\n\tspin_unlock(&gt->gt_spin);\n\treturn x;\n}",
          "includes": [
            "#include \"incore.h\"",
            "#include <linux/mempool.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"incore.h\"\n#include <linux/mempool.h>\n\nstatic inline unsigned int gfs2_tune_get_i(struct gfs2_tune *gt,\n\t\t\t\t\t   unsigned int *p)\n{\n\tunsigned int x;\n\tspin_lock(&gt->gt_spin);\n\tx = *p;\n\tspin_unlock(&gt->gt_spin);\n\treturn x;\n}"
        }
      },
      {
        "call_info": {
          "callee": "check_and_update_goal",
          "args": [
            "dip"
          ],
          "line": 667
        },
        "resolved": true,
        "details": {
          "function_name": "check_and_update_goal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/rgrp.c",
          "lines": "580-585",
          "snippet": "void check_and_update_goal(struct gfs2_inode *ip)\n{\n\tstruct gfs2_sbd *sdp = GFS2_SB(&ip->i_inode);\n\tif (!ip->i_goal || gfs2_blk2rgrpd(sdp, ip->i_goal, 1) == NULL)\n\t\tip->i_goal = ip->i_no_addr;\n}",
          "includes": [
            "#include \"trace_gfs2.h\"",
            "#include \"inode.h\"",
            "#include \"log.h\"",
            "#include \"util.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"lops.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/random.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/fs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"inode.h\"\n#include \"log.h\"\n#include \"util.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"lops.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/random.h>\n#include <linux/rbtree.h>\n#include <linux/blkdev.h>\n#include <linux/prefetch.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/fs.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nvoid check_and_update_goal(struct gfs2_inode *ip)\n{\n\tstruct gfs2_sbd *sdp = GFS2_SB(&ip->i_inode);\n\tif (!ip->i_goal || gfs2_blk2rgrpd(sdp, ip->i_goal, 1) == NULL)\n\t\tip->i_goal = ip->i_no_addr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "munge_mode_uid_gid",
          "args": [
            "dip",
            "inode"
          ],
          "line": 666
        },
        "resolved": true,
        "details": {
          "function_name": "munge_mode_uid_gid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/inode.c",
          "lines": "357-377",
          "snippet": "static void munge_mode_uid_gid(const struct gfs2_inode *dip,\n\t\t\t       struct inode *inode)\n{\n\tif (GFS2_SB(&dip->i_inode)->sd_args.ar_suiddir &&\n\t    (dip->i_inode.i_mode & S_ISUID) &&\n\t    !uid_eq(dip->i_inode.i_uid, GLOBAL_ROOT_UID)) {\n\t\tif (S_ISDIR(inode->i_mode))\n\t\t\tinode->i_mode |= S_ISUID;\n\t\telse if (!uid_eq(dip->i_inode.i_uid, current_fsuid()))\n\t\t\tinode->i_mode &= ~07111;\n\t\tinode->i_uid = dip->i_inode.i_uid;\n\t} else\n\t\tinode->i_uid = current_fsuid();\n\n\tif (dip->i_inode.i_mode & S_ISGID) {\n\t\tif (S_ISDIR(inode->i_mode))\n\t\t\tinode->i_mode |= S_ISGID;\n\t\tinode->i_gid = dip->i_inode.i_gid;\n\t} else\n\t\tinode->i_gid = current_fsgid();\n}",
          "includes": [
            "#include \"glops.h\"",
            "#include \"super.h\"",
            "#include \"util.h\"",
            "#include \"trans.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"inode.h\"",
            "#include \"glock.h\"",
            "#include \"xattr.h\"",
            "#include \"dir.h\"",
            "#include \"bmap.h\"",
            "#include \"acl.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/security.h>",
            "#include <linux/fiemap.h>",
            "#include <linux/crc32.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/xattr.h>",
            "#include <linux/mm.h>",
            "#include <linux/namei.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glops.h\"\n#include \"super.h\"\n#include \"util.h\"\n#include \"trans.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"xattr.h\"\n#include \"dir.h\"\n#include \"bmap.h\"\n#include \"acl.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <asm/uaccess.h>\n#include <linux/security.h>\n#include <linux/fiemap.h>\n#include <linux/crc32.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/posix_acl.h>\n#include <linux/xattr.h>\n#include <linux/mm.h>\n#include <linux/namei.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nstatic void munge_mode_uid_gid(const struct gfs2_inode *dip,\n\t\t\t       struct inode *inode)\n{\n\tif (GFS2_SB(&dip->i_inode)->sd_args.ar_suiddir &&\n\t    (dip->i_inode.i_mode & S_ISUID) &&\n\t    !uid_eq(dip->i_inode.i_uid, GLOBAL_ROOT_UID)) {\n\t\tif (S_ISDIR(inode->i_mode))\n\t\t\tinode->i_mode |= S_ISUID;\n\t\telse if (!uid_eq(dip->i_inode.i_uid, current_fsuid()))\n\t\t\tinode->i_mode &= ~07111;\n\t\tinode->i_uid = dip->i_inode.i_uid;\n\t} else\n\t\tinode->i_uid = current_fsuid();\n\n\tif (dip->i_inode.i_mode & S_ISGID) {\n\t\tif (S_ISDIR(inode->i_mode))\n\t\t\tinode->i_mode |= S_ISGID;\n\t\tinode->i_gid = dip->i_inode.i_gid;\n\t} else\n\t\tinode->i_gid = current_fsgid();\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_nlink",
          "args": [
            "inode",
            "S_ISDIR(mode) ? 2 : 1"
          ],
          "line": 661
        },
        "resolved": true,
        "details": {
          "function_name": "set_nlink",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "305-316",
          "snippet": "void set_nlink(struct inode *inode, unsigned int nlink)\n{\n\tif (!nlink) {\n\t\tclear_nlink(inode);\n\t} else {\n\t\t/* Yes, some filesystems do change nlink from zero to one */\n\t\tif (inode->i_nlink == 0)\n\t\t\tatomic_long_dec(&inode->i_sb->s_remove_count);\n\n\t\tinode->__i_nlink = nlink;\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid set_nlink(struct inode *inode, unsigned int nlink)\n{\n\tif (!nlink) {\n\t\tclear_nlink(inode);\n\t} else {\n\t\t/* Yes, some filesystems do change nlink from zero to one */\n\t\tif (inode->i_nlink == 0)\n\t\t\tatomic_long_dec(&inode->i_sb->s_remove_count);\n\n\t\tinode->__i_nlink = nlink;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "S_ISDIR",
          "args": [
            "mode"
          ],
          "line": 661
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gfs2_rs_alloc",
          "args": [
            "ip"
          ],
          "line": 656
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_rs_alloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/rgrp.c",
          "lines": "602-620",
          "snippet": "int gfs2_rs_alloc(struct gfs2_inode *ip)\n{\n\tint error = 0;\n\n\tdown_write(&ip->i_rw_mutex);\n\tif (ip->i_res)\n\t\tgoto out;\n\n\tip->i_res = kmem_cache_zalloc(gfs2_rsrv_cachep, GFP_NOFS);\n\tif (!ip->i_res) {\n\t\terror = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tRB_CLEAR_NODE(&ip->i_res->rs_node);\nout:\n\tup_write(&ip->i_rw_mutex);\n\treturn error;\n}",
          "includes": [
            "#include \"trace_gfs2.h\"",
            "#include \"inode.h\"",
            "#include \"log.h\"",
            "#include \"util.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"lops.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/random.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/fs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"inode.h\"\n#include \"log.h\"\n#include \"util.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"lops.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/random.h>\n#include <linux/rbtree.h>\n#include <linux/blkdev.h>\n#include <linux/prefetch.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/fs.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nint gfs2_rs_alloc(struct gfs2_inode *ip)\n{\n\tint error = 0;\n\n\tdown_write(&ip->i_rw_mutex);\n\tif (ip->i_res)\n\t\tgoto out;\n\n\tip->i_res = kmem_cache_zalloc(gfs2_rsrv_cachep, GFP_NOFS);\n\tif (!ip->i_res) {\n\t\terror = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tRB_CLEAR_NODE(&ip->i_res->rs_node);\nout:\n\tup_write(&ip->i_rw_mutex);\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "posix_acl_create",
          "args": [
            "dir",
            "&mode",
            "&default_acl",
            "&acl"
          ],
          "line": 651
        },
        "resolved": true,
        "details": {
          "function_name": "posix_acl_create",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/posix_acl.c",
          "lines": "545-598",
          "snippet": "int\nposix_acl_create(struct inode *dir, umode_t *mode,\n\t\tstruct posix_acl **default_acl, struct posix_acl **acl)\n{\n\tstruct posix_acl *p;\n\tint ret;\n\n\tif (S_ISLNK(*mode) || !IS_POSIXACL(dir))\n\t\tgoto no_acl;\n\n\tp = get_acl(dir, ACL_TYPE_DEFAULT);\n\tif (IS_ERR(p)) {\n\t\tif (p == ERR_PTR(-EOPNOTSUPP))\n\t\t\tgoto apply_umask;\n\t\treturn PTR_ERR(p);\n\t}\n\n\tif (!p)\n\t\tgoto apply_umask;\n\n\t*acl = posix_acl_clone(p, GFP_NOFS);\n\tif (!*acl)\n\t\tgoto no_mem;\n\n\tret = posix_acl_create_masq(*acl, mode);\n\tif (ret < 0)\n\t\tgoto no_mem_clone;\n\n\tif (ret == 0) {\n\t\tposix_acl_release(*acl);\n\t\t*acl = NULL;\n\t}\n\n\tif (!S_ISDIR(*mode)) {\n\t\tposix_acl_release(p);\n\t\t*default_acl = NULL;\n\t} else {\n\t\t*default_acl = p;\n\t}\n\treturn 0;\n\napply_umask:\n\t*mode &= ~current_umask();\nno_acl:\n\t*default_acl = NULL;\n\t*acl = NULL;\n\treturn 0;\n\nno_mem_clone:\n\tposix_acl_release(*acl);\nno_mem:\n\tposix_acl_release(p);\n\treturn -ENOMEM;\n}",
          "includes": [
            "#include <linux/user_namespace.h>",
            "#include <linux/export.h>",
            "#include <linux/xattr.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/sched.h>",
            "#include <linux/fs.h>",
            "#include <linux/atomic.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/user_namespace.h>\n#include <linux/export.h>\n#include <linux/xattr.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/posix_acl.h>\n#include <linux/sched.h>\n#include <linux/fs.h>\n#include <linux/atomic.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nint\nposix_acl_create(struct inode *dir, umode_t *mode,\n\t\tstruct posix_acl **default_acl, struct posix_acl **acl)\n{\n\tstruct posix_acl *p;\n\tint ret;\n\n\tif (S_ISLNK(*mode) || !IS_POSIXACL(dir))\n\t\tgoto no_acl;\n\n\tp = get_acl(dir, ACL_TYPE_DEFAULT);\n\tif (IS_ERR(p)) {\n\t\tif (p == ERR_PTR(-EOPNOTSUPP))\n\t\t\tgoto apply_umask;\n\t\treturn PTR_ERR(p);\n\t}\n\n\tif (!p)\n\t\tgoto apply_umask;\n\n\t*acl = posix_acl_clone(p, GFP_NOFS);\n\tif (!*acl)\n\t\tgoto no_mem;\n\n\tret = posix_acl_create_masq(*acl, mode);\n\tif (ret < 0)\n\t\tgoto no_mem_clone;\n\n\tif (ret == 0) {\n\t\tposix_acl_release(*acl);\n\t\t*acl = NULL;\n\t}\n\n\tif (!S_ISDIR(*mode)) {\n\t\tposix_acl_release(p);\n\t\t*default_acl = NULL;\n\t} else {\n\t\t*default_acl = p;\n\t}\n\treturn 0;\n\napply_umask:\n\t*mode &= ~current_umask();\nno_acl:\n\t*default_acl = NULL;\n\t*acl = NULL;\n\treturn 0;\n\nno_mem_clone:\n\tposix_acl_release(*acl);\nno_mem:\n\tposix_acl_release(p);\n\treturn -ENOMEM;\n}"
        }
      },
      {
        "call_info": {
          "callee": "new_inode",
          "args": [
            "sdp->sd_vfs"
          ],
          "line": 646
        },
        "resolved": true,
        "details": {
          "function_name": "unlock_new_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "924-933",
          "snippet": "void unlock_new_inode(struct inode *inode)\n{\n\tlockdep_annotate_inode_mutex_key(inode);\n\tspin_lock(&inode->i_lock);\n\tWARN_ON(!(inode->i_state & I_NEW));\n\tinode->i_state &= ~I_NEW;\n\tsmp_mb();\n\twake_up_bit(&inode->i_state, __I_NEW);\n\tspin_unlock(&inode->i_lock);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid unlock_new_inode(struct inode *inode)\n{\n\tlockdep_annotate_inode_mutex_key(inode);\n\tspin_lock(&inode->i_lock);\n\tWARN_ON(!(inode->i_state & I_NEW));\n\tinode->i_state &= ~I_NEW;\n\tsmp_mb();\n\twake_up_bit(&inode->i_state, __I_NEW);\n\tspin_unlock(&inode->i_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "gfs2_diradd_alloc_required",
          "args": [
            "dir",
            "name",
            "&da"
          ],
          "line": 642
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_diradd_alloc_required",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/dir.c",
          "lines": "2058-2089",
          "snippet": "int gfs2_diradd_alloc_required(struct inode *inode, const struct qstr *name,\n\t\t\t       struct gfs2_diradd *da)\n{\n\tstruct gfs2_inode *ip = GFS2_I(inode);\n\tstruct gfs2_sbd *sdp = GFS2_SB(inode);\n\tconst unsigned int extra = sizeof(struct gfs2_dinode) - sizeof(struct gfs2_leaf);\n\tstruct gfs2_dirent *dent;\n\tstruct buffer_head *bh;\n\n\tda->nr_blocks = 0;\n\tda->bh = NULL;\n\tda->dent = NULL;\n\n\tdent = gfs2_dirent_search(inode, name, gfs2_dirent_find_space, &bh);\n\tif (!dent) {\n\t\tda->nr_blocks = sdp->sd_max_dirres;\n\t\tif (!(ip->i_diskflags & GFS2_DIF_EXHASH) &&\n\t\t    (GFS2_DIRENT_SIZE(name->len) < extra))\n\t\t\tda->nr_blocks = 1;\n\t\treturn 0;\n\t}\n\tif (IS_ERR(dent))\n\t\treturn PTR_ERR(dent);\n\n\tif (da->save_loc) {\n\t\tda->bh = bh;\n\t\tda->dent = dent;\n\t} else {\n\t\tbrelse(bh);\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"bmap.h\"",
            "#include \"trans.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"inode.h\"",
            "#include \"glock.h\"",
            "#include \"dir.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/crc32.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/sort.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"bmap.h\"\n#include \"trans.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"dir.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/vmalloc.h>\n#include <linux/crc32.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/sort.h>\n#include <linux/buffer_head.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nint gfs2_diradd_alloc_required(struct inode *inode, const struct qstr *name,\n\t\t\t       struct gfs2_diradd *da)\n{\n\tstruct gfs2_inode *ip = GFS2_I(inode);\n\tstruct gfs2_sbd *sdp = GFS2_SB(inode);\n\tconst unsigned int extra = sizeof(struct gfs2_dinode) - sizeof(struct gfs2_leaf);\n\tstruct gfs2_dirent *dent;\n\tstruct buffer_head *bh;\n\n\tda->nr_blocks = 0;\n\tda->bh = NULL;\n\tda->dent = NULL;\n\n\tdent = gfs2_dirent_search(inode, name, gfs2_dirent_find_space, &bh);\n\tif (!dent) {\n\t\tda->nr_blocks = sdp->sd_max_dirres;\n\t\tif (!(ip->i_diskflags & GFS2_DIF_EXHASH) &&\n\t\t    (GFS2_DIRENT_SIZE(name->len) < extra))\n\t\t\tda->nr_blocks = 1;\n\t\treturn 0;\n\t}\n\tif (IS_ERR(dent))\n\t\treturn PTR_ERR(dent);\n\n\tif (da->save_loc) {\n\t\tda->bh = bh;\n\t\tda->dent = dent;\n\t} else {\n\t\tbrelse(bh);\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "finish_no_open",
          "args": [
            "file",
            "NULL"
          ],
          "line": 634
        },
        "resolved": true,
        "details": {
          "function_name": "finish_no_open",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/open.c",
          "lines": "814-818",
          "snippet": "int finish_no_open(struct file *file, struct dentry *dentry)\n{\n\tfile->f_path.dentry = dentry;\n\treturn 1;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/compat.h>",
            "#include <linux/dnotify.h>",
            "#include <linux/ima.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/falloc.h>",
            "#include <linux/audit.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/personality.h>",
            "#include <linux/fs.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/mount.h>",
            "#include <linux/security.h>",
            "#include <linux/securebits.h>",
            "#include <linux/capability.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/namei.h>",
            "#include <linux/tty.h>",
            "#include <linux/module.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/compat.h>\n#include <linux/dnotify.h>\n#include <linux/ima.h>\n#include <linux/fs_struct.h>\n#include <linux/falloc.h>\n#include <linux/audit.h>\n#include <linux/rcupdate.h>\n#include <linux/syscalls.h>\n#include <linux/pagemap.h>\n#include <linux/personality.h>\n#include <linux/fs.h>\n#include <asm/uaccess.h>\n#include <linux/slab.h>\n#include <linux/fcntl.h>\n#include <linux/mount.h>\n#include <linux/security.h>\n#include <linux/securebits.h>\n#include <linux/capability.h>\n#include <linux/backing-dev.h>\n#include <linux/namei.h>\n#include <linux/tty.h>\n#include <linux/module.h>\n#include <linux/fsnotify.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n\nint finish_no_open(struct file *file, struct dentry *dentry)\n{\n\tfile->f_path.dentry = dentry;\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "S_ISREG",
          "args": [
            "inode->i_mode"
          ],
          "line": 631
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-EISDIR"
          ],
          "line": 625
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISDIR",
          "args": [
            "inode->i_mode"
          ],
          "line": 623
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "inode"
          ],
          "line": 622
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "inode"
          ],
          "line": 621
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gfs2_dir_search",
          "args": [
            "dir",
            "&dentry->d_name",
            "!S_ISREG(mode) || excl"
          ],
          "line": 620
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_dir_search",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/dir.c",
          "lines": "1548-1569",
          "snippet": "struct inode *gfs2_dir_search(struct inode *dir, const struct qstr *name,\n\t\t\t      bool fail_on_exist)\n{\n\tstruct buffer_head *bh;\n\tstruct gfs2_dirent *dent;\n\tu64 addr, formal_ino;\n\tu16 dtype;\n\n\tdent = gfs2_dirent_search(dir, name, gfs2_dirent_find, &bh);\n\tif (dent) {\n\t\tif (IS_ERR(dent))\n\t\t\treturn ERR_CAST(dent);\n\t\tdtype = be16_to_cpu(dent->de_type);\n\t\taddr = be64_to_cpu(dent->de_inum.no_addr);\n\t\tformal_ino = be64_to_cpu(dent->de_inum.no_formal_ino);\n\t\tbrelse(bh);\n\t\tif (fail_on_exist)\n\t\t\treturn ERR_PTR(-EEXIST);\n\t\treturn gfs2_inode_lookup(dir->i_sb, dtype, addr, formal_ino, 0);\n\t}\n\treturn ERR_PTR(-ENOENT);\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"bmap.h\"",
            "#include \"trans.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"inode.h\"",
            "#include \"glock.h\"",
            "#include \"dir.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/crc32.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/sort.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"bmap.h\"\n#include \"trans.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"dir.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/vmalloc.h>\n#include <linux/crc32.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/sort.h>\n#include <linux/buffer_head.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nstruct inode *gfs2_dir_search(struct inode *dir, const struct qstr *name,\n\t\t\t      bool fail_on_exist)\n{\n\tstruct buffer_head *bh;\n\tstruct gfs2_dirent *dent;\n\tu64 addr, formal_ino;\n\tu16 dtype;\n\n\tdent = gfs2_dirent_search(dir, name, gfs2_dirent_find, &bh);\n\tif (dent) {\n\t\tif (IS_ERR(dent))\n\t\t\treturn ERR_CAST(dent);\n\t\tdtype = be16_to_cpu(dent->de_type);\n\t\taddr = be64_to_cpu(dent->de_inum.no_addr);\n\t\tformal_ino = be64_to_cpu(dent->de_inum.no_formal_ino);\n\t\tbrelse(bh);\n\t\tif (fail_on_exist)\n\t\t\treturn ERR_PTR(-EEXIST);\n\t\treturn gfs2_inode_lookup(dir->i_sb, dtype, addr, formal_ino, 0);\n\t}\n\treturn ERR_PTR(-ENOENT);\n}"
        }
      },
      {
        "call_info": {
          "callee": "S_ISREG",
          "args": [
            "mode"
          ],
          "line": 620
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "create_ok",
          "args": [
            "dip",
            "name",
            "mode"
          ],
          "line": 616
        },
        "resolved": true,
        "details": {
          "function_name": "create_ok",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/inode.c",
          "lines": "336-355",
          "snippet": "static int create_ok(struct gfs2_inode *dip, const struct qstr *name,\n\t\t     umode_t mode)\n{\n\tint error;\n\n\terror = gfs2_permission(&dip->i_inode, MAY_WRITE | MAY_EXEC);\n\tif (error)\n\t\treturn error;\n\n\t/*  Don't create entries in an unlinked directory  */\n\tif (!dip->i_inode.i_nlink)\n\t\treturn -ENOENT;\n\n\tif (dip->i_entries == (u32)-1)\n\t\treturn -EFBIG;\n\tif (S_ISDIR(mode) && dip->i_inode.i_nlink == (u32)-1)\n\t\treturn -EMLINK;\n\n\treturn 0;\n}",
          "includes": [
            "#include \"glops.h\"",
            "#include \"super.h\"",
            "#include \"util.h\"",
            "#include \"trans.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"inode.h\"",
            "#include \"glock.h\"",
            "#include \"xattr.h\"",
            "#include \"dir.h\"",
            "#include \"bmap.h\"",
            "#include \"acl.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/security.h>",
            "#include <linux/fiemap.h>",
            "#include <linux/crc32.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/xattr.h>",
            "#include <linux/mm.h>",
            "#include <linux/namei.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glops.h\"\n#include \"super.h\"\n#include \"util.h\"\n#include \"trans.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"xattr.h\"\n#include \"dir.h\"\n#include \"bmap.h\"\n#include \"acl.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <asm/uaccess.h>\n#include <linux/security.h>\n#include <linux/fiemap.h>\n#include <linux/crc32.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/posix_acl.h>\n#include <linux/xattr.h>\n#include <linux/mm.h>\n#include <linux/namei.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nstatic int create_ok(struct gfs2_inode *dip, const struct qstr *name,\n\t\t     umode_t mode)\n{\n\tint error;\n\n\terror = gfs2_permission(&dip->i_inode, MAY_WRITE | MAY_EXEC);\n\tif (error)\n\t\treturn error;\n\n\t/*  Don't create entries in an unlinked directory  */\n\tif (!dip->i_inode.i_nlink)\n\t\treturn -ENOENT;\n\n\tif (dip->i_entries == (u32)-1)\n\t\treturn -EFBIG;\n\tif (S_ISDIR(mode) && dip->i_inode.i_nlink == (u32)-1)\n\t\treturn -EMLINK;\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "gfs2_rindex_update",
          "args": [
            "sdp"
          ],
          "line": 608
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_rindex_update",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/rgrp.c",
          "lines": "1029-1052",
          "snippet": "int gfs2_rindex_update(struct gfs2_sbd *sdp)\n{\n\tstruct gfs2_inode *ip = GFS2_I(sdp->sd_rindex);\n\tstruct gfs2_glock *gl = ip->i_gl;\n\tstruct gfs2_holder ri_gh;\n\tint error = 0;\n\tint unlock_required = 0;\n\n\t/* Read new copy from disk if we don't have the latest */\n\tif (!sdp->sd_rindex_uptodate) {\n\t\tif (!gfs2_glock_is_locked_by_me(gl)) {\n\t\t\terror = gfs2_glock_nq_init(gl, LM_ST_SHARED, 0, &ri_gh);\n\t\t\tif (error)\n\t\t\t\treturn error;\n\t\t\tunlock_required = 1;\n\t\t}\n\t\tif (!sdp->sd_rindex_uptodate)\n\t\t\terror = gfs2_ri_update(ip);\n\t\tif (unlock_required)\n\t\t\tgfs2_glock_dq_uninit(&ri_gh);\n\t}\n\n\treturn error;\n}",
          "includes": [
            "#include \"trace_gfs2.h\"",
            "#include \"inode.h\"",
            "#include \"log.h\"",
            "#include \"util.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"lops.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/random.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/fs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"inode.h\"\n#include \"log.h\"\n#include \"util.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"lops.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/random.h>\n#include <linux/rbtree.h>\n#include <linux/blkdev.h>\n#include <linux/prefetch.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/fs.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nint gfs2_rindex_update(struct gfs2_sbd *sdp)\n{\n\tstruct gfs2_inode *ip = GFS2_I(sdp->sd_rindex);\n\tstruct gfs2_glock *gl = ip->i_gl;\n\tstruct gfs2_holder ri_gh;\n\tint error = 0;\n\tint unlock_required = 0;\n\n\t/* Read new copy from disk if we don't have the latest */\n\tif (!sdp->sd_rindex_uptodate) {\n\t\tif (!gfs2_glock_is_locked_by_me(gl)) {\n\t\t\terror = gfs2_glock_nq_init(gl, LM_ST_SHARED, 0, &ri_gh);\n\t\t\tif (error)\n\t\t\t\treturn error;\n\t\t\tunlock_required = 1;\n\t\t}\n\t\tif (!sdp->sd_rindex_uptodate)\n\t\t\terror = gfs2_ri_update(ip);\n\t\tif (unlock_required)\n\t\t\tgfs2_glock_dq_uninit(&ri_gh);\n\t}\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "GFS2_SB",
          "args": [
            "&dip->i_inode"
          ],
          "line": 594
        },
        "resolved": true,
        "details": {
          "function_name": "GFS2_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/incore.h",
          "lines": "413-416",
          "snippet": "static inline struct gfs2_sbd *GFS2_SB(const struct inode *inode)\n{\n\treturn inode->i_sb->s_fs_info;\n}",
          "includes": [
            "#include <linux/lockref.h>",
            "#include <linux/percpu.h>",
            "#include <linux/ktime.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/completion.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/dlm.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/kobject.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/lockref.h>\n#include <linux/percpu.h>\n#include <linux/ktime.h>\n#include <linux/rbtree.h>\n#include <linux/completion.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/buffer_head.h>\n#include <linux/dlm.h>\n#include <linux/workqueue.h>\n#include <linux/kobject.h>\n#include <linux/fs.h>\n\nstatic inline struct gfs2_sbd *GFS2_SB(const struct inode *inode)\n{\n\treturn inode->i_sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"glops.h\"\n#include \"super.h\"\n#include \"util.h\"\n#include \"trans.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"xattr.h\"\n#include \"dir.h\"\n#include \"bmap.h\"\n#include \"acl.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <asm/uaccess.h>\n#include <linux/security.h>\n#include <linux/fiemap.h>\n#include <linux/crc32.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/posix_acl.h>\n#include <linux/xattr.h>\n#include <linux/mm.h>\n#include <linux/namei.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nstatic int gfs2_create_inode(struct inode *dir, struct dentry *dentry,\n\t\t\t     struct file *file,\n\t\t\t     umode_t mode, dev_t dev, const char *symname,\n\t\t\t     unsigned int size, int excl, int *opened)\n{\n\tconst struct qstr *name = &dentry->d_name;\n\tstruct posix_acl *default_acl, *acl;\n\tstruct gfs2_holder ghs[2];\n\tstruct inode *inode = NULL;\n\tstruct gfs2_inode *dip = GFS2_I(dir), *ip;\n\tstruct gfs2_sbd *sdp = GFS2_SB(&dip->i_inode);\n\tstruct gfs2_glock *io_gl;\n\tint error, free_vfs_inode = 0;\n\tu32 aflags = 0;\n\tunsigned blocks = 1;\n\tstruct gfs2_diradd da = { .bh = NULL, .save_loc = 1, };\n\n\tif (!name->len || name->len > GFS2_FNAMESIZE)\n\t\treturn -ENAMETOOLONG;\n\n\terror = gfs2_rs_alloc(dip);\n\tif (error)\n\t\treturn error;\n\n\terror = gfs2_rindex_update(sdp);\n\tif (error)\n\t\treturn error;\n\n\terror = gfs2_glock_nq_init(dip->i_gl, LM_ST_EXCLUSIVE, 0, ghs);\n\tif (error)\n\t\tgoto fail;\n\n\terror = create_ok(dip, name, mode);\n\tif (error)\n\t\tgoto fail_gunlock;\n\n\tinode = gfs2_dir_search(dir, &dentry->d_name, !S_ISREG(mode) || excl);\n\terror = PTR_ERR(inode);\n\tif (!IS_ERR(inode)) {\n\t\tif (S_ISDIR(inode->i_mode)) {\n\t\t\tiput(inode);\n\t\t\tinode = ERR_PTR(-EISDIR);\n\t\t\tgoto fail_gunlock;\n\t\t}\n\t\td_instantiate(dentry, inode);\n\t\terror = 0;\n\t\tif (file) {\n\t\t\tif (S_ISREG(inode->i_mode))\n\t\t\t\terror = finish_open(file, dentry, gfs2_open_common, opened);\n\t\t\telse\n\t\t\t\terror = finish_no_open(file, NULL);\n\t\t}\n\t\tgfs2_glock_dq_uninit(ghs);\n\t\treturn error;\n\t} else if (error != -ENOENT) {\n\t\tgoto fail_gunlock;\n\t}\n\n\terror = gfs2_diradd_alloc_required(dir, name, &da);\n\tif (error < 0)\n\t\tgoto fail_gunlock;\n\n\tinode = new_inode(sdp->sd_vfs);\n\terror = -ENOMEM;\n\tif (!inode)\n\t\tgoto fail_gunlock;\n\n\terror = posix_acl_create(dir, &mode, &default_acl, &acl);\n\tif (error)\n\t\tgoto fail_free_vfs_inode;\n\n\tip = GFS2_I(inode);\n\terror = gfs2_rs_alloc(ip);\n\tif (error)\n\t\tgoto fail_free_acls;\n\n\tinode->i_mode = mode;\n\tset_nlink(inode, S_ISDIR(mode) ? 2 : 1);\n\tinode->i_rdev = dev;\n\tinode->i_size = size;\n\tinode->i_atime = inode->i_mtime = inode->i_ctime = CURRENT_TIME;\n\tgfs2_set_inode_blocks(inode, 1);\n\tmunge_mode_uid_gid(dip, inode);\n\tcheck_and_update_goal(dip);\n\tip->i_goal = dip->i_goal;\n\tip->i_diskflags = 0;\n\tip->i_eattr = 0;\n\tip->i_height = 0;\n\tip->i_depth = 0;\n\tip->i_entries = 0;\n\n\tswitch(mode & S_IFMT) {\n\tcase S_IFREG:\n\t\tif ((dip->i_diskflags & GFS2_DIF_INHERIT_JDATA) ||\n\t\t    gfs2_tune_get(sdp, gt_new_files_jdata))\n\t\t\tip->i_diskflags |= GFS2_DIF_JDATA;\n\t\tgfs2_set_aops(inode);\n\t\tbreak;\n\tcase S_IFDIR:\n\t\tip->i_diskflags |= (dip->i_diskflags & GFS2_DIF_INHERIT_JDATA);\n\t\tip->i_diskflags |= GFS2_DIF_JDATA;\n\t\tip->i_entries = 2;\n\t\tbreak;\n\t}\n\tgfs2_set_inode_flags(inode);\n\n\tif ((GFS2_I(sdp->sd_root_dir->d_inode) == dip) ||\n\t    (dip->i_diskflags & GFS2_DIF_TOPDIR))\n\t\taflags |= GFS2_AF_ORLOV;\n\n\tif (default_acl || acl)\n\t\tblocks++;\n\n\terror = alloc_dinode(ip, aflags, &blocks);\n\tif (error)\n\t\tgoto fail_free_inode;\n\n\tgfs2_set_inode_blocks(inode, blocks);\n\n\terror = gfs2_glock_get(sdp, ip->i_no_addr, &gfs2_inode_glops, CREATE, &ip->i_gl);\n\tif (error)\n\t\tgoto fail_free_inode;\n\n\tip->i_gl->gl_object = ip;\n\terror = gfs2_glock_nq_init(ip->i_gl, LM_ST_EXCLUSIVE, GL_SKIP, ghs + 1);\n\tif (error)\n\t\tgoto fail_free_inode;\n\n\terror = gfs2_trans_begin(sdp, blocks, 0);\n\tif (error)\n\t\tgoto fail_gunlock2;\n\n\tif (blocks > 1) {\n\t\tip->i_eattr = ip->i_no_addr + 1;\n\t\tgfs2_init_xattr(ip);\n\t}\n\tinit_dinode(dip, ip, symname);\n\tgfs2_trans_end(sdp);\n\n\terror = gfs2_glock_get(sdp, ip->i_no_addr, &gfs2_iopen_glops, CREATE, &io_gl);\n\tif (error)\n\t\tgoto fail_gunlock2;\n\n\terror = gfs2_glock_nq_init(io_gl, LM_ST_SHARED, GL_EXACT, &ip->i_iopen_gh);\n\tif (error)\n\t\tgoto fail_gunlock2;\n\n\tip->i_iopen_gh.gh_gl->gl_object = ip;\n\tgfs2_glock_put(io_gl);\n\tgfs2_set_iop(inode);\n\tinsert_inode_hash(inode);\n\n\tif (default_acl) {\n\t\terror = gfs2_set_acl(inode, default_acl, ACL_TYPE_DEFAULT);\n\t\tposix_acl_release(default_acl);\n\t}\n\tif (acl) {\n\t\tif (!error)\n\t\t\terror = gfs2_set_acl(inode, acl, ACL_TYPE_ACCESS);\n\t\tposix_acl_release(acl);\n\t}\n\n\tif (error)\n\t\tgoto fail_gunlock3;\n\n\terror = security_inode_init_security(&ip->i_inode, &dip->i_inode, name,\n\t\t\t\t\t     &gfs2_initxattrs, NULL);\n\tif (error)\n\t\tgoto fail_gunlock3;\n\n\terror = link_dinode(dip, name, ip, &da);\n\tif (error)\n\t\tgoto fail_gunlock3;\n\n\tmark_inode_dirty(inode);\n\td_instantiate(dentry, inode);\n\tif (file) {\n\t\t*opened |= FILE_CREATED;\n\t\terror = finish_open(file, dentry, gfs2_open_common, opened);\n\t}\n\tgfs2_glock_dq_uninit(ghs);\n\tgfs2_glock_dq_uninit(ghs + 1);\n\treturn error;\n\nfail_gunlock3:\n\tgfs2_glock_dq_uninit(ghs + 1);\n\tif (ip->i_gl)\n\t\tgfs2_glock_put(ip->i_gl);\n\tgoto fail_gunlock;\n\nfail_gunlock2:\n\tgfs2_glock_dq_uninit(ghs + 1);\nfail_free_inode:\n\tif (ip->i_gl)\n\t\tgfs2_glock_put(ip->i_gl);\n\tgfs2_rs_delete(ip, NULL);\nfail_free_acls:\n\tif (default_acl)\n\t\tposix_acl_release(default_acl);\n\tif (acl)\n\t\tposix_acl_release(acl);\nfail_free_vfs_inode:\n\tfree_vfs_inode = 1;\nfail_gunlock:\n\tgfs2_dir_no_add(&da);\n\tgfs2_glock_dq_uninit(ghs);\n\tif (inode && !IS_ERR(inode)) {\n\t\tclear_nlink(inode);\n\t\tif (!free_vfs_inode)\n\t\t\tmark_inode_dirty(inode);\n\t\tset_bit(free_vfs_inode ? GIF_FREE_VFS_INODE : GIF_ALLOC_FAILED,\n\t\t\t&GFS2_I(inode)->i_flags);\n\t\tiput(inode);\n\t}\nfail:\n\treturn error;\n}"
  },
  {
    "function_name": "gfs2_initxattrs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/inode.c",
    "lines": "555-569",
    "snippet": "static int gfs2_initxattrs(struct inode *inode, const struct xattr *xattr_array,\n\t\t    void *fs_info)\n{\n\tconst struct xattr *xattr;\n\tint err = 0;\n\n\tfor (xattr = xattr_array; xattr->name != NULL; xattr++) {\n\t\terr = __gfs2_xattr_set(inode, xattr->name, xattr->value,\n\t\t\t\t       xattr->value_len, 0,\n\t\t\t\t       GFS2_EATYPE_SECURITY);\n\t\tif (err < 0)\n\t\t\tbreak;\n\t}\n\treturn err;\n}",
    "includes": [
      "#include \"glops.h\"",
      "#include \"super.h\"",
      "#include \"util.h\"",
      "#include \"trans.h\"",
      "#include \"rgrp.h\"",
      "#include \"quota.h\"",
      "#include \"meta_io.h\"",
      "#include \"inode.h\"",
      "#include \"glock.h\"",
      "#include \"xattr.h\"",
      "#include \"dir.h\"",
      "#include \"bmap.h\"",
      "#include \"acl.h\"",
      "#include \"incore.h\"",
      "#include \"gfs2.h\"",
      "#include <asm/uaccess.h>",
      "#include <linux/security.h>",
      "#include <linux/fiemap.h>",
      "#include <linux/crc32.h>",
      "#include <linux/gfs2_ondisk.h>",
      "#include <linux/posix_acl.h>",
      "#include <linux/xattr.h>",
      "#include <linux/mm.h>",
      "#include <linux/namei.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/completion.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__gfs2_xattr_set",
          "args": [
            "inode",
            "xattr->name",
            "xattr->value",
            "xattr->value_len",
            "0",
            "GFS2_EATYPE_SECURITY"
          ],
          "line": 562
        },
        "resolved": true,
        "details": {
          "function_name": "__gfs2_xattr_set",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/xattr.c",
          "lines": "1175-1228",
          "snippet": "int __gfs2_xattr_set(struct inode *inode, const char *name,\n\t\t   const void *value, size_t size, int flags, int type)\n{\n\tstruct gfs2_inode *ip = GFS2_I(inode);\n\tstruct gfs2_sbd *sdp = GFS2_SB(inode);\n\tstruct gfs2_ea_location el;\n\tunsigned int namel = strlen(name);\n\tint error;\n\n\tif (IS_IMMUTABLE(inode) || IS_APPEND(inode))\n\t\treturn -EPERM;\n\tif (namel > GFS2_EA_MAX_NAME_LEN)\n\t\treturn -ERANGE;\n\n\tif (value == NULL)\n\t\treturn gfs2_xattr_remove(ip, type, name);\n\n\tif (ea_check_size(sdp, namel, size))\n\t\treturn -ERANGE;\n\n\tif (!ip->i_eattr) {\n\t\tif (flags & XATTR_REPLACE)\n\t\t\treturn -ENODATA;\n\t\treturn ea_init(ip, type, name, value, size);\n\t}\n\n\terror = gfs2_ea_find(ip, type, name, &el);\n\tif (error)\n\t\treturn error;\n\n\tif (el.el_ea) {\n\t\tif (ip->i_diskflags & GFS2_DIF_APPENDONLY) {\n\t\t\tbrelse(el.el_bh);\n\t\t\treturn -EPERM;\n\t\t}\n\n\t\terror = -EEXIST;\n\t\tif (!(flags & XATTR_CREATE)) {\n\t\t\tint unstuffed = !GFS2_EA_IS_STUFFED(el.el_ea);\n\t\t\terror = ea_set_i(ip, type, name, value, size, &el);\n\t\t\tif (!error && unstuffed)\n\t\t\t\tea_set_remove_unstuffed(ip, &el);\n\t\t}\n\n\t\tbrelse(el.el_bh);\n\t\treturn error;\n\t}\n\n\terror = -ENODATA;\n\tif (!(flags & XATTR_REPLACE))\n\t\terror = ea_set_i(ip, type, name, value, size, NULL);\n\n\treturn error;\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"trans.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"inode.h\"",
            "#include \"glock.h\"",
            "#include \"xattr.h\"",
            "#include \"acl.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/xattr.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"trans.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"xattr.h\"\n#include \"acl.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <asm/uaccess.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/xattr.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nint __gfs2_xattr_set(struct inode *inode, const char *name,\n\t\t   const void *value, size_t size, int flags, int type)\n{\n\tstruct gfs2_inode *ip = GFS2_I(inode);\n\tstruct gfs2_sbd *sdp = GFS2_SB(inode);\n\tstruct gfs2_ea_location el;\n\tunsigned int namel = strlen(name);\n\tint error;\n\n\tif (IS_IMMUTABLE(inode) || IS_APPEND(inode))\n\t\treturn -EPERM;\n\tif (namel > GFS2_EA_MAX_NAME_LEN)\n\t\treturn -ERANGE;\n\n\tif (value == NULL)\n\t\treturn gfs2_xattr_remove(ip, type, name);\n\n\tif (ea_check_size(sdp, namel, size))\n\t\treturn -ERANGE;\n\n\tif (!ip->i_eattr) {\n\t\tif (flags & XATTR_REPLACE)\n\t\t\treturn -ENODATA;\n\t\treturn ea_init(ip, type, name, value, size);\n\t}\n\n\terror = gfs2_ea_find(ip, type, name, &el);\n\tif (error)\n\t\treturn error;\n\n\tif (el.el_ea) {\n\t\tif (ip->i_diskflags & GFS2_DIF_APPENDONLY) {\n\t\t\tbrelse(el.el_bh);\n\t\t\treturn -EPERM;\n\t\t}\n\n\t\terror = -EEXIST;\n\t\tif (!(flags & XATTR_CREATE)) {\n\t\t\tint unstuffed = !GFS2_EA_IS_STUFFED(el.el_ea);\n\t\t\terror = ea_set_i(ip, type, name, value, size, &el);\n\t\t\tif (!error && unstuffed)\n\t\t\t\tea_set_remove_unstuffed(ip, &el);\n\t\t}\n\n\t\tbrelse(el.el_bh);\n\t\treturn error;\n\t}\n\n\terror = -ENODATA;\n\tif (!(flags & XATTR_REPLACE))\n\t\terror = ea_set_i(ip, type, name, value, size, NULL);\n\n\treturn error;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"glops.h\"\n#include \"super.h\"\n#include \"util.h\"\n#include \"trans.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"xattr.h\"\n#include \"dir.h\"\n#include \"bmap.h\"\n#include \"acl.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <asm/uaccess.h>\n#include <linux/security.h>\n#include <linux/fiemap.h>\n#include <linux/crc32.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/posix_acl.h>\n#include <linux/xattr.h>\n#include <linux/mm.h>\n#include <linux/namei.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nstatic int gfs2_initxattrs(struct inode *inode, const struct xattr *xattr_array,\n\t\t    void *fs_info)\n{\n\tconst struct xattr *xattr;\n\tint err = 0;\n\n\tfor (xattr = xattr_array; xattr->name != NULL; xattr++) {\n\t\terr = __gfs2_xattr_set(inode, xattr->name, xattr->value,\n\t\t\t\t       xattr->value_len, 0,\n\t\t\t\t       GFS2_EATYPE_SECURITY);\n\t\tif (err < 0)\n\t\t\tbreak;\n\t}\n\treturn err;\n}"
  },
  {
    "function_name": "link_dinode",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/inode.c",
    "lines": "520-553",
    "snippet": "static int link_dinode(struct gfs2_inode *dip, const struct qstr *name,\n\t\t       struct gfs2_inode *ip, struct gfs2_diradd *da)\n{\n\tstruct gfs2_sbd *sdp = GFS2_SB(&dip->i_inode);\n\tstruct gfs2_alloc_parms ap = { .target = da->nr_blocks, };\n\tint error;\n\n\tif (da->nr_blocks) {\n\t\terror = gfs2_quota_lock_check(dip);\n\t\tif (error)\n\t\t\tgoto fail_quota_locks;\n\n\t\terror = gfs2_inplace_reserve(dip, &ap);\n\t\tif (error)\n\t\t\tgoto fail_quota_locks;\n\n\t\terror = gfs2_trans_begin(sdp, gfs2_trans_da_blks(dip, da, 2), 0);\n\t\tif (error)\n\t\t\tgoto fail_ipreserv;\n\t} else {\n\t\terror = gfs2_trans_begin(sdp, RES_LEAF + 2 * RES_DINODE, 0);\n\t\tif (error)\n\t\t\tgoto fail_quota_locks;\n\t}\n\n\terror = gfs2_dir_add(&dip->i_inode, name, ip, da);\n\n\tgfs2_trans_end(sdp);\nfail_ipreserv:\n\tgfs2_inplace_release(dip);\nfail_quota_locks:\n\tgfs2_quota_unlock(dip);\n\treturn error;\n}",
    "includes": [
      "#include \"glops.h\"",
      "#include \"super.h\"",
      "#include \"util.h\"",
      "#include \"trans.h\"",
      "#include \"rgrp.h\"",
      "#include \"quota.h\"",
      "#include \"meta_io.h\"",
      "#include \"inode.h\"",
      "#include \"glock.h\"",
      "#include \"xattr.h\"",
      "#include \"dir.h\"",
      "#include \"bmap.h\"",
      "#include \"acl.h\"",
      "#include \"incore.h\"",
      "#include \"gfs2.h\"",
      "#include <asm/uaccess.h>",
      "#include <linux/security.h>",
      "#include <linux/fiemap.h>",
      "#include <linux/crc32.h>",
      "#include <linux/gfs2_ondisk.h>",
      "#include <linux/posix_acl.h>",
      "#include <linux/xattr.h>",
      "#include <linux/mm.h>",
      "#include <linux/namei.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/completion.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "gfs2_quota_unlock",
          "args": [
            "dip"
          ],
          "line": 551
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_quota_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/quota.c",
          "lines": "1033-1081",
          "snippet": "void gfs2_quota_unlock(struct gfs2_inode *ip)\n{\n\tstruct gfs2_sbd *sdp = GFS2_SB(&ip->i_inode);\n\tstruct gfs2_quota_data *qda[4];\n\tunsigned int count = 0;\n\tunsigned int x;\n\tint found;\n\n\tif (!test_and_clear_bit(GIF_QD_LOCKED, &ip->i_flags))\n\t\tgoto out;\n\n\tfor (x = 0; x < ip->i_res->rs_qa_qd_num; x++) {\n\t\tstruct gfs2_quota_data *qd;\n\t\tint sync;\n\n\t\tqd = ip->i_res->rs_qa_qd[x];\n\t\tsync = need_sync(qd);\n\n\t\tgfs2_glock_dq_uninit(&ip->i_res->rs_qa_qd_ghs[x]);\n\t\tif (!sync)\n\t\t\tcontinue;\n\n\t\tspin_lock(&qd_lock);\n\t\tfound = qd_check_sync(sdp, qd, NULL);\n\t\tspin_unlock(&qd_lock);\n\n\t\tif (!found)\n\t\t\tcontinue;\n\n\t\tgfs2_assert_warn(sdp, qd->qd_change_sync);\n\t\tif (bh_get(qd)) {\n\t\t\tclear_bit(QDF_LOCKED, &qd->qd_flags);\n\t\t\tslot_put(qd);\n\t\t\tqd_put(qd);\n\t\t\tcontinue;\n\t\t}\n\n\t\tqda[count++] = qd;\n\t}\n\n\tif (count) {\n\t\tdo_sync(count, qda);\n\t\tfor (x = 0; x < count; x++)\n\t\t\tqd_unlock(qda[x]);\n\t}\n\nout:\n\tgfs2_quota_unhold(ip);\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"inode.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"log.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"bmap.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/jhash.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/lockref.h>",
            "#include <linux/dqblk_xfs.h>",
            "#include <linux/quota.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/bio.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_SPINLOCK(qd_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"inode.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"log.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/vmalloc.h>\n#include <linux/jhash.h>\n#include <linux/bit_spinlock.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/list_lru.h>\n#include <linux/lockref.h>\n#include <linux/dqblk_xfs.h>\n#include <linux/quota.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/bio.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic DEFINE_SPINLOCK(qd_lock);\n\nvoid gfs2_quota_unlock(struct gfs2_inode *ip)\n{\n\tstruct gfs2_sbd *sdp = GFS2_SB(&ip->i_inode);\n\tstruct gfs2_quota_data *qda[4];\n\tunsigned int count = 0;\n\tunsigned int x;\n\tint found;\n\n\tif (!test_and_clear_bit(GIF_QD_LOCKED, &ip->i_flags))\n\t\tgoto out;\n\n\tfor (x = 0; x < ip->i_res->rs_qa_qd_num; x++) {\n\t\tstruct gfs2_quota_data *qd;\n\t\tint sync;\n\n\t\tqd = ip->i_res->rs_qa_qd[x];\n\t\tsync = need_sync(qd);\n\n\t\tgfs2_glock_dq_uninit(&ip->i_res->rs_qa_qd_ghs[x]);\n\t\tif (!sync)\n\t\t\tcontinue;\n\n\t\tspin_lock(&qd_lock);\n\t\tfound = qd_check_sync(sdp, qd, NULL);\n\t\tspin_unlock(&qd_lock);\n\n\t\tif (!found)\n\t\t\tcontinue;\n\n\t\tgfs2_assert_warn(sdp, qd->qd_change_sync);\n\t\tif (bh_get(qd)) {\n\t\t\tclear_bit(QDF_LOCKED, &qd->qd_flags);\n\t\t\tslot_put(qd);\n\t\t\tqd_put(qd);\n\t\t\tcontinue;\n\t\t}\n\n\t\tqda[count++] = qd;\n\t}\n\n\tif (count) {\n\t\tdo_sync(count, qda);\n\t\tfor (x = 0; x < count; x++)\n\t\t\tqd_unlock(qda[x]);\n\t}\n\nout:\n\tgfs2_quota_unhold(ip);\n}"
        }
      },
      {
        "call_info": {
          "callee": "gfs2_inplace_release",
          "args": [
            "dip"
          ],
          "line": 549
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_inplace_release",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/rgrp.c",
          "lines": "2081-2087",
          "snippet": "void gfs2_inplace_release(struct gfs2_inode *ip)\n{\n\tstruct gfs2_blkreserv *rs = ip->i_res;\n\n\tif (rs->rs_rgd_gh.gh_gl)\n\t\tgfs2_glock_dq_uninit(&rs->rs_rgd_gh);\n}",
          "includes": [
            "#include \"trace_gfs2.h\"",
            "#include \"inode.h\"",
            "#include \"log.h\"",
            "#include \"util.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"lops.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/random.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/fs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"inode.h\"\n#include \"log.h\"\n#include \"util.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"lops.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/random.h>\n#include <linux/rbtree.h>\n#include <linux/blkdev.h>\n#include <linux/prefetch.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/fs.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nvoid gfs2_inplace_release(struct gfs2_inode *ip)\n{\n\tstruct gfs2_blkreserv *rs = ip->i_res;\n\n\tif (rs->rs_rgd_gh.gh_gl)\n\t\tgfs2_glock_dq_uninit(&rs->rs_rgd_gh);\n}"
        }
      },
      {
        "call_info": {
          "callee": "gfs2_trans_end",
          "args": [
            "sdp"
          ],
          "line": 547
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_trans_end",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/trans.c",
          "lines": "88-123",
          "snippet": "void gfs2_trans_end(struct gfs2_sbd *sdp)\n{\n\tstruct gfs2_trans *tr = current->journal_info;\n\ts64 nbuf;\n\tint alloced = tr->tr_alloced;\n\n\tBUG_ON(!tr);\n\tcurrent->journal_info = NULL;\n\n\tif (!tr->tr_touched) {\n\t\tgfs2_log_release(sdp, tr->tr_reserved);\n\t\tif (alloced) {\n\t\t\tkfree(tr);\n\t\t\tsb_end_intwrite(sdp->sd_vfs);\n\t\t}\n\t\treturn;\n\t}\n\n\tnbuf = tr->tr_num_buf_new + tr->tr_num_databuf_new;\n\tnbuf -= tr->tr_num_buf_rm;\n\tnbuf -= tr->tr_num_databuf_rm;\n\n\tif (gfs2_assert_withdraw(sdp, (nbuf <= tr->tr_blocks) &&\n\t\t\t\t       (tr->tr_num_revoke <= tr->tr_revokes)))\n\t\tgfs2_print_trans(tr);\n\n\tgfs2_log_commit(sdp, tr);\n\tif (alloced && !tr->tr_attached)\n\t\t\tkfree(tr);\n\tup_read(&sdp->sd_log_flush_lock);\n\n\tif (sdp->sd_vfs->s_flags & MS_SYNCHRONOUS)\n\t\tgfs2_log_flush(sdp, NULL, NORMAL_FLUSH);\n\tif (alloced)\n\t\tsb_end_intwrite(sdp->sd_vfs);\n}",
          "includes": [
            "#include \"trace_gfs2.h\"",
            "#include \"util.h\"",
            "#include \"trans.h\"",
            "#include \"meta_io.h\"",
            "#include \"lops.h\"",
            "#include \"log.h\"",
            "#include \"inode.h\"",
            "#include \"glock.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"util.h\"\n#include \"trans.h\"\n#include \"meta_io.h\"\n#include \"lops.h\"\n#include \"log.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/gfs2_ondisk.h>\n#include <linux/kallsyms.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nvoid gfs2_trans_end(struct gfs2_sbd *sdp)\n{\n\tstruct gfs2_trans *tr = current->journal_info;\n\ts64 nbuf;\n\tint alloced = tr->tr_alloced;\n\n\tBUG_ON(!tr);\n\tcurrent->journal_info = NULL;\n\n\tif (!tr->tr_touched) {\n\t\tgfs2_log_release(sdp, tr->tr_reserved);\n\t\tif (alloced) {\n\t\t\tkfree(tr);\n\t\t\tsb_end_intwrite(sdp->sd_vfs);\n\t\t}\n\t\treturn;\n\t}\n\n\tnbuf = tr->tr_num_buf_new + tr->tr_num_databuf_new;\n\tnbuf -= tr->tr_num_buf_rm;\n\tnbuf -= tr->tr_num_databuf_rm;\n\n\tif (gfs2_assert_withdraw(sdp, (nbuf <= tr->tr_blocks) &&\n\t\t\t\t       (tr->tr_num_revoke <= tr->tr_revokes)))\n\t\tgfs2_print_trans(tr);\n\n\tgfs2_log_commit(sdp, tr);\n\tif (alloced && !tr->tr_attached)\n\t\t\tkfree(tr);\n\tup_read(&sdp->sd_log_flush_lock);\n\n\tif (sdp->sd_vfs->s_flags & MS_SYNCHRONOUS)\n\t\tgfs2_log_flush(sdp, NULL, NORMAL_FLUSH);\n\tif (alloced)\n\t\tsb_end_intwrite(sdp->sd_vfs);\n}"
        }
      },
      {
        "call_info": {
          "callee": "gfs2_dir_add",
          "args": [
            "&dip->i_inode",
            "name",
            "ip",
            "da"
          ],
          "line": 545
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_dir_add",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/dir.c",
          "lines": "1693-1761",
          "snippet": "int gfs2_dir_add(struct inode *inode, const struct qstr *name,\n\t\t const struct gfs2_inode *nip, struct gfs2_diradd *da)\n{\n\tstruct gfs2_inode *ip = GFS2_I(inode);\n\tstruct buffer_head *bh = da->bh;\n\tstruct gfs2_dirent *dent = da->dent;\n\tstruct timespec tv;\n\tstruct gfs2_leaf *leaf;\n\tint error;\n\n\twhile(1) {\n\t\tif (da->bh == NULL) {\n\t\t\tdent = gfs2_dirent_search(inode, name,\n\t\t\t\t\t\t  gfs2_dirent_find_space, &bh);\n\t\t}\n\t\tif (dent) {\n\t\t\tif (IS_ERR(dent))\n\t\t\t\treturn PTR_ERR(dent);\n\t\t\tdent = gfs2_init_dirent(inode, dent, name, bh);\n\t\t\tgfs2_inum_out(nip, dent);\n\t\t\tdent->de_type = cpu_to_be16(IF2DT(nip->i_inode.i_mode));\n\t\t\tdent->de_rahead = cpu_to_be16(gfs2_inode_ra_len(nip));\n\t\t\ttv = CURRENT_TIME;\n\t\t\tif (ip->i_diskflags & GFS2_DIF_EXHASH) {\n\t\t\t\tleaf = (struct gfs2_leaf *)bh->b_data;\n\t\t\t\tbe16_add_cpu(&leaf->lf_entries, 1);\n\t\t\t\tleaf->lf_nsec = cpu_to_be32(tv.tv_nsec);\n\t\t\t\tleaf->lf_sec = cpu_to_be64(tv.tv_sec);\n\t\t\t}\n\t\t\tda->dent = NULL;\n\t\t\tda->bh = NULL;\n\t\t\tbrelse(bh);\n\t\t\tip->i_entries++;\n\t\t\tip->i_inode.i_mtime = ip->i_inode.i_ctime = tv;\n\t\t\tif (S_ISDIR(nip->i_inode.i_mode))\n\t\t\t\tinc_nlink(&ip->i_inode);\n\t\t\tmark_inode_dirty(inode);\n\t\t\terror = 0;\n\t\t\tbreak;\n\t\t}\n\t\tif (!(ip->i_diskflags & GFS2_DIF_EXHASH)) {\n\t\t\terror = dir_make_exhash(inode);\n\t\t\tif (error)\n\t\t\t\tbreak;\n\t\t\tcontinue;\n\t\t}\n\t\terror = dir_split_leaf(inode, name);\n\t\tif (error == 0)\n\t\t\tcontinue;\n\t\tif (error < 0)\n\t\t\tbreak;\n\t\tif (ip->i_depth < GFS2_DIR_MAX_DEPTH) {\n\t\t\terror = dir_double_exhash(ip);\n\t\t\tif (error)\n\t\t\t\tbreak;\n\t\t\terror = dir_split_leaf(inode, name);\n\t\t\tif (error < 0)\n\t\t\t\tbreak;\n\t\t\tif (error == 0)\n\t\t\t\tcontinue;\n\t\t}\n\t\terror = dir_new_leaf(inode, name);\n\t\tif (!error)\n\t\t\tcontinue;\n\t\terror = -ENOSPC;\n\t\tbreak;\n\t}\n\treturn error;\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"bmap.h\"",
            "#include \"trans.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"inode.h\"",
            "#include \"glock.h\"",
            "#include \"dir.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/crc32.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/sort.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"bmap.h\"\n#include \"trans.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"dir.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/vmalloc.h>\n#include <linux/crc32.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/sort.h>\n#include <linux/buffer_head.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nint gfs2_dir_add(struct inode *inode, const struct qstr *name,\n\t\t const struct gfs2_inode *nip, struct gfs2_diradd *da)\n{\n\tstruct gfs2_inode *ip = GFS2_I(inode);\n\tstruct buffer_head *bh = da->bh;\n\tstruct gfs2_dirent *dent = da->dent;\n\tstruct timespec tv;\n\tstruct gfs2_leaf *leaf;\n\tint error;\n\n\twhile(1) {\n\t\tif (da->bh == NULL) {\n\t\t\tdent = gfs2_dirent_search(inode, name,\n\t\t\t\t\t\t  gfs2_dirent_find_space, &bh);\n\t\t}\n\t\tif (dent) {\n\t\t\tif (IS_ERR(dent))\n\t\t\t\treturn PTR_ERR(dent);\n\t\t\tdent = gfs2_init_dirent(inode, dent, name, bh);\n\t\t\tgfs2_inum_out(nip, dent);\n\t\t\tdent->de_type = cpu_to_be16(IF2DT(nip->i_inode.i_mode));\n\t\t\tdent->de_rahead = cpu_to_be16(gfs2_inode_ra_len(nip));\n\t\t\ttv = CURRENT_TIME;\n\t\t\tif (ip->i_diskflags & GFS2_DIF_EXHASH) {\n\t\t\t\tleaf = (struct gfs2_leaf *)bh->b_data;\n\t\t\t\tbe16_add_cpu(&leaf->lf_entries, 1);\n\t\t\t\tleaf->lf_nsec = cpu_to_be32(tv.tv_nsec);\n\t\t\t\tleaf->lf_sec = cpu_to_be64(tv.tv_sec);\n\t\t\t}\n\t\t\tda->dent = NULL;\n\t\t\tda->bh = NULL;\n\t\t\tbrelse(bh);\n\t\t\tip->i_entries++;\n\t\t\tip->i_inode.i_mtime = ip->i_inode.i_ctime = tv;\n\t\t\tif (S_ISDIR(nip->i_inode.i_mode))\n\t\t\t\tinc_nlink(&ip->i_inode);\n\t\t\tmark_inode_dirty(inode);\n\t\t\terror = 0;\n\t\t\tbreak;\n\t\t}\n\t\tif (!(ip->i_diskflags & GFS2_DIF_EXHASH)) {\n\t\t\terror = dir_make_exhash(inode);\n\t\t\tif (error)\n\t\t\t\tbreak;\n\t\t\tcontinue;\n\t\t}\n\t\terror = dir_split_leaf(inode, name);\n\t\tif (error == 0)\n\t\t\tcontinue;\n\t\tif (error < 0)\n\t\t\tbreak;\n\t\tif (ip->i_depth < GFS2_DIR_MAX_DEPTH) {\n\t\t\terror = dir_double_exhash(ip);\n\t\t\tif (error)\n\t\t\t\tbreak;\n\t\t\terror = dir_split_leaf(inode, name);\n\t\t\tif (error < 0)\n\t\t\t\tbreak;\n\t\t\tif (error == 0)\n\t\t\t\tcontinue;\n\t\t}\n\t\terror = dir_new_leaf(inode, name);\n\t\tif (!error)\n\t\t\tcontinue;\n\t\terror = -ENOSPC;\n\t\tbreak;\n\t}\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "gfs2_trans_begin",
          "args": [
            "sdp",
            "RES_LEAF + 2 * RES_DINODE",
            "0"
          ],
          "line": 540
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_trans_begin",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/trans.c",
          "lines": "31-75",
          "snippet": "int gfs2_trans_begin(struct gfs2_sbd *sdp, unsigned int blocks,\n\t\t     unsigned int revokes)\n{\n\tstruct gfs2_trans *tr;\n\tint error;\n\n\tBUG_ON(current->journal_info);\n\tBUG_ON(blocks == 0 && revokes == 0);\n\n\tif (!test_bit(SDF_JOURNAL_LIVE, &sdp->sd_flags))\n\t\treturn -EROFS;\n\n\ttr = kzalloc(sizeof(struct gfs2_trans), GFP_NOFS);\n\tif (!tr)\n\t\treturn -ENOMEM;\n\n\ttr->tr_ip = _RET_IP_;\n\ttr->tr_blocks = blocks;\n\ttr->tr_revokes = revokes;\n\ttr->tr_reserved = 1;\n\ttr->tr_alloced = 1;\n\tif (blocks)\n\t\ttr->tr_reserved += 6 + blocks;\n\tif (revokes)\n\t\ttr->tr_reserved += gfs2_struct2blk(sdp, revokes,\n\t\t\t\t\t\t   sizeof(u64));\n\tINIT_LIST_HEAD(&tr->tr_databuf);\n\tINIT_LIST_HEAD(&tr->tr_buf);\n\n\tsb_start_intwrite(sdp->sd_vfs);\n\n\terror = gfs2_log_reserve(sdp, tr->tr_reserved);\n\tif (error)\n\t\tgoto fail;\n\n\tcurrent->journal_info = tr;\n\n\treturn 0;\n\nfail:\n\tsb_end_intwrite(sdp->sd_vfs);\n\tkfree(tr);\n\n\treturn error;\n}",
          "includes": [
            "#include \"trace_gfs2.h\"",
            "#include \"util.h\"",
            "#include \"trans.h\"",
            "#include \"meta_io.h\"",
            "#include \"lops.h\"",
            "#include \"log.h\"",
            "#include \"inode.h\"",
            "#include \"glock.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"util.h\"\n#include \"trans.h\"\n#include \"meta_io.h\"\n#include \"lops.h\"\n#include \"log.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/gfs2_ondisk.h>\n#include <linux/kallsyms.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nint gfs2_trans_begin(struct gfs2_sbd *sdp, unsigned int blocks,\n\t\t     unsigned int revokes)\n{\n\tstruct gfs2_trans *tr;\n\tint error;\n\n\tBUG_ON(current->journal_info);\n\tBUG_ON(blocks == 0 && revokes == 0);\n\n\tif (!test_bit(SDF_JOURNAL_LIVE, &sdp->sd_flags))\n\t\treturn -EROFS;\n\n\ttr = kzalloc(sizeof(struct gfs2_trans), GFP_NOFS);\n\tif (!tr)\n\t\treturn -ENOMEM;\n\n\ttr->tr_ip = _RET_IP_;\n\ttr->tr_blocks = blocks;\n\ttr->tr_revokes = revokes;\n\ttr->tr_reserved = 1;\n\ttr->tr_alloced = 1;\n\tif (blocks)\n\t\ttr->tr_reserved += 6 + blocks;\n\tif (revokes)\n\t\ttr->tr_reserved += gfs2_struct2blk(sdp, revokes,\n\t\t\t\t\t\t   sizeof(u64));\n\tINIT_LIST_HEAD(&tr->tr_databuf);\n\tINIT_LIST_HEAD(&tr->tr_buf);\n\n\tsb_start_intwrite(sdp->sd_vfs);\n\n\terror = gfs2_log_reserve(sdp, tr->tr_reserved);\n\tif (error)\n\t\tgoto fail;\n\n\tcurrent->journal_info = tr;\n\n\treturn 0;\n\nfail:\n\tsb_end_intwrite(sdp->sd_vfs);\n\tkfree(tr);\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "gfs2_trans_da_blks",
          "args": [
            "dip",
            "da",
            "2"
          ],
          "line": 536
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_trans_da_blks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/inode.c",
          "lines": "512-518",
          "snippet": "static unsigned gfs2_trans_da_blks(const struct gfs2_inode *dip,\n\t\t\t\t   const struct gfs2_diradd *da,\n\t\t\t\t   unsigned nr_inodes)\n{\n\treturn da->nr_blocks + gfs2_rg_blocks(dip, da->nr_blocks) +\n\t       (nr_inodes * RES_DINODE) + RES_QUOTA + RES_STATFS;\n}",
          "includes": [
            "#include \"glops.h\"",
            "#include \"super.h\"",
            "#include \"util.h\"",
            "#include \"trans.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"inode.h\"",
            "#include \"glock.h\"",
            "#include \"xattr.h\"",
            "#include \"dir.h\"",
            "#include \"bmap.h\"",
            "#include \"acl.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/security.h>",
            "#include <linux/fiemap.h>",
            "#include <linux/crc32.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/xattr.h>",
            "#include <linux/mm.h>",
            "#include <linux/namei.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glops.h\"\n#include \"super.h\"\n#include \"util.h\"\n#include \"trans.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"xattr.h\"\n#include \"dir.h\"\n#include \"bmap.h\"\n#include \"acl.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <asm/uaccess.h>\n#include <linux/security.h>\n#include <linux/fiemap.h>\n#include <linux/crc32.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/posix_acl.h>\n#include <linux/xattr.h>\n#include <linux/mm.h>\n#include <linux/namei.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nstatic unsigned gfs2_trans_da_blks(const struct gfs2_inode *dip,\n\t\t\t\t   const struct gfs2_diradd *da,\n\t\t\t\t   unsigned nr_inodes)\n{\n\treturn da->nr_blocks + gfs2_rg_blocks(dip, da->nr_blocks) +\n\t       (nr_inodes * RES_DINODE) + RES_QUOTA + RES_STATFS;\n}"
        }
      },
      {
        "call_info": {
          "callee": "gfs2_inplace_reserve",
          "args": [
            "dip",
            "&ap"
          ],
          "line": 532
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_inplace_reserve",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/rgrp.c",
          "lines": "1952-2072",
          "snippet": "int gfs2_inplace_reserve(struct gfs2_inode *ip, const struct gfs2_alloc_parms *ap)\n{\n\tstruct gfs2_sbd *sdp = GFS2_SB(&ip->i_inode);\n\tstruct gfs2_rgrpd *begin = NULL;\n\tstruct gfs2_blkreserv *rs = ip->i_res;\n\tint error = 0, rg_locked, flags = 0;\n\tu64 last_unlinked = NO_BLOCK;\n\tint loops = 0;\n\tu32 skip = 0;\n\n\tif (sdp->sd_args.ar_rgrplvb)\n\t\tflags |= GL_SKIP;\n\tif (gfs2_assert_warn(sdp, ap->target))\n\t\treturn -EINVAL;\n\tif (gfs2_rs_active(rs)) {\n\t\tbegin = rs->rs_rbm.rgd;\n\t} else if (ip->i_rgd && rgrp_contains_block(ip->i_rgd, ip->i_goal)) {\n\t\trs->rs_rbm.rgd = begin = ip->i_rgd;\n\t} else {\n\t\tcheck_and_update_goal(ip);\n\t\trs->rs_rbm.rgd = begin = gfs2_blk2rgrpd(sdp, ip->i_goal, 1);\n\t}\n\tif (S_ISDIR(ip->i_inode.i_mode) && (ap->aflags & GFS2_AF_ORLOV))\n\t\tskip = gfs2_orlov_skip(ip);\n\tif (rs->rs_rbm.rgd == NULL)\n\t\treturn -EBADSLT;\n\n\twhile (loops < 3) {\n\t\trg_locked = 1;\n\n\t\tif (!gfs2_glock_is_locked_by_me(rs->rs_rbm.rgd->rd_gl)) {\n\t\t\trg_locked = 0;\n\t\t\tif (skip && skip--)\n\t\t\t\tgoto next_rgrp;\n\t\t\tif (!gfs2_rs_active(rs)) {\n\t\t\t\tif (loops == 0 &&\n\t\t\t\t    !fast_to_acquire(rs->rs_rbm.rgd))\n\t\t\t\t\tgoto next_rgrp;\n\t\t\t\tif ((loops < 2) &&\n\t\t\t\t    gfs2_rgrp_used_recently(rs, 1000) &&\n\t\t\t\t    gfs2_rgrp_congested(rs->rs_rbm.rgd, loops))\n\t\t\t\t\tgoto next_rgrp;\n\t\t\t}\n\t\t\terror = gfs2_glock_nq_init(rs->rs_rbm.rgd->rd_gl,\n\t\t\t\t\t\t   LM_ST_EXCLUSIVE, flags,\n\t\t\t\t\t\t   &rs->rs_rgd_gh);\n\t\t\tif (unlikely(error))\n\t\t\t\treturn error;\n\t\t\tif (!gfs2_rs_active(rs) && (loops < 2) &&\n\t\t\t    gfs2_rgrp_congested(rs->rs_rbm.rgd, loops))\n\t\t\t\tgoto skip_rgrp;\n\t\t\tif (sdp->sd_args.ar_rgrplvb) {\n\t\t\t\terror = update_rgrp_lvb(rs->rs_rbm.rgd);\n\t\t\t\tif (unlikely(error)) {\n\t\t\t\t\tgfs2_glock_dq_uninit(&rs->rs_rgd_gh);\n\t\t\t\t\treturn error;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t/* Skip unuseable resource groups */\n\t\tif ((rs->rs_rbm.rgd->rd_flags & (GFS2_RGF_NOALLOC |\n\t\t\t\t\t\t GFS2_RDF_ERROR)) ||\n\t\t    (ap->target > rs->rs_rbm.rgd->rd_extfail_pt))\n\t\t\tgoto skip_rgrp;\n\n\t\tif (sdp->sd_args.ar_rgrplvb)\n\t\t\tgfs2_rgrp_bh_get(rs->rs_rbm.rgd);\n\n\t\t/* Get a reservation if we don't already have one */\n\t\tif (!gfs2_rs_active(rs))\n\t\t\trg_mblk_search(rs->rs_rbm.rgd, ip, ap);\n\n\t\t/* Skip rgrps when we can't get a reservation on first pass */\n\t\tif (!gfs2_rs_active(rs) && (loops < 1))\n\t\t\tgoto check_rgrp;\n\n\t\t/* If rgrp has enough free space, use it */\n\t\tif (rs->rs_rbm.rgd->rd_free_clone >= ap->target) {\n\t\t\tip->i_rgd = rs->rs_rbm.rgd;\n\t\t\treturn 0;\n\t\t}\n\ncheck_rgrp:\n\t\t/* Check for unlinked inodes which can be reclaimed */\n\t\tif (rs->rs_rbm.rgd->rd_flags & GFS2_RDF_CHECK)\n\t\t\ttry_rgrp_unlink(rs->rs_rbm.rgd, &last_unlinked,\n\t\t\t\t\tip->i_no_addr);\nskip_rgrp:\n\t\t/* Drop reservation, if we couldn't use reserved rgrp */\n\t\tif (gfs2_rs_active(rs))\n\t\t\tgfs2_rs_deltree(rs);\n\n\t\t/* Unlock rgrp if required */\n\t\tif (!rg_locked)\n\t\t\tgfs2_glock_dq_uninit(&rs->rs_rgd_gh);\nnext_rgrp:\n\t\t/* Find the next rgrp, and continue looking */\n\t\tif (gfs2_select_rgrp(&rs->rs_rbm.rgd, begin))\n\t\t\tcontinue;\n\t\tif (skip)\n\t\t\tcontinue;\n\n\t\t/* If we've scanned all the rgrps, but found no free blocks\n\t\t * then this checks for some less likely conditions before\n\t\t * trying again.\n\t\t */\n\t\tloops++;\n\t\t/* Check that fs hasn't grown if writing to rindex */\n\t\tif (ip == GFS2_I(sdp->sd_rindex) && !sdp->sd_rindex_uptodate) {\n\t\t\terror = gfs2_ri_update(ip);\n\t\t\tif (error)\n\t\t\t\treturn error;\n\t\t}\n\t\t/* Flushing the log may release space */\n\t\tif (loops == 2)\n\t\t\tgfs2_log_flush(sdp, NULL, NORMAL_FLUSH);\n\t}\n\n\treturn -ENOSPC;\n}",
          "includes": [
            "#include \"trace_gfs2.h\"",
            "#include \"inode.h\"",
            "#include \"log.h\"",
            "#include \"util.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"lops.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/random.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/fs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [
            "#define NO_BLOCK ((u64)~0)"
          ],
          "globals_used": [
            "static int gfs2_rbm_find(struct gfs2_rbm *rbm, u8 state, u32 *minext,\n\t\t\t const struct gfs2_inode *ip, bool nowrap,\n\t\t\t const struct gfs2_alloc_parms *ap);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"inode.h\"\n#include \"log.h\"\n#include \"util.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"lops.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/random.h>\n#include <linux/rbtree.h>\n#include <linux/blkdev.h>\n#include <linux/prefetch.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/fs.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\n#define NO_BLOCK ((u64)~0)\n\nstatic int gfs2_rbm_find(struct gfs2_rbm *rbm, u8 state, u32 *minext,\n\t\t\t const struct gfs2_inode *ip, bool nowrap,\n\t\t\t const struct gfs2_alloc_parms *ap);\n\nint gfs2_inplace_reserve(struct gfs2_inode *ip, const struct gfs2_alloc_parms *ap)\n{\n\tstruct gfs2_sbd *sdp = GFS2_SB(&ip->i_inode);\n\tstruct gfs2_rgrpd *begin = NULL;\n\tstruct gfs2_blkreserv *rs = ip->i_res;\n\tint error = 0, rg_locked, flags = 0;\n\tu64 last_unlinked = NO_BLOCK;\n\tint loops = 0;\n\tu32 skip = 0;\n\n\tif (sdp->sd_args.ar_rgrplvb)\n\t\tflags |= GL_SKIP;\n\tif (gfs2_assert_warn(sdp, ap->target))\n\t\treturn -EINVAL;\n\tif (gfs2_rs_active(rs)) {\n\t\tbegin = rs->rs_rbm.rgd;\n\t} else if (ip->i_rgd && rgrp_contains_block(ip->i_rgd, ip->i_goal)) {\n\t\trs->rs_rbm.rgd = begin = ip->i_rgd;\n\t} else {\n\t\tcheck_and_update_goal(ip);\n\t\trs->rs_rbm.rgd = begin = gfs2_blk2rgrpd(sdp, ip->i_goal, 1);\n\t}\n\tif (S_ISDIR(ip->i_inode.i_mode) && (ap->aflags & GFS2_AF_ORLOV))\n\t\tskip = gfs2_orlov_skip(ip);\n\tif (rs->rs_rbm.rgd == NULL)\n\t\treturn -EBADSLT;\n\n\twhile (loops < 3) {\n\t\trg_locked = 1;\n\n\t\tif (!gfs2_glock_is_locked_by_me(rs->rs_rbm.rgd->rd_gl)) {\n\t\t\trg_locked = 0;\n\t\t\tif (skip && skip--)\n\t\t\t\tgoto next_rgrp;\n\t\t\tif (!gfs2_rs_active(rs)) {\n\t\t\t\tif (loops == 0 &&\n\t\t\t\t    !fast_to_acquire(rs->rs_rbm.rgd))\n\t\t\t\t\tgoto next_rgrp;\n\t\t\t\tif ((loops < 2) &&\n\t\t\t\t    gfs2_rgrp_used_recently(rs, 1000) &&\n\t\t\t\t    gfs2_rgrp_congested(rs->rs_rbm.rgd, loops))\n\t\t\t\t\tgoto next_rgrp;\n\t\t\t}\n\t\t\terror = gfs2_glock_nq_init(rs->rs_rbm.rgd->rd_gl,\n\t\t\t\t\t\t   LM_ST_EXCLUSIVE, flags,\n\t\t\t\t\t\t   &rs->rs_rgd_gh);\n\t\t\tif (unlikely(error))\n\t\t\t\treturn error;\n\t\t\tif (!gfs2_rs_active(rs) && (loops < 2) &&\n\t\t\t    gfs2_rgrp_congested(rs->rs_rbm.rgd, loops))\n\t\t\t\tgoto skip_rgrp;\n\t\t\tif (sdp->sd_args.ar_rgrplvb) {\n\t\t\t\terror = update_rgrp_lvb(rs->rs_rbm.rgd);\n\t\t\t\tif (unlikely(error)) {\n\t\t\t\t\tgfs2_glock_dq_uninit(&rs->rs_rgd_gh);\n\t\t\t\t\treturn error;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t/* Skip unuseable resource groups */\n\t\tif ((rs->rs_rbm.rgd->rd_flags & (GFS2_RGF_NOALLOC |\n\t\t\t\t\t\t GFS2_RDF_ERROR)) ||\n\t\t    (ap->target > rs->rs_rbm.rgd->rd_extfail_pt))\n\t\t\tgoto skip_rgrp;\n\n\t\tif (sdp->sd_args.ar_rgrplvb)\n\t\t\tgfs2_rgrp_bh_get(rs->rs_rbm.rgd);\n\n\t\t/* Get a reservation if we don't already have one */\n\t\tif (!gfs2_rs_active(rs))\n\t\t\trg_mblk_search(rs->rs_rbm.rgd, ip, ap);\n\n\t\t/* Skip rgrps when we can't get a reservation on first pass */\n\t\tif (!gfs2_rs_active(rs) && (loops < 1))\n\t\t\tgoto check_rgrp;\n\n\t\t/* If rgrp has enough free space, use it */\n\t\tif (rs->rs_rbm.rgd->rd_free_clone >= ap->target) {\n\t\t\tip->i_rgd = rs->rs_rbm.rgd;\n\t\t\treturn 0;\n\t\t}\n\ncheck_rgrp:\n\t\t/* Check for unlinked inodes which can be reclaimed */\n\t\tif (rs->rs_rbm.rgd->rd_flags & GFS2_RDF_CHECK)\n\t\t\ttry_rgrp_unlink(rs->rs_rbm.rgd, &last_unlinked,\n\t\t\t\t\tip->i_no_addr);\nskip_rgrp:\n\t\t/* Drop reservation, if we couldn't use reserved rgrp */\n\t\tif (gfs2_rs_active(rs))\n\t\t\tgfs2_rs_deltree(rs);\n\n\t\t/* Unlock rgrp if required */\n\t\tif (!rg_locked)\n\t\t\tgfs2_glock_dq_uninit(&rs->rs_rgd_gh);\nnext_rgrp:\n\t\t/* Find the next rgrp, and continue looking */\n\t\tif (gfs2_select_rgrp(&rs->rs_rbm.rgd, begin))\n\t\t\tcontinue;\n\t\tif (skip)\n\t\t\tcontinue;\n\n\t\t/* If we've scanned all the rgrps, but found no free blocks\n\t\t * then this checks for some less likely conditions before\n\t\t * trying again.\n\t\t */\n\t\tloops++;\n\t\t/* Check that fs hasn't grown if writing to rindex */\n\t\tif (ip == GFS2_I(sdp->sd_rindex) && !sdp->sd_rindex_uptodate) {\n\t\t\terror = gfs2_ri_update(ip);\n\t\t\tif (error)\n\t\t\t\treturn error;\n\t\t}\n\t\t/* Flushing the log may release space */\n\t\tif (loops == 2)\n\t\t\tgfs2_log_flush(sdp, NULL, NORMAL_FLUSH);\n\t}\n\n\treturn -ENOSPC;\n}"
        }
      },
      {
        "call_info": {
          "callee": "gfs2_quota_lock_check",
          "args": [
            "dip"
          ],
          "line": 528
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_quota_lock_check",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/quota.h",
          "lines": "40-55",
          "snippet": "static inline int gfs2_quota_lock_check(struct gfs2_inode *ip)\n{\n\tstruct gfs2_sbd *sdp = GFS2_SB(&ip->i_inode);\n\tint ret;\n\tif (sdp->sd_args.ar_quota == GFS2_QUOTA_OFF)\n\t\treturn 0;\n\tret = gfs2_quota_lock(ip, NO_UID_QUOTA_CHANGE, NO_GID_QUOTA_CHANGE);\n\tif (ret)\n\t\treturn ret;\n\tif (sdp->sd_args.ar_quota != GFS2_QUOTA_ON)\n\t\treturn 0;\n\tret = gfs2_quota_check(ip, ip->i_inode.i_uid, ip->i_inode.i_gid);\n\tif (ret)\n\t\tgfs2_quota_unlock(ip);\n\treturn ret;\n}",
          "includes": [
            "#include <linux/list_lru.h>"
          ],
          "macros_used": [
            "#define NO_GID_QUOTA_CHANGE INVALID_GID",
            "#define NO_UID_QUOTA_CHANGE INVALID_UID"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/list_lru.h>\n\n#define NO_GID_QUOTA_CHANGE INVALID_GID\n#define NO_UID_QUOTA_CHANGE INVALID_UID\n\nstatic inline int gfs2_quota_lock_check(struct gfs2_inode *ip)\n{\n\tstruct gfs2_sbd *sdp = GFS2_SB(&ip->i_inode);\n\tint ret;\n\tif (sdp->sd_args.ar_quota == GFS2_QUOTA_OFF)\n\t\treturn 0;\n\tret = gfs2_quota_lock(ip, NO_UID_QUOTA_CHANGE, NO_GID_QUOTA_CHANGE);\n\tif (ret)\n\t\treturn ret;\n\tif (sdp->sd_args.ar_quota != GFS2_QUOTA_ON)\n\t\treturn 0;\n\tret = gfs2_quota_check(ip, ip->i_inode.i_uid, ip->i_inode.i_gid);\n\tif (ret)\n\t\tgfs2_quota_unlock(ip);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "GFS2_SB",
          "args": [
            "&dip->i_inode"
          ],
          "line": 523
        },
        "resolved": true,
        "details": {
          "function_name": "GFS2_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/incore.h",
          "lines": "413-416",
          "snippet": "static inline struct gfs2_sbd *GFS2_SB(const struct inode *inode)\n{\n\treturn inode->i_sb->s_fs_info;\n}",
          "includes": [
            "#include <linux/lockref.h>",
            "#include <linux/percpu.h>",
            "#include <linux/ktime.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/completion.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/dlm.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/kobject.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/lockref.h>\n#include <linux/percpu.h>\n#include <linux/ktime.h>\n#include <linux/rbtree.h>\n#include <linux/completion.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/buffer_head.h>\n#include <linux/dlm.h>\n#include <linux/workqueue.h>\n#include <linux/kobject.h>\n#include <linux/fs.h>\n\nstatic inline struct gfs2_sbd *GFS2_SB(const struct inode *inode)\n{\n\treturn inode->i_sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"glops.h\"\n#include \"super.h\"\n#include \"util.h\"\n#include \"trans.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"xattr.h\"\n#include \"dir.h\"\n#include \"bmap.h\"\n#include \"acl.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <asm/uaccess.h>\n#include <linux/security.h>\n#include <linux/fiemap.h>\n#include <linux/crc32.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/posix_acl.h>\n#include <linux/xattr.h>\n#include <linux/mm.h>\n#include <linux/namei.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nstatic int link_dinode(struct gfs2_inode *dip, const struct qstr *name,\n\t\t       struct gfs2_inode *ip, struct gfs2_diradd *da)\n{\n\tstruct gfs2_sbd *sdp = GFS2_SB(&dip->i_inode);\n\tstruct gfs2_alloc_parms ap = { .target = da->nr_blocks, };\n\tint error;\n\n\tif (da->nr_blocks) {\n\t\terror = gfs2_quota_lock_check(dip);\n\t\tif (error)\n\t\t\tgoto fail_quota_locks;\n\n\t\terror = gfs2_inplace_reserve(dip, &ap);\n\t\tif (error)\n\t\t\tgoto fail_quota_locks;\n\n\t\terror = gfs2_trans_begin(sdp, gfs2_trans_da_blks(dip, da, 2), 0);\n\t\tif (error)\n\t\t\tgoto fail_ipreserv;\n\t} else {\n\t\terror = gfs2_trans_begin(sdp, RES_LEAF + 2 * RES_DINODE, 0);\n\t\tif (error)\n\t\t\tgoto fail_quota_locks;\n\t}\n\n\terror = gfs2_dir_add(&dip->i_inode, name, ip, da);\n\n\tgfs2_trans_end(sdp);\nfail_ipreserv:\n\tgfs2_inplace_release(dip);\nfail_quota_locks:\n\tgfs2_quota_unlock(dip);\n\treturn error;\n}"
  },
  {
    "function_name": "gfs2_trans_da_blks",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/inode.c",
    "lines": "512-518",
    "snippet": "static unsigned gfs2_trans_da_blks(const struct gfs2_inode *dip,\n\t\t\t\t   const struct gfs2_diradd *da,\n\t\t\t\t   unsigned nr_inodes)\n{\n\treturn da->nr_blocks + gfs2_rg_blocks(dip, da->nr_blocks) +\n\t       (nr_inodes * RES_DINODE) + RES_QUOTA + RES_STATFS;\n}",
    "includes": [
      "#include \"glops.h\"",
      "#include \"super.h\"",
      "#include \"util.h\"",
      "#include \"trans.h\"",
      "#include \"rgrp.h\"",
      "#include \"quota.h\"",
      "#include \"meta_io.h\"",
      "#include \"inode.h\"",
      "#include \"glock.h\"",
      "#include \"xattr.h\"",
      "#include \"dir.h\"",
      "#include \"bmap.h\"",
      "#include \"acl.h\"",
      "#include \"incore.h\"",
      "#include \"gfs2.h\"",
      "#include <asm/uaccess.h>",
      "#include <linux/security.h>",
      "#include <linux/fiemap.h>",
      "#include <linux/crc32.h>",
      "#include <linux/gfs2_ondisk.h>",
      "#include <linux/posix_acl.h>",
      "#include <linux/xattr.h>",
      "#include <linux/mm.h>",
      "#include <linux/namei.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/completion.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "gfs2_rg_blocks",
          "args": [
            "dip",
            "da->nr_blocks"
          ],
          "line": 516
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_rg_blocks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/trans.h",
          "lines": "31-36",
          "snippet": "static inline unsigned int gfs2_rg_blocks(const struct gfs2_inode *ip, unsigned requested)\n{\n\tif (requested < ip->i_rgd->rd_length)\n\t\treturn requested + 1;\n\treturn ip->i_rgd->rd_length;\n}",
          "includes": [
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/buffer_head.h>\n\nstatic inline unsigned int gfs2_rg_blocks(const struct gfs2_inode *ip, unsigned requested)\n{\n\tif (requested < ip->i_rgd->rd_length)\n\t\treturn requested + 1;\n\treturn ip->i_rgd->rd_length;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"glops.h\"\n#include \"super.h\"\n#include \"util.h\"\n#include \"trans.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"xattr.h\"\n#include \"dir.h\"\n#include \"bmap.h\"\n#include \"acl.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <asm/uaccess.h>\n#include <linux/security.h>\n#include <linux/fiemap.h>\n#include <linux/crc32.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/posix_acl.h>\n#include <linux/xattr.h>\n#include <linux/mm.h>\n#include <linux/namei.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nstatic unsigned gfs2_trans_da_blks(const struct gfs2_inode *dip,\n\t\t\t\t   const struct gfs2_diradd *da,\n\t\t\t\t   unsigned nr_inodes)\n{\n\treturn da->nr_blocks + gfs2_rg_blocks(dip, da->nr_blocks) +\n\t       (nr_inodes * RES_DINODE) + RES_QUOTA + RES_STATFS;\n}"
  },
  {
    "function_name": "init_dinode",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/inode.c",
    "lines": "465-496",
    "snippet": "static void init_dinode(struct gfs2_inode *dip, struct gfs2_inode *ip,\n\t\t\tconst char *symname)\n{\n\tstruct gfs2_dinode *di;\n\tstruct buffer_head *dibh;\n\n\tdibh = gfs2_meta_new(ip->i_gl, ip->i_no_addr);\n\tgfs2_trans_add_meta(ip->i_gl, dibh);\n\tdi = (struct gfs2_dinode *)dibh->b_data;\n\tgfs2_dinode_out(ip, di);\n\n\tdi->di_major = cpu_to_be32(MAJOR(ip->i_inode.i_rdev));\n\tdi->di_minor = cpu_to_be32(MINOR(ip->i_inode.i_rdev));\n\tdi->__pad1 = 0;\n\tdi->__pad2 = 0;\n\tdi->__pad3 = 0;\n\tmemset(&di->__pad4, 0, sizeof(di->__pad4));\n\tmemset(&di->di_reserved, 0, sizeof(di->di_reserved));\n\tgfs2_buffer_clear_tail(dibh, sizeof(struct gfs2_dinode));\n\n\tswitch(ip->i_inode.i_mode & S_IFMT) {\n\tcase S_IFDIR:\n\t\tgfs2_init_dir(dibh, dip);\n\t\tbreak;\n\tcase S_IFLNK:\n\t\tmemcpy(dibh->b_data + sizeof(struct gfs2_dinode), symname, ip->i_inode.i_size);\n\t\tbreak;\n\t}\n\n\tset_buffer_uptodate(dibh);\n\tbrelse(dibh);\n}",
    "includes": [
      "#include \"glops.h\"",
      "#include \"super.h\"",
      "#include \"util.h\"",
      "#include \"trans.h\"",
      "#include \"rgrp.h\"",
      "#include \"quota.h\"",
      "#include \"meta_io.h\"",
      "#include \"inode.h\"",
      "#include \"glock.h\"",
      "#include \"xattr.h\"",
      "#include \"dir.h\"",
      "#include \"bmap.h\"",
      "#include \"acl.h\"",
      "#include \"incore.h\"",
      "#include \"gfs2.h\"",
      "#include <asm/uaccess.h>",
      "#include <linux/security.h>",
      "#include <linux/fiemap.h>",
      "#include <linux/crc32.h>",
      "#include <linux/gfs2_ondisk.h>",
      "#include <linux/posix_acl.h>",
      "#include <linux/xattr.h>",
      "#include <linux/mm.h>",
      "#include <linux/namei.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/completion.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "brelse",
          "args": [
            "dibh"
          ],
          "line": 495
        },
        "resolved": true,
        "details": {
          "function_name": "__brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1177-1184",
          "snippet": "void __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_buffer_uptodate",
          "args": [
            "dibh"
          ],
          "line": 494
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_set_buffer_uptodate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/disk-io.c",
          "lines": "3758-3761",
          "snippet": "int btrfs_set_buffer_uptodate(struct extent_buffer *buf)\n{\n\treturn set_extent_buffer_uptodate(buf);\n}",
          "includes": [
            "#include <asm/cpufeature.h>",
            "#include \"qgroup.h\"",
            "#include \"sysfs.h\"",
            "#include \"raid56.h\"",
            "#include \"dev-replace.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"inode-map.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"tree-log.h\"",
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"hash.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/uuid.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/migrate.h>",
            "#include <linux/slab.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/writeback.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/swap.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/cpufeature.h>\n#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"raid56.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <asm/unaligned.h>\n#include <linux/semaphore.h>\n#include <linux/uuid.h>\n#include <linux/ratelimit.h>\n#include <linux/migrate.h>\n#include <linux/slab.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/writeback.h>\n#include <linux/radix-tree.h>\n#include <linux/swap.h>\n#include <linux/scatterlist.h>\n#include <linux/blkdev.h>\n#include <linux/fs.h>\n\nint btrfs_set_buffer_uptodate(struct extent_buffer *buf)\n{\n\treturn set_extent_buffer_uptodate(buf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "dibh->b_data + sizeof(struct gfs2_dinode)",
            "symname",
            "ip->i_inode.i_size"
          ],
          "line": 490
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gfs2_init_dir",
          "args": [
            "dibh",
            "dip"
          ],
          "line": 487
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_init_dir",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/inode.c",
          "lines": "412-427",
          "snippet": "static void gfs2_init_dir(struct buffer_head *dibh,\n\t\t\t  const struct gfs2_inode *parent)\n{\n\tstruct gfs2_dinode *di = (struct gfs2_dinode *)dibh->b_data;\n\tstruct gfs2_dirent *dent = (struct gfs2_dirent *)(di+1);\n\n\tgfs2_qstr2dirent(&gfs2_qdot, GFS2_DIRENT_SIZE(gfs2_qdot.len), dent);\n\tdent->de_inum = di->di_num; /* already GFS2 endian */\n\tdent->de_type = cpu_to_be16(DT_DIR);\n\n\tdent = (struct gfs2_dirent *)((char*)dent + GFS2_DIRENT_SIZE(1));\n\tgfs2_qstr2dirent(&gfs2_qdotdot, dibh->b_size - GFS2_DIRENT_SIZE(1) - sizeof(struct gfs2_dinode), dent);\n\tgfs2_inum_out(parent, dent);\n\tdent->de_type = cpu_to_be16(DT_DIR);\n\t\n}",
          "includes": [
            "#include \"glops.h\"",
            "#include \"super.h\"",
            "#include \"util.h\"",
            "#include \"trans.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"inode.h\"",
            "#include \"glock.h\"",
            "#include \"xattr.h\"",
            "#include \"dir.h\"",
            "#include \"bmap.h\"",
            "#include \"acl.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/security.h>",
            "#include <linux/fiemap.h>",
            "#include <linux/crc32.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/xattr.h>",
            "#include <linux/mm.h>",
            "#include <linux/namei.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glops.h\"\n#include \"super.h\"\n#include \"util.h\"\n#include \"trans.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"xattr.h\"\n#include \"dir.h\"\n#include \"bmap.h\"\n#include \"acl.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <asm/uaccess.h>\n#include <linux/security.h>\n#include <linux/fiemap.h>\n#include <linux/crc32.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/posix_acl.h>\n#include <linux/xattr.h>\n#include <linux/mm.h>\n#include <linux/namei.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nstatic void gfs2_init_dir(struct buffer_head *dibh,\n\t\t\t  const struct gfs2_inode *parent)\n{\n\tstruct gfs2_dinode *di = (struct gfs2_dinode *)dibh->b_data;\n\tstruct gfs2_dirent *dent = (struct gfs2_dirent *)(di+1);\n\n\tgfs2_qstr2dirent(&gfs2_qdot, GFS2_DIRENT_SIZE(gfs2_qdot.len), dent);\n\tdent->de_inum = di->di_num; /* already GFS2 endian */\n\tdent->de_type = cpu_to_be16(DT_DIR);\n\n\tdent = (struct gfs2_dirent *)((char*)dent + GFS2_DIRENT_SIZE(1));\n\tgfs2_qstr2dirent(&gfs2_qdotdot, dibh->b_size - GFS2_DIRENT_SIZE(1) - sizeof(struct gfs2_dinode), dent);\n\tgfs2_inum_out(parent, dent);\n\tdent->de_type = cpu_to_be16(DT_DIR);\n\t\n}"
        }
      },
      {
        "call_info": {
          "callee": "gfs2_buffer_clear_tail",
          "args": [
            "dibh",
            "sizeof(struct gfs2_dinode)"
          ],
          "line": 483
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_buffer_clear_tail",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/meta_io.h",
          "lines": "22-26",
          "snippet": "static inline void gfs2_buffer_clear_tail(struct buffer_head *bh, int head)\n{\n\tBUG_ON(head > bh->b_size);\n\tmemset(bh->b_data + head, 0, bh->b_size - head);\n}",
          "includes": [
            "#include \"incore.h\"",
            "#include <linux/string.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"incore.h\"\n#include <linux/string.h>\n#include <linux/buffer_head.h>\n\nstatic inline void gfs2_buffer_clear_tail(struct buffer_head *bh, int head)\n{\n\tBUG_ON(head > bh->b_size);\n\tmemset(bh->b_data + head, 0, bh->b_size - head);\n}"
        }
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&di->di_reserved",
            "0",
            "sizeof(di->di_reserved)"
          ],
          "line": 482
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&di->__pad4",
            "0",
            "sizeof(di->__pad4)"
          ],
          "line": 481
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "MINOR(ip->i_inode.i_rdev)"
          ],
          "line": 477
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MINOR",
          "args": [
            "ip->i_inode.i_rdev"
          ],
          "line": 477
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "MAJOR(ip->i_inode.i_rdev)"
          ],
          "line": 476
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MAJOR",
          "args": [
            "ip->i_inode.i_rdev"
          ],
          "line": 476
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gfs2_dinode_out",
          "args": [
            "ip",
            "di"
          ],
          "line": 474
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_dinode_out",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/super.c",
          "lines": "696-731",
          "snippet": "void gfs2_dinode_out(const struct gfs2_inode *ip, void *buf)\n{\n\tstruct gfs2_dinode *str = buf;\n\n\tstr->di_header.mh_magic = cpu_to_be32(GFS2_MAGIC);\n\tstr->di_header.mh_type = cpu_to_be32(GFS2_METATYPE_DI);\n\tstr->di_header.mh_format = cpu_to_be32(GFS2_FORMAT_DI);\n\tstr->di_num.no_addr = cpu_to_be64(ip->i_no_addr);\n\tstr->di_num.no_formal_ino = cpu_to_be64(ip->i_no_formal_ino);\n\tstr->di_mode = cpu_to_be32(ip->i_inode.i_mode);\n\tstr->di_uid = cpu_to_be32(i_uid_read(&ip->i_inode));\n\tstr->di_gid = cpu_to_be32(i_gid_read(&ip->i_inode));\n\tstr->di_nlink = cpu_to_be32(ip->i_inode.i_nlink);\n\tstr->di_size = cpu_to_be64(i_size_read(&ip->i_inode));\n\tstr->di_blocks = cpu_to_be64(gfs2_get_inode_blocks(&ip->i_inode));\n\tstr->di_atime = cpu_to_be64(ip->i_inode.i_atime.tv_sec);\n\tstr->di_mtime = cpu_to_be64(ip->i_inode.i_mtime.tv_sec);\n\tstr->di_ctime = cpu_to_be64(ip->i_inode.i_ctime.tv_sec);\n\n\tstr->di_goal_meta = cpu_to_be64(ip->i_goal);\n\tstr->di_goal_data = cpu_to_be64(ip->i_goal);\n\tstr->di_generation = cpu_to_be64(ip->i_generation);\n\n\tstr->di_flags = cpu_to_be32(ip->i_diskflags);\n\tstr->di_height = cpu_to_be16(ip->i_height);\n\tstr->di_payload_format = cpu_to_be32(S_ISDIR(ip->i_inode.i_mode) &&\n\t\t\t\t\t     !(ip->i_diskflags & GFS2_DIF_EXHASH) ?\n\t\t\t\t\t     GFS2_FORMAT_DE : 0);\n\tstr->di_depth = cpu_to_be16(ip->i_depth);\n\tstr->di_entries = cpu_to_be32(ip->i_entries);\n\n\tstr->di_eattr = cpu_to_be64(ip->i_eattr);\n\tstr->di_atime_nsec = cpu_to_be32(ip->i_inode.i_atime.tv_nsec);\n\tstr->di_mtime_nsec = cpu_to_be32(ip->i_inode.i_mtime.tv_nsec);\n\tstr->di_ctime_nsec = cpu_to_be32(ip->i_inode.i_ctime.tv_nsec);\n}",
          "includes": [
            "#include \"xattr.h\"",
            "#include \"sys.h\"",
            "#include \"util.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"recovery.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"log.h\"",
            "#include \"inode.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"dir.h\"",
            "#include \"bmap.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/kernel.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/wait.h>",
            "#include <linux/time.h>",
            "#include <linux/crc32.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/mount.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/statfs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/bio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xattr.h\"\n#include \"sys.h\"\n#include \"util.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"recovery.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"log.h\"\n#include \"inode.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"dir.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/kernel.h>\n#include <linux/backing-dev.h>\n#include <linux/writeback.h>\n#include <linux/wait.h>\n#include <linux/time.h>\n#include <linux/crc32.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/mount.h>\n#include <linux/seq_file.h>\n#include <linux/statfs.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/bio.h>\n\nvoid gfs2_dinode_out(const struct gfs2_inode *ip, void *buf)\n{\n\tstruct gfs2_dinode *str = buf;\n\n\tstr->di_header.mh_magic = cpu_to_be32(GFS2_MAGIC);\n\tstr->di_header.mh_type = cpu_to_be32(GFS2_METATYPE_DI);\n\tstr->di_header.mh_format = cpu_to_be32(GFS2_FORMAT_DI);\n\tstr->di_num.no_addr = cpu_to_be64(ip->i_no_addr);\n\tstr->di_num.no_formal_ino = cpu_to_be64(ip->i_no_formal_ino);\n\tstr->di_mode = cpu_to_be32(ip->i_inode.i_mode);\n\tstr->di_uid = cpu_to_be32(i_uid_read(&ip->i_inode));\n\tstr->di_gid = cpu_to_be32(i_gid_read(&ip->i_inode));\n\tstr->di_nlink = cpu_to_be32(ip->i_inode.i_nlink);\n\tstr->di_size = cpu_to_be64(i_size_read(&ip->i_inode));\n\tstr->di_blocks = cpu_to_be64(gfs2_get_inode_blocks(&ip->i_inode));\n\tstr->di_atime = cpu_to_be64(ip->i_inode.i_atime.tv_sec);\n\tstr->di_mtime = cpu_to_be64(ip->i_inode.i_mtime.tv_sec);\n\tstr->di_ctime = cpu_to_be64(ip->i_inode.i_ctime.tv_sec);\n\n\tstr->di_goal_meta = cpu_to_be64(ip->i_goal);\n\tstr->di_goal_data = cpu_to_be64(ip->i_goal);\n\tstr->di_generation = cpu_to_be64(ip->i_generation);\n\n\tstr->di_flags = cpu_to_be32(ip->i_diskflags);\n\tstr->di_height = cpu_to_be16(ip->i_height);\n\tstr->di_payload_format = cpu_to_be32(S_ISDIR(ip->i_inode.i_mode) &&\n\t\t\t\t\t     !(ip->i_diskflags & GFS2_DIF_EXHASH) ?\n\t\t\t\t\t     GFS2_FORMAT_DE : 0);\n\tstr->di_depth = cpu_to_be16(ip->i_depth);\n\tstr->di_entries = cpu_to_be32(ip->i_entries);\n\n\tstr->di_eattr = cpu_to_be64(ip->i_eattr);\n\tstr->di_atime_nsec = cpu_to_be32(ip->i_inode.i_atime.tv_nsec);\n\tstr->di_mtime_nsec = cpu_to_be32(ip->i_inode.i_mtime.tv_nsec);\n\tstr->di_ctime_nsec = cpu_to_be32(ip->i_inode.i_ctime.tv_nsec);\n}"
        }
      },
      {
        "call_info": {
          "callee": "gfs2_trans_add_meta",
          "args": [
            "ip->i_gl",
            "dibh"
          ],
          "line": 472
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_trans_add_meta",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/trans.c",
          "lines": "224-247",
          "snippet": "void gfs2_trans_add_meta(struct gfs2_glock *gl, struct buffer_head *bh)\n{\n\n\tstruct gfs2_sbd *sdp = gl->gl_sbd;\n\tstruct gfs2_bufdata *bd;\n\n\tlock_buffer(bh);\n\tgfs2_log_lock(sdp);\n\tbd = bh->b_private;\n\tif (bd == NULL) {\n\t\tgfs2_log_unlock(sdp);\n\t\tunlock_buffer(bh);\n\t\tlock_page(bh->b_page);\n\t\tif (bh->b_private == NULL)\n\t\t\tbd = gfs2_alloc_bufdata(gl, bh, &gfs2_buf_lops);\n\t\tunlock_page(bh->b_page);\n\t\tlock_buffer(bh);\n\t\tgfs2_log_lock(sdp);\n\t}\n\tgfs2_assert(sdp, bd->bd_gl == gl);\n\tmeta_lo_add(sdp, bd);\n\tgfs2_log_unlock(sdp);\n\tunlock_buffer(bh);\n}",
          "includes": [
            "#include \"trace_gfs2.h\"",
            "#include \"util.h\"",
            "#include \"trans.h\"",
            "#include \"meta_io.h\"",
            "#include \"lops.h\"",
            "#include \"log.h\"",
            "#include \"inode.h\"",
            "#include \"glock.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"util.h\"\n#include \"trans.h\"\n#include \"meta_io.h\"\n#include \"lops.h\"\n#include \"log.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/gfs2_ondisk.h>\n#include <linux/kallsyms.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nvoid gfs2_trans_add_meta(struct gfs2_glock *gl, struct buffer_head *bh)\n{\n\n\tstruct gfs2_sbd *sdp = gl->gl_sbd;\n\tstruct gfs2_bufdata *bd;\n\n\tlock_buffer(bh);\n\tgfs2_log_lock(sdp);\n\tbd = bh->b_private;\n\tif (bd == NULL) {\n\t\tgfs2_log_unlock(sdp);\n\t\tunlock_buffer(bh);\n\t\tlock_page(bh->b_page);\n\t\tif (bh->b_private == NULL)\n\t\t\tbd = gfs2_alloc_bufdata(gl, bh, &gfs2_buf_lops);\n\t\tunlock_page(bh->b_page);\n\t\tlock_buffer(bh);\n\t\tgfs2_log_lock(sdp);\n\t}\n\tgfs2_assert(sdp, bd->bd_gl == gl);\n\tmeta_lo_add(sdp, bd);\n\tgfs2_log_unlock(sdp);\n\tunlock_buffer(bh);\n}"
        }
      },
      {
        "call_info": {
          "callee": "gfs2_meta_new",
          "args": [
            "ip->i_gl",
            "ip->i_no_addr"
          ],
          "line": 471
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_meta_new",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/meta_io.c",
          "lines": "182-188",
          "snippet": "struct buffer_head *gfs2_meta_new(struct gfs2_glock *gl, u64 blkno)\n{\n\tstruct buffer_head *bh;\n\tbh = gfs2_getbuf(gl, blkno, CREATE);\n\tmeta_prep_new(bh);\n\treturn bh;\n}",
          "includes": [
            "#include \"trace_gfs2.h\"",
            "#include \"util.h\"",
            "#include \"trans.h\"",
            "#include \"rgrp.h\"",
            "#include \"meta_io.h\"",
            "#include \"lops.h\"",
            "#include \"log.h\"",
            "#include \"inode.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/bio.h>",
            "#include <linux/delay.h>",
            "#include <linux/swap.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"util.h\"\n#include \"trans.h\"\n#include \"rgrp.h\"\n#include \"meta_io.h\"\n#include \"lops.h\"\n#include \"log.h\"\n#include \"inode.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/gfs2_ondisk.h>\n#include <linux/bio.h>\n#include <linux/delay.h>\n#include <linux/swap.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstruct buffer_head *gfs2_meta_new(struct gfs2_glock *gl, u64 blkno)\n{\n\tstruct buffer_head *bh;\n\tbh = gfs2_getbuf(gl, blkno, CREATE);\n\tmeta_prep_new(bh);\n\treturn bh;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"glops.h\"\n#include \"super.h\"\n#include \"util.h\"\n#include \"trans.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"xattr.h\"\n#include \"dir.h\"\n#include \"bmap.h\"\n#include \"acl.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <asm/uaccess.h>\n#include <linux/security.h>\n#include <linux/fiemap.h>\n#include <linux/crc32.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/posix_acl.h>\n#include <linux/xattr.h>\n#include <linux/mm.h>\n#include <linux/namei.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nstatic void init_dinode(struct gfs2_inode *dip, struct gfs2_inode *ip,\n\t\t\tconst char *symname)\n{\n\tstruct gfs2_dinode *di;\n\tstruct buffer_head *dibh;\n\n\tdibh = gfs2_meta_new(ip->i_gl, ip->i_no_addr);\n\tgfs2_trans_add_meta(ip->i_gl, dibh);\n\tdi = (struct gfs2_dinode *)dibh->b_data;\n\tgfs2_dinode_out(ip, di);\n\n\tdi->di_major = cpu_to_be32(MAJOR(ip->i_inode.i_rdev));\n\tdi->di_minor = cpu_to_be32(MINOR(ip->i_inode.i_rdev));\n\tdi->__pad1 = 0;\n\tdi->__pad2 = 0;\n\tdi->__pad3 = 0;\n\tmemset(&di->__pad4, 0, sizeof(di->__pad4));\n\tmemset(&di->di_reserved, 0, sizeof(di->di_reserved));\n\tgfs2_buffer_clear_tail(dibh, sizeof(struct gfs2_dinode));\n\n\tswitch(ip->i_inode.i_mode & S_IFMT) {\n\tcase S_IFDIR:\n\t\tgfs2_init_dir(dibh, dip);\n\t\tbreak;\n\tcase S_IFLNK:\n\t\tmemcpy(dibh->b_data + sizeof(struct gfs2_dinode), symname, ip->i_inode.i_size);\n\t\tbreak;\n\t}\n\n\tset_buffer_uptodate(dibh);\n\tbrelse(dibh);\n}"
  },
  {
    "function_name": "gfs2_init_xattr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/inode.c",
    "lines": "437-454",
    "snippet": "static void gfs2_init_xattr(struct gfs2_inode *ip)\n{\n\tstruct gfs2_sbd *sdp = GFS2_SB(&ip->i_inode);\n\tstruct buffer_head *bh;\n\tstruct gfs2_ea_header *ea;\n\n\tbh = gfs2_meta_new(ip->i_gl, ip->i_eattr);\n\tgfs2_trans_add_meta(ip->i_gl, bh);\n\tgfs2_metatype_set(bh, GFS2_METATYPE_EA, GFS2_FORMAT_EA);\n\tgfs2_buffer_clear_tail(bh, sizeof(struct gfs2_meta_header));\n\n\tea = GFS2_EA_BH2FIRST(bh);\n\tea->ea_rec_len = cpu_to_be32(sdp->sd_jbsize);\n\tea->ea_type = GFS2_EATYPE_UNUSED;\n\tea->ea_flags = GFS2_EAFLAG_LAST;\n\n\tbrelse(bh);\n}",
    "includes": [
      "#include \"glops.h\"",
      "#include \"super.h\"",
      "#include \"util.h\"",
      "#include \"trans.h\"",
      "#include \"rgrp.h\"",
      "#include \"quota.h\"",
      "#include \"meta_io.h\"",
      "#include \"inode.h\"",
      "#include \"glock.h\"",
      "#include \"xattr.h\"",
      "#include \"dir.h\"",
      "#include \"bmap.h\"",
      "#include \"acl.h\"",
      "#include \"incore.h\"",
      "#include \"gfs2.h\"",
      "#include <asm/uaccess.h>",
      "#include <linux/security.h>",
      "#include <linux/fiemap.h>",
      "#include <linux/crc32.h>",
      "#include <linux/gfs2_ondisk.h>",
      "#include <linux/posix_acl.h>",
      "#include <linux/xattr.h>",
      "#include <linux/mm.h>",
      "#include <linux/namei.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/completion.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "brelse",
          "args": [
            "bh"
          ],
          "line": 453
        },
        "resolved": true,
        "details": {
          "function_name": "__brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1177-1184",
          "snippet": "void __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "sdp->sd_jbsize"
          ],
          "line": 449
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GFS2_EA_BH2FIRST",
          "args": [
            "bh"
          ],
          "line": 448
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gfs2_buffer_clear_tail",
          "args": [
            "bh",
            "sizeof(struct gfs2_meta_header)"
          ],
          "line": 446
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_buffer_clear_tail",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/meta_io.h",
          "lines": "22-26",
          "snippet": "static inline void gfs2_buffer_clear_tail(struct buffer_head *bh, int head)\n{\n\tBUG_ON(head > bh->b_size);\n\tmemset(bh->b_data + head, 0, bh->b_size - head);\n}",
          "includes": [
            "#include \"incore.h\"",
            "#include <linux/string.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"incore.h\"\n#include <linux/string.h>\n#include <linux/buffer_head.h>\n\nstatic inline void gfs2_buffer_clear_tail(struct buffer_head *bh, int head)\n{\n\tBUG_ON(head > bh->b_size);\n\tmemset(bh->b_data + head, 0, bh->b_size - head);\n}"
        }
      },
      {
        "call_info": {
          "callee": "gfs2_metatype_set",
          "args": [
            "bh",
            "GFS2_METATYPE_EA",
            "GFS2_FORMAT_EA"
          ],
          "line": 445
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_metatype_set",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/util.h",
          "lines": "122-129",
          "snippet": "static inline void gfs2_metatype_set(struct buffer_head *bh, u16 type,\n\t\t\t\t     u16 format)\n{\n\tstruct gfs2_meta_header *mh;\n\tmh = (struct gfs2_meta_header *)bh->b_data;\n\tmh->mh_type = cpu_to_be32(type);\n\tmh->mh_format = cpu_to_be32(format);\n}",
          "includes": [
            "#include \"incore.h\"",
            "#include <linux/mempool.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"incore.h\"\n#include <linux/mempool.h>\n\nstatic inline void gfs2_metatype_set(struct buffer_head *bh, u16 type,\n\t\t\t\t     u16 format)\n{\n\tstruct gfs2_meta_header *mh;\n\tmh = (struct gfs2_meta_header *)bh->b_data;\n\tmh->mh_type = cpu_to_be32(type);\n\tmh->mh_format = cpu_to_be32(format);\n}"
        }
      },
      {
        "call_info": {
          "callee": "gfs2_trans_add_meta",
          "args": [
            "ip->i_gl",
            "bh"
          ],
          "line": 444
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_trans_add_meta",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/trans.c",
          "lines": "224-247",
          "snippet": "void gfs2_trans_add_meta(struct gfs2_glock *gl, struct buffer_head *bh)\n{\n\n\tstruct gfs2_sbd *sdp = gl->gl_sbd;\n\tstruct gfs2_bufdata *bd;\n\n\tlock_buffer(bh);\n\tgfs2_log_lock(sdp);\n\tbd = bh->b_private;\n\tif (bd == NULL) {\n\t\tgfs2_log_unlock(sdp);\n\t\tunlock_buffer(bh);\n\t\tlock_page(bh->b_page);\n\t\tif (bh->b_private == NULL)\n\t\t\tbd = gfs2_alloc_bufdata(gl, bh, &gfs2_buf_lops);\n\t\tunlock_page(bh->b_page);\n\t\tlock_buffer(bh);\n\t\tgfs2_log_lock(sdp);\n\t}\n\tgfs2_assert(sdp, bd->bd_gl == gl);\n\tmeta_lo_add(sdp, bd);\n\tgfs2_log_unlock(sdp);\n\tunlock_buffer(bh);\n}",
          "includes": [
            "#include \"trace_gfs2.h\"",
            "#include \"util.h\"",
            "#include \"trans.h\"",
            "#include \"meta_io.h\"",
            "#include \"lops.h\"",
            "#include \"log.h\"",
            "#include \"inode.h\"",
            "#include \"glock.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"util.h\"\n#include \"trans.h\"\n#include \"meta_io.h\"\n#include \"lops.h\"\n#include \"log.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/gfs2_ondisk.h>\n#include <linux/kallsyms.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nvoid gfs2_trans_add_meta(struct gfs2_glock *gl, struct buffer_head *bh)\n{\n\n\tstruct gfs2_sbd *sdp = gl->gl_sbd;\n\tstruct gfs2_bufdata *bd;\n\n\tlock_buffer(bh);\n\tgfs2_log_lock(sdp);\n\tbd = bh->b_private;\n\tif (bd == NULL) {\n\t\tgfs2_log_unlock(sdp);\n\t\tunlock_buffer(bh);\n\t\tlock_page(bh->b_page);\n\t\tif (bh->b_private == NULL)\n\t\t\tbd = gfs2_alloc_bufdata(gl, bh, &gfs2_buf_lops);\n\t\tunlock_page(bh->b_page);\n\t\tlock_buffer(bh);\n\t\tgfs2_log_lock(sdp);\n\t}\n\tgfs2_assert(sdp, bd->bd_gl == gl);\n\tmeta_lo_add(sdp, bd);\n\tgfs2_log_unlock(sdp);\n\tunlock_buffer(bh);\n}"
        }
      },
      {
        "call_info": {
          "callee": "gfs2_meta_new",
          "args": [
            "ip->i_gl",
            "ip->i_eattr"
          ],
          "line": 443
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_meta_new",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/meta_io.c",
          "lines": "182-188",
          "snippet": "struct buffer_head *gfs2_meta_new(struct gfs2_glock *gl, u64 blkno)\n{\n\tstruct buffer_head *bh;\n\tbh = gfs2_getbuf(gl, blkno, CREATE);\n\tmeta_prep_new(bh);\n\treturn bh;\n}",
          "includes": [
            "#include \"trace_gfs2.h\"",
            "#include \"util.h\"",
            "#include \"trans.h\"",
            "#include \"rgrp.h\"",
            "#include \"meta_io.h\"",
            "#include \"lops.h\"",
            "#include \"log.h\"",
            "#include \"inode.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/bio.h>",
            "#include <linux/delay.h>",
            "#include <linux/swap.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"util.h\"\n#include \"trans.h\"\n#include \"rgrp.h\"\n#include \"meta_io.h\"\n#include \"lops.h\"\n#include \"log.h\"\n#include \"inode.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/gfs2_ondisk.h>\n#include <linux/bio.h>\n#include <linux/delay.h>\n#include <linux/swap.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstruct buffer_head *gfs2_meta_new(struct gfs2_glock *gl, u64 blkno)\n{\n\tstruct buffer_head *bh;\n\tbh = gfs2_getbuf(gl, blkno, CREATE);\n\tmeta_prep_new(bh);\n\treturn bh;\n}"
        }
      },
      {
        "call_info": {
          "callee": "GFS2_SB",
          "args": [
            "&ip->i_inode"
          ],
          "line": 439
        },
        "resolved": true,
        "details": {
          "function_name": "GFS2_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/incore.h",
          "lines": "413-416",
          "snippet": "static inline struct gfs2_sbd *GFS2_SB(const struct inode *inode)\n{\n\treturn inode->i_sb->s_fs_info;\n}",
          "includes": [
            "#include <linux/lockref.h>",
            "#include <linux/percpu.h>",
            "#include <linux/ktime.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/completion.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/dlm.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/kobject.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/lockref.h>\n#include <linux/percpu.h>\n#include <linux/ktime.h>\n#include <linux/rbtree.h>\n#include <linux/completion.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/buffer_head.h>\n#include <linux/dlm.h>\n#include <linux/workqueue.h>\n#include <linux/kobject.h>\n#include <linux/fs.h>\n\nstatic inline struct gfs2_sbd *GFS2_SB(const struct inode *inode)\n{\n\treturn inode->i_sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"glops.h\"\n#include \"super.h\"\n#include \"util.h\"\n#include \"trans.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"xattr.h\"\n#include \"dir.h\"\n#include \"bmap.h\"\n#include \"acl.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <asm/uaccess.h>\n#include <linux/security.h>\n#include <linux/fiemap.h>\n#include <linux/crc32.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/posix_acl.h>\n#include <linux/xattr.h>\n#include <linux/mm.h>\n#include <linux/namei.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nstatic void gfs2_init_xattr(struct gfs2_inode *ip)\n{\n\tstruct gfs2_sbd *sdp = GFS2_SB(&ip->i_inode);\n\tstruct buffer_head *bh;\n\tstruct gfs2_ea_header *ea;\n\n\tbh = gfs2_meta_new(ip->i_gl, ip->i_eattr);\n\tgfs2_trans_add_meta(ip->i_gl, bh);\n\tgfs2_metatype_set(bh, GFS2_METATYPE_EA, GFS2_FORMAT_EA);\n\tgfs2_buffer_clear_tail(bh, sizeof(struct gfs2_meta_header));\n\n\tea = GFS2_EA_BH2FIRST(bh);\n\tea->ea_rec_len = cpu_to_be32(sdp->sd_jbsize);\n\tea->ea_type = GFS2_EATYPE_UNUSED;\n\tea->ea_flags = GFS2_EAFLAG_LAST;\n\n\tbrelse(bh);\n}"
  },
  {
    "function_name": "gfs2_init_dir",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/inode.c",
    "lines": "412-427",
    "snippet": "static void gfs2_init_dir(struct buffer_head *dibh,\n\t\t\t  const struct gfs2_inode *parent)\n{\n\tstruct gfs2_dinode *di = (struct gfs2_dinode *)dibh->b_data;\n\tstruct gfs2_dirent *dent = (struct gfs2_dirent *)(di+1);\n\n\tgfs2_qstr2dirent(&gfs2_qdot, GFS2_DIRENT_SIZE(gfs2_qdot.len), dent);\n\tdent->de_inum = di->di_num; /* already GFS2 endian */\n\tdent->de_type = cpu_to_be16(DT_DIR);\n\n\tdent = (struct gfs2_dirent *)((char*)dent + GFS2_DIRENT_SIZE(1));\n\tgfs2_qstr2dirent(&gfs2_qdotdot, dibh->b_size - GFS2_DIRENT_SIZE(1) - sizeof(struct gfs2_dinode), dent);\n\tgfs2_inum_out(parent, dent);\n\tdent->de_type = cpu_to_be16(DT_DIR);\n\t\n}",
    "includes": [
      "#include \"glops.h\"",
      "#include \"super.h\"",
      "#include \"util.h\"",
      "#include \"trans.h\"",
      "#include \"rgrp.h\"",
      "#include \"quota.h\"",
      "#include \"meta_io.h\"",
      "#include \"inode.h\"",
      "#include \"glock.h\"",
      "#include \"xattr.h\"",
      "#include \"dir.h\"",
      "#include \"bmap.h\"",
      "#include \"acl.h\"",
      "#include \"incore.h\"",
      "#include \"gfs2.h\"",
      "#include <asm/uaccess.h>",
      "#include <linux/security.h>",
      "#include <linux/fiemap.h>",
      "#include <linux/crc32.h>",
      "#include <linux/gfs2_ondisk.h>",
      "#include <linux/posix_acl.h>",
      "#include <linux/xattr.h>",
      "#include <linux/mm.h>",
      "#include <linux/namei.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/completion.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cpu_to_be16",
          "args": [
            "DT_DIR"
          ],
          "line": 425
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gfs2_inum_out",
          "args": [
            "parent",
            "dent"
          ],
          "line": 424
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_inum_out",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/inode.h",
          "lines": "75-80",
          "snippet": "static inline void gfs2_inum_out(const struct gfs2_inode *ip,\n\t\t\t\t struct gfs2_dirent *dent)\n{\n\tdent->de_inum.no_formal_ino = cpu_to_be64(ip->i_no_formal_ino);\n\tdent->de_inum.no_addr = cpu_to_be64(ip->i_no_addr);\n}",
          "includes": [
            "#include \"util.h\"",
            "#include <linux/mm.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include <linux/mm.h>\n#include <linux/buffer_head.h>\n#include <linux/fs.h>\n\nstatic inline void gfs2_inum_out(const struct gfs2_inode *ip,\n\t\t\t\t struct gfs2_dirent *dent)\n{\n\tdent->de_inum.no_formal_ino = cpu_to_be64(ip->i_no_formal_ino);\n\tdent->de_inum.no_addr = cpu_to_be64(ip->i_no_addr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "gfs2_qstr2dirent",
          "args": [
            "&gfs2_qdotdot",
            "dibh->b_size - GFS2_DIRENT_SIZE(1) - sizeof(struct gfs2_dinode)",
            "dent"
          ],
          "line": 423
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_qstr2dirent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/dir.h",
          "lines": "71-81",
          "snippet": "static inline void gfs2_qstr2dirent(const struct qstr *name, u16 reclen, struct gfs2_dirent *dent)\n{\n\tdent->de_inum.no_addr = cpu_to_be64(0);\n\tdent->de_inum.no_formal_ino = cpu_to_be64(0);\n\tdent->de_hash = cpu_to_be32(name->hash);\n\tdent->de_rec_len = cpu_to_be16(reclen);\n\tdent->de_name_len = cpu_to_be16(name->len);\n\tdent->de_type = cpu_to_be16(0);\n\tmemset(dent->__pad, 0, sizeof(dent->__pad));\n\tmemcpy(dent + 1, name->name, name->len);\n}",
          "includes": [
            "#include <linux/crc32.h>",
            "#include <linux/dcache.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/crc32.h>\n#include <linux/dcache.h>\n\nstatic inline void gfs2_qstr2dirent(const struct qstr *name, u16 reclen, struct gfs2_dirent *dent)\n{\n\tdent->de_inum.no_addr = cpu_to_be64(0);\n\tdent->de_inum.no_formal_ino = cpu_to_be64(0);\n\tdent->de_hash = cpu_to_be32(name->hash);\n\tdent->de_rec_len = cpu_to_be16(reclen);\n\tdent->de_name_len = cpu_to_be16(name->len);\n\tdent->de_type = cpu_to_be16(0);\n\tmemset(dent->__pad, 0, sizeof(dent->__pad));\n\tmemcpy(dent + 1, name->name, name->len);\n}"
        }
      },
      {
        "call_info": {
          "callee": "GFS2_DIRENT_SIZE",
          "args": [
            "1"
          ],
          "line": 423
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GFS2_DIRENT_SIZE",
          "args": [
            "1"
          ],
          "line": 422
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be16",
          "args": [
            "DT_DIR"
          ],
          "line": 420
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GFS2_DIRENT_SIZE",
          "args": [
            "gfs2_qdot.len"
          ],
          "line": 418
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"glops.h\"\n#include \"super.h\"\n#include \"util.h\"\n#include \"trans.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"xattr.h\"\n#include \"dir.h\"\n#include \"bmap.h\"\n#include \"acl.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <asm/uaccess.h>\n#include <linux/security.h>\n#include <linux/fiemap.h>\n#include <linux/crc32.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/posix_acl.h>\n#include <linux/xattr.h>\n#include <linux/mm.h>\n#include <linux/namei.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nstatic void gfs2_init_dir(struct buffer_head *dibh,\n\t\t\t  const struct gfs2_inode *parent)\n{\n\tstruct gfs2_dinode *di = (struct gfs2_dinode *)dibh->b_data;\n\tstruct gfs2_dirent *dent = (struct gfs2_dirent *)(di+1);\n\n\tgfs2_qstr2dirent(&gfs2_qdot, GFS2_DIRENT_SIZE(gfs2_qdot.len), dent);\n\tdent->de_inum = di->di_num; /* already GFS2 endian */\n\tdent->de_type = cpu_to_be16(DT_DIR);\n\n\tdent = (struct gfs2_dirent *)((char*)dent + GFS2_DIRENT_SIZE(1));\n\tgfs2_qstr2dirent(&gfs2_qdotdot, dibh->b_size - GFS2_DIRENT_SIZE(1) - sizeof(struct gfs2_dinode), dent);\n\tgfs2_inum_out(parent, dent);\n\tdent->de_type = cpu_to_be16(DT_DIR);\n\t\n}"
  },
  {
    "function_name": "alloc_dinode",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/inode.c",
    "lines": "379-410",
    "snippet": "static int alloc_dinode(struct gfs2_inode *ip, u32 flags, unsigned *dblocks)\n{\n\tstruct gfs2_sbd *sdp = GFS2_SB(&ip->i_inode);\n\tstruct gfs2_alloc_parms ap = { .target = *dblocks, .aflags = flags, };\n\tint error;\n\n\terror = gfs2_quota_lock_check(ip);\n\tif (error)\n\t\tgoto out;\n\n\terror = gfs2_inplace_reserve(ip, &ap);\n\tif (error)\n\t\tgoto out_quota;\n\n\terror = gfs2_trans_begin(sdp, (*dblocks * RES_RG_BIT) + RES_STATFS + RES_QUOTA, 0);\n\tif (error)\n\t\tgoto out_ipreserv;\n\n\terror = gfs2_alloc_blocks(ip, &ip->i_no_addr, dblocks, 1, &ip->i_generation);\n\tip->i_no_formal_ino = ip->i_generation;\n\tip->i_inode.i_ino = ip->i_no_addr;\n\tip->i_goal = ip->i_no_addr;\n\n\tgfs2_trans_end(sdp);\n\nout_ipreserv:\n\tgfs2_inplace_release(ip);\nout_quota:\n\tgfs2_quota_unlock(ip);\nout:\n\treturn error;\n}",
    "includes": [
      "#include \"glops.h\"",
      "#include \"super.h\"",
      "#include \"util.h\"",
      "#include \"trans.h\"",
      "#include \"rgrp.h\"",
      "#include \"quota.h\"",
      "#include \"meta_io.h\"",
      "#include \"inode.h\"",
      "#include \"glock.h\"",
      "#include \"xattr.h\"",
      "#include \"dir.h\"",
      "#include \"bmap.h\"",
      "#include \"acl.h\"",
      "#include \"incore.h\"",
      "#include \"gfs2.h\"",
      "#include <asm/uaccess.h>",
      "#include <linux/security.h>",
      "#include <linux/fiemap.h>",
      "#include <linux/crc32.h>",
      "#include <linux/gfs2_ondisk.h>",
      "#include <linux/posix_acl.h>",
      "#include <linux/xattr.h>",
      "#include <linux/mm.h>",
      "#include <linux/namei.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/completion.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "gfs2_quota_unlock",
          "args": [
            "ip"
          ],
          "line": 407
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_quota_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/quota.c",
          "lines": "1033-1081",
          "snippet": "void gfs2_quota_unlock(struct gfs2_inode *ip)\n{\n\tstruct gfs2_sbd *sdp = GFS2_SB(&ip->i_inode);\n\tstruct gfs2_quota_data *qda[4];\n\tunsigned int count = 0;\n\tunsigned int x;\n\tint found;\n\n\tif (!test_and_clear_bit(GIF_QD_LOCKED, &ip->i_flags))\n\t\tgoto out;\n\n\tfor (x = 0; x < ip->i_res->rs_qa_qd_num; x++) {\n\t\tstruct gfs2_quota_data *qd;\n\t\tint sync;\n\n\t\tqd = ip->i_res->rs_qa_qd[x];\n\t\tsync = need_sync(qd);\n\n\t\tgfs2_glock_dq_uninit(&ip->i_res->rs_qa_qd_ghs[x]);\n\t\tif (!sync)\n\t\t\tcontinue;\n\n\t\tspin_lock(&qd_lock);\n\t\tfound = qd_check_sync(sdp, qd, NULL);\n\t\tspin_unlock(&qd_lock);\n\n\t\tif (!found)\n\t\t\tcontinue;\n\n\t\tgfs2_assert_warn(sdp, qd->qd_change_sync);\n\t\tif (bh_get(qd)) {\n\t\t\tclear_bit(QDF_LOCKED, &qd->qd_flags);\n\t\t\tslot_put(qd);\n\t\t\tqd_put(qd);\n\t\t\tcontinue;\n\t\t}\n\n\t\tqda[count++] = qd;\n\t}\n\n\tif (count) {\n\t\tdo_sync(count, qda);\n\t\tfor (x = 0; x < count; x++)\n\t\t\tqd_unlock(qda[x]);\n\t}\n\nout:\n\tgfs2_quota_unhold(ip);\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"inode.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"log.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"bmap.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/jhash.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/lockref.h>",
            "#include <linux/dqblk_xfs.h>",
            "#include <linux/quota.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/bio.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_SPINLOCK(qd_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"inode.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"log.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/vmalloc.h>\n#include <linux/jhash.h>\n#include <linux/bit_spinlock.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/list_lru.h>\n#include <linux/lockref.h>\n#include <linux/dqblk_xfs.h>\n#include <linux/quota.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/bio.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic DEFINE_SPINLOCK(qd_lock);\n\nvoid gfs2_quota_unlock(struct gfs2_inode *ip)\n{\n\tstruct gfs2_sbd *sdp = GFS2_SB(&ip->i_inode);\n\tstruct gfs2_quota_data *qda[4];\n\tunsigned int count = 0;\n\tunsigned int x;\n\tint found;\n\n\tif (!test_and_clear_bit(GIF_QD_LOCKED, &ip->i_flags))\n\t\tgoto out;\n\n\tfor (x = 0; x < ip->i_res->rs_qa_qd_num; x++) {\n\t\tstruct gfs2_quota_data *qd;\n\t\tint sync;\n\n\t\tqd = ip->i_res->rs_qa_qd[x];\n\t\tsync = need_sync(qd);\n\n\t\tgfs2_glock_dq_uninit(&ip->i_res->rs_qa_qd_ghs[x]);\n\t\tif (!sync)\n\t\t\tcontinue;\n\n\t\tspin_lock(&qd_lock);\n\t\tfound = qd_check_sync(sdp, qd, NULL);\n\t\tspin_unlock(&qd_lock);\n\n\t\tif (!found)\n\t\t\tcontinue;\n\n\t\tgfs2_assert_warn(sdp, qd->qd_change_sync);\n\t\tif (bh_get(qd)) {\n\t\t\tclear_bit(QDF_LOCKED, &qd->qd_flags);\n\t\t\tslot_put(qd);\n\t\t\tqd_put(qd);\n\t\t\tcontinue;\n\t\t}\n\n\t\tqda[count++] = qd;\n\t}\n\n\tif (count) {\n\t\tdo_sync(count, qda);\n\t\tfor (x = 0; x < count; x++)\n\t\t\tqd_unlock(qda[x]);\n\t}\n\nout:\n\tgfs2_quota_unhold(ip);\n}"
        }
      },
      {
        "call_info": {
          "callee": "gfs2_inplace_release",
          "args": [
            "ip"
          ],
          "line": 405
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_inplace_release",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/rgrp.c",
          "lines": "2081-2087",
          "snippet": "void gfs2_inplace_release(struct gfs2_inode *ip)\n{\n\tstruct gfs2_blkreserv *rs = ip->i_res;\n\n\tif (rs->rs_rgd_gh.gh_gl)\n\t\tgfs2_glock_dq_uninit(&rs->rs_rgd_gh);\n}",
          "includes": [
            "#include \"trace_gfs2.h\"",
            "#include \"inode.h\"",
            "#include \"log.h\"",
            "#include \"util.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"lops.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/random.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/fs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"inode.h\"\n#include \"log.h\"\n#include \"util.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"lops.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/random.h>\n#include <linux/rbtree.h>\n#include <linux/blkdev.h>\n#include <linux/prefetch.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/fs.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nvoid gfs2_inplace_release(struct gfs2_inode *ip)\n{\n\tstruct gfs2_blkreserv *rs = ip->i_res;\n\n\tif (rs->rs_rgd_gh.gh_gl)\n\t\tgfs2_glock_dq_uninit(&rs->rs_rgd_gh);\n}"
        }
      },
      {
        "call_info": {
          "callee": "gfs2_trans_end",
          "args": [
            "sdp"
          ],
          "line": 402
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_trans_end",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/trans.c",
          "lines": "88-123",
          "snippet": "void gfs2_trans_end(struct gfs2_sbd *sdp)\n{\n\tstruct gfs2_trans *tr = current->journal_info;\n\ts64 nbuf;\n\tint alloced = tr->tr_alloced;\n\n\tBUG_ON(!tr);\n\tcurrent->journal_info = NULL;\n\n\tif (!tr->tr_touched) {\n\t\tgfs2_log_release(sdp, tr->tr_reserved);\n\t\tif (alloced) {\n\t\t\tkfree(tr);\n\t\t\tsb_end_intwrite(sdp->sd_vfs);\n\t\t}\n\t\treturn;\n\t}\n\n\tnbuf = tr->tr_num_buf_new + tr->tr_num_databuf_new;\n\tnbuf -= tr->tr_num_buf_rm;\n\tnbuf -= tr->tr_num_databuf_rm;\n\n\tif (gfs2_assert_withdraw(sdp, (nbuf <= tr->tr_blocks) &&\n\t\t\t\t       (tr->tr_num_revoke <= tr->tr_revokes)))\n\t\tgfs2_print_trans(tr);\n\n\tgfs2_log_commit(sdp, tr);\n\tif (alloced && !tr->tr_attached)\n\t\t\tkfree(tr);\n\tup_read(&sdp->sd_log_flush_lock);\n\n\tif (sdp->sd_vfs->s_flags & MS_SYNCHRONOUS)\n\t\tgfs2_log_flush(sdp, NULL, NORMAL_FLUSH);\n\tif (alloced)\n\t\tsb_end_intwrite(sdp->sd_vfs);\n}",
          "includes": [
            "#include \"trace_gfs2.h\"",
            "#include \"util.h\"",
            "#include \"trans.h\"",
            "#include \"meta_io.h\"",
            "#include \"lops.h\"",
            "#include \"log.h\"",
            "#include \"inode.h\"",
            "#include \"glock.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"util.h\"\n#include \"trans.h\"\n#include \"meta_io.h\"\n#include \"lops.h\"\n#include \"log.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/gfs2_ondisk.h>\n#include <linux/kallsyms.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nvoid gfs2_trans_end(struct gfs2_sbd *sdp)\n{\n\tstruct gfs2_trans *tr = current->journal_info;\n\ts64 nbuf;\n\tint alloced = tr->tr_alloced;\n\n\tBUG_ON(!tr);\n\tcurrent->journal_info = NULL;\n\n\tif (!tr->tr_touched) {\n\t\tgfs2_log_release(sdp, tr->tr_reserved);\n\t\tif (alloced) {\n\t\t\tkfree(tr);\n\t\t\tsb_end_intwrite(sdp->sd_vfs);\n\t\t}\n\t\treturn;\n\t}\n\n\tnbuf = tr->tr_num_buf_new + tr->tr_num_databuf_new;\n\tnbuf -= tr->tr_num_buf_rm;\n\tnbuf -= tr->tr_num_databuf_rm;\n\n\tif (gfs2_assert_withdraw(sdp, (nbuf <= tr->tr_blocks) &&\n\t\t\t\t       (tr->tr_num_revoke <= tr->tr_revokes)))\n\t\tgfs2_print_trans(tr);\n\n\tgfs2_log_commit(sdp, tr);\n\tif (alloced && !tr->tr_attached)\n\t\t\tkfree(tr);\n\tup_read(&sdp->sd_log_flush_lock);\n\n\tif (sdp->sd_vfs->s_flags & MS_SYNCHRONOUS)\n\t\tgfs2_log_flush(sdp, NULL, NORMAL_FLUSH);\n\tif (alloced)\n\t\tsb_end_intwrite(sdp->sd_vfs);\n}"
        }
      },
      {
        "call_info": {
          "callee": "gfs2_alloc_blocks",
          "args": [
            "ip",
            "&ip->i_no_addr",
            "dblocks",
            "1",
            "&ip->i_generation"
          ],
          "line": 397
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_alloc_blocks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/rgrp.c",
          "lines": "2304-2385",
          "snippet": "int gfs2_alloc_blocks(struct gfs2_inode *ip, u64 *bn, unsigned int *nblocks,\n\t\t      bool dinode, u64 *generation)\n{\n\tstruct gfs2_sbd *sdp = GFS2_SB(&ip->i_inode);\n\tstruct buffer_head *dibh;\n\tstruct gfs2_rbm rbm = { .rgd = ip->i_rgd, };\n\tunsigned int ndata;\n\tu64 block; /* block, within the file system scope */\n\tint error;\n\n\tgfs2_set_alloc_start(&rbm, ip, dinode);\n\terror = gfs2_rbm_find(&rbm, GFS2_BLKST_FREE, NULL, ip, false, NULL);\n\n\tif (error == -ENOSPC) {\n\t\tgfs2_set_alloc_start(&rbm, ip, dinode);\n\t\terror = gfs2_rbm_find(&rbm, GFS2_BLKST_FREE, NULL, NULL, false,\n\t\t\t\t      NULL);\n\t}\n\n\t/* Since all blocks are reserved in advance, this shouldn't happen */\n\tif (error) {\n\t\tfs_warn(sdp, \"inum=%llu error=%d, nblocks=%u, full=%d fail_pt=%d\\n\",\n\t\t\t(unsigned long long)ip->i_no_addr, error, *nblocks,\n\t\t\ttest_bit(GBF_FULL, &rbm.rgd->rd_bits->bi_flags),\n\t\t\trbm.rgd->rd_extfail_pt);\n\t\tgoto rgrp_error;\n\t}\n\n\tgfs2_alloc_extent(&rbm, dinode, nblocks);\n\tblock = gfs2_rbm_to_block(&rbm);\n\trbm.rgd->rd_last_alloc = block - rbm.rgd->rd_data0;\n\tif (gfs2_rs_active(ip->i_res))\n\t\tgfs2_adjust_reservation(ip, &rbm, *nblocks);\n\tndata = *nblocks;\n\tif (dinode)\n\t\tndata--;\n\n\tif (!dinode) {\n\t\tip->i_goal = block + ndata - 1;\n\t\terror = gfs2_meta_inode_buffer(ip, &dibh);\n\t\tif (error == 0) {\n\t\t\tstruct gfs2_dinode *di =\n\t\t\t\t(struct gfs2_dinode *)dibh->b_data;\n\t\t\tgfs2_trans_add_meta(ip->i_gl, dibh);\n\t\t\tdi->di_goal_meta = di->di_goal_data =\n\t\t\t\tcpu_to_be64(ip->i_goal);\n\t\t\tbrelse(dibh);\n\t\t}\n\t}\n\tif (rbm.rgd->rd_free < *nblocks) {\n\t\tpr_warn(\"nblocks=%u\\n\", *nblocks);\n\t\tgoto rgrp_error;\n\t}\n\n\trbm.rgd->rd_free -= *nblocks;\n\tif (dinode) {\n\t\trbm.rgd->rd_dinodes++;\n\t\t*generation = rbm.rgd->rd_igeneration++;\n\t\tif (*generation == 0)\n\t\t\t*generation = rbm.rgd->rd_igeneration++;\n\t}\n\n\tgfs2_trans_add_meta(rbm.rgd->rd_gl, rbm.rgd->rd_bits[0].bi_bh);\n\tgfs2_rgrp_out(rbm.rgd, rbm.rgd->rd_bits[0].bi_bh->b_data);\n\tgfs2_rgrp_ondisk2lvb(rbm.rgd->rd_rgl, rbm.rgd->rd_bits[0].bi_bh->b_data);\n\n\tgfs2_statfs_change(sdp, 0, -(s64)*nblocks, dinode ? 1 : 0);\n\tif (dinode)\n\t\tgfs2_trans_add_unrevoke(sdp, block, *nblocks);\n\n\tgfs2_quota_change(ip, *nblocks, ip->i_inode.i_uid, ip->i_inode.i_gid);\n\n\trbm.rgd->rd_free_clone -= *nblocks;\n\ttrace_gfs2_block_alloc(ip, rbm.rgd, block, *nblocks,\n\t\t\t       dinode ? GFS2_BLKST_DINODE : GFS2_BLKST_USED);\n\t*bn = block;\n\treturn 0;\n\nrgrp_error:\n\tgfs2_rgrp_error(rbm.rgd);\n\treturn -EIO;\n}",
          "includes": [
            "#include \"trace_gfs2.h\"",
            "#include \"inode.h\"",
            "#include \"log.h\"",
            "#include \"util.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"lops.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/random.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/fs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"inode.h\"\n#include \"log.h\"\n#include \"util.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"lops.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/random.h>\n#include <linux/rbtree.h>\n#include <linux/blkdev.h>\n#include <linux/prefetch.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/fs.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nint gfs2_alloc_blocks(struct gfs2_inode *ip, u64 *bn, unsigned int *nblocks,\n\t\t      bool dinode, u64 *generation)\n{\n\tstruct gfs2_sbd *sdp = GFS2_SB(&ip->i_inode);\n\tstruct buffer_head *dibh;\n\tstruct gfs2_rbm rbm = { .rgd = ip->i_rgd, };\n\tunsigned int ndata;\n\tu64 block; /* block, within the file system scope */\n\tint error;\n\n\tgfs2_set_alloc_start(&rbm, ip, dinode);\n\terror = gfs2_rbm_find(&rbm, GFS2_BLKST_FREE, NULL, ip, false, NULL);\n\n\tif (error == -ENOSPC) {\n\t\tgfs2_set_alloc_start(&rbm, ip, dinode);\n\t\terror = gfs2_rbm_find(&rbm, GFS2_BLKST_FREE, NULL, NULL, false,\n\t\t\t\t      NULL);\n\t}\n\n\t/* Since all blocks are reserved in advance, this shouldn't happen */\n\tif (error) {\n\t\tfs_warn(sdp, \"inum=%llu error=%d, nblocks=%u, full=%d fail_pt=%d\\n\",\n\t\t\t(unsigned long long)ip->i_no_addr, error, *nblocks,\n\t\t\ttest_bit(GBF_FULL, &rbm.rgd->rd_bits->bi_flags),\n\t\t\trbm.rgd->rd_extfail_pt);\n\t\tgoto rgrp_error;\n\t}\n\n\tgfs2_alloc_extent(&rbm, dinode, nblocks);\n\tblock = gfs2_rbm_to_block(&rbm);\n\trbm.rgd->rd_last_alloc = block - rbm.rgd->rd_data0;\n\tif (gfs2_rs_active(ip->i_res))\n\t\tgfs2_adjust_reservation(ip, &rbm, *nblocks);\n\tndata = *nblocks;\n\tif (dinode)\n\t\tndata--;\n\n\tif (!dinode) {\n\t\tip->i_goal = block + ndata - 1;\n\t\terror = gfs2_meta_inode_buffer(ip, &dibh);\n\t\tif (error == 0) {\n\t\t\tstruct gfs2_dinode *di =\n\t\t\t\t(struct gfs2_dinode *)dibh->b_data;\n\t\t\tgfs2_trans_add_meta(ip->i_gl, dibh);\n\t\t\tdi->di_goal_meta = di->di_goal_data =\n\t\t\t\tcpu_to_be64(ip->i_goal);\n\t\t\tbrelse(dibh);\n\t\t}\n\t}\n\tif (rbm.rgd->rd_free < *nblocks) {\n\t\tpr_warn(\"nblocks=%u\\n\", *nblocks);\n\t\tgoto rgrp_error;\n\t}\n\n\trbm.rgd->rd_free -= *nblocks;\n\tif (dinode) {\n\t\trbm.rgd->rd_dinodes++;\n\t\t*generation = rbm.rgd->rd_igeneration++;\n\t\tif (*generation == 0)\n\t\t\t*generation = rbm.rgd->rd_igeneration++;\n\t}\n\n\tgfs2_trans_add_meta(rbm.rgd->rd_gl, rbm.rgd->rd_bits[0].bi_bh);\n\tgfs2_rgrp_out(rbm.rgd, rbm.rgd->rd_bits[0].bi_bh->b_data);\n\tgfs2_rgrp_ondisk2lvb(rbm.rgd->rd_rgl, rbm.rgd->rd_bits[0].bi_bh->b_data);\n\n\tgfs2_statfs_change(sdp, 0, -(s64)*nblocks, dinode ? 1 : 0);\n\tif (dinode)\n\t\tgfs2_trans_add_unrevoke(sdp, block, *nblocks);\n\n\tgfs2_quota_change(ip, *nblocks, ip->i_inode.i_uid, ip->i_inode.i_gid);\n\n\trbm.rgd->rd_free_clone -= *nblocks;\n\ttrace_gfs2_block_alloc(ip, rbm.rgd, block, *nblocks,\n\t\t\t       dinode ? GFS2_BLKST_DINODE : GFS2_BLKST_USED);\n\t*bn = block;\n\treturn 0;\n\nrgrp_error:\n\tgfs2_rgrp_error(rbm.rgd);\n\treturn -EIO;\n}"
        }
      },
      {
        "call_info": {
          "callee": "gfs2_trans_begin",
          "args": [
            "sdp",
            "(*dblocks * RES_RG_BIT) + RES_STATFS + RES_QUOTA",
            "0"
          ],
          "line": 393
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_trans_begin",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/trans.c",
          "lines": "31-75",
          "snippet": "int gfs2_trans_begin(struct gfs2_sbd *sdp, unsigned int blocks,\n\t\t     unsigned int revokes)\n{\n\tstruct gfs2_trans *tr;\n\tint error;\n\n\tBUG_ON(current->journal_info);\n\tBUG_ON(blocks == 0 && revokes == 0);\n\n\tif (!test_bit(SDF_JOURNAL_LIVE, &sdp->sd_flags))\n\t\treturn -EROFS;\n\n\ttr = kzalloc(sizeof(struct gfs2_trans), GFP_NOFS);\n\tif (!tr)\n\t\treturn -ENOMEM;\n\n\ttr->tr_ip = _RET_IP_;\n\ttr->tr_blocks = blocks;\n\ttr->tr_revokes = revokes;\n\ttr->tr_reserved = 1;\n\ttr->tr_alloced = 1;\n\tif (blocks)\n\t\ttr->tr_reserved += 6 + blocks;\n\tif (revokes)\n\t\ttr->tr_reserved += gfs2_struct2blk(sdp, revokes,\n\t\t\t\t\t\t   sizeof(u64));\n\tINIT_LIST_HEAD(&tr->tr_databuf);\n\tINIT_LIST_HEAD(&tr->tr_buf);\n\n\tsb_start_intwrite(sdp->sd_vfs);\n\n\terror = gfs2_log_reserve(sdp, tr->tr_reserved);\n\tif (error)\n\t\tgoto fail;\n\n\tcurrent->journal_info = tr;\n\n\treturn 0;\n\nfail:\n\tsb_end_intwrite(sdp->sd_vfs);\n\tkfree(tr);\n\n\treturn error;\n}",
          "includes": [
            "#include \"trace_gfs2.h\"",
            "#include \"util.h\"",
            "#include \"trans.h\"",
            "#include \"meta_io.h\"",
            "#include \"lops.h\"",
            "#include \"log.h\"",
            "#include \"inode.h\"",
            "#include \"glock.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"util.h\"\n#include \"trans.h\"\n#include \"meta_io.h\"\n#include \"lops.h\"\n#include \"log.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/gfs2_ondisk.h>\n#include <linux/kallsyms.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nint gfs2_trans_begin(struct gfs2_sbd *sdp, unsigned int blocks,\n\t\t     unsigned int revokes)\n{\n\tstruct gfs2_trans *tr;\n\tint error;\n\n\tBUG_ON(current->journal_info);\n\tBUG_ON(blocks == 0 && revokes == 0);\n\n\tif (!test_bit(SDF_JOURNAL_LIVE, &sdp->sd_flags))\n\t\treturn -EROFS;\n\n\ttr = kzalloc(sizeof(struct gfs2_trans), GFP_NOFS);\n\tif (!tr)\n\t\treturn -ENOMEM;\n\n\ttr->tr_ip = _RET_IP_;\n\ttr->tr_blocks = blocks;\n\ttr->tr_revokes = revokes;\n\ttr->tr_reserved = 1;\n\ttr->tr_alloced = 1;\n\tif (blocks)\n\t\ttr->tr_reserved += 6 + blocks;\n\tif (revokes)\n\t\ttr->tr_reserved += gfs2_struct2blk(sdp, revokes,\n\t\t\t\t\t\t   sizeof(u64));\n\tINIT_LIST_HEAD(&tr->tr_databuf);\n\tINIT_LIST_HEAD(&tr->tr_buf);\n\n\tsb_start_intwrite(sdp->sd_vfs);\n\n\terror = gfs2_log_reserve(sdp, tr->tr_reserved);\n\tif (error)\n\t\tgoto fail;\n\n\tcurrent->journal_info = tr;\n\n\treturn 0;\n\nfail:\n\tsb_end_intwrite(sdp->sd_vfs);\n\tkfree(tr);\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "gfs2_inplace_reserve",
          "args": [
            "ip",
            "&ap"
          ],
          "line": 389
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_inplace_reserve",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/rgrp.c",
          "lines": "1952-2072",
          "snippet": "int gfs2_inplace_reserve(struct gfs2_inode *ip, const struct gfs2_alloc_parms *ap)\n{\n\tstruct gfs2_sbd *sdp = GFS2_SB(&ip->i_inode);\n\tstruct gfs2_rgrpd *begin = NULL;\n\tstruct gfs2_blkreserv *rs = ip->i_res;\n\tint error = 0, rg_locked, flags = 0;\n\tu64 last_unlinked = NO_BLOCK;\n\tint loops = 0;\n\tu32 skip = 0;\n\n\tif (sdp->sd_args.ar_rgrplvb)\n\t\tflags |= GL_SKIP;\n\tif (gfs2_assert_warn(sdp, ap->target))\n\t\treturn -EINVAL;\n\tif (gfs2_rs_active(rs)) {\n\t\tbegin = rs->rs_rbm.rgd;\n\t} else if (ip->i_rgd && rgrp_contains_block(ip->i_rgd, ip->i_goal)) {\n\t\trs->rs_rbm.rgd = begin = ip->i_rgd;\n\t} else {\n\t\tcheck_and_update_goal(ip);\n\t\trs->rs_rbm.rgd = begin = gfs2_blk2rgrpd(sdp, ip->i_goal, 1);\n\t}\n\tif (S_ISDIR(ip->i_inode.i_mode) && (ap->aflags & GFS2_AF_ORLOV))\n\t\tskip = gfs2_orlov_skip(ip);\n\tif (rs->rs_rbm.rgd == NULL)\n\t\treturn -EBADSLT;\n\n\twhile (loops < 3) {\n\t\trg_locked = 1;\n\n\t\tif (!gfs2_glock_is_locked_by_me(rs->rs_rbm.rgd->rd_gl)) {\n\t\t\trg_locked = 0;\n\t\t\tif (skip && skip--)\n\t\t\t\tgoto next_rgrp;\n\t\t\tif (!gfs2_rs_active(rs)) {\n\t\t\t\tif (loops == 0 &&\n\t\t\t\t    !fast_to_acquire(rs->rs_rbm.rgd))\n\t\t\t\t\tgoto next_rgrp;\n\t\t\t\tif ((loops < 2) &&\n\t\t\t\t    gfs2_rgrp_used_recently(rs, 1000) &&\n\t\t\t\t    gfs2_rgrp_congested(rs->rs_rbm.rgd, loops))\n\t\t\t\t\tgoto next_rgrp;\n\t\t\t}\n\t\t\terror = gfs2_glock_nq_init(rs->rs_rbm.rgd->rd_gl,\n\t\t\t\t\t\t   LM_ST_EXCLUSIVE, flags,\n\t\t\t\t\t\t   &rs->rs_rgd_gh);\n\t\t\tif (unlikely(error))\n\t\t\t\treturn error;\n\t\t\tif (!gfs2_rs_active(rs) && (loops < 2) &&\n\t\t\t    gfs2_rgrp_congested(rs->rs_rbm.rgd, loops))\n\t\t\t\tgoto skip_rgrp;\n\t\t\tif (sdp->sd_args.ar_rgrplvb) {\n\t\t\t\terror = update_rgrp_lvb(rs->rs_rbm.rgd);\n\t\t\t\tif (unlikely(error)) {\n\t\t\t\t\tgfs2_glock_dq_uninit(&rs->rs_rgd_gh);\n\t\t\t\t\treturn error;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t/* Skip unuseable resource groups */\n\t\tif ((rs->rs_rbm.rgd->rd_flags & (GFS2_RGF_NOALLOC |\n\t\t\t\t\t\t GFS2_RDF_ERROR)) ||\n\t\t    (ap->target > rs->rs_rbm.rgd->rd_extfail_pt))\n\t\t\tgoto skip_rgrp;\n\n\t\tif (sdp->sd_args.ar_rgrplvb)\n\t\t\tgfs2_rgrp_bh_get(rs->rs_rbm.rgd);\n\n\t\t/* Get a reservation if we don't already have one */\n\t\tif (!gfs2_rs_active(rs))\n\t\t\trg_mblk_search(rs->rs_rbm.rgd, ip, ap);\n\n\t\t/* Skip rgrps when we can't get a reservation on first pass */\n\t\tif (!gfs2_rs_active(rs) && (loops < 1))\n\t\t\tgoto check_rgrp;\n\n\t\t/* If rgrp has enough free space, use it */\n\t\tif (rs->rs_rbm.rgd->rd_free_clone >= ap->target) {\n\t\t\tip->i_rgd = rs->rs_rbm.rgd;\n\t\t\treturn 0;\n\t\t}\n\ncheck_rgrp:\n\t\t/* Check for unlinked inodes which can be reclaimed */\n\t\tif (rs->rs_rbm.rgd->rd_flags & GFS2_RDF_CHECK)\n\t\t\ttry_rgrp_unlink(rs->rs_rbm.rgd, &last_unlinked,\n\t\t\t\t\tip->i_no_addr);\nskip_rgrp:\n\t\t/* Drop reservation, if we couldn't use reserved rgrp */\n\t\tif (gfs2_rs_active(rs))\n\t\t\tgfs2_rs_deltree(rs);\n\n\t\t/* Unlock rgrp if required */\n\t\tif (!rg_locked)\n\t\t\tgfs2_glock_dq_uninit(&rs->rs_rgd_gh);\nnext_rgrp:\n\t\t/* Find the next rgrp, and continue looking */\n\t\tif (gfs2_select_rgrp(&rs->rs_rbm.rgd, begin))\n\t\t\tcontinue;\n\t\tif (skip)\n\t\t\tcontinue;\n\n\t\t/* If we've scanned all the rgrps, but found no free blocks\n\t\t * then this checks for some less likely conditions before\n\t\t * trying again.\n\t\t */\n\t\tloops++;\n\t\t/* Check that fs hasn't grown if writing to rindex */\n\t\tif (ip == GFS2_I(sdp->sd_rindex) && !sdp->sd_rindex_uptodate) {\n\t\t\terror = gfs2_ri_update(ip);\n\t\t\tif (error)\n\t\t\t\treturn error;\n\t\t}\n\t\t/* Flushing the log may release space */\n\t\tif (loops == 2)\n\t\t\tgfs2_log_flush(sdp, NULL, NORMAL_FLUSH);\n\t}\n\n\treturn -ENOSPC;\n}",
          "includes": [
            "#include \"trace_gfs2.h\"",
            "#include \"inode.h\"",
            "#include \"log.h\"",
            "#include \"util.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"lops.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/random.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/fs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [
            "#define NO_BLOCK ((u64)~0)"
          ],
          "globals_used": [
            "static int gfs2_rbm_find(struct gfs2_rbm *rbm, u8 state, u32 *minext,\n\t\t\t const struct gfs2_inode *ip, bool nowrap,\n\t\t\t const struct gfs2_alloc_parms *ap);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"inode.h\"\n#include \"log.h\"\n#include \"util.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"lops.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/random.h>\n#include <linux/rbtree.h>\n#include <linux/blkdev.h>\n#include <linux/prefetch.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/fs.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\n#define NO_BLOCK ((u64)~0)\n\nstatic int gfs2_rbm_find(struct gfs2_rbm *rbm, u8 state, u32 *minext,\n\t\t\t const struct gfs2_inode *ip, bool nowrap,\n\t\t\t const struct gfs2_alloc_parms *ap);\n\nint gfs2_inplace_reserve(struct gfs2_inode *ip, const struct gfs2_alloc_parms *ap)\n{\n\tstruct gfs2_sbd *sdp = GFS2_SB(&ip->i_inode);\n\tstruct gfs2_rgrpd *begin = NULL;\n\tstruct gfs2_blkreserv *rs = ip->i_res;\n\tint error = 0, rg_locked, flags = 0;\n\tu64 last_unlinked = NO_BLOCK;\n\tint loops = 0;\n\tu32 skip = 0;\n\n\tif (sdp->sd_args.ar_rgrplvb)\n\t\tflags |= GL_SKIP;\n\tif (gfs2_assert_warn(sdp, ap->target))\n\t\treturn -EINVAL;\n\tif (gfs2_rs_active(rs)) {\n\t\tbegin = rs->rs_rbm.rgd;\n\t} else if (ip->i_rgd && rgrp_contains_block(ip->i_rgd, ip->i_goal)) {\n\t\trs->rs_rbm.rgd = begin = ip->i_rgd;\n\t} else {\n\t\tcheck_and_update_goal(ip);\n\t\trs->rs_rbm.rgd = begin = gfs2_blk2rgrpd(sdp, ip->i_goal, 1);\n\t}\n\tif (S_ISDIR(ip->i_inode.i_mode) && (ap->aflags & GFS2_AF_ORLOV))\n\t\tskip = gfs2_orlov_skip(ip);\n\tif (rs->rs_rbm.rgd == NULL)\n\t\treturn -EBADSLT;\n\n\twhile (loops < 3) {\n\t\trg_locked = 1;\n\n\t\tif (!gfs2_glock_is_locked_by_me(rs->rs_rbm.rgd->rd_gl)) {\n\t\t\trg_locked = 0;\n\t\t\tif (skip && skip--)\n\t\t\t\tgoto next_rgrp;\n\t\t\tif (!gfs2_rs_active(rs)) {\n\t\t\t\tif (loops == 0 &&\n\t\t\t\t    !fast_to_acquire(rs->rs_rbm.rgd))\n\t\t\t\t\tgoto next_rgrp;\n\t\t\t\tif ((loops < 2) &&\n\t\t\t\t    gfs2_rgrp_used_recently(rs, 1000) &&\n\t\t\t\t    gfs2_rgrp_congested(rs->rs_rbm.rgd, loops))\n\t\t\t\t\tgoto next_rgrp;\n\t\t\t}\n\t\t\terror = gfs2_glock_nq_init(rs->rs_rbm.rgd->rd_gl,\n\t\t\t\t\t\t   LM_ST_EXCLUSIVE, flags,\n\t\t\t\t\t\t   &rs->rs_rgd_gh);\n\t\t\tif (unlikely(error))\n\t\t\t\treturn error;\n\t\t\tif (!gfs2_rs_active(rs) && (loops < 2) &&\n\t\t\t    gfs2_rgrp_congested(rs->rs_rbm.rgd, loops))\n\t\t\t\tgoto skip_rgrp;\n\t\t\tif (sdp->sd_args.ar_rgrplvb) {\n\t\t\t\terror = update_rgrp_lvb(rs->rs_rbm.rgd);\n\t\t\t\tif (unlikely(error)) {\n\t\t\t\t\tgfs2_glock_dq_uninit(&rs->rs_rgd_gh);\n\t\t\t\t\treturn error;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t/* Skip unuseable resource groups */\n\t\tif ((rs->rs_rbm.rgd->rd_flags & (GFS2_RGF_NOALLOC |\n\t\t\t\t\t\t GFS2_RDF_ERROR)) ||\n\t\t    (ap->target > rs->rs_rbm.rgd->rd_extfail_pt))\n\t\t\tgoto skip_rgrp;\n\n\t\tif (sdp->sd_args.ar_rgrplvb)\n\t\t\tgfs2_rgrp_bh_get(rs->rs_rbm.rgd);\n\n\t\t/* Get a reservation if we don't already have one */\n\t\tif (!gfs2_rs_active(rs))\n\t\t\trg_mblk_search(rs->rs_rbm.rgd, ip, ap);\n\n\t\t/* Skip rgrps when we can't get a reservation on first pass */\n\t\tif (!gfs2_rs_active(rs) && (loops < 1))\n\t\t\tgoto check_rgrp;\n\n\t\t/* If rgrp has enough free space, use it */\n\t\tif (rs->rs_rbm.rgd->rd_free_clone >= ap->target) {\n\t\t\tip->i_rgd = rs->rs_rbm.rgd;\n\t\t\treturn 0;\n\t\t}\n\ncheck_rgrp:\n\t\t/* Check for unlinked inodes which can be reclaimed */\n\t\tif (rs->rs_rbm.rgd->rd_flags & GFS2_RDF_CHECK)\n\t\t\ttry_rgrp_unlink(rs->rs_rbm.rgd, &last_unlinked,\n\t\t\t\t\tip->i_no_addr);\nskip_rgrp:\n\t\t/* Drop reservation, if we couldn't use reserved rgrp */\n\t\tif (gfs2_rs_active(rs))\n\t\t\tgfs2_rs_deltree(rs);\n\n\t\t/* Unlock rgrp if required */\n\t\tif (!rg_locked)\n\t\t\tgfs2_glock_dq_uninit(&rs->rs_rgd_gh);\nnext_rgrp:\n\t\t/* Find the next rgrp, and continue looking */\n\t\tif (gfs2_select_rgrp(&rs->rs_rbm.rgd, begin))\n\t\t\tcontinue;\n\t\tif (skip)\n\t\t\tcontinue;\n\n\t\t/* If we've scanned all the rgrps, but found no free blocks\n\t\t * then this checks for some less likely conditions before\n\t\t * trying again.\n\t\t */\n\t\tloops++;\n\t\t/* Check that fs hasn't grown if writing to rindex */\n\t\tif (ip == GFS2_I(sdp->sd_rindex) && !sdp->sd_rindex_uptodate) {\n\t\t\terror = gfs2_ri_update(ip);\n\t\t\tif (error)\n\t\t\t\treturn error;\n\t\t}\n\t\t/* Flushing the log may release space */\n\t\tif (loops == 2)\n\t\t\tgfs2_log_flush(sdp, NULL, NORMAL_FLUSH);\n\t}\n\n\treturn -ENOSPC;\n}"
        }
      },
      {
        "call_info": {
          "callee": "gfs2_quota_lock_check",
          "args": [
            "ip"
          ],
          "line": 385
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_quota_lock_check",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/quota.h",
          "lines": "40-55",
          "snippet": "static inline int gfs2_quota_lock_check(struct gfs2_inode *ip)\n{\n\tstruct gfs2_sbd *sdp = GFS2_SB(&ip->i_inode);\n\tint ret;\n\tif (sdp->sd_args.ar_quota == GFS2_QUOTA_OFF)\n\t\treturn 0;\n\tret = gfs2_quota_lock(ip, NO_UID_QUOTA_CHANGE, NO_GID_QUOTA_CHANGE);\n\tif (ret)\n\t\treturn ret;\n\tif (sdp->sd_args.ar_quota != GFS2_QUOTA_ON)\n\t\treturn 0;\n\tret = gfs2_quota_check(ip, ip->i_inode.i_uid, ip->i_inode.i_gid);\n\tif (ret)\n\t\tgfs2_quota_unlock(ip);\n\treturn ret;\n}",
          "includes": [
            "#include <linux/list_lru.h>"
          ],
          "macros_used": [
            "#define NO_GID_QUOTA_CHANGE INVALID_GID",
            "#define NO_UID_QUOTA_CHANGE INVALID_UID"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/list_lru.h>\n\n#define NO_GID_QUOTA_CHANGE INVALID_GID\n#define NO_UID_QUOTA_CHANGE INVALID_UID\n\nstatic inline int gfs2_quota_lock_check(struct gfs2_inode *ip)\n{\n\tstruct gfs2_sbd *sdp = GFS2_SB(&ip->i_inode);\n\tint ret;\n\tif (sdp->sd_args.ar_quota == GFS2_QUOTA_OFF)\n\t\treturn 0;\n\tret = gfs2_quota_lock(ip, NO_UID_QUOTA_CHANGE, NO_GID_QUOTA_CHANGE);\n\tif (ret)\n\t\treturn ret;\n\tif (sdp->sd_args.ar_quota != GFS2_QUOTA_ON)\n\t\treturn 0;\n\tret = gfs2_quota_check(ip, ip->i_inode.i_uid, ip->i_inode.i_gid);\n\tif (ret)\n\t\tgfs2_quota_unlock(ip);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "GFS2_SB",
          "args": [
            "&ip->i_inode"
          ],
          "line": 381
        },
        "resolved": true,
        "details": {
          "function_name": "GFS2_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/incore.h",
          "lines": "413-416",
          "snippet": "static inline struct gfs2_sbd *GFS2_SB(const struct inode *inode)\n{\n\treturn inode->i_sb->s_fs_info;\n}",
          "includes": [
            "#include <linux/lockref.h>",
            "#include <linux/percpu.h>",
            "#include <linux/ktime.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/completion.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/dlm.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/kobject.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/lockref.h>\n#include <linux/percpu.h>\n#include <linux/ktime.h>\n#include <linux/rbtree.h>\n#include <linux/completion.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/buffer_head.h>\n#include <linux/dlm.h>\n#include <linux/workqueue.h>\n#include <linux/kobject.h>\n#include <linux/fs.h>\n\nstatic inline struct gfs2_sbd *GFS2_SB(const struct inode *inode)\n{\n\treturn inode->i_sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"glops.h\"\n#include \"super.h\"\n#include \"util.h\"\n#include \"trans.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"xattr.h\"\n#include \"dir.h\"\n#include \"bmap.h\"\n#include \"acl.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <asm/uaccess.h>\n#include <linux/security.h>\n#include <linux/fiemap.h>\n#include <linux/crc32.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/posix_acl.h>\n#include <linux/xattr.h>\n#include <linux/mm.h>\n#include <linux/namei.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nstatic int alloc_dinode(struct gfs2_inode *ip, u32 flags, unsigned *dblocks)\n{\n\tstruct gfs2_sbd *sdp = GFS2_SB(&ip->i_inode);\n\tstruct gfs2_alloc_parms ap = { .target = *dblocks, .aflags = flags, };\n\tint error;\n\n\terror = gfs2_quota_lock_check(ip);\n\tif (error)\n\t\tgoto out;\n\n\terror = gfs2_inplace_reserve(ip, &ap);\n\tif (error)\n\t\tgoto out_quota;\n\n\terror = gfs2_trans_begin(sdp, (*dblocks * RES_RG_BIT) + RES_STATFS + RES_QUOTA, 0);\n\tif (error)\n\t\tgoto out_ipreserv;\n\n\terror = gfs2_alloc_blocks(ip, &ip->i_no_addr, dblocks, 1, &ip->i_generation);\n\tip->i_no_formal_ino = ip->i_generation;\n\tip->i_inode.i_ino = ip->i_no_addr;\n\tip->i_goal = ip->i_no_addr;\n\n\tgfs2_trans_end(sdp);\n\nout_ipreserv:\n\tgfs2_inplace_release(ip);\nout_quota:\n\tgfs2_quota_unlock(ip);\nout:\n\treturn error;\n}"
  },
  {
    "function_name": "munge_mode_uid_gid",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/inode.c",
    "lines": "357-377",
    "snippet": "static void munge_mode_uid_gid(const struct gfs2_inode *dip,\n\t\t\t       struct inode *inode)\n{\n\tif (GFS2_SB(&dip->i_inode)->sd_args.ar_suiddir &&\n\t    (dip->i_inode.i_mode & S_ISUID) &&\n\t    !uid_eq(dip->i_inode.i_uid, GLOBAL_ROOT_UID)) {\n\t\tif (S_ISDIR(inode->i_mode))\n\t\t\tinode->i_mode |= S_ISUID;\n\t\telse if (!uid_eq(dip->i_inode.i_uid, current_fsuid()))\n\t\t\tinode->i_mode &= ~07111;\n\t\tinode->i_uid = dip->i_inode.i_uid;\n\t} else\n\t\tinode->i_uid = current_fsuid();\n\n\tif (dip->i_inode.i_mode & S_ISGID) {\n\t\tif (S_ISDIR(inode->i_mode))\n\t\t\tinode->i_mode |= S_ISGID;\n\t\tinode->i_gid = dip->i_inode.i_gid;\n\t} else\n\t\tinode->i_gid = current_fsgid();\n}",
    "includes": [
      "#include \"glops.h\"",
      "#include \"super.h\"",
      "#include \"util.h\"",
      "#include \"trans.h\"",
      "#include \"rgrp.h\"",
      "#include \"quota.h\"",
      "#include \"meta_io.h\"",
      "#include \"inode.h\"",
      "#include \"glock.h\"",
      "#include \"xattr.h\"",
      "#include \"dir.h\"",
      "#include \"bmap.h\"",
      "#include \"acl.h\"",
      "#include \"incore.h\"",
      "#include \"gfs2.h\"",
      "#include <asm/uaccess.h>",
      "#include <linux/security.h>",
      "#include <linux/fiemap.h>",
      "#include <linux/crc32.h>",
      "#include <linux/gfs2_ondisk.h>",
      "#include <linux/posix_acl.h>",
      "#include <linux/xattr.h>",
      "#include <linux/mm.h>",
      "#include <linux/namei.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/completion.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "current_fsgid",
          "args": [],
          "line": 376
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISDIR",
          "args": [
            "inode->i_mode"
          ],
          "line": 372
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "current_fsuid",
          "args": [],
          "line": 369
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "uid_eq",
          "args": [
            "dip->i_inode.i_uid",
            "current_fsuid()"
          ],
          "line": 365
        },
        "resolved": true,
        "details": {
          "function_name": "uuid_equal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/uuid.c",
          "lines": "59-63",
          "snippet": "int\nuuid_equal(uuid_t *uuid1, uuid_t *uuid2)\n{\n\treturn memcmp(uuid1, uuid2, sizeof(uuid_t)) ? 0 : 1;\n}",
          "includes": [
            "#include <xfs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <xfs.h>\n\nint\nuuid_equal(uuid_t *uuid1, uuid_t *uuid2)\n{\n\treturn memcmp(uuid1, uuid2, sizeof(uuid_t)) ? 0 : 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "current_fsuid",
          "args": [],
          "line": 365
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISDIR",
          "args": [
            "inode->i_mode"
          ],
          "line": 363
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GFS2_SB",
          "args": [
            "&dip->i_inode"
          ],
          "line": 360
        },
        "resolved": true,
        "details": {
          "function_name": "GFS2_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/incore.h",
          "lines": "413-416",
          "snippet": "static inline struct gfs2_sbd *GFS2_SB(const struct inode *inode)\n{\n\treturn inode->i_sb->s_fs_info;\n}",
          "includes": [
            "#include <linux/lockref.h>",
            "#include <linux/percpu.h>",
            "#include <linux/ktime.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/completion.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/dlm.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/kobject.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/lockref.h>\n#include <linux/percpu.h>\n#include <linux/ktime.h>\n#include <linux/rbtree.h>\n#include <linux/completion.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/buffer_head.h>\n#include <linux/dlm.h>\n#include <linux/workqueue.h>\n#include <linux/kobject.h>\n#include <linux/fs.h>\n\nstatic inline struct gfs2_sbd *GFS2_SB(const struct inode *inode)\n{\n\treturn inode->i_sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"glops.h\"\n#include \"super.h\"\n#include \"util.h\"\n#include \"trans.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"xattr.h\"\n#include \"dir.h\"\n#include \"bmap.h\"\n#include \"acl.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <asm/uaccess.h>\n#include <linux/security.h>\n#include <linux/fiemap.h>\n#include <linux/crc32.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/posix_acl.h>\n#include <linux/xattr.h>\n#include <linux/mm.h>\n#include <linux/namei.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nstatic void munge_mode_uid_gid(const struct gfs2_inode *dip,\n\t\t\t       struct inode *inode)\n{\n\tif (GFS2_SB(&dip->i_inode)->sd_args.ar_suiddir &&\n\t    (dip->i_inode.i_mode & S_ISUID) &&\n\t    !uid_eq(dip->i_inode.i_uid, GLOBAL_ROOT_UID)) {\n\t\tif (S_ISDIR(inode->i_mode))\n\t\t\tinode->i_mode |= S_ISUID;\n\t\telse if (!uid_eq(dip->i_inode.i_uid, current_fsuid()))\n\t\t\tinode->i_mode &= ~07111;\n\t\tinode->i_uid = dip->i_inode.i_uid;\n\t} else\n\t\tinode->i_uid = current_fsuid();\n\n\tif (dip->i_inode.i_mode & S_ISGID) {\n\t\tif (S_ISDIR(inode->i_mode))\n\t\t\tinode->i_mode |= S_ISGID;\n\t\tinode->i_gid = dip->i_inode.i_gid;\n\t} else\n\t\tinode->i_gid = current_fsgid();\n}"
  },
  {
    "function_name": "create_ok",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/inode.c",
    "lines": "336-355",
    "snippet": "static int create_ok(struct gfs2_inode *dip, const struct qstr *name,\n\t\t     umode_t mode)\n{\n\tint error;\n\n\terror = gfs2_permission(&dip->i_inode, MAY_WRITE | MAY_EXEC);\n\tif (error)\n\t\treturn error;\n\n\t/*  Don't create entries in an unlinked directory  */\n\tif (!dip->i_inode.i_nlink)\n\t\treturn -ENOENT;\n\n\tif (dip->i_entries == (u32)-1)\n\t\treturn -EFBIG;\n\tif (S_ISDIR(mode) && dip->i_inode.i_nlink == (u32)-1)\n\t\treturn -EMLINK;\n\n\treturn 0;\n}",
    "includes": [
      "#include \"glops.h\"",
      "#include \"super.h\"",
      "#include \"util.h\"",
      "#include \"trans.h\"",
      "#include \"rgrp.h\"",
      "#include \"quota.h\"",
      "#include \"meta_io.h\"",
      "#include \"inode.h\"",
      "#include \"glock.h\"",
      "#include \"xattr.h\"",
      "#include \"dir.h\"",
      "#include \"bmap.h\"",
      "#include \"acl.h\"",
      "#include \"incore.h\"",
      "#include \"gfs2.h\"",
      "#include <asm/uaccess.h>",
      "#include <linux/security.h>",
      "#include <linux/fiemap.h>",
      "#include <linux/crc32.h>",
      "#include <linux/gfs2_ondisk.h>",
      "#include <linux/posix_acl.h>",
      "#include <linux/xattr.h>",
      "#include <linux/mm.h>",
      "#include <linux/namei.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/completion.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "S_ISDIR",
          "args": [
            "mode"
          ],
          "line": 351
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gfs2_permission",
          "args": [
            "&dip->i_inode",
            "MAY_WRITE | MAY_EXEC"
          ],
          "line": 341
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_permission",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/inode.c",
          "lines": "1606-1632",
          "snippet": "int gfs2_permission(struct inode *inode, int mask)\n{\n\tstruct gfs2_inode *ip;\n\tstruct gfs2_holder i_gh;\n\tint error;\n\tint unlock = 0;\n\n\n\tip = GFS2_I(inode);\n\tif (gfs2_glock_is_locked_by_me(ip->i_gl) == NULL) {\n\t\tif (mask & MAY_NOT_BLOCK)\n\t\t\treturn -ECHILD;\n\t\terror = gfs2_glock_nq_init(ip->i_gl, LM_ST_SHARED, LM_FLAG_ANY, &i_gh);\n\t\tif (error)\n\t\t\treturn error;\n\t\tunlock = 1;\n\t}\n\n\tif ((mask & MAY_WRITE) && IS_IMMUTABLE(inode))\n\t\terror = -EACCES;\n\telse\n\t\terror = generic_permission(inode, mask);\n\tif (unlock)\n\t\tgfs2_glock_dq_uninit(&i_gh);\n\n\treturn error;\n}",
          "includes": [
            "#include \"glops.h\"",
            "#include \"super.h\"",
            "#include \"util.h\"",
            "#include \"trans.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"inode.h\"",
            "#include \"glock.h\"",
            "#include \"xattr.h\"",
            "#include \"dir.h\"",
            "#include \"bmap.h\"",
            "#include \"acl.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/security.h>",
            "#include <linux/fiemap.h>",
            "#include <linux/crc32.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/xattr.h>",
            "#include <linux/mm.h>",
            "#include <linux/namei.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glops.h\"\n#include \"super.h\"\n#include \"util.h\"\n#include \"trans.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"xattr.h\"\n#include \"dir.h\"\n#include \"bmap.h\"\n#include \"acl.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <asm/uaccess.h>\n#include <linux/security.h>\n#include <linux/fiemap.h>\n#include <linux/crc32.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/posix_acl.h>\n#include <linux/xattr.h>\n#include <linux/mm.h>\n#include <linux/namei.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nint gfs2_permission(struct inode *inode, int mask)\n{\n\tstruct gfs2_inode *ip;\n\tstruct gfs2_holder i_gh;\n\tint error;\n\tint unlock = 0;\n\n\n\tip = GFS2_I(inode);\n\tif (gfs2_glock_is_locked_by_me(ip->i_gl) == NULL) {\n\t\tif (mask & MAY_NOT_BLOCK)\n\t\t\treturn -ECHILD;\n\t\terror = gfs2_glock_nq_init(ip->i_gl, LM_ST_SHARED, LM_FLAG_ANY, &i_gh);\n\t\tif (error)\n\t\t\treturn error;\n\t\tunlock = 1;\n\t}\n\n\tif ((mask & MAY_WRITE) && IS_IMMUTABLE(inode))\n\t\terror = -EACCES;\n\telse\n\t\terror = generic_permission(inode, mask);\n\tif (unlock)\n\t\tgfs2_glock_dq_uninit(&i_gh);\n\n\treturn error;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"glops.h\"\n#include \"super.h\"\n#include \"util.h\"\n#include \"trans.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"xattr.h\"\n#include \"dir.h\"\n#include \"bmap.h\"\n#include \"acl.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <asm/uaccess.h>\n#include <linux/security.h>\n#include <linux/fiemap.h>\n#include <linux/crc32.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/posix_acl.h>\n#include <linux/xattr.h>\n#include <linux/mm.h>\n#include <linux/namei.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nstatic int create_ok(struct gfs2_inode *dip, const struct qstr *name,\n\t\t     umode_t mode)\n{\n\tint error;\n\n\terror = gfs2_permission(&dip->i_inode, MAY_WRITE | MAY_EXEC);\n\tif (error)\n\t\treturn error;\n\n\t/*  Don't create entries in an unlinked directory  */\n\tif (!dip->i_inode.i_nlink)\n\t\treturn -ENOENT;\n\n\tif (dip->i_entries == (u32)-1)\n\t\treturn -EFBIG;\n\tif (S_ISDIR(mode) && dip->i_inode.i_nlink == (u32)-1)\n\t\treturn -EMLINK;\n\n\treturn 0;\n}"
  },
  {
    "function_name": "gfs2_lookupi",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/inode.c",
    "lines": "283-325",
    "snippet": "struct inode *gfs2_lookupi(struct inode *dir, const struct qstr *name,\n\t\t\t   int is_root)\n{\n\tstruct super_block *sb = dir->i_sb;\n\tstruct gfs2_inode *dip = GFS2_I(dir);\n\tstruct gfs2_holder d_gh;\n\tint error = 0;\n\tstruct inode *inode = NULL;\n\tint unlock = 0;\n\n\tif (!name->len || name->len > GFS2_FNAMESIZE)\n\t\treturn ERR_PTR(-ENAMETOOLONG);\n\n\tif ((name->len == 1 && memcmp(name->name, \".\", 1) == 0) ||\n\t    (name->len == 2 && memcmp(name->name, \"..\", 2) == 0 &&\n\t     dir == sb->s_root->d_inode)) {\n\t\tigrab(dir);\n\t\treturn dir;\n\t}\n\n\tif (gfs2_glock_is_locked_by_me(dip->i_gl) == NULL) {\n\t\terror = gfs2_glock_nq_init(dip->i_gl, LM_ST_SHARED, 0, &d_gh);\n\t\tif (error)\n\t\t\treturn ERR_PTR(error);\n\t\tunlock = 1;\n\t}\n\n\tif (!is_root) {\n\t\terror = gfs2_permission(dir, MAY_EXEC);\n\t\tif (error)\n\t\t\tgoto out;\n\t}\n\n\tinode = gfs2_dir_search(dir, name, false);\n\tif (IS_ERR(inode))\n\t\terror = PTR_ERR(inode);\nout:\n\tif (unlock)\n\t\tgfs2_glock_dq_uninit(&d_gh);\n\tif (error == -ENOENT)\n\t\treturn NULL;\n\treturn inode ? inode : ERR_PTR(error);\n}",
    "includes": [
      "#include \"glops.h\"",
      "#include \"super.h\"",
      "#include \"util.h\"",
      "#include \"trans.h\"",
      "#include \"rgrp.h\"",
      "#include \"quota.h\"",
      "#include \"meta_io.h\"",
      "#include \"inode.h\"",
      "#include \"glock.h\"",
      "#include \"xattr.h\"",
      "#include \"dir.h\"",
      "#include \"bmap.h\"",
      "#include \"acl.h\"",
      "#include \"incore.h\"",
      "#include \"gfs2.h\"",
      "#include <asm/uaccess.h>",
      "#include <linux/security.h>",
      "#include <linux/fiemap.h>",
      "#include <linux/crc32.h>",
      "#include <linux/gfs2_ondisk.h>",
      "#include <linux/posix_acl.h>",
      "#include <linux/xattr.h>",
      "#include <linux/mm.h>",
      "#include <linux/namei.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/completion.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "error"
          ],
          "line": 324
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gfs2_glock_dq_uninit",
          "args": [
            "&d_gh"
          ],
          "line": 321
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_glock_dq_uninit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/glock.c",
          "lines": "1110-1114",
          "snippet": "void gfs2_glock_dq_uninit(struct gfs2_holder *gh)\n{\n\tgfs2_glock_dq(gh);\n\tgfs2_holder_uninit(gh);\n}",
          "includes": [
            "#include \"trace_gfs2.h\"",
            "#include \"bmap.h\"",
            "#include \"util.h\"",
            "#include \"super.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"lops.h\"",
            "#include \"inode.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/lockref.h>",
            "#include <linux/list_sort.h>",
            "#include <linux/percpu.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/seq_file.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/module.h>",
            "#include <linux/wait.h>",
            "#include <linux/list.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/jhash.h>",
            "#include <linux/sort.h>",
            "#include <linux/delay.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"bmap.h\"\n#include \"util.h\"\n#include \"super.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"lops.h\"\n#include \"inode.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/lockref.h>\n#include <linux/list_sort.h>\n#include <linux/percpu.h>\n#include <linux/bit_spinlock.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/jiffies.h>\n#include <linux/workqueue.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <asm/uaccess.h>\n#include <linux/module.h>\n#include <linux/wait.h>\n#include <linux/list.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/kallsyms.h>\n#include <linux/jhash.h>\n#include <linux/sort.h>\n#include <linux/delay.h>\n#include <linux/buffer_head.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nvoid gfs2_glock_dq_uninit(struct gfs2_holder *gh)\n{\n\tgfs2_glock_dq(gh);\n\tgfs2_holder_uninit(gh);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "inode"
          ],
          "line": 318
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "inode"
          ],
          "line": 317
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gfs2_dir_search",
          "args": [
            "dir",
            "name",
            "false"
          ],
          "line": 316
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_dir_search",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/dir.c",
          "lines": "1548-1569",
          "snippet": "struct inode *gfs2_dir_search(struct inode *dir, const struct qstr *name,\n\t\t\t      bool fail_on_exist)\n{\n\tstruct buffer_head *bh;\n\tstruct gfs2_dirent *dent;\n\tu64 addr, formal_ino;\n\tu16 dtype;\n\n\tdent = gfs2_dirent_search(dir, name, gfs2_dirent_find, &bh);\n\tif (dent) {\n\t\tif (IS_ERR(dent))\n\t\t\treturn ERR_CAST(dent);\n\t\tdtype = be16_to_cpu(dent->de_type);\n\t\taddr = be64_to_cpu(dent->de_inum.no_addr);\n\t\tformal_ino = be64_to_cpu(dent->de_inum.no_formal_ino);\n\t\tbrelse(bh);\n\t\tif (fail_on_exist)\n\t\t\treturn ERR_PTR(-EEXIST);\n\t\treturn gfs2_inode_lookup(dir->i_sb, dtype, addr, formal_ino, 0);\n\t}\n\treturn ERR_PTR(-ENOENT);\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"bmap.h\"",
            "#include \"trans.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"inode.h\"",
            "#include \"glock.h\"",
            "#include \"dir.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/crc32.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/sort.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"bmap.h\"\n#include \"trans.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"dir.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/vmalloc.h>\n#include <linux/crc32.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/sort.h>\n#include <linux/buffer_head.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nstruct inode *gfs2_dir_search(struct inode *dir, const struct qstr *name,\n\t\t\t      bool fail_on_exist)\n{\n\tstruct buffer_head *bh;\n\tstruct gfs2_dirent *dent;\n\tu64 addr, formal_ino;\n\tu16 dtype;\n\n\tdent = gfs2_dirent_search(dir, name, gfs2_dirent_find, &bh);\n\tif (dent) {\n\t\tif (IS_ERR(dent))\n\t\t\treturn ERR_CAST(dent);\n\t\tdtype = be16_to_cpu(dent->de_type);\n\t\taddr = be64_to_cpu(dent->de_inum.no_addr);\n\t\tformal_ino = be64_to_cpu(dent->de_inum.no_formal_ino);\n\t\tbrelse(bh);\n\t\tif (fail_on_exist)\n\t\t\treturn ERR_PTR(-EEXIST);\n\t\treturn gfs2_inode_lookup(dir->i_sb, dtype, addr, formal_ino, 0);\n\t}\n\treturn ERR_PTR(-ENOENT);\n}"
        }
      },
      {
        "call_info": {
          "callee": "gfs2_permission",
          "args": [
            "dir",
            "MAY_EXEC"
          ],
          "line": 311
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_permission",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/inode.c",
          "lines": "1606-1632",
          "snippet": "int gfs2_permission(struct inode *inode, int mask)\n{\n\tstruct gfs2_inode *ip;\n\tstruct gfs2_holder i_gh;\n\tint error;\n\tint unlock = 0;\n\n\n\tip = GFS2_I(inode);\n\tif (gfs2_glock_is_locked_by_me(ip->i_gl) == NULL) {\n\t\tif (mask & MAY_NOT_BLOCK)\n\t\t\treturn -ECHILD;\n\t\terror = gfs2_glock_nq_init(ip->i_gl, LM_ST_SHARED, LM_FLAG_ANY, &i_gh);\n\t\tif (error)\n\t\t\treturn error;\n\t\tunlock = 1;\n\t}\n\n\tif ((mask & MAY_WRITE) && IS_IMMUTABLE(inode))\n\t\terror = -EACCES;\n\telse\n\t\terror = generic_permission(inode, mask);\n\tif (unlock)\n\t\tgfs2_glock_dq_uninit(&i_gh);\n\n\treturn error;\n}",
          "includes": [
            "#include \"glops.h\"",
            "#include \"super.h\"",
            "#include \"util.h\"",
            "#include \"trans.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"inode.h\"",
            "#include \"glock.h\"",
            "#include \"xattr.h\"",
            "#include \"dir.h\"",
            "#include \"bmap.h\"",
            "#include \"acl.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/security.h>",
            "#include <linux/fiemap.h>",
            "#include <linux/crc32.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/xattr.h>",
            "#include <linux/mm.h>",
            "#include <linux/namei.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glops.h\"\n#include \"super.h\"\n#include \"util.h\"\n#include \"trans.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"xattr.h\"\n#include \"dir.h\"\n#include \"bmap.h\"\n#include \"acl.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <asm/uaccess.h>\n#include <linux/security.h>\n#include <linux/fiemap.h>\n#include <linux/crc32.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/posix_acl.h>\n#include <linux/xattr.h>\n#include <linux/mm.h>\n#include <linux/namei.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nint gfs2_permission(struct inode *inode, int mask)\n{\n\tstruct gfs2_inode *ip;\n\tstruct gfs2_holder i_gh;\n\tint error;\n\tint unlock = 0;\n\n\n\tip = GFS2_I(inode);\n\tif (gfs2_glock_is_locked_by_me(ip->i_gl) == NULL) {\n\t\tif (mask & MAY_NOT_BLOCK)\n\t\t\treturn -ECHILD;\n\t\terror = gfs2_glock_nq_init(ip->i_gl, LM_ST_SHARED, LM_FLAG_ANY, &i_gh);\n\t\tif (error)\n\t\t\treturn error;\n\t\tunlock = 1;\n\t}\n\n\tif ((mask & MAY_WRITE) && IS_IMMUTABLE(inode))\n\t\terror = -EACCES;\n\telse\n\t\terror = generic_permission(inode, mask);\n\tif (unlock)\n\t\tgfs2_glock_dq_uninit(&i_gh);\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "error"
          ],
          "line": 306
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gfs2_glock_nq_init",
          "args": [
            "dip->i_gl",
            "LM_ST_SHARED",
            "0",
            "&d_gh"
          ],
          "line": 304
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_glock_nq_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/glock.h",
          "lines": "204-230",
          "snippet": "extern __printf(2, 3)\nvoid gfs2_print_dbg(struct seq_file *seq, const char *fmt, ...);\n\n/**\n * gfs2_glock_nq_init - initialize a holder and enqueue it on a glock\n * @gl: the glock\n * @state: the state we're requesting\n * @flags: the modifier flags\n * @gh: the holder structure\n *\n * Returns: 0, GLR_*, or errno\n */\n\nstatic inline int gfs2_glock_nq_init(struct gfs2_glock *gl,\n\t\t\t\t     unsigned int state, int flags,\n\t\t\t\t     struct gfs2_holder *gh)\n{\n\tint error;\n\n\tgfs2_holder_init(gl, state, flags, gh);\n\n\terror = gfs2_glock_nq(gh);\n\tif (error)\n\t\tgfs2_holder_uninit(gh);\n\n\treturn error;\n}",
          "includes": [
            "#include \"incore.h\"",
            "#include <linux/parser.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"incore.h\"\n#include <linux/parser.h>\n#include <linux/sched.h>\n\nextern __printf(2, 3)\nvoid gfs2_print_dbg(struct seq_file *seq, const char *fmt, ...);\n\n/**\n * gfs2_glock_nq_init - initialize a holder and enqueue it on a glock\n * @gl: the glock\n * @state: the state we're requesting\n * @flags: the modifier flags\n * @gh: the holder structure\n *\n * Returns: 0, GLR_*, or errno\n */\n\nstatic inline int gfs2_glock_nq_init(struct gfs2_glock *gl,\n\t\t\t\t     unsigned int state, int flags,\n\t\t\t\t     struct gfs2_holder *gh)\n{\n\tint error;\n\n\tgfs2_holder_init(gl, state, flags, gh);\n\n\terror = gfs2_glock_nq(gh);\n\tif (error)\n\t\tgfs2_holder_uninit(gh);\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "gfs2_glock_is_locked_by_me",
          "args": [
            "dip->i_gl"
          ],
          "line": 303
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_glock_is_locked_by_me",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/glock.h",
          "lines": "138-157",
          "snippet": "static inline struct gfs2_holder *gfs2_glock_is_locked_by_me(struct gfs2_glock *gl)\n{\n\tstruct gfs2_holder *gh;\n\tstruct pid *pid;\n\n\t/* Look in glock's list of holders for one with current task as owner */\n\tspin_lock(&gl->gl_spin);\n\tpid = task_pid(current);\n\tlist_for_each_entry(gh, &gl->gl_holders, gh_list) {\n\t\tif (!test_bit(HIF_HOLDER, &gh->gh_iflags))\n\t\t\tbreak;\n\t\tif (gh->gh_owner_pid == pid)\n\t\t\tgoto out;\n\t}\n\tgh = NULL;\nout:\n\tspin_unlock(&gl->gl_spin);\n\n\treturn gh;\n}",
          "includes": [
            "#include \"incore.h\"",
            "#include <linux/parser.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"incore.h\"\n#include <linux/parser.h>\n#include <linux/sched.h>\n\nstatic inline struct gfs2_holder *gfs2_glock_is_locked_by_me(struct gfs2_glock *gl)\n{\n\tstruct gfs2_holder *gh;\n\tstruct pid *pid;\n\n\t/* Look in glock's list of holders for one with current task as owner */\n\tspin_lock(&gl->gl_spin);\n\tpid = task_pid(current);\n\tlist_for_each_entry(gh, &gl->gl_holders, gh_list) {\n\t\tif (!test_bit(HIF_HOLDER, &gh->gh_iflags))\n\t\t\tbreak;\n\t\tif (gh->gh_owner_pid == pid)\n\t\t\tgoto out;\n\t}\n\tgh = NULL;\nout:\n\tspin_unlock(&gl->gl_spin);\n\n\treturn gh;\n}"
        }
      },
      {
        "call_info": {
          "callee": "igrab",
          "args": [
            "dir"
          ],
          "line": 299
        },
        "resolved": true,
        "details": {
          "function_name": "igrab",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "1173-1189",
          "snippet": "struct inode *igrab(struct inode *inode)\n{\n\tspin_lock(&inode->i_lock);\n\tif (!(inode->i_state & (I_FREEING|I_WILL_FREE))) {\n\t\t__iget(inode);\n\t\tspin_unlock(&inode->i_lock);\n\t} else {\n\t\tspin_unlock(&inode->i_lock);\n\t\t/*\n\t\t * Handle the case where s_op->clear_inode is not been\n\t\t * called yet, and somebody is calling igrab\n\t\t * while the inode is getting freed.\n\t\t */\n\t\tinode = NULL;\n\t}\n\treturn inode;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nstruct inode *igrab(struct inode *inode)\n{\n\tspin_lock(&inode->i_lock);\n\tif (!(inode->i_state & (I_FREEING|I_WILL_FREE))) {\n\t\t__iget(inode);\n\t\tspin_unlock(&inode->i_lock);\n\t} else {\n\t\tspin_unlock(&inode->i_lock);\n\t\t/*\n\t\t * Handle the case where s_op->clear_inode is not been\n\t\t * called yet, and somebody is calling igrab\n\t\t * while the inode is getting freed.\n\t\t */\n\t\tinode = NULL;\n\t}\n\treturn inode;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcmp",
          "args": [
            "name->name",
            "\"..\"",
            "2"
          ],
          "line": 297
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcmp",
          "args": [
            "name->name",
            "\".\"",
            "1"
          ],
          "line": 296
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-ENAMETOOLONG"
          ],
          "line": 294
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GFS2_I",
          "args": [
            "dir"
          ],
          "line": 287
        },
        "resolved": true,
        "details": {
          "function_name": "GFS2_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/incore.h",
          "lines": "408-411",
          "snippet": "static inline struct gfs2_inode *GFS2_I(struct inode *inode)\n{\n\treturn container_of(inode, struct gfs2_inode, i_inode);\n}",
          "includes": [
            "#include <linux/lockref.h>",
            "#include <linux/percpu.h>",
            "#include <linux/ktime.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/completion.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/dlm.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/kobject.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/lockref.h>\n#include <linux/percpu.h>\n#include <linux/ktime.h>\n#include <linux/rbtree.h>\n#include <linux/completion.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/buffer_head.h>\n#include <linux/dlm.h>\n#include <linux/workqueue.h>\n#include <linux/kobject.h>\n#include <linux/fs.h>\n\nstatic inline struct gfs2_inode *GFS2_I(struct inode *inode)\n{\n\treturn container_of(inode, struct gfs2_inode, i_inode);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"glops.h\"\n#include \"super.h\"\n#include \"util.h\"\n#include \"trans.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"xattr.h\"\n#include \"dir.h\"\n#include \"bmap.h\"\n#include \"acl.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <asm/uaccess.h>\n#include <linux/security.h>\n#include <linux/fiemap.h>\n#include <linux/crc32.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/posix_acl.h>\n#include <linux/xattr.h>\n#include <linux/mm.h>\n#include <linux/namei.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nstruct inode *gfs2_lookupi(struct inode *dir, const struct qstr *name,\n\t\t\t   int is_root)\n{\n\tstruct super_block *sb = dir->i_sb;\n\tstruct gfs2_inode *dip = GFS2_I(dir);\n\tstruct gfs2_holder d_gh;\n\tint error = 0;\n\tstruct inode *inode = NULL;\n\tint unlock = 0;\n\n\tif (!name->len || name->len > GFS2_FNAMESIZE)\n\t\treturn ERR_PTR(-ENAMETOOLONG);\n\n\tif ((name->len == 1 && memcmp(name->name, \".\", 1) == 0) ||\n\t    (name->len == 2 && memcmp(name->name, \"..\", 2) == 0 &&\n\t     dir == sb->s_root->d_inode)) {\n\t\tigrab(dir);\n\t\treturn dir;\n\t}\n\n\tif (gfs2_glock_is_locked_by_me(dip->i_gl) == NULL) {\n\t\terror = gfs2_glock_nq_init(dip->i_gl, LM_ST_SHARED, 0, &d_gh);\n\t\tif (error)\n\t\t\treturn ERR_PTR(error);\n\t\tunlock = 1;\n\t}\n\n\tif (!is_root) {\n\t\terror = gfs2_permission(dir, MAY_EXEC);\n\t\tif (error)\n\t\t\tgoto out;\n\t}\n\n\tinode = gfs2_dir_search(dir, name, false);\n\tif (IS_ERR(inode))\n\t\terror = PTR_ERR(inode);\nout:\n\tif (unlock)\n\t\tgfs2_glock_dq_uninit(&d_gh);\n\tif (error == -ENOENT)\n\t\treturn NULL;\n\treturn inode ? inode : ERR_PTR(error);\n}"
  },
  {
    "function_name": "gfs2_lookup_simple",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/inode.c",
    "lines": "250-265",
    "snippet": "struct inode *gfs2_lookup_simple(struct inode *dip, const char *name)\n{\n\tstruct qstr qstr;\n\tstruct inode *inode;\n\tgfs2_str2qstr(&qstr, name);\n\tinode = gfs2_lookupi(dip, &qstr, 1);\n\t/* gfs2_lookupi has inconsistent callers: vfs\n\t * related routines expect NULL for no entry found,\n\t * gfs2_lookup_simple callers expect ENOENT\n\t * and do not check for NULL.\n\t */\n\tif (inode == NULL)\n\t\treturn ERR_PTR(-ENOENT);\n\telse\n\t\treturn inode;\n}",
    "includes": [
      "#include \"glops.h\"",
      "#include \"super.h\"",
      "#include \"util.h\"",
      "#include \"trans.h\"",
      "#include \"rgrp.h\"",
      "#include \"quota.h\"",
      "#include \"meta_io.h\"",
      "#include \"inode.h\"",
      "#include \"glock.h\"",
      "#include \"xattr.h\"",
      "#include \"dir.h\"",
      "#include \"bmap.h\"",
      "#include \"acl.h\"",
      "#include \"incore.h\"",
      "#include \"gfs2.h\"",
      "#include <asm/uaccess.h>",
      "#include <linux/security.h>",
      "#include <linux/fiemap.h>",
      "#include <linux/crc32.h>",
      "#include <linux/gfs2_ondisk.h>",
      "#include <linux/posix_acl.h>",
      "#include <linux/xattr.h>",
      "#include <linux/mm.h>",
      "#include <linux/namei.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/completion.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-ENOENT"
          ],
          "line": 262
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gfs2_lookupi",
          "args": [
            "dip",
            "&qstr",
            "1"
          ],
          "line": 255
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_lookupi",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/inode.c",
          "lines": "283-325",
          "snippet": "struct inode *gfs2_lookupi(struct inode *dir, const struct qstr *name,\n\t\t\t   int is_root)\n{\n\tstruct super_block *sb = dir->i_sb;\n\tstruct gfs2_inode *dip = GFS2_I(dir);\n\tstruct gfs2_holder d_gh;\n\tint error = 0;\n\tstruct inode *inode = NULL;\n\tint unlock = 0;\n\n\tif (!name->len || name->len > GFS2_FNAMESIZE)\n\t\treturn ERR_PTR(-ENAMETOOLONG);\n\n\tif ((name->len == 1 && memcmp(name->name, \".\", 1) == 0) ||\n\t    (name->len == 2 && memcmp(name->name, \"..\", 2) == 0 &&\n\t     dir == sb->s_root->d_inode)) {\n\t\tigrab(dir);\n\t\treturn dir;\n\t}\n\n\tif (gfs2_glock_is_locked_by_me(dip->i_gl) == NULL) {\n\t\terror = gfs2_glock_nq_init(dip->i_gl, LM_ST_SHARED, 0, &d_gh);\n\t\tif (error)\n\t\t\treturn ERR_PTR(error);\n\t\tunlock = 1;\n\t}\n\n\tif (!is_root) {\n\t\terror = gfs2_permission(dir, MAY_EXEC);\n\t\tif (error)\n\t\t\tgoto out;\n\t}\n\n\tinode = gfs2_dir_search(dir, name, false);\n\tif (IS_ERR(inode))\n\t\terror = PTR_ERR(inode);\nout:\n\tif (unlock)\n\t\tgfs2_glock_dq_uninit(&d_gh);\n\tif (error == -ENOENT)\n\t\treturn NULL;\n\treturn inode ? inode : ERR_PTR(error);\n}",
          "includes": [
            "#include \"glops.h\"",
            "#include \"super.h\"",
            "#include \"util.h\"",
            "#include \"trans.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"inode.h\"",
            "#include \"glock.h\"",
            "#include \"xattr.h\"",
            "#include \"dir.h\"",
            "#include \"bmap.h\"",
            "#include \"acl.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/security.h>",
            "#include <linux/fiemap.h>",
            "#include <linux/crc32.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/xattr.h>",
            "#include <linux/mm.h>",
            "#include <linux/namei.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glops.h\"\n#include \"super.h\"\n#include \"util.h\"\n#include \"trans.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"xattr.h\"\n#include \"dir.h\"\n#include \"bmap.h\"\n#include \"acl.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <asm/uaccess.h>\n#include <linux/security.h>\n#include <linux/fiemap.h>\n#include <linux/crc32.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/posix_acl.h>\n#include <linux/xattr.h>\n#include <linux/mm.h>\n#include <linux/namei.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nstruct inode *gfs2_lookupi(struct inode *dir, const struct qstr *name,\n\t\t\t   int is_root)\n{\n\tstruct super_block *sb = dir->i_sb;\n\tstruct gfs2_inode *dip = GFS2_I(dir);\n\tstruct gfs2_holder d_gh;\n\tint error = 0;\n\tstruct inode *inode = NULL;\n\tint unlock = 0;\n\n\tif (!name->len || name->len > GFS2_FNAMESIZE)\n\t\treturn ERR_PTR(-ENAMETOOLONG);\n\n\tif ((name->len == 1 && memcmp(name->name, \".\", 1) == 0) ||\n\t    (name->len == 2 && memcmp(name->name, \"..\", 2) == 0 &&\n\t     dir == sb->s_root->d_inode)) {\n\t\tigrab(dir);\n\t\treturn dir;\n\t}\n\n\tif (gfs2_glock_is_locked_by_me(dip->i_gl) == NULL) {\n\t\terror = gfs2_glock_nq_init(dip->i_gl, LM_ST_SHARED, 0, &d_gh);\n\t\tif (error)\n\t\t\treturn ERR_PTR(error);\n\t\tunlock = 1;\n\t}\n\n\tif (!is_root) {\n\t\terror = gfs2_permission(dir, MAY_EXEC);\n\t\tif (error)\n\t\t\tgoto out;\n\t}\n\n\tinode = gfs2_dir_search(dir, name, false);\n\tif (IS_ERR(inode))\n\t\terror = PTR_ERR(inode);\nout:\n\tif (unlock)\n\t\tgfs2_glock_dq_uninit(&d_gh);\n\tif (error == -ENOENT)\n\t\treturn NULL;\n\treturn inode ? inode : ERR_PTR(error);\n}"
        }
      },
      {
        "call_info": {
          "callee": "gfs2_str2qstr",
          "args": [
            "&qstr",
            "name"
          ],
          "line": 254
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_str2qstr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/dir.h",
          "lines": "63-68",
          "snippet": "static inline void gfs2_str2qstr(struct qstr *name, const char *fname)\n{\n\tname->name = fname;\n\tname->len = strlen(fname);\n\tname->hash = gfs2_disk_hash(name->name, name->len);\n}",
          "includes": [
            "#include <linux/crc32.h>",
            "#include <linux/dcache.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/crc32.h>\n#include <linux/dcache.h>\n\nstatic inline void gfs2_str2qstr(struct qstr *name, const char *fname)\n{\n\tname->name = fname;\n\tname->len = strlen(fname);\n\tname->hash = gfs2_disk_hash(name->name, name->len);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"glops.h\"\n#include \"super.h\"\n#include \"util.h\"\n#include \"trans.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"xattr.h\"\n#include \"dir.h\"\n#include \"bmap.h\"\n#include \"acl.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <asm/uaccess.h>\n#include <linux/security.h>\n#include <linux/fiemap.h>\n#include <linux/crc32.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/posix_acl.h>\n#include <linux/xattr.h>\n#include <linux/mm.h>\n#include <linux/namei.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nstruct inode *gfs2_lookup_simple(struct inode *dip, const char *name)\n{\n\tstruct qstr qstr;\n\tstruct inode *inode;\n\tgfs2_str2qstr(&qstr, name);\n\tinode = gfs2_lookupi(dip, &qstr, 1);\n\t/* gfs2_lookupi has inconsistent callers: vfs\n\t * related routines expect NULL for no entry found,\n\t * gfs2_lookup_simple callers expect ENOENT\n\t * and do not check for NULL.\n\t */\n\tif (inode == NULL)\n\t\treturn ERR_PTR(-ENOENT);\n\telse\n\t\treturn inode;\n}"
  },
  {
    "function_name": "gfs2_lookup_by_inum",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/inode.c",
    "lines": "206-247",
    "snippet": "struct inode *gfs2_lookup_by_inum(struct gfs2_sbd *sdp, u64 no_addr,\n\t\t\t\t  u64 *no_formal_ino, unsigned int blktype)\n{\n\tstruct super_block *sb = sdp->sd_vfs;\n\tstruct gfs2_holder i_gh;\n\tstruct inode *inode = NULL;\n\tint error;\n\n\t/* Must not read in block until block type is verified */\n\terror = gfs2_glock_nq_num(sdp, no_addr, &gfs2_inode_glops,\n\t\t\t\t  LM_ST_EXCLUSIVE, GL_SKIP, &i_gh);\n\tif (error)\n\t\treturn ERR_PTR(error);\n\n\terror = gfs2_check_blk_type(sdp, no_addr, blktype);\n\tif (error)\n\t\tgoto fail;\n\n\tinode = gfs2_inode_lookup(sb, DT_UNKNOWN, no_addr, 0, 1);\n\tif (IS_ERR(inode))\n\t\tgoto fail;\n\n\t/* Two extra checks for NFS only */\n\tif (no_formal_ino) {\n\t\terror = -ESTALE;\n\t\tif (GFS2_I(inode)->i_no_formal_ino != *no_formal_ino)\n\t\t\tgoto fail_iput;\n\n\t\terror = -EIO;\n\t\tif (GFS2_I(inode)->i_diskflags & GFS2_DIF_SYSTEM)\n\t\t\tgoto fail_iput;\n\n\t\terror = 0;\n\t}\n\nfail:\n\tgfs2_glock_dq_uninit(&i_gh);\n\treturn error ? ERR_PTR(error) : inode;\nfail_iput:\n\tiput(inode);\n\tgoto fail;\n}",
    "includes": [
      "#include \"glops.h\"",
      "#include \"super.h\"",
      "#include \"util.h\"",
      "#include \"trans.h\"",
      "#include \"rgrp.h\"",
      "#include \"quota.h\"",
      "#include \"meta_io.h\"",
      "#include \"inode.h\"",
      "#include \"glock.h\"",
      "#include \"xattr.h\"",
      "#include \"dir.h\"",
      "#include \"bmap.h\"",
      "#include \"acl.h\"",
      "#include \"incore.h\"",
      "#include \"gfs2.h\"",
      "#include <asm/uaccess.h>",
      "#include <linux/security.h>",
      "#include <linux/fiemap.h>",
      "#include <linux/crc32.h>",
      "#include <linux/gfs2_ondisk.h>",
      "#include <linux/posix_acl.h>",
      "#include <linux/xattr.h>",
      "#include <linux/mm.h>",
      "#include <linux/namei.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/completion.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "iput",
          "args": [
            "inode"
          ],
          "line": 245
        },
        "resolved": true,
        "details": {
          "function_name": "iput",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "1471-1488",
          "snippet": "void iput(struct inode *inode)\n{\n\tif (!inode)\n\t\treturn;\n\tBUG_ON(inode->i_state & I_CLEAR);\nretry:\n\tif (atomic_dec_and_lock(&inode->i_count, &inode->i_lock)) {\n\t\tif (inode->i_nlink && (inode->i_state & I_DIRTY_TIME)) {\n\t\t\tatomic_inc(&inode->i_count);\n\t\t\tinode->i_state &= ~I_DIRTY_TIME;\n\t\t\tspin_unlock(&inode->i_lock);\n\t\t\ttrace_writeback_lazytime_iput(inode);\n\t\t\tmark_inode_dirty_sync(inode);\n\t\t\tgoto retry;\n\t\t}\n\t\tiput_final(inode);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid iput(struct inode *inode)\n{\n\tif (!inode)\n\t\treturn;\n\tBUG_ON(inode->i_state & I_CLEAR);\nretry:\n\tif (atomic_dec_and_lock(&inode->i_count, &inode->i_lock)) {\n\t\tif (inode->i_nlink && (inode->i_state & I_DIRTY_TIME)) {\n\t\t\tatomic_inc(&inode->i_count);\n\t\t\tinode->i_state &= ~I_DIRTY_TIME;\n\t\t\tspin_unlock(&inode->i_lock);\n\t\t\ttrace_writeback_lazytime_iput(inode);\n\t\t\tmark_inode_dirty_sync(inode);\n\t\t\tgoto retry;\n\t\t}\n\t\tiput_final(inode);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "error"
          ],
          "line": 243
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gfs2_glock_dq_uninit",
          "args": [
            "&i_gh"
          ],
          "line": 242
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_glock_dq_uninit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/glock.c",
          "lines": "1110-1114",
          "snippet": "void gfs2_glock_dq_uninit(struct gfs2_holder *gh)\n{\n\tgfs2_glock_dq(gh);\n\tgfs2_holder_uninit(gh);\n}",
          "includes": [
            "#include \"trace_gfs2.h\"",
            "#include \"bmap.h\"",
            "#include \"util.h\"",
            "#include \"super.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"lops.h\"",
            "#include \"inode.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/lockref.h>",
            "#include <linux/list_sort.h>",
            "#include <linux/percpu.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/seq_file.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/module.h>",
            "#include <linux/wait.h>",
            "#include <linux/list.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/jhash.h>",
            "#include <linux/sort.h>",
            "#include <linux/delay.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"bmap.h\"\n#include \"util.h\"\n#include \"super.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"lops.h\"\n#include \"inode.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/lockref.h>\n#include <linux/list_sort.h>\n#include <linux/percpu.h>\n#include <linux/bit_spinlock.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/jiffies.h>\n#include <linux/workqueue.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <asm/uaccess.h>\n#include <linux/module.h>\n#include <linux/wait.h>\n#include <linux/list.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/kallsyms.h>\n#include <linux/jhash.h>\n#include <linux/sort.h>\n#include <linux/delay.h>\n#include <linux/buffer_head.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nvoid gfs2_glock_dq_uninit(struct gfs2_holder *gh)\n{\n\tgfs2_glock_dq(gh);\n\tgfs2_holder_uninit(gh);\n}"
        }
      },
      {
        "call_info": {
          "callee": "GFS2_I",
          "args": [
            "inode"
          ],
          "line": 235
        },
        "resolved": true,
        "details": {
          "function_name": "GFS2_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/incore.h",
          "lines": "408-411",
          "snippet": "static inline struct gfs2_inode *GFS2_I(struct inode *inode)\n{\n\treturn container_of(inode, struct gfs2_inode, i_inode);\n}",
          "includes": [
            "#include <linux/lockref.h>",
            "#include <linux/percpu.h>",
            "#include <linux/ktime.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/completion.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/dlm.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/kobject.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/lockref.h>\n#include <linux/percpu.h>\n#include <linux/ktime.h>\n#include <linux/rbtree.h>\n#include <linux/completion.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/buffer_head.h>\n#include <linux/dlm.h>\n#include <linux/workqueue.h>\n#include <linux/kobject.h>\n#include <linux/fs.h>\n\nstatic inline struct gfs2_inode *GFS2_I(struct inode *inode)\n{\n\treturn container_of(inode, struct gfs2_inode, i_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "inode"
          ],
          "line": 225
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gfs2_inode_lookup",
          "args": [
            "sb",
            "DT_UNKNOWN",
            "no_addr",
            "0",
            "1"
          ],
          "line": 224
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_inode_lookup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/inode.c",
          "lines": "140-204",
          "snippet": "struct inode *gfs2_inode_lookup(struct super_block *sb, unsigned int type,\n\t\t\t\tu64 no_addr, u64 no_formal_ino, int non_block)\n{\n\tstruct inode *inode;\n\tstruct gfs2_inode *ip;\n\tstruct gfs2_glock *io_gl = NULL;\n\tint error;\n\n\tinode = gfs2_iget(sb, no_addr, non_block);\n\tip = GFS2_I(inode);\n\n\tif (!inode)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tif (inode->i_state & I_NEW) {\n\t\tstruct gfs2_sbd *sdp = GFS2_SB(inode);\n\t\tip->i_no_formal_ino = no_formal_ino;\n\n\t\terror = gfs2_glock_get(sdp, no_addr, &gfs2_inode_glops, CREATE, &ip->i_gl);\n\t\tif (unlikely(error))\n\t\t\tgoto fail;\n\t\tip->i_gl->gl_object = ip;\n\n\t\terror = gfs2_glock_get(sdp, no_addr, &gfs2_iopen_glops, CREATE, &io_gl);\n\t\tif (unlikely(error))\n\t\t\tgoto fail_put;\n\n\t\tset_bit(GIF_INVALID, &ip->i_flags);\n\t\terror = gfs2_glock_nq_init(io_gl, LM_ST_SHARED, GL_EXACT, &ip->i_iopen_gh);\n\t\tif (unlikely(error))\n\t\t\tgoto fail_iopen;\n\n\t\tip->i_iopen_gh.gh_gl->gl_object = ip;\n\t\tgfs2_glock_put(io_gl);\n\t\tio_gl = NULL;\n\n\t\tif (type == DT_UNKNOWN) {\n\t\t\t/* Inode glock must be locked already */\n\t\t\terror = gfs2_inode_refresh(GFS2_I(inode));\n\t\t\tif (error)\n\t\t\t\tgoto fail_refresh;\n\t\t} else {\n\t\t\tinode->i_mode = DT2IF(type);\n\t\t}\n\n\t\tgfs2_set_iop(inode);\n\t\tunlock_new_inode(inode);\n\t}\n\n\treturn inode;\n\nfail_refresh:\n\tip->i_iopen_gh.gh_flags |= GL_NOCACHE;\n\tip->i_iopen_gh.gh_gl->gl_object = NULL;\n\tgfs2_glock_dq_uninit(&ip->i_iopen_gh);\nfail_iopen:\n\tif (io_gl)\n\t\tgfs2_glock_put(io_gl);\nfail_put:\n\tip->i_gl->gl_object = NULL;\n\tgfs2_glock_put(ip->i_gl);\nfail:\n\tiget_failed(inode);\n\treturn ERR_PTR(error);\n}",
          "includes": [
            "#include \"glops.h\"",
            "#include \"super.h\"",
            "#include \"util.h\"",
            "#include \"trans.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"inode.h\"",
            "#include \"glock.h\"",
            "#include \"xattr.h\"",
            "#include \"dir.h\"",
            "#include \"bmap.h\"",
            "#include \"acl.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/security.h>",
            "#include <linux/fiemap.h>",
            "#include <linux/crc32.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/xattr.h>",
            "#include <linux/mm.h>",
            "#include <linux/namei.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glops.h\"\n#include \"super.h\"\n#include \"util.h\"\n#include \"trans.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"xattr.h\"\n#include \"dir.h\"\n#include \"bmap.h\"\n#include \"acl.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <asm/uaccess.h>\n#include <linux/security.h>\n#include <linux/fiemap.h>\n#include <linux/crc32.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/posix_acl.h>\n#include <linux/xattr.h>\n#include <linux/mm.h>\n#include <linux/namei.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nstruct inode *gfs2_inode_lookup(struct super_block *sb, unsigned int type,\n\t\t\t\tu64 no_addr, u64 no_formal_ino, int non_block)\n{\n\tstruct inode *inode;\n\tstruct gfs2_inode *ip;\n\tstruct gfs2_glock *io_gl = NULL;\n\tint error;\n\n\tinode = gfs2_iget(sb, no_addr, non_block);\n\tip = GFS2_I(inode);\n\n\tif (!inode)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tif (inode->i_state & I_NEW) {\n\t\tstruct gfs2_sbd *sdp = GFS2_SB(inode);\n\t\tip->i_no_formal_ino = no_formal_ino;\n\n\t\terror = gfs2_glock_get(sdp, no_addr, &gfs2_inode_glops, CREATE, &ip->i_gl);\n\t\tif (unlikely(error))\n\t\t\tgoto fail;\n\t\tip->i_gl->gl_object = ip;\n\n\t\terror = gfs2_glock_get(sdp, no_addr, &gfs2_iopen_glops, CREATE, &io_gl);\n\t\tif (unlikely(error))\n\t\t\tgoto fail_put;\n\n\t\tset_bit(GIF_INVALID, &ip->i_flags);\n\t\terror = gfs2_glock_nq_init(io_gl, LM_ST_SHARED, GL_EXACT, &ip->i_iopen_gh);\n\t\tif (unlikely(error))\n\t\t\tgoto fail_iopen;\n\n\t\tip->i_iopen_gh.gh_gl->gl_object = ip;\n\t\tgfs2_glock_put(io_gl);\n\t\tio_gl = NULL;\n\n\t\tif (type == DT_UNKNOWN) {\n\t\t\t/* Inode glock must be locked already */\n\t\t\terror = gfs2_inode_refresh(GFS2_I(inode));\n\t\t\tif (error)\n\t\t\t\tgoto fail_refresh;\n\t\t} else {\n\t\t\tinode->i_mode = DT2IF(type);\n\t\t}\n\n\t\tgfs2_set_iop(inode);\n\t\tunlock_new_inode(inode);\n\t}\n\n\treturn inode;\n\nfail_refresh:\n\tip->i_iopen_gh.gh_flags |= GL_NOCACHE;\n\tip->i_iopen_gh.gh_gl->gl_object = NULL;\n\tgfs2_glock_dq_uninit(&ip->i_iopen_gh);\nfail_iopen:\n\tif (io_gl)\n\t\tgfs2_glock_put(io_gl);\nfail_put:\n\tip->i_gl->gl_object = NULL;\n\tgfs2_glock_put(ip->i_gl);\nfail:\n\tiget_failed(inode);\n\treturn ERR_PTR(error);\n}"
        }
      },
      {
        "call_info": {
          "callee": "gfs2_check_blk_type",
          "args": [
            "sdp",
            "no_addr",
            "blktype"
          ],
          "line": 220
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_check_blk_type",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/rgrp.c",
          "lines": "2493-2513",
          "snippet": "int gfs2_check_blk_type(struct gfs2_sbd *sdp, u64 no_addr, unsigned int type)\n{\n\tstruct gfs2_rgrpd *rgd;\n\tstruct gfs2_holder rgd_gh;\n\tint error = -EINVAL;\n\n\trgd = gfs2_blk2rgrpd(sdp, no_addr, 1);\n\tif (!rgd)\n\t\tgoto fail;\n\n\terror = gfs2_glock_nq_init(rgd->rd_gl, LM_ST_SHARED, 0, &rgd_gh);\n\tif (error)\n\t\tgoto fail;\n\n\tif (gfs2_get_block_type(rgd, no_addr) != type)\n\t\terror = -ESTALE;\n\n\tgfs2_glock_dq_uninit(&rgd_gh);\nfail:\n\treturn error;\n}",
          "includes": [
            "#include \"trace_gfs2.h\"",
            "#include \"inode.h\"",
            "#include \"log.h\"",
            "#include \"util.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"lops.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/random.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/fs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"inode.h\"\n#include \"log.h\"\n#include \"util.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"lops.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/random.h>\n#include <linux/rbtree.h>\n#include <linux/blkdev.h>\n#include <linux/prefetch.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/fs.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nint gfs2_check_blk_type(struct gfs2_sbd *sdp, u64 no_addr, unsigned int type)\n{\n\tstruct gfs2_rgrpd *rgd;\n\tstruct gfs2_holder rgd_gh;\n\tint error = -EINVAL;\n\n\trgd = gfs2_blk2rgrpd(sdp, no_addr, 1);\n\tif (!rgd)\n\t\tgoto fail;\n\n\terror = gfs2_glock_nq_init(rgd->rd_gl, LM_ST_SHARED, 0, &rgd_gh);\n\tif (error)\n\t\tgoto fail;\n\n\tif (gfs2_get_block_type(rgd, no_addr) != type)\n\t\terror = -ESTALE;\n\n\tgfs2_glock_dq_uninit(&rgd_gh);\nfail:\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "error"
          ],
          "line": 218
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gfs2_glock_nq_num",
          "args": [
            "sdp",
            "no_addr",
            "&gfs2_inode_glops",
            "LM_ST_EXCLUSIVE",
            "GL_SKIP",
            "&i_gh"
          ],
          "line": 215
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_glock_nq_num",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/glock.c",
          "lines": "1128-1142",
          "snippet": "int gfs2_glock_nq_num(struct gfs2_sbd *sdp, u64 number,\n\t\t      const struct gfs2_glock_operations *glops,\n\t\t      unsigned int state, int flags, struct gfs2_holder *gh)\n{\n\tstruct gfs2_glock *gl;\n\tint error;\n\n\terror = gfs2_glock_get(sdp, number, glops, CREATE, &gl);\n\tif (!error) {\n\t\terror = gfs2_glock_nq_init(gl, state, flags, gh);\n\t\tgfs2_glock_put(gl);\n\t}\n\n\treturn error;\n}",
          "includes": [
            "#include \"trace_gfs2.h\"",
            "#include \"bmap.h\"",
            "#include \"util.h\"",
            "#include \"super.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"lops.h\"",
            "#include \"inode.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/lockref.h>",
            "#include <linux/list_sort.h>",
            "#include <linux/percpu.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/seq_file.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/module.h>",
            "#include <linux/wait.h>",
            "#include <linux/list.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/jhash.h>",
            "#include <linux/sort.h>",
            "#include <linux/delay.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"bmap.h\"\n#include \"util.h\"\n#include \"super.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"lops.h\"\n#include \"inode.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/lockref.h>\n#include <linux/list_sort.h>\n#include <linux/percpu.h>\n#include <linux/bit_spinlock.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/jiffies.h>\n#include <linux/workqueue.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <asm/uaccess.h>\n#include <linux/module.h>\n#include <linux/wait.h>\n#include <linux/list.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/kallsyms.h>\n#include <linux/jhash.h>\n#include <linux/sort.h>\n#include <linux/delay.h>\n#include <linux/buffer_head.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nint gfs2_glock_nq_num(struct gfs2_sbd *sdp, u64 number,\n\t\t      const struct gfs2_glock_operations *glops,\n\t\t      unsigned int state, int flags, struct gfs2_holder *gh)\n{\n\tstruct gfs2_glock *gl;\n\tint error;\n\n\terror = gfs2_glock_get(sdp, number, glops, CREATE, &gl);\n\tif (!error) {\n\t\terror = gfs2_glock_nq_init(gl, state, flags, gh);\n\t\tgfs2_glock_put(gl);\n\t}\n\n\treturn error;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"glops.h\"\n#include \"super.h\"\n#include \"util.h\"\n#include \"trans.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"xattr.h\"\n#include \"dir.h\"\n#include \"bmap.h\"\n#include \"acl.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <asm/uaccess.h>\n#include <linux/security.h>\n#include <linux/fiemap.h>\n#include <linux/crc32.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/posix_acl.h>\n#include <linux/xattr.h>\n#include <linux/mm.h>\n#include <linux/namei.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nstruct inode *gfs2_lookup_by_inum(struct gfs2_sbd *sdp, u64 no_addr,\n\t\t\t\t  u64 *no_formal_ino, unsigned int blktype)\n{\n\tstruct super_block *sb = sdp->sd_vfs;\n\tstruct gfs2_holder i_gh;\n\tstruct inode *inode = NULL;\n\tint error;\n\n\t/* Must not read in block until block type is verified */\n\terror = gfs2_glock_nq_num(sdp, no_addr, &gfs2_inode_glops,\n\t\t\t\t  LM_ST_EXCLUSIVE, GL_SKIP, &i_gh);\n\tif (error)\n\t\treturn ERR_PTR(error);\n\n\terror = gfs2_check_blk_type(sdp, no_addr, blktype);\n\tif (error)\n\t\tgoto fail;\n\n\tinode = gfs2_inode_lookup(sb, DT_UNKNOWN, no_addr, 0, 1);\n\tif (IS_ERR(inode))\n\t\tgoto fail;\n\n\t/* Two extra checks for NFS only */\n\tif (no_formal_ino) {\n\t\terror = -ESTALE;\n\t\tif (GFS2_I(inode)->i_no_formal_ino != *no_formal_ino)\n\t\t\tgoto fail_iput;\n\n\t\terror = -EIO;\n\t\tif (GFS2_I(inode)->i_diskflags & GFS2_DIF_SYSTEM)\n\t\t\tgoto fail_iput;\n\n\t\terror = 0;\n\t}\n\nfail:\n\tgfs2_glock_dq_uninit(&i_gh);\n\treturn error ? ERR_PTR(error) : inode;\nfail_iput:\n\tiput(inode);\n\tgoto fail;\n}"
  },
  {
    "function_name": "gfs2_inode_lookup",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/inode.c",
    "lines": "140-204",
    "snippet": "struct inode *gfs2_inode_lookup(struct super_block *sb, unsigned int type,\n\t\t\t\tu64 no_addr, u64 no_formal_ino, int non_block)\n{\n\tstruct inode *inode;\n\tstruct gfs2_inode *ip;\n\tstruct gfs2_glock *io_gl = NULL;\n\tint error;\n\n\tinode = gfs2_iget(sb, no_addr, non_block);\n\tip = GFS2_I(inode);\n\n\tif (!inode)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tif (inode->i_state & I_NEW) {\n\t\tstruct gfs2_sbd *sdp = GFS2_SB(inode);\n\t\tip->i_no_formal_ino = no_formal_ino;\n\n\t\terror = gfs2_glock_get(sdp, no_addr, &gfs2_inode_glops, CREATE, &ip->i_gl);\n\t\tif (unlikely(error))\n\t\t\tgoto fail;\n\t\tip->i_gl->gl_object = ip;\n\n\t\terror = gfs2_glock_get(sdp, no_addr, &gfs2_iopen_glops, CREATE, &io_gl);\n\t\tif (unlikely(error))\n\t\t\tgoto fail_put;\n\n\t\tset_bit(GIF_INVALID, &ip->i_flags);\n\t\terror = gfs2_glock_nq_init(io_gl, LM_ST_SHARED, GL_EXACT, &ip->i_iopen_gh);\n\t\tif (unlikely(error))\n\t\t\tgoto fail_iopen;\n\n\t\tip->i_iopen_gh.gh_gl->gl_object = ip;\n\t\tgfs2_glock_put(io_gl);\n\t\tio_gl = NULL;\n\n\t\tif (type == DT_UNKNOWN) {\n\t\t\t/* Inode glock must be locked already */\n\t\t\terror = gfs2_inode_refresh(GFS2_I(inode));\n\t\t\tif (error)\n\t\t\t\tgoto fail_refresh;\n\t\t} else {\n\t\t\tinode->i_mode = DT2IF(type);\n\t\t}\n\n\t\tgfs2_set_iop(inode);\n\t\tunlock_new_inode(inode);\n\t}\n\n\treturn inode;\n\nfail_refresh:\n\tip->i_iopen_gh.gh_flags |= GL_NOCACHE;\n\tip->i_iopen_gh.gh_gl->gl_object = NULL;\n\tgfs2_glock_dq_uninit(&ip->i_iopen_gh);\nfail_iopen:\n\tif (io_gl)\n\t\tgfs2_glock_put(io_gl);\nfail_put:\n\tip->i_gl->gl_object = NULL;\n\tgfs2_glock_put(ip->i_gl);\nfail:\n\tiget_failed(inode);\n\treturn ERR_PTR(error);\n}",
    "includes": [
      "#include \"glops.h\"",
      "#include \"super.h\"",
      "#include \"util.h\"",
      "#include \"trans.h\"",
      "#include \"rgrp.h\"",
      "#include \"quota.h\"",
      "#include \"meta_io.h\"",
      "#include \"inode.h\"",
      "#include \"glock.h\"",
      "#include \"xattr.h\"",
      "#include \"dir.h\"",
      "#include \"bmap.h\"",
      "#include \"acl.h\"",
      "#include \"incore.h\"",
      "#include \"gfs2.h\"",
      "#include <asm/uaccess.h>",
      "#include <linux/security.h>",
      "#include <linux/fiemap.h>",
      "#include <linux/crc32.h>",
      "#include <linux/gfs2_ondisk.h>",
      "#include <linux/posix_acl.h>",
      "#include <linux/xattr.h>",
      "#include <linux/mm.h>",
      "#include <linux/namei.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/completion.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "error"
          ],
          "line": 203
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "iget_failed",
          "args": [
            "inode"
          ],
          "line": 202
        },
        "resolved": true,
        "details": {
          "function_name": "iget_failed",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/bad_inode.c",
          "lines": "208-213",
          "snippet": "void iget_failed(struct inode *inode)\n{\n\tmake_bad_inode(inode);\n\tunlock_new_inode(inode);\n\tiput(inode);\n}",
          "includes": [
            "#include <linux/poll.h>",
            "#include <linux/namei.h>",
            "#include <linux/time.h>",
            "#include <linux/stat.h>",
            "#include <linux/export.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/poll.h>\n#include <linux/namei.h>\n#include <linux/time.h>\n#include <linux/stat.h>\n#include <linux/export.h>\n#include <linux/fs.h>\n\nvoid iget_failed(struct inode *inode)\n{\n\tmake_bad_inode(inode);\n\tunlock_new_inode(inode);\n\tiput(inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "gfs2_glock_put",
          "args": [
            "ip->i_gl"
          ],
          "line": 200
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_glock_put",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/glock.c",
          "lines": "193-212",
          "snippet": "void gfs2_glock_put(struct gfs2_glock *gl)\n{\n\tstruct gfs2_sbd *sdp = gl->gl_sbd;\n\tstruct address_space *mapping = gfs2_glock2aspace(gl);\n\n\tif (lockref_put_or_lock(&gl->gl_lockref))\n\t\treturn;\n\n\tlockref_mark_dead(&gl->gl_lockref);\n\n\tgfs2_glock_remove_from_lru(gl);\n\tspin_unlock(&gl->gl_lockref.lock);\n\tspin_lock_bucket(gl->gl_hash);\n\thlist_bl_del_rcu(&gl->gl_list);\n\tspin_unlock_bucket(gl->gl_hash);\n\tGLOCK_BUG_ON(gl, !list_empty(&gl->gl_holders));\n\tGLOCK_BUG_ON(gl, mapping && mapping->nrpages);\n\ttrace_gfs2_glock_put(gl);\n\tsdp->sd_lockstruct.ls_ops->lm_put_lock(gl);\n}",
          "includes": [
            "#include \"trace_gfs2.h\"",
            "#include \"bmap.h\"",
            "#include \"util.h\"",
            "#include \"super.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"lops.h\"",
            "#include \"inode.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/lockref.h>",
            "#include <linux/list_sort.h>",
            "#include <linux/percpu.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/seq_file.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/module.h>",
            "#include <linux/wait.h>",
            "#include <linux/list.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/jhash.h>",
            "#include <linux/sort.h>",
            "#include <linux/delay.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"bmap.h\"\n#include \"util.h\"\n#include \"super.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"lops.h\"\n#include \"inode.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/lockref.h>\n#include <linux/list_sort.h>\n#include <linux/percpu.h>\n#include <linux/bit_spinlock.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/jiffies.h>\n#include <linux/workqueue.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <asm/uaccess.h>\n#include <linux/module.h>\n#include <linux/wait.h>\n#include <linux/list.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/kallsyms.h>\n#include <linux/jhash.h>\n#include <linux/sort.h>\n#include <linux/delay.h>\n#include <linux/buffer_head.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nvoid gfs2_glock_put(struct gfs2_glock *gl)\n{\n\tstruct gfs2_sbd *sdp = gl->gl_sbd;\n\tstruct address_space *mapping = gfs2_glock2aspace(gl);\n\n\tif (lockref_put_or_lock(&gl->gl_lockref))\n\t\treturn;\n\n\tlockref_mark_dead(&gl->gl_lockref);\n\n\tgfs2_glock_remove_from_lru(gl);\n\tspin_unlock(&gl->gl_lockref.lock);\n\tspin_lock_bucket(gl->gl_hash);\n\thlist_bl_del_rcu(&gl->gl_list);\n\tspin_unlock_bucket(gl->gl_hash);\n\tGLOCK_BUG_ON(gl, !list_empty(&gl->gl_holders));\n\tGLOCK_BUG_ON(gl, mapping && mapping->nrpages);\n\ttrace_gfs2_glock_put(gl);\n\tsdp->sd_lockstruct.ls_ops->lm_put_lock(gl);\n}"
        }
      },
      {
        "call_info": {
          "callee": "gfs2_glock_dq_uninit",
          "args": [
            "&ip->i_iopen_gh"
          ],
          "line": 194
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_glock_dq_uninit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/glock.c",
          "lines": "1110-1114",
          "snippet": "void gfs2_glock_dq_uninit(struct gfs2_holder *gh)\n{\n\tgfs2_glock_dq(gh);\n\tgfs2_holder_uninit(gh);\n}",
          "includes": [
            "#include \"trace_gfs2.h\"",
            "#include \"bmap.h\"",
            "#include \"util.h\"",
            "#include \"super.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"lops.h\"",
            "#include \"inode.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/lockref.h>",
            "#include <linux/list_sort.h>",
            "#include <linux/percpu.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/seq_file.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/module.h>",
            "#include <linux/wait.h>",
            "#include <linux/list.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/jhash.h>",
            "#include <linux/sort.h>",
            "#include <linux/delay.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"bmap.h\"\n#include \"util.h\"\n#include \"super.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"lops.h\"\n#include \"inode.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/lockref.h>\n#include <linux/list_sort.h>\n#include <linux/percpu.h>\n#include <linux/bit_spinlock.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/jiffies.h>\n#include <linux/workqueue.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <asm/uaccess.h>\n#include <linux/module.h>\n#include <linux/wait.h>\n#include <linux/list.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/kallsyms.h>\n#include <linux/jhash.h>\n#include <linux/sort.h>\n#include <linux/delay.h>\n#include <linux/buffer_head.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nvoid gfs2_glock_dq_uninit(struct gfs2_holder *gh)\n{\n\tgfs2_glock_dq(gh);\n\tgfs2_holder_uninit(gh);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlock_new_inode",
          "args": [
            "inode"
          ],
          "line": 186
        },
        "resolved": true,
        "details": {
          "function_name": "unlock_new_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "924-933",
          "snippet": "void unlock_new_inode(struct inode *inode)\n{\n\tlockdep_annotate_inode_mutex_key(inode);\n\tspin_lock(&inode->i_lock);\n\tWARN_ON(!(inode->i_state & I_NEW));\n\tinode->i_state &= ~I_NEW;\n\tsmp_mb();\n\twake_up_bit(&inode->i_state, __I_NEW);\n\tspin_unlock(&inode->i_lock);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid unlock_new_inode(struct inode *inode)\n{\n\tlockdep_annotate_inode_mutex_key(inode);\n\tspin_lock(&inode->i_lock);\n\tWARN_ON(!(inode->i_state & I_NEW));\n\tinode->i_state &= ~I_NEW;\n\tsmp_mb();\n\twake_up_bit(&inode->i_state, __I_NEW);\n\tspin_unlock(&inode->i_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "gfs2_set_iop",
          "args": [
            "inode"
          ],
          "line": 185
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_set_iop",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/inode.c",
          "lines": "105-128",
          "snippet": "static void gfs2_set_iop(struct inode *inode)\n{\n\tstruct gfs2_sbd *sdp = GFS2_SB(inode);\n\tumode_t mode = inode->i_mode;\n\n\tif (S_ISREG(mode)) {\n\t\tinode->i_op = &gfs2_file_iops;\n\t\tif (gfs2_localflocks(sdp))\n\t\t\tinode->i_fop = &gfs2_file_fops_nolock;\n\t\telse\n\t\t\tinode->i_fop = &gfs2_file_fops;\n\t} else if (S_ISDIR(mode)) {\n\t\tinode->i_op = &gfs2_dir_iops;\n\t\tif (gfs2_localflocks(sdp))\n\t\t\tinode->i_fop = &gfs2_dir_fops_nolock;\n\t\telse\n\t\t\tinode->i_fop = &gfs2_dir_fops;\n\t} else if (S_ISLNK(mode)) {\n\t\tinode->i_op = &gfs2_symlink_iops;\n\t} else {\n\t\tinode->i_op = &gfs2_file_iops;\n\t\tinit_special_inode(inode, inode->i_mode, inode->i_rdev);\n\t}\n}",
          "includes": [
            "#include \"glops.h\"",
            "#include \"super.h\"",
            "#include \"util.h\"",
            "#include \"trans.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"inode.h\"",
            "#include \"glock.h\"",
            "#include \"xattr.h\"",
            "#include \"dir.h\"",
            "#include \"bmap.h\"",
            "#include \"acl.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/security.h>",
            "#include <linux/fiemap.h>",
            "#include <linux/crc32.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/xattr.h>",
            "#include <linux/mm.h>",
            "#include <linux/namei.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "const struct inode_operations gfs2_file_iops = {\n\t.permission = gfs2_permission,\n\t.setattr = gfs2_setattr,\n\t.getattr = gfs2_getattr,\n\t.setxattr = gfs2_setxattr,\n\t.getxattr = gfs2_getxattr,\n\t.listxattr = gfs2_listxattr,\n\t.removexattr = gfs2_removexattr,\n\t.fiemap = gfs2_fiemap,\n\t.get_acl = gfs2_get_acl,\n\t.set_acl = gfs2_set_acl,\n};",
            "const struct inode_operations gfs2_dir_iops = {\n\t.create = gfs2_create,\n\t.lookup = gfs2_lookup,\n\t.link = gfs2_link,\n\t.unlink = gfs2_unlink,\n\t.symlink = gfs2_symlink,\n\t.mkdir = gfs2_mkdir,\n\t.rmdir = gfs2_unlink,\n\t.mknod = gfs2_mknod,\n\t.rename = gfs2_rename,\n\t.permission = gfs2_permission,\n\t.setattr = gfs2_setattr,\n\t.getattr = gfs2_getattr,\n\t.setxattr = gfs2_setxattr,\n\t.getxattr = gfs2_getxattr,\n\t.listxattr = gfs2_listxattr,\n\t.removexattr = gfs2_removexattr,\n\t.fiemap = gfs2_fiemap,\n\t.get_acl = gfs2_get_acl,\n\t.set_acl = gfs2_set_acl,\n\t.atomic_open = gfs2_atomic_open,\n};",
            "const struct inode_operations gfs2_symlink_iops = {\n\t.readlink = generic_readlink,\n\t.follow_link = gfs2_follow_link,\n\t.put_link = kfree_put_link,\n\t.permission = gfs2_permission,\n\t.setattr = gfs2_setattr,\n\t.getattr = gfs2_getattr,\n\t.setxattr = gfs2_setxattr,\n\t.getxattr = gfs2_getxattr,\n\t.listxattr = gfs2_listxattr,\n\t.removexattr = gfs2_removexattr,\n\t.fiemap = gfs2_fiemap,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"glops.h\"\n#include \"super.h\"\n#include \"util.h\"\n#include \"trans.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"xattr.h\"\n#include \"dir.h\"\n#include \"bmap.h\"\n#include \"acl.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <asm/uaccess.h>\n#include <linux/security.h>\n#include <linux/fiemap.h>\n#include <linux/crc32.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/posix_acl.h>\n#include <linux/xattr.h>\n#include <linux/mm.h>\n#include <linux/namei.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nconst struct inode_operations gfs2_file_iops = {\n\t.permission = gfs2_permission,\n\t.setattr = gfs2_setattr,\n\t.getattr = gfs2_getattr,\n\t.setxattr = gfs2_setxattr,\n\t.getxattr = gfs2_getxattr,\n\t.listxattr = gfs2_listxattr,\n\t.removexattr = gfs2_removexattr,\n\t.fiemap = gfs2_fiemap,\n\t.get_acl = gfs2_get_acl,\n\t.set_acl = gfs2_set_acl,\n};\nconst struct inode_operations gfs2_dir_iops = {\n\t.create = gfs2_create,\n\t.lookup = gfs2_lookup,\n\t.link = gfs2_link,\n\t.unlink = gfs2_unlink,\n\t.symlink = gfs2_symlink,\n\t.mkdir = gfs2_mkdir,\n\t.rmdir = gfs2_unlink,\n\t.mknod = gfs2_mknod,\n\t.rename = gfs2_rename,\n\t.permission = gfs2_permission,\n\t.setattr = gfs2_setattr,\n\t.getattr = gfs2_getattr,\n\t.setxattr = gfs2_setxattr,\n\t.getxattr = gfs2_getxattr,\n\t.listxattr = gfs2_listxattr,\n\t.removexattr = gfs2_removexattr,\n\t.fiemap = gfs2_fiemap,\n\t.get_acl = gfs2_get_acl,\n\t.set_acl = gfs2_set_acl,\n\t.atomic_open = gfs2_atomic_open,\n};\nconst struct inode_operations gfs2_symlink_iops = {\n\t.readlink = generic_readlink,\n\t.follow_link = gfs2_follow_link,\n\t.put_link = kfree_put_link,\n\t.permission = gfs2_permission,\n\t.setattr = gfs2_setattr,\n\t.getattr = gfs2_getattr,\n\t.setxattr = gfs2_setxattr,\n\t.getxattr = gfs2_getxattr,\n\t.listxattr = gfs2_listxattr,\n\t.removexattr = gfs2_removexattr,\n\t.fiemap = gfs2_fiemap,\n};\n\nstatic void gfs2_set_iop(struct inode *inode)\n{\n\tstruct gfs2_sbd *sdp = GFS2_SB(inode);\n\tumode_t mode = inode->i_mode;\n\n\tif (S_ISREG(mode)) {\n\t\tinode->i_op = &gfs2_file_iops;\n\t\tif (gfs2_localflocks(sdp))\n\t\t\tinode->i_fop = &gfs2_file_fops_nolock;\n\t\telse\n\t\t\tinode->i_fop = &gfs2_file_fops;\n\t} else if (S_ISDIR(mode)) {\n\t\tinode->i_op = &gfs2_dir_iops;\n\t\tif (gfs2_localflocks(sdp))\n\t\t\tinode->i_fop = &gfs2_dir_fops_nolock;\n\t\telse\n\t\t\tinode->i_fop = &gfs2_dir_fops;\n\t} else if (S_ISLNK(mode)) {\n\t\tinode->i_op = &gfs2_symlink_iops;\n\t} else {\n\t\tinode->i_op = &gfs2_file_iops;\n\t\tinit_special_inode(inode, inode->i_mode, inode->i_rdev);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "DT2IF",
          "args": [
            "type"
          ],
          "line": 182
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gfs2_inode_refresh",
          "args": [
            "GFS2_I(inode)"
          ],
          "line": 178
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_inode_refresh",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/glops.c",
          "lines": "384-398",
          "snippet": "int gfs2_inode_refresh(struct gfs2_inode *ip)\n{\n\tstruct buffer_head *dibh;\n\tint error;\n\n\terror = gfs2_meta_inode_buffer(ip, &dibh);\n\tif (error)\n\t\treturn error;\n\n\terror = gfs2_dinode_in(ip, dibh->b_data);\n\tbrelse(dibh);\n\tclear_bit(GIF_INVALID, &ip->i_flags);\n\n\treturn error;\n}",
          "includes": [
            "#include \"dir.h\"",
            "#include \"trans.h\"",
            "#include \"util.h\"",
            "#include \"rgrp.h\"",
            "#include \"recovery.h\"",
            "#include \"meta_io.h\"",
            "#include \"log.h\"",
            "#include \"inode.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"bmap.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/posix_acl.h>",
            "#include <linux/bio.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"dir.h\"\n#include \"trans.h\"\n#include \"util.h\"\n#include \"rgrp.h\"\n#include \"recovery.h\"\n#include \"meta_io.h\"\n#include \"log.h\"\n#include \"inode.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/posix_acl.h>\n#include <linux/bio.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n\nint gfs2_inode_refresh(struct gfs2_inode *ip)\n{\n\tstruct buffer_head *dibh;\n\tint error;\n\n\terror = gfs2_meta_inode_buffer(ip, &dibh);\n\tif (error)\n\t\treturn error;\n\n\terror = gfs2_dinode_in(ip, dibh->b_data);\n\tbrelse(dibh);\n\tclear_bit(GIF_INVALID, &ip->i_flags);\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "GFS2_I",
          "args": [
            "inode"
          ],
          "line": 178
        },
        "resolved": true,
        "details": {
          "function_name": "GFS2_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/incore.h",
          "lines": "408-411",
          "snippet": "static inline struct gfs2_inode *GFS2_I(struct inode *inode)\n{\n\treturn container_of(inode, struct gfs2_inode, i_inode);\n}",
          "includes": [
            "#include <linux/lockref.h>",
            "#include <linux/percpu.h>",
            "#include <linux/ktime.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/completion.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/dlm.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/kobject.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/lockref.h>\n#include <linux/percpu.h>\n#include <linux/ktime.h>\n#include <linux/rbtree.h>\n#include <linux/completion.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/buffer_head.h>\n#include <linux/dlm.h>\n#include <linux/workqueue.h>\n#include <linux/kobject.h>\n#include <linux/fs.h>\n\nstatic inline struct gfs2_inode *GFS2_I(struct inode *inode)\n{\n\treturn container_of(inode, struct gfs2_inode, i_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "error"
          ],
          "line": 169
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gfs2_glock_nq_init",
          "args": [
            "io_gl",
            "LM_ST_SHARED",
            "GL_EXACT",
            "&ip->i_iopen_gh"
          ],
          "line": 168
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_glock_nq_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/glock.h",
          "lines": "204-230",
          "snippet": "extern __printf(2, 3)\nvoid gfs2_print_dbg(struct seq_file *seq, const char *fmt, ...);\n\n/**\n * gfs2_glock_nq_init - initialize a holder and enqueue it on a glock\n * @gl: the glock\n * @state: the state we're requesting\n * @flags: the modifier flags\n * @gh: the holder structure\n *\n * Returns: 0, GLR_*, or errno\n */\n\nstatic inline int gfs2_glock_nq_init(struct gfs2_glock *gl,\n\t\t\t\t     unsigned int state, int flags,\n\t\t\t\t     struct gfs2_holder *gh)\n{\n\tint error;\n\n\tgfs2_holder_init(gl, state, flags, gh);\n\n\terror = gfs2_glock_nq(gh);\n\tif (error)\n\t\tgfs2_holder_uninit(gh);\n\n\treturn error;\n}",
          "includes": [
            "#include \"incore.h\"",
            "#include <linux/parser.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"incore.h\"\n#include <linux/parser.h>\n#include <linux/sched.h>\n\nextern __printf(2, 3)\nvoid gfs2_print_dbg(struct seq_file *seq, const char *fmt, ...);\n\n/**\n * gfs2_glock_nq_init - initialize a holder and enqueue it on a glock\n * @gl: the glock\n * @state: the state we're requesting\n * @flags: the modifier flags\n * @gh: the holder structure\n *\n * Returns: 0, GLR_*, or errno\n */\n\nstatic inline int gfs2_glock_nq_init(struct gfs2_glock *gl,\n\t\t\t\t     unsigned int state, int flags,\n\t\t\t\t     struct gfs2_holder *gh)\n{\n\tint error;\n\n\tgfs2_holder_init(gl, state, flags, gh);\n\n\terror = gfs2_glock_nq(gh);\n\tif (error)\n\t\tgfs2_holder_uninit(gh);\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_bit",
          "args": [
            "GIF_INVALID",
            "&ip->i_flags"
          ],
          "line": 167
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_set_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "886-890",
          "snippet": "static inline void ocfs2_set_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_set_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\nstatic inline void ocfs2_set_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_set_bit(bit, bitmap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "error"
          ],
          "line": 164
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gfs2_glock_get",
          "args": [
            "sdp",
            "no_addr",
            "&gfs2_iopen_glops",
            "CREATE",
            "&io_gl"
          ],
          "line": 163
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_glock_get",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/glock.c",
          "lines": "702-790",
          "snippet": "int gfs2_glock_get(struct gfs2_sbd *sdp, u64 number,\n\t\t   const struct gfs2_glock_operations *glops, int create,\n\t\t   struct gfs2_glock **glp)\n{\n\tstruct super_block *s = sdp->sd_vfs;\n\tstruct lm_lockname name = { .ln_number = number, .ln_type = glops->go_type };\n\tstruct gfs2_glock *gl, *tmp;\n\tunsigned int hash = gl_hash(sdp, &name);\n\tstruct address_space *mapping;\n\tstruct kmem_cache *cachep;\n\n\trcu_read_lock();\n\tgl = search_bucket(hash, sdp, &name);\n\trcu_read_unlock();\n\n\t*glp = gl;\n\tif (gl)\n\t\treturn 0;\n\tif (!create)\n\t\treturn -ENOENT;\n\n\tif (glops->go_flags & GLOF_ASPACE)\n\t\tcachep = gfs2_glock_aspace_cachep;\n\telse\n\t\tcachep = gfs2_glock_cachep;\n\tgl = kmem_cache_alloc(cachep, GFP_NOFS);\n\tif (!gl)\n\t\treturn -ENOMEM;\n\n\tmemset(&gl->gl_lksb, 0, sizeof(struct dlm_lksb));\n\n\tif (glops->go_flags & GLOF_LVB) {\n\t\tgl->gl_lksb.sb_lvbptr = kzalloc(GFS2_MIN_LVB_SIZE, GFP_NOFS);\n\t\tif (!gl->gl_lksb.sb_lvbptr) {\n\t\t\tkmem_cache_free(cachep, gl);\n\t\t\treturn -ENOMEM;\n\t\t}\n\t}\n\n\tatomic_inc(&sdp->sd_glock_disposal);\n\tgl->gl_sbd = sdp;\n\tgl->gl_flags = 0;\n\tgl->gl_name = name;\n\tgl->gl_lockref.count = 1;\n\tgl->gl_state = LM_ST_UNLOCKED;\n\tgl->gl_target = LM_ST_UNLOCKED;\n\tgl->gl_demote_state = LM_ST_EXCLUSIVE;\n\tgl->gl_hash = hash;\n\tgl->gl_ops = glops;\n\tgl->gl_dstamp = ktime_set(0, 0);\n\tpreempt_disable();\n\t/* We use the global stats to estimate the initial per-glock stats */\n\tgl->gl_stats = this_cpu_ptr(sdp->sd_lkstats)->lkstats[glops->go_type];\n\tpreempt_enable();\n\tgl->gl_stats.stats[GFS2_LKS_DCOUNT] = 0;\n\tgl->gl_stats.stats[GFS2_LKS_QCOUNT] = 0;\n\tgl->gl_tchange = jiffies;\n\tgl->gl_object = NULL;\n\tgl->gl_hold_time = GL_GLOCK_DFT_HOLD;\n\tINIT_DELAYED_WORK(&gl->gl_work, glock_work_func);\n\tINIT_WORK(&gl->gl_delete, delete_work_func);\n\n\tmapping = gfs2_glock2aspace(gl);\n\tif (mapping) {\n                mapping->a_ops = &gfs2_meta_aops;\n\t\tmapping->host = s->s_bdev->bd_inode;\n\t\tmapping->flags = 0;\n\t\tmapping_set_gfp_mask(mapping, GFP_NOFS);\n\t\tmapping->private_data = NULL;\n\t\tmapping->writeback_index = 0;\n\t}\n\n\tspin_lock_bucket(hash);\n\ttmp = search_bucket(hash, sdp, &name);\n\tif (tmp) {\n\t\tspin_unlock_bucket(hash);\n\t\tkfree(gl->gl_lksb.sb_lvbptr);\n\t\tkmem_cache_free(cachep, gl);\n\t\tatomic_dec(&sdp->sd_glock_disposal);\n\t\tgl = tmp;\n\t} else {\n\t\thlist_bl_add_head_rcu(&gl->gl_list, &gl_hash_table[hash]);\n\t\tspin_unlock_bucket(hash);\n\t}\n\n\t*glp = gl;\n\n\treturn 0;\n}",
          "includes": [
            "#include \"trace_gfs2.h\"",
            "#include \"bmap.h\"",
            "#include \"util.h\"",
            "#include \"super.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"lops.h\"",
            "#include \"inode.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/lockref.h>",
            "#include <linux/list_sort.h>",
            "#include <linux/percpu.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/seq_file.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/module.h>",
            "#include <linux/wait.h>",
            "#include <linux/list.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/jhash.h>",
            "#include <linux/sort.h>",
            "#include <linux/delay.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct hlist_bl_head gl_hash_table[GFS2_GL_HASH_SIZE];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"bmap.h\"\n#include \"util.h\"\n#include \"super.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"lops.h\"\n#include \"inode.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/lockref.h>\n#include <linux/list_sort.h>\n#include <linux/percpu.h>\n#include <linux/bit_spinlock.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/jiffies.h>\n#include <linux/workqueue.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <asm/uaccess.h>\n#include <linux/module.h>\n#include <linux/wait.h>\n#include <linux/list.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/kallsyms.h>\n#include <linux/jhash.h>\n#include <linux/sort.h>\n#include <linux/delay.h>\n#include <linux/buffer_head.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic struct hlist_bl_head gl_hash_table[GFS2_GL_HASH_SIZE];\n\nint gfs2_glock_get(struct gfs2_sbd *sdp, u64 number,\n\t\t   const struct gfs2_glock_operations *glops, int create,\n\t\t   struct gfs2_glock **glp)\n{\n\tstruct super_block *s = sdp->sd_vfs;\n\tstruct lm_lockname name = { .ln_number = number, .ln_type = glops->go_type };\n\tstruct gfs2_glock *gl, *tmp;\n\tunsigned int hash = gl_hash(sdp, &name);\n\tstruct address_space *mapping;\n\tstruct kmem_cache *cachep;\n\n\trcu_read_lock();\n\tgl = search_bucket(hash, sdp, &name);\n\trcu_read_unlock();\n\n\t*glp = gl;\n\tif (gl)\n\t\treturn 0;\n\tif (!create)\n\t\treturn -ENOENT;\n\n\tif (glops->go_flags & GLOF_ASPACE)\n\t\tcachep = gfs2_glock_aspace_cachep;\n\telse\n\t\tcachep = gfs2_glock_cachep;\n\tgl = kmem_cache_alloc(cachep, GFP_NOFS);\n\tif (!gl)\n\t\treturn -ENOMEM;\n\n\tmemset(&gl->gl_lksb, 0, sizeof(struct dlm_lksb));\n\n\tif (glops->go_flags & GLOF_LVB) {\n\t\tgl->gl_lksb.sb_lvbptr = kzalloc(GFS2_MIN_LVB_SIZE, GFP_NOFS);\n\t\tif (!gl->gl_lksb.sb_lvbptr) {\n\t\t\tkmem_cache_free(cachep, gl);\n\t\t\treturn -ENOMEM;\n\t\t}\n\t}\n\n\tatomic_inc(&sdp->sd_glock_disposal);\n\tgl->gl_sbd = sdp;\n\tgl->gl_flags = 0;\n\tgl->gl_name = name;\n\tgl->gl_lockref.count = 1;\n\tgl->gl_state = LM_ST_UNLOCKED;\n\tgl->gl_target = LM_ST_UNLOCKED;\n\tgl->gl_demote_state = LM_ST_EXCLUSIVE;\n\tgl->gl_hash = hash;\n\tgl->gl_ops = glops;\n\tgl->gl_dstamp = ktime_set(0, 0);\n\tpreempt_disable();\n\t/* We use the global stats to estimate the initial per-glock stats */\n\tgl->gl_stats = this_cpu_ptr(sdp->sd_lkstats)->lkstats[glops->go_type];\n\tpreempt_enable();\n\tgl->gl_stats.stats[GFS2_LKS_DCOUNT] = 0;\n\tgl->gl_stats.stats[GFS2_LKS_QCOUNT] = 0;\n\tgl->gl_tchange = jiffies;\n\tgl->gl_object = NULL;\n\tgl->gl_hold_time = GL_GLOCK_DFT_HOLD;\n\tINIT_DELAYED_WORK(&gl->gl_work, glock_work_func);\n\tINIT_WORK(&gl->gl_delete, delete_work_func);\n\n\tmapping = gfs2_glock2aspace(gl);\n\tif (mapping) {\n                mapping->a_ops = &gfs2_meta_aops;\n\t\tmapping->host = s->s_bdev->bd_inode;\n\t\tmapping->flags = 0;\n\t\tmapping_set_gfp_mask(mapping, GFP_NOFS);\n\t\tmapping->private_data = NULL;\n\t\tmapping->writeback_index = 0;\n\t}\n\n\tspin_lock_bucket(hash);\n\ttmp = search_bucket(hash, sdp, &name);\n\tif (tmp) {\n\t\tspin_unlock_bucket(hash);\n\t\tkfree(gl->gl_lksb.sb_lvbptr);\n\t\tkmem_cache_free(cachep, gl);\n\t\tatomic_dec(&sdp->sd_glock_disposal);\n\t\tgl = tmp;\n\t} else {\n\t\thlist_bl_add_head_rcu(&gl->gl_list, &gl_hash_table[hash]);\n\t\tspin_unlock_bucket(hash);\n\t}\n\n\t*glp = gl;\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "error"
          ],
          "line": 159
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GFS2_SB",
          "args": [
            "inode"
          ],
          "line": 155
        },
        "resolved": true,
        "details": {
          "function_name": "GFS2_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/incore.h",
          "lines": "413-416",
          "snippet": "static inline struct gfs2_sbd *GFS2_SB(const struct inode *inode)\n{\n\treturn inode->i_sb->s_fs_info;\n}",
          "includes": [
            "#include <linux/lockref.h>",
            "#include <linux/percpu.h>",
            "#include <linux/ktime.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/completion.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/dlm.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/kobject.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/lockref.h>\n#include <linux/percpu.h>\n#include <linux/ktime.h>\n#include <linux/rbtree.h>\n#include <linux/completion.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/buffer_head.h>\n#include <linux/dlm.h>\n#include <linux/workqueue.h>\n#include <linux/kobject.h>\n#include <linux/fs.h>\n\nstatic inline struct gfs2_sbd *GFS2_SB(const struct inode *inode)\n{\n\treturn inode->i_sb->s_fs_info;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-ENOMEM"
          ],
          "line": 152
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gfs2_iget",
          "args": [
            "sb",
            "no_addr",
            "non_block"
          ],
          "line": 148
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_iget",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/inode.c",
          "lines": "85-95",
          "snippet": "static struct inode *gfs2_iget(struct super_block *sb, u64 no_addr,\n\t\t\t       int non_block)\n{\n\tstruct gfs2_skip_data data;\n\tunsigned long hash = (unsigned long)no_addr;\n\n\tdata.no_addr = no_addr;\n\tdata.skipped = 0;\n\tdata.non_block = non_block;\n\treturn iget5_locked(sb, hash, iget_test, iget_set, &data);\n}",
          "includes": [
            "#include \"glops.h\"",
            "#include \"super.h\"",
            "#include \"util.h\"",
            "#include \"trans.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"inode.h\"",
            "#include \"glock.h\"",
            "#include \"xattr.h\"",
            "#include \"dir.h\"",
            "#include \"bmap.h\"",
            "#include \"acl.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/security.h>",
            "#include <linux/fiemap.h>",
            "#include <linux/crc32.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/xattr.h>",
            "#include <linux/mm.h>",
            "#include <linux/namei.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glops.h\"\n#include \"super.h\"\n#include \"util.h\"\n#include \"trans.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"xattr.h\"\n#include \"dir.h\"\n#include \"bmap.h\"\n#include \"acl.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <asm/uaccess.h>\n#include <linux/security.h>\n#include <linux/fiemap.h>\n#include <linux/crc32.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/posix_acl.h>\n#include <linux/xattr.h>\n#include <linux/mm.h>\n#include <linux/namei.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nstatic struct inode *gfs2_iget(struct super_block *sb, u64 no_addr,\n\t\t\t       int non_block)\n{\n\tstruct gfs2_skip_data data;\n\tunsigned long hash = (unsigned long)no_addr;\n\n\tdata.no_addr = no_addr;\n\tdata.skipped = 0;\n\tdata.non_block = non_block;\n\treturn iget5_locked(sb, hash, iget_test, iget_set, &data);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"glops.h\"\n#include \"super.h\"\n#include \"util.h\"\n#include \"trans.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"xattr.h\"\n#include \"dir.h\"\n#include \"bmap.h\"\n#include \"acl.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <asm/uaccess.h>\n#include <linux/security.h>\n#include <linux/fiemap.h>\n#include <linux/crc32.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/posix_acl.h>\n#include <linux/xattr.h>\n#include <linux/mm.h>\n#include <linux/namei.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nstruct inode *gfs2_inode_lookup(struct super_block *sb, unsigned int type,\n\t\t\t\tu64 no_addr, u64 no_formal_ino, int non_block)\n{\n\tstruct inode *inode;\n\tstruct gfs2_inode *ip;\n\tstruct gfs2_glock *io_gl = NULL;\n\tint error;\n\n\tinode = gfs2_iget(sb, no_addr, non_block);\n\tip = GFS2_I(inode);\n\n\tif (!inode)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tif (inode->i_state & I_NEW) {\n\t\tstruct gfs2_sbd *sdp = GFS2_SB(inode);\n\t\tip->i_no_formal_ino = no_formal_ino;\n\n\t\terror = gfs2_glock_get(sdp, no_addr, &gfs2_inode_glops, CREATE, &ip->i_gl);\n\t\tif (unlikely(error))\n\t\t\tgoto fail;\n\t\tip->i_gl->gl_object = ip;\n\n\t\terror = gfs2_glock_get(sdp, no_addr, &gfs2_iopen_glops, CREATE, &io_gl);\n\t\tif (unlikely(error))\n\t\t\tgoto fail_put;\n\n\t\tset_bit(GIF_INVALID, &ip->i_flags);\n\t\terror = gfs2_glock_nq_init(io_gl, LM_ST_SHARED, GL_EXACT, &ip->i_iopen_gh);\n\t\tif (unlikely(error))\n\t\t\tgoto fail_iopen;\n\n\t\tip->i_iopen_gh.gh_gl->gl_object = ip;\n\t\tgfs2_glock_put(io_gl);\n\t\tio_gl = NULL;\n\n\t\tif (type == DT_UNKNOWN) {\n\t\t\t/* Inode glock must be locked already */\n\t\t\terror = gfs2_inode_refresh(GFS2_I(inode));\n\t\t\tif (error)\n\t\t\t\tgoto fail_refresh;\n\t\t} else {\n\t\t\tinode->i_mode = DT2IF(type);\n\t\t}\n\n\t\tgfs2_set_iop(inode);\n\t\tunlock_new_inode(inode);\n\t}\n\n\treturn inode;\n\nfail_refresh:\n\tip->i_iopen_gh.gh_flags |= GL_NOCACHE;\n\tip->i_iopen_gh.gh_gl->gl_object = NULL;\n\tgfs2_glock_dq_uninit(&ip->i_iopen_gh);\nfail_iopen:\n\tif (io_gl)\n\t\tgfs2_glock_put(io_gl);\nfail_put:\n\tip->i_gl->gl_object = NULL;\n\tgfs2_glock_put(ip->i_gl);\nfail:\n\tiget_failed(inode);\n\treturn ERR_PTR(error);\n}"
  },
  {
    "function_name": "gfs2_set_iop",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/inode.c",
    "lines": "105-128",
    "snippet": "static void gfs2_set_iop(struct inode *inode)\n{\n\tstruct gfs2_sbd *sdp = GFS2_SB(inode);\n\tumode_t mode = inode->i_mode;\n\n\tif (S_ISREG(mode)) {\n\t\tinode->i_op = &gfs2_file_iops;\n\t\tif (gfs2_localflocks(sdp))\n\t\t\tinode->i_fop = &gfs2_file_fops_nolock;\n\t\telse\n\t\t\tinode->i_fop = &gfs2_file_fops;\n\t} else if (S_ISDIR(mode)) {\n\t\tinode->i_op = &gfs2_dir_iops;\n\t\tif (gfs2_localflocks(sdp))\n\t\t\tinode->i_fop = &gfs2_dir_fops_nolock;\n\t\telse\n\t\t\tinode->i_fop = &gfs2_dir_fops;\n\t} else if (S_ISLNK(mode)) {\n\t\tinode->i_op = &gfs2_symlink_iops;\n\t} else {\n\t\tinode->i_op = &gfs2_file_iops;\n\t\tinit_special_inode(inode, inode->i_mode, inode->i_rdev);\n\t}\n}",
    "includes": [
      "#include \"glops.h\"",
      "#include \"super.h\"",
      "#include \"util.h\"",
      "#include \"trans.h\"",
      "#include \"rgrp.h\"",
      "#include \"quota.h\"",
      "#include \"meta_io.h\"",
      "#include \"inode.h\"",
      "#include \"glock.h\"",
      "#include \"xattr.h\"",
      "#include \"dir.h\"",
      "#include \"bmap.h\"",
      "#include \"acl.h\"",
      "#include \"incore.h\"",
      "#include \"gfs2.h\"",
      "#include <asm/uaccess.h>",
      "#include <linux/security.h>",
      "#include <linux/fiemap.h>",
      "#include <linux/crc32.h>",
      "#include <linux/gfs2_ondisk.h>",
      "#include <linux/posix_acl.h>",
      "#include <linux/xattr.h>",
      "#include <linux/mm.h>",
      "#include <linux/namei.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/completion.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "const struct inode_operations gfs2_file_iops = {\n\t.permission = gfs2_permission,\n\t.setattr = gfs2_setattr,\n\t.getattr = gfs2_getattr,\n\t.setxattr = gfs2_setxattr,\n\t.getxattr = gfs2_getxattr,\n\t.listxattr = gfs2_listxattr,\n\t.removexattr = gfs2_removexattr,\n\t.fiemap = gfs2_fiemap,\n\t.get_acl = gfs2_get_acl,\n\t.set_acl = gfs2_set_acl,\n};",
      "const struct inode_operations gfs2_dir_iops = {\n\t.create = gfs2_create,\n\t.lookup = gfs2_lookup,\n\t.link = gfs2_link,\n\t.unlink = gfs2_unlink,\n\t.symlink = gfs2_symlink,\n\t.mkdir = gfs2_mkdir,\n\t.rmdir = gfs2_unlink,\n\t.mknod = gfs2_mknod,\n\t.rename = gfs2_rename,\n\t.permission = gfs2_permission,\n\t.setattr = gfs2_setattr,\n\t.getattr = gfs2_getattr,\n\t.setxattr = gfs2_setxattr,\n\t.getxattr = gfs2_getxattr,\n\t.listxattr = gfs2_listxattr,\n\t.removexattr = gfs2_removexattr,\n\t.fiemap = gfs2_fiemap,\n\t.get_acl = gfs2_get_acl,\n\t.set_acl = gfs2_set_acl,\n\t.atomic_open = gfs2_atomic_open,\n};",
      "const struct inode_operations gfs2_symlink_iops = {\n\t.readlink = generic_readlink,\n\t.follow_link = gfs2_follow_link,\n\t.put_link = kfree_put_link,\n\t.permission = gfs2_permission,\n\t.setattr = gfs2_setattr,\n\t.getattr = gfs2_getattr,\n\t.setxattr = gfs2_setxattr,\n\t.getxattr = gfs2_getxattr,\n\t.listxattr = gfs2_listxattr,\n\t.removexattr = gfs2_removexattr,\n\t.fiemap = gfs2_fiemap,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "init_special_inode",
          "args": [
            "inode",
            "inode->i_mode",
            "inode->i_rdev"
          ],
          "line": 126
        },
        "resolved": true,
        "details": {
          "function_name": "init_special_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "1854-1871",
          "snippet": "void init_special_inode(struct inode *inode, umode_t mode, dev_t rdev)\n{\n\tinode->i_mode = mode;\n\tif (S_ISCHR(mode)) {\n\t\tinode->i_fop = &def_chr_fops;\n\t\tinode->i_rdev = rdev;\n\t} else if (S_ISBLK(mode)) {\n\t\tinode->i_fop = &def_blk_fops;\n\t\tinode->i_rdev = rdev;\n\t} else if (S_ISFIFO(mode))\n\t\tinode->i_fop = &pipefifo_fops;\n\telse if (S_ISSOCK(mode))\n\t\t;\t/* leave it no_open_fops */\n\telse\n\t\tprintk(KERN_DEBUG \"init_special_inode: bogus i_mode (%o) for\"\n\t\t\t\t  \" inode %s:%lu\\n\", mode, inode->i_sb->s_id,\n\t\t\t\t  inode->i_ino);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid init_special_inode(struct inode *inode, umode_t mode, dev_t rdev)\n{\n\tinode->i_mode = mode;\n\tif (S_ISCHR(mode)) {\n\t\tinode->i_fop = &def_chr_fops;\n\t\tinode->i_rdev = rdev;\n\t} else if (S_ISBLK(mode)) {\n\t\tinode->i_fop = &def_blk_fops;\n\t\tinode->i_rdev = rdev;\n\t} else if (S_ISFIFO(mode))\n\t\tinode->i_fop = &pipefifo_fops;\n\telse if (S_ISSOCK(mode))\n\t\t;\t/* leave it no_open_fops */\n\telse\n\t\tprintk(KERN_DEBUG \"init_special_inode: bogus i_mode (%o) for\"\n\t\t\t\t  \" inode %s:%lu\\n\", mode, inode->i_sb->s_id,\n\t\t\t\t  inode->i_ino);\n}"
        }
      },
      {
        "call_info": {
          "callee": "S_ISLNK",
          "args": [
            "mode"
          ],
          "line": 122
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gfs2_localflocks",
          "args": [
            "sdp"
          ],
          "line": 118
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_localflocks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/inode.h",
          "lines": "134-137",
          "snippet": "static inline int gfs2_localflocks(const struct gfs2_sbd *sdp)\n{\n\treturn 1;\n}",
          "includes": [
            "#include \"util.h\"",
            "#include <linux/mm.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include <linux/mm.h>\n#include <linux/buffer_head.h>\n#include <linux/fs.h>\n\nstatic inline int gfs2_localflocks(const struct gfs2_sbd *sdp)\n{\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "S_ISDIR",
          "args": [
            "mode"
          ],
          "line": 116
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISREG",
          "args": [
            "mode"
          ],
          "line": 110
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GFS2_SB",
          "args": [
            "inode"
          ],
          "line": 107
        },
        "resolved": true,
        "details": {
          "function_name": "GFS2_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/incore.h",
          "lines": "413-416",
          "snippet": "static inline struct gfs2_sbd *GFS2_SB(const struct inode *inode)\n{\n\treturn inode->i_sb->s_fs_info;\n}",
          "includes": [
            "#include <linux/lockref.h>",
            "#include <linux/percpu.h>",
            "#include <linux/ktime.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/completion.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/dlm.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/kobject.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/lockref.h>\n#include <linux/percpu.h>\n#include <linux/ktime.h>\n#include <linux/rbtree.h>\n#include <linux/completion.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/buffer_head.h>\n#include <linux/dlm.h>\n#include <linux/workqueue.h>\n#include <linux/kobject.h>\n#include <linux/fs.h>\n\nstatic inline struct gfs2_sbd *GFS2_SB(const struct inode *inode)\n{\n\treturn inode->i_sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"glops.h\"\n#include \"super.h\"\n#include \"util.h\"\n#include \"trans.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"xattr.h\"\n#include \"dir.h\"\n#include \"bmap.h\"\n#include \"acl.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <asm/uaccess.h>\n#include <linux/security.h>\n#include <linux/fiemap.h>\n#include <linux/crc32.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/posix_acl.h>\n#include <linux/xattr.h>\n#include <linux/mm.h>\n#include <linux/namei.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nconst struct inode_operations gfs2_file_iops = {\n\t.permission = gfs2_permission,\n\t.setattr = gfs2_setattr,\n\t.getattr = gfs2_getattr,\n\t.setxattr = gfs2_setxattr,\n\t.getxattr = gfs2_getxattr,\n\t.listxattr = gfs2_listxattr,\n\t.removexattr = gfs2_removexattr,\n\t.fiemap = gfs2_fiemap,\n\t.get_acl = gfs2_get_acl,\n\t.set_acl = gfs2_set_acl,\n};\nconst struct inode_operations gfs2_dir_iops = {\n\t.create = gfs2_create,\n\t.lookup = gfs2_lookup,\n\t.link = gfs2_link,\n\t.unlink = gfs2_unlink,\n\t.symlink = gfs2_symlink,\n\t.mkdir = gfs2_mkdir,\n\t.rmdir = gfs2_unlink,\n\t.mknod = gfs2_mknod,\n\t.rename = gfs2_rename,\n\t.permission = gfs2_permission,\n\t.setattr = gfs2_setattr,\n\t.getattr = gfs2_getattr,\n\t.setxattr = gfs2_setxattr,\n\t.getxattr = gfs2_getxattr,\n\t.listxattr = gfs2_listxattr,\n\t.removexattr = gfs2_removexattr,\n\t.fiemap = gfs2_fiemap,\n\t.get_acl = gfs2_get_acl,\n\t.set_acl = gfs2_set_acl,\n\t.atomic_open = gfs2_atomic_open,\n};\nconst struct inode_operations gfs2_symlink_iops = {\n\t.readlink = generic_readlink,\n\t.follow_link = gfs2_follow_link,\n\t.put_link = kfree_put_link,\n\t.permission = gfs2_permission,\n\t.setattr = gfs2_setattr,\n\t.getattr = gfs2_getattr,\n\t.setxattr = gfs2_setxattr,\n\t.getxattr = gfs2_getxattr,\n\t.listxattr = gfs2_listxattr,\n\t.removexattr = gfs2_removexattr,\n\t.fiemap = gfs2_fiemap,\n};\n\nstatic void gfs2_set_iop(struct inode *inode)\n{\n\tstruct gfs2_sbd *sdp = GFS2_SB(inode);\n\tumode_t mode = inode->i_mode;\n\n\tif (S_ISREG(mode)) {\n\t\tinode->i_op = &gfs2_file_iops;\n\t\tif (gfs2_localflocks(sdp))\n\t\t\tinode->i_fop = &gfs2_file_fops_nolock;\n\t\telse\n\t\t\tinode->i_fop = &gfs2_file_fops;\n\t} else if (S_ISDIR(mode)) {\n\t\tinode->i_op = &gfs2_dir_iops;\n\t\tif (gfs2_localflocks(sdp))\n\t\t\tinode->i_fop = &gfs2_dir_fops_nolock;\n\t\telse\n\t\t\tinode->i_fop = &gfs2_dir_fops;\n\t} else if (S_ISLNK(mode)) {\n\t\tinode->i_op = &gfs2_symlink_iops;\n\t} else {\n\t\tinode->i_op = &gfs2_file_iops;\n\t\tinit_special_inode(inode, inode->i_mode, inode->i_rdev);\n\t}\n}"
  },
  {
    "function_name": "gfs2_iget",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/inode.c",
    "lines": "85-95",
    "snippet": "static struct inode *gfs2_iget(struct super_block *sb, u64 no_addr,\n\t\t\t       int non_block)\n{\n\tstruct gfs2_skip_data data;\n\tunsigned long hash = (unsigned long)no_addr;\n\n\tdata.no_addr = no_addr;\n\tdata.skipped = 0;\n\tdata.non_block = non_block;\n\treturn iget5_locked(sb, hash, iget_test, iget_set, &data);\n}",
    "includes": [
      "#include \"glops.h\"",
      "#include \"super.h\"",
      "#include \"util.h\"",
      "#include \"trans.h\"",
      "#include \"rgrp.h\"",
      "#include \"quota.h\"",
      "#include \"meta_io.h\"",
      "#include \"inode.h\"",
      "#include \"glock.h\"",
      "#include \"xattr.h\"",
      "#include \"dir.h\"",
      "#include \"bmap.h\"",
      "#include \"acl.h\"",
      "#include \"incore.h\"",
      "#include \"gfs2.h\"",
      "#include <asm/uaccess.h>",
      "#include <linux/security.h>",
      "#include <linux/fiemap.h>",
      "#include <linux/crc32.h>",
      "#include <linux/gfs2_ondisk.h>",
      "#include <linux/posix_acl.h>",
      "#include <linux/xattr.h>",
      "#include <linux/mm.h>",
      "#include <linux/namei.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/completion.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "iget5_locked",
          "args": [
            "sb",
            "hash",
            "iget_test",
            "iget_set",
            "&data"
          ],
          "line": 94
        },
        "resolved": true,
        "details": {
          "function_name": "iget5_locked",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "991-1047",
          "snippet": "struct inode *iget5_locked(struct super_block *sb, unsigned long hashval,\n\t\tint (*test)(struct inode *, void *),\n\t\tint (*set)(struct inode *, void *), void *data)\n{\n\tstruct hlist_head *head = inode_hashtable + hash(sb, hashval);\n\tstruct inode *inode;\n\n\tspin_lock(&inode_hash_lock);\n\tinode = find_inode(sb, head, test, data);\n\tspin_unlock(&inode_hash_lock);\n\n\tif (inode) {\n\t\twait_on_inode(inode);\n\t\treturn inode;\n\t}\n\n\tinode = alloc_inode(sb);\n\tif (inode) {\n\t\tstruct inode *old;\n\n\t\tspin_lock(&inode_hash_lock);\n\t\t/* We released the lock, so.. */\n\t\told = find_inode(sb, head, test, data);\n\t\tif (!old) {\n\t\t\tif (set(inode, data))\n\t\t\t\tgoto set_failed;\n\n\t\t\tspin_lock(&inode->i_lock);\n\t\t\tinode->i_state = I_NEW;\n\t\t\thlist_add_head(&inode->i_hash, head);\n\t\t\tspin_unlock(&inode->i_lock);\n\t\t\tinode_sb_list_add(inode);\n\t\t\tspin_unlock(&inode_hash_lock);\n\n\t\t\t/* Return the locked inode with I_NEW set, the\n\t\t\t * caller is responsible for filling in the contents\n\t\t\t */\n\t\t\treturn inode;\n\t\t}\n\n\t\t/*\n\t\t * Uhhuh, somebody else created the same inode under\n\t\t * us. Use the old inode instead of the one we just\n\t\t * allocated.\n\t\t */\n\t\tspin_unlock(&inode_hash_lock);\n\t\tdestroy_inode(inode);\n\t\tinode = old;\n\t\twait_on_inode(inode);\n\t}\n\treturn inode;\n\nset_failed:\n\tspin_unlock(&inode_hash_lock);\n\tdestroy_inode(inode);\n\treturn NULL;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct hlist_head *inode_hashtable",
            "static __cacheline_aligned_in_smp DEFINE_SPINLOCK(inode_hash_lock);",
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic struct hlist_head *inode_hashtable;\nstatic __cacheline_aligned_in_smp DEFINE_SPINLOCK(inode_hash_lock);\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nstruct inode *iget5_locked(struct super_block *sb, unsigned long hashval,\n\t\tint (*test)(struct inode *, void *),\n\t\tint (*set)(struct inode *, void *), void *data)\n{\n\tstruct hlist_head *head = inode_hashtable + hash(sb, hashval);\n\tstruct inode *inode;\n\n\tspin_lock(&inode_hash_lock);\n\tinode = find_inode(sb, head, test, data);\n\tspin_unlock(&inode_hash_lock);\n\n\tif (inode) {\n\t\twait_on_inode(inode);\n\t\treturn inode;\n\t}\n\n\tinode = alloc_inode(sb);\n\tif (inode) {\n\t\tstruct inode *old;\n\n\t\tspin_lock(&inode_hash_lock);\n\t\t/* We released the lock, so.. */\n\t\told = find_inode(sb, head, test, data);\n\t\tif (!old) {\n\t\t\tif (set(inode, data))\n\t\t\t\tgoto set_failed;\n\n\t\t\tspin_lock(&inode->i_lock);\n\t\t\tinode->i_state = I_NEW;\n\t\t\thlist_add_head(&inode->i_hash, head);\n\t\t\tspin_unlock(&inode->i_lock);\n\t\t\tinode_sb_list_add(inode);\n\t\t\tspin_unlock(&inode_hash_lock);\n\n\t\t\t/* Return the locked inode with I_NEW set, the\n\t\t\t * caller is responsible for filling in the contents\n\t\t\t */\n\t\t\treturn inode;\n\t\t}\n\n\t\t/*\n\t\t * Uhhuh, somebody else created the same inode under\n\t\t * us. Use the old inode instead of the one we just\n\t\t * allocated.\n\t\t */\n\t\tspin_unlock(&inode_hash_lock);\n\t\tdestroy_inode(inode);\n\t\tinode = old;\n\t\twait_on_inode(inode);\n\t}\n\treturn inode;\n\nset_failed:\n\tspin_unlock(&inode_hash_lock);\n\tdestroy_inode(inode);\n\treturn NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"glops.h\"\n#include \"super.h\"\n#include \"util.h\"\n#include \"trans.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"xattr.h\"\n#include \"dir.h\"\n#include \"bmap.h\"\n#include \"acl.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <asm/uaccess.h>\n#include <linux/security.h>\n#include <linux/fiemap.h>\n#include <linux/crc32.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/posix_acl.h>\n#include <linux/xattr.h>\n#include <linux/mm.h>\n#include <linux/namei.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nstatic struct inode *gfs2_iget(struct super_block *sb, u64 no_addr,\n\t\t\t       int non_block)\n{\n\tstruct gfs2_skip_data data;\n\tunsigned long hash = (unsigned long)no_addr;\n\n\tdata.no_addr = no_addr;\n\tdata.skipped = 0;\n\tdata.non_block = non_block;\n\treturn iget5_locked(sb, hash, iget_test, iget_set, &data);\n}"
  },
  {
    "function_name": "gfs2_ilookup",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/inode.c",
    "lines": "74-83",
    "snippet": "struct inode *gfs2_ilookup(struct super_block *sb, u64 no_addr, int non_block)\n{\n\tunsigned long hash = (unsigned long)no_addr;\n\tstruct gfs2_skip_data data;\n\n\tdata.no_addr = no_addr;\n\tdata.skipped = 0;\n\tdata.non_block = non_block;\n\treturn ilookup5(sb, hash, iget_test, &data);\n}",
    "includes": [
      "#include \"glops.h\"",
      "#include \"super.h\"",
      "#include \"util.h\"",
      "#include \"trans.h\"",
      "#include \"rgrp.h\"",
      "#include \"quota.h\"",
      "#include \"meta_io.h\"",
      "#include \"inode.h\"",
      "#include \"glock.h\"",
      "#include \"xattr.h\"",
      "#include \"dir.h\"",
      "#include \"bmap.h\"",
      "#include \"acl.h\"",
      "#include \"incore.h\"",
      "#include \"gfs2.h\"",
      "#include <asm/uaccess.h>",
      "#include <linux/security.h>",
      "#include <linux/fiemap.h>",
      "#include <linux/crc32.h>",
      "#include <linux/gfs2_ondisk.h>",
      "#include <linux/posix_acl.h>",
      "#include <linux/xattr.h>",
      "#include <linux/mm.h>",
      "#include <linux/namei.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/completion.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ilookup5",
          "args": [
            "sb",
            "hash",
            "iget_test",
            "&data"
          ],
          "line": 82
        },
        "resolved": true,
        "details": {
          "function_name": "ilookup5",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "1239-1247",
          "snippet": "struct inode *ilookup5(struct super_block *sb, unsigned long hashval,\n\t\tint (*test)(struct inode *, void *), void *data)\n{\n\tstruct inode *inode = ilookup5_nowait(sb, hashval, test, data);\n\n\tif (inode)\n\t\twait_on_inode(inode);\n\treturn inode;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nstruct inode *ilookup5(struct super_block *sb, unsigned long hashval,\n\t\tint (*test)(struct inode *, void *), void *data)\n{\n\tstruct inode *inode = ilookup5_nowait(sb, hashval, test, data);\n\n\tif (inode)\n\t\twait_on_inode(inode);\n\treturn inode;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"glops.h\"\n#include \"super.h\"\n#include \"util.h\"\n#include \"trans.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"xattr.h\"\n#include \"dir.h\"\n#include \"bmap.h\"\n#include \"acl.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <asm/uaccess.h>\n#include <linux/security.h>\n#include <linux/fiemap.h>\n#include <linux/crc32.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/posix_acl.h>\n#include <linux/xattr.h>\n#include <linux/mm.h>\n#include <linux/namei.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nstruct inode *gfs2_ilookup(struct super_block *sb, u64 no_addr, int non_block)\n{\n\tunsigned long hash = (unsigned long)no_addr;\n\tstruct gfs2_skip_data data;\n\n\tdata.no_addr = no_addr;\n\tdata.skipped = 0;\n\tdata.non_block = non_block;\n\treturn ilookup5(sb, hash, iget_test, &data);\n}"
  },
  {
    "function_name": "iget_set",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/inode.c",
    "lines": "62-72",
    "snippet": "static int iget_set(struct inode *inode, void *opaque)\n{\n\tstruct gfs2_inode *ip = GFS2_I(inode);\n\tstruct gfs2_skip_data *data = opaque;\n\n\tif (data->skipped)\n\t\treturn -ENOENT;\n\tinode->i_ino = (unsigned long)(data->no_addr);\n\tip->i_no_addr = data->no_addr;\n\treturn 0;\n}",
    "includes": [
      "#include \"glops.h\"",
      "#include \"super.h\"",
      "#include \"util.h\"",
      "#include \"trans.h\"",
      "#include \"rgrp.h\"",
      "#include \"quota.h\"",
      "#include \"meta_io.h\"",
      "#include \"inode.h\"",
      "#include \"glock.h\"",
      "#include \"xattr.h\"",
      "#include \"dir.h\"",
      "#include \"bmap.h\"",
      "#include \"acl.h\"",
      "#include \"incore.h\"",
      "#include \"gfs2.h\"",
      "#include <asm/uaccess.h>",
      "#include <linux/security.h>",
      "#include <linux/fiemap.h>",
      "#include <linux/crc32.h>",
      "#include <linux/gfs2_ondisk.h>",
      "#include <linux/posix_acl.h>",
      "#include <linux/xattr.h>",
      "#include <linux/mm.h>",
      "#include <linux/namei.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/completion.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "GFS2_I",
          "args": [
            "inode"
          ],
          "line": 64
        },
        "resolved": true,
        "details": {
          "function_name": "GFS2_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/incore.h",
          "lines": "408-411",
          "snippet": "static inline struct gfs2_inode *GFS2_I(struct inode *inode)\n{\n\treturn container_of(inode, struct gfs2_inode, i_inode);\n}",
          "includes": [
            "#include <linux/lockref.h>",
            "#include <linux/percpu.h>",
            "#include <linux/ktime.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/completion.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/dlm.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/kobject.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/lockref.h>\n#include <linux/percpu.h>\n#include <linux/ktime.h>\n#include <linux/rbtree.h>\n#include <linux/completion.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/buffer_head.h>\n#include <linux/dlm.h>\n#include <linux/workqueue.h>\n#include <linux/kobject.h>\n#include <linux/fs.h>\n\nstatic inline struct gfs2_inode *GFS2_I(struct inode *inode)\n{\n\treturn container_of(inode, struct gfs2_inode, i_inode);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"glops.h\"\n#include \"super.h\"\n#include \"util.h\"\n#include \"trans.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"xattr.h\"\n#include \"dir.h\"\n#include \"bmap.h\"\n#include \"acl.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <asm/uaccess.h>\n#include <linux/security.h>\n#include <linux/fiemap.h>\n#include <linux/crc32.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/posix_acl.h>\n#include <linux/xattr.h>\n#include <linux/mm.h>\n#include <linux/namei.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nstatic int iget_set(struct inode *inode, void *opaque)\n{\n\tstruct gfs2_inode *ip = GFS2_I(inode);\n\tstruct gfs2_skip_data *data = opaque;\n\n\tif (data->skipped)\n\t\treturn -ENOENT;\n\tinode->i_ino = (unsigned long)(data->no_addr);\n\tip->i_no_addr = data->no_addr;\n\treturn 0;\n}"
  },
  {
    "function_name": "iget_test",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/inode.c",
    "lines": "46-60",
    "snippet": "static int iget_test(struct inode *inode, void *opaque)\n{\n\tstruct gfs2_inode *ip = GFS2_I(inode);\n\tstruct gfs2_skip_data *data = opaque;\n\n\tif (ip->i_no_addr == data->no_addr) {\n\t\tif (data->non_block &&\n\t\t    inode->i_state & (I_FREEING|I_CLEAR|I_WILL_FREE)) {\n\t\t\tdata->skipped = 1;\n\t\t\treturn 0;\n\t\t}\n\t\treturn 1;\n\t}\n\treturn 0;\n}",
    "includes": [
      "#include \"glops.h\"",
      "#include \"super.h\"",
      "#include \"util.h\"",
      "#include \"trans.h\"",
      "#include \"rgrp.h\"",
      "#include \"quota.h\"",
      "#include \"meta_io.h\"",
      "#include \"inode.h\"",
      "#include \"glock.h\"",
      "#include \"xattr.h\"",
      "#include \"dir.h\"",
      "#include \"bmap.h\"",
      "#include \"acl.h\"",
      "#include \"incore.h\"",
      "#include \"gfs2.h\"",
      "#include <asm/uaccess.h>",
      "#include <linux/security.h>",
      "#include <linux/fiemap.h>",
      "#include <linux/crc32.h>",
      "#include <linux/gfs2_ondisk.h>",
      "#include <linux/posix_acl.h>",
      "#include <linux/xattr.h>",
      "#include <linux/mm.h>",
      "#include <linux/namei.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/completion.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "GFS2_I",
          "args": [
            "inode"
          ],
          "line": 48
        },
        "resolved": true,
        "details": {
          "function_name": "GFS2_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/incore.h",
          "lines": "408-411",
          "snippet": "static inline struct gfs2_inode *GFS2_I(struct inode *inode)\n{\n\treturn container_of(inode, struct gfs2_inode, i_inode);\n}",
          "includes": [
            "#include <linux/lockref.h>",
            "#include <linux/percpu.h>",
            "#include <linux/ktime.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/completion.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/dlm.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/kobject.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/lockref.h>\n#include <linux/percpu.h>\n#include <linux/ktime.h>\n#include <linux/rbtree.h>\n#include <linux/completion.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/buffer_head.h>\n#include <linux/dlm.h>\n#include <linux/workqueue.h>\n#include <linux/kobject.h>\n#include <linux/fs.h>\n\nstatic inline struct gfs2_inode *GFS2_I(struct inode *inode)\n{\n\treturn container_of(inode, struct gfs2_inode, i_inode);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"glops.h\"\n#include \"super.h\"\n#include \"util.h\"\n#include \"trans.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"xattr.h\"\n#include \"dir.h\"\n#include \"bmap.h\"\n#include \"acl.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <asm/uaccess.h>\n#include <linux/security.h>\n#include <linux/fiemap.h>\n#include <linux/crc32.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/posix_acl.h>\n#include <linux/xattr.h>\n#include <linux/mm.h>\n#include <linux/namei.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nstatic int iget_test(struct inode *inode, void *opaque)\n{\n\tstruct gfs2_inode *ip = GFS2_I(inode);\n\tstruct gfs2_skip_data *data = opaque;\n\n\tif (ip->i_no_addr == data->no_addr) {\n\t\tif (data->non_block &&\n\t\t    inode->i_state & (I_FREEING|I_CLEAR|I_WILL_FREE)) {\n\t\t\tdata->skipped = 1;\n\t\t\treturn 0;\n\t\t}\n\t\treturn 1;\n\t}\n\treturn 0;\n}"
  }
]