[
  {
    "function_name": "ext4_exit_fs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/super.c",
    "lines": "5628-5642",
    "snippet": "static void __exit ext4_exit_fs(void)\n{\n\text4_destroy_lazyinit_thread();\n\tunregister_as_ext2();\n\tunregister_as_ext3();\n\tunregister_filesystem(&ext4_fs_type);\n\tdestroy_inodecache();\n\text4_exit_mballoc();\n\text4_exit_feat_adverts();\n\tremove_proc_entry(\"fs/ext4\", NULL);\n\tkset_unregister(ext4_kset);\n\text4_exit_system_zone();\n\text4_exit_pageio();\n\text4_exit_es();\n}",
    "includes": [
      "#include <trace/events/ext4.h>",
      "#include \"mballoc.h\"",
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"ext4_jbd2.h\"",
      "#include \"ext4_extents.h\"\t/* Needed for trace points definition */",
      "#include \"ext4.h\"",
      "#include <linux/freezer.h>",
      "#include <linux/kthread.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/cleancache.h>",
      "#include <linux/crc16.h>",
      "#include <linux/log2.h>",
      "#include <linux/ctype.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/namei.h>",
      "#include <linux/mount.h>",
      "#include <linux/random.h>",
      "#include <linux/vfs.h>",
      "#include <linux/exportfs.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/parser.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/init.h>",
      "#include <linux/slab.h>",
      "#include <linux/jbd2.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/time.h>",
      "#include <linux/fs.h>",
      "#include <linux/string.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct kset *ext4_kset;",
      "static void ext4_destroy_lazyinit_thread(void);",
      "static struct file_system_type ext4_fs_type = {\n\t.owner\t\t= THIS_MODULE,\n\t.name\t\t= \"ext4\",\n\t.mount\t\t= ext4_mount,\n\t.kill_sb\t= kill_block_super,\n\t.fs_flags\t= FS_REQUIRES_DEV,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ext4_exit_es",
          "args": [],
          "line": 5641
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_exit_es",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/extents_status.c",
          "lines": "164-168",
          "snippet": "void ext4_exit_es(void)\n{\n\tif (ext4_es_cachep)\n\t\tkmem_cache_destroy(ext4_es_cachep);\n}",
          "includes": [
            "#include \"ext4_extents.h\"\t/* Needed when ES_AGGRESSIVE_TEST is defined */",
            "#include <trace/events/ext4.h>",
            "#include \"extents_status.h\"",
            "#include \"ext4.h\"",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/list_sort.h>",
            "#include <linux/rbtree.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kmem_cache *ext4_es_cachep;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ext4_extents.h\"\t/* Needed when ES_AGGRESSIVE_TEST is defined */\n#include <trace/events/ext4.h>\n#include \"extents_status.h\"\n#include \"ext4.h\"\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/list_sort.h>\n#include <linux/rbtree.h>\n\nstatic struct kmem_cache *ext4_es_cachep;\n\nvoid ext4_exit_es(void)\n{\n\tif (ext4_es_cachep)\n\t\tkmem_cache_destroy(ext4_es_cachep);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_exit_pageio",
          "args": [],
          "line": 5640
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_exit_pageio",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/page-io.c",
          "lines": "44-47",
          "snippet": "void ext4_exit_pageio(void)\n{\n\tkmem_cache_destroy(io_end_cachep);\n}",
          "includes": [
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include <linux/ratelimit.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/bio.h>",
            "#include <linux/uio.h>",
            "#include <linux/aio.h>",
            "#include <linux/namei.h>",
            "#include <linux/mpage.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highuid.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/time.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kmem_cache *io_end_cachep;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include <linux/ratelimit.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/workqueue.h>\n#include <linux/bio.h>\n#include <linux/uio.h>\n#include <linux/aio.h>\n#include <linux/namei.h>\n#include <linux/mpage.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/highuid.h>\n#include <linux/jbd2.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n\nstatic struct kmem_cache *io_end_cachep;\n\nvoid ext4_exit_pageio(void)\n{\n\tkmem_cache_destroy(io_end_cachep);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_exit_system_zone",
          "args": [],
          "line": 5639
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_exit_system_zone",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/block_validity.c",
          "lines": "39-42",
          "snippet": "void ext4_exit_system_zone(void)\n{\n\tkmem_cache_destroy(ext4_system_zone_cachep);\n}",
          "includes": [
            "#include \"ext4.h\"",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kmem_cache *ext4_system_zone_cachep;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ext4.h\"\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/blkdev.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/buffer_head.h>\n#include <linux/quotaops.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n\nstatic struct kmem_cache *ext4_system_zone_cachep;\n\nvoid ext4_exit_system_zone(void)\n{\n\tkmem_cache_destroy(ext4_system_zone_cachep);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kset_unregister",
          "args": [
            "ext4_kset"
          ],
          "line": 5638
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "remove_proc_entry",
          "args": [
            "\"fs/ext4\"",
            "NULL"
          ],
          "line": 5637
        },
        "resolved": true,
        "details": {
          "function_name": "remove_proc_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/generic.c",
          "lines": "523-554",
          "snippet": "void remove_proc_entry(const char *name, struct proc_dir_entry *parent)\n{\n\tstruct proc_dir_entry *de = NULL;\n\tconst char *fn = name;\n\tunsigned int len;\n\n\tspin_lock(&proc_subdir_lock);\n\tif (__xlate_proc_name(name, &parent, &fn) != 0) {\n\t\tspin_unlock(&proc_subdir_lock);\n\t\treturn;\n\t}\n\tlen = strlen(fn);\n\n\tde = pde_subdir_find(parent, fn, len);\n\tif (de)\n\t\trb_erase(&de->subdir_node, &parent->subdir);\n\tspin_unlock(&proc_subdir_lock);\n\tif (!de) {\n\t\tWARN(1, \"name '%s'\\n\", name);\n\t\treturn;\n\t}\n\n\tproc_entry_rundown(de);\n\n\tif (S_ISDIR(de->mode))\n\t\tparent->nlink--;\n\tde->nlink = 0;\n\tWARN(pde_subdir_first(de),\n\t     \"%s: removing non-empty directory '%s/%s', leaking at least '%s'\\n\",\n\t     __func__, de->parent->name, de->name, pde_subdir_first(de)->name);\n\tpde_put(de);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/bitops.h>",
            "#include <linux/idr.h>",
            "#include <linux/init.h>",
            "#include <linux/mount.h>",
            "#include <linux/printk.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/stat.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/time.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_SPINLOCK(proc_subdir_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/bitops.h>\n#include <linux/idr.h>\n#include <linux/init.h>\n#include <linux/mount.h>\n#include <linux/printk.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/stat.h>\n#include <linux/proc_fs.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n\nstatic DEFINE_SPINLOCK(proc_subdir_lock);\n\nvoid remove_proc_entry(const char *name, struct proc_dir_entry *parent)\n{\n\tstruct proc_dir_entry *de = NULL;\n\tconst char *fn = name;\n\tunsigned int len;\n\n\tspin_lock(&proc_subdir_lock);\n\tif (__xlate_proc_name(name, &parent, &fn) != 0) {\n\t\tspin_unlock(&proc_subdir_lock);\n\t\treturn;\n\t}\n\tlen = strlen(fn);\n\n\tde = pde_subdir_find(parent, fn, len);\n\tif (de)\n\t\trb_erase(&de->subdir_node, &parent->subdir);\n\tspin_unlock(&proc_subdir_lock);\n\tif (!de) {\n\t\tWARN(1, \"name '%s'\\n\", name);\n\t\treturn;\n\t}\n\n\tproc_entry_rundown(de);\n\n\tif (S_ISDIR(de->mode))\n\t\tparent->nlink--;\n\tde->nlink = 0;\n\tWARN(pde_subdir_first(de),\n\t     \"%s: removing non-empty directory '%s/%s', leaking at least '%s'\\n\",\n\t     __func__, de->parent->name, de->name, pde_subdir_first(de)->name);\n\tpde_put(de);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_exit_feat_adverts",
          "args": [],
          "line": 5636
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_exit_feat_adverts",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/super.c",
          "lines": "5542-5547",
          "snippet": "static void ext4_exit_feat_adverts(void)\n{\n\tkobject_put(&ext4_feat->f_kobj);\n\twait_for_completion(&ext4_feat->f_kobj_unregister);\n\tkfree(ext4_feat);\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"mballoc.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include \"ext4_extents.h\"\t/* Needed for trace points definition */",
            "#include \"ext4.h\"",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/crc16.h>",
            "#include <linux/log2.h>",
            "#include <linux/ctype.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/random.h>",
            "#include <linux/vfs.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/parser.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/time.h>",
            "#include <linux/fs.h>",
            "#include <linux/string.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct ext4_features *ext4_feat;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"mballoc.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4_extents.h\"\t/* Needed for trace points definition */\n#include \"ext4.h\"\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <asm/uaccess.h>\n#include <linux/cleancache.h>\n#include <linux/crc16.h>\n#include <linux/log2.h>\n#include <linux/ctype.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/random.h>\n#include <linux/vfs.h>\n#include <linux/exportfs.h>\n#include <linux/buffer_head.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/jbd2.h>\n#include <linux/vmalloc.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n#include <linux/string.h>\n#include <linux/module.h>\n\nstatic struct ext4_features *ext4_feat;\n\nstatic void ext4_exit_feat_adverts(void)\n{\n\tkobject_put(&ext4_feat->f_kobj);\n\twait_for_completion(&ext4_feat->f_kobj_unregister);\n\tkfree(ext4_feat);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_exit_mballoc",
          "args": [],
          "line": 5635
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_exit_mballoc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/mballoc.c",
          "lines": "2847-2858",
          "snippet": "void ext4_exit_mballoc(void)\n{\n\t/*\n\t * Wait for completion of call_rcu()'s on ext4_pspace_cachep\n\t * before destroying the slab cache.\n\t */\n\trcu_barrier();\n\tkmem_cache_destroy(ext4_pspace_cachep);\n\tkmem_cache_destroy(ext4_ac_cachep);\n\tkmem_cache_destroy(ext4_free_data_cachep);\n\text4_groupinfo_destroy_slabs();\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/log2.h>",
            "#include \"mballoc.h\"",
            "#include \"ext4_jbd2.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kmem_cache *ext4_pspace_cachep;",
            "static struct kmem_cache *ext4_ac_cachep;",
            "static struct kmem_cache *ext4_free_data_cachep;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/log2.h>\n#include \"mballoc.h\"\n#include \"ext4_jbd2.h\"\n\nstatic struct kmem_cache *ext4_pspace_cachep;\nstatic struct kmem_cache *ext4_ac_cachep;\nstatic struct kmem_cache *ext4_free_data_cachep;\n\nvoid ext4_exit_mballoc(void)\n{\n\t/*\n\t * Wait for completion of call_rcu()'s on ext4_pspace_cachep\n\t * before destroying the slab cache.\n\t */\n\trcu_barrier();\n\tkmem_cache_destroy(ext4_pspace_cachep);\n\tkmem_cache_destroy(ext4_ac_cachep);\n\tkmem_cache_destroy(ext4_free_data_cachep);\n\text4_groupinfo_destroy_slabs();\n}"
        }
      },
      {
        "call_info": {
          "callee": "destroy_inodecache",
          "args": [],
          "line": 5634
        },
        "resolved": true,
        "details": {
          "function_name": "destroy_inodecache",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/super.c",
          "lines": "950-958",
          "snippet": "static void destroy_inodecache(void)\n{\n\t/*\n\t * Make sure all delayed rcu free inodes are flushed before we\n\t * destroy cache.\n\t */\n\trcu_barrier();\n\tkmem_cache_destroy(ext4_inode_cachep);\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"mballoc.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include \"ext4_extents.h\"\t/* Needed for trace points definition */",
            "#include \"ext4.h\"",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/crc16.h>",
            "#include <linux/log2.h>",
            "#include <linux/ctype.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/random.h>",
            "#include <linux/vfs.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/parser.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/time.h>",
            "#include <linux/fs.h>",
            "#include <linux/string.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kmem_cache *ext4_inode_cachep;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"mballoc.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4_extents.h\"\t/* Needed for trace points definition */\n#include \"ext4.h\"\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <asm/uaccess.h>\n#include <linux/cleancache.h>\n#include <linux/crc16.h>\n#include <linux/log2.h>\n#include <linux/ctype.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/random.h>\n#include <linux/vfs.h>\n#include <linux/exportfs.h>\n#include <linux/buffer_head.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/jbd2.h>\n#include <linux/vmalloc.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n#include <linux/string.h>\n#include <linux/module.h>\n\nstatic struct kmem_cache *ext4_inode_cachep;\n\nstatic void destroy_inodecache(void)\n{\n\t/*\n\t * Make sure all delayed rcu free inodes are flushed before we\n\t * destroy cache.\n\t */\n\trcu_barrier();\n\tkmem_cache_destroy(ext4_inode_cachep);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unregister_filesystem",
          "args": [
            "&ext4_fs_type"
          ],
          "line": 5633
        },
        "resolved": true,
        "details": {
          "function_name": "unregister_filesystem",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/filesystems.c",
          "lines": "101-120",
          "snippet": "int unregister_filesystem(struct file_system_type * fs)\n{\n\tstruct file_system_type ** tmp;\n\n\twrite_lock(&file_systems_lock);\n\ttmp = &file_systems;\n\twhile (*tmp) {\n\t\tif (fs == *tmp) {\n\t\t\t*tmp = fs->next;\n\t\t\tfs->next = NULL;\n\t\t\twrite_unlock(&file_systems_lock);\n\t\t\tsynchronize_rcu();\n\t\t\treturn 0;\n\t\t}\n\t\ttmp = &(*tmp)->next;\n\t}\n\twrite_unlock(&file_systems_lock);\n\n\treturn -EINVAL;\n}",
          "includes": [
            "#include <asm/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/kmod.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct file_system_type *file_systems;",
            "static DEFINE_RWLOCK(file_systems_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/uaccess.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kmod.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n\nstatic struct file_system_type *file_systems;\nstatic DEFINE_RWLOCK(file_systems_lock);\n\nint unregister_filesystem(struct file_system_type * fs)\n{\n\tstruct file_system_type ** tmp;\n\n\twrite_lock(&file_systems_lock);\n\ttmp = &file_systems;\n\twhile (*tmp) {\n\t\tif (fs == *tmp) {\n\t\t\t*tmp = fs->next;\n\t\t\tfs->next = NULL;\n\t\t\twrite_unlock(&file_systems_lock);\n\t\t\tsynchronize_rcu();\n\t\t\treturn 0;\n\t\t}\n\t\ttmp = &(*tmp)->next;\n\t}\n\twrite_unlock(&file_systems_lock);\n\n\treturn -EINVAL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "unregister_as_ext3",
          "args": [],
          "line": 5632
        },
        "resolved": true,
        "details": {
          "function_name": "unregister_as_ext3",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/super.c",
          "lines": "5505-5505",
          "snippet": "static inline void unregister_as_ext3(void) { }",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"mballoc.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include \"ext4_extents.h\"\t/* Needed for trace points definition */",
            "#include \"ext4.h\"",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/crc16.h>",
            "#include <linux/log2.h>",
            "#include <linux/ctype.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/random.h>",
            "#include <linux/vfs.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/parser.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/time.h>",
            "#include <linux/fs.h>",
            "#include <linux/string.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"mballoc.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4_extents.h\"\t/* Needed for trace points definition */\n#include \"ext4.h\"\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <asm/uaccess.h>\n#include <linux/cleancache.h>\n#include <linux/crc16.h>\n#include <linux/log2.h>\n#include <linux/ctype.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/random.h>\n#include <linux/vfs.h>\n#include <linux/exportfs.h>\n#include <linux/buffer_head.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/jbd2.h>\n#include <linux/vmalloc.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n#include <linux/string.h>\n#include <linux/module.h>\n\nstatic inline void unregister_as_ext3(void) { }"
        }
      },
      {
        "call_info": {
          "callee": "unregister_as_ext2",
          "args": [],
          "line": 5631
        },
        "resolved": true,
        "details": {
          "function_name": "unregister_as_ext2",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/super.c",
          "lines": "5473-5473",
          "snippet": "static inline void unregister_as_ext2(void) { }",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"mballoc.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include \"ext4_extents.h\"\t/* Needed for trace points definition */",
            "#include \"ext4.h\"",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/crc16.h>",
            "#include <linux/log2.h>",
            "#include <linux/ctype.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/random.h>",
            "#include <linux/vfs.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/parser.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/time.h>",
            "#include <linux/fs.h>",
            "#include <linux/string.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"mballoc.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4_extents.h\"\t/* Needed for trace points definition */\n#include \"ext4.h\"\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <asm/uaccess.h>\n#include <linux/cleancache.h>\n#include <linux/crc16.h>\n#include <linux/log2.h>\n#include <linux/ctype.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/random.h>\n#include <linux/vfs.h>\n#include <linux/exportfs.h>\n#include <linux/buffer_head.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/jbd2.h>\n#include <linux/vmalloc.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n#include <linux/string.h>\n#include <linux/module.h>\n\nstatic inline void unregister_as_ext2(void) { }"
        }
      },
      {
        "call_info": {
          "callee": "ext4_destroy_lazyinit_thread",
          "args": [],
          "line": 5630
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_destroy_lazyinit_thread",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/super.c",
          "lines": "3200-3210",
          "snippet": "static void ext4_destroy_lazyinit_thread(void)\n{\n\t/*\n\t * If thread exited earlier\n\t * there's nothing to be done.\n\t */\n\tif (!ext4_li_info || !ext4_lazyinit_task)\n\t\treturn;\n\n\tkthread_stop(ext4_lazyinit_task);\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"mballoc.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include \"ext4_extents.h\"\t/* Needed for trace points definition */",
            "#include \"ext4.h\"",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/crc16.h>",
            "#include <linux/log2.h>",
            "#include <linux/ctype.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/random.h>",
            "#include <linux/vfs.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/parser.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/time.h>",
            "#include <linux/fs.h>",
            "#include <linux/string.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct ext4_lazy_init *ext4_li_info;",
            "static void ext4_destroy_lazyinit_thread(void);",
            "static struct task_struct *ext4_lazyinit_task;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"mballoc.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4_extents.h\"\t/* Needed for trace points definition */\n#include \"ext4.h\"\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <asm/uaccess.h>\n#include <linux/cleancache.h>\n#include <linux/crc16.h>\n#include <linux/log2.h>\n#include <linux/ctype.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/random.h>\n#include <linux/vfs.h>\n#include <linux/exportfs.h>\n#include <linux/buffer_head.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/jbd2.h>\n#include <linux/vmalloc.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n#include <linux/string.h>\n#include <linux/module.h>\n\nstatic struct ext4_lazy_init *ext4_li_info;\nstatic void ext4_destroy_lazyinit_thread(void);\nstatic struct task_struct *ext4_lazyinit_task;\n\nstatic void ext4_destroy_lazyinit_thread(void)\n{\n\t/*\n\t * If thread exited earlier\n\t * there's nothing to be done.\n\t */\n\tif (!ext4_li_info || !ext4_lazyinit_task)\n\t\treturn;\n\n\tkthread_stop(ext4_lazyinit_task);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"mballoc.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4_extents.h\"\t/* Needed for trace points definition */\n#include \"ext4.h\"\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <asm/uaccess.h>\n#include <linux/cleancache.h>\n#include <linux/crc16.h>\n#include <linux/log2.h>\n#include <linux/ctype.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/random.h>\n#include <linux/vfs.h>\n#include <linux/exportfs.h>\n#include <linux/buffer_head.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/jbd2.h>\n#include <linux/vmalloc.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n#include <linux/string.h>\n#include <linux/module.h>\n\nstatic struct kset *ext4_kset;\nstatic void ext4_destroy_lazyinit_thread(void);\nstatic struct file_system_type ext4_fs_type = {\n\t.owner\t\t= THIS_MODULE,\n\t.name\t\t= \"ext4\",\n\t.mount\t\t= ext4_mount,\n\t.kill_sb\t= kill_block_super,\n\t.fs_flags\t= FS_REQUIRES_DEV,\n};\n\nstatic void __exit ext4_exit_fs(void)\n{\n\text4_destroy_lazyinit_thread();\n\tunregister_as_ext2();\n\tunregister_as_ext3();\n\tunregister_filesystem(&ext4_fs_type);\n\tdestroy_inodecache();\n\text4_exit_mballoc();\n\text4_exit_feat_adverts();\n\tremove_proc_entry(\"fs/ext4\", NULL);\n\tkset_unregister(ext4_kset);\n\text4_exit_system_zone();\n\text4_exit_pageio();\n\text4_exit_es();\n}"
  },
  {
    "function_name": "ext4_init_fs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/super.c",
    "lines": "5553-5626",
    "snippet": "static int __init ext4_init_fs(void)\n{\n\tint i, err;\n\n\text4_li_info = NULL;\n\tmutex_init(&ext4_li_mtx);\n\n\t/* Build-time check for flags consistency */\n\text4_check_flag_values();\n\n\tfor (i = 0; i < EXT4_WQ_HASH_SZ; i++) {\n\t\tmutex_init(&ext4__aio_mutex[i]);\n\t\tinit_waitqueue_head(&ext4__ioend_wq[i]);\n\t}\n\n\terr = ext4_init_es();\n\tif (err)\n\t\treturn err;\n\n\terr = ext4_init_pageio();\n\tif (err)\n\t\tgoto out7;\n\n\terr = ext4_init_system_zone();\n\tif (err)\n\t\tgoto out6;\n\text4_kset = kset_create_and_add(\"ext4\", NULL, fs_kobj);\n\tif (!ext4_kset) {\n\t\terr = -ENOMEM;\n\t\tgoto out5;\n\t}\n\text4_proc_root = proc_mkdir(\"fs/ext4\", NULL);\n\n\terr = ext4_init_feat_adverts();\n\tif (err)\n\t\tgoto out4;\n\n\terr = ext4_init_mballoc();\n\tif (err)\n\t\tgoto out2;\n\telse\n\t\text4_mballoc_ready = 1;\n\terr = init_inodecache();\n\tif (err)\n\t\tgoto out1;\n\tregister_as_ext3();\n\tregister_as_ext2();\n\terr = register_filesystem(&ext4_fs_type);\n\tif (err)\n\t\tgoto out;\n\n\treturn 0;\nout:\n\tunregister_as_ext2();\n\tunregister_as_ext3();\n\tdestroy_inodecache();\nout1:\n\text4_mballoc_ready = 0;\n\text4_exit_mballoc();\nout2:\n\text4_exit_feat_adverts();\nout4:\n\tif (ext4_proc_root)\n\t\tremove_proc_entry(\"fs/ext4\", NULL);\n\tkset_unregister(ext4_kset);\nout5:\n\text4_exit_system_zone();\nout6:\n\text4_exit_pageio();\nout7:\n\text4_exit_es();\n\n\treturn err;\n}",
    "includes": [
      "#include <trace/events/ext4.h>",
      "#include \"mballoc.h\"",
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"ext4_jbd2.h\"",
      "#include \"ext4_extents.h\"\t/* Needed for trace points definition */",
      "#include \"ext4.h\"",
      "#include <linux/freezer.h>",
      "#include <linux/kthread.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/cleancache.h>",
      "#include <linux/crc16.h>",
      "#include <linux/log2.h>",
      "#include <linux/ctype.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/namei.h>",
      "#include <linux/mount.h>",
      "#include <linux/random.h>",
      "#include <linux/vfs.h>",
      "#include <linux/exportfs.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/parser.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/init.h>",
      "#include <linux/slab.h>",
      "#include <linux/jbd2.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/time.h>",
      "#include <linux/fs.h>",
      "#include <linux/string.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct proc_dir_entry *ext4_proc_root;",
      "static struct kset *ext4_kset;",
      "static struct ext4_lazy_init *ext4_li_info;",
      "static struct mutex ext4_li_mtx;",
      "static int ext4_mballoc_ready;",
      "static struct file_system_type ext4_fs_type = {\n\t.owner\t\t= THIS_MODULE,\n\t.name\t\t= \"ext4\",\n\t.mount\t\t= ext4_mount,\n\t.kill_sb\t= kill_block_super,\n\t.fs_flags\t= FS_REQUIRES_DEV,\n};",
      "wait_queue_head_t ext4__ioend_wq[EXT4_WQ_HASH_SZ];",
      "struct mutex ext4__aio_mutex[EXT4_WQ_HASH_SZ];"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ext4_exit_es",
          "args": [],
          "line": 5623
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_exit_es",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/extents_status.c",
          "lines": "164-168",
          "snippet": "void ext4_exit_es(void)\n{\n\tif (ext4_es_cachep)\n\t\tkmem_cache_destroy(ext4_es_cachep);\n}",
          "includes": [
            "#include \"ext4_extents.h\"\t/* Needed when ES_AGGRESSIVE_TEST is defined */",
            "#include <trace/events/ext4.h>",
            "#include \"extents_status.h\"",
            "#include \"ext4.h\"",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/list_sort.h>",
            "#include <linux/rbtree.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kmem_cache *ext4_es_cachep;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ext4_extents.h\"\t/* Needed when ES_AGGRESSIVE_TEST is defined */\n#include <trace/events/ext4.h>\n#include \"extents_status.h\"\n#include \"ext4.h\"\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/list_sort.h>\n#include <linux/rbtree.h>\n\nstatic struct kmem_cache *ext4_es_cachep;\n\nvoid ext4_exit_es(void)\n{\n\tif (ext4_es_cachep)\n\t\tkmem_cache_destroy(ext4_es_cachep);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_exit_pageio",
          "args": [],
          "line": 5621
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_exit_pageio",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/page-io.c",
          "lines": "44-47",
          "snippet": "void ext4_exit_pageio(void)\n{\n\tkmem_cache_destroy(io_end_cachep);\n}",
          "includes": [
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include <linux/ratelimit.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/bio.h>",
            "#include <linux/uio.h>",
            "#include <linux/aio.h>",
            "#include <linux/namei.h>",
            "#include <linux/mpage.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highuid.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/time.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kmem_cache *io_end_cachep;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include <linux/ratelimit.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/workqueue.h>\n#include <linux/bio.h>\n#include <linux/uio.h>\n#include <linux/aio.h>\n#include <linux/namei.h>\n#include <linux/mpage.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/highuid.h>\n#include <linux/jbd2.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n\nstatic struct kmem_cache *io_end_cachep;\n\nvoid ext4_exit_pageio(void)\n{\n\tkmem_cache_destroy(io_end_cachep);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_exit_system_zone",
          "args": [],
          "line": 5619
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_exit_system_zone",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/block_validity.c",
          "lines": "39-42",
          "snippet": "void ext4_exit_system_zone(void)\n{\n\tkmem_cache_destroy(ext4_system_zone_cachep);\n}",
          "includes": [
            "#include \"ext4.h\"",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kmem_cache *ext4_system_zone_cachep;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ext4.h\"\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/blkdev.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/buffer_head.h>\n#include <linux/quotaops.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n\nstatic struct kmem_cache *ext4_system_zone_cachep;\n\nvoid ext4_exit_system_zone(void)\n{\n\tkmem_cache_destroy(ext4_system_zone_cachep);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kset_unregister",
          "args": [
            "ext4_kset"
          ],
          "line": 5617
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "remove_proc_entry",
          "args": [
            "\"fs/ext4\"",
            "NULL"
          ],
          "line": 5616
        },
        "resolved": true,
        "details": {
          "function_name": "remove_proc_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/generic.c",
          "lines": "523-554",
          "snippet": "void remove_proc_entry(const char *name, struct proc_dir_entry *parent)\n{\n\tstruct proc_dir_entry *de = NULL;\n\tconst char *fn = name;\n\tunsigned int len;\n\n\tspin_lock(&proc_subdir_lock);\n\tif (__xlate_proc_name(name, &parent, &fn) != 0) {\n\t\tspin_unlock(&proc_subdir_lock);\n\t\treturn;\n\t}\n\tlen = strlen(fn);\n\n\tde = pde_subdir_find(parent, fn, len);\n\tif (de)\n\t\trb_erase(&de->subdir_node, &parent->subdir);\n\tspin_unlock(&proc_subdir_lock);\n\tif (!de) {\n\t\tWARN(1, \"name '%s'\\n\", name);\n\t\treturn;\n\t}\n\n\tproc_entry_rundown(de);\n\n\tif (S_ISDIR(de->mode))\n\t\tparent->nlink--;\n\tde->nlink = 0;\n\tWARN(pde_subdir_first(de),\n\t     \"%s: removing non-empty directory '%s/%s', leaking at least '%s'\\n\",\n\t     __func__, de->parent->name, de->name, pde_subdir_first(de)->name);\n\tpde_put(de);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/bitops.h>",
            "#include <linux/idr.h>",
            "#include <linux/init.h>",
            "#include <linux/mount.h>",
            "#include <linux/printk.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/stat.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/time.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_SPINLOCK(proc_subdir_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/bitops.h>\n#include <linux/idr.h>\n#include <linux/init.h>\n#include <linux/mount.h>\n#include <linux/printk.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/stat.h>\n#include <linux/proc_fs.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n\nstatic DEFINE_SPINLOCK(proc_subdir_lock);\n\nvoid remove_proc_entry(const char *name, struct proc_dir_entry *parent)\n{\n\tstruct proc_dir_entry *de = NULL;\n\tconst char *fn = name;\n\tunsigned int len;\n\n\tspin_lock(&proc_subdir_lock);\n\tif (__xlate_proc_name(name, &parent, &fn) != 0) {\n\t\tspin_unlock(&proc_subdir_lock);\n\t\treturn;\n\t}\n\tlen = strlen(fn);\n\n\tde = pde_subdir_find(parent, fn, len);\n\tif (de)\n\t\trb_erase(&de->subdir_node, &parent->subdir);\n\tspin_unlock(&proc_subdir_lock);\n\tif (!de) {\n\t\tWARN(1, \"name '%s'\\n\", name);\n\t\treturn;\n\t}\n\n\tproc_entry_rundown(de);\n\n\tif (S_ISDIR(de->mode))\n\t\tparent->nlink--;\n\tde->nlink = 0;\n\tWARN(pde_subdir_first(de),\n\t     \"%s: removing non-empty directory '%s/%s', leaking at least '%s'\\n\",\n\t     __func__, de->parent->name, de->name, pde_subdir_first(de)->name);\n\tpde_put(de);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_exit_feat_adverts",
          "args": [],
          "line": 5613
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_exit_feat_adverts",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/super.c",
          "lines": "5542-5547",
          "snippet": "static void ext4_exit_feat_adverts(void)\n{\n\tkobject_put(&ext4_feat->f_kobj);\n\twait_for_completion(&ext4_feat->f_kobj_unregister);\n\tkfree(ext4_feat);\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"mballoc.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include \"ext4_extents.h\"\t/* Needed for trace points definition */",
            "#include \"ext4.h\"",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/crc16.h>",
            "#include <linux/log2.h>",
            "#include <linux/ctype.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/random.h>",
            "#include <linux/vfs.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/parser.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/time.h>",
            "#include <linux/fs.h>",
            "#include <linux/string.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct ext4_features *ext4_feat;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"mballoc.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4_extents.h\"\t/* Needed for trace points definition */\n#include \"ext4.h\"\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <asm/uaccess.h>\n#include <linux/cleancache.h>\n#include <linux/crc16.h>\n#include <linux/log2.h>\n#include <linux/ctype.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/random.h>\n#include <linux/vfs.h>\n#include <linux/exportfs.h>\n#include <linux/buffer_head.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/jbd2.h>\n#include <linux/vmalloc.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n#include <linux/string.h>\n#include <linux/module.h>\n\nstatic struct ext4_features *ext4_feat;\n\nstatic void ext4_exit_feat_adverts(void)\n{\n\tkobject_put(&ext4_feat->f_kobj);\n\twait_for_completion(&ext4_feat->f_kobj_unregister);\n\tkfree(ext4_feat);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_exit_mballoc",
          "args": [],
          "line": 5611
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_exit_mballoc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/mballoc.c",
          "lines": "2847-2858",
          "snippet": "void ext4_exit_mballoc(void)\n{\n\t/*\n\t * Wait for completion of call_rcu()'s on ext4_pspace_cachep\n\t * before destroying the slab cache.\n\t */\n\trcu_barrier();\n\tkmem_cache_destroy(ext4_pspace_cachep);\n\tkmem_cache_destroy(ext4_ac_cachep);\n\tkmem_cache_destroy(ext4_free_data_cachep);\n\text4_groupinfo_destroy_slabs();\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/log2.h>",
            "#include \"mballoc.h\"",
            "#include \"ext4_jbd2.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kmem_cache *ext4_pspace_cachep;",
            "static struct kmem_cache *ext4_ac_cachep;",
            "static struct kmem_cache *ext4_free_data_cachep;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/log2.h>\n#include \"mballoc.h\"\n#include \"ext4_jbd2.h\"\n\nstatic struct kmem_cache *ext4_pspace_cachep;\nstatic struct kmem_cache *ext4_ac_cachep;\nstatic struct kmem_cache *ext4_free_data_cachep;\n\nvoid ext4_exit_mballoc(void)\n{\n\t/*\n\t * Wait for completion of call_rcu()'s on ext4_pspace_cachep\n\t * before destroying the slab cache.\n\t */\n\trcu_barrier();\n\tkmem_cache_destroy(ext4_pspace_cachep);\n\tkmem_cache_destroy(ext4_ac_cachep);\n\tkmem_cache_destroy(ext4_free_data_cachep);\n\text4_groupinfo_destroy_slabs();\n}"
        }
      },
      {
        "call_info": {
          "callee": "destroy_inodecache",
          "args": [],
          "line": 5608
        },
        "resolved": true,
        "details": {
          "function_name": "destroy_inodecache",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/super.c",
          "lines": "950-958",
          "snippet": "static void destroy_inodecache(void)\n{\n\t/*\n\t * Make sure all delayed rcu free inodes are flushed before we\n\t * destroy cache.\n\t */\n\trcu_barrier();\n\tkmem_cache_destroy(ext4_inode_cachep);\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"mballoc.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include \"ext4_extents.h\"\t/* Needed for trace points definition */",
            "#include \"ext4.h\"",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/crc16.h>",
            "#include <linux/log2.h>",
            "#include <linux/ctype.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/random.h>",
            "#include <linux/vfs.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/parser.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/time.h>",
            "#include <linux/fs.h>",
            "#include <linux/string.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kmem_cache *ext4_inode_cachep;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"mballoc.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4_extents.h\"\t/* Needed for trace points definition */\n#include \"ext4.h\"\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <asm/uaccess.h>\n#include <linux/cleancache.h>\n#include <linux/crc16.h>\n#include <linux/log2.h>\n#include <linux/ctype.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/random.h>\n#include <linux/vfs.h>\n#include <linux/exportfs.h>\n#include <linux/buffer_head.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/jbd2.h>\n#include <linux/vmalloc.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n#include <linux/string.h>\n#include <linux/module.h>\n\nstatic struct kmem_cache *ext4_inode_cachep;\n\nstatic void destroy_inodecache(void)\n{\n\t/*\n\t * Make sure all delayed rcu free inodes are flushed before we\n\t * destroy cache.\n\t */\n\trcu_barrier();\n\tkmem_cache_destroy(ext4_inode_cachep);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unregister_as_ext3",
          "args": [],
          "line": 5607
        },
        "resolved": true,
        "details": {
          "function_name": "unregister_as_ext3",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/super.c",
          "lines": "5505-5505",
          "snippet": "static inline void unregister_as_ext3(void) { }",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"mballoc.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include \"ext4_extents.h\"\t/* Needed for trace points definition */",
            "#include \"ext4.h\"",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/crc16.h>",
            "#include <linux/log2.h>",
            "#include <linux/ctype.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/random.h>",
            "#include <linux/vfs.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/parser.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/time.h>",
            "#include <linux/fs.h>",
            "#include <linux/string.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"mballoc.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4_extents.h\"\t/* Needed for trace points definition */\n#include \"ext4.h\"\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <asm/uaccess.h>\n#include <linux/cleancache.h>\n#include <linux/crc16.h>\n#include <linux/log2.h>\n#include <linux/ctype.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/random.h>\n#include <linux/vfs.h>\n#include <linux/exportfs.h>\n#include <linux/buffer_head.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/jbd2.h>\n#include <linux/vmalloc.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n#include <linux/string.h>\n#include <linux/module.h>\n\nstatic inline void unregister_as_ext3(void) { }"
        }
      },
      {
        "call_info": {
          "callee": "unregister_as_ext2",
          "args": [],
          "line": 5606
        },
        "resolved": true,
        "details": {
          "function_name": "unregister_as_ext2",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/super.c",
          "lines": "5473-5473",
          "snippet": "static inline void unregister_as_ext2(void) { }",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"mballoc.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include \"ext4_extents.h\"\t/* Needed for trace points definition */",
            "#include \"ext4.h\"",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/crc16.h>",
            "#include <linux/log2.h>",
            "#include <linux/ctype.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/random.h>",
            "#include <linux/vfs.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/parser.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/time.h>",
            "#include <linux/fs.h>",
            "#include <linux/string.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"mballoc.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4_extents.h\"\t/* Needed for trace points definition */\n#include \"ext4.h\"\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <asm/uaccess.h>\n#include <linux/cleancache.h>\n#include <linux/crc16.h>\n#include <linux/log2.h>\n#include <linux/ctype.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/random.h>\n#include <linux/vfs.h>\n#include <linux/exportfs.h>\n#include <linux/buffer_head.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/jbd2.h>\n#include <linux/vmalloc.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n#include <linux/string.h>\n#include <linux/module.h>\n\nstatic inline void unregister_as_ext2(void) { }"
        }
      },
      {
        "call_info": {
          "callee": "register_filesystem",
          "args": [
            "&ext4_fs_type"
          ],
          "line": 5600
        },
        "resolved": true,
        "details": {
          "function_name": "unregister_filesystem",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/filesystems.c",
          "lines": "101-120",
          "snippet": "int unregister_filesystem(struct file_system_type * fs)\n{\n\tstruct file_system_type ** tmp;\n\n\twrite_lock(&file_systems_lock);\n\ttmp = &file_systems;\n\twhile (*tmp) {\n\t\tif (fs == *tmp) {\n\t\t\t*tmp = fs->next;\n\t\t\tfs->next = NULL;\n\t\t\twrite_unlock(&file_systems_lock);\n\t\t\tsynchronize_rcu();\n\t\t\treturn 0;\n\t\t}\n\t\ttmp = &(*tmp)->next;\n\t}\n\twrite_unlock(&file_systems_lock);\n\n\treturn -EINVAL;\n}",
          "includes": [
            "#include <asm/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/kmod.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct file_system_type *file_systems;",
            "static DEFINE_RWLOCK(file_systems_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/uaccess.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kmod.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n\nstatic struct file_system_type *file_systems;\nstatic DEFINE_RWLOCK(file_systems_lock);\n\nint unregister_filesystem(struct file_system_type * fs)\n{\n\tstruct file_system_type ** tmp;\n\n\twrite_lock(&file_systems_lock);\n\ttmp = &file_systems;\n\twhile (*tmp) {\n\t\tif (fs == *tmp) {\n\t\t\t*tmp = fs->next;\n\t\t\tfs->next = NULL;\n\t\t\twrite_unlock(&file_systems_lock);\n\t\t\tsynchronize_rcu();\n\t\t\treturn 0;\n\t\t}\n\t\ttmp = &(*tmp)->next;\n\t}\n\twrite_unlock(&file_systems_lock);\n\n\treturn -EINVAL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "init_inodecache",
          "args": [],
          "line": 5595
        },
        "resolved": true,
        "details": {
          "function_name": "init_inodecache",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/super.c",
          "lines": "938-948",
          "snippet": "static int __init init_inodecache(void)\n{\n\text4_inode_cachep = kmem_cache_create(\"ext4_inode_cache\",\n\t\t\t\t\t     sizeof(struct ext4_inode_info),\n\t\t\t\t\t     0, (SLAB_RECLAIM_ACCOUNT|\n\t\t\t\t\t\tSLAB_MEM_SPREAD),\n\t\t\t\t\t     init_once);\n\tif (ext4_inode_cachep == NULL)\n\t\treturn -ENOMEM;\n\treturn 0;\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"mballoc.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include \"ext4_extents.h\"\t/* Needed for trace points definition */",
            "#include \"ext4.h\"",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/crc16.h>",
            "#include <linux/log2.h>",
            "#include <linux/ctype.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/random.h>",
            "#include <linux/vfs.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/parser.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/time.h>",
            "#include <linux/fs.h>",
            "#include <linux/string.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kmem_cache *ext4_inode_cachep;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"mballoc.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4_extents.h\"\t/* Needed for trace points definition */\n#include \"ext4.h\"\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <asm/uaccess.h>\n#include <linux/cleancache.h>\n#include <linux/crc16.h>\n#include <linux/log2.h>\n#include <linux/ctype.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/random.h>\n#include <linux/vfs.h>\n#include <linux/exportfs.h>\n#include <linux/buffer_head.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/jbd2.h>\n#include <linux/vmalloc.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n#include <linux/string.h>\n#include <linux/module.h>\n\nstatic struct kmem_cache *ext4_inode_cachep;\n\nstatic int __init init_inodecache(void)\n{\n\text4_inode_cachep = kmem_cache_create(\"ext4_inode_cache\",\n\t\t\t\t\t     sizeof(struct ext4_inode_info),\n\t\t\t\t\t     0, (SLAB_RECLAIM_ACCOUNT|\n\t\t\t\t\t\tSLAB_MEM_SPREAD),\n\t\t\t\t\t     init_once);\n\tif (ext4_inode_cachep == NULL)\n\t\treturn -ENOMEM;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_init_mballoc",
          "args": [],
          "line": 5590
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_init_mballoc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/mballoc.c",
          "lines": "2823-2845",
          "snippet": "int __init ext4_init_mballoc(void)\n{\n\text4_pspace_cachep = KMEM_CACHE(ext4_prealloc_space,\n\t\t\t\t\tSLAB_RECLAIM_ACCOUNT);\n\tif (ext4_pspace_cachep == NULL)\n\t\treturn -ENOMEM;\n\n\text4_ac_cachep = KMEM_CACHE(ext4_allocation_context,\n\t\t\t\t    SLAB_RECLAIM_ACCOUNT);\n\tif (ext4_ac_cachep == NULL) {\n\t\tkmem_cache_destroy(ext4_pspace_cachep);\n\t\treturn -ENOMEM;\n\t}\n\n\text4_free_data_cachep = KMEM_CACHE(ext4_free_data,\n\t\t\t\t\t   SLAB_RECLAIM_ACCOUNT);\n\tif (ext4_free_data_cachep == NULL) {\n\t\tkmem_cache_destroy(ext4_pspace_cachep);\n\t\tkmem_cache_destroy(ext4_ac_cachep);\n\t\treturn -ENOMEM;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/log2.h>",
            "#include \"mballoc.h\"",
            "#include \"ext4_jbd2.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kmem_cache *ext4_pspace_cachep;",
            "static struct kmem_cache *ext4_ac_cachep;",
            "static struct kmem_cache *ext4_free_data_cachep;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/log2.h>\n#include \"mballoc.h\"\n#include \"ext4_jbd2.h\"\n\nstatic struct kmem_cache *ext4_pspace_cachep;\nstatic struct kmem_cache *ext4_ac_cachep;\nstatic struct kmem_cache *ext4_free_data_cachep;\n\nint __init ext4_init_mballoc(void)\n{\n\text4_pspace_cachep = KMEM_CACHE(ext4_prealloc_space,\n\t\t\t\t\tSLAB_RECLAIM_ACCOUNT);\n\tif (ext4_pspace_cachep == NULL)\n\t\treturn -ENOMEM;\n\n\text4_ac_cachep = KMEM_CACHE(ext4_allocation_context,\n\t\t\t\t    SLAB_RECLAIM_ACCOUNT);\n\tif (ext4_ac_cachep == NULL) {\n\t\tkmem_cache_destroy(ext4_pspace_cachep);\n\t\treturn -ENOMEM;\n\t}\n\n\text4_free_data_cachep = KMEM_CACHE(ext4_free_data,\n\t\t\t\t\t   SLAB_RECLAIM_ACCOUNT);\n\tif (ext4_free_data_cachep == NULL) {\n\t\tkmem_cache_destroy(ext4_pspace_cachep);\n\t\tkmem_cache_destroy(ext4_ac_cachep);\n\t\treturn -ENOMEM;\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_init_feat_adverts",
          "args": [],
          "line": 5586
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_init_feat_adverts",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/super.c",
          "lines": "5518-5540",
          "snippet": "static int __init ext4_init_feat_adverts(void)\n{\n\tstruct ext4_features *ef;\n\tint ret = -ENOMEM;\n\n\tef = kzalloc(sizeof(struct ext4_features), GFP_KERNEL);\n\tif (!ef)\n\t\tgoto out;\n\n\tef->f_kobj.kset = ext4_kset;\n\tinit_completion(&ef->f_kobj_unregister);\n\tret = kobject_init_and_add(&ef->f_kobj, &ext4_feat_ktype, NULL,\n\t\t\t\t   \"features\");\n\tif (ret) {\n\t\tkfree(ef);\n\t\tgoto out;\n\t}\n\n\text4_feat = ef;\n\tret = 0;\nout:\n\treturn ret;\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"mballoc.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include \"ext4_extents.h\"\t/* Needed for trace points definition */",
            "#include \"ext4.h\"",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/crc16.h>",
            "#include <linux/log2.h>",
            "#include <linux/ctype.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/random.h>",
            "#include <linux/vfs.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/parser.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/time.h>",
            "#include <linux/fs.h>",
            "#include <linux/string.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kset *ext4_kset;",
            "static struct ext4_features *ext4_feat;",
            "static struct kobj_type ext4_feat_ktype = {\n\t.default_attrs\t= ext4_feat_attrs,\n\t.sysfs_ops\t= &ext4_feat_ops,\n\t.release\t= ext4_feat_release,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"mballoc.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4_extents.h\"\t/* Needed for trace points definition */\n#include \"ext4.h\"\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <asm/uaccess.h>\n#include <linux/cleancache.h>\n#include <linux/crc16.h>\n#include <linux/log2.h>\n#include <linux/ctype.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/random.h>\n#include <linux/vfs.h>\n#include <linux/exportfs.h>\n#include <linux/buffer_head.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/jbd2.h>\n#include <linux/vmalloc.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n#include <linux/string.h>\n#include <linux/module.h>\n\nstatic struct kset *ext4_kset;\nstatic struct ext4_features *ext4_feat;\nstatic struct kobj_type ext4_feat_ktype = {\n\t.default_attrs\t= ext4_feat_attrs,\n\t.sysfs_ops\t= &ext4_feat_ops,\n\t.release\t= ext4_feat_release,\n};\n\nstatic int __init ext4_init_feat_adverts(void)\n{\n\tstruct ext4_features *ef;\n\tint ret = -ENOMEM;\n\n\tef = kzalloc(sizeof(struct ext4_features), GFP_KERNEL);\n\tif (!ef)\n\t\tgoto out;\n\n\tef->f_kobj.kset = ext4_kset;\n\tinit_completion(&ef->f_kobj_unregister);\n\tret = kobject_init_and_add(&ef->f_kobj, &ext4_feat_ktype, NULL,\n\t\t\t\t   \"features\");\n\tif (ret) {\n\t\tkfree(ef);\n\t\tgoto out;\n\t}\n\n\text4_feat = ef;\n\tret = 0;\nout:\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "proc_mkdir",
          "args": [
            "\"fs/ext4\"",
            "NULL"
          ],
          "line": 5584
        },
        "resolved": true,
        "details": {
          "function_name": "proc_mkdir",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/generic.c",
          "lines": "451-455",
          "snippet": "struct proc_dir_entry *proc_mkdir(const char *name,\n\t\tstruct proc_dir_entry *parent)\n{\n\treturn proc_mkdir_data(name, 0, parent, NULL);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/bitops.h>",
            "#include <linux/idr.h>",
            "#include <linux/init.h>",
            "#include <linux/mount.h>",
            "#include <linux/printk.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/stat.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/time.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/bitops.h>\n#include <linux/idr.h>\n#include <linux/init.h>\n#include <linux/mount.h>\n#include <linux/printk.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/stat.h>\n#include <linux/proc_fs.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n\nstruct proc_dir_entry *proc_mkdir(const char *name,\n\t\tstruct proc_dir_entry *parent)\n{\n\treturn proc_mkdir_data(name, 0, parent, NULL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kset_create_and_add",
          "args": [
            "\"ext4\"",
            "NULL",
            "fs_kobj"
          ],
          "line": 5579
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_init_system_zone",
          "args": [],
          "line": 5576
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_init_system_zone",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/block_validity.c",
          "lines": "31-37",
          "snippet": "int __init ext4_init_system_zone(void)\n{\n\text4_system_zone_cachep = KMEM_CACHE(ext4_system_zone, 0);\n\tif (ext4_system_zone_cachep == NULL)\n\t\treturn -ENOMEM;\n\treturn 0;\n}",
          "includes": [
            "#include \"ext4.h\"",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kmem_cache *ext4_system_zone_cachep;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ext4.h\"\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/blkdev.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/buffer_head.h>\n#include <linux/quotaops.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n\nstatic struct kmem_cache *ext4_system_zone_cachep;\n\nint __init ext4_init_system_zone(void)\n{\n\text4_system_zone_cachep = KMEM_CACHE(ext4_system_zone, 0);\n\tif (ext4_system_zone_cachep == NULL)\n\t\treturn -ENOMEM;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_init_pageio",
          "args": [],
          "line": 5572
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_init_pageio",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/page-io.c",
          "lines": "36-42",
          "snippet": "int __init ext4_init_pageio(void)\n{\n\tio_end_cachep = KMEM_CACHE(ext4_io_end, SLAB_RECLAIM_ACCOUNT);\n\tif (io_end_cachep == NULL)\n\t\treturn -ENOMEM;\n\treturn 0;\n}",
          "includes": [
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include <linux/ratelimit.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/bio.h>",
            "#include <linux/uio.h>",
            "#include <linux/aio.h>",
            "#include <linux/namei.h>",
            "#include <linux/mpage.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highuid.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/time.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kmem_cache *io_end_cachep;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include <linux/ratelimit.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/workqueue.h>\n#include <linux/bio.h>\n#include <linux/uio.h>\n#include <linux/aio.h>\n#include <linux/namei.h>\n#include <linux/mpage.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/highuid.h>\n#include <linux/jbd2.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n\nstatic struct kmem_cache *io_end_cachep;\n\nint __init ext4_init_pageio(void)\n{\n\tio_end_cachep = KMEM_CACHE(ext4_io_end, SLAB_RECLAIM_ACCOUNT);\n\tif (io_end_cachep == NULL)\n\t\treturn -ENOMEM;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_init_es",
          "args": [],
          "line": 5568
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_init_es",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/extents_status.c",
          "lines": "154-162",
          "snippet": "int __init ext4_init_es(void)\n{\n\text4_es_cachep = kmem_cache_create(\"ext4_extent_status\",\n\t\t\t\t\t   sizeof(struct extent_status),\n\t\t\t\t\t   0, (SLAB_RECLAIM_ACCOUNT), NULL);\n\tif (ext4_es_cachep == NULL)\n\t\treturn -ENOMEM;\n\treturn 0;\n}",
          "includes": [
            "#include \"ext4_extents.h\"\t/* Needed when ES_AGGRESSIVE_TEST is defined */",
            "#include <trace/events/ext4.h>",
            "#include \"extents_status.h\"",
            "#include \"ext4.h\"",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/list_sort.h>",
            "#include <linux/rbtree.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kmem_cache *ext4_es_cachep;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ext4_extents.h\"\t/* Needed when ES_AGGRESSIVE_TEST is defined */\n#include <trace/events/ext4.h>\n#include \"extents_status.h\"\n#include \"ext4.h\"\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/list_sort.h>\n#include <linux/rbtree.h>\n\nstatic struct kmem_cache *ext4_es_cachep;\n\nint __init ext4_init_es(void)\n{\n\text4_es_cachep = kmem_cache_create(\"ext4_extent_status\",\n\t\t\t\t\t   sizeof(struct extent_status),\n\t\t\t\t\t   0, (SLAB_RECLAIM_ACCOUNT), NULL);\n\tif (ext4_es_cachep == NULL)\n\t\treturn -ENOMEM;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "init_waitqueue_head",
          "args": [
            "&ext4__ioend_wq[i]"
          ],
          "line": 5565
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_init",
          "args": [
            "&ext4__aio_mutex[i]"
          ],
          "line": 5564
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_check_flag_values",
          "args": [],
          "line": 5561
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_check_flag_values",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ext4.h",
          "lines": "457-483",
          "snippet": "static inline void ext4_check_flag_values(void)\n{\n\tCHECK_FLAG_VALUE(SECRM);\n\tCHECK_FLAG_VALUE(UNRM);\n\tCHECK_FLAG_VALUE(COMPR);\n\tCHECK_FLAG_VALUE(SYNC);\n\tCHECK_FLAG_VALUE(IMMUTABLE);\n\tCHECK_FLAG_VALUE(APPEND);\n\tCHECK_FLAG_VALUE(NODUMP);\n\tCHECK_FLAG_VALUE(NOATIME);\n\tCHECK_FLAG_VALUE(DIRTY);\n\tCHECK_FLAG_VALUE(COMPRBLK);\n\tCHECK_FLAG_VALUE(NOCOMPR);\n\tCHECK_FLAG_VALUE(ENCRYPT);\n\tCHECK_FLAG_VALUE(INDEX);\n\tCHECK_FLAG_VALUE(IMAGIC);\n\tCHECK_FLAG_VALUE(JOURNAL_DATA);\n\tCHECK_FLAG_VALUE(NOTAIL);\n\tCHECK_FLAG_VALUE(DIRSYNC);\n\tCHECK_FLAG_VALUE(TOPDIR);\n\tCHECK_FLAG_VALUE(HUGE_FILE);\n\tCHECK_FLAG_VALUE(EXTENTS);\n\tCHECK_FLAG_VALUE(EA_INODE);\n\tCHECK_FLAG_VALUE(EOFBLOCKS);\n\tCHECK_FLAG_VALUE(INLINE_DATA);\n\tCHECK_FLAG_VALUE(RESERVED);\n}",
          "includes": [
            "#include \"extents_status.h\"",
            "#include <linux/compat.h>",
            "#include <linux/falloc.h>",
            "#include <crypto/hash.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/wait.h>",
            "#include <linux/timer.h>",
            "#include <linux/mutex.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/quota.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extents_status.h\"\n#include <linux/compat.h>\n#include <linux/falloc.h>\n#include <crypto/hash.h>\n#include <linux/ratelimit.h>\n#include <linux/percpu_counter.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/wait.h>\n#include <linux/timer.h>\n#include <linux/mutex.h>\n#include <linux/seqlock.h>\n#include <linux/rbtree.h>\n#include <linux/rwsem.h>\n#include <linux/quota.h>\n#include <linux/jbd2.h>\n#include <linux/magic.h>\n#include <linux/blkdev.h>\n#include <linux/types.h>\n\nstatic inline void ext4_check_flag_values(void)\n{\n\tCHECK_FLAG_VALUE(SECRM);\n\tCHECK_FLAG_VALUE(UNRM);\n\tCHECK_FLAG_VALUE(COMPR);\n\tCHECK_FLAG_VALUE(SYNC);\n\tCHECK_FLAG_VALUE(IMMUTABLE);\n\tCHECK_FLAG_VALUE(APPEND);\n\tCHECK_FLAG_VALUE(NODUMP);\n\tCHECK_FLAG_VALUE(NOATIME);\n\tCHECK_FLAG_VALUE(DIRTY);\n\tCHECK_FLAG_VALUE(COMPRBLK);\n\tCHECK_FLAG_VALUE(NOCOMPR);\n\tCHECK_FLAG_VALUE(ENCRYPT);\n\tCHECK_FLAG_VALUE(INDEX);\n\tCHECK_FLAG_VALUE(IMAGIC);\n\tCHECK_FLAG_VALUE(JOURNAL_DATA);\n\tCHECK_FLAG_VALUE(NOTAIL);\n\tCHECK_FLAG_VALUE(DIRSYNC);\n\tCHECK_FLAG_VALUE(TOPDIR);\n\tCHECK_FLAG_VALUE(HUGE_FILE);\n\tCHECK_FLAG_VALUE(EXTENTS);\n\tCHECK_FLAG_VALUE(EA_INODE);\n\tCHECK_FLAG_VALUE(EOFBLOCKS);\n\tCHECK_FLAG_VALUE(INLINE_DATA);\n\tCHECK_FLAG_VALUE(RESERVED);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_init",
          "args": [
            "&ext4_li_mtx"
          ],
          "line": 5558
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"mballoc.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4_extents.h\"\t/* Needed for trace points definition */\n#include \"ext4.h\"\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <asm/uaccess.h>\n#include <linux/cleancache.h>\n#include <linux/crc16.h>\n#include <linux/log2.h>\n#include <linux/ctype.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/random.h>\n#include <linux/vfs.h>\n#include <linux/exportfs.h>\n#include <linux/buffer_head.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/jbd2.h>\n#include <linux/vmalloc.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n#include <linux/string.h>\n#include <linux/module.h>\n\nstatic struct proc_dir_entry *ext4_proc_root;\nstatic struct kset *ext4_kset;\nstatic struct ext4_lazy_init *ext4_li_info;\nstatic struct mutex ext4_li_mtx;\nstatic int ext4_mballoc_ready;\nstatic struct file_system_type ext4_fs_type = {\n\t.owner\t\t= THIS_MODULE,\n\t.name\t\t= \"ext4\",\n\t.mount\t\t= ext4_mount,\n\t.kill_sb\t= kill_block_super,\n\t.fs_flags\t= FS_REQUIRES_DEV,\n};\nwait_queue_head_t ext4__ioend_wq[EXT4_WQ_HASH_SZ];\nstruct mutex ext4__aio_mutex[EXT4_WQ_HASH_SZ];\n\nstatic int __init ext4_init_fs(void)\n{\n\tint i, err;\n\n\text4_li_info = NULL;\n\tmutex_init(&ext4_li_mtx);\n\n\t/* Build-time check for flags consistency */\n\text4_check_flag_values();\n\n\tfor (i = 0; i < EXT4_WQ_HASH_SZ; i++) {\n\t\tmutex_init(&ext4__aio_mutex[i]);\n\t\tinit_waitqueue_head(&ext4__ioend_wq[i]);\n\t}\n\n\terr = ext4_init_es();\n\tif (err)\n\t\treturn err;\n\n\terr = ext4_init_pageio();\n\tif (err)\n\t\tgoto out7;\n\n\terr = ext4_init_system_zone();\n\tif (err)\n\t\tgoto out6;\n\text4_kset = kset_create_and_add(\"ext4\", NULL, fs_kobj);\n\tif (!ext4_kset) {\n\t\terr = -ENOMEM;\n\t\tgoto out5;\n\t}\n\text4_proc_root = proc_mkdir(\"fs/ext4\", NULL);\n\n\terr = ext4_init_feat_adverts();\n\tif (err)\n\t\tgoto out4;\n\n\terr = ext4_init_mballoc();\n\tif (err)\n\t\tgoto out2;\n\telse\n\t\text4_mballoc_ready = 1;\n\terr = init_inodecache();\n\tif (err)\n\t\tgoto out1;\n\tregister_as_ext3();\n\tregister_as_ext2();\n\terr = register_filesystem(&ext4_fs_type);\n\tif (err)\n\t\tgoto out;\n\n\treturn 0;\nout:\n\tunregister_as_ext2();\n\tunregister_as_ext3();\n\tdestroy_inodecache();\nout1:\n\text4_mballoc_ready = 0;\n\text4_exit_mballoc();\nout2:\n\text4_exit_feat_adverts();\nout4:\n\tif (ext4_proc_root)\n\t\tremove_proc_entry(\"fs/ext4\", NULL);\n\tkset_unregister(ext4_kset);\nout5:\n\text4_exit_system_zone();\nout6:\n\text4_exit_pageio();\nout7:\n\text4_exit_es();\n\n\treturn err;\n}"
  },
  {
    "function_name": "ext4_exit_feat_adverts",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/super.c",
    "lines": "5542-5547",
    "snippet": "static void ext4_exit_feat_adverts(void)\n{\n\tkobject_put(&ext4_feat->f_kobj);\n\twait_for_completion(&ext4_feat->f_kobj_unregister);\n\tkfree(ext4_feat);\n}",
    "includes": [
      "#include <trace/events/ext4.h>",
      "#include \"mballoc.h\"",
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"ext4_jbd2.h\"",
      "#include \"ext4_extents.h\"\t/* Needed for trace points definition */",
      "#include \"ext4.h\"",
      "#include <linux/freezer.h>",
      "#include <linux/kthread.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/cleancache.h>",
      "#include <linux/crc16.h>",
      "#include <linux/log2.h>",
      "#include <linux/ctype.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/namei.h>",
      "#include <linux/mount.h>",
      "#include <linux/random.h>",
      "#include <linux/vfs.h>",
      "#include <linux/exportfs.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/parser.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/init.h>",
      "#include <linux/slab.h>",
      "#include <linux/jbd2.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/time.h>",
      "#include <linux/fs.h>",
      "#include <linux/string.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct ext4_features *ext4_feat;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "ext4_feat"
          ],
          "line": 5546
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wait_for_completion",
          "args": [
            "&ext4_feat->f_kobj_unregister"
          ],
          "line": 5545
        },
        "resolved": true,
        "details": {
          "function_name": "nfs4_wait_for_completion_rpc_task",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/nfs4proc.c",
          "lines": "1116-1122",
          "snippet": "static int nfs4_wait_for_completion_rpc_task(struct rpc_task *task)\n{\n\tint ret;\n\n\tret = rpc_wait_for_completion_task(task);\n\treturn ret;\n}",
          "includes": [
            "#include \"nfs4trace.h\"",
            "#include \"fscache.h\"",
            "#include \"nfs4session.h\"",
            "#include \"netns.h\"",
            "#include \"pnfs.h\"",
            "#include \"callback.h\"",
            "#include \"iostat.h\"",
            "#include \"internal.h\"",
            "#include \"delegation.h\"",
            "#include \"nfs4_fs.h\"",
            "#include <linux/freezer.h>",
            "#include <linux/utsname.h>",
            "#include <linux/xattr.h>",
            "#include <linux/nfs_idmap.h>",
            "#include <linux/module.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/nfs_mount.h>",
            "#include <linux/nfs_page.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/nfs4.h>",
            "#include <linux/nfs.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/slab.h>",
            "#include <linux/printk.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/string.h>",
            "#include <linux/errno.h>",
            "#include <linux/delay.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"nfs4trace.h\"\n#include \"fscache.h\"\n#include \"nfs4session.h\"\n#include \"netns.h\"\n#include \"pnfs.h\"\n#include \"callback.h\"\n#include \"iostat.h\"\n#include \"internal.h\"\n#include \"delegation.h\"\n#include \"nfs4_fs.h\"\n#include <linux/freezer.h>\n#include <linux/utsname.h>\n#include <linux/xattr.h>\n#include <linux/nfs_idmap.h>\n#include <linux/module.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/nfs_mount.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_fs.h>\n#include <linux/nfs4.h>\n#include <linux/nfs.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/slab.h>\n#include <linux/printk.h>\n#include <linux/ratelimit.h>\n#include <linux/string.h>\n#include <linux/errno.h>\n#include <linux/delay.h>\n#include <linux/mm.h>\n\nstatic int nfs4_wait_for_completion_rpc_task(struct rpc_task *task)\n{\n\tint ret;\n\n\tret = rpc_wait_for_completion_task(task);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kobject_put",
          "args": [
            "&ext4_feat->f_kobj"
          ],
          "line": 5544
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"mballoc.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4_extents.h\"\t/* Needed for trace points definition */\n#include \"ext4.h\"\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <asm/uaccess.h>\n#include <linux/cleancache.h>\n#include <linux/crc16.h>\n#include <linux/log2.h>\n#include <linux/ctype.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/random.h>\n#include <linux/vfs.h>\n#include <linux/exportfs.h>\n#include <linux/buffer_head.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/jbd2.h>\n#include <linux/vmalloc.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n#include <linux/string.h>\n#include <linux/module.h>\n\nstatic struct ext4_features *ext4_feat;\n\nstatic void ext4_exit_feat_adverts(void)\n{\n\tkobject_put(&ext4_feat->f_kobj);\n\twait_for_completion(&ext4_feat->f_kobj_unregister);\n\tkfree(ext4_feat);\n}"
  },
  {
    "function_name": "ext4_init_feat_adverts",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/super.c",
    "lines": "5518-5540",
    "snippet": "static int __init ext4_init_feat_adverts(void)\n{\n\tstruct ext4_features *ef;\n\tint ret = -ENOMEM;\n\n\tef = kzalloc(sizeof(struct ext4_features), GFP_KERNEL);\n\tif (!ef)\n\t\tgoto out;\n\n\tef->f_kobj.kset = ext4_kset;\n\tinit_completion(&ef->f_kobj_unregister);\n\tret = kobject_init_and_add(&ef->f_kobj, &ext4_feat_ktype, NULL,\n\t\t\t\t   \"features\");\n\tif (ret) {\n\t\tkfree(ef);\n\t\tgoto out;\n\t}\n\n\text4_feat = ef;\n\tret = 0;\nout:\n\treturn ret;\n}",
    "includes": [
      "#include <trace/events/ext4.h>",
      "#include \"mballoc.h\"",
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"ext4_jbd2.h\"",
      "#include \"ext4_extents.h\"\t/* Needed for trace points definition */",
      "#include \"ext4.h\"",
      "#include <linux/freezer.h>",
      "#include <linux/kthread.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/cleancache.h>",
      "#include <linux/crc16.h>",
      "#include <linux/log2.h>",
      "#include <linux/ctype.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/namei.h>",
      "#include <linux/mount.h>",
      "#include <linux/random.h>",
      "#include <linux/vfs.h>",
      "#include <linux/exportfs.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/parser.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/init.h>",
      "#include <linux/slab.h>",
      "#include <linux/jbd2.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/time.h>",
      "#include <linux/fs.h>",
      "#include <linux/string.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct kset *ext4_kset;",
      "static struct ext4_features *ext4_feat;",
      "static struct kobj_type ext4_feat_ktype = {\n\t.default_attrs\t= ext4_feat_attrs,\n\t.sysfs_ops\t= &ext4_feat_ops,\n\t.release\t= ext4_feat_release,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "ef"
          ],
          "line": 5532
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kobject_init_and_add",
          "args": [
            "&ef->f_kobj",
            "&ext4_feat_ktype",
            "NULL",
            "\"features\""
          ],
          "line": 5529
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "init_completion",
          "args": [
            "&ef->f_kobj_unregister"
          ],
          "line": 5528
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "sizeof(struct ext4_features)",
            "GFP_KERNEL"
          ],
          "line": 5523
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"mballoc.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4_extents.h\"\t/* Needed for trace points definition */\n#include \"ext4.h\"\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <asm/uaccess.h>\n#include <linux/cleancache.h>\n#include <linux/crc16.h>\n#include <linux/log2.h>\n#include <linux/ctype.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/random.h>\n#include <linux/vfs.h>\n#include <linux/exportfs.h>\n#include <linux/buffer_head.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/jbd2.h>\n#include <linux/vmalloc.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n#include <linux/string.h>\n#include <linux/module.h>\n\nstatic struct kset *ext4_kset;\nstatic struct ext4_features *ext4_feat;\nstatic struct kobj_type ext4_feat_ktype = {\n\t.default_attrs\t= ext4_feat_attrs,\n\t.sysfs_ops\t= &ext4_feat_ops,\n\t.release\t= ext4_feat_release,\n};\n\nstatic int __init ext4_init_feat_adverts(void)\n{\n\tstruct ext4_features *ef;\n\tint ret = -ENOMEM;\n\n\tef = kzalloc(sizeof(struct ext4_features), GFP_KERNEL);\n\tif (!ef)\n\t\tgoto out;\n\n\tef->f_kobj.kset = ext4_kset;\n\tinit_completion(&ef->f_kobj_unregister);\n\tret = kobject_init_and_add(&ef->f_kobj, &ext4_feat_ktype, NULL,\n\t\t\t\t   \"features\");\n\tif (ret) {\n\t\tkfree(ef);\n\t\tgoto out;\n\t}\n\n\text4_feat = ef;\n\tret = 0;\nout:\n\treturn ret;\n}"
  },
  {
    "function_name": "ext3_feature_set_ok",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/super.c",
    "lines": "5506-5506",
    "snippet": "static inline int ext3_feature_set_ok(struct super_block *sb) { return 0; }",
    "includes": [
      "#include <trace/events/ext4.h>",
      "#include \"mballoc.h\"",
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"ext4_jbd2.h\"",
      "#include \"ext4_extents.h\"\t/* Needed for trace points definition */",
      "#include \"ext4.h\"",
      "#include <linux/freezer.h>",
      "#include <linux/kthread.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/cleancache.h>",
      "#include <linux/crc16.h>",
      "#include <linux/log2.h>",
      "#include <linux/ctype.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/namei.h>",
      "#include <linux/mount.h>",
      "#include <linux/random.h>",
      "#include <linux/vfs.h>",
      "#include <linux/exportfs.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/parser.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/init.h>",
      "#include <linux/slab.h>",
      "#include <linux/jbd2.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/time.h>",
      "#include <linux/fs.h>",
      "#include <linux/string.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ext4_unfreeze(struct super_block *sb);",
      "static int ext4_freeze(struct super_block *sb);",
      "static inline int ext2_feature_set_ok(struct super_block *sb);",
      "static inline int ext3_feature_set_ok(struct super_block *sb);",
      "static void ext4_unregister_li_request(struct super_block *sb);"
    ],
    "called_functions": [],
    "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"mballoc.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4_extents.h\"\t/* Needed for trace points definition */\n#include \"ext4.h\"\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <asm/uaccess.h>\n#include <linux/cleancache.h>\n#include <linux/crc16.h>\n#include <linux/log2.h>\n#include <linux/ctype.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/random.h>\n#include <linux/vfs.h>\n#include <linux/exportfs.h>\n#include <linux/buffer_head.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/jbd2.h>\n#include <linux/vmalloc.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n#include <linux/string.h>\n#include <linux/module.h>\n\nstatic int ext4_unfreeze(struct super_block *sb);\nstatic int ext4_freeze(struct super_block *sb);\nstatic inline int ext2_feature_set_ok(struct super_block *sb);\nstatic inline int ext3_feature_set_ok(struct super_block *sb);\nstatic void ext4_unregister_li_request(struct super_block *sb);\n\nstatic inline int ext3_feature_set_ok(struct super_block *sb) { return 0; }"
  },
  {
    "function_name": "unregister_as_ext3",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/super.c",
    "lines": "5505-5505",
    "snippet": "static inline void unregister_as_ext3(void) { }",
    "includes": [
      "#include <trace/events/ext4.h>",
      "#include \"mballoc.h\"",
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"ext4_jbd2.h\"",
      "#include \"ext4_extents.h\"\t/* Needed for trace points definition */",
      "#include \"ext4.h\"",
      "#include <linux/freezer.h>",
      "#include <linux/kthread.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/cleancache.h>",
      "#include <linux/crc16.h>",
      "#include <linux/log2.h>",
      "#include <linux/ctype.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/namei.h>",
      "#include <linux/mount.h>",
      "#include <linux/random.h>",
      "#include <linux/vfs.h>",
      "#include <linux/exportfs.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/parser.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/init.h>",
      "#include <linux/slab.h>",
      "#include <linux/jbd2.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/time.h>",
      "#include <linux/fs.h>",
      "#include <linux/string.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"mballoc.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4_extents.h\"\t/* Needed for trace points definition */\n#include \"ext4.h\"\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <asm/uaccess.h>\n#include <linux/cleancache.h>\n#include <linux/crc16.h>\n#include <linux/log2.h>\n#include <linux/ctype.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/random.h>\n#include <linux/vfs.h>\n#include <linux/exportfs.h>\n#include <linux/buffer_head.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/jbd2.h>\n#include <linux/vmalloc.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n#include <linux/string.h>\n#include <linux/module.h>\n\nstatic inline void unregister_as_ext3(void) { }"
  },
  {
    "function_name": "register_as_ext3",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/super.c",
    "lines": "5504-5504",
    "snippet": "static inline void register_as_ext3(void) { }",
    "includes": [
      "#include <trace/events/ext4.h>",
      "#include \"mballoc.h\"",
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"ext4_jbd2.h\"",
      "#include \"ext4_extents.h\"\t/* Needed for trace points definition */",
      "#include \"ext4.h\"",
      "#include <linux/freezer.h>",
      "#include <linux/kthread.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/cleancache.h>",
      "#include <linux/crc16.h>",
      "#include <linux/log2.h>",
      "#include <linux/ctype.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/namei.h>",
      "#include <linux/mount.h>",
      "#include <linux/random.h>",
      "#include <linux/vfs.h>",
      "#include <linux/exportfs.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/parser.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/init.h>",
      "#include <linux/slab.h>",
      "#include <linux/jbd2.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/time.h>",
      "#include <linux/fs.h>",
      "#include <linux/string.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"mballoc.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4_extents.h\"\t/* Needed for trace points definition */\n#include \"ext4.h\"\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <asm/uaccess.h>\n#include <linux/cleancache.h>\n#include <linux/crc16.h>\n#include <linux/log2.h>\n#include <linux/ctype.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/random.h>\n#include <linux/vfs.h>\n#include <linux/exportfs.h>\n#include <linux/buffer_head.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/jbd2.h>\n#include <linux/vmalloc.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n#include <linux/string.h>\n#include <linux/module.h>\n\nstatic inline void register_as_ext3(void) { }"
  },
  {
    "function_name": "ext3_feature_set_ok",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/super.c",
    "lines": "5491-5502",
    "snippet": "static inline int ext3_feature_set_ok(struct super_block *sb)\n{\n\tif (EXT4_HAS_INCOMPAT_FEATURE(sb, ~EXT3_FEATURE_INCOMPAT_SUPP))\n\t\treturn 0;\n\tif (!EXT4_HAS_COMPAT_FEATURE(sb, EXT4_FEATURE_COMPAT_HAS_JOURNAL))\n\t\treturn 0;\n\tif (sb->s_flags & MS_RDONLY)\n\t\treturn 1;\n\tif (EXT4_HAS_RO_COMPAT_FEATURE(sb, ~EXT3_FEATURE_RO_COMPAT_SUPP))\n\t\treturn 0;\n\treturn 1;\n}",
    "includes": [
      "#include <trace/events/ext4.h>",
      "#include \"mballoc.h\"",
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"ext4_jbd2.h\"",
      "#include \"ext4_extents.h\"\t/* Needed for trace points definition */",
      "#include \"ext4.h\"",
      "#include <linux/freezer.h>",
      "#include <linux/kthread.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/cleancache.h>",
      "#include <linux/crc16.h>",
      "#include <linux/log2.h>",
      "#include <linux/ctype.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/namei.h>",
      "#include <linux/mount.h>",
      "#include <linux/random.h>",
      "#include <linux/vfs.h>",
      "#include <linux/exportfs.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/parser.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/init.h>",
      "#include <linux/slab.h>",
      "#include <linux/jbd2.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/time.h>",
      "#include <linux/fs.h>",
      "#include <linux/string.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ext4_unfreeze(struct super_block *sb);",
      "static int ext4_freeze(struct super_block *sb);",
      "static inline int ext2_feature_set_ok(struct super_block *sb);",
      "static inline int ext3_feature_set_ok(struct super_block *sb);",
      "static void ext4_unregister_li_request(struct super_block *sb);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "EXT4_HAS_RO_COMPAT_FEATURE",
          "args": [
            "sb",
            "~EXT3_FEATURE_RO_COMPAT_SUPP"
          ],
          "line": 5499
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXT4_HAS_COMPAT_FEATURE",
          "args": [
            "sb",
            "EXT4_FEATURE_COMPAT_HAS_JOURNAL"
          ],
          "line": 5495
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXT4_HAS_INCOMPAT_FEATURE",
          "args": [
            "sb",
            "~EXT3_FEATURE_INCOMPAT_SUPP"
          ],
          "line": 5493
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"mballoc.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4_extents.h\"\t/* Needed for trace points definition */\n#include \"ext4.h\"\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <asm/uaccess.h>\n#include <linux/cleancache.h>\n#include <linux/crc16.h>\n#include <linux/log2.h>\n#include <linux/ctype.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/random.h>\n#include <linux/vfs.h>\n#include <linux/exportfs.h>\n#include <linux/buffer_head.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/jbd2.h>\n#include <linux/vmalloc.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n#include <linux/string.h>\n#include <linux/module.h>\n\nstatic int ext4_unfreeze(struct super_block *sb);\nstatic int ext4_freeze(struct super_block *sb);\nstatic inline int ext2_feature_set_ok(struct super_block *sb);\nstatic inline int ext3_feature_set_ok(struct super_block *sb);\nstatic void ext4_unregister_li_request(struct super_block *sb);\n\nstatic inline int ext3_feature_set_ok(struct super_block *sb)\n{\n\tif (EXT4_HAS_INCOMPAT_FEATURE(sb, ~EXT3_FEATURE_INCOMPAT_SUPP))\n\t\treturn 0;\n\tif (!EXT4_HAS_COMPAT_FEATURE(sb, EXT4_FEATURE_COMPAT_HAS_JOURNAL))\n\t\treturn 0;\n\tif (sb->s_flags & MS_RDONLY)\n\t\treturn 1;\n\tif (EXT4_HAS_RO_COMPAT_FEATURE(sb, ~EXT3_FEATURE_RO_COMPAT_SUPP))\n\t\treturn 0;\n\treturn 1;\n}"
  },
  {
    "function_name": "unregister_as_ext3",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/super.c",
    "lines": "5486-5489",
    "snippet": "static inline void unregister_as_ext3(void)\n{\n\tunregister_filesystem(&ext3_fs_type);\n}",
    "includes": [
      "#include <trace/events/ext4.h>",
      "#include \"mballoc.h\"",
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"ext4_jbd2.h\"",
      "#include \"ext4_extents.h\"\t/* Needed for trace points definition */",
      "#include \"ext4.h\"",
      "#include <linux/freezer.h>",
      "#include <linux/kthread.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/cleancache.h>",
      "#include <linux/crc16.h>",
      "#include <linux/log2.h>",
      "#include <linux/ctype.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/namei.h>",
      "#include <linux/mount.h>",
      "#include <linux/random.h>",
      "#include <linux/vfs.h>",
      "#include <linux/exportfs.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/parser.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/init.h>",
      "#include <linux/slab.h>",
      "#include <linux/jbd2.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/time.h>",
      "#include <linux/fs.h>",
      "#include <linux/string.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "unregister_filesystem",
          "args": [
            "&ext3_fs_type"
          ],
          "line": 5488
        },
        "resolved": true,
        "details": {
          "function_name": "unregister_filesystem",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/filesystems.c",
          "lines": "101-120",
          "snippet": "int unregister_filesystem(struct file_system_type * fs)\n{\n\tstruct file_system_type ** tmp;\n\n\twrite_lock(&file_systems_lock);\n\ttmp = &file_systems;\n\twhile (*tmp) {\n\t\tif (fs == *tmp) {\n\t\t\t*tmp = fs->next;\n\t\t\tfs->next = NULL;\n\t\t\twrite_unlock(&file_systems_lock);\n\t\t\tsynchronize_rcu();\n\t\t\treturn 0;\n\t\t}\n\t\ttmp = &(*tmp)->next;\n\t}\n\twrite_unlock(&file_systems_lock);\n\n\treturn -EINVAL;\n}",
          "includes": [
            "#include <asm/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/kmod.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct file_system_type *file_systems;",
            "static DEFINE_RWLOCK(file_systems_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/uaccess.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kmod.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n\nstatic struct file_system_type *file_systems;\nstatic DEFINE_RWLOCK(file_systems_lock);\n\nint unregister_filesystem(struct file_system_type * fs)\n{\n\tstruct file_system_type ** tmp;\n\n\twrite_lock(&file_systems_lock);\n\ttmp = &file_systems;\n\twhile (*tmp) {\n\t\tif (fs == *tmp) {\n\t\t\t*tmp = fs->next;\n\t\t\tfs->next = NULL;\n\t\t\twrite_unlock(&file_systems_lock);\n\t\t\tsynchronize_rcu();\n\t\t\treturn 0;\n\t\t}\n\t\ttmp = &(*tmp)->next;\n\t}\n\twrite_unlock(&file_systems_lock);\n\n\treturn -EINVAL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"mballoc.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4_extents.h\"\t/* Needed for trace points definition */\n#include \"ext4.h\"\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <asm/uaccess.h>\n#include <linux/cleancache.h>\n#include <linux/crc16.h>\n#include <linux/log2.h>\n#include <linux/ctype.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/random.h>\n#include <linux/vfs.h>\n#include <linux/exportfs.h>\n#include <linux/buffer_head.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/jbd2.h>\n#include <linux/vmalloc.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n#include <linux/string.h>\n#include <linux/module.h>\n\nstatic inline void unregister_as_ext3(void)\n{\n\tunregister_filesystem(&ext3_fs_type);\n}"
  },
  {
    "function_name": "register_as_ext3",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/super.c",
    "lines": "5478-5484",
    "snippet": "static inline void register_as_ext3(void)\n{\n\tint err = register_filesystem(&ext3_fs_type);\n\tif (err)\n\t\tprintk(KERN_WARNING\n\t\t       \"EXT4-fs: Unable to register as ext3 (%d)\\n\", err);\n}",
    "includes": [
      "#include <trace/events/ext4.h>",
      "#include \"mballoc.h\"",
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"ext4_jbd2.h\"",
      "#include \"ext4_extents.h\"\t/* Needed for trace points definition */",
      "#include \"ext4.h\"",
      "#include <linux/freezer.h>",
      "#include <linux/kthread.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/cleancache.h>",
      "#include <linux/crc16.h>",
      "#include <linux/log2.h>",
      "#include <linux/ctype.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/namei.h>",
      "#include <linux/mount.h>",
      "#include <linux/random.h>",
      "#include <linux/vfs.h>",
      "#include <linux/exportfs.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/parser.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/init.h>",
      "#include <linux/slab.h>",
      "#include <linux/jbd2.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/time.h>",
      "#include <linux/fs.h>",
      "#include <linux/string.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_WARNING\n\t\t       \"EXT4-fs: Unable to register as ext3 (%d)\\n\"",
            "err"
          ],
          "line": 5482
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_printk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/super.c",
          "lines": "186-213",
          "snippet": "void btrfs_printk(const struct btrfs_fs_info *fs_info, const char *fmt, ...)\n{\n\tstruct super_block *sb = fs_info->sb;\n\tchar lvl[4];\n\tstruct va_format vaf;\n\tva_list args;\n\tconst char *type = logtypes[4];\n\tint kern_level;\n\n\tva_start(args, fmt);\n\n\tkern_level = printk_get_level(fmt);\n\tif (kern_level) {\n\t\tsize_t size = printk_skip_level(fmt) - fmt;\n\t\tmemcpy(lvl, fmt,  size);\n\t\tlvl[size] = '\\0';\n\t\tfmt += size;\n\t\ttype = logtypes[kern_level - '0'];\n\t} else\n\t\t*lvl = '\\0';\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\tprintk(\"%sBTRFS %s (device %s): %pV\\n\", lvl, type, sb->s_id, &vaf);\n\n\tva_end(args);\n}",
          "includes": [
            "#include <trace/events/btrfs.h>",
            "#include \"qgroup.h\"",
            "#include \"tests/btrfs-tests.h\"",
            "#include \"backref.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"dev-replace.h\"",
            "#include \"rcu-string.h\"",
            "#include \"compression.h\"",
            "#include \"export.h\"",
            "#include \"volumes.h\"",
            "#include \"xattr.h\"",
            "#include \"props.h\"",
            "#include \"hash.h\"",
            "#include \"print-tree.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include \"delayed-inode.h\"",
            "#include <linux/btrfs.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/slab.h>",
            "#include <linux/magic.h>",
            "#include <linux/miscdevice.h>",
            "#include <linux/namei.h>",
            "#include <linux/ctype.h>",
            "#include <linux/parser.h>",
            "#include <linux/compat.h>",
            "#include <linux/statfs.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/mpage.h>",
            "#include <linux/mount.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/string.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/init.h>",
            "#include <linux/time.h>",
            "#include <linux/highmem.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/module.h>",
            "#include <linux/blkdev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/btrfs.h>\n#include \"qgroup.h\"\n#include \"tests/btrfs-tests.h\"\n#include \"backref.h\"\n#include \"free-space-cache.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"compression.h\"\n#include \"export.h\"\n#include \"volumes.h\"\n#include \"xattr.h\"\n#include \"props.h\"\n#include \"hash.h\"\n#include \"print-tree.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include \"delayed-inode.h\"\n#include <linux/btrfs.h>\n#include <linux/ratelimit.h>\n#include <linux/cleancache.h>\n#include <linux/slab.h>\n#include <linux/magic.h>\n#include <linux/miscdevice.h>\n#include <linux/namei.h>\n#include <linux/ctype.h>\n#include <linux/parser.h>\n#include <linux/compat.h>\n#include <linux/statfs.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/mpage.h>\n#include <linux/mount.h>\n#include <linux/backing-dev.h>\n#include <linux/string.h>\n#include <linux/seq_file.h>\n#include <linux/init.h>\n#include <linux/time.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n#include <linux/buffer_head.h>\n#include <linux/module.h>\n#include <linux/blkdev.h>\n\nvoid btrfs_printk(const struct btrfs_fs_info *fs_info, const char *fmt, ...)\n{\n\tstruct super_block *sb = fs_info->sb;\n\tchar lvl[4];\n\tstruct va_format vaf;\n\tva_list args;\n\tconst char *type = logtypes[4];\n\tint kern_level;\n\n\tva_start(args, fmt);\n\n\tkern_level = printk_get_level(fmt);\n\tif (kern_level) {\n\t\tsize_t size = printk_skip_level(fmt) - fmt;\n\t\tmemcpy(lvl, fmt,  size);\n\t\tlvl[size] = '\\0';\n\t\tfmt += size;\n\t\ttype = logtypes[kern_level - '0'];\n\t} else\n\t\t*lvl = '\\0';\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\tprintk(\"%sBTRFS %s (device %s): %pV\\n\", lvl, type, sb->s_id, &vaf);\n\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "register_filesystem",
          "args": [
            "&ext3_fs_type"
          ],
          "line": 5480
        },
        "resolved": true,
        "details": {
          "function_name": "unregister_filesystem",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/filesystems.c",
          "lines": "101-120",
          "snippet": "int unregister_filesystem(struct file_system_type * fs)\n{\n\tstruct file_system_type ** tmp;\n\n\twrite_lock(&file_systems_lock);\n\ttmp = &file_systems;\n\twhile (*tmp) {\n\t\tif (fs == *tmp) {\n\t\t\t*tmp = fs->next;\n\t\t\tfs->next = NULL;\n\t\t\twrite_unlock(&file_systems_lock);\n\t\t\tsynchronize_rcu();\n\t\t\treturn 0;\n\t\t}\n\t\ttmp = &(*tmp)->next;\n\t}\n\twrite_unlock(&file_systems_lock);\n\n\treturn -EINVAL;\n}",
          "includes": [
            "#include <asm/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/kmod.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct file_system_type *file_systems;",
            "static DEFINE_RWLOCK(file_systems_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/uaccess.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kmod.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n\nstatic struct file_system_type *file_systems;\nstatic DEFINE_RWLOCK(file_systems_lock);\n\nint unregister_filesystem(struct file_system_type * fs)\n{\n\tstruct file_system_type ** tmp;\n\n\twrite_lock(&file_systems_lock);\n\ttmp = &file_systems;\n\twhile (*tmp) {\n\t\tif (fs == *tmp) {\n\t\t\t*tmp = fs->next;\n\t\t\tfs->next = NULL;\n\t\t\twrite_unlock(&file_systems_lock);\n\t\t\tsynchronize_rcu();\n\t\t\treturn 0;\n\t\t}\n\t\ttmp = &(*tmp)->next;\n\t}\n\twrite_unlock(&file_systems_lock);\n\n\treturn -EINVAL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"mballoc.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4_extents.h\"\t/* Needed for trace points definition */\n#include \"ext4.h\"\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <asm/uaccess.h>\n#include <linux/cleancache.h>\n#include <linux/crc16.h>\n#include <linux/log2.h>\n#include <linux/ctype.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/random.h>\n#include <linux/vfs.h>\n#include <linux/exportfs.h>\n#include <linux/buffer_head.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/jbd2.h>\n#include <linux/vmalloc.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n#include <linux/string.h>\n#include <linux/module.h>\n\nstatic inline void register_as_ext3(void)\n{\n\tint err = register_filesystem(&ext3_fs_type);\n\tif (err)\n\t\tprintk(KERN_WARNING\n\t\t       \"EXT4-fs: Unable to register as ext3 (%d)\\n\", err);\n}"
  },
  {
    "function_name": "ext2_feature_set_ok",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/super.c",
    "lines": "5474-5474",
    "snippet": "static inline int ext2_feature_set_ok(struct super_block *sb) { return 0; }",
    "includes": [
      "#include <trace/events/ext4.h>",
      "#include \"mballoc.h\"",
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"ext4_jbd2.h\"",
      "#include \"ext4_extents.h\"\t/* Needed for trace points definition */",
      "#include \"ext4.h\"",
      "#include <linux/freezer.h>",
      "#include <linux/kthread.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/cleancache.h>",
      "#include <linux/crc16.h>",
      "#include <linux/log2.h>",
      "#include <linux/ctype.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/namei.h>",
      "#include <linux/mount.h>",
      "#include <linux/random.h>",
      "#include <linux/vfs.h>",
      "#include <linux/exportfs.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/parser.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/init.h>",
      "#include <linux/slab.h>",
      "#include <linux/jbd2.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/time.h>",
      "#include <linux/fs.h>",
      "#include <linux/string.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ext4_unfreeze(struct super_block *sb);",
      "static int ext4_freeze(struct super_block *sb);",
      "static inline int ext2_feature_set_ok(struct super_block *sb);",
      "static inline int ext3_feature_set_ok(struct super_block *sb);",
      "static void ext4_unregister_li_request(struct super_block *sb);"
    ],
    "called_functions": [],
    "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"mballoc.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4_extents.h\"\t/* Needed for trace points definition */\n#include \"ext4.h\"\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <asm/uaccess.h>\n#include <linux/cleancache.h>\n#include <linux/crc16.h>\n#include <linux/log2.h>\n#include <linux/ctype.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/random.h>\n#include <linux/vfs.h>\n#include <linux/exportfs.h>\n#include <linux/buffer_head.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/jbd2.h>\n#include <linux/vmalloc.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n#include <linux/string.h>\n#include <linux/module.h>\n\nstatic int ext4_unfreeze(struct super_block *sb);\nstatic int ext4_freeze(struct super_block *sb);\nstatic inline int ext2_feature_set_ok(struct super_block *sb);\nstatic inline int ext3_feature_set_ok(struct super_block *sb);\nstatic void ext4_unregister_li_request(struct super_block *sb);\n\nstatic inline int ext2_feature_set_ok(struct super_block *sb) { return 0; }"
  },
  {
    "function_name": "unregister_as_ext2",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/super.c",
    "lines": "5473-5473",
    "snippet": "static inline void unregister_as_ext2(void) { }",
    "includes": [
      "#include <trace/events/ext4.h>",
      "#include \"mballoc.h\"",
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"ext4_jbd2.h\"",
      "#include \"ext4_extents.h\"\t/* Needed for trace points definition */",
      "#include \"ext4.h\"",
      "#include <linux/freezer.h>",
      "#include <linux/kthread.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/cleancache.h>",
      "#include <linux/crc16.h>",
      "#include <linux/log2.h>",
      "#include <linux/ctype.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/namei.h>",
      "#include <linux/mount.h>",
      "#include <linux/random.h>",
      "#include <linux/vfs.h>",
      "#include <linux/exportfs.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/parser.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/init.h>",
      "#include <linux/slab.h>",
      "#include <linux/jbd2.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/time.h>",
      "#include <linux/fs.h>",
      "#include <linux/string.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"mballoc.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4_extents.h\"\t/* Needed for trace points definition */\n#include \"ext4.h\"\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <asm/uaccess.h>\n#include <linux/cleancache.h>\n#include <linux/crc16.h>\n#include <linux/log2.h>\n#include <linux/ctype.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/random.h>\n#include <linux/vfs.h>\n#include <linux/exportfs.h>\n#include <linux/buffer_head.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/jbd2.h>\n#include <linux/vmalloc.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n#include <linux/string.h>\n#include <linux/module.h>\n\nstatic inline void unregister_as_ext2(void) { }"
  },
  {
    "function_name": "register_as_ext2",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/super.c",
    "lines": "5472-5472",
    "snippet": "static inline void register_as_ext2(void) { }",
    "includes": [
      "#include <trace/events/ext4.h>",
      "#include \"mballoc.h\"",
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"ext4_jbd2.h\"",
      "#include \"ext4_extents.h\"\t/* Needed for trace points definition */",
      "#include \"ext4.h\"",
      "#include <linux/freezer.h>",
      "#include <linux/kthread.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/cleancache.h>",
      "#include <linux/crc16.h>",
      "#include <linux/log2.h>",
      "#include <linux/ctype.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/namei.h>",
      "#include <linux/mount.h>",
      "#include <linux/random.h>",
      "#include <linux/vfs.h>",
      "#include <linux/exportfs.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/parser.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/init.h>",
      "#include <linux/slab.h>",
      "#include <linux/jbd2.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/time.h>",
      "#include <linux/fs.h>",
      "#include <linux/string.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"mballoc.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4_extents.h\"\t/* Needed for trace points definition */\n#include \"ext4.h\"\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <asm/uaccess.h>\n#include <linux/cleancache.h>\n#include <linux/crc16.h>\n#include <linux/log2.h>\n#include <linux/ctype.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/random.h>\n#include <linux/vfs.h>\n#include <linux/exportfs.h>\n#include <linux/buffer_head.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/jbd2.h>\n#include <linux/vmalloc.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n#include <linux/string.h>\n#include <linux/module.h>\n\nstatic inline void register_as_ext2(void) { }"
  },
  {
    "function_name": "ext2_feature_set_ok",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/super.c",
    "lines": "5461-5470",
    "snippet": "static inline int ext2_feature_set_ok(struct super_block *sb)\n{\n\tif (EXT4_HAS_INCOMPAT_FEATURE(sb, ~EXT2_FEATURE_INCOMPAT_SUPP))\n\t\treturn 0;\n\tif (sb->s_flags & MS_RDONLY)\n\t\treturn 1;\n\tif (EXT4_HAS_RO_COMPAT_FEATURE(sb, ~EXT2_FEATURE_RO_COMPAT_SUPP))\n\t\treturn 0;\n\treturn 1;\n}",
    "includes": [
      "#include <trace/events/ext4.h>",
      "#include \"mballoc.h\"",
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"ext4_jbd2.h\"",
      "#include \"ext4_extents.h\"\t/* Needed for trace points definition */",
      "#include \"ext4.h\"",
      "#include <linux/freezer.h>",
      "#include <linux/kthread.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/cleancache.h>",
      "#include <linux/crc16.h>",
      "#include <linux/log2.h>",
      "#include <linux/ctype.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/namei.h>",
      "#include <linux/mount.h>",
      "#include <linux/random.h>",
      "#include <linux/vfs.h>",
      "#include <linux/exportfs.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/parser.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/init.h>",
      "#include <linux/slab.h>",
      "#include <linux/jbd2.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/time.h>",
      "#include <linux/fs.h>",
      "#include <linux/string.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ext4_unfreeze(struct super_block *sb);",
      "static int ext4_freeze(struct super_block *sb);",
      "static inline int ext2_feature_set_ok(struct super_block *sb);",
      "static inline int ext3_feature_set_ok(struct super_block *sb);",
      "static void ext4_unregister_li_request(struct super_block *sb);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "EXT4_HAS_RO_COMPAT_FEATURE",
          "args": [
            "sb",
            "~EXT2_FEATURE_RO_COMPAT_SUPP"
          ],
          "line": 5467
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXT4_HAS_INCOMPAT_FEATURE",
          "args": [
            "sb",
            "~EXT2_FEATURE_INCOMPAT_SUPP"
          ],
          "line": 5463
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"mballoc.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4_extents.h\"\t/* Needed for trace points definition */\n#include \"ext4.h\"\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <asm/uaccess.h>\n#include <linux/cleancache.h>\n#include <linux/crc16.h>\n#include <linux/log2.h>\n#include <linux/ctype.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/random.h>\n#include <linux/vfs.h>\n#include <linux/exportfs.h>\n#include <linux/buffer_head.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/jbd2.h>\n#include <linux/vmalloc.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n#include <linux/string.h>\n#include <linux/module.h>\n\nstatic int ext4_unfreeze(struct super_block *sb);\nstatic int ext4_freeze(struct super_block *sb);\nstatic inline int ext2_feature_set_ok(struct super_block *sb);\nstatic inline int ext3_feature_set_ok(struct super_block *sb);\nstatic void ext4_unregister_li_request(struct super_block *sb);\n\nstatic inline int ext2_feature_set_ok(struct super_block *sb)\n{\n\tif (EXT4_HAS_INCOMPAT_FEATURE(sb, ~EXT2_FEATURE_INCOMPAT_SUPP))\n\t\treturn 0;\n\tif (sb->s_flags & MS_RDONLY)\n\t\treturn 1;\n\tif (EXT4_HAS_RO_COMPAT_FEATURE(sb, ~EXT2_FEATURE_RO_COMPAT_SUPP))\n\t\treturn 0;\n\treturn 1;\n}"
  },
  {
    "function_name": "unregister_as_ext2",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/super.c",
    "lines": "5456-5459",
    "snippet": "static inline void unregister_as_ext2(void)\n{\n\tunregister_filesystem(&ext2_fs_type);\n}",
    "includes": [
      "#include <trace/events/ext4.h>",
      "#include \"mballoc.h\"",
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"ext4_jbd2.h\"",
      "#include \"ext4_extents.h\"\t/* Needed for trace points definition */",
      "#include \"ext4.h\"",
      "#include <linux/freezer.h>",
      "#include <linux/kthread.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/cleancache.h>",
      "#include <linux/crc16.h>",
      "#include <linux/log2.h>",
      "#include <linux/ctype.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/namei.h>",
      "#include <linux/mount.h>",
      "#include <linux/random.h>",
      "#include <linux/vfs.h>",
      "#include <linux/exportfs.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/parser.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/init.h>",
      "#include <linux/slab.h>",
      "#include <linux/jbd2.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/time.h>",
      "#include <linux/fs.h>",
      "#include <linux/string.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "unregister_filesystem",
          "args": [
            "&ext2_fs_type"
          ],
          "line": 5458
        },
        "resolved": true,
        "details": {
          "function_name": "unregister_filesystem",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/filesystems.c",
          "lines": "101-120",
          "snippet": "int unregister_filesystem(struct file_system_type * fs)\n{\n\tstruct file_system_type ** tmp;\n\n\twrite_lock(&file_systems_lock);\n\ttmp = &file_systems;\n\twhile (*tmp) {\n\t\tif (fs == *tmp) {\n\t\t\t*tmp = fs->next;\n\t\t\tfs->next = NULL;\n\t\t\twrite_unlock(&file_systems_lock);\n\t\t\tsynchronize_rcu();\n\t\t\treturn 0;\n\t\t}\n\t\ttmp = &(*tmp)->next;\n\t}\n\twrite_unlock(&file_systems_lock);\n\n\treturn -EINVAL;\n}",
          "includes": [
            "#include <asm/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/kmod.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct file_system_type *file_systems;",
            "static DEFINE_RWLOCK(file_systems_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/uaccess.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kmod.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n\nstatic struct file_system_type *file_systems;\nstatic DEFINE_RWLOCK(file_systems_lock);\n\nint unregister_filesystem(struct file_system_type * fs)\n{\n\tstruct file_system_type ** tmp;\n\n\twrite_lock(&file_systems_lock);\n\ttmp = &file_systems;\n\twhile (*tmp) {\n\t\tif (fs == *tmp) {\n\t\t\t*tmp = fs->next;\n\t\t\tfs->next = NULL;\n\t\t\twrite_unlock(&file_systems_lock);\n\t\t\tsynchronize_rcu();\n\t\t\treturn 0;\n\t\t}\n\t\ttmp = &(*tmp)->next;\n\t}\n\twrite_unlock(&file_systems_lock);\n\n\treturn -EINVAL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"mballoc.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4_extents.h\"\t/* Needed for trace points definition */\n#include \"ext4.h\"\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <asm/uaccess.h>\n#include <linux/cleancache.h>\n#include <linux/crc16.h>\n#include <linux/log2.h>\n#include <linux/ctype.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/random.h>\n#include <linux/vfs.h>\n#include <linux/exportfs.h>\n#include <linux/buffer_head.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/jbd2.h>\n#include <linux/vmalloc.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n#include <linux/string.h>\n#include <linux/module.h>\n\nstatic inline void unregister_as_ext2(void)\n{\n\tunregister_filesystem(&ext2_fs_type);\n}"
  },
  {
    "function_name": "register_as_ext2",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/super.c",
    "lines": "5448-5454",
    "snippet": "static inline void register_as_ext2(void)\n{\n\tint err = register_filesystem(&ext2_fs_type);\n\tif (err)\n\t\tprintk(KERN_WARNING\n\t\t       \"EXT4-fs: Unable to register as ext2 (%d)\\n\", err);\n}",
    "includes": [
      "#include <trace/events/ext4.h>",
      "#include \"mballoc.h\"",
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"ext4_jbd2.h\"",
      "#include \"ext4_extents.h\"\t/* Needed for trace points definition */",
      "#include \"ext4.h\"",
      "#include <linux/freezer.h>",
      "#include <linux/kthread.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/cleancache.h>",
      "#include <linux/crc16.h>",
      "#include <linux/log2.h>",
      "#include <linux/ctype.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/namei.h>",
      "#include <linux/mount.h>",
      "#include <linux/random.h>",
      "#include <linux/vfs.h>",
      "#include <linux/exportfs.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/parser.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/init.h>",
      "#include <linux/slab.h>",
      "#include <linux/jbd2.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/time.h>",
      "#include <linux/fs.h>",
      "#include <linux/string.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_WARNING\n\t\t       \"EXT4-fs: Unable to register as ext2 (%d)\\n\"",
            "err"
          ],
          "line": 5452
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_printk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/super.c",
          "lines": "186-213",
          "snippet": "void btrfs_printk(const struct btrfs_fs_info *fs_info, const char *fmt, ...)\n{\n\tstruct super_block *sb = fs_info->sb;\n\tchar lvl[4];\n\tstruct va_format vaf;\n\tva_list args;\n\tconst char *type = logtypes[4];\n\tint kern_level;\n\n\tva_start(args, fmt);\n\n\tkern_level = printk_get_level(fmt);\n\tif (kern_level) {\n\t\tsize_t size = printk_skip_level(fmt) - fmt;\n\t\tmemcpy(lvl, fmt,  size);\n\t\tlvl[size] = '\\0';\n\t\tfmt += size;\n\t\ttype = logtypes[kern_level - '0'];\n\t} else\n\t\t*lvl = '\\0';\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\tprintk(\"%sBTRFS %s (device %s): %pV\\n\", lvl, type, sb->s_id, &vaf);\n\n\tva_end(args);\n}",
          "includes": [
            "#include <trace/events/btrfs.h>",
            "#include \"qgroup.h\"",
            "#include \"tests/btrfs-tests.h\"",
            "#include \"backref.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"dev-replace.h\"",
            "#include \"rcu-string.h\"",
            "#include \"compression.h\"",
            "#include \"export.h\"",
            "#include \"volumes.h\"",
            "#include \"xattr.h\"",
            "#include \"props.h\"",
            "#include \"hash.h\"",
            "#include \"print-tree.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include \"delayed-inode.h\"",
            "#include <linux/btrfs.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/slab.h>",
            "#include <linux/magic.h>",
            "#include <linux/miscdevice.h>",
            "#include <linux/namei.h>",
            "#include <linux/ctype.h>",
            "#include <linux/parser.h>",
            "#include <linux/compat.h>",
            "#include <linux/statfs.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/mpage.h>",
            "#include <linux/mount.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/string.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/init.h>",
            "#include <linux/time.h>",
            "#include <linux/highmem.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/module.h>",
            "#include <linux/blkdev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/btrfs.h>\n#include \"qgroup.h\"\n#include \"tests/btrfs-tests.h\"\n#include \"backref.h\"\n#include \"free-space-cache.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"compression.h\"\n#include \"export.h\"\n#include \"volumes.h\"\n#include \"xattr.h\"\n#include \"props.h\"\n#include \"hash.h\"\n#include \"print-tree.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include \"delayed-inode.h\"\n#include <linux/btrfs.h>\n#include <linux/ratelimit.h>\n#include <linux/cleancache.h>\n#include <linux/slab.h>\n#include <linux/magic.h>\n#include <linux/miscdevice.h>\n#include <linux/namei.h>\n#include <linux/ctype.h>\n#include <linux/parser.h>\n#include <linux/compat.h>\n#include <linux/statfs.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/mpage.h>\n#include <linux/mount.h>\n#include <linux/backing-dev.h>\n#include <linux/string.h>\n#include <linux/seq_file.h>\n#include <linux/init.h>\n#include <linux/time.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n#include <linux/buffer_head.h>\n#include <linux/module.h>\n#include <linux/blkdev.h>\n\nvoid btrfs_printk(const struct btrfs_fs_info *fs_info, const char *fmt, ...)\n{\n\tstruct super_block *sb = fs_info->sb;\n\tchar lvl[4];\n\tstruct va_format vaf;\n\tva_list args;\n\tconst char *type = logtypes[4];\n\tint kern_level;\n\n\tva_start(args, fmt);\n\n\tkern_level = printk_get_level(fmt);\n\tif (kern_level) {\n\t\tsize_t size = printk_skip_level(fmt) - fmt;\n\t\tmemcpy(lvl, fmt,  size);\n\t\tlvl[size] = '\\0';\n\t\tfmt += size;\n\t\ttype = logtypes[kern_level - '0'];\n\t} else\n\t\t*lvl = '\\0';\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\tprintk(\"%sBTRFS %s (device %s): %pV\\n\", lvl, type, sb->s_id, &vaf);\n\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "register_filesystem",
          "args": [
            "&ext2_fs_type"
          ],
          "line": 5450
        },
        "resolved": true,
        "details": {
          "function_name": "unregister_filesystem",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/filesystems.c",
          "lines": "101-120",
          "snippet": "int unregister_filesystem(struct file_system_type * fs)\n{\n\tstruct file_system_type ** tmp;\n\n\twrite_lock(&file_systems_lock);\n\ttmp = &file_systems;\n\twhile (*tmp) {\n\t\tif (fs == *tmp) {\n\t\t\t*tmp = fs->next;\n\t\t\tfs->next = NULL;\n\t\t\twrite_unlock(&file_systems_lock);\n\t\t\tsynchronize_rcu();\n\t\t\treturn 0;\n\t\t}\n\t\ttmp = &(*tmp)->next;\n\t}\n\twrite_unlock(&file_systems_lock);\n\n\treturn -EINVAL;\n}",
          "includes": [
            "#include <asm/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/kmod.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct file_system_type *file_systems;",
            "static DEFINE_RWLOCK(file_systems_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/uaccess.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kmod.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n\nstatic struct file_system_type *file_systems;\nstatic DEFINE_RWLOCK(file_systems_lock);\n\nint unregister_filesystem(struct file_system_type * fs)\n{\n\tstruct file_system_type ** tmp;\n\n\twrite_lock(&file_systems_lock);\n\ttmp = &file_systems;\n\twhile (*tmp) {\n\t\tif (fs == *tmp) {\n\t\t\t*tmp = fs->next;\n\t\t\tfs->next = NULL;\n\t\t\twrite_unlock(&file_systems_lock);\n\t\t\tsynchronize_rcu();\n\t\t\treturn 0;\n\t\t}\n\t\ttmp = &(*tmp)->next;\n\t}\n\twrite_unlock(&file_systems_lock);\n\n\treturn -EINVAL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"mballoc.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4_extents.h\"\t/* Needed for trace points definition */\n#include \"ext4.h\"\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <asm/uaccess.h>\n#include <linux/cleancache.h>\n#include <linux/crc16.h>\n#include <linux/log2.h>\n#include <linux/ctype.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/random.h>\n#include <linux/vfs.h>\n#include <linux/exportfs.h>\n#include <linux/buffer_head.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/jbd2.h>\n#include <linux/vmalloc.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n#include <linux/string.h>\n#include <linux/module.h>\n\nstatic inline void register_as_ext2(void)\n{\n\tint err = register_filesystem(&ext2_fs_type);\n\tif (err)\n\t\tprintk(KERN_WARNING\n\t\t       \"EXT4-fs: Unable to register as ext2 (%d)\\n\", err);\n}"
  },
  {
    "function_name": "ext4_mount",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/super.c",
    "lines": "5441-5445",
    "snippet": "static struct dentry *ext4_mount(struct file_system_type *fs_type, int flags,\n\t\t       const char *dev_name, void *data)\n{\n\treturn mount_bdev(fs_type, flags, dev_name, data, ext4_fill_super);\n}",
    "includes": [
      "#include <trace/events/ext4.h>",
      "#include \"mballoc.h\"",
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"ext4_jbd2.h\"",
      "#include \"ext4_extents.h\"\t/* Needed for trace points definition */",
      "#include \"ext4.h\"",
      "#include <linux/freezer.h>",
      "#include <linux/kthread.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/cleancache.h>",
      "#include <linux/crc16.h>",
      "#include <linux/log2.h>",
      "#include <linux/ctype.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/namei.h>",
      "#include <linux/mount.h>",
      "#include <linux/random.h>",
      "#include <linux/vfs.h>",
      "#include <linux/exportfs.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/parser.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/init.h>",
      "#include <linux/slab.h>",
      "#include <linux/jbd2.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/time.h>",
      "#include <linux/fs.h>",
      "#include <linux/string.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ext4_remount(struct super_block *sb, int *flags, char *data);",
      "static struct dentry *ext4_mount(struct file_system_type *fs_type, int flags,\n\t\t       const char *dev_name, void *data);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mount_bdev",
          "args": [
            "fs_type",
            "flags",
            "dev_name",
            "data",
            "ext4_fill_super"
          ],
          "line": 5444
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"mballoc.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4_extents.h\"\t/* Needed for trace points definition */\n#include \"ext4.h\"\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <asm/uaccess.h>\n#include <linux/cleancache.h>\n#include <linux/crc16.h>\n#include <linux/log2.h>\n#include <linux/ctype.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/random.h>\n#include <linux/vfs.h>\n#include <linux/exportfs.h>\n#include <linux/buffer_head.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/jbd2.h>\n#include <linux/vmalloc.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n#include <linux/string.h>\n#include <linux/module.h>\n\nstatic int ext4_remount(struct super_block *sb, int *flags, char *data);\nstatic struct dentry *ext4_mount(struct file_system_type *fs_type, int flags,\n\t\t       const char *dev_name, void *data);\n\nstatic struct dentry *ext4_mount(struct file_system_type *fs_type, int flags,\n\t\t       const char *dev_name, void *data)\n{\n\treturn mount_bdev(fs_type, flags, dev_name, data, ext4_fill_super);\n}"
  },
  {
    "function_name": "ext4_quota_write",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/super.c",
    "lines": "5387-5437",
    "snippet": "static ssize_t ext4_quota_write(struct super_block *sb, int type,\n\t\t\t\tconst char *data, size_t len, loff_t off)\n{\n\tstruct inode *inode = sb_dqopt(sb)->files[type];\n\text4_lblk_t blk = off >> EXT4_BLOCK_SIZE_BITS(sb);\n\tint err, offset = off & (sb->s_blocksize - 1);\n\tstruct buffer_head *bh;\n\thandle_t *handle = journal_current_handle();\n\n\tif (EXT4_SB(sb)->s_journal && !handle) {\n\t\text4_msg(sb, KERN_WARNING, \"Quota write (off=%llu, len=%llu)\"\n\t\t\t\" cancelled because transaction is not started\",\n\t\t\t(unsigned long long)off, (unsigned long long)len);\n\t\treturn -EIO;\n\t}\n\t/*\n\t * Since we account only one data block in transaction credits,\n\t * then it is impossible to cross a block boundary.\n\t */\n\tif (sb->s_blocksize - offset < len) {\n\t\text4_msg(sb, KERN_WARNING, \"Quota write (off=%llu, len=%llu)\"\n\t\t\t\" cancelled because not block aligned\",\n\t\t\t(unsigned long long)off, (unsigned long long)len);\n\t\treturn -EIO;\n\t}\n\n\tbh = ext4_bread(handle, inode, blk, 1);\n\tif (IS_ERR(bh))\n\t\treturn PTR_ERR(bh);\n\tif (!bh)\n\t\tgoto out;\n\tBUFFER_TRACE(bh, \"get write access\");\n\terr = ext4_journal_get_write_access(handle, bh);\n\tif (err) {\n\t\tbrelse(bh);\n\t\treturn err;\n\t}\n\tlock_buffer(bh);\n\tmemcpy(bh->b_data+offset, data, len);\n\tflush_dcache_page(bh->b_page);\n\tunlock_buffer(bh);\n\terr = ext4_handle_dirty_metadata(handle, NULL, bh);\n\tbrelse(bh);\nout:\n\tif (inode->i_size < off + len) {\n\t\ti_size_write(inode, off + len);\n\t\tEXT4_I(inode)->i_disksize = inode->i_size;\n\t\text4_mark_inode_dirty(handle, inode);\n\t}\n\treturn len;\n}",
    "includes": [
      "#include <trace/events/ext4.h>",
      "#include \"mballoc.h\"",
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"ext4_jbd2.h\"",
      "#include \"ext4_extents.h\"\t/* Needed for trace points definition */",
      "#include \"ext4.h\"",
      "#include <linux/freezer.h>",
      "#include <linux/kthread.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/cleancache.h>",
      "#include <linux/crc16.h>",
      "#include <linux/log2.h>",
      "#include <linux/ctype.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/namei.h>",
      "#include <linux/mount.h>",
      "#include <linux/random.h>",
      "#include <linux/vfs.h>",
      "#include <linux/exportfs.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/parser.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/init.h>",
      "#include <linux/slab.h>",
      "#include <linux/jbd2.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/time.h>",
      "#include <linux/fs.h>",
      "#include <linux/string.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ext4_remount(struct super_block *sb, int *flags, char *data);",
      "static int ext4_unfreeze(struct super_block *sb);",
      "static int ext4_freeze(struct super_block *sb);",
      "static struct dentry *ext4_mount(struct file_system_type *fs_type, int flags,\n\t\t       const char *dev_name, void *data);",
      "static inline int ext2_feature_set_ok(struct super_block *sb);",
      "static inline int ext3_feature_set_ok(struct super_block *sb);",
      "static void ext4_unregister_li_request(struct super_block *sb);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ext4_mark_inode_dirty",
          "args": [
            "handle",
            "inode"
          ],
          "line": 5434
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_mark_inode_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/inode.c",
          "lines": "4887-4930",
          "snippet": "int ext4_mark_inode_dirty(handle_t *handle, struct inode *inode)\n{\n\tstruct ext4_iloc iloc;\n\tstruct ext4_sb_info *sbi = EXT4_SB(inode->i_sb);\n\tstatic unsigned int mnt_count;\n\tint err, ret;\n\n\tmight_sleep();\n\ttrace_ext4_mark_inode_dirty(inode, _RET_IP_);\n\terr = ext4_reserve_inode_write(handle, inode, &iloc);\n\tif (ext4_handle_valid(handle) &&\n\t    EXT4_I(inode)->i_extra_isize < sbi->s_want_extra_isize &&\n\t    !ext4_test_inode_state(inode, EXT4_STATE_NO_EXPAND)) {\n\t\t/*\n\t\t * We need extra buffer credits since we may write into EA block\n\t\t * with this same handle. If journal_extend fails, then it will\n\t\t * only result in a minor loss of functionality for that inode.\n\t\t * If this is felt to be critical, then e2fsck should be run to\n\t\t * force a large enough s_min_extra_isize.\n\t\t */\n\t\tif ((jbd2_journal_extend(handle,\n\t\t\t     EXT4_DATA_TRANS_BLOCKS(inode->i_sb))) == 0) {\n\t\t\tret = ext4_expand_extra_isize(inode,\n\t\t\t\t\t\t      sbi->s_want_extra_isize,\n\t\t\t\t\t\t      iloc, handle);\n\t\t\tif (ret) {\n\t\t\t\text4_set_inode_state(inode,\n\t\t\t\t\t\t     EXT4_STATE_NO_EXPAND);\n\t\t\t\tif (mnt_count !=\n\t\t\t\t\tle16_to_cpu(sbi->s_es->s_mnt_count)) {\n\t\t\t\t\text4_warning(inode->i_sb,\n\t\t\t\t\t\"Unable to expand inode %lu. Delete\"\n\t\t\t\t\t\" some EAs or run e2fsck.\",\n\t\t\t\t\tinode->i_ino);\n\t\t\t\t\tmnt_count =\n\t\t\t\t\t  le16_to_cpu(sbi->s_es->s_mnt_count);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tif (!err)\n\t\terr = ext4_mark_iloc_dirty(handle, inode, &iloc);\n\treturn err;\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"truncate.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include <linux/bitops.h>",
            "#include <linux/aio.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/printk.h>",
            "#include <linux/kernel.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/bio.h>",
            "#include <linux/uio.h>",
            "#include <linux/namei.h>",
            "#include <linux/mpage.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highuid.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/time.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"truncate.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include <linux/bitops.h>\n#include <linux/aio.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/printk.h>\n#include <linux/kernel.h>\n#include <linux/workqueue.h>\n#include <linux/bio.h>\n#include <linux/uio.h>\n#include <linux/namei.h>\n#include <linux/mpage.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/highuid.h>\n#include <linux/jbd2.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n\nint ext4_mark_inode_dirty(handle_t *handle, struct inode *inode)\n{\n\tstruct ext4_iloc iloc;\n\tstruct ext4_sb_info *sbi = EXT4_SB(inode->i_sb);\n\tstatic unsigned int mnt_count;\n\tint err, ret;\n\n\tmight_sleep();\n\ttrace_ext4_mark_inode_dirty(inode, _RET_IP_);\n\terr = ext4_reserve_inode_write(handle, inode, &iloc);\n\tif (ext4_handle_valid(handle) &&\n\t    EXT4_I(inode)->i_extra_isize < sbi->s_want_extra_isize &&\n\t    !ext4_test_inode_state(inode, EXT4_STATE_NO_EXPAND)) {\n\t\t/*\n\t\t * We need extra buffer credits since we may write into EA block\n\t\t * with this same handle. If journal_extend fails, then it will\n\t\t * only result in a minor loss of functionality for that inode.\n\t\t * If this is felt to be critical, then e2fsck should be run to\n\t\t * force a large enough s_min_extra_isize.\n\t\t */\n\t\tif ((jbd2_journal_extend(handle,\n\t\t\t     EXT4_DATA_TRANS_BLOCKS(inode->i_sb))) == 0) {\n\t\t\tret = ext4_expand_extra_isize(inode,\n\t\t\t\t\t\t      sbi->s_want_extra_isize,\n\t\t\t\t\t\t      iloc, handle);\n\t\t\tif (ret) {\n\t\t\t\text4_set_inode_state(inode,\n\t\t\t\t\t\t     EXT4_STATE_NO_EXPAND);\n\t\t\t\tif (mnt_count !=\n\t\t\t\t\tle16_to_cpu(sbi->s_es->s_mnt_count)) {\n\t\t\t\t\text4_warning(inode->i_sb,\n\t\t\t\t\t\"Unable to expand inode %lu. Delete\"\n\t\t\t\t\t\" some EAs or run e2fsck.\",\n\t\t\t\t\tinode->i_ino);\n\t\t\t\t\tmnt_count =\n\t\t\t\t\t  le16_to_cpu(sbi->s_es->s_mnt_count);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tif (!err)\n\t\terr = ext4_mark_iloc_dirty(handle, inode, &iloc);\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "EXT4_I",
          "args": [
            "inode"
          ],
          "line": 5433
        },
        "resolved": true,
        "details": {
          "function_name": "EXT4_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ext4.h",
          "lines": "1360-1363",
          "snippet": "static inline struct ext4_inode_info *EXT4_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ext4_inode_info, vfs_inode);\n}",
          "includes": [
            "#include \"extents_status.h\"",
            "#include <linux/compat.h>",
            "#include <linux/falloc.h>",
            "#include <crypto/hash.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/wait.h>",
            "#include <linux/timer.h>",
            "#include <linux/mutex.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/quota.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extents_status.h\"\n#include <linux/compat.h>\n#include <linux/falloc.h>\n#include <crypto/hash.h>\n#include <linux/ratelimit.h>\n#include <linux/percpu_counter.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/wait.h>\n#include <linux/timer.h>\n#include <linux/mutex.h>\n#include <linux/seqlock.h>\n#include <linux/rbtree.h>\n#include <linux/rwsem.h>\n#include <linux/quota.h>\n#include <linux/jbd2.h>\n#include <linux/magic.h>\n#include <linux/blkdev.h>\n#include <linux/types.h>\n\nstatic inline struct ext4_inode_info *EXT4_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ext4_inode_info, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "i_size_write",
          "args": [
            "inode",
            "off + len"
          ],
          "line": 5432
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_i_size_write",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/btrfs_inode.h",
          "lines": "233-237",
          "snippet": "static inline void btrfs_i_size_write(struct inode *inode, u64 size)\n{\n\ti_size_write(inode, size);\n\tBTRFS_I(inode)->disk_i_size = size;\n}",
          "includes": [
            "#include \"delayed-inode.h\"",
            "#include \"ordered-data.h\"",
            "#include \"extent_io.h\"",
            "#include \"extent_map.h\"",
            "#include <linux/hash.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"delayed-inode.h\"\n#include \"ordered-data.h\"\n#include \"extent_io.h\"\n#include \"extent_map.h\"\n#include <linux/hash.h>\n\nstatic inline void btrfs_i_size_write(struct inode *inode, u64 size)\n{\n\ti_size_write(inode, size);\n\tBTRFS_I(inode)->disk_i_size = size;\n}"
        }
      },
      {
        "call_info": {
          "callee": "brelse",
          "args": [
            "bh"
          ],
          "line": 5429
        },
        "resolved": true,
        "details": {
          "function_name": "__brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1177-1184",
          "snippet": "void __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_handle_dirty_metadata",
          "args": [
            "handle",
            "NULL",
            "bh"
          ],
          "line": 5428
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlock_buffer",
          "args": [
            "bh"
          ],
          "line": 5427
        },
        "resolved": true,
        "details": {
          "function_name": "unlock_buffer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "70-75",
          "snippet": "void unlock_buffer(struct buffer_head *bh)\n{\n\tclear_bit_unlock(BH_Lock, &bh->b_state);\n\tsmp_mb__after_atomic();\n\twake_up_bit(&bh->b_state, BH_Lock);\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid unlock_buffer(struct buffer_head *bh)\n{\n\tclear_bit_unlock(BH_Lock, &bh->b_state);\n\tsmp_mb__after_atomic();\n\twake_up_bit(&bh->b_state, BH_Lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "flush_dcache_page",
          "args": [
            "bh->b_page"
          ],
          "line": 5426
        },
        "resolved": true,
        "details": {
          "function_name": "ntfs_index_entry_flush_dcache_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/index.h",
          "lines": "111-117",
          "snippet": "static inline void ntfs_index_entry_flush_dcache_page(ntfs_index_context *ictx)\n{\n\tif (ictx->is_in_root)\n\t\tflush_dcache_mft_record_page(ictx->actx->ntfs_ino);\n\telse\n\t\tflush_dcache_page(ictx->page);\n}",
          "includes": [
            "#include \"aops.h\"",
            "#include \"mft.h\"",
            "#include \"attrib.h\"",
            "#include \"inode.h\"",
            "#include \"layout.h\"",
            "#include \"types.h\"",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"aops.h\"\n#include \"mft.h\"\n#include \"attrib.h\"\n#include \"inode.h\"\n#include \"layout.h\"\n#include \"types.h\"\n#include <linux/fs.h>\n\nstatic inline void ntfs_index_entry_flush_dcache_page(ntfs_index_context *ictx)\n{\n\tif (ictx->is_in_root)\n\t\tflush_dcache_mft_record_page(ictx->actx->ntfs_ino);\n\telse\n\t\tflush_dcache_page(ictx->page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "bh->b_data+offset",
            "data",
            "len"
          ],
          "line": 5425
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_journal_get_write_access",
          "args": [
            "handle",
            "bh"
          ],
          "line": 5419
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUFFER_TRACE",
          "args": [
            "bh",
            "\"get write access\""
          ],
          "line": 5418
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "bh"
          ],
          "line": 5415
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "bh"
          ],
          "line": 5414
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_bread",
          "args": [
            "handle",
            "inode",
            "blk",
            "1"
          ],
          "line": 5413
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_bread",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/inode.c",
          "lines": "791-807",
          "snippet": "struct buffer_head *ext4_bread(handle_t *handle, struct inode *inode,\n\t\t\t       ext4_lblk_t block, int create)\n{\n\tstruct buffer_head *bh;\n\n\tbh = ext4_getblk(handle, inode, block, create);\n\tif (IS_ERR(bh))\n\t\treturn bh;\n\tif (!bh || buffer_uptodate(bh))\n\t\treturn bh;\n\tll_rw_block(READ | REQ_META | REQ_PRIO, 1, &bh);\n\twait_on_buffer(bh);\n\tif (buffer_uptodate(bh))\n\t\treturn bh;\n\tput_bh(bh);\n\treturn ERR_PTR(-EIO);\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"truncate.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include <linux/bitops.h>",
            "#include <linux/aio.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/printk.h>",
            "#include <linux/kernel.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/bio.h>",
            "#include <linux/uio.h>",
            "#include <linux/namei.h>",
            "#include <linux/mpage.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highuid.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/time.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ext4_bh_delay_or_unwritten(handle_t *handle, struct buffer_head *bh);",
            "static int ext4_get_block_write_nolock(struct inode *inode, sector_t iblock,\n\t\t   struct buffer_head *bh_result, int create);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"truncate.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include <linux/bitops.h>\n#include <linux/aio.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/printk.h>\n#include <linux/kernel.h>\n#include <linux/workqueue.h>\n#include <linux/bio.h>\n#include <linux/uio.h>\n#include <linux/namei.h>\n#include <linux/mpage.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/highuid.h>\n#include <linux/jbd2.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n\nstatic int ext4_bh_delay_or_unwritten(handle_t *handle, struct buffer_head *bh);\nstatic int ext4_get_block_write_nolock(struct inode *inode, sector_t iblock,\n\t\t   struct buffer_head *bh_result, int create);\n\nstruct buffer_head *ext4_bread(handle_t *handle, struct inode *inode,\n\t\t\t       ext4_lblk_t block, int create)\n{\n\tstruct buffer_head *bh;\n\n\tbh = ext4_getblk(handle, inode, block, create);\n\tif (IS_ERR(bh))\n\t\treturn bh;\n\tif (!bh || buffer_uptodate(bh))\n\t\treturn bh;\n\tll_rw_block(READ | REQ_META | REQ_PRIO, 1, &bh);\n\twait_on_buffer(bh);\n\tif (buffer_uptodate(bh))\n\t\treturn bh;\n\tput_bh(bh);\n\treturn ERR_PTR(-EIO);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_msg",
          "args": [
            "sb",
            "KERN_WARNING",
            "\"Quota write (off=%llu, len=%llu)\"\n\t\t\t\" cancelled because not block aligned\"",
            "(unsigned long long)off",
            "(unsigned long long)len"
          ],
          "line": 5407
        },
        "resolved": true,
        "details": {
          "function_name": "__ext4_msg",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/super.c",
          "lines": "593-607",
          "snippet": "void __ext4_msg(struct super_block *sb,\n\t\tconst char *prefix, const char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tif (!___ratelimit(&(EXT4_SB(sb)->s_msg_ratelimit_state), \"EXT4-fs\"))\n\t\treturn;\n\n\tva_start(args, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\tprintk(\"%sEXT4-fs (%s): %pV\\n\", prefix, sb->s_id, &vaf);\n\tva_end(args);\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"mballoc.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include \"ext4_extents.h\"\t/* Needed for trace points definition */",
            "#include \"ext4.h\"",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/crc16.h>",
            "#include <linux/log2.h>",
            "#include <linux/ctype.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/random.h>",
            "#include <linux/vfs.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/parser.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/time.h>",
            "#include <linux/fs.h>",
            "#include <linux/string.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ext4_unfreeze(struct super_block *sb);",
            "static int ext4_freeze(struct super_block *sb);",
            "static inline int ext2_feature_set_ok(struct super_block *sb);",
            "static inline int ext3_feature_set_ok(struct super_block *sb);",
            "static void ext4_unregister_li_request(struct super_block *sb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"mballoc.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4_extents.h\"\t/* Needed for trace points definition */\n#include \"ext4.h\"\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <asm/uaccess.h>\n#include <linux/cleancache.h>\n#include <linux/crc16.h>\n#include <linux/log2.h>\n#include <linux/ctype.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/random.h>\n#include <linux/vfs.h>\n#include <linux/exportfs.h>\n#include <linux/buffer_head.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/jbd2.h>\n#include <linux/vmalloc.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n#include <linux/string.h>\n#include <linux/module.h>\n\nstatic int ext4_unfreeze(struct super_block *sb);\nstatic int ext4_freeze(struct super_block *sb);\nstatic inline int ext2_feature_set_ok(struct super_block *sb);\nstatic inline int ext3_feature_set_ok(struct super_block *sb);\nstatic void ext4_unregister_li_request(struct super_block *sb);\n\nvoid __ext4_msg(struct super_block *sb,\n\t\tconst char *prefix, const char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tif (!___ratelimit(&(EXT4_SB(sb)->s_msg_ratelimit_state), \"EXT4-fs\"))\n\t\treturn;\n\n\tva_start(args, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\tprintk(\"%sEXT4-fs (%s): %pV\\n\", prefix, sb->s_id, &vaf);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "EXT4_SB",
          "args": [
            "sb"
          ],
          "line": 5396
        },
        "resolved": true,
        "details": {
          "function_name": "EXT4_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ext4.h",
          "lines": "1356-1359",
          "snippet": "static inline struct ext4_sb_info *EXT4_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include \"extents_status.h\"",
            "#include <linux/compat.h>",
            "#include <linux/falloc.h>",
            "#include <crypto/hash.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/wait.h>",
            "#include <linux/timer.h>",
            "#include <linux/mutex.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/quota.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extents_status.h\"\n#include <linux/compat.h>\n#include <linux/falloc.h>\n#include <crypto/hash.h>\n#include <linux/ratelimit.h>\n#include <linux/percpu_counter.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/wait.h>\n#include <linux/timer.h>\n#include <linux/mutex.h>\n#include <linux/seqlock.h>\n#include <linux/rbtree.h>\n#include <linux/rwsem.h>\n#include <linux/quota.h>\n#include <linux/jbd2.h>\n#include <linux/magic.h>\n#include <linux/blkdev.h>\n#include <linux/types.h>\n\nstatic inline struct ext4_sb_info *EXT4_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      },
      {
        "call_info": {
          "callee": "journal_current_handle",
          "args": [],
          "line": 5394
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_journal_current_handle",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ext4_jbd2.h",
          "lines": "331-334",
          "snippet": "static inline handle_t *ext4_journal_current_handle(void)\n{\n\treturn journal_current_handle();\n}",
          "includes": [
            "#include \"ext4.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ext4.h\"\n#include <linux/jbd2.h>\n#include <linux/fs.h>\n\nstatic inline handle_t *ext4_journal_current_handle(void)\n{\n\treturn journal_current_handle();\n}"
        }
      },
      {
        "call_info": {
          "callee": "EXT4_BLOCK_SIZE_BITS",
          "args": [
            "sb"
          ],
          "line": 5391
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sb_dqopt",
          "args": [
            "sb"
          ],
          "line": 5390
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"mballoc.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4_extents.h\"\t/* Needed for trace points definition */\n#include \"ext4.h\"\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <asm/uaccess.h>\n#include <linux/cleancache.h>\n#include <linux/crc16.h>\n#include <linux/log2.h>\n#include <linux/ctype.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/random.h>\n#include <linux/vfs.h>\n#include <linux/exportfs.h>\n#include <linux/buffer_head.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/jbd2.h>\n#include <linux/vmalloc.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n#include <linux/string.h>\n#include <linux/module.h>\n\nstatic int ext4_remount(struct super_block *sb, int *flags, char *data);\nstatic int ext4_unfreeze(struct super_block *sb);\nstatic int ext4_freeze(struct super_block *sb);\nstatic struct dentry *ext4_mount(struct file_system_type *fs_type, int flags,\n\t\t       const char *dev_name, void *data);\nstatic inline int ext2_feature_set_ok(struct super_block *sb);\nstatic inline int ext3_feature_set_ok(struct super_block *sb);\nstatic void ext4_unregister_li_request(struct super_block *sb);\n\nstatic ssize_t ext4_quota_write(struct super_block *sb, int type,\n\t\t\t\tconst char *data, size_t len, loff_t off)\n{\n\tstruct inode *inode = sb_dqopt(sb)->files[type];\n\text4_lblk_t blk = off >> EXT4_BLOCK_SIZE_BITS(sb);\n\tint err, offset = off & (sb->s_blocksize - 1);\n\tstruct buffer_head *bh;\n\thandle_t *handle = journal_current_handle();\n\n\tif (EXT4_SB(sb)->s_journal && !handle) {\n\t\text4_msg(sb, KERN_WARNING, \"Quota write (off=%llu, len=%llu)\"\n\t\t\t\" cancelled because transaction is not started\",\n\t\t\t(unsigned long long)off, (unsigned long long)len);\n\t\treturn -EIO;\n\t}\n\t/*\n\t * Since we account only one data block in transaction credits,\n\t * then it is impossible to cross a block boundary.\n\t */\n\tif (sb->s_blocksize - offset < len) {\n\t\text4_msg(sb, KERN_WARNING, \"Quota write (off=%llu, len=%llu)\"\n\t\t\t\" cancelled because not block aligned\",\n\t\t\t(unsigned long long)off, (unsigned long long)len);\n\t\treturn -EIO;\n\t}\n\n\tbh = ext4_bread(handle, inode, blk, 1);\n\tif (IS_ERR(bh))\n\t\treturn PTR_ERR(bh);\n\tif (!bh)\n\t\tgoto out;\n\tBUFFER_TRACE(bh, \"get write access\");\n\terr = ext4_journal_get_write_access(handle, bh);\n\tif (err) {\n\t\tbrelse(bh);\n\t\treturn err;\n\t}\n\tlock_buffer(bh);\n\tmemcpy(bh->b_data+offset, data, len);\n\tflush_dcache_page(bh->b_page);\n\tunlock_buffer(bh);\n\terr = ext4_handle_dirty_metadata(handle, NULL, bh);\n\tbrelse(bh);\nout:\n\tif (inode->i_size < off + len) {\n\t\ti_size_write(inode, off + len);\n\t\tEXT4_I(inode)->i_disksize = inode->i_size;\n\t\text4_mark_inode_dirty(handle, inode);\n\t}\n\treturn len;\n}"
  },
  {
    "function_name": "ext4_quota_read",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/super.c",
    "lines": "5350-5383",
    "snippet": "static ssize_t ext4_quota_read(struct super_block *sb, int type, char *data,\n\t\t\t       size_t len, loff_t off)\n{\n\tstruct inode *inode = sb_dqopt(sb)->files[type];\n\text4_lblk_t blk = off >> EXT4_BLOCK_SIZE_BITS(sb);\n\tint offset = off & (sb->s_blocksize - 1);\n\tint tocopy;\n\tsize_t toread;\n\tstruct buffer_head *bh;\n\tloff_t i_size = i_size_read(inode);\n\n\tif (off > i_size)\n\t\treturn 0;\n\tif (off+len > i_size)\n\t\tlen = i_size-off;\n\ttoread = len;\n\twhile (toread > 0) {\n\t\ttocopy = sb->s_blocksize - offset < toread ?\n\t\t\t\tsb->s_blocksize - offset : toread;\n\t\tbh = ext4_bread(NULL, inode, blk, 0);\n\t\tif (IS_ERR(bh))\n\t\t\treturn PTR_ERR(bh);\n\t\tif (!bh)\t/* A hole? */\n\t\t\tmemset(data, 0, tocopy);\n\t\telse\n\t\t\tmemcpy(data, bh->b_data+offset, tocopy);\n\t\tbrelse(bh);\n\t\toffset = 0;\n\t\ttoread -= tocopy;\n\t\tdata += tocopy;\n\t\tblk++;\n\t}\n\treturn len;\n}",
    "includes": [
      "#include <trace/events/ext4.h>",
      "#include \"mballoc.h\"",
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"ext4_jbd2.h\"",
      "#include \"ext4_extents.h\"\t/* Needed for trace points definition */",
      "#include \"ext4.h\"",
      "#include <linux/freezer.h>",
      "#include <linux/kthread.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/cleancache.h>",
      "#include <linux/crc16.h>",
      "#include <linux/log2.h>",
      "#include <linux/ctype.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/namei.h>",
      "#include <linux/mount.h>",
      "#include <linux/random.h>",
      "#include <linux/vfs.h>",
      "#include <linux/exportfs.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/parser.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/init.h>",
      "#include <linux/slab.h>",
      "#include <linux/jbd2.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/time.h>",
      "#include <linux/fs.h>",
      "#include <linux/string.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ext4_remount(struct super_block *sb, int *flags, char *data);",
      "static int ext4_unfreeze(struct super_block *sb);",
      "static int ext4_freeze(struct super_block *sb);",
      "static struct dentry *ext4_mount(struct file_system_type *fs_type, int flags,\n\t\t       const char *dev_name, void *data);",
      "static inline int ext2_feature_set_ok(struct super_block *sb);",
      "static inline int ext3_feature_set_ok(struct super_block *sb);",
      "static void ext4_unregister_li_request(struct super_block *sb);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "brelse",
          "args": [
            "bh"
          ],
          "line": 5376
        },
        "resolved": true,
        "details": {
          "function_name": "__brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1177-1184",
          "snippet": "void __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "data",
            "bh->b_data+offset",
            "tocopy"
          ],
          "line": 5375
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "data",
            "0",
            "tocopy"
          ],
          "line": 5373
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "bh"
          ],
          "line": 5371
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "bh"
          ],
          "line": 5370
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_bread",
          "args": [
            "NULL",
            "inode",
            "blk",
            "0"
          ],
          "line": 5369
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_bread",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/inode.c",
          "lines": "791-807",
          "snippet": "struct buffer_head *ext4_bread(handle_t *handle, struct inode *inode,\n\t\t\t       ext4_lblk_t block, int create)\n{\n\tstruct buffer_head *bh;\n\n\tbh = ext4_getblk(handle, inode, block, create);\n\tif (IS_ERR(bh))\n\t\treturn bh;\n\tif (!bh || buffer_uptodate(bh))\n\t\treturn bh;\n\tll_rw_block(READ | REQ_META | REQ_PRIO, 1, &bh);\n\twait_on_buffer(bh);\n\tif (buffer_uptodate(bh))\n\t\treturn bh;\n\tput_bh(bh);\n\treturn ERR_PTR(-EIO);\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"truncate.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include <linux/bitops.h>",
            "#include <linux/aio.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/printk.h>",
            "#include <linux/kernel.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/bio.h>",
            "#include <linux/uio.h>",
            "#include <linux/namei.h>",
            "#include <linux/mpage.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highuid.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/time.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ext4_bh_delay_or_unwritten(handle_t *handle, struct buffer_head *bh);",
            "static int ext4_get_block_write_nolock(struct inode *inode, sector_t iblock,\n\t\t   struct buffer_head *bh_result, int create);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"truncate.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include <linux/bitops.h>\n#include <linux/aio.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/printk.h>\n#include <linux/kernel.h>\n#include <linux/workqueue.h>\n#include <linux/bio.h>\n#include <linux/uio.h>\n#include <linux/namei.h>\n#include <linux/mpage.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/highuid.h>\n#include <linux/jbd2.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n\nstatic int ext4_bh_delay_or_unwritten(handle_t *handle, struct buffer_head *bh);\nstatic int ext4_get_block_write_nolock(struct inode *inode, sector_t iblock,\n\t\t   struct buffer_head *bh_result, int create);\n\nstruct buffer_head *ext4_bread(handle_t *handle, struct inode *inode,\n\t\t\t       ext4_lblk_t block, int create)\n{\n\tstruct buffer_head *bh;\n\n\tbh = ext4_getblk(handle, inode, block, create);\n\tif (IS_ERR(bh))\n\t\treturn bh;\n\tif (!bh || buffer_uptodate(bh))\n\t\treturn bh;\n\tll_rw_block(READ | REQ_META | REQ_PRIO, 1, &bh);\n\twait_on_buffer(bh);\n\tif (buffer_uptodate(bh))\n\t\treturn bh;\n\tput_bh(bh);\n\treturn ERR_PTR(-EIO);\n}"
        }
      },
      {
        "call_info": {
          "callee": "i_size_read",
          "args": [
            "inode"
          ],
          "line": 5359
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXT4_BLOCK_SIZE_BITS",
          "args": [
            "sb"
          ],
          "line": 5354
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sb_dqopt",
          "args": [
            "sb"
          ],
          "line": 5353
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"mballoc.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4_extents.h\"\t/* Needed for trace points definition */\n#include \"ext4.h\"\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <asm/uaccess.h>\n#include <linux/cleancache.h>\n#include <linux/crc16.h>\n#include <linux/log2.h>\n#include <linux/ctype.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/random.h>\n#include <linux/vfs.h>\n#include <linux/exportfs.h>\n#include <linux/buffer_head.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/jbd2.h>\n#include <linux/vmalloc.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n#include <linux/string.h>\n#include <linux/module.h>\n\nstatic int ext4_remount(struct super_block *sb, int *flags, char *data);\nstatic int ext4_unfreeze(struct super_block *sb);\nstatic int ext4_freeze(struct super_block *sb);\nstatic struct dentry *ext4_mount(struct file_system_type *fs_type, int flags,\n\t\t       const char *dev_name, void *data);\nstatic inline int ext2_feature_set_ok(struct super_block *sb);\nstatic inline int ext3_feature_set_ok(struct super_block *sb);\nstatic void ext4_unregister_li_request(struct super_block *sb);\n\nstatic ssize_t ext4_quota_read(struct super_block *sb, int type, char *data,\n\t\t\t       size_t len, loff_t off)\n{\n\tstruct inode *inode = sb_dqopt(sb)->files[type];\n\text4_lblk_t blk = off >> EXT4_BLOCK_SIZE_BITS(sb);\n\tint offset = off & (sb->s_blocksize - 1);\n\tint tocopy;\n\tsize_t toread;\n\tstruct buffer_head *bh;\n\tloff_t i_size = i_size_read(inode);\n\n\tif (off > i_size)\n\t\treturn 0;\n\tif (off+len > i_size)\n\t\tlen = i_size-off;\n\ttoread = len;\n\twhile (toread > 0) {\n\t\ttocopy = sb->s_blocksize - offset < toread ?\n\t\t\t\tsb->s_blocksize - offset : toread;\n\t\tbh = ext4_bread(NULL, inode, blk, 0);\n\t\tif (IS_ERR(bh))\n\t\t\treturn PTR_ERR(bh);\n\t\tif (!bh)\t/* A hole? */\n\t\t\tmemset(data, 0, tocopy);\n\t\telse\n\t\t\tmemcpy(data, bh->b_data+offset, tocopy);\n\t\tbrelse(bh);\n\t\toffset = 0;\n\t\ttoread -= tocopy;\n\t\tdata += tocopy;\n\t\tblk++;\n\t}\n\treturn len;\n}"
  },
  {
    "function_name": "ext4_quota_off",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/super.c",
    "lines": "5320-5344",
    "snippet": "static int ext4_quota_off(struct super_block *sb, int type)\n{\n\tstruct inode *inode = sb_dqopt(sb)->files[type];\n\thandle_t *handle;\n\n\t/* Force all delayed allocation blocks to be allocated.\n\t * Caller already holds s_umount sem */\n\tif (test_opt(sb, DELALLOC))\n\t\tsync_filesystem(sb);\n\n\tif (!inode)\n\t\tgoto out;\n\n\t/* Update modification times of quota files when userspace can\n\t * start looking at them */\n\thandle = ext4_journal_start(inode, EXT4_HT_QUOTA, 1);\n\tif (IS_ERR(handle))\n\t\tgoto out;\n\tinode->i_mtime = inode->i_ctime = CURRENT_TIME;\n\text4_mark_inode_dirty(handle, inode);\n\text4_journal_stop(handle);\n\nout:\n\treturn dquot_quota_off(sb, type);\n}",
    "includes": [
      "#include <trace/events/ext4.h>",
      "#include \"mballoc.h\"",
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"ext4_jbd2.h\"",
      "#include \"ext4_extents.h\"\t/* Needed for trace points definition */",
      "#include \"ext4.h\"",
      "#include <linux/freezer.h>",
      "#include <linux/kthread.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/cleancache.h>",
      "#include <linux/crc16.h>",
      "#include <linux/log2.h>",
      "#include <linux/ctype.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/namei.h>",
      "#include <linux/mount.h>",
      "#include <linux/random.h>",
      "#include <linux/vfs.h>",
      "#include <linux/exportfs.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/parser.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/init.h>",
      "#include <linux/slab.h>",
      "#include <linux/jbd2.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/time.h>",
      "#include <linux/fs.h>",
      "#include <linux/string.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ext4_unfreeze(struct super_block *sb);",
      "static int ext4_freeze(struct super_block *sb);",
      "static inline int ext2_feature_set_ok(struct super_block *sb);",
      "static inline int ext3_feature_set_ok(struct super_block *sb);",
      "static void ext4_unregister_li_request(struct super_block *sb);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "dquot_quota_off",
          "args": [
            "sb",
            "type"
          ],
          "line": 5343
        },
        "resolved": true,
        "details": {
          "function_name": "dquot_quota_off",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/quota/dquot.c",
          "lines": "2130-2134",
          "snippet": "int dquot_quota_off(struct super_block *sb, int type)\n{\n\treturn dquot_disable(sb, type,\n\t\t\t     DQUOT_USAGE_ENABLED | DQUOT_LIMITS_ENABLED);\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include \"../internal.h\" /* ugh */",
            "#include <linux/quotaops.h>",
            "#include <linux/capability.h>",
            "#include <linux/namei.h>",
            "#include <linux/kmod.h>",
            "#include <linux/sched.h>",
            "#include <linux/security.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>",
            "#include <linux/tty.h>",
            "#include <linux/stat.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/time.h>",
            "#include <linux/mm.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __dquot_initialize(struct inode *inode, int type);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include \"../internal.h\" /* ugh */\n#include <linux/quotaops.h>\n#include <linux/capability.h>\n#include <linux/namei.h>\n#include <linux/kmod.h>\n#include <linux/sched.h>\n#include <linux/security.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/sysctl.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/tty.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/time.h>\n#include <linux/mm.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/kernel.h>\n#include <linux/errno.h>\n\nstatic void __dquot_initialize(struct inode *inode, int type);\n\nint dquot_quota_off(struct super_block *sb, int type)\n{\n\treturn dquot_disable(sb, type,\n\t\t\t     DQUOT_USAGE_ENABLED | DQUOT_LIMITS_ENABLED);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_journal_stop",
          "args": [
            "handle"
          ],
          "line": 5340
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_mark_inode_dirty",
          "args": [
            "handle",
            "inode"
          ],
          "line": 5339
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_mark_inode_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/inode.c",
          "lines": "4887-4930",
          "snippet": "int ext4_mark_inode_dirty(handle_t *handle, struct inode *inode)\n{\n\tstruct ext4_iloc iloc;\n\tstruct ext4_sb_info *sbi = EXT4_SB(inode->i_sb);\n\tstatic unsigned int mnt_count;\n\tint err, ret;\n\n\tmight_sleep();\n\ttrace_ext4_mark_inode_dirty(inode, _RET_IP_);\n\terr = ext4_reserve_inode_write(handle, inode, &iloc);\n\tif (ext4_handle_valid(handle) &&\n\t    EXT4_I(inode)->i_extra_isize < sbi->s_want_extra_isize &&\n\t    !ext4_test_inode_state(inode, EXT4_STATE_NO_EXPAND)) {\n\t\t/*\n\t\t * We need extra buffer credits since we may write into EA block\n\t\t * with this same handle. If journal_extend fails, then it will\n\t\t * only result in a minor loss of functionality for that inode.\n\t\t * If this is felt to be critical, then e2fsck should be run to\n\t\t * force a large enough s_min_extra_isize.\n\t\t */\n\t\tif ((jbd2_journal_extend(handle,\n\t\t\t     EXT4_DATA_TRANS_BLOCKS(inode->i_sb))) == 0) {\n\t\t\tret = ext4_expand_extra_isize(inode,\n\t\t\t\t\t\t      sbi->s_want_extra_isize,\n\t\t\t\t\t\t      iloc, handle);\n\t\t\tif (ret) {\n\t\t\t\text4_set_inode_state(inode,\n\t\t\t\t\t\t     EXT4_STATE_NO_EXPAND);\n\t\t\t\tif (mnt_count !=\n\t\t\t\t\tle16_to_cpu(sbi->s_es->s_mnt_count)) {\n\t\t\t\t\text4_warning(inode->i_sb,\n\t\t\t\t\t\"Unable to expand inode %lu. Delete\"\n\t\t\t\t\t\" some EAs or run e2fsck.\",\n\t\t\t\t\tinode->i_ino);\n\t\t\t\t\tmnt_count =\n\t\t\t\t\t  le16_to_cpu(sbi->s_es->s_mnt_count);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tif (!err)\n\t\terr = ext4_mark_iloc_dirty(handle, inode, &iloc);\n\treturn err;\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"truncate.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include <linux/bitops.h>",
            "#include <linux/aio.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/printk.h>",
            "#include <linux/kernel.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/bio.h>",
            "#include <linux/uio.h>",
            "#include <linux/namei.h>",
            "#include <linux/mpage.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highuid.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/time.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"truncate.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include <linux/bitops.h>\n#include <linux/aio.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/printk.h>\n#include <linux/kernel.h>\n#include <linux/workqueue.h>\n#include <linux/bio.h>\n#include <linux/uio.h>\n#include <linux/namei.h>\n#include <linux/mpage.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/highuid.h>\n#include <linux/jbd2.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n\nint ext4_mark_inode_dirty(handle_t *handle, struct inode *inode)\n{\n\tstruct ext4_iloc iloc;\n\tstruct ext4_sb_info *sbi = EXT4_SB(inode->i_sb);\n\tstatic unsigned int mnt_count;\n\tint err, ret;\n\n\tmight_sleep();\n\ttrace_ext4_mark_inode_dirty(inode, _RET_IP_);\n\terr = ext4_reserve_inode_write(handle, inode, &iloc);\n\tif (ext4_handle_valid(handle) &&\n\t    EXT4_I(inode)->i_extra_isize < sbi->s_want_extra_isize &&\n\t    !ext4_test_inode_state(inode, EXT4_STATE_NO_EXPAND)) {\n\t\t/*\n\t\t * We need extra buffer credits since we may write into EA block\n\t\t * with this same handle. If journal_extend fails, then it will\n\t\t * only result in a minor loss of functionality for that inode.\n\t\t * If this is felt to be critical, then e2fsck should be run to\n\t\t * force a large enough s_min_extra_isize.\n\t\t */\n\t\tif ((jbd2_journal_extend(handle,\n\t\t\t     EXT4_DATA_TRANS_BLOCKS(inode->i_sb))) == 0) {\n\t\t\tret = ext4_expand_extra_isize(inode,\n\t\t\t\t\t\t      sbi->s_want_extra_isize,\n\t\t\t\t\t\t      iloc, handle);\n\t\t\tif (ret) {\n\t\t\t\text4_set_inode_state(inode,\n\t\t\t\t\t\t     EXT4_STATE_NO_EXPAND);\n\t\t\t\tif (mnt_count !=\n\t\t\t\t\tle16_to_cpu(sbi->s_es->s_mnt_count)) {\n\t\t\t\t\text4_warning(inode->i_sb,\n\t\t\t\t\t\"Unable to expand inode %lu. Delete\"\n\t\t\t\t\t\" some EAs or run e2fsck.\",\n\t\t\t\t\tinode->i_ino);\n\t\t\t\t\tmnt_count =\n\t\t\t\t\t  le16_to_cpu(sbi->s_es->s_mnt_count);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tif (!err)\n\t\terr = ext4_mark_iloc_dirty(handle, inode, &iloc);\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "handle"
          ],
          "line": 5336
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_journal_start",
          "args": [
            "inode",
            "EXT4_HT_QUOTA",
            "1"
          ],
          "line": 5335
        },
        "resolved": true,
        "details": {
          "function_name": "__ext4_journal_start_reserved",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ext4_jbd2.c",
          "lines": "101-123",
          "snippet": "handle_t *__ext4_journal_start_reserved(handle_t *handle, unsigned int line,\n\t\t\t\t\tint type)\n{\n\tstruct super_block *sb;\n\tint err;\n\n\tif (!ext4_handle_valid(handle))\n\t\treturn ext4_get_nojournal();\n\n\tsb = handle->h_journal->j_private;\n\ttrace_ext4_journal_start_reserved(sb, handle->h_buffer_credits,\n\t\t\t\t\t  _RET_IP_);\n\terr = ext4_journal_check_start(sb);\n\tif (err < 0) {\n\t\tjbd2_journal_free_reserved(handle);\n\t\treturn ERR_PTR(err);\n\t}\n\n\terr = jbd2_journal_start_reserved(handle, type, line);\n\tif (err < 0)\n\t\treturn ERR_PTR(err);\n\treturn handle;\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"ext4_jbd2.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"ext4_jbd2.h\"\n\nhandle_t *__ext4_journal_start_reserved(handle_t *handle, unsigned int line,\n\t\t\t\t\tint type)\n{\n\tstruct super_block *sb;\n\tint err;\n\n\tif (!ext4_handle_valid(handle))\n\t\treturn ext4_get_nojournal();\n\n\tsb = handle->h_journal->j_private;\n\ttrace_ext4_journal_start_reserved(sb, handle->h_buffer_credits,\n\t\t\t\t\t  _RET_IP_);\n\terr = ext4_journal_check_start(sb);\n\tif (err < 0) {\n\t\tjbd2_journal_free_reserved(handle);\n\t\treturn ERR_PTR(err);\n\t}\n\n\terr = jbd2_journal_start_reserved(handle, type, line);\n\tif (err < 0)\n\t\treturn ERR_PTR(err);\n\treturn handle;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sync_filesystem",
          "args": [
            "sb"
          ],
          "line": 5328
        },
        "resolved": true,
        "details": {
          "function_name": "sync_filesystem",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/sync.c",
          "lines": "47-67",
          "snippet": "int sync_filesystem(struct super_block *sb)\n{\n\tint ret;\n\n\t/*\n\t * We need to be protected against the filesystem going from\n\t * r/o to r/w or vice versa.\n\t */\n\tWARN_ON(!rwsem_is_locked(&sb->s_umount));\n\n\t/*\n\t * No point in syncing out anything if the filesystem is read-only.\n\t */\n\tif (sb->s_flags & MS_RDONLY)\n\t\treturn 0;\n\n\tret = __sync_filesystem(sb, 0);\n\tif (ret < 0)\n\t\treturn ret;\n\treturn __sync_filesystem(sb, 1);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/backing-dev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/linkage.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/writeback.h>",
            "#include <linux/sched.h>",
            "#include <linux/namei.h>",
            "#include <linux/export.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/backing-dev.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/linkage.h>\n#include <linux/syscalls.h>\n#include <linux/writeback.h>\n#include <linux/sched.h>\n#include <linux/namei.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/kernel.h>\n\nint sync_filesystem(struct super_block *sb)\n{\n\tint ret;\n\n\t/*\n\t * We need to be protected against the filesystem going from\n\t * r/o to r/w or vice versa.\n\t */\n\tWARN_ON(!rwsem_is_locked(&sb->s_umount));\n\n\t/*\n\t * No point in syncing out anything if the filesystem is read-only.\n\t */\n\tif (sb->s_flags & MS_RDONLY)\n\t\treturn 0;\n\n\tret = __sync_filesystem(sb, 0);\n\tif (ret < 0)\n\t\treturn ret;\n\treturn __sync_filesystem(sb, 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "test_opt",
          "args": [
            "sb",
            "DELALLOC"
          ],
          "line": 5327
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sb_dqopt",
          "args": [
            "sb"
          ],
          "line": 5322
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"mballoc.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4_extents.h\"\t/* Needed for trace points definition */\n#include \"ext4.h\"\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <asm/uaccess.h>\n#include <linux/cleancache.h>\n#include <linux/crc16.h>\n#include <linux/log2.h>\n#include <linux/ctype.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/random.h>\n#include <linux/vfs.h>\n#include <linux/exportfs.h>\n#include <linux/buffer_head.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/jbd2.h>\n#include <linux/vmalloc.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n#include <linux/string.h>\n#include <linux/module.h>\n\nstatic int ext4_unfreeze(struct super_block *sb);\nstatic int ext4_freeze(struct super_block *sb);\nstatic inline int ext2_feature_set_ok(struct super_block *sb);\nstatic inline int ext3_feature_set_ok(struct super_block *sb);\nstatic void ext4_unregister_li_request(struct super_block *sb);\n\nstatic int ext4_quota_off(struct super_block *sb, int type)\n{\n\tstruct inode *inode = sb_dqopt(sb)->files[type];\n\thandle_t *handle;\n\n\t/* Force all delayed allocation blocks to be allocated.\n\t * Caller already holds s_umount sem */\n\tif (test_opt(sb, DELALLOC))\n\t\tsync_filesystem(sb);\n\n\tif (!inode)\n\t\tgoto out;\n\n\t/* Update modification times of quota files when userspace can\n\t * start looking at them */\n\thandle = ext4_journal_start(inode, EXT4_HT_QUOTA, 1);\n\tif (IS_ERR(handle))\n\t\tgoto out;\n\tinode->i_mtime = inode->i_ctime = CURRENT_TIME;\n\text4_mark_inode_dirty(handle, inode);\n\text4_journal_stop(handle);\n\nout:\n\treturn dquot_quota_off(sb, type);\n}"
  },
  {
    "function_name": "ext4_enable_quotas",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/super.c",
    "lines": "5295-5318",
    "snippet": "static int ext4_enable_quotas(struct super_block *sb)\n{\n\tint type, err = 0;\n\tunsigned long qf_inums[EXT4_MAXQUOTAS] = {\n\t\tle32_to_cpu(EXT4_SB(sb)->s_es->s_usr_quota_inum),\n\t\tle32_to_cpu(EXT4_SB(sb)->s_es->s_grp_quota_inum)\n\t};\n\n\tsb_dqopt(sb)->flags |= DQUOT_QUOTA_SYS_FILE;\n\tfor (type = 0; type < EXT4_MAXQUOTAS; type++) {\n\t\tif (qf_inums[type]) {\n\t\t\terr = ext4_quota_enable(sb, type, QFMT_VFS_V1,\n\t\t\t\t\t\tDQUOT_USAGE_ENABLED);\n\t\t\tif (err) {\n\t\t\t\text4_warning(sb,\n\t\t\t\t\t\"Failed to enable quota tracking \"\n\t\t\t\t\t\"(type=%d, err=%d). Please run \"\n\t\t\t\t\t\"e2fsck to fix.\", type, err);\n\t\t\t\treturn err;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}",
    "includes": [
      "#include <trace/events/ext4.h>",
      "#include \"mballoc.h\"",
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"ext4_jbd2.h\"",
      "#include \"ext4_extents.h\"\t/* Needed for trace points definition */",
      "#include \"ext4.h\"",
      "#include <linux/freezer.h>",
      "#include <linux/kthread.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/cleancache.h>",
      "#include <linux/crc16.h>",
      "#include <linux/log2.h>",
      "#include <linux/ctype.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/namei.h>",
      "#include <linux/mount.h>",
      "#include <linux/random.h>",
      "#include <linux/vfs.h>",
      "#include <linux/exportfs.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/parser.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/init.h>",
      "#include <linux/slab.h>",
      "#include <linux/jbd2.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/time.h>",
      "#include <linux/fs.h>",
      "#include <linux/string.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ext4_unfreeze(struct super_block *sb);",
      "static int ext4_freeze(struct super_block *sb);",
      "static inline int ext2_feature_set_ok(struct super_block *sb);",
      "static inline int ext3_feature_set_ok(struct super_block *sb);",
      "static void ext4_unregister_li_request(struct super_block *sb);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ext4_warning",
          "args": [
            "sb",
            "\"Failed to enable quota tracking \"\n\t\t\t\t\t\"(type=%d, err=%d). Please run \"\n\t\t\t\t\t\"e2fsck to fix.\"",
            "type",
            "err"
          ],
          "line": 5309
        },
        "resolved": true,
        "details": {
          "function_name": "__ext4_warning",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/super.c",
          "lines": "609-625",
          "snippet": "void __ext4_warning(struct super_block *sb, const char *function,\n\t\t    unsigned int line, const char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tif (!___ratelimit(&(EXT4_SB(sb)->s_warning_ratelimit_state),\n\t\t\t  \"EXT4-fs warning\"))\n\t\treturn;\n\n\tva_start(args, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\tprintk(KERN_WARNING \"EXT4-fs warning (device %s): %s:%d: %pV\\n\",\n\t       sb->s_id, function, line, &vaf);\n\tva_end(args);\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"mballoc.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include \"ext4_extents.h\"\t/* Needed for trace points definition */",
            "#include \"ext4.h\"",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/crc16.h>",
            "#include <linux/log2.h>",
            "#include <linux/ctype.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/random.h>",
            "#include <linux/vfs.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/parser.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/time.h>",
            "#include <linux/fs.h>",
            "#include <linux/string.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ext4_unfreeze(struct super_block *sb);",
            "static int ext4_freeze(struct super_block *sb);",
            "static inline int ext2_feature_set_ok(struct super_block *sb);",
            "static inline int ext3_feature_set_ok(struct super_block *sb);",
            "static void ext4_unregister_li_request(struct super_block *sb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"mballoc.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4_extents.h\"\t/* Needed for trace points definition */\n#include \"ext4.h\"\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <asm/uaccess.h>\n#include <linux/cleancache.h>\n#include <linux/crc16.h>\n#include <linux/log2.h>\n#include <linux/ctype.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/random.h>\n#include <linux/vfs.h>\n#include <linux/exportfs.h>\n#include <linux/buffer_head.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/jbd2.h>\n#include <linux/vmalloc.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n#include <linux/string.h>\n#include <linux/module.h>\n\nstatic int ext4_unfreeze(struct super_block *sb);\nstatic int ext4_freeze(struct super_block *sb);\nstatic inline int ext2_feature_set_ok(struct super_block *sb);\nstatic inline int ext3_feature_set_ok(struct super_block *sb);\nstatic void ext4_unregister_li_request(struct super_block *sb);\n\nvoid __ext4_warning(struct super_block *sb, const char *function,\n\t\t    unsigned int line, const char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tif (!___ratelimit(&(EXT4_SB(sb)->s_warning_ratelimit_state),\n\t\t\t  \"EXT4-fs warning\"))\n\t\treturn;\n\n\tva_start(args, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\tprintk(KERN_WARNING \"EXT4-fs warning (device %s): %s:%d: %pV\\n\",\n\t       sb->s_id, function, line, &vaf);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_quota_enable",
          "args": [
            "sb",
            "type",
            "QFMT_VFS_V1",
            "DQUOT_USAGE_ENABLED"
          ],
          "line": 5306
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_quota_enable",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/super.c",
          "lines": "5265-5292",
          "snippet": "static int ext4_quota_enable(struct super_block *sb, int type, int format_id,\n\t\t\t     unsigned int flags)\n{\n\tint err;\n\tstruct inode *qf_inode;\n\tunsigned long qf_inums[EXT4_MAXQUOTAS] = {\n\t\tle32_to_cpu(EXT4_SB(sb)->s_es->s_usr_quota_inum),\n\t\tle32_to_cpu(EXT4_SB(sb)->s_es->s_grp_quota_inum)\n\t};\n\n\tBUG_ON(!EXT4_HAS_RO_COMPAT_FEATURE(sb, EXT4_FEATURE_RO_COMPAT_QUOTA));\n\n\tif (!qf_inums[type])\n\t\treturn -EPERM;\n\n\tqf_inode = ext4_iget(sb, qf_inums[type]);\n\tif (IS_ERR(qf_inode)) {\n\t\text4_error(sb, \"Bad quota inode # %lu\", qf_inums[type]);\n\t\treturn PTR_ERR(qf_inode);\n\t}\n\n\t/* Don't account quota for quota files to avoid recursion */\n\tqf_inode->i_flags |= S_NOQUOTA;\n\terr = dquot_enable(qf_inode, type, format_id, flags);\n\tiput(qf_inode);\n\n\treturn err;\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"mballoc.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include \"ext4_extents.h\"\t/* Needed for trace points definition */",
            "#include \"ext4.h\"",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/crc16.h>",
            "#include <linux/log2.h>",
            "#include <linux/ctype.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/random.h>",
            "#include <linux/vfs.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/parser.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/time.h>",
            "#include <linux/fs.h>",
            "#include <linux/string.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ext4_unfreeze(struct super_block *sb);",
            "static int ext4_freeze(struct super_block *sb);",
            "static inline int ext2_feature_set_ok(struct super_block *sb);",
            "static inline int ext3_feature_set_ok(struct super_block *sb);",
            "static void ext4_unregister_li_request(struct super_block *sb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"mballoc.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4_extents.h\"\t/* Needed for trace points definition */\n#include \"ext4.h\"\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <asm/uaccess.h>\n#include <linux/cleancache.h>\n#include <linux/crc16.h>\n#include <linux/log2.h>\n#include <linux/ctype.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/random.h>\n#include <linux/vfs.h>\n#include <linux/exportfs.h>\n#include <linux/buffer_head.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/jbd2.h>\n#include <linux/vmalloc.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n#include <linux/string.h>\n#include <linux/module.h>\n\nstatic int ext4_unfreeze(struct super_block *sb);\nstatic int ext4_freeze(struct super_block *sb);\nstatic inline int ext2_feature_set_ok(struct super_block *sb);\nstatic inline int ext3_feature_set_ok(struct super_block *sb);\nstatic void ext4_unregister_li_request(struct super_block *sb);\n\nstatic int ext4_quota_enable(struct super_block *sb, int type, int format_id,\n\t\t\t     unsigned int flags)\n{\n\tint err;\n\tstruct inode *qf_inode;\n\tunsigned long qf_inums[EXT4_MAXQUOTAS] = {\n\t\tle32_to_cpu(EXT4_SB(sb)->s_es->s_usr_quota_inum),\n\t\tle32_to_cpu(EXT4_SB(sb)->s_es->s_grp_quota_inum)\n\t};\n\n\tBUG_ON(!EXT4_HAS_RO_COMPAT_FEATURE(sb, EXT4_FEATURE_RO_COMPAT_QUOTA));\n\n\tif (!qf_inums[type])\n\t\treturn -EPERM;\n\n\tqf_inode = ext4_iget(sb, qf_inums[type]);\n\tif (IS_ERR(qf_inode)) {\n\t\text4_error(sb, \"Bad quota inode # %lu\", qf_inums[type]);\n\t\treturn PTR_ERR(qf_inode);\n\t}\n\n\t/* Don't account quota for quota files to avoid recursion */\n\tqf_inode->i_flags |= S_NOQUOTA;\n\terr = dquot_enable(qf_inode, type, format_id, flags);\n\tiput(qf_inode);\n\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sb_dqopt",
          "args": [
            "sb"
          ],
          "line": 5303
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "EXT4_SB(sb)->s_es->s_grp_quota_inum"
          ],
          "line": 5300
        },
        "resolved": true,
        "details": {
          "function_name": "sle32_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "53-56",
          "snippet": "static inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "EXT4_SB",
          "args": [
            "sb"
          ],
          "line": 5300
        },
        "resolved": true,
        "details": {
          "function_name": "EXT4_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ext4.h",
          "lines": "1356-1359",
          "snippet": "static inline struct ext4_sb_info *EXT4_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include \"extents_status.h\"",
            "#include <linux/compat.h>",
            "#include <linux/falloc.h>",
            "#include <crypto/hash.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/wait.h>",
            "#include <linux/timer.h>",
            "#include <linux/mutex.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/quota.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extents_status.h\"\n#include <linux/compat.h>\n#include <linux/falloc.h>\n#include <crypto/hash.h>\n#include <linux/ratelimit.h>\n#include <linux/percpu_counter.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/wait.h>\n#include <linux/timer.h>\n#include <linux/mutex.h>\n#include <linux/seqlock.h>\n#include <linux/rbtree.h>\n#include <linux/rwsem.h>\n#include <linux/quota.h>\n#include <linux/jbd2.h>\n#include <linux/magic.h>\n#include <linux/blkdev.h>\n#include <linux/types.h>\n\nstatic inline struct ext4_sb_info *EXT4_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"mballoc.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4_extents.h\"\t/* Needed for trace points definition */\n#include \"ext4.h\"\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <asm/uaccess.h>\n#include <linux/cleancache.h>\n#include <linux/crc16.h>\n#include <linux/log2.h>\n#include <linux/ctype.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/random.h>\n#include <linux/vfs.h>\n#include <linux/exportfs.h>\n#include <linux/buffer_head.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/jbd2.h>\n#include <linux/vmalloc.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n#include <linux/string.h>\n#include <linux/module.h>\n\nstatic int ext4_unfreeze(struct super_block *sb);\nstatic int ext4_freeze(struct super_block *sb);\nstatic inline int ext2_feature_set_ok(struct super_block *sb);\nstatic inline int ext3_feature_set_ok(struct super_block *sb);\nstatic void ext4_unregister_li_request(struct super_block *sb);\n\nstatic int ext4_enable_quotas(struct super_block *sb)\n{\n\tint type, err = 0;\n\tunsigned long qf_inums[EXT4_MAXQUOTAS] = {\n\t\tle32_to_cpu(EXT4_SB(sb)->s_es->s_usr_quota_inum),\n\t\tle32_to_cpu(EXT4_SB(sb)->s_es->s_grp_quota_inum)\n\t};\n\n\tsb_dqopt(sb)->flags |= DQUOT_QUOTA_SYS_FILE;\n\tfor (type = 0; type < EXT4_MAXQUOTAS; type++) {\n\t\tif (qf_inums[type]) {\n\t\t\terr = ext4_quota_enable(sb, type, QFMT_VFS_V1,\n\t\t\t\t\t\tDQUOT_USAGE_ENABLED);\n\t\t\tif (err) {\n\t\t\t\text4_warning(sb,\n\t\t\t\t\t\"Failed to enable quota tracking \"\n\t\t\t\t\t\"(type=%d, err=%d). Please run \"\n\t\t\t\t\t\"e2fsck to fix.\", type, err);\n\t\t\t\treturn err;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "function_name": "ext4_quota_enable",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/super.c",
    "lines": "5265-5292",
    "snippet": "static int ext4_quota_enable(struct super_block *sb, int type, int format_id,\n\t\t\t     unsigned int flags)\n{\n\tint err;\n\tstruct inode *qf_inode;\n\tunsigned long qf_inums[EXT4_MAXQUOTAS] = {\n\t\tle32_to_cpu(EXT4_SB(sb)->s_es->s_usr_quota_inum),\n\t\tle32_to_cpu(EXT4_SB(sb)->s_es->s_grp_quota_inum)\n\t};\n\n\tBUG_ON(!EXT4_HAS_RO_COMPAT_FEATURE(sb, EXT4_FEATURE_RO_COMPAT_QUOTA));\n\n\tif (!qf_inums[type])\n\t\treturn -EPERM;\n\n\tqf_inode = ext4_iget(sb, qf_inums[type]);\n\tif (IS_ERR(qf_inode)) {\n\t\text4_error(sb, \"Bad quota inode # %lu\", qf_inums[type]);\n\t\treturn PTR_ERR(qf_inode);\n\t}\n\n\t/* Don't account quota for quota files to avoid recursion */\n\tqf_inode->i_flags |= S_NOQUOTA;\n\terr = dquot_enable(qf_inode, type, format_id, flags);\n\tiput(qf_inode);\n\n\treturn err;\n}",
    "includes": [
      "#include <trace/events/ext4.h>",
      "#include \"mballoc.h\"",
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"ext4_jbd2.h\"",
      "#include \"ext4_extents.h\"\t/* Needed for trace points definition */",
      "#include \"ext4.h\"",
      "#include <linux/freezer.h>",
      "#include <linux/kthread.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/cleancache.h>",
      "#include <linux/crc16.h>",
      "#include <linux/log2.h>",
      "#include <linux/ctype.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/namei.h>",
      "#include <linux/mount.h>",
      "#include <linux/random.h>",
      "#include <linux/vfs.h>",
      "#include <linux/exportfs.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/parser.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/init.h>",
      "#include <linux/slab.h>",
      "#include <linux/jbd2.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/time.h>",
      "#include <linux/fs.h>",
      "#include <linux/string.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ext4_unfreeze(struct super_block *sb);",
      "static int ext4_freeze(struct super_block *sb);",
      "static inline int ext2_feature_set_ok(struct super_block *sb);",
      "static inline int ext3_feature_set_ok(struct super_block *sb);",
      "static void ext4_unregister_li_request(struct super_block *sb);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "iput",
          "args": [
            "qf_inode"
          ],
          "line": 5289
        },
        "resolved": true,
        "details": {
          "function_name": "dentry_iput",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "308-327",
          "snippet": "static void dentry_iput(struct dentry * dentry)\n\t__releases(dentry->d_lock)\n\t__releases(dentry->d_inode->i_lock)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tif (inode) {\n\t\tdentry->d_inode = NULL;\n\t\thlist_del_init(&dentry->d_u.d_alias);\n\t\tspin_unlock(&dentry->d_lock);\n\t\tspin_unlock(&inode->i_lock);\n\t\tif (!inode->i_nlink)\n\t\t\tfsnotify_inoderemove(inode);\n\t\tif (dentry->d_op && dentry->d_op->d_iput)\n\t\t\tdentry->d_op->d_iput(dentry, inode);\n\t\telse\n\t\t\tiput(inode);\n\t} else {\n\t\tspin_unlock(&dentry->d_lock);\n\t}\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nstatic void dentry_iput(struct dentry * dentry)\n\t__releases(dentry->d_lock)\n\t__releases(dentry->d_inode->i_lock)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tif (inode) {\n\t\tdentry->d_inode = NULL;\n\t\thlist_del_init(&dentry->d_u.d_alias);\n\t\tspin_unlock(&dentry->d_lock);\n\t\tspin_unlock(&inode->i_lock);\n\t\tif (!inode->i_nlink)\n\t\t\tfsnotify_inoderemove(inode);\n\t\tif (dentry->d_op && dentry->d_op->d_iput)\n\t\t\tdentry->d_op->d_iput(dentry, inode);\n\t\telse\n\t\t\tiput(inode);\n\t} else {\n\t\tspin_unlock(&dentry->d_lock);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "dquot_enable",
          "args": [
            "qf_inode",
            "type",
            "format_id",
            "flags"
          ],
          "line": 5288
        },
        "resolved": true,
        "details": {
          "function_name": "dquot_enable",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/quota/dquot.c",
          "lines": "2313-2353",
          "snippet": "int dquot_enable(struct inode *inode, int type, int format_id,\n\t\t unsigned int flags)\n{\n\tint ret = 0;\n\tstruct super_block *sb = inode->i_sb;\n\tstruct quota_info *dqopt = sb_dqopt(sb);\n\n\t/* Just unsuspend quotas? */\n\tBUG_ON(flags & DQUOT_SUSPENDED);\n\n\tif (!flags)\n\t\treturn 0;\n\t/* Just updating flags needed? */\n\tif (sb_has_quota_loaded(sb, type)) {\n\t\tmutex_lock(&dqopt->dqonoff_mutex);\n\t\t/* Now do a reliable test... */\n\t\tif (!sb_has_quota_loaded(sb, type)) {\n\t\t\tmutex_unlock(&dqopt->dqonoff_mutex);\n\t\t\tgoto load_quota;\n\t\t}\n\t\tif (flags & DQUOT_USAGE_ENABLED &&\n\t\t    sb_has_quota_usage_enabled(sb, type)) {\n\t\t\tret = -EBUSY;\n\t\t\tgoto out_lock;\n\t\t}\n\t\tif (flags & DQUOT_LIMITS_ENABLED &&\n\t\t    sb_has_quota_limits_enabled(sb, type)) {\n\t\t\tret = -EBUSY;\n\t\t\tgoto out_lock;\n\t\t}\n\t\tspin_lock(&dq_state_lock);\n\t\tsb_dqopt(sb)->flags |= dquot_state_flag(flags, type);\n\t\tspin_unlock(&dq_state_lock);\nout_lock:\n\t\tmutex_unlock(&dqopt->dqonoff_mutex);\n\t\treturn ret;\n\t}\n\nload_quota:\n\treturn vfs_load_quota_inode(inode, type, format_id, flags);\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include \"../internal.h\" /* ugh */",
            "#include <linux/quotaops.h>",
            "#include <linux/capability.h>",
            "#include <linux/namei.h>",
            "#include <linux/kmod.h>",
            "#include <linux/sched.h>",
            "#include <linux/security.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>",
            "#include <linux/tty.h>",
            "#include <linux/stat.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/time.h>",
            "#include <linux/mm.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __cacheline_aligned_in_smp DEFINE_SPINLOCK(dq_state_lock);",
            "static qsize_t inode_get_rsv_space(struct inode *inode);",
            "static void __dquot_initialize(struct inode *inode, int type);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include \"../internal.h\" /* ugh */\n#include <linux/quotaops.h>\n#include <linux/capability.h>\n#include <linux/namei.h>\n#include <linux/kmod.h>\n#include <linux/sched.h>\n#include <linux/security.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/sysctl.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/tty.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/time.h>\n#include <linux/mm.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/kernel.h>\n#include <linux/errno.h>\n\nstatic __cacheline_aligned_in_smp DEFINE_SPINLOCK(dq_state_lock);\nstatic qsize_t inode_get_rsv_space(struct inode *inode);\nstatic void __dquot_initialize(struct inode *inode, int type);\n\nint dquot_enable(struct inode *inode, int type, int format_id,\n\t\t unsigned int flags)\n{\n\tint ret = 0;\n\tstruct super_block *sb = inode->i_sb;\n\tstruct quota_info *dqopt = sb_dqopt(sb);\n\n\t/* Just unsuspend quotas? */\n\tBUG_ON(flags & DQUOT_SUSPENDED);\n\n\tif (!flags)\n\t\treturn 0;\n\t/* Just updating flags needed? */\n\tif (sb_has_quota_loaded(sb, type)) {\n\t\tmutex_lock(&dqopt->dqonoff_mutex);\n\t\t/* Now do a reliable test... */\n\t\tif (!sb_has_quota_loaded(sb, type)) {\n\t\t\tmutex_unlock(&dqopt->dqonoff_mutex);\n\t\t\tgoto load_quota;\n\t\t}\n\t\tif (flags & DQUOT_USAGE_ENABLED &&\n\t\t    sb_has_quota_usage_enabled(sb, type)) {\n\t\t\tret = -EBUSY;\n\t\t\tgoto out_lock;\n\t\t}\n\t\tif (flags & DQUOT_LIMITS_ENABLED &&\n\t\t    sb_has_quota_limits_enabled(sb, type)) {\n\t\t\tret = -EBUSY;\n\t\t\tgoto out_lock;\n\t\t}\n\t\tspin_lock(&dq_state_lock);\n\t\tsb_dqopt(sb)->flags |= dquot_state_flag(flags, type);\n\t\tspin_unlock(&dq_state_lock);\nout_lock:\n\t\tmutex_unlock(&dqopt->dqonoff_mutex);\n\t\treturn ret;\n\t}\n\nload_quota:\n\treturn vfs_load_quota_inode(inode, type, format_id, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "qf_inode"
          ],
          "line": 5283
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_error",
          "args": [
            "sb",
            "\"Bad quota inode # %lu\"",
            "qf_inums[type]"
          ],
          "line": 5282
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "qf_inode"
          ],
          "line": 5281
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_iget",
          "args": [
            "sb",
            "qf_inums[type]"
          ],
          "line": 5280
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_iget_normal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/inode.c",
          "lines": "4138-4143",
          "snippet": "struct inode *ext4_iget_normal(struct super_block *sb, unsigned long ino)\n{\n\tif (ino < EXT4_FIRST_INO(sb) && ino != EXT4_ROOT_INO)\n\t\treturn ERR_PTR(-EIO);\n\treturn ext4_iget(sb, ino);\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"truncate.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include <linux/bitops.h>",
            "#include <linux/aio.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/printk.h>",
            "#include <linux/kernel.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/bio.h>",
            "#include <linux/uio.h>",
            "#include <linux/namei.h>",
            "#include <linux/mpage.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highuid.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/time.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"truncate.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include <linux/bitops.h>\n#include <linux/aio.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/printk.h>\n#include <linux/kernel.h>\n#include <linux/workqueue.h>\n#include <linux/bio.h>\n#include <linux/uio.h>\n#include <linux/namei.h>\n#include <linux/mpage.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/highuid.h>\n#include <linux/jbd2.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n\nstruct inode *ext4_iget_normal(struct super_block *sb, unsigned long ino)\n{\n\tif (ino < EXT4_FIRST_INO(sb) && ino != EXT4_ROOT_INO)\n\t\treturn ERR_PTR(-EIO);\n\treturn ext4_iget(sb, ino);\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!EXT4_HAS_RO_COMPAT_FEATURE(sb, EXT4_FEATURE_RO_COMPAT_QUOTA)"
          ],
          "line": 5275
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXT4_HAS_RO_COMPAT_FEATURE",
          "args": [
            "sb",
            "EXT4_FEATURE_RO_COMPAT_QUOTA"
          ],
          "line": 5275
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "EXT4_SB(sb)->s_es->s_grp_quota_inum"
          ],
          "line": 5272
        },
        "resolved": true,
        "details": {
          "function_name": "sle32_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "53-56",
          "snippet": "static inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "EXT4_SB",
          "args": [
            "sb"
          ],
          "line": 5272
        },
        "resolved": true,
        "details": {
          "function_name": "EXT4_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ext4.h",
          "lines": "1356-1359",
          "snippet": "static inline struct ext4_sb_info *EXT4_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include \"extents_status.h\"",
            "#include <linux/compat.h>",
            "#include <linux/falloc.h>",
            "#include <crypto/hash.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/wait.h>",
            "#include <linux/timer.h>",
            "#include <linux/mutex.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/quota.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extents_status.h\"\n#include <linux/compat.h>\n#include <linux/falloc.h>\n#include <crypto/hash.h>\n#include <linux/ratelimit.h>\n#include <linux/percpu_counter.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/wait.h>\n#include <linux/timer.h>\n#include <linux/mutex.h>\n#include <linux/seqlock.h>\n#include <linux/rbtree.h>\n#include <linux/rwsem.h>\n#include <linux/quota.h>\n#include <linux/jbd2.h>\n#include <linux/magic.h>\n#include <linux/blkdev.h>\n#include <linux/types.h>\n\nstatic inline struct ext4_sb_info *EXT4_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"mballoc.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4_extents.h\"\t/* Needed for trace points definition */\n#include \"ext4.h\"\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <asm/uaccess.h>\n#include <linux/cleancache.h>\n#include <linux/crc16.h>\n#include <linux/log2.h>\n#include <linux/ctype.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/random.h>\n#include <linux/vfs.h>\n#include <linux/exportfs.h>\n#include <linux/buffer_head.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/jbd2.h>\n#include <linux/vmalloc.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n#include <linux/string.h>\n#include <linux/module.h>\n\nstatic int ext4_unfreeze(struct super_block *sb);\nstatic int ext4_freeze(struct super_block *sb);\nstatic inline int ext2_feature_set_ok(struct super_block *sb);\nstatic inline int ext3_feature_set_ok(struct super_block *sb);\nstatic void ext4_unregister_li_request(struct super_block *sb);\n\nstatic int ext4_quota_enable(struct super_block *sb, int type, int format_id,\n\t\t\t     unsigned int flags)\n{\n\tint err;\n\tstruct inode *qf_inode;\n\tunsigned long qf_inums[EXT4_MAXQUOTAS] = {\n\t\tle32_to_cpu(EXT4_SB(sb)->s_es->s_usr_quota_inum),\n\t\tle32_to_cpu(EXT4_SB(sb)->s_es->s_grp_quota_inum)\n\t};\n\n\tBUG_ON(!EXT4_HAS_RO_COMPAT_FEATURE(sb, EXT4_FEATURE_RO_COMPAT_QUOTA));\n\n\tif (!qf_inums[type])\n\t\treturn -EPERM;\n\n\tqf_inode = ext4_iget(sb, qf_inums[type]);\n\tif (IS_ERR(qf_inode)) {\n\t\text4_error(sb, \"Bad quota inode # %lu\", qf_inums[type]);\n\t\treturn PTR_ERR(qf_inode);\n\t}\n\n\t/* Don't account quota for quota files to avoid recursion */\n\tqf_inode->i_flags |= S_NOQUOTA;\n\terr = dquot_enable(qf_inode, type, format_id, flags);\n\tiput(qf_inode);\n\n\treturn err;\n}"
  },
  {
    "function_name": "ext4_quota_on",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/super.c",
    "lines": "5225-5263",
    "snippet": "static int ext4_quota_on(struct super_block *sb, int type, int format_id,\n\t\t\t struct path *path)\n{\n\tint err;\n\n\tif (!test_opt(sb, QUOTA))\n\t\treturn -EINVAL;\n\n\t/* Quotafile not on the same filesystem? */\n\tif (path->dentry->d_sb != sb)\n\t\treturn -EXDEV;\n\t/* Journaling quota? */\n\tif (EXT4_SB(sb)->s_qf_names[type]) {\n\t\t/* Quotafile not in fs root? */\n\t\tif (path->dentry->d_parent != sb->s_root)\n\t\t\text4_msg(sb, KERN_WARNING,\n\t\t\t\t\"Quota file not on filesystem root. \"\n\t\t\t\t\"Journaled quota will not work\");\n\t}\n\n\t/*\n\t * When we journal data on quota file, we have to flush journal to see\n\t * all updates to the file when we bypass pagecache...\n\t */\n\tif (EXT4_SB(sb)->s_journal &&\n\t    ext4_should_journal_data(path->dentry->d_inode)) {\n\t\t/*\n\t\t * We don't need to lock updates but journal_flush() could\n\t\t * otherwise be livelocked...\n\t\t */\n\t\tjbd2_journal_lock_updates(EXT4_SB(sb)->s_journal);\n\t\terr = jbd2_journal_flush(EXT4_SB(sb)->s_journal);\n\t\tjbd2_journal_unlock_updates(EXT4_SB(sb)->s_journal);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\treturn dquot_quota_on(sb, type, format_id, path);\n}",
    "includes": [
      "#include <trace/events/ext4.h>",
      "#include \"mballoc.h\"",
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"ext4_jbd2.h\"",
      "#include \"ext4_extents.h\"\t/* Needed for trace points definition */",
      "#include \"ext4.h\"",
      "#include <linux/freezer.h>",
      "#include <linux/kthread.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/cleancache.h>",
      "#include <linux/crc16.h>",
      "#include <linux/log2.h>",
      "#include <linux/ctype.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/namei.h>",
      "#include <linux/mount.h>",
      "#include <linux/random.h>",
      "#include <linux/vfs.h>",
      "#include <linux/exportfs.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/parser.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/init.h>",
      "#include <linux/slab.h>",
      "#include <linux/jbd2.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/time.h>",
      "#include <linux/fs.h>",
      "#include <linux/string.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ext4_show_options(struct seq_file *seq, struct dentry *root);",
      "static int ext4_remount(struct super_block *sb, int *flags, char *data);",
      "static int ext4_unfreeze(struct super_block *sb);",
      "static int ext4_freeze(struct super_block *sb);",
      "static struct dentry *ext4_mount(struct file_system_type *fs_type, int flags,\n\t\t       const char *dev_name, void *data);",
      "static inline int ext2_feature_set_ok(struct super_block *sb);",
      "static inline int ext3_feature_set_ok(struct super_block *sb);",
      "static void ext4_unregister_li_request(struct super_block *sb);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "dquot_quota_on",
          "args": [
            "sb",
            "type",
            "format_id",
            "path"
          ],
          "line": 5262
        },
        "resolved": true,
        "details": {
          "function_name": "dquot_quota_on_mount",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/quota/dquot.c",
          "lines": "2360-2385",
          "snippet": "int dquot_quota_on_mount(struct super_block *sb, char *qf_name,\n\t\tint format_id, int type)\n{\n\tstruct dentry *dentry;\n\tint error;\n\n\tmutex_lock(&sb->s_root->d_inode->i_mutex);\n\tdentry = lookup_one_len(qf_name, sb->s_root, strlen(qf_name));\n\tmutex_unlock(&sb->s_root->d_inode->i_mutex);\n\tif (IS_ERR(dentry))\n\t\treturn PTR_ERR(dentry);\n\n\tif (!dentry->d_inode) {\n\t\terror = -ENOENT;\n\t\tgoto out;\n\t}\n\n\terror = security_quota_on(dentry);\n\tif (!error)\n\t\terror = vfs_load_quota_inode(dentry->d_inode, type, format_id,\n\t\t\t\tDQUOT_USAGE_ENABLED | DQUOT_LIMITS_ENABLED);\n\nout:\n\tdput(dentry);\n\treturn error;\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include \"../internal.h\" /* ugh */",
            "#include <linux/quotaops.h>",
            "#include <linux/capability.h>",
            "#include <linux/namei.h>",
            "#include <linux/kmod.h>",
            "#include <linux/sched.h>",
            "#include <linux/security.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>",
            "#include <linux/tty.h>",
            "#include <linux/stat.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/time.h>",
            "#include <linux/mm.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __dquot_initialize(struct inode *inode, int type);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include \"../internal.h\" /* ugh */\n#include <linux/quotaops.h>\n#include <linux/capability.h>\n#include <linux/namei.h>\n#include <linux/kmod.h>\n#include <linux/sched.h>\n#include <linux/security.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/sysctl.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/tty.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/time.h>\n#include <linux/mm.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/kernel.h>\n#include <linux/errno.h>\n\nstatic void __dquot_initialize(struct inode *inode, int type);\n\nint dquot_quota_on_mount(struct super_block *sb, char *qf_name,\n\t\tint format_id, int type)\n{\n\tstruct dentry *dentry;\n\tint error;\n\n\tmutex_lock(&sb->s_root->d_inode->i_mutex);\n\tdentry = lookup_one_len(qf_name, sb->s_root, strlen(qf_name));\n\tmutex_unlock(&sb->s_root->d_inode->i_mutex);\n\tif (IS_ERR(dentry))\n\t\treturn PTR_ERR(dentry);\n\n\tif (!dentry->d_inode) {\n\t\terror = -ENOENT;\n\t\tgoto out;\n\t}\n\n\terror = security_quota_on(dentry);\n\tif (!error)\n\t\terror = vfs_load_quota_inode(dentry->d_inode, type, format_id,\n\t\t\t\tDQUOT_USAGE_ENABLED | DQUOT_LIMITS_ENABLED);\n\nout:\n\tdput(dentry);\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "jbd2_journal_unlock_updates",
          "args": [
            "EXT4_SB(sb)->s_journal"
          ],
          "line": 5257
        },
        "resolved": true,
        "details": {
          "function_name": "jbd2_journal_unlock_updates",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd2/transaction.c",
          "lines": "744-753",
          "snippet": "void jbd2_journal_unlock_updates (journal_t *journal)\n{\n\tJ_ASSERT(journal->j_barrier_count != 0);\n\n\tmutex_unlock(&journal->j_barrier);\n\twrite_lock(&journal->j_state_lock);\n\t--journal->j_barrier_count;\n\twrite_unlock(&journal->j_state_lock);\n\twake_up(&journal->j_wait_transaction_locked);\n}",
          "includes": [
            "#include <trace/events/jbd2.h>",
            "#include <linux/module.h>",
            "#include <linux/bug.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/timer.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/jbd2.h>\n#include <linux/module.h>\n#include <linux/bug.h>\n#include <linux/backing-dev.h>\n#include <linux/hrtimer.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/timer.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd2.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n\nvoid jbd2_journal_unlock_updates (journal_t *journal)\n{\n\tJ_ASSERT(journal->j_barrier_count != 0);\n\n\tmutex_unlock(&journal->j_barrier);\n\twrite_lock(&journal->j_state_lock);\n\t--journal->j_barrier_count;\n\twrite_unlock(&journal->j_state_lock);\n\twake_up(&journal->j_wait_transaction_locked);\n}"
        }
      },
      {
        "call_info": {
          "callee": "EXT4_SB",
          "args": [
            "sb"
          ],
          "line": 5257
        },
        "resolved": true,
        "details": {
          "function_name": "EXT4_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ext4.h",
          "lines": "1356-1359",
          "snippet": "static inline struct ext4_sb_info *EXT4_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include \"extents_status.h\"",
            "#include <linux/compat.h>",
            "#include <linux/falloc.h>",
            "#include <crypto/hash.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/wait.h>",
            "#include <linux/timer.h>",
            "#include <linux/mutex.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/quota.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extents_status.h\"\n#include <linux/compat.h>\n#include <linux/falloc.h>\n#include <crypto/hash.h>\n#include <linux/ratelimit.h>\n#include <linux/percpu_counter.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/wait.h>\n#include <linux/timer.h>\n#include <linux/mutex.h>\n#include <linux/seqlock.h>\n#include <linux/rbtree.h>\n#include <linux/rwsem.h>\n#include <linux/quota.h>\n#include <linux/jbd2.h>\n#include <linux/magic.h>\n#include <linux/blkdev.h>\n#include <linux/types.h>\n\nstatic inline struct ext4_sb_info *EXT4_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      },
      {
        "call_info": {
          "callee": "jbd2_journal_flush",
          "args": [
            "EXT4_SB(sb)->s_journal"
          ],
          "line": 5256
        },
        "resolved": true,
        "details": {
          "function_name": "jbd2_journal_flush",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd2/journal.c",
          "lines": "1914-1970",
          "snippet": "int jbd2_journal_flush(journal_t *journal)\n{\n\tint err = 0;\n\ttransaction_t *transaction = NULL;\n\n\twrite_lock(&journal->j_state_lock);\n\n\t/* Force everything buffered to the log... */\n\tif (journal->j_running_transaction) {\n\t\ttransaction = journal->j_running_transaction;\n\t\t__jbd2_log_start_commit(journal, transaction->t_tid);\n\t} else if (journal->j_committing_transaction)\n\t\ttransaction = journal->j_committing_transaction;\n\n\t/* Wait for the log commit to complete... */\n\tif (transaction) {\n\t\ttid_t tid = transaction->t_tid;\n\n\t\twrite_unlock(&journal->j_state_lock);\n\t\tjbd2_log_wait_commit(journal, tid);\n\t} else {\n\t\twrite_unlock(&journal->j_state_lock);\n\t}\n\n\t/* ...and flush everything in the log out to disk. */\n\tspin_lock(&journal->j_list_lock);\n\twhile (!err && journal->j_checkpoint_transactions != NULL) {\n\t\tspin_unlock(&journal->j_list_lock);\n\t\tmutex_lock(&journal->j_checkpoint_mutex);\n\t\terr = jbd2_log_do_checkpoint(journal);\n\t\tmutex_unlock(&journal->j_checkpoint_mutex);\n\t\tspin_lock(&journal->j_list_lock);\n\t}\n\tspin_unlock(&journal->j_list_lock);\n\n\tif (is_journal_aborted(journal))\n\t\treturn -EIO;\n\n\tmutex_lock(&journal->j_checkpoint_mutex);\n\tjbd2_cleanup_journal_tail(journal);\n\n\t/* Finally, mark the journal as really needing no recovery.\n\t * This sets s_start==0 in the underlying superblock, which is\n\t * the magic code for a fully-recovered superblock.  Any future\n\t * commits of data to the journal will restore the current\n\t * s_start value. */\n\tjbd2_mark_journal_empty(journal);\n\tmutex_unlock(&journal->j_checkpoint_mutex);\n\twrite_lock(&journal->j_state_lock);\n\tJ_ASSERT(!journal->j_running_transaction);\n\tJ_ASSERT(!journal->j_committing_transaction);\n\tJ_ASSERT(!journal->j_checkpoint_transactions);\n\tJ_ASSERT(journal->j_head == journal->j_tail);\n\tJ_ASSERT(journal->j_tail_sequence == journal->j_transaction_sequence);\n\twrite_unlock(&journal->j_state_lock);\n\treturn 0;\n}",
          "includes": [
            "#include <asm/page.h>",
            "#include <asm/uaccess.h>",
            "#include <trace/events/jbd2.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/bitops.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/log2.h>",
            "#include <linux/hash.h>",
            "#include <linux/math64.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/poison.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <trace/events/jbd2.h>\n#include <linux/ratelimit.h>\n#include <linux/bitops.h>\n#include <linux/backing-dev.h>\n#include <linux/vmalloc.h>\n#include <linux/log2.h>\n#include <linux/hash.h>\n#include <linux/math64.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/poison.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/freezer.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd2.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/module.h>\n\nint jbd2_journal_flush(journal_t *journal)\n{\n\tint err = 0;\n\ttransaction_t *transaction = NULL;\n\n\twrite_lock(&journal->j_state_lock);\n\n\t/* Force everything buffered to the log... */\n\tif (journal->j_running_transaction) {\n\t\ttransaction = journal->j_running_transaction;\n\t\t__jbd2_log_start_commit(journal, transaction->t_tid);\n\t} else if (journal->j_committing_transaction)\n\t\ttransaction = journal->j_committing_transaction;\n\n\t/* Wait for the log commit to complete... */\n\tif (transaction) {\n\t\ttid_t tid = transaction->t_tid;\n\n\t\twrite_unlock(&journal->j_state_lock);\n\t\tjbd2_log_wait_commit(journal, tid);\n\t} else {\n\t\twrite_unlock(&journal->j_state_lock);\n\t}\n\n\t/* ...and flush everything in the log out to disk. */\n\tspin_lock(&journal->j_list_lock);\n\twhile (!err && journal->j_checkpoint_transactions != NULL) {\n\t\tspin_unlock(&journal->j_list_lock);\n\t\tmutex_lock(&journal->j_checkpoint_mutex);\n\t\terr = jbd2_log_do_checkpoint(journal);\n\t\tmutex_unlock(&journal->j_checkpoint_mutex);\n\t\tspin_lock(&journal->j_list_lock);\n\t}\n\tspin_unlock(&journal->j_list_lock);\n\n\tif (is_journal_aborted(journal))\n\t\treturn -EIO;\n\n\tmutex_lock(&journal->j_checkpoint_mutex);\n\tjbd2_cleanup_journal_tail(journal);\n\n\t/* Finally, mark the journal as really needing no recovery.\n\t * This sets s_start==0 in the underlying superblock, which is\n\t * the magic code for a fully-recovered superblock.  Any future\n\t * commits of data to the journal will restore the current\n\t * s_start value. */\n\tjbd2_mark_journal_empty(journal);\n\tmutex_unlock(&journal->j_checkpoint_mutex);\n\twrite_lock(&journal->j_state_lock);\n\tJ_ASSERT(!journal->j_running_transaction);\n\tJ_ASSERT(!journal->j_committing_transaction);\n\tJ_ASSERT(!journal->j_checkpoint_transactions);\n\tJ_ASSERT(journal->j_head == journal->j_tail);\n\tJ_ASSERT(journal->j_tail_sequence == journal->j_transaction_sequence);\n\twrite_unlock(&journal->j_state_lock);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "jbd2_journal_lock_updates",
          "args": [
            "EXT4_SB(sb)->s_journal"
          ],
          "line": 5255
        },
        "resolved": true,
        "details": {
          "function_name": "jbd2_journal_lock_updates",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd2/transaction.c",
          "lines": "689-734",
          "snippet": "void jbd2_journal_lock_updates(journal_t *journal)\n{\n\tDEFINE_WAIT(wait);\n\n\twrite_lock(&journal->j_state_lock);\n\t++journal->j_barrier_count;\n\n\t/* Wait until there are no reserved handles */\n\tif (atomic_read(&journal->j_reserved_credits)) {\n\t\twrite_unlock(&journal->j_state_lock);\n\t\twait_event(journal->j_wait_reserved,\n\t\t\t   atomic_read(&journal->j_reserved_credits) == 0);\n\t\twrite_lock(&journal->j_state_lock);\n\t}\n\n\t/* Wait until there are no running updates */\n\twhile (1) {\n\t\ttransaction_t *transaction = journal->j_running_transaction;\n\n\t\tif (!transaction)\n\t\t\tbreak;\n\n\t\tspin_lock(&transaction->t_handle_lock);\n\t\tprepare_to_wait(&journal->j_wait_updates, &wait,\n\t\t\t\tTASK_UNINTERRUPTIBLE);\n\t\tif (!atomic_read(&transaction->t_updates)) {\n\t\t\tspin_unlock(&transaction->t_handle_lock);\n\t\t\tfinish_wait(&journal->j_wait_updates, &wait);\n\t\t\tbreak;\n\t\t}\n\t\tspin_unlock(&transaction->t_handle_lock);\n\t\twrite_unlock(&journal->j_state_lock);\n\t\tschedule();\n\t\tfinish_wait(&journal->j_wait_updates, &wait);\n\t\twrite_lock(&journal->j_state_lock);\n\t}\n\twrite_unlock(&journal->j_state_lock);\n\n\t/*\n\t * We have now established a barrier against other normal updates, but\n\t * we also need to barrier against other jbd2_journal_lock_updates() calls\n\t * to make sure that we serialise special journal-locked operations\n\t * too.\n\t */\n\tmutex_lock(&journal->j_barrier);\n}",
          "includes": [
            "#include <trace/events/jbd2.h>",
            "#include <linux/module.h>",
            "#include <linux/bug.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/timer.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/jbd2.h>\n#include <linux/module.h>\n#include <linux/bug.h>\n#include <linux/backing-dev.h>\n#include <linux/hrtimer.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/timer.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd2.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n\nvoid jbd2_journal_lock_updates(journal_t *journal)\n{\n\tDEFINE_WAIT(wait);\n\n\twrite_lock(&journal->j_state_lock);\n\t++journal->j_barrier_count;\n\n\t/* Wait until there are no reserved handles */\n\tif (atomic_read(&journal->j_reserved_credits)) {\n\t\twrite_unlock(&journal->j_state_lock);\n\t\twait_event(journal->j_wait_reserved,\n\t\t\t   atomic_read(&journal->j_reserved_credits) == 0);\n\t\twrite_lock(&journal->j_state_lock);\n\t}\n\n\t/* Wait until there are no running updates */\n\twhile (1) {\n\t\ttransaction_t *transaction = journal->j_running_transaction;\n\n\t\tif (!transaction)\n\t\t\tbreak;\n\n\t\tspin_lock(&transaction->t_handle_lock);\n\t\tprepare_to_wait(&journal->j_wait_updates, &wait,\n\t\t\t\tTASK_UNINTERRUPTIBLE);\n\t\tif (!atomic_read(&transaction->t_updates)) {\n\t\t\tspin_unlock(&transaction->t_handle_lock);\n\t\t\tfinish_wait(&journal->j_wait_updates, &wait);\n\t\t\tbreak;\n\t\t}\n\t\tspin_unlock(&transaction->t_handle_lock);\n\t\twrite_unlock(&journal->j_state_lock);\n\t\tschedule();\n\t\tfinish_wait(&journal->j_wait_updates, &wait);\n\t\twrite_lock(&journal->j_state_lock);\n\t}\n\twrite_unlock(&journal->j_state_lock);\n\n\t/*\n\t * We have now established a barrier against other normal updates, but\n\t * we also need to barrier against other jbd2_journal_lock_updates() calls\n\t * to make sure that we serialise special journal-locked operations\n\t * too.\n\t */\n\tmutex_lock(&journal->j_barrier);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_should_journal_data",
          "args": [
            "path->dentry->d_inode"
          ],
          "line": 5250
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_should_journal_data",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ext4_jbd2.h",
          "lines": "413-416",
          "snippet": "static inline int ext4_should_journal_data(struct inode *inode)\n{\n\treturn ext4_inode_journal_mode(inode) & EXT4_INODE_JOURNAL_DATA_MODE;\n}",
          "includes": [
            "#include \"ext4.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [
            "#define EXT4_INODE_JOURNAL_DATA_MODE\t0x01 /* journal data mode */"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ext4.h\"\n#include <linux/jbd2.h>\n#include <linux/fs.h>\n\n#define EXT4_INODE_JOURNAL_DATA_MODE\t0x01 /* journal data mode */\n\nstatic inline int ext4_should_journal_data(struct inode *inode)\n{\n\treturn ext4_inode_journal_mode(inode) & EXT4_INODE_JOURNAL_DATA_MODE;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_msg",
          "args": [
            "sb",
            "KERN_WARNING",
            "\"Quota file not on filesystem root. \"\n\t\t\t\t\"Journaled quota will not work\""
          ],
          "line": 5240
        },
        "resolved": true,
        "details": {
          "function_name": "__ext4_msg",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/super.c",
          "lines": "593-607",
          "snippet": "void __ext4_msg(struct super_block *sb,\n\t\tconst char *prefix, const char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tif (!___ratelimit(&(EXT4_SB(sb)->s_msg_ratelimit_state), \"EXT4-fs\"))\n\t\treturn;\n\n\tva_start(args, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\tprintk(\"%sEXT4-fs (%s): %pV\\n\", prefix, sb->s_id, &vaf);\n\tva_end(args);\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"mballoc.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include \"ext4_extents.h\"\t/* Needed for trace points definition */",
            "#include \"ext4.h\"",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/crc16.h>",
            "#include <linux/log2.h>",
            "#include <linux/ctype.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/random.h>",
            "#include <linux/vfs.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/parser.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/time.h>",
            "#include <linux/fs.h>",
            "#include <linux/string.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ext4_unfreeze(struct super_block *sb);",
            "static int ext4_freeze(struct super_block *sb);",
            "static inline int ext2_feature_set_ok(struct super_block *sb);",
            "static inline int ext3_feature_set_ok(struct super_block *sb);",
            "static void ext4_unregister_li_request(struct super_block *sb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"mballoc.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4_extents.h\"\t/* Needed for trace points definition */\n#include \"ext4.h\"\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <asm/uaccess.h>\n#include <linux/cleancache.h>\n#include <linux/crc16.h>\n#include <linux/log2.h>\n#include <linux/ctype.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/random.h>\n#include <linux/vfs.h>\n#include <linux/exportfs.h>\n#include <linux/buffer_head.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/jbd2.h>\n#include <linux/vmalloc.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n#include <linux/string.h>\n#include <linux/module.h>\n\nstatic int ext4_unfreeze(struct super_block *sb);\nstatic int ext4_freeze(struct super_block *sb);\nstatic inline int ext2_feature_set_ok(struct super_block *sb);\nstatic inline int ext3_feature_set_ok(struct super_block *sb);\nstatic void ext4_unregister_li_request(struct super_block *sb);\n\nvoid __ext4_msg(struct super_block *sb,\n\t\tconst char *prefix, const char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tif (!___ratelimit(&(EXT4_SB(sb)->s_msg_ratelimit_state), \"EXT4-fs\"))\n\t\treturn;\n\n\tva_start(args, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\tprintk(\"%sEXT4-fs (%s): %pV\\n\", prefix, sb->s_id, &vaf);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "test_opt",
          "args": [
            "sb",
            "QUOTA"
          ],
          "line": 5230
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"mballoc.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4_extents.h\"\t/* Needed for trace points definition */\n#include \"ext4.h\"\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <asm/uaccess.h>\n#include <linux/cleancache.h>\n#include <linux/crc16.h>\n#include <linux/log2.h>\n#include <linux/ctype.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/random.h>\n#include <linux/vfs.h>\n#include <linux/exportfs.h>\n#include <linux/buffer_head.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/jbd2.h>\n#include <linux/vmalloc.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n#include <linux/string.h>\n#include <linux/module.h>\n\nstatic int ext4_show_options(struct seq_file *seq, struct dentry *root);\nstatic int ext4_remount(struct super_block *sb, int *flags, char *data);\nstatic int ext4_unfreeze(struct super_block *sb);\nstatic int ext4_freeze(struct super_block *sb);\nstatic struct dentry *ext4_mount(struct file_system_type *fs_type, int flags,\n\t\t       const char *dev_name, void *data);\nstatic inline int ext2_feature_set_ok(struct super_block *sb);\nstatic inline int ext3_feature_set_ok(struct super_block *sb);\nstatic void ext4_unregister_li_request(struct super_block *sb);\n\nstatic int ext4_quota_on(struct super_block *sb, int type, int format_id,\n\t\t\t struct path *path)\n{\n\tint err;\n\n\tif (!test_opt(sb, QUOTA))\n\t\treturn -EINVAL;\n\n\t/* Quotafile not on the same filesystem? */\n\tif (path->dentry->d_sb != sb)\n\t\treturn -EXDEV;\n\t/* Journaling quota? */\n\tif (EXT4_SB(sb)->s_qf_names[type]) {\n\t\t/* Quotafile not in fs root? */\n\t\tif (path->dentry->d_parent != sb->s_root)\n\t\t\text4_msg(sb, KERN_WARNING,\n\t\t\t\t\"Quota file not on filesystem root. \"\n\t\t\t\t\"Journaled quota will not work\");\n\t}\n\n\t/*\n\t * When we journal data on quota file, we have to flush journal to see\n\t * all updates to the file when we bypass pagecache...\n\t */\n\tif (EXT4_SB(sb)->s_journal &&\n\t    ext4_should_journal_data(path->dentry->d_inode)) {\n\t\t/*\n\t\t * We don't need to lock updates but journal_flush() could\n\t\t * otherwise be livelocked...\n\t\t */\n\t\tjbd2_journal_lock_updates(EXT4_SB(sb)->s_journal);\n\t\terr = jbd2_journal_flush(EXT4_SB(sb)->s_journal);\n\t\tjbd2_journal_unlock_updates(EXT4_SB(sb)->s_journal);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\treturn dquot_quota_on(sb, type, format_id, path);\n}"
  },
  {
    "function_name": "ext4_quota_on_mount",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/super.c",
    "lines": "5216-5220",
    "snippet": "static int ext4_quota_on_mount(struct super_block *sb, int type)\n{\n\treturn dquot_quota_on_mount(sb, EXT4_SB(sb)->s_qf_names[type],\n\t\t\t\t\tEXT4_SB(sb)->s_jquota_fmt, type);\n}",
    "includes": [
      "#include <trace/events/ext4.h>",
      "#include \"mballoc.h\"",
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"ext4_jbd2.h\"",
      "#include \"ext4_extents.h\"\t/* Needed for trace points definition */",
      "#include \"ext4.h\"",
      "#include <linux/freezer.h>",
      "#include <linux/kthread.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/cleancache.h>",
      "#include <linux/crc16.h>",
      "#include <linux/log2.h>",
      "#include <linux/ctype.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/namei.h>",
      "#include <linux/mount.h>",
      "#include <linux/random.h>",
      "#include <linux/vfs.h>",
      "#include <linux/exportfs.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/parser.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/init.h>",
      "#include <linux/slab.h>",
      "#include <linux/jbd2.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/time.h>",
      "#include <linux/fs.h>",
      "#include <linux/string.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ext4_unfreeze(struct super_block *sb);",
      "static int ext4_freeze(struct super_block *sb);",
      "static inline int ext2_feature_set_ok(struct super_block *sb);",
      "static inline int ext3_feature_set_ok(struct super_block *sb);",
      "static void ext4_unregister_li_request(struct super_block *sb);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "dquot_quota_on_mount",
          "args": [
            "sb",
            "EXT4_SB(sb)->s_qf_names[type]",
            "EXT4_SB(sb)->s_jquota_fmt",
            "type"
          ],
          "line": 5218
        },
        "resolved": true,
        "details": {
          "function_name": "dquot_quota_on_mount",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/quota/dquot.c",
          "lines": "2360-2385",
          "snippet": "int dquot_quota_on_mount(struct super_block *sb, char *qf_name,\n\t\tint format_id, int type)\n{\n\tstruct dentry *dentry;\n\tint error;\n\n\tmutex_lock(&sb->s_root->d_inode->i_mutex);\n\tdentry = lookup_one_len(qf_name, sb->s_root, strlen(qf_name));\n\tmutex_unlock(&sb->s_root->d_inode->i_mutex);\n\tif (IS_ERR(dentry))\n\t\treturn PTR_ERR(dentry);\n\n\tif (!dentry->d_inode) {\n\t\terror = -ENOENT;\n\t\tgoto out;\n\t}\n\n\terror = security_quota_on(dentry);\n\tif (!error)\n\t\terror = vfs_load_quota_inode(dentry->d_inode, type, format_id,\n\t\t\t\tDQUOT_USAGE_ENABLED | DQUOT_LIMITS_ENABLED);\n\nout:\n\tdput(dentry);\n\treturn error;\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include \"../internal.h\" /* ugh */",
            "#include <linux/quotaops.h>",
            "#include <linux/capability.h>",
            "#include <linux/namei.h>",
            "#include <linux/kmod.h>",
            "#include <linux/sched.h>",
            "#include <linux/security.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>",
            "#include <linux/tty.h>",
            "#include <linux/stat.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/time.h>",
            "#include <linux/mm.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __dquot_initialize(struct inode *inode, int type);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include \"../internal.h\" /* ugh */\n#include <linux/quotaops.h>\n#include <linux/capability.h>\n#include <linux/namei.h>\n#include <linux/kmod.h>\n#include <linux/sched.h>\n#include <linux/security.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/sysctl.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/tty.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/time.h>\n#include <linux/mm.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/kernel.h>\n#include <linux/errno.h>\n\nstatic void __dquot_initialize(struct inode *inode, int type);\n\nint dquot_quota_on_mount(struct super_block *sb, char *qf_name,\n\t\tint format_id, int type)\n{\n\tstruct dentry *dentry;\n\tint error;\n\n\tmutex_lock(&sb->s_root->d_inode->i_mutex);\n\tdentry = lookup_one_len(qf_name, sb->s_root, strlen(qf_name));\n\tmutex_unlock(&sb->s_root->d_inode->i_mutex);\n\tif (IS_ERR(dentry))\n\t\treturn PTR_ERR(dentry);\n\n\tif (!dentry->d_inode) {\n\t\terror = -ENOENT;\n\t\tgoto out;\n\t}\n\n\terror = security_quota_on(dentry);\n\tif (!error)\n\t\terror = vfs_load_quota_inode(dentry->d_inode, type, format_id,\n\t\t\t\tDQUOT_USAGE_ENABLED | DQUOT_LIMITS_ENABLED);\n\nout:\n\tdput(dentry);\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "EXT4_SB",
          "args": [
            "sb"
          ],
          "line": 5219
        },
        "resolved": true,
        "details": {
          "function_name": "EXT4_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ext4.h",
          "lines": "1356-1359",
          "snippet": "static inline struct ext4_sb_info *EXT4_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include \"extents_status.h\"",
            "#include <linux/compat.h>",
            "#include <linux/falloc.h>",
            "#include <crypto/hash.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/wait.h>",
            "#include <linux/timer.h>",
            "#include <linux/mutex.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/quota.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extents_status.h\"\n#include <linux/compat.h>\n#include <linux/falloc.h>\n#include <crypto/hash.h>\n#include <linux/ratelimit.h>\n#include <linux/percpu_counter.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/wait.h>\n#include <linux/timer.h>\n#include <linux/mutex.h>\n#include <linux/seqlock.h>\n#include <linux/rbtree.h>\n#include <linux/rwsem.h>\n#include <linux/quota.h>\n#include <linux/jbd2.h>\n#include <linux/magic.h>\n#include <linux/blkdev.h>\n#include <linux/types.h>\n\nstatic inline struct ext4_sb_info *EXT4_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"mballoc.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4_extents.h\"\t/* Needed for trace points definition */\n#include \"ext4.h\"\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <asm/uaccess.h>\n#include <linux/cleancache.h>\n#include <linux/crc16.h>\n#include <linux/log2.h>\n#include <linux/ctype.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/random.h>\n#include <linux/vfs.h>\n#include <linux/exportfs.h>\n#include <linux/buffer_head.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/jbd2.h>\n#include <linux/vmalloc.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n#include <linux/string.h>\n#include <linux/module.h>\n\nstatic int ext4_unfreeze(struct super_block *sb);\nstatic int ext4_freeze(struct super_block *sb);\nstatic inline int ext2_feature_set_ok(struct super_block *sb);\nstatic inline int ext3_feature_set_ok(struct super_block *sb);\nstatic void ext4_unregister_li_request(struct super_block *sb);\n\nstatic int ext4_quota_on_mount(struct super_block *sb, int type)\n{\n\treturn dquot_quota_on_mount(sb, EXT4_SB(sb)->s_qf_names[type],\n\t\t\t\t\tEXT4_SB(sb)->s_jquota_fmt, type);\n}"
  },
  {
    "function_name": "ext4_write_info",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/super.c",
    "lines": "5196-5210",
    "snippet": "static int ext4_write_info(struct super_block *sb, int type)\n{\n\tint ret, err;\n\thandle_t *handle;\n\n\t/* Data block + inode block */\n\thandle = ext4_journal_start(sb->s_root->d_inode, EXT4_HT_QUOTA, 2);\n\tif (IS_ERR(handle))\n\t\treturn PTR_ERR(handle);\n\tret = dquot_commit_info(sb, type);\n\terr = ext4_journal_stop(handle);\n\tif (!ret)\n\t\tret = err;\n\treturn ret;\n}",
    "includes": [
      "#include <trace/events/ext4.h>",
      "#include \"mballoc.h\"",
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"ext4_jbd2.h\"",
      "#include \"ext4_extents.h\"\t/* Needed for trace points definition */",
      "#include \"ext4.h\"",
      "#include <linux/freezer.h>",
      "#include <linux/kthread.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/cleancache.h>",
      "#include <linux/crc16.h>",
      "#include <linux/log2.h>",
      "#include <linux/ctype.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/namei.h>",
      "#include <linux/mount.h>",
      "#include <linux/random.h>",
      "#include <linux/vfs.h>",
      "#include <linux/exportfs.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/parser.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/init.h>",
      "#include <linux/slab.h>",
      "#include <linux/jbd2.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/time.h>",
      "#include <linux/fs.h>",
      "#include <linux/string.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ext4_unfreeze(struct super_block *sb);",
      "static int ext4_freeze(struct super_block *sb);",
      "static inline int ext2_feature_set_ok(struct super_block *sb);",
      "static inline int ext3_feature_set_ok(struct super_block *sb);",
      "static void ext4_unregister_li_request(struct super_block *sb);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ext4_journal_stop",
          "args": [
            "handle"
          ],
          "line": 5206
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dquot_commit_info",
          "args": [
            "sb",
            "type"
          ],
          "line": 5205
        },
        "resolved": true,
        "details": {
          "function_name": "dquot_commit_info",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/quota/dquot.c",
          "lines": "1956-1965",
          "snippet": "int dquot_commit_info(struct super_block *sb, int type)\n{\n\tint ret;\n\tstruct quota_info *dqopt = sb_dqopt(sb);\n\n\tmutex_lock(&dqopt->dqio_mutex);\n\tret = dqopt->ops[type]->write_file_info(sb, type);\n\tmutex_unlock(&dqopt->dqio_mutex);\n\treturn ret;\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include \"../internal.h\" /* ugh */",
            "#include <linux/quotaops.h>",
            "#include <linux/capability.h>",
            "#include <linux/namei.h>",
            "#include <linux/kmod.h>",
            "#include <linux/sched.h>",
            "#include <linux/security.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>",
            "#include <linux/tty.h>",
            "#include <linux/stat.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/time.h>",
            "#include <linux/mm.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __dquot_initialize(struct inode *inode, int type);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include \"../internal.h\" /* ugh */\n#include <linux/quotaops.h>\n#include <linux/capability.h>\n#include <linux/namei.h>\n#include <linux/kmod.h>\n#include <linux/sched.h>\n#include <linux/security.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/sysctl.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/tty.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/time.h>\n#include <linux/mm.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/kernel.h>\n#include <linux/errno.h>\n\nstatic void __dquot_initialize(struct inode *inode, int type);\n\nint dquot_commit_info(struct super_block *sb, int type)\n{\n\tint ret;\n\tstruct quota_info *dqopt = sb_dqopt(sb);\n\n\tmutex_lock(&dqopt->dqio_mutex);\n\tret = dqopt->ops[type]->write_file_info(sb, type);\n\tmutex_unlock(&dqopt->dqio_mutex);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "handle"
          ],
          "line": 5204
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "handle"
          ],
          "line": 5203
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_journal_start",
          "args": [
            "sb->s_root->d_inode",
            "EXT4_HT_QUOTA",
            "2"
          ],
          "line": 5202
        },
        "resolved": true,
        "details": {
          "function_name": "__ext4_journal_start_reserved",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ext4_jbd2.c",
          "lines": "101-123",
          "snippet": "handle_t *__ext4_journal_start_reserved(handle_t *handle, unsigned int line,\n\t\t\t\t\tint type)\n{\n\tstruct super_block *sb;\n\tint err;\n\n\tif (!ext4_handle_valid(handle))\n\t\treturn ext4_get_nojournal();\n\n\tsb = handle->h_journal->j_private;\n\ttrace_ext4_journal_start_reserved(sb, handle->h_buffer_credits,\n\t\t\t\t\t  _RET_IP_);\n\terr = ext4_journal_check_start(sb);\n\tif (err < 0) {\n\t\tjbd2_journal_free_reserved(handle);\n\t\treturn ERR_PTR(err);\n\t}\n\n\terr = jbd2_journal_start_reserved(handle, type, line);\n\tif (err < 0)\n\t\treturn ERR_PTR(err);\n\treturn handle;\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"ext4_jbd2.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"ext4_jbd2.h\"\n\nhandle_t *__ext4_journal_start_reserved(handle_t *handle, unsigned int line,\n\t\t\t\t\tint type)\n{\n\tstruct super_block *sb;\n\tint err;\n\n\tif (!ext4_handle_valid(handle))\n\t\treturn ext4_get_nojournal();\n\n\tsb = handle->h_journal->j_private;\n\ttrace_ext4_journal_start_reserved(sb, handle->h_buffer_credits,\n\t\t\t\t\t  _RET_IP_);\n\terr = ext4_journal_check_start(sb);\n\tif (err < 0) {\n\t\tjbd2_journal_free_reserved(handle);\n\t\treturn ERR_PTR(err);\n\t}\n\n\terr = jbd2_journal_start_reserved(handle, type, line);\n\tif (err < 0)\n\t\treturn ERR_PTR(err);\n\treturn handle;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"mballoc.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4_extents.h\"\t/* Needed for trace points definition */\n#include \"ext4.h\"\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <asm/uaccess.h>\n#include <linux/cleancache.h>\n#include <linux/crc16.h>\n#include <linux/log2.h>\n#include <linux/ctype.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/random.h>\n#include <linux/vfs.h>\n#include <linux/exportfs.h>\n#include <linux/buffer_head.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/jbd2.h>\n#include <linux/vmalloc.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n#include <linux/string.h>\n#include <linux/module.h>\n\nstatic int ext4_unfreeze(struct super_block *sb);\nstatic int ext4_freeze(struct super_block *sb);\nstatic inline int ext2_feature_set_ok(struct super_block *sb);\nstatic inline int ext3_feature_set_ok(struct super_block *sb);\nstatic void ext4_unregister_li_request(struct super_block *sb);\n\nstatic int ext4_write_info(struct super_block *sb, int type)\n{\n\tint ret, err;\n\thandle_t *handle;\n\n\t/* Data block + inode block */\n\thandle = ext4_journal_start(sb->s_root->d_inode, EXT4_HT_QUOTA, 2);\n\tif (IS_ERR(handle))\n\t\treturn PTR_ERR(handle);\n\tret = dquot_commit_info(sb, type);\n\terr = ext4_journal_stop(handle);\n\tif (!ret)\n\t\tret = err;\n\treturn ret;\n}"
  },
  {
    "function_name": "ext4_mark_dquot_dirty",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/super.c",
    "lines": "5181-5194",
    "snippet": "static int ext4_mark_dquot_dirty(struct dquot *dquot)\n{\n\tstruct super_block *sb = dquot->dq_sb;\n\tstruct ext4_sb_info *sbi = EXT4_SB(sb);\n\n\t/* Are we journaling quotas? */\n\tif (EXT4_HAS_RO_COMPAT_FEATURE(sb, EXT4_FEATURE_RO_COMPAT_QUOTA) ||\n\t    sbi->s_qf_names[USRQUOTA] || sbi->s_qf_names[GRPQUOTA]) {\n\t\tdquot_mark_dquot_dirty(dquot);\n\t\treturn ext4_write_dquot(dquot);\n\t} else {\n\t\treturn dquot_mark_dquot_dirty(dquot);\n\t}\n}",
    "includes": [
      "#include <trace/events/ext4.h>",
      "#include \"mballoc.h\"",
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"ext4_jbd2.h\"",
      "#include \"ext4_extents.h\"\t/* Needed for trace points definition */",
      "#include \"ext4.h\"",
      "#include <linux/freezer.h>",
      "#include <linux/kthread.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/cleancache.h>",
      "#include <linux/crc16.h>",
      "#include <linux/log2.h>",
      "#include <linux/ctype.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/namei.h>",
      "#include <linux/mount.h>",
      "#include <linux/random.h>",
      "#include <linux/vfs.h>",
      "#include <linux/exportfs.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/parser.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/init.h>",
      "#include <linux/slab.h>",
      "#include <linux/jbd2.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/time.h>",
      "#include <linux/fs.h>",
      "#include <linux/string.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ext4_unfreeze(struct super_block *sb);",
      "static int ext4_freeze(struct super_block *sb);",
      "static inline int ext2_feature_set_ok(struct super_block *sb);",
      "static inline int ext3_feature_set_ok(struct super_block *sb);",
      "static void ext4_unregister_li_request(struct super_block *sb);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "dquot_mark_dquot_dirty",
          "args": [
            "dquot"
          ],
          "line": 5192
        },
        "resolved": true,
        "details": {
          "function_name": "dquot_mark_dquot_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/quota/dquot.c",
          "lines": "341-357",
          "snippet": "int dquot_mark_dquot_dirty(struct dquot *dquot)\n{\n\tint ret = 1;\n\n\t/* If quota is dirty already, we don't have to acquire dq_list_lock */\n\tif (test_bit(DQ_MOD_B, &dquot->dq_flags))\n\t\treturn 1;\n\n\tspin_lock(&dq_list_lock);\n\tif (!test_and_set_bit(DQ_MOD_B, &dquot->dq_flags)) {\n\t\tlist_add(&dquot->dq_dirty, &sb_dqopt(dquot->dq_sb)->\n\t\t\t\tinfo[dquot->dq_id.type].dqi_dirty_list);\n\t\tret = 0;\n\t}\n\tspin_unlock(&dq_list_lock);\n\treturn ret;\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include \"../internal.h\" /* ugh */",
            "#include <linux/quotaops.h>",
            "#include <linux/capability.h>",
            "#include <linux/namei.h>",
            "#include <linux/kmod.h>",
            "#include <linux/sched.h>",
            "#include <linux/security.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>",
            "#include <linux/tty.h>",
            "#include <linux/stat.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/time.h>",
            "#include <linux/mm.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __cacheline_aligned_in_smp DEFINE_SPINLOCK(dq_list_lock);",
            "static void __dquot_initialize(struct inode *inode, int type);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include \"../internal.h\" /* ugh */\n#include <linux/quotaops.h>\n#include <linux/capability.h>\n#include <linux/namei.h>\n#include <linux/kmod.h>\n#include <linux/sched.h>\n#include <linux/security.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/sysctl.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/tty.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/time.h>\n#include <linux/mm.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/kernel.h>\n#include <linux/errno.h>\n\nstatic __cacheline_aligned_in_smp DEFINE_SPINLOCK(dq_list_lock);\nstatic void __dquot_initialize(struct inode *inode, int type);\n\nint dquot_mark_dquot_dirty(struct dquot *dquot)\n{\n\tint ret = 1;\n\n\t/* If quota is dirty already, we don't have to acquire dq_list_lock */\n\tif (test_bit(DQ_MOD_B, &dquot->dq_flags))\n\t\treturn 1;\n\n\tspin_lock(&dq_list_lock);\n\tif (!test_and_set_bit(DQ_MOD_B, &dquot->dq_flags)) {\n\t\tlist_add(&dquot->dq_dirty, &sb_dqopt(dquot->dq_sb)->\n\t\t\t\tinfo[dquot->dq_id.type].dqi_dirty_list);\n\t\tret = 0;\n\t}\n\tspin_unlock(&dq_list_lock);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_write_dquot",
          "args": [
            "dquot"
          ],
          "line": 5190
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_write_dquot",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/super.c",
          "lines": "5128-5144",
          "snippet": "static int ext4_write_dquot(struct dquot *dquot)\n{\n\tint ret, err;\n\thandle_t *handle;\n\tstruct inode *inode;\n\n\tinode = dquot_to_inode(dquot);\n\thandle = ext4_journal_start(inode, EXT4_HT_QUOTA,\n\t\t\t\t    EXT4_QUOTA_TRANS_BLOCKS(dquot->dq_sb));\n\tif (IS_ERR(handle))\n\t\treturn PTR_ERR(handle);\n\tret = dquot_commit(dquot);\n\terr = ext4_journal_stop(handle);\n\tif (!ret)\n\t\tret = err;\n\treturn ret;\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"mballoc.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include \"ext4_extents.h\"\t/* Needed for trace points definition */",
            "#include \"ext4.h\"",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/crc16.h>",
            "#include <linux/log2.h>",
            "#include <linux/ctype.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/random.h>",
            "#include <linux/vfs.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/parser.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/time.h>",
            "#include <linux/fs.h>",
            "#include <linux/string.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"mballoc.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4_extents.h\"\t/* Needed for trace points definition */\n#include \"ext4.h\"\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <asm/uaccess.h>\n#include <linux/cleancache.h>\n#include <linux/crc16.h>\n#include <linux/log2.h>\n#include <linux/ctype.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/random.h>\n#include <linux/vfs.h>\n#include <linux/exportfs.h>\n#include <linux/buffer_head.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/jbd2.h>\n#include <linux/vmalloc.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n#include <linux/string.h>\n#include <linux/module.h>\n\nstatic int ext4_write_dquot(struct dquot *dquot)\n{\n\tint ret, err;\n\thandle_t *handle;\n\tstruct inode *inode;\n\n\tinode = dquot_to_inode(dquot);\n\thandle = ext4_journal_start(inode, EXT4_HT_QUOTA,\n\t\t\t\t    EXT4_QUOTA_TRANS_BLOCKS(dquot->dq_sb));\n\tif (IS_ERR(handle))\n\t\treturn PTR_ERR(handle);\n\tret = dquot_commit(dquot);\n\terr = ext4_journal_stop(handle);\n\tif (!ret)\n\t\tret = err;\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "EXT4_HAS_RO_COMPAT_FEATURE",
          "args": [
            "sb",
            "EXT4_FEATURE_RO_COMPAT_QUOTA"
          ],
          "line": 5187
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXT4_SB",
          "args": [
            "sb"
          ],
          "line": 5184
        },
        "resolved": true,
        "details": {
          "function_name": "EXT4_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ext4.h",
          "lines": "1356-1359",
          "snippet": "static inline struct ext4_sb_info *EXT4_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include \"extents_status.h\"",
            "#include <linux/compat.h>",
            "#include <linux/falloc.h>",
            "#include <crypto/hash.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/wait.h>",
            "#include <linux/timer.h>",
            "#include <linux/mutex.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/quota.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extents_status.h\"\n#include <linux/compat.h>\n#include <linux/falloc.h>\n#include <crypto/hash.h>\n#include <linux/ratelimit.h>\n#include <linux/percpu_counter.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/wait.h>\n#include <linux/timer.h>\n#include <linux/mutex.h>\n#include <linux/seqlock.h>\n#include <linux/rbtree.h>\n#include <linux/rwsem.h>\n#include <linux/quota.h>\n#include <linux/jbd2.h>\n#include <linux/magic.h>\n#include <linux/blkdev.h>\n#include <linux/types.h>\n\nstatic inline struct ext4_sb_info *EXT4_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"mballoc.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4_extents.h\"\t/* Needed for trace points definition */\n#include \"ext4.h\"\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <asm/uaccess.h>\n#include <linux/cleancache.h>\n#include <linux/crc16.h>\n#include <linux/log2.h>\n#include <linux/ctype.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/random.h>\n#include <linux/vfs.h>\n#include <linux/exportfs.h>\n#include <linux/buffer_head.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/jbd2.h>\n#include <linux/vmalloc.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n#include <linux/string.h>\n#include <linux/module.h>\n\nstatic int ext4_unfreeze(struct super_block *sb);\nstatic int ext4_freeze(struct super_block *sb);\nstatic inline int ext2_feature_set_ok(struct super_block *sb);\nstatic inline int ext3_feature_set_ok(struct super_block *sb);\nstatic void ext4_unregister_li_request(struct super_block *sb);\n\nstatic int ext4_mark_dquot_dirty(struct dquot *dquot)\n{\n\tstruct super_block *sb = dquot->dq_sb;\n\tstruct ext4_sb_info *sbi = EXT4_SB(sb);\n\n\t/* Are we journaling quotas? */\n\tif (EXT4_HAS_RO_COMPAT_FEATURE(sb, EXT4_FEATURE_RO_COMPAT_QUOTA) ||\n\t    sbi->s_qf_names[USRQUOTA] || sbi->s_qf_names[GRPQUOTA]) {\n\t\tdquot_mark_dquot_dirty(dquot);\n\t\treturn ext4_write_dquot(dquot);\n\t} else {\n\t\treturn dquot_mark_dquot_dirty(dquot);\n\t}\n}"
  },
  {
    "function_name": "ext4_release_dquot",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/super.c",
    "lines": "5162-5179",
    "snippet": "static int ext4_release_dquot(struct dquot *dquot)\n{\n\tint ret, err;\n\thandle_t *handle;\n\n\thandle = ext4_journal_start(dquot_to_inode(dquot), EXT4_HT_QUOTA,\n\t\t\t\t    EXT4_QUOTA_DEL_BLOCKS(dquot->dq_sb));\n\tif (IS_ERR(handle)) {\n\t\t/* Release dquot anyway to avoid endless cycle in dqput() */\n\t\tdquot_release(dquot);\n\t\treturn PTR_ERR(handle);\n\t}\n\tret = dquot_release(dquot);\n\terr = ext4_journal_stop(handle);\n\tif (!ret)\n\t\tret = err;\n\treturn ret;\n}",
    "includes": [
      "#include <trace/events/ext4.h>",
      "#include \"mballoc.h\"",
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"ext4_jbd2.h\"",
      "#include \"ext4_extents.h\"\t/* Needed for trace points definition */",
      "#include \"ext4.h\"",
      "#include <linux/freezer.h>",
      "#include <linux/kthread.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/cleancache.h>",
      "#include <linux/crc16.h>",
      "#include <linux/log2.h>",
      "#include <linux/ctype.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/namei.h>",
      "#include <linux/mount.h>",
      "#include <linux/random.h>",
      "#include <linux/vfs.h>",
      "#include <linux/exportfs.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/parser.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/init.h>",
      "#include <linux/slab.h>",
      "#include <linux/jbd2.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/time.h>",
      "#include <linux/fs.h>",
      "#include <linux/string.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ext4_journal_stop",
          "args": [
            "handle"
          ],
          "line": 5175
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dquot_release",
          "args": [
            "dquot"
          ],
          "line": 5174
        },
        "resolved": true,
        "details": {
          "function_name": "dquot_release",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/quota/dquot.c",
          "lines": "468-493",
          "snippet": "int dquot_release(struct dquot *dquot)\n{\n\tint ret = 0, ret2 = 0;\n\tstruct quota_info *dqopt = sb_dqopt(dquot->dq_sb);\n\n\tmutex_lock(&dquot->dq_lock);\n\t/* Check whether we are not racing with some other dqget() */\n\tif (atomic_read(&dquot->dq_count) > 1)\n\t\tgoto out_dqlock;\n\tmutex_lock(&dqopt->dqio_mutex);\n\tif (dqopt->ops[dquot->dq_id.type]->release_dqblk) {\n\t\tret = dqopt->ops[dquot->dq_id.type]->release_dqblk(dquot);\n\t\t/* Write the info */\n\t\tif (info_dirty(&dqopt->info[dquot->dq_id.type])) {\n\t\t\tret2 = dqopt->ops[dquot->dq_id.type]->write_file_info(\n\t\t\t\t\t\tdquot->dq_sb, dquot->dq_id.type);\n\t\t}\n\t\tif (ret >= 0)\n\t\t\tret = ret2;\n\t}\n\tclear_bit(DQ_ACTIVE_B, &dquot->dq_flags);\n\tmutex_unlock(&dqopt->dqio_mutex);\nout_dqlock:\n\tmutex_unlock(&dquot->dq_lock);\n\treturn ret;\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include \"../internal.h\" /* ugh */",
            "#include <linux/quotaops.h>",
            "#include <linux/capability.h>",
            "#include <linux/namei.h>",
            "#include <linux/kmod.h>",
            "#include <linux/sched.h>",
            "#include <linux/security.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>",
            "#include <linux/tty.h>",
            "#include <linux/stat.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/time.h>",
            "#include <linux/mm.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __dquot_initialize(struct inode *inode, int type);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include \"../internal.h\" /* ugh */\n#include <linux/quotaops.h>\n#include <linux/capability.h>\n#include <linux/namei.h>\n#include <linux/kmod.h>\n#include <linux/sched.h>\n#include <linux/security.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/sysctl.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/tty.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/time.h>\n#include <linux/mm.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/kernel.h>\n#include <linux/errno.h>\n\nstatic void __dquot_initialize(struct inode *inode, int type);\n\nint dquot_release(struct dquot *dquot)\n{\n\tint ret = 0, ret2 = 0;\n\tstruct quota_info *dqopt = sb_dqopt(dquot->dq_sb);\n\n\tmutex_lock(&dquot->dq_lock);\n\t/* Check whether we are not racing with some other dqget() */\n\tif (atomic_read(&dquot->dq_count) > 1)\n\t\tgoto out_dqlock;\n\tmutex_lock(&dqopt->dqio_mutex);\n\tif (dqopt->ops[dquot->dq_id.type]->release_dqblk) {\n\t\tret = dqopt->ops[dquot->dq_id.type]->release_dqblk(dquot);\n\t\t/* Write the info */\n\t\tif (info_dirty(&dqopt->info[dquot->dq_id.type])) {\n\t\t\tret2 = dqopt->ops[dquot->dq_id.type]->write_file_info(\n\t\t\t\t\t\tdquot->dq_sb, dquot->dq_id.type);\n\t\t}\n\t\tif (ret >= 0)\n\t\t\tret = ret2;\n\t}\n\tclear_bit(DQ_ACTIVE_B, &dquot->dq_flags);\n\tmutex_unlock(&dqopt->dqio_mutex);\nout_dqlock:\n\tmutex_unlock(&dquot->dq_lock);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "handle"
          ],
          "line": 5172
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "handle"
          ],
          "line": 5169
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_journal_start",
          "args": [
            "dquot_to_inode(dquot)",
            "EXT4_HT_QUOTA",
            "EXT4_QUOTA_DEL_BLOCKS(dquot->dq_sb)"
          ],
          "line": 5167
        },
        "resolved": true,
        "details": {
          "function_name": "__ext4_journal_start_reserved",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ext4_jbd2.c",
          "lines": "101-123",
          "snippet": "handle_t *__ext4_journal_start_reserved(handle_t *handle, unsigned int line,\n\t\t\t\t\tint type)\n{\n\tstruct super_block *sb;\n\tint err;\n\n\tif (!ext4_handle_valid(handle))\n\t\treturn ext4_get_nojournal();\n\n\tsb = handle->h_journal->j_private;\n\ttrace_ext4_journal_start_reserved(sb, handle->h_buffer_credits,\n\t\t\t\t\t  _RET_IP_);\n\terr = ext4_journal_check_start(sb);\n\tif (err < 0) {\n\t\tjbd2_journal_free_reserved(handle);\n\t\treturn ERR_PTR(err);\n\t}\n\n\terr = jbd2_journal_start_reserved(handle, type, line);\n\tif (err < 0)\n\t\treturn ERR_PTR(err);\n\treturn handle;\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"ext4_jbd2.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"ext4_jbd2.h\"\n\nhandle_t *__ext4_journal_start_reserved(handle_t *handle, unsigned int line,\n\t\t\t\t\tint type)\n{\n\tstruct super_block *sb;\n\tint err;\n\n\tif (!ext4_handle_valid(handle))\n\t\treturn ext4_get_nojournal();\n\n\tsb = handle->h_journal->j_private;\n\ttrace_ext4_journal_start_reserved(sb, handle->h_buffer_credits,\n\t\t\t\t\t  _RET_IP_);\n\terr = ext4_journal_check_start(sb);\n\tif (err < 0) {\n\t\tjbd2_journal_free_reserved(handle);\n\t\treturn ERR_PTR(err);\n\t}\n\n\terr = jbd2_journal_start_reserved(handle, type, line);\n\tif (err < 0)\n\t\treturn ERR_PTR(err);\n\treturn handle;\n}"
        }
      },
      {
        "call_info": {
          "callee": "EXT4_QUOTA_DEL_BLOCKS",
          "args": [
            "dquot->dq_sb"
          ],
          "line": 5168
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dquot_to_inode",
          "args": [
            "dquot"
          ],
          "line": 5167
        },
        "resolved": true,
        "details": {
          "function_name": "dquot_to_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/super.c",
          "lines": "5123-5126",
          "snippet": "static inline struct inode *dquot_to_inode(struct dquot *dquot)\n{\n\treturn sb_dqopt(dquot->dq_sb)->files[dquot->dq_id.type];\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"mballoc.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include \"ext4_extents.h\"\t/* Needed for trace points definition */",
            "#include \"ext4.h\"",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/crc16.h>",
            "#include <linux/log2.h>",
            "#include <linux/ctype.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/random.h>",
            "#include <linux/vfs.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/parser.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/time.h>",
            "#include <linux/fs.h>",
            "#include <linux/string.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"mballoc.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4_extents.h\"\t/* Needed for trace points definition */\n#include \"ext4.h\"\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <asm/uaccess.h>\n#include <linux/cleancache.h>\n#include <linux/crc16.h>\n#include <linux/log2.h>\n#include <linux/ctype.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/random.h>\n#include <linux/vfs.h>\n#include <linux/exportfs.h>\n#include <linux/buffer_head.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/jbd2.h>\n#include <linux/vmalloc.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n#include <linux/string.h>\n#include <linux/module.h>\n\nstatic inline struct inode *dquot_to_inode(struct dquot *dquot)\n{\n\treturn sb_dqopt(dquot->dq_sb)->files[dquot->dq_id.type];\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"mballoc.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4_extents.h\"\t/* Needed for trace points definition */\n#include \"ext4.h\"\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <asm/uaccess.h>\n#include <linux/cleancache.h>\n#include <linux/crc16.h>\n#include <linux/log2.h>\n#include <linux/ctype.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/random.h>\n#include <linux/vfs.h>\n#include <linux/exportfs.h>\n#include <linux/buffer_head.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/jbd2.h>\n#include <linux/vmalloc.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n#include <linux/string.h>\n#include <linux/module.h>\n\nstatic int ext4_release_dquot(struct dquot *dquot)\n{\n\tint ret, err;\n\thandle_t *handle;\n\n\thandle = ext4_journal_start(dquot_to_inode(dquot), EXT4_HT_QUOTA,\n\t\t\t\t    EXT4_QUOTA_DEL_BLOCKS(dquot->dq_sb));\n\tif (IS_ERR(handle)) {\n\t\t/* Release dquot anyway to avoid endless cycle in dqput() */\n\t\tdquot_release(dquot);\n\t\treturn PTR_ERR(handle);\n\t}\n\tret = dquot_release(dquot);\n\terr = ext4_journal_stop(handle);\n\tif (!ret)\n\t\tret = err;\n\treturn ret;\n}"
  },
  {
    "function_name": "ext4_acquire_dquot",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/super.c",
    "lines": "5146-5160",
    "snippet": "static int ext4_acquire_dquot(struct dquot *dquot)\n{\n\tint ret, err;\n\thandle_t *handle;\n\n\thandle = ext4_journal_start(dquot_to_inode(dquot), EXT4_HT_QUOTA,\n\t\t\t\t    EXT4_QUOTA_INIT_BLOCKS(dquot->dq_sb));\n\tif (IS_ERR(handle))\n\t\treturn PTR_ERR(handle);\n\tret = dquot_acquire(dquot);\n\terr = ext4_journal_stop(handle);\n\tif (!ret)\n\t\tret = err;\n\treturn ret;\n}",
    "includes": [
      "#include <trace/events/ext4.h>",
      "#include \"mballoc.h\"",
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"ext4_jbd2.h\"",
      "#include \"ext4_extents.h\"\t/* Needed for trace points definition */",
      "#include \"ext4.h\"",
      "#include <linux/freezer.h>",
      "#include <linux/kthread.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/cleancache.h>",
      "#include <linux/crc16.h>",
      "#include <linux/log2.h>",
      "#include <linux/ctype.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/namei.h>",
      "#include <linux/mount.h>",
      "#include <linux/random.h>",
      "#include <linux/vfs.h>",
      "#include <linux/exportfs.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/parser.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/init.h>",
      "#include <linux/slab.h>",
      "#include <linux/jbd2.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/time.h>",
      "#include <linux/fs.h>",
      "#include <linux/string.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ext4_journal_stop",
          "args": [
            "handle"
          ],
          "line": 5156
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dquot_acquire",
          "args": [
            "dquot"
          ],
          "line": 5155
        },
        "resolved": true,
        "details": {
          "function_name": "dquot_acquire",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/quota/dquot.c",
          "lines": "403-435",
          "snippet": "int dquot_acquire(struct dquot *dquot)\n{\n\tint ret = 0, ret2 = 0;\n\tstruct quota_info *dqopt = sb_dqopt(dquot->dq_sb);\n\n\tmutex_lock(&dquot->dq_lock);\n\tmutex_lock(&dqopt->dqio_mutex);\n\tif (!test_bit(DQ_READ_B, &dquot->dq_flags))\n\t\tret = dqopt->ops[dquot->dq_id.type]->read_dqblk(dquot);\n\tif (ret < 0)\n\t\tgoto out_iolock;\n\tset_bit(DQ_READ_B, &dquot->dq_flags);\n\t/* Instantiate dquot if needed */\n\tif (!test_bit(DQ_ACTIVE_B, &dquot->dq_flags) && !dquot->dq_off) {\n\t\tret = dqopt->ops[dquot->dq_id.type]->commit_dqblk(dquot);\n\t\t/* Write the info if needed */\n\t\tif (info_dirty(&dqopt->info[dquot->dq_id.type])) {\n\t\t\tret2 = dqopt->ops[dquot->dq_id.type]->write_file_info(\n\t\t\t\t\tdquot->dq_sb, dquot->dq_id.type);\n\t\t}\n\t\tif (ret < 0)\n\t\t\tgoto out_iolock;\n\t\tif (ret2 < 0) {\n\t\t\tret = ret2;\n\t\t\tgoto out_iolock;\n\t\t}\n\t}\n\tset_bit(DQ_ACTIVE_B, &dquot->dq_flags);\nout_iolock:\n\tmutex_unlock(&dqopt->dqio_mutex);\n\tmutex_unlock(&dquot->dq_lock);\n\treturn ret;\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include \"../internal.h\" /* ugh */",
            "#include <linux/quotaops.h>",
            "#include <linux/capability.h>",
            "#include <linux/namei.h>",
            "#include <linux/kmod.h>",
            "#include <linux/sched.h>",
            "#include <linux/security.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>",
            "#include <linux/tty.h>",
            "#include <linux/stat.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/time.h>",
            "#include <linux/mm.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __dquot_initialize(struct inode *inode, int type);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include \"../internal.h\" /* ugh */\n#include <linux/quotaops.h>\n#include <linux/capability.h>\n#include <linux/namei.h>\n#include <linux/kmod.h>\n#include <linux/sched.h>\n#include <linux/security.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/sysctl.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/tty.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/time.h>\n#include <linux/mm.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/kernel.h>\n#include <linux/errno.h>\n\nstatic void __dquot_initialize(struct inode *inode, int type);\n\nint dquot_acquire(struct dquot *dquot)\n{\n\tint ret = 0, ret2 = 0;\n\tstruct quota_info *dqopt = sb_dqopt(dquot->dq_sb);\n\n\tmutex_lock(&dquot->dq_lock);\n\tmutex_lock(&dqopt->dqio_mutex);\n\tif (!test_bit(DQ_READ_B, &dquot->dq_flags))\n\t\tret = dqopt->ops[dquot->dq_id.type]->read_dqblk(dquot);\n\tif (ret < 0)\n\t\tgoto out_iolock;\n\tset_bit(DQ_READ_B, &dquot->dq_flags);\n\t/* Instantiate dquot if needed */\n\tif (!test_bit(DQ_ACTIVE_B, &dquot->dq_flags) && !dquot->dq_off) {\n\t\tret = dqopt->ops[dquot->dq_id.type]->commit_dqblk(dquot);\n\t\t/* Write the info if needed */\n\t\tif (info_dirty(&dqopt->info[dquot->dq_id.type])) {\n\t\t\tret2 = dqopt->ops[dquot->dq_id.type]->write_file_info(\n\t\t\t\t\tdquot->dq_sb, dquot->dq_id.type);\n\t\t}\n\t\tif (ret < 0)\n\t\t\tgoto out_iolock;\n\t\tif (ret2 < 0) {\n\t\t\tret = ret2;\n\t\t\tgoto out_iolock;\n\t\t}\n\t}\n\tset_bit(DQ_ACTIVE_B, &dquot->dq_flags);\nout_iolock:\n\tmutex_unlock(&dqopt->dqio_mutex);\n\tmutex_unlock(&dquot->dq_lock);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "handle"
          ],
          "line": 5154
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "handle"
          ],
          "line": 5153
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_journal_start",
          "args": [
            "dquot_to_inode(dquot)",
            "EXT4_HT_QUOTA",
            "EXT4_QUOTA_INIT_BLOCKS(dquot->dq_sb)"
          ],
          "line": 5151
        },
        "resolved": true,
        "details": {
          "function_name": "__ext4_journal_start_reserved",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ext4_jbd2.c",
          "lines": "101-123",
          "snippet": "handle_t *__ext4_journal_start_reserved(handle_t *handle, unsigned int line,\n\t\t\t\t\tint type)\n{\n\tstruct super_block *sb;\n\tint err;\n\n\tif (!ext4_handle_valid(handle))\n\t\treturn ext4_get_nojournal();\n\n\tsb = handle->h_journal->j_private;\n\ttrace_ext4_journal_start_reserved(sb, handle->h_buffer_credits,\n\t\t\t\t\t  _RET_IP_);\n\terr = ext4_journal_check_start(sb);\n\tif (err < 0) {\n\t\tjbd2_journal_free_reserved(handle);\n\t\treturn ERR_PTR(err);\n\t}\n\n\terr = jbd2_journal_start_reserved(handle, type, line);\n\tif (err < 0)\n\t\treturn ERR_PTR(err);\n\treturn handle;\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"ext4_jbd2.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"ext4_jbd2.h\"\n\nhandle_t *__ext4_journal_start_reserved(handle_t *handle, unsigned int line,\n\t\t\t\t\tint type)\n{\n\tstruct super_block *sb;\n\tint err;\n\n\tif (!ext4_handle_valid(handle))\n\t\treturn ext4_get_nojournal();\n\n\tsb = handle->h_journal->j_private;\n\ttrace_ext4_journal_start_reserved(sb, handle->h_buffer_credits,\n\t\t\t\t\t  _RET_IP_);\n\terr = ext4_journal_check_start(sb);\n\tif (err < 0) {\n\t\tjbd2_journal_free_reserved(handle);\n\t\treturn ERR_PTR(err);\n\t}\n\n\terr = jbd2_journal_start_reserved(handle, type, line);\n\tif (err < 0)\n\t\treturn ERR_PTR(err);\n\treturn handle;\n}"
        }
      },
      {
        "call_info": {
          "callee": "EXT4_QUOTA_INIT_BLOCKS",
          "args": [
            "dquot->dq_sb"
          ],
          "line": 5152
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dquot_to_inode",
          "args": [
            "dquot"
          ],
          "line": 5151
        },
        "resolved": true,
        "details": {
          "function_name": "dquot_to_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/super.c",
          "lines": "5123-5126",
          "snippet": "static inline struct inode *dquot_to_inode(struct dquot *dquot)\n{\n\treturn sb_dqopt(dquot->dq_sb)->files[dquot->dq_id.type];\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"mballoc.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include \"ext4_extents.h\"\t/* Needed for trace points definition */",
            "#include \"ext4.h\"",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/crc16.h>",
            "#include <linux/log2.h>",
            "#include <linux/ctype.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/random.h>",
            "#include <linux/vfs.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/parser.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/time.h>",
            "#include <linux/fs.h>",
            "#include <linux/string.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"mballoc.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4_extents.h\"\t/* Needed for trace points definition */\n#include \"ext4.h\"\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <asm/uaccess.h>\n#include <linux/cleancache.h>\n#include <linux/crc16.h>\n#include <linux/log2.h>\n#include <linux/ctype.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/random.h>\n#include <linux/vfs.h>\n#include <linux/exportfs.h>\n#include <linux/buffer_head.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/jbd2.h>\n#include <linux/vmalloc.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n#include <linux/string.h>\n#include <linux/module.h>\n\nstatic inline struct inode *dquot_to_inode(struct dquot *dquot)\n{\n\treturn sb_dqopt(dquot->dq_sb)->files[dquot->dq_id.type];\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"mballoc.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4_extents.h\"\t/* Needed for trace points definition */\n#include \"ext4.h\"\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <asm/uaccess.h>\n#include <linux/cleancache.h>\n#include <linux/crc16.h>\n#include <linux/log2.h>\n#include <linux/ctype.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/random.h>\n#include <linux/vfs.h>\n#include <linux/exportfs.h>\n#include <linux/buffer_head.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/jbd2.h>\n#include <linux/vmalloc.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n#include <linux/string.h>\n#include <linux/module.h>\n\nstatic int ext4_acquire_dquot(struct dquot *dquot)\n{\n\tint ret, err;\n\thandle_t *handle;\n\n\thandle = ext4_journal_start(dquot_to_inode(dquot), EXT4_HT_QUOTA,\n\t\t\t\t    EXT4_QUOTA_INIT_BLOCKS(dquot->dq_sb));\n\tif (IS_ERR(handle))\n\t\treturn PTR_ERR(handle);\n\tret = dquot_acquire(dquot);\n\terr = ext4_journal_stop(handle);\n\tif (!ret)\n\t\tret = err;\n\treturn ret;\n}"
  },
  {
    "function_name": "ext4_write_dquot",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/super.c",
    "lines": "5128-5144",
    "snippet": "static int ext4_write_dquot(struct dquot *dquot)\n{\n\tint ret, err;\n\thandle_t *handle;\n\tstruct inode *inode;\n\n\tinode = dquot_to_inode(dquot);\n\thandle = ext4_journal_start(inode, EXT4_HT_QUOTA,\n\t\t\t\t    EXT4_QUOTA_TRANS_BLOCKS(dquot->dq_sb));\n\tif (IS_ERR(handle))\n\t\treturn PTR_ERR(handle);\n\tret = dquot_commit(dquot);\n\terr = ext4_journal_stop(handle);\n\tif (!ret)\n\t\tret = err;\n\treturn ret;\n}",
    "includes": [
      "#include <trace/events/ext4.h>",
      "#include \"mballoc.h\"",
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"ext4_jbd2.h\"",
      "#include \"ext4_extents.h\"\t/* Needed for trace points definition */",
      "#include \"ext4.h\"",
      "#include <linux/freezer.h>",
      "#include <linux/kthread.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/cleancache.h>",
      "#include <linux/crc16.h>",
      "#include <linux/log2.h>",
      "#include <linux/ctype.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/namei.h>",
      "#include <linux/mount.h>",
      "#include <linux/random.h>",
      "#include <linux/vfs.h>",
      "#include <linux/exportfs.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/parser.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/init.h>",
      "#include <linux/slab.h>",
      "#include <linux/jbd2.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/time.h>",
      "#include <linux/fs.h>",
      "#include <linux/string.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ext4_journal_stop",
          "args": [
            "handle"
          ],
          "line": 5140
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dquot_commit",
          "args": [
            "dquot"
          ],
          "line": 5139
        },
        "resolved": true,
        "details": {
          "function_name": "dquot_commit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/quota/dquot.c",
          "lines": "441-462",
          "snippet": "int dquot_commit(struct dquot *dquot)\n{\n\tint ret = 0;\n\tstruct quota_info *dqopt = sb_dqopt(dquot->dq_sb);\n\n\tmutex_lock(&dqopt->dqio_mutex);\n\tspin_lock(&dq_list_lock);\n\tif (!clear_dquot_dirty(dquot)) {\n\t\tspin_unlock(&dq_list_lock);\n\t\tgoto out_sem;\n\t}\n\tspin_unlock(&dq_list_lock);\n\t/* Inactive dquot can be only if there was error during read/init\n\t * => we have better not writing it */\n\tif (test_bit(DQ_ACTIVE_B, &dquot->dq_flags))\n\t\tret = dqopt->ops[dquot->dq_id.type]->commit_dqblk(dquot);\n\telse\n\t\tret = -EIO;\nout_sem:\n\tmutex_unlock(&dqopt->dqio_mutex);\n\treturn ret;\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include \"../internal.h\" /* ugh */",
            "#include <linux/quotaops.h>",
            "#include <linux/capability.h>",
            "#include <linux/namei.h>",
            "#include <linux/kmod.h>",
            "#include <linux/sched.h>",
            "#include <linux/security.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>",
            "#include <linux/tty.h>",
            "#include <linux/stat.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/time.h>",
            "#include <linux/mm.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __cacheline_aligned_in_smp DEFINE_SPINLOCK(dq_list_lock);",
            "static void __dquot_initialize(struct inode *inode, int type);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include \"../internal.h\" /* ugh */\n#include <linux/quotaops.h>\n#include <linux/capability.h>\n#include <linux/namei.h>\n#include <linux/kmod.h>\n#include <linux/sched.h>\n#include <linux/security.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/sysctl.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/tty.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/time.h>\n#include <linux/mm.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/kernel.h>\n#include <linux/errno.h>\n\nstatic __cacheline_aligned_in_smp DEFINE_SPINLOCK(dq_list_lock);\nstatic void __dquot_initialize(struct inode *inode, int type);\n\nint dquot_commit(struct dquot *dquot)\n{\n\tint ret = 0;\n\tstruct quota_info *dqopt = sb_dqopt(dquot->dq_sb);\n\n\tmutex_lock(&dqopt->dqio_mutex);\n\tspin_lock(&dq_list_lock);\n\tif (!clear_dquot_dirty(dquot)) {\n\t\tspin_unlock(&dq_list_lock);\n\t\tgoto out_sem;\n\t}\n\tspin_unlock(&dq_list_lock);\n\t/* Inactive dquot can be only if there was error during read/init\n\t * => we have better not writing it */\n\tif (test_bit(DQ_ACTIVE_B, &dquot->dq_flags))\n\t\tret = dqopt->ops[dquot->dq_id.type]->commit_dqblk(dquot);\n\telse\n\t\tret = -EIO;\nout_sem:\n\tmutex_unlock(&dqopt->dqio_mutex);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "handle"
          ],
          "line": 5138
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "handle"
          ],
          "line": 5137
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_journal_start",
          "args": [
            "inode",
            "EXT4_HT_QUOTA",
            "EXT4_QUOTA_TRANS_BLOCKS(dquot->dq_sb)"
          ],
          "line": 5135
        },
        "resolved": true,
        "details": {
          "function_name": "__ext4_journal_start_reserved",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ext4_jbd2.c",
          "lines": "101-123",
          "snippet": "handle_t *__ext4_journal_start_reserved(handle_t *handle, unsigned int line,\n\t\t\t\t\tint type)\n{\n\tstruct super_block *sb;\n\tint err;\n\n\tif (!ext4_handle_valid(handle))\n\t\treturn ext4_get_nojournal();\n\n\tsb = handle->h_journal->j_private;\n\ttrace_ext4_journal_start_reserved(sb, handle->h_buffer_credits,\n\t\t\t\t\t  _RET_IP_);\n\terr = ext4_journal_check_start(sb);\n\tif (err < 0) {\n\t\tjbd2_journal_free_reserved(handle);\n\t\treturn ERR_PTR(err);\n\t}\n\n\terr = jbd2_journal_start_reserved(handle, type, line);\n\tif (err < 0)\n\t\treturn ERR_PTR(err);\n\treturn handle;\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"ext4_jbd2.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"ext4_jbd2.h\"\n\nhandle_t *__ext4_journal_start_reserved(handle_t *handle, unsigned int line,\n\t\t\t\t\tint type)\n{\n\tstruct super_block *sb;\n\tint err;\n\n\tif (!ext4_handle_valid(handle))\n\t\treturn ext4_get_nojournal();\n\n\tsb = handle->h_journal->j_private;\n\ttrace_ext4_journal_start_reserved(sb, handle->h_buffer_credits,\n\t\t\t\t\t  _RET_IP_);\n\terr = ext4_journal_check_start(sb);\n\tif (err < 0) {\n\t\tjbd2_journal_free_reserved(handle);\n\t\treturn ERR_PTR(err);\n\t}\n\n\terr = jbd2_journal_start_reserved(handle, type, line);\n\tif (err < 0)\n\t\treturn ERR_PTR(err);\n\treturn handle;\n}"
        }
      },
      {
        "call_info": {
          "callee": "EXT4_QUOTA_TRANS_BLOCKS",
          "args": [
            "dquot->dq_sb"
          ],
          "line": 5136
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dquot_to_inode",
          "args": [
            "dquot"
          ],
          "line": 5134
        },
        "resolved": true,
        "details": {
          "function_name": "dquot_to_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/super.c",
          "lines": "5123-5126",
          "snippet": "static inline struct inode *dquot_to_inode(struct dquot *dquot)\n{\n\treturn sb_dqopt(dquot->dq_sb)->files[dquot->dq_id.type];\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"mballoc.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include \"ext4_extents.h\"\t/* Needed for trace points definition */",
            "#include \"ext4.h\"",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/crc16.h>",
            "#include <linux/log2.h>",
            "#include <linux/ctype.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/random.h>",
            "#include <linux/vfs.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/parser.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/time.h>",
            "#include <linux/fs.h>",
            "#include <linux/string.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"mballoc.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4_extents.h\"\t/* Needed for trace points definition */\n#include \"ext4.h\"\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <asm/uaccess.h>\n#include <linux/cleancache.h>\n#include <linux/crc16.h>\n#include <linux/log2.h>\n#include <linux/ctype.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/random.h>\n#include <linux/vfs.h>\n#include <linux/exportfs.h>\n#include <linux/buffer_head.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/jbd2.h>\n#include <linux/vmalloc.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n#include <linux/string.h>\n#include <linux/module.h>\n\nstatic inline struct inode *dquot_to_inode(struct dquot *dquot)\n{\n\treturn sb_dqopt(dquot->dq_sb)->files[dquot->dq_id.type];\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"mballoc.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4_extents.h\"\t/* Needed for trace points definition */\n#include \"ext4.h\"\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <asm/uaccess.h>\n#include <linux/cleancache.h>\n#include <linux/crc16.h>\n#include <linux/log2.h>\n#include <linux/ctype.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/random.h>\n#include <linux/vfs.h>\n#include <linux/exportfs.h>\n#include <linux/buffer_head.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/jbd2.h>\n#include <linux/vmalloc.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n#include <linux/string.h>\n#include <linux/module.h>\n\nstatic int ext4_write_dquot(struct dquot *dquot)\n{\n\tint ret, err;\n\thandle_t *handle;\n\tstruct inode *inode;\n\n\tinode = dquot_to_inode(dquot);\n\thandle = ext4_journal_start(inode, EXT4_HT_QUOTA,\n\t\t\t\t    EXT4_QUOTA_TRANS_BLOCKS(dquot->dq_sb));\n\tif (IS_ERR(handle))\n\t\treturn PTR_ERR(handle);\n\tret = dquot_commit(dquot);\n\terr = ext4_journal_stop(handle);\n\tif (!ret)\n\t\tret = err;\n\treturn ret;\n}"
  },
  {
    "function_name": "dquot_to_inode",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/super.c",
    "lines": "5123-5126",
    "snippet": "static inline struct inode *dquot_to_inode(struct dquot *dquot)\n{\n\treturn sb_dqopt(dquot->dq_sb)->files[dquot->dq_id.type];\n}",
    "includes": [
      "#include <trace/events/ext4.h>",
      "#include \"mballoc.h\"",
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"ext4_jbd2.h\"",
      "#include \"ext4_extents.h\"\t/* Needed for trace points definition */",
      "#include \"ext4.h\"",
      "#include <linux/freezer.h>",
      "#include <linux/kthread.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/cleancache.h>",
      "#include <linux/crc16.h>",
      "#include <linux/log2.h>",
      "#include <linux/ctype.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/namei.h>",
      "#include <linux/mount.h>",
      "#include <linux/random.h>",
      "#include <linux/vfs.h>",
      "#include <linux/exportfs.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/parser.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/init.h>",
      "#include <linux/slab.h>",
      "#include <linux/jbd2.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/time.h>",
      "#include <linux/fs.h>",
      "#include <linux/string.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "sb_dqopt",
          "args": [
            "dquot->dq_sb"
          ],
          "line": 5125
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"mballoc.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4_extents.h\"\t/* Needed for trace points definition */\n#include \"ext4.h\"\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <asm/uaccess.h>\n#include <linux/cleancache.h>\n#include <linux/crc16.h>\n#include <linux/log2.h>\n#include <linux/ctype.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/random.h>\n#include <linux/vfs.h>\n#include <linux/exportfs.h>\n#include <linux/buffer_head.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/jbd2.h>\n#include <linux/vmalloc.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n#include <linux/string.h>\n#include <linux/module.h>\n\nstatic inline struct inode *dquot_to_inode(struct dquot *dquot)\n{\n\treturn sb_dqopt(dquot->dq_sb)->files[dquot->dq_id.type];\n}"
  },
  {
    "function_name": "ext4_statfs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/super.c",
    "lines": "5076-5109",
    "snippet": "static int ext4_statfs(struct dentry *dentry, struct kstatfs *buf)\n{\n\tstruct super_block *sb = dentry->d_sb;\n\tstruct ext4_sb_info *sbi = EXT4_SB(sb);\n\tstruct ext4_super_block *es = sbi->s_es;\n\text4_fsblk_t overhead = 0, resv_blocks;\n\tu64 fsid;\n\ts64 bfree;\n\tresv_blocks = EXT4_C2B(sbi, atomic64_read(&sbi->s_resv_clusters));\n\n\tif (!test_opt(sb, MINIX_DF))\n\t\toverhead = sbi->s_overhead;\n\n\tbuf->f_type = EXT4_SUPER_MAGIC;\n\tbuf->f_bsize = sb->s_blocksize;\n\tbuf->f_blocks = ext4_blocks_count(es) - EXT4_C2B(sbi, overhead);\n\tbfree = percpu_counter_sum_positive(&sbi->s_freeclusters_counter) -\n\t\tpercpu_counter_sum_positive(&sbi->s_dirtyclusters_counter);\n\t/* prevent underflow in case that few free space is available */\n\tbuf->f_bfree = EXT4_C2B(sbi, max_t(s64, bfree, 0));\n\tbuf->f_bavail = buf->f_bfree -\n\t\t\t(ext4_r_blocks_count(es) + resv_blocks);\n\tif (buf->f_bfree < (ext4_r_blocks_count(es) + resv_blocks))\n\t\tbuf->f_bavail = 0;\n\tbuf->f_files = le32_to_cpu(es->s_inodes_count);\n\tbuf->f_ffree = percpu_counter_sum_positive(&sbi->s_freeinodes_counter);\n\tbuf->f_namelen = EXT4_NAME_LEN;\n\tfsid = le64_to_cpup((void *)es->s_uuid) ^\n\t       le64_to_cpup((void *)es->s_uuid + sizeof(u64));\n\tbuf->f_fsid.val[0] = fsid & 0xFFFFFFFFUL;\n\tbuf->f_fsid.val[1] = (fsid >> 32) & 0xFFFFFFFFUL;\n\n\treturn 0;\n}",
    "includes": [
      "#include <trace/events/ext4.h>",
      "#include \"mballoc.h\"",
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"ext4_jbd2.h\"",
      "#include \"ext4_extents.h\"\t/* Needed for trace points definition */",
      "#include \"ext4.h\"",
      "#include <linux/freezer.h>",
      "#include <linux/kthread.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/cleancache.h>",
      "#include <linux/crc16.h>",
      "#include <linux/log2.h>",
      "#include <linux/ctype.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/namei.h>",
      "#include <linux/mount.h>",
      "#include <linux/random.h>",
      "#include <linux/vfs.h>",
      "#include <linux/exportfs.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/parser.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/init.h>",
      "#include <linux/slab.h>",
      "#include <linux/jbd2.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/time.h>",
      "#include <linux/fs.h>",
      "#include <linux/string.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void ext4_mark_recovery_complete(struct super_block *sb,\n\t\t\t\t\tstruct ext4_super_block *es);",
      "static void ext4_clear_journal_err(struct super_block *sb,\n\t\t\t\t   struct ext4_super_block *es);",
      "static int ext4_statfs(struct dentry *dentry, struct kstatfs *buf);",
      "static int ext4_unfreeze(struct super_block *sb);",
      "static int ext4_freeze(struct super_block *sb);",
      "static inline int ext2_feature_set_ok(struct super_block *sb);",
      "static inline int ext3_feature_set_ok(struct super_block *sb);",
      "static void ext4_unregister_li_request(struct super_block *sb);",
      "static int ext4_reserve_clusters(struct ext4_sb_info *, ext4_fsblk_t);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "le64_to_cpup",
          "args": [
            "(void *)es->s_uuid + sizeof(u64)"
          ],
          "line": 5104
        },
        "resolved": true,
        "details": {
          "function_name": "sle64_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "58-61",
          "snippet": "static inline s64 sle64_to_cpup(sle64 *x)\n{\n\treturn le64_to_cpu(*(__force le64*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s64 sle64_to_cpup(sle64 *x)\n{\n\treturn le64_to_cpu(*(__force le64*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "percpu_counter_sum_positive",
          "args": [
            "&sbi->s_freeinodes_counter"
          ],
          "line": 5101
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "es->s_inodes_count"
          ],
          "line": 5100
        },
        "resolved": true,
        "details": {
          "function_name": "sle32_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "53-56",
          "snippet": "static inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_r_blocks_count",
          "args": [
            "es"
          ],
          "line": 5098
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_r_blocks_count",
          "args": [
            "es"
          ],
          "line": 5097
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXT4_C2B",
          "args": [
            "sbi",
            "max_t(s64, bfree, 0)"
          ],
          "line": 5095
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "max_t",
          "args": [
            "s64",
            "bfree",
            "0"
          ],
          "line": 5095
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "percpu_counter_sum_positive",
          "args": [
            "&sbi->s_dirtyclusters_counter"
          ],
          "line": 5093
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "percpu_counter_sum_positive",
          "args": [
            "&sbi->s_freeclusters_counter"
          ],
          "line": 5092
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXT4_C2B",
          "args": [
            "sbi",
            "overhead"
          ],
          "line": 5091
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_blocks_count",
          "args": [
            "es"
          ],
          "line": 5091
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_opt",
          "args": [
            "sb",
            "MINIX_DF"
          ],
          "line": 5086
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXT4_C2B",
          "args": [
            "sbi",
            "atomic64_read(&sbi->s_resv_clusters)"
          ],
          "line": 5084
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic64_read",
          "args": [
            "&sbi->s_resv_clusters"
          ],
          "line": 5084
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXT4_SB",
          "args": [
            "sb"
          ],
          "line": 5079
        },
        "resolved": true,
        "details": {
          "function_name": "EXT4_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ext4.h",
          "lines": "1356-1359",
          "snippet": "static inline struct ext4_sb_info *EXT4_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include \"extents_status.h\"",
            "#include <linux/compat.h>",
            "#include <linux/falloc.h>",
            "#include <crypto/hash.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/wait.h>",
            "#include <linux/timer.h>",
            "#include <linux/mutex.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/quota.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extents_status.h\"\n#include <linux/compat.h>\n#include <linux/falloc.h>\n#include <crypto/hash.h>\n#include <linux/ratelimit.h>\n#include <linux/percpu_counter.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/wait.h>\n#include <linux/timer.h>\n#include <linux/mutex.h>\n#include <linux/seqlock.h>\n#include <linux/rbtree.h>\n#include <linux/rwsem.h>\n#include <linux/quota.h>\n#include <linux/jbd2.h>\n#include <linux/magic.h>\n#include <linux/blkdev.h>\n#include <linux/types.h>\n\nstatic inline struct ext4_sb_info *EXT4_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"mballoc.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4_extents.h\"\t/* Needed for trace points definition */\n#include \"ext4.h\"\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <asm/uaccess.h>\n#include <linux/cleancache.h>\n#include <linux/crc16.h>\n#include <linux/log2.h>\n#include <linux/ctype.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/random.h>\n#include <linux/vfs.h>\n#include <linux/exportfs.h>\n#include <linux/buffer_head.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/jbd2.h>\n#include <linux/vmalloc.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n#include <linux/string.h>\n#include <linux/module.h>\n\nstatic void ext4_mark_recovery_complete(struct super_block *sb,\n\t\t\t\t\tstruct ext4_super_block *es);\nstatic void ext4_clear_journal_err(struct super_block *sb,\n\t\t\t\t   struct ext4_super_block *es);\nstatic int ext4_statfs(struct dentry *dentry, struct kstatfs *buf);\nstatic int ext4_unfreeze(struct super_block *sb);\nstatic int ext4_freeze(struct super_block *sb);\nstatic inline int ext2_feature_set_ok(struct super_block *sb);\nstatic inline int ext3_feature_set_ok(struct super_block *sb);\nstatic void ext4_unregister_li_request(struct super_block *sb);\nstatic int ext4_reserve_clusters(struct ext4_sb_info *, ext4_fsblk_t);\n\nstatic int ext4_statfs(struct dentry *dentry, struct kstatfs *buf)\n{\n\tstruct super_block *sb = dentry->d_sb;\n\tstruct ext4_sb_info *sbi = EXT4_SB(sb);\n\tstruct ext4_super_block *es = sbi->s_es;\n\text4_fsblk_t overhead = 0, resv_blocks;\n\tu64 fsid;\n\ts64 bfree;\n\tresv_blocks = EXT4_C2B(sbi, atomic64_read(&sbi->s_resv_clusters));\n\n\tif (!test_opt(sb, MINIX_DF))\n\t\toverhead = sbi->s_overhead;\n\n\tbuf->f_type = EXT4_SUPER_MAGIC;\n\tbuf->f_bsize = sb->s_blocksize;\n\tbuf->f_blocks = ext4_blocks_count(es) - EXT4_C2B(sbi, overhead);\n\tbfree = percpu_counter_sum_positive(&sbi->s_freeclusters_counter) -\n\t\tpercpu_counter_sum_positive(&sbi->s_dirtyclusters_counter);\n\t/* prevent underflow in case that few free space is available */\n\tbuf->f_bfree = EXT4_C2B(sbi, max_t(s64, bfree, 0));\n\tbuf->f_bavail = buf->f_bfree -\n\t\t\t(ext4_r_blocks_count(es) + resv_blocks);\n\tif (buf->f_bfree < (ext4_r_blocks_count(es) + resv_blocks))\n\t\tbuf->f_bavail = 0;\n\tbuf->f_files = le32_to_cpu(es->s_inodes_count);\n\tbuf->f_ffree = percpu_counter_sum_positive(&sbi->s_freeinodes_counter);\n\tbuf->f_namelen = EXT4_NAME_LEN;\n\tfsid = le64_to_cpup((void *)es->s_uuid) ^\n\t       le64_to_cpup((void *)es->s_uuid + sizeof(u64));\n\tbuf->f_fsid.val[0] = fsid & 0xFFFFFFFFUL;\n\tbuf->f_fsid.val[1] = (fsid >> 32) & 0xFFFFFFFFUL;\n\n\treturn 0;\n}"
  },
  {
    "function_name": "ext4_remount",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/super.c",
    "lines": "4832-5074",
    "snippet": "static int ext4_remount(struct super_block *sb, int *flags, char *data)\n{\n\tstruct ext4_super_block *es;\n\tstruct ext4_sb_info *sbi = EXT4_SB(sb);\n\tunsigned long old_sb_flags;\n\tstruct ext4_mount_options old_opts;\n\tint enable_quota = 0;\n\text4_group_t g;\n\tunsigned int journal_ioprio = DEFAULT_JOURNAL_IOPRIO;\n\tint err = 0;\n#ifdef CONFIG_QUOTA\n\tint i, j;\n#endif\n\tchar *orig_data = kstrdup(data, GFP_KERNEL);\n\n\t/* Store the original options */\n\told_sb_flags = sb->s_flags;\n\told_opts.s_mount_opt = sbi->s_mount_opt;\n\told_opts.s_mount_opt2 = sbi->s_mount_opt2;\n\told_opts.s_resuid = sbi->s_resuid;\n\told_opts.s_resgid = sbi->s_resgid;\n\told_opts.s_commit_interval = sbi->s_commit_interval;\n\told_opts.s_min_batch_time = sbi->s_min_batch_time;\n\told_opts.s_max_batch_time = sbi->s_max_batch_time;\n#ifdef CONFIG_QUOTA\n\told_opts.s_jquota_fmt = sbi->s_jquota_fmt;\n\tfor (i = 0; i < EXT4_MAXQUOTAS; i++)\n\t\tif (sbi->s_qf_names[i]) {\n\t\t\told_opts.s_qf_names[i] = kstrdup(sbi->s_qf_names[i],\n\t\t\t\t\t\t\t GFP_KERNEL);\n\t\t\tif (!old_opts.s_qf_names[i]) {\n\t\t\t\tfor (j = 0; j < i; j++)\n\t\t\t\t\tkfree(old_opts.s_qf_names[j]);\n\t\t\t\tkfree(orig_data);\n\t\t\t\treturn -ENOMEM;\n\t\t\t}\n\t\t} else\n\t\t\told_opts.s_qf_names[i] = NULL;\n#endif\n\tif (sbi->s_journal && sbi->s_journal->j_task->io_context)\n\t\tjournal_ioprio = sbi->s_journal->j_task->io_context->ioprio;\n\n\tif (!parse_options(data, sb, NULL, &journal_ioprio, 1)) {\n\t\terr = -EINVAL;\n\t\tgoto restore_opts;\n\t}\n\n\tif ((old_opts.s_mount_opt & EXT4_MOUNT_JOURNAL_CHECKSUM) ^\n\t    test_opt(sb, JOURNAL_CHECKSUM)) {\n\t\text4_msg(sb, KERN_ERR, \"changing journal_checksum \"\n\t\t\t \"during remount not supported; ignoring\");\n\t\tsbi->s_mount_opt ^= EXT4_MOUNT_JOURNAL_CHECKSUM;\n\t}\n\n\tif (test_opt(sb, DATA_FLAGS) == EXT4_MOUNT_JOURNAL_DATA) {\n\t\tif (test_opt2(sb, EXPLICIT_DELALLOC)) {\n\t\t\text4_msg(sb, KERN_ERR, \"can't mount with \"\n\t\t\t\t \"both data=journal and delalloc\");\n\t\t\terr = -EINVAL;\n\t\t\tgoto restore_opts;\n\t\t}\n\t\tif (test_opt(sb, DIOREAD_NOLOCK)) {\n\t\t\text4_msg(sb, KERN_ERR, \"can't mount with \"\n\t\t\t\t \"both data=journal and dioread_nolock\");\n\t\t\terr = -EINVAL;\n\t\t\tgoto restore_opts;\n\t\t}\n\t\tif (test_opt(sb, DAX)) {\n\t\t\text4_msg(sb, KERN_ERR, \"can't mount with \"\n\t\t\t\t \"both data=journal and dax\");\n\t\t\terr = -EINVAL;\n\t\t\tgoto restore_opts;\n\t\t}\n\t}\n\n\tif ((sbi->s_mount_opt ^ old_opts.s_mount_opt) & EXT4_MOUNT_DAX) {\n\t\text4_msg(sb, KERN_WARNING, \"warning: refusing change of \"\n\t\t\t\"dax flag with busy inodes while remounting\");\n\t\tsbi->s_mount_opt ^= EXT4_MOUNT_DAX;\n\t}\n\n\tif (sbi->s_mount_flags & EXT4_MF_FS_ABORTED)\n\t\text4_abort(sb, \"Abort forced by user\");\n\n\tsb->s_flags = (sb->s_flags & ~MS_POSIXACL) |\n\t\t(test_opt(sb, POSIX_ACL) ? MS_POSIXACL : 0);\n\n\tes = sbi->s_es;\n\n\tif (sbi->s_journal) {\n\t\text4_init_journal_params(sb, sbi->s_journal);\n\t\tset_task_ioprio(sbi->s_journal->j_task, journal_ioprio);\n\t}\n\n\tif ((*flags & MS_RDONLY) != (sb->s_flags & MS_RDONLY)) {\n\t\tif (sbi->s_mount_flags & EXT4_MF_FS_ABORTED) {\n\t\t\terr = -EROFS;\n\t\t\tgoto restore_opts;\n\t\t}\n\n\t\tif (*flags & MS_RDONLY) {\n\t\t\terr = sync_filesystem(sb);\n\t\t\tif (err < 0)\n\t\t\t\tgoto restore_opts;\n\t\t\terr = dquot_suspend(sb, -1);\n\t\t\tif (err < 0)\n\t\t\t\tgoto restore_opts;\n\n\t\t\t/*\n\t\t\t * First of all, the unconditional stuff we have to do\n\t\t\t * to disable replay of the journal when we next remount\n\t\t\t */\n\t\t\tsb->s_flags |= MS_RDONLY;\n\n\t\t\t/*\n\t\t\t * OK, test if we are remounting a valid rw partition\n\t\t\t * readonly, and if so set the rdonly flag and then\n\t\t\t * mark the partition as valid again.\n\t\t\t */\n\t\t\tif (!(es->s_state & cpu_to_le16(EXT4_VALID_FS)) &&\n\t\t\t    (sbi->s_mount_state & EXT4_VALID_FS))\n\t\t\t\tes->s_state = cpu_to_le16(sbi->s_mount_state);\n\n\t\t\tif (sbi->s_journal)\n\t\t\t\text4_mark_recovery_complete(sb, es);\n\t\t} else {\n\t\t\t/* Make sure we can mount this feature set readwrite */\n\t\t\tif (EXT4_HAS_RO_COMPAT_FEATURE(sb,\n\t\t\t\t\tEXT4_FEATURE_RO_COMPAT_READONLY) ||\n\t\t\t    !ext4_feature_set_ok(sb, 0)) {\n\t\t\t\terr = -EROFS;\n\t\t\t\tgoto restore_opts;\n\t\t\t}\n\t\t\t/*\n\t\t\t * Make sure the group descriptor checksums\n\t\t\t * are sane.  If they aren't, refuse to remount r/w.\n\t\t\t */\n\t\t\tfor (g = 0; g < sbi->s_groups_count; g++) {\n\t\t\t\tstruct ext4_group_desc *gdp =\n\t\t\t\t\text4_get_group_desc(sb, g, NULL);\n\n\t\t\t\tif (!ext4_group_desc_csum_verify(sb, g, gdp)) {\n\t\t\t\t\text4_msg(sb, KERN_ERR,\n\t       \"ext4_remount: Checksum for group %u failed (%u!=%u)\",\n\t\tg, le16_to_cpu(ext4_group_desc_csum(sbi, g, gdp)),\n\t\t\t\t\t       le16_to_cpu(gdp->bg_checksum));\n\t\t\t\t\terr = -EINVAL;\n\t\t\t\t\tgoto restore_opts;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * If we have an unprocessed orphan list hanging\n\t\t\t * around from a previously readonly bdev mount,\n\t\t\t * require a full umount/remount for now.\n\t\t\t */\n\t\t\tif (es->s_last_orphan) {\n\t\t\t\text4_msg(sb, KERN_WARNING, \"Couldn't \"\n\t\t\t\t       \"remount RDWR because of unprocessed \"\n\t\t\t\t       \"orphan inode list.  Please \"\n\t\t\t\t       \"umount/remount instead\");\n\t\t\t\terr = -EINVAL;\n\t\t\t\tgoto restore_opts;\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * Mounting a RDONLY partition read-write, so reread\n\t\t\t * and store the current valid flag.  (It may have\n\t\t\t * been changed by e2fsck since we originally mounted\n\t\t\t * the partition.)\n\t\t\t */\n\t\t\tif (sbi->s_journal)\n\t\t\t\text4_clear_journal_err(sb, es);\n\t\t\tsbi->s_mount_state = le16_to_cpu(es->s_state);\n\t\t\tif (!ext4_setup_super(sb, es, 0))\n\t\t\t\tsb->s_flags &= ~MS_RDONLY;\n\t\t\tif (EXT4_HAS_INCOMPAT_FEATURE(sb,\n\t\t\t\t\t\t     EXT4_FEATURE_INCOMPAT_MMP))\n\t\t\t\tif (ext4_multi_mount_protect(sb,\n\t\t\t\t\t\tle64_to_cpu(es->s_mmp_block))) {\n\t\t\t\t\terr = -EROFS;\n\t\t\t\t\tgoto restore_opts;\n\t\t\t\t}\n\t\t\tenable_quota = 1;\n\t\t}\n\t}\n\n\t/*\n\t * Reinitialize lazy itable initialization thread based on\n\t * current settings\n\t */\n\tif ((sb->s_flags & MS_RDONLY) || !test_opt(sb, INIT_INODE_TABLE))\n\t\text4_unregister_li_request(sb);\n\telse {\n\t\text4_group_t first_not_zeroed;\n\t\tfirst_not_zeroed = ext4_has_uninit_itable(sb);\n\t\text4_register_li_request(sb, first_not_zeroed);\n\t}\n\n\text4_setup_system_zone(sb);\n\tif (sbi->s_journal == NULL && !(old_sb_flags & MS_RDONLY))\n\t\text4_commit_super(sb, 1);\n\n#ifdef CONFIG_QUOTA\n\t/* Release old quota file names */\n\tfor (i = 0; i < EXT4_MAXQUOTAS; i++)\n\t\tkfree(old_opts.s_qf_names[i]);\n\tif (enable_quota) {\n\t\tif (sb_any_quota_suspended(sb))\n\t\t\tdquot_resume(sb, -1);\n\t\telse if (EXT4_HAS_RO_COMPAT_FEATURE(sb,\n\t\t\t\t\tEXT4_FEATURE_RO_COMPAT_QUOTA)) {\n\t\t\terr = ext4_enable_quotas(sb);\n\t\t\tif (err)\n\t\t\t\tgoto restore_opts;\n\t\t}\n\t}\n#endif\n\n\t*flags = (*flags & ~MS_LAZYTIME) | (sb->s_flags & MS_LAZYTIME);\n\text4_msg(sb, KERN_INFO, \"re-mounted. Opts: %s\", orig_data);\n\tkfree(orig_data);\n\treturn 0;\n\nrestore_opts:\n\tsb->s_flags = old_sb_flags;\n\tsbi->s_mount_opt = old_opts.s_mount_opt;\n\tsbi->s_mount_opt2 = old_opts.s_mount_opt2;\n\tsbi->s_resuid = old_opts.s_resuid;\n\tsbi->s_resgid = old_opts.s_resgid;\n\tsbi->s_commit_interval = old_opts.s_commit_interval;\n\tsbi->s_min_batch_time = old_opts.s_min_batch_time;\n\tsbi->s_max_batch_time = old_opts.s_max_batch_time;\n#ifdef CONFIG_QUOTA\n\tsbi->s_jquota_fmt = old_opts.s_jquota_fmt;\n\tfor (i = 0; i < EXT4_MAXQUOTAS; i++) {\n\t\tkfree(sbi->s_qf_names[i]);\n\t\tsbi->s_qf_names[i] = old_opts.s_qf_names[i];\n\t}\n#endif\n\tkfree(orig_data);\n\treturn err;\n}",
    "includes": [
      "#include <trace/events/ext4.h>",
      "#include \"mballoc.h\"",
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"ext4_jbd2.h\"",
      "#include \"ext4_extents.h\"\t/* Needed for trace points definition */",
      "#include \"ext4.h\"",
      "#include <linux/freezer.h>",
      "#include <linux/kthread.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/cleancache.h>",
      "#include <linux/crc16.h>",
      "#include <linux/log2.h>",
      "#include <linux/ctype.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/namei.h>",
      "#include <linux/mount.h>",
      "#include <linux/random.h>",
      "#include <linux/vfs.h>",
      "#include <linux/exportfs.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/parser.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/init.h>",
      "#include <linux/slab.h>",
      "#include <linux/jbd2.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/time.h>",
      "#include <linux/fs.h>",
      "#include <linux/string.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [
      "#define DEFAULT_JOURNAL_IOPRIO (IOPRIO_PRIO_VALUE(IOPRIO_CLASS_BE, 3))"
    ],
    "globals_used": [
      "static void ext4_mark_recovery_complete(struct super_block *sb,\n\t\t\t\t\tstruct ext4_super_block *es);",
      "static void ext4_clear_journal_err(struct super_block *sb,\n\t\t\t\t   struct ext4_super_block *es);",
      "static int ext4_remount(struct super_block *sb, int *flags, char *data);",
      "static int ext4_unfreeze(struct super_block *sb);",
      "static int ext4_freeze(struct super_block *sb);",
      "static struct dentry *ext4_mount(struct file_system_type *fs_type, int flags,\n\t\t       const char *dev_name, void *data);",
      "static inline int ext2_feature_set_ok(struct super_block *sb);",
      "static inline int ext3_feature_set_ok(struct super_block *sb);",
      "static int ext4_feature_set_ok(struct super_block *sb, int readonly);",
      "static void ext4_unregister_li_request(struct super_block *sb);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "orig_data"
          ],
          "line": 5072
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "sbi->s_qf_names[i]"
          ],
          "line": 5068
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "orig_data"
          ],
          "line": 5053
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_msg",
          "args": [
            "sb",
            "KERN_INFO",
            "\"re-mounted. Opts: %s\"",
            "orig_data"
          ],
          "line": 5052
        },
        "resolved": true,
        "details": {
          "function_name": "__ext4_msg",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/super.c",
          "lines": "593-607",
          "snippet": "void __ext4_msg(struct super_block *sb,\n\t\tconst char *prefix, const char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tif (!___ratelimit(&(EXT4_SB(sb)->s_msg_ratelimit_state), \"EXT4-fs\"))\n\t\treturn;\n\n\tva_start(args, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\tprintk(\"%sEXT4-fs (%s): %pV\\n\", prefix, sb->s_id, &vaf);\n\tva_end(args);\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"mballoc.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include \"ext4_extents.h\"\t/* Needed for trace points definition */",
            "#include \"ext4.h\"",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/crc16.h>",
            "#include <linux/log2.h>",
            "#include <linux/ctype.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/random.h>",
            "#include <linux/vfs.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/parser.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/time.h>",
            "#include <linux/fs.h>",
            "#include <linux/string.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ext4_unfreeze(struct super_block *sb);",
            "static int ext4_freeze(struct super_block *sb);",
            "static inline int ext2_feature_set_ok(struct super_block *sb);",
            "static inline int ext3_feature_set_ok(struct super_block *sb);",
            "static void ext4_unregister_li_request(struct super_block *sb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"mballoc.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4_extents.h\"\t/* Needed for trace points definition */\n#include \"ext4.h\"\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <asm/uaccess.h>\n#include <linux/cleancache.h>\n#include <linux/crc16.h>\n#include <linux/log2.h>\n#include <linux/ctype.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/random.h>\n#include <linux/vfs.h>\n#include <linux/exportfs.h>\n#include <linux/buffer_head.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/jbd2.h>\n#include <linux/vmalloc.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n#include <linux/string.h>\n#include <linux/module.h>\n\nstatic int ext4_unfreeze(struct super_block *sb);\nstatic int ext4_freeze(struct super_block *sb);\nstatic inline int ext2_feature_set_ok(struct super_block *sb);\nstatic inline int ext3_feature_set_ok(struct super_block *sb);\nstatic void ext4_unregister_li_request(struct super_block *sb);\n\nvoid __ext4_msg(struct super_block *sb,\n\t\tconst char *prefix, const char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tif (!___ratelimit(&(EXT4_SB(sb)->s_msg_ratelimit_state), \"EXT4-fs\"))\n\t\treturn;\n\n\tva_start(args, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\tprintk(\"%sEXT4-fs (%s): %pV\\n\", prefix, sb->s_id, &vaf);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_enable_quotas",
          "args": [
            "sb"
          ],
          "line": 5044
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_enable_quotas",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/super.c",
          "lines": "5295-5318",
          "snippet": "static int ext4_enable_quotas(struct super_block *sb)\n{\n\tint type, err = 0;\n\tunsigned long qf_inums[EXT4_MAXQUOTAS] = {\n\t\tle32_to_cpu(EXT4_SB(sb)->s_es->s_usr_quota_inum),\n\t\tle32_to_cpu(EXT4_SB(sb)->s_es->s_grp_quota_inum)\n\t};\n\n\tsb_dqopt(sb)->flags |= DQUOT_QUOTA_SYS_FILE;\n\tfor (type = 0; type < EXT4_MAXQUOTAS; type++) {\n\t\tif (qf_inums[type]) {\n\t\t\terr = ext4_quota_enable(sb, type, QFMT_VFS_V1,\n\t\t\t\t\t\tDQUOT_USAGE_ENABLED);\n\t\t\tif (err) {\n\t\t\t\text4_warning(sb,\n\t\t\t\t\t\"Failed to enable quota tracking \"\n\t\t\t\t\t\"(type=%d, err=%d). Please run \"\n\t\t\t\t\t\"e2fsck to fix.\", type, err);\n\t\t\t\treturn err;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"mballoc.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include \"ext4_extents.h\"\t/* Needed for trace points definition */",
            "#include \"ext4.h\"",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/crc16.h>",
            "#include <linux/log2.h>",
            "#include <linux/ctype.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/random.h>",
            "#include <linux/vfs.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/parser.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/time.h>",
            "#include <linux/fs.h>",
            "#include <linux/string.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ext4_unfreeze(struct super_block *sb);",
            "static int ext4_freeze(struct super_block *sb);",
            "static inline int ext2_feature_set_ok(struct super_block *sb);",
            "static inline int ext3_feature_set_ok(struct super_block *sb);",
            "static void ext4_unregister_li_request(struct super_block *sb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"mballoc.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4_extents.h\"\t/* Needed for trace points definition */\n#include \"ext4.h\"\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <asm/uaccess.h>\n#include <linux/cleancache.h>\n#include <linux/crc16.h>\n#include <linux/log2.h>\n#include <linux/ctype.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/random.h>\n#include <linux/vfs.h>\n#include <linux/exportfs.h>\n#include <linux/buffer_head.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/jbd2.h>\n#include <linux/vmalloc.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n#include <linux/string.h>\n#include <linux/module.h>\n\nstatic int ext4_unfreeze(struct super_block *sb);\nstatic int ext4_freeze(struct super_block *sb);\nstatic inline int ext2_feature_set_ok(struct super_block *sb);\nstatic inline int ext3_feature_set_ok(struct super_block *sb);\nstatic void ext4_unregister_li_request(struct super_block *sb);\n\nstatic int ext4_enable_quotas(struct super_block *sb)\n{\n\tint type, err = 0;\n\tunsigned long qf_inums[EXT4_MAXQUOTAS] = {\n\t\tle32_to_cpu(EXT4_SB(sb)->s_es->s_usr_quota_inum),\n\t\tle32_to_cpu(EXT4_SB(sb)->s_es->s_grp_quota_inum)\n\t};\n\n\tsb_dqopt(sb)->flags |= DQUOT_QUOTA_SYS_FILE;\n\tfor (type = 0; type < EXT4_MAXQUOTAS; type++) {\n\t\tif (qf_inums[type]) {\n\t\t\terr = ext4_quota_enable(sb, type, QFMT_VFS_V1,\n\t\t\t\t\t\tDQUOT_USAGE_ENABLED);\n\t\t\tif (err) {\n\t\t\t\text4_warning(sb,\n\t\t\t\t\t\"Failed to enable quota tracking \"\n\t\t\t\t\t\"(type=%d, err=%d). Please run \"\n\t\t\t\t\t\"e2fsck to fix.\", type, err);\n\t\t\t\treturn err;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "EXT4_HAS_RO_COMPAT_FEATURE",
          "args": [
            "sb",
            "EXT4_FEATURE_RO_COMPAT_QUOTA"
          ],
          "line": 5042
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dquot_resume",
          "args": [
            "sb",
            "-1"
          ],
          "line": 5041
        },
        "resolved": true,
        "details": {
          "function_name": "dquot_resume",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/quota/dquot.c",
          "lines": "2256-2289",
          "snippet": "int dquot_resume(struct super_block *sb, int type)\n{\n\tstruct quota_info *dqopt = sb_dqopt(sb);\n\tstruct inode *inode;\n\tint ret = 0, cnt;\n\tunsigned int flags;\n\n\tfor (cnt = 0; cnt < MAXQUOTAS; cnt++) {\n\t\tif (type != -1 && cnt != type)\n\t\t\tcontinue;\n\n\t\tmutex_lock(&dqopt->dqonoff_mutex);\n\t\tif (!sb_has_quota_suspended(sb, cnt)) {\n\t\t\tmutex_unlock(&dqopt->dqonoff_mutex);\n\t\t\tcontinue;\n\t\t}\n\t\tinode = dqopt->files[cnt];\n\t\tdqopt->files[cnt] = NULL;\n\t\tspin_lock(&dq_state_lock);\n\t\tflags = dqopt->flags & dquot_state_flag(DQUOT_USAGE_ENABLED |\n\t\t\t\t\t\t\tDQUOT_LIMITS_ENABLED,\n\t\t\t\t\t\t\tcnt);\n\t\tdqopt->flags &= ~dquot_state_flag(DQUOT_STATE_FLAGS, cnt);\n\t\tspin_unlock(&dq_state_lock);\n\t\tmutex_unlock(&dqopt->dqonoff_mutex);\n\n\t\tflags = dquot_generic_flag(flags, cnt);\n\t\tret = vfs_load_quota_inode(inode, cnt,\n\t\t\t\tdqopt->info[cnt].dqi_fmt_id, flags);\n\t\tiput(inode);\n\t}\n\n\treturn ret;\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include \"../internal.h\" /* ugh */",
            "#include <linux/quotaops.h>",
            "#include <linux/capability.h>",
            "#include <linux/namei.h>",
            "#include <linux/kmod.h>",
            "#include <linux/sched.h>",
            "#include <linux/security.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>",
            "#include <linux/tty.h>",
            "#include <linux/stat.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/time.h>",
            "#include <linux/mm.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __cacheline_aligned_in_smp DEFINE_SPINLOCK(dq_state_lock);",
            "static qsize_t inode_get_rsv_space(struct inode *inode);",
            "static void __dquot_initialize(struct inode *inode, int type);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include \"../internal.h\" /* ugh */\n#include <linux/quotaops.h>\n#include <linux/capability.h>\n#include <linux/namei.h>\n#include <linux/kmod.h>\n#include <linux/sched.h>\n#include <linux/security.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/sysctl.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/tty.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/time.h>\n#include <linux/mm.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/kernel.h>\n#include <linux/errno.h>\n\nstatic __cacheline_aligned_in_smp DEFINE_SPINLOCK(dq_state_lock);\nstatic qsize_t inode_get_rsv_space(struct inode *inode);\nstatic void __dquot_initialize(struct inode *inode, int type);\n\nint dquot_resume(struct super_block *sb, int type)\n{\n\tstruct quota_info *dqopt = sb_dqopt(sb);\n\tstruct inode *inode;\n\tint ret = 0, cnt;\n\tunsigned int flags;\n\n\tfor (cnt = 0; cnt < MAXQUOTAS; cnt++) {\n\t\tif (type != -1 && cnt != type)\n\t\t\tcontinue;\n\n\t\tmutex_lock(&dqopt->dqonoff_mutex);\n\t\tif (!sb_has_quota_suspended(sb, cnt)) {\n\t\t\tmutex_unlock(&dqopt->dqonoff_mutex);\n\t\t\tcontinue;\n\t\t}\n\t\tinode = dqopt->files[cnt];\n\t\tdqopt->files[cnt] = NULL;\n\t\tspin_lock(&dq_state_lock);\n\t\tflags = dqopt->flags & dquot_state_flag(DQUOT_USAGE_ENABLED |\n\t\t\t\t\t\t\tDQUOT_LIMITS_ENABLED,\n\t\t\t\t\t\t\tcnt);\n\t\tdqopt->flags &= ~dquot_state_flag(DQUOT_STATE_FLAGS, cnt);\n\t\tspin_unlock(&dq_state_lock);\n\t\tmutex_unlock(&dqopt->dqonoff_mutex);\n\n\t\tflags = dquot_generic_flag(flags, cnt);\n\t\tret = vfs_load_quota_inode(inode, cnt,\n\t\t\t\tdqopt->info[cnt].dqi_fmt_id, flags);\n\t\tiput(inode);\n\t}\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sb_any_quota_suspended",
          "args": [
            "sb"
          ],
          "line": 5040
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "old_opts.s_qf_names[i]"
          ],
          "line": 5038
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_commit_super",
          "args": [
            "sb",
            "1"
          ],
          "line": 5033
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_commit_super",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/super.c",
          "lines": "4567-4634",
          "snippet": "static int ext4_commit_super(struct super_block *sb, int sync)\n{\n\tstruct ext4_super_block *es = EXT4_SB(sb)->s_es;\n\tstruct buffer_head *sbh = EXT4_SB(sb)->s_sbh;\n\tint error = 0;\n\n\tif (!sbh || block_device_ejected(sb))\n\t\treturn error;\n\tif (buffer_write_io_error(sbh)) {\n\t\t/*\n\t\t * Oh, dear.  A previous attempt to write the\n\t\t * superblock failed.  This could happen because the\n\t\t * USB device was yanked out.  Or it could happen to\n\t\t * be a transient write error and maybe the block will\n\t\t * be remapped.  Nothing we can do but to retry the\n\t\t * write and hope for the best.\n\t\t */\n\t\text4_msg(sb, KERN_ERR, \"previous I/O error to \"\n\t\t       \"superblock detected\");\n\t\tclear_buffer_write_io_error(sbh);\n\t\tset_buffer_uptodate(sbh);\n\t}\n\t/*\n\t * If the file system is mounted read-only, don't update the\n\t * superblock write time.  This avoids updating the superblock\n\t * write time when we are mounting the root file system\n\t * read/only but we need to replay the journal; at that point,\n\t * for people who are east of GMT and who make their clock\n\t * tick in localtime for Windows bug-for-bug compatibility,\n\t * the clock is set in the future, and this will cause e2fsck\n\t * to complain and force a full file system check.\n\t */\n\tif (!(sb->s_flags & MS_RDONLY))\n\t\tes->s_wtime = cpu_to_le32(get_seconds());\n\tif (sb->s_bdev->bd_part)\n\t\tes->s_kbytes_written =\n\t\t\tcpu_to_le64(EXT4_SB(sb)->s_kbytes_written +\n\t\t\t    ((part_stat_read(sb->s_bdev->bd_part, sectors[1]) -\n\t\t\t      EXT4_SB(sb)->s_sectors_written_start) >> 1));\n\telse\n\t\tes->s_kbytes_written =\n\t\t\tcpu_to_le64(EXT4_SB(sb)->s_kbytes_written);\n\tif (percpu_counter_initialized(&EXT4_SB(sb)->s_freeclusters_counter))\n\t\text4_free_blocks_count_set(es,\n\t\t\tEXT4_C2B(EXT4_SB(sb), percpu_counter_sum_positive(\n\t\t\t\t&EXT4_SB(sb)->s_freeclusters_counter)));\n\tif (percpu_counter_initialized(&EXT4_SB(sb)->s_freeinodes_counter))\n\t\tes->s_free_inodes_count =\n\t\t\tcpu_to_le32(percpu_counter_sum_positive(\n\t\t\t\t&EXT4_SB(sb)->s_freeinodes_counter));\n\tBUFFER_TRACE(sbh, \"marking dirty\");\n\text4_superblock_csum_set(sb);\n\tmark_buffer_dirty(sbh);\n\tif (sync) {\n\t\terror = sync_dirty_buffer(sbh);\n\t\tif (error)\n\t\t\treturn error;\n\n\t\terror = buffer_write_io_error(sbh);\n\t\tif (error) {\n\t\t\text4_msg(sb, KERN_ERR, \"I/O error while writing \"\n\t\t\t       \"superblock\");\n\t\t\tclear_buffer_write_io_error(sbh);\n\t\t\tset_buffer_uptodate(sbh);\n\t\t}\n\t}\n\treturn error;\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"mballoc.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include \"ext4_extents.h\"\t/* Needed for trace points definition */",
            "#include \"ext4.h\"",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/crc16.h>",
            "#include <linux/log2.h>",
            "#include <linux/ctype.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/random.h>",
            "#include <linux/vfs.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/parser.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/time.h>",
            "#include <linux/fs.h>",
            "#include <linux/string.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ext4_show_options(struct seq_file *seq, struct dentry *root);",
            "static int ext4_commit_super(struct super_block *sb, int sync);",
            "static void ext4_mark_recovery_complete(struct super_block *sb,\n\t\t\t\t\tstruct ext4_super_block *es);",
            "static void ext4_clear_journal_err(struct super_block *sb,\n\t\t\t\t   struct ext4_super_block *es);",
            "static int ext4_unfreeze(struct super_block *sb);",
            "static int ext4_freeze(struct super_block *sb);",
            "static inline int ext2_feature_set_ok(struct super_block *sb);",
            "static inline int ext3_feature_set_ok(struct super_block *sb);",
            "static void ext4_unregister_li_request(struct super_block *sb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"mballoc.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4_extents.h\"\t/* Needed for trace points definition */\n#include \"ext4.h\"\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <asm/uaccess.h>\n#include <linux/cleancache.h>\n#include <linux/crc16.h>\n#include <linux/log2.h>\n#include <linux/ctype.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/random.h>\n#include <linux/vfs.h>\n#include <linux/exportfs.h>\n#include <linux/buffer_head.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/jbd2.h>\n#include <linux/vmalloc.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n#include <linux/string.h>\n#include <linux/module.h>\n\nstatic int ext4_show_options(struct seq_file *seq, struct dentry *root);\nstatic int ext4_commit_super(struct super_block *sb, int sync);\nstatic void ext4_mark_recovery_complete(struct super_block *sb,\n\t\t\t\t\tstruct ext4_super_block *es);\nstatic void ext4_clear_journal_err(struct super_block *sb,\n\t\t\t\t   struct ext4_super_block *es);\nstatic int ext4_unfreeze(struct super_block *sb);\nstatic int ext4_freeze(struct super_block *sb);\nstatic inline int ext2_feature_set_ok(struct super_block *sb);\nstatic inline int ext3_feature_set_ok(struct super_block *sb);\nstatic void ext4_unregister_li_request(struct super_block *sb);\n\nstatic int ext4_commit_super(struct super_block *sb, int sync)\n{\n\tstruct ext4_super_block *es = EXT4_SB(sb)->s_es;\n\tstruct buffer_head *sbh = EXT4_SB(sb)->s_sbh;\n\tint error = 0;\n\n\tif (!sbh || block_device_ejected(sb))\n\t\treturn error;\n\tif (buffer_write_io_error(sbh)) {\n\t\t/*\n\t\t * Oh, dear.  A previous attempt to write the\n\t\t * superblock failed.  This could happen because the\n\t\t * USB device was yanked out.  Or it could happen to\n\t\t * be a transient write error and maybe the block will\n\t\t * be remapped.  Nothing we can do but to retry the\n\t\t * write and hope for the best.\n\t\t */\n\t\text4_msg(sb, KERN_ERR, \"previous I/O error to \"\n\t\t       \"superblock detected\");\n\t\tclear_buffer_write_io_error(sbh);\n\t\tset_buffer_uptodate(sbh);\n\t}\n\t/*\n\t * If the file system is mounted read-only, don't update the\n\t * superblock write time.  This avoids updating the superblock\n\t * write time when we are mounting the root file system\n\t * read/only but we need to replay the journal; at that point,\n\t * for people who are east of GMT and who make their clock\n\t * tick in localtime for Windows bug-for-bug compatibility,\n\t * the clock is set in the future, and this will cause e2fsck\n\t * to complain and force a full file system check.\n\t */\n\tif (!(sb->s_flags & MS_RDONLY))\n\t\tes->s_wtime = cpu_to_le32(get_seconds());\n\tif (sb->s_bdev->bd_part)\n\t\tes->s_kbytes_written =\n\t\t\tcpu_to_le64(EXT4_SB(sb)->s_kbytes_written +\n\t\t\t    ((part_stat_read(sb->s_bdev->bd_part, sectors[1]) -\n\t\t\t      EXT4_SB(sb)->s_sectors_written_start) >> 1));\n\telse\n\t\tes->s_kbytes_written =\n\t\t\tcpu_to_le64(EXT4_SB(sb)->s_kbytes_written);\n\tif (percpu_counter_initialized(&EXT4_SB(sb)->s_freeclusters_counter))\n\t\text4_free_blocks_count_set(es,\n\t\t\tEXT4_C2B(EXT4_SB(sb), percpu_counter_sum_positive(\n\t\t\t\t&EXT4_SB(sb)->s_freeclusters_counter)));\n\tif (percpu_counter_initialized(&EXT4_SB(sb)->s_freeinodes_counter))\n\t\tes->s_free_inodes_count =\n\t\t\tcpu_to_le32(percpu_counter_sum_positive(\n\t\t\t\t&EXT4_SB(sb)->s_freeinodes_counter));\n\tBUFFER_TRACE(sbh, \"marking dirty\");\n\text4_superblock_csum_set(sb);\n\tmark_buffer_dirty(sbh);\n\tif (sync) {\n\t\terror = sync_dirty_buffer(sbh);\n\t\tif (error)\n\t\t\treturn error;\n\n\t\terror = buffer_write_io_error(sbh);\n\t\tif (error) {\n\t\t\text4_msg(sb, KERN_ERR, \"I/O error while writing \"\n\t\t\t       \"superblock\");\n\t\t\tclear_buffer_write_io_error(sbh);\n\t\t\tset_buffer_uptodate(sbh);\n\t\t}\n\t}\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_setup_system_zone",
          "args": [
            "sb"
          ],
          "line": 5031
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_setup_system_zone",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/block_validity.c",
          "lines": "140-178",
          "snippet": "int ext4_setup_system_zone(struct super_block *sb)\n{\n\text4_group_t ngroups = ext4_get_groups_count(sb);\n\tstruct ext4_sb_info *sbi = EXT4_SB(sb);\n\tstruct ext4_group_desc *gdp;\n\text4_group_t i;\n\tint flex_size = ext4_flex_bg_size(sbi);\n\tint ret;\n\n\tif (!test_opt(sb, BLOCK_VALIDITY)) {\n\t\tif (EXT4_SB(sb)->system_blks.rb_node)\n\t\t\text4_release_system_zone(sb);\n\t\treturn 0;\n\t}\n\tif (EXT4_SB(sb)->system_blks.rb_node)\n\t\treturn 0;\n\n\tfor (i=0; i < ngroups; i++) {\n\t\tif (ext4_bg_has_super(sb, i) &&\n\t\t    ((i < 5) || ((i % flex_size) == 0)))\n\t\t\tadd_system_zone(sbi, ext4_group_first_block_no(sb, i),\n\t\t\t\t\text4_bg_num_gdb(sb, i) + 1);\n\t\tgdp = ext4_get_group_desc(sb, i, NULL);\n\t\tret = add_system_zone(sbi, ext4_block_bitmap(sb, gdp), 1);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tret = add_system_zone(sbi, ext4_inode_bitmap(sb, gdp), 1);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tret = add_system_zone(sbi, ext4_inode_table(sb, gdp),\n\t\t\t\tsbi->s_itb_per_group);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tif (test_opt(sb, DEBUG))\n\t\tdebug_print_tree(EXT4_SB(sb));\n\treturn 0;\n}",
          "includes": [
            "#include \"ext4.h\"",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ext4.h\"\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/blkdev.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/buffer_head.h>\n#include <linux/quotaops.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n\nint ext4_setup_system_zone(struct super_block *sb)\n{\n\text4_group_t ngroups = ext4_get_groups_count(sb);\n\tstruct ext4_sb_info *sbi = EXT4_SB(sb);\n\tstruct ext4_group_desc *gdp;\n\text4_group_t i;\n\tint flex_size = ext4_flex_bg_size(sbi);\n\tint ret;\n\n\tif (!test_opt(sb, BLOCK_VALIDITY)) {\n\t\tif (EXT4_SB(sb)->system_blks.rb_node)\n\t\t\text4_release_system_zone(sb);\n\t\treturn 0;\n\t}\n\tif (EXT4_SB(sb)->system_blks.rb_node)\n\t\treturn 0;\n\n\tfor (i=0; i < ngroups; i++) {\n\t\tif (ext4_bg_has_super(sb, i) &&\n\t\t    ((i < 5) || ((i % flex_size) == 0)))\n\t\t\tadd_system_zone(sbi, ext4_group_first_block_no(sb, i),\n\t\t\t\t\text4_bg_num_gdb(sb, i) + 1);\n\t\tgdp = ext4_get_group_desc(sb, i, NULL);\n\t\tret = add_system_zone(sbi, ext4_block_bitmap(sb, gdp), 1);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tret = add_system_zone(sbi, ext4_inode_bitmap(sb, gdp), 1);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tret = add_system_zone(sbi, ext4_inode_table(sb, gdp),\n\t\t\t\tsbi->s_itb_per_group);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tif (test_opt(sb, DEBUG))\n\t\tdebug_print_tree(EXT4_SB(sb));\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_register_li_request",
          "args": [
            "sb",
            "first_not_zeroed"
          ],
          "line": 5028
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_register_li_request",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/super.c",
          "lines": "3137-3194",
          "snippet": "int ext4_register_li_request(struct super_block *sb,\n\t\t\t     ext4_group_t first_not_zeroed)\n{\n\tstruct ext4_sb_info *sbi = EXT4_SB(sb);\n\tstruct ext4_li_request *elr = NULL;\n\text4_group_t ngroups = EXT4_SB(sb)->s_groups_count;\n\tint ret = 0;\n\n\tmutex_lock(&ext4_li_mtx);\n\tif (sbi->s_li_request != NULL) {\n\t\t/*\n\t\t * Reset timeout so it can be computed again, because\n\t\t * s_li_wait_mult might have changed.\n\t\t */\n\t\tsbi->s_li_request->lr_timeout = 0;\n\t\tgoto out;\n\t}\n\n\tif (first_not_zeroed == ngroups ||\n\t    (sb->s_flags & MS_RDONLY) ||\n\t    !test_opt(sb, INIT_INODE_TABLE))\n\t\tgoto out;\n\n\telr = ext4_li_request_new(sb, first_not_zeroed);\n\tif (!elr) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tif (NULL == ext4_li_info) {\n\t\tret = ext4_li_info_new();\n\t\tif (ret)\n\t\t\tgoto out;\n\t}\n\n\tmutex_lock(&ext4_li_info->li_list_mtx);\n\tlist_add(&elr->lr_request, &ext4_li_info->li_request_list);\n\tmutex_unlock(&ext4_li_info->li_list_mtx);\n\n\tsbi->s_li_request = elr;\n\t/*\n\t * set elr to NULL here since it has been inserted to\n\t * the request_list and the removal and free of it is\n\t * handled by ext4_clear_request_list from now on.\n\t */\n\telr = NULL;\n\n\tif (!(ext4_li_info->li_state & EXT4_LAZYINIT_RUNNING)) {\n\t\tret = ext4_run_lazyinit_thread();\n\t\tif (ret)\n\t\t\tgoto out;\n\t}\nout:\n\tmutex_unlock(&ext4_li_mtx);\n\tif (ret)\n\t\tkfree(elr);\n\treturn ret;\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"mballoc.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include \"ext4_extents.h\"\t/* Needed for trace points definition */",
            "#include \"ext4.h\"",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/crc16.h>",
            "#include <linux/log2.h>",
            "#include <linux/ctype.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/random.h>",
            "#include <linux/vfs.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/parser.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/time.h>",
            "#include <linux/fs.h>",
            "#include <linux/string.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct ext4_lazy_init *ext4_li_info;",
            "static struct mutex ext4_li_mtx;",
            "static int ext4_unfreeze(struct super_block *sb);",
            "static int ext4_freeze(struct super_block *sb);",
            "static inline int ext2_feature_set_ok(struct super_block *sb);",
            "static inline int ext3_feature_set_ok(struct super_block *sb);",
            "static void ext4_unregister_li_request(struct super_block *sb);",
            "static void ext4_clear_request_list(void);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"mballoc.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4_extents.h\"\t/* Needed for trace points definition */\n#include \"ext4.h\"\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <asm/uaccess.h>\n#include <linux/cleancache.h>\n#include <linux/crc16.h>\n#include <linux/log2.h>\n#include <linux/ctype.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/random.h>\n#include <linux/vfs.h>\n#include <linux/exportfs.h>\n#include <linux/buffer_head.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/jbd2.h>\n#include <linux/vmalloc.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n#include <linux/string.h>\n#include <linux/module.h>\n\nstatic struct ext4_lazy_init *ext4_li_info;\nstatic struct mutex ext4_li_mtx;\nstatic int ext4_unfreeze(struct super_block *sb);\nstatic int ext4_freeze(struct super_block *sb);\nstatic inline int ext2_feature_set_ok(struct super_block *sb);\nstatic inline int ext3_feature_set_ok(struct super_block *sb);\nstatic void ext4_unregister_li_request(struct super_block *sb);\nstatic void ext4_clear_request_list(void);\n\nint ext4_register_li_request(struct super_block *sb,\n\t\t\t     ext4_group_t first_not_zeroed)\n{\n\tstruct ext4_sb_info *sbi = EXT4_SB(sb);\n\tstruct ext4_li_request *elr = NULL;\n\text4_group_t ngroups = EXT4_SB(sb)->s_groups_count;\n\tint ret = 0;\n\n\tmutex_lock(&ext4_li_mtx);\n\tif (sbi->s_li_request != NULL) {\n\t\t/*\n\t\t * Reset timeout so it can be computed again, because\n\t\t * s_li_wait_mult might have changed.\n\t\t */\n\t\tsbi->s_li_request->lr_timeout = 0;\n\t\tgoto out;\n\t}\n\n\tif (first_not_zeroed == ngroups ||\n\t    (sb->s_flags & MS_RDONLY) ||\n\t    !test_opt(sb, INIT_INODE_TABLE))\n\t\tgoto out;\n\n\telr = ext4_li_request_new(sb, first_not_zeroed);\n\tif (!elr) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tif (NULL == ext4_li_info) {\n\t\tret = ext4_li_info_new();\n\t\tif (ret)\n\t\t\tgoto out;\n\t}\n\n\tmutex_lock(&ext4_li_info->li_list_mtx);\n\tlist_add(&elr->lr_request, &ext4_li_info->li_request_list);\n\tmutex_unlock(&ext4_li_info->li_list_mtx);\n\n\tsbi->s_li_request = elr;\n\t/*\n\t * set elr to NULL here since it has been inserted to\n\t * the request_list and the removal and free of it is\n\t * handled by ext4_clear_request_list from now on.\n\t */\n\telr = NULL;\n\n\tif (!(ext4_li_info->li_state & EXT4_LAZYINIT_RUNNING)) {\n\t\tret = ext4_run_lazyinit_thread();\n\t\tif (ret)\n\t\t\tgoto out;\n\t}\nout:\n\tmutex_unlock(&ext4_li_mtx);\n\tif (ret)\n\t\tkfree(elr);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_has_uninit_itable",
          "args": [
            "sb"
          ],
          "line": 5027
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_has_uninit_itable",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/super.c",
          "lines": "3078-3093",
          "snippet": "static ext4_group_t ext4_has_uninit_itable(struct super_block *sb)\n{\n\text4_group_t group, ngroups = EXT4_SB(sb)->s_groups_count;\n\tstruct ext4_group_desc *gdp = NULL;\n\n\tfor (group = 0; group < ngroups; group++) {\n\t\tgdp = ext4_get_group_desc(sb, group, NULL);\n\t\tif (!gdp)\n\t\t\tcontinue;\n\n\t\tif (!(gdp->bg_flags & cpu_to_le16(EXT4_BG_INODE_ZEROED)))\n\t\t\tbreak;\n\t}\n\n\treturn group;\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"mballoc.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include \"ext4_extents.h\"\t/* Needed for trace points definition */",
            "#include \"ext4.h\"",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/crc16.h>",
            "#include <linux/log2.h>",
            "#include <linux/ctype.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/random.h>",
            "#include <linux/vfs.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/parser.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/time.h>",
            "#include <linux/fs.h>",
            "#include <linux/string.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ext4_unfreeze(struct super_block *sb);",
            "static int ext4_freeze(struct super_block *sb);",
            "static inline int ext2_feature_set_ok(struct super_block *sb);",
            "static inline int ext3_feature_set_ok(struct super_block *sb);",
            "static void ext4_unregister_li_request(struct super_block *sb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"mballoc.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4_extents.h\"\t/* Needed for trace points definition */\n#include \"ext4.h\"\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <asm/uaccess.h>\n#include <linux/cleancache.h>\n#include <linux/crc16.h>\n#include <linux/log2.h>\n#include <linux/ctype.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/random.h>\n#include <linux/vfs.h>\n#include <linux/exportfs.h>\n#include <linux/buffer_head.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/jbd2.h>\n#include <linux/vmalloc.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n#include <linux/string.h>\n#include <linux/module.h>\n\nstatic int ext4_unfreeze(struct super_block *sb);\nstatic int ext4_freeze(struct super_block *sb);\nstatic inline int ext2_feature_set_ok(struct super_block *sb);\nstatic inline int ext3_feature_set_ok(struct super_block *sb);\nstatic void ext4_unregister_li_request(struct super_block *sb);\n\nstatic ext4_group_t ext4_has_uninit_itable(struct super_block *sb)\n{\n\text4_group_t group, ngroups = EXT4_SB(sb)->s_groups_count;\n\tstruct ext4_group_desc *gdp = NULL;\n\n\tfor (group = 0; group < ngroups; group++) {\n\t\tgdp = ext4_get_group_desc(sb, group, NULL);\n\t\tif (!gdp)\n\t\t\tcontinue;\n\n\t\tif (!(gdp->bg_flags & cpu_to_le16(EXT4_BG_INODE_ZEROED)))\n\t\t\tbreak;\n\t}\n\n\treturn group;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_unregister_li_request",
          "args": [
            "sb"
          ],
          "line": 5024
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_unregister_li_request",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/super.c",
          "lines": "2938-2950",
          "snippet": "static void ext4_unregister_li_request(struct super_block *sb)\n{\n\tmutex_lock(&ext4_li_mtx);\n\tif (!ext4_li_info) {\n\t\tmutex_unlock(&ext4_li_mtx);\n\t\treturn;\n\t}\n\n\tmutex_lock(&ext4_li_info->li_list_mtx);\n\text4_remove_li_request(EXT4_SB(sb)->s_li_request);\n\tmutex_unlock(&ext4_li_info->li_list_mtx);\n\tmutex_unlock(&ext4_li_mtx);\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"mballoc.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include \"ext4_extents.h\"\t/* Needed for trace points definition */",
            "#include \"ext4.h\"",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/crc16.h>",
            "#include <linux/log2.h>",
            "#include <linux/ctype.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/random.h>",
            "#include <linux/vfs.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/parser.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/time.h>",
            "#include <linux/fs.h>",
            "#include <linux/string.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct ext4_lazy_init *ext4_li_info;",
            "static struct mutex ext4_li_mtx;",
            "static int ext4_unfreeze(struct super_block *sb);",
            "static int ext4_freeze(struct super_block *sb);",
            "static inline int ext2_feature_set_ok(struct super_block *sb);",
            "static inline int ext3_feature_set_ok(struct super_block *sb);",
            "static void ext4_unregister_li_request(struct super_block *sb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"mballoc.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4_extents.h\"\t/* Needed for trace points definition */\n#include \"ext4.h\"\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <asm/uaccess.h>\n#include <linux/cleancache.h>\n#include <linux/crc16.h>\n#include <linux/log2.h>\n#include <linux/ctype.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/random.h>\n#include <linux/vfs.h>\n#include <linux/exportfs.h>\n#include <linux/buffer_head.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/jbd2.h>\n#include <linux/vmalloc.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n#include <linux/string.h>\n#include <linux/module.h>\n\nstatic struct ext4_lazy_init *ext4_li_info;\nstatic struct mutex ext4_li_mtx;\nstatic int ext4_unfreeze(struct super_block *sb);\nstatic int ext4_freeze(struct super_block *sb);\nstatic inline int ext2_feature_set_ok(struct super_block *sb);\nstatic inline int ext3_feature_set_ok(struct super_block *sb);\nstatic void ext4_unregister_li_request(struct super_block *sb);\n\nstatic void ext4_unregister_li_request(struct super_block *sb)\n{\n\tmutex_lock(&ext4_li_mtx);\n\tif (!ext4_li_info) {\n\t\tmutex_unlock(&ext4_li_mtx);\n\t\treturn;\n\t}\n\n\tmutex_lock(&ext4_li_info->li_list_mtx);\n\text4_remove_li_request(EXT4_SB(sb)->s_li_request);\n\tmutex_unlock(&ext4_li_info->li_list_mtx);\n\tmutex_unlock(&ext4_li_mtx);\n}"
        }
      },
      {
        "call_info": {
          "callee": "test_opt",
          "args": [
            "sb",
            "INIT_INODE_TABLE"
          ],
          "line": 5023
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_multi_mount_protect",
          "args": [
            "sb",
            "le64_to_cpu(es->s_mmp_block)"
          ],
          "line": 5010
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_multi_mount_protect",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/mmp.c",
          "lines": "269-391",
          "snippet": "int ext4_multi_mount_protect(struct super_block *sb,\n\t\t\t\t    ext4_fsblk_t mmp_block)\n{\n\tstruct ext4_super_block *es = EXT4_SB(sb)->s_es;\n\tstruct buffer_head *bh = NULL;\n\tstruct mmp_struct *mmp = NULL;\n\tstruct mmpd_data *mmpd_data;\n\tu32 seq;\n\tunsigned int mmp_check_interval = le16_to_cpu(es->s_mmp_update_interval);\n\tunsigned int wait_time = 0;\n\tint retval;\n\n\tif (mmp_block < le32_to_cpu(es->s_first_data_block) ||\n\t    mmp_block >= ext4_blocks_count(es)) {\n\t\text4_warning(sb, \"Invalid MMP block in superblock\");\n\t\tgoto failed;\n\t}\n\n\tretval = read_mmp_block(sb, &bh, mmp_block);\n\tif (retval)\n\t\tgoto failed;\n\n\tmmp = (struct mmp_struct *)(bh->b_data);\n\n\tif (mmp_check_interval < EXT4_MMP_MIN_CHECK_INTERVAL)\n\t\tmmp_check_interval = EXT4_MMP_MIN_CHECK_INTERVAL;\n\n\t/*\n\t * If check_interval in MMP block is larger, use that instead of\n\t * update_interval from the superblock.\n\t */\n\tif (le16_to_cpu(mmp->mmp_check_interval) > mmp_check_interval)\n\t\tmmp_check_interval = le16_to_cpu(mmp->mmp_check_interval);\n\n\tseq = le32_to_cpu(mmp->mmp_seq);\n\tif (seq == EXT4_MMP_SEQ_CLEAN)\n\t\tgoto skip;\n\n\tif (seq == EXT4_MMP_SEQ_FSCK) {\n\t\tdump_mmp_msg(sb, mmp, \"fsck is running on the filesystem\");\n\t\tgoto failed;\n\t}\n\n\twait_time = min(mmp_check_interval * 2 + 1,\n\t\t\tmmp_check_interval + 60);\n\n\t/* Print MMP interval if more than 20 secs. */\n\tif (wait_time > EXT4_MMP_MIN_CHECK_INTERVAL * 4)\n\t\text4_warning(sb, \"MMP interval %u higher than expected, please\"\n\t\t\t     \" wait.\\n\", wait_time * 2);\n\n\tif (schedule_timeout_interruptible(HZ * wait_time) != 0) {\n\t\text4_warning(sb, \"MMP startup interrupted, failing mount\\n\");\n\t\tgoto failed;\n\t}\n\n\tretval = read_mmp_block(sb, &bh, mmp_block);\n\tif (retval)\n\t\tgoto failed;\n\tmmp = (struct mmp_struct *)(bh->b_data);\n\tif (seq != le32_to_cpu(mmp->mmp_seq)) {\n\t\tdump_mmp_msg(sb, mmp,\n\t\t\t     \"Device is already active on another node.\");\n\t\tgoto failed;\n\t}\n\nskip:\n\t/*\n\t * write a new random sequence number.\n\t */\n\tseq = mmp_new_seq();\n\tmmp->mmp_seq = cpu_to_le32(seq);\n\n\tretval = write_mmp_block(sb, bh);\n\tif (retval)\n\t\tgoto failed;\n\n\t/*\n\t * wait for MMP interval and check mmp_seq.\n\t */\n\tif (schedule_timeout_interruptible(HZ * wait_time) != 0) {\n\t\text4_warning(sb, \"MMP startup interrupted, failing mount\\n\");\n\t\tgoto failed;\n\t}\n\n\tretval = read_mmp_block(sb, &bh, mmp_block);\n\tif (retval)\n\t\tgoto failed;\n\tmmp = (struct mmp_struct *)(bh->b_data);\n\tif (seq != le32_to_cpu(mmp->mmp_seq)) {\n\t\tdump_mmp_msg(sb, mmp,\n\t\t\t     \"Device is already active on another node.\");\n\t\tgoto failed;\n\t}\n\n\tmmpd_data = kmalloc(sizeof(struct mmpd_data), GFP_KERNEL);\n\tif (!mmpd_data) {\n\t\text4_warning(sb, \"not enough memory for mmpd_data\");\n\t\tgoto failed;\n\t}\n\tmmpd_data->sb = sb;\n\tmmpd_data->bh = bh;\n\n\t/*\n\t * Start a kernel thread to update the MMP block periodically.\n\t */\n\tEXT4_SB(sb)->s_mmp_tsk = kthread_run(kmmpd, mmpd_data, \"kmmpd-%s\",\n\t\t\t\t\t     bdevname(bh->b_bdev,\n\t\t\t\t\t\t      mmp->mmp_bdevname));\n\tif (IS_ERR(EXT4_SB(sb)->s_mmp_tsk)) {\n\t\tEXT4_SB(sb)->s_mmp_tsk = NULL;\n\t\tkfree(mmpd_data);\n\t\text4_warning(sb, \"Unable to create kmmpd thread for %s.\",\n\t\t\t     sb->s_id);\n\t\tgoto failed;\n\t}\n\n\treturn 0;\n\nfailed:\n\tbrelse(bh);\n\treturn 1;\n}",
          "includes": [
            "#include \"ext4.h\"",
            "#include <linux/kthread.h>",
            "#include <linux/utsname.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/random.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ext4.h\"\n#include <linux/kthread.h>\n#include <linux/utsname.h>\n#include <linux/buffer_head.h>\n#include <linux/random.h>\n#include <linux/fs.h>\n\nint ext4_multi_mount_protect(struct super_block *sb,\n\t\t\t\t    ext4_fsblk_t mmp_block)\n{\n\tstruct ext4_super_block *es = EXT4_SB(sb)->s_es;\n\tstruct buffer_head *bh = NULL;\n\tstruct mmp_struct *mmp = NULL;\n\tstruct mmpd_data *mmpd_data;\n\tu32 seq;\n\tunsigned int mmp_check_interval = le16_to_cpu(es->s_mmp_update_interval);\n\tunsigned int wait_time = 0;\n\tint retval;\n\n\tif (mmp_block < le32_to_cpu(es->s_first_data_block) ||\n\t    mmp_block >= ext4_blocks_count(es)) {\n\t\text4_warning(sb, \"Invalid MMP block in superblock\");\n\t\tgoto failed;\n\t}\n\n\tretval = read_mmp_block(sb, &bh, mmp_block);\n\tif (retval)\n\t\tgoto failed;\n\n\tmmp = (struct mmp_struct *)(bh->b_data);\n\n\tif (mmp_check_interval < EXT4_MMP_MIN_CHECK_INTERVAL)\n\t\tmmp_check_interval = EXT4_MMP_MIN_CHECK_INTERVAL;\n\n\t/*\n\t * If check_interval in MMP block is larger, use that instead of\n\t * update_interval from the superblock.\n\t */\n\tif (le16_to_cpu(mmp->mmp_check_interval) > mmp_check_interval)\n\t\tmmp_check_interval = le16_to_cpu(mmp->mmp_check_interval);\n\n\tseq = le32_to_cpu(mmp->mmp_seq);\n\tif (seq == EXT4_MMP_SEQ_CLEAN)\n\t\tgoto skip;\n\n\tif (seq == EXT4_MMP_SEQ_FSCK) {\n\t\tdump_mmp_msg(sb, mmp, \"fsck is running on the filesystem\");\n\t\tgoto failed;\n\t}\n\n\twait_time = min(mmp_check_interval * 2 + 1,\n\t\t\tmmp_check_interval + 60);\n\n\t/* Print MMP interval if more than 20 secs. */\n\tif (wait_time > EXT4_MMP_MIN_CHECK_INTERVAL * 4)\n\t\text4_warning(sb, \"MMP interval %u higher than expected, please\"\n\t\t\t     \" wait.\\n\", wait_time * 2);\n\n\tif (schedule_timeout_interruptible(HZ * wait_time) != 0) {\n\t\text4_warning(sb, \"MMP startup interrupted, failing mount\\n\");\n\t\tgoto failed;\n\t}\n\n\tretval = read_mmp_block(sb, &bh, mmp_block);\n\tif (retval)\n\t\tgoto failed;\n\tmmp = (struct mmp_struct *)(bh->b_data);\n\tif (seq != le32_to_cpu(mmp->mmp_seq)) {\n\t\tdump_mmp_msg(sb, mmp,\n\t\t\t     \"Device is already active on another node.\");\n\t\tgoto failed;\n\t}\n\nskip:\n\t/*\n\t * write a new random sequence number.\n\t */\n\tseq = mmp_new_seq();\n\tmmp->mmp_seq = cpu_to_le32(seq);\n\n\tretval = write_mmp_block(sb, bh);\n\tif (retval)\n\t\tgoto failed;\n\n\t/*\n\t * wait for MMP interval and check mmp_seq.\n\t */\n\tif (schedule_timeout_interruptible(HZ * wait_time) != 0) {\n\t\text4_warning(sb, \"MMP startup interrupted, failing mount\\n\");\n\t\tgoto failed;\n\t}\n\n\tretval = read_mmp_block(sb, &bh, mmp_block);\n\tif (retval)\n\t\tgoto failed;\n\tmmp = (struct mmp_struct *)(bh->b_data);\n\tif (seq != le32_to_cpu(mmp->mmp_seq)) {\n\t\tdump_mmp_msg(sb, mmp,\n\t\t\t     \"Device is already active on another node.\");\n\t\tgoto failed;\n\t}\n\n\tmmpd_data = kmalloc(sizeof(struct mmpd_data), GFP_KERNEL);\n\tif (!mmpd_data) {\n\t\text4_warning(sb, \"not enough memory for mmpd_data\");\n\t\tgoto failed;\n\t}\n\tmmpd_data->sb = sb;\n\tmmpd_data->bh = bh;\n\n\t/*\n\t * Start a kernel thread to update the MMP block periodically.\n\t */\n\tEXT4_SB(sb)->s_mmp_tsk = kthread_run(kmmpd, mmpd_data, \"kmmpd-%s\",\n\t\t\t\t\t     bdevname(bh->b_bdev,\n\t\t\t\t\t\t      mmp->mmp_bdevname));\n\tif (IS_ERR(EXT4_SB(sb)->s_mmp_tsk)) {\n\t\tEXT4_SB(sb)->s_mmp_tsk = NULL;\n\t\tkfree(mmpd_data);\n\t\text4_warning(sb, \"Unable to create kmmpd thread for %s.\",\n\t\t\t     sb->s_id);\n\t\tgoto failed;\n\t}\n\n\treturn 0;\n\nfailed:\n\tbrelse(bh);\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "le64_to_cpu",
          "args": [
            "es->s_mmp_block"
          ],
          "line": 5011
        },
        "resolved": true,
        "details": {
          "function_name": "sle64_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "58-61",
          "snippet": "static inline s64 sle64_to_cpup(sle64 *x)\n{\n\treturn le64_to_cpu(*(__force le64*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s64 sle64_to_cpup(sle64 *x)\n{\n\treturn le64_to_cpu(*(__force le64*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "EXT4_HAS_INCOMPAT_FEATURE",
          "args": [
            "sb",
            "EXT4_FEATURE_INCOMPAT_MMP"
          ],
          "line": 5008
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_setup_super",
          "args": [
            "sb",
            "es",
            "0"
          ],
          "line": 5006
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_setup_super",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/super.c",
          "lines": "1869-1924",
          "snippet": "static int ext4_setup_super(struct super_block *sb, struct ext4_super_block *es,\n\t\t\t    int read_only)\n{\n\tstruct ext4_sb_info *sbi = EXT4_SB(sb);\n\tint res = 0;\n\n\tif (le32_to_cpu(es->s_rev_level) > EXT4_MAX_SUPP_REV) {\n\t\text4_msg(sb, KERN_ERR, \"revision level too high, \"\n\t\t\t \"forcing read-only mode\");\n\t\tres = MS_RDONLY;\n\t}\n\tif (read_only)\n\t\tgoto done;\n\tif (!(sbi->s_mount_state & EXT4_VALID_FS))\n\t\text4_msg(sb, KERN_WARNING, \"warning: mounting unchecked fs, \"\n\t\t\t \"running e2fsck is recommended\");\n\telse if (sbi->s_mount_state & EXT4_ERROR_FS)\n\t\text4_msg(sb, KERN_WARNING,\n\t\t\t \"warning: mounting fs with errors, \"\n\t\t\t \"running e2fsck is recommended\");\n\telse if ((__s16) le16_to_cpu(es->s_max_mnt_count) > 0 &&\n\t\t le16_to_cpu(es->s_mnt_count) >=\n\t\t (unsigned short) (__s16) le16_to_cpu(es->s_max_mnt_count))\n\t\text4_msg(sb, KERN_WARNING,\n\t\t\t \"warning: maximal mount count reached, \"\n\t\t\t \"running e2fsck is recommended\");\n\telse if (le32_to_cpu(es->s_checkinterval) &&\n\t\t(le32_to_cpu(es->s_lastcheck) +\n\t\t\tle32_to_cpu(es->s_checkinterval) <= get_seconds()))\n\t\text4_msg(sb, KERN_WARNING,\n\t\t\t \"warning: checktime reached, \"\n\t\t\t \"running e2fsck is recommended\");\n\tif (!sbi->s_journal)\n\t\tes->s_state &= cpu_to_le16(~EXT4_VALID_FS);\n\tif (!(__s16) le16_to_cpu(es->s_max_mnt_count))\n\t\tes->s_max_mnt_count = cpu_to_le16(EXT4_DFL_MAX_MNT_COUNT);\n\tle16_add_cpu(&es->s_mnt_count, 1);\n\tes->s_mtime = cpu_to_le32(get_seconds());\n\text4_update_dynamic_rev(sb);\n\tif (sbi->s_journal)\n\t\tEXT4_SET_INCOMPAT_FEATURE(sb, EXT4_FEATURE_INCOMPAT_RECOVER);\n\n\text4_commit_super(sb, 1);\ndone:\n\tif (test_opt(sb, DEBUG))\n\t\tprintk(KERN_INFO \"[EXT4 FS bs=%lu, gc=%u, \"\n\t\t\t\t\"bpg=%lu, ipg=%lu, mo=%04x, mo2=%04x]\\n\",\n\t\t\tsb->s_blocksize,\n\t\t\tsbi->s_groups_count,\n\t\t\tEXT4_BLOCKS_PER_GROUP(sb),\n\t\t\tEXT4_INODES_PER_GROUP(sb),\n\t\t\tsbi->s_mount_opt, sbi->s_mount_opt2);\n\n\tcleancache_init_fs(sb);\n\treturn res;\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"mballoc.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include \"ext4_extents.h\"\t/* Needed for trace points definition */",
            "#include \"ext4.h\"",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/crc16.h>",
            "#include <linux/log2.h>",
            "#include <linux/ctype.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/random.h>",
            "#include <linux/vfs.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/parser.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/time.h>",
            "#include <linux/fs.h>",
            "#include <linux/string.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void ext4_mark_recovery_complete(struct super_block *sb,\n\t\t\t\t\tstruct ext4_super_block *es);",
            "static void ext4_clear_journal_err(struct super_block *sb,\n\t\t\t\t   struct ext4_super_block *es);",
            "static int ext4_unfreeze(struct super_block *sb);",
            "static int ext4_freeze(struct super_block *sb);",
            "static inline int ext2_feature_set_ok(struct super_block *sb);",
            "static inline int ext3_feature_set_ok(struct super_block *sb);",
            "static void ext4_unregister_li_request(struct super_block *sb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"mballoc.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4_extents.h\"\t/* Needed for trace points definition */\n#include \"ext4.h\"\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <asm/uaccess.h>\n#include <linux/cleancache.h>\n#include <linux/crc16.h>\n#include <linux/log2.h>\n#include <linux/ctype.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/random.h>\n#include <linux/vfs.h>\n#include <linux/exportfs.h>\n#include <linux/buffer_head.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/jbd2.h>\n#include <linux/vmalloc.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n#include <linux/string.h>\n#include <linux/module.h>\n\nstatic void ext4_mark_recovery_complete(struct super_block *sb,\n\t\t\t\t\tstruct ext4_super_block *es);\nstatic void ext4_clear_journal_err(struct super_block *sb,\n\t\t\t\t   struct ext4_super_block *es);\nstatic int ext4_unfreeze(struct super_block *sb);\nstatic int ext4_freeze(struct super_block *sb);\nstatic inline int ext2_feature_set_ok(struct super_block *sb);\nstatic inline int ext3_feature_set_ok(struct super_block *sb);\nstatic void ext4_unregister_li_request(struct super_block *sb);\n\nstatic int ext4_setup_super(struct super_block *sb, struct ext4_super_block *es,\n\t\t\t    int read_only)\n{\n\tstruct ext4_sb_info *sbi = EXT4_SB(sb);\n\tint res = 0;\n\n\tif (le32_to_cpu(es->s_rev_level) > EXT4_MAX_SUPP_REV) {\n\t\text4_msg(sb, KERN_ERR, \"revision level too high, \"\n\t\t\t \"forcing read-only mode\");\n\t\tres = MS_RDONLY;\n\t}\n\tif (read_only)\n\t\tgoto done;\n\tif (!(sbi->s_mount_state & EXT4_VALID_FS))\n\t\text4_msg(sb, KERN_WARNING, \"warning: mounting unchecked fs, \"\n\t\t\t \"running e2fsck is recommended\");\n\telse if (sbi->s_mount_state & EXT4_ERROR_FS)\n\t\text4_msg(sb, KERN_WARNING,\n\t\t\t \"warning: mounting fs with errors, \"\n\t\t\t \"running e2fsck is recommended\");\n\telse if ((__s16) le16_to_cpu(es->s_max_mnt_count) > 0 &&\n\t\t le16_to_cpu(es->s_mnt_count) >=\n\t\t (unsigned short) (__s16) le16_to_cpu(es->s_max_mnt_count))\n\t\text4_msg(sb, KERN_WARNING,\n\t\t\t \"warning: maximal mount count reached, \"\n\t\t\t \"running e2fsck is recommended\");\n\telse if (le32_to_cpu(es->s_checkinterval) &&\n\t\t(le32_to_cpu(es->s_lastcheck) +\n\t\t\tle32_to_cpu(es->s_checkinterval) <= get_seconds()))\n\t\text4_msg(sb, KERN_WARNING,\n\t\t\t \"warning: checktime reached, \"\n\t\t\t \"running e2fsck is recommended\");\n\tif (!sbi->s_journal)\n\t\tes->s_state &= cpu_to_le16(~EXT4_VALID_FS);\n\tif (!(__s16) le16_to_cpu(es->s_max_mnt_count))\n\t\tes->s_max_mnt_count = cpu_to_le16(EXT4_DFL_MAX_MNT_COUNT);\n\tle16_add_cpu(&es->s_mnt_count, 1);\n\tes->s_mtime = cpu_to_le32(get_seconds());\n\text4_update_dynamic_rev(sb);\n\tif (sbi->s_journal)\n\t\tEXT4_SET_INCOMPAT_FEATURE(sb, EXT4_FEATURE_INCOMPAT_RECOVER);\n\n\text4_commit_super(sb, 1);\ndone:\n\tif (test_opt(sb, DEBUG))\n\t\tprintk(KERN_INFO \"[EXT4 FS bs=%lu, gc=%u, \"\n\t\t\t\t\"bpg=%lu, ipg=%lu, mo=%04x, mo2=%04x]\\n\",\n\t\t\tsb->s_blocksize,\n\t\t\tsbi->s_groups_count,\n\t\t\tEXT4_BLOCKS_PER_GROUP(sb),\n\t\t\tEXT4_INODES_PER_GROUP(sb),\n\t\t\tsbi->s_mount_opt, sbi->s_mount_opt2);\n\n\tcleancache_init_fs(sb);\n\treturn res;\n}"
        }
      },
      {
        "call_info": {
          "callee": "le16_to_cpu",
          "args": [
            "es->s_state"
          ],
          "line": 5005
        },
        "resolved": true,
        "details": {
          "function_name": "sle16_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "48-51",
          "snippet": "static inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_clear_journal_err",
          "args": [
            "sb",
            "es"
          ],
          "line": 5004
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_clear_journal_err",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/super.c",
          "lines": "4669-4701",
          "snippet": "static void ext4_clear_journal_err(struct super_block *sb,\n\t\t\t\t   struct ext4_super_block *es)\n{\n\tjournal_t *journal;\n\tint j_errno;\n\tconst char *errstr;\n\n\tBUG_ON(!EXT4_HAS_COMPAT_FEATURE(sb, EXT4_FEATURE_COMPAT_HAS_JOURNAL));\n\n\tjournal = EXT4_SB(sb)->s_journal;\n\n\t/*\n\t * Now check for any error status which may have been recorded in the\n\t * journal by a prior ext4_error() or ext4_abort()\n\t */\n\n\tj_errno = jbd2_journal_errno(journal);\n\tif (j_errno) {\n\t\tchar nbuf[16];\n\n\t\terrstr = ext4_decode_error(sb, j_errno, nbuf);\n\t\text4_warning(sb, \"Filesystem error recorded \"\n\t\t\t     \"from previous mount: %s\", errstr);\n\t\text4_warning(sb, \"Marking fs in need of filesystem check.\");\n\n\t\tEXT4_SB(sb)->s_mount_state |= EXT4_ERROR_FS;\n\t\tes->s_state |= cpu_to_le16(EXT4_ERROR_FS);\n\t\text4_commit_super(sb, 1);\n\n\t\tjbd2_journal_clear_err(journal);\n\t\tjbd2_journal_update_sb_errno(journal);\n\t}\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"mballoc.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include \"ext4_extents.h\"\t/* Needed for trace points definition */",
            "#include \"ext4.h\"",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/crc16.h>",
            "#include <linux/log2.h>",
            "#include <linux/ctype.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/random.h>",
            "#include <linux/vfs.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/parser.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/time.h>",
            "#include <linux/fs.h>",
            "#include <linux/string.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void ext4_mark_recovery_complete(struct super_block *sb,\n\t\t\t\t\tstruct ext4_super_block *es);",
            "static void ext4_clear_journal_err(struct super_block *sb,\n\t\t\t\t   struct ext4_super_block *es);",
            "static int ext4_unfreeze(struct super_block *sb);",
            "static int ext4_freeze(struct super_block *sb);",
            "static inline int ext2_feature_set_ok(struct super_block *sb);",
            "static inline int ext3_feature_set_ok(struct super_block *sb);",
            "static void ext4_unregister_li_request(struct super_block *sb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"mballoc.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4_extents.h\"\t/* Needed for trace points definition */\n#include \"ext4.h\"\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <asm/uaccess.h>\n#include <linux/cleancache.h>\n#include <linux/crc16.h>\n#include <linux/log2.h>\n#include <linux/ctype.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/random.h>\n#include <linux/vfs.h>\n#include <linux/exportfs.h>\n#include <linux/buffer_head.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/jbd2.h>\n#include <linux/vmalloc.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n#include <linux/string.h>\n#include <linux/module.h>\n\nstatic void ext4_mark_recovery_complete(struct super_block *sb,\n\t\t\t\t\tstruct ext4_super_block *es);\nstatic void ext4_clear_journal_err(struct super_block *sb,\n\t\t\t\t   struct ext4_super_block *es);\nstatic int ext4_unfreeze(struct super_block *sb);\nstatic int ext4_freeze(struct super_block *sb);\nstatic inline int ext2_feature_set_ok(struct super_block *sb);\nstatic inline int ext3_feature_set_ok(struct super_block *sb);\nstatic void ext4_unregister_li_request(struct super_block *sb);\n\nstatic void ext4_clear_journal_err(struct super_block *sb,\n\t\t\t\t   struct ext4_super_block *es)\n{\n\tjournal_t *journal;\n\tint j_errno;\n\tconst char *errstr;\n\n\tBUG_ON(!EXT4_HAS_COMPAT_FEATURE(sb, EXT4_FEATURE_COMPAT_HAS_JOURNAL));\n\n\tjournal = EXT4_SB(sb)->s_journal;\n\n\t/*\n\t * Now check for any error status which may have been recorded in the\n\t * journal by a prior ext4_error() or ext4_abort()\n\t */\n\n\tj_errno = jbd2_journal_errno(journal);\n\tif (j_errno) {\n\t\tchar nbuf[16];\n\n\t\terrstr = ext4_decode_error(sb, j_errno, nbuf);\n\t\text4_warning(sb, \"Filesystem error recorded \"\n\t\t\t     \"from previous mount: %s\", errstr);\n\t\text4_warning(sb, \"Marking fs in need of filesystem check.\");\n\n\t\tEXT4_SB(sb)->s_mount_state |= EXT4_ERROR_FS;\n\t\tes->s_state |= cpu_to_le16(EXT4_ERROR_FS);\n\t\text4_commit_super(sb, 1);\n\n\t\tjbd2_journal_clear_err(journal);\n\t\tjbd2_journal_update_sb_errno(journal);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_group_desc_csum",
          "args": [
            "sbi",
            "g",
            "gdp"
          ],
          "line": 4976
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_group_desc_csum_set",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/super.c",
          "lines": "2050-2056",
          "snippet": "void ext4_group_desc_csum_set(struct super_block *sb, __u32 block_group,\n\t\t\t      struct ext4_group_desc *gdp)\n{\n\tif (!ext4_has_group_desc_csum(sb))\n\t\treturn;\n\tgdp->bg_checksum = ext4_group_desc_csum(EXT4_SB(sb), block_group, gdp);\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"mballoc.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include \"ext4_extents.h\"\t/* Needed for trace points definition */",
            "#include \"ext4.h\"",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/crc16.h>",
            "#include <linux/log2.h>",
            "#include <linux/ctype.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/random.h>",
            "#include <linux/vfs.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/parser.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/time.h>",
            "#include <linux/fs.h>",
            "#include <linux/string.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ext4_unfreeze(struct super_block *sb);",
            "static int ext4_freeze(struct super_block *sb);",
            "static inline int ext2_feature_set_ok(struct super_block *sb);",
            "static inline int ext3_feature_set_ok(struct super_block *sb);",
            "static void ext4_unregister_li_request(struct super_block *sb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"mballoc.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4_extents.h\"\t/* Needed for trace points definition */\n#include \"ext4.h\"\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <asm/uaccess.h>\n#include <linux/cleancache.h>\n#include <linux/crc16.h>\n#include <linux/log2.h>\n#include <linux/ctype.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/random.h>\n#include <linux/vfs.h>\n#include <linux/exportfs.h>\n#include <linux/buffer_head.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/jbd2.h>\n#include <linux/vmalloc.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n#include <linux/string.h>\n#include <linux/module.h>\n\nstatic int ext4_unfreeze(struct super_block *sb);\nstatic int ext4_freeze(struct super_block *sb);\nstatic inline int ext2_feature_set_ok(struct super_block *sb);\nstatic inline int ext3_feature_set_ok(struct super_block *sb);\nstatic void ext4_unregister_li_request(struct super_block *sb);\n\nvoid ext4_group_desc_csum_set(struct super_block *sb, __u32 block_group,\n\t\t\t      struct ext4_group_desc *gdp)\n{\n\tif (!ext4_has_group_desc_csum(sb))\n\t\treturn;\n\tgdp->bg_checksum = ext4_group_desc_csum(EXT4_SB(sb), block_group, gdp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_group_desc_csum_verify",
          "args": [
            "sb",
            "g",
            "gdp"
          ],
          "line": 4973
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_group_desc_csum_verify",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/super.c",
          "lines": "2039-2048",
          "snippet": "int ext4_group_desc_csum_verify(struct super_block *sb, __u32 block_group,\n\t\t\t\tstruct ext4_group_desc *gdp)\n{\n\tif (ext4_has_group_desc_csum(sb) &&\n\t    (gdp->bg_checksum != ext4_group_desc_csum(EXT4_SB(sb),\n\t\t\t\t\t\t      block_group, gdp)))\n\t\treturn 0;\n\n\treturn 1;\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"mballoc.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include \"ext4_extents.h\"\t/* Needed for trace points definition */",
            "#include \"ext4.h\"",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/crc16.h>",
            "#include <linux/log2.h>",
            "#include <linux/ctype.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/random.h>",
            "#include <linux/vfs.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/parser.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/time.h>",
            "#include <linux/fs.h>",
            "#include <linux/string.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ext4_unfreeze(struct super_block *sb);",
            "static int ext4_freeze(struct super_block *sb);",
            "static inline int ext2_feature_set_ok(struct super_block *sb);",
            "static inline int ext3_feature_set_ok(struct super_block *sb);",
            "static void ext4_unregister_li_request(struct super_block *sb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"mballoc.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4_extents.h\"\t/* Needed for trace points definition */\n#include \"ext4.h\"\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <asm/uaccess.h>\n#include <linux/cleancache.h>\n#include <linux/crc16.h>\n#include <linux/log2.h>\n#include <linux/ctype.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/random.h>\n#include <linux/vfs.h>\n#include <linux/exportfs.h>\n#include <linux/buffer_head.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/jbd2.h>\n#include <linux/vmalloc.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n#include <linux/string.h>\n#include <linux/module.h>\n\nstatic int ext4_unfreeze(struct super_block *sb);\nstatic int ext4_freeze(struct super_block *sb);\nstatic inline int ext2_feature_set_ok(struct super_block *sb);\nstatic inline int ext3_feature_set_ok(struct super_block *sb);\nstatic void ext4_unregister_li_request(struct super_block *sb);\n\nint ext4_group_desc_csum_verify(struct super_block *sb, __u32 block_group,\n\t\t\t\tstruct ext4_group_desc *gdp)\n{\n\tif (ext4_has_group_desc_csum(sb) &&\n\t    (gdp->bg_checksum != ext4_group_desc_csum(EXT4_SB(sb),\n\t\t\t\t\t\t      block_group, gdp)))\n\t\treturn 0;\n\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_get_group_desc",
          "args": [
            "sb",
            "g",
            "NULL"
          ],
          "line": 4971
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_get_group_desc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/balloc.c",
          "lines": "277-309",
          "snippet": "struct ext4_group_desc * ext4_get_group_desc(struct super_block *sb,\n\t\t\t\t\t     ext4_group_t block_group,\n\t\t\t\t\t     struct buffer_head **bh)\n{\n\tunsigned int group_desc;\n\tunsigned int offset;\n\text4_group_t ngroups = ext4_get_groups_count(sb);\n\tstruct ext4_group_desc *desc;\n\tstruct ext4_sb_info *sbi = EXT4_SB(sb);\n\n\tif (block_group >= ngroups) {\n\t\text4_error(sb, \"block_group >= groups_count - block_group = %u,\"\n\t\t\t   \" groups_count = %u\", block_group, ngroups);\n\n\t\treturn NULL;\n\t}\n\n\tgroup_desc = block_group >> EXT4_DESC_PER_BLOCK_BITS(sb);\n\toffset = block_group & (EXT4_DESC_PER_BLOCK(sb) - 1);\n\tif (!sbi->s_group_desc[group_desc]) {\n\t\text4_error(sb, \"Group descriptor not loaded - \"\n\t\t\t   \"block_group = %u, group_desc = %u, desc = %u\",\n\t\t\t   block_group, group_desc, offset);\n\t\treturn NULL;\n\t}\n\n\tdesc = (struct ext4_group_desc *)(\n\t\t(__u8 *)sbi->s_group_desc[group_desc]->b_data +\n\t\toffset * EXT4_DESC_SIZE(sb));\n\tif (bh)\n\t\t*bh = sbi->s_group_desc[group_desc];\n\treturn desc;\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"mballoc.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include \"ext4.h\"",
            "#include <linux/buffer_head.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/fs.h>",
            "#include <linux/capability.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static unsigned ext4_num_base_meta_clusters(struct super_block *sb,\n\t\t\t\t\t    ext4_group_t block_group);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"mballoc.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4.h\"\n#include <linux/buffer_head.h>\n#include <linux/quotaops.h>\n#include <linux/jbd2.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n#include <linux/time.h>\n\nstatic unsigned ext4_num_base_meta_clusters(struct super_block *sb,\n\t\t\t\t\t    ext4_group_t block_group);\n\nstruct ext4_group_desc * ext4_get_group_desc(struct super_block *sb,\n\t\t\t\t\t     ext4_group_t block_group,\n\t\t\t\t\t     struct buffer_head **bh)\n{\n\tunsigned int group_desc;\n\tunsigned int offset;\n\text4_group_t ngroups = ext4_get_groups_count(sb);\n\tstruct ext4_group_desc *desc;\n\tstruct ext4_sb_info *sbi = EXT4_SB(sb);\n\n\tif (block_group >= ngroups) {\n\t\text4_error(sb, \"block_group >= groups_count - block_group = %u,\"\n\t\t\t   \" groups_count = %u\", block_group, ngroups);\n\n\t\treturn NULL;\n\t}\n\n\tgroup_desc = block_group >> EXT4_DESC_PER_BLOCK_BITS(sb);\n\toffset = block_group & (EXT4_DESC_PER_BLOCK(sb) - 1);\n\tif (!sbi->s_group_desc[group_desc]) {\n\t\text4_error(sb, \"Group descriptor not loaded - \"\n\t\t\t   \"block_group = %u, group_desc = %u, desc = %u\",\n\t\t\t   block_group, group_desc, offset);\n\t\treturn NULL;\n\t}\n\n\tdesc = (struct ext4_group_desc *)(\n\t\t(__u8 *)sbi->s_group_desc[group_desc]->b_data +\n\t\toffset * EXT4_DESC_SIZE(sb));\n\tif (bh)\n\t\t*bh = sbi->s_group_desc[group_desc];\n\treturn desc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_feature_set_ok",
          "args": [
            "sb",
            "0"
          ],
          "line": 4961
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_feature_set_ok",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/super.c",
          "lines": "2768-2826",
          "snippet": "static int ext4_feature_set_ok(struct super_block *sb, int readonly)\n{\n\tif (EXT4_HAS_INCOMPAT_FEATURE(sb, ~EXT4_FEATURE_INCOMPAT_SUPP)) {\n\t\text4_msg(sb, KERN_ERR,\n\t\t\t\"Couldn't mount because of \"\n\t\t\t\"unsupported optional features (%x)\",\n\t\t\t(le32_to_cpu(EXT4_SB(sb)->s_es->s_feature_incompat) &\n\t\t\t~EXT4_FEATURE_INCOMPAT_SUPP));\n\t\treturn 0;\n\t}\n\n\tif (readonly)\n\t\treturn 1;\n\n\tif (EXT4_HAS_RO_COMPAT_FEATURE(sb, EXT4_FEATURE_RO_COMPAT_READONLY)) {\n\t\text4_msg(sb, KERN_INFO, \"filesystem is read-only\");\n\t\tsb->s_flags |= MS_RDONLY;\n\t\treturn 1;\n\t}\n\n\t/* Check that feature set is OK for a read-write mount */\n\tif (EXT4_HAS_RO_COMPAT_FEATURE(sb, ~EXT4_FEATURE_RO_COMPAT_SUPP)) {\n\t\text4_msg(sb, KERN_ERR, \"couldn't mount RDWR because of \"\n\t\t\t \"unsupported optional features (%x)\",\n\t\t\t (le32_to_cpu(EXT4_SB(sb)->s_es->s_feature_ro_compat) &\n\t\t\t\t~EXT4_FEATURE_RO_COMPAT_SUPP));\n\t\treturn 0;\n\t}\n\t/*\n\t * Large file size enabled file system can only be mounted\n\t * read-write on 32-bit systems if kernel is built with CONFIG_LBDAF\n\t */\n\tif (EXT4_HAS_RO_COMPAT_FEATURE(sb, EXT4_FEATURE_RO_COMPAT_HUGE_FILE)) {\n\t\tif (sizeof(blkcnt_t) < sizeof(u64)) {\n\t\t\text4_msg(sb, KERN_ERR, \"Filesystem with huge files \"\n\t\t\t\t \"cannot be mounted RDWR without \"\n\t\t\t\t \"CONFIG_LBDAF\");\n\t\t\treturn 0;\n\t\t}\n\t}\n\tif (EXT4_HAS_RO_COMPAT_FEATURE(sb, EXT4_FEATURE_RO_COMPAT_BIGALLOC) &&\n\t    !EXT4_HAS_INCOMPAT_FEATURE(sb, EXT4_FEATURE_INCOMPAT_EXTENTS)) {\n\t\text4_msg(sb, KERN_ERR,\n\t\t\t \"Can't support bigalloc feature without \"\n\t\t\t \"extents feature\\n\");\n\t\treturn 0;\n\t}\n\n#ifndef CONFIG_QUOTA\n\tif (EXT4_HAS_RO_COMPAT_FEATURE(sb, EXT4_FEATURE_RO_COMPAT_QUOTA) &&\n\t    !readonly) {\n\t\text4_msg(sb, KERN_ERR,\n\t\t\t \"Filesystem with quota feature cannot be mounted RDWR \"\n\t\t\t \"without CONFIG_QUOTA\");\n\t\treturn 0;\n\t}\n#endif  /* CONFIG_QUOTA */\n\treturn 1;\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"mballoc.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include \"ext4_extents.h\"\t/* Needed for trace points definition */",
            "#include \"ext4.h\"",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/crc16.h>",
            "#include <linux/log2.h>",
            "#include <linux/ctype.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/random.h>",
            "#include <linux/vfs.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/parser.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/time.h>",
            "#include <linux/fs.h>",
            "#include <linux/string.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ext4_unfreeze(struct super_block *sb);",
            "static int ext4_freeze(struct super_block *sb);",
            "static inline int ext2_feature_set_ok(struct super_block *sb);",
            "static inline int ext3_feature_set_ok(struct super_block *sb);",
            "static int ext4_feature_set_ok(struct super_block *sb, int readonly);",
            "static void ext4_unregister_li_request(struct super_block *sb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"mballoc.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4_extents.h\"\t/* Needed for trace points definition */\n#include \"ext4.h\"\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <asm/uaccess.h>\n#include <linux/cleancache.h>\n#include <linux/crc16.h>\n#include <linux/log2.h>\n#include <linux/ctype.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/random.h>\n#include <linux/vfs.h>\n#include <linux/exportfs.h>\n#include <linux/buffer_head.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/jbd2.h>\n#include <linux/vmalloc.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n#include <linux/string.h>\n#include <linux/module.h>\n\nstatic int ext4_unfreeze(struct super_block *sb);\nstatic int ext4_freeze(struct super_block *sb);\nstatic inline int ext2_feature_set_ok(struct super_block *sb);\nstatic inline int ext3_feature_set_ok(struct super_block *sb);\nstatic int ext4_feature_set_ok(struct super_block *sb, int readonly);\nstatic void ext4_unregister_li_request(struct super_block *sb);\n\nstatic int ext4_feature_set_ok(struct super_block *sb, int readonly)\n{\n\tif (EXT4_HAS_INCOMPAT_FEATURE(sb, ~EXT4_FEATURE_INCOMPAT_SUPP)) {\n\t\text4_msg(sb, KERN_ERR,\n\t\t\t\"Couldn't mount because of \"\n\t\t\t\"unsupported optional features (%x)\",\n\t\t\t(le32_to_cpu(EXT4_SB(sb)->s_es->s_feature_incompat) &\n\t\t\t~EXT4_FEATURE_INCOMPAT_SUPP));\n\t\treturn 0;\n\t}\n\n\tif (readonly)\n\t\treturn 1;\n\n\tif (EXT4_HAS_RO_COMPAT_FEATURE(sb, EXT4_FEATURE_RO_COMPAT_READONLY)) {\n\t\text4_msg(sb, KERN_INFO, \"filesystem is read-only\");\n\t\tsb->s_flags |= MS_RDONLY;\n\t\treturn 1;\n\t}\n\n\t/* Check that feature set is OK for a read-write mount */\n\tif (EXT4_HAS_RO_COMPAT_FEATURE(sb, ~EXT4_FEATURE_RO_COMPAT_SUPP)) {\n\t\text4_msg(sb, KERN_ERR, \"couldn't mount RDWR because of \"\n\t\t\t \"unsupported optional features (%x)\",\n\t\t\t (le32_to_cpu(EXT4_SB(sb)->s_es->s_feature_ro_compat) &\n\t\t\t\t~EXT4_FEATURE_RO_COMPAT_SUPP));\n\t\treturn 0;\n\t}\n\t/*\n\t * Large file size enabled file system can only be mounted\n\t * read-write on 32-bit systems if kernel is built with CONFIG_LBDAF\n\t */\n\tif (EXT4_HAS_RO_COMPAT_FEATURE(sb, EXT4_FEATURE_RO_COMPAT_HUGE_FILE)) {\n\t\tif (sizeof(blkcnt_t) < sizeof(u64)) {\n\t\t\text4_msg(sb, KERN_ERR, \"Filesystem with huge files \"\n\t\t\t\t \"cannot be mounted RDWR without \"\n\t\t\t\t \"CONFIG_LBDAF\");\n\t\t\treturn 0;\n\t\t}\n\t}\n\tif (EXT4_HAS_RO_COMPAT_FEATURE(sb, EXT4_FEATURE_RO_COMPAT_BIGALLOC) &&\n\t    !EXT4_HAS_INCOMPAT_FEATURE(sb, EXT4_FEATURE_INCOMPAT_EXTENTS)) {\n\t\text4_msg(sb, KERN_ERR,\n\t\t\t \"Can't support bigalloc feature without \"\n\t\t\t \"extents feature\\n\");\n\t\treturn 0;\n\t}\n\n#ifndef CONFIG_QUOTA\n\tif (EXT4_HAS_RO_COMPAT_FEATURE(sb, EXT4_FEATURE_RO_COMPAT_QUOTA) &&\n\t    !readonly) {\n\t\text4_msg(sb, KERN_ERR,\n\t\t\t \"Filesystem with quota feature cannot be mounted RDWR \"\n\t\t\t \"without CONFIG_QUOTA\");\n\t\treturn 0;\n\t}\n#endif  /* CONFIG_QUOTA */\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "EXT4_HAS_RO_COMPAT_FEATURE",
          "args": [
            "sb",
            "EXT4_FEATURE_RO_COMPAT_READONLY"
          ],
          "line": 4959
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_mark_recovery_complete",
          "args": [
            "sb",
            "es"
          ],
          "line": 4956
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_mark_recovery_complete",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/super.c",
          "lines": "4641-4662",
          "snippet": "static void ext4_mark_recovery_complete(struct super_block *sb,\n\t\t\t\t\tstruct ext4_super_block *es)\n{\n\tjournal_t *journal = EXT4_SB(sb)->s_journal;\n\n\tif (!EXT4_HAS_COMPAT_FEATURE(sb, EXT4_FEATURE_COMPAT_HAS_JOURNAL)) {\n\t\tBUG_ON(journal != NULL);\n\t\treturn;\n\t}\n\tjbd2_journal_lock_updates(journal);\n\tif (jbd2_journal_flush(journal) < 0)\n\t\tgoto out;\n\n\tif (EXT4_HAS_INCOMPAT_FEATURE(sb, EXT4_FEATURE_INCOMPAT_RECOVER) &&\n\t    sb->s_flags & MS_RDONLY) {\n\t\tEXT4_CLEAR_INCOMPAT_FEATURE(sb, EXT4_FEATURE_INCOMPAT_RECOVER);\n\t\text4_commit_super(sb, 1);\n\t}\n\nout:\n\tjbd2_journal_unlock_updates(journal);\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"mballoc.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include \"ext4_extents.h\"\t/* Needed for trace points definition */",
            "#include \"ext4.h\"",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/crc16.h>",
            "#include <linux/log2.h>",
            "#include <linux/ctype.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/random.h>",
            "#include <linux/vfs.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/parser.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/time.h>",
            "#include <linux/fs.h>",
            "#include <linux/string.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void ext4_mark_recovery_complete(struct super_block *sb,\n\t\t\t\t\tstruct ext4_super_block *es);",
            "static void ext4_clear_journal_err(struct super_block *sb,\n\t\t\t\t   struct ext4_super_block *es);",
            "static int ext4_unfreeze(struct super_block *sb);",
            "static int ext4_freeze(struct super_block *sb);",
            "static inline int ext2_feature_set_ok(struct super_block *sb);",
            "static inline int ext3_feature_set_ok(struct super_block *sb);",
            "static void ext4_unregister_li_request(struct super_block *sb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"mballoc.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4_extents.h\"\t/* Needed for trace points definition */\n#include \"ext4.h\"\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <asm/uaccess.h>\n#include <linux/cleancache.h>\n#include <linux/crc16.h>\n#include <linux/log2.h>\n#include <linux/ctype.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/random.h>\n#include <linux/vfs.h>\n#include <linux/exportfs.h>\n#include <linux/buffer_head.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/jbd2.h>\n#include <linux/vmalloc.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n#include <linux/string.h>\n#include <linux/module.h>\n\nstatic void ext4_mark_recovery_complete(struct super_block *sb,\n\t\t\t\t\tstruct ext4_super_block *es);\nstatic void ext4_clear_journal_err(struct super_block *sb,\n\t\t\t\t   struct ext4_super_block *es);\nstatic int ext4_unfreeze(struct super_block *sb);\nstatic int ext4_freeze(struct super_block *sb);\nstatic inline int ext2_feature_set_ok(struct super_block *sb);\nstatic inline int ext3_feature_set_ok(struct super_block *sb);\nstatic void ext4_unregister_li_request(struct super_block *sb);\n\nstatic void ext4_mark_recovery_complete(struct super_block *sb,\n\t\t\t\t\tstruct ext4_super_block *es)\n{\n\tjournal_t *journal = EXT4_SB(sb)->s_journal;\n\n\tif (!EXT4_HAS_COMPAT_FEATURE(sb, EXT4_FEATURE_COMPAT_HAS_JOURNAL)) {\n\t\tBUG_ON(journal != NULL);\n\t\treturn;\n\t}\n\tjbd2_journal_lock_updates(journal);\n\tif (jbd2_journal_flush(journal) < 0)\n\t\tgoto out;\n\n\tif (EXT4_HAS_INCOMPAT_FEATURE(sb, EXT4_FEATURE_INCOMPAT_RECOVER) &&\n\t    sb->s_flags & MS_RDONLY) {\n\t\tEXT4_CLEAR_INCOMPAT_FEATURE(sb, EXT4_FEATURE_INCOMPAT_RECOVER);\n\t\text4_commit_super(sb, 1);\n\t}\n\nout:\n\tjbd2_journal_unlock_updates(journal);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "sbi->s_mount_state"
          ],
          "line": 4953
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "EXT4_VALID_FS"
          ],
          "line": 4951
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dquot_suspend",
          "args": [
            "sb",
            "-1"
          ],
          "line": 4936
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sync_filesystem",
          "args": [
            "sb"
          ],
          "line": 4933
        },
        "resolved": true,
        "details": {
          "function_name": "sync_filesystem",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/sync.c",
          "lines": "47-67",
          "snippet": "int sync_filesystem(struct super_block *sb)\n{\n\tint ret;\n\n\t/*\n\t * We need to be protected against the filesystem going from\n\t * r/o to r/w or vice versa.\n\t */\n\tWARN_ON(!rwsem_is_locked(&sb->s_umount));\n\n\t/*\n\t * No point in syncing out anything if the filesystem is read-only.\n\t */\n\tif (sb->s_flags & MS_RDONLY)\n\t\treturn 0;\n\n\tret = __sync_filesystem(sb, 0);\n\tif (ret < 0)\n\t\treturn ret;\n\treturn __sync_filesystem(sb, 1);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/backing-dev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/linkage.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/writeback.h>",
            "#include <linux/sched.h>",
            "#include <linux/namei.h>",
            "#include <linux/export.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/backing-dev.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/linkage.h>\n#include <linux/syscalls.h>\n#include <linux/writeback.h>\n#include <linux/sched.h>\n#include <linux/namei.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/kernel.h>\n\nint sync_filesystem(struct super_block *sb)\n{\n\tint ret;\n\n\t/*\n\t * We need to be protected against the filesystem going from\n\t * r/o to r/w or vice versa.\n\t */\n\tWARN_ON(!rwsem_is_locked(&sb->s_umount));\n\n\t/*\n\t * No point in syncing out anything if the filesystem is read-only.\n\t */\n\tif (sb->s_flags & MS_RDONLY)\n\t\treturn 0;\n\n\tret = __sync_filesystem(sb, 0);\n\tif (ret < 0)\n\t\treturn ret;\n\treturn __sync_filesystem(sb, 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_task_ioprio",
          "args": [
            "sbi->s_journal->j_task",
            "journal_ioprio"
          ],
          "line": 4923
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_init_journal_params",
          "args": [
            "sb",
            "sbi->s_journal"
          ],
          "line": 4922
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_init_journal_params",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/super.c",
          "lines": "4317-4335",
          "snippet": "static void ext4_init_journal_params(struct super_block *sb, journal_t *journal)\n{\n\tstruct ext4_sb_info *sbi = EXT4_SB(sb);\n\n\tjournal->j_commit_interval = sbi->s_commit_interval;\n\tjournal->j_min_batch_time = sbi->s_min_batch_time;\n\tjournal->j_max_batch_time = sbi->s_max_batch_time;\n\n\twrite_lock(&journal->j_state_lock);\n\tif (test_opt(sb, BARRIER))\n\t\tjournal->j_flags |= JBD2_BARRIER;\n\telse\n\t\tjournal->j_flags &= ~JBD2_BARRIER;\n\tif (test_opt(sb, DATA_ERR_ABORT))\n\t\tjournal->j_flags |= JBD2_ABORT_ON_SYNCDATA_ERR;\n\telse\n\t\tjournal->j_flags &= ~JBD2_ABORT_ON_SYNCDATA_ERR;\n\twrite_unlock(&journal->j_state_lock);\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"mballoc.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include \"ext4_extents.h\"\t/* Needed for trace points definition */",
            "#include \"ext4.h\"",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/crc16.h>",
            "#include <linux/log2.h>",
            "#include <linux/ctype.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/random.h>",
            "#include <linux/vfs.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/parser.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/time.h>",
            "#include <linux/fs.h>",
            "#include <linux/string.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ext4_unfreeze(struct super_block *sb);",
            "static int ext4_freeze(struct super_block *sb);",
            "static inline int ext2_feature_set_ok(struct super_block *sb);",
            "static inline int ext3_feature_set_ok(struct super_block *sb);",
            "static void ext4_unregister_li_request(struct super_block *sb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"mballoc.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4_extents.h\"\t/* Needed for trace points definition */\n#include \"ext4.h\"\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <asm/uaccess.h>\n#include <linux/cleancache.h>\n#include <linux/crc16.h>\n#include <linux/log2.h>\n#include <linux/ctype.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/random.h>\n#include <linux/vfs.h>\n#include <linux/exportfs.h>\n#include <linux/buffer_head.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/jbd2.h>\n#include <linux/vmalloc.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n#include <linux/string.h>\n#include <linux/module.h>\n\nstatic int ext4_unfreeze(struct super_block *sb);\nstatic int ext4_freeze(struct super_block *sb);\nstatic inline int ext2_feature_set_ok(struct super_block *sb);\nstatic inline int ext3_feature_set_ok(struct super_block *sb);\nstatic void ext4_unregister_li_request(struct super_block *sb);\n\nstatic void ext4_init_journal_params(struct super_block *sb, journal_t *journal)\n{\n\tstruct ext4_sb_info *sbi = EXT4_SB(sb);\n\n\tjournal->j_commit_interval = sbi->s_commit_interval;\n\tjournal->j_min_batch_time = sbi->s_min_batch_time;\n\tjournal->j_max_batch_time = sbi->s_max_batch_time;\n\n\twrite_lock(&journal->j_state_lock);\n\tif (test_opt(sb, BARRIER))\n\t\tjournal->j_flags |= JBD2_BARRIER;\n\telse\n\t\tjournal->j_flags &= ~JBD2_BARRIER;\n\tif (test_opt(sb, DATA_ERR_ABORT))\n\t\tjournal->j_flags |= JBD2_ABORT_ON_SYNCDATA_ERR;\n\telse\n\t\tjournal->j_flags &= ~JBD2_ABORT_ON_SYNCDATA_ERR;\n\twrite_unlock(&journal->j_state_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "test_opt",
          "args": [
            "sb",
            "POSIX_ACL"
          ],
          "line": 4917
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_abort",
          "args": [
            "sb",
            "\"Abort forced by user\""
          ],
          "line": 4914
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_opt",
          "args": [
            "sb",
            "DAX"
          ],
          "line": 4899
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_opt",
          "args": [
            "sb",
            "DIOREAD_NOLOCK"
          ],
          "line": 4893
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_opt2",
          "args": [
            "sb",
            "EXPLICIT_DELALLOC"
          ],
          "line": 4887
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_opt",
          "args": [
            "sb",
            "DATA_FLAGS"
          ],
          "line": 4886
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_opt",
          "args": [
            "sb",
            "JOURNAL_CHECKSUM"
          ],
          "line": 4880
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "parse_options",
          "args": [
            "data",
            "sb",
            "NULL",
            "&journal_ioprio",
            "1"
          ],
          "line": 4874
        },
        "resolved": true,
        "details": {
          "function_name": "parse_options",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/super.c",
          "lines": "1645-1715",
          "snippet": "static int parse_options(char *options, struct super_block *sb,\n\t\t\t unsigned long *journal_devnum,\n\t\t\t unsigned int *journal_ioprio,\n\t\t\t int is_remount)\n{\n\tstruct ext4_sb_info *sbi = EXT4_SB(sb);\n\tchar *p;\n\tsubstring_t args[MAX_OPT_ARGS];\n\tint token;\n\n\tif (!options)\n\t\treturn 1;\n\n\twhile ((p = strsep(&options, \",\")) != NULL) {\n\t\tif (!*p)\n\t\t\tcontinue;\n\t\t/*\n\t\t * Initialize args struct so we know whether arg was\n\t\t * found; some options take optional arguments.\n\t\t */\n\t\targs[0].to = args[0].from = NULL;\n\t\ttoken = match_token(p, tokens, args);\n\t\tif (handle_mount_opt(sb, p, token, args, journal_devnum,\n\t\t\t\t     journal_ioprio, is_remount) < 0)\n\t\t\treturn 0;\n\t}\n#ifdef CONFIG_QUOTA\n\tif (EXT4_HAS_RO_COMPAT_FEATURE(sb, EXT4_FEATURE_RO_COMPAT_QUOTA) &&\n\t    (test_opt(sb, USRQUOTA) || test_opt(sb, GRPQUOTA))) {\n\t\text4_msg(sb, KERN_ERR, \"Cannot set quota options when QUOTA \"\n\t\t\t \"feature is enabled\");\n\t\treturn 0;\n\t}\n\tif (sbi->s_qf_names[USRQUOTA] || sbi->s_qf_names[GRPQUOTA]) {\n\t\tif (test_opt(sb, USRQUOTA) && sbi->s_qf_names[USRQUOTA])\n\t\t\tclear_opt(sb, USRQUOTA);\n\n\t\tif (test_opt(sb, GRPQUOTA) && sbi->s_qf_names[GRPQUOTA])\n\t\t\tclear_opt(sb, GRPQUOTA);\n\n\t\tif (test_opt(sb, GRPQUOTA) || test_opt(sb, USRQUOTA)) {\n\t\t\text4_msg(sb, KERN_ERR, \"old and new quota \"\n\t\t\t\t\t\"format mixing\");\n\t\t\treturn 0;\n\t\t}\n\n\t\tif (!sbi->s_jquota_fmt) {\n\t\t\text4_msg(sb, KERN_ERR, \"journaled quota format \"\n\t\t\t\t\t\"not specified\");\n\t\t\treturn 0;\n\t\t}\n\t}\n#endif\n\tif (test_opt(sb, DIOREAD_NOLOCK)) {\n\t\tint blocksize =\n\t\t\tBLOCK_SIZE << le32_to_cpu(sbi->s_es->s_log_block_size);\n\n\t\tif (blocksize < PAGE_CACHE_SIZE) {\n\t\t\text4_msg(sb, KERN_ERR, \"can't mount with \"\n\t\t\t\t \"dioread_nolock if block size != PAGE_SIZE\");\n\t\t\treturn 0;\n\t\t}\n\t}\n\tif (test_opt(sb, DATA_FLAGS) == EXT4_MOUNT_ORDERED_DATA &&\n\t    test_opt(sb, JOURNAL_ASYNC_COMMIT)) {\n\t\text4_msg(sb, KERN_ERR, \"can't mount with journal_async_commit \"\n\t\t\t \"in data=ordered mode\");\n\t\treturn 0;\n\t}\n\treturn 1;\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"mballoc.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include \"ext4_extents.h\"\t/* Needed for trace points definition */",
            "#include \"ext4.h\"",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/crc16.h>",
            "#include <linux/log2.h>",
            "#include <linux/ctype.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/random.h>",
            "#include <linux/vfs.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/parser.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/time.h>",
            "#include <linux/fs.h>",
            "#include <linux/string.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ext4_load_journal(struct super_block *, struct ext4_super_block *,\n\t\t\t     unsigned long journal_devnum);",
            "static int ext4_remount(struct super_block *sb, int *flags, char *data);",
            "static int ext4_unfreeze(struct super_block *sb);",
            "static int ext4_freeze(struct super_block *sb);",
            "static struct dentry *ext4_mount(struct file_system_type *fs_type, int flags,\n\t\t       const char *dev_name, void *data);",
            "static inline int ext2_feature_set_ok(struct super_block *sb);",
            "static inline int ext3_feature_set_ok(struct super_block *sb);",
            "static void ext4_unregister_li_request(struct super_block *sb);",
            "static const match_table_t tokens = {\n\t{Opt_bsd_df, \"bsddf\"},\n\t{Opt_minix_df, \"minixdf\"},\n\t{Opt_grpid, \"grpid\"},\n\t{Opt_grpid, \"bsdgroups\"},\n\t{Opt_nogrpid, \"nogrpid\"},\n\t{Opt_nogrpid, \"sysvgroups\"},\n\t{Opt_resgid, \"resgid=%u\"},\n\t{Opt_resuid, \"resuid=%u\"},\n\t{Opt_sb, \"sb=%u\"},\n\t{Opt_err_cont, \"errors=continue\"},\n\t{Opt_err_panic, \"errors=panic\"},\n\t{Opt_err_ro, \"errors=remount-ro\"},\n\t{Opt_nouid32, \"nouid32\"},\n\t{Opt_debug, \"debug\"},\n\t{Opt_removed, \"oldalloc\"},\n\t{Opt_removed, \"orlov\"},\n\t{Opt_user_xattr, \"user_xattr\"},\n\t{Opt_nouser_xattr, \"nouser_xattr\"},\n\t{Opt_acl, \"acl\"},\n\t{Opt_noacl, \"noacl\"},\n\t{Opt_noload, \"norecovery\"},\n\t{Opt_noload, \"noload\"},\n\t{Opt_removed, \"nobh\"},\n\t{Opt_removed, \"bh\"},\n\t{Opt_commit, \"commit=%u\"},\n\t{Opt_min_batch_time, \"min_batch_time=%u\"},\n\t{Opt_max_batch_time, \"max_batch_time=%u\"},\n\t{Opt_journal_dev, \"journal_dev=%u\"},\n\t{Opt_journal_path, \"journal_path=%s\"},\n\t{Opt_journal_checksum, \"journal_checksum\"},\n\t{Opt_nojournal_checksum, \"nojournal_checksum\"},\n\t{Opt_journal_async_commit, \"journal_async_commit\"},\n\t{Opt_abort, \"abort\"},\n\t{Opt_data_journal, \"data=journal\"},\n\t{Opt_data_ordered, \"data=ordered\"},\n\t{Opt_data_writeback, \"data=writeback\"},\n\t{Opt_data_err_abort, \"data_err=abort\"},\n\t{Opt_data_err_ignore, \"data_err=ignore\"},\n\t{Opt_offusrjquota, \"usrjquota=\"},\n\t{Opt_usrjquota, \"usrjquota=%s\"},\n\t{Opt_offgrpjquota, \"grpjquota=\"},\n\t{Opt_grpjquota, \"grpjquota=%s\"},\n\t{Opt_jqfmt_vfsold, \"jqfmt=vfsold\"},\n\t{Opt_jqfmt_vfsv0, \"jqfmt=vfsv0\"},\n\t{Opt_jqfmt_vfsv1, \"jqfmt=vfsv1\"},\n\t{Opt_grpquota, \"grpquota\"},\n\t{Opt_noquota, \"noquota\"},\n\t{Opt_quota, \"quota\"},\n\t{Opt_usrquota, \"usrquota\"},\n\t{Opt_barrier, \"barrier=%u\"},\n\t{Opt_barrier, \"barrier\"},\n\t{Opt_nobarrier, \"nobarrier\"},\n\t{Opt_i_version, \"i_version\"},\n\t{Opt_dax, \"dax\"},\n\t{Opt_stripe, \"stripe=%u\"},\n\t{Opt_delalloc, \"delalloc\"},\n\t{Opt_lazytime, \"lazytime\"},\n\t{Opt_nolazytime, \"nolazytime\"},\n\t{Opt_nodelalloc, \"nodelalloc\"},\n\t{Opt_removed, \"mblk_io_submit\"},\n\t{Opt_removed, \"nomblk_io_submit\"},\n\t{Opt_block_validity, \"block_validity\"},\n\t{Opt_noblock_validity, \"noblock_validity\"},\n\t{Opt_inode_readahead_blks, \"inode_readahead_blks=%u\"},\n\t{Opt_journal_ioprio, \"journal_ioprio=%u\"},\n\t{Opt_auto_da_alloc, \"auto_da_alloc=%u\"},\n\t{Opt_auto_da_alloc, \"auto_da_alloc\"},\n\t{Opt_noauto_da_alloc, \"noauto_da_alloc\"},\n\t{Opt_dioread_nolock, \"dioread_nolock\"},\n\t{Opt_dioread_lock, \"dioread_lock\"},\n\t{Opt_discard, \"discard\"},\n\t{Opt_nodiscard, \"nodiscard\"},\n\t{Opt_init_itable, \"init_itable=%u\"},\n\t{Opt_init_itable, \"init_itable\"},\n\t{Opt_noinit_itable, \"noinit_itable\"},\n\t{Opt_max_dir_size_kb, \"max_dir_size_kb=%u\"},\n\t{Opt_removed, \"check=none\"},\t/* mount option from ext2/3 */\n\t{Opt_removed, \"nocheck\"},\t/* mount option from ext2/3 */\n\t{Opt_removed, \"reservation\"},\t/* mount option from ext2/3 */\n\t{Opt_removed, \"noreservation\"}, /* mount option from ext2/3 */\n\t{Opt_removed, \"journal=%u\"},\t/* mount option from ext2/3 */\n\t{Opt_err, NULL},\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"mballoc.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4_extents.h\"\t/* Needed for trace points definition */\n#include \"ext4.h\"\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <asm/uaccess.h>\n#include <linux/cleancache.h>\n#include <linux/crc16.h>\n#include <linux/log2.h>\n#include <linux/ctype.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/random.h>\n#include <linux/vfs.h>\n#include <linux/exportfs.h>\n#include <linux/buffer_head.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/jbd2.h>\n#include <linux/vmalloc.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n#include <linux/string.h>\n#include <linux/module.h>\n\nstatic int ext4_load_journal(struct super_block *, struct ext4_super_block *,\n\t\t\t     unsigned long journal_devnum);\nstatic int ext4_remount(struct super_block *sb, int *flags, char *data);\nstatic int ext4_unfreeze(struct super_block *sb);\nstatic int ext4_freeze(struct super_block *sb);\nstatic struct dentry *ext4_mount(struct file_system_type *fs_type, int flags,\n\t\t       const char *dev_name, void *data);\nstatic inline int ext2_feature_set_ok(struct super_block *sb);\nstatic inline int ext3_feature_set_ok(struct super_block *sb);\nstatic void ext4_unregister_li_request(struct super_block *sb);\nstatic const match_table_t tokens = {\n\t{Opt_bsd_df, \"bsddf\"},\n\t{Opt_minix_df, \"minixdf\"},\n\t{Opt_grpid, \"grpid\"},\n\t{Opt_grpid, \"bsdgroups\"},\n\t{Opt_nogrpid, \"nogrpid\"},\n\t{Opt_nogrpid, \"sysvgroups\"},\n\t{Opt_resgid, \"resgid=%u\"},\n\t{Opt_resuid, \"resuid=%u\"},\n\t{Opt_sb, \"sb=%u\"},\n\t{Opt_err_cont, \"errors=continue\"},\n\t{Opt_err_panic, \"errors=panic\"},\n\t{Opt_err_ro, \"errors=remount-ro\"},\n\t{Opt_nouid32, \"nouid32\"},\n\t{Opt_debug, \"debug\"},\n\t{Opt_removed, \"oldalloc\"},\n\t{Opt_removed, \"orlov\"},\n\t{Opt_user_xattr, \"user_xattr\"},\n\t{Opt_nouser_xattr, \"nouser_xattr\"},\n\t{Opt_acl, \"acl\"},\n\t{Opt_noacl, \"noacl\"},\n\t{Opt_noload, \"norecovery\"},\n\t{Opt_noload, \"noload\"},\n\t{Opt_removed, \"nobh\"},\n\t{Opt_removed, \"bh\"},\n\t{Opt_commit, \"commit=%u\"},\n\t{Opt_min_batch_time, \"min_batch_time=%u\"},\n\t{Opt_max_batch_time, \"max_batch_time=%u\"},\n\t{Opt_journal_dev, \"journal_dev=%u\"},\n\t{Opt_journal_path, \"journal_path=%s\"},\n\t{Opt_journal_checksum, \"journal_checksum\"},\n\t{Opt_nojournal_checksum, \"nojournal_checksum\"},\n\t{Opt_journal_async_commit, \"journal_async_commit\"},\n\t{Opt_abort, \"abort\"},\n\t{Opt_data_journal, \"data=journal\"},\n\t{Opt_data_ordered, \"data=ordered\"},\n\t{Opt_data_writeback, \"data=writeback\"},\n\t{Opt_data_err_abort, \"data_err=abort\"},\n\t{Opt_data_err_ignore, \"data_err=ignore\"},\n\t{Opt_offusrjquota, \"usrjquota=\"},\n\t{Opt_usrjquota, \"usrjquota=%s\"},\n\t{Opt_offgrpjquota, \"grpjquota=\"},\n\t{Opt_grpjquota, \"grpjquota=%s\"},\n\t{Opt_jqfmt_vfsold, \"jqfmt=vfsold\"},\n\t{Opt_jqfmt_vfsv0, \"jqfmt=vfsv0\"},\n\t{Opt_jqfmt_vfsv1, \"jqfmt=vfsv1\"},\n\t{Opt_grpquota, \"grpquota\"},\n\t{Opt_noquota, \"noquota\"},\n\t{Opt_quota, \"quota\"},\n\t{Opt_usrquota, \"usrquota\"},\n\t{Opt_barrier, \"barrier=%u\"},\n\t{Opt_barrier, \"barrier\"},\n\t{Opt_nobarrier, \"nobarrier\"},\n\t{Opt_i_version, \"i_version\"},\n\t{Opt_dax, \"dax\"},\n\t{Opt_stripe, \"stripe=%u\"},\n\t{Opt_delalloc, \"delalloc\"},\n\t{Opt_lazytime, \"lazytime\"},\n\t{Opt_nolazytime, \"nolazytime\"},\n\t{Opt_nodelalloc, \"nodelalloc\"},\n\t{Opt_removed, \"mblk_io_submit\"},\n\t{Opt_removed, \"nomblk_io_submit\"},\n\t{Opt_block_validity, \"block_validity\"},\n\t{Opt_noblock_validity, \"noblock_validity\"},\n\t{Opt_inode_readahead_blks, \"inode_readahead_blks=%u\"},\n\t{Opt_journal_ioprio, \"journal_ioprio=%u\"},\n\t{Opt_auto_da_alloc, \"auto_da_alloc=%u\"},\n\t{Opt_auto_da_alloc, \"auto_da_alloc\"},\n\t{Opt_noauto_da_alloc, \"noauto_da_alloc\"},\n\t{Opt_dioread_nolock, \"dioread_nolock\"},\n\t{Opt_dioread_lock, \"dioread_lock\"},\n\t{Opt_discard, \"discard\"},\n\t{Opt_nodiscard, \"nodiscard\"},\n\t{Opt_init_itable, \"init_itable=%u\"},\n\t{Opt_init_itable, \"init_itable\"},\n\t{Opt_noinit_itable, \"noinit_itable\"},\n\t{Opt_max_dir_size_kb, \"max_dir_size_kb=%u\"},\n\t{Opt_removed, \"check=none\"},\t/* mount option from ext2/3 */\n\t{Opt_removed, \"nocheck\"},\t/* mount option from ext2/3 */\n\t{Opt_removed, \"reservation\"},\t/* mount option from ext2/3 */\n\t{Opt_removed, \"noreservation\"}, /* mount option from ext2/3 */\n\t{Opt_removed, \"journal=%u\"},\t/* mount option from ext2/3 */\n\t{Opt_err, NULL},\n};\n\nstatic int parse_options(char *options, struct super_block *sb,\n\t\t\t unsigned long *journal_devnum,\n\t\t\t unsigned int *journal_ioprio,\n\t\t\t int is_remount)\n{\n\tstruct ext4_sb_info *sbi = EXT4_SB(sb);\n\tchar *p;\n\tsubstring_t args[MAX_OPT_ARGS];\n\tint token;\n\n\tif (!options)\n\t\treturn 1;\n\n\twhile ((p = strsep(&options, \",\")) != NULL) {\n\t\tif (!*p)\n\t\t\tcontinue;\n\t\t/*\n\t\t * Initialize args struct so we know whether arg was\n\t\t * found; some options take optional arguments.\n\t\t */\n\t\targs[0].to = args[0].from = NULL;\n\t\ttoken = match_token(p, tokens, args);\n\t\tif (handle_mount_opt(sb, p, token, args, journal_devnum,\n\t\t\t\t     journal_ioprio, is_remount) < 0)\n\t\t\treturn 0;\n\t}\n#ifdef CONFIG_QUOTA\n\tif (EXT4_HAS_RO_COMPAT_FEATURE(sb, EXT4_FEATURE_RO_COMPAT_QUOTA) &&\n\t    (test_opt(sb, USRQUOTA) || test_opt(sb, GRPQUOTA))) {\n\t\text4_msg(sb, KERN_ERR, \"Cannot set quota options when QUOTA \"\n\t\t\t \"feature is enabled\");\n\t\treturn 0;\n\t}\n\tif (sbi->s_qf_names[USRQUOTA] || sbi->s_qf_names[GRPQUOTA]) {\n\t\tif (test_opt(sb, USRQUOTA) && sbi->s_qf_names[USRQUOTA])\n\t\t\tclear_opt(sb, USRQUOTA);\n\n\t\tif (test_opt(sb, GRPQUOTA) && sbi->s_qf_names[GRPQUOTA])\n\t\t\tclear_opt(sb, GRPQUOTA);\n\n\t\tif (test_opt(sb, GRPQUOTA) || test_opt(sb, USRQUOTA)) {\n\t\t\text4_msg(sb, KERN_ERR, \"old and new quota \"\n\t\t\t\t\t\"format mixing\");\n\t\t\treturn 0;\n\t\t}\n\n\t\tif (!sbi->s_jquota_fmt) {\n\t\t\text4_msg(sb, KERN_ERR, \"journaled quota format \"\n\t\t\t\t\t\"not specified\");\n\t\t\treturn 0;\n\t\t}\n\t}\n#endif\n\tif (test_opt(sb, DIOREAD_NOLOCK)) {\n\t\tint blocksize =\n\t\t\tBLOCK_SIZE << le32_to_cpu(sbi->s_es->s_log_block_size);\n\n\t\tif (blocksize < PAGE_CACHE_SIZE) {\n\t\t\text4_msg(sb, KERN_ERR, \"can't mount with \"\n\t\t\t\t \"dioread_nolock if block size != PAGE_SIZE\");\n\t\t\treturn 0;\n\t\t}\n\t}\n\tif (test_opt(sb, DATA_FLAGS) == EXT4_MOUNT_ORDERED_DATA &&\n\t    test_opt(sb, JOURNAL_ASYNC_COMMIT)) {\n\t\text4_msg(sb, KERN_ERR, \"can't mount with journal_async_commit \"\n\t\t\t \"in data=ordered mode\");\n\t\treturn 0;\n\t}\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "orig_data"
          ],
          "line": 4865
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "old_opts.s_qf_names[j]"
          ],
          "line": 4864
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kstrdup",
          "args": [
            "sbi->s_qf_names[i]",
            "GFP_KERNEL"
          ],
          "line": 4860
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kstrdup",
          "args": [
            "data",
            "GFP_KERNEL"
          ],
          "line": 4845
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXT4_SB",
          "args": [
            "sb"
          ],
          "line": 4835
        },
        "resolved": true,
        "details": {
          "function_name": "EXT4_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ext4.h",
          "lines": "1356-1359",
          "snippet": "static inline struct ext4_sb_info *EXT4_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include \"extents_status.h\"",
            "#include <linux/compat.h>",
            "#include <linux/falloc.h>",
            "#include <crypto/hash.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/wait.h>",
            "#include <linux/timer.h>",
            "#include <linux/mutex.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/quota.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extents_status.h\"\n#include <linux/compat.h>\n#include <linux/falloc.h>\n#include <crypto/hash.h>\n#include <linux/ratelimit.h>\n#include <linux/percpu_counter.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/wait.h>\n#include <linux/timer.h>\n#include <linux/mutex.h>\n#include <linux/seqlock.h>\n#include <linux/rbtree.h>\n#include <linux/rwsem.h>\n#include <linux/quota.h>\n#include <linux/jbd2.h>\n#include <linux/magic.h>\n#include <linux/blkdev.h>\n#include <linux/types.h>\n\nstatic inline struct ext4_sb_info *EXT4_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"mballoc.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4_extents.h\"\t/* Needed for trace points definition */\n#include \"ext4.h\"\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <asm/uaccess.h>\n#include <linux/cleancache.h>\n#include <linux/crc16.h>\n#include <linux/log2.h>\n#include <linux/ctype.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/random.h>\n#include <linux/vfs.h>\n#include <linux/exportfs.h>\n#include <linux/buffer_head.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/jbd2.h>\n#include <linux/vmalloc.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n#include <linux/string.h>\n#include <linux/module.h>\n\n#define DEFAULT_JOURNAL_IOPRIO (IOPRIO_PRIO_VALUE(IOPRIO_CLASS_BE, 3))\n\nstatic void ext4_mark_recovery_complete(struct super_block *sb,\n\t\t\t\t\tstruct ext4_super_block *es);\nstatic void ext4_clear_journal_err(struct super_block *sb,\n\t\t\t\t   struct ext4_super_block *es);\nstatic int ext4_remount(struct super_block *sb, int *flags, char *data);\nstatic int ext4_unfreeze(struct super_block *sb);\nstatic int ext4_freeze(struct super_block *sb);\nstatic struct dentry *ext4_mount(struct file_system_type *fs_type, int flags,\n\t\t       const char *dev_name, void *data);\nstatic inline int ext2_feature_set_ok(struct super_block *sb);\nstatic inline int ext3_feature_set_ok(struct super_block *sb);\nstatic int ext4_feature_set_ok(struct super_block *sb, int readonly);\nstatic void ext4_unregister_li_request(struct super_block *sb);\n\nstatic int ext4_remount(struct super_block *sb, int *flags, char *data)\n{\n\tstruct ext4_super_block *es;\n\tstruct ext4_sb_info *sbi = EXT4_SB(sb);\n\tunsigned long old_sb_flags;\n\tstruct ext4_mount_options old_opts;\n\tint enable_quota = 0;\n\text4_group_t g;\n\tunsigned int journal_ioprio = DEFAULT_JOURNAL_IOPRIO;\n\tint err = 0;\n#ifdef CONFIG_QUOTA\n\tint i, j;\n#endif\n\tchar *orig_data = kstrdup(data, GFP_KERNEL);\n\n\t/* Store the original options */\n\told_sb_flags = sb->s_flags;\n\told_opts.s_mount_opt = sbi->s_mount_opt;\n\told_opts.s_mount_opt2 = sbi->s_mount_opt2;\n\told_opts.s_resuid = sbi->s_resuid;\n\told_opts.s_resgid = sbi->s_resgid;\n\told_opts.s_commit_interval = sbi->s_commit_interval;\n\told_opts.s_min_batch_time = sbi->s_min_batch_time;\n\told_opts.s_max_batch_time = sbi->s_max_batch_time;\n#ifdef CONFIG_QUOTA\n\told_opts.s_jquota_fmt = sbi->s_jquota_fmt;\n\tfor (i = 0; i < EXT4_MAXQUOTAS; i++)\n\t\tif (sbi->s_qf_names[i]) {\n\t\t\told_opts.s_qf_names[i] = kstrdup(sbi->s_qf_names[i],\n\t\t\t\t\t\t\t GFP_KERNEL);\n\t\t\tif (!old_opts.s_qf_names[i]) {\n\t\t\t\tfor (j = 0; j < i; j++)\n\t\t\t\t\tkfree(old_opts.s_qf_names[j]);\n\t\t\t\tkfree(orig_data);\n\t\t\t\treturn -ENOMEM;\n\t\t\t}\n\t\t} else\n\t\t\told_opts.s_qf_names[i] = NULL;\n#endif\n\tif (sbi->s_journal && sbi->s_journal->j_task->io_context)\n\t\tjournal_ioprio = sbi->s_journal->j_task->io_context->ioprio;\n\n\tif (!parse_options(data, sb, NULL, &journal_ioprio, 1)) {\n\t\terr = -EINVAL;\n\t\tgoto restore_opts;\n\t}\n\n\tif ((old_opts.s_mount_opt & EXT4_MOUNT_JOURNAL_CHECKSUM) ^\n\t    test_opt(sb, JOURNAL_CHECKSUM)) {\n\t\text4_msg(sb, KERN_ERR, \"changing journal_checksum \"\n\t\t\t \"during remount not supported; ignoring\");\n\t\tsbi->s_mount_opt ^= EXT4_MOUNT_JOURNAL_CHECKSUM;\n\t}\n\n\tif (test_opt(sb, DATA_FLAGS) == EXT4_MOUNT_JOURNAL_DATA) {\n\t\tif (test_opt2(sb, EXPLICIT_DELALLOC)) {\n\t\t\text4_msg(sb, KERN_ERR, \"can't mount with \"\n\t\t\t\t \"both data=journal and delalloc\");\n\t\t\terr = -EINVAL;\n\t\t\tgoto restore_opts;\n\t\t}\n\t\tif (test_opt(sb, DIOREAD_NOLOCK)) {\n\t\t\text4_msg(sb, KERN_ERR, \"can't mount with \"\n\t\t\t\t \"both data=journal and dioread_nolock\");\n\t\t\terr = -EINVAL;\n\t\t\tgoto restore_opts;\n\t\t}\n\t\tif (test_opt(sb, DAX)) {\n\t\t\text4_msg(sb, KERN_ERR, \"can't mount with \"\n\t\t\t\t \"both data=journal and dax\");\n\t\t\terr = -EINVAL;\n\t\t\tgoto restore_opts;\n\t\t}\n\t}\n\n\tif ((sbi->s_mount_opt ^ old_opts.s_mount_opt) & EXT4_MOUNT_DAX) {\n\t\text4_msg(sb, KERN_WARNING, \"warning: refusing change of \"\n\t\t\t\"dax flag with busy inodes while remounting\");\n\t\tsbi->s_mount_opt ^= EXT4_MOUNT_DAX;\n\t}\n\n\tif (sbi->s_mount_flags & EXT4_MF_FS_ABORTED)\n\t\text4_abort(sb, \"Abort forced by user\");\n\n\tsb->s_flags = (sb->s_flags & ~MS_POSIXACL) |\n\t\t(test_opt(sb, POSIX_ACL) ? MS_POSIXACL : 0);\n\n\tes = sbi->s_es;\n\n\tif (sbi->s_journal) {\n\t\text4_init_journal_params(sb, sbi->s_journal);\n\t\tset_task_ioprio(sbi->s_journal->j_task, journal_ioprio);\n\t}\n\n\tif ((*flags & MS_RDONLY) != (sb->s_flags & MS_RDONLY)) {\n\t\tif (sbi->s_mount_flags & EXT4_MF_FS_ABORTED) {\n\t\t\terr = -EROFS;\n\t\t\tgoto restore_opts;\n\t\t}\n\n\t\tif (*flags & MS_RDONLY) {\n\t\t\terr = sync_filesystem(sb);\n\t\t\tif (err < 0)\n\t\t\t\tgoto restore_opts;\n\t\t\terr = dquot_suspend(sb, -1);\n\t\t\tif (err < 0)\n\t\t\t\tgoto restore_opts;\n\n\t\t\t/*\n\t\t\t * First of all, the unconditional stuff we have to do\n\t\t\t * to disable replay of the journal when we next remount\n\t\t\t */\n\t\t\tsb->s_flags |= MS_RDONLY;\n\n\t\t\t/*\n\t\t\t * OK, test if we are remounting a valid rw partition\n\t\t\t * readonly, and if so set the rdonly flag and then\n\t\t\t * mark the partition as valid again.\n\t\t\t */\n\t\t\tif (!(es->s_state & cpu_to_le16(EXT4_VALID_FS)) &&\n\t\t\t    (sbi->s_mount_state & EXT4_VALID_FS))\n\t\t\t\tes->s_state = cpu_to_le16(sbi->s_mount_state);\n\n\t\t\tif (sbi->s_journal)\n\t\t\t\text4_mark_recovery_complete(sb, es);\n\t\t} else {\n\t\t\t/* Make sure we can mount this feature set readwrite */\n\t\t\tif (EXT4_HAS_RO_COMPAT_FEATURE(sb,\n\t\t\t\t\tEXT4_FEATURE_RO_COMPAT_READONLY) ||\n\t\t\t    !ext4_feature_set_ok(sb, 0)) {\n\t\t\t\terr = -EROFS;\n\t\t\t\tgoto restore_opts;\n\t\t\t}\n\t\t\t/*\n\t\t\t * Make sure the group descriptor checksums\n\t\t\t * are sane.  If they aren't, refuse to remount r/w.\n\t\t\t */\n\t\t\tfor (g = 0; g < sbi->s_groups_count; g++) {\n\t\t\t\tstruct ext4_group_desc *gdp =\n\t\t\t\t\text4_get_group_desc(sb, g, NULL);\n\n\t\t\t\tif (!ext4_group_desc_csum_verify(sb, g, gdp)) {\n\t\t\t\t\text4_msg(sb, KERN_ERR,\n\t       \"ext4_remount: Checksum for group %u failed (%u!=%u)\",\n\t\tg, le16_to_cpu(ext4_group_desc_csum(sbi, g, gdp)),\n\t\t\t\t\t       le16_to_cpu(gdp->bg_checksum));\n\t\t\t\t\terr = -EINVAL;\n\t\t\t\t\tgoto restore_opts;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * If we have an unprocessed orphan list hanging\n\t\t\t * around from a previously readonly bdev mount,\n\t\t\t * require a full umount/remount for now.\n\t\t\t */\n\t\t\tif (es->s_last_orphan) {\n\t\t\t\text4_msg(sb, KERN_WARNING, \"Couldn't \"\n\t\t\t\t       \"remount RDWR because of unprocessed \"\n\t\t\t\t       \"orphan inode list.  Please \"\n\t\t\t\t       \"umount/remount instead\");\n\t\t\t\terr = -EINVAL;\n\t\t\t\tgoto restore_opts;\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * Mounting a RDONLY partition read-write, so reread\n\t\t\t * and store the current valid flag.  (It may have\n\t\t\t * been changed by e2fsck since we originally mounted\n\t\t\t * the partition.)\n\t\t\t */\n\t\t\tif (sbi->s_journal)\n\t\t\t\text4_clear_journal_err(sb, es);\n\t\t\tsbi->s_mount_state = le16_to_cpu(es->s_state);\n\t\t\tif (!ext4_setup_super(sb, es, 0))\n\t\t\t\tsb->s_flags &= ~MS_RDONLY;\n\t\t\tif (EXT4_HAS_INCOMPAT_FEATURE(sb,\n\t\t\t\t\t\t     EXT4_FEATURE_INCOMPAT_MMP))\n\t\t\t\tif (ext4_multi_mount_protect(sb,\n\t\t\t\t\t\tle64_to_cpu(es->s_mmp_block))) {\n\t\t\t\t\terr = -EROFS;\n\t\t\t\t\tgoto restore_opts;\n\t\t\t\t}\n\t\t\tenable_quota = 1;\n\t\t}\n\t}\n\n\t/*\n\t * Reinitialize lazy itable initialization thread based on\n\t * current settings\n\t */\n\tif ((sb->s_flags & MS_RDONLY) || !test_opt(sb, INIT_INODE_TABLE))\n\t\text4_unregister_li_request(sb);\n\telse {\n\t\text4_group_t first_not_zeroed;\n\t\tfirst_not_zeroed = ext4_has_uninit_itable(sb);\n\t\text4_register_li_request(sb, first_not_zeroed);\n\t}\n\n\text4_setup_system_zone(sb);\n\tif (sbi->s_journal == NULL && !(old_sb_flags & MS_RDONLY))\n\t\text4_commit_super(sb, 1);\n\n#ifdef CONFIG_QUOTA\n\t/* Release old quota file names */\n\tfor (i = 0; i < EXT4_MAXQUOTAS; i++)\n\t\tkfree(old_opts.s_qf_names[i]);\n\tif (enable_quota) {\n\t\tif (sb_any_quota_suspended(sb))\n\t\t\tdquot_resume(sb, -1);\n\t\telse if (EXT4_HAS_RO_COMPAT_FEATURE(sb,\n\t\t\t\t\tEXT4_FEATURE_RO_COMPAT_QUOTA)) {\n\t\t\terr = ext4_enable_quotas(sb);\n\t\t\tif (err)\n\t\t\t\tgoto restore_opts;\n\t\t}\n\t}\n#endif\n\n\t*flags = (*flags & ~MS_LAZYTIME) | (sb->s_flags & MS_LAZYTIME);\n\text4_msg(sb, KERN_INFO, \"re-mounted. Opts: %s\", orig_data);\n\tkfree(orig_data);\n\treturn 0;\n\nrestore_opts:\n\tsb->s_flags = old_sb_flags;\n\tsbi->s_mount_opt = old_opts.s_mount_opt;\n\tsbi->s_mount_opt2 = old_opts.s_mount_opt2;\n\tsbi->s_resuid = old_opts.s_resuid;\n\tsbi->s_resgid = old_opts.s_resgid;\n\tsbi->s_commit_interval = old_opts.s_commit_interval;\n\tsbi->s_min_batch_time = old_opts.s_min_batch_time;\n\tsbi->s_max_batch_time = old_opts.s_max_batch_time;\n#ifdef CONFIG_QUOTA\n\tsbi->s_jquota_fmt = old_opts.s_jquota_fmt;\n\tfor (i = 0; i < EXT4_MAXQUOTAS; i++) {\n\t\tkfree(sbi->s_qf_names[i]);\n\t\tsbi->s_qf_names[i] = old_opts.s_qf_names[i];\n\t}\n#endif\n\tkfree(orig_data);\n\treturn err;\n}"
  },
  {
    "function_name": "ext4_unfreeze",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/super.c",
    "lines": "4805-4814",
    "snippet": "static int ext4_unfreeze(struct super_block *sb)\n{\n\tif (sb->s_flags & MS_RDONLY)\n\t\treturn 0;\n\n\t/* Reset the needs_recovery flag before the fs is unlocked. */\n\tEXT4_SET_INCOMPAT_FEATURE(sb, EXT4_FEATURE_INCOMPAT_RECOVER);\n\text4_commit_super(sb, 1);\n\treturn 0;\n}",
    "includes": [
      "#include <trace/events/ext4.h>",
      "#include \"mballoc.h\"",
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"ext4_jbd2.h\"",
      "#include \"ext4_extents.h\"\t/* Needed for trace points definition */",
      "#include \"ext4.h\"",
      "#include <linux/freezer.h>",
      "#include <linux/kthread.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/cleancache.h>",
      "#include <linux/crc16.h>",
      "#include <linux/log2.h>",
      "#include <linux/ctype.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/namei.h>",
      "#include <linux/mount.h>",
      "#include <linux/random.h>",
      "#include <linux/vfs.h>",
      "#include <linux/exportfs.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/parser.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/init.h>",
      "#include <linux/slab.h>",
      "#include <linux/jbd2.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/time.h>",
      "#include <linux/fs.h>",
      "#include <linux/string.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ext4_unfreeze(struct super_block *sb);",
      "static int ext4_freeze(struct super_block *sb);",
      "static inline int ext2_feature_set_ok(struct super_block *sb);",
      "static inline int ext3_feature_set_ok(struct super_block *sb);",
      "static void ext4_unregister_li_request(struct super_block *sb);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ext4_commit_super",
          "args": [
            "sb",
            "1"
          ],
          "line": 4812
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_commit_super",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/super.c",
          "lines": "4567-4634",
          "snippet": "static int ext4_commit_super(struct super_block *sb, int sync)\n{\n\tstruct ext4_super_block *es = EXT4_SB(sb)->s_es;\n\tstruct buffer_head *sbh = EXT4_SB(sb)->s_sbh;\n\tint error = 0;\n\n\tif (!sbh || block_device_ejected(sb))\n\t\treturn error;\n\tif (buffer_write_io_error(sbh)) {\n\t\t/*\n\t\t * Oh, dear.  A previous attempt to write the\n\t\t * superblock failed.  This could happen because the\n\t\t * USB device was yanked out.  Or it could happen to\n\t\t * be a transient write error and maybe the block will\n\t\t * be remapped.  Nothing we can do but to retry the\n\t\t * write and hope for the best.\n\t\t */\n\t\text4_msg(sb, KERN_ERR, \"previous I/O error to \"\n\t\t       \"superblock detected\");\n\t\tclear_buffer_write_io_error(sbh);\n\t\tset_buffer_uptodate(sbh);\n\t}\n\t/*\n\t * If the file system is mounted read-only, don't update the\n\t * superblock write time.  This avoids updating the superblock\n\t * write time when we are mounting the root file system\n\t * read/only but we need to replay the journal; at that point,\n\t * for people who are east of GMT and who make their clock\n\t * tick in localtime for Windows bug-for-bug compatibility,\n\t * the clock is set in the future, and this will cause e2fsck\n\t * to complain and force a full file system check.\n\t */\n\tif (!(sb->s_flags & MS_RDONLY))\n\t\tes->s_wtime = cpu_to_le32(get_seconds());\n\tif (sb->s_bdev->bd_part)\n\t\tes->s_kbytes_written =\n\t\t\tcpu_to_le64(EXT4_SB(sb)->s_kbytes_written +\n\t\t\t    ((part_stat_read(sb->s_bdev->bd_part, sectors[1]) -\n\t\t\t      EXT4_SB(sb)->s_sectors_written_start) >> 1));\n\telse\n\t\tes->s_kbytes_written =\n\t\t\tcpu_to_le64(EXT4_SB(sb)->s_kbytes_written);\n\tif (percpu_counter_initialized(&EXT4_SB(sb)->s_freeclusters_counter))\n\t\text4_free_blocks_count_set(es,\n\t\t\tEXT4_C2B(EXT4_SB(sb), percpu_counter_sum_positive(\n\t\t\t\t&EXT4_SB(sb)->s_freeclusters_counter)));\n\tif (percpu_counter_initialized(&EXT4_SB(sb)->s_freeinodes_counter))\n\t\tes->s_free_inodes_count =\n\t\t\tcpu_to_le32(percpu_counter_sum_positive(\n\t\t\t\t&EXT4_SB(sb)->s_freeinodes_counter));\n\tBUFFER_TRACE(sbh, \"marking dirty\");\n\text4_superblock_csum_set(sb);\n\tmark_buffer_dirty(sbh);\n\tif (sync) {\n\t\terror = sync_dirty_buffer(sbh);\n\t\tif (error)\n\t\t\treturn error;\n\n\t\terror = buffer_write_io_error(sbh);\n\t\tif (error) {\n\t\t\text4_msg(sb, KERN_ERR, \"I/O error while writing \"\n\t\t\t       \"superblock\");\n\t\t\tclear_buffer_write_io_error(sbh);\n\t\t\tset_buffer_uptodate(sbh);\n\t\t}\n\t}\n\treturn error;\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"mballoc.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include \"ext4_extents.h\"\t/* Needed for trace points definition */",
            "#include \"ext4.h\"",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/crc16.h>",
            "#include <linux/log2.h>",
            "#include <linux/ctype.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/random.h>",
            "#include <linux/vfs.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/parser.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/time.h>",
            "#include <linux/fs.h>",
            "#include <linux/string.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ext4_show_options(struct seq_file *seq, struct dentry *root);",
            "static int ext4_commit_super(struct super_block *sb, int sync);",
            "static void ext4_mark_recovery_complete(struct super_block *sb,\n\t\t\t\t\tstruct ext4_super_block *es);",
            "static void ext4_clear_journal_err(struct super_block *sb,\n\t\t\t\t   struct ext4_super_block *es);",
            "static int ext4_unfreeze(struct super_block *sb);",
            "static int ext4_freeze(struct super_block *sb);",
            "static inline int ext2_feature_set_ok(struct super_block *sb);",
            "static inline int ext3_feature_set_ok(struct super_block *sb);",
            "static void ext4_unregister_li_request(struct super_block *sb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"mballoc.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4_extents.h\"\t/* Needed for trace points definition */\n#include \"ext4.h\"\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <asm/uaccess.h>\n#include <linux/cleancache.h>\n#include <linux/crc16.h>\n#include <linux/log2.h>\n#include <linux/ctype.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/random.h>\n#include <linux/vfs.h>\n#include <linux/exportfs.h>\n#include <linux/buffer_head.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/jbd2.h>\n#include <linux/vmalloc.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n#include <linux/string.h>\n#include <linux/module.h>\n\nstatic int ext4_show_options(struct seq_file *seq, struct dentry *root);\nstatic int ext4_commit_super(struct super_block *sb, int sync);\nstatic void ext4_mark_recovery_complete(struct super_block *sb,\n\t\t\t\t\tstruct ext4_super_block *es);\nstatic void ext4_clear_journal_err(struct super_block *sb,\n\t\t\t\t   struct ext4_super_block *es);\nstatic int ext4_unfreeze(struct super_block *sb);\nstatic int ext4_freeze(struct super_block *sb);\nstatic inline int ext2_feature_set_ok(struct super_block *sb);\nstatic inline int ext3_feature_set_ok(struct super_block *sb);\nstatic void ext4_unregister_li_request(struct super_block *sb);\n\nstatic int ext4_commit_super(struct super_block *sb, int sync)\n{\n\tstruct ext4_super_block *es = EXT4_SB(sb)->s_es;\n\tstruct buffer_head *sbh = EXT4_SB(sb)->s_sbh;\n\tint error = 0;\n\n\tif (!sbh || block_device_ejected(sb))\n\t\treturn error;\n\tif (buffer_write_io_error(sbh)) {\n\t\t/*\n\t\t * Oh, dear.  A previous attempt to write the\n\t\t * superblock failed.  This could happen because the\n\t\t * USB device was yanked out.  Or it could happen to\n\t\t * be a transient write error and maybe the block will\n\t\t * be remapped.  Nothing we can do but to retry the\n\t\t * write and hope for the best.\n\t\t */\n\t\text4_msg(sb, KERN_ERR, \"previous I/O error to \"\n\t\t       \"superblock detected\");\n\t\tclear_buffer_write_io_error(sbh);\n\t\tset_buffer_uptodate(sbh);\n\t}\n\t/*\n\t * If the file system is mounted read-only, don't update the\n\t * superblock write time.  This avoids updating the superblock\n\t * write time when we are mounting the root file system\n\t * read/only but we need to replay the journal; at that point,\n\t * for people who are east of GMT and who make their clock\n\t * tick in localtime for Windows bug-for-bug compatibility,\n\t * the clock is set in the future, and this will cause e2fsck\n\t * to complain and force a full file system check.\n\t */\n\tif (!(sb->s_flags & MS_RDONLY))\n\t\tes->s_wtime = cpu_to_le32(get_seconds());\n\tif (sb->s_bdev->bd_part)\n\t\tes->s_kbytes_written =\n\t\t\tcpu_to_le64(EXT4_SB(sb)->s_kbytes_written +\n\t\t\t    ((part_stat_read(sb->s_bdev->bd_part, sectors[1]) -\n\t\t\t      EXT4_SB(sb)->s_sectors_written_start) >> 1));\n\telse\n\t\tes->s_kbytes_written =\n\t\t\tcpu_to_le64(EXT4_SB(sb)->s_kbytes_written);\n\tif (percpu_counter_initialized(&EXT4_SB(sb)->s_freeclusters_counter))\n\t\text4_free_blocks_count_set(es,\n\t\t\tEXT4_C2B(EXT4_SB(sb), percpu_counter_sum_positive(\n\t\t\t\t&EXT4_SB(sb)->s_freeclusters_counter)));\n\tif (percpu_counter_initialized(&EXT4_SB(sb)->s_freeinodes_counter))\n\t\tes->s_free_inodes_count =\n\t\t\tcpu_to_le32(percpu_counter_sum_positive(\n\t\t\t\t&EXT4_SB(sb)->s_freeinodes_counter));\n\tBUFFER_TRACE(sbh, \"marking dirty\");\n\text4_superblock_csum_set(sb);\n\tmark_buffer_dirty(sbh);\n\tif (sync) {\n\t\terror = sync_dirty_buffer(sbh);\n\t\tif (error)\n\t\t\treturn error;\n\n\t\terror = buffer_write_io_error(sbh);\n\t\tif (error) {\n\t\t\text4_msg(sb, KERN_ERR, \"I/O error while writing \"\n\t\t\t       \"superblock\");\n\t\t\tclear_buffer_write_io_error(sbh);\n\t\t\tset_buffer_uptodate(sbh);\n\t\t}\n\t}\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "EXT4_SET_INCOMPAT_FEATURE",
          "args": [
            "sb",
            "EXT4_FEATURE_INCOMPAT_RECOVER"
          ],
          "line": 4811
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"mballoc.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4_extents.h\"\t/* Needed for trace points definition */\n#include \"ext4.h\"\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <asm/uaccess.h>\n#include <linux/cleancache.h>\n#include <linux/crc16.h>\n#include <linux/log2.h>\n#include <linux/ctype.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/random.h>\n#include <linux/vfs.h>\n#include <linux/exportfs.h>\n#include <linux/buffer_head.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/jbd2.h>\n#include <linux/vmalloc.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n#include <linux/string.h>\n#include <linux/module.h>\n\nstatic int ext4_unfreeze(struct super_block *sb);\nstatic int ext4_freeze(struct super_block *sb);\nstatic inline int ext2_feature_set_ok(struct super_block *sb);\nstatic inline int ext3_feature_set_ok(struct super_block *sb);\nstatic void ext4_unregister_li_request(struct super_block *sb);\n\nstatic int ext4_unfreeze(struct super_block *sb)\n{\n\tif (sb->s_flags & MS_RDONLY)\n\t\treturn 0;\n\n\t/* Reset the needs_recovery flag before the fs is unlocked. */\n\tEXT4_SET_INCOMPAT_FEATURE(sb, EXT4_FEATURE_INCOMPAT_RECOVER);\n\text4_commit_super(sb, 1);\n\treturn 0;\n}"
  },
  {
    "function_name": "ext4_freeze",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/super.c",
    "lines": "4768-4799",
    "snippet": "static int ext4_freeze(struct super_block *sb)\n{\n\tint error = 0;\n\tjournal_t *journal;\n\n\tif (sb->s_flags & MS_RDONLY)\n\t\treturn 0;\n\n\tjournal = EXT4_SB(sb)->s_journal;\n\n\tif (journal) {\n\t\t/* Now we set up the journal barrier. */\n\t\tjbd2_journal_lock_updates(journal);\n\n\t\t/*\n\t\t * Don't clear the needs_recovery flag if we failed to\n\t\t * flush the journal.\n\t\t */\n\t\terror = jbd2_journal_flush(journal);\n\t\tif (error < 0)\n\t\t\tgoto out;\n\t}\n\n\t/* Journal blocked and flushed, clear needs_recovery flag. */\n\tEXT4_CLEAR_INCOMPAT_FEATURE(sb, EXT4_FEATURE_INCOMPAT_RECOVER);\n\terror = ext4_commit_super(sb, 1);\nout:\n\tif (journal)\n\t\t/* we rely on upper layer to stop further updates */\n\t\tjbd2_journal_unlock_updates(journal);\n\treturn error;\n}",
    "includes": [
      "#include <trace/events/ext4.h>",
      "#include \"mballoc.h\"",
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"ext4_jbd2.h\"",
      "#include \"ext4_extents.h\"\t/* Needed for trace points definition */",
      "#include \"ext4.h\"",
      "#include <linux/freezer.h>",
      "#include <linux/kthread.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/cleancache.h>",
      "#include <linux/crc16.h>",
      "#include <linux/log2.h>",
      "#include <linux/ctype.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/namei.h>",
      "#include <linux/mount.h>",
      "#include <linux/random.h>",
      "#include <linux/vfs.h>",
      "#include <linux/exportfs.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/parser.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/init.h>",
      "#include <linux/slab.h>",
      "#include <linux/jbd2.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/time.h>",
      "#include <linux/fs.h>",
      "#include <linux/string.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ext4_unfreeze(struct super_block *sb);",
      "static int ext4_freeze(struct super_block *sb);",
      "static inline int ext2_feature_set_ok(struct super_block *sb);",
      "static inline int ext3_feature_set_ok(struct super_block *sb);",
      "static void ext4_unregister_li_request(struct super_block *sb);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "jbd2_journal_unlock_updates",
          "args": [
            "journal"
          ],
          "line": 4797
        },
        "resolved": true,
        "details": {
          "function_name": "jbd2_journal_unlock_updates",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd2/transaction.c",
          "lines": "744-753",
          "snippet": "void jbd2_journal_unlock_updates (journal_t *journal)\n{\n\tJ_ASSERT(journal->j_barrier_count != 0);\n\n\tmutex_unlock(&journal->j_barrier);\n\twrite_lock(&journal->j_state_lock);\n\t--journal->j_barrier_count;\n\twrite_unlock(&journal->j_state_lock);\n\twake_up(&journal->j_wait_transaction_locked);\n}",
          "includes": [
            "#include <trace/events/jbd2.h>",
            "#include <linux/module.h>",
            "#include <linux/bug.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/timer.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/jbd2.h>\n#include <linux/module.h>\n#include <linux/bug.h>\n#include <linux/backing-dev.h>\n#include <linux/hrtimer.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/timer.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd2.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n\nvoid jbd2_journal_unlock_updates (journal_t *journal)\n{\n\tJ_ASSERT(journal->j_barrier_count != 0);\n\n\tmutex_unlock(&journal->j_barrier);\n\twrite_lock(&journal->j_state_lock);\n\t--journal->j_barrier_count;\n\twrite_unlock(&journal->j_state_lock);\n\twake_up(&journal->j_wait_transaction_locked);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_commit_super",
          "args": [
            "sb",
            "1"
          ],
          "line": 4793
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_commit_super",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/super.c",
          "lines": "4567-4634",
          "snippet": "static int ext4_commit_super(struct super_block *sb, int sync)\n{\n\tstruct ext4_super_block *es = EXT4_SB(sb)->s_es;\n\tstruct buffer_head *sbh = EXT4_SB(sb)->s_sbh;\n\tint error = 0;\n\n\tif (!sbh || block_device_ejected(sb))\n\t\treturn error;\n\tif (buffer_write_io_error(sbh)) {\n\t\t/*\n\t\t * Oh, dear.  A previous attempt to write the\n\t\t * superblock failed.  This could happen because the\n\t\t * USB device was yanked out.  Or it could happen to\n\t\t * be a transient write error and maybe the block will\n\t\t * be remapped.  Nothing we can do but to retry the\n\t\t * write and hope for the best.\n\t\t */\n\t\text4_msg(sb, KERN_ERR, \"previous I/O error to \"\n\t\t       \"superblock detected\");\n\t\tclear_buffer_write_io_error(sbh);\n\t\tset_buffer_uptodate(sbh);\n\t}\n\t/*\n\t * If the file system is mounted read-only, don't update the\n\t * superblock write time.  This avoids updating the superblock\n\t * write time when we are mounting the root file system\n\t * read/only but we need to replay the journal; at that point,\n\t * for people who are east of GMT and who make their clock\n\t * tick in localtime for Windows bug-for-bug compatibility,\n\t * the clock is set in the future, and this will cause e2fsck\n\t * to complain and force a full file system check.\n\t */\n\tif (!(sb->s_flags & MS_RDONLY))\n\t\tes->s_wtime = cpu_to_le32(get_seconds());\n\tif (sb->s_bdev->bd_part)\n\t\tes->s_kbytes_written =\n\t\t\tcpu_to_le64(EXT4_SB(sb)->s_kbytes_written +\n\t\t\t    ((part_stat_read(sb->s_bdev->bd_part, sectors[1]) -\n\t\t\t      EXT4_SB(sb)->s_sectors_written_start) >> 1));\n\telse\n\t\tes->s_kbytes_written =\n\t\t\tcpu_to_le64(EXT4_SB(sb)->s_kbytes_written);\n\tif (percpu_counter_initialized(&EXT4_SB(sb)->s_freeclusters_counter))\n\t\text4_free_blocks_count_set(es,\n\t\t\tEXT4_C2B(EXT4_SB(sb), percpu_counter_sum_positive(\n\t\t\t\t&EXT4_SB(sb)->s_freeclusters_counter)));\n\tif (percpu_counter_initialized(&EXT4_SB(sb)->s_freeinodes_counter))\n\t\tes->s_free_inodes_count =\n\t\t\tcpu_to_le32(percpu_counter_sum_positive(\n\t\t\t\t&EXT4_SB(sb)->s_freeinodes_counter));\n\tBUFFER_TRACE(sbh, \"marking dirty\");\n\text4_superblock_csum_set(sb);\n\tmark_buffer_dirty(sbh);\n\tif (sync) {\n\t\terror = sync_dirty_buffer(sbh);\n\t\tif (error)\n\t\t\treturn error;\n\n\t\terror = buffer_write_io_error(sbh);\n\t\tif (error) {\n\t\t\text4_msg(sb, KERN_ERR, \"I/O error while writing \"\n\t\t\t       \"superblock\");\n\t\t\tclear_buffer_write_io_error(sbh);\n\t\t\tset_buffer_uptodate(sbh);\n\t\t}\n\t}\n\treturn error;\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"mballoc.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include \"ext4_extents.h\"\t/* Needed for trace points definition */",
            "#include \"ext4.h\"",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/crc16.h>",
            "#include <linux/log2.h>",
            "#include <linux/ctype.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/random.h>",
            "#include <linux/vfs.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/parser.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/time.h>",
            "#include <linux/fs.h>",
            "#include <linux/string.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ext4_show_options(struct seq_file *seq, struct dentry *root);",
            "static int ext4_commit_super(struct super_block *sb, int sync);",
            "static void ext4_mark_recovery_complete(struct super_block *sb,\n\t\t\t\t\tstruct ext4_super_block *es);",
            "static void ext4_clear_journal_err(struct super_block *sb,\n\t\t\t\t   struct ext4_super_block *es);",
            "static int ext4_unfreeze(struct super_block *sb);",
            "static int ext4_freeze(struct super_block *sb);",
            "static inline int ext2_feature_set_ok(struct super_block *sb);",
            "static inline int ext3_feature_set_ok(struct super_block *sb);",
            "static void ext4_unregister_li_request(struct super_block *sb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"mballoc.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4_extents.h\"\t/* Needed for trace points definition */\n#include \"ext4.h\"\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <asm/uaccess.h>\n#include <linux/cleancache.h>\n#include <linux/crc16.h>\n#include <linux/log2.h>\n#include <linux/ctype.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/random.h>\n#include <linux/vfs.h>\n#include <linux/exportfs.h>\n#include <linux/buffer_head.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/jbd2.h>\n#include <linux/vmalloc.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n#include <linux/string.h>\n#include <linux/module.h>\n\nstatic int ext4_show_options(struct seq_file *seq, struct dentry *root);\nstatic int ext4_commit_super(struct super_block *sb, int sync);\nstatic void ext4_mark_recovery_complete(struct super_block *sb,\n\t\t\t\t\tstruct ext4_super_block *es);\nstatic void ext4_clear_journal_err(struct super_block *sb,\n\t\t\t\t   struct ext4_super_block *es);\nstatic int ext4_unfreeze(struct super_block *sb);\nstatic int ext4_freeze(struct super_block *sb);\nstatic inline int ext2_feature_set_ok(struct super_block *sb);\nstatic inline int ext3_feature_set_ok(struct super_block *sb);\nstatic void ext4_unregister_li_request(struct super_block *sb);\n\nstatic int ext4_commit_super(struct super_block *sb, int sync)\n{\n\tstruct ext4_super_block *es = EXT4_SB(sb)->s_es;\n\tstruct buffer_head *sbh = EXT4_SB(sb)->s_sbh;\n\tint error = 0;\n\n\tif (!sbh || block_device_ejected(sb))\n\t\treturn error;\n\tif (buffer_write_io_error(sbh)) {\n\t\t/*\n\t\t * Oh, dear.  A previous attempt to write the\n\t\t * superblock failed.  This could happen because the\n\t\t * USB device was yanked out.  Or it could happen to\n\t\t * be a transient write error and maybe the block will\n\t\t * be remapped.  Nothing we can do but to retry the\n\t\t * write and hope for the best.\n\t\t */\n\t\text4_msg(sb, KERN_ERR, \"previous I/O error to \"\n\t\t       \"superblock detected\");\n\t\tclear_buffer_write_io_error(sbh);\n\t\tset_buffer_uptodate(sbh);\n\t}\n\t/*\n\t * If the file system is mounted read-only, don't update the\n\t * superblock write time.  This avoids updating the superblock\n\t * write time when we are mounting the root file system\n\t * read/only but we need to replay the journal; at that point,\n\t * for people who are east of GMT and who make their clock\n\t * tick in localtime for Windows bug-for-bug compatibility,\n\t * the clock is set in the future, and this will cause e2fsck\n\t * to complain and force a full file system check.\n\t */\n\tif (!(sb->s_flags & MS_RDONLY))\n\t\tes->s_wtime = cpu_to_le32(get_seconds());\n\tif (sb->s_bdev->bd_part)\n\t\tes->s_kbytes_written =\n\t\t\tcpu_to_le64(EXT4_SB(sb)->s_kbytes_written +\n\t\t\t    ((part_stat_read(sb->s_bdev->bd_part, sectors[1]) -\n\t\t\t      EXT4_SB(sb)->s_sectors_written_start) >> 1));\n\telse\n\t\tes->s_kbytes_written =\n\t\t\tcpu_to_le64(EXT4_SB(sb)->s_kbytes_written);\n\tif (percpu_counter_initialized(&EXT4_SB(sb)->s_freeclusters_counter))\n\t\text4_free_blocks_count_set(es,\n\t\t\tEXT4_C2B(EXT4_SB(sb), percpu_counter_sum_positive(\n\t\t\t\t&EXT4_SB(sb)->s_freeclusters_counter)));\n\tif (percpu_counter_initialized(&EXT4_SB(sb)->s_freeinodes_counter))\n\t\tes->s_free_inodes_count =\n\t\t\tcpu_to_le32(percpu_counter_sum_positive(\n\t\t\t\t&EXT4_SB(sb)->s_freeinodes_counter));\n\tBUFFER_TRACE(sbh, \"marking dirty\");\n\text4_superblock_csum_set(sb);\n\tmark_buffer_dirty(sbh);\n\tif (sync) {\n\t\terror = sync_dirty_buffer(sbh);\n\t\tif (error)\n\t\t\treturn error;\n\n\t\terror = buffer_write_io_error(sbh);\n\t\tif (error) {\n\t\t\text4_msg(sb, KERN_ERR, \"I/O error while writing \"\n\t\t\t       \"superblock\");\n\t\t\tclear_buffer_write_io_error(sbh);\n\t\t\tset_buffer_uptodate(sbh);\n\t\t}\n\t}\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "EXT4_CLEAR_INCOMPAT_FEATURE",
          "args": [
            "sb",
            "EXT4_FEATURE_INCOMPAT_RECOVER"
          ],
          "line": 4792
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "jbd2_journal_flush",
          "args": [
            "journal"
          ],
          "line": 4786
        },
        "resolved": true,
        "details": {
          "function_name": "jbd2_journal_flush",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd2/journal.c",
          "lines": "1914-1970",
          "snippet": "int jbd2_journal_flush(journal_t *journal)\n{\n\tint err = 0;\n\ttransaction_t *transaction = NULL;\n\n\twrite_lock(&journal->j_state_lock);\n\n\t/* Force everything buffered to the log... */\n\tif (journal->j_running_transaction) {\n\t\ttransaction = journal->j_running_transaction;\n\t\t__jbd2_log_start_commit(journal, transaction->t_tid);\n\t} else if (journal->j_committing_transaction)\n\t\ttransaction = journal->j_committing_transaction;\n\n\t/* Wait for the log commit to complete... */\n\tif (transaction) {\n\t\ttid_t tid = transaction->t_tid;\n\n\t\twrite_unlock(&journal->j_state_lock);\n\t\tjbd2_log_wait_commit(journal, tid);\n\t} else {\n\t\twrite_unlock(&journal->j_state_lock);\n\t}\n\n\t/* ...and flush everything in the log out to disk. */\n\tspin_lock(&journal->j_list_lock);\n\twhile (!err && journal->j_checkpoint_transactions != NULL) {\n\t\tspin_unlock(&journal->j_list_lock);\n\t\tmutex_lock(&journal->j_checkpoint_mutex);\n\t\terr = jbd2_log_do_checkpoint(journal);\n\t\tmutex_unlock(&journal->j_checkpoint_mutex);\n\t\tspin_lock(&journal->j_list_lock);\n\t}\n\tspin_unlock(&journal->j_list_lock);\n\n\tif (is_journal_aborted(journal))\n\t\treturn -EIO;\n\n\tmutex_lock(&journal->j_checkpoint_mutex);\n\tjbd2_cleanup_journal_tail(journal);\n\n\t/* Finally, mark the journal as really needing no recovery.\n\t * This sets s_start==0 in the underlying superblock, which is\n\t * the magic code for a fully-recovered superblock.  Any future\n\t * commits of data to the journal will restore the current\n\t * s_start value. */\n\tjbd2_mark_journal_empty(journal);\n\tmutex_unlock(&journal->j_checkpoint_mutex);\n\twrite_lock(&journal->j_state_lock);\n\tJ_ASSERT(!journal->j_running_transaction);\n\tJ_ASSERT(!journal->j_committing_transaction);\n\tJ_ASSERT(!journal->j_checkpoint_transactions);\n\tJ_ASSERT(journal->j_head == journal->j_tail);\n\tJ_ASSERT(journal->j_tail_sequence == journal->j_transaction_sequence);\n\twrite_unlock(&journal->j_state_lock);\n\treturn 0;\n}",
          "includes": [
            "#include <asm/page.h>",
            "#include <asm/uaccess.h>",
            "#include <trace/events/jbd2.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/bitops.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/log2.h>",
            "#include <linux/hash.h>",
            "#include <linux/math64.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/poison.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <trace/events/jbd2.h>\n#include <linux/ratelimit.h>\n#include <linux/bitops.h>\n#include <linux/backing-dev.h>\n#include <linux/vmalloc.h>\n#include <linux/log2.h>\n#include <linux/hash.h>\n#include <linux/math64.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/poison.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/freezer.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd2.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/module.h>\n\nint jbd2_journal_flush(journal_t *journal)\n{\n\tint err = 0;\n\ttransaction_t *transaction = NULL;\n\n\twrite_lock(&journal->j_state_lock);\n\n\t/* Force everything buffered to the log... */\n\tif (journal->j_running_transaction) {\n\t\ttransaction = journal->j_running_transaction;\n\t\t__jbd2_log_start_commit(journal, transaction->t_tid);\n\t} else if (journal->j_committing_transaction)\n\t\ttransaction = journal->j_committing_transaction;\n\n\t/* Wait for the log commit to complete... */\n\tif (transaction) {\n\t\ttid_t tid = transaction->t_tid;\n\n\t\twrite_unlock(&journal->j_state_lock);\n\t\tjbd2_log_wait_commit(journal, tid);\n\t} else {\n\t\twrite_unlock(&journal->j_state_lock);\n\t}\n\n\t/* ...and flush everything in the log out to disk. */\n\tspin_lock(&journal->j_list_lock);\n\twhile (!err && journal->j_checkpoint_transactions != NULL) {\n\t\tspin_unlock(&journal->j_list_lock);\n\t\tmutex_lock(&journal->j_checkpoint_mutex);\n\t\terr = jbd2_log_do_checkpoint(journal);\n\t\tmutex_unlock(&journal->j_checkpoint_mutex);\n\t\tspin_lock(&journal->j_list_lock);\n\t}\n\tspin_unlock(&journal->j_list_lock);\n\n\tif (is_journal_aborted(journal))\n\t\treturn -EIO;\n\n\tmutex_lock(&journal->j_checkpoint_mutex);\n\tjbd2_cleanup_journal_tail(journal);\n\n\t/* Finally, mark the journal as really needing no recovery.\n\t * This sets s_start==0 in the underlying superblock, which is\n\t * the magic code for a fully-recovered superblock.  Any future\n\t * commits of data to the journal will restore the current\n\t * s_start value. */\n\tjbd2_mark_journal_empty(journal);\n\tmutex_unlock(&journal->j_checkpoint_mutex);\n\twrite_lock(&journal->j_state_lock);\n\tJ_ASSERT(!journal->j_running_transaction);\n\tJ_ASSERT(!journal->j_committing_transaction);\n\tJ_ASSERT(!journal->j_checkpoint_transactions);\n\tJ_ASSERT(journal->j_head == journal->j_tail);\n\tJ_ASSERT(journal->j_tail_sequence == journal->j_transaction_sequence);\n\twrite_unlock(&journal->j_state_lock);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "jbd2_journal_lock_updates",
          "args": [
            "journal"
          ],
          "line": 4780
        },
        "resolved": true,
        "details": {
          "function_name": "jbd2_journal_lock_updates",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd2/transaction.c",
          "lines": "689-734",
          "snippet": "void jbd2_journal_lock_updates(journal_t *journal)\n{\n\tDEFINE_WAIT(wait);\n\n\twrite_lock(&journal->j_state_lock);\n\t++journal->j_barrier_count;\n\n\t/* Wait until there are no reserved handles */\n\tif (atomic_read(&journal->j_reserved_credits)) {\n\t\twrite_unlock(&journal->j_state_lock);\n\t\twait_event(journal->j_wait_reserved,\n\t\t\t   atomic_read(&journal->j_reserved_credits) == 0);\n\t\twrite_lock(&journal->j_state_lock);\n\t}\n\n\t/* Wait until there are no running updates */\n\twhile (1) {\n\t\ttransaction_t *transaction = journal->j_running_transaction;\n\n\t\tif (!transaction)\n\t\t\tbreak;\n\n\t\tspin_lock(&transaction->t_handle_lock);\n\t\tprepare_to_wait(&journal->j_wait_updates, &wait,\n\t\t\t\tTASK_UNINTERRUPTIBLE);\n\t\tif (!atomic_read(&transaction->t_updates)) {\n\t\t\tspin_unlock(&transaction->t_handle_lock);\n\t\t\tfinish_wait(&journal->j_wait_updates, &wait);\n\t\t\tbreak;\n\t\t}\n\t\tspin_unlock(&transaction->t_handle_lock);\n\t\twrite_unlock(&journal->j_state_lock);\n\t\tschedule();\n\t\tfinish_wait(&journal->j_wait_updates, &wait);\n\t\twrite_lock(&journal->j_state_lock);\n\t}\n\twrite_unlock(&journal->j_state_lock);\n\n\t/*\n\t * We have now established a barrier against other normal updates, but\n\t * we also need to barrier against other jbd2_journal_lock_updates() calls\n\t * to make sure that we serialise special journal-locked operations\n\t * too.\n\t */\n\tmutex_lock(&journal->j_barrier);\n}",
          "includes": [
            "#include <trace/events/jbd2.h>",
            "#include <linux/module.h>",
            "#include <linux/bug.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/timer.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/jbd2.h>\n#include <linux/module.h>\n#include <linux/bug.h>\n#include <linux/backing-dev.h>\n#include <linux/hrtimer.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/timer.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd2.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n\nvoid jbd2_journal_lock_updates(journal_t *journal)\n{\n\tDEFINE_WAIT(wait);\n\n\twrite_lock(&journal->j_state_lock);\n\t++journal->j_barrier_count;\n\n\t/* Wait until there are no reserved handles */\n\tif (atomic_read(&journal->j_reserved_credits)) {\n\t\twrite_unlock(&journal->j_state_lock);\n\t\twait_event(journal->j_wait_reserved,\n\t\t\t   atomic_read(&journal->j_reserved_credits) == 0);\n\t\twrite_lock(&journal->j_state_lock);\n\t}\n\n\t/* Wait until there are no running updates */\n\twhile (1) {\n\t\ttransaction_t *transaction = journal->j_running_transaction;\n\n\t\tif (!transaction)\n\t\t\tbreak;\n\n\t\tspin_lock(&transaction->t_handle_lock);\n\t\tprepare_to_wait(&journal->j_wait_updates, &wait,\n\t\t\t\tTASK_UNINTERRUPTIBLE);\n\t\tif (!atomic_read(&transaction->t_updates)) {\n\t\t\tspin_unlock(&transaction->t_handle_lock);\n\t\t\tfinish_wait(&journal->j_wait_updates, &wait);\n\t\t\tbreak;\n\t\t}\n\t\tspin_unlock(&transaction->t_handle_lock);\n\t\twrite_unlock(&journal->j_state_lock);\n\t\tschedule();\n\t\tfinish_wait(&journal->j_wait_updates, &wait);\n\t\twrite_lock(&journal->j_state_lock);\n\t}\n\twrite_unlock(&journal->j_state_lock);\n\n\t/*\n\t * We have now established a barrier against other normal updates, but\n\t * we also need to barrier against other jbd2_journal_lock_updates() calls\n\t * to make sure that we serialise special journal-locked operations\n\t * too.\n\t */\n\tmutex_lock(&journal->j_barrier);\n}"
        }
      },
      {
        "call_info": {
          "callee": "EXT4_SB",
          "args": [
            "sb"
          ],
          "line": 4776
        },
        "resolved": true,
        "details": {
          "function_name": "EXT4_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ext4.h",
          "lines": "1356-1359",
          "snippet": "static inline struct ext4_sb_info *EXT4_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include \"extents_status.h\"",
            "#include <linux/compat.h>",
            "#include <linux/falloc.h>",
            "#include <crypto/hash.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/wait.h>",
            "#include <linux/timer.h>",
            "#include <linux/mutex.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/quota.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extents_status.h\"\n#include <linux/compat.h>\n#include <linux/falloc.h>\n#include <crypto/hash.h>\n#include <linux/ratelimit.h>\n#include <linux/percpu_counter.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/wait.h>\n#include <linux/timer.h>\n#include <linux/mutex.h>\n#include <linux/seqlock.h>\n#include <linux/rbtree.h>\n#include <linux/rwsem.h>\n#include <linux/quota.h>\n#include <linux/jbd2.h>\n#include <linux/magic.h>\n#include <linux/blkdev.h>\n#include <linux/types.h>\n\nstatic inline struct ext4_sb_info *EXT4_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"mballoc.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4_extents.h\"\t/* Needed for trace points definition */\n#include \"ext4.h\"\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <asm/uaccess.h>\n#include <linux/cleancache.h>\n#include <linux/crc16.h>\n#include <linux/log2.h>\n#include <linux/ctype.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/random.h>\n#include <linux/vfs.h>\n#include <linux/exportfs.h>\n#include <linux/buffer_head.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/jbd2.h>\n#include <linux/vmalloc.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n#include <linux/string.h>\n#include <linux/module.h>\n\nstatic int ext4_unfreeze(struct super_block *sb);\nstatic int ext4_freeze(struct super_block *sb);\nstatic inline int ext2_feature_set_ok(struct super_block *sb);\nstatic inline int ext3_feature_set_ok(struct super_block *sb);\nstatic void ext4_unregister_li_request(struct super_block *sb);\n\nstatic int ext4_freeze(struct super_block *sb)\n{\n\tint error = 0;\n\tjournal_t *journal;\n\n\tif (sb->s_flags & MS_RDONLY)\n\t\treturn 0;\n\n\tjournal = EXT4_SB(sb)->s_journal;\n\n\tif (journal) {\n\t\t/* Now we set up the journal barrier. */\n\t\tjbd2_journal_lock_updates(journal);\n\n\t\t/*\n\t\t * Don't clear the needs_recovery flag if we failed to\n\t\t * flush the journal.\n\t\t */\n\t\terror = jbd2_journal_flush(journal);\n\t\tif (error < 0)\n\t\t\tgoto out;\n\t}\n\n\t/* Journal blocked and flushed, clear needs_recovery flag. */\n\tEXT4_CLEAR_INCOMPAT_FEATURE(sb, EXT4_FEATURE_INCOMPAT_RECOVER);\n\terror = ext4_commit_super(sb, 1);\nout:\n\tif (journal)\n\t\t/* we rely on upper layer to stop further updates */\n\t\tjbd2_journal_unlock_updates(journal);\n\treturn error;\n}"
  },
  {
    "function_name": "ext4_sync_fs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/super.c",
    "lines": "4718-4758",
    "snippet": "static int ext4_sync_fs(struct super_block *sb, int wait)\n{\n\tint ret = 0;\n\ttid_t target;\n\tbool needs_barrier = false;\n\tstruct ext4_sb_info *sbi = EXT4_SB(sb);\n\n\ttrace_ext4_sync_fs(sb, wait);\n\tflush_workqueue(sbi->rsv_conversion_wq);\n\t/*\n\t * Writeback quota in non-journalled quota case - journalled quota has\n\t * no dirty dquots\n\t */\n\tdquot_writeback_dquots(sb, -1);\n\t/*\n\t * Data writeback is possible w/o journal transaction, so barrier must\n\t * being sent at the end of the function. But we can skip it if\n\t * transaction_commit will do it for us.\n\t */\n\tif (sbi->s_journal) {\n\t\ttarget = jbd2_get_latest_transaction(sbi->s_journal);\n\t\tif (wait && sbi->s_journal->j_flags & JBD2_BARRIER &&\n\t\t    !jbd2_trans_will_send_data_barrier(sbi->s_journal, target))\n\t\t\tneeds_barrier = true;\n\n\t\tif (jbd2_journal_start_commit(sbi->s_journal, &target)) {\n\t\t\tif (wait)\n\t\t\t\tret = jbd2_log_wait_commit(sbi->s_journal,\n\t\t\t\t\t\t\t   target);\n\t\t}\n\t} else if (wait && test_opt(sb, BARRIER))\n\t\tneeds_barrier = true;\n\tif (needs_barrier) {\n\t\tint err;\n\t\terr = blkdev_issue_flush(sb->s_bdev, GFP_KERNEL, NULL);\n\t\tif (!ret)\n\t\t\tret = err;\n\t}\n\n\treturn ret;\n}",
    "includes": [
      "#include <trace/events/ext4.h>",
      "#include \"mballoc.h\"",
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"ext4_jbd2.h\"",
      "#include \"ext4_extents.h\"\t/* Needed for trace points definition */",
      "#include \"ext4.h\"",
      "#include <linux/freezer.h>",
      "#include <linux/kthread.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/cleancache.h>",
      "#include <linux/crc16.h>",
      "#include <linux/log2.h>",
      "#include <linux/ctype.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/namei.h>",
      "#include <linux/mount.h>",
      "#include <linux/random.h>",
      "#include <linux/vfs.h>",
      "#include <linux/exportfs.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/parser.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/init.h>",
      "#include <linux/slab.h>",
      "#include <linux/jbd2.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/time.h>",
      "#include <linux/fs.h>",
      "#include <linux/string.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ext4_sync_fs(struct super_block *sb, int wait);",
      "static int ext4_unfreeze(struct super_block *sb);",
      "static int ext4_freeze(struct super_block *sb);",
      "static inline int ext2_feature_set_ok(struct super_block *sb);",
      "static inline int ext3_feature_set_ok(struct super_block *sb);",
      "static void ext4_unregister_li_request(struct super_block *sb);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "blkdev_issue_flush",
          "args": [
            "sb->s_bdev",
            "GFP_KERNEL",
            "NULL"
          ],
          "line": 4752
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_opt",
          "args": [
            "sb",
            "BARRIER"
          ],
          "line": 4748
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "jbd2_log_wait_commit",
          "args": [
            "sbi->s_journal",
            "target"
          ],
          "line": 4745
        },
        "resolved": true,
        "details": {
          "function_name": "jbd2_log_wait_commit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd2/journal.c",
          "lines": "698-724",
          "snippet": "int jbd2_log_wait_commit(journal_t *journal, tid_t tid)\n{\n\tint err = 0;\n\n\tread_lock(&journal->j_state_lock);\n#ifdef CONFIG_JBD2_DEBUG\n\tif (!tid_geq(journal->j_commit_request, tid)) {\n\t\tprintk(KERN_ERR\n\t\t       \"%s: error: j_commit_request=%d, tid=%d\\n\",\n\t\t       __func__, journal->j_commit_request, tid);\n\t}\n#endif\n\twhile (tid_gt(tid, journal->j_commit_sequence)) {\n\t\tjbd_debug(1, \"JBD2: want %d, j_commit_sequence=%d\\n\",\n\t\t\t\t  tid, journal->j_commit_sequence);\n\t\tread_unlock(&journal->j_state_lock);\n\t\twake_up(&journal->j_wait_commit);\n\t\twait_event(journal->j_wait_done_commit,\n\t\t\t\t!tid_gt(tid, journal->j_commit_sequence));\n\t\tread_lock(&journal->j_state_lock);\n\t}\n\tread_unlock(&journal->j_state_lock);\n\n\tif (unlikely(is_journal_aborted(journal)))\n\t\terr = -EIO;\n\treturn err;\n}",
          "includes": [
            "#include <asm/page.h>",
            "#include <asm/uaccess.h>",
            "#include <trace/events/jbd2.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/bitops.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/log2.h>",
            "#include <linux/hash.h>",
            "#include <linux/math64.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/poison.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <trace/events/jbd2.h>\n#include <linux/ratelimit.h>\n#include <linux/bitops.h>\n#include <linux/backing-dev.h>\n#include <linux/vmalloc.h>\n#include <linux/log2.h>\n#include <linux/hash.h>\n#include <linux/math64.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/poison.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/freezer.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd2.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/module.h>\n\nint jbd2_log_wait_commit(journal_t *journal, tid_t tid)\n{\n\tint err = 0;\n\n\tread_lock(&journal->j_state_lock);\n#ifdef CONFIG_JBD2_DEBUG\n\tif (!tid_geq(journal->j_commit_request, tid)) {\n\t\tprintk(KERN_ERR\n\t\t       \"%s: error: j_commit_request=%d, tid=%d\\n\",\n\t\t       __func__, journal->j_commit_request, tid);\n\t}\n#endif\n\twhile (tid_gt(tid, journal->j_commit_sequence)) {\n\t\tjbd_debug(1, \"JBD2: want %d, j_commit_sequence=%d\\n\",\n\t\t\t\t  tid, journal->j_commit_sequence);\n\t\tread_unlock(&journal->j_state_lock);\n\t\twake_up(&journal->j_wait_commit);\n\t\twait_event(journal->j_wait_done_commit,\n\t\t\t\t!tid_gt(tid, journal->j_commit_sequence));\n\t\tread_lock(&journal->j_state_lock);\n\t}\n\tread_unlock(&journal->j_state_lock);\n\n\tif (unlikely(is_journal_aborted(journal)))\n\t\terr = -EIO;\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "jbd2_journal_start_commit",
          "args": [
            "sbi->s_journal",
            "&target"
          ],
          "line": 4743
        },
        "resolved": true,
        "details": {
          "function_name": "jbd2_journal_start_commit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd2/journal.c",
          "lines": "626-651",
          "snippet": "int jbd2_journal_start_commit(journal_t *journal, tid_t *ptid)\n{\n\tint ret = 0;\n\n\twrite_lock(&journal->j_state_lock);\n\tif (journal->j_running_transaction) {\n\t\ttid_t tid = journal->j_running_transaction->t_tid;\n\n\t\t__jbd2_log_start_commit(journal, tid);\n\t\t/* There's a running transaction and we've just made sure\n\t\t * it's commit has been scheduled. */\n\t\tif (ptid)\n\t\t\t*ptid = tid;\n\t\tret = 1;\n\t} else if (journal->j_committing_transaction) {\n\t\t/*\n\t\t * If commit has been started, then we have to wait for\n\t\t * completion of that transaction.\n\t\t */\n\t\tif (ptid)\n\t\t\t*ptid = journal->j_committing_transaction->t_tid;\n\t\tret = 1;\n\t}\n\twrite_unlock(&journal->j_state_lock);\n\treturn ret;\n}",
          "includes": [
            "#include <asm/page.h>",
            "#include <asm/uaccess.h>",
            "#include <trace/events/jbd2.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/bitops.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/log2.h>",
            "#include <linux/hash.h>",
            "#include <linux/math64.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/poison.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <trace/events/jbd2.h>\n#include <linux/ratelimit.h>\n#include <linux/bitops.h>\n#include <linux/backing-dev.h>\n#include <linux/vmalloc.h>\n#include <linux/log2.h>\n#include <linux/hash.h>\n#include <linux/math64.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/poison.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/freezer.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd2.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/module.h>\n\nint jbd2_journal_start_commit(journal_t *journal, tid_t *ptid)\n{\n\tint ret = 0;\n\n\twrite_lock(&journal->j_state_lock);\n\tif (journal->j_running_transaction) {\n\t\ttid_t tid = journal->j_running_transaction->t_tid;\n\n\t\t__jbd2_log_start_commit(journal, tid);\n\t\t/* There's a running transaction and we've just made sure\n\t\t * it's commit has been scheduled. */\n\t\tif (ptid)\n\t\t\t*ptid = tid;\n\t\tret = 1;\n\t} else if (journal->j_committing_transaction) {\n\t\t/*\n\t\t * If commit has been started, then we have to wait for\n\t\t * completion of that transaction.\n\t\t */\n\t\tif (ptid)\n\t\t\t*ptid = journal->j_committing_transaction->t_tid;\n\t\tret = 1;\n\t}\n\twrite_unlock(&journal->j_state_lock);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "jbd2_trans_will_send_data_barrier",
          "args": [
            "sbi->s_journal",
            "target"
          ],
          "line": 4740
        },
        "resolved": true,
        "details": {
          "function_name": "jbd2_trans_will_send_data_barrier",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd2/journal.c",
          "lines": "659-691",
          "snippet": "int jbd2_trans_will_send_data_barrier(journal_t *journal, tid_t tid)\n{\n\tint ret = 0;\n\ttransaction_t *commit_trans;\n\n\tif (!(journal->j_flags & JBD2_BARRIER))\n\t\treturn 0;\n\tread_lock(&journal->j_state_lock);\n\t/* Transaction already committed? */\n\tif (tid_geq(journal->j_commit_sequence, tid))\n\t\tgoto out;\n\tcommit_trans = journal->j_committing_transaction;\n\tif (!commit_trans || commit_trans->t_tid != tid) {\n\t\tret = 1;\n\t\tgoto out;\n\t}\n\t/*\n\t * Transaction is being committed and we already proceeded to\n\t * submitting a flush to fs partition?\n\t */\n\tif (journal->j_fs_dev != journal->j_dev) {\n\t\tif (!commit_trans->t_need_data_flush ||\n\t\t    commit_trans->t_state >= T_COMMIT_DFLUSH)\n\t\t\tgoto out;\n\t} else {\n\t\tif (commit_trans->t_state >= T_COMMIT_JFLUSH)\n\t\t\tgoto out;\n\t}\n\tret = 1;\nout:\n\tread_unlock(&journal->j_state_lock);\n\treturn ret;\n}",
          "includes": [
            "#include <asm/page.h>",
            "#include <asm/uaccess.h>",
            "#include <trace/events/jbd2.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/bitops.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/log2.h>",
            "#include <linux/hash.h>",
            "#include <linux/math64.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/poison.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <trace/events/jbd2.h>\n#include <linux/ratelimit.h>\n#include <linux/bitops.h>\n#include <linux/backing-dev.h>\n#include <linux/vmalloc.h>\n#include <linux/log2.h>\n#include <linux/hash.h>\n#include <linux/math64.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/poison.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/freezer.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd2.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/module.h>\n\nint jbd2_trans_will_send_data_barrier(journal_t *journal, tid_t tid)\n{\n\tint ret = 0;\n\ttransaction_t *commit_trans;\n\n\tif (!(journal->j_flags & JBD2_BARRIER))\n\t\treturn 0;\n\tread_lock(&journal->j_state_lock);\n\t/* Transaction already committed? */\n\tif (tid_geq(journal->j_commit_sequence, tid))\n\t\tgoto out;\n\tcommit_trans = journal->j_committing_transaction;\n\tif (!commit_trans || commit_trans->t_tid != tid) {\n\t\tret = 1;\n\t\tgoto out;\n\t}\n\t/*\n\t * Transaction is being committed and we already proceeded to\n\t * submitting a flush to fs partition?\n\t */\n\tif (journal->j_fs_dev != journal->j_dev) {\n\t\tif (!commit_trans->t_need_data_flush ||\n\t\t    commit_trans->t_state >= T_COMMIT_DFLUSH)\n\t\t\tgoto out;\n\t} else {\n\t\tif (commit_trans->t_state >= T_COMMIT_JFLUSH)\n\t\t\tgoto out;\n\t}\n\tret = 1;\nout:\n\tread_unlock(&journal->j_state_lock);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "jbd2_get_latest_transaction",
          "args": [
            "sbi->s_journal"
          ],
          "line": 4738
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dquot_writeback_dquots",
          "args": [
            "sb",
            "-1"
          ],
          "line": 4731
        },
        "resolved": true,
        "details": {
          "function_name": "dquot_writeback_dquots",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/quota/dquot.c",
          "lines": "605-652",
          "snippet": "int dquot_writeback_dquots(struct super_block *sb, int type)\n{\n\tstruct list_head *dirty;\n\tstruct dquot *dquot;\n\tstruct quota_info *dqopt = sb_dqopt(sb);\n\tint cnt;\n\tint err, ret = 0;\n\n\tmutex_lock(&dqopt->dqonoff_mutex);\n\tfor (cnt = 0; cnt < MAXQUOTAS; cnt++) {\n\t\tif (type != -1 && cnt != type)\n\t\t\tcontinue;\n\t\tif (!sb_has_quota_active(sb, cnt))\n\t\t\tcontinue;\n\t\tspin_lock(&dq_list_lock);\n\t\tdirty = &dqopt->info[cnt].dqi_dirty_list;\n\t\twhile (!list_empty(dirty)) {\n\t\t\tdquot = list_first_entry(dirty, struct dquot,\n\t\t\t\t\t\t dq_dirty);\n\t\t\t/* Dirty and inactive can be only bad dquot... */\n\t\t\tif (!test_bit(DQ_ACTIVE_B, &dquot->dq_flags)) {\n\t\t\t\tclear_dquot_dirty(dquot);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t/* Now we have active dquot from which someone is\n \t\t\t * holding reference so we can safely just increase\n\t\t\t * use count */\n\t\t\tdqgrab(dquot);\n\t\t\tspin_unlock(&dq_list_lock);\n\t\t\tdqstats_inc(DQST_LOOKUPS);\n\t\t\terr = sb->dq_op->write_dquot(dquot);\n\t\t\tif (!ret && err)\n\t\t\t\tret = err;\n\t\t\tdqput(dquot);\n\t\t\tspin_lock(&dq_list_lock);\n\t\t}\n\t\tspin_unlock(&dq_list_lock);\n\t}\n\n\tfor (cnt = 0; cnt < MAXQUOTAS; cnt++)\n\t\tif ((cnt == type || type == -1) && sb_has_quota_active(sb, cnt)\n\t\t    && info_dirty(&dqopt->info[cnt]))\n\t\t\tsb->dq_op->write_info(sb, cnt);\n\tdqstats_inc(DQST_SYNCS);\n\tmutex_unlock(&dqopt->dqonoff_mutex);\n\n\treturn ret;\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include \"../internal.h\" /* ugh */",
            "#include <linux/quotaops.h>",
            "#include <linux/capability.h>",
            "#include <linux/namei.h>",
            "#include <linux/kmod.h>",
            "#include <linux/sched.h>",
            "#include <linux/security.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>",
            "#include <linux/tty.h>",
            "#include <linux/stat.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/time.h>",
            "#include <linux/mm.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __cacheline_aligned_in_smp DEFINE_SPINLOCK(dq_list_lock);",
            "static void __dquot_initialize(struct inode *inode, int type);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include \"../internal.h\" /* ugh */\n#include <linux/quotaops.h>\n#include <linux/capability.h>\n#include <linux/namei.h>\n#include <linux/kmod.h>\n#include <linux/sched.h>\n#include <linux/security.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/sysctl.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/tty.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/time.h>\n#include <linux/mm.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/kernel.h>\n#include <linux/errno.h>\n\nstatic __cacheline_aligned_in_smp DEFINE_SPINLOCK(dq_list_lock);\nstatic void __dquot_initialize(struct inode *inode, int type);\n\nint dquot_writeback_dquots(struct super_block *sb, int type)\n{\n\tstruct list_head *dirty;\n\tstruct dquot *dquot;\n\tstruct quota_info *dqopt = sb_dqopt(sb);\n\tint cnt;\n\tint err, ret = 0;\n\n\tmutex_lock(&dqopt->dqonoff_mutex);\n\tfor (cnt = 0; cnt < MAXQUOTAS; cnt++) {\n\t\tif (type != -1 && cnt != type)\n\t\t\tcontinue;\n\t\tif (!sb_has_quota_active(sb, cnt))\n\t\t\tcontinue;\n\t\tspin_lock(&dq_list_lock);\n\t\tdirty = &dqopt->info[cnt].dqi_dirty_list;\n\t\twhile (!list_empty(dirty)) {\n\t\t\tdquot = list_first_entry(dirty, struct dquot,\n\t\t\t\t\t\t dq_dirty);\n\t\t\t/* Dirty and inactive can be only bad dquot... */\n\t\t\tif (!test_bit(DQ_ACTIVE_B, &dquot->dq_flags)) {\n\t\t\t\tclear_dquot_dirty(dquot);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t/* Now we have active dquot from which someone is\n \t\t\t * holding reference so we can safely just increase\n\t\t\t * use count */\n\t\t\tdqgrab(dquot);\n\t\t\tspin_unlock(&dq_list_lock);\n\t\t\tdqstats_inc(DQST_LOOKUPS);\n\t\t\terr = sb->dq_op->write_dquot(dquot);\n\t\t\tif (!ret && err)\n\t\t\t\tret = err;\n\t\t\tdqput(dquot);\n\t\t\tspin_lock(&dq_list_lock);\n\t\t}\n\t\tspin_unlock(&dq_list_lock);\n\t}\n\n\tfor (cnt = 0; cnt < MAXQUOTAS; cnt++)\n\t\tif ((cnt == type || type == -1) && sb_has_quota_active(sb, cnt)\n\t\t    && info_dirty(&dqopt->info[cnt]))\n\t\t\tsb->dq_op->write_info(sb, cnt);\n\tdqstats_inc(DQST_SYNCS);\n\tmutex_unlock(&dqopt->dqonoff_mutex);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "flush_workqueue",
          "args": [
            "sbi->rsv_conversion_wq"
          ],
          "line": 4726
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_ext4_sync_fs",
          "args": [
            "sb",
            "wait"
          ],
          "line": 4725
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXT4_SB",
          "args": [
            "sb"
          ],
          "line": 4723
        },
        "resolved": true,
        "details": {
          "function_name": "EXT4_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ext4.h",
          "lines": "1356-1359",
          "snippet": "static inline struct ext4_sb_info *EXT4_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include \"extents_status.h\"",
            "#include <linux/compat.h>",
            "#include <linux/falloc.h>",
            "#include <crypto/hash.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/wait.h>",
            "#include <linux/timer.h>",
            "#include <linux/mutex.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/quota.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extents_status.h\"\n#include <linux/compat.h>\n#include <linux/falloc.h>\n#include <crypto/hash.h>\n#include <linux/ratelimit.h>\n#include <linux/percpu_counter.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/wait.h>\n#include <linux/timer.h>\n#include <linux/mutex.h>\n#include <linux/seqlock.h>\n#include <linux/rbtree.h>\n#include <linux/rwsem.h>\n#include <linux/quota.h>\n#include <linux/jbd2.h>\n#include <linux/magic.h>\n#include <linux/blkdev.h>\n#include <linux/types.h>\n\nstatic inline struct ext4_sb_info *EXT4_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"mballoc.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4_extents.h\"\t/* Needed for trace points definition */\n#include \"ext4.h\"\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <asm/uaccess.h>\n#include <linux/cleancache.h>\n#include <linux/crc16.h>\n#include <linux/log2.h>\n#include <linux/ctype.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/random.h>\n#include <linux/vfs.h>\n#include <linux/exportfs.h>\n#include <linux/buffer_head.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/jbd2.h>\n#include <linux/vmalloc.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n#include <linux/string.h>\n#include <linux/module.h>\n\nstatic int ext4_sync_fs(struct super_block *sb, int wait);\nstatic int ext4_unfreeze(struct super_block *sb);\nstatic int ext4_freeze(struct super_block *sb);\nstatic inline int ext2_feature_set_ok(struct super_block *sb);\nstatic inline int ext3_feature_set_ok(struct super_block *sb);\nstatic void ext4_unregister_li_request(struct super_block *sb);\n\nstatic int ext4_sync_fs(struct super_block *sb, int wait)\n{\n\tint ret = 0;\n\ttid_t target;\n\tbool needs_barrier = false;\n\tstruct ext4_sb_info *sbi = EXT4_SB(sb);\n\n\ttrace_ext4_sync_fs(sb, wait);\n\tflush_workqueue(sbi->rsv_conversion_wq);\n\t/*\n\t * Writeback quota in non-journalled quota case - journalled quota has\n\t * no dirty dquots\n\t */\n\tdquot_writeback_dquots(sb, -1);\n\t/*\n\t * Data writeback is possible w/o journal transaction, so barrier must\n\t * being sent at the end of the function. But we can skip it if\n\t * transaction_commit will do it for us.\n\t */\n\tif (sbi->s_journal) {\n\t\ttarget = jbd2_get_latest_transaction(sbi->s_journal);\n\t\tif (wait && sbi->s_journal->j_flags & JBD2_BARRIER &&\n\t\t    !jbd2_trans_will_send_data_barrier(sbi->s_journal, target))\n\t\t\tneeds_barrier = true;\n\n\t\tif (jbd2_journal_start_commit(sbi->s_journal, &target)) {\n\t\t\tif (wait)\n\t\t\t\tret = jbd2_log_wait_commit(sbi->s_journal,\n\t\t\t\t\t\t\t   target);\n\t\t}\n\t} else if (wait && test_opt(sb, BARRIER))\n\t\tneeds_barrier = true;\n\tif (needs_barrier) {\n\t\tint err;\n\t\terr = blkdev_issue_flush(sb->s_bdev, GFP_KERNEL, NULL);\n\t\tif (!ret)\n\t\t\tret = err;\n\t}\n\n\treturn ret;\n}"
  },
  {
    "function_name": "ext4_force_commit",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/super.c",
    "lines": "4707-4716",
    "snippet": "int ext4_force_commit(struct super_block *sb)\n{\n\tjournal_t *journal;\n\n\tif (sb->s_flags & MS_RDONLY)\n\t\treturn 0;\n\n\tjournal = EXT4_SB(sb)->s_journal;\n\treturn ext4_journal_force_commit(journal);\n}",
    "includes": [
      "#include <trace/events/ext4.h>",
      "#include \"mballoc.h\"",
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"ext4_jbd2.h\"",
      "#include \"ext4_extents.h\"\t/* Needed for trace points definition */",
      "#include \"ext4.h\"",
      "#include <linux/freezer.h>",
      "#include <linux/kthread.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/cleancache.h>",
      "#include <linux/crc16.h>",
      "#include <linux/log2.h>",
      "#include <linux/ctype.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/namei.h>",
      "#include <linux/mount.h>",
      "#include <linux/random.h>",
      "#include <linux/vfs.h>",
      "#include <linux/exportfs.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/parser.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/init.h>",
      "#include <linux/slab.h>",
      "#include <linux/jbd2.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/time.h>",
      "#include <linux/fs.h>",
      "#include <linux/string.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ext4_unfreeze(struct super_block *sb);",
      "static int ext4_freeze(struct super_block *sb);",
      "static inline int ext2_feature_set_ok(struct super_block *sb);",
      "static inline int ext3_feature_set_ok(struct super_block *sb);",
      "static void ext4_unregister_li_request(struct super_block *sb);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ext4_journal_force_commit",
          "args": [
            "journal"
          ],
          "line": 4715
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_journal_force_commit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ext4_jbd2.h",
          "lines": "357-362",
          "snippet": "static inline int ext4_journal_force_commit(journal_t *journal)\n{\n\tif (journal)\n\t\treturn jbd2_journal_force_commit(journal);\n\treturn 0;\n}",
          "includes": [
            "#include \"ext4.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ext4.h\"\n#include <linux/jbd2.h>\n#include <linux/fs.h>\n\nstatic inline int ext4_journal_force_commit(journal_t *journal)\n{\n\tif (journal)\n\t\treturn jbd2_journal_force_commit(journal);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "EXT4_SB",
          "args": [
            "sb"
          ],
          "line": 4714
        },
        "resolved": true,
        "details": {
          "function_name": "EXT4_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ext4.h",
          "lines": "1356-1359",
          "snippet": "static inline struct ext4_sb_info *EXT4_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include \"extents_status.h\"",
            "#include <linux/compat.h>",
            "#include <linux/falloc.h>",
            "#include <crypto/hash.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/wait.h>",
            "#include <linux/timer.h>",
            "#include <linux/mutex.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/quota.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extents_status.h\"\n#include <linux/compat.h>\n#include <linux/falloc.h>\n#include <crypto/hash.h>\n#include <linux/ratelimit.h>\n#include <linux/percpu_counter.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/wait.h>\n#include <linux/timer.h>\n#include <linux/mutex.h>\n#include <linux/seqlock.h>\n#include <linux/rbtree.h>\n#include <linux/rwsem.h>\n#include <linux/quota.h>\n#include <linux/jbd2.h>\n#include <linux/magic.h>\n#include <linux/blkdev.h>\n#include <linux/types.h>\n\nstatic inline struct ext4_sb_info *EXT4_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"mballoc.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4_extents.h\"\t/* Needed for trace points definition */\n#include \"ext4.h\"\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <asm/uaccess.h>\n#include <linux/cleancache.h>\n#include <linux/crc16.h>\n#include <linux/log2.h>\n#include <linux/ctype.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/random.h>\n#include <linux/vfs.h>\n#include <linux/exportfs.h>\n#include <linux/buffer_head.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/jbd2.h>\n#include <linux/vmalloc.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n#include <linux/string.h>\n#include <linux/module.h>\n\nstatic int ext4_unfreeze(struct super_block *sb);\nstatic int ext4_freeze(struct super_block *sb);\nstatic inline int ext2_feature_set_ok(struct super_block *sb);\nstatic inline int ext3_feature_set_ok(struct super_block *sb);\nstatic void ext4_unregister_li_request(struct super_block *sb);\n\nint ext4_force_commit(struct super_block *sb)\n{\n\tjournal_t *journal;\n\n\tif (sb->s_flags & MS_RDONLY)\n\t\treturn 0;\n\n\tjournal = EXT4_SB(sb)->s_journal;\n\treturn ext4_journal_force_commit(journal);\n}"
  },
  {
    "function_name": "ext4_clear_journal_err",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/super.c",
    "lines": "4669-4701",
    "snippet": "static void ext4_clear_journal_err(struct super_block *sb,\n\t\t\t\t   struct ext4_super_block *es)\n{\n\tjournal_t *journal;\n\tint j_errno;\n\tconst char *errstr;\n\n\tBUG_ON(!EXT4_HAS_COMPAT_FEATURE(sb, EXT4_FEATURE_COMPAT_HAS_JOURNAL));\n\n\tjournal = EXT4_SB(sb)->s_journal;\n\n\t/*\n\t * Now check for any error status which may have been recorded in the\n\t * journal by a prior ext4_error() or ext4_abort()\n\t */\n\n\tj_errno = jbd2_journal_errno(journal);\n\tif (j_errno) {\n\t\tchar nbuf[16];\n\n\t\terrstr = ext4_decode_error(sb, j_errno, nbuf);\n\t\text4_warning(sb, \"Filesystem error recorded \"\n\t\t\t     \"from previous mount: %s\", errstr);\n\t\text4_warning(sb, \"Marking fs in need of filesystem check.\");\n\n\t\tEXT4_SB(sb)->s_mount_state |= EXT4_ERROR_FS;\n\t\tes->s_state |= cpu_to_le16(EXT4_ERROR_FS);\n\t\text4_commit_super(sb, 1);\n\n\t\tjbd2_journal_clear_err(journal);\n\t\tjbd2_journal_update_sb_errno(journal);\n\t}\n}",
    "includes": [
      "#include <trace/events/ext4.h>",
      "#include \"mballoc.h\"",
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"ext4_jbd2.h\"",
      "#include \"ext4_extents.h\"\t/* Needed for trace points definition */",
      "#include \"ext4.h\"",
      "#include <linux/freezer.h>",
      "#include <linux/kthread.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/cleancache.h>",
      "#include <linux/crc16.h>",
      "#include <linux/log2.h>",
      "#include <linux/ctype.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/namei.h>",
      "#include <linux/mount.h>",
      "#include <linux/random.h>",
      "#include <linux/vfs.h>",
      "#include <linux/exportfs.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/parser.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/init.h>",
      "#include <linux/slab.h>",
      "#include <linux/jbd2.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/time.h>",
      "#include <linux/fs.h>",
      "#include <linux/string.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void ext4_mark_recovery_complete(struct super_block *sb,\n\t\t\t\t\tstruct ext4_super_block *es);",
      "static void ext4_clear_journal_err(struct super_block *sb,\n\t\t\t\t   struct ext4_super_block *es);",
      "static int ext4_unfreeze(struct super_block *sb);",
      "static int ext4_freeze(struct super_block *sb);",
      "static inline int ext2_feature_set_ok(struct super_block *sb);",
      "static inline int ext3_feature_set_ok(struct super_block *sb);",
      "static void ext4_unregister_li_request(struct super_block *sb);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "jbd2_journal_update_sb_errno",
          "args": [
            "journal"
          ],
          "line": 4699
        },
        "resolved": true,
        "details": {
          "function_name": "jbd2_journal_update_sb_errno",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd2/journal.c",
          "lines": "1448-1459",
          "snippet": "void jbd2_journal_update_sb_errno(journal_t *journal)\n{\n\tjournal_superblock_t *sb = journal->j_superblock;\n\n\tread_lock(&journal->j_state_lock);\n\tjbd_debug(1, \"JBD2: updating superblock error (errno %d)\\n\",\n\t\t  journal->j_errno);\n\tsb->s_errno    = cpu_to_be32(journal->j_errno);\n\tread_unlock(&journal->j_state_lock);\n\n\tjbd2_write_superblock(journal, WRITE_SYNC);\n}",
          "includes": [
            "#include <asm/page.h>",
            "#include <asm/uaccess.h>",
            "#include <trace/events/jbd2.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/bitops.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/log2.h>",
            "#include <linux/hash.h>",
            "#include <linux/math64.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/poison.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __journal_abort_soft (journal_t *journal, int errno);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <trace/events/jbd2.h>\n#include <linux/ratelimit.h>\n#include <linux/bitops.h>\n#include <linux/backing-dev.h>\n#include <linux/vmalloc.h>\n#include <linux/log2.h>\n#include <linux/hash.h>\n#include <linux/math64.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/poison.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/freezer.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd2.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/module.h>\n\nstatic void __journal_abort_soft (journal_t *journal, int errno);\n\nvoid jbd2_journal_update_sb_errno(journal_t *journal)\n{\n\tjournal_superblock_t *sb = journal->j_superblock;\n\n\tread_lock(&journal->j_state_lock);\n\tjbd_debug(1, \"JBD2: updating superblock error (errno %d)\\n\",\n\t\t  journal->j_errno);\n\tsb->s_errno    = cpu_to_be32(journal->j_errno);\n\tread_unlock(&journal->j_state_lock);\n\n\tjbd2_write_superblock(journal, WRITE_SYNC);\n}"
        }
      },
      {
        "call_info": {
          "callee": "jbd2_journal_clear_err",
          "args": [
            "journal"
          ],
          "line": 4698
        },
        "resolved": true,
        "details": {
          "function_name": "jbd2_journal_clear_err",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd2/journal.c",
          "lines": "2142-2153",
          "snippet": "int jbd2_journal_clear_err(journal_t *journal)\n{\n\tint err = 0;\n\n\twrite_lock(&journal->j_state_lock);\n\tif (journal->j_flags & JBD2_ABORT)\n\t\terr = -EROFS;\n\telse\n\t\tjournal->j_errno = 0;\n\twrite_unlock(&journal->j_state_lock);\n\treturn err;\n}",
          "includes": [
            "#include <asm/page.h>",
            "#include <asm/uaccess.h>",
            "#include <trace/events/jbd2.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/bitops.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/log2.h>",
            "#include <linux/hash.h>",
            "#include <linux/math64.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/poison.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <trace/events/jbd2.h>\n#include <linux/ratelimit.h>\n#include <linux/bitops.h>\n#include <linux/backing-dev.h>\n#include <linux/vmalloc.h>\n#include <linux/log2.h>\n#include <linux/hash.h>\n#include <linux/math64.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/poison.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/freezer.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd2.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/module.h>\n\nint jbd2_journal_clear_err(journal_t *journal)\n{\n\tint err = 0;\n\n\twrite_lock(&journal->j_state_lock);\n\tif (journal->j_flags & JBD2_ABORT)\n\t\terr = -EROFS;\n\telse\n\t\tjournal->j_errno = 0;\n\twrite_unlock(&journal->j_state_lock);\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_commit_super",
          "args": [
            "sb",
            "1"
          ],
          "line": 4696
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_commit_super",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/super.c",
          "lines": "4567-4634",
          "snippet": "static int ext4_commit_super(struct super_block *sb, int sync)\n{\n\tstruct ext4_super_block *es = EXT4_SB(sb)->s_es;\n\tstruct buffer_head *sbh = EXT4_SB(sb)->s_sbh;\n\tint error = 0;\n\n\tif (!sbh || block_device_ejected(sb))\n\t\treturn error;\n\tif (buffer_write_io_error(sbh)) {\n\t\t/*\n\t\t * Oh, dear.  A previous attempt to write the\n\t\t * superblock failed.  This could happen because the\n\t\t * USB device was yanked out.  Or it could happen to\n\t\t * be a transient write error and maybe the block will\n\t\t * be remapped.  Nothing we can do but to retry the\n\t\t * write and hope for the best.\n\t\t */\n\t\text4_msg(sb, KERN_ERR, \"previous I/O error to \"\n\t\t       \"superblock detected\");\n\t\tclear_buffer_write_io_error(sbh);\n\t\tset_buffer_uptodate(sbh);\n\t}\n\t/*\n\t * If the file system is mounted read-only, don't update the\n\t * superblock write time.  This avoids updating the superblock\n\t * write time when we are mounting the root file system\n\t * read/only but we need to replay the journal; at that point,\n\t * for people who are east of GMT and who make their clock\n\t * tick in localtime for Windows bug-for-bug compatibility,\n\t * the clock is set in the future, and this will cause e2fsck\n\t * to complain and force a full file system check.\n\t */\n\tif (!(sb->s_flags & MS_RDONLY))\n\t\tes->s_wtime = cpu_to_le32(get_seconds());\n\tif (sb->s_bdev->bd_part)\n\t\tes->s_kbytes_written =\n\t\t\tcpu_to_le64(EXT4_SB(sb)->s_kbytes_written +\n\t\t\t    ((part_stat_read(sb->s_bdev->bd_part, sectors[1]) -\n\t\t\t      EXT4_SB(sb)->s_sectors_written_start) >> 1));\n\telse\n\t\tes->s_kbytes_written =\n\t\t\tcpu_to_le64(EXT4_SB(sb)->s_kbytes_written);\n\tif (percpu_counter_initialized(&EXT4_SB(sb)->s_freeclusters_counter))\n\t\text4_free_blocks_count_set(es,\n\t\t\tEXT4_C2B(EXT4_SB(sb), percpu_counter_sum_positive(\n\t\t\t\t&EXT4_SB(sb)->s_freeclusters_counter)));\n\tif (percpu_counter_initialized(&EXT4_SB(sb)->s_freeinodes_counter))\n\t\tes->s_free_inodes_count =\n\t\t\tcpu_to_le32(percpu_counter_sum_positive(\n\t\t\t\t&EXT4_SB(sb)->s_freeinodes_counter));\n\tBUFFER_TRACE(sbh, \"marking dirty\");\n\text4_superblock_csum_set(sb);\n\tmark_buffer_dirty(sbh);\n\tif (sync) {\n\t\terror = sync_dirty_buffer(sbh);\n\t\tif (error)\n\t\t\treturn error;\n\n\t\terror = buffer_write_io_error(sbh);\n\t\tif (error) {\n\t\t\text4_msg(sb, KERN_ERR, \"I/O error while writing \"\n\t\t\t       \"superblock\");\n\t\t\tclear_buffer_write_io_error(sbh);\n\t\t\tset_buffer_uptodate(sbh);\n\t\t}\n\t}\n\treturn error;\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"mballoc.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include \"ext4_extents.h\"\t/* Needed for trace points definition */",
            "#include \"ext4.h\"",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/crc16.h>",
            "#include <linux/log2.h>",
            "#include <linux/ctype.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/random.h>",
            "#include <linux/vfs.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/parser.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/time.h>",
            "#include <linux/fs.h>",
            "#include <linux/string.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ext4_show_options(struct seq_file *seq, struct dentry *root);",
            "static int ext4_commit_super(struct super_block *sb, int sync);",
            "static void ext4_mark_recovery_complete(struct super_block *sb,\n\t\t\t\t\tstruct ext4_super_block *es);",
            "static void ext4_clear_journal_err(struct super_block *sb,\n\t\t\t\t   struct ext4_super_block *es);",
            "static int ext4_unfreeze(struct super_block *sb);",
            "static int ext4_freeze(struct super_block *sb);",
            "static inline int ext2_feature_set_ok(struct super_block *sb);",
            "static inline int ext3_feature_set_ok(struct super_block *sb);",
            "static void ext4_unregister_li_request(struct super_block *sb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"mballoc.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4_extents.h\"\t/* Needed for trace points definition */\n#include \"ext4.h\"\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <asm/uaccess.h>\n#include <linux/cleancache.h>\n#include <linux/crc16.h>\n#include <linux/log2.h>\n#include <linux/ctype.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/random.h>\n#include <linux/vfs.h>\n#include <linux/exportfs.h>\n#include <linux/buffer_head.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/jbd2.h>\n#include <linux/vmalloc.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n#include <linux/string.h>\n#include <linux/module.h>\n\nstatic int ext4_show_options(struct seq_file *seq, struct dentry *root);\nstatic int ext4_commit_super(struct super_block *sb, int sync);\nstatic void ext4_mark_recovery_complete(struct super_block *sb,\n\t\t\t\t\tstruct ext4_super_block *es);\nstatic void ext4_clear_journal_err(struct super_block *sb,\n\t\t\t\t   struct ext4_super_block *es);\nstatic int ext4_unfreeze(struct super_block *sb);\nstatic int ext4_freeze(struct super_block *sb);\nstatic inline int ext2_feature_set_ok(struct super_block *sb);\nstatic inline int ext3_feature_set_ok(struct super_block *sb);\nstatic void ext4_unregister_li_request(struct super_block *sb);\n\nstatic int ext4_commit_super(struct super_block *sb, int sync)\n{\n\tstruct ext4_super_block *es = EXT4_SB(sb)->s_es;\n\tstruct buffer_head *sbh = EXT4_SB(sb)->s_sbh;\n\tint error = 0;\n\n\tif (!sbh || block_device_ejected(sb))\n\t\treturn error;\n\tif (buffer_write_io_error(sbh)) {\n\t\t/*\n\t\t * Oh, dear.  A previous attempt to write the\n\t\t * superblock failed.  This could happen because the\n\t\t * USB device was yanked out.  Or it could happen to\n\t\t * be a transient write error and maybe the block will\n\t\t * be remapped.  Nothing we can do but to retry the\n\t\t * write and hope for the best.\n\t\t */\n\t\text4_msg(sb, KERN_ERR, \"previous I/O error to \"\n\t\t       \"superblock detected\");\n\t\tclear_buffer_write_io_error(sbh);\n\t\tset_buffer_uptodate(sbh);\n\t}\n\t/*\n\t * If the file system is mounted read-only, don't update the\n\t * superblock write time.  This avoids updating the superblock\n\t * write time when we are mounting the root file system\n\t * read/only but we need to replay the journal; at that point,\n\t * for people who are east of GMT and who make their clock\n\t * tick in localtime for Windows bug-for-bug compatibility,\n\t * the clock is set in the future, and this will cause e2fsck\n\t * to complain and force a full file system check.\n\t */\n\tif (!(sb->s_flags & MS_RDONLY))\n\t\tes->s_wtime = cpu_to_le32(get_seconds());\n\tif (sb->s_bdev->bd_part)\n\t\tes->s_kbytes_written =\n\t\t\tcpu_to_le64(EXT4_SB(sb)->s_kbytes_written +\n\t\t\t    ((part_stat_read(sb->s_bdev->bd_part, sectors[1]) -\n\t\t\t      EXT4_SB(sb)->s_sectors_written_start) >> 1));\n\telse\n\t\tes->s_kbytes_written =\n\t\t\tcpu_to_le64(EXT4_SB(sb)->s_kbytes_written);\n\tif (percpu_counter_initialized(&EXT4_SB(sb)->s_freeclusters_counter))\n\t\text4_free_blocks_count_set(es,\n\t\t\tEXT4_C2B(EXT4_SB(sb), percpu_counter_sum_positive(\n\t\t\t\t&EXT4_SB(sb)->s_freeclusters_counter)));\n\tif (percpu_counter_initialized(&EXT4_SB(sb)->s_freeinodes_counter))\n\t\tes->s_free_inodes_count =\n\t\t\tcpu_to_le32(percpu_counter_sum_positive(\n\t\t\t\t&EXT4_SB(sb)->s_freeinodes_counter));\n\tBUFFER_TRACE(sbh, \"marking dirty\");\n\text4_superblock_csum_set(sb);\n\tmark_buffer_dirty(sbh);\n\tif (sync) {\n\t\terror = sync_dirty_buffer(sbh);\n\t\tif (error)\n\t\t\treturn error;\n\n\t\terror = buffer_write_io_error(sbh);\n\t\tif (error) {\n\t\t\text4_msg(sb, KERN_ERR, \"I/O error while writing \"\n\t\t\t       \"superblock\");\n\t\t\tclear_buffer_write_io_error(sbh);\n\t\t\tset_buffer_uptodate(sbh);\n\t\t}\n\t}\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "EXT4_ERROR_FS"
          ],
          "line": 4695
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXT4_SB",
          "args": [
            "sb"
          ],
          "line": 4694
        },
        "resolved": true,
        "details": {
          "function_name": "EXT4_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ext4.h",
          "lines": "1356-1359",
          "snippet": "static inline struct ext4_sb_info *EXT4_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include \"extents_status.h\"",
            "#include <linux/compat.h>",
            "#include <linux/falloc.h>",
            "#include <crypto/hash.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/wait.h>",
            "#include <linux/timer.h>",
            "#include <linux/mutex.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/quota.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extents_status.h\"\n#include <linux/compat.h>\n#include <linux/falloc.h>\n#include <crypto/hash.h>\n#include <linux/ratelimit.h>\n#include <linux/percpu_counter.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/wait.h>\n#include <linux/timer.h>\n#include <linux/mutex.h>\n#include <linux/seqlock.h>\n#include <linux/rbtree.h>\n#include <linux/rwsem.h>\n#include <linux/quota.h>\n#include <linux/jbd2.h>\n#include <linux/magic.h>\n#include <linux/blkdev.h>\n#include <linux/types.h>\n\nstatic inline struct ext4_sb_info *EXT4_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_warning",
          "args": [
            "sb",
            "\"Marking fs in need of filesystem check.\""
          ],
          "line": 4692
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_warning",
          "args": [
            "sb",
            "\"Filesystem error recorded \"\n\t\t\t     \"from previous mount: %s\"",
            "errstr"
          ],
          "line": 4690
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_decode_error",
          "args": [
            "sb",
            "j_errno",
            "nbuf"
          ],
          "line": 4689
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_decode_error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/super.c",
          "lines": "493-525",
          "snippet": "const char *ext4_decode_error(struct super_block *sb, int errno,\n\t\t\t      char nbuf[16])\n{\n\tchar *errstr = NULL;\n\n\tswitch (errno) {\n\tcase -EIO:\n\t\terrstr = \"IO failure\";\n\t\tbreak;\n\tcase -ENOMEM:\n\t\terrstr = \"Out of memory\";\n\t\tbreak;\n\tcase -EROFS:\n\t\tif (!sb || (EXT4_SB(sb)->s_journal &&\n\t\t\t    EXT4_SB(sb)->s_journal->j_flags & JBD2_ABORT))\n\t\t\terrstr = \"Journal has aborted\";\n\t\telse\n\t\t\terrstr = \"Readonly filesystem\";\n\t\tbreak;\n\tdefault:\n\t\t/* If the caller passed in an extra buffer for unknown\n\t\t * errors, textualise them now.  Else we just return\n\t\t * NULL. */\n\t\tif (nbuf) {\n\t\t\t/* Check for truncated error codes... */\n\t\t\tif (snprintf(nbuf, 16, \"error %d\", -errno) >= 0)\n\t\t\t\terrstr = nbuf;\n\t\t}\n\t\tbreak;\n\t}\n\n\treturn errstr;\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"mballoc.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include \"ext4_extents.h\"\t/* Needed for trace points definition */",
            "#include \"ext4.h\"",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/crc16.h>",
            "#include <linux/log2.h>",
            "#include <linux/ctype.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/random.h>",
            "#include <linux/vfs.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/parser.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/time.h>",
            "#include <linux/fs.h>",
            "#include <linux/string.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ext4_unfreeze(struct super_block *sb);",
            "static int ext4_freeze(struct super_block *sb);",
            "static inline int ext2_feature_set_ok(struct super_block *sb);",
            "static inline int ext3_feature_set_ok(struct super_block *sb);",
            "static void ext4_unregister_li_request(struct super_block *sb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"mballoc.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4_extents.h\"\t/* Needed for trace points definition */\n#include \"ext4.h\"\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <asm/uaccess.h>\n#include <linux/cleancache.h>\n#include <linux/crc16.h>\n#include <linux/log2.h>\n#include <linux/ctype.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/random.h>\n#include <linux/vfs.h>\n#include <linux/exportfs.h>\n#include <linux/buffer_head.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/jbd2.h>\n#include <linux/vmalloc.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n#include <linux/string.h>\n#include <linux/module.h>\n\nstatic int ext4_unfreeze(struct super_block *sb);\nstatic int ext4_freeze(struct super_block *sb);\nstatic inline int ext2_feature_set_ok(struct super_block *sb);\nstatic inline int ext3_feature_set_ok(struct super_block *sb);\nstatic void ext4_unregister_li_request(struct super_block *sb);\n\nconst char *ext4_decode_error(struct super_block *sb, int errno,\n\t\t\t      char nbuf[16])\n{\n\tchar *errstr = NULL;\n\n\tswitch (errno) {\n\tcase -EIO:\n\t\terrstr = \"IO failure\";\n\t\tbreak;\n\tcase -ENOMEM:\n\t\terrstr = \"Out of memory\";\n\t\tbreak;\n\tcase -EROFS:\n\t\tif (!sb || (EXT4_SB(sb)->s_journal &&\n\t\t\t    EXT4_SB(sb)->s_journal->j_flags & JBD2_ABORT))\n\t\t\terrstr = \"Journal has aborted\";\n\t\telse\n\t\t\terrstr = \"Readonly filesystem\";\n\t\tbreak;\n\tdefault:\n\t\t/* If the caller passed in an extra buffer for unknown\n\t\t * errors, textualise them now.  Else we just return\n\t\t * NULL. */\n\t\tif (nbuf) {\n\t\t\t/* Check for truncated error codes... */\n\t\t\tif (snprintf(nbuf, 16, \"error %d\", -errno) >= 0)\n\t\t\t\terrstr = nbuf;\n\t\t}\n\t\tbreak;\n\t}\n\n\treturn errstr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "jbd2_journal_errno",
          "args": [
            "journal"
          ],
          "line": 4685
        },
        "resolved": true,
        "details": {
          "function_name": "jbd2_journal_errno",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd2/journal.c",
          "lines": "2122-2133",
          "snippet": "int jbd2_journal_errno(journal_t *journal)\n{\n\tint err;\n\n\tread_lock(&journal->j_state_lock);\n\tif (journal->j_flags & JBD2_ABORT)\n\t\terr = -EROFS;\n\telse\n\t\terr = journal->j_errno;\n\tread_unlock(&journal->j_state_lock);\n\treturn err;\n}",
          "includes": [
            "#include <asm/page.h>",
            "#include <asm/uaccess.h>",
            "#include <trace/events/jbd2.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/bitops.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/log2.h>",
            "#include <linux/hash.h>",
            "#include <linux/math64.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/poison.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <trace/events/jbd2.h>\n#include <linux/ratelimit.h>\n#include <linux/bitops.h>\n#include <linux/backing-dev.h>\n#include <linux/vmalloc.h>\n#include <linux/log2.h>\n#include <linux/hash.h>\n#include <linux/math64.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/poison.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/freezer.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd2.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/module.h>\n\nint jbd2_journal_errno(journal_t *journal)\n{\n\tint err;\n\n\tread_lock(&journal->j_state_lock);\n\tif (journal->j_flags & JBD2_ABORT)\n\t\terr = -EROFS;\n\telse\n\t\terr = journal->j_errno;\n\tread_unlock(&journal->j_state_lock);\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!EXT4_HAS_COMPAT_FEATURE(sb, EXT4_FEATURE_COMPAT_HAS_JOURNAL)"
          ],
          "line": 4676
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXT4_HAS_COMPAT_FEATURE",
          "args": [
            "sb",
            "EXT4_FEATURE_COMPAT_HAS_JOURNAL"
          ],
          "line": 4676
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"mballoc.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4_extents.h\"\t/* Needed for trace points definition */\n#include \"ext4.h\"\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <asm/uaccess.h>\n#include <linux/cleancache.h>\n#include <linux/crc16.h>\n#include <linux/log2.h>\n#include <linux/ctype.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/random.h>\n#include <linux/vfs.h>\n#include <linux/exportfs.h>\n#include <linux/buffer_head.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/jbd2.h>\n#include <linux/vmalloc.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n#include <linux/string.h>\n#include <linux/module.h>\n\nstatic void ext4_mark_recovery_complete(struct super_block *sb,\n\t\t\t\t\tstruct ext4_super_block *es);\nstatic void ext4_clear_journal_err(struct super_block *sb,\n\t\t\t\t   struct ext4_super_block *es);\nstatic int ext4_unfreeze(struct super_block *sb);\nstatic int ext4_freeze(struct super_block *sb);\nstatic inline int ext2_feature_set_ok(struct super_block *sb);\nstatic inline int ext3_feature_set_ok(struct super_block *sb);\nstatic void ext4_unregister_li_request(struct super_block *sb);\n\nstatic void ext4_clear_journal_err(struct super_block *sb,\n\t\t\t\t   struct ext4_super_block *es)\n{\n\tjournal_t *journal;\n\tint j_errno;\n\tconst char *errstr;\n\n\tBUG_ON(!EXT4_HAS_COMPAT_FEATURE(sb, EXT4_FEATURE_COMPAT_HAS_JOURNAL));\n\n\tjournal = EXT4_SB(sb)->s_journal;\n\n\t/*\n\t * Now check for any error status which may have been recorded in the\n\t * journal by a prior ext4_error() or ext4_abort()\n\t */\n\n\tj_errno = jbd2_journal_errno(journal);\n\tif (j_errno) {\n\t\tchar nbuf[16];\n\n\t\terrstr = ext4_decode_error(sb, j_errno, nbuf);\n\t\text4_warning(sb, \"Filesystem error recorded \"\n\t\t\t     \"from previous mount: %s\", errstr);\n\t\text4_warning(sb, \"Marking fs in need of filesystem check.\");\n\n\t\tEXT4_SB(sb)->s_mount_state |= EXT4_ERROR_FS;\n\t\tes->s_state |= cpu_to_le16(EXT4_ERROR_FS);\n\t\text4_commit_super(sb, 1);\n\n\t\tjbd2_journal_clear_err(journal);\n\t\tjbd2_journal_update_sb_errno(journal);\n\t}\n}"
  },
  {
    "function_name": "ext4_mark_recovery_complete",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/super.c",
    "lines": "4641-4662",
    "snippet": "static void ext4_mark_recovery_complete(struct super_block *sb,\n\t\t\t\t\tstruct ext4_super_block *es)\n{\n\tjournal_t *journal = EXT4_SB(sb)->s_journal;\n\n\tif (!EXT4_HAS_COMPAT_FEATURE(sb, EXT4_FEATURE_COMPAT_HAS_JOURNAL)) {\n\t\tBUG_ON(journal != NULL);\n\t\treturn;\n\t}\n\tjbd2_journal_lock_updates(journal);\n\tif (jbd2_journal_flush(journal) < 0)\n\t\tgoto out;\n\n\tif (EXT4_HAS_INCOMPAT_FEATURE(sb, EXT4_FEATURE_INCOMPAT_RECOVER) &&\n\t    sb->s_flags & MS_RDONLY) {\n\t\tEXT4_CLEAR_INCOMPAT_FEATURE(sb, EXT4_FEATURE_INCOMPAT_RECOVER);\n\t\text4_commit_super(sb, 1);\n\t}\n\nout:\n\tjbd2_journal_unlock_updates(journal);\n}",
    "includes": [
      "#include <trace/events/ext4.h>",
      "#include \"mballoc.h\"",
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"ext4_jbd2.h\"",
      "#include \"ext4_extents.h\"\t/* Needed for trace points definition */",
      "#include \"ext4.h\"",
      "#include <linux/freezer.h>",
      "#include <linux/kthread.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/cleancache.h>",
      "#include <linux/crc16.h>",
      "#include <linux/log2.h>",
      "#include <linux/ctype.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/namei.h>",
      "#include <linux/mount.h>",
      "#include <linux/random.h>",
      "#include <linux/vfs.h>",
      "#include <linux/exportfs.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/parser.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/init.h>",
      "#include <linux/slab.h>",
      "#include <linux/jbd2.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/time.h>",
      "#include <linux/fs.h>",
      "#include <linux/string.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void ext4_mark_recovery_complete(struct super_block *sb,\n\t\t\t\t\tstruct ext4_super_block *es);",
      "static void ext4_clear_journal_err(struct super_block *sb,\n\t\t\t\t   struct ext4_super_block *es);",
      "static int ext4_unfreeze(struct super_block *sb);",
      "static int ext4_freeze(struct super_block *sb);",
      "static inline int ext2_feature_set_ok(struct super_block *sb);",
      "static inline int ext3_feature_set_ok(struct super_block *sb);",
      "static void ext4_unregister_li_request(struct super_block *sb);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "jbd2_journal_unlock_updates",
          "args": [
            "journal"
          ],
          "line": 4661
        },
        "resolved": true,
        "details": {
          "function_name": "jbd2_journal_unlock_updates",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd2/transaction.c",
          "lines": "744-753",
          "snippet": "void jbd2_journal_unlock_updates (journal_t *journal)\n{\n\tJ_ASSERT(journal->j_barrier_count != 0);\n\n\tmutex_unlock(&journal->j_barrier);\n\twrite_lock(&journal->j_state_lock);\n\t--journal->j_barrier_count;\n\twrite_unlock(&journal->j_state_lock);\n\twake_up(&journal->j_wait_transaction_locked);\n}",
          "includes": [
            "#include <trace/events/jbd2.h>",
            "#include <linux/module.h>",
            "#include <linux/bug.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/timer.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/jbd2.h>\n#include <linux/module.h>\n#include <linux/bug.h>\n#include <linux/backing-dev.h>\n#include <linux/hrtimer.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/timer.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd2.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n\nvoid jbd2_journal_unlock_updates (journal_t *journal)\n{\n\tJ_ASSERT(journal->j_barrier_count != 0);\n\n\tmutex_unlock(&journal->j_barrier);\n\twrite_lock(&journal->j_state_lock);\n\t--journal->j_barrier_count;\n\twrite_unlock(&journal->j_state_lock);\n\twake_up(&journal->j_wait_transaction_locked);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_commit_super",
          "args": [
            "sb",
            "1"
          ],
          "line": 4657
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_commit_super",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/super.c",
          "lines": "4567-4634",
          "snippet": "static int ext4_commit_super(struct super_block *sb, int sync)\n{\n\tstruct ext4_super_block *es = EXT4_SB(sb)->s_es;\n\tstruct buffer_head *sbh = EXT4_SB(sb)->s_sbh;\n\tint error = 0;\n\n\tif (!sbh || block_device_ejected(sb))\n\t\treturn error;\n\tif (buffer_write_io_error(sbh)) {\n\t\t/*\n\t\t * Oh, dear.  A previous attempt to write the\n\t\t * superblock failed.  This could happen because the\n\t\t * USB device was yanked out.  Or it could happen to\n\t\t * be a transient write error and maybe the block will\n\t\t * be remapped.  Nothing we can do but to retry the\n\t\t * write and hope for the best.\n\t\t */\n\t\text4_msg(sb, KERN_ERR, \"previous I/O error to \"\n\t\t       \"superblock detected\");\n\t\tclear_buffer_write_io_error(sbh);\n\t\tset_buffer_uptodate(sbh);\n\t}\n\t/*\n\t * If the file system is mounted read-only, don't update the\n\t * superblock write time.  This avoids updating the superblock\n\t * write time when we are mounting the root file system\n\t * read/only but we need to replay the journal; at that point,\n\t * for people who are east of GMT and who make their clock\n\t * tick in localtime for Windows bug-for-bug compatibility,\n\t * the clock is set in the future, and this will cause e2fsck\n\t * to complain and force a full file system check.\n\t */\n\tif (!(sb->s_flags & MS_RDONLY))\n\t\tes->s_wtime = cpu_to_le32(get_seconds());\n\tif (sb->s_bdev->bd_part)\n\t\tes->s_kbytes_written =\n\t\t\tcpu_to_le64(EXT4_SB(sb)->s_kbytes_written +\n\t\t\t    ((part_stat_read(sb->s_bdev->bd_part, sectors[1]) -\n\t\t\t      EXT4_SB(sb)->s_sectors_written_start) >> 1));\n\telse\n\t\tes->s_kbytes_written =\n\t\t\tcpu_to_le64(EXT4_SB(sb)->s_kbytes_written);\n\tif (percpu_counter_initialized(&EXT4_SB(sb)->s_freeclusters_counter))\n\t\text4_free_blocks_count_set(es,\n\t\t\tEXT4_C2B(EXT4_SB(sb), percpu_counter_sum_positive(\n\t\t\t\t&EXT4_SB(sb)->s_freeclusters_counter)));\n\tif (percpu_counter_initialized(&EXT4_SB(sb)->s_freeinodes_counter))\n\t\tes->s_free_inodes_count =\n\t\t\tcpu_to_le32(percpu_counter_sum_positive(\n\t\t\t\t&EXT4_SB(sb)->s_freeinodes_counter));\n\tBUFFER_TRACE(sbh, \"marking dirty\");\n\text4_superblock_csum_set(sb);\n\tmark_buffer_dirty(sbh);\n\tif (sync) {\n\t\terror = sync_dirty_buffer(sbh);\n\t\tif (error)\n\t\t\treturn error;\n\n\t\terror = buffer_write_io_error(sbh);\n\t\tif (error) {\n\t\t\text4_msg(sb, KERN_ERR, \"I/O error while writing \"\n\t\t\t       \"superblock\");\n\t\t\tclear_buffer_write_io_error(sbh);\n\t\t\tset_buffer_uptodate(sbh);\n\t\t}\n\t}\n\treturn error;\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"mballoc.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include \"ext4_extents.h\"\t/* Needed for trace points definition */",
            "#include \"ext4.h\"",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/crc16.h>",
            "#include <linux/log2.h>",
            "#include <linux/ctype.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/random.h>",
            "#include <linux/vfs.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/parser.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/time.h>",
            "#include <linux/fs.h>",
            "#include <linux/string.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ext4_show_options(struct seq_file *seq, struct dentry *root);",
            "static int ext4_commit_super(struct super_block *sb, int sync);",
            "static void ext4_mark_recovery_complete(struct super_block *sb,\n\t\t\t\t\tstruct ext4_super_block *es);",
            "static void ext4_clear_journal_err(struct super_block *sb,\n\t\t\t\t   struct ext4_super_block *es);",
            "static int ext4_unfreeze(struct super_block *sb);",
            "static int ext4_freeze(struct super_block *sb);",
            "static inline int ext2_feature_set_ok(struct super_block *sb);",
            "static inline int ext3_feature_set_ok(struct super_block *sb);",
            "static void ext4_unregister_li_request(struct super_block *sb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"mballoc.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4_extents.h\"\t/* Needed for trace points definition */\n#include \"ext4.h\"\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <asm/uaccess.h>\n#include <linux/cleancache.h>\n#include <linux/crc16.h>\n#include <linux/log2.h>\n#include <linux/ctype.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/random.h>\n#include <linux/vfs.h>\n#include <linux/exportfs.h>\n#include <linux/buffer_head.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/jbd2.h>\n#include <linux/vmalloc.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n#include <linux/string.h>\n#include <linux/module.h>\n\nstatic int ext4_show_options(struct seq_file *seq, struct dentry *root);\nstatic int ext4_commit_super(struct super_block *sb, int sync);\nstatic void ext4_mark_recovery_complete(struct super_block *sb,\n\t\t\t\t\tstruct ext4_super_block *es);\nstatic void ext4_clear_journal_err(struct super_block *sb,\n\t\t\t\t   struct ext4_super_block *es);\nstatic int ext4_unfreeze(struct super_block *sb);\nstatic int ext4_freeze(struct super_block *sb);\nstatic inline int ext2_feature_set_ok(struct super_block *sb);\nstatic inline int ext3_feature_set_ok(struct super_block *sb);\nstatic void ext4_unregister_li_request(struct super_block *sb);\n\nstatic int ext4_commit_super(struct super_block *sb, int sync)\n{\n\tstruct ext4_super_block *es = EXT4_SB(sb)->s_es;\n\tstruct buffer_head *sbh = EXT4_SB(sb)->s_sbh;\n\tint error = 0;\n\n\tif (!sbh || block_device_ejected(sb))\n\t\treturn error;\n\tif (buffer_write_io_error(sbh)) {\n\t\t/*\n\t\t * Oh, dear.  A previous attempt to write the\n\t\t * superblock failed.  This could happen because the\n\t\t * USB device was yanked out.  Or it could happen to\n\t\t * be a transient write error and maybe the block will\n\t\t * be remapped.  Nothing we can do but to retry the\n\t\t * write and hope for the best.\n\t\t */\n\t\text4_msg(sb, KERN_ERR, \"previous I/O error to \"\n\t\t       \"superblock detected\");\n\t\tclear_buffer_write_io_error(sbh);\n\t\tset_buffer_uptodate(sbh);\n\t}\n\t/*\n\t * If the file system is mounted read-only, don't update the\n\t * superblock write time.  This avoids updating the superblock\n\t * write time when we are mounting the root file system\n\t * read/only but we need to replay the journal; at that point,\n\t * for people who are east of GMT and who make their clock\n\t * tick in localtime for Windows bug-for-bug compatibility,\n\t * the clock is set in the future, and this will cause e2fsck\n\t * to complain and force a full file system check.\n\t */\n\tif (!(sb->s_flags & MS_RDONLY))\n\t\tes->s_wtime = cpu_to_le32(get_seconds());\n\tif (sb->s_bdev->bd_part)\n\t\tes->s_kbytes_written =\n\t\t\tcpu_to_le64(EXT4_SB(sb)->s_kbytes_written +\n\t\t\t    ((part_stat_read(sb->s_bdev->bd_part, sectors[1]) -\n\t\t\t      EXT4_SB(sb)->s_sectors_written_start) >> 1));\n\telse\n\t\tes->s_kbytes_written =\n\t\t\tcpu_to_le64(EXT4_SB(sb)->s_kbytes_written);\n\tif (percpu_counter_initialized(&EXT4_SB(sb)->s_freeclusters_counter))\n\t\text4_free_blocks_count_set(es,\n\t\t\tEXT4_C2B(EXT4_SB(sb), percpu_counter_sum_positive(\n\t\t\t\t&EXT4_SB(sb)->s_freeclusters_counter)));\n\tif (percpu_counter_initialized(&EXT4_SB(sb)->s_freeinodes_counter))\n\t\tes->s_free_inodes_count =\n\t\t\tcpu_to_le32(percpu_counter_sum_positive(\n\t\t\t\t&EXT4_SB(sb)->s_freeinodes_counter));\n\tBUFFER_TRACE(sbh, \"marking dirty\");\n\text4_superblock_csum_set(sb);\n\tmark_buffer_dirty(sbh);\n\tif (sync) {\n\t\terror = sync_dirty_buffer(sbh);\n\t\tif (error)\n\t\t\treturn error;\n\n\t\terror = buffer_write_io_error(sbh);\n\t\tif (error) {\n\t\t\text4_msg(sb, KERN_ERR, \"I/O error while writing \"\n\t\t\t       \"superblock\");\n\t\t\tclear_buffer_write_io_error(sbh);\n\t\t\tset_buffer_uptodate(sbh);\n\t\t}\n\t}\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "EXT4_CLEAR_INCOMPAT_FEATURE",
          "args": [
            "sb",
            "EXT4_FEATURE_INCOMPAT_RECOVER"
          ],
          "line": 4656
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXT4_HAS_INCOMPAT_FEATURE",
          "args": [
            "sb",
            "EXT4_FEATURE_INCOMPAT_RECOVER"
          ],
          "line": 4654
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "jbd2_journal_flush",
          "args": [
            "journal"
          ],
          "line": 4651
        },
        "resolved": true,
        "details": {
          "function_name": "jbd2_journal_flush",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd2/journal.c",
          "lines": "1914-1970",
          "snippet": "int jbd2_journal_flush(journal_t *journal)\n{\n\tint err = 0;\n\ttransaction_t *transaction = NULL;\n\n\twrite_lock(&journal->j_state_lock);\n\n\t/* Force everything buffered to the log... */\n\tif (journal->j_running_transaction) {\n\t\ttransaction = journal->j_running_transaction;\n\t\t__jbd2_log_start_commit(journal, transaction->t_tid);\n\t} else if (journal->j_committing_transaction)\n\t\ttransaction = journal->j_committing_transaction;\n\n\t/* Wait for the log commit to complete... */\n\tif (transaction) {\n\t\ttid_t tid = transaction->t_tid;\n\n\t\twrite_unlock(&journal->j_state_lock);\n\t\tjbd2_log_wait_commit(journal, tid);\n\t} else {\n\t\twrite_unlock(&journal->j_state_lock);\n\t}\n\n\t/* ...and flush everything in the log out to disk. */\n\tspin_lock(&journal->j_list_lock);\n\twhile (!err && journal->j_checkpoint_transactions != NULL) {\n\t\tspin_unlock(&journal->j_list_lock);\n\t\tmutex_lock(&journal->j_checkpoint_mutex);\n\t\terr = jbd2_log_do_checkpoint(journal);\n\t\tmutex_unlock(&journal->j_checkpoint_mutex);\n\t\tspin_lock(&journal->j_list_lock);\n\t}\n\tspin_unlock(&journal->j_list_lock);\n\n\tif (is_journal_aborted(journal))\n\t\treturn -EIO;\n\n\tmutex_lock(&journal->j_checkpoint_mutex);\n\tjbd2_cleanup_journal_tail(journal);\n\n\t/* Finally, mark the journal as really needing no recovery.\n\t * This sets s_start==0 in the underlying superblock, which is\n\t * the magic code for a fully-recovered superblock.  Any future\n\t * commits of data to the journal will restore the current\n\t * s_start value. */\n\tjbd2_mark_journal_empty(journal);\n\tmutex_unlock(&journal->j_checkpoint_mutex);\n\twrite_lock(&journal->j_state_lock);\n\tJ_ASSERT(!journal->j_running_transaction);\n\tJ_ASSERT(!journal->j_committing_transaction);\n\tJ_ASSERT(!journal->j_checkpoint_transactions);\n\tJ_ASSERT(journal->j_head == journal->j_tail);\n\tJ_ASSERT(journal->j_tail_sequence == journal->j_transaction_sequence);\n\twrite_unlock(&journal->j_state_lock);\n\treturn 0;\n}",
          "includes": [
            "#include <asm/page.h>",
            "#include <asm/uaccess.h>",
            "#include <trace/events/jbd2.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/bitops.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/log2.h>",
            "#include <linux/hash.h>",
            "#include <linux/math64.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/poison.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <trace/events/jbd2.h>\n#include <linux/ratelimit.h>\n#include <linux/bitops.h>\n#include <linux/backing-dev.h>\n#include <linux/vmalloc.h>\n#include <linux/log2.h>\n#include <linux/hash.h>\n#include <linux/math64.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/poison.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/freezer.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd2.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/module.h>\n\nint jbd2_journal_flush(journal_t *journal)\n{\n\tint err = 0;\n\ttransaction_t *transaction = NULL;\n\n\twrite_lock(&journal->j_state_lock);\n\n\t/* Force everything buffered to the log... */\n\tif (journal->j_running_transaction) {\n\t\ttransaction = journal->j_running_transaction;\n\t\t__jbd2_log_start_commit(journal, transaction->t_tid);\n\t} else if (journal->j_committing_transaction)\n\t\ttransaction = journal->j_committing_transaction;\n\n\t/* Wait for the log commit to complete... */\n\tif (transaction) {\n\t\ttid_t tid = transaction->t_tid;\n\n\t\twrite_unlock(&journal->j_state_lock);\n\t\tjbd2_log_wait_commit(journal, tid);\n\t} else {\n\t\twrite_unlock(&journal->j_state_lock);\n\t}\n\n\t/* ...and flush everything in the log out to disk. */\n\tspin_lock(&journal->j_list_lock);\n\twhile (!err && journal->j_checkpoint_transactions != NULL) {\n\t\tspin_unlock(&journal->j_list_lock);\n\t\tmutex_lock(&journal->j_checkpoint_mutex);\n\t\terr = jbd2_log_do_checkpoint(journal);\n\t\tmutex_unlock(&journal->j_checkpoint_mutex);\n\t\tspin_lock(&journal->j_list_lock);\n\t}\n\tspin_unlock(&journal->j_list_lock);\n\n\tif (is_journal_aborted(journal))\n\t\treturn -EIO;\n\n\tmutex_lock(&journal->j_checkpoint_mutex);\n\tjbd2_cleanup_journal_tail(journal);\n\n\t/* Finally, mark the journal as really needing no recovery.\n\t * This sets s_start==0 in the underlying superblock, which is\n\t * the magic code for a fully-recovered superblock.  Any future\n\t * commits of data to the journal will restore the current\n\t * s_start value. */\n\tjbd2_mark_journal_empty(journal);\n\tmutex_unlock(&journal->j_checkpoint_mutex);\n\twrite_lock(&journal->j_state_lock);\n\tJ_ASSERT(!journal->j_running_transaction);\n\tJ_ASSERT(!journal->j_committing_transaction);\n\tJ_ASSERT(!journal->j_checkpoint_transactions);\n\tJ_ASSERT(journal->j_head == journal->j_tail);\n\tJ_ASSERT(journal->j_tail_sequence == journal->j_transaction_sequence);\n\twrite_unlock(&journal->j_state_lock);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "jbd2_journal_lock_updates",
          "args": [
            "journal"
          ],
          "line": 4650
        },
        "resolved": true,
        "details": {
          "function_name": "jbd2_journal_lock_updates",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd2/transaction.c",
          "lines": "689-734",
          "snippet": "void jbd2_journal_lock_updates(journal_t *journal)\n{\n\tDEFINE_WAIT(wait);\n\n\twrite_lock(&journal->j_state_lock);\n\t++journal->j_barrier_count;\n\n\t/* Wait until there are no reserved handles */\n\tif (atomic_read(&journal->j_reserved_credits)) {\n\t\twrite_unlock(&journal->j_state_lock);\n\t\twait_event(journal->j_wait_reserved,\n\t\t\t   atomic_read(&journal->j_reserved_credits) == 0);\n\t\twrite_lock(&journal->j_state_lock);\n\t}\n\n\t/* Wait until there are no running updates */\n\twhile (1) {\n\t\ttransaction_t *transaction = journal->j_running_transaction;\n\n\t\tif (!transaction)\n\t\t\tbreak;\n\n\t\tspin_lock(&transaction->t_handle_lock);\n\t\tprepare_to_wait(&journal->j_wait_updates, &wait,\n\t\t\t\tTASK_UNINTERRUPTIBLE);\n\t\tif (!atomic_read(&transaction->t_updates)) {\n\t\t\tspin_unlock(&transaction->t_handle_lock);\n\t\t\tfinish_wait(&journal->j_wait_updates, &wait);\n\t\t\tbreak;\n\t\t}\n\t\tspin_unlock(&transaction->t_handle_lock);\n\t\twrite_unlock(&journal->j_state_lock);\n\t\tschedule();\n\t\tfinish_wait(&journal->j_wait_updates, &wait);\n\t\twrite_lock(&journal->j_state_lock);\n\t}\n\twrite_unlock(&journal->j_state_lock);\n\n\t/*\n\t * We have now established a barrier against other normal updates, but\n\t * we also need to barrier against other jbd2_journal_lock_updates() calls\n\t * to make sure that we serialise special journal-locked operations\n\t * too.\n\t */\n\tmutex_lock(&journal->j_barrier);\n}",
          "includes": [
            "#include <trace/events/jbd2.h>",
            "#include <linux/module.h>",
            "#include <linux/bug.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/timer.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/jbd2.h>\n#include <linux/module.h>\n#include <linux/bug.h>\n#include <linux/backing-dev.h>\n#include <linux/hrtimer.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/timer.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd2.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n\nvoid jbd2_journal_lock_updates(journal_t *journal)\n{\n\tDEFINE_WAIT(wait);\n\n\twrite_lock(&journal->j_state_lock);\n\t++journal->j_barrier_count;\n\n\t/* Wait until there are no reserved handles */\n\tif (atomic_read(&journal->j_reserved_credits)) {\n\t\twrite_unlock(&journal->j_state_lock);\n\t\twait_event(journal->j_wait_reserved,\n\t\t\t   atomic_read(&journal->j_reserved_credits) == 0);\n\t\twrite_lock(&journal->j_state_lock);\n\t}\n\n\t/* Wait until there are no running updates */\n\twhile (1) {\n\t\ttransaction_t *transaction = journal->j_running_transaction;\n\n\t\tif (!transaction)\n\t\t\tbreak;\n\n\t\tspin_lock(&transaction->t_handle_lock);\n\t\tprepare_to_wait(&journal->j_wait_updates, &wait,\n\t\t\t\tTASK_UNINTERRUPTIBLE);\n\t\tif (!atomic_read(&transaction->t_updates)) {\n\t\t\tspin_unlock(&transaction->t_handle_lock);\n\t\t\tfinish_wait(&journal->j_wait_updates, &wait);\n\t\t\tbreak;\n\t\t}\n\t\tspin_unlock(&transaction->t_handle_lock);\n\t\twrite_unlock(&journal->j_state_lock);\n\t\tschedule();\n\t\tfinish_wait(&journal->j_wait_updates, &wait);\n\t\twrite_lock(&journal->j_state_lock);\n\t}\n\twrite_unlock(&journal->j_state_lock);\n\n\t/*\n\t * We have now established a barrier against other normal updates, but\n\t * we also need to barrier against other jbd2_journal_lock_updates() calls\n\t * to make sure that we serialise special journal-locked operations\n\t * too.\n\t */\n\tmutex_lock(&journal->j_barrier);\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "journal != NULL"
          ],
          "line": 4647
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXT4_HAS_COMPAT_FEATURE",
          "args": [
            "sb",
            "EXT4_FEATURE_COMPAT_HAS_JOURNAL"
          ],
          "line": 4646
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXT4_SB",
          "args": [
            "sb"
          ],
          "line": 4644
        },
        "resolved": true,
        "details": {
          "function_name": "EXT4_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ext4.h",
          "lines": "1356-1359",
          "snippet": "static inline struct ext4_sb_info *EXT4_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include \"extents_status.h\"",
            "#include <linux/compat.h>",
            "#include <linux/falloc.h>",
            "#include <crypto/hash.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/wait.h>",
            "#include <linux/timer.h>",
            "#include <linux/mutex.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/quota.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extents_status.h\"\n#include <linux/compat.h>\n#include <linux/falloc.h>\n#include <crypto/hash.h>\n#include <linux/ratelimit.h>\n#include <linux/percpu_counter.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/wait.h>\n#include <linux/timer.h>\n#include <linux/mutex.h>\n#include <linux/seqlock.h>\n#include <linux/rbtree.h>\n#include <linux/rwsem.h>\n#include <linux/quota.h>\n#include <linux/jbd2.h>\n#include <linux/magic.h>\n#include <linux/blkdev.h>\n#include <linux/types.h>\n\nstatic inline struct ext4_sb_info *EXT4_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"mballoc.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4_extents.h\"\t/* Needed for trace points definition */\n#include \"ext4.h\"\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <asm/uaccess.h>\n#include <linux/cleancache.h>\n#include <linux/crc16.h>\n#include <linux/log2.h>\n#include <linux/ctype.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/random.h>\n#include <linux/vfs.h>\n#include <linux/exportfs.h>\n#include <linux/buffer_head.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/jbd2.h>\n#include <linux/vmalloc.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n#include <linux/string.h>\n#include <linux/module.h>\n\nstatic void ext4_mark_recovery_complete(struct super_block *sb,\n\t\t\t\t\tstruct ext4_super_block *es);\nstatic void ext4_clear_journal_err(struct super_block *sb,\n\t\t\t\t   struct ext4_super_block *es);\nstatic int ext4_unfreeze(struct super_block *sb);\nstatic int ext4_freeze(struct super_block *sb);\nstatic inline int ext2_feature_set_ok(struct super_block *sb);\nstatic inline int ext3_feature_set_ok(struct super_block *sb);\nstatic void ext4_unregister_li_request(struct super_block *sb);\n\nstatic void ext4_mark_recovery_complete(struct super_block *sb,\n\t\t\t\t\tstruct ext4_super_block *es)\n{\n\tjournal_t *journal = EXT4_SB(sb)->s_journal;\n\n\tif (!EXT4_HAS_COMPAT_FEATURE(sb, EXT4_FEATURE_COMPAT_HAS_JOURNAL)) {\n\t\tBUG_ON(journal != NULL);\n\t\treturn;\n\t}\n\tjbd2_journal_lock_updates(journal);\n\tif (jbd2_journal_flush(journal) < 0)\n\t\tgoto out;\n\n\tif (EXT4_HAS_INCOMPAT_FEATURE(sb, EXT4_FEATURE_INCOMPAT_RECOVER) &&\n\t    sb->s_flags & MS_RDONLY) {\n\t\tEXT4_CLEAR_INCOMPAT_FEATURE(sb, EXT4_FEATURE_INCOMPAT_RECOVER);\n\t\text4_commit_super(sb, 1);\n\t}\n\nout:\n\tjbd2_journal_unlock_updates(journal);\n}"
  },
  {
    "function_name": "ext4_commit_super",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/super.c",
    "lines": "4567-4634",
    "snippet": "static int ext4_commit_super(struct super_block *sb, int sync)\n{\n\tstruct ext4_super_block *es = EXT4_SB(sb)->s_es;\n\tstruct buffer_head *sbh = EXT4_SB(sb)->s_sbh;\n\tint error = 0;\n\n\tif (!sbh || block_device_ejected(sb))\n\t\treturn error;\n\tif (buffer_write_io_error(sbh)) {\n\t\t/*\n\t\t * Oh, dear.  A previous attempt to write the\n\t\t * superblock failed.  This could happen because the\n\t\t * USB device was yanked out.  Or it could happen to\n\t\t * be a transient write error and maybe the block will\n\t\t * be remapped.  Nothing we can do but to retry the\n\t\t * write and hope for the best.\n\t\t */\n\t\text4_msg(sb, KERN_ERR, \"previous I/O error to \"\n\t\t       \"superblock detected\");\n\t\tclear_buffer_write_io_error(sbh);\n\t\tset_buffer_uptodate(sbh);\n\t}\n\t/*\n\t * If the file system is mounted read-only, don't update the\n\t * superblock write time.  This avoids updating the superblock\n\t * write time when we are mounting the root file system\n\t * read/only but we need to replay the journal; at that point,\n\t * for people who are east of GMT and who make their clock\n\t * tick in localtime for Windows bug-for-bug compatibility,\n\t * the clock is set in the future, and this will cause e2fsck\n\t * to complain and force a full file system check.\n\t */\n\tif (!(sb->s_flags & MS_RDONLY))\n\t\tes->s_wtime = cpu_to_le32(get_seconds());\n\tif (sb->s_bdev->bd_part)\n\t\tes->s_kbytes_written =\n\t\t\tcpu_to_le64(EXT4_SB(sb)->s_kbytes_written +\n\t\t\t    ((part_stat_read(sb->s_bdev->bd_part, sectors[1]) -\n\t\t\t      EXT4_SB(sb)->s_sectors_written_start) >> 1));\n\telse\n\t\tes->s_kbytes_written =\n\t\t\tcpu_to_le64(EXT4_SB(sb)->s_kbytes_written);\n\tif (percpu_counter_initialized(&EXT4_SB(sb)->s_freeclusters_counter))\n\t\text4_free_blocks_count_set(es,\n\t\t\tEXT4_C2B(EXT4_SB(sb), percpu_counter_sum_positive(\n\t\t\t\t&EXT4_SB(sb)->s_freeclusters_counter)));\n\tif (percpu_counter_initialized(&EXT4_SB(sb)->s_freeinodes_counter))\n\t\tes->s_free_inodes_count =\n\t\t\tcpu_to_le32(percpu_counter_sum_positive(\n\t\t\t\t&EXT4_SB(sb)->s_freeinodes_counter));\n\tBUFFER_TRACE(sbh, \"marking dirty\");\n\text4_superblock_csum_set(sb);\n\tmark_buffer_dirty(sbh);\n\tif (sync) {\n\t\terror = sync_dirty_buffer(sbh);\n\t\tif (error)\n\t\t\treturn error;\n\n\t\terror = buffer_write_io_error(sbh);\n\t\tif (error) {\n\t\t\text4_msg(sb, KERN_ERR, \"I/O error while writing \"\n\t\t\t       \"superblock\");\n\t\t\tclear_buffer_write_io_error(sbh);\n\t\t\tset_buffer_uptodate(sbh);\n\t\t}\n\t}\n\treturn error;\n}",
    "includes": [
      "#include <trace/events/ext4.h>",
      "#include \"mballoc.h\"",
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"ext4_jbd2.h\"",
      "#include \"ext4_extents.h\"\t/* Needed for trace points definition */",
      "#include \"ext4.h\"",
      "#include <linux/freezer.h>",
      "#include <linux/kthread.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/cleancache.h>",
      "#include <linux/crc16.h>",
      "#include <linux/log2.h>",
      "#include <linux/ctype.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/namei.h>",
      "#include <linux/mount.h>",
      "#include <linux/random.h>",
      "#include <linux/vfs.h>",
      "#include <linux/exportfs.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/parser.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/init.h>",
      "#include <linux/slab.h>",
      "#include <linux/jbd2.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/time.h>",
      "#include <linux/fs.h>",
      "#include <linux/string.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ext4_show_options(struct seq_file *seq, struct dentry *root);",
      "static int ext4_commit_super(struct super_block *sb, int sync);",
      "static void ext4_mark_recovery_complete(struct super_block *sb,\n\t\t\t\t\tstruct ext4_super_block *es);",
      "static void ext4_clear_journal_err(struct super_block *sb,\n\t\t\t\t   struct ext4_super_block *es);",
      "static int ext4_unfreeze(struct super_block *sb);",
      "static int ext4_freeze(struct super_block *sb);",
      "static inline int ext2_feature_set_ok(struct super_block *sb);",
      "static inline int ext3_feature_set_ok(struct super_block *sb);",
      "static void ext4_unregister_li_request(struct super_block *sb);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "set_buffer_uptodate",
          "args": [
            "sbh"
          ],
          "line": 4630
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_set_buffer_uptodate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/disk-io.c",
          "lines": "3758-3761",
          "snippet": "int btrfs_set_buffer_uptodate(struct extent_buffer *buf)\n{\n\treturn set_extent_buffer_uptodate(buf);\n}",
          "includes": [
            "#include <asm/cpufeature.h>",
            "#include \"qgroup.h\"",
            "#include \"sysfs.h\"",
            "#include \"raid56.h\"",
            "#include \"dev-replace.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"inode-map.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"tree-log.h\"",
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"hash.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/uuid.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/migrate.h>",
            "#include <linux/slab.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/writeback.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/swap.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/cpufeature.h>\n#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"raid56.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <asm/unaligned.h>\n#include <linux/semaphore.h>\n#include <linux/uuid.h>\n#include <linux/ratelimit.h>\n#include <linux/migrate.h>\n#include <linux/slab.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/writeback.h>\n#include <linux/radix-tree.h>\n#include <linux/swap.h>\n#include <linux/scatterlist.h>\n#include <linux/blkdev.h>\n#include <linux/fs.h>\n\nint btrfs_set_buffer_uptodate(struct extent_buffer *buf)\n{\n\treturn set_extent_buffer_uptodate(buf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "clear_buffer_write_io_error",
          "args": [
            "sbh"
          ],
          "line": 4629
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_msg",
          "args": [
            "sb",
            "KERN_ERR",
            "\"I/O error while writing \"\n\t\t\t       \"superblock\""
          ],
          "line": 4627
        },
        "resolved": true,
        "details": {
          "function_name": "__ext4_msg",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/super.c",
          "lines": "593-607",
          "snippet": "void __ext4_msg(struct super_block *sb,\n\t\tconst char *prefix, const char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tif (!___ratelimit(&(EXT4_SB(sb)->s_msg_ratelimit_state), \"EXT4-fs\"))\n\t\treturn;\n\n\tva_start(args, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\tprintk(\"%sEXT4-fs (%s): %pV\\n\", prefix, sb->s_id, &vaf);\n\tva_end(args);\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"mballoc.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include \"ext4_extents.h\"\t/* Needed for trace points definition */",
            "#include \"ext4.h\"",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/crc16.h>",
            "#include <linux/log2.h>",
            "#include <linux/ctype.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/random.h>",
            "#include <linux/vfs.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/parser.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/time.h>",
            "#include <linux/fs.h>",
            "#include <linux/string.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ext4_unfreeze(struct super_block *sb);",
            "static int ext4_freeze(struct super_block *sb);",
            "static inline int ext2_feature_set_ok(struct super_block *sb);",
            "static inline int ext3_feature_set_ok(struct super_block *sb);",
            "static void ext4_unregister_li_request(struct super_block *sb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"mballoc.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4_extents.h\"\t/* Needed for trace points definition */\n#include \"ext4.h\"\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <asm/uaccess.h>\n#include <linux/cleancache.h>\n#include <linux/crc16.h>\n#include <linux/log2.h>\n#include <linux/ctype.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/random.h>\n#include <linux/vfs.h>\n#include <linux/exportfs.h>\n#include <linux/buffer_head.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/jbd2.h>\n#include <linux/vmalloc.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n#include <linux/string.h>\n#include <linux/module.h>\n\nstatic int ext4_unfreeze(struct super_block *sb);\nstatic int ext4_freeze(struct super_block *sb);\nstatic inline int ext2_feature_set_ok(struct super_block *sb);\nstatic inline int ext3_feature_set_ok(struct super_block *sb);\nstatic void ext4_unregister_li_request(struct super_block *sb);\n\nvoid __ext4_msg(struct super_block *sb,\n\t\tconst char *prefix, const char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tif (!___ratelimit(&(EXT4_SB(sb)->s_msg_ratelimit_state), \"EXT4-fs\"))\n\t\treturn;\n\n\tva_start(args, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\tprintk(\"%sEXT4-fs (%s): %pV\\n\", prefix, sb->s_id, &vaf);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "buffer_write_io_error",
          "args": [
            "sbh"
          ],
          "line": 4625
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sync_dirty_buffer",
          "args": [
            "sbh"
          ],
          "line": 4621
        },
        "resolved": true,
        "details": {
          "function_name": "sync_dirty_buffer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "3153-3156",
          "snippet": "int sync_dirty_buffer(struct buffer_head *bh)\n{\n\treturn __sync_dirty_buffer(bh, WRITE_SYNC);\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nint sync_dirty_buffer(struct buffer_head *bh)\n{\n\treturn __sync_dirty_buffer(bh, WRITE_SYNC);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mark_buffer_dirty",
          "args": [
            "sbh"
          ],
          "line": 4619
        },
        "resolved": true,
        "details": {
          "function_name": "mark_buffer_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1141-1167",
          "snippet": "void mark_buffer_dirty(struct buffer_head *bh)\n{\n\tWARN_ON_ONCE(!buffer_uptodate(bh));\n\n\ttrace_block_dirty_buffer(bh);\n\n\t/*\n\t * Very *carefully* optimize the it-is-already-dirty case.\n\t *\n\t * Don't let the final \"is it dirty\" escape to before we\n\t * perhaps modified the buffer.\n\t */\n\tif (buffer_dirty(bh)) {\n\t\tsmp_mb();\n\t\tif (buffer_dirty(bh))\n\t\t\treturn;\n\t}\n\n\tif (!test_set_buffer_dirty(bh)) {\n\t\tstruct page *page = bh->b_page;\n\t\tif (!TestSetPageDirty(page)) {\n\t\t\tstruct address_space *mapping = page_mapping(page);\n\t\t\tif (mapping)\n\t\t\t\t__set_page_dirty(page, mapping, 0);\n\t\t}\n\t}\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid mark_buffer_dirty(struct buffer_head *bh)\n{\n\tWARN_ON_ONCE(!buffer_uptodate(bh));\n\n\ttrace_block_dirty_buffer(bh);\n\n\t/*\n\t * Very *carefully* optimize the it-is-already-dirty case.\n\t *\n\t * Don't let the final \"is it dirty\" escape to before we\n\t * perhaps modified the buffer.\n\t */\n\tif (buffer_dirty(bh)) {\n\t\tsmp_mb();\n\t\tif (buffer_dirty(bh))\n\t\t\treturn;\n\t}\n\n\tif (!test_set_buffer_dirty(bh)) {\n\t\tstruct page *page = bh->b_page;\n\t\tif (!TestSetPageDirty(page)) {\n\t\t\tstruct address_space *mapping = page_mapping(page);\n\t\t\tif (mapping)\n\t\t\t\t__set_page_dirty(page, mapping, 0);\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_superblock_csum_set",
          "args": [
            "sb"
          ],
          "line": 4618
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_superblock_csum_set",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/super.c",
          "lines": "149-157",
          "snippet": "void ext4_superblock_csum_set(struct super_block *sb)\n{\n\tstruct ext4_super_block *es = EXT4_SB(sb)->s_es;\n\n\tif (!ext4_has_metadata_csum(sb))\n\t\treturn;\n\n\tes->s_checksum = ext4_superblock_csum(sb, es);\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"mballoc.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include \"ext4_extents.h\"\t/* Needed for trace points definition */",
            "#include \"ext4.h\"",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/crc16.h>",
            "#include <linux/log2.h>",
            "#include <linux/ctype.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/random.h>",
            "#include <linux/vfs.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/parser.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/time.h>",
            "#include <linux/fs.h>",
            "#include <linux/string.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void ext4_mark_recovery_complete(struct super_block *sb,\n\t\t\t\t\tstruct ext4_super_block *es);",
            "static void ext4_clear_journal_err(struct super_block *sb,\n\t\t\t\t   struct ext4_super_block *es);",
            "static int ext4_unfreeze(struct super_block *sb);",
            "static int ext4_freeze(struct super_block *sb);",
            "static inline int ext2_feature_set_ok(struct super_block *sb);",
            "static inline int ext3_feature_set_ok(struct super_block *sb);",
            "static void ext4_unregister_li_request(struct super_block *sb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"mballoc.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4_extents.h\"\t/* Needed for trace points definition */\n#include \"ext4.h\"\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <asm/uaccess.h>\n#include <linux/cleancache.h>\n#include <linux/crc16.h>\n#include <linux/log2.h>\n#include <linux/ctype.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/random.h>\n#include <linux/vfs.h>\n#include <linux/exportfs.h>\n#include <linux/buffer_head.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/jbd2.h>\n#include <linux/vmalloc.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n#include <linux/string.h>\n#include <linux/module.h>\n\nstatic void ext4_mark_recovery_complete(struct super_block *sb,\n\t\t\t\t\tstruct ext4_super_block *es);\nstatic void ext4_clear_journal_err(struct super_block *sb,\n\t\t\t\t   struct ext4_super_block *es);\nstatic int ext4_unfreeze(struct super_block *sb);\nstatic int ext4_freeze(struct super_block *sb);\nstatic inline int ext2_feature_set_ok(struct super_block *sb);\nstatic inline int ext3_feature_set_ok(struct super_block *sb);\nstatic void ext4_unregister_li_request(struct super_block *sb);\n\nvoid ext4_superblock_csum_set(struct super_block *sb)\n{\n\tstruct ext4_super_block *es = EXT4_SB(sb)->s_es;\n\n\tif (!ext4_has_metadata_csum(sb))\n\t\treturn;\n\n\tes->s_checksum = ext4_superblock_csum(sb, es);\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUFFER_TRACE",
          "args": [
            "sbh",
            "\"marking dirty\""
          ],
          "line": 4617
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "percpu_counter_sum_positive(\n\t\t\t\t&EXT4_SB(sb)->s_freeinodes_counter)"
          ],
          "line": 4615
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "percpu_counter_sum_positive",
          "args": [
            "&EXT4_SB(sb)->s_freeinodes_counter"
          ],
          "line": 4615
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXT4_SB",
          "args": [
            "sb"
          ],
          "line": 4616
        },
        "resolved": true,
        "details": {
          "function_name": "EXT4_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ext4.h",
          "lines": "1356-1359",
          "snippet": "static inline struct ext4_sb_info *EXT4_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include \"extents_status.h\"",
            "#include <linux/compat.h>",
            "#include <linux/falloc.h>",
            "#include <crypto/hash.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/wait.h>",
            "#include <linux/timer.h>",
            "#include <linux/mutex.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/quota.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extents_status.h\"\n#include <linux/compat.h>\n#include <linux/falloc.h>\n#include <crypto/hash.h>\n#include <linux/ratelimit.h>\n#include <linux/percpu_counter.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/wait.h>\n#include <linux/timer.h>\n#include <linux/mutex.h>\n#include <linux/seqlock.h>\n#include <linux/rbtree.h>\n#include <linux/rwsem.h>\n#include <linux/quota.h>\n#include <linux/jbd2.h>\n#include <linux/magic.h>\n#include <linux/blkdev.h>\n#include <linux/types.h>\n\nstatic inline struct ext4_sb_info *EXT4_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      },
      {
        "call_info": {
          "callee": "percpu_counter_initialized",
          "args": [
            "&EXT4_SB(sb)->s_freeinodes_counter"
          ],
          "line": 4613
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_free_blocks_count_set",
          "args": [
            "es",
            "EXT4_C2B(EXT4_SB(sb), percpu_counter_sum_positive(\n\t\t\t\t&EXT4_SB(sb)->s_freeclusters_counter))"
          ],
          "line": 4610
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXT4_C2B",
          "args": [
            "EXT4_SB(sb)",
            "percpu_counter_sum_positive(\n\t\t\t\t&EXT4_SB(sb)->s_freeclusters_counter)"
          ],
          "line": 4611
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "percpu_counter_sum_positive",
          "args": [
            "&EXT4_SB(sb)->s_freeclusters_counter"
          ],
          "line": 4611
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "percpu_counter_initialized",
          "args": [
            "&EXT4_SB(sb)->s_freeclusters_counter"
          ],
          "line": 4609
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le64",
          "args": [
            "EXT4_SB(sb)->s_kbytes_written"
          ],
          "line": 4608
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le64",
          "args": [
            "EXT4_SB(sb)->s_kbytes_written +\n\t\t\t    ((part_stat_read(sb->s_bdev->bd_part, sectors[1]) -\n\t\t\t      EXT4_SB(sb)->s_sectors_written_start) >> 1)"
          ],
          "line": 4603
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "part_stat_read",
          "args": [
            "sb->s_bdev->bd_part",
            "sectors[1]"
          ],
          "line": 4604
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "get_seconds()"
          ],
          "line": 4600
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_seconds",
          "args": [],
          "line": 4600
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "clear_buffer_write_io_error",
          "args": [
            "sbh"
          ],
          "line": 4586
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "buffer_write_io_error",
          "args": [
            "sbh"
          ],
          "line": 4575
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "block_device_ejected",
          "args": [
            "sb"
          ],
          "line": 4573
        },
        "resolved": true,
        "details": {
          "function_name": "block_device_ejected",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/super.c",
          "lines": "334-340",
          "snippet": "static int block_device_ejected(struct super_block *sb)\n{\n\tstruct inode *bd_inode = sb->s_bdev->bd_inode;\n\tstruct backing_dev_info *bdi = inode_to_bdi(bd_inode);\n\n\treturn bdi->dev == NULL;\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"mballoc.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include \"ext4_extents.h\"\t/* Needed for trace points definition */",
            "#include \"ext4.h\"",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/crc16.h>",
            "#include <linux/log2.h>",
            "#include <linux/ctype.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/random.h>",
            "#include <linux/vfs.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/parser.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/time.h>",
            "#include <linux/fs.h>",
            "#include <linux/string.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ext4_unfreeze(struct super_block *sb);",
            "static int ext4_freeze(struct super_block *sb);",
            "static inline int ext2_feature_set_ok(struct super_block *sb);",
            "static inline int ext3_feature_set_ok(struct super_block *sb);",
            "static void ext4_unregister_li_request(struct super_block *sb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"mballoc.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4_extents.h\"\t/* Needed for trace points definition */\n#include \"ext4.h\"\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <asm/uaccess.h>\n#include <linux/cleancache.h>\n#include <linux/crc16.h>\n#include <linux/log2.h>\n#include <linux/ctype.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/random.h>\n#include <linux/vfs.h>\n#include <linux/exportfs.h>\n#include <linux/buffer_head.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/jbd2.h>\n#include <linux/vmalloc.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n#include <linux/string.h>\n#include <linux/module.h>\n\nstatic int ext4_unfreeze(struct super_block *sb);\nstatic int ext4_freeze(struct super_block *sb);\nstatic inline int ext2_feature_set_ok(struct super_block *sb);\nstatic inline int ext3_feature_set_ok(struct super_block *sb);\nstatic void ext4_unregister_li_request(struct super_block *sb);\n\nstatic int block_device_ejected(struct super_block *sb)\n{\n\tstruct inode *bd_inode = sb->s_bdev->bd_inode;\n\tstruct backing_dev_info *bdi = inode_to_bdi(bd_inode);\n\n\treturn bdi->dev == NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"mballoc.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4_extents.h\"\t/* Needed for trace points definition */\n#include \"ext4.h\"\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <asm/uaccess.h>\n#include <linux/cleancache.h>\n#include <linux/crc16.h>\n#include <linux/log2.h>\n#include <linux/ctype.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/random.h>\n#include <linux/vfs.h>\n#include <linux/exportfs.h>\n#include <linux/buffer_head.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/jbd2.h>\n#include <linux/vmalloc.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n#include <linux/string.h>\n#include <linux/module.h>\n\nstatic int ext4_show_options(struct seq_file *seq, struct dentry *root);\nstatic int ext4_commit_super(struct super_block *sb, int sync);\nstatic void ext4_mark_recovery_complete(struct super_block *sb,\n\t\t\t\t\tstruct ext4_super_block *es);\nstatic void ext4_clear_journal_err(struct super_block *sb,\n\t\t\t\t   struct ext4_super_block *es);\nstatic int ext4_unfreeze(struct super_block *sb);\nstatic int ext4_freeze(struct super_block *sb);\nstatic inline int ext2_feature_set_ok(struct super_block *sb);\nstatic inline int ext3_feature_set_ok(struct super_block *sb);\nstatic void ext4_unregister_li_request(struct super_block *sb);\n\nstatic int ext4_commit_super(struct super_block *sb, int sync)\n{\n\tstruct ext4_super_block *es = EXT4_SB(sb)->s_es;\n\tstruct buffer_head *sbh = EXT4_SB(sb)->s_sbh;\n\tint error = 0;\n\n\tif (!sbh || block_device_ejected(sb))\n\t\treturn error;\n\tif (buffer_write_io_error(sbh)) {\n\t\t/*\n\t\t * Oh, dear.  A previous attempt to write the\n\t\t * superblock failed.  This could happen because the\n\t\t * USB device was yanked out.  Or it could happen to\n\t\t * be a transient write error and maybe the block will\n\t\t * be remapped.  Nothing we can do but to retry the\n\t\t * write and hope for the best.\n\t\t */\n\t\text4_msg(sb, KERN_ERR, \"previous I/O error to \"\n\t\t       \"superblock detected\");\n\t\tclear_buffer_write_io_error(sbh);\n\t\tset_buffer_uptodate(sbh);\n\t}\n\t/*\n\t * If the file system is mounted read-only, don't update the\n\t * superblock write time.  This avoids updating the superblock\n\t * write time when we are mounting the root file system\n\t * read/only but we need to replay the journal; at that point,\n\t * for people who are east of GMT and who make their clock\n\t * tick in localtime for Windows bug-for-bug compatibility,\n\t * the clock is set in the future, and this will cause e2fsck\n\t * to complain and force a full file system check.\n\t */\n\tif (!(sb->s_flags & MS_RDONLY))\n\t\tes->s_wtime = cpu_to_le32(get_seconds());\n\tif (sb->s_bdev->bd_part)\n\t\tes->s_kbytes_written =\n\t\t\tcpu_to_le64(EXT4_SB(sb)->s_kbytes_written +\n\t\t\t    ((part_stat_read(sb->s_bdev->bd_part, sectors[1]) -\n\t\t\t      EXT4_SB(sb)->s_sectors_written_start) >> 1));\n\telse\n\t\tes->s_kbytes_written =\n\t\t\tcpu_to_le64(EXT4_SB(sb)->s_kbytes_written);\n\tif (percpu_counter_initialized(&EXT4_SB(sb)->s_freeclusters_counter))\n\t\text4_free_blocks_count_set(es,\n\t\t\tEXT4_C2B(EXT4_SB(sb), percpu_counter_sum_positive(\n\t\t\t\t&EXT4_SB(sb)->s_freeclusters_counter)));\n\tif (percpu_counter_initialized(&EXT4_SB(sb)->s_freeinodes_counter))\n\t\tes->s_free_inodes_count =\n\t\t\tcpu_to_le32(percpu_counter_sum_positive(\n\t\t\t\t&EXT4_SB(sb)->s_freeinodes_counter));\n\tBUFFER_TRACE(sbh, \"marking dirty\");\n\text4_superblock_csum_set(sb);\n\tmark_buffer_dirty(sbh);\n\tif (sync) {\n\t\terror = sync_dirty_buffer(sbh);\n\t\tif (error)\n\t\t\treturn error;\n\n\t\terror = buffer_write_io_error(sbh);\n\t\tif (error) {\n\t\t\text4_msg(sb, KERN_ERR, \"I/O error while writing \"\n\t\t\t       \"superblock\");\n\t\t\tclear_buffer_write_io_error(sbh);\n\t\t\tset_buffer_uptodate(sbh);\n\t\t}\n\t}\n\treturn error;\n}"
  },
  {
    "function_name": "ext4_load_journal",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/super.c",
    "lines": "4475-4565",
    "snippet": "static int ext4_load_journal(struct super_block *sb,\n\t\t\t     struct ext4_super_block *es,\n\t\t\t     unsigned long journal_devnum)\n{\n\tjournal_t *journal;\n\tunsigned int journal_inum = le32_to_cpu(es->s_journal_inum);\n\tdev_t journal_dev;\n\tint err = 0;\n\tint really_read_only;\n\n\tBUG_ON(!EXT4_HAS_COMPAT_FEATURE(sb, EXT4_FEATURE_COMPAT_HAS_JOURNAL));\n\n\tif (journal_devnum &&\n\t    journal_devnum != le32_to_cpu(es->s_journal_dev)) {\n\t\text4_msg(sb, KERN_INFO, \"external journal device major/minor \"\n\t\t\t\"numbers have changed\");\n\t\tjournal_dev = new_decode_dev(journal_devnum);\n\t} else\n\t\tjournal_dev = new_decode_dev(le32_to_cpu(es->s_journal_dev));\n\n\treally_read_only = bdev_read_only(sb->s_bdev);\n\n\t/*\n\t * Are we loading a blank journal or performing recovery after a\n\t * crash?  For recovery, we need to check in advance whether we\n\t * can get read-write access to the device.\n\t */\n\tif (EXT4_HAS_INCOMPAT_FEATURE(sb, EXT4_FEATURE_INCOMPAT_RECOVER)) {\n\t\tif (sb->s_flags & MS_RDONLY) {\n\t\t\text4_msg(sb, KERN_INFO, \"INFO: recovery \"\n\t\t\t\t\t\"required on readonly filesystem\");\n\t\t\tif (really_read_only) {\n\t\t\t\text4_msg(sb, KERN_ERR, \"write access \"\n\t\t\t\t\t\"unavailable, cannot proceed\");\n\t\t\t\treturn -EROFS;\n\t\t\t}\n\t\t\text4_msg(sb, KERN_INFO, \"write access will \"\n\t\t\t       \"be enabled during recovery\");\n\t\t}\n\t}\n\n\tif (journal_inum && journal_dev) {\n\t\text4_msg(sb, KERN_ERR, \"filesystem has both journal \"\n\t\t       \"and inode journals!\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (journal_inum) {\n\t\tif (!(journal = ext4_get_journal(sb, journal_inum)))\n\t\t\treturn -EINVAL;\n\t} else {\n\t\tif (!(journal = ext4_get_dev_journal(sb, journal_dev)))\n\t\t\treturn -EINVAL;\n\t}\n\n\tif (!(journal->j_flags & JBD2_BARRIER))\n\t\text4_msg(sb, KERN_INFO, \"barriers disabled\");\n\n\tif (!EXT4_HAS_INCOMPAT_FEATURE(sb, EXT4_FEATURE_INCOMPAT_RECOVER))\n\t\terr = jbd2_journal_wipe(journal, !really_read_only);\n\tif (!err) {\n\t\tchar *save = kmalloc(EXT4_S_ERR_LEN, GFP_KERNEL);\n\t\tif (save)\n\t\t\tmemcpy(save, ((char *) es) +\n\t\t\t       EXT4_S_ERR_START, EXT4_S_ERR_LEN);\n\t\terr = jbd2_journal_load(journal);\n\t\tif (save)\n\t\t\tmemcpy(((char *) es) + EXT4_S_ERR_START,\n\t\t\t       save, EXT4_S_ERR_LEN);\n\t\tkfree(save);\n\t}\n\n\tif (err) {\n\t\text4_msg(sb, KERN_ERR, \"error loading journal\");\n\t\tjbd2_journal_destroy(journal);\n\t\treturn err;\n\t}\n\n\tEXT4_SB(sb)->s_journal = journal;\n\text4_clear_journal_err(sb, es);\n\n\tif (!really_read_only && journal_devnum &&\n\t    journal_devnum != le32_to_cpu(es->s_journal_dev)) {\n\t\tes->s_journal_dev = cpu_to_le32(journal_devnum);\n\n\t\t/* Make sure we flush the recovery flag to disk. */\n\t\text4_commit_super(sb, 1);\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include <trace/events/ext4.h>",
      "#include \"mballoc.h\"",
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"ext4_jbd2.h\"",
      "#include \"ext4_extents.h\"\t/* Needed for trace points definition */",
      "#include \"ext4.h\"",
      "#include <linux/freezer.h>",
      "#include <linux/kthread.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/cleancache.h>",
      "#include <linux/crc16.h>",
      "#include <linux/log2.h>",
      "#include <linux/ctype.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/namei.h>",
      "#include <linux/mount.h>",
      "#include <linux/random.h>",
      "#include <linux/vfs.h>",
      "#include <linux/exportfs.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/parser.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/init.h>",
      "#include <linux/slab.h>",
      "#include <linux/jbd2.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/time.h>",
      "#include <linux/fs.h>",
      "#include <linux/string.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ext4_load_journal(struct super_block *, struct ext4_super_block *,\n\t\t\t     unsigned long journal_devnum);",
      "static void ext4_mark_recovery_complete(struct super_block *sb,\n\t\t\t\t\tstruct ext4_super_block *es);",
      "static void ext4_clear_journal_err(struct super_block *sb,\n\t\t\t\t   struct ext4_super_block *es);",
      "static int ext4_unfreeze(struct super_block *sb);",
      "static int ext4_freeze(struct super_block *sb);",
      "static inline int ext2_feature_set_ok(struct super_block *sb);",
      "static inline int ext3_feature_set_ok(struct super_block *sb);",
      "static int ext4_feature_set_ok(struct super_block *sb, int readonly);",
      "static void ext4_unregister_li_request(struct super_block *sb);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ext4_commit_super",
          "args": [
            "sb",
            "1"
          ],
          "line": 4561
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_commit_super",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/super.c",
          "lines": "4567-4634",
          "snippet": "static int ext4_commit_super(struct super_block *sb, int sync)\n{\n\tstruct ext4_super_block *es = EXT4_SB(sb)->s_es;\n\tstruct buffer_head *sbh = EXT4_SB(sb)->s_sbh;\n\tint error = 0;\n\n\tif (!sbh || block_device_ejected(sb))\n\t\treturn error;\n\tif (buffer_write_io_error(sbh)) {\n\t\t/*\n\t\t * Oh, dear.  A previous attempt to write the\n\t\t * superblock failed.  This could happen because the\n\t\t * USB device was yanked out.  Or it could happen to\n\t\t * be a transient write error and maybe the block will\n\t\t * be remapped.  Nothing we can do but to retry the\n\t\t * write and hope for the best.\n\t\t */\n\t\text4_msg(sb, KERN_ERR, \"previous I/O error to \"\n\t\t       \"superblock detected\");\n\t\tclear_buffer_write_io_error(sbh);\n\t\tset_buffer_uptodate(sbh);\n\t}\n\t/*\n\t * If the file system is mounted read-only, don't update the\n\t * superblock write time.  This avoids updating the superblock\n\t * write time when we are mounting the root file system\n\t * read/only but we need to replay the journal; at that point,\n\t * for people who are east of GMT and who make their clock\n\t * tick in localtime for Windows bug-for-bug compatibility,\n\t * the clock is set in the future, and this will cause e2fsck\n\t * to complain and force a full file system check.\n\t */\n\tif (!(sb->s_flags & MS_RDONLY))\n\t\tes->s_wtime = cpu_to_le32(get_seconds());\n\tif (sb->s_bdev->bd_part)\n\t\tes->s_kbytes_written =\n\t\t\tcpu_to_le64(EXT4_SB(sb)->s_kbytes_written +\n\t\t\t    ((part_stat_read(sb->s_bdev->bd_part, sectors[1]) -\n\t\t\t      EXT4_SB(sb)->s_sectors_written_start) >> 1));\n\telse\n\t\tes->s_kbytes_written =\n\t\t\tcpu_to_le64(EXT4_SB(sb)->s_kbytes_written);\n\tif (percpu_counter_initialized(&EXT4_SB(sb)->s_freeclusters_counter))\n\t\text4_free_blocks_count_set(es,\n\t\t\tEXT4_C2B(EXT4_SB(sb), percpu_counter_sum_positive(\n\t\t\t\t&EXT4_SB(sb)->s_freeclusters_counter)));\n\tif (percpu_counter_initialized(&EXT4_SB(sb)->s_freeinodes_counter))\n\t\tes->s_free_inodes_count =\n\t\t\tcpu_to_le32(percpu_counter_sum_positive(\n\t\t\t\t&EXT4_SB(sb)->s_freeinodes_counter));\n\tBUFFER_TRACE(sbh, \"marking dirty\");\n\text4_superblock_csum_set(sb);\n\tmark_buffer_dirty(sbh);\n\tif (sync) {\n\t\terror = sync_dirty_buffer(sbh);\n\t\tif (error)\n\t\t\treturn error;\n\n\t\terror = buffer_write_io_error(sbh);\n\t\tif (error) {\n\t\t\text4_msg(sb, KERN_ERR, \"I/O error while writing \"\n\t\t\t       \"superblock\");\n\t\t\tclear_buffer_write_io_error(sbh);\n\t\t\tset_buffer_uptodate(sbh);\n\t\t}\n\t}\n\treturn error;\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"mballoc.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include \"ext4_extents.h\"\t/* Needed for trace points definition */",
            "#include \"ext4.h\"",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/crc16.h>",
            "#include <linux/log2.h>",
            "#include <linux/ctype.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/random.h>",
            "#include <linux/vfs.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/parser.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/time.h>",
            "#include <linux/fs.h>",
            "#include <linux/string.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ext4_show_options(struct seq_file *seq, struct dentry *root);",
            "static int ext4_commit_super(struct super_block *sb, int sync);",
            "static void ext4_mark_recovery_complete(struct super_block *sb,\n\t\t\t\t\tstruct ext4_super_block *es);",
            "static void ext4_clear_journal_err(struct super_block *sb,\n\t\t\t\t   struct ext4_super_block *es);",
            "static int ext4_unfreeze(struct super_block *sb);",
            "static int ext4_freeze(struct super_block *sb);",
            "static inline int ext2_feature_set_ok(struct super_block *sb);",
            "static inline int ext3_feature_set_ok(struct super_block *sb);",
            "static void ext4_unregister_li_request(struct super_block *sb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"mballoc.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4_extents.h\"\t/* Needed for trace points definition */\n#include \"ext4.h\"\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <asm/uaccess.h>\n#include <linux/cleancache.h>\n#include <linux/crc16.h>\n#include <linux/log2.h>\n#include <linux/ctype.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/random.h>\n#include <linux/vfs.h>\n#include <linux/exportfs.h>\n#include <linux/buffer_head.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/jbd2.h>\n#include <linux/vmalloc.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n#include <linux/string.h>\n#include <linux/module.h>\n\nstatic int ext4_show_options(struct seq_file *seq, struct dentry *root);\nstatic int ext4_commit_super(struct super_block *sb, int sync);\nstatic void ext4_mark_recovery_complete(struct super_block *sb,\n\t\t\t\t\tstruct ext4_super_block *es);\nstatic void ext4_clear_journal_err(struct super_block *sb,\n\t\t\t\t   struct ext4_super_block *es);\nstatic int ext4_unfreeze(struct super_block *sb);\nstatic int ext4_freeze(struct super_block *sb);\nstatic inline int ext2_feature_set_ok(struct super_block *sb);\nstatic inline int ext3_feature_set_ok(struct super_block *sb);\nstatic void ext4_unregister_li_request(struct super_block *sb);\n\nstatic int ext4_commit_super(struct super_block *sb, int sync)\n{\n\tstruct ext4_super_block *es = EXT4_SB(sb)->s_es;\n\tstruct buffer_head *sbh = EXT4_SB(sb)->s_sbh;\n\tint error = 0;\n\n\tif (!sbh || block_device_ejected(sb))\n\t\treturn error;\n\tif (buffer_write_io_error(sbh)) {\n\t\t/*\n\t\t * Oh, dear.  A previous attempt to write the\n\t\t * superblock failed.  This could happen because the\n\t\t * USB device was yanked out.  Or it could happen to\n\t\t * be a transient write error and maybe the block will\n\t\t * be remapped.  Nothing we can do but to retry the\n\t\t * write and hope for the best.\n\t\t */\n\t\text4_msg(sb, KERN_ERR, \"previous I/O error to \"\n\t\t       \"superblock detected\");\n\t\tclear_buffer_write_io_error(sbh);\n\t\tset_buffer_uptodate(sbh);\n\t}\n\t/*\n\t * If the file system is mounted read-only, don't update the\n\t * superblock write time.  This avoids updating the superblock\n\t * write time when we are mounting the root file system\n\t * read/only but we need to replay the journal; at that point,\n\t * for people who are east of GMT and who make their clock\n\t * tick in localtime for Windows bug-for-bug compatibility,\n\t * the clock is set in the future, and this will cause e2fsck\n\t * to complain and force a full file system check.\n\t */\n\tif (!(sb->s_flags & MS_RDONLY))\n\t\tes->s_wtime = cpu_to_le32(get_seconds());\n\tif (sb->s_bdev->bd_part)\n\t\tes->s_kbytes_written =\n\t\t\tcpu_to_le64(EXT4_SB(sb)->s_kbytes_written +\n\t\t\t    ((part_stat_read(sb->s_bdev->bd_part, sectors[1]) -\n\t\t\t      EXT4_SB(sb)->s_sectors_written_start) >> 1));\n\telse\n\t\tes->s_kbytes_written =\n\t\t\tcpu_to_le64(EXT4_SB(sb)->s_kbytes_written);\n\tif (percpu_counter_initialized(&EXT4_SB(sb)->s_freeclusters_counter))\n\t\text4_free_blocks_count_set(es,\n\t\t\tEXT4_C2B(EXT4_SB(sb), percpu_counter_sum_positive(\n\t\t\t\t&EXT4_SB(sb)->s_freeclusters_counter)));\n\tif (percpu_counter_initialized(&EXT4_SB(sb)->s_freeinodes_counter))\n\t\tes->s_free_inodes_count =\n\t\t\tcpu_to_le32(percpu_counter_sum_positive(\n\t\t\t\t&EXT4_SB(sb)->s_freeinodes_counter));\n\tBUFFER_TRACE(sbh, \"marking dirty\");\n\text4_superblock_csum_set(sb);\n\tmark_buffer_dirty(sbh);\n\tif (sync) {\n\t\terror = sync_dirty_buffer(sbh);\n\t\tif (error)\n\t\t\treturn error;\n\n\t\terror = buffer_write_io_error(sbh);\n\t\tif (error) {\n\t\t\text4_msg(sb, KERN_ERR, \"I/O error while writing \"\n\t\t\t       \"superblock\");\n\t\t\tclear_buffer_write_io_error(sbh);\n\t\t\tset_buffer_uptodate(sbh);\n\t\t}\n\t}\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "journal_devnum"
          ],
          "line": 4558
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "es->s_journal_dev"
          ],
          "line": 4557
        },
        "resolved": true,
        "details": {
          "function_name": "sle32_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "53-56",
          "snippet": "static inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_clear_journal_err",
          "args": [
            "sb",
            "es"
          ],
          "line": 4554
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_clear_journal_err",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/super.c",
          "lines": "4669-4701",
          "snippet": "static void ext4_clear_journal_err(struct super_block *sb,\n\t\t\t\t   struct ext4_super_block *es)\n{\n\tjournal_t *journal;\n\tint j_errno;\n\tconst char *errstr;\n\n\tBUG_ON(!EXT4_HAS_COMPAT_FEATURE(sb, EXT4_FEATURE_COMPAT_HAS_JOURNAL));\n\n\tjournal = EXT4_SB(sb)->s_journal;\n\n\t/*\n\t * Now check for any error status which may have been recorded in the\n\t * journal by a prior ext4_error() or ext4_abort()\n\t */\n\n\tj_errno = jbd2_journal_errno(journal);\n\tif (j_errno) {\n\t\tchar nbuf[16];\n\n\t\terrstr = ext4_decode_error(sb, j_errno, nbuf);\n\t\text4_warning(sb, \"Filesystem error recorded \"\n\t\t\t     \"from previous mount: %s\", errstr);\n\t\text4_warning(sb, \"Marking fs in need of filesystem check.\");\n\n\t\tEXT4_SB(sb)->s_mount_state |= EXT4_ERROR_FS;\n\t\tes->s_state |= cpu_to_le16(EXT4_ERROR_FS);\n\t\text4_commit_super(sb, 1);\n\n\t\tjbd2_journal_clear_err(journal);\n\t\tjbd2_journal_update_sb_errno(journal);\n\t}\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"mballoc.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include \"ext4_extents.h\"\t/* Needed for trace points definition */",
            "#include \"ext4.h\"",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/crc16.h>",
            "#include <linux/log2.h>",
            "#include <linux/ctype.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/random.h>",
            "#include <linux/vfs.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/parser.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/time.h>",
            "#include <linux/fs.h>",
            "#include <linux/string.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void ext4_mark_recovery_complete(struct super_block *sb,\n\t\t\t\t\tstruct ext4_super_block *es);",
            "static void ext4_clear_journal_err(struct super_block *sb,\n\t\t\t\t   struct ext4_super_block *es);",
            "static int ext4_unfreeze(struct super_block *sb);",
            "static int ext4_freeze(struct super_block *sb);",
            "static inline int ext2_feature_set_ok(struct super_block *sb);",
            "static inline int ext3_feature_set_ok(struct super_block *sb);",
            "static void ext4_unregister_li_request(struct super_block *sb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"mballoc.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4_extents.h\"\t/* Needed for trace points definition */\n#include \"ext4.h\"\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <asm/uaccess.h>\n#include <linux/cleancache.h>\n#include <linux/crc16.h>\n#include <linux/log2.h>\n#include <linux/ctype.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/random.h>\n#include <linux/vfs.h>\n#include <linux/exportfs.h>\n#include <linux/buffer_head.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/jbd2.h>\n#include <linux/vmalloc.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n#include <linux/string.h>\n#include <linux/module.h>\n\nstatic void ext4_mark_recovery_complete(struct super_block *sb,\n\t\t\t\t\tstruct ext4_super_block *es);\nstatic void ext4_clear_journal_err(struct super_block *sb,\n\t\t\t\t   struct ext4_super_block *es);\nstatic int ext4_unfreeze(struct super_block *sb);\nstatic int ext4_freeze(struct super_block *sb);\nstatic inline int ext2_feature_set_ok(struct super_block *sb);\nstatic inline int ext3_feature_set_ok(struct super_block *sb);\nstatic void ext4_unregister_li_request(struct super_block *sb);\n\nstatic void ext4_clear_journal_err(struct super_block *sb,\n\t\t\t\t   struct ext4_super_block *es)\n{\n\tjournal_t *journal;\n\tint j_errno;\n\tconst char *errstr;\n\n\tBUG_ON(!EXT4_HAS_COMPAT_FEATURE(sb, EXT4_FEATURE_COMPAT_HAS_JOURNAL));\n\n\tjournal = EXT4_SB(sb)->s_journal;\n\n\t/*\n\t * Now check for any error status which may have been recorded in the\n\t * journal by a prior ext4_error() or ext4_abort()\n\t */\n\n\tj_errno = jbd2_journal_errno(journal);\n\tif (j_errno) {\n\t\tchar nbuf[16];\n\n\t\terrstr = ext4_decode_error(sb, j_errno, nbuf);\n\t\text4_warning(sb, \"Filesystem error recorded \"\n\t\t\t     \"from previous mount: %s\", errstr);\n\t\text4_warning(sb, \"Marking fs in need of filesystem check.\");\n\n\t\tEXT4_SB(sb)->s_mount_state |= EXT4_ERROR_FS;\n\t\tes->s_state |= cpu_to_le16(EXT4_ERROR_FS);\n\t\text4_commit_super(sb, 1);\n\n\t\tjbd2_journal_clear_err(journal);\n\t\tjbd2_journal_update_sb_errno(journal);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "EXT4_SB",
          "args": [
            "sb"
          ],
          "line": 4553
        },
        "resolved": true,
        "details": {
          "function_name": "EXT4_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ext4.h",
          "lines": "1356-1359",
          "snippet": "static inline struct ext4_sb_info *EXT4_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include \"extents_status.h\"",
            "#include <linux/compat.h>",
            "#include <linux/falloc.h>",
            "#include <crypto/hash.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/wait.h>",
            "#include <linux/timer.h>",
            "#include <linux/mutex.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/quota.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extents_status.h\"\n#include <linux/compat.h>\n#include <linux/falloc.h>\n#include <crypto/hash.h>\n#include <linux/ratelimit.h>\n#include <linux/percpu_counter.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/wait.h>\n#include <linux/timer.h>\n#include <linux/mutex.h>\n#include <linux/seqlock.h>\n#include <linux/rbtree.h>\n#include <linux/rwsem.h>\n#include <linux/quota.h>\n#include <linux/jbd2.h>\n#include <linux/magic.h>\n#include <linux/blkdev.h>\n#include <linux/types.h>\n\nstatic inline struct ext4_sb_info *EXT4_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      },
      {
        "call_info": {
          "callee": "jbd2_journal_destroy",
          "args": [
            "journal"
          ],
          "line": 4549
        },
        "resolved": true,
        "details": {
          "function_name": "jbd2_journal_destroy_revoke",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd2/revoke.c",
          "lines": "293-300",
          "snippet": "void jbd2_journal_destroy_revoke(journal_t *journal)\n{\n\tjournal->j_revoke = NULL;\n\tif (journal->j_revoke_table[0])\n\t\tjbd2_journal_destroy_revoke_table(journal->j_revoke_table[0]);\n\tif (journal->j_revoke_table[1])\n\t\tjbd2_journal_destroy_revoke_table(journal->j_revoke_table[1]);\n}",
          "includes": [
            "#include <linux/hash.h>",
            "#include <linux/log2.h>",
            "#include <linux/bio.h>",
            "#include <linux/init.h>",
            "#include <linux/list.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include \"jfs_user.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/hash.h>\n#include <linux/log2.h>\n#include <linux/bio.h>\n#include <linux/init.h>\n#include <linux/list.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd2.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include \"jfs_user.h\"\n\nvoid jbd2_journal_destroy_revoke(journal_t *journal)\n{\n\tjournal->j_revoke = NULL;\n\tif (journal->j_revoke_table[0])\n\t\tjbd2_journal_destroy_revoke_table(journal->j_revoke_table[0]);\n\tif (journal->j_revoke_table[1])\n\t\tjbd2_journal_destroy_revoke_table(journal->j_revoke_table[1]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_msg",
          "args": [
            "sb",
            "KERN_ERR",
            "\"error loading journal\""
          ],
          "line": 4548
        },
        "resolved": true,
        "details": {
          "function_name": "__ext4_msg",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/super.c",
          "lines": "593-607",
          "snippet": "void __ext4_msg(struct super_block *sb,\n\t\tconst char *prefix, const char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tif (!___ratelimit(&(EXT4_SB(sb)->s_msg_ratelimit_state), \"EXT4-fs\"))\n\t\treturn;\n\n\tva_start(args, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\tprintk(\"%sEXT4-fs (%s): %pV\\n\", prefix, sb->s_id, &vaf);\n\tva_end(args);\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"mballoc.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include \"ext4_extents.h\"\t/* Needed for trace points definition */",
            "#include \"ext4.h\"",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/crc16.h>",
            "#include <linux/log2.h>",
            "#include <linux/ctype.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/random.h>",
            "#include <linux/vfs.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/parser.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/time.h>",
            "#include <linux/fs.h>",
            "#include <linux/string.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ext4_unfreeze(struct super_block *sb);",
            "static int ext4_freeze(struct super_block *sb);",
            "static inline int ext2_feature_set_ok(struct super_block *sb);",
            "static inline int ext3_feature_set_ok(struct super_block *sb);",
            "static void ext4_unregister_li_request(struct super_block *sb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"mballoc.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4_extents.h\"\t/* Needed for trace points definition */\n#include \"ext4.h\"\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <asm/uaccess.h>\n#include <linux/cleancache.h>\n#include <linux/crc16.h>\n#include <linux/log2.h>\n#include <linux/ctype.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/random.h>\n#include <linux/vfs.h>\n#include <linux/exportfs.h>\n#include <linux/buffer_head.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/jbd2.h>\n#include <linux/vmalloc.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n#include <linux/string.h>\n#include <linux/module.h>\n\nstatic int ext4_unfreeze(struct super_block *sb);\nstatic int ext4_freeze(struct super_block *sb);\nstatic inline int ext2_feature_set_ok(struct super_block *sb);\nstatic inline int ext3_feature_set_ok(struct super_block *sb);\nstatic void ext4_unregister_li_request(struct super_block *sb);\n\nvoid __ext4_msg(struct super_block *sb,\n\t\tconst char *prefix, const char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tif (!___ratelimit(&(EXT4_SB(sb)->s_msg_ratelimit_state), \"EXT4-fs\"))\n\t\treturn;\n\n\tva_start(args, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\tprintk(\"%sEXT4-fs (%s): %pV\\n\", prefix, sb->s_id, &vaf);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "save"
          ],
          "line": 4544
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "((char *) es) + EXT4_S_ERR_START",
            "save",
            "EXT4_S_ERR_LEN"
          ],
          "line": 4542
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "jbd2_journal_load",
          "args": [
            "journal"
          ],
          "line": 4540
        },
        "resolved": true,
        "details": {
          "function_name": "jbd2_journal_load",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd2/journal.c",
          "lines": "1611-1667",
          "snippet": "int jbd2_journal_load(journal_t *journal)\n{\n\tint err;\n\tjournal_superblock_t *sb;\n\n\terr = load_superblock(journal);\n\tif (err)\n\t\treturn err;\n\n\tsb = journal->j_superblock;\n\t/* If this is a V2 superblock, then we have to check the\n\t * features flags on it. */\n\n\tif (journal->j_format_version >= 2) {\n\t\tif ((sb->s_feature_ro_compat &\n\t\t     ~cpu_to_be32(JBD2_KNOWN_ROCOMPAT_FEATURES)) ||\n\t\t    (sb->s_feature_incompat &\n\t\t     ~cpu_to_be32(JBD2_KNOWN_INCOMPAT_FEATURES))) {\n\t\t\tprintk(KERN_WARNING\n\t\t\t\t\"JBD2: Unrecognised features on journal\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\t/*\n\t * Create a slab for this blocksize\n\t */\n\terr = jbd2_journal_create_slab(be32_to_cpu(sb->s_blocksize));\n\tif (err)\n\t\treturn err;\n\n\t/* Let the recovery code check whether it needs to recover any\n\t * data from the journal. */\n\tif (jbd2_journal_recover(journal))\n\t\tgoto recovery_error;\n\n\tif (journal->j_failed_commit) {\n\t\tprintk(KERN_ERR \"JBD2: journal transaction %u on %s \"\n\t\t       \"is corrupt.\\n\", journal->j_failed_commit,\n\t\t       journal->j_devname);\n\t\treturn -EIO;\n\t}\n\n\t/* OK, we've finished with the dynamic journal bits:\n\t * reinitialise the dynamic contents of the superblock in memory\n\t * and reset them on disk. */\n\tif (journal_reset(journal))\n\t\tgoto recovery_error;\n\n\tjournal->j_flags &= ~JBD2_ABORT;\n\tjournal->j_flags |= JBD2_LOADED;\n\treturn 0;\n\nrecovery_error:\n\tprintk(KERN_WARNING \"JBD2: recovery failed\\n\");\n\treturn -EIO;\n}",
          "includes": [
            "#include <asm/page.h>",
            "#include <asm/uaccess.h>",
            "#include <trace/events/jbd2.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/bitops.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/log2.h>",
            "#include <linux/hash.h>",
            "#include <linux/math64.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/poison.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <trace/events/jbd2.h>\n#include <linux/ratelimit.h>\n#include <linux/bitops.h>\n#include <linux/backing-dev.h>\n#include <linux/vmalloc.h>\n#include <linux/log2.h>\n#include <linux/hash.h>\n#include <linux/math64.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/poison.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/freezer.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd2.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/module.h>\n\nint jbd2_journal_load(journal_t *journal)\n{\n\tint err;\n\tjournal_superblock_t *sb;\n\n\terr = load_superblock(journal);\n\tif (err)\n\t\treturn err;\n\n\tsb = journal->j_superblock;\n\t/* If this is a V2 superblock, then we have to check the\n\t * features flags on it. */\n\n\tif (journal->j_format_version >= 2) {\n\t\tif ((sb->s_feature_ro_compat &\n\t\t     ~cpu_to_be32(JBD2_KNOWN_ROCOMPAT_FEATURES)) ||\n\t\t    (sb->s_feature_incompat &\n\t\t     ~cpu_to_be32(JBD2_KNOWN_INCOMPAT_FEATURES))) {\n\t\t\tprintk(KERN_WARNING\n\t\t\t\t\"JBD2: Unrecognised features on journal\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\t/*\n\t * Create a slab for this blocksize\n\t */\n\terr = jbd2_journal_create_slab(be32_to_cpu(sb->s_blocksize));\n\tif (err)\n\t\treturn err;\n\n\t/* Let the recovery code check whether it needs to recover any\n\t * data from the journal. */\n\tif (jbd2_journal_recover(journal))\n\t\tgoto recovery_error;\n\n\tif (journal->j_failed_commit) {\n\t\tprintk(KERN_ERR \"JBD2: journal transaction %u on %s \"\n\t\t       \"is corrupt.\\n\", journal->j_failed_commit,\n\t\t       journal->j_devname);\n\t\treturn -EIO;\n\t}\n\n\t/* OK, we've finished with the dynamic journal bits:\n\t * reinitialise the dynamic contents of the superblock in memory\n\t * and reset them on disk. */\n\tif (journal_reset(journal))\n\t\tgoto recovery_error;\n\n\tjournal->j_flags &= ~JBD2_ABORT;\n\tjournal->j_flags |= JBD2_LOADED;\n\treturn 0;\n\nrecovery_error:\n\tprintk(KERN_WARNING \"JBD2: recovery failed\\n\");\n\treturn -EIO;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "save",
            "((char *) es) +\n\t\t\t       EXT4_S_ERR_START",
            "EXT4_S_ERR_LEN"
          ],
          "line": 4538
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmalloc",
          "args": [
            "EXT4_S_ERR_LEN",
            "GFP_KERNEL"
          ],
          "line": 4536
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_dx_dir_kmalloc_leaves",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
          "lines": "2534-2546",
          "snippet": "static struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}"
        }
      },
      {
        "call_info": {
          "callee": "jbd2_journal_wipe",
          "args": [
            "journal",
            "!really_read_only"
          ],
          "line": 4534
        },
        "resolved": true,
        "details": {
          "function_name": "jbd2_journal_wipe",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd2/journal.c",
          "lines": "1985-2011",
          "snippet": "int jbd2_journal_wipe(journal_t *journal, int write)\n{\n\tint err = 0;\n\n\tJ_ASSERT (!(journal->j_flags & JBD2_LOADED));\n\n\terr = load_superblock(journal);\n\tif (err)\n\t\treturn err;\n\n\tif (!journal->j_tail)\n\t\tgoto no_recovery;\n\n\tprintk(KERN_WARNING \"JBD2: %s recovery information on journal\\n\",\n\t\twrite ? \"Clearing\" : \"Ignoring\");\n\n\terr = jbd2_journal_skip_recovery(journal);\n\tif (write) {\n\t\t/* Lock to make assertions happy... */\n\t\tmutex_lock(&journal->j_checkpoint_mutex);\n\t\tjbd2_mark_journal_empty(journal);\n\t\tmutex_unlock(&journal->j_checkpoint_mutex);\n\t}\n\n no_recovery:\n\treturn err;\n}",
          "includes": [
            "#include <asm/page.h>",
            "#include <asm/uaccess.h>",
            "#include <trace/events/jbd2.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/bitops.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/log2.h>",
            "#include <linux/hash.h>",
            "#include <linux/math64.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/poison.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <trace/events/jbd2.h>\n#include <linux/ratelimit.h>\n#include <linux/bitops.h>\n#include <linux/backing-dev.h>\n#include <linux/vmalloc.h>\n#include <linux/log2.h>\n#include <linux/hash.h>\n#include <linux/math64.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/poison.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/freezer.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd2.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/module.h>\n\nint jbd2_journal_wipe(journal_t *journal, int write)\n{\n\tint err = 0;\n\n\tJ_ASSERT (!(journal->j_flags & JBD2_LOADED));\n\n\terr = load_superblock(journal);\n\tif (err)\n\t\treturn err;\n\n\tif (!journal->j_tail)\n\t\tgoto no_recovery;\n\n\tprintk(KERN_WARNING \"JBD2: %s recovery information on journal\\n\",\n\t\twrite ? \"Clearing\" : \"Ignoring\");\n\n\terr = jbd2_journal_skip_recovery(journal);\n\tif (write) {\n\t\t/* Lock to make assertions happy... */\n\t\tmutex_lock(&journal->j_checkpoint_mutex);\n\t\tjbd2_mark_journal_empty(journal);\n\t\tmutex_unlock(&journal->j_checkpoint_mutex);\n\t}\n\n no_recovery:\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "EXT4_HAS_INCOMPAT_FEATURE",
          "args": [
            "sb",
            "EXT4_FEATURE_INCOMPAT_RECOVER"
          ],
          "line": 4533
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_get_dev_journal",
          "args": [
            "sb",
            "journal_dev"
          ],
          "line": 4526
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_get_dev_journal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/super.c",
          "lines": "4380-4473",
          "snippet": "static journal_t *ext4_get_dev_journal(struct super_block *sb,\n\t\t\t\t       dev_t j_dev)\n{\n\tstruct buffer_head *bh;\n\tjournal_t *journal;\n\text4_fsblk_t start;\n\text4_fsblk_t len;\n\tint hblock, blocksize;\n\text4_fsblk_t sb_block;\n\tunsigned long offset;\n\tstruct ext4_super_block *es;\n\tstruct block_device *bdev;\n\n\tBUG_ON(!EXT4_HAS_COMPAT_FEATURE(sb, EXT4_FEATURE_COMPAT_HAS_JOURNAL));\n\n\tbdev = ext4_blkdev_get(j_dev, sb);\n\tif (bdev == NULL)\n\t\treturn NULL;\n\n\tblocksize = sb->s_blocksize;\n\thblock = bdev_logical_block_size(bdev);\n\tif (blocksize < hblock) {\n\t\text4_msg(sb, KERN_ERR,\n\t\t\t\"blocksize too small for journal device\");\n\t\tgoto out_bdev;\n\t}\n\n\tsb_block = EXT4_MIN_BLOCK_SIZE / blocksize;\n\toffset = EXT4_MIN_BLOCK_SIZE % blocksize;\n\tset_blocksize(bdev, blocksize);\n\tif (!(bh = __bread(bdev, sb_block, blocksize))) {\n\t\text4_msg(sb, KERN_ERR, \"couldn't read superblock of \"\n\t\t       \"external journal\");\n\t\tgoto out_bdev;\n\t}\n\n\tes = (struct ext4_super_block *) (bh->b_data + offset);\n\tif ((le16_to_cpu(es->s_magic) != EXT4_SUPER_MAGIC) ||\n\t    !(le32_to_cpu(es->s_feature_incompat) &\n\t      EXT4_FEATURE_INCOMPAT_JOURNAL_DEV)) {\n\t\text4_msg(sb, KERN_ERR, \"external journal has \"\n\t\t\t\t\t\"bad superblock\");\n\t\tbrelse(bh);\n\t\tgoto out_bdev;\n\t}\n\n\tif ((le32_to_cpu(es->s_feature_ro_compat) &\n\t     EXT4_FEATURE_RO_COMPAT_METADATA_CSUM) &&\n\t    es->s_checksum != ext4_superblock_csum(sb, es)) {\n\t\text4_msg(sb, KERN_ERR, \"external journal has \"\n\t\t\t\t       \"corrupt superblock\");\n\t\tbrelse(bh);\n\t\tgoto out_bdev;\n\t}\n\n\tif (memcmp(EXT4_SB(sb)->s_es->s_journal_uuid, es->s_uuid, 16)) {\n\t\text4_msg(sb, KERN_ERR, \"journal UUID does not match\");\n\t\tbrelse(bh);\n\t\tgoto out_bdev;\n\t}\n\n\tlen = ext4_blocks_count(es);\n\tstart = sb_block + 1;\n\tbrelse(bh);\t/* we're done with the superblock */\n\n\tjournal = jbd2_journal_init_dev(bdev, sb->s_bdev,\n\t\t\t\t\tstart, len, blocksize);\n\tif (!journal) {\n\t\text4_msg(sb, KERN_ERR, \"failed to create device journal\");\n\t\tgoto out_bdev;\n\t}\n\tjournal->j_private = sb;\n\tll_rw_block(READ | REQ_META | REQ_PRIO, 1, &journal->j_sb_buffer);\n\twait_on_buffer(journal->j_sb_buffer);\n\tif (!buffer_uptodate(journal->j_sb_buffer)) {\n\t\text4_msg(sb, KERN_ERR, \"I/O error on journal device\");\n\t\tgoto out_journal;\n\t}\n\tif (be32_to_cpu(journal->j_superblock->s_nr_users) != 1) {\n\t\text4_msg(sb, KERN_ERR, \"External journal has more than one \"\n\t\t\t\t\t\"user (unsupported) - %d\",\n\t\t\tbe32_to_cpu(journal->j_superblock->s_nr_users));\n\t\tgoto out_journal;\n\t}\n\tEXT4_SB(sb)->journal_bdev = bdev;\n\text4_init_journal_params(sb, journal);\n\treturn journal;\n\nout_journal:\n\tjbd2_journal_destroy(journal);\nout_bdev:\n\text4_blkdev_put(bdev);\n\treturn NULL;\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"mballoc.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include \"ext4_extents.h\"\t/* Needed for trace points definition */",
            "#include \"ext4.h\"",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/crc16.h>",
            "#include <linux/log2.h>",
            "#include <linux/ctype.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/random.h>",
            "#include <linux/vfs.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/parser.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/time.h>",
            "#include <linux/fs.h>",
            "#include <linux/string.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void ext4_mark_recovery_complete(struct super_block *sb,\n\t\t\t\t\tstruct ext4_super_block *es);",
            "static void ext4_clear_journal_err(struct super_block *sb,\n\t\t\t\t   struct ext4_super_block *es);",
            "static int ext4_unfreeze(struct super_block *sb);",
            "static int ext4_freeze(struct super_block *sb);",
            "static inline int ext2_feature_set_ok(struct super_block *sb);",
            "static inline int ext3_feature_set_ok(struct super_block *sb);",
            "static void ext4_unregister_li_request(struct super_block *sb);",
            "static int ext4_reserve_clusters(struct ext4_sb_info *, ext4_fsblk_t);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"mballoc.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4_extents.h\"\t/* Needed for trace points definition */\n#include \"ext4.h\"\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <asm/uaccess.h>\n#include <linux/cleancache.h>\n#include <linux/crc16.h>\n#include <linux/log2.h>\n#include <linux/ctype.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/random.h>\n#include <linux/vfs.h>\n#include <linux/exportfs.h>\n#include <linux/buffer_head.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/jbd2.h>\n#include <linux/vmalloc.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n#include <linux/string.h>\n#include <linux/module.h>\n\nstatic void ext4_mark_recovery_complete(struct super_block *sb,\n\t\t\t\t\tstruct ext4_super_block *es);\nstatic void ext4_clear_journal_err(struct super_block *sb,\n\t\t\t\t   struct ext4_super_block *es);\nstatic int ext4_unfreeze(struct super_block *sb);\nstatic int ext4_freeze(struct super_block *sb);\nstatic inline int ext2_feature_set_ok(struct super_block *sb);\nstatic inline int ext3_feature_set_ok(struct super_block *sb);\nstatic void ext4_unregister_li_request(struct super_block *sb);\nstatic int ext4_reserve_clusters(struct ext4_sb_info *, ext4_fsblk_t);\n\nstatic journal_t *ext4_get_dev_journal(struct super_block *sb,\n\t\t\t\t       dev_t j_dev)\n{\n\tstruct buffer_head *bh;\n\tjournal_t *journal;\n\text4_fsblk_t start;\n\text4_fsblk_t len;\n\tint hblock, blocksize;\n\text4_fsblk_t sb_block;\n\tunsigned long offset;\n\tstruct ext4_super_block *es;\n\tstruct block_device *bdev;\n\n\tBUG_ON(!EXT4_HAS_COMPAT_FEATURE(sb, EXT4_FEATURE_COMPAT_HAS_JOURNAL));\n\n\tbdev = ext4_blkdev_get(j_dev, sb);\n\tif (bdev == NULL)\n\t\treturn NULL;\n\n\tblocksize = sb->s_blocksize;\n\thblock = bdev_logical_block_size(bdev);\n\tif (blocksize < hblock) {\n\t\text4_msg(sb, KERN_ERR,\n\t\t\t\"blocksize too small for journal device\");\n\t\tgoto out_bdev;\n\t}\n\n\tsb_block = EXT4_MIN_BLOCK_SIZE / blocksize;\n\toffset = EXT4_MIN_BLOCK_SIZE % blocksize;\n\tset_blocksize(bdev, blocksize);\n\tif (!(bh = __bread(bdev, sb_block, blocksize))) {\n\t\text4_msg(sb, KERN_ERR, \"couldn't read superblock of \"\n\t\t       \"external journal\");\n\t\tgoto out_bdev;\n\t}\n\n\tes = (struct ext4_super_block *) (bh->b_data + offset);\n\tif ((le16_to_cpu(es->s_magic) != EXT4_SUPER_MAGIC) ||\n\t    !(le32_to_cpu(es->s_feature_incompat) &\n\t      EXT4_FEATURE_INCOMPAT_JOURNAL_DEV)) {\n\t\text4_msg(sb, KERN_ERR, \"external journal has \"\n\t\t\t\t\t\"bad superblock\");\n\t\tbrelse(bh);\n\t\tgoto out_bdev;\n\t}\n\n\tif ((le32_to_cpu(es->s_feature_ro_compat) &\n\t     EXT4_FEATURE_RO_COMPAT_METADATA_CSUM) &&\n\t    es->s_checksum != ext4_superblock_csum(sb, es)) {\n\t\text4_msg(sb, KERN_ERR, \"external journal has \"\n\t\t\t\t       \"corrupt superblock\");\n\t\tbrelse(bh);\n\t\tgoto out_bdev;\n\t}\n\n\tif (memcmp(EXT4_SB(sb)->s_es->s_journal_uuid, es->s_uuid, 16)) {\n\t\text4_msg(sb, KERN_ERR, \"journal UUID does not match\");\n\t\tbrelse(bh);\n\t\tgoto out_bdev;\n\t}\n\n\tlen = ext4_blocks_count(es);\n\tstart = sb_block + 1;\n\tbrelse(bh);\t/* we're done with the superblock */\n\n\tjournal = jbd2_journal_init_dev(bdev, sb->s_bdev,\n\t\t\t\t\tstart, len, blocksize);\n\tif (!journal) {\n\t\text4_msg(sb, KERN_ERR, \"failed to create device journal\");\n\t\tgoto out_bdev;\n\t}\n\tjournal->j_private = sb;\n\tll_rw_block(READ | REQ_META | REQ_PRIO, 1, &journal->j_sb_buffer);\n\twait_on_buffer(journal->j_sb_buffer);\n\tif (!buffer_uptodate(journal->j_sb_buffer)) {\n\t\text4_msg(sb, KERN_ERR, \"I/O error on journal device\");\n\t\tgoto out_journal;\n\t}\n\tif (be32_to_cpu(journal->j_superblock->s_nr_users) != 1) {\n\t\text4_msg(sb, KERN_ERR, \"External journal has more than one \"\n\t\t\t\t\t\"user (unsupported) - %d\",\n\t\t\tbe32_to_cpu(journal->j_superblock->s_nr_users));\n\t\tgoto out_journal;\n\t}\n\tEXT4_SB(sb)->journal_bdev = bdev;\n\text4_init_journal_params(sb, journal);\n\treturn journal;\n\nout_journal:\n\tjbd2_journal_destroy(journal);\nout_bdev:\n\text4_blkdev_put(bdev);\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_get_journal",
          "args": [
            "sb",
            "journal_inum"
          ],
          "line": 4523
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_get_journal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/super.c",
          "lines": "4337-4378",
          "snippet": "static journal_t *ext4_get_journal(struct super_block *sb,\n\t\t\t\t   unsigned int journal_inum)\n{\n\tstruct inode *journal_inode;\n\tjournal_t *journal;\n\n\tBUG_ON(!EXT4_HAS_COMPAT_FEATURE(sb, EXT4_FEATURE_COMPAT_HAS_JOURNAL));\n\n\t/* First, test for the existence of a valid inode on disk.  Bad\n\t * things happen if we iget() an unused inode, as the subsequent\n\t * iput() will try to delete it. */\n\n\tjournal_inode = ext4_iget(sb, journal_inum);\n\tif (IS_ERR(journal_inode)) {\n\t\text4_msg(sb, KERN_ERR, \"no journal found\");\n\t\treturn NULL;\n\t}\n\tif (!journal_inode->i_nlink) {\n\t\tmake_bad_inode(journal_inode);\n\t\tiput(journal_inode);\n\t\text4_msg(sb, KERN_ERR, \"journal inode is deleted\");\n\t\treturn NULL;\n\t}\n\n\tjbd_debug(2, \"Journal inode found at %p: %lld bytes\\n\",\n\t\t  journal_inode, journal_inode->i_size);\n\tif (!S_ISREG(journal_inode->i_mode)) {\n\t\text4_msg(sb, KERN_ERR, \"invalid journal inode\");\n\t\tiput(journal_inode);\n\t\treturn NULL;\n\t}\n\n\tjournal = jbd2_journal_init_inode(journal_inode);\n\tif (!journal) {\n\t\text4_msg(sb, KERN_ERR, \"Could not load journal inode\");\n\t\tiput(journal_inode);\n\t\treturn NULL;\n\t}\n\tjournal->j_private = sb;\n\text4_init_journal_params(sb, journal);\n\treturn journal;\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"mballoc.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include \"ext4_extents.h\"\t/* Needed for trace points definition */",
            "#include \"ext4.h\"",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/crc16.h>",
            "#include <linux/log2.h>",
            "#include <linux/ctype.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/random.h>",
            "#include <linux/vfs.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/parser.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/time.h>",
            "#include <linux/fs.h>",
            "#include <linux/string.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ext4_unfreeze(struct super_block *sb);",
            "static int ext4_freeze(struct super_block *sb);",
            "static inline int ext2_feature_set_ok(struct super_block *sb);",
            "static inline int ext3_feature_set_ok(struct super_block *sb);",
            "static void ext4_unregister_li_request(struct super_block *sb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"mballoc.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4_extents.h\"\t/* Needed for trace points definition */\n#include \"ext4.h\"\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <asm/uaccess.h>\n#include <linux/cleancache.h>\n#include <linux/crc16.h>\n#include <linux/log2.h>\n#include <linux/ctype.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/random.h>\n#include <linux/vfs.h>\n#include <linux/exportfs.h>\n#include <linux/buffer_head.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/jbd2.h>\n#include <linux/vmalloc.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n#include <linux/string.h>\n#include <linux/module.h>\n\nstatic int ext4_unfreeze(struct super_block *sb);\nstatic int ext4_freeze(struct super_block *sb);\nstatic inline int ext2_feature_set_ok(struct super_block *sb);\nstatic inline int ext3_feature_set_ok(struct super_block *sb);\nstatic void ext4_unregister_li_request(struct super_block *sb);\n\nstatic journal_t *ext4_get_journal(struct super_block *sb,\n\t\t\t\t   unsigned int journal_inum)\n{\n\tstruct inode *journal_inode;\n\tjournal_t *journal;\n\n\tBUG_ON(!EXT4_HAS_COMPAT_FEATURE(sb, EXT4_FEATURE_COMPAT_HAS_JOURNAL));\n\n\t/* First, test for the existence of a valid inode on disk.  Bad\n\t * things happen if we iget() an unused inode, as the subsequent\n\t * iput() will try to delete it. */\n\n\tjournal_inode = ext4_iget(sb, journal_inum);\n\tif (IS_ERR(journal_inode)) {\n\t\text4_msg(sb, KERN_ERR, \"no journal found\");\n\t\treturn NULL;\n\t}\n\tif (!journal_inode->i_nlink) {\n\t\tmake_bad_inode(journal_inode);\n\t\tiput(journal_inode);\n\t\text4_msg(sb, KERN_ERR, \"journal inode is deleted\");\n\t\treturn NULL;\n\t}\n\n\tjbd_debug(2, \"Journal inode found at %p: %lld bytes\\n\",\n\t\t  journal_inode, journal_inode->i_size);\n\tif (!S_ISREG(journal_inode->i_mode)) {\n\t\text4_msg(sb, KERN_ERR, \"invalid journal inode\");\n\t\tiput(journal_inode);\n\t\treturn NULL;\n\t}\n\n\tjournal = jbd2_journal_init_inode(journal_inode);\n\tif (!journal) {\n\t\text4_msg(sb, KERN_ERR, \"Could not load journal inode\");\n\t\tiput(journal_inode);\n\t\treturn NULL;\n\t}\n\tjournal->j_private = sb;\n\text4_init_journal_params(sb, journal);\n\treturn journal;\n}"
        }
      },
      {
        "call_info": {
          "callee": "EXT4_HAS_INCOMPAT_FEATURE",
          "args": [
            "sb",
            "EXT4_FEATURE_INCOMPAT_RECOVER"
          ],
          "line": 4502
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bdev_read_only",
          "args": [
            "sb->s_bdev"
          ],
          "line": 4495
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "new_decode_dev",
          "args": [
            "le32_to_cpu(es->s_journal_dev)"
          ],
          "line": 4493
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "new_decode_dev",
          "args": [
            "journal_devnum"
          ],
          "line": 4491
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!EXT4_HAS_COMPAT_FEATURE(sb, EXT4_FEATURE_COMPAT_HAS_JOURNAL)"
          ],
          "line": 4485
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXT4_HAS_COMPAT_FEATURE",
          "args": [
            "sb",
            "EXT4_FEATURE_COMPAT_HAS_JOURNAL"
          ],
          "line": 4485
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"mballoc.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4_extents.h\"\t/* Needed for trace points definition */\n#include \"ext4.h\"\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <asm/uaccess.h>\n#include <linux/cleancache.h>\n#include <linux/crc16.h>\n#include <linux/log2.h>\n#include <linux/ctype.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/random.h>\n#include <linux/vfs.h>\n#include <linux/exportfs.h>\n#include <linux/buffer_head.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/jbd2.h>\n#include <linux/vmalloc.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n#include <linux/string.h>\n#include <linux/module.h>\n\nstatic int ext4_load_journal(struct super_block *, struct ext4_super_block *,\n\t\t\t     unsigned long journal_devnum);\nstatic void ext4_mark_recovery_complete(struct super_block *sb,\n\t\t\t\t\tstruct ext4_super_block *es);\nstatic void ext4_clear_journal_err(struct super_block *sb,\n\t\t\t\t   struct ext4_super_block *es);\nstatic int ext4_unfreeze(struct super_block *sb);\nstatic int ext4_freeze(struct super_block *sb);\nstatic inline int ext2_feature_set_ok(struct super_block *sb);\nstatic inline int ext3_feature_set_ok(struct super_block *sb);\nstatic int ext4_feature_set_ok(struct super_block *sb, int readonly);\nstatic void ext4_unregister_li_request(struct super_block *sb);\n\nstatic int ext4_load_journal(struct super_block *sb,\n\t\t\t     struct ext4_super_block *es,\n\t\t\t     unsigned long journal_devnum)\n{\n\tjournal_t *journal;\n\tunsigned int journal_inum = le32_to_cpu(es->s_journal_inum);\n\tdev_t journal_dev;\n\tint err = 0;\n\tint really_read_only;\n\n\tBUG_ON(!EXT4_HAS_COMPAT_FEATURE(sb, EXT4_FEATURE_COMPAT_HAS_JOURNAL));\n\n\tif (journal_devnum &&\n\t    journal_devnum != le32_to_cpu(es->s_journal_dev)) {\n\t\text4_msg(sb, KERN_INFO, \"external journal device major/minor \"\n\t\t\t\"numbers have changed\");\n\t\tjournal_dev = new_decode_dev(journal_devnum);\n\t} else\n\t\tjournal_dev = new_decode_dev(le32_to_cpu(es->s_journal_dev));\n\n\treally_read_only = bdev_read_only(sb->s_bdev);\n\n\t/*\n\t * Are we loading a blank journal or performing recovery after a\n\t * crash?  For recovery, we need to check in advance whether we\n\t * can get read-write access to the device.\n\t */\n\tif (EXT4_HAS_INCOMPAT_FEATURE(sb, EXT4_FEATURE_INCOMPAT_RECOVER)) {\n\t\tif (sb->s_flags & MS_RDONLY) {\n\t\t\text4_msg(sb, KERN_INFO, \"INFO: recovery \"\n\t\t\t\t\t\"required on readonly filesystem\");\n\t\t\tif (really_read_only) {\n\t\t\t\text4_msg(sb, KERN_ERR, \"write access \"\n\t\t\t\t\t\"unavailable, cannot proceed\");\n\t\t\t\treturn -EROFS;\n\t\t\t}\n\t\t\text4_msg(sb, KERN_INFO, \"write access will \"\n\t\t\t       \"be enabled during recovery\");\n\t\t}\n\t}\n\n\tif (journal_inum && journal_dev) {\n\t\text4_msg(sb, KERN_ERR, \"filesystem has both journal \"\n\t\t       \"and inode journals!\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (journal_inum) {\n\t\tif (!(journal = ext4_get_journal(sb, journal_inum)))\n\t\t\treturn -EINVAL;\n\t} else {\n\t\tif (!(journal = ext4_get_dev_journal(sb, journal_dev)))\n\t\t\treturn -EINVAL;\n\t}\n\n\tif (!(journal->j_flags & JBD2_BARRIER))\n\t\text4_msg(sb, KERN_INFO, \"barriers disabled\");\n\n\tif (!EXT4_HAS_INCOMPAT_FEATURE(sb, EXT4_FEATURE_INCOMPAT_RECOVER))\n\t\terr = jbd2_journal_wipe(journal, !really_read_only);\n\tif (!err) {\n\t\tchar *save = kmalloc(EXT4_S_ERR_LEN, GFP_KERNEL);\n\t\tif (save)\n\t\t\tmemcpy(save, ((char *) es) +\n\t\t\t       EXT4_S_ERR_START, EXT4_S_ERR_LEN);\n\t\terr = jbd2_journal_load(journal);\n\t\tif (save)\n\t\t\tmemcpy(((char *) es) + EXT4_S_ERR_START,\n\t\t\t       save, EXT4_S_ERR_LEN);\n\t\tkfree(save);\n\t}\n\n\tif (err) {\n\t\text4_msg(sb, KERN_ERR, \"error loading journal\");\n\t\tjbd2_journal_destroy(journal);\n\t\treturn err;\n\t}\n\n\tEXT4_SB(sb)->s_journal = journal;\n\text4_clear_journal_err(sb, es);\n\n\tif (!really_read_only && journal_devnum &&\n\t    journal_devnum != le32_to_cpu(es->s_journal_dev)) {\n\t\tes->s_journal_dev = cpu_to_le32(journal_devnum);\n\n\t\t/* Make sure we flush the recovery flag to disk. */\n\t\text4_commit_super(sb, 1);\n\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "ext4_get_dev_journal",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/super.c",
    "lines": "4380-4473",
    "snippet": "static journal_t *ext4_get_dev_journal(struct super_block *sb,\n\t\t\t\t       dev_t j_dev)\n{\n\tstruct buffer_head *bh;\n\tjournal_t *journal;\n\text4_fsblk_t start;\n\text4_fsblk_t len;\n\tint hblock, blocksize;\n\text4_fsblk_t sb_block;\n\tunsigned long offset;\n\tstruct ext4_super_block *es;\n\tstruct block_device *bdev;\n\n\tBUG_ON(!EXT4_HAS_COMPAT_FEATURE(sb, EXT4_FEATURE_COMPAT_HAS_JOURNAL));\n\n\tbdev = ext4_blkdev_get(j_dev, sb);\n\tif (bdev == NULL)\n\t\treturn NULL;\n\n\tblocksize = sb->s_blocksize;\n\thblock = bdev_logical_block_size(bdev);\n\tif (blocksize < hblock) {\n\t\text4_msg(sb, KERN_ERR,\n\t\t\t\"blocksize too small for journal device\");\n\t\tgoto out_bdev;\n\t}\n\n\tsb_block = EXT4_MIN_BLOCK_SIZE / blocksize;\n\toffset = EXT4_MIN_BLOCK_SIZE % blocksize;\n\tset_blocksize(bdev, blocksize);\n\tif (!(bh = __bread(bdev, sb_block, blocksize))) {\n\t\text4_msg(sb, KERN_ERR, \"couldn't read superblock of \"\n\t\t       \"external journal\");\n\t\tgoto out_bdev;\n\t}\n\n\tes = (struct ext4_super_block *) (bh->b_data + offset);\n\tif ((le16_to_cpu(es->s_magic) != EXT4_SUPER_MAGIC) ||\n\t    !(le32_to_cpu(es->s_feature_incompat) &\n\t      EXT4_FEATURE_INCOMPAT_JOURNAL_DEV)) {\n\t\text4_msg(sb, KERN_ERR, \"external journal has \"\n\t\t\t\t\t\"bad superblock\");\n\t\tbrelse(bh);\n\t\tgoto out_bdev;\n\t}\n\n\tif ((le32_to_cpu(es->s_feature_ro_compat) &\n\t     EXT4_FEATURE_RO_COMPAT_METADATA_CSUM) &&\n\t    es->s_checksum != ext4_superblock_csum(sb, es)) {\n\t\text4_msg(sb, KERN_ERR, \"external journal has \"\n\t\t\t\t       \"corrupt superblock\");\n\t\tbrelse(bh);\n\t\tgoto out_bdev;\n\t}\n\n\tif (memcmp(EXT4_SB(sb)->s_es->s_journal_uuid, es->s_uuid, 16)) {\n\t\text4_msg(sb, KERN_ERR, \"journal UUID does not match\");\n\t\tbrelse(bh);\n\t\tgoto out_bdev;\n\t}\n\n\tlen = ext4_blocks_count(es);\n\tstart = sb_block + 1;\n\tbrelse(bh);\t/* we're done with the superblock */\n\n\tjournal = jbd2_journal_init_dev(bdev, sb->s_bdev,\n\t\t\t\t\tstart, len, blocksize);\n\tif (!journal) {\n\t\text4_msg(sb, KERN_ERR, \"failed to create device journal\");\n\t\tgoto out_bdev;\n\t}\n\tjournal->j_private = sb;\n\tll_rw_block(READ | REQ_META | REQ_PRIO, 1, &journal->j_sb_buffer);\n\twait_on_buffer(journal->j_sb_buffer);\n\tif (!buffer_uptodate(journal->j_sb_buffer)) {\n\t\text4_msg(sb, KERN_ERR, \"I/O error on journal device\");\n\t\tgoto out_journal;\n\t}\n\tif (be32_to_cpu(journal->j_superblock->s_nr_users) != 1) {\n\t\text4_msg(sb, KERN_ERR, \"External journal has more than one \"\n\t\t\t\t\t\"user (unsupported) - %d\",\n\t\t\tbe32_to_cpu(journal->j_superblock->s_nr_users));\n\t\tgoto out_journal;\n\t}\n\tEXT4_SB(sb)->journal_bdev = bdev;\n\text4_init_journal_params(sb, journal);\n\treturn journal;\n\nout_journal:\n\tjbd2_journal_destroy(journal);\nout_bdev:\n\text4_blkdev_put(bdev);\n\treturn NULL;\n}",
    "includes": [
      "#include <trace/events/ext4.h>",
      "#include \"mballoc.h\"",
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"ext4_jbd2.h\"",
      "#include \"ext4_extents.h\"\t/* Needed for trace points definition */",
      "#include \"ext4.h\"",
      "#include <linux/freezer.h>",
      "#include <linux/kthread.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/cleancache.h>",
      "#include <linux/crc16.h>",
      "#include <linux/log2.h>",
      "#include <linux/ctype.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/namei.h>",
      "#include <linux/mount.h>",
      "#include <linux/random.h>",
      "#include <linux/vfs.h>",
      "#include <linux/exportfs.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/parser.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/init.h>",
      "#include <linux/slab.h>",
      "#include <linux/jbd2.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/time.h>",
      "#include <linux/fs.h>",
      "#include <linux/string.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void ext4_mark_recovery_complete(struct super_block *sb,\n\t\t\t\t\tstruct ext4_super_block *es);",
      "static void ext4_clear_journal_err(struct super_block *sb,\n\t\t\t\t   struct ext4_super_block *es);",
      "static int ext4_unfreeze(struct super_block *sb);",
      "static int ext4_freeze(struct super_block *sb);",
      "static inline int ext2_feature_set_ok(struct super_block *sb);",
      "static inline int ext3_feature_set_ok(struct super_block *sb);",
      "static void ext4_unregister_li_request(struct super_block *sb);",
      "static int ext4_reserve_clusters(struct ext4_sb_info *, ext4_fsblk_t);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ext4_blkdev_put",
          "args": [
            "bdev"
          ],
          "line": 4471
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_blkdev_put",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/super.c",
          "lines": "726-729",
          "snippet": "static void ext4_blkdev_put(struct block_device *bdev)\n{\n\tblkdev_put(bdev, FMODE_READ|FMODE_WRITE|FMODE_EXCL);\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"mballoc.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include \"ext4_extents.h\"\t/* Needed for trace points definition */",
            "#include \"ext4.h\"",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/crc16.h>",
            "#include <linux/log2.h>",
            "#include <linux/ctype.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/random.h>",
            "#include <linux/vfs.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/parser.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/time.h>",
            "#include <linux/fs.h>",
            "#include <linux/string.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"mballoc.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4_extents.h\"\t/* Needed for trace points definition */\n#include \"ext4.h\"\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <asm/uaccess.h>\n#include <linux/cleancache.h>\n#include <linux/crc16.h>\n#include <linux/log2.h>\n#include <linux/ctype.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/random.h>\n#include <linux/vfs.h>\n#include <linux/exportfs.h>\n#include <linux/buffer_head.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/jbd2.h>\n#include <linux/vmalloc.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n#include <linux/string.h>\n#include <linux/module.h>\n\nstatic void ext4_blkdev_put(struct block_device *bdev)\n{\n\tblkdev_put(bdev, FMODE_READ|FMODE_WRITE|FMODE_EXCL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "jbd2_journal_destroy",
          "args": [
            "journal"
          ],
          "line": 4469
        },
        "resolved": true,
        "details": {
          "function_name": "jbd2_journal_destroy_revoke",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd2/revoke.c",
          "lines": "293-300",
          "snippet": "void jbd2_journal_destroy_revoke(journal_t *journal)\n{\n\tjournal->j_revoke = NULL;\n\tif (journal->j_revoke_table[0])\n\t\tjbd2_journal_destroy_revoke_table(journal->j_revoke_table[0]);\n\tif (journal->j_revoke_table[1])\n\t\tjbd2_journal_destroy_revoke_table(journal->j_revoke_table[1]);\n}",
          "includes": [
            "#include <linux/hash.h>",
            "#include <linux/log2.h>",
            "#include <linux/bio.h>",
            "#include <linux/init.h>",
            "#include <linux/list.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include \"jfs_user.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/hash.h>\n#include <linux/log2.h>\n#include <linux/bio.h>\n#include <linux/init.h>\n#include <linux/list.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd2.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include \"jfs_user.h\"\n\nvoid jbd2_journal_destroy_revoke(journal_t *journal)\n{\n\tjournal->j_revoke = NULL;\n\tif (journal->j_revoke_table[0])\n\t\tjbd2_journal_destroy_revoke_table(journal->j_revoke_table[0]);\n\tif (journal->j_revoke_table[1])\n\t\tjbd2_journal_destroy_revoke_table(journal->j_revoke_table[1]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_init_journal_params",
          "args": [
            "sb",
            "journal"
          ],
          "line": 4465
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_init_journal_params",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/super.c",
          "lines": "4317-4335",
          "snippet": "static void ext4_init_journal_params(struct super_block *sb, journal_t *journal)\n{\n\tstruct ext4_sb_info *sbi = EXT4_SB(sb);\n\n\tjournal->j_commit_interval = sbi->s_commit_interval;\n\tjournal->j_min_batch_time = sbi->s_min_batch_time;\n\tjournal->j_max_batch_time = sbi->s_max_batch_time;\n\n\twrite_lock(&journal->j_state_lock);\n\tif (test_opt(sb, BARRIER))\n\t\tjournal->j_flags |= JBD2_BARRIER;\n\telse\n\t\tjournal->j_flags &= ~JBD2_BARRIER;\n\tif (test_opt(sb, DATA_ERR_ABORT))\n\t\tjournal->j_flags |= JBD2_ABORT_ON_SYNCDATA_ERR;\n\telse\n\t\tjournal->j_flags &= ~JBD2_ABORT_ON_SYNCDATA_ERR;\n\twrite_unlock(&journal->j_state_lock);\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"mballoc.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include \"ext4_extents.h\"\t/* Needed for trace points definition */",
            "#include \"ext4.h\"",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/crc16.h>",
            "#include <linux/log2.h>",
            "#include <linux/ctype.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/random.h>",
            "#include <linux/vfs.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/parser.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/time.h>",
            "#include <linux/fs.h>",
            "#include <linux/string.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ext4_unfreeze(struct super_block *sb);",
            "static int ext4_freeze(struct super_block *sb);",
            "static inline int ext2_feature_set_ok(struct super_block *sb);",
            "static inline int ext3_feature_set_ok(struct super_block *sb);",
            "static void ext4_unregister_li_request(struct super_block *sb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"mballoc.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4_extents.h\"\t/* Needed for trace points definition */\n#include \"ext4.h\"\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <asm/uaccess.h>\n#include <linux/cleancache.h>\n#include <linux/crc16.h>\n#include <linux/log2.h>\n#include <linux/ctype.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/random.h>\n#include <linux/vfs.h>\n#include <linux/exportfs.h>\n#include <linux/buffer_head.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/jbd2.h>\n#include <linux/vmalloc.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n#include <linux/string.h>\n#include <linux/module.h>\n\nstatic int ext4_unfreeze(struct super_block *sb);\nstatic int ext4_freeze(struct super_block *sb);\nstatic inline int ext2_feature_set_ok(struct super_block *sb);\nstatic inline int ext3_feature_set_ok(struct super_block *sb);\nstatic void ext4_unregister_li_request(struct super_block *sb);\n\nstatic void ext4_init_journal_params(struct super_block *sb, journal_t *journal)\n{\n\tstruct ext4_sb_info *sbi = EXT4_SB(sb);\n\n\tjournal->j_commit_interval = sbi->s_commit_interval;\n\tjournal->j_min_batch_time = sbi->s_min_batch_time;\n\tjournal->j_max_batch_time = sbi->s_max_batch_time;\n\n\twrite_lock(&journal->j_state_lock);\n\tif (test_opt(sb, BARRIER))\n\t\tjournal->j_flags |= JBD2_BARRIER;\n\telse\n\t\tjournal->j_flags &= ~JBD2_BARRIER;\n\tif (test_opt(sb, DATA_ERR_ABORT))\n\t\tjournal->j_flags |= JBD2_ABORT_ON_SYNCDATA_ERR;\n\telse\n\t\tjournal->j_flags &= ~JBD2_ABORT_ON_SYNCDATA_ERR;\n\twrite_unlock(&journal->j_state_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "EXT4_SB",
          "args": [
            "sb"
          ],
          "line": 4464
        },
        "resolved": true,
        "details": {
          "function_name": "EXT4_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ext4.h",
          "lines": "1356-1359",
          "snippet": "static inline struct ext4_sb_info *EXT4_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include \"extents_status.h\"",
            "#include <linux/compat.h>",
            "#include <linux/falloc.h>",
            "#include <crypto/hash.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/wait.h>",
            "#include <linux/timer.h>",
            "#include <linux/mutex.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/quota.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extents_status.h\"\n#include <linux/compat.h>\n#include <linux/falloc.h>\n#include <crypto/hash.h>\n#include <linux/ratelimit.h>\n#include <linux/percpu_counter.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/wait.h>\n#include <linux/timer.h>\n#include <linux/mutex.h>\n#include <linux/seqlock.h>\n#include <linux/rbtree.h>\n#include <linux/rwsem.h>\n#include <linux/quota.h>\n#include <linux/jbd2.h>\n#include <linux/magic.h>\n#include <linux/blkdev.h>\n#include <linux/types.h>\n\nstatic inline struct ext4_sb_info *EXT4_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_msg",
          "args": [
            "sb",
            "KERN_ERR",
            "\"External journal has more than one \"\n\t\t\t\t\t\"user (unsupported) - %d\"",
            "be32_to_cpu(journal->j_superblock->s_nr_users)"
          ],
          "line": 4459
        },
        "resolved": true,
        "details": {
          "function_name": "__ext4_msg",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/super.c",
          "lines": "593-607",
          "snippet": "void __ext4_msg(struct super_block *sb,\n\t\tconst char *prefix, const char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tif (!___ratelimit(&(EXT4_SB(sb)->s_msg_ratelimit_state), \"EXT4-fs\"))\n\t\treturn;\n\n\tva_start(args, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\tprintk(\"%sEXT4-fs (%s): %pV\\n\", prefix, sb->s_id, &vaf);\n\tva_end(args);\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"mballoc.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include \"ext4_extents.h\"\t/* Needed for trace points definition */",
            "#include \"ext4.h\"",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/crc16.h>",
            "#include <linux/log2.h>",
            "#include <linux/ctype.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/random.h>",
            "#include <linux/vfs.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/parser.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/time.h>",
            "#include <linux/fs.h>",
            "#include <linux/string.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ext4_unfreeze(struct super_block *sb);",
            "static int ext4_freeze(struct super_block *sb);",
            "static inline int ext2_feature_set_ok(struct super_block *sb);",
            "static inline int ext3_feature_set_ok(struct super_block *sb);",
            "static void ext4_unregister_li_request(struct super_block *sb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"mballoc.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4_extents.h\"\t/* Needed for trace points definition */\n#include \"ext4.h\"\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <asm/uaccess.h>\n#include <linux/cleancache.h>\n#include <linux/crc16.h>\n#include <linux/log2.h>\n#include <linux/ctype.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/random.h>\n#include <linux/vfs.h>\n#include <linux/exportfs.h>\n#include <linux/buffer_head.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/jbd2.h>\n#include <linux/vmalloc.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n#include <linux/string.h>\n#include <linux/module.h>\n\nstatic int ext4_unfreeze(struct super_block *sb);\nstatic int ext4_freeze(struct super_block *sb);\nstatic inline int ext2_feature_set_ok(struct super_block *sb);\nstatic inline int ext3_feature_set_ok(struct super_block *sb);\nstatic void ext4_unregister_li_request(struct super_block *sb);\n\nvoid __ext4_msg(struct super_block *sb,\n\t\tconst char *prefix, const char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tif (!___ratelimit(&(EXT4_SB(sb)->s_msg_ratelimit_state), \"EXT4-fs\"))\n\t\treturn;\n\n\tva_start(args, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\tprintk(\"%sEXT4-fs (%s): %pV\\n\", prefix, sb->s_id, &vaf);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "journal->j_superblock->s_nr_users"
          ],
          "line": 4461
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "journal->j_superblock->s_nr_users"
          ],
          "line": 4458
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "buffer_uptodate",
          "args": [
            "journal->j_sb_buffer"
          ],
          "line": 4454
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_set_buffer_uptodate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/disk-io.c",
          "lines": "3758-3761",
          "snippet": "int btrfs_set_buffer_uptodate(struct extent_buffer *buf)\n{\n\treturn set_extent_buffer_uptodate(buf);\n}",
          "includes": [
            "#include <asm/cpufeature.h>",
            "#include \"qgroup.h\"",
            "#include \"sysfs.h\"",
            "#include \"raid56.h\"",
            "#include \"dev-replace.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"inode-map.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"tree-log.h\"",
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"hash.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/uuid.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/migrate.h>",
            "#include <linux/slab.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/writeback.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/swap.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/cpufeature.h>\n#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"raid56.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <asm/unaligned.h>\n#include <linux/semaphore.h>\n#include <linux/uuid.h>\n#include <linux/ratelimit.h>\n#include <linux/migrate.h>\n#include <linux/slab.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/writeback.h>\n#include <linux/radix-tree.h>\n#include <linux/swap.h>\n#include <linux/scatterlist.h>\n#include <linux/blkdev.h>\n#include <linux/fs.h>\n\nint btrfs_set_buffer_uptodate(struct extent_buffer *buf)\n{\n\treturn set_extent_buffer_uptodate(buf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "wait_on_buffer",
          "args": [
            "journal->j_sb_buffer"
          ],
          "line": 4453
        },
        "resolved": true,
        "details": {
          "function_name": "__wait_on_buffer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "117-120",
          "snippet": "void __wait_on_buffer(struct buffer_head * bh)\n{\n\twait_on_bit_io(&bh->b_state, BH_Lock, TASK_UNINTERRUPTIBLE);\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid __wait_on_buffer(struct buffer_head * bh)\n{\n\twait_on_bit_io(&bh->b_state, BH_Lock, TASK_UNINTERRUPTIBLE);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ll_rw_block",
          "args": [
            "READ | REQ_META | REQ_PRIO",
            "1",
            "&journal->j_sb_buffer"
          ],
          "line": 4452
        },
        "resolved": true,
        "details": {
          "function_name": "ll_rw_block",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "3086-3112",
          "snippet": "void ll_rw_block(int rw, int nr, struct buffer_head *bhs[])\n{\n\tint i;\n\n\tfor (i = 0; i < nr; i++) {\n\t\tstruct buffer_head *bh = bhs[i];\n\n\t\tif (!trylock_buffer(bh))\n\t\t\tcontinue;\n\t\tif (rw == WRITE) {\n\t\t\tif (test_clear_buffer_dirty(bh)) {\n\t\t\t\tbh->b_end_io = end_buffer_write_sync;\n\t\t\t\tget_bh(bh);\n\t\t\t\tsubmit_bh(WRITE, bh);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t} else {\n\t\t\tif (!buffer_uptodate(bh)) {\n\t\t\t\tbh->b_end_io = end_buffer_read_sync;\n\t\t\t\tget_bh(bh);\n\t\t\t\tsubmit_bh(rw, bh);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\t\tunlock_buffer(bh);\n\t}\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid ll_rw_block(int rw, int nr, struct buffer_head *bhs[])\n{\n\tint i;\n\n\tfor (i = 0; i < nr; i++) {\n\t\tstruct buffer_head *bh = bhs[i];\n\n\t\tif (!trylock_buffer(bh))\n\t\t\tcontinue;\n\t\tif (rw == WRITE) {\n\t\t\tif (test_clear_buffer_dirty(bh)) {\n\t\t\t\tbh->b_end_io = end_buffer_write_sync;\n\t\t\t\tget_bh(bh);\n\t\t\t\tsubmit_bh(WRITE, bh);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t} else {\n\t\t\tif (!buffer_uptodate(bh)) {\n\t\t\t\tbh->b_end_io = end_buffer_read_sync;\n\t\t\t\tget_bh(bh);\n\t\t\t\tsubmit_bh(rw, bh);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\t\tunlock_buffer(bh);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "jbd2_journal_init_dev",
          "args": [
            "bdev",
            "sb->s_bdev",
            "start",
            "len",
            "blocksize"
          ],
          "line": 4445
        },
        "resolved": true,
        "details": {
          "function_name": "jbd2_journal_init_dev",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd2/journal.c",
          "lines": "1134-1182",
          "snippet": "journal_t * jbd2_journal_init_dev(struct block_device *bdev,\n\t\t\tstruct block_device *fs_dev,\n\t\t\tunsigned long long start, int len, int blocksize)\n{\n\tjournal_t *journal = journal_init_common();\n\tstruct buffer_head *bh;\n\tchar *p;\n\tint n;\n\n\tif (!journal)\n\t\treturn NULL;\n\n\t/* journal descriptor can store up to n blocks -bzzz */\n\tjournal->j_blocksize = blocksize;\n\tjournal->j_dev = bdev;\n\tjournal->j_fs_dev = fs_dev;\n\tjournal->j_blk_offset = start;\n\tjournal->j_maxlen = len;\n\tbdevname(journal->j_dev, journal->j_devname);\n\tp = journal->j_devname;\n\twhile ((p = strchr(p, '/')))\n\t\t*p = '!';\n\tjbd2_stats_proc_init(journal);\n\tn = journal->j_blocksize / sizeof(journal_block_tag_t);\n\tjournal->j_wbufsize = n;\n\tjournal->j_wbuf = kmalloc(n * sizeof(struct buffer_head*), GFP_KERNEL);\n\tif (!journal->j_wbuf) {\n\t\tprintk(KERN_ERR \"%s: Can't allocate bhs for commit thread\\n\",\n\t\t\t__func__);\n\t\tgoto out_err;\n\t}\n\n\tbh = __getblk(journal->j_dev, start, journal->j_blocksize);\n\tif (!bh) {\n\t\tprintk(KERN_ERR\n\t\t       \"%s: Cannot get buffer for journal superblock\\n\",\n\t\t       __func__);\n\t\tgoto out_err;\n\t}\n\tjournal->j_sb_buffer = bh;\n\tjournal->j_superblock = (journal_superblock_t *)bh->b_data;\n\n\treturn journal;\nout_err:\n\tkfree(journal->j_wbuf);\n\tjbd2_stats_proc_exit(journal);\n\tkfree(journal);\n\treturn NULL;\n}",
          "includes": [
            "#include <asm/page.h>",
            "#include <asm/uaccess.h>",
            "#include <trace/events/jbd2.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/bitops.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/log2.h>",
            "#include <linux/hash.h>",
            "#include <linux/math64.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/poison.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <trace/events/jbd2.h>\n#include <linux/ratelimit.h>\n#include <linux/bitops.h>\n#include <linux/backing-dev.h>\n#include <linux/vmalloc.h>\n#include <linux/log2.h>\n#include <linux/hash.h>\n#include <linux/math64.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/poison.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/freezer.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd2.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/module.h>\n\njournal_t * jbd2_journal_init_dev(struct block_device *bdev,\n\t\t\tstruct block_device *fs_dev,\n\t\t\tunsigned long long start, int len, int blocksize)\n{\n\tjournal_t *journal = journal_init_common();\n\tstruct buffer_head *bh;\n\tchar *p;\n\tint n;\n\n\tif (!journal)\n\t\treturn NULL;\n\n\t/* journal descriptor can store up to n blocks -bzzz */\n\tjournal->j_blocksize = blocksize;\n\tjournal->j_dev = bdev;\n\tjournal->j_fs_dev = fs_dev;\n\tjournal->j_blk_offset = start;\n\tjournal->j_maxlen = len;\n\tbdevname(journal->j_dev, journal->j_devname);\n\tp = journal->j_devname;\n\twhile ((p = strchr(p, '/')))\n\t\t*p = '!';\n\tjbd2_stats_proc_init(journal);\n\tn = journal->j_blocksize / sizeof(journal_block_tag_t);\n\tjournal->j_wbufsize = n;\n\tjournal->j_wbuf = kmalloc(n * sizeof(struct buffer_head*), GFP_KERNEL);\n\tif (!journal->j_wbuf) {\n\t\tprintk(KERN_ERR \"%s: Can't allocate bhs for commit thread\\n\",\n\t\t\t__func__);\n\t\tgoto out_err;\n\t}\n\n\tbh = __getblk(journal->j_dev, start, journal->j_blocksize);\n\tif (!bh) {\n\t\tprintk(KERN_ERR\n\t\t       \"%s: Cannot get buffer for journal superblock\\n\",\n\t\t       __func__);\n\t\tgoto out_err;\n\t}\n\tjournal->j_sb_buffer = bh;\n\tjournal->j_superblock = (journal_superblock_t *)bh->b_data;\n\n\treturn journal;\nout_err:\n\tkfree(journal->j_wbuf);\n\tjbd2_stats_proc_exit(journal);\n\tkfree(journal);\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "brelse",
          "args": [
            "bh"
          ],
          "line": 4443
        },
        "resolved": true,
        "details": {
          "function_name": "__brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1177-1184",
          "snippet": "void __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_blocks_count",
          "args": [
            "es"
          ],
          "line": 4441
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcmp",
          "args": [
            "EXT4_SB(sb)->s_es->s_journal_uuid",
            "es->s_uuid",
            "16"
          ],
          "line": 4435
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_superblock_csum",
          "args": [
            "sb",
            "es"
          ],
          "line": 4428
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_superblock_csum_verify",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/super.c",
          "lines": "140-147",
          "snippet": "static int ext4_superblock_csum_verify(struct super_block *sb,\n\t\t\t\t       struct ext4_super_block *es)\n{\n\tif (!ext4_has_metadata_csum(sb))\n\t\treturn 1;\n\n\treturn es->s_checksum == ext4_superblock_csum(sb, es);\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"mballoc.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include \"ext4_extents.h\"\t/* Needed for trace points definition */",
            "#include \"ext4.h\"",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/crc16.h>",
            "#include <linux/log2.h>",
            "#include <linux/ctype.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/random.h>",
            "#include <linux/vfs.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/parser.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/time.h>",
            "#include <linux/fs.h>",
            "#include <linux/string.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void ext4_mark_recovery_complete(struct super_block *sb,\n\t\t\t\t\tstruct ext4_super_block *es);",
            "static void ext4_clear_journal_err(struct super_block *sb,\n\t\t\t\t   struct ext4_super_block *es);",
            "static int ext4_unfreeze(struct super_block *sb);",
            "static int ext4_freeze(struct super_block *sb);",
            "static inline int ext2_feature_set_ok(struct super_block *sb);",
            "static inline int ext3_feature_set_ok(struct super_block *sb);",
            "static void ext4_unregister_li_request(struct super_block *sb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"mballoc.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4_extents.h\"\t/* Needed for trace points definition */\n#include \"ext4.h\"\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <asm/uaccess.h>\n#include <linux/cleancache.h>\n#include <linux/crc16.h>\n#include <linux/log2.h>\n#include <linux/ctype.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/random.h>\n#include <linux/vfs.h>\n#include <linux/exportfs.h>\n#include <linux/buffer_head.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/jbd2.h>\n#include <linux/vmalloc.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n#include <linux/string.h>\n#include <linux/module.h>\n\nstatic void ext4_mark_recovery_complete(struct super_block *sb,\n\t\t\t\t\tstruct ext4_super_block *es);\nstatic void ext4_clear_journal_err(struct super_block *sb,\n\t\t\t\t   struct ext4_super_block *es);\nstatic int ext4_unfreeze(struct super_block *sb);\nstatic int ext4_freeze(struct super_block *sb);\nstatic inline int ext2_feature_set_ok(struct super_block *sb);\nstatic inline int ext3_feature_set_ok(struct super_block *sb);\nstatic void ext4_unregister_li_request(struct super_block *sb);\n\nstatic int ext4_superblock_csum_verify(struct super_block *sb,\n\t\t\t\t       struct ext4_super_block *es)\n{\n\tif (!ext4_has_metadata_csum(sb))\n\t\treturn 1;\n\n\treturn es->s_checksum == ext4_superblock_csum(sb, es);\n}"
        }
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "es->s_feature_ro_compat"
          ],
          "line": 4426
        },
        "resolved": true,
        "details": {
          "function_name": "sle32_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "53-56",
          "snippet": "static inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "le16_to_cpu",
          "args": [
            "es->s_magic"
          ],
          "line": 4417
        },
        "resolved": true,
        "details": {
          "function_name": "sle16_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "48-51",
          "snippet": "static inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__bread",
          "args": [
            "bdev",
            "sb_block",
            "blocksize"
          ],
          "line": 4410
        },
        "resolved": true,
        "details": {
          "function_name": "__breadahead",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1381-1388",
          "snippet": "void __breadahead(struct block_device *bdev, sector_t block, unsigned size)\n{\n\tstruct buffer_head *bh = __getblk(bdev, block, size);\n\tif (likely(bh)) {\n\t\tll_rw_block(READA, 1, &bh);\n\t\tbrelse(bh);\n\t}\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid __breadahead(struct block_device *bdev, sector_t block, unsigned size)\n{\n\tstruct buffer_head *bh = __getblk(bdev, block, size);\n\tif (likely(bh)) {\n\t\tll_rw_block(READA, 1, &bh);\n\t\tbrelse(bh);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_blocksize",
          "args": [
            "bdev",
            "blocksize"
          ],
          "line": 4409
        },
        "resolved": true,
        "details": {
          "function_name": "sb_set_blocksize",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/block_dev.c",
          "lines": "116-125",
          "snippet": "int sb_set_blocksize(struct super_block *sb, int size)\n{\n\tif (set_blocksize(sb->s_bdev, size))\n\t\treturn 0;\n\t/* If we get here, we know size is power of two\n\t * and it's value is between 512 and PAGE_SIZE */\n\tsb->s_blocksize = size;\n\tsb->s_blocksize_bits = blksize_bits(size);\n\treturn sb->s_blocksize;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/aio.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/log2.h>",
            "#include <linux/namei.h>",
            "#include <linux/uio.h>",
            "#include <linux/mount.h>",
            "#include <linux/mpage.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/swap.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkpg.h>",
            "#include <linux/module.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/highmem.h>",
            "#include <linux/device_cgroup.h>",
            "#include <linux/major.h>",
            "#include <linux/kmod.h>",
            "#include <linux/slab.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <linux/aio.h>\n#include <linux/cleancache.h>\n#include <linux/log2.h>\n#include <linux/namei.h>\n#include <linux/uio.h>\n#include <linux/mount.h>\n#include <linux/mpage.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/swap.h>\n#include <linux/buffer_head.h>\n#include <linux/magic.h>\n#include <linux/blkpg.h>\n#include <linux/module.h>\n#include <linux/blkdev.h>\n#include <linux/highmem.h>\n#include <linux/device_cgroup.h>\n#include <linux/major.h>\n#include <linux/kmod.h>\n#include <linux/slab.h>\n#include <linux/fcntl.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n\nint sb_set_blocksize(struct super_block *sb, int size)\n{\n\tif (set_blocksize(sb->s_bdev, size))\n\t\treturn 0;\n\t/* If we get here, we know size is power of two\n\t * and it's value is between 512 and PAGE_SIZE */\n\tsb->s_blocksize = size;\n\tsb->s_blocksize_bits = blksize_bits(size);\n\treturn sb->s_blocksize;\n}"
        }
      },
      {
        "call_info": {
          "callee": "bdev_logical_block_size",
          "args": [
            "bdev"
          ],
          "line": 4400
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_blkdev_get",
          "args": [
            "j_dev",
            "sb"
          ],
          "line": 4395
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_blkdev_get",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/super.c",
          "lines": "707-721",
          "snippet": "static struct block_device *ext4_blkdev_get(dev_t dev, struct super_block *sb)\n{\n\tstruct block_device *bdev;\n\tchar b[BDEVNAME_SIZE];\n\n\tbdev = blkdev_get_by_dev(dev, FMODE_READ|FMODE_WRITE|FMODE_EXCL, sb);\n\tif (IS_ERR(bdev))\n\t\tgoto fail;\n\treturn bdev;\n\nfail:\n\text4_msg(sb, KERN_ERR, \"failed to open journal device %s: %ld\",\n\t\t\t__bdevname(dev, b), PTR_ERR(bdev));\n\treturn NULL;\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"mballoc.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include \"ext4_extents.h\"\t/* Needed for trace points definition */",
            "#include \"ext4.h\"",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/crc16.h>",
            "#include <linux/log2.h>",
            "#include <linux/ctype.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/random.h>",
            "#include <linux/vfs.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/parser.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/time.h>",
            "#include <linux/fs.h>",
            "#include <linux/string.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ext4_unfreeze(struct super_block *sb);",
            "static int ext4_freeze(struct super_block *sb);",
            "static inline int ext2_feature_set_ok(struct super_block *sb);",
            "static inline int ext3_feature_set_ok(struct super_block *sb);",
            "static void ext4_unregister_li_request(struct super_block *sb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"mballoc.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4_extents.h\"\t/* Needed for trace points definition */\n#include \"ext4.h\"\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <asm/uaccess.h>\n#include <linux/cleancache.h>\n#include <linux/crc16.h>\n#include <linux/log2.h>\n#include <linux/ctype.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/random.h>\n#include <linux/vfs.h>\n#include <linux/exportfs.h>\n#include <linux/buffer_head.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/jbd2.h>\n#include <linux/vmalloc.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n#include <linux/string.h>\n#include <linux/module.h>\n\nstatic int ext4_unfreeze(struct super_block *sb);\nstatic int ext4_freeze(struct super_block *sb);\nstatic inline int ext2_feature_set_ok(struct super_block *sb);\nstatic inline int ext3_feature_set_ok(struct super_block *sb);\nstatic void ext4_unregister_li_request(struct super_block *sb);\n\nstatic struct block_device *ext4_blkdev_get(dev_t dev, struct super_block *sb)\n{\n\tstruct block_device *bdev;\n\tchar b[BDEVNAME_SIZE];\n\n\tbdev = blkdev_get_by_dev(dev, FMODE_READ|FMODE_WRITE|FMODE_EXCL, sb);\n\tif (IS_ERR(bdev))\n\t\tgoto fail;\n\treturn bdev;\n\nfail:\n\text4_msg(sb, KERN_ERR, \"failed to open journal device %s: %ld\",\n\t\t\t__bdevname(dev, b), PTR_ERR(bdev));\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!EXT4_HAS_COMPAT_FEATURE(sb, EXT4_FEATURE_COMPAT_HAS_JOURNAL)"
          ],
          "line": 4393
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXT4_HAS_COMPAT_FEATURE",
          "args": [
            "sb",
            "EXT4_FEATURE_COMPAT_HAS_JOURNAL"
          ],
          "line": 4393
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"mballoc.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4_extents.h\"\t/* Needed for trace points definition */\n#include \"ext4.h\"\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <asm/uaccess.h>\n#include <linux/cleancache.h>\n#include <linux/crc16.h>\n#include <linux/log2.h>\n#include <linux/ctype.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/random.h>\n#include <linux/vfs.h>\n#include <linux/exportfs.h>\n#include <linux/buffer_head.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/jbd2.h>\n#include <linux/vmalloc.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n#include <linux/string.h>\n#include <linux/module.h>\n\nstatic void ext4_mark_recovery_complete(struct super_block *sb,\n\t\t\t\t\tstruct ext4_super_block *es);\nstatic void ext4_clear_journal_err(struct super_block *sb,\n\t\t\t\t   struct ext4_super_block *es);\nstatic int ext4_unfreeze(struct super_block *sb);\nstatic int ext4_freeze(struct super_block *sb);\nstatic inline int ext2_feature_set_ok(struct super_block *sb);\nstatic inline int ext3_feature_set_ok(struct super_block *sb);\nstatic void ext4_unregister_li_request(struct super_block *sb);\nstatic int ext4_reserve_clusters(struct ext4_sb_info *, ext4_fsblk_t);\n\nstatic journal_t *ext4_get_dev_journal(struct super_block *sb,\n\t\t\t\t       dev_t j_dev)\n{\n\tstruct buffer_head *bh;\n\tjournal_t *journal;\n\text4_fsblk_t start;\n\text4_fsblk_t len;\n\tint hblock, blocksize;\n\text4_fsblk_t sb_block;\n\tunsigned long offset;\n\tstruct ext4_super_block *es;\n\tstruct block_device *bdev;\n\n\tBUG_ON(!EXT4_HAS_COMPAT_FEATURE(sb, EXT4_FEATURE_COMPAT_HAS_JOURNAL));\n\n\tbdev = ext4_blkdev_get(j_dev, sb);\n\tif (bdev == NULL)\n\t\treturn NULL;\n\n\tblocksize = sb->s_blocksize;\n\thblock = bdev_logical_block_size(bdev);\n\tif (blocksize < hblock) {\n\t\text4_msg(sb, KERN_ERR,\n\t\t\t\"blocksize too small for journal device\");\n\t\tgoto out_bdev;\n\t}\n\n\tsb_block = EXT4_MIN_BLOCK_SIZE / blocksize;\n\toffset = EXT4_MIN_BLOCK_SIZE % blocksize;\n\tset_blocksize(bdev, blocksize);\n\tif (!(bh = __bread(bdev, sb_block, blocksize))) {\n\t\text4_msg(sb, KERN_ERR, \"couldn't read superblock of \"\n\t\t       \"external journal\");\n\t\tgoto out_bdev;\n\t}\n\n\tes = (struct ext4_super_block *) (bh->b_data + offset);\n\tif ((le16_to_cpu(es->s_magic) != EXT4_SUPER_MAGIC) ||\n\t    !(le32_to_cpu(es->s_feature_incompat) &\n\t      EXT4_FEATURE_INCOMPAT_JOURNAL_DEV)) {\n\t\text4_msg(sb, KERN_ERR, \"external journal has \"\n\t\t\t\t\t\"bad superblock\");\n\t\tbrelse(bh);\n\t\tgoto out_bdev;\n\t}\n\n\tif ((le32_to_cpu(es->s_feature_ro_compat) &\n\t     EXT4_FEATURE_RO_COMPAT_METADATA_CSUM) &&\n\t    es->s_checksum != ext4_superblock_csum(sb, es)) {\n\t\text4_msg(sb, KERN_ERR, \"external journal has \"\n\t\t\t\t       \"corrupt superblock\");\n\t\tbrelse(bh);\n\t\tgoto out_bdev;\n\t}\n\n\tif (memcmp(EXT4_SB(sb)->s_es->s_journal_uuid, es->s_uuid, 16)) {\n\t\text4_msg(sb, KERN_ERR, \"journal UUID does not match\");\n\t\tbrelse(bh);\n\t\tgoto out_bdev;\n\t}\n\n\tlen = ext4_blocks_count(es);\n\tstart = sb_block + 1;\n\tbrelse(bh);\t/* we're done with the superblock */\n\n\tjournal = jbd2_journal_init_dev(bdev, sb->s_bdev,\n\t\t\t\t\tstart, len, blocksize);\n\tif (!journal) {\n\t\text4_msg(sb, KERN_ERR, \"failed to create device journal\");\n\t\tgoto out_bdev;\n\t}\n\tjournal->j_private = sb;\n\tll_rw_block(READ | REQ_META | REQ_PRIO, 1, &journal->j_sb_buffer);\n\twait_on_buffer(journal->j_sb_buffer);\n\tif (!buffer_uptodate(journal->j_sb_buffer)) {\n\t\text4_msg(sb, KERN_ERR, \"I/O error on journal device\");\n\t\tgoto out_journal;\n\t}\n\tif (be32_to_cpu(journal->j_superblock->s_nr_users) != 1) {\n\t\text4_msg(sb, KERN_ERR, \"External journal has more than one \"\n\t\t\t\t\t\"user (unsupported) - %d\",\n\t\t\tbe32_to_cpu(journal->j_superblock->s_nr_users));\n\t\tgoto out_journal;\n\t}\n\tEXT4_SB(sb)->journal_bdev = bdev;\n\text4_init_journal_params(sb, journal);\n\treturn journal;\n\nout_journal:\n\tjbd2_journal_destroy(journal);\nout_bdev:\n\text4_blkdev_put(bdev);\n\treturn NULL;\n}"
  },
  {
    "function_name": "ext4_get_journal",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/super.c",
    "lines": "4337-4378",
    "snippet": "static journal_t *ext4_get_journal(struct super_block *sb,\n\t\t\t\t   unsigned int journal_inum)\n{\n\tstruct inode *journal_inode;\n\tjournal_t *journal;\n\n\tBUG_ON(!EXT4_HAS_COMPAT_FEATURE(sb, EXT4_FEATURE_COMPAT_HAS_JOURNAL));\n\n\t/* First, test for the existence of a valid inode on disk.  Bad\n\t * things happen if we iget() an unused inode, as the subsequent\n\t * iput() will try to delete it. */\n\n\tjournal_inode = ext4_iget(sb, journal_inum);\n\tif (IS_ERR(journal_inode)) {\n\t\text4_msg(sb, KERN_ERR, \"no journal found\");\n\t\treturn NULL;\n\t}\n\tif (!journal_inode->i_nlink) {\n\t\tmake_bad_inode(journal_inode);\n\t\tiput(journal_inode);\n\t\text4_msg(sb, KERN_ERR, \"journal inode is deleted\");\n\t\treturn NULL;\n\t}\n\n\tjbd_debug(2, \"Journal inode found at %p: %lld bytes\\n\",\n\t\t  journal_inode, journal_inode->i_size);\n\tif (!S_ISREG(journal_inode->i_mode)) {\n\t\text4_msg(sb, KERN_ERR, \"invalid journal inode\");\n\t\tiput(journal_inode);\n\t\treturn NULL;\n\t}\n\n\tjournal = jbd2_journal_init_inode(journal_inode);\n\tif (!journal) {\n\t\text4_msg(sb, KERN_ERR, \"Could not load journal inode\");\n\t\tiput(journal_inode);\n\t\treturn NULL;\n\t}\n\tjournal->j_private = sb;\n\text4_init_journal_params(sb, journal);\n\treturn journal;\n}",
    "includes": [
      "#include <trace/events/ext4.h>",
      "#include \"mballoc.h\"",
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"ext4_jbd2.h\"",
      "#include \"ext4_extents.h\"\t/* Needed for trace points definition */",
      "#include \"ext4.h\"",
      "#include <linux/freezer.h>",
      "#include <linux/kthread.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/cleancache.h>",
      "#include <linux/crc16.h>",
      "#include <linux/log2.h>",
      "#include <linux/ctype.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/namei.h>",
      "#include <linux/mount.h>",
      "#include <linux/random.h>",
      "#include <linux/vfs.h>",
      "#include <linux/exportfs.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/parser.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/init.h>",
      "#include <linux/slab.h>",
      "#include <linux/jbd2.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/time.h>",
      "#include <linux/fs.h>",
      "#include <linux/string.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ext4_unfreeze(struct super_block *sb);",
      "static int ext4_freeze(struct super_block *sb);",
      "static inline int ext2_feature_set_ok(struct super_block *sb);",
      "static inline int ext3_feature_set_ok(struct super_block *sb);",
      "static void ext4_unregister_li_request(struct super_block *sb);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ext4_init_journal_params",
          "args": [
            "sb",
            "journal"
          ],
          "line": 4376
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_init_journal_params",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/super.c",
          "lines": "4317-4335",
          "snippet": "static void ext4_init_journal_params(struct super_block *sb, journal_t *journal)\n{\n\tstruct ext4_sb_info *sbi = EXT4_SB(sb);\n\n\tjournal->j_commit_interval = sbi->s_commit_interval;\n\tjournal->j_min_batch_time = sbi->s_min_batch_time;\n\tjournal->j_max_batch_time = sbi->s_max_batch_time;\n\n\twrite_lock(&journal->j_state_lock);\n\tif (test_opt(sb, BARRIER))\n\t\tjournal->j_flags |= JBD2_BARRIER;\n\telse\n\t\tjournal->j_flags &= ~JBD2_BARRIER;\n\tif (test_opt(sb, DATA_ERR_ABORT))\n\t\tjournal->j_flags |= JBD2_ABORT_ON_SYNCDATA_ERR;\n\telse\n\t\tjournal->j_flags &= ~JBD2_ABORT_ON_SYNCDATA_ERR;\n\twrite_unlock(&journal->j_state_lock);\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"mballoc.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include \"ext4_extents.h\"\t/* Needed for trace points definition */",
            "#include \"ext4.h\"",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/crc16.h>",
            "#include <linux/log2.h>",
            "#include <linux/ctype.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/random.h>",
            "#include <linux/vfs.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/parser.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/time.h>",
            "#include <linux/fs.h>",
            "#include <linux/string.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ext4_unfreeze(struct super_block *sb);",
            "static int ext4_freeze(struct super_block *sb);",
            "static inline int ext2_feature_set_ok(struct super_block *sb);",
            "static inline int ext3_feature_set_ok(struct super_block *sb);",
            "static void ext4_unregister_li_request(struct super_block *sb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"mballoc.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4_extents.h\"\t/* Needed for trace points definition */\n#include \"ext4.h\"\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <asm/uaccess.h>\n#include <linux/cleancache.h>\n#include <linux/crc16.h>\n#include <linux/log2.h>\n#include <linux/ctype.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/random.h>\n#include <linux/vfs.h>\n#include <linux/exportfs.h>\n#include <linux/buffer_head.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/jbd2.h>\n#include <linux/vmalloc.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n#include <linux/string.h>\n#include <linux/module.h>\n\nstatic int ext4_unfreeze(struct super_block *sb);\nstatic int ext4_freeze(struct super_block *sb);\nstatic inline int ext2_feature_set_ok(struct super_block *sb);\nstatic inline int ext3_feature_set_ok(struct super_block *sb);\nstatic void ext4_unregister_li_request(struct super_block *sb);\n\nstatic void ext4_init_journal_params(struct super_block *sb, journal_t *journal)\n{\n\tstruct ext4_sb_info *sbi = EXT4_SB(sb);\n\n\tjournal->j_commit_interval = sbi->s_commit_interval;\n\tjournal->j_min_batch_time = sbi->s_min_batch_time;\n\tjournal->j_max_batch_time = sbi->s_max_batch_time;\n\n\twrite_lock(&journal->j_state_lock);\n\tif (test_opt(sb, BARRIER))\n\t\tjournal->j_flags |= JBD2_BARRIER;\n\telse\n\t\tjournal->j_flags &= ~JBD2_BARRIER;\n\tif (test_opt(sb, DATA_ERR_ABORT))\n\t\tjournal->j_flags |= JBD2_ABORT_ON_SYNCDATA_ERR;\n\telse\n\t\tjournal->j_flags &= ~JBD2_ABORT_ON_SYNCDATA_ERR;\n\twrite_unlock(&journal->j_state_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "iput",
          "args": [
            "journal_inode"
          ],
          "line": 4372
        },
        "resolved": true,
        "details": {
          "function_name": "dentry_iput",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "308-327",
          "snippet": "static void dentry_iput(struct dentry * dentry)\n\t__releases(dentry->d_lock)\n\t__releases(dentry->d_inode->i_lock)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tif (inode) {\n\t\tdentry->d_inode = NULL;\n\t\thlist_del_init(&dentry->d_u.d_alias);\n\t\tspin_unlock(&dentry->d_lock);\n\t\tspin_unlock(&inode->i_lock);\n\t\tif (!inode->i_nlink)\n\t\t\tfsnotify_inoderemove(inode);\n\t\tif (dentry->d_op && dentry->d_op->d_iput)\n\t\t\tdentry->d_op->d_iput(dentry, inode);\n\t\telse\n\t\t\tiput(inode);\n\t} else {\n\t\tspin_unlock(&dentry->d_lock);\n\t}\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nstatic void dentry_iput(struct dentry * dentry)\n\t__releases(dentry->d_lock)\n\t__releases(dentry->d_inode->i_lock)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tif (inode) {\n\t\tdentry->d_inode = NULL;\n\t\thlist_del_init(&dentry->d_u.d_alias);\n\t\tspin_unlock(&dentry->d_lock);\n\t\tspin_unlock(&inode->i_lock);\n\t\tif (!inode->i_nlink)\n\t\t\tfsnotify_inoderemove(inode);\n\t\tif (dentry->d_op && dentry->d_op->d_iput)\n\t\t\tdentry->d_op->d_iput(dentry, inode);\n\t\telse\n\t\t\tiput(inode);\n\t} else {\n\t\tspin_unlock(&dentry->d_lock);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_msg",
          "args": [
            "sb",
            "KERN_ERR",
            "\"Could not load journal inode\""
          ],
          "line": 4371
        },
        "resolved": true,
        "details": {
          "function_name": "__ext4_msg",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/super.c",
          "lines": "593-607",
          "snippet": "void __ext4_msg(struct super_block *sb,\n\t\tconst char *prefix, const char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tif (!___ratelimit(&(EXT4_SB(sb)->s_msg_ratelimit_state), \"EXT4-fs\"))\n\t\treturn;\n\n\tva_start(args, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\tprintk(\"%sEXT4-fs (%s): %pV\\n\", prefix, sb->s_id, &vaf);\n\tva_end(args);\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"mballoc.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include \"ext4_extents.h\"\t/* Needed for trace points definition */",
            "#include \"ext4.h\"",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/crc16.h>",
            "#include <linux/log2.h>",
            "#include <linux/ctype.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/random.h>",
            "#include <linux/vfs.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/parser.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/time.h>",
            "#include <linux/fs.h>",
            "#include <linux/string.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ext4_unfreeze(struct super_block *sb);",
            "static int ext4_freeze(struct super_block *sb);",
            "static inline int ext2_feature_set_ok(struct super_block *sb);",
            "static inline int ext3_feature_set_ok(struct super_block *sb);",
            "static void ext4_unregister_li_request(struct super_block *sb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"mballoc.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4_extents.h\"\t/* Needed for trace points definition */\n#include \"ext4.h\"\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <asm/uaccess.h>\n#include <linux/cleancache.h>\n#include <linux/crc16.h>\n#include <linux/log2.h>\n#include <linux/ctype.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/random.h>\n#include <linux/vfs.h>\n#include <linux/exportfs.h>\n#include <linux/buffer_head.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/jbd2.h>\n#include <linux/vmalloc.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n#include <linux/string.h>\n#include <linux/module.h>\n\nstatic int ext4_unfreeze(struct super_block *sb);\nstatic int ext4_freeze(struct super_block *sb);\nstatic inline int ext2_feature_set_ok(struct super_block *sb);\nstatic inline int ext3_feature_set_ok(struct super_block *sb);\nstatic void ext4_unregister_li_request(struct super_block *sb);\n\nvoid __ext4_msg(struct super_block *sb,\n\t\tconst char *prefix, const char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tif (!___ratelimit(&(EXT4_SB(sb)->s_msg_ratelimit_state), \"EXT4-fs\"))\n\t\treturn;\n\n\tva_start(args, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\tprintk(\"%sEXT4-fs (%s): %pV\\n\", prefix, sb->s_id, &vaf);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "jbd2_journal_init_inode",
          "args": [
            "journal_inode"
          ],
          "line": 4369
        },
        "resolved": true,
        "details": {
          "function_name": "jbd2_journal_init_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd2/journal.c",
          "lines": "1192-1256",
          "snippet": "journal_t * jbd2_journal_init_inode (struct inode *inode)\n{\n\tstruct buffer_head *bh;\n\tjournal_t *journal = journal_init_common();\n\tchar *p;\n\tint err;\n\tint n;\n\tunsigned long long blocknr;\n\n\tif (!journal)\n\t\treturn NULL;\n\n\tjournal->j_dev = journal->j_fs_dev = inode->i_sb->s_bdev;\n\tjournal->j_inode = inode;\n\tbdevname(journal->j_dev, journal->j_devname);\n\tp = journal->j_devname;\n\twhile ((p = strchr(p, '/')))\n\t\t*p = '!';\n\tp = journal->j_devname + strlen(journal->j_devname);\n\tsprintf(p, \"-%lu\", journal->j_inode->i_ino);\n\tjbd_debug(1,\n\t\t  \"journal %p: inode %s/%ld, size %Ld, bits %d, blksize %ld\\n\",\n\t\t  journal, inode->i_sb->s_id, inode->i_ino,\n\t\t  (long long) inode->i_size,\n\t\t  inode->i_sb->s_blocksize_bits, inode->i_sb->s_blocksize);\n\n\tjournal->j_maxlen = inode->i_size >> inode->i_sb->s_blocksize_bits;\n\tjournal->j_blocksize = inode->i_sb->s_blocksize;\n\tjbd2_stats_proc_init(journal);\n\n\t/* journal descriptor can store up to n blocks -bzzz */\n\tn = journal->j_blocksize / sizeof(journal_block_tag_t);\n\tjournal->j_wbufsize = n;\n\tjournal->j_wbuf = kmalloc(n * sizeof(struct buffer_head*), GFP_KERNEL);\n\tif (!journal->j_wbuf) {\n\t\tprintk(KERN_ERR \"%s: Can't allocate bhs for commit thread\\n\",\n\t\t\t__func__);\n\t\tgoto out_err;\n\t}\n\n\terr = jbd2_journal_bmap(journal, 0, &blocknr);\n\t/* If that failed, give up */\n\tif (err) {\n\t\tprintk(KERN_ERR \"%s: Cannot locate journal superblock\\n\",\n\t\t       __func__);\n\t\tgoto out_err;\n\t}\n\n\tbh = getblk_unmovable(journal->j_dev, blocknr, journal->j_blocksize);\n\tif (!bh) {\n\t\tprintk(KERN_ERR\n\t\t       \"%s: Cannot get buffer for journal superblock\\n\",\n\t\t       __func__);\n\t\tgoto out_err;\n\t}\n\tjournal->j_sb_buffer = bh;\n\tjournal->j_superblock = (journal_superblock_t *)bh->b_data;\n\n\treturn journal;\nout_err:\n\tkfree(journal->j_wbuf);\n\tjbd2_stats_proc_exit(journal);\n\tkfree(journal);\n\treturn NULL;\n}",
          "includes": [
            "#include <asm/page.h>",
            "#include <asm/uaccess.h>",
            "#include <trace/events/jbd2.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/bitops.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/log2.h>",
            "#include <linux/hash.h>",
            "#include <linux/math64.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/poison.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <trace/events/jbd2.h>\n#include <linux/ratelimit.h>\n#include <linux/bitops.h>\n#include <linux/backing-dev.h>\n#include <linux/vmalloc.h>\n#include <linux/log2.h>\n#include <linux/hash.h>\n#include <linux/math64.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/poison.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/freezer.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd2.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/module.h>\n\njournal_t * jbd2_journal_init_inode (struct inode *inode)\n{\n\tstruct buffer_head *bh;\n\tjournal_t *journal = journal_init_common();\n\tchar *p;\n\tint err;\n\tint n;\n\tunsigned long long blocknr;\n\n\tif (!journal)\n\t\treturn NULL;\n\n\tjournal->j_dev = journal->j_fs_dev = inode->i_sb->s_bdev;\n\tjournal->j_inode = inode;\n\tbdevname(journal->j_dev, journal->j_devname);\n\tp = journal->j_devname;\n\twhile ((p = strchr(p, '/')))\n\t\t*p = '!';\n\tp = journal->j_devname + strlen(journal->j_devname);\n\tsprintf(p, \"-%lu\", journal->j_inode->i_ino);\n\tjbd_debug(1,\n\t\t  \"journal %p: inode %s/%ld, size %Ld, bits %d, blksize %ld\\n\",\n\t\t  journal, inode->i_sb->s_id, inode->i_ino,\n\t\t  (long long) inode->i_size,\n\t\t  inode->i_sb->s_blocksize_bits, inode->i_sb->s_blocksize);\n\n\tjournal->j_maxlen = inode->i_size >> inode->i_sb->s_blocksize_bits;\n\tjournal->j_blocksize = inode->i_sb->s_blocksize;\n\tjbd2_stats_proc_init(journal);\n\n\t/* journal descriptor can store up to n blocks -bzzz */\n\tn = journal->j_blocksize / sizeof(journal_block_tag_t);\n\tjournal->j_wbufsize = n;\n\tjournal->j_wbuf = kmalloc(n * sizeof(struct buffer_head*), GFP_KERNEL);\n\tif (!journal->j_wbuf) {\n\t\tprintk(KERN_ERR \"%s: Can't allocate bhs for commit thread\\n\",\n\t\t\t__func__);\n\t\tgoto out_err;\n\t}\n\n\terr = jbd2_journal_bmap(journal, 0, &blocknr);\n\t/* If that failed, give up */\n\tif (err) {\n\t\tprintk(KERN_ERR \"%s: Cannot locate journal superblock\\n\",\n\t\t       __func__);\n\t\tgoto out_err;\n\t}\n\n\tbh = getblk_unmovable(journal->j_dev, blocknr, journal->j_blocksize);\n\tif (!bh) {\n\t\tprintk(KERN_ERR\n\t\t       \"%s: Cannot get buffer for journal superblock\\n\",\n\t\t       __func__);\n\t\tgoto out_err;\n\t}\n\tjournal->j_sb_buffer = bh;\n\tjournal->j_superblock = (journal_superblock_t *)bh->b_data;\n\n\treturn journal;\nout_err:\n\tkfree(journal->j_wbuf);\n\tjbd2_stats_proc_exit(journal);\n\tkfree(journal);\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "S_ISREG",
          "args": [
            "journal_inode->i_mode"
          ],
          "line": 4363
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "jbd_debug",
          "args": [
            "2",
            "\"Journal inode found at %p: %lld bytes\\n\"",
            "journal_inode",
            "journal_inode->i_size"
          ],
          "line": 4361
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "make_bad_inode",
          "args": [
            "journal_inode"
          ],
          "line": 4355
        },
        "resolved": true,
        "details": {
          "function_name": "make_bad_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/bad_inode.c",
          "lines": "170-179",
          "snippet": "void make_bad_inode(struct inode *inode)\n{\n\tremove_inode_hash(inode);\n\n\tinode->i_mode = S_IFREG;\n\tinode->i_atime = inode->i_mtime = inode->i_ctime =\n\t\tcurrent_fs_time(inode->i_sb);\n\tinode->i_op = &bad_inode_ops;\t\n\tinode->i_fop = &bad_file_ops;\t\n}",
          "includes": [
            "#include <linux/poll.h>",
            "#include <linux/namei.h>",
            "#include <linux/time.h>",
            "#include <linux/stat.h>",
            "#include <linux/export.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct file_operations bad_file_ops =\n{\n\t.open\t\t= bad_file_open,\n};",
            "static const struct inode_operations bad_inode_ops =\n{\n\t.create\t\t= bad_inode_create,\n\t.lookup\t\t= bad_inode_lookup,\n\t.link\t\t= bad_inode_link,\n\t.unlink\t\t= bad_inode_unlink,\n\t.symlink\t= bad_inode_symlink,\n\t.mkdir\t\t= bad_inode_mkdir,\n\t.rmdir\t\t= bad_inode_rmdir,\n\t.mknod\t\t= bad_inode_mknod,\n\t.rename2\t= bad_inode_rename2,\n\t.readlink\t= bad_inode_readlink,\n\t/* follow_link must be no-op, otherwise unmounting this inode\n\t   won't work */\n\t/* put_link returns void */\n\t/* truncate returns void */\n\t.permission\t= bad_inode_permission,\n\t.getattr\t= bad_inode_getattr,\n\t.setattr\t= bad_inode_setattr,\n\t.setxattr\t= bad_inode_setxattr,\n\t.getxattr\t= bad_inode_getxattr,\n\t.listxattr\t= bad_inode_listxattr,\n\t.removexattr\t= bad_inode_removexattr,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/poll.h>\n#include <linux/namei.h>\n#include <linux/time.h>\n#include <linux/stat.h>\n#include <linux/export.h>\n#include <linux/fs.h>\n\nstatic const struct file_operations bad_file_ops =\n{\n\t.open\t\t= bad_file_open,\n};\nstatic const struct inode_operations bad_inode_ops =\n{\n\t.create\t\t= bad_inode_create,\n\t.lookup\t\t= bad_inode_lookup,\n\t.link\t\t= bad_inode_link,\n\t.unlink\t\t= bad_inode_unlink,\n\t.symlink\t= bad_inode_symlink,\n\t.mkdir\t\t= bad_inode_mkdir,\n\t.rmdir\t\t= bad_inode_rmdir,\n\t.mknod\t\t= bad_inode_mknod,\n\t.rename2\t= bad_inode_rename2,\n\t.readlink\t= bad_inode_readlink,\n\t/* follow_link must be no-op, otherwise unmounting this inode\n\t   won't work */\n\t/* put_link returns void */\n\t/* truncate returns void */\n\t.permission\t= bad_inode_permission,\n\t.getattr\t= bad_inode_getattr,\n\t.setattr\t= bad_inode_setattr,\n\t.setxattr\t= bad_inode_setxattr,\n\t.getxattr\t= bad_inode_getxattr,\n\t.listxattr\t= bad_inode_listxattr,\n\t.removexattr\t= bad_inode_removexattr,\n};\n\nvoid make_bad_inode(struct inode *inode)\n{\n\tremove_inode_hash(inode);\n\n\tinode->i_mode = S_IFREG;\n\tinode->i_atime = inode->i_mtime = inode->i_ctime =\n\t\tcurrent_fs_time(inode->i_sb);\n\tinode->i_op = &bad_inode_ops;\t\n\tinode->i_fop = &bad_file_ops;\t\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "journal_inode"
          ],
          "line": 4350
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_iget",
          "args": [
            "sb",
            "journal_inum"
          ],
          "line": 4349
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_iget_normal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/inode.c",
          "lines": "4138-4143",
          "snippet": "struct inode *ext4_iget_normal(struct super_block *sb, unsigned long ino)\n{\n\tif (ino < EXT4_FIRST_INO(sb) && ino != EXT4_ROOT_INO)\n\t\treturn ERR_PTR(-EIO);\n\treturn ext4_iget(sb, ino);\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"truncate.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include <linux/bitops.h>",
            "#include <linux/aio.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/printk.h>",
            "#include <linux/kernel.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/bio.h>",
            "#include <linux/uio.h>",
            "#include <linux/namei.h>",
            "#include <linux/mpage.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highuid.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/time.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"truncate.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include <linux/bitops.h>\n#include <linux/aio.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/printk.h>\n#include <linux/kernel.h>\n#include <linux/workqueue.h>\n#include <linux/bio.h>\n#include <linux/uio.h>\n#include <linux/namei.h>\n#include <linux/mpage.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/highuid.h>\n#include <linux/jbd2.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n\nstruct inode *ext4_iget_normal(struct super_block *sb, unsigned long ino)\n{\n\tif (ino < EXT4_FIRST_INO(sb) && ino != EXT4_ROOT_INO)\n\t\treturn ERR_PTR(-EIO);\n\treturn ext4_iget(sb, ino);\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!EXT4_HAS_COMPAT_FEATURE(sb, EXT4_FEATURE_COMPAT_HAS_JOURNAL)"
          ],
          "line": 4343
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXT4_HAS_COMPAT_FEATURE",
          "args": [
            "sb",
            "EXT4_FEATURE_COMPAT_HAS_JOURNAL"
          ],
          "line": 4343
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"mballoc.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4_extents.h\"\t/* Needed for trace points definition */\n#include \"ext4.h\"\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <asm/uaccess.h>\n#include <linux/cleancache.h>\n#include <linux/crc16.h>\n#include <linux/log2.h>\n#include <linux/ctype.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/random.h>\n#include <linux/vfs.h>\n#include <linux/exportfs.h>\n#include <linux/buffer_head.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/jbd2.h>\n#include <linux/vmalloc.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n#include <linux/string.h>\n#include <linux/module.h>\n\nstatic int ext4_unfreeze(struct super_block *sb);\nstatic int ext4_freeze(struct super_block *sb);\nstatic inline int ext2_feature_set_ok(struct super_block *sb);\nstatic inline int ext3_feature_set_ok(struct super_block *sb);\nstatic void ext4_unregister_li_request(struct super_block *sb);\n\nstatic journal_t *ext4_get_journal(struct super_block *sb,\n\t\t\t\t   unsigned int journal_inum)\n{\n\tstruct inode *journal_inode;\n\tjournal_t *journal;\n\n\tBUG_ON(!EXT4_HAS_COMPAT_FEATURE(sb, EXT4_FEATURE_COMPAT_HAS_JOURNAL));\n\n\t/* First, test for the existence of a valid inode on disk.  Bad\n\t * things happen if we iget() an unused inode, as the subsequent\n\t * iput() will try to delete it. */\n\n\tjournal_inode = ext4_iget(sb, journal_inum);\n\tif (IS_ERR(journal_inode)) {\n\t\text4_msg(sb, KERN_ERR, \"no journal found\");\n\t\treturn NULL;\n\t}\n\tif (!journal_inode->i_nlink) {\n\t\tmake_bad_inode(journal_inode);\n\t\tiput(journal_inode);\n\t\text4_msg(sb, KERN_ERR, \"journal inode is deleted\");\n\t\treturn NULL;\n\t}\n\n\tjbd_debug(2, \"Journal inode found at %p: %lld bytes\\n\",\n\t\t  journal_inode, journal_inode->i_size);\n\tif (!S_ISREG(journal_inode->i_mode)) {\n\t\text4_msg(sb, KERN_ERR, \"invalid journal inode\");\n\t\tiput(journal_inode);\n\t\treturn NULL;\n\t}\n\n\tjournal = jbd2_journal_init_inode(journal_inode);\n\tif (!journal) {\n\t\text4_msg(sb, KERN_ERR, \"Could not load journal inode\");\n\t\tiput(journal_inode);\n\t\treturn NULL;\n\t}\n\tjournal->j_private = sb;\n\text4_init_journal_params(sb, journal);\n\treturn journal;\n}"
  },
  {
    "function_name": "ext4_init_journal_params",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/super.c",
    "lines": "4317-4335",
    "snippet": "static void ext4_init_journal_params(struct super_block *sb, journal_t *journal)\n{\n\tstruct ext4_sb_info *sbi = EXT4_SB(sb);\n\n\tjournal->j_commit_interval = sbi->s_commit_interval;\n\tjournal->j_min_batch_time = sbi->s_min_batch_time;\n\tjournal->j_max_batch_time = sbi->s_max_batch_time;\n\n\twrite_lock(&journal->j_state_lock);\n\tif (test_opt(sb, BARRIER))\n\t\tjournal->j_flags |= JBD2_BARRIER;\n\telse\n\t\tjournal->j_flags &= ~JBD2_BARRIER;\n\tif (test_opt(sb, DATA_ERR_ABORT))\n\t\tjournal->j_flags |= JBD2_ABORT_ON_SYNCDATA_ERR;\n\telse\n\t\tjournal->j_flags &= ~JBD2_ABORT_ON_SYNCDATA_ERR;\n\twrite_unlock(&journal->j_state_lock);\n}",
    "includes": [
      "#include <trace/events/ext4.h>",
      "#include \"mballoc.h\"",
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"ext4_jbd2.h\"",
      "#include \"ext4_extents.h\"\t/* Needed for trace points definition */",
      "#include \"ext4.h\"",
      "#include <linux/freezer.h>",
      "#include <linux/kthread.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/cleancache.h>",
      "#include <linux/crc16.h>",
      "#include <linux/log2.h>",
      "#include <linux/ctype.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/namei.h>",
      "#include <linux/mount.h>",
      "#include <linux/random.h>",
      "#include <linux/vfs.h>",
      "#include <linux/exportfs.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/parser.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/init.h>",
      "#include <linux/slab.h>",
      "#include <linux/jbd2.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/time.h>",
      "#include <linux/fs.h>",
      "#include <linux/string.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ext4_unfreeze(struct super_block *sb);",
      "static int ext4_freeze(struct super_block *sb);",
      "static inline int ext2_feature_set_ok(struct super_block *sb);",
      "static inline int ext3_feature_set_ok(struct super_block *sb);",
      "static void ext4_unregister_li_request(struct super_block *sb);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "write_unlock",
          "args": [
            "&journal->j_state_lock"
          ],
          "line": 4334
        },
        "resolved": true,
        "details": {
          "function_name": "reiserfs_write_unlock_nested",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/lock.c",
          "lines": "51-67",
          "snippet": "int __must_check reiserfs_write_unlock_nested(struct super_block *s)\n{\n\tstruct reiserfs_sb_info *sb_i = REISERFS_SB(s);\n\tint depth;\n\n\t/* this can happen when the lock isn't always held */\n\tif (sb_i->lock_owner != current)\n\t\treturn -1;\n\n\tdepth = sb_i->lock_depth;\n\n\tsb_i->lock_depth = -1;\n\tsb_i->lock_owner = NULL;\n\tmutex_unlock(&sb_i->lock);\n\n\treturn depth;\n}",
          "includes": [
            "#include <linux/mutex.h>",
            "#include \"reiserfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/mutex.h>\n#include \"reiserfs.h\"\n\nint __must_check reiserfs_write_unlock_nested(struct super_block *s)\n{\n\tstruct reiserfs_sb_info *sb_i = REISERFS_SB(s);\n\tint depth;\n\n\t/* this can happen when the lock isn't always held */\n\tif (sb_i->lock_owner != current)\n\t\treturn -1;\n\n\tdepth = sb_i->lock_depth;\n\n\tsb_i->lock_depth = -1;\n\tsb_i->lock_owner = NULL;\n\tmutex_unlock(&sb_i->lock);\n\n\treturn depth;\n}"
        }
      },
      {
        "call_info": {
          "callee": "test_opt",
          "args": [
            "sb",
            "DATA_ERR_ABORT"
          ],
          "line": 4330
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_opt",
          "args": [
            "sb",
            "BARRIER"
          ],
          "line": 4326
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "write_lock",
          "args": [
            "&journal->j_state_lock"
          ],
          "line": 4325
        },
        "resolved": true,
        "details": {
          "function_name": "reiserfs_write_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/lock.c",
          "lines": "21-32",
          "snippet": "void reiserfs_write_lock(struct super_block *s)\n{\n\tstruct reiserfs_sb_info *sb_i = REISERFS_SB(s);\n\n\tif (sb_i->lock_owner != current) {\n\t\tmutex_lock(&sb_i->lock);\n\t\tsb_i->lock_owner = current;\n\t}\n\n\t/* No need to protect it, only the current task touches it */\n\tsb_i->lock_depth++;\n}",
          "includes": [
            "#include <linux/mutex.h>",
            "#include \"reiserfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/mutex.h>\n#include \"reiserfs.h\"\n\nvoid reiserfs_write_lock(struct super_block *s)\n{\n\tstruct reiserfs_sb_info *sb_i = REISERFS_SB(s);\n\n\tif (sb_i->lock_owner != current) {\n\t\tmutex_lock(&sb_i->lock);\n\t\tsb_i->lock_owner = current;\n\t}\n\n\t/* No need to protect it, only the current task touches it */\n\tsb_i->lock_depth++;\n}"
        }
      },
      {
        "call_info": {
          "callee": "EXT4_SB",
          "args": [
            "sb"
          ],
          "line": 4319
        },
        "resolved": true,
        "details": {
          "function_name": "EXT4_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ext4.h",
          "lines": "1356-1359",
          "snippet": "static inline struct ext4_sb_info *EXT4_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include \"extents_status.h\"",
            "#include <linux/compat.h>",
            "#include <linux/falloc.h>",
            "#include <crypto/hash.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/wait.h>",
            "#include <linux/timer.h>",
            "#include <linux/mutex.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/quota.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extents_status.h\"\n#include <linux/compat.h>\n#include <linux/falloc.h>\n#include <crypto/hash.h>\n#include <linux/ratelimit.h>\n#include <linux/percpu_counter.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/wait.h>\n#include <linux/timer.h>\n#include <linux/mutex.h>\n#include <linux/seqlock.h>\n#include <linux/rbtree.h>\n#include <linux/rwsem.h>\n#include <linux/quota.h>\n#include <linux/jbd2.h>\n#include <linux/magic.h>\n#include <linux/blkdev.h>\n#include <linux/types.h>\n\nstatic inline struct ext4_sb_info *EXT4_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"mballoc.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4_extents.h\"\t/* Needed for trace points definition */\n#include \"ext4.h\"\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <asm/uaccess.h>\n#include <linux/cleancache.h>\n#include <linux/crc16.h>\n#include <linux/log2.h>\n#include <linux/ctype.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/random.h>\n#include <linux/vfs.h>\n#include <linux/exportfs.h>\n#include <linux/buffer_head.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/jbd2.h>\n#include <linux/vmalloc.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n#include <linux/string.h>\n#include <linux/module.h>\n\nstatic int ext4_unfreeze(struct super_block *sb);\nstatic int ext4_freeze(struct super_block *sb);\nstatic inline int ext2_feature_set_ok(struct super_block *sb);\nstatic inline int ext3_feature_set_ok(struct super_block *sb);\nstatic void ext4_unregister_li_request(struct super_block *sb);\n\nstatic void ext4_init_journal_params(struct super_block *sb, journal_t *journal)\n{\n\tstruct ext4_sb_info *sbi = EXT4_SB(sb);\n\n\tjournal->j_commit_interval = sbi->s_commit_interval;\n\tjournal->j_min_batch_time = sbi->s_min_batch_time;\n\tjournal->j_max_batch_time = sbi->s_max_batch_time;\n\n\twrite_lock(&journal->j_state_lock);\n\tif (test_opt(sb, BARRIER))\n\t\tjournal->j_flags |= JBD2_BARRIER;\n\telse\n\t\tjournal->j_flags &= ~JBD2_BARRIER;\n\tif (test_opt(sb, DATA_ERR_ABORT))\n\t\tjournal->j_flags |= JBD2_ABORT_ON_SYNCDATA_ERR;\n\telse\n\t\tjournal->j_flags &= ~JBD2_ABORT_ON_SYNCDATA_ERR;\n\twrite_unlock(&journal->j_state_lock);\n}"
  },
  {
    "function_name": "ext4_fill_super",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/super.c",
    "lines": "3409-4310",
    "snippet": "static int ext4_fill_super(struct super_block *sb, void *data, int silent)\n{\n\tchar *orig_data = kstrdup(data, GFP_KERNEL);\n\tstruct buffer_head *bh;\n\tstruct ext4_super_block *es = NULL;\n\tstruct ext4_sb_info *sbi;\n\text4_fsblk_t block;\n\text4_fsblk_t sb_block = get_sb_block(&data);\n\text4_fsblk_t logical_sb_block;\n\tunsigned long offset = 0;\n\tunsigned long journal_devnum = 0;\n\tunsigned long def_mount_opts;\n\tstruct inode *root;\n\tchar *cp;\n\tconst char *descr;\n\tint ret = -ENOMEM;\n\tint blocksize, clustersize;\n\tunsigned int db_count;\n\tunsigned int i;\n\tint needs_recovery, has_huge_files, has_bigalloc;\n\t__u64 blocks_count;\n\tint err = 0;\n\tunsigned int journal_ioprio = DEFAULT_JOURNAL_IOPRIO;\n\text4_group_t first_not_zeroed;\n\n\tsbi = kzalloc(sizeof(*sbi), GFP_KERNEL);\n\tif (!sbi)\n\t\tgoto out_free_orig;\n\n\tsbi->s_blockgroup_lock =\n\t\tkzalloc(sizeof(struct blockgroup_lock), GFP_KERNEL);\n\tif (!sbi->s_blockgroup_lock) {\n\t\tkfree(sbi);\n\t\tgoto out_free_orig;\n\t}\n\tsb->s_fs_info = sbi;\n\tsbi->s_sb = sb;\n\tsbi->s_inode_readahead_blks = EXT4_DEF_INODE_READAHEAD_BLKS;\n\tsbi->s_sb_block = sb_block;\n\tif (sb->s_bdev->bd_part)\n\t\tsbi->s_sectors_written_start =\n\t\t\tpart_stat_read(sb->s_bdev->bd_part, sectors[1]);\n\n\t/* Cleanup superblock name */\n\tfor (cp = sb->s_id; (cp = strchr(cp, '/'));)\n\t\t*cp = '!';\n\n\t/* -EINVAL is default */\n\tret = -EINVAL;\n\tblocksize = sb_min_blocksize(sb, EXT4_MIN_BLOCK_SIZE);\n\tif (!blocksize) {\n\t\text4_msg(sb, KERN_ERR, \"unable to set blocksize\");\n\t\tgoto out_fail;\n\t}\n\n\t/*\n\t * The ext4 superblock will not be buffer aligned for other than 1kB\n\t * block sizes.  We need to calculate the offset from buffer start.\n\t */\n\tif (blocksize != EXT4_MIN_BLOCK_SIZE) {\n\t\tlogical_sb_block = sb_block * EXT4_MIN_BLOCK_SIZE;\n\t\toffset = do_div(logical_sb_block, blocksize);\n\t} else {\n\t\tlogical_sb_block = sb_block;\n\t}\n\n\tif (!(bh = sb_bread_unmovable(sb, logical_sb_block))) {\n\t\text4_msg(sb, KERN_ERR, \"unable to read superblock\");\n\t\tgoto out_fail;\n\t}\n\t/*\n\t * Note: s_es must be initialized as soon as possible because\n\t *       some ext4 macro-instructions depend on its value\n\t */\n\tes = (struct ext4_super_block *) (bh->b_data + offset);\n\tsbi->s_es = es;\n\tsb->s_magic = le16_to_cpu(es->s_magic);\n\tif (sb->s_magic != EXT4_SUPER_MAGIC)\n\t\tgoto cantfind_ext4;\n\tsbi->s_kbytes_written = le64_to_cpu(es->s_kbytes_written);\n\n\t/* Warn if metadata_csum and gdt_csum are both set. */\n\tif (EXT4_HAS_RO_COMPAT_FEATURE(sb,\n\t\t\t\t       EXT4_FEATURE_RO_COMPAT_METADATA_CSUM) &&\n\t    EXT4_HAS_RO_COMPAT_FEATURE(sb, EXT4_FEATURE_RO_COMPAT_GDT_CSUM))\n\t\text4_warning(sb, \"metadata_csum and uninit_bg are \"\n\t\t\t     \"redundant flags; please run fsck.\");\n\n\t/* Check for a known checksum algorithm */\n\tif (!ext4_verify_csum_type(sb, es)) {\n\t\text4_msg(sb, KERN_ERR, \"VFS: Found ext4 filesystem with \"\n\t\t\t \"unknown checksum algorithm.\");\n\t\tsilent = 1;\n\t\tgoto cantfind_ext4;\n\t}\n\n\t/* Load the checksum driver */\n\tif (EXT4_HAS_RO_COMPAT_FEATURE(sb,\n\t\t\t\t       EXT4_FEATURE_RO_COMPAT_METADATA_CSUM)) {\n\t\tsbi->s_chksum_driver = crypto_alloc_shash(\"crc32c\", 0, 0);\n\t\tif (IS_ERR(sbi->s_chksum_driver)) {\n\t\t\text4_msg(sb, KERN_ERR, \"Cannot load crc32c driver.\");\n\t\t\tret = PTR_ERR(sbi->s_chksum_driver);\n\t\t\tsbi->s_chksum_driver = NULL;\n\t\t\tgoto failed_mount;\n\t\t}\n\t}\n\n\t/* Check superblock checksum */\n\tif (!ext4_superblock_csum_verify(sb, es)) {\n\t\text4_msg(sb, KERN_ERR, \"VFS: Found ext4 filesystem with \"\n\t\t\t \"invalid superblock checksum.  Run e2fsck?\");\n\t\tsilent = 1;\n\t\tgoto cantfind_ext4;\n\t}\n\n\t/* Precompute checksum seed for all metadata */\n\tif (ext4_has_metadata_csum(sb))\n\t\tsbi->s_csum_seed = ext4_chksum(sbi, ~0, es->s_uuid,\n\t\t\t\t\t       sizeof(es->s_uuid));\n\n\t/* Set defaults before we parse the mount options */\n\tdef_mount_opts = le32_to_cpu(es->s_default_mount_opts);\n\tset_opt(sb, INIT_INODE_TABLE);\n\tif (def_mount_opts & EXT4_DEFM_DEBUG)\n\t\tset_opt(sb, DEBUG);\n\tif (def_mount_opts & EXT4_DEFM_BSDGROUPS)\n\t\tset_opt(sb, GRPID);\n\tif (def_mount_opts & EXT4_DEFM_UID16)\n\t\tset_opt(sb, NO_UID32);\n\t/* xattr user namespace & acls are now defaulted on */\n\tset_opt(sb, XATTR_USER);\n#ifdef CONFIG_EXT4_FS_POSIX_ACL\n\tset_opt(sb, POSIX_ACL);\n#endif\n\t/* don't forget to enable journal_csum when metadata_csum is enabled. */\n\tif (ext4_has_metadata_csum(sb))\n\t\tset_opt(sb, JOURNAL_CHECKSUM);\n\n\tif ((def_mount_opts & EXT4_DEFM_JMODE) == EXT4_DEFM_JMODE_DATA)\n\t\tset_opt(sb, JOURNAL_DATA);\n\telse if ((def_mount_opts & EXT4_DEFM_JMODE) == EXT4_DEFM_JMODE_ORDERED)\n\t\tset_opt(sb, ORDERED_DATA);\n\telse if ((def_mount_opts & EXT4_DEFM_JMODE) == EXT4_DEFM_JMODE_WBACK)\n\t\tset_opt(sb, WRITEBACK_DATA);\n\n\tif (le16_to_cpu(sbi->s_es->s_errors) == EXT4_ERRORS_PANIC)\n\t\tset_opt(sb, ERRORS_PANIC);\n\telse if (le16_to_cpu(sbi->s_es->s_errors) == EXT4_ERRORS_CONTINUE)\n\t\tset_opt(sb, ERRORS_CONT);\n\telse\n\t\tset_opt(sb, ERRORS_RO);\n\t/* block_validity enabled by default; disable with noblock_validity */\n\tset_opt(sb, BLOCK_VALIDITY);\n\tif (def_mount_opts & EXT4_DEFM_DISCARD)\n\t\tset_opt(sb, DISCARD);\n\n\tsbi->s_resuid = make_kuid(&init_user_ns, le16_to_cpu(es->s_def_resuid));\n\tsbi->s_resgid = make_kgid(&init_user_ns, le16_to_cpu(es->s_def_resgid));\n\tsbi->s_commit_interval = JBD2_DEFAULT_MAX_COMMIT_AGE * HZ;\n\tsbi->s_min_batch_time = EXT4_DEF_MIN_BATCH_TIME;\n\tsbi->s_max_batch_time = EXT4_DEF_MAX_BATCH_TIME;\n\n\tif ((def_mount_opts & EXT4_DEFM_NOBARRIER) == 0)\n\t\tset_opt(sb, BARRIER);\n\n\t/*\n\t * enable delayed allocation by default\n\t * Use -o nodelalloc to turn it off\n\t */\n\tif (!IS_EXT3_SB(sb) && !IS_EXT2_SB(sb) &&\n\t    ((def_mount_opts & EXT4_DEFM_NODELALLOC) == 0))\n\t\tset_opt(sb, DELALLOC);\n\n\t/*\n\t * set default s_li_wait_mult for lazyinit, for the case there is\n\t * no mount option specified.\n\t */\n\tsbi->s_li_wait_mult = EXT4_DEF_LI_WAIT_MULT;\n\n\tif (!parse_options((char *) sbi->s_es->s_mount_opts, sb,\n\t\t\t   &journal_devnum, &journal_ioprio, 0)) {\n\t\text4_msg(sb, KERN_WARNING,\n\t\t\t \"failed to parse options in superblock: %s\",\n\t\t\t sbi->s_es->s_mount_opts);\n\t}\n\tsbi->s_def_mount_opt = sbi->s_mount_opt;\n\tif (!parse_options((char *) data, sb, &journal_devnum,\n\t\t\t   &journal_ioprio, 0))\n\t\tgoto failed_mount;\n\n\tif (test_opt(sb, DATA_FLAGS) == EXT4_MOUNT_JOURNAL_DATA) {\n\t\tprintk_once(KERN_WARNING \"EXT4-fs: Warning: mounting \"\n\t\t\t    \"with data=journal disables delayed \"\n\t\t\t    \"allocation and O_DIRECT support!\\n\");\n\t\tif (test_opt2(sb, EXPLICIT_DELALLOC)) {\n\t\t\text4_msg(sb, KERN_ERR, \"can't mount with \"\n\t\t\t\t \"both data=journal and delalloc\");\n\t\t\tgoto failed_mount;\n\t\t}\n\t\tif (test_opt(sb, DIOREAD_NOLOCK)) {\n\t\t\text4_msg(sb, KERN_ERR, \"can't mount with \"\n\t\t\t\t \"both data=journal and dioread_nolock\");\n\t\t\tgoto failed_mount;\n\t\t}\n\t\tif (test_opt(sb, DAX)) {\n\t\t\text4_msg(sb, KERN_ERR, \"can't mount with \"\n\t\t\t\t \"both data=journal and dax\");\n\t\t\tgoto failed_mount;\n\t\t}\n\t\tif (test_opt(sb, DELALLOC))\n\t\t\tclear_opt(sb, DELALLOC);\n\t}\n\n\tsb->s_flags = (sb->s_flags & ~MS_POSIXACL) |\n\t\t(test_opt(sb, POSIX_ACL) ? MS_POSIXACL : 0);\n\n\tif (le32_to_cpu(es->s_rev_level) == EXT4_GOOD_OLD_REV &&\n\t    (EXT4_HAS_COMPAT_FEATURE(sb, ~0U) ||\n\t     EXT4_HAS_RO_COMPAT_FEATURE(sb, ~0U) ||\n\t     EXT4_HAS_INCOMPAT_FEATURE(sb, ~0U)))\n\t\text4_msg(sb, KERN_WARNING,\n\t\t       \"feature flags set on rev 0 fs, \"\n\t\t       \"running e2fsck is recommended\");\n\n\tif (es->s_creator_os == cpu_to_le32(EXT4_OS_HURD)) {\n\t\tset_opt2(sb, HURD_COMPAT);\n\t\tif (EXT4_HAS_INCOMPAT_FEATURE(sb,\n\t\t\t\t\t      EXT4_FEATURE_INCOMPAT_64BIT)) {\n\t\t\text4_msg(sb, KERN_ERR,\n\t\t\t\t \"The Hurd can't support 64-bit file systems\");\n\t\t\tgoto failed_mount;\n\t\t}\n\t}\n\n\tif (IS_EXT2_SB(sb)) {\n\t\tif (ext2_feature_set_ok(sb))\n\t\t\text4_msg(sb, KERN_INFO, \"mounting ext2 file system \"\n\t\t\t\t \"using the ext4 subsystem\");\n\t\telse {\n\t\t\text4_msg(sb, KERN_ERR, \"couldn't mount as ext2 due \"\n\t\t\t\t \"to feature incompatibilities\");\n\t\t\tgoto failed_mount;\n\t\t}\n\t}\n\n\tif (IS_EXT3_SB(sb)) {\n\t\tif (ext3_feature_set_ok(sb))\n\t\t\text4_msg(sb, KERN_INFO, \"mounting ext3 file system \"\n\t\t\t\t \"using the ext4 subsystem\");\n\t\telse {\n\t\t\text4_msg(sb, KERN_ERR, \"couldn't mount as ext3 due \"\n\t\t\t\t \"to feature incompatibilities\");\n\t\t\tgoto failed_mount;\n\t\t}\n\t}\n\n\t/*\n\t * Check feature flags regardless of the revision level, since we\n\t * previously didn't change the revision level when setting the flags,\n\t * so there is a chance incompat flags are set on a rev 0 filesystem.\n\t */\n\tif (!ext4_feature_set_ok(sb, (sb->s_flags & MS_RDONLY)))\n\t\tgoto failed_mount;\n\n\tblocksize = BLOCK_SIZE << le32_to_cpu(es->s_log_block_size);\n\tif (blocksize < EXT4_MIN_BLOCK_SIZE ||\n\t    blocksize > EXT4_MAX_BLOCK_SIZE) {\n\t\text4_msg(sb, KERN_ERR,\n\t\t       \"Unsupported filesystem blocksize %d\", blocksize);\n\t\tgoto failed_mount;\n\t}\n\n\tif (sbi->s_mount_opt & EXT4_MOUNT_DAX) {\n\t\tif (blocksize != PAGE_SIZE) {\n\t\t\text4_msg(sb, KERN_ERR,\n\t\t\t\t\t\"error: unsupported blocksize for dax\");\n\t\t\tgoto failed_mount;\n\t\t}\n\t\tif (!sb->s_bdev->bd_disk->fops->direct_access) {\n\t\t\text4_msg(sb, KERN_ERR,\n\t\t\t\t\t\"error: device does not support dax\");\n\t\t\tgoto failed_mount;\n\t\t}\n\t}\n\n\tif (sb->s_blocksize != blocksize) {\n\t\t/* Validate the filesystem blocksize */\n\t\tif (!sb_set_blocksize(sb, blocksize)) {\n\t\t\text4_msg(sb, KERN_ERR, \"bad block size %d\",\n\t\t\t\t\tblocksize);\n\t\t\tgoto failed_mount;\n\t\t}\n\n\t\tbrelse(bh);\n\t\tlogical_sb_block = sb_block * EXT4_MIN_BLOCK_SIZE;\n\t\toffset = do_div(logical_sb_block, blocksize);\n\t\tbh = sb_bread_unmovable(sb, logical_sb_block);\n\t\tif (!bh) {\n\t\t\text4_msg(sb, KERN_ERR,\n\t\t\t       \"Can't read superblock on 2nd try\");\n\t\t\tgoto failed_mount;\n\t\t}\n\t\tes = (struct ext4_super_block *)(bh->b_data + offset);\n\t\tsbi->s_es = es;\n\t\tif (es->s_magic != cpu_to_le16(EXT4_SUPER_MAGIC)) {\n\t\t\text4_msg(sb, KERN_ERR,\n\t\t\t       \"Magic mismatch, very weird!\");\n\t\t\tgoto failed_mount;\n\t\t}\n\t}\n\n\thas_huge_files = EXT4_HAS_RO_COMPAT_FEATURE(sb,\n\t\t\t\tEXT4_FEATURE_RO_COMPAT_HUGE_FILE);\n\tsbi->s_bitmap_maxbytes = ext4_max_bitmap_size(sb->s_blocksize_bits,\n\t\t\t\t\t\t      has_huge_files);\n\tsb->s_maxbytes = ext4_max_size(sb->s_blocksize_bits, has_huge_files);\n\n\tif (le32_to_cpu(es->s_rev_level) == EXT4_GOOD_OLD_REV) {\n\t\tsbi->s_inode_size = EXT4_GOOD_OLD_INODE_SIZE;\n\t\tsbi->s_first_ino = EXT4_GOOD_OLD_FIRST_INO;\n\t} else {\n\t\tsbi->s_inode_size = le16_to_cpu(es->s_inode_size);\n\t\tsbi->s_first_ino = le32_to_cpu(es->s_first_ino);\n\t\tif ((sbi->s_inode_size < EXT4_GOOD_OLD_INODE_SIZE) ||\n\t\t    (!is_power_of_2(sbi->s_inode_size)) ||\n\t\t    (sbi->s_inode_size > blocksize)) {\n\t\t\text4_msg(sb, KERN_ERR,\n\t\t\t       \"unsupported inode size: %d\",\n\t\t\t       sbi->s_inode_size);\n\t\t\tgoto failed_mount;\n\t\t}\n\t\tif (sbi->s_inode_size > EXT4_GOOD_OLD_INODE_SIZE)\n\t\t\tsb->s_time_gran = 1 << (EXT4_EPOCH_BITS - 2);\n\t}\n\n\tsbi->s_desc_size = le16_to_cpu(es->s_desc_size);\n\tif (EXT4_HAS_INCOMPAT_FEATURE(sb, EXT4_FEATURE_INCOMPAT_64BIT)) {\n\t\tif (sbi->s_desc_size < EXT4_MIN_DESC_SIZE_64BIT ||\n\t\t    sbi->s_desc_size > EXT4_MAX_DESC_SIZE ||\n\t\t    !is_power_of_2(sbi->s_desc_size)) {\n\t\t\text4_msg(sb, KERN_ERR,\n\t\t\t       \"unsupported descriptor size %lu\",\n\t\t\t       sbi->s_desc_size);\n\t\t\tgoto failed_mount;\n\t\t}\n\t} else\n\t\tsbi->s_desc_size = EXT4_MIN_DESC_SIZE;\n\n\tsbi->s_blocks_per_group = le32_to_cpu(es->s_blocks_per_group);\n\tsbi->s_inodes_per_group = le32_to_cpu(es->s_inodes_per_group);\n\tif (EXT4_INODE_SIZE(sb) == 0 || EXT4_INODES_PER_GROUP(sb) == 0)\n\t\tgoto cantfind_ext4;\n\n\tsbi->s_inodes_per_block = blocksize / EXT4_INODE_SIZE(sb);\n\tif (sbi->s_inodes_per_block == 0)\n\t\tgoto cantfind_ext4;\n\tsbi->s_itb_per_group = sbi->s_inodes_per_group /\n\t\t\t\t\tsbi->s_inodes_per_block;\n\tsbi->s_desc_per_block = blocksize / EXT4_DESC_SIZE(sb);\n\tsbi->s_sbh = bh;\n\tsbi->s_mount_state = le16_to_cpu(es->s_state);\n\tsbi->s_addr_per_block_bits = ilog2(EXT4_ADDR_PER_BLOCK(sb));\n\tsbi->s_desc_per_block_bits = ilog2(EXT4_DESC_PER_BLOCK(sb));\n\n\tfor (i = 0; i < 4; i++)\n\t\tsbi->s_hash_seed[i] = le32_to_cpu(es->s_hash_seed[i]);\n\tsbi->s_def_hash_version = es->s_def_hash_version;\n\tif (EXT4_HAS_COMPAT_FEATURE(sb, EXT4_FEATURE_COMPAT_DIR_INDEX)) {\n\t\ti = le32_to_cpu(es->s_flags);\n\t\tif (i & EXT2_FLAGS_UNSIGNED_HASH)\n\t\t\tsbi->s_hash_unsigned = 3;\n\t\telse if ((i & EXT2_FLAGS_SIGNED_HASH) == 0) {\n#ifdef __CHAR_UNSIGNED__\n\t\t\tif (!(sb->s_flags & MS_RDONLY))\n\t\t\t\tes->s_flags |=\n\t\t\t\t\tcpu_to_le32(EXT2_FLAGS_UNSIGNED_HASH);\n\t\t\tsbi->s_hash_unsigned = 3;\n#else\n\t\t\tif (!(sb->s_flags & MS_RDONLY))\n\t\t\t\tes->s_flags |=\n\t\t\t\t\tcpu_to_le32(EXT2_FLAGS_SIGNED_HASH);\n#endif\n\t\t}\n\t}\n\n\t/* Handle clustersize */\n\tclustersize = BLOCK_SIZE << le32_to_cpu(es->s_log_cluster_size);\n\thas_bigalloc = EXT4_HAS_RO_COMPAT_FEATURE(sb,\n\t\t\t\tEXT4_FEATURE_RO_COMPAT_BIGALLOC);\n\tif (has_bigalloc) {\n\t\tif (clustersize < blocksize) {\n\t\t\text4_msg(sb, KERN_ERR,\n\t\t\t\t \"cluster size (%d) smaller than \"\n\t\t\t\t \"block size (%d)\", clustersize, blocksize);\n\t\t\tgoto failed_mount;\n\t\t}\n\t\tsbi->s_cluster_bits = le32_to_cpu(es->s_log_cluster_size) -\n\t\t\tle32_to_cpu(es->s_log_block_size);\n\t\tsbi->s_clusters_per_group =\n\t\t\tle32_to_cpu(es->s_clusters_per_group);\n\t\tif (sbi->s_clusters_per_group > blocksize * 8) {\n\t\t\text4_msg(sb, KERN_ERR,\n\t\t\t\t \"#clusters per group too big: %lu\",\n\t\t\t\t sbi->s_clusters_per_group);\n\t\t\tgoto failed_mount;\n\t\t}\n\t\tif (sbi->s_blocks_per_group !=\n\t\t    (sbi->s_clusters_per_group * (clustersize / blocksize))) {\n\t\t\text4_msg(sb, KERN_ERR, \"blocks per group (%lu) and \"\n\t\t\t\t \"clusters per group (%lu) inconsistent\",\n\t\t\t\t sbi->s_blocks_per_group,\n\t\t\t\t sbi->s_clusters_per_group);\n\t\t\tgoto failed_mount;\n\t\t}\n\t} else {\n\t\tif (clustersize != blocksize) {\n\t\t\text4_warning(sb, \"fragment/cluster size (%d) != \"\n\t\t\t\t     \"block size (%d)\", clustersize,\n\t\t\t\t     blocksize);\n\t\t\tclustersize = blocksize;\n\t\t}\n\t\tif (sbi->s_blocks_per_group > blocksize * 8) {\n\t\t\text4_msg(sb, KERN_ERR,\n\t\t\t\t \"#blocks per group too big: %lu\",\n\t\t\t\t sbi->s_blocks_per_group);\n\t\t\tgoto failed_mount;\n\t\t}\n\t\tsbi->s_clusters_per_group = sbi->s_blocks_per_group;\n\t\tsbi->s_cluster_bits = 0;\n\t}\n\tsbi->s_cluster_ratio = clustersize / blocksize;\n\n\tif (sbi->s_inodes_per_group > blocksize * 8) {\n\t\text4_msg(sb, KERN_ERR,\n\t\t       \"#inodes per group too big: %lu\",\n\t\t       sbi->s_inodes_per_group);\n\t\tgoto failed_mount;\n\t}\n\n\t/* Do we have standard group size of clustersize * 8 blocks ? */\n\tif (sbi->s_blocks_per_group == clustersize << 3)\n\t\tset_opt2(sb, STD_GROUP_SIZE);\n\n\t/*\n\t * Test whether we have more sectors than will fit in sector_t,\n\t * and whether the max offset is addressable by the page cache.\n\t */\n\terr = generic_check_addressable(sb->s_blocksize_bits,\n\t\t\t\t\text4_blocks_count(es));\n\tif (err) {\n\t\text4_msg(sb, KERN_ERR, \"filesystem\"\n\t\t\t \" too large to mount safely on this system\");\n\t\tif (sizeof(sector_t) < 8)\n\t\t\text4_msg(sb, KERN_WARNING, \"CONFIG_LBDAF not enabled\");\n\t\tgoto failed_mount;\n\t}\n\n\tif (EXT4_BLOCKS_PER_GROUP(sb) == 0)\n\t\tgoto cantfind_ext4;\n\n\t/* check blocks count against device size */\n\tblocks_count = sb->s_bdev->bd_inode->i_size >> sb->s_blocksize_bits;\n\tif (blocks_count && ext4_blocks_count(es) > blocks_count) {\n\t\text4_msg(sb, KERN_WARNING, \"bad geometry: block count %llu \"\n\t\t       \"exceeds size of device (%llu blocks)\",\n\t\t       ext4_blocks_count(es), blocks_count);\n\t\tgoto failed_mount;\n\t}\n\n\t/*\n\t * It makes no sense for the first data block to be beyond the end\n\t * of the filesystem.\n\t */\n\tif (le32_to_cpu(es->s_first_data_block) >= ext4_blocks_count(es)) {\n\t\text4_msg(sb, KERN_WARNING, \"bad geometry: first data \"\n\t\t\t \"block %u is beyond end of filesystem (%llu)\",\n\t\t\t le32_to_cpu(es->s_first_data_block),\n\t\t\t ext4_blocks_count(es));\n\t\tgoto failed_mount;\n\t}\n\tblocks_count = (ext4_blocks_count(es) -\n\t\t\tle32_to_cpu(es->s_first_data_block) +\n\t\t\tEXT4_BLOCKS_PER_GROUP(sb) - 1);\n\tdo_div(blocks_count, EXT4_BLOCKS_PER_GROUP(sb));\n\tif (blocks_count > ((uint64_t)1<<32) - EXT4_DESC_PER_BLOCK(sb)) {\n\t\text4_msg(sb, KERN_WARNING, \"groups count too large: %u \"\n\t\t       \"(block count %llu, first data block %u, \"\n\t\t       \"blocks per group %lu)\", sbi->s_groups_count,\n\t\t       ext4_blocks_count(es),\n\t\t       le32_to_cpu(es->s_first_data_block),\n\t\t       EXT4_BLOCKS_PER_GROUP(sb));\n\t\tgoto failed_mount;\n\t}\n\tsbi->s_groups_count = blocks_count;\n\tsbi->s_blockfile_groups = min_t(ext4_group_t, sbi->s_groups_count,\n\t\t\t(EXT4_MAX_BLOCK_FILE_PHYS / EXT4_BLOCKS_PER_GROUP(sb)));\n\tdb_count = (sbi->s_groups_count + EXT4_DESC_PER_BLOCK(sb) - 1) /\n\t\t   EXT4_DESC_PER_BLOCK(sb);\n\tsbi->s_group_desc = ext4_kvmalloc(db_count *\n\t\t\t\t\t  sizeof(struct buffer_head *),\n\t\t\t\t\t  GFP_KERNEL);\n\tif (sbi->s_group_desc == NULL) {\n\t\text4_msg(sb, KERN_ERR, \"not enough memory\");\n\t\tret = -ENOMEM;\n\t\tgoto failed_mount;\n\t}\n\n\tif (ext4_proc_root)\n\t\tsbi->s_proc = proc_mkdir(sb->s_id, ext4_proc_root);\n\n\tif (sbi->s_proc)\n\t\tproc_create_data(\"options\", S_IRUGO, sbi->s_proc,\n\t\t\t\t &ext4_seq_options_fops, sb);\n\n\tbgl_lock_init(sbi->s_blockgroup_lock);\n\n\tfor (i = 0; i < db_count; i++) {\n\t\tblock = descriptor_loc(sb, logical_sb_block, i);\n\t\tsbi->s_group_desc[i] = sb_bread_unmovable(sb, block);\n\t\tif (!sbi->s_group_desc[i]) {\n\t\t\text4_msg(sb, KERN_ERR,\n\t\t\t       \"can't read group descriptor %d\", i);\n\t\t\tdb_count = i;\n\t\t\tgoto failed_mount2;\n\t\t}\n\t}\n\tif (!ext4_check_descriptors(sb, &first_not_zeroed)) {\n\t\text4_msg(sb, KERN_ERR, \"group descriptors corrupted!\");\n\t\tgoto failed_mount2;\n\t}\n\n\tsbi->s_gdb_count = db_count;\n\tget_random_bytes(&sbi->s_next_generation, sizeof(u32));\n\tspin_lock_init(&sbi->s_next_gen_lock);\n\n\tsetup_timer(&sbi->s_err_report, print_daily_error_info,\n\t\t(unsigned long) sb);\n\n\t/* Register extent status tree shrinker */\n\tif (ext4_es_register_shrinker(sbi))\n\t\tgoto failed_mount3;\n\n\tsbi->s_stripe = ext4_get_stripe_size(sbi);\n\tsbi->s_extent_max_zeroout_kb = 32;\n\n\t/*\n\t * set up enough so that it can read an inode\n\t */\n\tsb->s_op = &ext4_sops;\n\tsb->s_export_op = &ext4_export_ops;\n\tsb->s_xattr = ext4_xattr_handlers;\n#ifdef CONFIG_QUOTA\n\tsb->dq_op = &ext4_quota_operations;\n\tif (EXT4_HAS_RO_COMPAT_FEATURE(sb, EXT4_FEATURE_RO_COMPAT_QUOTA))\n\t\tsb->s_qcop = &dquot_quotactl_sysfile_ops;\n\telse\n\t\tsb->s_qcop = &ext4_qctl_operations;\n\tsb->s_quota_types = QTYPE_MASK_USR | QTYPE_MASK_GRP;\n#endif\n\tmemcpy(sb->s_uuid, es->s_uuid, sizeof(es->s_uuid));\n\n\tINIT_LIST_HEAD(&sbi->s_orphan); /* unlinked but open files */\n\tmutex_init(&sbi->s_orphan_lock);\n\n\tsb->s_root = NULL;\n\n\tneeds_recovery = (es->s_last_orphan != 0 ||\n\t\t\t  EXT4_HAS_INCOMPAT_FEATURE(sb,\n\t\t\t\t    EXT4_FEATURE_INCOMPAT_RECOVER));\n\n\tif (EXT4_HAS_INCOMPAT_FEATURE(sb, EXT4_FEATURE_INCOMPAT_MMP) &&\n\t    !(sb->s_flags & MS_RDONLY))\n\t\tif (ext4_multi_mount_protect(sb, le64_to_cpu(es->s_mmp_block)))\n\t\t\tgoto failed_mount3a;\n\n\t/*\n\t * The first inode we look at is the journal inode.  Don't try\n\t * root first: it may be modified in the journal!\n\t */\n\tif (!test_opt(sb, NOLOAD) &&\n\t    EXT4_HAS_COMPAT_FEATURE(sb, EXT4_FEATURE_COMPAT_HAS_JOURNAL)) {\n\t\tif (ext4_load_journal(sb, es, journal_devnum))\n\t\t\tgoto failed_mount3a;\n\t} else if (test_opt(sb, NOLOAD) && !(sb->s_flags & MS_RDONLY) &&\n\t      EXT4_HAS_INCOMPAT_FEATURE(sb, EXT4_FEATURE_INCOMPAT_RECOVER)) {\n\t\text4_msg(sb, KERN_ERR, \"required journal recovery \"\n\t\t       \"suppressed and not mounted read-only\");\n\t\tgoto failed_mount_wq;\n\t} else {\n\t\tclear_opt(sb, DATA_FLAGS);\n\t\tsbi->s_journal = NULL;\n\t\tneeds_recovery = 0;\n\t\tgoto no_journal;\n\t}\n\n\tif (EXT4_HAS_INCOMPAT_FEATURE(sb, EXT4_FEATURE_INCOMPAT_64BIT) &&\n\t    !jbd2_journal_set_features(EXT4_SB(sb)->s_journal, 0, 0,\n\t\t\t\t       JBD2_FEATURE_INCOMPAT_64BIT)) {\n\t\text4_msg(sb, KERN_ERR, \"Failed to set 64-bit journal feature\");\n\t\tgoto failed_mount_wq;\n\t}\n\n\tif (!set_journal_csum_feature_set(sb)) {\n\t\text4_msg(sb, KERN_ERR, \"Failed to set journal checksum \"\n\t\t\t \"feature set\");\n\t\tgoto failed_mount_wq;\n\t}\n\n\t/* We have now updated the journal if required, so we can\n\t * validate the data journaling mode. */\n\tswitch (test_opt(sb, DATA_FLAGS)) {\n\tcase 0:\n\t\t/* No mode set, assume a default based on the journal\n\t\t * capabilities: ORDERED_DATA if the journal can\n\t\t * cope, else JOURNAL_DATA\n\t\t */\n\t\tif (jbd2_journal_check_available_features\n\t\t    (sbi->s_journal, 0, 0, JBD2_FEATURE_INCOMPAT_REVOKE))\n\t\t\tset_opt(sb, ORDERED_DATA);\n\t\telse\n\t\t\tset_opt(sb, JOURNAL_DATA);\n\t\tbreak;\n\n\tcase EXT4_MOUNT_ORDERED_DATA:\n\tcase EXT4_MOUNT_WRITEBACK_DATA:\n\t\tif (!jbd2_journal_check_available_features\n\t\t    (sbi->s_journal, 0, 0, JBD2_FEATURE_INCOMPAT_REVOKE)) {\n\t\t\text4_msg(sb, KERN_ERR, \"Journal does not support \"\n\t\t\t       \"requested data journaling mode\");\n\t\t\tgoto failed_mount_wq;\n\t\t}\n\tdefault:\n\t\tbreak;\n\t}\n\tset_task_ioprio(sbi->s_journal->j_task, journal_ioprio);\n\n\tsbi->s_journal->j_commit_callback = ext4_journal_commit_callback;\n\nno_journal:\n\tif (ext4_mballoc_ready) {\n\t\tsbi->s_mb_cache = ext4_xattr_create_cache(sb->s_id);\n\t\tif (!sbi->s_mb_cache) {\n\t\t\text4_msg(sb, KERN_ERR, \"Failed to create an mb_cache\");\n\t\t\tgoto failed_mount_wq;\n\t\t}\n\t}\n\n\t/*\n\t * Get the # of file system overhead blocks from the\n\t * superblock if present.\n\t */\n\tif (es->s_overhead_clusters)\n\t\tsbi->s_overhead = le32_to_cpu(es->s_overhead_clusters);\n\telse {\n\t\terr = ext4_calculate_overhead(sb);\n\t\tif (err)\n\t\t\tgoto failed_mount_wq;\n\t}\n\n\t/*\n\t * The maximum number of concurrent works can be high and\n\t * concurrency isn't really necessary.  Limit it to 1.\n\t */\n\tEXT4_SB(sb)->rsv_conversion_wq =\n\t\talloc_workqueue(\"ext4-rsv-conversion\", WQ_MEM_RECLAIM | WQ_UNBOUND, 1);\n\tif (!EXT4_SB(sb)->rsv_conversion_wq) {\n\t\tprintk(KERN_ERR \"EXT4-fs: failed to create workqueue\\n\");\n\t\tret = -ENOMEM;\n\t\tgoto failed_mount4;\n\t}\n\n\t/*\n\t * The jbd2_journal_load will have done any necessary log recovery,\n\t * so we can safely mount the rest of the filesystem now.\n\t */\n\n\troot = ext4_iget(sb, EXT4_ROOT_INO);\n\tif (IS_ERR(root)) {\n\t\text4_msg(sb, KERN_ERR, \"get root inode failed\");\n\t\tret = PTR_ERR(root);\n\t\troot = NULL;\n\t\tgoto failed_mount4;\n\t}\n\tif (!S_ISDIR(root->i_mode) || !root->i_blocks || !root->i_size) {\n\t\text4_msg(sb, KERN_ERR, \"corrupt root inode, run e2fsck\");\n\t\tiput(root);\n\t\tgoto failed_mount4;\n\t}\n\tsb->s_root = d_make_root(root);\n\tif (!sb->s_root) {\n\t\text4_msg(sb, KERN_ERR, \"get root dentry failed\");\n\t\tret = -ENOMEM;\n\t\tgoto failed_mount4;\n\t}\n\n\tif (ext4_setup_super(sb, es, sb->s_flags & MS_RDONLY))\n\t\tsb->s_flags |= MS_RDONLY;\n\n\t/* determine the minimum size of new large inodes, if present */\n\tif (sbi->s_inode_size > EXT4_GOOD_OLD_INODE_SIZE) {\n\t\tsbi->s_want_extra_isize = sizeof(struct ext4_inode) -\n\t\t\t\t\t\t     EXT4_GOOD_OLD_INODE_SIZE;\n\t\tif (EXT4_HAS_RO_COMPAT_FEATURE(sb,\n\t\t\t\t       EXT4_FEATURE_RO_COMPAT_EXTRA_ISIZE)) {\n\t\t\tif (sbi->s_want_extra_isize <\n\t\t\t    le16_to_cpu(es->s_want_extra_isize))\n\t\t\t\tsbi->s_want_extra_isize =\n\t\t\t\t\tle16_to_cpu(es->s_want_extra_isize);\n\t\t\tif (sbi->s_want_extra_isize <\n\t\t\t    le16_to_cpu(es->s_min_extra_isize))\n\t\t\t\tsbi->s_want_extra_isize =\n\t\t\t\t\tle16_to_cpu(es->s_min_extra_isize);\n\t\t}\n\t}\n\t/* Check if enough inode space is available */\n\tif (EXT4_GOOD_OLD_INODE_SIZE + sbi->s_want_extra_isize >\n\t\t\t\t\t\t\tsbi->s_inode_size) {\n\t\tsbi->s_want_extra_isize = sizeof(struct ext4_inode) -\n\t\t\t\t\t\t       EXT4_GOOD_OLD_INODE_SIZE;\n\t\text4_msg(sb, KERN_INFO, \"required extra inode space not\"\n\t\t\t \"available\");\n\t}\n\n\terr = ext4_reserve_clusters(sbi, ext4_calculate_resv_clusters(sb));\n\tif (err) {\n\t\text4_msg(sb, KERN_ERR, \"failed to reserve %llu clusters for \"\n\t\t\t \"reserved pool\", ext4_calculate_resv_clusters(sb));\n\t\tgoto failed_mount4a;\n\t}\n\n\terr = ext4_setup_system_zone(sb);\n\tif (err) {\n\t\text4_msg(sb, KERN_ERR, \"failed to initialize system \"\n\t\t\t \"zone (%d)\", err);\n\t\tgoto failed_mount4a;\n\t}\n\n\text4_ext_init(sb);\n\terr = ext4_mb_init(sb);\n\tif (err) {\n\t\text4_msg(sb, KERN_ERR, \"failed to initialize mballoc (%d)\",\n\t\t\t err);\n\t\tgoto failed_mount5;\n\t}\n\n\tblock = ext4_count_free_clusters(sb);\n\text4_free_blocks_count_set(sbi->s_es, \n\t\t\t\t   EXT4_C2B(sbi, block));\n\terr = percpu_counter_init(&sbi->s_freeclusters_counter, block,\n\t\t\t\t  GFP_KERNEL);\n\tif (!err) {\n\t\tunsigned long freei = ext4_count_free_inodes(sb);\n\t\tsbi->s_es->s_free_inodes_count = cpu_to_le32(freei);\n\t\terr = percpu_counter_init(&sbi->s_freeinodes_counter, freei,\n\t\t\t\t\t  GFP_KERNEL);\n\t}\n\tif (!err)\n\t\terr = percpu_counter_init(&sbi->s_dirs_counter,\n\t\t\t\t\t  ext4_count_dirs(sb), GFP_KERNEL);\n\tif (!err)\n\t\terr = percpu_counter_init(&sbi->s_dirtyclusters_counter, 0,\n\t\t\t\t\t  GFP_KERNEL);\n\tif (err) {\n\t\text4_msg(sb, KERN_ERR, \"insufficient memory\");\n\t\tgoto failed_mount6;\n\t}\n\n\tif (EXT4_HAS_INCOMPAT_FEATURE(sb, EXT4_FEATURE_INCOMPAT_FLEX_BG))\n\t\tif (!ext4_fill_flex_info(sb)) {\n\t\t\text4_msg(sb, KERN_ERR,\n\t\t\t       \"unable to initialize \"\n\t\t\t       \"flex_bg meta info!\");\n\t\t\tgoto failed_mount6;\n\t\t}\n\n\terr = ext4_register_li_request(sb, first_not_zeroed);\n\tif (err)\n\t\tgoto failed_mount6;\n\n\tsbi->s_kobj.kset = ext4_kset;\n\tinit_completion(&sbi->s_kobj_unregister);\n\terr = kobject_init_and_add(&sbi->s_kobj, &ext4_ktype, NULL,\n\t\t\t\t   \"%s\", sb->s_id);\n\tif (err)\n\t\tgoto failed_mount7;\n\n#ifdef CONFIG_QUOTA\n\t/* Enable quota usage during mount. */\n\tif (EXT4_HAS_RO_COMPAT_FEATURE(sb, EXT4_FEATURE_RO_COMPAT_QUOTA) &&\n\t    !(sb->s_flags & MS_RDONLY)) {\n\t\terr = ext4_enable_quotas(sb);\n\t\tif (err)\n\t\t\tgoto failed_mount8;\n\t}\n#endif  /* CONFIG_QUOTA */\n\n\tEXT4_SB(sb)->s_mount_state |= EXT4_ORPHAN_FS;\n\text4_orphan_cleanup(sb, es);\n\tEXT4_SB(sb)->s_mount_state &= ~EXT4_ORPHAN_FS;\n\tif (needs_recovery) {\n\t\text4_msg(sb, KERN_INFO, \"recovery complete\");\n\t\text4_mark_recovery_complete(sb, es);\n\t}\n\tif (EXT4_SB(sb)->s_journal) {\n\t\tif (test_opt(sb, DATA_FLAGS) == EXT4_MOUNT_JOURNAL_DATA)\n\t\t\tdescr = \" journalled data mode\";\n\t\telse if (test_opt(sb, DATA_FLAGS) == EXT4_MOUNT_ORDERED_DATA)\n\t\t\tdescr = \" ordered data mode\";\n\t\telse\n\t\t\tdescr = \" writeback data mode\";\n\t} else\n\t\tdescr = \"out journal\";\n\n\tif (test_opt(sb, DISCARD)) {\n\t\tstruct request_queue *q = bdev_get_queue(sb->s_bdev);\n\t\tif (!blk_queue_discard(q))\n\t\t\text4_msg(sb, KERN_WARNING,\n\t\t\t\t \"mounting with \\\"discard\\\" option, but \"\n\t\t\t\t \"the device does not support discard\");\n\t}\n\n\text4_msg(sb, KERN_INFO, \"mounted filesystem with%s. \"\n\t\t \"Opts: %s%s%s\", descr, sbi->s_es->s_mount_opts,\n\t\t *sbi->s_es->s_mount_opts ? \"; \" : \"\", orig_data);\n\n\tif (es->s_error_count)\n\t\tmod_timer(&sbi->s_err_report, jiffies + 300*HZ); /* 5 minutes */\n\n\t/* Enable message ratelimiting. Default is 10 messages per 5 secs. */\n\tratelimit_state_init(&sbi->s_err_ratelimit_state, 5 * HZ, 10);\n\tratelimit_state_init(&sbi->s_warning_ratelimit_state, 5 * HZ, 10);\n\tratelimit_state_init(&sbi->s_msg_ratelimit_state, 5 * HZ, 10);\n\n\tkfree(orig_data);\n\treturn 0;\n\ncantfind_ext4:\n\tif (!silent)\n\t\text4_msg(sb, KERN_ERR, \"VFS: Can't find ext4 filesystem\");\n\tgoto failed_mount;\n\n#ifdef CONFIG_QUOTA\nfailed_mount8:\n\tkobject_del(&sbi->s_kobj);\n#endif\nfailed_mount7:\n\text4_unregister_li_request(sb);\nfailed_mount6:\n\text4_mb_release(sb);\n\tif (sbi->s_flex_groups)\n\t\tkvfree(sbi->s_flex_groups);\n\tpercpu_counter_destroy(&sbi->s_freeclusters_counter);\n\tpercpu_counter_destroy(&sbi->s_freeinodes_counter);\n\tpercpu_counter_destroy(&sbi->s_dirs_counter);\n\tpercpu_counter_destroy(&sbi->s_dirtyclusters_counter);\nfailed_mount5:\n\text4_ext_release(sb);\n\text4_release_system_zone(sb);\nfailed_mount4a:\n\tdput(sb->s_root);\n\tsb->s_root = NULL;\nfailed_mount4:\n\text4_msg(sb, KERN_ERR, \"mount failed\");\n\tif (EXT4_SB(sb)->rsv_conversion_wq)\n\t\tdestroy_workqueue(EXT4_SB(sb)->rsv_conversion_wq);\nfailed_mount_wq:\n\tif (sbi->s_journal) {\n\t\tjbd2_journal_destroy(sbi->s_journal);\n\t\tsbi->s_journal = NULL;\n\t}\nfailed_mount3a:\n\text4_es_unregister_shrinker(sbi);\nfailed_mount3:\n\tdel_timer_sync(&sbi->s_err_report);\n\tif (sbi->s_mmp_tsk)\n\t\tkthread_stop(sbi->s_mmp_tsk);\nfailed_mount2:\n\tfor (i = 0; i < db_count; i++)\n\t\tbrelse(sbi->s_group_desc[i]);\n\tkvfree(sbi->s_group_desc);\nfailed_mount:\n\tif (sbi->s_chksum_driver)\n\t\tcrypto_free_shash(sbi->s_chksum_driver);\n\tif (sbi->s_proc) {\n\t\tremove_proc_entry(\"options\", sbi->s_proc);\n\t\tremove_proc_entry(sb->s_id, ext4_proc_root);\n\t}\n#ifdef CONFIG_QUOTA\n\tfor (i = 0; i < EXT4_MAXQUOTAS; i++)\n\t\tkfree(sbi->s_qf_names[i]);\n#endif\n\text4_blkdev_remove(sbi);\n\tbrelse(bh);\nout_fail:\n\tsb->s_fs_info = NULL;\n\tkfree(sbi->s_blockgroup_lock);\n\tkfree(sbi);\nout_free_orig:\n\tkfree(orig_data);\n\treturn err ? err : ret;\n}",
    "includes": [
      "#include <trace/events/ext4.h>",
      "#include \"mballoc.h\"",
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"ext4_jbd2.h\"",
      "#include \"ext4_extents.h\"\t/* Needed for trace points definition */",
      "#include \"ext4.h\"",
      "#include <linux/freezer.h>",
      "#include <linux/kthread.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/cleancache.h>",
      "#include <linux/crc16.h>",
      "#include <linux/log2.h>",
      "#include <linux/ctype.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/namei.h>",
      "#include <linux/mount.h>",
      "#include <linux/random.h>",
      "#include <linux/vfs.h>",
      "#include <linux/exportfs.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/parser.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/init.h>",
      "#include <linux/slab.h>",
      "#include <linux/jbd2.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/time.h>",
      "#include <linux/fs.h>",
      "#include <linux/string.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [
      "#define DEFAULT_JOURNAL_IOPRIO (IOPRIO_PRIO_VALUE(IOPRIO_CLASS_BE, 3))"
    ],
    "globals_used": [
      "static struct proc_dir_entry *ext4_proc_root;",
      "static struct kset *ext4_kset;",
      "static int ext4_mballoc_ready;",
      "static int ext4_load_journal(struct super_block *, struct ext4_super_block *,\n\t\t\t     unsigned long journal_devnum);",
      "static int ext4_show_options(struct seq_file *seq, struct dentry *root);",
      "static void ext4_mark_recovery_complete(struct super_block *sb,\n\t\t\t\t\tstruct ext4_super_block *es);",
      "static void ext4_clear_journal_err(struct super_block *sb,\n\t\t\t\t   struct ext4_super_block *es);",
      "static int ext4_remount(struct super_block *sb, int *flags, char *data);",
      "static int ext4_unfreeze(struct super_block *sb);",
      "static int ext4_freeze(struct super_block *sb);",
      "static struct dentry *ext4_mount(struct file_system_type *fs_type, int flags,\n\t\t       const char *dev_name, void *data);",
      "static inline int ext2_feature_set_ok(struct super_block *sb);",
      "static inline int ext3_feature_set_ok(struct super_block *sb);",
      "static void ext4_unregister_li_request(struct super_block *sb);",
      "static int ext4_reserve_clusters(struct ext4_sb_info *, ext4_fsblk_t);",
      "static const struct super_operations ext4_sops = {\n\t.alloc_inode\t= ext4_alloc_inode,\n\t.destroy_inode\t= ext4_destroy_inode,\n\t.write_inode\t= ext4_write_inode,\n\t.dirty_inode\t= ext4_dirty_inode,\n\t.drop_inode\t= ext4_drop_inode,\n\t.evict_inode\t= ext4_evict_inode,\n\t.put_super\t= ext4_put_super,\n\t.sync_fs\t= ext4_sync_fs,\n\t.freeze_fs\t= ext4_freeze,\n\t.unfreeze_fs\t= ext4_unfreeze,\n\t.statfs\t\t= ext4_statfs,\n\t.remount_fs\t= ext4_remount,\n\t.show_options\t= ext4_show_options,\n#ifdef CONFIG_QUOTA\n\t.quota_read\t= ext4_quota_read,\n\t.quota_write\t= ext4_quota_write,\n\t.get_dquots\t= ext4_get_dquots,\n#endif\n\t.bdev_try_to_free_page = bdev_try_to_free_page,\n};",
      "static const struct export_operations ext4_export_ops = {\n\t.fh_to_dentry = ext4_fh_to_dentry,\n\t.fh_to_parent = ext4_fh_to_parent,\n\t.get_parent = ext4_get_parent,\n};",
      "static const struct file_operations ext4_seq_options_fops = {\n\t.owner = THIS_MODULE,\n\t.open = options_open_fs,\n\t.read = seq_read,\n\t.llseek = seq_lseek,\n\t.release = single_release,\n};",
      "static struct kobj_type ext4_ktype = {\n\t.default_attrs\t= ext4_attrs,\n\t.sysfs_ops\t= &ext4_attr_ops,\n\t.release\t= ext4_sb_release,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "orig_data"
          ],
          "line": 4308
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "sbi"
          ],
          "line": 4306
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "sbi->s_blockgroup_lock"
          ],
          "line": 4305
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "brelse",
          "args": [
            "bh"
          ],
          "line": 4302
        },
        "resolved": true,
        "details": {
          "function_name": "__brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1177-1184",
          "snippet": "void __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_blkdev_remove",
          "args": [
            "sbi"
          ],
          "line": 4301
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_blkdev_remove",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/super.c",
          "lines": "731-739",
          "snippet": "static void ext4_blkdev_remove(struct ext4_sb_info *sbi)\n{\n\tstruct block_device *bdev;\n\tbdev = sbi->journal_bdev;\n\tif (bdev) {\n\t\text4_blkdev_put(bdev);\n\t\tsbi->journal_bdev = NULL;\n\t}\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"mballoc.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include \"ext4_extents.h\"\t/* Needed for trace points definition */",
            "#include \"ext4.h\"",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/crc16.h>",
            "#include <linux/log2.h>",
            "#include <linux/ctype.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/random.h>",
            "#include <linux/vfs.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/parser.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/time.h>",
            "#include <linux/fs.h>",
            "#include <linux/string.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"mballoc.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4_extents.h\"\t/* Needed for trace points definition */\n#include \"ext4.h\"\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <asm/uaccess.h>\n#include <linux/cleancache.h>\n#include <linux/crc16.h>\n#include <linux/log2.h>\n#include <linux/ctype.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/random.h>\n#include <linux/vfs.h>\n#include <linux/exportfs.h>\n#include <linux/buffer_head.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/jbd2.h>\n#include <linux/vmalloc.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n#include <linux/string.h>\n#include <linux/module.h>\n\nstatic void ext4_blkdev_remove(struct ext4_sb_info *sbi)\n{\n\tstruct block_device *bdev;\n\tbdev = sbi->journal_bdev;\n\tif (bdev) {\n\t\text4_blkdev_put(bdev);\n\t\tsbi->journal_bdev = NULL;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "sbi->s_qf_names[i]"
          ],
          "line": 4299
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "remove_proc_entry",
          "args": [
            "sb->s_id",
            "ext4_proc_root"
          ],
          "line": 4295
        },
        "resolved": true,
        "details": {
          "function_name": "remove_proc_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/generic.c",
          "lines": "523-554",
          "snippet": "void remove_proc_entry(const char *name, struct proc_dir_entry *parent)\n{\n\tstruct proc_dir_entry *de = NULL;\n\tconst char *fn = name;\n\tunsigned int len;\n\n\tspin_lock(&proc_subdir_lock);\n\tif (__xlate_proc_name(name, &parent, &fn) != 0) {\n\t\tspin_unlock(&proc_subdir_lock);\n\t\treturn;\n\t}\n\tlen = strlen(fn);\n\n\tde = pde_subdir_find(parent, fn, len);\n\tif (de)\n\t\trb_erase(&de->subdir_node, &parent->subdir);\n\tspin_unlock(&proc_subdir_lock);\n\tif (!de) {\n\t\tWARN(1, \"name '%s'\\n\", name);\n\t\treturn;\n\t}\n\n\tproc_entry_rundown(de);\n\n\tif (S_ISDIR(de->mode))\n\t\tparent->nlink--;\n\tde->nlink = 0;\n\tWARN(pde_subdir_first(de),\n\t     \"%s: removing non-empty directory '%s/%s', leaking at least '%s'\\n\",\n\t     __func__, de->parent->name, de->name, pde_subdir_first(de)->name);\n\tpde_put(de);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/bitops.h>",
            "#include <linux/idr.h>",
            "#include <linux/init.h>",
            "#include <linux/mount.h>",
            "#include <linux/printk.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/stat.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/time.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_SPINLOCK(proc_subdir_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/bitops.h>\n#include <linux/idr.h>\n#include <linux/init.h>\n#include <linux/mount.h>\n#include <linux/printk.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/stat.h>\n#include <linux/proc_fs.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n\nstatic DEFINE_SPINLOCK(proc_subdir_lock);\n\nvoid remove_proc_entry(const char *name, struct proc_dir_entry *parent)\n{\n\tstruct proc_dir_entry *de = NULL;\n\tconst char *fn = name;\n\tunsigned int len;\n\n\tspin_lock(&proc_subdir_lock);\n\tif (__xlate_proc_name(name, &parent, &fn) != 0) {\n\t\tspin_unlock(&proc_subdir_lock);\n\t\treturn;\n\t}\n\tlen = strlen(fn);\n\n\tde = pde_subdir_find(parent, fn, len);\n\tif (de)\n\t\trb_erase(&de->subdir_node, &parent->subdir);\n\tspin_unlock(&proc_subdir_lock);\n\tif (!de) {\n\t\tWARN(1, \"name '%s'\\n\", name);\n\t\treturn;\n\t}\n\n\tproc_entry_rundown(de);\n\n\tif (S_ISDIR(de->mode))\n\t\tparent->nlink--;\n\tde->nlink = 0;\n\tWARN(pde_subdir_first(de),\n\t     \"%s: removing non-empty directory '%s/%s', leaking at least '%s'\\n\",\n\t     __func__, de->parent->name, de->name, pde_subdir_first(de)->name);\n\tpde_put(de);\n}"
        }
      },
      {
        "call_info": {
          "callee": "crypto_free_shash",
          "args": [
            "sbi->s_chksum_driver"
          ],
          "line": 4292
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvfree",
          "args": [
            "sbi->s_group_desc"
          ],
          "line": 4289
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kthread_stop",
          "args": [
            "sbi->s_mmp_tsk"
          ],
          "line": 4285
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "del_timer_sync",
          "args": [
            "&sbi->s_err_report"
          ],
          "line": 4283
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_es_unregister_shrinker",
          "args": [
            "sbi"
          ],
          "line": 4281
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_es_unregister_shrinker",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/extents_status.c",
          "lines": "1220-1227",
          "snippet": "void ext4_es_unregister_shrinker(struct ext4_sb_info *sbi)\n{\n\tif (sbi->s_proc)\n\t\tremove_proc_entry(\"es_shrinker_info\", sbi->s_proc);\n\tpercpu_counter_destroy(&sbi->s_es_stats.es_stats_all_cnt);\n\tpercpu_counter_destroy(&sbi->s_es_stats.es_stats_shk_cnt);\n\tunregister_shrinker(&sbi->s_es_shrinker);\n}",
          "includes": [
            "#include \"ext4_extents.h\"\t/* Needed when ES_AGGRESSIVE_TEST is defined */",
            "#include <trace/events/ext4.h>",
            "#include \"extents_status.h\"",
            "#include \"ext4.h\"",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/list_sort.h>",
            "#include <linux/rbtree.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ext4_extents.h\"\t/* Needed when ES_AGGRESSIVE_TEST is defined */\n#include <trace/events/ext4.h>\n#include \"extents_status.h\"\n#include \"ext4.h\"\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/list_sort.h>\n#include <linux/rbtree.h>\n\nvoid ext4_es_unregister_shrinker(struct ext4_sb_info *sbi)\n{\n\tif (sbi->s_proc)\n\t\tremove_proc_entry(\"es_shrinker_info\", sbi->s_proc);\n\tpercpu_counter_destroy(&sbi->s_es_stats.es_stats_all_cnt);\n\tpercpu_counter_destroy(&sbi->s_es_stats.es_stats_shk_cnt);\n\tunregister_shrinker(&sbi->s_es_shrinker);\n}"
        }
      },
      {
        "call_info": {
          "callee": "jbd2_journal_destroy",
          "args": [
            "sbi->s_journal"
          ],
          "line": 4277
        },
        "resolved": true,
        "details": {
          "function_name": "jbd2_journal_destroy_revoke",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd2/revoke.c",
          "lines": "293-300",
          "snippet": "void jbd2_journal_destroy_revoke(journal_t *journal)\n{\n\tjournal->j_revoke = NULL;\n\tif (journal->j_revoke_table[0])\n\t\tjbd2_journal_destroy_revoke_table(journal->j_revoke_table[0]);\n\tif (journal->j_revoke_table[1])\n\t\tjbd2_journal_destroy_revoke_table(journal->j_revoke_table[1]);\n}",
          "includes": [
            "#include <linux/hash.h>",
            "#include <linux/log2.h>",
            "#include <linux/bio.h>",
            "#include <linux/init.h>",
            "#include <linux/list.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include \"jfs_user.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/hash.h>\n#include <linux/log2.h>\n#include <linux/bio.h>\n#include <linux/init.h>\n#include <linux/list.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd2.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include \"jfs_user.h\"\n\nvoid jbd2_journal_destroy_revoke(journal_t *journal)\n{\n\tjournal->j_revoke = NULL;\n\tif (journal->j_revoke_table[0])\n\t\tjbd2_journal_destroy_revoke_table(journal->j_revoke_table[0]);\n\tif (journal->j_revoke_table[1])\n\t\tjbd2_journal_destroy_revoke_table(journal->j_revoke_table[1]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "destroy_workqueue",
          "args": [
            "EXT4_SB(sb)->rsv_conversion_wq"
          ],
          "line": 4274
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_destroy_workqueue",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/async-thread.c",
          "lines": "343-351",
          "snippet": "void btrfs_destroy_workqueue(struct btrfs_workqueue *wq)\n{\n\tif (!wq)\n\t\treturn;\n\tif (wq->high)\n\t\t__btrfs_destroy_workqueue(wq->high);\n\t__btrfs_destroy_workqueue(wq->normal);\n\tkfree(wq);\n}",
          "includes": [
            "#include \"ctree.h\"",
            "#include \"async-thread.h\"",
            "#include <linux/freezer.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/list.h>",
            "#include <linux/slab.h>",
            "#include <linux/kthread.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static inline void\n__btrfs_destroy_workqueue(struct __btrfs_workqueue *wq);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ctree.h\"\n#include \"async-thread.h\"\n#include <linux/freezer.h>\n#include <linux/spinlock.h>\n#include <linux/list.h>\n#include <linux/slab.h>\n#include <linux/kthread.h>\n\nstatic inline void\n__btrfs_destroy_workqueue(struct __btrfs_workqueue *wq);\n\nvoid btrfs_destroy_workqueue(struct btrfs_workqueue *wq)\n{\n\tif (!wq)\n\t\treturn;\n\tif (wq->high)\n\t\t__btrfs_destroy_workqueue(wq->high);\n\t__btrfs_destroy_workqueue(wq->normal);\n\tkfree(wq);\n}"
        }
      },
      {
        "call_info": {
          "callee": "EXT4_SB",
          "args": [
            "sb"
          ],
          "line": 4274
        },
        "resolved": true,
        "details": {
          "function_name": "EXT4_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ext4.h",
          "lines": "1356-1359",
          "snippet": "static inline struct ext4_sb_info *EXT4_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include \"extents_status.h\"",
            "#include <linux/compat.h>",
            "#include <linux/falloc.h>",
            "#include <crypto/hash.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/wait.h>",
            "#include <linux/timer.h>",
            "#include <linux/mutex.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/quota.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extents_status.h\"\n#include <linux/compat.h>\n#include <linux/falloc.h>\n#include <crypto/hash.h>\n#include <linux/ratelimit.h>\n#include <linux/percpu_counter.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/wait.h>\n#include <linux/timer.h>\n#include <linux/mutex.h>\n#include <linux/seqlock.h>\n#include <linux/rbtree.h>\n#include <linux/rwsem.h>\n#include <linux/quota.h>\n#include <linux/jbd2.h>\n#include <linux/magic.h>\n#include <linux/blkdev.h>\n#include <linux/types.h>\n\nstatic inline struct ext4_sb_info *EXT4_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_msg",
          "args": [
            "sb",
            "KERN_ERR",
            "\"mount failed\""
          ],
          "line": 4272
        },
        "resolved": true,
        "details": {
          "function_name": "__ext4_msg",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/super.c",
          "lines": "593-607",
          "snippet": "void __ext4_msg(struct super_block *sb,\n\t\tconst char *prefix, const char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tif (!___ratelimit(&(EXT4_SB(sb)->s_msg_ratelimit_state), \"EXT4-fs\"))\n\t\treturn;\n\n\tva_start(args, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\tprintk(\"%sEXT4-fs (%s): %pV\\n\", prefix, sb->s_id, &vaf);\n\tva_end(args);\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"mballoc.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include \"ext4_extents.h\"\t/* Needed for trace points definition */",
            "#include \"ext4.h\"",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/crc16.h>",
            "#include <linux/log2.h>",
            "#include <linux/ctype.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/random.h>",
            "#include <linux/vfs.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/parser.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/time.h>",
            "#include <linux/fs.h>",
            "#include <linux/string.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ext4_unfreeze(struct super_block *sb);",
            "static int ext4_freeze(struct super_block *sb);",
            "static inline int ext2_feature_set_ok(struct super_block *sb);",
            "static inline int ext3_feature_set_ok(struct super_block *sb);",
            "static void ext4_unregister_li_request(struct super_block *sb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"mballoc.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4_extents.h\"\t/* Needed for trace points definition */\n#include \"ext4.h\"\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <asm/uaccess.h>\n#include <linux/cleancache.h>\n#include <linux/crc16.h>\n#include <linux/log2.h>\n#include <linux/ctype.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/random.h>\n#include <linux/vfs.h>\n#include <linux/exportfs.h>\n#include <linux/buffer_head.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/jbd2.h>\n#include <linux/vmalloc.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n#include <linux/string.h>\n#include <linux/module.h>\n\nstatic int ext4_unfreeze(struct super_block *sb);\nstatic int ext4_freeze(struct super_block *sb);\nstatic inline int ext2_feature_set_ok(struct super_block *sb);\nstatic inline int ext3_feature_set_ok(struct super_block *sb);\nstatic void ext4_unregister_li_request(struct super_block *sb);\n\nvoid __ext4_msg(struct super_block *sb,\n\t\tconst char *prefix, const char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tif (!___ratelimit(&(EXT4_SB(sb)->s_msg_ratelimit_state), \"EXT4-fs\"))\n\t\treturn;\n\n\tva_start(args, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\tprintk(\"%sEXT4-fs (%s): %pV\\n\", prefix, sb->s_id, &vaf);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dput",
          "args": [
            "sb->s_root"
          ],
          "line": 4269
        },
        "resolved": true,
        "details": {
          "function_name": "dput",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "726-762",
          "snippet": "void dput(struct dentry *dentry)\n{\n\tif (unlikely(!dentry))\n\t\treturn;\n\nrepeat:\n\trcu_read_lock();\n\tif (likely(fast_dput(dentry))) {\n\t\trcu_read_unlock();\n\t\treturn;\n\t}\n\n\t/* Slow case: now with the dentry lock held */\n\trcu_read_unlock();\n\n\t/* Unreachable? Get rid of it */\n\tif (unlikely(d_unhashed(dentry)))\n\t\tgoto kill_it;\n\n\tif (unlikely(dentry->d_flags & DCACHE_OP_DELETE)) {\n\t\tif (dentry->d_op->d_delete(dentry))\n\t\t\tgoto kill_it;\n\t}\n\n\tif (!(dentry->d_flags & DCACHE_REFERENCED))\n\t\tdentry->d_flags |= DCACHE_REFERENCED;\n\tdentry_lru_add(dentry);\n\n\tdentry->d_lockref.count--;\n\tspin_unlock(&dentry->d_lock);\n\treturn;\n\nkill_it:\n\tdentry = dentry_kill(dentry);\n\tif (dentry)\n\t\tgoto repeat;\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nvoid dput(struct dentry *dentry)\n{\n\tif (unlikely(!dentry))\n\t\treturn;\n\nrepeat:\n\trcu_read_lock();\n\tif (likely(fast_dput(dentry))) {\n\t\trcu_read_unlock();\n\t\treturn;\n\t}\n\n\t/* Slow case: now with the dentry lock held */\n\trcu_read_unlock();\n\n\t/* Unreachable? Get rid of it */\n\tif (unlikely(d_unhashed(dentry)))\n\t\tgoto kill_it;\n\n\tif (unlikely(dentry->d_flags & DCACHE_OP_DELETE)) {\n\t\tif (dentry->d_op->d_delete(dentry))\n\t\t\tgoto kill_it;\n\t}\n\n\tif (!(dentry->d_flags & DCACHE_REFERENCED))\n\t\tdentry->d_flags |= DCACHE_REFERENCED;\n\tdentry_lru_add(dentry);\n\n\tdentry->d_lockref.count--;\n\tspin_unlock(&dentry->d_lock);\n\treturn;\n\nkill_it:\n\tdentry = dentry_kill(dentry);\n\tif (dentry)\n\t\tgoto repeat;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_release_system_zone",
          "args": [
            "sb"
          ],
          "line": 4267
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_release_system_zone",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/block_validity.c",
          "lines": "181-190",
          "snippet": "void ext4_release_system_zone(struct super_block *sb)\n{\n\tstruct ext4_system_zone\t*entry, *n;\n\n\trbtree_postorder_for_each_entry_safe(entry, n,\n\t\t\t&EXT4_SB(sb)->system_blks, node)\n\t\tkmem_cache_free(ext4_system_zone_cachep, entry);\n\n\tEXT4_SB(sb)->system_blks = RB_ROOT;\n}",
          "includes": [
            "#include \"ext4.h\"",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kmem_cache *ext4_system_zone_cachep;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ext4.h\"\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/blkdev.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/buffer_head.h>\n#include <linux/quotaops.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n\nstatic struct kmem_cache *ext4_system_zone_cachep;\n\nvoid ext4_release_system_zone(struct super_block *sb)\n{\n\tstruct ext4_system_zone\t*entry, *n;\n\n\trbtree_postorder_for_each_entry_safe(entry, n,\n\t\t\t&EXT4_SB(sb)->system_blks, node)\n\t\tkmem_cache_free(ext4_system_zone_cachep, entry);\n\n\tEXT4_SB(sb)->system_blks = RB_ROOT;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_ext_release",
          "args": [
            "sb"
          ],
          "line": 4266
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_ext_release",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/extents.c",
          "lines": "3087-3102",
          "snippet": "void ext4_ext_release(struct super_block *sb)\n{\n\tif (!EXT4_HAS_INCOMPAT_FEATURE(sb, EXT4_FEATURE_INCOMPAT_EXTENTS))\n\t\treturn;\n\n#ifdef EXTENTS_STATS\n\tif (EXT4_SB(sb)->s_ext_blocks && EXT4_SB(sb)->s_ext_extents) {\n\t\tstruct ext4_sb_info *sbi = EXT4_SB(sb);\n\t\tprintk(KERN_ERR \"EXT4-fs: %lu blocks in %lu extents (%lu ave)\\n\",\n\t\t\tsbi->s_ext_blocks, sbi->s_ext_extents,\n\t\t\tsbi->s_ext_blocks / sbi->s_ext_extents);\n\t\tprintk(KERN_ERR \"EXT4-fs: extents: %lu min, %lu max, max depth %lu\\n\",\n\t\t\tsbi->s_ext_min, sbi->s_ext_max, sbi->s_depth_max);\n\t}\n#endif\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"xattr.h\"",
            "#include \"ext4_extents.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include <linux/fiemap.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/string.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highuid.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/time.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"xattr.h\"\n#include \"ext4_extents.h\"\n#include \"ext4_jbd2.h\"\n#include <linux/fiemap.h>\n#include <asm/uaccess.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/highuid.h>\n#include <linux/jbd2.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n\nvoid ext4_ext_release(struct super_block *sb)\n{\n\tif (!EXT4_HAS_INCOMPAT_FEATURE(sb, EXT4_FEATURE_INCOMPAT_EXTENTS))\n\t\treturn;\n\n#ifdef EXTENTS_STATS\n\tif (EXT4_SB(sb)->s_ext_blocks && EXT4_SB(sb)->s_ext_extents) {\n\t\tstruct ext4_sb_info *sbi = EXT4_SB(sb);\n\t\tprintk(KERN_ERR \"EXT4-fs: %lu blocks in %lu extents (%lu ave)\\n\",\n\t\t\tsbi->s_ext_blocks, sbi->s_ext_extents,\n\t\t\tsbi->s_ext_blocks / sbi->s_ext_extents);\n\t\tprintk(KERN_ERR \"EXT4-fs: extents: %lu min, %lu max, max depth %lu\\n\",\n\t\t\tsbi->s_ext_min, sbi->s_ext_max, sbi->s_depth_max);\n\t}\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "percpu_counter_destroy",
          "args": [
            "&sbi->s_dirtyclusters_counter"
          ],
          "line": 4264
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "percpu_counter_destroy",
          "args": [
            "&sbi->s_dirs_counter"
          ],
          "line": 4263
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "percpu_counter_destroy",
          "args": [
            "&sbi->s_freeinodes_counter"
          ],
          "line": 4262
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "percpu_counter_destroy",
          "args": [
            "&sbi->s_freeclusters_counter"
          ],
          "line": 4261
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvfree",
          "args": [
            "sbi->s_flex_groups"
          ],
          "line": 4260
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_mb_release",
          "args": [
            "sb"
          ],
          "line": 4258
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_mb_release_context",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/mballoc.c",
          "lines": "4329-4367",
          "snippet": "static int ext4_mb_release_context(struct ext4_allocation_context *ac)\n{\n\tstruct ext4_sb_info *sbi = EXT4_SB(ac->ac_sb);\n\tstruct ext4_prealloc_space *pa = ac->ac_pa;\n\tif (pa) {\n\t\tif (pa->pa_type == MB_GROUP_PA) {\n\t\t\t/* see comment in ext4_mb_use_group_pa() */\n\t\t\tspin_lock(&pa->pa_lock);\n\t\t\tpa->pa_pstart += EXT4_C2B(sbi, ac->ac_b_ex.fe_len);\n\t\t\tpa->pa_lstart += EXT4_C2B(sbi, ac->ac_b_ex.fe_len);\n\t\t\tpa->pa_free -= ac->ac_b_ex.fe_len;\n\t\t\tpa->pa_len -= ac->ac_b_ex.fe_len;\n\t\t\tspin_unlock(&pa->pa_lock);\n\t\t}\n\t}\n\tif (pa) {\n\t\t/*\n\t\t * We want to add the pa to the right bucket.\n\t\t * Remove it from the list and while adding\n\t\t * make sure the list to which we are adding\n\t\t * doesn't grow big.\n\t\t */\n\t\tif ((pa->pa_type == MB_GROUP_PA) && likely(pa->pa_free)) {\n\t\t\tspin_lock(pa->pa_obj_lock);\n\t\t\tlist_del_rcu(&pa->pa_inode_list);\n\t\t\tspin_unlock(pa->pa_obj_lock);\n\t\t\text4_mb_add_n_trim(ac);\n\t\t}\n\t\text4_mb_put_pa(ac, ac->ac_sb, pa);\n\t}\n\tif (ac->ac_bitmap_page)\n\t\tpage_cache_release(ac->ac_bitmap_page);\n\tif (ac->ac_buddy_page)\n\t\tpage_cache_release(ac->ac_buddy_page);\n\tif (ac->ac_flags & EXT4_MB_HINT_GROUP_ALLOC)\n\t\tmutex_unlock(&ac->ac_lg->lg_mutex);\n\text4_mb_collect_stats(ac);\n\treturn 0;\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/log2.h>",
            "#include \"mballoc.h\"",
            "#include \"ext4_jbd2.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/log2.h>\n#include \"mballoc.h\"\n#include \"ext4_jbd2.h\"\n\nstatic int ext4_mb_release_context(struct ext4_allocation_context *ac)\n{\n\tstruct ext4_sb_info *sbi = EXT4_SB(ac->ac_sb);\n\tstruct ext4_prealloc_space *pa = ac->ac_pa;\n\tif (pa) {\n\t\tif (pa->pa_type == MB_GROUP_PA) {\n\t\t\t/* see comment in ext4_mb_use_group_pa() */\n\t\t\tspin_lock(&pa->pa_lock);\n\t\t\tpa->pa_pstart += EXT4_C2B(sbi, ac->ac_b_ex.fe_len);\n\t\t\tpa->pa_lstart += EXT4_C2B(sbi, ac->ac_b_ex.fe_len);\n\t\t\tpa->pa_free -= ac->ac_b_ex.fe_len;\n\t\t\tpa->pa_len -= ac->ac_b_ex.fe_len;\n\t\t\tspin_unlock(&pa->pa_lock);\n\t\t}\n\t}\n\tif (pa) {\n\t\t/*\n\t\t * We want to add the pa to the right bucket.\n\t\t * Remove it from the list and while adding\n\t\t * make sure the list to which we are adding\n\t\t * doesn't grow big.\n\t\t */\n\t\tif ((pa->pa_type == MB_GROUP_PA) && likely(pa->pa_free)) {\n\t\t\tspin_lock(pa->pa_obj_lock);\n\t\t\tlist_del_rcu(&pa->pa_inode_list);\n\t\t\tspin_unlock(pa->pa_obj_lock);\n\t\t\text4_mb_add_n_trim(ac);\n\t\t}\n\t\text4_mb_put_pa(ac, ac->ac_sb, pa);\n\t}\n\tif (ac->ac_bitmap_page)\n\t\tpage_cache_release(ac->ac_bitmap_page);\n\tif (ac->ac_buddy_page)\n\t\tpage_cache_release(ac->ac_buddy_page);\n\tif (ac->ac_flags & EXT4_MB_HINT_GROUP_ALLOC)\n\t\tmutex_unlock(&ac->ac_lg->lg_mutex);\n\text4_mb_collect_stats(ac);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_unregister_li_request",
          "args": [
            "sb"
          ],
          "line": 4256
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_unregister_li_request",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/super.c",
          "lines": "2938-2950",
          "snippet": "static void ext4_unregister_li_request(struct super_block *sb)\n{\n\tmutex_lock(&ext4_li_mtx);\n\tif (!ext4_li_info) {\n\t\tmutex_unlock(&ext4_li_mtx);\n\t\treturn;\n\t}\n\n\tmutex_lock(&ext4_li_info->li_list_mtx);\n\text4_remove_li_request(EXT4_SB(sb)->s_li_request);\n\tmutex_unlock(&ext4_li_info->li_list_mtx);\n\tmutex_unlock(&ext4_li_mtx);\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"mballoc.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include \"ext4_extents.h\"\t/* Needed for trace points definition */",
            "#include \"ext4.h\"",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/crc16.h>",
            "#include <linux/log2.h>",
            "#include <linux/ctype.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/random.h>",
            "#include <linux/vfs.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/parser.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/time.h>",
            "#include <linux/fs.h>",
            "#include <linux/string.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct ext4_lazy_init *ext4_li_info;",
            "static struct mutex ext4_li_mtx;",
            "static int ext4_unfreeze(struct super_block *sb);",
            "static int ext4_freeze(struct super_block *sb);",
            "static inline int ext2_feature_set_ok(struct super_block *sb);",
            "static inline int ext3_feature_set_ok(struct super_block *sb);",
            "static void ext4_unregister_li_request(struct super_block *sb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"mballoc.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4_extents.h\"\t/* Needed for trace points definition */\n#include \"ext4.h\"\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <asm/uaccess.h>\n#include <linux/cleancache.h>\n#include <linux/crc16.h>\n#include <linux/log2.h>\n#include <linux/ctype.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/random.h>\n#include <linux/vfs.h>\n#include <linux/exportfs.h>\n#include <linux/buffer_head.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/jbd2.h>\n#include <linux/vmalloc.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n#include <linux/string.h>\n#include <linux/module.h>\n\nstatic struct ext4_lazy_init *ext4_li_info;\nstatic struct mutex ext4_li_mtx;\nstatic int ext4_unfreeze(struct super_block *sb);\nstatic int ext4_freeze(struct super_block *sb);\nstatic inline int ext2_feature_set_ok(struct super_block *sb);\nstatic inline int ext3_feature_set_ok(struct super_block *sb);\nstatic void ext4_unregister_li_request(struct super_block *sb);\n\nstatic void ext4_unregister_li_request(struct super_block *sb)\n{\n\tmutex_lock(&ext4_li_mtx);\n\tif (!ext4_li_info) {\n\t\tmutex_unlock(&ext4_li_mtx);\n\t\treturn;\n\t}\n\n\tmutex_lock(&ext4_li_info->li_list_mtx);\n\text4_remove_li_request(EXT4_SB(sb)->s_li_request);\n\tmutex_unlock(&ext4_li_info->li_list_mtx);\n\tmutex_unlock(&ext4_li_mtx);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kobject_del",
          "args": [
            "&sbi->s_kobj"
          ],
          "line": 4253
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "orig_data"
          ],
          "line": 4243
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ratelimit_state_init",
          "args": [
            "&sbi->s_msg_ratelimit_state",
            "5 * HZ",
            "10"
          ],
          "line": 4241
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ratelimit_state_init",
          "args": [
            "&sbi->s_warning_ratelimit_state",
            "5 * HZ",
            "10"
          ],
          "line": 4240
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ratelimit_state_init",
          "args": [
            "&sbi->s_err_ratelimit_state",
            "5 * HZ",
            "10"
          ],
          "line": 4239
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mod_timer",
          "args": [
            "&sbi->s_err_report",
            "jiffies + 300*HZ"
          ],
          "line": 4236
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "blk_queue_discard",
          "args": [
            "q"
          ],
          "line": 4225
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bdev_get_queue",
          "args": [
            "sb->s_bdev"
          ],
          "line": 4224
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_opt",
          "args": [
            "sb",
            "DISCARD"
          ],
          "line": 4223
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_opt",
          "args": [
            "sb",
            "DATA_FLAGS"
          ],
          "line": 4216
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_opt",
          "args": [
            "sb",
            "DATA_FLAGS"
          ],
          "line": 4214
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_mark_recovery_complete",
          "args": [
            "sb",
            "es"
          ],
          "line": 4211
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_mark_recovery_complete",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/super.c",
          "lines": "4641-4662",
          "snippet": "static void ext4_mark_recovery_complete(struct super_block *sb,\n\t\t\t\t\tstruct ext4_super_block *es)\n{\n\tjournal_t *journal = EXT4_SB(sb)->s_journal;\n\n\tif (!EXT4_HAS_COMPAT_FEATURE(sb, EXT4_FEATURE_COMPAT_HAS_JOURNAL)) {\n\t\tBUG_ON(journal != NULL);\n\t\treturn;\n\t}\n\tjbd2_journal_lock_updates(journal);\n\tif (jbd2_journal_flush(journal) < 0)\n\t\tgoto out;\n\n\tif (EXT4_HAS_INCOMPAT_FEATURE(sb, EXT4_FEATURE_INCOMPAT_RECOVER) &&\n\t    sb->s_flags & MS_RDONLY) {\n\t\tEXT4_CLEAR_INCOMPAT_FEATURE(sb, EXT4_FEATURE_INCOMPAT_RECOVER);\n\t\text4_commit_super(sb, 1);\n\t}\n\nout:\n\tjbd2_journal_unlock_updates(journal);\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"mballoc.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include \"ext4_extents.h\"\t/* Needed for trace points definition */",
            "#include \"ext4.h\"",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/crc16.h>",
            "#include <linux/log2.h>",
            "#include <linux/ctype.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/random.h>",
            "#include <linux/vfs.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/parser.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/time.h>",
            "#include <linux/fs.h>",
            "#include <linux/string.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void ext4_mark_recovery_complete(struct super_block *sb,\n\t\t\t\t\tstruct ext4_super_block *es);",
            "static void ext4_clear_journal_err(struct super_block *sb,\n\t\t\t\t   struct ext4_super_block *es);",
            "static int ext4_unfreeze(struct super_block *sb);",
            "static int ext4_freeze(struct super_block *sb);",
            "static inline int ext2_feature_set_ok(struct super_block *sb);",
            "static inline int ext3_feature_set_ok(struct super_block *sb);",
            "static void ext4_unregister_li_request(struct super_block *sb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"mballoc.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4_extents.h\"\t/* Needed for trace points definition */\n#include \"ext4.h\"\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <asm/uaccess.h>\n#include <linux/cleancache.h>\n#include <linux/crc16.h>\n#include <linux/log2.h>\n#include <linux/ctype.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/random.h>\n#include <linux/vfs.h>\n#include <linux/exportfs.h>\n#include <linux/buffer_head.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/jbd2.h>\n#include <linux/vmalloc.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n#include <linux/string.h>\n#include <linux/module.h>\n\nstatic void ext4_mark_recovery_complete(struct super_block *sb,\n\t\t\t\t\tstruct ext4_super_block *es);\nstatic void ext4_clear_journal_err(struct super_block *sb,\n\t\t\t\t   struct ext4_super_block *es);\nstatic int ext4_unfreeze(struct super_block *sb);\nstatic int ext4_freeze(struct super_block *sb);\nstatic inline int ext2_feature_set_ok(struct super_block *sb);\nstatic inline int ext3_feature_set_ok(struct super_block *sb);\nstatic void ext4_unregister_li_request(struct super_block *sb);\n\nstatic void ext4_mark_recovery_complete(struct super_block *sb,\n\t\t\t\t\tstruct ext4_super_block *es)\n{\n\tjournal_t *journal = EXT4_SB(sb)->s_journal;\n\n\tif (!EXT4_HAS_COMPAT_FEATURE(sb, EXT4_FEATURE_COMPAT_HAS_JOURNAL)) {\n\t\tBUG_ON(journal != NULL);\n\t\treturn;\n\t}\n\tjbd2_journal_lock_updates(journal);\n\tif (jbd2_journal_flush(journal) < 0)\n\t\tgoto out;\n\n\tif (EXT4_HAS_INCOMPAT_FEATURE(sb, EXT4_FEATURE_INCOMPAT_RECOVER) &&\n\t    sb->s_flags & MS_RDONLY) {\n\t\tEXT4_CLEAR_INCOMPAT_FEATURE(sb, EXT4_FEATURE_INCOMPAT_RECOVER);\n\t\text4_commit_super(sb, 1);\n\t}\n\nout:\n\tjbd2_journal_unlock_updates(journal);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_orphan_cleanup",
          "args": [
            "sb",
            "es"
          ],
          "line": 4207
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_orphan_cleanup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/super.c",
          "lines": "2148-2255",
          "snippet": "static void ext4_orphan_cleanup(struct super_block *sb,\n\t\t\t\tstruct ext4_super_block *es)\n{\n\tunsigned int s_flags = sb->s_flags;\n\tint nr_orphans = 0, nr_truncates = 0;\n#ifdef CONFIG_QUOTA\n\tint i;\n#endif\n\tif (!es->s_last_orphan) {\n\t\tjbd_debug(4, \"no orphan inodes to clean up\\n\");\n\t\treturn;\n\t}\n\n\tif (bdev_read_only(sb->s_bdev)) {\n\t\text4_msg(sb, KERN_ERR, \"write access \"\n\t\t\t\"unavailable, skipping orphan cleanup\");\n\t\treturn;\n\t}\n\n\t/* Check if feature set would not allow a r/w mount */\n\tif (!ext4_feature_set_ok(sb, 0)) {\n\t\text4_msg(sb, KERN_INFO, \"Skipping orphan cleanup due to \"\n\t\t\t \"unknown ROCOMPAT features\");\n\t\treturn;\n\t}\n\n\tif (EXT4_SB(sb)->s_mount_state & EXT4_ERROR_FS) {\n\t\t/* don't clear list on RO mount w/ errors */\n\t\tif (es->s_last_orphan && !(s_flags & MS_RDONLY)) {\n\t\t\text4_msg(sb, KERN_INFO, \"Errors on filesystem, \"\n\t\t\t\t  \"clearing orphan list.\\n\");\n\t\t\tes->s_last_orphan = 0;\n\t\t}\n\t\tjbd_debug(1, \"Skipping orphan recovery on fs with errors.\\n\");\n\t\treturn;\n\t}\n\n\tif (s_flags & MS_RDONLY) {\n\t\text4_msg(sb, KERN_INFO, \"orphan cleanup on readonly fs\");\n\t\tsb->s_flags &= ~MS_RDONLY;\n\t}\n#ifdef CONFIG_QUOTA\n\t/* Needed for iput() to work correctly and not trash data */\n\tsb->s_flags |= MS_ACTIVE;\n\t/* Turn on quotas so that they are updated correctly */\n\tfor (i = 0; i < EXT4_MAXQUOTAS; i++) {\n\t\tif (EXT4_SB(sb)->s_qf_names[i]) {\n\t\t\tint ret = ext4_quota_on_mount(sb, i);\n\t\t\tif (ret < 0)\n\t\t\t\text4_msg(sb, KERN_ERR,\n\t\t\t\t\t\"Cannot turn on journaled \"\n\t\t\t\t\t\"quota: error %d\", ret);\n\t\t}\n\t}\n#endif\n\n\twhile (es->s_last_orphan) {\n\t\tstruct inode *inode;\n\n\t\tinode = ext4_orphan_get(sb, le32_to_cpu(es->s_last_orphan));\n\t\tif (IS_ERR(inode)) {\n\t\t\tes->s_last_orphan = 0;\n\t\t\tbreak;\n\t\t}\n\n\t\tlist_add(&EXT4_I(inode)->i_orphan, &EXT4_SB(sb)->s_orphan);\n\t\tdquot_initialize(inode);\n\t\tif (inode->i_nlink) {\n\t\t\tif (test_opt(sb, DEBUG))\n\t\t\t\text4_msg(sb, KERN_DEBUG,\n\t\t\t\t\t\"%s: truncating inode %lu to %lld bytes\",\n\t\t\t\t\t__func__, inode->i_ino, inode->i_size);\n\t\t\tjbd_debug(2, \"truncating inode %lu to %lld bytes\\n\",\n\t\t\t\t  inode->i_ino, inode->i_size);\n\t\t\tmutex_lock(&inode->i_mutex);\n\t\t\ttruncate_inode_pages(inode->i_mapping, inode->i_size);\n\t\t\text4_truncate(inode);\n\t\t\tmutex_unlock(&inode->i_mutex);\n\t\t\tnr_truncates++;\n\t\t} else {\n\t\t\tif (test_opt(sb, DEBUG))\n\t\t\t\text4_msg(sb, KERN_DEBUG,\n\t\t\t\t\t\"%s: deleting unreferenced inode %lu\",\n\t\t\t\t\t__func__, inode->i_ino);\n\t\t\tjbd_debug(2, \"deleting unreferenced inode %lu\\n\",\n\t\t\t\t  inode->i_ino);\n\t\t\tnr_orphans++;\n\t\t}\n\t\tiput(inode);  /* The delete magic happens here! */\n\t}\n\n#define PLURAL(x) (x), ((x) == 1) ? \"\" : \"s\"\n\n\tif (nr_orphans)\n\t\text4_msg(sb, KERN_INFO, \"%d orphan inode%s deleted\",\n\t\t       PLURAL(nr_orphans));\n\tif (nr_truncates)\n\t\text4_msg(sb, KERN_INFO, \"%d truncate%s cleaned up\",\n\t\t       PLURAL(nr_truncates));\n#ifdef CONFIG_QUOTA\n\t/* Turn quotas off */\n\tfor (i = 0; i < EXT4_MAXQUOTAS; i++) {\n\t\tif (sb_dqopt(sb)->files[i])\n\t\t\tdquot_quota_off(sb, i);\n\t}\n#endif\n\tsb->s_flags = s_flags; /* Restore MS_RDONLY status */\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"mballoc.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include \"ext4_extents.h\"\t/* Needed for trace points definition */",
            "#include \"ext4.h\"",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/crc16.h>",
            "#include <linux/log2.h>",
            "#include <linux/ctype.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/random.h>",
            "#include <linux/vfs.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/parser.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/time.h>",
            "#include <linux/fs.h>",
            "#include <linux/string.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void ext4_mark_recovery_complete(struct super_block *sb,\n\t\t\t\t\tstruct ext4_super_block *es);",
            "static void ext4_clear_journal_err(struct super_block *sb,\n\t\t\t\t   struct ext4_super_block *es);",
            "static int ext4_remount(struct super_block *sb, int *flags, char *data);",
            "static int ext4_unfreeze(struct super_block *sb);",
            "static int ext4_freeze(struct super_block *sb);",
            "static struct dentry *ext4_mount(struct file_system_type *fs_type, int flags,\n\t\t       const char *dev_name, void *data);",
            "static inline int ext2_feature_set_ok(struct super_block *sb);",
            "static inline int ext3_feature_set_ok(struct super_block *sb);",
            "static int ext4_feature_set_ok(struct super_block *sb, int readonly);",
            "static void ext4_unregister_li_request(struct super_block *sb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"mballoc.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4_extents.h\"\t/* Needed for trace points definition */\n#include \"ext4.h\"\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <asm/uaccess.h>\n#include <linux/cleancache.h>\n#include <linux/crc16.h>\n#include <linux/log2.h>\n#include <linux/ctype.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/random.h>\n#include <linux/vfs.h>\n#include <linux/exportfs.h>\n#include <linux/buffer_head.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/jbd2.h>\n#include <linux/vmalloc.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n#include <linux/string.h>\n#include <linux/module.h>\n\nstatic void ext4_mark_recovery_complete(struct super_block *sb,\n\t\t\t\t\tstruct ext4_super_block *es);\nstatic void ext4_clear_journal_err(struct super_block *sb,\n\t\t\t\t   struct ext4_super_block *es);\nstatic int ext4_remount(struct super_block *sb, int *flags, char *data);\nstatic int ext4_unfreeze(struct super_block *sb);\nstatic int ext4_freeze(struct super_block *sb);\nstatic struct dentry *ext4_mount(struct file_system_type *fs_type, int flags,\n\t\t       const char *dev_name, void *data);\nstatic inline int ext2_feature_set_ok(struct super_block *sb);\nstatic inline int ext3_feature_set_ok(struct super_block *sb);\nstatic int ext4_feature_set_ok(struct super_block *sb, int readonly);\nstatic void ext4_unregister_li_request(struct super_block *sb);\n\nstatic void ext4_orphan_cleanup(struct super_block *sb,\n\t\t\t\tstruct ext4_super_block *es)\n{\n\tunsigned int s_flags = sb->s_flags;\n\tint nr_orphans = 0, nr_truncates = 0;\n#ifdef CONFIG_QUOTA\n\tint i;\n#endif\n\tif (!es->s_last_orphan) {\n\t\tjbd_debug(4, \"no orphan inodes to clean up\\n\");\n\t\treturn;\n\t}\n\n\tif (bdev_read_only(sb->s_bdev)) {\n\t\text4_msg(sb, KERN_ERR, \"write access \"\n\t\t\t\"unavailable, skipping orphan cleanup\");\n\t\treturn;\n\t}\n\n\t/* Check if feature set would not allow a r/w mount */\n\tif (!ext4_feature_set_ok(sb, 0)) {\n\t\text4_msg(sb, KERN_INFO, \"Skipping orphan cleanup due to \"\n\t\t\t \"unknown ROCOMPAT features\");\n\t\treturn;\n\t}\n\n\tif (EXT4_SB(sb)->s_mount_state & EXT4_ERROR_FS) {\n\t\t/* don't clear list on RO mount w/ errors */\n\t\tif (es->s_last_orphan && !(s_flags & MS_RDONLY)) {\n\t\t\text4_msg(sb, KERN_INFO, \"Errors on filesystem, \"\n\t\t\t\t  \"clearing orphan list.\\n\");\n\t\t\tes->s_last_orphan = 0;\n\t\t}\n\t\tjbd_debug(1, \"Skipping orphan recovery on fs with errors.\\n\");\n\t\treturn;\n\t}\n\n\tif (s_flags & MS_RDONLY) {\n\t\text4_msg(sb, KERN_INFO, \"orphan cleanup on readonly fs\");\n\t\tsb->s_flags &= ~MS_RDONLY;\n\t}\n#ifdef CONFIG_QUOTA\n\t/* Needed for iput() to work correctly and not trash data */\n\tsb->s_flags |= MS_ACTIVE;\n\t/* Turn on quotas so that they are updated correctly */\n\tfor (i = 0; i < EXT4_MAXQUOTAS; i++) {\n\t\tif (EXT4_SB(sb)->s_qf_names[i]) {\n\t\t\tint ret = ext4_quota_on_mount(sb, i);\n\t\t\tif (ret < 0)\n\t\t\t\text4_msg(sb, KERN_ERR,\n\t\t\t\t\t\"Cannot turn on journaled \"\n\t\t\t\t\t\"quota: error %d\", ret);\n\t\t}\n\t}\n#endif\n\n\twhile (es->s_last_orphan) {\n\t\tstruct inode *inode;\n\n\t\tinode = ext4_orphan_get(sb, le32_to_cpu(es->s_last_orphan));\n\t\tif (IS_ERR(inode)) {\n\t\t\tes->s_last_orphan = 0;\n\t\t\tbreak;\n\t\t}\n\n\t\tlist_add(&EXT4_I(inode)->i_orphan, &EXT4_SB(sb)->s_orphan);\n\t\tdquot_initialize(inode);\n\t\tif (inode->i_nlink) {\n\t\t\tif (test_opt(sb, DEBUG))\n\t\t\t\text4_msg(sb, KERN_DEBUG,\n\t\t\t\t\t\"%s: truncating inode %lu to %lld bytes\",\n\t\t\t\t\t__func__, inode->i_ino, inode->i_size);\n\t\t\tjbd_debug(2, \"truncating inode %lu to %lld bytes\\n\",\n\t\t\t\t  inode->i_ino, inode->i_size);\n\t\t\tmutex_lock(&inode->i_mutex);\n\t\t\ttruncate_inode_pages(inode->i_mapping, inode->i_size);\n\t\t\text4_truncate(inode);\n\t\t\tmutex_unlock(&inode->i_mutex);\n\t\t\tnr_truncates++;\n\t\t} else {\n\t\t\tif (test_opt(sb, DEBUG))\n\t\t\t\text4_msg(sb, KERN_DEBUG,\n\t\t\t\t\t\"%s: deleting unreferenced inode %lu\",\n\t\t\t\t\t__func__, inode->i_ino);\n\t\t\tjbd_debug(2, \"deleting unreferenced inode %lu\\n\",\n\t\t\t\t  inode->i_ino);\n\t\t\tnr_orphans++;\n\t\t}\n\t\tiput(inode);  /* The delete magic happens here! */\n\t}\n\n#define PLURAL(x) (x), ((x) == 1) ? \"\" : \"s\"\n\n\tif (nr_orphans)\n\t\text4_msg(sb, KERN_INFO, \"%d orphan inode%s deleted\",\n\t\t       PLURAL(nr_orphans));\n\tif (nr_truncates)\n\t\text4_msg(sb, KERN_INFO, \"%d truncate%s cleaned up\",\n\t\t       PLURAL(nr_truncates));\n#ifdef CONFIG_QUOTA\n\t/* Turn quotas off */\n\tfor (i = 0; i < EXT4_MAXQUOTAS; i++) {\n\t\tif (sb_dqopt(sb)->files[i])\n\t\t\tdquot_quota_off(sb, i);\n\t}\n#endif\n\tsb->s_flags = s_flags; /* Restore MS_RDONLY status */\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_enable_quotas",
          "args": [
            "sb"
          ],
          "line": 4200
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_enable_quotas",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/super.c",
          "lines": "5295-5318",
          "snippet": "static int ext4_enable_quotas(struct super_block *sb)\n{\n\tint type, err = 0;\n\tunsigned long qf_inums[EXT4_MAXQUOTAS] = {\n\t\tle32_to_cpu(EXT4_SB(sb)->s_es->s_usr_quota_inum),\n\t\tle32_to_cpu(EXT4_SB(sb)->s_es->s_grp_quota_inum)\n\t};\n\n\tsb_dqopt(sb)->flags |= DQUOT_QUOTA_SYS_FILE;\n\tfor (type = 0; type < EXT4_MAXQUOTAS; type++) {\n\t\tif (qf_inums[type]) {\n\t\t\terr = ext4_quota_enable(sb, type, QFMT_VFS_V1,\n\t\t\t\t\t\tDQUOT_USAGE_ENABLED);\n\t\t\tif (err) {\n\t\t\t\text4_warning(sb,\n\t\t\t\t\t\"Failed to enable quota tracking \"\n\t\t\t\t\t\"(type=%d, err=%d). Please run \"\n\t\t\t\t\t\"e2fsck to fix.\", type, err);\n\t\t\t\treturn err;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"mballoc.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include \"ext4_extents.h\"\t/* Needed for trace points definition */",
            "#include \"ext4.h\"",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/crc16.h>",
            "#include <linux/log2.h>",
            "#include <linux/ctype.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/random.h>",
            "#include <linux/vfs.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/parser.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/time.h>",
            "#include <linux/fs.h>",
            "#include <linux/string.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ext4_unfreeze(struct super_block *sb);",
            "static int ext4_freeze(struct super_block *sb);",
            "static inline int ext2_feature_set_ok(struct super_block *sb);",
            "static inline int ext3_feature_set_ok(struct super_block *sb);",
            "static void ext4_unregister_li_request(struct super_block *sb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"mballoc.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4_extents.h\"\t/* Needed for trace points definition */\n#include \"ext4.h\"\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <asm/uaccess.h>\n#include <linux/cleancache.h>\n#include <linux/crc16.h>\n#include <linux/log2.h>\n#include <linux/ctype.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/random.h>\n#include <linux/vfs.h>\n#include <linux/exportfs.h>\n#include <linux/buffer_head.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/jbd2.h>\n#include <linux/vmalloc.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n#include <linux/string.h>\n#include <linux/module.h>\n\nstatic int ext4_unfreeze(struct super_block *sb);\nstatic int ext4_freeze(struct super_block *sb);\nstatic inline int ext2_feature_set_ok(struct super_block *sb);\nstatic inline int ext3_feature_set_ok(struct super_block *sb);\nstatic void ext4_unregister_li_request(struct super_block *sb);\n\nstatic int ext4_enable_quotas(struct super_block *sb)\n{\n\tint type, err = 0;\n\tunsigned long qf_inums[EXT4_MAXQUOTAS] = {\n\t\tle32_to_cpu(EXT4_SB(sb)->s_es->s_usr_quota_inum),\n\t\tle32_to_cpu(EXT4_SB(sb)->s_es->s_grp_quota_inum)\n\t};\n\n\tsb_dqopt(sb)->flags |= DQUOT_QUOTA_SYS_FILE;\n\tfor (type = 0; type < EXT4_MAXQUOTAS; type++) {\n\t\tif (qf_inums[type]) {\n\t\t\terr = ext4_quota_enable(sb, type, QFMT_VFS_V1,\n\t\t\t\t\t\tDQUOT_USAGE_ENABLED);\n\t\t\tif (err) {\n\t\t\t\text4_warning(sb,\n\t\t\t\t\t\"Failed to enable quota tracking \"\n\t\t\t\t\t\"(type=%d, err=%d). Please run \"\n\t\t\t\t\t\"e2fsck to fix.\", type, err);\n\t\t\t\treturn err;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "EXT4_HAS_RO_COMPAT_FEATURE",
          "args": [
            "sb",
            "EXT4_FEATURE_RO_COMPAT_QUOTA"
          ],
          "line": 4198
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kobject_init_and_add",
          "args": [
            "&sbi->s_kobj",
            "&ext4_ktype",
            "NULL",
            "\"%s\"",
            "sb->s_id"
          ],
          "line": 4191
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "init_completion",
          "args": [
            "&sbi->s_kobj_unregister"
          ],
          "line": 4190
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_register_li_request",
          "args": [
            "sb",
            "first_not_zeroed"
          ],
          "line": 4185
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_register_li_request",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/super.c",
          "lines": "3137-3194",
          "snippet": "int ext4_register_li_request(struct super_block *sb,\n\t\t\t     ext4_group_t first_not_zeroed)\n{\n\tstruct ext4_sb_info *sbi = EXT4_SB(sb);\n\tstruct ext4_li_request *elr = NULL;\n\text4_group_t ngroups = EXT4_SB(sb)->s_groups_count;\n\tint ret = 0;\n\n\tmutex_lock(&ext4_li_mtx);\n\tif (sbi->s_li_request != NULL) {\n\t\t/*\n\t\t * Reset timeout so it can be computed again, because\n\t\t * s_li_wait_mult might have changed.\n\t\t */\n\t\tsbi->s_li_request->lr_timeout = 0;\n\t\tgoto out;\n\t}\n\n\tif (first_not_zeroed == ngroups ||\n\t    (sb->s_flags & MS_RDONLY) ||\n\t    !test_opt(sb, INIT_INODE_TABLE))\n\t\tgoto out;\n\n\telr = ext4_li_request_new(sb, first_not_zeroed);\n\tif (!elr) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tif (NULL == ext4_li_info) {\n\t\tret = ext4_li_info_new();\n\t\tif (ret)\n\t\t\tgoto out;\n\t}\n\n\tmutex_lock(&ext4_li_info->li_list_mtx);\n\tlist_add(&elr->lr_request, &ext4_li_info->li_request_list);\n\tmutex_unlock(&ext4_li_info->li_list_mtx);\n\n\tsbi->s_li_request = elr;\n\t/*\n\t * set elr to NULL here since it has been inserted to\n\t * the request_list and the removal and free of it is\n\t * handled by ext4_clear_request_list from now on.\n\t */\n\telr = NULL;\n\n\tif (!(ext4_li_info->li_state & EXT4_LAZYINIT_RUNNING)) {\n\t\tret = ext4_run_lazyinit_thread();\n\t\tif (ret)\n\t\t\tgoto out;\n\t}\nout:\n\tmutex_unlock(&ext4_li_mtx);\n\tif (ret)\n\t\tkfree(elr);\n\treturn ret;\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"mballoc.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include \"ext4_extents.h\"\t/* Needed for trace points definition */",
            "#include \"ext4.h\"",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/crc16.h>",
            "#include <linux/log2.h>",
            "#include <linux/ctype.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/random.h>",
            "#include <linux/vfs.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/parser.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/time.h>",
            "#include <linux/fs.h>",
            "#include <linux/string.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct ext4_lazy_init *ext4_li_info;",
            "static struct mutex ext4_li_mtx;",
            "static int ext4_unfreeze(struct super_block *sb);",
            "static int ext4_freeze(struct super_block *sb);",
            "static inline int ext2_feature_set_ok(struct super_block *sb);",
            "static inline int ext3_feature_set_ok(struct super_block *sb);",
            "static void ext4_unregister_li_request(struct super_block *sb);",
            "static void ext4_clear_request_list(void);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"mballoc.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4_extents.h\"\t/* Needed for trace points definition */\n#include \"ext4.h\"\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <asm/uaccess.h>\n#include <linux/cleancache.h>\n#include <linux/crc16.h>\n#include <linux/log2.h>\n#include <linux/ctype.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/random.h>\n#include <linux/vfs.h>\n#include <linux/exportfs.h>\n#include <linux/buffer_head.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/jbd2.h>\n#include <linux/vmalloc.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n#include <linux/string.h>\n#include <linux/module.h>\n\nstatic struct ext4_lazy_init *ext4_li_info;\nstatic struct mutex ext4_li_mtx;\nstatic int ext4_unfreeze(struct super_block *sb);\nstatic int ext4_freeze(struct super_block *sb);\nstatic inline int ext2_feature_set_ok(struct super_block *sb);\nstatic inline int ext3_feature_set_ok(struct super_block *sb);\nstatic void ext4_unregister_li_request(struct super_block *sb);\nstatic void ext4_clear_request_list(void);\n\nint ext4_register_li_request(struct super_block *sb,\n\t\t\t     ext4_group_t first_not_zeroed)\n{\n\tstruct ext4_sb_info *sbi = EXT4_SB(sb);\n\tstruct ext4_li_request *elr = NULL;\n\text4_group_t ngroups = EXT4_SB(sb)->s_groups_count;\n\tint ret = 0;\n\n\tmutex_lock(&ext4_li_mtx);\n\tif (sbi->s_li_request != NULL) {\n\t\t/*\n\t\t * Reset timeout so it can be computed again, because\n\t\t * s_li_wait_mult might have changed.\n\t\t */\n\t\tsbi->s_li_request->lr_timeout = 0;\n\t\tgoto out;\n\t}\n\n\tif (first_not_zeroed == ngroups ||\n\t    (sb->s_flags & MS_RDONLY) ||\n\t    !test_opt(sb, INIT_INODE_TABLE))\n\t\tgoto out;\n\n\telr = ext4_li_request_new(sb, first_not_zeroed);\n\tif (!elr) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tif (NULL == ext4_li_info) {\n\t\tret = ext4_li_info_new();\n\t\tif (ret)\n\t\t\tgoto out;\n\t}\n\n\tmutex_lock(&ext4_li_info->li_list_mtx);\n\tlist_add(&elr->lr_request, &ext4_li_info->li_request_list);\n\tmutex_unlock(&ext4_li_info->li_list_mtx);\n\n\tsbi->s_li_request = elr;\n\t/*\n\t * set elr to NULL here since it has been inserted to\n\t * the request_list and the removal and free of it is\n\t * handled by ext4_clear_request_list from now on.\n\t */\n\telr = NULL;\n\n\tif (!(ext4_li_info->li_state & EXT4_LAZYINIT_RUNNING)) {\n\t\tret = ext4_run_lazyinit_thread();\n\t\tif (ret)\n\t\t\tgoto out;\n\t}\nout:\n\tmutex_unlock(&ext4_li_mtx);\n\tif (ret)\n\t\tkfree(elr);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_fill_flex_info",
          "args": [
            "sb"
          ],
          "line": 4178
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_fill_flex_info",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/super.c",
          "lines": "1958-1990",
          "snippet": "static int ext4_fill_flex_info(struct super_block *sb)\n{\n\tstruct ext4_sb_info *sbi = EXT4_SB(sb);\n\tstruct ext4_group_desc *gdp = NULL;\n\text4_group_t flex_group;\n\tint i, err;\n\n\tsbi->s_log_groups_per_flex = sbi->s_es->s_log_groups_per_flex;\n\tif (sbi->s_log_groups_per_flex < 1 || sbi->s_log_groups_per_flex > 31) {\n\t\tsbi->s_log_groups_per_flex = 0;\n\t\treturn 1;\n\t}\n\n\terr = ext4_alloc_flex_bg_array(sb, sbi->s_groups_count);\n\tif (err)\n\t\tgoto failed;\n\n\tfor (i = 0; i < sbi->s_groups_count; i++) {\n\t\tgdp = ext4_get_group_desc(sb, i, NULL);\n\n\t\tflex_group = ext4_flex_group(sbi, i);\n\t\tatomic_add(ext4_free_inodes_count(sb, gdp),\n\t\t\t   &sbi->s_flex_groups[flex_group].free_inodes);\n\t\tatomic64_add(ext4_free_group_clusters(sb, gdp),\n\t\t\t     &sbi->s_flex_groups[flex_group].free_clusters);\n\t\tatomic_add(ext4_used_dirs_count(sb, gdp),\n\t\t\t   &sbi->s_flex_groups[flex_group].used_dirs);\n\t}\n\n\treturn 1;\nfailed:\n\treturn 0;\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"mballoc.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include \"ext4_extents.h\"\t/* Needed for trace points definition */",
            "#include \"ext4.h\"",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/crc16.h>",
            "#include <linux/log2.h>",
            "#include <linux/ctype.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/random.h>",
            "#include <linux/vfs.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/parser.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/time.h>",
            "#include <linux/fs.h>",
            "#include <linux/string.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ext4_unfreeze(struct super_block *sb);",
            "static int ext4_freeze(struct super_block *sb);",
            "static inline int ext2_feature_set_ok(struct super_block *sb);",
            "static inline int ext3_feature_set_ok(struct super_block *sb);",
            "static void ext4_unregister_li_request(struct super_block *sb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"mballoc.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4_extents.h\"\t/* Needed for trace points definition */\n#include \"ext4.h\"\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <asm/uaccess.h>\n#include <linux/cleancache.h>\n#include <linux/crc16.h>\n#include <linux/log2.h>\n#include <linux/ctype.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/random.h>\n#include <linux/vfs.h>\n#include <linux/exportfs.h>\n#include <linux/buffer_head.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/jbd2.h>\n#include <linux/vmalloc.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n#include <linux/string.h>\n#include <linux/module.h>\n\nstatic int ext4_unfreeze(struct super_block *sb);\nstatic int ext4_freeze(struct super_block *sb);\nstatic inline int ext2_feature_set_ok(struct super_block *sb);\nstatic inline int ext3_feature_set_ok(struct super_block *sb);\nstatic void ext4_unregister_li_request(struct super_block *sb);\n\nstatic int ext4_fill_flex_info(struct super_block *sb)\n{\n\tstruct ext4_sb_info *sbi = EXT4_SB(sb);\n\tstruct ext4_group_desc *gdp = NULL;\n\text4_group_t flex_group;\n\tint i, err;\n\n\tsbi->s_log_groups_per_flex = sbi->s_es->s_log_groups_per_flex;\n\tif (sbi->s_log_groups_per_flex < 1 || sbi->s_log_groups_per_flex > 31) {\n\t\tsbi->s_log_groups_per_flex = 0;\n\t\treturn 1;\n\t}\n\n\terr = ext4_alloc_flex_bg_array(sb, sbi->s_groups_count);\n\tif (err)\n\t\tgoto failed;\n\n\tfor (i = 0; i < sbi->s_groups_count; i++) {\n\t\tgdp = ext4_get_group_desc(sb, i, NULL);\n\n\t\tflex_group = ext4_flex_group(sbi, i);\n\t\tatomic_add(ext4_free_inodes_count(sb, gdp),\n\t\t\t   &sbi->s_flex_groups[flex_group].free_inodes);\n\t\tatomic64_add(ext4_free_group_clusters(sb, gdp),\n\t\t\t     &sbi->s_flex_groups[flex_group].free_clusters);\n\t\tatomic_add(ext4_used_dirs_count(sb, gdp),\n\t\t\t   &sbi->s_flex_groups[flex_group].used_dirs);\n\t}\n\n\treturn 1;\nfailed:\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "EXT4_HAS_INCOMPAT_FEATURE",
          "args": [
            "sb",
            "EXT4_FEATURE_INCOMPAT_FLEX_BG"
          ],
          "line": 4177
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "percpu_counter_init",
          "args": [
            "&sbi->s_dirtyclusters_counter",
            "0",
            "GFP_KERNEL"
          ],
          "line": 4170
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "percpu_counter_init",
          "args": [
            "&sbi->s_dirs_counter",
            "ext4_count_dirs(sb)",
            "GFP_KERNEL"
          ],
          "line": 4167
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_count_dirs",
          "args": [
            "sb"
          ],
          "line": 4168
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_count_dirs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ialloc.c",
          "lines": "1210-1222",
          "snippet": "unsigned long ext4_count_dirs(struct super_block * sb)\n{\n\tunsigned long count = 0;\n\text4_group_t i, ngroups = ext4_get_groups_count(sb);\n\n\tfor (i = 0; i < ngroups; i++) {\n\t\tstruct ext4_group_desc *gdp = ext4_get_group_desc(sb, i, NULL);\n\t\tif (!gdp)\n\t\t\tcontinue;\n\t\tcount += ext4_used_dirs_count(sb, gdp);\n\t}\n\treturn count;\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include \"ext4.h\"",
            "#include <asm/byteorder.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/bitops.h>",
            "#include <linux/random.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4.h\"\n#include <asm/byteorder.h>\n#include <linux/blkdev.h>\n#include <linux/bitops.h>\n#include <linux/random.h>\n#include <linux/buffer_head.h>\n#include <linux/quotaops.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/jbd2.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n\nunsigned long ext4_count_dirs(struct super_block * sb)\n{\n\tunsigned long count = 0;\n\text4_group_t i, ngroups = ext4_get_groups_count(sb);\n\n\tfor (i = 0; i < ngroups; i++) {\n\t\tstruct ext4_group_desc *gdp = ext4_get_group_desc(sb, i, NULL);\n\t\tif (!gdp)\n\t\t\tcontinue;\n\t\tcount += ext4_used_dirs_count(sb, gdp);\n\t}\n\treturn count;\n}"
        }
      },
      {
        "call_info": {
          "callee": "percpu_counter_init",
          "args": [
            "&sbi->s_freeinodes_counter",
            "freei",
            "GFP_KERNEL"
          ],
          "line": 4163
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "freei"
          ],
          "line": 4162
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_count_free_inodes",
          "args": [
            "sb"
          ],
          "line": 4161
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_count_free_inodes",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ialloc.c",
          "lines": "1161-1207",
          "snippet": "unsigned long ext4_count_free_inodes(struct super_block *sb)\n{\n\tunsigned long desc_count;\n\tstruct ext4_group_desc *gdp;\n\text4_group_t i, ngroups = ext4_get_groups_count(sb);\n#ifdef EXT4FS_DEBUG\n\tstruct ext4_super_block *es;\n\tunsigned long bitmap_count, x;\n\tstruct buffer_head *bitmap_bh = NULL;\n\n\tes = EXT4_SB(sb)->s_es;\n\tdesc_count = 0;\n\tbitmap_count = 0;\n\tgdp = NULL;\n\tfor (i = 0; i < ngroups; i++) {\n\t\tgdp = ext4_get_group_desc(sb, i, NULL);\n\t\tif (!gdp)\n\t\t\tcontinue;\n\t\tdesc_count += ext4_free_inodes_count(sb, gdp);\n\t\tbrelse(bitmap_bh);\n\t\tbitmap_bh = ext4_read_inode_bitmap(sb, i);\n\t\tif (!bitmap_bh)\n\t\t\tcontinue;\n\n\t\tx = ext4_count_free(bitmap_bh->b_data,\n\t\t\t\t    EXT4_INODES_PER_GROUP(sb) / 8);\n\t\tprintk(KERN_DEBUG \"group %lu: stored = %d, counted = %lu\\n\",\n\t\t\t(unsigned long) i, ext4_free_inodes_count(sb, gdp), x);\n\t\tbitmap_count += x;\n\t}\n\tbrelse(bitmap_bh);\n\tprintk(KERN_DEBUG \"ext4_count_free_inodes: \"\n\t       \"stored = %u, computed = %lu, %lu\\n\",\n\t       le32_to_cpu(es->s_free_inodes_count), desc_count, bitmap_count);\n\treturn desc_count;\n#else\n\tdesc_count = 0;\n\tfor (i = 0; i < ngroups; i++) {\n\t\tgdp = ext4_get_group_desc(sb, i, NULL);\n\t\tif (!gdp)\n\t\t\tcontinue;\n\t\tdesc_count += ext4_free_inodes_count(sb, gdp);\n\t\tcond_resched();\n\t}\n\treturn desc_count;\n#endif\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include \"ext4.h\"",
            "#include <asm/byteorder.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/bitops.h>",
            "#include <linux/random.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4.h\"\n#include <asm/byteorder.h>\n#include <linux/blkdev.h>\n#include <linux/bitops.h>\n#include <linux/random.h>\n#include <linux/buffer_head.h>\n#include <linux/quotaops.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/jbd2.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n\nunsigned long ext4_count_free_inodes(struct super_block *sb)\n{\n\tunsigned long desc_count;\n\tstruct ext4_group_desc *gdp;\n\text4_group_t i, ngroups = ext4_get_groups_count(sb);\n#ifdef EXT4FS_DEBUG\n\tstruct ext4_super_block *es;\n\tunsigned long bitmap_count, x;\n\tstruct buffer_head *bitmap_bh = NULL;\n\n\tes = EXT4_SB(sb)->s_es;\n\tdesc_count = 0;\n\tbitmap_count = 0;\n\tgdp = NULL;\n\tfor (i = 0; i < ngroups; i++) {\n\t\tgdp = ext4_get_group_desc(sb, i, NULL);\n\t\tif (!gdp)\n\t\t\tcontinue;\n\t\tdesc_count += ext4_free_inodes_count(sb, gdp);\n\t\tbrelse(bitmap_bh);\n\t\tbitmap_bh = ext4_read_inode_bitmap(sb, i);\n\t\tif (!bitmap_bh)\n\t\t\tcontinue;\n\n\t\tx = ext4_count_free(bitmap_bh->b_data,\n\t\t\t\t    EXT4_INODES_PER_GROUP(sb) / 8);\n\t\tprintk(KERN_DEBUG \"group %lu: stored = %d, counted = %lu\\n\",\n\t\t\t(unsigned long) i, ext4_free_inodes_count(sb, gdp), x);\n\t\tbitmap_count += x;\n\t}\n\tbrelse(bitmap_bh);\n\tprintk(KERN_DEBUG \"ext4_count_free_inodes: \"\n\t       \"stored = %u, computed = %lu, %lu\\n\",\n\t       le32_to_cpu(es->s_free_inodes_count), desc_count, bitmap_count);\n\treturn desc_count;\n#else\n\tdesc_count = 0;\n\tfor (i = 0; i < ngroups; i++) {\n\t\tgdp = ext4_get_group_desc(sb, i, NULL);\n\t\tif (!gdp)\n\t\t\tcontinue;\n\t\tdesc_count += ext4_free_inodes_count(sb, gdp);\n\t\tcond_resched();\n\t}\n\treturn desc_count;\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "percpu_counter_init",
          "args": [
            "&sbi->s_freeclusters_counter",
            "block",
            "GFP_KERNEL"
          ],
          "line": 4158
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_free_blocks_count_set",
          "args": [
            "sbi->s_es",
            "EXT4_C2B(sbi, block)"
          ],
          "line": 4156
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXT4_C2B",
          "args": [
            "sbi",
            "block"
          ],
          "line": 4157
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_count_free_clusters",
          "args": [
            "sb"
          ],
          "line": 4155
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_count_free_clusters",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/balloc.c",
          "lines": "658-717",
          "snippet": "ext4_fsblk_t ext4_count_free_clusters(struct super_block *sb)\n{\n\text4_fsblk_t desc_count;\n\tstruct ext4_group_desc *gdp;\n\text4_group_t i;\n\text4_group_t ngroups = ext4_get_groups_count(sb);\n\tstruct ext4_group_info *grp;\n#ifdef EXT4FS_DEBUG\n\tstruct ext4_super_block *es;\n\text4_fsblk_t bitmap_count;\n\tunsigned int x;\n\tstruct buffer_head *bitmap_bh = NULL;\n\n\tes = EXT4_SB(sb)->s_es;\n\tdesc_count = 0;\n\tbitmap_count = 0;\n\tgdp = NULL;\n\n\tfor (i = 0; i < ngroups; i++) {\n\t\tgdp = ext4_get_group_desc(sb, i, NULL);\n\t\tif (!gdp)\n\t\t\tcontinue;\n\t\tgrp = NULL;\n\t\tif (EXT4_SB(sb)->s_group_info)\n\t\t\tgrp = ext4_get_group_info(sb, i);\n\t\tif (!grp || !EXT4_MB_GRP_BBITMAP_CORRUPT(grp))\n\t\t\tdesc_count += ext4_free_group_clusters(sb, gdp);\n\t\tbrelse(bitmap_bh);\n\t\tbitmap_bh = ext4_read_block_bitmap(sb, i);\n\t\tif (bitmap_bh == NULL)\n\t\t\tcontinue;\n\n\t\tx = ext4_count_free(bitmap_bh->b_data,\n\t\t\t\t    EXT4_CLUSTERS_PER_GROUP(sb) / 8);\n\t\tprintk(KERN_DEBUG \"group %u: stored = %d, counted = %u\\n\",\n\t\t\ti, ext4_free_group_clusters(sb, gdp), x);\n\t\tbitmap_count += x;\n\t}\n\tbrelse(bitmap_bh);\n\tprintk(KERN_DEBUG \"ext4_count_free_clusters: stored = %llu\"\n\t       \", computed = %llu, %llu\\n\",\n\t       EXT4_NUM_B2C(EXT4_SB(sb), ext4_free_blocks_count(es)),\n\t       desc_count, bitmap_count);\n\treturn bitmap_count;\n#else\n\tdesc_count = 0;\n\tfor (i = 0; i < ngroups; i++) {\n\t\tgdp = ext4_get_group_desc(sb, i, NULL);\n\t\tif (!gdp)\n\t\t\tcontinue;\n\t\tgrp = NULL;\n\t\tif (EXT4_SB(sb)->s_group_info)\n\t\t\tgrp = ext4_get_group_info(sb, i);\n\t\tif (!grp || !EXT4_MB_GRP_BBITMAP_CORRUPT(grp))\n\t\t\tdesc_count += ext4_free_group_clusters(sb, gdp);\n\t}\n\n\treturn desc_count;\n#endif\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"mballoc.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include \"ext4.h\"",
            "#include <linux/buffer_head.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/fs.h>",
            "#include <linux/capability.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"mballoc.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4.h\"\n#include <linux/buffer_head.h>\n#include <linux/quotaops.h>\n#include <linux/jbd2.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n#include <linux/time.h>\n\next4_fsblk_t ext4_count_free_clusters(struct super_block *sb)\n{\n\text4_fsblk_t desc_count;\n\tstruct ext4_group_desc *gdp;\n\text4_group_t i;\n\text4_group_t ngroups = ext4_get_groups_count(sb);\n\tstruct ext4_group_info *grp;\n#ifdef EXT4FS_DEBUG\n\tstruct ext4_super_block *es;\n\text4_fsblk_t bitmap_count;\n\tunsigned int x;\n\tstruct buffer_head *bitmap_bh = NULL;\n\n\tes = EXT4_SB(sb)->s_es;\n\tdesc_count = 0;\n\tbitmap_count = 0;\n\tgdp = NULL;\n\n\tfor (i = 0; i < ngroups; i++) {\n\t\tgdp = ext4_get_group_desc(sb, i, NULL);\n\t\tif (!gdp)\n\t\t\tcontinue;\n\t\tgrp = NULL;\n\t\tif (EXT4_SB(sb)->s_group_info)\n\t\t\tgrp = ext4_get_group_info(sb, i);\n\t\tif (!grp || !EXT4_MB_GRP_BBITMAP_CORRUPT(grp))\n\t\t\tdesc_count += ext4_free_group_clusters(sb, gdp);\n\t\tbrelse(bitmap_bh);\n\t\tbitmap_bh = ext4_read_block_bitmap(sb, i);\n\t\tif (bitmap_bh == NULL)\n\t\t\tcontinue;\n\n\t\tx = ext4_count_free(bitmap_bh->b_data,\n\t\t\t\t    EXT4_CLUSTERS_PER_GROUP(sb) / 8);\n\t\tprintk(KERN_DEBUG \"group %u: stored = %d, counted = %u\\n\",\n\t\t\ti, ext4_free_group_clusters(sb, gdp), x);\n\t\tbitmap_count += x;\n\t}\n\tbrelse(bitmap_bh);\n\tprintk(KERN_DEBUG \"ext4_count_free_clusters: stored = %llu\"\n\t       \", computed = %llu, %llu\\n\",\n\t       EXT4_NUM_B2C(EXT4_SB(sb), ext4_free_blocks_count(es)),\n\t       desc_count, bitmap_count);\n\treturn bitmap_count;\n#else\n\tdesc_count = 0;\n\tfor (i = 0; i < ngroups; i++) {\n\t\tgdp = ext4_get_group_desc(sb, i, NULL);\n\t\tif (!gdp)\n\t\t\tcontinue;\n\t\tgrp = NULL;\n\t\tif (EXT4_SB(sb)->s_group_info)\n\t\t\tgrp = ext4_get_group_info(sb, i);\n\t\tif (!grp || !EXT4_MB_GRP_BBITMAP_CORRUPT(grp))\n\t\t\tdesc_count += ext4_free_group_clusters(sb, gdp);\n\t}\n\n\treturn desc_count;\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_mb_init",
          "args": [
            "sb"
          ],
          "line": 4148
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_mb_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/mballoc.c",
          "lines": "2552-2663",
          "snippet": "int ext4_mb_init(struct super_block *sb)\n{\n\tstruct ext4_sb_info *sbi = EXT4_SB(sb);\n\tunsigned i, j;\n\tunsigned offset;\n\tunsigned max;\n\tint ret;\n\n\ti = (sb->s_blocksize_bits + 2) * sizeof(*sbi->s_mb_offsets);\n\n\tsbi->s_mb_offsets = kmalloc(i, GFP_KERNEL);\n\tif (sbi->s_mb_offsets == NULL) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\ti = (sb->s_blocksize_bits + 2) * sizeof(*sbi->s_mb_maxs);\n\tsbi->s_mb_maxs = kmalloc(i, GFP_KERNEL);\n\tif (sbi->s_mb_maxs == NULL) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tret = ext4_groupinfo_create_slab(sb->s_blocksize);\n\tif (ret < 0)\n\t\tgoto out;\n\n\t/* order 0 is regular bitmap */\n\tsbi->s_mb_maxs[0] = sb->s_blocksize << 3;\n\tsbi->s_mb_offsets[0] = 0;\n\n\ti = 1;\n\toffset = 0;\n\tmax = sb->s_blocksize << 2;\n\tdo {\n\t\tsbi->s_mb_offsets[i] = offset;\n\t\tsbi->s_mb_maxs[i] = max;\n\t\toffset += 1 << (sb->s_blocksize_bits - i);\n\t\tmax = max >> 1;\n\t\ti++;\n\t} while (i <= sb->s_blocksize_bits + 1);\n\n\tspin_lock_init(&sbi->s_md_lock);\n\tspin_lock_init(&sbi->s_bal_lock);\n\n\tsbi->s_mb_max_to_scan = MB_DEFAULT_MAX_TO_SCAN;\n\tsbi->s_mb_min_to_scan = MB_DEFAULT_MIN_TO_SCAN;\n\tsbi->s_mb_stats = MB_DEFAULT_STATS;\n\tsbi->s_mb_stream_request = MB_DEFAULT_STREAM_THRESHOLD;\n\tsbi->s_mb_order2_reqs = MB_DEFAULT_ORDER2_REQS;\n\t/*\n\t * The default group preallocation is 512, which for 4k block\n\t * sizes translates to 2 megabytes.  However for bigalloc file\n\t * systems, this is probably too big (i.e, if the cluster size\n\t * is 1 megabyte, then group preallocation size becomes half a\n\t * gigabyte!).  As a default, we will keep a two megabyte\n\t * group pralloc size for cluster sizes up to 64k, and after\n\t * that, we will force a minimum group preallocation size of\n\t * 32 clusters.  This translates to 8 megs when the cluster\n\t * size is 256k, and 32 megs when the cluster size is 1 meg,\n\t * which seems reasonable as a default.\n\t */\n\tsbi->s_mb_group_prealloc = max(MB_DEFAULT_GROUP_PREALLOC >>\n\t\t\t\t       sbi->s_cluster_bits, 32);\n\t/*\n\t * If there is a s_stripe > 1, then we set the s_mb_group_prealloc\n\t * to the lowest multiple of s_stripe which is bigger than\n\t * the s_mb_group_prealloc as determined above. We want\n\t * the preallocation size to be an exact multiple of the\n\t * RAID stripe size so that preallocations don't fragment\n\t * the stripes.\n\t */\n\tif (sbi->s_stripe > 1) {\n\t\tsbi->s_mb_group_prealloc = roundup(\n\t\t\tsbi->s_mb_group_prealloc, sbi->s_stripe);\n\t}\n\n\tsbi->s_locality_groups = alloc_percpu(struct ext4_locality_group);\n\tif (sbi->s_locality_groups == NULL) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\tfor_each_possible_cpu(i) {\n\t\tstruct ext4_locality_group *lg;\n\t\tlg = per_cpu_ptr(sbi->s_locality_groups, i);\n\t\tmutex_init(&lg->lg_mutex);\n\t\tfor (j = 0; j < PREALLOC_TB_SIZE; j++)\n\t\t\tINIT_LIST_HEAD(&lg->lg_prealloc_list[j]);\n\t\tspin_lock_init(&lg->lg_prealloc_lock);\n\t}\n\n\t/* init file for buddy data */\n\tret = ext4_mb_init_backend(sb);\n\tif (ret != 0)\n\t\tgoto out_free_locality_groups;\n\n\tif (sbi->s_proc)\n\t\tproc_create_data(\"mb_groups\", S_IRUGO, sbi->s_proc,\n\t\t\t\t &ext4_mb_seq_groups_fops, sb);\n\n\treturn 0;\n\nout_free_locality_groups:\n\tfree_percpu(sbi->s_locality_groups);\n\tsbi->s_locality_groups = NULL;\nout:\n\tkfree(sbi->s_mb_offsets);\n\tsbi->s_mb_offsets = NULL;\n\tkfree(sbi->s_mb_maxs);\n\tsbi->s_mb_maxs = NULL;\n\treturn ret;\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/log2.h>",
            "#include \"mballoc.h\"",
            "#include \"ext4_jbd2.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void ext4_mb_generate_from_pa(struct super_block *sb, void *bitmap,\n\t\t\t\t\text4_group_t group);",
            "static void ext4_mb_generate_from_freelist(struct super_block *sb, void *bitmap,\n\t\t\t\t\t\text4_group_t group);",
            "static const struct file_operations ext4_mb_seq_groups_fops = {\n\t.owner\t\t= THIS_MODULE,\n\t.open\t\t= ext4_mb_seq_groups_open,\n\t.read\t\t= seq_read,\n\t.llseek\t\t= seq_lseek,\n\t.release\t= seq_release,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/log2.h>\n#include \"mballoc.h\"\n#include \"ext4_jbd2.h\"\n\nstatic void ext4_mb_generate_from_pa(struct super_block *sb, void *bitmap,\n\t\t\t\t\text4_group_t group);\nstatic void ext4_mb_generate_from_freelist(struct super_block *sb, void *bitmap,\n\t\t\t\t\t\text4_group_t group);\nstatic const struct file_operations ext4_mb_seq_groups_fops = {\n\t.owner\t\t= THIS_MODULE,\n\t.open\t\t= ext4_mb_seq_groups_open,\n\t.read\t\t= seq_read,\n\t.llseek\t\t= seq_lseek,\n\t.release\t= seq_release,\n};\n\nint ext4_mb_init(struct super_block *sb)\n{\n\tstruct ext4_sb_info *sbi = EXT4_SB(sb);\n\tunsigned i, j;\n\tunsigned offset;\n\tunsigned max;\n\tint ret;\n\n\ti = (sb->s_blocksize_bits + 2) * sizeof(*sbi->s_mb_offsets);\n\n\tsbi->s_mb_offsets = kmalloc(i, GFP_KERNEL);\n\tif (sbi->s_mb_offsets == NULL) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\ti = (sb->s_blocksize_bits + 2) * sizeof(*sbi->s_mb_maxs);\n\tsbi->s_mb_maxs = kmalloc(i, GFP_KERNEL);\n\tif (sbi->s_mb_maxs == NULL) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tret = ext4_groupinfo_create_slab(sb->s_blocksize);\n\tif (ret < 0)\n\t\tgoto out;\n\n\t/* order 0 is regular bitmap */\n\tsbi->s_mb_maxs[0] = sb->s_blocksize << 3;\n\tsbi->s_mb_offsets[0] = 0;\n\n\ti = 1;\n\toffset = 0;\n\tmax = sb->s_blocksize << 2;\n\tdo {\n\t\tsbi->s_mb_offsets[i] = offset;\n\t\tsbi->s_mb_maxs[i] = max;\n\t\toffset += 1 << (sb->s_blocksize_bits - i);\n\t\tmax = max >> 1;\n\t\ti++;\n\t} while (i <= sb->s_blocksize_bits + 1);\n\n\tspin_lock_init(&sbi->s_md_lock);\n\tspin_lock_init(&sbi->s_bal_lock);\n\n\tsbi->s_mb_max_to_scan = MB_DEFAULT_MAX_TO_SCAN;\n\tsbi->s_mb_min_to_scan = MB_DEFAULT_MIN_TO_SCAN;\n\tsbi->s_mb_stats = MB_DEFAULT_STATS;\n\tsbi->s_mb_stream_request = MB_DEFAULT_STREAM_THRESHOLD;\n\tsbi->s_mb_order2_reqs = MB_DEFAULT_ORDER2_REQS;\n\t/*\n\t * The default group preallocation is 512, which for 4k block\n\t * sizes translates to 2 megabytes.  However for bigalloc file\n\t * systems, this is probably too big (i.e, if the cluster size\n\t * is 1 megabyte, then group preallocation size becomes half a\n\t * gigabyte!).  As a default, we will keep a two megabyte\n\t * group pralloc size for cluster sizes up to 64k, and after\n\t * that, we will force a minimum group preallocation size of\n\t * 32 clusters.  This translates to 8 megs when the cluster\n\t * size is 256k, and 32 megs when the cluster size is 1 meg,\n\t * which seems reasonable as a default.\n\t */\n\tsbi->s_mb_group_prealloc = max(MB_DEFAULT_GROUP_PREALLOC >>\n\t\t\t\t       sbi->s_cluster_bits, 32);\n\t/*\n\t * If there is a s_stripe > 1, then we set the s_mb_group_prealloc\n\t * to the lowest multiple of s_stripe which is bigger than\n\t * the s_mb_group_prealloc as determined above. We want\n\t * the preallocation size to be an exact multiple of the\n\t * RAID stripe size so that preallocations don't fragment\n\t * the stripes.\n\t */\n\tif (sbi->s_stripe > 1) {\n\t\tsbi->s_mb_group_prealloc = roundup(\n\t\t\tsbi->s_mb_group_prealloc, sbi->s_stripe);\n\t}\n\n\tsbi->s_locality_groups = alloc_percpu(struct ext4_locality_group);\n\tif (sbi->s_locality_groups == NULL) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\tfor_each_possible_cpu(i) {\n\t\tstruct ext4_locality_group *lg;\n\t\tlg = per_cpu_ptr(sbi->s_locality_groups, i);\n\t\tmutex_init(&lg->lg_mutex);\n\t\tfor (j = 0; j < PREALLOC_TB_SIZE; j++)\n\t\t\tINIT_LIST_HEAD(&lg->lg_prealloc_list[j]);\n\t\tspin_lock_init(&lg->lg_prealloc_lock);\n\t}\n\n\t/* init file for buddy data */\n\tret = ext4_mb_init_backend(sb);\n\tif (ret != 0)\n\t\tgoto out_free_locality_groups;\n\n\tif (sbi->s_proc)\n\t\tproc_create_data(\"mb_groups\", S_IRUGO, sbi->s_proc,\n\t\t\t\t &ext4_mb_seq_groups_fops, sb);\n\n\treturn 0;\n\nout_free_locality_groups:\n\tfree_percpu(sbi->s_locality_groups);\n\tsbi->s_locality_groups = NULL;\nout:\n\tkfree(sbi->s_mb_offsets);\n\tsbi->s_mb_offsets = NULL;\n\tkfree(sbi->s_mb_maxs);\n\tsbi->s_mb_maxs = NULL;\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_ext_init",
          "args": [
            "sb"
          ],
          "line": 4147
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_ext_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/extents.c",
          "lines": "3056-3082",
          "snippet": "void ext4_ext_init(struct super_block *sb)\n{\n\t/*\n\t * possible initialization would be here\n\t */\n\n\tif (EXT4_HAS_INCOMPAT_FEATURE(sb, EXT4_FEATURE_INCOMPAT_EXTENTS)) {\n#if defined(AGGRESSIVE_TEST) || defined(CHECK_BINSEARCH) || defined(EXTENTS_STATS)\n\t\tprintk(KERN_INFO \"EXT4-fs: file extents enabled\"\n#ifdef AGGRESSIVE_TEST\n\t\t       \", aggressive tests\"\n#endif\n#ifdef CHECK_BINSEARCH\n\t\t       \", check binsearch\"\n#endif\n#ifdef EXTENTS_STATS\n\t\t       \", stats\"\n#endif\n\t\t       \"\\n\");\n#endif\n#ifdef EXTENTS_STATS\n\t\tspin_lock_init(&EXT4_SB(sb)->s_ext_stats_lock);\n\t\tEXT4_SB(sb)->s_ext_min = 1 << 30;\n\t\tEXT4_SB(sb)->s_ext_max = 0;\n#endif\n\t}\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"xattr.h\"",
            "#include \"ext4_extents.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include <linux/fiemap.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/string.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highuid.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/time.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"xattr.h\"\n#include \"ext4_extents.h\"\n#include \"ext4_jbd2.h\"\n#include <linux/fiemap.h>\n#include <asm/uaccess.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/highuid.h>\n#include <linux/jbd2.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n\nvoid ext4_ext_init(struct super_block *sb)\n{\n\t/*\n\t * possible initialization would be here\n\t */\n\n\tif (EXT4_HAS_INCOMPAT_FEATURE(sb, EXT4_FEATURE_INCOMPAT_EXTENTS)) {\n#if defined(AGGRESSIVE_TEST) || defined(CHECK_BINSEARCH) || defined(EXTENTS_STATS)\n\t\tprintk(KERN_INFO \"EXT4-fs: file extents enabled\"\n#ifdef AGGRESSIVE_TEST\n\t\t       \", aggressive tests\"\n#endif\n#ifdef CHECK_BINSEARCH\n\t\t       \", check binsearch\"\n#endif\n#ifdef EXTENTS_STATS\n\t\t       \", stats\"\n#endif\n\t\t       \"\\n\");\n#endif\n#ifdef EXTENTS_STATS\n\t\tspin_lock_init(&EXT4_SB(sb)->s_ext_stats_lock);\n\t\tEXT4_SB(sb)->s_ext_min = 1 << 30;\n\t\tEXT4_SB(sb)->s_ext_max = 0;\n#endif\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_setup_system_zone",
          "args": [
            "sb"
          ],
          "line": 4140
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_setup_system_zone",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/block_validity.c",
          "lines": "140-178",
          "snippet": "int ext4_setup_system_zone(struct super_block *sb)\n{\n\text4_group_t ngroups = ext4_get_groups_count(sb);\n\tstruct ext4_sb_info *sbi = EXT4_SB(sb);\n\tstruct ext4_group_desc *gdp;\n\text4_group_t i;\n\tint flex_size = ext4_flex_bg_size(sbi);\n\tint ret;\n\n\tif (!test_opt(sb, BLOCK_VALIDITY)) {\n\t\tif (EXT4_SB(sb)->system_blks.rb_node)\n\t\t\text4_release_system_zone(sb);\n\t\treturn 0;\n\t}\n\tif (EXT4_SB(sb)->system_blks.rb_node)\n\t\treturn 0;\n\n\tfor (i=0; i < ngroups; i++) {\n\t\tif (ext4_bg_has_super(sb, i) &&\n\t\t    ((i < 5) || ((i % flex_size) == 0)))\n\t\t\tadd_system_zone(sbi, ext4_group_first_block_no(sb, i),\n\t\t\t\t\text4_bg_num_gdb(sb, i) + 1);\n\t\tgdp = ext4_get_group_desc(sb, i, NULL);\n\t\tret = add_system_zone(sbi, ext4_block_bitmap(sb, gdp), 1);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tret = add_system_zone(sbi, ext4_inode_bitmap(sb, gdp), 1);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tret = add_system_zone(sbi, ext4_inode_table(sb, gdp),\n\t\t\t\tsbi->s_itb_per_group);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tif (test_opt(sb, DEBUG))\n\t\tdebug_print_tree(EXT4_SB(sb));\n\treturn 0;\n}",
          "includes": [
            "#include \"ext4.h\"",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ext4.h\"\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/blkdev.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/buffer_head.h>\n#include <linux/quotaops.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n\nint ext4_setup_system_zone(struct super_block *sb)\n{\n\text4_group_t ngroups = ext4_get_groups_count(sb);\n\tstruct ext4_sb_info *sbi = EXT4_SB(sb);\n\tstruct ext4_group_desc *gdp;\n\text4_group_t i;\n\tint flex_size = ext4_flex_bg_size(sbi);\n\tint ret;\n\n\tif (!test_opt(sb, BLOCK_VALIDITY)) {\n\t\tif (EXT4_SB(sb)->system_blks.rb_node)\n\t\t\text4_release_system_zone(sb);\n\t\treturn 0;\n\t}\n\tif (EXT4_SB(sb)->system_blks.rb_node)\n\t\treturn 0;\n\n\tfor (i=0; i < ngroups; i++) {\n\t\tif (ext4_bg_has_super(sb, i) &&\n\t\t    ((i < 5) || ((i % flex_size) == 0)))\n\t\t\tadd_system_zone(sbi, ext4_group_first_block_no(sb, i),\n\t\t\t\t\text4_bg_num_gdb(sb, i) + 1);\n\t\tgdp = ext4_get_group_desc(sb, i, NULL);\n\t\tret = add_system_zone(sbi, ext4_block_bitmap(sb, gdp), 1);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tret = add_system_zone(sbi, ext4_inode_bitmap(sb, gdp), 1);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tret = add_system_zone(sbi, ext4_inode_table(sb, gdp),\n\t\t\t\tsbi->s_itb_per_group);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tif (test_opt(sb, DEBUG))\n\t\tdebug_print_tree(EXT4_SB(sb));\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_calculate_resv_clusters",
          "args": [
            "sb"
          ],
          "line": 4136
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_calculate_resv_clusters",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/super.c",
          "lines": "3367-3394",
          "snippet": "static ext4_fsblk_t ext4_calculate_resv_clusters(struct super_block *sb)\n{\n\text4_fsblk_t resv_clusters;\n\n\t/*\n\t * There's no need to reserve anything when we aren't using extents.\n\t * The space estimates are exact, there are no unwritten extents,\n\t * hole punching doesn't need new metadata... This is needed especially\n\t * to keep ext2/3 backward compatibility.\n\t */\n\tif (!EXT4_HAS_INCOMPAT_FEATURE(sb, EXT4_FEATURE_INCOMPAT_EXTENTS))\n\t\treturn 0;\n\t/*\n\t * By default we reserve 2% or 4096 clusters, whichever is smaller.\n\t * This should cover the situations where we can not afford to run\n\t * out of space like for example punch hole, or converting\n\t * unwritten extents in delalloc path. In most cases such\n\t * allocation would require 1, or 2 blocks, higher numbers are\n\t * very rare.\n\t */\n\tresv_clusters = ext4_blocks_count(EXT4_SB(sb)->s_es) >>\n\t\t\tEXT4_SB(sb)->s_cluster_bits;\n\n\tdo_div(resv_clusters, 50);\n\tresv_clusters = min_t(ext4_fsblk_t, resv_clusters, 4096);\n\n\treturn resv_clusters;\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"mballoc.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include \"ext4_extents.h\"\t/* Needed for trace points definition */",
            "#include \"ext4.h\"",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/crc16.h>",
            "#include <linux/log2.h>",
            "#include <linux/ctype.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/random.h>",
            "#include <linux/vfs.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/parser.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/time.h>",
            "#include <linux/fs.h>",
            "#include <linux/string.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ext4_unfreeze(struct super_block *sb);",
            "static int ext4_freeze(struct super_block *sb);",
            "static inline int ext2_feature_set_ok(struct super_block *sb);",
            "static inline int ext3_feature_set_ok(struct super_block *sb);",
            "static void ext4_unregister_li_request(struct super_block *sb);",
            "static int ext4_reserve_clusters(struct ext4_sb_info *, ext4_fsblk_t);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"mballoc.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4_extents.h\"\t/* Needed for trace points definition */\n#include \"ext4.h\"\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <asm/uaccess.h>\n#include <linux/cleancache.h>\n#include <linux/crc16.h>\n#include <linux/log2.h>\n#include <linux/ctype.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/random.h>\n#include <linux/vfs.h>\n#include <linux/exportfs.h>\n#include <linux/buffer_head.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/jbd2.h>\n#include <linux/vmalloc.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n#include <linux/string.h>\n#include <linux/module.h>\n\nstatic int ext4_unfreeze(struct super_block *sb);\nstatic int ext4_freeze(struct super_block *sb);\nstatic inline int ext2_feature_set_ok(struct super_block *sb);\nstatic inline int ext3_feature_set_ok(struct super_block *sb);\nstatic void ext4_unregister_li_request(struct super_block *sb);\nstatic int ext4_reserve_clusters(struct ext4_sb_info *, ext4_fsblk_t);\n\nstatic ext4_fsblk_t ext4_calculate_resv_clusters(struct super_block *sb)\n{\n\text4_fsblk_t resv_clusters;\n\n\t/*\n\t * There's no need to reserve anything when we aren't using extents.\n\t * The space estimates are exact, there are no unwritten extents,\n\t * hole punching doesn't need new metadata... This is needed especially\n\t * to keep ext2/3 backward compatibility.\n\t */\n\tif (!EXT4_HAS_INCOMPAT_FEATURE(sb, EXT4_FEATURE_INCOMPAT_EXTENTS))\n\t\treturn 0;\n\t/*\n\t * By default we reserve 2% or 4096 clusters, whichever is smaller.\n\t * This should cover the situations where we can not afford to run\n\t * out of space like for example punch hole, or converting\n\t * unwritten extents in delalloc path. In most cases such\n\t * allocation would require 1, or 2 blocks, higher numbers are\n\t * very rare.\n\t */\n\tresv_clusters = ext4_blocks_count(EXT4_SB(sb)->s_es) >>\n\t\t\tEXT4_SB(sb)->s_cluster_bits;\n\n\tdo_div(resv_clusters, 50);\n\tresv_clusters = min_t(ext4_fsblk_t, resv_clusters, 4096);\n\n\treturn resv_clusters;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_reserve_clusters",
          "args": [
            "sbi",
            "ext4_calculate_resv_clusters(sb)"
          ],
          "line": 4133
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_reserve_clusters",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/super.c",
          "lines": "3397-3407",
          "snippet": "static int ext4_reserve_clusters(struct ext4_sb_info *sbi, ext4_fsblk_t count)\n{\n\text4_fsblk_t clusters = ext4_blocks_count(sbi->s_es) >>\n\t\t\t\tsbi->s_cluster_bits;\n\n\tif (count >= clusters)\n\t\treturn -EINVAL;\n\n\tatomic64_set(&sbi->s_resv_clusters, count);\n\treturn 0;\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"mballoc.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include \"ext4_extents.h\"\t/* Needed for trace points definition */",
            "#include \"ext4.h\"",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/crc16.h>",
            "#include <linux/log2.h>",
            "#include <linux/ctype.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/random.h>",
            "#include <linux/vfs.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/parser.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/time.h>",
            "#include <linux/fs.h>",
            "#include <linux/string.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ext4_reserve_clusters(struct ext4_sb_info *, ext4_fsblk_t);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"mballoc.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4_extents.h\"\t/* Needed for trace points definition */\n#include \"ext4.h\"\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <asm/uaccess.h>\n#include <linux/cleancache.h>\n#include <linux/crc16.h>\n#include <linux/log2.h>\n#include <linux/ctype.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/random.h>\n#include <linux/vfs.h>\n#include <linux/exportfs.h>\n#include <linux/buffer_head.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/jbd2.h>\n#include <linux/vmalloc.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n#include <linux/string.h>\n#include <linux/module.h>\n\nstatic int ext4_reserve_clusters(struct ext4_sb_info *, ext4_fsblk_t);\n\nstatic int ext4_reserve_clusters(struct ext4_sb_info *sbi, ext4_fsblk_t count)\n{\n\text4_fsblk_t clusters = ext4_blocks_count(sbi->s_es) >>\n\t\t\t\tsbi->s_cluster_bits;\n\n\tif (count >= clusters)\n\t\treturn -EINVAL;\n\n\tatomic64_set(&sbi->s_resv_clusters, count);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "le16_to_cpu",
          "args": [
            "es->s_min_extra_isize"
          ],
          "line": 4121
        },
        "resolved": true,
        "details": {
          "function_name": "sle16_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "48-51",
          "snippet": "static inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "EXT4_HAS_RO_COMPAT_FEATURE",
          "args": [
            "sb",
            "EXT4_FEATURE_RO_COMPAT_EXTRA_ISIZE"
          ],
          "line": 4112
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_setup_super",
          "args": [
            "sb",
            "es",
            "sb->s_flags & MS_RDONLY"
          ],
          "line": 4105
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_setup_super",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/super.c",
          "lines": "1869-1924",
          "snippet": "static int ext4_setup_super(struct super_block *sb, struct ext4_super_block *es,\n\t\t\t    int read_only)\n{\n\tstruct ext4_sb_info *sbi = EXT4_SB(sb);\n\tint res = 0;\n\n\tif (le32_to_cpu(es->s_rev_level) > EXT4_MAX_SUPP_REV) {\n\t\text4_msg(sb, KERN_ERR, \"revision level too high, \"\n\t\t\t \"forcing read-only mode\");\n\t\tres = MS_RDONLY;\n\t}\n\tif (read_only)\n\t\tgoto done;\n\tif (!(sbi->s_mount_state & EXT4_VALID_FS))\n\t\text4_msg(sb, KERN_WARNING, \"warning: mounting unchecked fs, \"\n\t\t\t \"running e2fsck is recommended\");\n\telse if (sbi->s_mount_state & EXT4_ERROR_FS)\n\t\text4_msg(sb, KERN_WARNING,\n\t\t\t \"warning: mounting fs with errors, \"\n\t\t\t \"running e2fsck is recommended\");\n\telse if ((__s16) le16_to_cpu(es->s_max_mnt_count) > 0 &&\n\t\t le16_to_cpu(es->s_mnt_count) >=\n\t\t (unsigned short) (__s16) le16_to_cpu(es->s_max_mnt_count))\n\t\text4_msg(sb, KERN_WARNING,\n\t\t\t \"warning: maximal mount count reached, \"\n\t\t\t \"running e2fsck is recommended\");\n\telse if (le32_to_cpu(es->s_checkinterval) &&\n\t\t(le32_to_cpu(es->s_lastcheck) +\n\t\t\tle32_to_cpu(es->s_checkinterval) <= get_seconds()))\n\t\text4_msg(sb, KERN_WARNING,\n\t\t\t \"warning: checktime reached, \"\n\t\t\t \"running e2fsck is recommended\");\n\tif (!sbi->s_journal)\n\t\tes->s_state &= cpu_to_le16(~EXT4_VALID_FS);\n\tif (!(__s16) le16_to_cpu(es->s_max_mnt_count))\n\t\tes->s_max_mnt_count = cpu_to_le16(EXT4_DFL_MAX_MNT_COUNT);\n\tle16_add_cpu(&es->s_mnt_count, 1);\n\tes->s_mtime = cpu_to_le32(get_seconds());\n\text4_update_dynamic_rev(sb);\n\tif (sbi->s_journal)\n\t\tEXT4_SET_INCOMPAT_FEATURE(sb, EXT4_FEATURE_INCOMPAT_RECOVER);\n\n\text4_commit_super(sb, 1);\ndone:\n\tif (test_opt(sb, DEBUG))\n\t\tprintk(KERN_INFO \"[EXT4 FS bs=%lu, gc=%u, \"\n\t\t\t\t\"bpg=%lu, ipg=%lu, mo=%04x, mo2=%04x]\\n\",\n\t\t\tsb->s_blocksize,\n\t\t\tsbi->s_groups_count,\n\t\t\tEXT4_BLOCKS_PER_GROUP(sb),\n\t\t\tEXT4_INODES_PER_GROUP(sb),\n\t\t\tsbi->s_mount_opt, sbi->s_mount_opt2);\n\n\tcleancache_init_fs(sb);\n\treturn res;\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"mballoc.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include \"ext4_extents.h\"\t/* Needed for trace points definition */",
            "#include \"ext4.h\"",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/crc16.h>",
            "#include <linux/log2.h>",
            "#include <linux/ctype.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/random.h>",
            "#include <linux/vfs.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/parser.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/time.h>",
            "#include <linux/fs.h>",
            "#include <linux/string.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void ext4_mark_recovery_complete(struct super_block *sb,\n\t\t\t\t\tstruct ext4_super_block *es);",
            "static void ext4_clear_journal_err(struct super_block *sb,\n\t\t\t\t   struct ext4_super_block *es);",
            "static int ext4_unfreeze(struct super_block *sb);",
            "static int ext4_freeze(struct super_block *sb);",
            "static inline int ext2_feature_set_ok(struct super_block *sb);",
            "static inline int ext3_feature_set_ok(struct super_block *sb);",
            "static void ext4_unregister_li_request(struct super_block *sb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"mballoc.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4_extents.h\"\t/* Needed for trace points definition */\n#include \"ext4.h\"\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <asm/uaccess.h>\n#include <linux/cleancache.h>\n#include <linux/crc16.h>\n#include <linux/log2.h>\n#include <linux/ctype.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/random.h>\n#include <linux/vfs.h>\n#include <linux/exportfs.h>\n#include <linux/buffer_head.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/jbd2.h>\n#include <linux/vmalloc.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n#include <linux/string.h>\n#include <linux/module.h>\n\nstatic void ext4_mark_recovery_complete(struct super_block *sb,\n\t\t\t\t\tstruct ext4_super_block *es);\nstatic void ext4_clear_journal_err(struct super_block *sb,\n\t\t\t\t   struct ext4_super_block *es);\nstatic int ext4_unfreeze(struct super_block *sb);\nstatic int ext4_freeze(struct super_block *sb);\nstatic inline int ext2_feature_set_ok(struct super_block *sb);\nstatic inline int ext3_feature_set_ok(struct super_block *sb);\nstatic void ext4_unregister_li_request(struct super_block *sb);\n\nstatic int ext4_setup_super(struct super_block *sb, struct ext4_super_block *es,\n\t\t\t    int read_only)\n{\n\tstruct ext4_sb_info *sbi = EXT4_SB(sb);\n\tint res = 0;\n\n\tif (le32_to_cpu(es->s_rev_level) > EXT4_MAX_SUPP_REV) {\n\t\text4_msg(sb, KERN_ERR, \"revision level too high, \"\n\t\t\t \"forcing read-only mode\");\n\t\tres = MS_RDONLY;\n\t}\n\tif (read_only)\n\t\tgoto done;\n\tif (!(sbi->s_mount_state & EXT4_VALID_FS))\n\t\text4_msg(sb, KERN_WARNING, \"warning: mounting unchecked fs, \"\n\t\t\t \"running e2fsck is recommended\");\n\telse if (sbi->s_mount_state & EXT4_ERROR_FS)\n\t\text4_msg(sb, KERN_WARNING,\n\t\t\t \"warning: mounting fs with errors, \"\n\t\t\t \"running e2fsck is recommended\");\n\telse if ((__s16) le16_to_cpu(es->s_max_mnt_count) > 0 &&\n\t\t le16_to_cpu(es->s_mnt_count) >=\n\t\t (unsigned short) (__s16) le16_to_cpu(es->s_max_mnt_count))\n\t\text4_msg(sb, KERN_WARNING,\n\t\t\t \"warning: maximal mount count reached, \"\n\t\t\t \"running e2fsck is recommended\");\n\telse if (le32_to_cpu(es->s_checkinterval) &&\n\t\t(le32_to_cpu(es->s_lastcheck) +\n\t\t\tle32_to_cpu(es->s_checkinterval) <= get_seconds()))\n\t\text4_msg(sb, KERN_WARNING,\n\t\t\t \"warning: checktime reached, \"\n\t\t\t \"running e2fsck is recommended\");\n\tif (!sbi->s_journal)\n\t\tes->s_state &= cpu_to_le16(~EXT4_VALID_FS);\n\tif (!(__s16) le16_to_cpu(es->s_max_mnt_count))\n\t\tes->s_max_mnt_count = cpu_to_le16(EXT4_DFL_MAX_MNT_COUNT);\n\tle16_add_cpu(&es->s_mnt_count, 1);\n\tes->s_mtime = cpu_to_le32(get_seconds());\n\text4_update_dynamic_rev(sb);\n\tif (sbi->s_journal)\n\t\tEXT4_SET_INCOMPAT_FEATURE(sb, EXT4_FEATURE_INCOMPAT_RECOVER);\n\n\text4_commit_super(sb, 1);\ndone:\n\tif (test_opt(sb, DEBUG))\n\t\tprintk(KERN_INFO \"[EXT4 FS bs=%lu, gc=%u, \"\n\t\t\t\t\"bpg=%lu, ipg=%lu, mo=%04x, mo2=%04x]\\n\",\n\t\t\tsb->s_blocksize,\n\t\t\tsbi->s_groups_count,\n\t\t\tEXT4_BLOCKS_PER_GROUP(sb),\n\t\t\tEXT4_INODES_PER_GROUP(sb),\n\t\t\tsbi->s_mount_opt, sbi->s_mount_opt2);\n\n\tcleancache_init_fs(sb);\n\treturn res;\n}"
        }
      },
      {
        "call_info": {
          "callee": "d_make_root",
          "args": [
            "root"
          ],
          "line": 4098
        },
        "resolved": true,
        "details": {
          "function_name": "d_make_root",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "1857-1871",
          "snippet": "struct dentry *d_make_root(struct inode *root_inode)\n{\n\tstruct dentry *res = NULL;\n\n\tif (root_inode) {\n\t\tstatic const struct qstr name = QSTR_INIT(\"/\", 1);\n\n\t\tres = __d_alloc(root_inode->i_sb, &name);\n\t\tif (res)\n\t\t\td_instantiate(res, root_inode);\n\t\telse\n\t\t\tiput(root_inode);\n\t}\n\treturn res;\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nstruct dentry *d_make_root(struct inode *root_inode)\n{\n\tstruct dentry *res = NULL;\n\n\tif (root_inode) {\n\t\tstatic const struct qstr name = QSTR_INIT(\"/\", 1);\n\n\t\tres = __d_alloc(root_inode->i_sb, &name);\n\t\tif (res)\n\t\t\td_instantiate(res, root_inode);\n\t\telse\n\t\t\tiput(root_inode);\n\t}\n\treturn res;\n}"
        }
      },
      {
        "call_info": {
          "callee": "iput",
          "args": [
            "root"
          ],
          "line": 4095
        },
        "resolved": true,
        "details": {
          "function_name": "dentry_iput",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "308-327",
          "snippet": "static void dentry_iput(struct dentry * dentry)\n\t__releases(dentry->d_lock)\n\t__releases(dentry->d_inode->i_lock)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tif (inode) {\n\t\tdentry->d_inode = NULL;\n\t\thlist_del_init(&dentry->d_u.d_alias);\n\t\tspin_unlock(&dentry->d_lock);\n\t\tspin_unlock(&inode->i_lock);\n\t\tif (!inode->i_nlink)\n\t\t\tfsnotify_inoderemove(inode);\n\t\tif (dentry->d_op && dentry->d_op->d_iput)\n\t\t\tdentry->d_op->d_iput(dentry, inode);\n\t\telse\n\t\t\tiput(inode);\n\t} else {\n\t\tspin_unlock(&dentry->d_lock);\n\t}\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nstatic void dentry_iput(struct dentry * dentry)\n\t__releases(dentry->d_lock)\n\t__releases(dentry->d_inode->i_lock)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tif (inode) {\n\t\tdentry->d_inode = NULL;\n\t\thlist_del_init(&dentry->d_u.d_alias);\n\t\tspin_unlock(&dentry->d_lock);\n\t\tspin_unlock(&inode->i_lock);\n\t\tif (!inode->i_nlink)\n\t\t\tfsnotify_inoderemove(inode);\n\t\tif (dentry->d_op && dentry->d_op->d_iput)\n\t\t\tdentry->d_op->d_iput(dentry, inode);\n\t\telse\n\t\t\tiput(inode);\n\t} else {\n\t\tspin_unlock(&dentry->d_lock);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "S_ISDIR",
          "args": [
            "root->i_mode"
          ],
          "line": 4093
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "root"
          ],
          "line": 4089
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "root"
          ],
          "line": 4087
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_iget",
          "args": [
            "sb",
            "EXT4_ROOT_INO"
          ],
          "line": 4086
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_iget_normal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/inode.c",
          "lines": "4138-4143",
          "snippet": "struct inode *ext4_iget_normal(struct super_block *sb, unsigned long ino)\n{\n\tif (ino < EXT4_FIRST_INO(sb) && ino != EXT4_ROOT_INO)\n\t\treturn ERR_PTR(-EIO);\n\treturn ext4_iget(sb, ino);\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"truncate.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include <linux/bitops.h>",
            "#include <linux/aio.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/printk.h>",
            "#include <linux/kernel.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/bio.h>",
            "#include <linux/uio.h>",
            "#include <linux/namei.h>",
            "#include <linux/mpage.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highuid.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/time.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"truncate.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include <linux/bitops.h>\n#include <linux/aio.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/printk.h>\n#include <linux/kernel.h>\n#include <linux/workqueue.h>\n#include <linux/bio.h>\n#include <linux/uio.h>\n#include <linux/namei.h>\n#include <linux/mpage.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/highuid.h>\n#include <linux/jbd2.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n\nstruct inode *ext4_iget_normal(struct super_block *sb, unsigned long ino)\n{\n\tif (ino < EXT4_FIRST_INO(sb) && ino != EXT4_ROOT_INO)\n\t\treturn ERR_PTR(-EIO);\n\treturn ext4_iget(sb, ino);\n}"
        }
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_ERR \"EXT4-fs: failed to create workqueue\\n\""
          ],
          "line": 4076
        },
        "resolved": true,
        "details": {
          "function_name": "compat_printk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/compat.c",
          "lines": "59-69",
          "snippet": "int compat_printk(const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\tif (!compat_log)\n\t\treturn 0;\n\tva_start(ap, fmt);\n\tret = vprintk(fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/ioctls.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/aio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/mm.h>",
            "#include <linux/poll.h>",
            "#include <linux/signal.h>",
            "#include <linux/highmem.h>",
            "#include <linux/security.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/personality.h>",
            "#include <linux/highuid.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/dirent.h>",
            "#include <linux/ctype.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/nfs4_mount.h>",
            "#include <linux/ncp_mount.h>",
            "#include <linux/init.h>",
            "#include <linux/ioctl.h>",
            "#include <linux/vfs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/namei.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/errno.h>",
            "#include <linux/compat.h>",
            "#include <linux/linkage.h>",
            "#include <linux/kernel.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int compat_log = 1;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/ioctls.h>\n#include <asm/mmu_context.h>\n#include <asm/uaccess.h>\n#include <linux/aio.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/fs_struct.h>\n#include <linux/mm.h>\n#include <linux/poll.h>\n#include <linux/signal.h>\n#include <linux/highmem.h>\n#include <linux/security.h>\n#include <linux/tsacct_kern.h>\n#include <linux/rwsem.h>\n#include <linux/personality.h>\n#include <linux/highuid.h>\n#include <linux/fsnotify.h>\n#include <linux/dirent.h>\n#include <linux/ctype.h>\n#include <linux/syscalls.h>\n#include <linux/nfs4_mount.h>\n#include <linux/ncp_mount.h>\n#include <linux/init.h>\n#include <linux/ioctl.h>\n#include <linux/vfs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/namei.h>\n#include <linux/fcntl.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <linux/compat.h>\n#include <linux/linkage.h>\n#include <linux/kernel.h>\n#include <linux/stddef.h>\n\nint compat_log = 1;\n\nint compat_printk(const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\tif (!compat_log)\n\t\treturn 0;\n\tva_start(ap, fmt);\n\tret = vprintk(fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "alloc_workqueue",
          "args": [
            "\"ext4-rsv-conversion\"",
            "WQ_MEM_RECLAIM | WQ_UNBOUND",
            "1"
          ],
          "line": 4074
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_calculate_overhead",
          "args": [
            "sb"
          ],
          "line": 4064
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_calculate_overhead",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/super.c",
          "lines": "3322-3364",
          "snippet": "int ext4_calculate_overhead(struct super_block *sb)\n{\n\tstruct ext4_sb_info *sbi = EXT4_SB(sb);\n\tstruct ext4_super_block *es = sbi->s_es;\n\text4_group_t i, ngroups = ext4_get_groups_count(sb);\n\text4_fsblk_t overhead = 0;\n\tchar *buf = (char *) get_zeroed_page(GFP_NOFS);\n\n\tif (!buf)\n\t\treturn -ENOMEM;\n\n\t/*\n\t * Compute the overhead (FS structures).  This is constant\n\t * for a given filesystem unless the number of block groups\n\t * changes so we cache the previous value until it does.\n\t */\n\n\t/*\n\t * All of the blocks before first_data_block are overhead\n\t */\n\toverhead = EXT4_B2C(sbi, le32_to_cpu(es->s_first_data_block));\n\n\t/*\n\t * Add the overhead found in each block group\n\t */\n\tfor (i = 0; i < ngroups; i++) {\n\t\tint blks;\n\n\t\tblks = count_overhead(sb, i, buf);\n\t\toverhead += blks;\n\t\tif (blks)\n\t\t\tmemset(buf, 0, PAGE_SIZE);\n\t\tcond_resched();\n\t}\n\t/* Add the internal journal blocks as well */\n\tif (sbi->s_journal && !sbi->journal_bdev)\n\t\toverhead += EXT4_NUM_B2C(sbi, sbi->s_journal->j_maxlen);\n\n\tsbi->s_overhead = overhead;\n\tsmp_wmb();\n\tfree_page((unsigned long) buf);\n\treturn 0;\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"mballoc.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include \"ext4_extents.h\"\t/* Needed for trace points definition */",
            "#include \"ext4.h\"",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/crc16.h>",
            "#include <linux/log2.h>",
            "#include <linux/ctype.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/random.h>",
            "#include <linux/vfs.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/parser.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/time.h>",
            "#include <linux/fs.h>",
            "#include <linux/string.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void ext4_mark_recovery_complete(struct super_block *sb,\n\t\t\t\t\tstruct ext4_super_block *es);",
            "static void ext4_clear_journal_err(struct super_block *sb,\n\t\t\t\t   struct ext4_super_block *es);",
            "static int ext4_statfs(struct dentry *dentry, struct kstatfs *buf);",
            "static int ext4_unfreeze(struct super_block *sb);",
            "static int ext4_freeze(struct super_block *sb);",
            "static inline int ext2_feature_set_ok(struct super_block *sb);",
            "static inline int ext3_feature_set_ok(struct super_block *sb);",
            "static void ext4_unregister_li_request(struct super_block *sb);",
            "static int ext4_reserve_clusters(struct ext4_sb_info *, ext4_fsblk_t);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"mballoc.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4_extents.h\"\t/* Needed for trace points definition */\n#include \"ext4.h\"\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <asm/uaccess.h>\n#include <linux/cleancache.h>\n#include <linux/crc16.h>\n#include <linux/log2.h>\n#include <linux/ctype.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/random.h>\n#include <linux/vfs.h>\n#include <linux/exportfs.h>\n#include <linux/buffer_head.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/jbd2.h>\n#include <linux/vmalloc.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n#include <linux/string.h>\n#include <linux/module.h>\n\nstatic void ext4_mark_recovery_complete(struct super_block *sb,\n\t\t\t\t\tstruct ext4_super_block *es);\nstatic void ext4_clear_journal_err(struct super_block *sb,\n\t\t\t\t   struct ext4_super_block *es);\nstatic int ext4_statfs(struct dentry *dentry, struct kstatfs *buf);\nstatic int ext4_unfreeze(struct super_block *sb);\nstatic int ext4_freeze(struct super_block *sb);\nstatic inline int ext2_feature_set_ok(struct super_block *sb);\nstatic inline int ext3_feature_set_ok(struct super_block *sb);\nstatic void ext4_unregister_li_request(struct super_block *sb);\nstatic int ext4_reserve_clusters(struct ext4_sb_info *, ext4_fsblk_t);\n\nint ext4_calculate_overhead(struct super_block *sb)\n{\n\tstruct ext4_sb_info *sbi = EXT4_SB(sb);\n\tstruct ext4_super_block *es = sbi->s_es;\n\text4_group_t i, ngroups = ext4_get_groups_count(sb);\n\text4_fsblk_t overhead = 0;\n\tchar *buf = (char *) get_zeroed_page(GFP_NOFS);\n\n\tif (!buf)\n\t\treturn -ENOMEM;\n\n\t/*\n\t * Compute the overhead (FS structures).  This is constant\n\t * for a given filesystem unless the number of block groups\n\t * changes so we cache the previous value until it does.\n\t */\n\n\t/*\n\t * All of the blocks before first_data_block are overhead\n\t */\n\toverhead = EXT4_B2C(sbi, le32_to_cpu(es->s_first_data_block));\n\n\t/*\n\t * Add the overhead found in each block group\n\t */\n\tfor (i = 0; i < ngroups; i++) {\n\t\tint blks;\n\n\t\tblks = count_overhead(sb, i, buf);\n\t\toverhead += blks;\n\t\tif (blks)\n\t\t\tmemset(buf, 0, PAGE_SIZE);\n\t\tcond_resched();\n\t}\n\t/* Add the internal journal blocks as well */\n\tif (sbi->s_journal && !sbi->journal_bdev)\n\t\toverhead += EXT4_NUM_B2C(sbi, sbi->s_journal->j_maxlen);\n\n\tsbi->s_overhead = overhead;\n\tsmp_wmb();\n\tfree_page((unsigned long) buf);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "es->s_overhead_clusters"
          ],
          "line": 4062
        },
        "resolved": true,
        "details": {
          "function_name": "sle32_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "53-56",
          "snippet": "static inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_xattr_create_cache",
          "args": [
            "sb->s_id"
          ],
          "line": 4050
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_xattr_create_cache",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/xattr.c",
          "lines": "1718-1722",
          "snippet": "struct mb_cache *\next4_xattr_create_cache(char *name)\n{\n\treturn mb_cache_create(name, HASH_BUCKET_BITS);\n}",
          "includes": [
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include <linux/rwsem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [
            "#define\tHASH_BUCKET_BITS\t10"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4.h\"\n#include \"ext4_jbd2.h\"\n#include <linux/rwsem.h>\n#include <linux/quotaops.h>\n#include <linux/mbcache.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n\n#define\tHASH_BUCKET_BITS\t10\n\nstruct mb_cache *\next4_xattr_create_cache(char *name)\n{\n\treturn mb_cache_create(name, HASH_BUCKET_BITS);\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_task_ioprio",
          "args": [
            "sbi->s_journal->j_task",
            "journal_ioprio"
          ],
          "line": 4044
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "jbd2_journal_check_available_features",
          "args": [
            "sbi->s_journal",
            "0",
            "0",
            "JBD2_FEATURE_INCOMPAT_REVOKE"
          ],
          "line": 4035
        },
        "resolved": true,
        "details": {
          "function_name": "jbd2_journal_check_available_features",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd2/journal.c",
          "lines": "1775-1794",
          "snippet": "int jbd2_journal_check_available_features (journal_t *journal, unsigned long compat,\n\t\t\t\t      unsigned long ro, unsigned long incompat)\n{\n\tif (!compat && !ro && !incompat)\n\t\treturn 1;\n\n\t/* We can support any known requested features iff the\n\t * superblock is in version 2.  Otherwise we fail to support any\n\t * extended sb features. */\n\n\tif (journal->j_format_version != 2)\n\t\treturn 0;\n\n\tif ((compat   & JBD2_KNOWN_COMPAT_FEATURES) == compat &&\n\t    (ro       & JBD2_KNOWN_ROCOMPAT_FEATURES) == ro &&\n\t    (incompat & JBD2_KNOWN_INCOMPAT_FEATURES) == incompat)\n\t\treturn 1;\n\n\treturn 0;\n}",
          "includes": [
            "#include <asm/page.h>",
            "#include <asm/uaccess.h>",
            "#include <trace/events/jbd2.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/bitops.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/log2.h>",
            "#include <linux/hash.h>",
            "#include <linux/math64.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/poison.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <trace/events/jbd2.h>\n#include <linux/ratelimit.h>\n#include <linux/bitops.h>\n#include <linux/backing-dev.h>\n#include <linux/vmalloc.h>\n#include <linux/log2.h>\n#include <linux/hash.h>\n#include <linux/math64.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/poison.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/freezer.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd2.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/module.h>\n\nint jbd2_journal_check_available_features (journal_t *journal, unsigned long compat,\n\t\t\t\t      unsigned long ro, unsigned long incompat)\n{\n\tif (!compat && !ro && !incompat)\n\t\treturn 1;\n\n\t/* We can support any known requested features iff the\n\t * superblock is in version 2.  Otherwise we fail to support any\n\t * extended sb features. */\n\n\tif (journal->j_format_version != 2)\n\t\treturn 0;\n\n\tif ((compat   & JBD2_KNOWN_COMPAT_FEATURES) == compat &&\n\t    (ro       & JBD2_KNOWN_ROCOMPAT_FEATURES) == ro &&\n\t    (incompat & JBD2_KNOWN_INCOMPAT_FEATURES) == incompat)\n\t\treturn 1;\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_opt",
          "args": [
            "sb",
            "JOURNAL_DATA"
          ],
          "line": 4030
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_check_set_options",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/super.c",
          "lines": "1239-1271",
          "snippet": "static int ocfs2_check_set_options(struct super_block *sb,\n\t\t\t\t   struct mount_options *options)\n{\n\tif (options->mount_opt & OCFS2_MOUNT_USRQUOTA &&\n\t    !OCFS2_HAS_RO_COMPAT_FEATURE(sb,\n\t\t\t\t\t OCFS2_FEATURE_RO_COMPAT_USRQUOTA)) {\n\t\tmlog(ML_ERROR, \"User quotas were requested, but this \"\n\t\t     \"filesystem does not have the feature enabled.\\n\");\n\t\treturn 0;\n\t}\n\tif (options->mount_opt & OCFS2_MOUNT_GRPQUOTA &&\n\t    !OCFS2_HAS_RO_COMPAT_FEATURE(sb,\n\t\t\t\t\t OCFS2_FEATURE_RO_COMPAT_GRPQUOTA)) {\n\t\tmlog(ML_ERROR, \"Group quotas were requested, but this \"\n\t\t     \"filesystem does not have the feature enabled.\\n\");\n\t\treturn 0;\n\t}\n\tif (options->mount_opt & OCFS2_MOUNT_POSIX_ACL &&\n\t    !OCFS2_HAS_INCOMPAT_FEATURE(sb, OCFS2_FEATURE_INCOMPAT_XATTR)) {\n\t\tmlog(ML_ERROR, \"ACL support requested but extended attributes \"\n\t\t     \"feature is not enabled\\n\");\n\t\treturn 0;\n\t}\n\t/* No ACL setting specified? Use XATTR feature... */\n\tif (!(options->mount_opt & (OCFS2_MOUNT_POSIX_ACL |\n\t\t\t\t    OCFS2_MOUNT_NO_POSIX_ACL))) {\n\t\tif (OCFS2_HAS_INCOMPAT_FEATURE(sb, OCFS2_FEATURE_INCOMPAT_XATTR))\n\t\t\toptions->mount_opt |= OCFS2_MOUNT_POSIX_ACL;\n\t\telse\n\t\t\toptions->mount_opt |= OCFS2_MOUNT_NO_POSIX_ACL;\n\t}\n\treturn 1;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"suballoc.h\"",
            "#include \"refcounttree.h\"",
            "#include \"quota.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"namei.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"extent_map.h\"",
            "#include \"export.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs1_fs_compat.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include \"ocfs2_trace.h\"",
            "#include <linux/cleancache.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mount.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/crc32.h>",
            "#include <linux/parser.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/statfs.h>",
            "#include <linux/random.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ocfs2_check_set_options(struct super_block *sb,\n\t\t\t\t   struct mount_options *options);",
            "static void ocfs2_put_super(struct super_block *sb);",
            "static int ocfs2_mount_volume(struct super_block *sb);",
            "static struct inode *ocfs2_alloc_inode(struct super_block *sb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"suballoc.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"namei.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"export.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs1_fs_compat.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include \"ocfs2_trace.h\"\n#include <linux/cleancache.h>\n#include <linux/quotaops.h>\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n#include <linux/debugfs.h>\n#include <linux/crc32.h>\n#include <linux/parser.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/moduleparam.h>\n#include <linux/statfs.h>\n#include <linux/random.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic int ocfs2_check_set_options(struct super_block *sb,\n\t\t\t\t   struct mount_options *options);\nstatic void ocfs2_put_super(struct super_block *sb);\nstatic int ocfs2_mount_volume(struct super_block *sb);\nstatic struct inode *ocfs2_alloc_inode(struct super_block *sb);\n\nstatic int ocfs2_check_set_options(struct super_block *sb,\n\t\t\t\t   struct mount_options *options)\n{\n\tif (options->mount_opt & OCFS2_MOUNT_USRQUOTA &&\n\t    !OCFS2_HAS_RO_COMPAT_FEATURE(sb,\n\t\t\t\t\t OCFS2_FEATURE_RO_COMPAT_USRQUOTA)) {\n\t\tmlog(ML_ERROR, \"User quotas were requested, but this \"\n\t\t     \"filesystem does not have the feature enabled.\\n\");\n\t\treturn 0;\n\t}\n\tif (options->mount_opt & OCFS2_MOUNT_GRPQUOTA &&\n\t    !OCFS2_HAS_RO_COMPAT_FEATURE(sb,\n\t\t\t\t\t OCFS2_FEATURE_RO_COMPAT_GRPQUOTA)) {\n\t\tmlog(ML_ERROR, \"Group quotas were requested, but this \"\n\t\t     \"filesystem does not have the feature enabled.\\n\");\n\t\treturn 0;\n\t}\n\tif (options->mount_opt & OCFS2_MOUNT_POSIX_ACL &&\n\t    !OCFS2_HAS_INCOMPAT_FEATURE(sb, OCFS2_FEATURE_INCOMPAT_XATTR)) {\n\t\tmlog(ML_ERROR, \"ACL support requested but extended attributes \"\n\t\t     \"feature is not enabled\\n\");\n\t\treturn 0;\n\t}\n\t/* No ACL setting specified? Use XATTR feature... */\n\tif (!(options->mount_opt & (OCFS2_MOUNT_POSIX_ACL |\n\t\t\t\t    OCFS2_MOUNT_NO_POSIX_ACL))) {\n\t\tif (OCFS2_HAS_INCOMPAT_FEATURE(sb, OCFS2_FEATURE_INCOMPAT_XATTR))\n\t\t\toptions->mount_opt |= OCFS2_MOUNT_POSIX_ACL;\n\t\telse\n\t\t\toptions->mount_opt |= OCFS2_MOUNT_NO_POSIX_ACL;\n\t}\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "test_opt",
          "args": [
            "sb",
            "DATA_FLAGS"
          ],
          "line": 4020
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_journal_csum_feature_set",
          "args": [
            "sb"
          ],
          "line": 4012
        },
        "resolved": true,
        "details": {
          "function_name": "set_journal_csum_feature_set",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/super.c",
          "lines": "3212-3249",
          "snippet": "static int set_journal_csum_feature_set(struct super_block *sb)\n{\n\tint ret = 1;\n\tint compat, incompat;\n\tstruct ext4_sb_info *sbi = EXT4_SB(sb);\n\n\tif (ext4_has_metadata_csum(sb)) {\n\t\t/* journal checksum v3 */\n\t\tcompat = 0;\n\t\tincompat = JBD2_FEATURE_INCOMPAT_CSUM_V3;\n\t} else {\n\t\t/* journal checksum v1 */\n\t\tcompat = JBD2_FEATURE_COMPAT_CHECKSUM;\n\t\tincompat = 0;\n\t}\n\n\tjbd2_journal_clear_features(sbi->s_journal,\n\t\t\tJBD2_FEATURE_COMPAT_CHECKSUM, 0,\n\t\t\tJBD2_FEATURE_INCOMPAT_CSUM_V3 |\n\t\t\tJBD2_FEATURE_INCOMPAT_CSUM_V2);\n\tif (test_opt(sb, JOURNAL_ASYNC_COMMIT)) {\n\t\tret = jbd2_journal_set_features(sbi->s_journal,\n\t\t\t\tcompat, 0,\n\t\t\t\tJBD2_FEATURE_INCOMPAT_ASYNC_COMMIT |\n\t\t\t\tincompat);\n\t} else if (test_opt(sb, JOURNAL_CHECKSUM)) {\n\t\tret = jbd2_journal_set_features(sbi->s_journal,\n\t\t\t\tcompat, 0,\n\t\t\t\tincompat);\n\t\tjbd2_journal_clear_features(sbi->s_journal, 0, 0,\n\t\t\t\tJBD2_FEATURE_INCOMPAT_ASYNC_COMMIT);\n\t} else {\n\t\tjbd2_journal_clear_features(sbi->s_journal, 0, 0,\n\t\t\t\tJBD2_FEATURE_INCOMPAT_ASYNC_COMMIT);\n\t}\n\n\treturn ret;\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"mballoc.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include \"ext4_extents.h\"\t/* Needed for trace points definition */",
            "#include \"ext4.h\"",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/crc16.h>",
            "#include <linux/log2.h>",
            "#include <linux/ctype.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/random.h>",
            "#include <linux/vfs.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/parser.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/time.h>",
            "#include <linux/fs.h>",
            "#include <linux/string.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ext4_unfreeze(struct super_block *sb);",
            "static int ext4_freeze(struct super_block *sb);",
            "static inline int ext2_feature_set_ok(struct super_block *sb);",
            "static inline int ext3_feature_set_ok(struct super_block *sb);",
            "static void ext4_unregister_li_request(struct super_block *sb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"mballoc.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4_extents.h\"\t/* Needed for trace points definition */\n#include \"ext4.h\"\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <asm/uaccess.h>\n#include <linux/cleancache.h>\n#include <linux/crc16.h>\n#include <linux/log2.h>\n#include <linux/ctype.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/random.h>\n#include <linux/vfs.h>\n#include <linux/exportfs.h>\n#include <linux/buffer_head.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/jbd2.h>\n#include <linux/vmalloc.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n#include <linux/string.h>\n#include <linux/module.h>\n\nstatic int ext4_unfreeze(struct super_block *sb);\nstatic int ext4_freeze(struct super_block *sb);\nstatic inline int ext2_feature_set_ok(struct super_block *sb);\nstatic inline int ext3_feature_set_ok(struct super_block *sb);\nstatic void ext4_unregister_li_request(struct super_block *sb);\n\nstatic int set_journal_csum_feature_set(struct super_block *sb)\n{\n\tint ret = 1;\n\tint compat, incompat;\n\tstruct ext4_sb_info *sbi = EXT4_SB(sb);\n\n\tif (ext4_has_metadata_csum(sb)) {\n\t\t/* journal checksum v3 */\n\t\tcompat = 0;\n\t\tincompat = JBD2_FEATURE_INCOMPAT_CSUM_V3;\n\t} else {\n\t\t/* journal checksum v1 */\n\t\tcompat = JBD2_FEATURE_COMPAT_CHECKSUM;\n\t\tincompat = 0;\n\t}\n\n\tjbd2_journal_clear_features(sbi->s_journal,\n\t\t\tJBD2_FEATURE_COMPAT_CHECKSUM, 0,\n\t\t\tJBD2_FEATURE_INCOMPAT_CSUM_V3 |\n\t\t\tJBD2_FEATURE_INCOMPAT_CSUM_V2);\n\tif (test_opt(sb, JOURNAL_ASYNC_COMMIT)) {\n\t\tret = jbd2_journal_set_features(sbi->s_journal,\n\t\t\t\tcompat, 0,\n\t\t\t\tJBD2_FEATURE_INCOMPAT_ASYNC_COMMIT |\n\t\t\t\tincompat);\n\t} else if (test_opt(sb, JOURNAL_CHECKSUM)) {\n\t\tret = jbd2_journal_set_features(sbi->s_journal,\n\t\t\t\tcompat, 0,\n\t\t\t\tincompat);\n\t\tjbd2_journal_clear_features(sbi->s_journal, 0, 0,\n\t\t\t\tJBD2_FEATURE_INCOMPAT_ASYNC_COMMIT);\n\t} else {\n\t\tjbd2_journal_clear_features(sbi->s_journal, 0, 0,\n\t\t\t\tJBD2_FEATURE_INCOMPAT_ASYNC_COMMIT);\n\t}\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "jbd2_journal_set_features",
          "args": [
            "EXT4_SB(sb)->s_journal",
            "0",
            "0",
            "JBD2_FEATURE_INCOMPAT_64BIT"
          ],
          "line": 4006
        },
        "resolved": true,
        "details": {
          "function_name": "jbd2_journal_set_features",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd2/journal.c",
          "lines": "1808-1876",
          "snippet": "int jbd2_journal_set_features (journal_t *journal, unsigned long compat,\n\t\t\t  unsigned long ro, unsigned long incompat)\n{\n#define INCOMPAT_FEATURE_ON(f) \\\n\t\t((incompat & (f)) && !(sb->s_feature_incompat & cpu_to_be32(f)))\n#define COMPAT_FEATURE_ON(f) \\\n\t\t((compat & (f)) && !(sb->s_feature_compat & cpu_to_be32(f)))\n\tjournal_superblock_t *sb;\n\n\tif (jbd2_journal_check_used_features(journal, compat, ro, incompat))\n\t\treturn 1;\n\n\tif (!jbd2_journal_check_available_features(journal, compat, ro, incompat))\n\t\treturn 0;\n\n\t/* If enabling v2 checksums, turn on v3 instead */\n\tif (incompat & JBD2_FEATURE_INCOMPAT_CSUM_V2) {\n\t\tincompat &= ~JBD2_FEATURE_INCOMPAT_CSUM_V2;\n\t\tincompat |= JBD2_FEATURE_INCOMPAT_CSUM_V3;\n\t}\n\n\t/* Asking for checksumming v3 and v1?  Only give them v3. */\n\tif (incompat & JBD2_FEATURE_INCOMPAT_CSUM_V3 &&\n\t    compat & JBD2_FEATURE_COMPAT_CHECKSUM)\n\t\tcompat &= ~JBD2_FEATURE_COMPAT_CHECKSUM;\n\n\tjbd_debug(1, \"Setting new features 0x%lx/0x%lx/0x%lx\\n\",\n\t\t  compat, ro, incompat);\n\n\tsb = journal->j_superblock;\n\n\t/* If enabling v3 checksums, update superblock */\n\tif (INCOMPAT_FEATURE_ON(JBD2_FEATURE_INCOMPAT_CSUM_V3)) {\n\t\tsb->s_checksum_type = JBD2_CRC32C_CHKSUM;\n\t\tsb->s_feature_compat &=\n\t\t\t~cpu_to_be32(JBD2_FEATURE_COMPAT_CHECKSUM);\n\n\t\t/* Load the checksum driver */\n\t\tif (journal->j_chksum_driver == NULL) {\n\t\t\tjournal->j_chksum_driver = crypto_alloc_shash(\"crc32c\",\n\t\t\t\t\t\t\t\t      0, 0);\n\t\t\tif (IS_ERR(journal->j_chksum_driver)) {\n\t\t\t\tprintk(KERN_ERR \"JBD2: Cannot load crc32c \"\n\t\t\t\t       \"driver.\\n\");\n\t\t\t\tjournal->j_chksum_driver = NULL;\n\t\t\t\treturn 0;\n\t\t\t}\n\n\t\t\t/* Precompute checksum seed for all metadata */\n\t\t\tjournal->j_csum_seed = jbd2_chksum(journal, ~0,\n\t\t\t\t\t\t\t   sb->s_uuid,\n\t\t\t\t\t\t\t   sizeof(sb->s_uuid));\n\t\t}\n\t}\n\n\t/* If enabling v1 checksums, downgrade superblock */\n\tif (COMPAT_FEATURE_ON(JBD2_FEATURE_COMPAT_CHECKSUM))\n\t\tsb->s_feature_incompat &=\n\t\t\t~cpu_to_be32(JBD2_FEATURE_INCOMPAT_CSUM_V2 |\n\t\t\t\t     JBD2_FEATURE_INCOMPAT_CSUM_V3);\n\n\tsb->s_feature_compat    |= cpu_to_be32(compat);\n\tsb->s_feature_ro_compat |= cpu_to_be32(ro);\n\tsb->s_feature_incompat  |= cpu_to_be32(incompat);\n\n\treturn 1;\n#undef COMPAT_FEATURE_ON\n#undef INCOMPAT_FEATURE_ON\n}",
          "includes": [
            "#include <asm/page.h>",
            "#include <asm/uaccess.h>",
            "#include <trace/events/jbd2.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/bitops.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/log2.h>",
            "#include <linux/hash.h>",
            "#include <linux/math64.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/poison.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <trace/events/jbd2.h>\n#include <linux/ratelimit.h>\n#include <linux/bitops.h>\n#include <linux/backing-dev.h>\n#include <linux/vmalloc.h>\n#include <linux/log2.h>\n#include <linux/hash.h>\n#include <linux/math64.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/poison.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/freezer.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd2.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/module.h>\n\nint jbd2_journal_set_features (journal_t *journal, unsigned long compat,\n\t\t\t  unsigned long ro, unsigned long incompat)\n{\n#define INCOMPAT_FEATURE_ON(f) \\\n\t\t((incompat & (f)) && !(sb->s_feature_incompat & cpu_to_be32(f)))\n#define COMPAT_FEATURE_ON(f) \\\n\t\t((compat & (f)) && !(sb->s_feature_compat & cpu_to_be32(f)))\n\tjournal_superblock_t *sb;\n\n\tif (jbd2_journal_check_used_features(journal, compat, ro, incompat))\n\t\treturn 1;\n\n\tif (!jbd2_journal_check_available_features(journal, compat, ro, incompat))\n\t\treturn 0;\n\n\t/* If enabling v2 checksums, turn on v3 instead */\n\tif (incompat & JBD2_FEATURE_INCOMPAT_CSUM_V2) {\n\t\tincompat &= ~JBD2_FEATURE_INCOMPAT_CSUM_V2;\n\t\tincompat |= JBD2_FEATURE_INCOMPAT_CSUM_V3;\n\t}\n\n\t/* Asking for checksumming v3 and v1?  Only give them v3. */\n\tif (incompat & JBD2_FEATURE_INCOMPAT_CSUM_V3 &&\n\t    compat & JBD2_FEATURE_COMPAT_CHECKSUM)\n\t\tcompat &= ~JBD2_FEATURE_COMPAT_CHECKSUM;\n\n\tjbd_debug(1, \"Setting new features 0x%lx/0x%lx/0x%lx\\n\",\n\t\t  compat, ro, incompat);\n\n\tsb = journal->j_superblock;\n\n\t/* If enabling v3 checksums, update superblock */\n\tif (INCOMPAT_FEATURE_ON(JBD2_FEATURE_INCOMPAT_CSUM_V3)) {\n\t\tsb->s_checksum_type = JBD2_CRC32C_CHKSUM;\n\t\tsb->s_feature_compat &=\n\t\t\t~cpu_to_be32(JBD2_FEATURE_COMPAT_CHECKSUM);\n\n\t\t/* Load the checksum driver */\n\t\tif (journal->j_chksum_driver == NULL) {\n\t\t\tjournal->j_chksum_driver = crypto_alloc_shash(\"crc32c\",\n\t\t\t\t\t\t\t\t      0, 0);\n\t\t\tif (IS_ERR(journal->j_chksum_driver)) {\n\t\t\t\tprintk(KERN_ERR \"JBD2: Cannot load crc32c \"\n\t\t\t\t       \"driver.\\n\");\n\t\t\t\tjournal->j_chksum_driver = NULL;\n\t\t\t\treturn 0;\n\t\t\t}\n\n\t\t\t/* Precompute checksum seed for all metadata */\n\t\t\tjournal->j_csum_seed = jbd2_chksum(journal, ~0,\n\t\t\t\t\t\t\t   sb->s_uuid,\n\t\t\t\t\t\t\t   sizeof(sb->s_uuid));\n\t\t}\n\t}\n\n\t/* If enabling v1 checksums, downgrade superblock */\n\tif (COMPAT_FEATURE_ON(JBD2_FEATURE_COMPAT_CHECKSUM))\n\t\tsb->s_feature_incompat &=\n\t\t\t~cpu_to_be32(JBD2_FEATURE_INCOMPAT_CSUM_V2 |\n\t\t\t\t     JBD2_FEATURE_INCOMPAT_CSUM_V3);\n\n\tsb->s_feature_compat    |= cpu_to_be32(compat);\n\tsb->s_feature_ro_compat |= cpu_to_be32(ro);\n\tsb->s_feature_incompat  |= cpu_to_be32(incompat);\n\n\treturn 1;\n#undef COMPAT_FEATURE_ON\n#undef INCOMPAT_FEATURE_ON\n}"
        }
      },
      {
        "call_info": {
          "callee": "EXT4_HAS_INCOMPAT_FEATURE",
          "args": [
            "sb",
            "EXT4_FEATURE_INCOMPAT_64BIT"
          ],
          "line": 4005
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "clear_opt",
          "args": [
            "sb",
            "DATA_FLAGS"
          ],
          "line": 3999
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXT4_HAS_INCOMPAT_FEATURE",
          "args": [
            "sb",
            "EXT4_FEATURE_INCOMPAT_RECOVER"
          ],
          "line": 3994
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_opt",
          "args": [
            "sb",
            "NOLOAD"
          ],
          "line": 3993
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_load_journal",
          "args": [
            "sb",
            "es",
            "journal_devnum"
          ],
          "line": 3991
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_load_journal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/super.c",
          "lines": "4475-4565",
          "snippet": "static int ext4_load_journal(struct super_block *sb,\n\t\t\t     struct ext4_super_block *es,\n\t\t\t     unsigned long journal_devnum)\n{\n\tjournal_t *journal;\n\tunsigned int journal_inum = le32_to_cpu(es->s_journal_inum);\n\tdev_t journal_dev;\n\tint err = 0;\n\tint really_read_only;\n\n\tBUG_ON(!EXT4_HAS_COMPAT_FEATURE(sb, EXT4_FEATURE_COMPAT_HAS_JOURNAL));\n\n\tif (journal_devnum &&\n\t    journal_devnum != le32_to_cpu(es->s_journal_dev)) {\n\t\text4_msg(sb, KERN_INFO, \"external journal device major/minor \"\n\t\t\t\"numbers have changed\");\n\t\tjournal_dev = new_decode_dev(journal_devnum);\n\t} else\n\t\tjournal_dev = new_decode_dev(le32_to_cpu(es->s_journal_dev));\n\n\treally_read_only = bdev_read_only(sb->s_bdev);\n\n\t/*\n\t * Are we loading a blank journal or performing recovery after a\n\t * crash?  For recovery, we need to check in advance whether we\n\t * can get read-write access to the device.\n\t */\n\tif (EXT4_HAS_INCOMPAT_FEATURE(sb, EXT4_FEATURE_INCOMPAT_RECOVER)) {\n\t\tif (sb->s_flags & MS_RDONLY) {\n\t\t\text4_msg(sb, KERN_INFO, \"INFO: recovery \"\n\t\t\t\t\t\"required on readonly filesystem\");\n\t\t\tif (really_read_only) {\n\t\t\t\text4_msg(sb, KERN_ERR, \"write access \"\n\t\t\t\t\t\"unavailable, cannot proceed\");\n\t\t\t\treturn -EROFS;\n\t\t\t}\n\t\t\text4_msg(sb, KERN_INFO, \"write access will \"\n\t\t\t       \"be enabled during recovery\");\n\t\t}\n\t}\n\n\tif (journal_inum && journal_dev) {\n\t\text4_msg(sb, KERN_ERR, \"filesystem has both journal \"\n\t\t       \"and inode journals!\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (journal_inum) {\n\t\tif (!(journal = ext4_get_journal(sb, journal_inum)))\n\t\t\treturn -EINVAL;\n\t} else {\n\t\tif (!(journal = ext4_get_dev_journal(sb, journal_dev)))\n\t\t\treturn -EINVAL;\n\t}\n\n\tif (!(journal->j_flags & JBD2_BARRIER))\n\t\text4_msg(sb, KERN_INFO, \"barriers disabled\");\n\n\tif (!EXT4_HAS_INCOMPAT_FEATURE(sb, EXT4_FEATURE_INCOMPAT_RECOVER))\n\t\terr = jbd2_journal_wipe(journal, !really_read_only);\n\tif (!err) {\n\t\tchar *save = kmalloc(EXT4_S_ERR_LEN, GFP_KERNEL);\n\t\tif (save)\n\t\t\tmemcpy(save, ((char *) es) +\n\t\t\t       EXT4_S_ERR_START, EXT4_S_ERR_LEN);\n\t\terr = jbd2_journal_load(journal);\n\t\tif (save)\n\t\t\tmemcpy(((char *) es) + EXT4_S_ERR_START,\n\t\t\t       save, EXT4_S_ERR_LEN);\n\t\tkfree(save);\n\t}\n\n\tif (err) {\n\t\text4_msg(sb, KERN_ERR, \"error loading journal\");\n\t\tjbd2_journal_destroy(journal);\n\t\treturn err;\n\t}\n\n\tEXT4_SB(sb)->s_journal = journal;\n\text4_clear_journal_err(sb, es);\n\n\tif (!really_read_only && journal_devnum &&\n\t    journal_devnum != le32_to_cpu(es->s_journal_dev)) {\n\t\tes->s_journal_dev = cpu_to_le32(journal_devnum);\n\n\t\t/* Make sure we flush the recovery flag to disk. */\n\t\text4_commit_super(sb, 1);\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"mballoc.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include \"ext4_extents.h\"\t/* Needed for trace points definition */",
            "#include \"ext4.h\"",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/crc16.h>",
            "#include <linux/log2.h>",
            "#include <linux/ctype.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/random.h>",
            "#include <linux/vfs.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/parser.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/time.h>",
            "#include <linux/fs.h>",
            "#include <linux/string.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ext4_load_journal(struct super_block *, struct ext4_super_block *,\n\t\t\t     unsigned long journal_devnum);",
            "static void ext4_mark_recovery_complete(struct super_block *sb,\n\t\t\t\t\tstruct ext4_super_block *es);",
            "static void ext4_clear_journal_err(struct super_block *sb,\n\t\t\t\t   struct ext4_super_block *es);",
            "static int ext4_unfreeze(struct super_block *sb);",
            "static int ext4_freeze(struct super_block *sb);",
            "static inline int ext2_feature_set_ok(struct super_block *sb);",
            "static inline int ext3_feature_set_ok(struct super_block *sb);",
            "static int ext4_feature_set_ok(struct super_block *sb, int readonly);",
            "static void ext4_unregister_li_request(struct super_block *sb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"mballoc.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4_extents.h\"\t/* Needed for trace points definition */\n#include \"ext4.h\"\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <asm/uaccess.h>\n#include <linux/cleancache.h>\n#include <linux/crc16.h>\n#include <linux/log2.h>\n#include <linux/ctype.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/random.h>\n#include <linux/vfs.h>\n#include <linux/exportfs.h>\n#include <linux/buffer_head.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/jbd2.h>\n#include <linux/vmalloc.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n#include <linux/string.h>\n#include <linux/module.h>\n\nstatic int ext4_load_journal(struct super_block *, struct ext4_super_block *,\n\t\t\t     unsigned long journal_devnum);\nstatic void ext4_mark_recovery_complete(struct super_block *sb,\n\t\t\t\t\tstruct ext4_super_block *es);\nstatic void ext4_clear_journal_err(struct super_block *sb,\n\t\t\t\t   struct ext4_super_block *es);\nstatic int ext4_unfreeze(struct super_block *sb);\nstatic int ext4_freeze(struct super_block *sb);\nstatic inline int ext2_feature_set_ok(struct super_block *sb);\nstatic inline int ext3_feature_set_ok(struct super_block *sb);\nstatic int ext4_feature_set_ok(struct super_block *sb, int readonly);\nstatic void ext4_unregister_li_request(struct super_block *sb);\n\nstatic int ext4_load_journal(struct super_block *sb,\n\t\t\t     struct ext4_super_block *es,\n\t\t\t     unsigned long journal_devnum)\n{\n\tjournal_t *journal;\n\tunsigned int journal_inum = le32_to_cpu(es->s_journal_inum);\n\tdev_t journal_dev;\n\tint err = 0;\n\tint really_read_only;\n\n\tBUG_ON(!EXT4_HAS_COMPAT_FEATURE(sb, EXT4_FEATURE_COMPAT_HAS_JOURNAL));\n\n\tif (journal_devnum &&\n\t    journal_devnum != le32_to_cpu(es->s_journal_dev)) {\n\t\text4_msg(sb, KERN_INFO, \"external journal device major/minor \"\n\t\t\t\"numbers have changed\");\n\t\tjournal_dev = new_decode_dev(journal_devnum);\n\t} else\n\t\tjournal_dev = new_decode_dev(le32_to_cpu(es->s_journal_dev));\n\n\treally_read_only = bdev_read_only(sb->s_bdev);\n\n\t/*\n\t * Are we loading a blank journal or performing recovery after a\n\t * crash?  For recovery, we need to check in advance whether we\n\t * can get read-write access to the device.\n\t */\n\tif (EXT4_HAS_INCOMPAT_FEATURE(sb, EXT4_FEATURE_INCOMPAT_RECOVER)) {\n\t\tif (sb->s_flags & MS_RDONLY) {\n\t\t\text4_msg(sb, KERN_INFO, \"INFO: recovery \"\n\t\t\t\t\t\"required on readonly filesystem\");\n\t\t\tif (really_read_only) {\n\t\t\t\text4_msg(sb, KERN_ERR, \"write access \"\n\t\t\t\t\t\"unavailable, cannot proceed\");\n\t\t\t\treturn -EROFS;\n\t\t\t}\n\t\t\text4_msg(sb, KERN_INFO, \"write access will \"\n\t\t\t       \"be enabled during recovery\");\n\t\t}\n\t}\n\n\tif (journal_inum && journal_dev) {\n\t\text4_msg(sb, KERN_ERR, \"filesystem has both journal \"\n\t\t       \"and inode journals!\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (journal_inum) {\n\t\tif (!(journal = ext4_get_journal(sb, journal_inum)))\n\t\t\treturn -EINVAL;\n\t} else {\n\t\tif (!(journal = ext4_get_dev_journal(sb, journal_dev)))\n\t\t\treturn -EINVAL;\n\t}\n\n\tif (!(journal->j_flags & JBD2_BARRIER))\n\t\text4_msg(sb, KERN_INFO, \"barriers disabled\");\n\n\tif (!EXT4_HAS_INCOMPAT_FEATURE(sb, EXT4_FEATURE_INCOMPAT_RECOVER))\n\t\terr = jbd2_journal_wipe(journal, !really_read_only);\n\tif (!err) {\n\t\tchar *save = kmalloc(EXT4_S_ERR_LEN, GFP_KERNEL);\n\t\tif (save)\n\t\t\tmemcpy(save, ((char *) es) +\n\t\t\t       EXT4_S_ERR_START, EXT4_S_ERR_LEN);\n\t\terr = jbd2_journal_load(journal);\n\t\tif (save)\n\t\t\tmemcpy(((char *) es) + EXT4_S_ERR_START,\n\t\t\t       save, EXT4_S_ERR_LEN);\n\t\tkfree(save);\n\t}\n\n\tif (err) {\n\t\text4_msg(sb, KERN_ERR, \"error loading journal\");\n\t\tjbd2_journal_destroy(journal);\n\t\treturn err;\n\t}\n\n\tEXT4_SB(sb)->s_journal = journal;\n\text4_clear_journal_err(sb, es);\n\n\tif (!really_read_only && journal_devnum &&\n\t    journal_devnum != le32_to_cpu(es->s_journal_dev)) {\n\t\tes->s_journal_dev = cpu_to_le32(journal_devnum);\n\n\t\t/* Make sure we flush the recovery flag to disk. */\n\t\text4_commit_super(sb, 1);\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "EXT4_HAS_COMPAT_FEATURE",
          "args": [
            "sb",
            "EXT4_FEATURE_COMPAT_HAS_JOURNAL"
          ],
          "line": 3990
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_opt",
          "args": [
            "sb",
            "NOLOAD"
          ],
          "line": 3989
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_multi_mount_protect",
          "args": [
            "sb",
            "le64_to_cpu(es->s_mmp_block)"
          ],
          "line": 3982
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_multi_mount_protect",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/mmp.c",
          "lines": "269-391",
          "snippet": "int ext4_multi_mount_protect(struct super_block *sb,\n\t\t\t\t    ext4_fsblk_t mmp_block)\n{\n\tstruct ext4_super_block *es = EXT4_SB(sb)->s_es;\n\tstruct buffer_head *bh = NULL;\n\tstruct mmp_struct *mmp = NULL;\n\tstruct mmpd_data *mmpd_data;\n\tu32 seq;\n\tunsigned int mmp_check_interval = le16_to_cpu(es->s_mmp_update_interval);\n\tunsigned int wait_time = 0;\n\tint retval;\n\n\tif (mmp_block < le32_to_cpu(es->s_first_data_block) ||\n\t    mmp_block >= ext4_blocks_count(es)) {\n\t\text4_warning(sb, \"Invalid MMP block in superblock\");\n\t\tgoto failed;\n\t}\n\n\tretval = read_mmp_block(sb, &bh, mmp_block);\n\tif (retval)\n\t\tgoto failed;\n\n\tmmp = (struct mmp_struct *)(bh->b_data);\n\n\tif (mmp_check_interval < EXT4_MMP_MIN_CHECK_INTERVAL)\n\t\tmmp_check_interval = EXT4_MMP_MIN_CHECK_INTERVAL;\n\n\t/*\n\t * If check_interval in MMP block is larger, use that instead of\n\t * update_interval from the superblock.\n\t */\n\tif (le16_to_cpu(mmp->mmp_check_interval) > mmp_check_interval)\n\t\tmmp_check_interval = le16_to_cpu(mmp->mmp_check_interval);\n\n\tseq = le32_to_cpu(mmp->mmp_seq);\n\tif (seq == EXT4_MMP_SEQ_CLEAN)\n\t\tgoto skip;\n\n\tif (seq == EXT4_MMP_SEQ_FSCK) {\n\t\tdump_mmp_msg(sb, mmp, \"fsck is running on the filesystem\");\n\t\tgoto failed;\n\t}\n\n\twait_time = min(mmp_check_interval * 2 + 1,\n\t\t\tmmp_check_interval + 60);\n\n\t/* Print MMP interval if more than 20 secs. */\n\tif (wait_time > EXT4_MMP_MIN_CHECK_INTERVAL * 4)\n\t\text4_warning(sb, \"MMP interval %u higher than expected, please\"\n\t\t\t     \" wait.\\n\", wait_time * 2);\n\n\tif (schedule_timeout_interruptible(HZ * wait_time) != 0) {\n\t\text4_warning(sb, \"MMP startup interrupted, failing mount\\n\");\n\t\tgoto failed;\n\t}\n\n\tretval = read_mmp_block(sb, &bh, mmp_block);\n\tif (retval)\n\t\tgoto failed;\n\tmmp = (struct mmp_struct *)(bh->b_data);\n\tif (seq != le32_to_cpu(mmp->mmp_seq)) {\n\t\tdump_mmp_msg(sb, mmp,\n\t\t\t     \"Device is already active on another node.\");\n\t\tgoto failed;\n\t}\n\nskip:\n\t/*\n\t * write a new random sequence number.\n\t */\n\tseq = mmp_new_seq();\n\tmmp->mmp_seq = cpu_to_le32(seq);\n\n\tretval = write_mmp_block(sb, bh);\n\tif (retval)\n\t\tgoto failed;\n\n\t/*\n\t * wait for MMP interval and check mmp_seq.\n\t */\n\tif (schedule_timeout_interruptible(HZ * wait_time) != 0) {\n\t\text4_warning(sb, \"MMP startup interrupted, failing mount\\n\");\n\t\tgoto failed;\n\t}\n\n\tretval = read_mmp_block(sb, &bh, mmp_block);\n\tif (retval)\n\t\tgoto failed;\n\tmmp = (struct mmp_struct *)(bh->b_data);\n\tif (seq != le32_to_cpu(mmp->mmp_seq)) {\n\t\tdump_mmp_msg(sb, mmp,\n\t\t\t     \"Device is already active on another node.\");\n\t\tgoto failed;\n\t}\n\n\tmmpd_data = kmalloc(sizeof(struct mmpd_data), GFP_KERNEL);\n\tif (!mmpd_data) {\n\t\text4_warning(sb, \"not enough memory for mmpd_data\");\n\t\tgoto failed;\n\t}\n\tmmpd_data->sb = sb;\n\tmmpd_data->bh = bh;\n\n\t/*\n\t * Start a kernel thread to update the MMP block periodically.\n\t */\n\tEXT4_SB(sb)->s_mmp_tsk = kthread_run(kmmpd, mmpd_data, \"kmmpd-%s\",\n\t\t\t\t\t     bdevname(bh->b_bdev,\n\t\t\t\t\t\t      mmp->mmp_bdevname));\n\tif (IS_ERR(EXT4_SB(sb)->s_mmp_tsk)) {\n\t\tEXT4_SB(sb)->s_mmp_tsk = NULL;\n\t\tkfree(mmpd_data);\n\t\text4_warning(sb, \"Unable to create kmmpd thread for %s.\",\n\t\t\t     sb->s_id);\n\t\tgoto failed;\n\t}\n\n\treturn 0;\n\nfailed:\n\tbrelse(bh);\n\treturn 1;\n}",
          "includes": [
            "#include \"ext4.h\"",
            "#include <linux/kthread.h>",
            "#include <linux/utsname.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/random.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ext4.h\"\n#include <linux/kthread.h>\n#include <linux/utsname.h>\n#include <linux/buffer_head.h>\n#include <linux/random.h>\n#include <linux/fs.h>\n\nint ext4_multi_mount_protect(struct super_block *sb,\n\t\t\t\t    ext4_fsblk_t mmp_block)\n{\n\tstruct ext4_super_block *es = EXT4_SB(sb)->s_es;\n\tstruct buffer_head *bh = NULL;\n\tstruct mmp_struct *mmp = NULL;\n\tstruct mmpd_data *mmpd_data;\n\tu32 seq;\n\tunsigned int mmp_check_interval = le16_to_cpu(es->s_mmp_update_interval);\n\tunsigned int wait_time = 0;\n\tint retval;\n\n\tif (mmp_block < le32_to_cpu(es->s_first_data_block) ||\n\t    mmp_block >= ext4_blocks_count(es)) {\n\t\text4_warning(sb, \"Invalid MMP block in superblock\");\n\t\tgoto failed;\n\t}\n\n\tretval = read_mmp_block(sb, &bh, mmp_block);\n\tif (retval)\n\t\tgoto failed;\n\n\tmmp = (struct mmp_struct *)(bh->b_data);\n\n\tif (mmp_check_interval < EXT4_MMP_MIN_CHECK_INTERVAL)\n\t\tmmp_check_interval = EXT4_MMP_MIN_CHECK_INTERVAL;\n\n\t/*\n\t * If check_interval in MMP block is larger, use that instead of\n\t * update_interval from the superblock.\n\t */\n\tif (le16_to_cpu(mmp->mmp_check_interval) > mmp_check_interval)\n\t\tmmp_check_interval = le16_to_cpu(mmp->mmp_check_interval);\n\n\tseq = le32_to_cpu(mmp->mmp_seq);\n\tif (seq == EXT4_MMP_SEQ_CLEAN)\n\t\tgoto skip;\n\n\tif (seq == EXT4_MMP_SEQ_FSCK) {\n\t\tdump_mmp_msg(sb, mmp, \"fsck is running on the filesystem\");\n\t\tgoto failed;\n\t}\n\n\twait_time = min(mmp_check_interval * 2 + 1,\n\t\t\tmmp_check_interval + 60);\n\n\t/* Print MMP interval if more than 20 secs. */\n\tif (wait_time > EXT4_MMP_MIN_CHECK_INTERVAL * 4)\n\t\text4_warning(sb, \"MMP interval %u higher than expected, please\"\n\t\t\t     \" wait.\\n\", wait_time * 2);\n\n\tif (schedule_timeout_interruptible(HZ * wait_time) != 0) {\n\t\text4_warning(sb, \"MMP startup interrupted, failing mount\\n\");\n\t\tgoto failed;\n\t}\n\n\tretval = read_mmp_block(sb, &bh, mmp_block);\n\tif (retval)\n\t\tgoto failed;\n\tmmp = (struct mmp_struct *)(bh->b_data);\n\tif (seq != le32_to_cpu(mmp->mmp_seq)) {\n\t\tdump_mmp_msg(sb, mmp,\n\t\t\t     \"Device is already active on another node.\");\n\t\tgoto failed;\n\t}\n\nskip:\n\t/*\n\t * write a new random sequence number.\n\t */\n\tseq = mmp_new_seq();\n\tmmp->mmp_seq = cpu_to_le32(seq);\n\n\tretval = write_mmp_block(sb, bh);\n\tif (retval)\n\t\tgoto failed;\n\n\t/*\n\t * wait for MMP interval and check mmp_seq.\n\t */\n\tif (schedule_timeout_interruptible(HZ * wait_time) != 0) {\n\t\text4_warning(sb, \"MMP startup interrupted, failing mount\\n\");\n\t\tgoto failed;\n\t}\n\n\tretval = read_mmp_block(sb, &bh, mmp_block);\n\tif (retval)\n\t\tgoto failed;\n\tmmp = (struct mmp_struct *)(bh->b_data);\n\tif (seq != le32_to_cpu(mmp->mmp_seq)) {\n\t\tdump_mmp_msg(sb, mmp,\n\t\t\t     \"Device is already active on another node.\");\n\t\tgoto failed;\n\t}\n\n\tmmpd_data = kmalloc(sizeof(struct mmpd_data), GFP_KERNEL);\n\tif (!mmpd_data) {\n\t\text4_warning(sb, \"not enough memory for mmpd_data\");\n\t\tgoto failed;\n\t}\n\tmmpd_data->sb = sb;\n\tmmpd_data->bh = bh;\n\n\t/*\n\t * Start a kernel thread to update the MMP block periodically.\n\t */\n\tEXT4_SB(sb)->s_mmp_tsk = kthread_run(kmmpd, mmpd_data, \"kmmpd-%s\",\n\t\t\t\t\t     bdevname(bh->b_bdev,\n\t\t\t\t\t\t      mmp->mmp_bdevname));\n\tif (IS_ERR(EXT4_SB(sb)->s_mmp_tsk)) {\n\t\tEXT4_SB(sb)->s_mmp_tsk = NULL;\n\t\tkfree(mmpd_data);\n\t\text4_warning(sb, \"Unable to create kmmpd thread for %s.\",\n\t\t\t     sb->s_id);\n\t\tgoto failed;\n\t}\n\n\treturn 0;\n\nfailed:\n\tbrelse(bh);\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "le64_to_cpu",
          "args": [
            "es->s_mmp_block"
          ],
          "line": 3982
        },
        "resolved": true,
        "details": {
          "function_name": "sle64_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "58-61",
          "snippet": "static inline s64 sle64_to_cpup(sle64 *x)\n{\n\treturn le64_to_cpu(*(__force le64*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s64 sle64_to_cpup(sle64 *x)\n{\n\treturn le64_to_cpu(*(__force le64*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "EXT4_HAS_INCOMPAT_FEATURE",
          "args": [
            "sb",
            "EXT4_FEATURE_INCOMPAT_MMP"
          ],
          "line": 3980
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXT4_HAS_INCOMPAT_FEATURE",
          "args": [
            "sb",
            "EXT4_FEATURE_INCOMPAT_RECOVER"
          ],
          "line": 3977
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_init",
          "args": [
            "&sbi->s_orphan_lock"
          ],
          "line": 3972
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&sbi->s_orphan"
          ],
          "line": 3971
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "sb->s_uuid",
            "es->s_uuid",
            "sizeof(es->s_uuid)"
          ],
          "line": 3969
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXT4_HAS_RO_COMPAT_FEATURE",
          "args": [
            "sb",
            "EXT4_FEATURE_RO_COMPAT_QUOTA"
          ],
          "line": 3963
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_get_stripe_size",
          "args": [
            "sbi"
          ],
          "line": 3952
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_get_stripe_size",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/super.c",
          "lines": "2409-2433",
          "snippet": "static unsigned long ext4_get_stripe_size(struct ext4_sb_info *sbi)\n{\n\tunsigned long stride = le16_to_cpu(sbi->s_es->s_raid_stride);\n\tunsigned long stripe_width =\n\t\t\tle32_to_cpu(sbi->s_es->s_raid_stripe_width);\n\tint ret;\n\n\tif (sbi->s_stripe && sbi->s_stripe <= sbi->s_blocks_per_group)\n\t\tret = sbi->s_stripe;\n\telse if (stripe_width <= sbi->s_blocks_per_group)\n\t\tret = stripe_width;\n\telse if (stride <= sbi->s_blocks_per_group)\n\t\tret = stride;\n\telse\n\t\tret = 0;\n\n\t/*\n\t * If the stripe width is 1, this makes no sense and\n\t * we set it to 0 to turn off stripe handling code.\n\t */\n\tif (ret <= 1)\n\t\tret = 0;\n\n\treturn ret;\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"mballoc.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include \"ext4_extents.h\"\t/* Needed for trace points definition */",
            "#include \"ext4.h\"",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/crc16.h>",
            "#include <linux/log2.h>",
            "#include <linux/ctype.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/random.h>",
            "#include <linux/vfs.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/parser.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/time.h>",
            "#include <linux/fs.h>",
            "#include <linux/string.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"mballoc.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4_extents.h\"\t/* Needed for trace points definition */\n#include \"ext4.h\"\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <asm/uaccess.h>\n#include <linux/cleancache.h>\n#include <linux/crc16.h>\n#include <linux/log2.h>\n#include <linux/ctype.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/random.h>\n#include <linux/vfs.h>\n#include <linux/exportfs.h>\n#include <linux/buffer_head.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/jbd2.h>\n#include <linux/vmalloc.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n#include <linux/string.h>\n#include <linux/module.h>\n\nstatic unsigned long ext4_get_stripe_size(struct ext4_sb_info *sbi)\n{\n\tunsigned long stride = le16_to_cpu(sbi->s_es->s_raid_stride);\n\tunsigned long stripe_width =\n\t\t\tle32_to_cpu(sbi->s_es->s_raid_stripe_width);\n\tint ret;\n\n\tif (sbi->s_stripe && sbi->s_stripe <= sbi->s_blocks_per_group)\n\t\tret = sbi->s_stripe;\n\telse if (stripe_width <= sbi->s_blocks_per_group)\n\t\tret = stripe_width;\n\telse if (stride <= sbi->s_blocks_per_group)\n\t\tret = stride;\n\telse\n\t\tret = 0;\n\n\t/*\n\t * If the stripe width is 1, this makes no sense and\n\t * we set it to 0 to turn off stripe handling code.\n\t */\n\tif (ret <= 1)\n\t\tret = 0;\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_es_register_shrinker",
          "args": [
            "sbi"
          ],
          "line": 3949
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_es_register_shrinker",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/extents_status.c",
          "lines": "1179-1218",
          "snippet": "int ext4_es_register_shrinker(struct ext4_sb_info *sbi)\n{\n\tint err;\n\n\t/* Make sure we have enough bits for physical block number */\n\tBUILD_BUG_ON(ES_SHIFT < 48);\n\tINIT_LIST_HEAD(&sbi->s_es_list);\n\tsbi->s_es_nr_inode = 0;\n\tspin_lock_init(&sbi->s_es_lock);\n\tsbi->s_es_stats.es_stats_shrunk = 0;\n\tsbi->s_es_stats.es_stats_cache_hits = 0;\n\tsbi->s_es_stats.es_stats_cache_misses = 0;\n\tsbi->s_es_stats.es_stats_scan_time = 0;\n\tsbi->s_es_stats.es_stats_max_scan_time = 0;\n\terr = percpu_counter_init(&sbi->s_es_stats.es_stats_all_cnt, 0, GFP_KERNEL);\n\tif (err)\n\t\treturn err;\n\terr = percpu_counter_init(&sbi->s_es_stats.es_stats_shk_cnt, 0, GFP_KERNEL);\n\tif (err)\n\t\tgoto err1;\n\n\tsbi->s_es_shrinker.scan_objects = ext4_es_scan;\n\tsbi->s_es_shrinker.count_objects = ext4_es_count;\n\tsbi->s_es_shrinker.seeks = DEFAULT_SEEKS;\n\terr = register_shrinker(&sbi->s_es_shrinker);\n\tif (err)\n\t\tgoto err2;\n\n\tif (sbi->s_proc)\n\t\tproc_create_data(\"es_shrinker_info\", S_IRUGO, sbi->s_proc,\n\t\t\t\t &ext4_es_seq_shrinker_info_fops, sbi);\n\n\treturn 0;\n\nerr2:\n\tpercpu_counter_destroy(&sbi->s_es_stats.es_stats_shk_cnt);\nerr1:\n\tpercpu_counter_destroy(&sbi->s_es_stats.es_stats_all_cnt);\n\treturn err;\n}",
          "includes": [
            "#include \"ext4_extents.h\"\t/* Needed when ES_AGGRESSIVE_TEST is defined */",
            "#include <trace/events/ext4.h>",
            "#include \"extents_status.h\"",
            "#include \"ext4.h\"",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/list_sort.h>",
            "#include <linux/rbtree.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct file_operations ext4_es_seq_shrinker_info_fops = {\n\t.owner\t\t= THIS_MODULE,\n\t.open\t\t= ext4_es_seq_shrinker_info_open,\n\t.read\t\t= seq_read,\n\t.llseek\t\t= seq_lseek,\n\t.release\t= ext4_es_seq_shrinker_info_release,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ext4_extents.h\"\t/* Needed when ES_AGGRESSIVE_TEST is defined */\n#include <trace/events/ext4.h>\n#include \"extents_status.h\"\n#include \"ext4.h\"\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/list_sort.h>\n#include <linux/rbtree.h>\n\nstatic const struct file_operations ext4_es_seq_shrinker_info_fops = {\n\t.owner\t\t= THIS_MODULE,\n\t.open\t\t= ext4_es_seq_shrinker_info_open,\n\t.read\t\t= seq_read,\n\t.llseek\t\t= seq_lseek,\n\t.release\t= ext4_es_seq_shrinker_info_release,\n};\n\nint ext4_es_register_shrinker(struct ext4_sb_info *sbi)\n{\n\tint err;\n\n\t/* Make sure we have enough bits for physical block number */\n\tBUILD_BUG_ON(ES_SHIFT < 48);\n\tINIT_LIST_HEAD(&sbi->s_es_list);\n\tsbi->s_es_nr_inode = 0;\n\tspin_lock_init(&sbi->s_es_lock);\n\tsbi->s_es_stats.es_stats_shrunk = 0;\n\tsbi->s_es_stats.es_stats_cache_hits = 0;\n\tsbi->s_es_stats.es_stats_cache_misses = 0;\n\tsbi->s_es_stats.es_stats_scan_time = 0;\n\tsbi->s_es_stats.es_stats_max_scan_time = 0;\n\terr = percpu_counter_init(&sbi->s_es_stats.es_stats_all_cnt, 0, GFP_KERNEL);\n\tif (err)\n\t\treturn err;\n\terr = percpu_counter_init(&sbi->s_es_stats.es_stats_shk_cnt, 0, GFP_KERNEL);\n\tif (err)\n\t\tgoto err1;\n\n\tsbi->s_es_shrinker.scan_objects = ext4_es_scan;\n\tsbi->s_es_shrinker.count_objects = ext4_es_count;\n\tsbi->s_es_shrinker.seeks = DEFAULT_SEEKS;\n\terr = register_shrinker(&sbi->s_es_shrinker);\n\tif (err)\n\t\tgoto err2;\n\n\tif (sbi->s_proc)\n\t\tproc_create_data(\"es_shrinker_info\", S_IRUGO, sbi->s_proc,\n\t\t\t\t &ext4_es_seq_shrinker_info_fops, sbi);\n\n\treturn 0;\n\nerr2:\n\tpercpu_counter_destroy(&sbi->s_es_stats.es_stats_shk_cnt);\nerr1:\n\tpercpu_counter_destroy(&sbi->s_es_stats.es_stats_all_cnt);\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "setup_timer",
          "args": [
            "&sbi->s_err_report",
            "print_daily_error_info",
            "(unsigned long) sb"
          ],
          "line": 3945
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock_init",
          "args": [
            "&sbi->s_next_gen_lock"
          ],
          "line": 3943
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_random_bytes",
          "args": [
            "&sbi->s_next_generation",
            "sizeof(u32)"
          ],
          "line": 3942
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_check_descriptors",
          "args": [
            "sb",
            "&first_not_zeroed"
          ],
          "line": 3936
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_check_descriptors",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/super.c",
          "lines": "2059-2129",
          "snippet": "static int ext4_check_descriptors(struct super_block *sb,\n\t\t\t\t  ext4_group_t *first_not_zeroed)\n{\n\tstruct ext4_sb_info *sbi = EXT4_SB(sb);\n\text4_fsblk_t first_block = le32_to_cpu(sbi->s_es->s_first_data_block);\n\text4_fsblk_t last_block;\n\text4_fsblk_t block_bitmap;\n\text4_fsblk_t inode_bitmap;\n\text4_fsblk_t inode_table;\n\tint flexbg_flag = 0;\n\text4_group_t i, grp = sbi->s_groups_count;\n\n\tif (EXT4_HAS_INCOMPAT_FEATURE(sb, EXT4_FEATURE_INCOMPAT_FLEX_BG))\n\t\tflexbg_flag = 1;\n\n\text4_debug(\"Checking group descriptors\");\n\n\tfor (i = 0; i < sbi->s_groups_count; i++) {\n\t\tstruct ext4_group_desc *gdp = ext4_get_group_desc(sb, i, NULL);\n\n\t\tif (i == sbi->s_groups_count - 1 || flexbg_flag)\n\t\t\tlast_block = ext4_blocks_count(sbi->s_es) - 1;\n\t\telse\n\t\t\tlast_block = first_block +\n\t\t\t\t(EXT4_BLOCKS_PER_GROUP(sb) - 1);\n\n\t\tif ((grp == sbi->s_groups_count) &&\n\t\t   !(gdp->bg_flags & cpu_to_le16(EXT4_BG_INODE_ZEROED)))\n\t\t\tgrp = i;\n\n\t\tblock_bitmap = ext4_block_bitmap(sb, gdp);\n\t\tif (block_bitmap < first_block || block_bitmap > last_block) {\n\t\t\text4_msg(sb, KERN_ERR, \"ext4_check_descriptors: \"\n\t\t\t       \"Block bitmap for group %u not in group \"\n\t\t\t       \"(block %llu)!\", i, block_bitmap);\n\t\t\treturn 0;\n\t\t}\n\t\tinode_bitmap = ext4_inode_bitmap(sb, gdp);\n\t\tif (inode_bitmap < first_block || inode_bitmap > last_block) {\n\t\t\text4_msg(sb, KERN_ERR, \"ext4_check_descriptors: \"\n\t\t\t       \"Inode bitmap for group %u not in group \"\n\t\t\t       \"(block %llu)!\", i, inode_bitmap);\n\t\t\treturn 0;\n\t\t}\n\t\tinode_table = ext4_inode_table(sb, gdp);\n\t\tif (inode_table < first_block ||\n\t\t    inode_table + sbi->s_itb_per_group - 1 > last_block) {\n\t\t\text4_msg(sb, KERN_ERR, \"ext4_check_descriptors: \"\n\t\t\t       \"Inode table for group %u not in group \"\n\t\t\t       \"(block %llu)!\", i, inode_table);\n\t\t\treturn 0;\n\t\t}\n\t\text4_lock_group(sb, i);\n\t\tif (!ext4_group_desc_csum_verify(sb, i, gdp)) {\n\t\t\text4_msg(sb, KERN_ERR, \"ext4_check_descriptors: \"\n\t\t\t\t \"Checksum for group %u failed (%u!=%u)\",\n\t\t\t\t i, le16_to_cpu(ext4_group_desc_csum(sbi, i,\n\t\t\t\t     gdp)), le16_to_cpu(gdp->bg_checksum));\n\t\t\tif (!(sb->s_flags & MS_RDONLY)) {\n\t\t\t\text4_unlock_group(sb, i);\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\t\text4_unlock_group(sb, i);\n\t\tif (!flexbg_flag)\n\t\t\tfirst_block += EXT4_BLOCKS_PER_GROUP(sb);\n\t}\n\tif (NULL != first_not_zeroed)\n\t\t*first_not_zeroed = grp;\n\treturn 1;\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"mballoc.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include \"ext4_extents.h\"\t/* Needed for trace points definition */",
            "#include \"ext4.h\"",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/crc16.h>",
            "#include <linux/log2.h>",
            "#include <linux/ctype.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/random.h>",
            "#include <linux/vfs.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/parser.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/time.h>",
            "#include <linux/fs.h>",
            "#include <linux/string.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ext4_unfreeze(struct super_block *sb);",
            "static int ext4_freeze(struct super_block *sb);",
            "static inline int ext2_feature_set_ok(struct super_block *sb);",
            "static inline int ext3_feature_set_ok(struct super_block *sb);",
            "static void ext4_unregister_li_request(struct super_block *sb);",
            "static int ext4_reserve_clusters(struct ext4_sb_info *, ext4_fsblk_t);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"mballoc.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4_extents.h\"\t/* Needed for trace points definition */\n#include \"ext4.h\"\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <asm/uaccess.h>\n#include <linux/cleancache.h>\n#include <linux/crc16.h>\n#include <linux/log2.h>\n#include <linux/ctype.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/random.h>\n#include <linux/vfs.h>\n#include <linux/exportfs.h>\n#include <linux/buffer_head.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/jbd2.h>\n#include <linux/vmalloc.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n#include <linux/string.h>\n#include <linux/module.h>\n\nstatic int ext4_unfreeze(struct super_block *sb);\nstatic int ext4_freeze(struct super_block *sb);\nstatic inline int ext2_feature_set_ok(struct super_block *sb);\nstatic inline int ext3_feature_set_ok(struct super_block *sb);\nstatic void ext4_unregister_li_request(struct super_block *sb);\nstatic int ext4_reserve_clusters(struct ext4_sb_info *, ext4_fsblk_t);\n\nstatic int ext4_check_descriptors(struct super_block *sb,\n\t\t\t\t  ext4_group_t *first_not_zeroed)\n{\n\tstruct ext4_sb_info *sbi = EXT4_SB(sb);\n\text4_fsblk_t first_block = le32_to_cpu(sbi->s_es->s_first_data_block);\n\text4_fsblk_t last_block;\n\text4_fsblk_t block_bitmap;\n\text4_fsblk_t inode_bitmap;\n\text4_fsblk_t inode_table;\n\tint flexbg_flag = 0;\n\text4_group_t i, grp = sbi->s_groups_count;\n\n\tif (EXT4_HAS_INCOMPAT_FEATURE(sb, EXT4_FEATURE_INCOMPAT_FLEX_BG))\n\t\tflexbg_flag = 1;\n\n\text4_debug(\"Checking group descriptors\");\n\n\tfor (i = 0; i < sbi->s_groups_count; i++) {\n\t\tstruct ext4_group_desc *gdp = ext4_get_group_desc(sb, i, NULL);\n\n\t\tif (i == sbi->s_groups_count - 1 || flexbg_flag)\n\t\t\tlast_block = ext4_blocks_count(sbi->s_es) - 1;\n\t\telse\n\t\t\tlast_block = first_block +\n\t\t\t\t(EXT4_BLOCKS_PER_GROUP(sb) - 1);\n\n\t\tif ((grp == sbi->s_groups_count) &&\n\t\t   !(gdp->bg_flags & cpu_to_le16(EXT4_BG_INODE_ZEROED)))\n\t\t\tgrp = i;\n\n\t\tblock_bitmap = ext4_block_bitmap(sb, gdp);\n\t\tif (block_bitmap < first_block || block_bitmap > last_block) {\n\t\t\text4_msg(sb, KERN_ERR, \"ext4_check_descriptors: \"\n\t\t\t       \"Block bitmap for group %u not in group \"\n\t\t\t       \"(block %llu)!\", i, block_bitmap);\n\t\t\treturn 0;\n\t\t}\n\t\tinode_bitmap = ext4_inode_bitmap(sb, gdp);\n\t\tif (inode_bitmap < first_block || inode_bitmap > last_block) {\n\t\t\text4_msg(sb, KERN_ERR, \"ext4_check_descriptors: \"\n\t\t\t       \"Inode bitmap for group %u not in group \"\n\t\t\t       \"(block %llu)!\", i, inode_bitmap);\n\t\t\treturn 0;\n\t\t}\n\t\tinode_table = ext4_inode_table(sb, gdp);\n\t\tif (inode_table < first_block ||\n\t\t    inode_table + sbi->s_itb_per_group - 1 > last_block) {\n\t\t\text4_msg(sb, KERN_ERR, \"ext4_check_descriptors: \"\n\t\t\t       \"Inode table for group %u not in group \"\n\t\t\t       \"(block %llu)!\", i, inode_table);\n\t\t\treturn 0;\n\t\t}\n\t\text4_lock_group(sb, i);\n\t\tif (!ext4_group_desc_csum_verify(sb, i, gdp)) {\n\t\t\text4_msg(sb, KERN_ERR, \"ext4_check_descriptors: \"\n\t\t\t\t \"Checksum for group %u failed (%u!=%u)\",\n\t\t\t\t i, le16_to_cpu(ext4_group_desc_csum(sbi, i,\n\t\t\t\t     gdp)), le16_to_cpu(gdp->bg_checksum));\n\t\t\tif (!(sb->s_flags & MS_RDONLY)) {\n\t\t\t\text4_unlock_group(sb, i);\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\t\text4_unlock_group(sb, i);\n\t\tif (!flexbg_flag)\n\t\t\tfirst_block += EXT4_BLOCKS_PER_GROUP(sb);\n\t}\n\tif (NULL != first_not_zeroed)\n\t\t*first_not_zeroed = grp;\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sb_bread_unmovable",
          "args": [
            "sb",
            "block"
          ],
          "line": 3928
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "descriptor_loc",
          "args": [
            "sb",
            "logical_sb_block",
            "i"
          ],
          "line": 3927
        },
        "resolved": true,
        "details": {
          "function_name": "descriptor_loc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/super.c",
          "lines": "2369-2396",
          "snippet": "static ext4_fsblk_t descriptor_loc(struct super_block *sb,\n\t\t\t\t   ext4_fsblk_t logical_sb_block, int nr)\n{\n\tstruct ext4_sb_info *sbi = EXT4_SB(sb);\n\text4_group_t bg, first_meta_bg;\n\tint has_super = 0;\n\n\tfirst_meta_bg = le32_to_cpu(sbi->s_es->s_first_meta_bg);\n\n\tif (!EXT4_HAS_INCOMPAT_FEATURE(sb, EXT4_FEATURE_INCOMPAT_META_BG) ||\n\t    nr < first_meta_bg)\n\t\treturn logical_sb_block + nr + 1;\n\tbg = sbi->s_desc_per_block * nr;\n\tif (ext4_bg_has_super(sb, bg))\n\t\thas_super = 1;\n\n\t/*\n\t * If we have a meta_bg fs with 1k blocks, group 0's GDT is at\n\t * block 2, not 1.  If s_first_data_block == 0 (bigalloc is enabled\n\t * on modern mke2fs or blksize > 1k on older mke2fs) then we must\n\t * compensate.\n\t */\n\tif (sb->s_blocksize == 1024 && nr == 0 &&\n\t    le32_to_cpu(EXT4_SB(sb)->s_es->s_first_data_block) == 0)\n\t\thas_super++;\n\n\treturn (has_super + ext4_group_first_block_no(sb, bg));\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"mballoc.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include \"ext4_extents.h\"\t/* Needed for trace points definition */",
            "#include \"ext4.h\"",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/crc16.h>",
            "#include <linux/log2.h>",
            "#include <linux/ctype.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/random.h>",
            "#include <linux/vfs.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/parser.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/time.h>",
            "#include <linux/fs.h>",
            "#include <linux/string.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ext4_unfreeze(struct super_block *sb);",
            "static int ext4_freeze(struct super_block *sb);",
            "static inline int ext2_feature_set_ok(struct super_block *sb);",
            "static inline int ext3_feature_set_ok(struct super_block *sb);",
            "static void ext4_unregister_li_request(struct super_block *sb);",
            "static int ext4_reserve_clusters(struct ext4_sb_info *, ext4_fsblk_t);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"mballoc.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4_extents.h\"\t/* Needed for trace points definition */\n#include \"ext4.h\"\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <asm/uaccess.h>\n#include <linux/cleancache.h>\n#include <linux/crc16.h>\n#include <linux/log2.h>\n#include <linux/ctype.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/random.h>\n#include <linux/vfs.h>\n#include <linux/exportfs.h>\n#include <linux/buffer_head.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/jbd2.h>\n#include <linux/vmalloc.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n#include <linux/string.h>\n#include <linux/module.h>\n\nstatic int ext4_unfreeze(struct super_block *sb);\nstatic int ext4_freeze(struct super_block *sb);\nstatic inline int ext2_feature_set_ok(struct super_block *sb);\nstatic inline int ext3_feature_set_ok(struct super_block *sb);\nstatic void ext4_unregister_li_request(struct super_block *sb);\nstatic int ext4_reserve_clusters(struct ext4_sb_info *, ext4_fsblk_t);\n\nstatic ext4_fsblk_t descriptor_loc(struct super_block *sb,\n\t\t\t\t   ext4_fsblk_t logical_sb_block, int nr)\n{\n\tstruct ext4_sb_info *sbi = EXT4_SB(sb);\n\text4_group_t bg, first_meta_bg;\n\tint has_super = 0;\n\n\tfirst_meta_bg = le32_to_cpu(sbi->s_es->s_first_meta_bg);\n\n\tif (!EXT4_HAS_INCOMPAT_FEATURE(sb, EXT4_FEATURE_INCOMPAT_META_BG) ||\n\t    nr < first_meta_bg)\n\t\treturn logical_sb_block + nr + 1;\n\tbg = sbi->s_desc_per_block * nr;\n\tif (ext4_bg_has_super(sb, bg))\n\t\thas_super = 1;\n\n\t/*\n\t * If we have a meta_bg fs with 1k blocks, group 0's GDT is at\n\t * block 2, not 1.  If s_first_data_block == 0 (bigalloc is enabled\n\t * on modern mke2fs or blksize > 1k on older mke2fs) then we must\n\t * compensate.\n\t */\n\tif (sb->s_blocksize == 1024 && nr == 0 &&\n\t    le32_to_cpu(EXT4_SB(sb)->s_es->s_first_data_block) == 0)\n\t\thas_super++;\n\n\treturn (has_super + ext4_group_first_block_no(sb, bg));\n}"
        }
      },
      {
        "call_info": {
          "callee": "bgl_lock_init",
          "args": [
            "sbi->s_blockgroup_lock"
          ],
          "line": 3924
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "proc_create_data",
          "args": [
            "\"options\"",
            "S_IRUGO",
            "sbi->s_proc",
            "&ext4_seq_options_fops",
            "sb"
          ],
          "line": 3921
        },
        "resolved": true,
        "details": {
          "function_name": "proc_create_data",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/generic.c",
          "lines": "458-489",
          "snippet": "struct proc_dir_entry *proc_create_data(const char *name, umode_t mode,\n\t\t\t\t\tstruct proc_dir_entry *parent,\n\t\t\t\t\tconst struct file_operations *proc_fops,\n\t\t\t\t\tvoid *data)\n{\n\tstruct proc_dir_entry *pde;\n\tif ((mode & S_IFMT) == 0)\n\t\tmode |= S_IFREG;\n\n\tif (!S_ISREG(mode)) {\n\t\tWARN_ON(1);\t/* use proc_mkdir() */\n\t\treturn NULL;\n\t}\n\n\tBUG_ON(proc_fops == NULL);\n\n\tif ((mode & S_IALLUGO) == 0)\n\t\tmode |= S_IRUGO;\n\tpde = __proc_create(&parent, name, mode, 1);\n\tif (!pde)\n\t\tgoto out;\n\tpde->proc_fops = proc_fops;\n\tpde->data = data;\n\tpde->proc_iops = &proc_file_inode_operations;\n\tif (proc_register(parent, pde) < 0)\n\t\tgoto out_free;\n\treturn pde;\nout_free:\n\tkfree(pde);\nout:\n\treturn NULL;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/bitops.h>",
            "#include <linux/idr.h>",
            "#include <linux/init.h>",
            "#include <linux/mount.h>",
            "#include <linux/printk.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/stat.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/time.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct inode_operations proc_file_inode_operations = {\n\t.setattr\t= proc_notify_change,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/bitops.h>\n#include <linux/idr.h>\n#include <linux/init.h>\n#include <linux/mount.h>\n#include <linux/printk.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/stat.h>\n#include <linux/proc_fs.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n\nstatic const struct inode_operations proc_file_inode_operations = {\n\t.setattr\t= proc_notify_change,\n};\n\nstruct proc_dir_entry *proc_create_data(const char *name, umode_t mode,\n\t\t\t\t\tstruct proc_dir_entry *parent,\n\t\t\t\t\tconst struct file_operations *proc_fops,\n\t\t\t\t\tvoid *data)\n{\n\tstruct proc_dir_entry *pde;\n\tif ((mode & S_IFMT) == 0)\n\t\tmode |= S_IFREG;\n\n\tif (!S_ISREG(mode)) {\n\t\tWARN_ON(1);\t/* use proc_mkdir() */\n\t\treturn NULL;\n\t}\n\n\tBUG_ON(proc_fops == NULL);\n\n\tif ((mode & S_IALLUGO) == 0)\n\t\tmode |= S_IRUGO;\n\tpde = __proc_create(&parent, name, mode, 1);\n\tif (!pde)\n\t\tgoto out;\n\tpde->proc_fops = proc_fops;\n\tpde->data = data;\n\tpde->proc_iops = &proc_file_inode_operations;\n\tif (proc_register(parent, pde) < 0)\n\t\tgoto out_free;\n\treturn pde;\nout_free:\n\tkfree(pde);\nout:\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "proc_mkdir",
          "args": [
            "sb->s_id",
            "ext4_proc_root"
          ],
          "line": 3918
        },
        "resolved": true,
        "details": {
          "function_name": "proc_mkdir",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/generic.c",
          "lines": "451-455",
          "snippet": "struct proc_dir_entry *proc_mkdir(const char *name,\n\t\tstruct proc_dir_entry *parent)\n{\n\treturn proc_mkdir_data(name, 0, parent, NULL);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/bitops.h>",
            "#include <linux/idr.h>",
            "#include <linux/init.h>",
            "#include <linux/mount.h>",
            "#include <linux/printk.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/stat.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/time.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/bitops.h>\n#include <linux/idr.h>\n#include <linux/init.h>\n#include <linux/mount.h>\n#include <linux/printk.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/stat.h>\n#include <linux/proc_fs.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n\nstruct proc_dir_entry *proc_mkdir(const char *name,\n\t\tstruct proc_dir_entry *parent)\n{\n\treturn proc_mkdir_data(name, 0, parent, NULL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_kvmalloc",
          "args": [
            "db_count *\n\t\t\t\t\t  sizeof(struct buffer_head *)",
            "GFP_KERNEL"
          ],
          "line": 3908
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_kvmalloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/super.c",
          "lines": "159-167",
          "snippet": "void *ext4_kvmalloc(size_t size, gfp_t flags)\n{\n\tvoid *ret;\n\n\tret = kmalloc(size, flags | __GFP_NOWARN);\n\tif (!ret)\n\t\tret = __vmalloc(size, flags, PAGE_KERNEL);\n\treturn ret;\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"mballoc.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include \"ext4_extents.h\"\t/* Needed for trace points definition */",
            "#include \"ext4.h\"",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/crc16.h>",
            "#include <linux/log2.h>",
            "#include <linux/ctype.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/random.h>",
            "#include <linux/vfs.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/parser.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/time.h>",
            "#include <linux/fs.h>",
            "#include <linux/string.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"mballoc.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4_extents.h\"\t/* Needed for trace points definition */\n#include \"ext4.h\"\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <asm/uaccess.h>\n#include <linux/cleancache.h>\n#include <linux/crc16.h>\n#include <linux/log2.h>\n#include <linux/ctype.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/random.h>\n#include <linux/vfs.h>\n#include <linux/exportfs.h>\n#include <linux/buffer_head.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/jbd2.h>\n#include <linux/vmalloc.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n#include <linux/string.h>\n#include <linux/module.h>\n\nvoid *ext4_kvmalloc(size_t size, gfp_t flags)\n{\n\tvoid *ret;\n\n\tret = kmalloc(size, flags | __GFP_NOWARN);\n\tif (!ret)\n\t\tret = __vmalloc(size, flags, PAGE_KERNEL);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "EXT4_DESC_PER_BLOCK",
          "args": [
            "sb"
          ],
          "line": 3907
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXT4_DESC_PER_BLOCK",
          "args": [
            "sb"
          ],
          "line": 3906
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "min_t",
          "args": [
            "ext4_group_t",
            "sbi->s_groups_count",
            "(EXT4_MAX_BLOCK_FILE_PHYS / EXT4_BLOCKS_PER_GROUP(sb))"
          ],
          "line": 3904
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXT4_BLOCKS_PER_GROUP",
          "args": [
            "sb"
          ],
          "line": 3905
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXT4_BLOCKS_PER_GROUP",
          "args": [
            "sb"
          ],
          "line": 3900
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_blocks_count",
          "args": [
            "es"
          ],
          "line": 3898
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXT4_DESC_PER_BLOCK",
          "args": [
            "sb"
          ],
          "line": 3894
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "do_div",
          "args": [
            "blocks_count",
            "EXT4_BLOCKS_PER_GROUP(sb)"
          ],
          "line": 3893
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXT4_BLOCKS_PER_GROUP",
          "args": [
            "sb"
          ],
          "line": 3893
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXT4_BLOCKS_PER_GROUP",
          "args": [
            "sb"
          ],
          "line": 3892
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_blocks_count",
          "args": [
            "es"
          ],
          "line": 3890
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_blocks_count",
          "args": [
            "es"
          ],
          "line": 3887
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_blocks_count",
          "args": [
            "es"
          ],
          "line": 3883
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_blocks_count",
          "args": [
            "es"
          ],
          "line": 3875
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_blocks_count",
          "args": [
            "es"
          ],
          "line": 3872
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXT4_BLOCKS_PER_GROUP",
          "args": [
            "sb"
          ],
          "line": 3867
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "generic_check_addressable",
          "args": [
            "sb->s_blocksize_bits",
            "ext4_blocks_count(es)"
          ],
          "line": 3857
        },
        "resolved": true,
        "details": {
          "function_name": "generic_check_addressable",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/libfs.c",
          "lines": "998-1015",
          "snippet": "int generic_check_addressable(unsigned blocksize_bits, u64 num_blocks)\n{\n\tu64 last_fs_block = num_blocks - 1;\n\tu64 last_fs_page =\n\t\tlast_fs_block >> (PAGE_CACHE_SHIFT - blocksize_bits);\n\n\tif (unlikely(num_blocks == 0))\n\t\treturn 0;\n\n\tif ((blocksize_bits < 9) || (blocksize_bits > PAGE_CACHE_SHIFT))\n\t\treturn -EINVAL;\n\n\tif ((last_fs_block > (sector_t)(~0ULL) >> (blocksize_bits - 9)) ||\n\t    (last_fs_page > (pgoff_t)(~0ULL))) {\n\t\treturn -EFBIG;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/buffer_head.h> /* sync_mapping_buffers */",
            "#include <linux/writeback.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/namei.h>",
            "#include <linux/mutex.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/vfs.h>",
            "#include <linux/mount.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/export.h>",
            "#include <linux/blkdev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <linux/buffer_head.h> /* sync_mapping_buffers */\n#include <linux/writeback.h>\n#include <linux/exportfs.h>\n#include <linux/namei.h>\n#include <linux/mutex.h>\n#include <linux/quotaops.h>\n#include <linux/vfs.h>\n#include <linux/mount.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include <linux/export.h>\n#include <linux/blkdev.h>\n\nint generic_check_addressable(unsigned blocksize_bits, u64 num_blocks)\n{\n\tu64 last_fs_block = num_blocks - 1;\n\tu64 last_fs_page =\n\t\tlast_fs_block >> (PAGE_CACHE_SHIFT - blocksize_bits);\n\n\tif (unlikely(num_blocks == 0))\n\t\treturn 0;\n\n\tif ((blocksize_bits < 9) || (blocksize_bits > PAGE_CACHE_SHIFT))\n\t\treturn -EINVAL;\n\n\tif ((last_fs_block > (sector_t)(~0ULL) >> (blocksize_bits - 9)) ||\n\t    (last_fs_page > (pgoff_t)(~0ULL))) {\n\t\treturn -EFBIG;\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_blocks_count",
          "args": [
            "es"
          ],
          "line": 3858
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_opt2",
          "args": [
            "sb",
            "STD_GROUP_SIZE"
          ],
          "line": 3851
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_warning",
          "args": [
            "sb",
            "\"fragment/cluster size (%d) != \"\n\t\t\t\t     \"block size (%d)\"",
            "clustersize",
            "blocksize"
          ],
          "line": 3826
        },
        "resolved": true,
        "details": {
          "function_name": "__ext4_warning",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/super.c",
          "lines": "609-625",
          "snippet": "void __ext4_warning(struct super_block *sb, const char *function,\n\t\t    unsigned int line, const char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tif (!___ratelimit(&(EXT4_SB(sb)->s_warning_ratelimit_state),\n\t\t\t  \"EXT4-fs warning\"))\n\t\treturn;\n\n\tva_start(args, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\tprintk(KERN_WARNING \"EXT4-fs warning (device %s): %s:%d: %pV\\n\",\n\t       sb->s_id, function, line, &vaf);\n\tva_end(args);\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"mballoc.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include \"ext4_extents.h\"\t/* Needed for trace points definition */",
            "#include \"ext4.h\"",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/crc16.h>",
            "#include <linux/log2.h>",
            "#include <linux/ctype.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/random.h>",
            "#include <linux/vfs.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/parser.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/time.h>",
            "#include <linux/fs.h>",
            "#include <linux/string.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ext4_unfreeze(struct super_block *sb);",
            "static int ext4_freeze(struct super_block *sb);",
            "static inline int ext2_feature_set_ok(struct super_block *sb);",
            "static inline int ext3_feature_set_ok(struct super_block *sb);",
            "static void ext4_unregister_li_request(struct super_block *sb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"mballoc.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4_extents.h\"\t/* Needed for trace points definition */\n#include \"ext4.h\"\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <asm/uaccess.h>\n#include <linux/cleancache.h>\n#include <linux/crc16.h>\n#include <linux/log2.h>\n#include <linux/ctype.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/random.h>\n#include <linux/vfs.h>\n#include <linux/exportfs.h>\n#include <linux/buffer_head.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/jbd2.h>\n#include <linux/vmalloc.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n#include <linux/string.h>\n#include <linux/module.h>\n\nstatic int ext4_unfreeze(struct super_block *sb);\nstatic int ext4_freeze(struct super_block *sb);\nstatic inline int ext2_feature_set_ok(struct super_block *sb);\nstatic inline int ext3_feature_set_ok(struct super_block *sb);\nstatic void ext4_unregister_li_request(struct super_block *sb);\n\nvoid __ext4_warning(struct super_block *sb, const char *function,\n\t\t    unsigned int line, const char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tif (!___ratelimit(&(EXT4_SB(sb)->s_warning_ratelimit_state),\n\t\t\t  \"EXT4-fs warning\"))\n\t\treturn;\n\n\tva_start(args, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\tprintk(KERN_WARNING \"EXT4-fs warning (device %s): %s:%d: %pV\\n\",\n\t       sb->s_id, function, line, &vaf);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "EXT4_HAS_RO_COMPAT_FEATURE",
          "args": [
            "sb",
            "EXT4_FEATURE_RO_COMPAT_BIGALLOC"
          ],
          "line": 3797
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "EXT2_FLAGS_SIGNED_HASH"
          ],
          "line": 3790
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "EXT2_FLAGS_UNSIGNED_HASH"
          ],
          "line": 3785
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXT4_HAS_COMPAT_FEATURE",
          "args": [
            "sb",
            "EXT4_FEATURE_COMPAT_DIR_INDEX"
          ],
          "line": 3777
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ilog2",
          "args": [
            "EXT4_DESC_PER_BLOCK(sb)"
          ],
          "line": 3772
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXT4_DESC_PER_BLOCK",
          "args": [
            "sb"
          ],
          "line": 3772
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ilog2",
          "args": [
            "EXT4_ADDR_PER_BLOCK(sb)"
          ],
          "line": 3771
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXT4_ADDR_PER_BLOCK",
          "args": [
            "sb"
          ],
          "line": 3771
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXT4_DESC_SIZE",
          "args": [
            "sb"
          ],
          "line": 3768
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXT4_INODE_SIZE",
          "args": [
            "sb"
          ],
          "line": 3763
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXT4_INODES_PER_GROUP",
          "args": [
            "sb"
          ],
          "line": 3760
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXT4_INODE_SIZE",
          "args": [
            "sb"
          ],
          "line": 3760
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_power_of_2",
          "args": [
            "sbi->s_desc_size"
          ],
          "line": 3749
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXT4_HAS_INCOMPAT_FEATURE",
          "args": [
            "sb",
            "EXT4_FEATURE_INCOMPAT_64BIT"
          ],
          "line": 3746
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_power_of_2",
          "args": [
            "sbi->s_inode_size"
          ],
          "line": 3734
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_max_size",
          "args": [
            "sb->s_blocksize_bits",
            "has_huge_files"
          ],
          "line": 3725
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_max_size",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/super.c",
          "lines": "2272-2304",
          "snippet": "static loff_t ext4_max_size(int blkbits, int has_huge_files)\n{\n\tloff_t res;\n\tloff_t upper_limit = MAX_LFS_FILESIZE;\n\n\t/* small i_blocks in vfs inode? */\n\tif (!has_huge_files || sizeof(blkcnt_t) < sizeof(u64)) {\n\t\t/*\n\t\t * CONFIG_LBDAF is not enabled implies the inode\n\t\t * i_block represent total blocks in 512 bytes\n\t\t * 32 == size of vfs inode i_blocks * 8\n\t\t */\n\t\tupper_limit = (1LL << 32) - 1;\n\n\t\t/* total blocks in file system block size */\n\t\tupper_limit >>= (blkbits - 9);\n\t\tupper_limit <<= blkbits;\n\t}\n\n\t/*\n\t * 32-bit extent-start container, ee_block. We lower the maxbytes\n\t * by one fs block, so ee_len can cover the extent of maximum file\n\t * size\n\t */\n\tres = (1LL << 32) - 1;\n\tres <<= blkbits;\n\n\t/* Sanity check against vm- & vfs- imposed limits */\n\tif (res > upper_limit)\n\t\tres = upper_limit;\n\n\treturn res;\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"mballoc.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include \"ext4_extents.h\"\t/* Needed for trace points definition */",
            "#include \"ext4.h\"",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/crc16.h>",
            "#include <linux/log2.h>",
            "#include <linux/ctype.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/random.h>",
            "#include <linux/vfs.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/parser.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/time.h>",
            "#include <linux/fs.h>",
            "#include <linux/string.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"mballoc.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4_extents.h\"\t/* Needed for trace points definition */\n#include \"ext4.h\"\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <asm/uaccess.h>\n#include <linux/cleancache.h>\n#include <linux/crc16.h>\n#include <linux/log2.h>\n#include <linux/ctype.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/random.h>\n#include <linux/vfs.h>\n#include <linux/exportfs.h>\n#include <linux/buffer_head.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/jbd2.h>\n#include <linux/vmalloc.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n#include <linux/string.h>\n#include <linux/module.h>\n\nstatic loff_t ext4_max_size(int blkbits, int has_huge_files)\n{\n\tloff_t res;\n\tloff_t upper_limit = MAX_LFS_FILESIZE;\n\n\t/* small i_blocks in vfs inode? */\n\tif (!has_huge_files || sizeof(blkcnt_t) < sizeof(u64)) {\n\t\t/*\n\t\t * CONFIG_LBDAF is not enabled implies the inode\n\t\t * i_block represent total blocks in 512 bytes\n\t\t * 32 == size of vfs inode i_blocks * 8\n\t\t */\n\t\tupper_limit = (1LL << 32) - 1;\n\n\t\t/* total blocks in file system block size */\n\t\tupper_limit >>= (blkbits - 9);\n\t\tupper_limit <<= blkbits;\n\t}\n\n\t/*\n\t * 32-bit extent-start container, ee_block. We lower the maxbytes\n\t * by one fs block, so ee_len can cover the extent of maximum file\n\t * size\n\t */\n\tres = (1LL << 32) - 1;\n\tres <<= blkbits;\n\n\t/* Sanity check against vm- & vfs- imposed limits */\n\tif (res > upper_limit)\n\t\tres = upper_limit;\n\n\treturn res;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_max_bitmap_size",
          "args": [
            "sb->s_blocksize_bits",
            "has_huge_files"
          ],
          "line": 3723
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_max_bitmap_size",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/super.c",
          "lines": "2311-2367",
          "snippet": "static loff_t ext4_max_bitmap_size(int bits, int has_huge_files)\n{\n\tloff_t res = EXT4_NDIR_BLOCKS;\n\tint meta_blocks;\n\tloff_t upper_limit;\n\t/* This is calculated to be the largest file size for a dense, block\n\t * mapped file such that the file's total number of 512-byte sectors,\n\t * including data and all indirect blocks, does not exceed (2^48 - 1).\n\t *\n\t * __u32 i_blocks_lo and _u16 i_blocks_high represent the total\n\t * number of 512-byte sectors of the file.\n\t */\n\n\tif (!has_huge_files || sizeof(blkcnt_t) < sizeof(u64)) {\n\t\t/*\n\t\t * !has_huge_files or CONFIG_LBDAF not enabled implies that\n\t\t * the inode i_block field represents total file blocks in\n\t\t * 2^32 512-byte sectors == size of vfs inode i_blocks * 8\n\t\t */\n\t\tupper_limit = (1LL << 32) - 1;\n\n\t\t/* total blocks in file system block size */\n\t\tupper_limit >>= (bits - 9);\n\n\t} else {\n\t\t/*\n\t\t * We use 48 bit ext4_inode i_blocks\n\t\t * With EXT4_HUGE_FILE_FL set the i_blocks\n\t\t * represent total number of blocks in\n\t\t * file system block size\n\t\t */\n\t\tupper_limit = (1LL << 48) - 1;\n\n\t}\n\n\t/* indirect blocks */\n\tmeta_blocks = 1;\n\t/* double indirect blocks */\n\tmeta_blocks += 1 + (1LL << (bits-2));\n\t/* tripple indirect blocks */\n\tmeta_blocks += 1 + (1LL << (bits-2)) + (1LL << (2*(bits-2)));\n\n\tupper_limit -= meta_blocks;\n\tupper_limit <<= bits;\n\n\tres += 1LL << (bits-2);\n\tres += 1LL << (2*(bits-2));\n\tres += 1LL << (3*(bits-2));\n\tres <<= bits;\n\tif (res > upper_limit)\n\t\tres = upper_limit;\n\n\tif (res > MAX_LFS_FILESIZE)\n\t\tres = MAX_LFS_FILESIZE;\n\n\treturn res;\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"mballoc.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include \"ext4_extents.h\"\t/* Needed for trace points definition */",
            "#include \"ext4.h\"",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/crc16.h>",
            "#include <linux/log2.h>",
            "#include <linux/ctype.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/random.h>",
            "#include <linux/vfs.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/parser.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/time.h>",
            "#include <linux/fs.h>",
            "#include <linux/string.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ext4_remount(struct super_block *sb, int *flags, char *data);",
            "static struct dentry *ext4_mount(struct file_system_type *fs_type, int flags,\n\t\t       const char *dev_name, void *data);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"mballoc.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4_extents.h\"\t/* Needed for trace points definition */\n#include \"ext4.h\"\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <asm/uaccess.h>\n#include <linux/cleancache.h>\n#include <linux/crc16.h>\n#include <linux/log2.h>\n#include <linux/ctype.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/random.h>\n#include <linux/vfs.h>\n#include <linux/exportfs.h>\n#include <linux/buffer_head.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/jbd2.h>\n#include <linux/vmalloc.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n#include <linux/string.h>\n#include <linux/module.h>\n\nstatic int ext4_remount(struct super_block *sb, int *flags, char *data);\nstatic struct dentry *ext4_mount(struct file_system_type *fs_type, int flags,\n\t\t       const char *dev_name, void *data);\n\nstatic loff_t ext4_max_bitmap_size(int bits, int has_huge_files)\n{\n\tloff_t res = EXT4_NDIR_BLOCKS;\n\tint meta_blocks;\n\tloff_t upper_limit;\n\t/* This is calculated to be the largest file size for a dense, block\n\t * mapped file such that the file's total number of 512-byte sectors,\n\t * including data and all indirect blocks, does not exceed (2^48 - 1).\n\t *\n\t * __u32 i_blocks_lo and _u16 i_blocks_high represent the total\n\t * number of 512-byte sectors of the file.\n\t */\n\n\tif (!has_huge_files || sizeof(blkcnt_t) < sizeof(u64)) {\n\t\t/*\n\t\t * !has_huge_files or CONFIG_LBDAF not enabled implies that\n\t\t * the inode i_block field represents total file blocks in\n\t\t * 2^32 512-byte sectors == size of vfs inode i_blocks * 8\n\t\t */\n\t\tupper_limit = (1LL << 32) - 1;\n\n\t\t/* total blocks in file system block size */\n\t\tupper_limit >>= (bits - 9);\n\n\t} else {\n\t\t/*\n\t\t * We use 48 bit ext4_inode i_blocks\n\t\t * With EXT4_HUGE_FILE_FL set the i_blocks\n\t\t * represent total number of blocks in\n\t\t * file system block size\n\t\t */\n\t\tupper_limit = (1LL << 48) - 1;\n\n\t}\n\n\t/* indirect blocks */\n\tmeta_blocks = 1;\n\t/* double indirect blocks */\n\tmeta_blocks += 1 + (1LL << (bits-2));\n\t/* tripple indirect blocks */\n\tmeta_blocks += 1 + (1LL << (bits-2)) + (1LL << (2*(bits-2)));\n\n\tupper_limit -= meta_blocks;\n\tupper_limit <<= bits;\n\n\tres += 1LL << (bits-2);\n\tres += 1LL << (2*(bits-2));\n\tres += 1LL << (3*(bits-2));\n\tres <<= bits;\n\tif (res > upper_limit)\n\t\tres = upper_limit;\n\n\tif (res > MAX_LFS_FILESIZE)\n\t\tres = MAX_LFS_FILESIZE;\n\n\treturn res;\n}"
        }
      },
      {
        "call_info": {
          "callee": "EXT4_HAS_RO_COMPAT_FEATURE",
          "args": [
            "sb",
            "EXT4_FEATURE_RO_COMPAT_HUGE_FILE"
          ],
          "line": 3721
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "EXT4_SUPER_MAGIC"
          ],
          "line": 3714
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sb_bread_unmovable",
          "args": [
            "sb",
            "logical_sb_block"
          ],
          "line": 3706
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "do_div",
          "args": [
            "logical_sb_block",
            "blocksize"
          ],
          "line": 3705
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sb_set_blocksize",
          "args": [
            "sb",
            "blocksize"
          ],
          "line": 3697
        },
        "resolved": true,
        "details": {
          "function_name": "sb_set_blocksize",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/block_dev.c",
          "lines": "116-125",
          "snippet": "int sb_set_blocksize(struct super_block *sb, int size)\n{\n\tif (set_blocksize(sb->s_bdev, size))\n\t\treturn 0;\n\t/* If we get here, we know size is power of two\n\t * and it's value is between 512 and PAGE_SIZE */\n\tsb->s_blocksize = size;\n\tsb->s_blocksize_bits = blksize_bits(size);\n\treturn sb->s_blocksize;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/aio.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/log2.h>",
            "#include <linux/namei.h>",
            "#include <linux/uio.h>",
            "#include <linux/mount.h>",
            "#include <linux/mpage.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/swap.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkpg.h>",
            "#include <linux/module.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/highmem.h>",
            "#include <linux/device_cgroup.h>",
            "#include <linux/major.h>",
            "#include <linux/kmod.h>",
            "#include <linux/slab.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <linux/aio.h>\n#include <linux/cleancache.h>\n#include <linux/log2.h>\n#include <linux/namei.h>\n#include <linux/uio.h>\n#include <linux/mount.h>\n#include <linux/mpage.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/swap.h>\n#include <linux/buffer_head.h>\n#include <linux/magic.h>\n#include <linux/blkpg.h>\n#include <linux/module.h>\n#include <linux/blkdev.h>\n#include <linux/highmem.h>\n#include <linux/device_cgroup.h>\n#include <linux/major.h>\n#include <linux/kmod.h>\n#include <linux/slab.h>\n#include <linux/fcntl.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n\nint sb_set_blocksize(struct super_block *sb, int size)\n{\n\tif (set_blocksize(sb->s_bdev, size))\n\t\treturn 0;\n\t/* If we get here, we know size is power of two\n\t * and it's value is between 512 and PAGE_SIZE */\n\tsb->s_blocksize = size;\n\tsb->s_blocksize_bits = blksize_bits(size);\n\treturn sb->s_blocksize;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_feature_set_ok",
          "args": [
            "sb",
            "(sb->s_flags & MS_RDONLY)"
          ],
          "line": 3671
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_feature_set_ok",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/super.c",
          "lines": "2768-2826",
          "snippet": "static int ext4_feature_set_ok(struct super_block *sb, int readonly)\n{\n\tif (EXT4_HAS_INCOMPAT_FEATURE(sb, ~EXT4_FEATURE_INCOMPAT_SUPP)) {\n\t\text4_msg(sb, KERN_ERR,\n\t\t\t\"Couldn't mount because of \"\n\t\t\t\"unsupported optional features (%x)\",\n\t\t\t(le32_to_cpu(EXT4_SB(sb)->s_es->s_feature_incompat) &\n\t\t\t~EXT4_FEATURE_INCOMPAT_SUPP));\n\t\treturn 0;\n\t}\n\n\tif (readonly)\n\t\treturn 1;\n\n\tif (EXT4_HAS_RO_COMPAT_FEATURE(sb, EXT4_FEATURE_RO_COMPAT_READONLY)) {\n\t\text4_msg(sb, KERN_INFO, \"filesystem is read-only\");\n\t\tsb->s_flags |= MS_RDONLY;\n\t\treturn 1;\n\t}\n\n\t/* Check that feature set is OK for a read-write mount */\n\tif (EXT4_HAS_RO_COMPAT_FEATURE(sb, ~EXT4_FEATURE_RO_COMPAT_SUPP)) {\n\t\text4_msg(sb, KERN_ERR, \"couldn't mount RDWR because of \"\n\t\t\t \"unsupported optional features (%x)\",\n\t\t\t (le32_to_cpu(EXT4_SB(sb)->s_es->s_feature_ro_compat) &\n\t\t\t\t~EXT4_FEATURE_RO_COMPAT_SUPP));\n\t\treturn 0;\n\t}\n\t/*\n\t * Large file size enabled file system can only be mounted\n\t * read-write on 32-bit systems if kernel is built with CONFIG_LBDAF\n\t */\n\tif (EXT4_HAS_RO_COMPAT_FEATURE(sb, EXT4_FEATURE_RO_COMPAT_HUGE_FILE)) {\n\t\tif (sizeof(blkcnt_t) < sizeof(u64)) {\n\t\t\text4_msg(sb, KERN_ERR, \"Filesystem with huge files \"\n\t\t\t\t \"cannot be mounted RDWR without \"\n\t\t\t\t \"CONFIG_LBDAF\");\n\t\t\treturn 0;\n\t\t}\n\t}\n\tif (EXT4_HAS_RO_COMPAT_FEATURE(sb, EXT4_FEATURE_RO_COMPAT_BIGALLOC) &&\n\t    !EXT4_HAS_INCOMPAT_FEATURE(sb, EXT4_FEATURE_INCOMPAT_EXTENTS)) {\n\t\text4_msg(sb, KERN_ERR,\n\t\t\t \"Can't support bigalloc feature without \"\n\t\t\t \"extents feature\\n\");\n\t\treturn 0;\n\t}\n\n#ifndef CONFIG_QUOTA\n\tif (EXT4_HAS_RO_COMPAT_FEATURE(sb, EXT4_FEATURE_RO_COMPAT_QUOTA) &&\n\t    !readonly) {\n\t\text4_msg(sb, KERN_ERR,\n\t\t\t \"Filesystem with quota feature cannot be mounted RDWR \"\n\t\t\t \"without CONFIG_QUOTA\");\n\t\treturn 0;\n\t}\n#endif  /* CONFIG_QUOTA */\n\treturn 1;\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"mballoc.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include \"ext4_extents.h\"\t/* Needed for trace points definition */",
            "#include \"ext4.h\"",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/crc16.h>",
            "#include <linux/log2.h>",
            "#include <linux/ctype.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/random.h>",
            "#include <linux/vfs.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/parser.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/time.h>",
            "#include <linux/fs.h>",
            "#include <linux/string.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ext4_unfreeze(struct super_block *sb);",
            "static int ext4_freeze(struct super_block *sb);",
            "static inline int ext2_feature_set_ok(struct super_block *sb);",
            "static inline int ext3_feature_set_ok(struct super_block *sb);",
            "static int ext4_feature_set_ok(struct super_block *sb, int readonly);",
            "static void ext4_unregister_li_request(struct super_block *sb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"mballoc.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4_extents.h\"\t/* Needed for trace points definition */\n#include \"ext4.h\"\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <asm/uaccess.h>\n#include <linux/cleancache.h>\n#include <linux/crc16.h>\n#include <linux/log2.h>\n#include <linux/ctype.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/random.h>\n#include <linux/vfs.h>\n#include <linux/exportfs.h>\n#include <linux/buffer_head.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/jbd2.h>\n#include <linux/vmalloc.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n#include <linux/string.h>\n#include <linux/module.h>\n\nstatic int ext4_unfreeze(struct super_block *sb);\nstatic int ext4_freeze(struct super_block *sb);\nstatic inline int ext2_feature_set_ok(struct super_block *sb);\nstatic inline int ext3_feature_set_ok(struct super_block *sb);\nstatic int ext4_feature_set_ok(struct super_block *sb, int readonly);\nstatic void ext4_unregister_li_request(struct super_block *sb);\n\nstatic int ext4_feature_set_ok(struct super_block *sb, int readonly)\n{\n\tif (EXT4_HAS_INCOMPAT_FEATURE(sb, ~EXT4_FEATURE_INCOMPAT_SUPP)) {\n\t\text4_msg(sb, KERN_ERR,\n\t\t\t\"Couldn't mount because of \"\n\t\t\t\"unsupported optional features (%x)\",\n\t\t\t(le32_to_cpu(EXT4_SB(sb)->s_es->s_feature_incompat) &\n\t\t\t~EXT4_FEATURE_INCOMPAT_SUPP));\n\t\treturn 0;\n\t}\n\n\tif (readonly)\n\t\treturn 1;\n\n\tif (EXT4_HAS_RO_COMPAT_FEATURE(sb, EXT4_FEATURE_RO_COMPAT_READONLY)) {\n\t\text4_msg(sb, KERN_INFO, \"filesystem is read-only\");\n\t\tsb->s_flags |= MS_RDONLY;\n\t\treturn 1;\n\t}\n\n\t/* Check that feature set is OK for a read-write mount */\n\tif (EXT4_HAS_RO_COMPAT_FEATURE(sb, ~EXT4_FEATURE_RO_COMPAT_SUPP)) {\n\t\text4_msg(sb, KERN_ERR, \"couldn't mount RDWR because of \"\n\t\t\t \"unsupported optional features (%x)\",\n\t\t\t (le32_to_cpu(EXT4_SB(sb)->s_es->s_feature_ro_compat) &\n\t\t\t\t~EXT4_FEATURE_RO_COMPAT_SUPP));\n\t\treturn 0;\n\t}\n\t/*\n\t * Large file size enabled file system can only be mounted\n\t * read-write on 32-bit systems if kernel is built with CONFIG_LBDAF\n\t */\n\tif (EXT4_HAS_RO_COMPAT_FEATURE(sb, EXT4_FEATURE_RO_COMPAT_HUGE_FILE)) {\n\t\tif (sizeof(blkcnt_t) < sizeof(u64)) {\n\t\t\text4_msg(sb, KERN_ERR, \"Filesystem with huge files \"\n\t\t\t\t \"cannot be mounted RDWR without \"\n\t\t\t\t \"CONFIG_LBDAF\");\n\t\t\treturn 0;\n\t\t}\n\t}\n\tif (EXT4_HAS_RO_COMPAT_FEATURE(sb, EXT4_FEATURE_RO_COMPAT_BIGALLOC) &&\n\t    !EXT4_HAS_INCOMPAT_FEATURE(sb, EXT4_FEATURE_INCOMPAT_EXTENTS)) {\n\t\text4_msg(sb, KERN_ERR,\n\t\t\t \"Can't support bigalloc feature without \"\n\t\t\t \"extents feature\\n\");\n\t\treturn 0;\n\t}\n\n#ifndef CONFIG_QUOTA\n\tif (EXT4_HAS_RO_COMPAT_FEATURE(sb, EXT4_FEATURE_RO_COMPAT_QUOTA) &&\n\t    !readonly) {\n\t\text4_msg(sb, KERN_ERR,\n\t\t\t \"Filesystem with quota feature cannot be mounted RDWR \"\n\t\t\t \"without CONFIG_QUOTA\");\n\t\treturn 0;\n\t}\n#endif  /* CONFIG_QUOTA */\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext3_feature_set_ok",
          "args": [
            "sb"
          ],
          "line": 3656
        },
        "resolved": true,
        "details": {
          "function_name": "ext3_feature_set_ok",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/super.c",
          "lines": "5506-5506",
          "snippet": "static inline int ext3_feature_set_ok(struct super_block *sb) { return 0; }",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"mballoc.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include \"ext4_extents.h\"\t/* Needed for trace points definition */",
            "#include \"ext4.h\"",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/crc16.h>",
            "#include <linux/log2.h>",
            "#include <linux/ctype.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/random.h>",
            "#include <linux/vfs.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/parser.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/time.h>",
            "#include <linux/fs.h>",
            "#include <linux/string.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ext4_unfreeze(struct super_block *sb);",
            "static int ext4_freeze(struct super_block *sb);",
            "static inline int ext2_feature_set_ok(struct super_block *sb);",
            "static inline int ext3_feature_set_ok(struct super_block *sb);",
            "static void ext4_unregister_li_request(struct super_block *sb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"mballoc.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4_extents.h\"\t/* Needed for trace points definition */\n#include \"ext4.h\"\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <asm/uaccess.h>\n#include <linux/cleancache.h>\n#include <linux/crc16.h>\n#include <linux/log2.h>\n#include <linux/ctype.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/random.h>\n#include <linux/vfs.h>\n#include <linux/exportfs.h>\n#include <linux/buffer_head.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/jbd2.h>\n#include <linux/vmalloc.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n#include <linux/string.h>\n#include <linux/module.h>\n\nstatic int ext4_unfreeze(struct super_block *sb);\nstatic int ext4_freeze(struct super_block *sb);\nstatic inline int ext2_feature_set_ok(struct super_block *sb);\nstatic inline int ext3_feature_set_ok(struct super_block *sb);\nstatic void ext4_unregister_li_request(struct super_block *sb);\n\nstatic inline int ext3_feature_set_ok(struct super_block *sb) { return 0; }"
        }
      },
      {
        "call_info": {
          "callee": "IS_EXT3_SB",
          "args": [
            "sb"
          ],
          "line": 3655
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext2_feature_set_ok",
          "args": [
            "sb"
          ],
          "line": 3645
        },
        "resolved": true,
        "details": {
          "function_name": "ext2_feature_set_ok",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/super.c",
          "lines": "5474-5474",
          "snippet": "static inline int ext2_feature_set_ok(struct super_block *sb) { return 0; }",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"mballoc.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include \"ext4_extents.h\"\t/* Needed for trace points definition */",
            "#include \"ext4.h\"",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/crc16.h>",
            "#include <linux/log2.h>",
            "#include <linux/ctype.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/random.h>",
            "#include <linux/vfs.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/parser.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/time.h>",
            "#include <linux/fs.h>",
            "#include <linux/string.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ext4_unfreeze(struct super_block *sb);",
            "static int ext4_freeze(struct super_block *sb);",
            "static inline int ext2_feature_set_ok(struct super_block *sb);",
            "static inline int ext3_feature_set_ok(struct super_block *sb);",
            "static void ext4_unregister_li_request(struct super_block *sb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"mballoc.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4_extents.h\"\t/* Needed for trace points definition */\n#include \"ext4.h\"\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <asm/uaccess.h>\n#include <linux/cleancache.h>\n#include <linux/crc16.h>\n#include <linux/log2.h>\n#include <linux/ctype.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/random.h>\n#include <linux/vfs.h>\n#include <linux/exportfs.h>\n#include <linux/buffer_head.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/jbd2.h>\n#include <linux/vmalloc.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n#include <linux/string.h>\n#include <linux/module.h>\n\nstatic int ext4_unfreeze(struct super_block *sb);\nstatic int ext4_freeze(struct super_block *sb);\nstatic inline int ext2_feature_set_ok(struct super_block *sb);\nstatic inline int ext3_feature_set_ok(struct super_block *sb);\nstatic void ext4_unregister_li_request(struct super_block *sb);\n\nstatic inline int ext2_feature_set_ok(struct super_block *sb) { return 0; }"
        }
      },
      {
        "call_info": {
          "callee": "IS_EXT2_SB",
          "args": [
            "sb"
          ],
          "line": 3644
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXT4_HAS_INCOMPAT_FEATURE",
          "args": [
            "sb",
            "EXT4_FEATURE_INCOMPAT_64BIT"
          ],
          "line": 3636
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_opt2",
          "args": [
            "sb",
            "HURD_COMPAT"
          ],
          "line": 3635
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "EXT4_OS_HURD"
          ],
          "line": 3634
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXT4_HAS_INCOMPAT_FEATURE",
          "args": [
            "sb",
            "~0U"
          ],
          "line": 3629
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXT4_HAS_RO_COMPAT_FEATURE",
          "args": [
            "sb",
            "~0U"
          ],
          "line": 3628
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXT4_HAS_COMPAT_FEATURE",
          "args": [
            "sb",
            "~0U"
          ],
          "line": 3627
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_opt",
          "args": [
            "sb",
            "POSIX_ACL"
          ],
          "line": 3624
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "clear_opt",
          "args": [
            "sb",
            "DELALLOC"
          ],
          "line": 3620
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_opt",
          "args": [
            "sb",
            "DELALLOC"
          ],
          "line": 3619
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_opt",
          "args": [
            "sb",
            "DAX"
          ],
          "line": 3614
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_opt",
          "args": [
            "sb",
            "DIOREAD_NOLOCK"
          ],
          "line": 3609
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_opt2",
          "args": [
            "sb",
            "EXPLICIT_DELALLOC"
          ],
          "line": 3604
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printk_once",
          "args": [
            "KERN_WARNING \"EXT4-fs: Warning: mounting \"\n\t\t\t    \"with data=journal disables delayed \"\n\t\t\t    \"allocation and O_DIRECT support!\\n\""
          ],
          "line": 3601
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_opt",
          "args": [
            "sb",
            "DATA_FLAGS"
          ],
          "line": 3600
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "parse_options",
          "args": [
            "(char *) data",
            "sb",
            "&journal_devnum",
            "&journal_ioprio",
            "0"
          ],
          "line": 3596
        },
        "resolved": true,
        "details": {
          "function_name": "parse_options",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/super.c",
          "lines": "1645-1715",
          "snippet": "static int parse_options(char *options, struct super_block *sb,\n\t\t\t unsigned long *journal_devnum,\n\t\t\t unsigned int *journal_ioprio,\n\t\t\t int is_remount)\n{\n\tstruct ext4_sb_info *sbi = EXT4_SB(sb);\n\tchar *p;\n\tsubstring_t args[MAX_OPT_ARGS];\n\tint token;\n\n\tif (!options)\n\t\treturn 1;\n\n\twhile ((p = strsep(&options, \",\")) != NULL) {\n\t\tif (!*p)\n\t\t\tcontinue;\n\t\t/*\n\t\t * Initialize args struct so we know whether arg was\n\t\t * found; some options take optional arguments.\n\t\t */\n\t\targs[0].to = args[0].from = NULL;\n\t\ttoken = match_token(p, tokens, args);\n\t\tif (handle_mount_opt(sb, p, token, args, journal_devnum,\n\t\t\t\t     journal_ioprio, is_remount) < 0)\n\t\t\treturn 0;\n\t}\n#ifdef CONFIG_QUOTA\n\tif (EXT4_HAS_RO_COMPAT_FEATURE(sb, EXT4_FEATURE_RO_COMPAT_QUOTA) &&\n\t    (test_opt(sb, USRQUOTA) || test_opt(sb, GRPQUOTA))) {\n\t\text4_msg(sb, KERN_ERR, \"Cannot set quota options when QUOTA \"\n\t\t\t \"feature is enabled\");\n\t\treturn 0;\n\t}\n\tif (sbi->s_qf_names[USRQUOTA] || sbi->s_qf_names[GRPQUOTA]) {\n\t\tif (test_opt(sb, USRQUOTA) && sbi->s_qf_names[USRQUOTA])\n\t\t\tclear_opt(sb, USRQUOTA);\n\n\t\tif (test_opt(sb, GRPQUOTA) && sbi->s_qf_names[GRPQUOTA])\n\t\t\tclear_opt(sb, GRPQUOTA);\n\n\t\tif (test_opt(sb, GRPQUOTA) || test_opt(sb, USRQUOTA)) {\n\t\t\text4_msg(sb, KERN_ERR, \"old and new quota \"\n\t\t\t\t\t\"format mixing\");\n\t\t\treturn 0;\n\t\t}\n\n\t\tif (!sbi->s_jquota_fmt) {\n\t\t\text4_msg(sb, KERN_ERR, \"journaled quota format \"\n\t\t\t\t\t\"not specified\");\n\t\t\treturn 0;\n\t\t}\n\t}\n#endif\n\tif (test_opt(sb, DIOREAD_NOLOCK)) {\n\t\tint blocksize =\n\t\t\tBLOCK_SIZE << le32_to_cpu(sbi->s_es->s_log_block_size);\n\n\t\tif (blocksize < PAGE_CACHE_SIZE) {\n\t\t\text4_msg(sb, KERN_ERR, \"can't mount with \"\n\t\t\t\t \"dioread_nolock if block size != PAGE_SIZE\");\n\t\t\treturn 0;\n\t\t}\n\t}\n\tif (test_opt(sb, DATA_FLAGS) == EXT4_MOUNT_ORDERED_DATA &&\n\t    test_opt(sb, JOURNAL_ASYNC_COMMIT)) {\n\t\text4_msg(sb, KERN_ERR, \"can't mount with journal_async_commit \"\n\t\t\t \"in data=ordered mode\");\n\t\treturn 0;\n\t}\n\treturn 1;\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"mballoc.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include \"ext4_extents.h\"\t/* Needed for trace points definition */",
            "#include \"ext4.h\"",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/crc16.h>",
            "#include <linux/log2.h>",
            "#include <linux/ctype.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/random.h>",
            "#include <linux/vfs.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/parser.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/time.h>",
            "#include <linux/fs.h>",
            "#include <linux/string.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ext4_load_journal(struct super_block *, struct ext4_super_block *,\n\t\t\t     unsigned long journal_devnum);",
            "static int ext4_remount(struct super_block *sb, int *flags, char *data);",
            "static int ext4_unfreeze(struct super_block *sb);",
            "static int ext4_freeze(struct super_block *sb);",
            "static struct dentry *ext4_mount(struct file_system_type *fs_type, int flags,\n\t\t       const char *dev_name, void *data);",
            "static inline int ext2_feature_set_ok(struct super_block *sb);",
            "static inline int ext3_feature_set_ok(struct super_block *sb);",
            "static void ext4_unregister_li_request(struct super_block *sb);",
            "static const match_table_t tokens = {\n\t{Opt_bsd_df, \"bsddf\"},\n\t{Opt_minix_df, \"minixdf\"},\n\t{Opt_grpid, \"grpid\"},\n\t{Opt_grpid, \"bsdgroups\"},\n\t{Opt_nogrpid, \"nogrpid\"},\n\t{Opt_nogrpid, \"sysvgroups\"},\n\t{Opt_resgid, \"resgid=%u\"},\n\t{Opt_resuid, \"resuid=%u\"},\n\t{Opt_sb, \"sb=%u\"},\n\t{Opt_err_cont, \"errors=continue\"},\n\t{Opt_err_panic, \"errors=panic\"},\n\t{Opt_err_ro, \"errors=remount-ro\"},\n\t{Opt_nouid32, \"nouid32\"},\n\t{Opt_debug, \"debug\"},\n\t{Opt_removed, \"oldalloc\"},\n\t{Opt_removed, \"orlov\"},\n\t{Opt_user_xattr, \"user_xattr\"},\n\t{Opt_nouser_xattr, \"nouser_xattr\"},\n\t{Opt_acl, \"acl\"},\n\t{Opt_noacl, \"noacl\"},\n\t{Opt_noload, \"norecovery\"},\n\t{Opt_noload, \"noload\"},\n\t{Opt_removed, \"nobh\"},\n\t{Opt_removed, \"bh\"},\n\t{Opt_commit, \"commit=%u\"},\n\t{Opt_min_batch_time, \"min_batch_time=%u\"},\n\t{Opt_max_batch_time, \"max_batch_time=%u\"},\n\t{Opt_journal_dev, \"journal_dev=%u\"},\n\t{Opt_journal_path, \"journal_path=%s\"},\n\t{Opt_journal_checksum, \"journal_checksum\"},\n\t{Opt_nojournal_checksum, \"nojournal_checksum\"},\n\t{Opt_journal_async_commit, \"journal_async_commit\"},\n\t{Opt_abort, \"abort\"},\n\t{Opt_data_journal, \"data=journal\"},\n\t{Opt_data_ordered, \"data=ordered\"},\n\t{Opt_data_writeback, \"data=writeback\"},\n\t{Opt_data_err_abort, \"data_err=abort\"},\n\t{Opt_data_err_ignore, \"data_err=ignore\"},\n\t{Opt_offusrjquota, \"usrjquota=\"},\n\t{Opt_usrjquota, \"usrjquota=%s\"},\n\t{Opt_offgrpjquota, \"grpjquota=\"},\n\t{Opt_grpjquota, \"grpjquota=%s\"},\n\t{Opt_jqfmt_vfsold, \"jqfmt=vfsold\"},\n\t{Opt_jqfmt_vfsv0, \"jqfmt=vfsv0\"},\n\t{Opt_jqfmt_vfsv1, \"jqfmt=vfsv1\"},\n\t{Opt_grpquota, \"grpquota\"},\n\t{Opt_noquota, \"noquota\"},\n\t{Opt_quota, \"quota\"},\n\t{Opt_usrquota, \"usrquota\"},\n\t{Opt_barrier, \"barrier=%u\"},\n\t{Opt_barrier, \"barrier\"},\n\t{Opt_nobarrier, \"nobarrier\"},\n\t{Opt_i_version, \"i_version\"},\n\t{Opt_dax, \"dax\"},\n\t{Opt_stripe, \"stripe=%u\"},\n\t{Opt_delalloc, \"delalloc\"},\n\t{Opt_lazytime, \"lazytime\"},\n\t{Opt_nolazytime, \"nolazytime\"},\n\t{Opt_nodelalloc, \"nodelalloc\"},\n\t{Opt_removed, \"mblk_io_submit\"},\n\t{Opt_removed, \"nomblk_io_submit\"},\n\t{Opt_block_validity, \"block_validity\"},\n\t{Opt_noblock_validity, \"noblock_validity\"},\n\t{Opt_inode_readahead_blks, \"inode_readahead_blks=%u\"},\n\t{Opt_journal_ioprio, \"journal_ioprio=%u\"},\n\t{Opt_auto_da_alloc, \"auto_da_alloc=%u\"},\n\t{Opt_auto_da_alloc, \"auto_da_alloc\"},\n\t{Opt_noauto_da_alloc, \"noauto_da_alloc\"},\n\t{Opt_dioread_nolock, \"dioread_nolock\"},\n\t{Opt_dioread_lock, \"dioread_lock\"},\n\t{Opt_discard, \"discard\"},\n\t{Opt_nodiscard, \"nodiscard\"},\n\t{Opt_init_itable, \"init_itable=%u\"},\n\t{Opt_init_itable, \"init_itable\"},\n\t{Opt_noinit_itable, \"noinit_itable\"},\n\t{Opt_max_dir_size_kb, \"max_dir_size_kb=%u\"},\n\t{Opt_removed, \"check=none\"},\t/* mount option from ext2/3 */\n\t{Opt_removed, \"nocheck\"},\t/* mount option from ext2/3 */\n\t{Opt_removed, \"reservation\"},\t/* mount option from ext2/3 */\n\t{Opt_removed, \"noreservation\"}, /* mount option from ext2/3 */\n\t{Opt_removed, \"journal=%u\"},\t/* mount option from ext2/3 */\n\t{Opt_err, NULL},\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"mballoc.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4_extents.h\"\t/* Needed for trace points definition */\n#include \"ext4.h\"\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <asm/uaccess.h>\n#include <linux/cleancache.h>\n#include <linux/crc16.h>\n#include <linux/log2.h>\n#include <linux/ctype.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/random.h>\n#include <linux/vfs.h>\n#include <linux/exportfs.h>\n#include <linux/buffer_head.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/jbd2.h>\n#include <linux/vmalloc.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n#include <linux/string.h>\n#include <linux/module.h>\n\nstatic int ext4_load_journal(struct super_block *, struct ext4_super_block *,\n\t\t\t     unsigned long journal_devnum);\nstatic int ext4_remount(struct super_block *sb, int *flags, char *data);\nstatic int ext4_unfreeze(struct super_block *sb);\nstatic int ext4_freeze(struct super_block *sb);\nstatic struct dentry *ext4_mount(struct file_system_type *fs_type, int flags,\n\t\t       const char *dev_name, void *data);\nstatic inline int ext2_feature_set_ok(struct super_block *sb);\nstatic inline int ext3_feature_set_ok(struct super_block *sb);\nstatic void ext4_unregister_li_request(struct super_block *sb);\nstatic const match_table_t tokens = {\n\t{Opt_bsd_df, \"bsddf\"},\n\t{Opt_minix_df, \"minixdf\"},\n\t{Opt_grpid, \"grpid\"},\n\t{Opt_grpid, \"bsdgroups\"},\n\t{Opt_nogrpid, \"nogrpid\"},\n\t{Opt_nogrpid, \"sysvgroups\"},\n\t{Opt_resgid, \"resgid=%u\"},\n\t{Opt_resuid, \"resuid=%u\"},\n\t{Opt_sb, \"sb=%u\"},\n\t{Opt_err_cont, \"errors=continue\"},\n\t{Opt_err_panic, \"errors=panic\"},\n\t{Opt_err_ro, \"errors=remount-ro\"},\n\t{Opt_nouid32, \"nouid32\"},\n\t{Opt_debug, \"debug\"},\n\t{Opt_removed, \"oldalloc\"},\n\t{Opt_removed, \"orlov\"},\n\t{Opt_user_xattr, \"user_xattr\"},\n\t{Opt_nouser_xattr, \"nouser_xattr\"},\n\t{Opt_acl, \"acl\"},\n\t{Opt_noacl, \"noacl\"},\n\t{Opt_noload, \"norecovery\"},\n\t{Opt_noload, \"noload\"},\n\t{Opt_removed, \"nobh\"},\n\t{Opt_removed, \"bh\"},\n\t{Opt_commit, \"commit=%u\"},\n\t{Opt_min_batch_time, \"min_batch_time=%u\"},\n\t{Opt_max_batch_time, \"max_batch_time=%u\"},\n\t{Opt_journal_dev, \"journal_dev=%u\"},\n\t{Opt_journal_path, \"journal_path=%s\"},\n\t{Opt_journal_checksum, \"journal_checksum\"},\n\t{Opt_nojournal_checksum, \"nojournal_checksum\"},\n\t{Opt_journal_async_commit, \"journal_async_commit\"},\n\t{Opt_abort, \"abort\"},\n\t{Opt_data_journal, \"data=journal\"},\n\t{Opt_data_ordered, \"data=ordered\"},\n\t{Opt_data_writeback, \"data=writeback\"},\n\t{Opt_data_err_abort, \"data_err=abort\"},\n\t{Opt_data_err_ignore, \"data_err=ignore\"},\n\t{Opt_offusrjquota, \"usrjquota=\"},\n\t{Opt_usrjquota, \"usrjquota=%s\"},\n\t{Opt_offgrpjquota, \"grpjquota=\"},\n\t{Opt_grpjquota, \"grpjquota=%s\"},\n\t{Opt_jqfmt_vfsold, \"jqfmt=vfsold\"},\n\t{Opt_jqfmt_vfsv0, \"jqfmt=vfsv0\"},\n\t{Opt_jqfmt_vfsv1, \"jqfmt=vfsv1\"},\n\t{Opt_grpquota, \"grpquota\"},\n\t{Opt_noquota, \"noquota\"},\n\t{Opt_quota, \"quota\"},\n\t{Opt_usrquota, \"usrquota\"},\n\t{Opt_barrier, \"barrier=%u\"},\n\t{Opt_barrier, \"barrier\"},\n\t{Opt_nobarrier, \"nobarrier\"},\n\t{Opt_i_version, \"i_version\"},\n\t{Opt_dax, \"dax\"},\n\t{Opt_stripe, \"stripe=%u\"},\n\t{Opt_delalloc, \"delalloc\"},\n\t{Opt_lazytime, \"lazytime\"},\n\t{Opt_nolazytime, \"nolazytime\"},\n\t{Opt_nodelalloc, \"nodelalloc\"},\n\t{Opt_removed, \"mblk_io_submit\"},\n\t{Opt_removed, \"nomblk_io_submit\"},\n\t{Opt_block_validity, \"block_validity\"},\n\t{Opt_noblock_validity, \"noblock_validity\"},\n\t{Opt_inode_readahead_blks, \"inode_readahead_blks=%u\"},\n\t{Opt_journal_ioprio, \"journal_ioprio=%u\"},\n\t{Opt_auto_da_alloc, \"auto_da_alloc=%u\"},\n\t{Opt_auto_da_alloc, \"auto_da_alloc\"},\n\t{Opt_noauto_da_alloc, \"noauto_da_alloc\"},\n\t{Opt_dioread_nolock, \"dioread_nolock\"},\n\t{Opt_dioread_lock, \"dioread_lock\"},\n\t{Opt_discard, \"discard\"},\n\t{Opt_nodiscard, \"nodiscard\"},\n\t{Opt_init_itable, \"init_itable=%u\"},\n\t{Opt_init_itable, \"init_itable\"},\n\t{Opt_noinit_itable, \"noinit_itable\"},\n\t{Opt_max_dir_size_kb, \"max_dir_size_kb=%u\"},\n\t{Opt_removed, \"check=none\"},\t/* mount option from ext2/3 */\n\t{Opt_removed, \"nocheck\"},\t/* mount option from ext2/3 */\n\t{Opt_removed, \"reservation\"},\t/* mount option from ext2/3 */\n\t{Opt_removed, \"noreservation\"}, /* mount option from ext2/3 */\n\t{Opt_removed, \"journal=%u\"},\t/* mount option from ext2/3 */\n\t{Opt_err, NULL},\n};\n\nstatic int parse_options(char *options, struct super_block *sb,\n\t\t\t unsigned long *journal_devnum,\n\t\t\t unsigned int *journal_ioprio,\n\t\t\t int is_remount)\n{\n\tstruct ext4_sb_info *sbi = EXT4_SB(sb);\n\tchar *p;\n\tsubstring_t args[MAX_OPT_ARGS];\n\tint token;\n\n\tif (!options)\n\t\treturn 1;\n\n\twhile ((p = strsep(&options, \",\")) != NULL) {\n\t\tif (!*p)\n\t\t\tcontinue;\n\t\t/*\n\t\t * Initialize args struct so we know whether arg was\n\t\t * found; some options take optional arguments.\n\t\t */\n\t\targs[0].to = args[0].from = NULL;\n\t\ttoken = match_token(p, tokens, args);\n\t\tif (handle_mount_opt(sb, p, token, args, journal_devnum,\n\t\t\t\t     journal_ioprio, is_remount) < 0)\n\t\t\treturn 0;\n\t}\n#ifdef CONFIG_QUOTA\n\tif (EXT4_HAS_RO_COMPAT_FEATURE(sb, EXT4_FEATURE_RO_COMPAT_QUOTA) &&\n\t    (test_opt(sb, USRQUOTA) || test_opt(sb, GRPQUOTA))) {\n\t\text4_msg(sb, KERN_ERR, \"Cannot set quota options when QUOTA \"\n\t\t\t \"feature is enabled\");\n\t\treturn 0;\n\t}\n\tif (sbi->s_qf_names[USRQUOTA] || sbi->s_qf_names[GRPQUOTA]) {\n\t\tif (test_opt(sb, USRQUOTA) && sbi->s_qf_names[USRQUOTA])\n\t\t\tclear_opt(sb, USRQUOTA);\n\n\t\tif (test_opt(sb, GRPQUOTA) && sbi->s_qf_names[GRPQUOTA])\n\t\t\tclear_opt(sb, GRPQUOTA);\n\n\t\tif (test_opt(sb, GRPQUOTA) || test_opt(sb, USRQUOTA)) {\n\t\t\text4_msg(sb, KERN_ERR, \"old and new quota \"\n\t\t\t\t\t\"format mixing\");\n\t\t\treturn 0;\n\t\t}\n\n\t\tif (!sbi->s_jquota_fmt) {\n\t\t\text4_msg(sb, KERN_ERR, \"journaled quota format \"\n\t\t\t\t\t\"not specified\");\n\t\t\treturn 0;\n\t\t}\n\t}\n#endif\n\tif (test_opt(sb, DIOREAD_NOLOCK)) {\n\t\tint blocksize =\n\t\t\tBLOCK_SIZE << le32_to_cpu(sbi->s_es->s_log_block_size);\n\n\t\tif (blocksize < PAGE_CACHE_SIZE) {\n\t\t\text4_msg(sb, KERN_ERR, \"can't mount with \"\n\t\t\t\t \"dioread_nolock if block size != PAGE_SIZE\");\n\t\t\treturn 0;\n\t\t}\n\t}\n\tif (test_opt(sb, DATA_FLAGS) == EXT4_MOUNT_ORDERED_DATA &&\n\t    test_opt(sb, JOURNAL_ASYNC_COMMIT)) {\n\t\text4_msg(sb, KERN_ERR, \"can't mount with journal_async_commit \"\n\t\t\t \"in data=ordered mode\");\n\t\treturn 0;\n\t}\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_EXT2_SB",
          "args": [
            "sb"
          ],
          "line": 3579
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_EXT3_SB",
          "args": [
            "sb"
          ],
          "line": 3579
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "make_kgid",
          "args": [
            "&init_user_ns",
            "le16_to_cpu(es->s_def_resgid)"
          ],
          "line": 3567
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "make_kuid",
          "args": [
            "&init_user_ns",
            "le16_to_cpu(es->s_def_resuid)"
          ],
          "line": 3566
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_has_metadata_csum",
          "args": [
            "sb"
          ],
          "line": 3545
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_chksum",
          "args": [
            "sbi",
            "~0",
            "es->s_uuid",
            "sizeof(es->s_uuid)"
          ],
          "line": 3527
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_chksum",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ext4.h",
          "lines": "1756-1775",
          "snippet": "static inline u32 ext4_chksum(struct ext4_sb_info *sbi, u32 crc,\n\t\t\t      const void *address, unsigned int length)\n{\n\tstruct {\n\t\tstruct shash_desc shash;\n\t\tchar ctx[4];\n\t} desc;\n\tint err;\n\n\tBUG_ON(crypto_shash_descsize(sbi->s_chksum_driver)!=sizeof(desc.ctx));\n\n\tdesc.shash.tfm = sbi->s_chksum_driver;\n\tdesc.shash.flags = 0;\n\t*(u32 *)desc.ctx = crc;\n\n\terr = crypto_shash_update(&desc.shash, address, length);\n\tBUG_ON(err);\n\n\treturn *(u32 *)desc.ctx;\n}",
          "includes": [
            "#include \"extents_status.h\"",
            "#include <linux/compat.h>",
            "#include <linux/falloc.h>",
            "#include <crypto/hash.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/wait.h>",
            "#include <linux/timer.h>",
            "#include <linux/mutex.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/quota.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extents_status.h\"\n#include <linux/compat.h>\n#include <linux/falloc.h>\n#include <crypto/hash.h>\n#include <linux/ratelimit.h>\n#include <linux/percpu_counter.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/wait.h>\n#include <linux/timer.h>\n#include <linux/mutex.h>\n#include <linux/seqlock.h>\n#include <linux/rbtree.h>\n#include <linux/rwsem.h>\n#include <linux/quota.h>\n#include <linux/jbd2.h>\n#include <linux/magic.h>\n#include <linux/blkdev.h>\n#include <linux/types.h>\n\nstatic inline u32 ext4_chksum(struct ext4_sb_info *sbi, u32 crc,\n\t\t\t      const void *address, unsigned int length)\n{\n\tstruct {\n\t\tstruct shash_desc shash;\n\t\tchar ctx[4];\n\t} desc;\n\tint err;\n\n\tBUG_ON(crypto_shash_descsize(sbi->s_chksum_driver)!=sizeof(desc.ctx));\n\n\tdesc.shash.tfm = sbi->s_chksum_driver;\n\tdesc.shash.flags = 0;\n\t*(u32 *)desc.ctx = crc;\n\n\terr = crypto_shash_update(&desc.shash, address, length);\n\tBUG_ON(err);\n\n\treturn *(u32 *)desc.ctx;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_has_metadata_csum",
          "args": [
            "sb"
          ],
          "line": 3526
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_superblock_csum_verify",
          "args": [
            "sb",
            "es"
          ],
          "line": 3518
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_superblock_csum_verify",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/super.c",
          "lines": "140-147",
          "snippet": "static int ext4_superblock_csum_verify(struct super_block *sb,\n\t\t\t\t       struct ext4_super_block *es)\n{\n\tif (!ext4_has_metadata_csum(sb))\n\t\treturn 1;\n\n\treturn es->s_checksum == ext4_superblock_csum(sb, es);\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"mballoc.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include \"ext4_extents.h\"\t/* Needed for trace points definition */",
            "#include \"ext4.h\"",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/crc16.h>",
            "#include <linux/log2.h>",
            "#include <linux/ctype.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/random.h>",
            "#include <linux/vfs.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/parser.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/time.h>",
            "#include <linux/fs.h>",
            "#include <linux/string.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void ext4_mark_recovery_complete(struct super_block *sb,\n\t\t\t\t\tstruct ext4_super_block *es);",
            "static void ext4_clear_journal_err(struct super_block *sb,\n\t\t\t\t   struct ext4_super_block *es);",
            "static int ext4_unfreeze(struct super_block *sb);",
            "static int ext4_freeze(struct super_block *sb);",
            "static inline int ext2_feature_set_ok(struct super_block *sb);",
            "static inline int ext3_feature_set_ok(struct super_block *sb);",
            "static void ext4_unregister_li_request(struct super_block *sb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"mballoc.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4_extents.h\"\t/* Needed for trace points definition */\n#include \"ext4.h\"\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <asm/uaccess.h>\n#include <linux/cleancache.h>\n#include <linux/crc16.h>\n#include <linux/log2.h>\n#include <linux/ctype.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/random.h>\n#include <linux/vfs.h>\n#include <linux/exportfs.h>\n#include <linux/buffer_head.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/jbd2.h>\n#include <linux/vmalloc.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n#include <linux/string.h>\n#include <linux/module.h>\n\nstatic void ext4_mark_recovery_complete(struct super_block *sb,\n\t\t\t\t\tstruct ext4_super_block *es);\nstatic void ext4_clear_journal_err(struct super_block *sb,\n\t\t\t\t   struct ext4_super_block *es);\nstatic int ext4_unfreeze(struct super_block *sb);\nstatic int ext4_freeze(struct super_block *sb);\nstatic inline int ext2_feature_set_ok(struct super_block *sb);\nstatic inline int ext3_feature_set_ok(struct super_block *sb);\nstatic void ext4_unregister_li_request(struct super_block *sb);\n\nstatic int ext4_superblock_csum_verify(struct super_block *sb,\n\t\t\t\t       struct ext4_super_block *es)\n{\n\tif (!ext4_has_metadata_csum(sb))\n\t\treturn 1;\n\n\treturn es->s_checksum == ext4_superblock_csum(sb, es);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "sbi->s_chksum_driver"
          ],
          "line": 3511
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "sbi->s_chksum_driver"
          ],
          "line": 3509
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "crypto_alloc_shash",
          "args": [
            "\"crc32c\"",
            "0",
            "0"
          ],
          "line": 3508
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXT4_HAS_RO_COMPAT_FEATURE",
          "args": [
            "sb",
            "EXT4_FEATURE_RO_COMPAT_METADATA_CSUM"
          ],
          "line": 3506
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_verify_csum_type",
          "args": [
            "sb",
            "es"
          ],
          "line": 3498
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_verify_csum_type",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/super.c",
          "lines": "118-126",
          "snippet": "static int ext4_verify_csum_type(struct super_block *sb,\n\t\t\t\t struct ext4_super_block *es)\n{\n\tif (!EXT4_HAS_RO_COMPAT_FEATURE(sb,\n\t\t\t\t\tEXT4_FEATURE_RO_COMPAT_METADATA_CSUM))\n\t\treturn 1;\n\n\treturn es->s_checksum_type == EXT4_CRC32C_CHKSUM;\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"mballoc.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include \"ext4_extents.h\"\t/* Needed for trace points definition */",
            "#include \"ext4.h\"",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/crc16.h>",
            "#include <linux/log2.h>",
            "#include <linux/ctype.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/random.h>",
            "#include <linux/vfs.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/parser.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/time.h>",
            "#include <linux/fs.h>",
            "#include <linux/string.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void ext4_mark_recovery_complete(struct super_block *sb,\n\t\t\t\t\tstruct ext4_super_block *es);",
            "static void ext4_clear_journal_err(struct super_block *sb,\n\t\t\t\t   struct ext4_super_block *es);",
            "static int ext4_unfreeze(struct super_block *sb);",
            "static int ext4_freeze(struct super_block *sb);",
            "static inline int ext2_feature_set_ok(struct super_block *sb);",
            "static inline int ext3_feature_set_ok(struct super_block *sb);",
            "static void ext4_unregister_li_request(struct super_block *sb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"mballoc.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4_extents.h\"\t/* Needed for trace points definition */\n#include \"ext4.h\"\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <asm/uaccess.h>\n#include <linux/cleancache.h>\n#include <linux/crc16.h>\n#include <linux/log2.h>\n#include <linux/ctype.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/random.h>\n#include <linux/vfs.h>\n#include <linux/exportfs.h>\n#include <linux/buffer_head.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/jbd2.h>\n#include <linux/vmalloc.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n#include <linux/string.h>\n#include <linux/module.h>\n\nstatic void ext4_mark_recovery_complete(struct super_block *sb,\n\t\t\t\t\tstruct ext4_super_block *es);\nstatic void ext4_clear_journal_err(struct super_block *sb,\n\t\t\t\t   struct ext4_super_block *es);\nstatic int ext4_unfreeze(struct super_block *sb);\nstatic int ext4_freeze(struct super_block *sb);\nstatic inline int ext2_feature_set_ok(struct super_block *sb);\nstatic inline int ext3_feature_set_ok(struct super_block *sb);\nstatic void ext4_unregister_li_request(struct super_block *sb);\n\nstatic int ext4_verify_csum_type(struct super_block *sb,\n\t\t\t\t struct ext4_super_block *es)\n{\n\tif (!EXT4_HAS_RO_COMPAT_FEATURE(sb,\n\t\t\t\t\tEXT4_FEATURE_RO_COMPAT_METADATA_CSUM))\n\t\treturn 1;\n\n\treturn es->s_checksum_type == EXT4_CRC32C_CHKSUM;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_warning",
          "args": [
            "sb",
            "\"metadata_csum and uninit_bg are \"\n\t\t\t     \"redundant flags; please run fsck.\""
          ],
          "line": 3494
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXT4_HAS_RO_COMPAT_FEATURE",
          "args": [
            "sb",
            "EXT4_FEATURE_RO_COMPAT_GDT_CSUM"
          ],
          "line": 3493
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXT4_HAS_RO_COMPAT_FEATURE",
          "args": [
            "sb",
            "EXT4_FEATURE_RO_COMPAT_METADATA_CSUM"
          ],
          "line": 3491
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sb_bread_unmovable",
          "args": [
            "sb",
            "logical_sb_block"
          ],
          "line": 3475
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "do_div",
          "args": [
            "logical_sb_block",
            "blocksize"
          ],
          "line": 3470
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sb_min_blocksize",
          "args": [
            "sb",
            "EXT4_MIN_BLOCK_SIZE"
          ],
          "line": 3458
        },
        "resolved": true,
        "details": {
          "function_name": "sb_min_blocksize",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/block_dev.c",
          "lines": "129-135",
          "snippet": "int sb_min_blocksize(struct super_block *sb, int size)\n{\n\tint minsize = bdev_logical_block_size(sb->s_bdev);\n\tif (size < minsize)\n\t\tsize = minsize;\n\treturn sb_set_blocksize(sb, size);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/aio.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/log2.h>",
            "#include <linux/namei.h>",
            "#include <linux/uio.h>",
            "#include <linux/mount.h>",
            "#include <linux/mpage.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/swap.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkpg.h>",
            "#include <linux/module.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/highmem.h>",
            "#include <linux/device_cgroup.h>",
            "#include <linux/major.h>",
            "#include <linux/kmod.h>",
            "#include <linux/slab.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <linux/aio.h>\n#include <linux/cleancache.h>\n#include <linux/log2.h>\n#include <linux/namei.h>\n#include <linux/uio.h>\n#include <linux/mount.h>\n#include <linux/mpage.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/swap.h>\n#include <linux/buffer_head.h>\n#include <linux/magic.h>\n#include <linux/blkpg.h>\n#include <linux/module.h>\n#include <linux/blkdev.h>\n#include <linux/highmem.h>\n#include <linux/device_cgroup.h>\n#include <linux/major.h>\n#include <linux/kmod.h>\n#include <linux/slab.h>\n#include <linux/fcntl.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n\nint sb_min_blocksize(struct super_block *sb, int size)\n{\n\tint minsize = bdev_logical_block_size(sb->s_bdev);\n\tif (size < minsize)\n\t\tsize = minsize;\n\treturn sb_set_blocksize(sb, size);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strchr",
          "args": [
            "cp",
            "'/'"
          ],
          "line": 3453
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "part_stat_read",
          "args": [
            "sb->s_bdev->bd_part",
            "sectors[1]"
          ],
          "line": 3450
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "sbi"
          ],
          "line": 3441
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "sizeof(struct blockgroup_lock)",
            "GFP_KERNEL"
          ],
          "line": 3439
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "sizeof(*sbi)",
            "GFP_KERNEL"
          ],
          "line": 3434
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_sb_block",
          "args": [
            "&data"
          ],
          "line": 3416
        },
        "resolved": true,
        "details": {
          "function_name": "get_sb_block",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/super.c",
          "lines": "1222-1243",
          "snippet": "static ext4_fsblk_t get_sb_block(void **data)\n{\n\text4_fsblk_t\tsb_block;\n\tchar\t\t*options = (char *) *data;\n\n\tif (!options || strncmp(options, \"sb=\", 3) != 0)\n\t\treturn 1;\t/* Default location */\n\n\toptions += 3;\n\t/* TODO: use simple_strtoll with >32bit ext4 */\n\tsb_block = simple_strtoul(options, &options, 0);\n\tif (*options && *options != ',') {\n\t\tprintk(KERN_ERR \"EXT4-fs: Invalid sb specification: %s\\n\",\n\t\t       (char *) *data);\n\t\treturn 1;\n\t}\n\tif (*options == ',')\n\t\toptions++;\n\t*data = (void *) options;\n\n\treturn sb_block;\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"mballoc.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include \"ext4_extents.h\"\t/* Needed for trace points definition */",
            "#include \"ext4.h\"",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/crc16.h>",
            "#include <linux/log2.h>",
            "#include <linux/ctype.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/random.h>",
            "#include <linux/vfs.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/parser.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/time.h>",
            "#include <linux/fs.h>",
            "#include <linux/string.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ext4_remount(struct super_block *sb, int *flags, char *data);",
            "static int ext4_unfreeze(struct super_block *sb);",
            "static int ext4_freeze(struct super_block *sb);",
            "static struct dentry *ext4_mount(struct file_system_type *fs_type, int flags,\n\t\t       const char *dev_name, void *data);",
            "static inline int ext2_feature_set_ok(struct super_block *sb);",
            "static inline int ext3_feature_set_ok(struct super_block *sb);",
            "static void ext4_unregister_li_request(struct super_block *sb);",
            "static int ext4_reserve_clusters(struct ext4_sb_info *, ext4_fsblk_t);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"mballoc.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4_extents.h\"\t/* Needed for trace points definition */\n#include \"ext4.h\"\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <asm/uaccess.h>\n#include <linux/cleancache.h>\n#include <linux/crc16.h>\n#include <linux/log2.h>\n#include <linux/ctype.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/random.h>\n#include <linux/vfs.h>\n#include <linux/exportfs.h>\n#include <linux/buffer_head.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/jbd2.h>\n#include <linux/vmalloc.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n#include <linux/string.h>\n#include <linux/module.h>\n\nstatic int ext4_remount(struct super_block *sb, int *flags, char *data);\nstatic int ext4_unfreeze(struct super_block *sb);\nstatic int ext4_freeze(struct super_block *sb);\nstatic struct dentry *ext4_mount(struct file_system_type *fs_type, int flags,\n\t\t       const char *dev_name, void *data);\nstatic inline int ext2_feature_set_ok(struct super_block *sb);\nstatic inline int ext3_feature_set_ok(struct super_block *sb);\nstatic void ext4_unregister_li_request(struct super_block *sb);\nstatic int ext4_reserve_clusters(struct ext4_sb_info *, ext4_fsblk_t);\n\nstatic ext4_fsblk_t get_sb_block(void **data)\n{\n\text4_fsblk_t\tsb_block;\n\tchar\t\t*options = (char *) *data;\n\n\tif (!options || strncmp(options, \"sb=\", 3) != 0)\n\t\treturn 1;\t/* Default location */\n\n\toptions += 3;\n\t/* TODO: use simple_strtoll with >32bit ext4 */\n\tsb_block = simple_strtoul(options, &options, 0);\n\tif (*options && *options != ',') {\n\t\tprintk(KERN_ERR \"EXT4-fs: Invalid sb specification: %s\\n\",\n\t\t       (char *) *data);\n\t\treturn 1;\n\t}\n\tif (*options == ',')\n\t\toptions++;\n\t*data = (void *) options;\n\n\treturn sb_block;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kstrdup",
          "args": [
            "data",
            "GFP_KERNEL"
          ],
          "line": 3411
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"mballoc.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4_extents.h\"\t/* Needed for trace points definition */\n#include \"ext4.h\"\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <asm/uaccess.h>\n#include <linux/cleancache.h>\n#include <linux/crc16.h>\n#include <linux/log2.h>\n#include <linux/ctype.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/random.h>\n#include <linux/vfs.h>\n#include <linux/exportfs.h>\n#include <linux/buffer_head.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/jbd2.h>\n#include <linux/vmalloc.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n#include <linux/string.h>\n#include <linux/module.h>\n\n#define DEFAULT_JOURNAL_IOPRIO (IOPRIO_PRIO_VALUE(IOPRIO_CLASS_BE, 3))\n\nstatic struct proc_dir_entry *ext4_proc_root;\nstatic struct kset *ext4_kset;\nstatic int ext4_mballoc_ready;\nstatic int ext4_load_journal(struct super_block *, struct ext4_super_block *,\n\t\t\t     unsigned long journal_devnum);\nstatic int ext4_show_options(struct seq_file *seq, struct dentry *root);\nstatic void ext4_mark_recovery_complete(struct super_block *sb,\n\t\t\t\t\tstruct ext4_super_block *es);\nstatic void ext4_clear_journal_err(struct super_block *sb,\n\t\t\t\t   struct ext4_super_block *es);\nstatic int ext4_remount(struct super_block *sb, int *flags, char *data);\nstatic int ext4_unfreeze(struct super_block *sb);\nstatic int ext4_freeze(struct super_block *sb);\nstatic struct dentry *ext4_mount(struct file_system_type *fs_type, int flags,\n\t\t       const char *dev_name, void *data);\nstatic inline int ext2_feature_set_ok(struct super_block *sb);\nstatic inline int ext3_feature_set_ok(struct super_block *sb);\nstatic void ext4_unregister_li_request(struct super_block *sb);\nstatic int ext4_reserve_clusters(struct ext4_sb_info *, ext4_fsblk_t);\nstatic const struct super_operations ext4_sops = {\n\t.alloc_inode\t= ext4_alloc_inode,\n\t.destroy_inode\t= ext4_destroy_inode,\n\t.write_inode\t= ext4_write_inode,\n\t.dirty_inode\t= ext4_dirty_inode,\n\t.drop_inode\t= ext4_drop_inode,\n\t.evict_inode\t= ext4_evict_inode,\n\t.put_super\t= ext4_put_super,\n\t.sync_fs\t= ext4_sync_fs,\n\t.freeze_fs\t= ext4_freeze,\n\t.unfreeze_fs\t= ext4_unfreeze,\n\t.statfs\t\t= ext4_statfs,\n\t.remount_fs\t= ext4_remount,\n\t.show_options\t= ext4_show_options,\n#ifdef CONFIG_QUOTA\n\t.quota_read\t= ext4_quota_read,\n\t.quota_write\t= ext4_quota_write,\n\t.get_dquots\t= ext4_get_dquots,\n#endif\n\t.bdev_try_to_free_page = bdev_try_to_free_page,\n};\nstatic const struct export_operations ext4_export_ops = {\n\t.fh_to_dentry = ext4_fh_to_dentry,\n\t.fh_to_parent = ext4_fh_to_parent,\n\t.get_parent = ext4_get_parent,\n};\nstatic const struct file_operations ext4_seq_options_fops = {\n\t.owner = THIS_MODULE,\n\t.open = options_open_fs,\n\t.read = seq_read,\n\t.llseek = seq_lseek,\n\t.release = single_release,\n};\nstatic struct kobj_type ext4_ktype = {\n\t.default_attrs\t= ext4_attrs,\n\t.sysfs_ops\t= &ext4_attr_ops,\n\t.release\t= ext4_sb_release,\n};\n\nstatic int ext4_fill_super(struct super_block *sb, void *data, int silent)\n{\n\tchar *orig_data = kstrdup(data, GFP_KERNEL);\n\tstruct buffer_head *bh;\n\tstruct ext4_super_block *es = NULL;\n\tstruct ext4_sb_info *sbi;\n\text4_fsblk_t block;\n\text4_fsblk_t sb_block = get_sb_block(&data);\n\text4_fsblk_t logical_sb_block;\n\tunsigned long offset = 0;\n\tunsigned long journal_devnum = 0;\n\tunsigned long def_mount_opts;\n\tstruct inode *root;\n\tchar *cp;\n\tconst char *descr;\n\tint ret = -ENOMEM;\n\tint blocksize, clustersize;\n\tunsigned int db_count;\n\tunsigned int i;\n\tint needs_recovery, has_huge_files, has_bigalloc;\n\t__u64 blocks_count;\n\tint err = 0;\n\tunsigned int journal_ioprio = DEFAULT_JOURNAL_IOPRIO;\n\text4_group_t first_not_zeroed;\n\n\tsbi = kzalloc(sizeof(*sbi), GFP_KERNEL);\n\tif (!sbi)\n\t\tgoto out_free_orig;\n\n\tsbi->s_blockgroup_lock =\n\t\tkzalloc(sizeof(struct blockgroup_lock), GFP_KERNEL);\n\tif (!sbi->s_blockgroup_lock) {\n\t\tkfree(sbi);\n\t\tgoto out_free_orig;\n\t}\n\tsb->s_fs_info = sbi;\n\tsbi->s_sb = sb;\n\tsbi->s_inode_readahead_blks = EXT4_DEF_INODE_READAHEAD_BLKS;\n\tsbi->s_sb_block = sb_block;\n\tif (sb->s_bdev->bd_part)\n\t\tsbi->s_sectors_written_start =\n\t\t\tpart_stat_read(sb->s_bdev->bd_part, sectors[1]);\n\n\t/* Cleanup superblock name */\n\tfor (cp = sb->s_id; (cp = strchr(cp, '/'));)\n\t\t*cp = '!';\n\n\t/* -EINVAL is default */\n\tret = -EINVAL;\n\tblocksize = sb_min_blocksize(sb, EXT4_MIN_BLOCK_SIZE);\n\tif (!blocksize) {\n\t\text4_msg(sb, KERN_ERR, \"unable to set blocksize\");\n\t\tgoto out_fail;\n\t}\n\n\t/*\n\t * The ext4 superblock will not be buffer aligned for other than 1kB\n\t * block sizes.  We need to calculate the offset from buffer start.\n\t */\n\tif (blocksize != EXT4_MIN_BLOCK_SIZE) {\n\t\tlogical_sb_block = sb_block * EXT4_MIN_BLOCK_SIZE;\n\t\toffset = do_div(logical_sb_block, blocksize);\n\t} else {\n\t\tlogical_sb_block = sb_block;\n\t}\n\n\tif (!(bh = sb_bread_unmovable(sb, logical_sb_block))) {\n\t\text4_msg(sb, KERN_ERR, \"unable to read superblock\");\n\t\tgoto out_fail;\n\t}\n\t/*\n\t * Note: s_es must be initialized as soon as possible because\n\t *       some ext4 macro-instructions depend on its value\n\t */\n\tes = (struct ext4_super_block *) (bh->b_data + offset);\n\tsbi->s_es = es;\n\tsb->s_magic = le16_to_cpu(es->s_magic);\n\tif (sb->s_magic != EXT4_SUPER_MAGIC)\n\t\tgoto cantfind_ext4;\n\tsbi->s_kbytes_written = le64_to_cpu(es->s_kbytes_written);\n\n\t/* Warn if metadata_csum and gdt_csum are both set. */\n\tif (EXT4_HAS_RO_COMPAT_FEATURE(sb,\n\t\t\t\t       EXT4_FEATURE_RO_COMPAT_METADATA_CSUM) &&\n\t    EXT4_HAS_RO_COMPAT_FEATURE(sb, EXT4_FEATURE_RO_COMPAT_GDT_CSUM))\n\t\text4_warning(sb, \"metadata_csum and uninit_bg are \"\n\t\t\t     \"redundant flags; please run fsck.\");\n\n\t/* Check for a known checksum algorithm */\n\tif (!ext4_verify_csum_type(sb, es)) {\n\t\text4_msg(sb, KERN_ERR, \"VFS: Found ext4 filesystem with \"\n\t\t\t \"unknown checksum algorithm.\");\n\t\tsilent = 1;\n\t\tgoto cantfind_ext4;\n\t}\n\n\t/* Load the checksum driver */\n\tif (EXT4_HAS_RO_COMPAT_FEATURE(sb,\n\t\t\t\t       EXT4_FEATURE_RO_COMPAT_METADATA_CSUM)) {\n\t\tsbi->s_chksum_driver = crypto_alloc_shash(\"crc32c\", 0, 0);\n\t\tif (IS_ERR(sbi->s_chksum_driver)) {\n\t\t\text4_msg(sb, KERN_ERR, \"Cannot load crc32c driver.\");\n\t\t\tret = PTR_ERR(sbi->s_chksum_driver);\n\t\t\tsbi->s_chksum_driver = NULL;\n\t\t\tgoto failed_mount;\n\t\t}\n\t}\n\n\t/* Check superblock checksum */\n\tif (!ext4_superblock_csum_verify(sb, es)) {\n\t\text4_msg(sb, KERN_ERR, \"VFS: Found ext4 filesystem with \"\n\t\t\t \"invalid superblock checksum.  Run e2fsck?\");\n\t\tsilent = 1;\n\t\tgoto cantfind_ext4;\n\t}\n\n\t/* Precompute checksum seed for all metadata */\n\tif (ext4_has_metadata_csum(sb))\n\t\tsbi->s_csum_seed = ext4_chksum(sbi, ~0, es->s_uuid,\n\t\t\t\t\t       sizeof(es->s_uuid));\n\n\t/* Set defaults before we parse the mount options */\n\tdef_mount_opts = le32_to_cpu(es->s_default_mount_opts);\n\tset_opt(sb, INIT_INODE_TABLE);\n\tif (def_mount_opts & EXT4_DEFM_DEBUG)\n\t\tset_opt(sb, DEBUG);\n\tif (def_mount_opts & EXT4_DEFM_BSDGROUPS)\n\t\tset_opt(sb, GRPID);\n\tif (def_mount_opts & EXT4_DEFM_UID16)\n\t\tset_opt(sb, NO_UID32);\n\t/* xattr user namespace & acls are now defaulted on */\n\tset_opt(sb, XATTR_USER);\n#ifdef CONFIG_EXT4_FS_POSIX_ACL\n\tset_opt(sb, POSIX_ACL);\n#endif\n\t/* don't forget to enable journal_csum when metadata_csum is enabled. */\n\tif (ext4_has_metadata_csum(sb))\n\t\tset_opt(sb, JOURNAL_CHECKSUM);\n\n\tif ((def_mount_opts & EXT4_DEFM_JMODE) == EXT4_DEFM_JMODE_DATA)\n\t\tset_opt(sb, JOURNAL_DATA);\n\telse if ((def_mount_opts & EXT4_DEFM_JMODE) == EXT4_DEFM_JMODE_ORDERED)\n\t\tset_opt(sb, ORDERED_DATA);\n\telse if ((def_mount_opts & EXT4_DEFM_JMODE) == EXT4_DEFM_JMODE_WBACK)\n\t\tset_opt(sb, WRITEBACK_DATA);\n\n\tif (le16_to_cpu(sbi->s_es->s_errors) == EXT4_ERRORS_PANIC)\n\t\tset_opt(sb, ERRORS_PANIC);\n\telse if (le16_to_cpu(sbi->s_es->s_errors) == EXT4_ERRORS_CONTINUE)\n\t\tset_opt(sb, ERRORS_CONT);\n\telse\n\t\tset_opt(sb, ERRORS_RO);\n\t/* block_validity enabled by default; disable with noblock_validity */\n\tset_opt(sb, BLOCK_VALIDITY);\n\tif (def_mount_opts & EXT4_DEFM_DISCARD)\n\t\tset_opt(sb, DISCARD);\n\n\tsbi->s_resuid = make_kuid(&init_user_ns, le16_to_cpu(es->s_def_resuid));\n\tsbi->s_resgid = make_kgid(&init_user_ns, le16_to_cpu(es->s_def_resgid));\n\tsbi->s_commit_interval = JBD2_DEFAULT_MAX_COMMIT_AGE * HZ;\n\tsbi->s_min_batch_time = EXT4_DEF_MIN_BATCH_TIME;\n\tsbi->s_max_batch_time = EXT4_DEF_MAX_BATCH_TIME;\n\n\tif ((def_mount_opts & EXT4_DEFM_NOBARRIER) == 0)\n\t\tset_opt(sb, BARRIER);\n\n\t/*\n\t * enable delayed allocation by default\n\t * Use -o nodelalloc to turn it off\n\t */\n\tif (!IS_EXT3_SB(sb) && !IS_EXT2_SB(sb) &&\n\t    ((def_mount_opts & EXT4_DEFM_NODELALLOC) == 0))\n\t\tset_opt(sb, DELALLOC);\n\n\t/*\n\t * set default s_li_wait_mult for lazyinit, for the case there is\n\t * no mount option specified.\n\t */\n\tsbi->s_li_wait_mult = EXT4_DEF_LI_WAIT_MULT;\n\n\tif (!parse_options((char *) sbi->s_es->s_mount_opts, sb,\n\t\t\t   &journal_devnum, &journal_ioprio, 0)) {\n\t\text4_msg(sb, KERN_WARNING,\n\t\t\t \"failed to parse options in superblock: %s\",\n\t\t\t sbi->s_es->s_mount_opts);\n\t}\n\tsbi->s_def_mount_opt = sbi->s_mount_opt;\n\tif (!parse_options((char *) data, sb, &journal_devnum,\n\t\t\t   &journal_ioprio, 0))\n\t\tgoto failed_mount;\n\n\tif (test_opt(sb, DATA_FLAGS) == EXT4_MOUNT_JOURNAL_DATA) {\n\t\tprintk_once(KERN_WARNING \"EXT4-fs: Warning: mounting \"\n\t\t\t    \"with data=journal disables delayed \"\n\t\t\t    \"allocation and O_DIRECT support!\\n\");\n\t\tif (test_opt2(sb, EXPLICIT_DELALLOC)) {\n\t\t\text4_msg(sb, KERN_ERR, \"can't mount with \"\n\t\t\t\t \"both data=journal and delalloc\");\n\t\t\tgoto failed_mount;\n\t\t}\n\t\tif (test_opt(sb, DIOREAD_NOLOCK)) {\n\t\t\text4_msg(sb, KERN_ERR, \"can't mount with \"\n\t\t\t\t \"both data=journal and dioread_nolock\");\n\t\t\tgoto failed_mount;\n\t\t}\n\t\tif (test_opt(sb, DAX)) {\n\t\t\text4_msg(sb, KERN_ERR, \"can't mount with \"\n\t\t\t\t \"both data=journal and dax\");\n\t\t\tgoto failed_mount;\n\t\t}\n\t\tif (test_opt(sb, DELALLOC))\n\t\t\tclear_opt(sb, DELALLOC);\n\t}\n\n\tsb->s_flags = (sb->s_flags & ~MS_POSIXACL) |\n\t\t(test_opt(sb, POSIX_ACL) ? MS_POSIXACL : 0);\n\n\tif (le32_to_cpu(es->s_rev_level) == EXT4_GOOD_OLD_REV &&\n\t    (EXT4_HAS_COMPAT_FEATURE(sb, ~0U) ||\n\t     EXT4_HAS_RO_COMPAT_FEATURE(sb, ~0U) ||\n\t     EXT4_HAS_INCOMPAT_FEATURE(sb, ~0U)))\n\t\text4_msg(sb, KERN_WARNING,\n\t\t       \"feature flags set on rev 0 fs, \"\n\t\t       \"running e2fsck is recommended\");\n\n\tif (es->s_creator_os == cpu_to_le32(EXT4_OS_HURD)) {\n\t\tset_opt2(sb, HURD_COMPAT);\n\t\tif (EXT4_HAS_INCOMPAT_FEATURE(sb,\n\t\t\t\t\t      EXT4_FEATURE_INCOMPAT_64BIT)) {\n\t\t\text4_msg(sb, KERN_ERR,\n\t\t\t\t \"The Hurd can't support 64-bit file systems\");\n\t\t\tgoto failed_mount;\n\t\t}\n\t}\n\n\tif (IS_EXT2_SB(sb)) {\n\t\tif (ext2_feature_set_ok(sb))\n\t\t\text4_msg(sb, KERN_INFO, \"mounting ext2 file system \"\n\t\t\t\t \"using the ext4 subsystem\");\n\t\telse {\n\t\t\text4_msg(sb, KERN_ERR, \"couldn't mount as ext2 due \"\n\t\t\t\t \"to feature incompatibilities\");\n\t\t\tgoto failed_mount;\n\t\t}\n\t}\n\n\tif (IS_EXT3_SB(sb)) {\n\t\tif (ext3_feature_set_ok(sb))\n\t\t\text4_msg(sb, KERN_INFO, \"mounting ext3 file system \"\n\t\t\t\t \"using the ext4 subsystem\");\n\t\telse {\n\t\t\text4_msg(sb, KERN_ERR, \"couldn't mount as ext3 due \"\n\t\t\t\t \"to feature incompatibilities\");\n\t\t\tgoto failed_mount;\n\t\t}\n\t}\n\n\t/*\n\t * Check feature flags regardless of the revision level, since we\n\t * previously didn't change the revision level when setting the flags,\n\t * so there is a chance incompat flags are set on a rev 0 filesystem.\n\t */\n\tif (!ext4_feature_set_ok(sb, (sb->s_flags & MS_RDONLY)))\n\t\tgoto failed_mount;\n\n\tblocksize = BLOCK_SIZE << le32_to_cpu(es->s_log_block_size);\n\tif (blocksize < EXT4_MIN_BLOCK_SIZE ||\n\t    blocksize > EXT4_MAX_BLOCK_SIZE) {\n\t\text4_msg(sb, KERN_ERR,\n\t\t       \"Unsupported filesystem blocksize %d\", blocksize);\n\t\tgoto failed_mount;\n\t}\n\n\tif (sbi->s_mount_opt & EXT4_MOUNT_DAX) {\n\t\tif (blocksize != PAGE_SIZE) {\n\t\t\text4_msg(sb, KERN_ERR,\n\t\t\t\t\t\"error: unsupported blocksize for dax\");\n\t\t\tgoto failed_mount;\n\t\t}\n\t\tif (!sb->s_bdev->bd_disk->fops->direct_access) {\n\t\t\text4_msg(sb, KERN_ERR,\n\t\t\t\t\t\"error: device does not support dax\");\n\t\t\tgoto failed_mount;\n\t\t}\n\t}\n\n\tif (sb->s_blocksize != blocksize) {\n\t\t/* Validate the filesystem blocksize */\n\t\tif (!sb_set_blocksize(sb, blocksize)) {\n\t\t\text4_msg(sb, KERN_ERR, \"bad block size %d\",\n\t\t\t\t\tblocksize);\n\t\t\tgoto failed_mount;\n\t\t}\n\n\t\tbrelse(bh);\n\t\tlogical_sb_block = sb_block * EXT4_MIN_BLOCK_SIZE;\n\t\toffset = do_div(logical_sb_block, blocksize);\n\t\tbh = sb_bread_unmovable(sb, logical_sb_block);\n\t\tif (!bh) {\n\t\t\text4_msg(sb, KERN_ERR,\n\t\t\t       \"Can't read superblock on 2nd try\");\n\t\t\tgoto failed_mount;\n\t\t}\n\t\tes = (struct ext4_super_block *)(bh->b_data + offset);\n\t\tsbi->s_es = es;\n\t\tif (es->s_magic != cpu_to_le16(EXT4_SUPER_MAGIC)) {\n\t\t\text4_msg(sb, KERN_ERR,\n\t\t\t       \"Magic mismatch, very weird!\");\n\t\t\tgoto failed_mount;\n\t\t}\n\t}\n\n\thas_huge_files = EXT4_HAS_RO_COMPAT_FEATURE(sb,\n\t\t\t\tEXT4_FEATURE_RO_COMPAT_HUGE_FILE);\n\tsbi->s_bitmap_maxbytes = ext4_max_bitmap_size(sb->s_blocksize_bits,\n\t\t\t\t\t\t      has_huge_files);\n\tsb->s_maxbytes = ext4_max_size(sb->s_blocksize_bits, has_huge_files);\n\n\tif (le32_to_cpu(es->s_rev_level) == EXT4_GOOD_OLD_REV) {\n\t\tsbi->s_inode_size = EXT4_GOOD_OLD_INODE_SIZE;\n\t\tsbi->s_first_ino = EXT4_GOOD_OLD_FIRST_INO;\n\t} else {\n\t\tsbi->s_inode_size = le16_to_cpu(es->s_inode_size);\n\t\tsbi->s_first_ino = le32_to_cpu(es->s_first_ino);\n\t\tif ((sbi->s_inode_size < EXT4_GOOD_OLD_INODE_SIZE) ||\n\t\t    (!is_power_of_2(sbi->s_inode_size)) ||\n\t\t    (sbi->s_inode_size > blocksize)) {\n\t\t\text4_msg(sb, KERN_ERR,\n\t\t\t       \"unsupported inode size: %d\",\n\t\t\t       sbi->s_inode_size);\n\t\t\tgoto failed_mount;\n\t\t}\n\t\tif (sbi->s_inode_size > EXT4_GOOD_OLD_INODE_SIZE)\n\t\t\tsb->s_time_gran = 1 << (EXT4_EPOCH_BITS - 2);\n\t}\n\n\tsbi->s_desc_size = le16_to_cpu(es->s_desc_size);\n\tif (EXT4_HAS_INCOMPAT_FEATURE(sb, EXT4_FEATURE_INCOMPAT_64BIT)) {\n\t\tif (sbi->s_desc_size < EXT4_MIN_DESC_SIZE_64BIT ||\n\t\t    sbi->s_desc_size > EXT4_MAX_DESC_SIZE ||\n\t\t    !is_power_of_2(sbi->s_desc_size)) {\n\t\t\text4_msg(sb, KERN_ERR,\n\t\t\t       \"unsupported descriptor size %lu\",\n\t\t\t       sbi->s_desc_size);\n\t\t\tgoto failed_mount;\n\t\t}\n\t} else\n\t\tsbi->s_desc_size = EXT4_MIN_DESC_SIZE;\n\n\tsbi->s_blocks_per_group = le32_to_cpu(es->s_blocks_per_group);\n\tsbi->s_inodes_per_group = le32_to_cpu(es->s_inodes_per_group);\n\tif (EXT4_INODE_SIZE(sb) == 0 || EXT4_INODES_PER_GROUP(sb) == 0)\n\t\tgoto cantfind_ext4;\n\n\tsbi->s_inodes_per_block = blocksize / EXT4_INODE_SIZE(sb);\n\tif (sbi->s_inodes_per_block == 0)\n\t\tgoto cantfind_ext4;\n\tsbi->s_itb_per_group = sbi->s_inodes_per_group /\n\t\t\t\t\tsbi->s_inodes_per_block;\n\tsbi->s_desc_per_block = blocksize / EXT4_DESC_SIZE(sb);\n\tsbi->s_sbh = bh;\n\tsbi->s_mount_state = le16_to_cpu(es->s_state);\n\tsbi->s_addr_per_block_bits = ilog2(EXT4_ADDR_PER_BLOCK(sb));\n\tsbi->s_desc_per_block_bits = ilog2(EXT4_DESC_PER_BLOCK(sb));\n\n\tfor (i = 0; i < 4; i++)\n\t\tsbi->s_hash_seed[i] = le32_to_cpu(es->s_hash_seed[i]);\n\tsbi->s_def_hash_version = es->s_def_hash_version;\n\tif (EXT4_HAS_COMPAT_FEATURE(sb, EXT4_FEATURE_COMPAT_DIR_INDEX)) {\n\t\ti = le32_to_cpu(es->s_flags);\n\t\tif (i & EXT2_FLAGS_UNSIGNED_HASH)\n\t\t\tsbi->s_hash_unsigned = 3;\n\t\telse if ((i & EXT2_FLAGS_SIGNED_HASH) == 0) {\n#ifdef __CHAR_UNSIGNED__\n\t\t\tif (!(sb->s_flags & MS_RDONLY))\n\t\t\t\tes->s_flags |=\n\t\t\t\t\tcpu_to_le32(EXT2_FLAGS_UNSIGNED_HASH);\n\t\t\tsbi->s_hash_unsigned = 3;\n#else\n\t\t\tif (!(sb->s_flags & MS_RDONLY))\n\t\t\t\tes->s_flags |=\n\t\t\t\t\tcpu_to_le32(EXT2_FLAGS_SIGNED_HASH);\n#endif\n\t\t}\n\t}\n\n\t/* Handle clustersize */\n\tclustersize = BLOCK_SIZE << le32_to_cpu(es->s_log_cluster_size);\n\thas_bigalloc = EXT4_HAS_RO_COMPAT_FEATURE(sb,\n\t\t\t\tEXT4_FEATURE_RO_COMPAT_BIGALLOC);\n\tif (has_bigalloc) {\n\t\tif (clustersize < blocksize) {\n\t\t\text4_msg(sb, KERN_ERR,\n\t\t\t\t \"cluster size (%d) smaller than \"\n\t\t\t\t \"block size (%d)\", clustersize, blocksize);\n\t\t\tgoto failed_mount;\n\t\t}\n\t\tsbi->s_cluster_bits = le32_to_cpu(es->s_log_cluster_size) -\n\t\t\tle32_to_cpu(es->s_log_block_size);\n\t\tsbi->s_clusters_per_group =\n\t\t\tle32_to_cpu(es->s_clusters_per_group);\n\t\tif (sbi->s_clusters_per_group > blocksize * 8) {\n\t\t\text4_msg(sb, KERN_ERR,\n\t\t\t\t \"#clusters per group too big: %lu\",\n\t\t\t\t sbi->s_clusters_per_group);\n\t\t\tgoto failed_mount;\n\t\t}\n\t\tif (sbi->s_blocks_per_group !=\n\t\t    (sbi->s_clusters_per_group * (clustersize / blocksize))) {\n\t\t\text4_msg(sb, KERN_ERR, \"blocks per group (%lu) and \"\n\t\t\t\t \"clusters per group (%lu) inconsistent\",\n\t\t\t\t sbi->s_blocks_per_group,\n\t\t\t\t sbi->s_clusters_per_group);\n\t\t\tgoto failed_mount;\n\t\t}\n\t} else {\n\t\tif (clustersize != blocksize) {\n\t\t\text4_warning(sb, \"fragment/cluster size (%d) != \"\n\t\t\t\t     \"block size (%d)\", clustersize,\n\t\t\t\t     blocksize);\n\t\t\tclustersize = blocksize;\n\t\t}\n\t\tif (sbi->s_blocks_per_group > blocksize * 8) {\n\t\t\text4_msg(sb, KERN_ERR,\n\t\t\t\t \"#blocks per group too big: %lu\",\n\t\t\t\t sbi->s_blocks_per_group);\n\t\t\tgoto failed_mount;\n\t\t}\n\t\tsbi->s_clusters_per_group = sbi->s_blocks_per_group;\n\t\tsbi->s_cluster_bits = 0;\n\t}\n\tsbi->s_cluster_ratio = clustersize / blocksize;\n\n\tif (sbi->s_inodes_per_group > blocksize * 8) {\n\t\text4_msg(sb, KERN_ERR,\n\t\t       \"#inodes per group too big: %lu\",\n\t\t       sbi->s_inodes_per_group);\n\t\tgoto failed_mount;\n\t}\n\n\t/* Do we have standard group size of clustersize * 8 blocks ? */\n\tif (sbi->s_blocks_per_group == clustersize << 3)\n\t\tset_opt2(sb, STD_GROUP_SIZE);\n\n\t/*\n\t * Test whether we have more sectors than will fit in sector_t,\n\t * and whether the max offset is addressable by the page cache.\n\t */\n\terr = generic_check_addressable(sb->s_blocksize_bits,\n\t\t\t\t\text4_blocks_count(es));\n\tif (err) {\n\t\text4_msg(sb, KERN_ERR, \"filesystem\"\n\t\t\t \" too large to mount safely on this system\");\n\t\tif (sizeof(sector_t) < 8)\n\t\t\text4_msg(sb, KERN_WARNING, \"CONFIG_LBDAF not enabled\");\n\t\tgoto failed_mount;\n\t}\n\n\tif (EXT4_BLOCKS_PER_GROUP(sb) == 0)\n\t\tgoto cantfind_ext4;\n\n\t/* check blocks count against device size */\n\tblocks_count = sb->s_bdev->bd_inode->i_size >> sb->s_blocksize_bits;\n\tif (blocks_count && ext4_blocks_count(es) > blocks_count) {\n\t\text4_msg(sb, KERN_WARNING, \"bad geometry: block count %llu \"\n\t\t       \"exceeds size of device (%llu blocks)\",\n\t\t       ext4_blocks_count(es), blocks_count);\n\t\tgoto failed_mount;\n\t}\n\n\t/*\n\t * It makes no sense for the first data block to be beyond the end\n\t * of the filesystem.\n\t */\n\tif (le32_to_cpu(es->s_first_data_block) >= ext4_blocks_count(es)) {\n\t\text4_msg(sb, KERN_WARNING, \"bad geometry: first data \"\n\t\t\t \"block %u is beyond end of filesystem (%llu)\",\n\t\t\t le32_to_cpu(es->s_first_data_block),\n\t\t\t ext4_blocks_count(es));\n\t\tgoto failed_mount;\n\t}\n\tblocks_count = (ext4_blocks_count(es) -\n\t\t\tle32_to_cpu(es->s_first_data_block) +\n\t\t\tEXT4_BLOCKS_PER_GROUP(sb) - 1);\n\tdo_div(blocks_count, EXT4_BLOCKS_PER_GROUP(sb));\n\tif (blocks_count > ((uint64_t)1<<32) - EXT4_DESC_PER_BLOCK(sb)) {\n\t\text4_msg(sb, KERN_WARNING, \"groups count too large: %u \"\n\t\t       \"(block count %llu, first data block %u, \"\n\t\t       \"blocks per group %lu)\", sbi->s_groups_count,\n\t\t       ext4_blocks_count(es),\n\t\t       le32_to_cpu(es->s_first_data_block),\n\t\t       EXT4_BLOCKS_PER_GROUP(sb));\n\t\tgoto failed_mount;\n\t}\n\tsbi->s_groups_count = blocks_count;\n\tsbi->s_blockfile_groups = min_t(ext4_group_t, sbi->s_groups_count,\n\t\t\t(EXT4_MAX_BLOCK_FILE_PHYS / EXT4_BLOCKS_PER_GROUP(sb)));\n\tdb_count = (sbi->s_groups_count + EXT4_DESC_PER_BLOCK(sb) - 1) /\n\t\t   EXT4_DESC_PER_BLOCK(sb);\n\tsbi->s_group_desc = ext4_kvmalloc(db_count *\n\t\t\t\t\t  sizeof(struct buffer_head *),\n\t\t\t\t\t  GFP_KERNEL);\n\tif (sbi->s_group_desc == NULL) {\n\t\text4_msg(sb, KERN_ERR, \"not enough memory\");\n\t\tret = -ENOMEM;\n\t\tgoto failed_mount;\n\t}\n\n\tif (ext4_proc_root)\n\t\tsbi->s_proc = proc_mkdir(sb->s_id, ext4_proc_root);\n\n\tif (sbi->s_proc)\n\t\tproc_create_data(\"options\", S_IRUGO, sbi->s_proc,\n\t\t\t\t &ext4_seq_options_fops, sb);\n\n\tbgl_lock_init(sbi->s_blockgroup_lock);\n\n\tfor (i = 0; i < db_count; i++) {\n\t\tblock = descriptor_loc(sb, logical_sb_block, i);\n\t\tsbi->s_group_desc[i] = sb_bread_unmovable(sb, block);\n\t\tif (!sbi->s_group_desc[i]) {\n\t\t\text4_msg(sb, KERN_ERR,\n\t\t\t       \"can't read group descriptor %d\", i);\n\t\t\tdb_count = i;\n\t\t\tgoto failed_mount2;\n\t\t}\n\t}\n\tif (!ext4_check_descriptors(sb, &first_not_zeroed)) {\n\t\text4_msg(sb, KERN_ERR, \"group descriptors corrupted!\");\n\t\tgoto failed_mount2;\n\t}\n\n\tsbi->s_gdb_count = db_count;\n\tget_random_bytes(&sbi->s_next_generation, sizeof(u32));\n\tspin_lock_init(&sbi->s_next_gen_lock);\n\n\tsetup_timer(&sbi->s_err_report, print_daily_error_info,\n\t\t(unsigned long) sb);\n\n\t/* Register extent status tree shrinker */\n\tif (ext4_es_register_shrinker(sbi))\n\t\tgoto failed_mount3;\n\n\tsbi->s_stripe = ext4_get_stripe_size(sbi);\n\tsbi->s_extent_max_zeroout_kb = 32;\n\n\t/*\n\t * set up enough so that it can read an inode\n\t */\n\tsb->s_op = &ext4_sops;\n\tsb->s_export_op = &ext4_export_ops;\n\tsb->s_xattr = ext4_xattr_handlers;\n#ifdef CONFIG_QUOTA\n\tsb->dq_op = &ext4_quota_operations;\n\tif (EXT4_HAS_RO_COMPAT_FEATURE(sb, EXT4_FEATURE_RO_COMPAT_QUOTA))\n\t\tsb->s_qcop = &dquot_quotactl_sysfile_ops;\n\telse\n\t\tsb->s_qcop = &ext4_qctl_operations;\n\tsb->s_quota_types = QTYPE_MASK_USR | QTYPE_MASK_GRP;\n#endif\n\tmemcpy(sb->s_uuid, es->s_uuid, sizeof(es->s_uuid));\n\n\tINIT_LIST_HEAD(&sbi->s_orphan); /* unlinked but open files */\n\tmutex_init(&sbi->s_orphan_lock);\n\n\tsb->s_root = NULL;\n\n\tneeds_recovery = (es->s_last_orphan != 0 ||\n\t\t\t  EXT4_HAS_INCOMPAT_FEATURE(sb,\n\t\t\t\t    EXT4_FEATURE_INCOMPAT_RECOVER));\n\n\tif (EXT4_HAS_INCOMPAT_FEATURE(sb, EXT4_FEATURE_INCOMPAT_MMP) &&\n\t    !(sb->s_flags & MS_RDONLY))\n\t\tif (ext4_multi_mount_protect(sb, le64_to_cpu(es->s_mmp_block)))\n\t\t\tgoto failed_mount3a;\n\n\t/*\n\t * The first inode we look at is the journal inode.  Don't try\n\t * root first: it may be modified in the journal!\n\t */\n\tif (!test_opt(sb, NOLOAD) &&\n\t    EXT4_HAS_COMPAT_FEATURE(sb, EXT4_FEATURE_COMPAT_HAS_JOURNAL)) {\n\t\tif (ext4_load_journal(sb, es, journal_devnum))\n\t\t\tgoto failed_mount3a;\n\t} else if (test_opt(sb, NOLOAD) && !(sb->s_flags & MS_RDONLY) &&\n\t      EXT4_HAS_INCOMPAT_FEATURE(sb, EXT4_FEATURE_INCOMPAT_RECOVER)) {\n\t\text4_msg(sb, KERN_ERR, \"required journal recovery \"\n\t\t       \"suppressed and not mounted read-only\");\n\t\tgoto failed_mount_wq;\n\t} else {\n\t\tclear_opt(sb, DATA_FLAGS);\n\t\tsbi->s_journal = NULL;\n\t\tneeds_recovery = 0;\n\t\tgoto no_journal;\n\t}\n\n\tif (EXT4_HAS_INCOMPAT_FEATURE(sb, EXT4_FEATURE_INCOMPAT_64BIT) &&\n\t    !jbd2_journal_set_features(EXT4_SB(sb)->s_journal, 0, 0,\n\t\t\t\t       JBD2_FEATURE_INCOMPAT_64BIT)) {\n\t\text4_msg(sb, KERN_ERR, \"Failed to set 64-bit journal feature\");\n\t\tgoto failed_mount_wq;\n\t}\n\n\tif (!set_journal_csum_feature_set(sb)) {\n\t\text4_msg(sb, KERN_ERR, \"Failed to set journal checksum \"\n\t\t\t \"feature set\");\n\t\tgoto failed_mount_wq;\n\t}\n\n\t/* We have now updated the journal if required, so we can\n\t * validate the data journaling mode. */\n\tswitch (test_opt(sb, DATA_FLAGS)) {\n\tcase 0:\n\t\t/* No mode set, assume a default based on the journal\n\t\t * capabilities: ORDERED_DATA if the journal can\n\t\t * cope, else JOURNAL_DATA\n\t\t */\n\t\tif (jbd2_journal_check_available_features\n\t\t    (sbi->s_journal, 0, 0, JBD2_FEATURE_INCOMPAT_REVOKE))\n\t\t\tset_opt(sb, ORDERED_DATA);\n\t\telse\n\t\t\tset_opt(sb, JOURNAL_DATA);\n\t\tbreak;\n\n\tcase EXT4_MOUNT_ORDERED_DATA:\n\tcase EXT4_MOUNT_WRITEBACK_DATA:\n\t\tif (!jbd2_journal_check_available_features\n\t\t    (sbi->s_journal, 0, 0, JBD2_FEATURE_INCOMPAT_REVOKE)) {\n\t\t\text4_msg(sb, KERN_ERR, \"Journal does not support \"\n\t\t\t       \"requested data journaling mode\");\n\t\t\tgoto failed_mount_wq;\n\t\t}\n\tdefault:\n\t\tbreak;\n\t}\n\tset_task_ioprio(sbi->s_journal->j_task, journal_ioprio);\n\n\tsbi->s_journal->j_commit_callback = ext4_journal_commit_callback;\n\nno_journal:\n\tif (ext4_mballoc_ready) {\n\t\tsbi->s_mb_cache = ext4_xattr_create_cache(sb->s_id);\n\t\tif (!sbi->s_mb_cache) {\n\t\t\text4_msg(sb, KERN_ERR, \"Failed to create an mb_cache\");\n\t\t\tgoto failed_mount_wq;\n\t\t}\n\t}\n\n\t/*\n\t * Get the # of file system overhead blocks from the\n\t * superblock if present.\n\t */\n\tif (es->s_overhead_clusters)\n\t\tsbi->s_overhead = le32_to_cpu(es->s_overhead_clusters);\n\telse {\n\t\terr = ext4_calculate_overhead(sb);\n\t\tif (err)\n\t\t\tgoto failed_mount_wq;\n\t}\n\n\t/*\n\t * The maximum number of concurrent works can be high and\n\t * concurrency isn't really necessary.  Limit it to 1.\n\t */\n\tEXT4_SB(sb)->rsv_conversion_wq =\n\t\talloc_workqueue(\"ext4-rsv-conversion\", WQ_MEM_RECLAIM | WQ_UNBOUND, 1);\n\tif (!EXT4_SB(sb)->rsv_conversion_wq) {\n\t\tprintk(KERN_ERR \"EXT4-fs: failed to create workqueue\\n\");\n\t\tret = -ENOMEM;\n\t\tgoto failed_mount4;\n\t}\n\n\t/*\n\t * The jbd2_journal_load will have done any necessary log recovery,\n\t * so we can safely mount the rest of the filesystem now.\n\t */\n\n\troot = ext4_iget(sb, EXT4_ROOT_INO);\n\tif (IS_ERR(root)) {\n\t\text4_msg(sb, KERN_ERR, \"get root inode failed\");\n\t\tret = PTR_ERR(root);\n\t\troot = NULL;\n\t\tgoto failed_mount4;\n\t}\n\tif (!S_ISDIR(root->i_mode) || !root->i_blocks || !root->i_size) {\n\t\text4_msg(sb, KERN_ERR, \"corrupt root inode, run e2fsck\");\n\t\tiput(root);\n\t\tgoto failed_mount4;\n\t}\n\tsb->s_root = d_make_root(root);\n\tif (!sb->s_root) {\n\t\text4_msg(sb, KERN_ERR, \"get root dentry failed\");\n\t\tret = -ENOMEM;\n\t\tgoto failed_mount4;\n\t}\n\n\tif (ext4_setup_super(sb, es, sb->s_flags & MS_RDONLY))\n\t\tsb->s_flags |= MS_RDONLY;\n\n\t/* determine the minimum size of new large inodes, if present */\n\tif (sbi->s_inode_size > EXT4_GOOD_OLD_INODE_SIZE) {\n\t\tsbi->s_want_extra_isize = sizeof(struct ext4_inode) -\n\t\t\t\t\t\t     EXT4_GOOD_OLD_INODE_SIZE;\n\t\tif (EXT4_HAS_RO_COMPAT_FEATURE(sb,\n\t\t\t\t       EXT4_FEATURE_RO_COMPAT_EXTRA_ISIZE)) {\n\t\t\tif (sbi->s_want_extra_isize <\n\t\t\t    le16_to_cpu(es->s_want_extra_isize))\n\t\t\t\tsbi->s_want_extra_isize =\n\t\t\t\t\tle16_to_cpu(es->s_want_extra_isize);\n\t\t\tif (sbi->s_want_extra_isize <\n\t\t\t    le16_to_cpu(es->s_min_extra_isize))\n\t\t\t\tsbi->s_want_extra_isize =\n\t\t\t\t\tle16_to_cpu(es->s_min_extra_isize);\n\t\t}\n\t}\n\t/* Check if enough inode space is available */\n\tif (EXT4_GOOD_OLD_INODE_SIZE + sbi->s_want_extra_isize >\n\t\t\t\t\t\t\tsbi->s_inode_size) {\n\t\tsbi->s_want_extra_isize = sizeof(struct ext4_inode) -\n\t\t\t\t\t\t       EXT4_GOOD_OLD_INODE_SIZE;\n\t\text4_msg(sb, KERN_INFO, \"required extra inode space not\"\n\t\t\t \"available\");\n\t}\n\n\terr = ext4_reserve_clusters(sbi, ext4_calculate_resv_clusters(sb));\n\tif (err) {\n\t\text4_msg(sb, KERN_ERR, \"failed to reserve %llu clusters for \"\n\t\t\t \"reserved pool\", ext4_calculate_resv_clusters(sb));\n\t\tgoto failed_mount4a;\n\t}\n\n\terr = ext4_setup_system_zone(sb);\n\tif (err) {\n\t\text4_msg(sb, KERN_ERR, \"failed to initialize system \"\n\t\t\t \"zone (%d)\", err);\n\t\tgoto failed_mount4a;\n\t}\n\n\text4_ext_init(sb);\n\terr = ext4_mb_init(sb);\n\tif (err) {\n\t\text4_msg(sb, KERN_ERR, \"failed to initialize mballoc (%d)\",\n\t\t\t err);\n\t\tgoto failed_mount5;\n\t}\n\n\tblock = ext4_count_free_clusters(sb);\n\text4_free_blocks_count_set(sbi->s_es, \n\t\t\t\t   EXT4_C2B(sbi, block));\n\terr = percpu_counter_init(&sbi->s_freeclusters_counter, block,\n\t\t\t\t  GFP_KERNEL);\n\tif (!err) {\n\t\tunsigned long freei = ext4_count_free_inodes(sb);\n\t\tsbi->s_es->s_free_inodes_count = cpu_to_le32(freei);\n\t\terr = percpu_counter_init(&sbi->s_freeinodes_counter, freei,\n\t\t\t\t\t  GFP_KERNEL);\n\t}\n\tif (!err)\n\t\terr = percpu_counter_init(&sbi->s_dirs_counter,\n\t\t\t\t\t  ext4_count_dirs(sb), GFP_KERNEL);\n\tif (!err)\n\t\terr = percpu_counter_init(&sbi->s_dirtyclusters_counter, 0,\n\t\t\t\t\t  GFP_KERNEL);\n\tif (err) {\n\t\text4_msg(sb, KERN_ERR, \"insufficient memory\");\n\t\tgoto failed_mount6;\n\t}\n\n\tif (EXT4_HAS_INCOMPAT_FEATURE(sb, EXT4_FEATURE_INCOMPAT_FLEX_BG))\n\t\tif (!ext4_fill_flex_info(sb)) {\n\t\t\text4_msg(sb, KERN_ERR,\n\t\t\t       \"unable to initialize \"\n\t\t\t       \"flex_bg meta info!\");\n\t\t\tgoto failed_mount6;\n\t\t}\n\n\terr = ext4_register_li_request(sb, first_not_zeroed);\n\tif (err)\n\t\tgoto failed_mount6;\n\n\tsbi->s_kobj.kset = ext4_kset;\n\tinit_completion(&sbi->s_kobj_unregister);\n\terr = kobject_init_and_add(&sbi->s_kobj, &ext4_ktype, NULL,\n\t\t\t\t   \"%s\", sb->s_id);\n\tif (err)\n\t\tgoto failed_mount7;\n\n#ifdef CONFIG_QUOTA\n\t/* Enable quota usage during mount. */\n\tif (EXT4_HAS_RO_COMPAT_FEATURE(sb, EXT4_FEATURE_RO_COMPAT_QUOTA) &&\n\t    !(sb->s_flags & MS_RDONLY)) {\n\t\terr = ext4_enable_quotas(sb);\n\t\tif (err)\n\t\t\tgoto failed_mount8;\n\t}\n#endif  /* CONFIG_QUOTA */\n\n\tEXT4_SB(sb)->s_mount_state |= EXT4_ORPHAN_FS;\n\text4_orphan_cleanup(sb, es);\n\tEXT4_SB(sb)->s_mount_state &= ~EXT4_ORPHAN_FS;\n\tif (needs_recovery) {\n\t\text4_msg(sb, KERN_INFO, \"recovery complete\");\n\t\text4_mark_recovery_complete(sb, es);\n\t}\n\tif (EXT4_SB(sb)->s_journal) {\n\t\tif (test_opt(sb, DATA_FLAGS) == EXT4_MOUNT_JOURNAL_DATA)\n\t\t\tdescr = \" journalled data mode\";\n\t\telse if (test_opt(sb, DATA_FLAGS) == EXT4_MOUNT_ORDERED_DATA)\n\t\t\tdescr = \" ordered data mode\";\n\t\telse\n\t\t\tdescr = \" writeback data mode\";\n\t} else\n\t\tdescr = \"out journal\";\n\n\tif (test_opt(sb, DISCARD)) {\n\t\tstruct request_queue *q = bdev_get_queue(sb->s_bdev);\n\t\tif (!blk_queue_discard(q))\n\t\t\text4_msg(sb, KERN_WARNING,\n\t\t\t\t \"mounting with \\\"discard\\\" option, but \"\n\t\t\t\t \"the device does not support discard\");\n\t}\n\n\text4_msg(sb, KERN_INFO, \"mounted filesystem with%s. \"\n\t\t \"Opts: %s%s%s\", descr, sbi->s_es->s_mount_opts,\n\t\t *sbi->s_es->s_mount_opts ? \"; \" : \"\", orig_data);\n\n\tif (es->s_error_count)\n\t\tmod_timer(&sbi->s_err_report, jiffies + 300*HZ); /* 5 minutes */\n\n\t/* Enable message ratelimiting. Default is 10 messages per 5 secs. */\n\tratelimit_state_init(&sbi->s_err_ratelimit_state, 5 * HZ, 10);\n\tratelimit_state_init(&sbi->s_warning_ratelimit_state, 5 * HZ, 10);\n\tratelimit_state_init(&sbi->s_msg_ratelimit_state, 5 * HZ, 10);\n\n\tkfree(orig_data);\n\treturn 0;\n\ncantfind_ext4:\n\tif (!silent)\n\t\text4_msg(sb, KERN_ERR, \"VFS: Can't find ext4 filesystem\");\n\tgoto failed_mount;\n\n#ifdef CONFIG_QUOTA\nfailed_mount8:\n\tkobject_del(&sbi->s_kobj);\n#endif\nfailed_mount7:\n\text4_unregister_li_request(sb);\nfailed_mount6:\n\text4_mb_release(sb);\n\tif (sbi->s_flex_groups)\n\t\tkvfree(sbi->s_flex_groups);\n\tpercpu_counter_destroy(&sbi->s_freeclusters_counter);\n\tpercpu_counter_destroy(&sbi->s_freeinodes_counter);\n\tpercpu_counter_destroy(&sbi->s_dirs_counter);\n\tpercpu_counter_destroy(&sbi->s_dirtyclusters_counter);\nfailed_mount5:\n\text4_ext_release(sb);\n\text4_release_system_zone(sb);\nfailed_mount4a:\n\tdput(sb->s_root);\n\tsb->s_root = NULL;\nfailed_mount4:\n\text4_msg(sb, KERN_ERR, \"mount failed\");\n\tif (EXT4_SB(sb)->rsv_conversion_wq)\n\t\tdestroy_workqueue(EXT4_SB(sb)->rsv_conversion_wq);\nfailed_mount_wq:\n\tif (sbi->s_journal) {\n\t\tjbd2_journal_destroy(sbi->s_journal);\n\t\tsbi->s_journal = NULL;\n\t}\nfailed_mount3a:\n\text4_es_unregister_shrinker(sbi);\nfailed_mount3:\n\tdel_timer_sync(&sbi->s_err_report);\n\tif (sbi->s_mmp_tsk)\n\t\tkthread_stop(sbi->s_mmp_tsk);\nfailed_mount2:\n\tfor (i = 0; i < db_count; i++)\n\t\tbrelse(sbi->s_group_desc[i]);\n\tkvfree(sbi->s_group_desc);\nfailed_mount:\n\tif (sbi->s_chksum_driver)\n\t\tcrypto_free_shash(sbi->s_chksum_driver);\n\tif (sbi->s_proc) {\n\t\tremove_proc_entry(\"options\", sbi->s_proc);\n\t\tremove_proc_entry(sb->s_id, ext4_proc_root);\n\t}\n#ifdef CONFIG_QUOTA\n\tfor (i = 0; i < EXT4_MAXQUOTAS; i++)\n\t\tkfree(sbi->s_qf_names[i]);\n#endif\n\text4_blkdev_remove(sbi);\n\tbrelse(bh);\nout_fail:\n\tsb->s_fs_info = NULL;\n\tkfree(sbi->s_blockgroup_lock);\n\tkfree(sbi);\nout_free_orig:\n\tkfree(orig_data);\n\treturn err ? err : ret;\n}"
  },
  {
    "function_name": "ext4_reserve_clusters",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/super.c",
    "lines": "3397-3407",
    "snippet": "static int ext4_reserve_clusters(struct ext4_sb_info *sbi, ext4_fsblk_t count)\n{\n\text4_fsblk_t clusters = ext4_blocks_count(sbi->s_es) >>\n\t\t\t\tsbi->s_cluster_bits;\n\n\tif (count >= clusters)\n\t\treturn -EINVAL;\n\n\tatomic64_set(&sbi->s_resv_clusters, count);\n\treturn 0;\n}",
    "includes": [
      "#include <trace/events/ext4.h>",
      "#include \"mballoc.h\"",
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"ext4_jbd2.h\"",
      "#include \"ext4_extents.h\"\t/* Needed for trace points definition */",
      "#include \"ext4.h\"",
      "#include <linux/freezer.h>",
      "#include <linux/kthread.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/cleancache.h>",
      "#include <linux/crc16.h>",
      "#include <linux/log2.h>",
      "#include <linux/ctype.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/namei.h>",
      "#include <linux/mount.h>",
      "#include <linux/random.h>",
      "#include <linux/vfs.h>",
      "#include <linux/exportfs.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/parser.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/init.h>",
      "#include <linux/slab.h>",
      "#include <linux/jbd2.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/time.h>",
      "#include <linux/fs.h>",
      "#include <linux/string.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ext4_reserve_clusters(struct ext4_sb_info *, ext4_fsblk_t);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "atomic64_set",
          "args": [
            "&sbi->s_resv_clusters",
            "count"
          ],
          "line": 3405
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_blocks_count",
          "args": [
            "sbi->s_es"
          ],
          "line": 3399
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"mballoc.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4_extents.h\"\t/* Needed for trace points definition */\n#include \"ext4.h\"\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <asm/uaccess.h>\n#include <linux/cleancache.h>\n#include <linux/crc16.h>\n#include <linux/log2.h>\n#include <linux/ctype.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/random.h>\n#include <linux/vfs.h>\n#include <linux/exportfs.h>\n#include <linux/buffer_head.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/jbd2.h>\n#include <linux/vmalloc.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n#include <linux/string.h>\n#include <linux/module.h>\n\nstatic int ext4_reserve_clusters(struct ext4_sb_info *, ext4_fsblk_t);\n\nstatic int ext4_reserve_clusters(struct ext4_sb_info *sbi, ext4_fsblk_t count)\n{\n\text4_fsblk_t clusters = ext4_blocks_count(sbi->s_es) >>\n\t\t\t\tsbi->s_cluster_bits;\n\n\tif (count >= clusters)\n\t\treturn -EINVAL;\n\n\tatomic64_set(&sbi->s_resv_clusters, count);\n\treturn 0;\n}"
  },
  {
    "function_name": "ext4_calculate_resv_clusters",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/super.c",
    "lines": "3367-3394",
    "snippet": "static ext4_fsblk_t ext4_calculate_resv_clusters(struct super_block *sb)\n{\n\text4_fsblk_t resv_clusters;\n\n\t/*\n\t * There's no need to reserve anything when we aren't using extents.\n\t * The space estimates are exact, there are no unwritten extents,\n\t * hole punching doesn't need new metadata... This is needed especially\n\t * to keep ext2/3 backward compatibility.\n\t */\n\tif (!EXT4_HAS_INCOMPAT_FEATURE(sb, EXT4_FEATURE_INCOMPAT_EXTENTS))\n\t\treturn 0;\n\t/*\n\t * By default we reserve 2% or 4096 clusters, whichever is smaller.\n\t * This should cover the situations where we can not afford to run\n\t * out of space like for example punch hole, or converting\n\t * unwritten extents in delalloc path. In most cases such\n\t * allocation would require 1, or 2 blocks, higher numbers are\n\t * very rare.\n\t */\n\tresv_clusters = ext4_blocks_count(EXT4_SB(sb)->s_es) >>\n\t\t\tEXT4_SB(sb)->s_cluster_bits;\n\n\tdo_div(resv_clusters, 50);\n\tresv_clusters = min_t(ext4_fsblk_t, resv_clusters, 4096);\n\n\treturn resv_clusters;\n}",
    "includes": [
      "#include <trace/events/ext4.h>",
      "#include \"mballoc.h\"",
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"ext4_jbd2.h\"",
      "#include \"ext4_extents.h\"\t/* Needed for trace points definition */",
      "#include \"ext4.h\"",
      "#include <linux/freezer.h>",
      "#include <linux/kthread.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/cleancache.h>",
      "#include <linux/crc16.h>",
      "#include <linux/log2.h>",
      "#include <linux/ctype.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/namei.h>",
      "#include <linux/mount.h>",
      "#include <linux/random.h>",
      "#include <linux/vfs.h>",
      "#include <linux/exportfs.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/parser.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/init.h>",
      "#include <linux/slab.h>",
      "#include <linux/jbd2.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/time.h>",
      "#include <linux/fs.h>",
      "#include <linux/string.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ext4_unfreeze(struct super_block *sb);",
      "static int ext4_freeze(struct super_block *sb);",
      "static inline int ext2_feature_set_ok(struct super_block *sb);",
      "static inline int ext3_feature_set_ok(struct super_block *sb);",
      "static void ext4_unregister_li_request(struct super_block *sb);",
      "static int ext4_reserve_clusters(struct ext4_sb_info *, ext4_fsblk_t);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "min_t",
          "args": [
            "ext4_fsblk_t",
            "resv_clusters",
            "4096"
          ],
          "line": 3391
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "do_div",
          "args": [
            "resv_clusters",
            "50"
          ],
          "line": 3390
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXT4_SB",
          "args": [
            "sb"
          ],
          "line": 3388
        },
        "resolved": true,
        "details": {
          "function_name": "EXT4_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ext4.h",
          "lines": "1356-1359",
          "snippet": "static inline struct ext4_sb_info *EXT4_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include \"extents_status.h\"",
            "#include <linux/compat.h>",
            "#include <linux/falloc.h>",
            "#include <crypto/hash.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/wait.h>",
            "#include <linux/timer.h>",
            "#include <linux/mutex.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/quota.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extents_status.h\"\n#include <linux/compat.h>\n#include <linux/falloc.h>\n#include <crypto/hash.h>\n#include <linux/ratelimit.h>\n#include <linux/percpu_counter.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/wait.h>\n#include <linux/timer.h>\n#include <linux/mutex.h>\n#include <linux/seqlock.h>\n#include <linux/rbtree.h>\n#include <linux/rwsem.h>\n#include <linux/quota.h>\n#include <linux/jbd2.h>\n#include <linux/magic.h>\n#include <linux/blkdev.h>\n#include <linux/types.h>\n\nstatic inline struct ext4_sb_info *EXT4_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_blocks_count",
          "args": [
            "EXT4_SB(sb)->s_es"
          ],
          "line": 3387
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXT4_HAS_INCOMPAT_FEATURE",
          "args": [
            "sb",
            "EXT4_FEATURE_INCOMPAT_EXTENTS"
          ],
          "line": 3377
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"mballoc.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4_extents.h\"\t/* Needed for trace points definition */\n#include \"ext4.h\"\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <asm/uaccess.h>\n#include <linux/cleancache.h>\n#include <linux/crc16.h>\n#include <linux/log2.h>\n#include <linux/ctype.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/random.h>\n#include <linux/vfs.h>\n#include <linux/exportfs.h>\n#include <linux/buffer_head.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/jbd2.h>\n#include <linux/vmalloc.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n#include <linux/string.h>\n#include <linux/module.h>\n\nstatic int ext4_unfreeze(struct super_block *sb);\nstatic int ext4_freeze(struct super_block *sb);\nstatic inline int ext2_feature_set_ok(struct super_block *sb);\nstatic inline int ext3_feature_set_ok(struct super_block *sb);\nstatic void ext4_unregister_li_request(struct super_block *sb);\nstatic int ext4_reserve_clusters(struct ext4_sb_info *, ext4_fsblk_t);\n\nstatic ext4_fsblk_t ext4_calculate_resv_clusters(struct super_block *sb)\n{\n\text4_fsblk_t resv_clusters;\n\n\t/*\n\t * There's no need to reserve anything when we aren't using extents.\n\t * The space estimates are exact, there are no unwritten extents,\n\t * hole punching doesn't need new metadata... This is needed especially\n\t * to keep ext2/3 backward compatibility.\n\t */\n\tif (!EXT4_HAS_INCOMPAT_FEATURE(sb, EXT4_FEATURE_INCOMPAT_EXTENTS))\n\t\treturn 0;\n\t/*\n\t * By default we reserve 2% or 4096 clusters, whichever is smaller.\n\t * This should cover the situations where we can not afford to run\n\t * out of space like for example punch hole, or converting\n\t * unwritten extents in delalloc path. In most cases such\n\t * allocation would require 1, or 2 blocks, higher numbers are\n\t * very rare.\n\t */\n\tresv_clusters = ext4_blocks_count(EXT4_SB(sb)->s_es) >>\n\t\t\tEXT4_SB(sb)->s_cluster_bits;\n\n\tdo_div(resv_clusters, 50);\n\tresv_clusters = min_t(ext4_fsblk_t, resv_clusters, 4096);\n\n\treturn resv_clusters;\n}"
  },
  {
    "function_name": "ext4_calculate_overhead",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/super.c",
    "lines": "3322-3364",
    "snippet": "int ext4_calculate_overhead(struct super_block *sb)\n{\n\tstruct ext4_sb_info *sbi = EXT4_SB(sb);\n\tstruct ext4_super_block *es = sbi->s_es;\n\text4_group_t i, ngroups = ext4_get_groups_count(sb);\n\text4_fsblk_t overhead = 0;\n\tchar *buf = (char *) get_zeroed_page(GFP_NOFS);\n\n\tif (!buf)\n\t\treturn -ENOMEM;\n\n\t/*\n\t * Compute the overhead (FS structures).  This is constant\n\t * for a given filesystem unless the number of block groups\n\t * changes so we cache the previous value until it does.\n\t */\n\n\t/*\n\t * All of the blocks before first_data_block are overhead\n\t */\n\toverhead = EXT4_B2C(sbi, le32_to_cpu(es->s_first_data_block));\n\n\t/*\n\t * Add the overhead found in each block group\n\t */\n\tfor (i = 0; i < ngroups; i++) {\n\t\tint blks;\n\n\t\tblks = count_overhead(sb, i, buf);\n\t\toverhead += blks;\n\t\tif (blks)\n\t\t\tmemset(buf, 0, PAGE_SIZE);\n\t\tcond_resched();\n\t}\n\t/* Add the internal journal blocks as well */\n\tif (sbi->s_journal && !sbi->journal_bdev)\n\t\toverhead += EXT4_NUM_B2C(sbi, sbi->s_journal->j_maxlen);\n\n\tsbi->s_overhead = overhead;\n\tsmp_wmb();\n\tfree_page((unsigned long) buf);\n\treturn 0;\n}",
    "includes": [
      "#include <trace/events/ext4.h>",
      "#include \"mballoc.h\"",
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"ext4_jbd2.h\"",
      "#include \"ext4_extents.h\"\t/* Needed for trace points definition */",
      "#include \"ext4.h\"",
      "#include <linux/freezer.h>",
      "#include <linux/kthread.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/cleancache.h>",
      "#include <linux/crc16.h>",
      "#include <linux/log2.h>",
      "#include <linux/ctype.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/namei.h>",
      "#include <linux/mount.h>",
      "#include <linux/random.h>",
      "#include <linux/vfs.h>",
      "#include <linux/exportfs.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/parser.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/init.h>",
      "#include <linux/slab.h>",
      "#include <linux/jbd2.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/time.h>",
      "#include <linux/fs.h>",
      "#include <linux/string.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void ext4_mark_recovery_complete(struct super_block *sb,\n\t\t\t\t\tstruct ext4_super_block *es);",
      "static void ext4_clear_journal_err(struct super_block *sb,\n\t\t\t\t   struct ext4_super_block *es);",
      "static int ext4_statfs(struct dentry *dentry, struct kstatfs *buf);",
      "static int ext4_unfreeze(struct super_block *sb);",
      "static int ext4_freeze(struct super_block *sb);",
      "static inline int ext2_feature_set_ok(struct super_block *sb);",
      "static inline int ext3_feature_set_ok(struct super_block *sb);",
      "static void ext4_unregister_li_request(struct super_block *sb);",
      "static int ext4_reserve_clusters(struct ext4_sb_info *, ext4_fsblk_t);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "free_page",
          "args": [
            "(unsigned long) buf"
          ],
          "line": 3362
        },
        "resolved": true,
        "details": {
          "function_name": "_xfs_buf_free_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_buf.c",
          "lines": "238-246",
          "snippet": "STATIC void\n_xfs_buf_free_pages(\n\txfs_buf_t\t*bp)\n{\n\tif (bp->b_pages != bp->b_page_array) {\n\t\tkmem_free(bp->b_pages);\n\t\tbp->b_pages = NULL;\n\t}\n}",
          "includes": [
            "#include \"xfs_log.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include <linux/freezer.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/migrate.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hash.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/percpu.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/bio.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/init.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/gfp.h>",
            "#include <linux/errno.h>",
            "#include <linux/stddef.h>",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_log.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include <linux/freezer.h>\n#include <linux/backing-dev.h>\n#include <linux/migrate.h>\n#include <linux/kthread.h>\n#include <linux/hash.h>\n#include <linux/blkdev.h>\n#include <linux/percpu.h>\n#include <linux/workqueue.h>\n#include <linux/proc_fs.h>\n#include <linux/sysctl.h>\n#include <linux/bio.h>\n#include <linux/vmalloc.h>\n#include <linux/init.h>\n#include <linux/pagemap.h>\n#include <linux/gfp.h>\n#include <linux/errno.h>\n#include <linux/stddef.h>\n#include \"xfs.h\"\n\nSTATIC void\n_xfs_buf_free_pages(\n\txfs_buf_t\t*bp)\n{\n\tif (bp->b_pages != bp->b_page_array) {\n\t\tkmem_free(bp->b_pages);\n\t\tbp->b_pages = NULL;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "smp_wmb",
          "args": [],
          "line": 3361
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXT4_NUM_B2C",
          "args": [
            "sbi",
            "sbi->s_journal->j_maxlen"
          ],
          "line": 3358
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cond_resched",
          "args": [],
          "line": 3354
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "buf",
            "0",
            "PAGE_SIZE"
          ],
          "line": 3353
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "count_overhead",
          "args": [
            "sb",
            "i",
            "buf"
          ],
          "line": 3350
        },
        "resolved": true,
        "details": {
          "function_name": "count_overhead",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/super.c",
          "lines": "3266-3317",
          "snippet": "static int count_overhead(struct super_block *sb, ext4_group_t grp,\n\t\t\t  char *buf)\n{\n\tstruct ext4_sb_info\t*sbi = EXT4_SB(sb);\n\tstruct ext4_group_desc\t*gdp;\n\text4_fsblk_t\t\tfirst_block, last_block, b;\n\text4_group_t\t\ti, ngroups = ext4_get_groups_count(sb);\n\tint\t\t\ts, j, count = 0;\n\n\tif (!EXT4_HAS_RO_COMPAT_FEATURE(sb, EXT4_FEATURE_RO_COMPAT_BIGALLOC))\n\t\treturn (ext4_bg_has_super(sb, grp) + ext4_bg_num_gdb(sb, grp) +\n\t\t\tsbi->s_itb_per_group + 2);\n\n\tfirst_block = le32_to_cpu(sbi->s_es->s_first_data_block) +\n\t\t(grp * EXT4_BLOCKS_PER_GROUP(sb));\n\tlast_block = first_block + EXT4_BLOCKS_PER_GROUP(sb) - 1;\n\tfor (i = 0; i < ngroups; i++) {\n\t\tgdp = ext4_get_group_desc(sb, i, NULL);\n\t\tb = ext4_block_bitmap(sb, gdp);\n\t\tif (b >= first_block && b <= last_block) {\n\t\t\text4_set_bit(EXT4_B2C(sbi, b - first_block), buf);\n\t\t\tcount++;\n\t\t}\n\t\tb = ext4_inode_bitmap(sb, gdp);\n\t\tif (b >= first_block && b <= last_block) {\n\t\t\text4_set_bit(EXT4_B2C(sbi, b - first_block), buf);\n\t\t\tcount++;\n\t\t}\n\t\tb = ext4_inode_table(sb, gdp);\n\t\tif (b >= first_block && b + sbi->s_itb_per_group <= last_block)\n\t\t\tfor (j = 0; j < sbi->s_itb_per_group; j++, b++) {\n\t\t\t\tint c = EXT4_B2C(sbi, b - first_block);\n\t\t\t\text4_set_bit(c, buf);\n\t\t\t\tcount++;\n\t\t\t}\n\t\tif (i != grp)\n\t\t\tcontinue;\n\t\ts = 0;\n\t\tif (ext4_bg_has_super(sb, grp)) {\n\t\t\text4_set_bit(s++, buf);\n\t\t\tcount++;\n\t\t}\n\t\tfor (j = ext4_bg_num_gdb(sb, grp); j > 0; j--) {\n\t\t\text4_set_bit(EXT4_B2C(sbi, s++), buf);\n\t\t\tcount++;\n\t\t}\n\t}\n\tif (!count)\n\t\treturn 0;\n\treturn EXT4_CLUSTERS_PER_GROUP(sb) -\n\t\text4_count_free(buf, EXT4_CLUSTERS_PER_GROUP(sb) / 8);\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"mballoc.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include \"ext4_extents.h\"\t/* Needed for trace points definition */",
            "#include \"ext4.h\"",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/crc16.h>",
            "#include <linux/log2.h>",
            "#include <linux/ctype.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/random.h>",
            "#include <linux/vfs.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/parser.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/time.h>",
            "#include <linux/fs.h>",
            "#include <linux/string.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ext4_statfs(struct dentry *dentry, struct kstatfs *buf);",
            "static int ext4_unfreeze(struct super_block *sb);",
            "static int ext4_freeze(struct super_block *sb);",
            "static inline int ext2_feature_set_ok(struct super_block *sb);",
            "static inline int ext3_feature_set_ok(struct super_block *sb);",
            "static void ext4_unregister_li_request(struct super_block *sb);",
            "static int ext4_reserve_clusters(struct ext4_sb_info *, ext4_fsblk_t);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"mballoc.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4_extents.h\"\t/* Needed for trace points definition */\n#include \"ext4.h\"\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <asm/uaccess.h>\n#include <linux/cleancache.h>\n#include <linux/crc16.h>\n#include <linux/log2.h>\n#include <linux/ctype.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/random.h>\n#include <linux/vfs.h>\n#include <linux/exportfs.h>\n#include <linux/buffer_head.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/jbd2.h>\n#include <linux/vmalloc.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n#include <linux/string.h>\n#include <linux/module.h>\n\nstatic int ext4_statfs(struct dentry *dentry, struct kstatfs *buf);\nstatic int ext4_unfreeze(struct super_block *sb);\nstatic int ext4_freeze(struct super_block *sb);\nstatic inline int ext2_feature_set_ok(struct super_block *sb);\nstatic inline int ext3_feature_set_ok(struct super_block *sb);\nstatic void ext4_unregister_li_request(struct super_block *sb);\nstatic int ext4_reserve_clusters(struct ext4_sb_info *, ext4_fsblk_t);\n\nstatic int count_overhead(struct super_block *sb, ext4_group_t grp,\n\t\t\t  char *buf)\n{\n\tstruct ext4_sb_info\t*sbi = EXT4_SB(sb);\n\tstruct ext4_group_desc\t*gdp;\n\text4_fsblk_t\t\tfirst_block, last_block, b;\n\text4_group_t\t\ti, ngroups = ext4_get_groups_count(sb);\n\tint\t\t\ts, j, count = 0;\n\n\tif (!EXT4_HAS_RO_COMPAT_FEATURE(sb, EXT4_FEATURE_RO_COMPAT_BIGALLOC))\n\t\treturn (ext4_bg_has_super(sb, grp) + ext4_bg_num_gdb(sb, grp) +\n\t\t\tsbi->s_itb_per_group + 2);\n\n\tfirst_block = le32_to_cpu(sbi->s_es->s_first_data_block) +\n\t\t(grp * EXT4_BLOCKS_PER_GROUP(sb));\n\tlast_block = first_block + EXT4_BLOCKS_PER_GROUP(sb) - 1;\n\tfor (i = 0; i < ngroups; i++) {\n\t\tgdp = ext4_get_group_desc(sb, i, NULL);\n\t\tb = ext4_block_bitmap(sb, gdp);\n\t\tif (b >= first_block && b <= last_block) {\n\t\t\text4_set_bit(EXT4_B2C(sbi, b - first_block), buf);\n\t\t\tcount++;\n\t\t}\n\t\tb = ext4_inode_bitmap(sb, gdp);\n\t\tif (b >= first_block && b <= last_block) {\n\t\t\text4_set_bit(EXT4_B2C(sbi, b - first_block), buf);\n\t\t\tcount++;\n\t\t}\n\t\tb = ext4_inode_table(sb, gdp);\n\t\tif (b >= first_block && b + sbi->s_itb_per_group <= last_block)\n\t\t\tfor (j = 0; j < sbi->s_itb_per_group; j++, b++) {\n\t\t\t\tint c = EXT4_B2C(sbi, b - first_block);\n\t\t\t\text4_set_bit(c, buf);\n\t\t\t\tcount++;\n\t\t\t}\n\t\tif (i != grp)\n\t\t\tcontinue;\n\t\ts = 0;\n\t\tif (ext4_bg_has_super(sb, grp)) {\n\t\t\text4_set_bit(s++, buf);\n\t\t\tcount++;\n\t\t}\n\t\tfor (j = ext4_bg_num_gdb(sb, grp); j > 0; j--) {\n\t\t\text4_set_bit(EXT4_B2C(sbi, s++), buf);\n\t\t\tcount++;\n\t\t}\n\t}\n\tif (!count)\n\t\treturn 0;\n\treturn EXT4_CLUSTERS_PER_GROUP(sb) -\n\t\text4_count_free(buf, EXT4_CLUSTERS_PER_GROUP(sb) / 8);\n}"
        }
      },
      {
        "call_info": {
          "callee": "EXT4_B2C",
          "args": [
            "sbi",
            "le32_to_cpu(es->s_first_data_block)"
          ],
          "line": 3342
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "es->s_first_data_block"
          ],
          "line": 3342
        },
        "resolved": true,
        "details": {
          "function_name": "sle32_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "53-56",
          "snippet": "static inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_zeroed_page",
          "args": [
            "GFP_NOFS"
          ],
          "line": 3328
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_get_groups_count",
          "args": [
            "sb"
          ],
          "line": 3326
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXT4_SB",
          "args": [
            "sb"
          ],
          "line": 3324
        },
        "resolved": true,
        "details": {
          "function_name": "EXT4_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ext4.h",
          "lines": "1356-1359",
          "snippet": "static inline struct ext4_sb_info *EXT4_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include \"extents_status.h\"",
            "#include <linux/compat.h>",
            "#include <linux/falloc.h>",
            "#include <crypto/hash.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/wait.h>",
            "#include <linux/timer.h>",
            "#include <linux/mutex.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/quota.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extents_status.h\"\n#include <linux/compat.h>\n#include <linux/falloc.h>\n#include <crypto/hash.h>\n#include <linux/ratelimit.h>\n#include <linux/percpu_counter.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/wait.h>\n#include <linux/timer.h>\n#include <linux/mutex.h>\n#include <linux/seqlock.h>\n#include <linux/rbtree.h>\n#include <linux/rwsem.h>\n#include <linux/quota.h>\n#include <linux/jbd2.h>\n#include <linux/magic.h>\n#include <linux/blkdev.h>\n#include <linux/types.h>\n\nstatic inline struct ext4_sb_info *EXT4_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"mballoc.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4_extents.h\"\t/* Needed for trace points definition */\n#include \"ext4.h\"\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <asm/uaccess.h>\n#include <linux/cleancache.h>\n#include <linux/crc16.h>\n#include <linux/log2.h>\n#include <linux/ctype.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/random.h>\n#include <linux/vfs.h>\n#include <linux/exportfs.h>\n#include <linux/buffer_head.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/jbd2.h>\n#include <linux/vmalloc.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n#include <linux/string.h>\n#include <linux/module.h>\n\nstatic void ext4_mark_recovery_complete(struct super_block *sb,\n\t\t\t\t\tstruct ext4_super_block *es);\nstatic void ext4_clear_journal_err(struct super_block *sb,\n\t\t\t\t   struct ext4_super_block *es);\nstatic int ext4_statfs(struct dentry *dentry, struct kstatfs *buf);\nstatic int ext4_unfreeze(struct super_block *sb);\nstatic int ext4_freeze(struct super_block *sb);\nstatic inline int ext2_feature_set_ok(struct super_block *sb);\nstatic inline int ext3_feature_set_ok(struct super_block *sb);\nstatic void ext4_unregister_li_request(struct super_block *sb);\nstatic int ext4_reserve_clusters(struct ext4_sb_info *, ext4_fsblk_t);\n\nint ext4_calculate_overhead(struct super_block *sb)\n{\n\tstruct ext4_sb_info *sbi = EXT4_SB(sb);\n\tstruct ext4_super_block *es = sbi->s_es;\n\text4_group_t i, ngroups = ext4_get_groups_count(sb);\n\text4_fsblk_t overhead = 0;\n\tchar *buf = (char *) get_zeroed_page(GFP_NOFS);\n\n\tif (!buf)\n\t\treturn -ENOMEM;\n\n\t/*\n\t * Compute the overhead (FS structures).  This is constant\n\t * for a given filesystem unless the number of block groups\n\t * changes so we cache the previous value until it does.\n\t */\n\n\t/*\n\t * All of the blocks before first_data_block are overhead\n\t */\n\toverhead = EXT4_B2C(sbi, le32_to_cpu(es->s_first_data_block));\n\n\t/*\n\t * Add the overhead found in each block group\n\t */\n\tfor (i = 0; i < ngroups; i++) {\n\t\tint blks;\n\n\t\tblks = count_overhead(sb, i, buf);\n\t\toverhead += blks;\n\t\tif (blks)\n\t\t\tmemset(buf, 0, PAGE_SIZE);\n\t\tcond_resched();\n\t}\n\t/* Add the internal journal blocks as well */\n\tif (sbi->s_journal && !sbi->journal_bdev)\n\t\toverhead += EXT4_NUM_B2C(sbi, sbi->s_journal->j_maxlen);\n\n\tsbi->s_overhead = overhead;\n\tsmp_wmb();\n\tfree_page((unsigned long) buf);\n\treturn 0;\n}"
  },
  {
    "function_name": "count_overhead",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/super.c",
    "lines": "3266-3317",
    "snippet": "static int count_overhead(struct super_block *sb, ext4_group_t grp,\n\t\t\t  char *buf)\n{\n\tstruct ext4_sb_info\t*sbi = EXT4_SB(sb);\n\tstruct ext4_group_desc\t*gdp;\n\text4_fsblk_t\t\tfirst_block, last_block, b;\n\text4_group_t\t\ti, ngroups = ext4_get_groups_count(sb);\n\tint\t\t\ts, j, count = 0;\n\n\tif (!EXT4_HAS_RO_COMPAT_FEATURE(sb, EXT4_FEATURE_RO_COMPAT_BIGALLOC))\n\t\treturn (ext4_bg_has_super(sb, grp) + ext4_bg_num_gdb(sb, grp) +\n\t\t\tsbi->s_itb_per_group + 2);\n\n\tfirst_block = le32_to_cpu(sbi->s_es->s_first_data_block) +\n\t\t(grp * EXT4_BLOCKS_PER_GROUP(sb));\n\tlast_block = first_block + EXT4_BLOCKS_PER_GROUP(sb) - 1;\n\tfor (i = 0; i < ngroups; i++) {\n\t\tgdp = ext4_get_group_desc(sb, i, NULL);\n\t\tb = ext4_block_bitmap(sb, gdp);\n\t\tif (b >= first_block && b <= last_block) {\n\t\t\text4_set_bit(EXT4_B2C(sbi, b - first_block), buf);\n\t\t\tcount++;\n\t\t}\n\t\tb = ext4_inode_bitmap(sb, gdp);\n\t\tif (b >= first_block && b <= last_block) {\n\t\t\text4_set_bit(EXT4_B2C(sbi, b - first_block), buf);\n\t\t\tcount++;\n\t\t}\n\t\tb = ext4_inode_table(sb, gdp);\n\t\tif (b >= first_block && b + sbi->s_itb_per_group <= last_block)\n\t\t\tfor (j = 0; j < sbi->s_itb_per_group; j++, b++) {\n\t\t\t\tint c = EXT4_B2C(sbi, b - first_block);\n\t\t\t\text4_set_bit(c, buf);\n\t\t\t\tcount++;\n\t\t\t}\n\t\tif (i != grp)\n\t\t\tcontinue;\n\t\ts = 0;\n\t\tif (ext4_bg_has_super(sb, grp)) {\n\t\t\text4_set_bit(s++, buf);\n\t\t\tcount++;\n\t\t}\n\t\tfor (j = ext4_bg_num_gdb(sb, grp); j > 0; j--) {\n\t\t\text4_set_bit(EXT4_B2C(sbi, s++), buf);\n\t\t\tcount++;\n\t\t}\n\t}\n\tif (!count)\n\t\treturn 0;\n\treturn EXT4_CLUSTERS_PER_GROUP(sb) -\n\t\text4_count_free(buf, EXT4_CLUSTERS_PER_GROUP(sb) / 8);\n}",
    "includes": [
      "#include <trace/events/ext4.h>",
      "#include \"mballoc.h\"",
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"ext4_jbd2.h\"",
      "#include \"ext4_extents.h\"\t/* Needed for trace points definition */",
      "#include \"ext4.h\"",
      "#include <linux/freezer.h>",
      "#include <linux/kthread.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/cleancache.h>",
      "#include <linux/crc16.h>",
      "#include <linux/log2.h>",
      "#include <linux/ctype.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/namei.h>",
      "#include <linux/mount.h>",
      "#include <linux/random.h>",
      "#include <linux/vfs.h>",
      "#include <linux/exportfs.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/parser.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/init.h>",
      "#include <linux/slab.h>",
      "#include <linux/jbd2.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/time.h>",
      "#include <linux/fs.h>",
      "#include <linux/string.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ext4_statfs(struct dentry *dentry, struct kstatfs *buf);",
      "static int ext4_unfreeze(struct super_block *sb);",
      "static int ext4_freeze(struct super_block *sb);",
      "static inline int ext2_feature_set_ok(struct super_block *sb);",
      "static inline int ext3_feature_set_ok(struct super_block *sb);",
      "static void ext4_unregister_li_request(struct super_block *sb);",
      "static int ext4_reserve_clusters(struct ext4_sb_info *, ext4_fsblk_t);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ext4_count_free",
          "args": [
            "buf",
            "EXT4_CLUSTERS_PER_GROUP(sb) / 8"
          ],
          "line": 3316
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_count_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/bitmap.c",
          "lines": "14-17",
          "snippet": "unsigned int ext4_count_free(char *bitmap, unsigned int numchars)\n{\n\treturn numchars * BITS_PER_BYTE - memweight(bitmap, numchars);\n}",
          "includes": [
            "#include \"ext4.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ext4.h\"\n#include <linux/jbd2.h>\n#include <linux/buffer_head.h>\n\nunsigned int ext4_count_free(char *bitmap, unsigned int numchars)\n{\n\treturn numchars * BITS_PER_BYTE - memweight(bitmap, numchars);\n}"
        }
      },
      {
        "call_info": {
          "callee": "EXT4_CLUSTERS_PER_GROUP",
          "args": [
            "sb"
          ],
          "line": 3316
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXT4_CLUSTERS_PER_GROUP",
          "args": [
            "sb"
          ],
          "line": 3315
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_set_bit",
          "args": [
            "EXT4_B2C(sbi, s++)",
            "buf"
          ],
          "line": 3309
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXT4_B2C",
          "args": [
            "sbi",
            "s++"
          ],
          "line": 3309
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_bg_num_gdb",
          "args": [
            "sb",
            "grp"
          ],
          "line": 3308
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_bg_num_gdb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/balloc.c",
          "lines": "797-809",
          "snippet": "unsigned long ext4_bg_num_gdb(struct super_block *sb, ext4_group_t group)\n{\n\tunsigned long first_meta_bg =\n\t\t\tle32_to_cpu(EXT4_SB(sb)->s_es->s_first_meta_bg);\n\tunsigned long metagroup = group / EXT4_DESC_PER_BLOCK(sb);\n\n\tif (!EXT4_HAS_INCOMPAT_FEATURE(sb,EXT4_FEATURE_INCOMPAT_META_BG) ||\n\t\t\tmetagroup < first_meta_bg)\n\t\treturn ext4_bg_num_gdb_nometa(sb, group);\n\n\treturn ext4_bg_num_gdb_meta(sb,group);\n\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"mballoc.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include \"ext4.h\"",
            "#include <linux/buffer_head.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/fs.h>",
            "#include <linux/capability.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"mballoc.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4.h\"\n#include <linux/buffer_head.h>\n#include <linux/quotaops.h>\n#include <linux/jbd2.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n#include <linux/time.h>\n\nunsigned long ext4_bg_num_gdb(struct super_block *sb, ext4_group_t group)\n{\n\tunsigned long first_meta_bg =\n\t\t\tle32_to_cpu(EXT4_SB(sb)->s_es->s_first_meta_bg);\n\tunsigned long metagroup = group / EXT4_DESC_PER_BLOCK(sb);\n\n\tif (!EXT4_HAS_INCOMPAT_FEATURE(sb,EXT4_FEATURE_INCOMPAT_META_BG) ||\n\t\t\tmetagroup < first_meta_bg)\n\t\treturn ext4_bg_num_gdb_nometa(sb, group);\n\n\treturn ext4_bg_num_gdb_meta(sb,group);\n\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_set_bit",
          "args": [
            "s++",
            "buf"
          ],
          "line": 3305
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_bg_has_super",
          "args": [
            "sb",
            "grp"
          ],
          "line": 3304
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_bg_has_super",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/balloc.c",
          "lines": "740-762",
          "snippet": "int ext4_bg_has_super(struct super_block *sb, ext4_group_t group)\n{\n\tstruct ext4_super_block *es = EXT4_SB(sb)->s_es;\n\n\tif (group == 0)\n\t\treturn 1;\n\tif (EXT4_HAS_COMPAT_FEATURE(sb, EXT4_FEATURE_COMPAT_SPARSE_SUPER2)) {\n\t\tif (group == le32_to_cpu(es->s_backup_bgs[0]) ||\n\t\t    group == le32_to_cpu(es->s_backup_bgs[1]))\n\t\t\treturn 1;\n\t\treturn 0;\n\t}\n\tif ((group <= 1) || !EXT4_HAS_RO_COMPAT_FEATURE(sb,\n\t\t\t\t\tEXT4_FEATURE_RO_COMPAT_SPARSE_SUPER))\n\t\treturn 1;\n\tif (!(group & 1))\n\t\treturn 0;\n\tif (test_root(group, 3) || (test_root(group, 5)) ||\n\t    test_root(group, 7))\n\t\treturn 1;\n\n\treturn 0;\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"mballoc.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include \"ext4.h\"",
            "#include <linux/buffer_head.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/fs.h>",
            "#include <linux/capability.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"mballoc.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4.h\"\n#include <linux/buffer_head.h>\n#include <linux/quotaops.h>\n#include <linux/jbd2.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n#include <linux/time.h>\n\nint ext4_bg_has_super(struct super_block *sb, ext4_group_t group)\n{\n\tstruct ext4_super_block *es = EXT4_SB(sb)->s_es;\n\n\tif (group == 0)\n\t\treturn 1;\n\tif (EXT4_HAS_COMPAT_FEATURE(sb, EXT4_FEATURE_COMPAT_SPARSE_SUPER2)) {\n\t\tif (group == le32_to_cpu(es->s_backup_bgs[0]) ||\n\t\t    group == le32_to_cpu(es->s_backup_bgs[1]))\n\t\t\treturn 1;\n\t\treturn 0;\n\t}\n\tif ((group <= 1) || !EXT4_HAS_RO_COMPAT_FEATURE(sb,\n\t\t\t\t\tEXT4_FEATURE_RO_COMPAT_SPARSE_SUPER))\n\t\treturn 1;\n\tif (!(group & 1))\n\t\treturn 0;\n\tif (test_root(group, 3) || (test_root(group, 5)) ||\n\t    test_root(group, 7))\n\t\treturn 1;\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_set_bit",
          "args": [
            "c",
            "buf"
          ],
          "line": 3298
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXT4_B2C",
          "args": [
            "sbi",
            "b - first_block"
          ],
          "line": 3297
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_inode_table",
          "args": [
            "sb",
            "gdp"
          ],
          "line": 3294
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_inode_table",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/super.c",
          "lines": "195-201",
          "snippet": "ext4_fsblk_t ext4_inode_table(struct super_block *sb,\n\t\t\t      struct ext4_group_desc *bg)\n{\n\treturn le32_to_cpu(bg->bg_inode_table_lo) |\n\t\t(EXT4_DESC_SIZE(sb) >= EXT4_MIN_DESC_SIZE_64BIT ?\n\t\t (ext4_fsblk_t)le32_to_cpu(bg->bg_inode_table_hi) << 32 : 0);\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"mballoc.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include \"ext4_extents.h\"\t/* Needed for trace points definition */",
            "#include \"ext4.h\"",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/crc16.h>",
            "#include <linux/log2.h>",
            "#include <linux/ctype.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/random.h>",
            "#include <linux/vfs.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/parser.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/time.h>",
            "#include <linux/fs.h>",
            "#include <linux/string.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ext4_unfreeze(struct super_block *sb);",
            "static int ext4_freeze(struct super_block *sb);",
            "static inline int ext2_feature_set_ok(struct super_block *sb);",
            "static inline int ext3_feature_set_ok(struct super_block *sb);",
            "static void ext4_unregister_li_request(struct super_block *sb);",
            "static int ext4_reserve_clusters(struct ext4_sb_info *, ext4_fsblk_t);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"mballoc.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4_extents.h\"\t/* Needed for trace points definition */\n#include \"ext4.h\"\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <asm/uaccess.h>\n#include <linux/cleancache.h>\n#include <linux/crc16.h>\n#include <linux/log2.h>\n#include <linux/ctype.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/random.h>\n#include <linux/vfs.h>\n#include <linux/exportfs.h>\n#include <linux/buffer_head.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/jbd2.h>\n#include <linux/vmalloc.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n#include <linux/string.h>\n#include <linux/module.h>\n\nstatic int ext4_unfreeze(struct super_block *sb);\nstatic int ext4_freeze(struct super_block *sb);\nstatic inline int ext2_feature_set_ok(struct super_block *sb);\nstatic inline int ext3_feature_set_ok(struct super_block *sb);\nstatic void ext4_unregister_li_request(struct super_block *sb);\nstatic int ext4_reserve_clusters(struct ext4_sb_info *, ext4_fsblk_t);\n\next4_fsblk_t ext4_inode_table(struct super_block *sb,\n\t\t\t      struct ext4_group_desc *bg)\n{\n\treturn le32_to_cpu(bg->bg_inode_table_lo) |\n\t\t(EXT4_DESC_SIZE(sb) >= EXT4_MIN_DESC_SIZE_64BIT ?\n\t\t (ext4_fsblk_t)le32_to_cpu(bg->bg_inode_table_hi) << 32 : 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_set_bit",
          "args": [
            "EXT4_B2C(sbi, b - first_block)",
            "buf"
          ],
          "line": 3291
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXT4_B2C",
          "args": [
            "sbi",
            "b - first_block"
          ],
          "line": 3291
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_inode_bitmap",
          "args": [
            "sb",
            "gdp"
          ],
          "line": 3289
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_inode_bitmap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/super.c",
          "lines": "187-193",
          "snippet": "ext4_fsblk_t ext4_inode_bitmap(struct super_block *sb,\n\t\t\t       struct ext4_group_desc *bg)\n{\n\treturn le32_to_cpu(bg->bg_inode_bitmap_lo) |\n\t\t(EXT4_DESC_SIZE(sb) >= EXT4_MIN_DESC_SIZE_64BIT ?\n\t\t (ext4_fsblk_t)le32_to_cpu(bg->bg_inode_bitmap_hi) << 32 : 0);\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"mballoc.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include \"ext4_extents.h\"\t/* Needed for trace points definition */",
            "#include \"ext4.h\"",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/crc16.h>",
            "#include <linux/log2.h>",
            "#include <linux/ctype.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/random.h>",
            "#include <linux/vfs.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/parser.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/time.h>",
            "#include <linux/fs.h>",
            "#include <linux/string.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ext4_unfreeze(struct super_block *sb);",
            "static int ext4_freeze(struct super_block *sb);",
            "static inline int ext2_feature_set_ok(struct super_block *sb);",
            "static inline int ext3_feature_set_ok(struct super_block *sb);",
            "static void ext4_unregister_li_request(struct super_block *sb);",
            "static int ext4_reserve_clusters(struct ext4_sb_info *, ext4_fsblk_t);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"mballoc.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4_extents.h\"\t/* Needed for trace points definition */\n#include \"ext4.h\"\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <asm/uaccess.h>\n#include <linux/cleancache.h>\n#include <linux/crc16.h>\n#include <linux/log2.h>\n#include <linux/ctype.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/random.h>\n#include <linux/vfs.h>\n#include <linux/exportfs.h>\n#include <linux/buffer_head.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/jbd2.h>\n#include <linux/vmalloc.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n#include <linux/string.h>\n#include <linux/module.h>\n\nstatic int ext4_unfreeze(struct super_block *sb);\nstatic int ext4_freeze(struct super_block *sb);\nstatic inline int ext2_feature_set_ok(struct super_block *sb);\nstatic inline int ext3_feature_set_ok(struct super_block *sb);\nstatic void ext4_unregister_li_request(struct super_block *sb);\nstatic int ext4_reserve_clusters(struct ext4_sb_info *, ext4_fsblk_t);\n\next4_fsblk_t ext4_inode_bitmap(struct super_block *sb,\n\t\t\t       struct ext4_group_desc *bg)\n{\n\treturn le32_to_cpu(bg->bg_inode_bitmap_lo) |\n\t\t(EXT4_DESC_SIZE(sb) >= EXT4_MIN_DESC_SIZE_64BIT ?\n\t\t (ext4_fsblk_t)le32_to_cpu(bg->bg_inode_bitmap_hi) << 32 : 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_set_bit",
          "args": [
            "EXT4_B2C(sbi, b - first_block)",
            "buf"
          ],
          "line": 3286
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXT4_B2C",
          "args": [
            "sbi",
            "b - first_block"
          ],
          "line": 3286
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_block_bitmap",
          "args": [
            "sb",
            "gdp"
          ],
          "line": 3284
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_block_bitmap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/super.c",
          "lines": "179-185",
          "snippet": "ext4_fsblk_t ext4_block_bitmap(struct super_block *sb,\n\t\t\t       struct ext4_group_desc *bg)\n{\n\treturn le32_to_cpu(bg->bg_block_bitmap_lo) |\n\t\t(EXT4_DESC_SIZE(sb) >= EXT4_MIN_DESC_SIZE_64BIT ?\n\t\t (ext4_fsblk_t)le32_to_cpu(bg->bg_block_bitmap_hi) << 32 : 0);\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"mballoc.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include \"ext4_extents.h\"\t/* Needed for trace points definition */",
            "#include \"ext4.h\"",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/crc16.h>",
            "#include <linux/log2.h>",
            "#include <linux/ctype.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/random.h>",
            "#include <linux/vfs.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/parser.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/time.h>",
            "#include <linux/fs.h>",
            "#include <linux/string.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ext4_unfreeze(struct super_block *sb);",
            "static int ext4_freeze(struct super_block *sb);",
            "static inline int ext2_feature_set_ok(struct super_block *sb);",
            "static inline int ext3_feature_set_ok(struct super_block *sb);",
            "static void ext4_unregister_li_request(struct super_block *sb);",
            "static int ext4_reserve_clusters(struct ext4_sb_info *, ext4_fsblk_t);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"mballoc.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4_extents.h\"\t/* Needed for trace points definition */\n#include \"ext4.h\"\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <asm/uaccess.h>\n#include <linux/cleancache.h>\n#include <linux/crc16.h>\n#include <linux/log2.h>\n#include <linux/ctype.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/random.h>\n#include <linux/vfs.h>\n#include <linux/exportfs.h>\n#include <linux/buffer_head.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/jbd2.h>\n#include <linux/vmalloc.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n#include <linux/string.h>\n#include <linux/module.h>\n\nstatic int ext4_unfreeze(struct super_block *sb);\nstatic int ext4_freeze(struct super_block *sb);\nstatic inline int ext2_feature_set_ok(struct super_block *sb);\nstatic inline int ext3_feature_set_ok(struct super_block *sb);\nstatic void ext4_unregister_li_request(struct super_block *sb);\nstatic int ext4_reserve_clusters(struct ext4_sb_info *, ext4_fsblk_t);\n\next4_fsblk_t ext4_block_bitmap(struct super_block *sb,\n\t\t\t       struct ext4_group_desc *bg)\n{\n\treturn le32_to_cpu(bg->bg_block_bitmap_lo) |\n\t\t(EXT4_DESC_SIZE(sb) >= EXT4_MIN_DESC_SIZE_64BIT ?\n\t\t (ext4_fsblk_t)le32_to_cpu(bg->bg_block_bitmap_hi) << 32 : 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_get_group_desc",
          "args": [
            "sb",
            "i",
            "NULL"
          ],
          "line": 3283
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_get_group_desc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/balloc.c",
          "lines": "277-309",
          "snippet": "struct ext4_group_desc * ext4_get_group_desc(struct super_block *sb,\n\t\t\t\t\t     ext4_group_t block_group,\n\t\t\t\t\t     struct buffer_head **bh)\n{\n\tunsigned int group_desc;\n\tunsigned int offset;\n\text4_group_t ngroups = ext4_get_groups_count(sb);\n\tstruct ext4_group_desc *desc;\n\tstruct ext4_sb_info *sbi = EXT4_SB(sb);\n\n\tif (block_group >= ngroups) {\n\t\text4_error(sb, \"block_group >= groups_count - block_group = %u,\"\n\t\t\t   \" groups_count = %u\", block_group, ngroups);\n\n\t\treturn NULL;\n\t}\n\n\tgroup_desc = block_group >> EXT4_DESC_PER_BLOCK_BITS(sb);\n\toffset = block_group & (EXT4_DESC_PER_BLOCK(sb) - 1);\n\tif (!sbi->s_group_desc[group_desc]) {\n\t\text4_error(sb, \"Group descriptor not loaded - \"\n\t\t\t   \"block_group = %u, group_desc = %u, desc = %u\",\n\t\t\t   block_group, group_desc, offset);\n\t\treturn NULL;\n\t}\n\n\tdesc = (struct ext4_group_desc *)(\n\t\t(__u8 *)sbi->s_group_desc[group_desc]->b_data +\n\t\toffset * EXT4_DESC_SIZE(sb));\n\tif (bh)\n\t\t*bh = sbi->s_group_desc[group_desc];\n\treturn desc;\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"mballoc.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include \"ext4.h\"",
            "#include <linux/buffer_head.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/fs.h>",
            "#include <linux/capability.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static unsigned ext4_num_base_meta_clusters(struct super_block *sb,\n\t\t\t\t\t    ext4_group_t block_group);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"mballoc.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4.h\"\n#include <linux/buffer_head.h>\n#include <linux/quotaops.h>\n#include <linux/jbd2.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n#include <linux/time.h>\n\nstatic unsigned ext4_num_base_meta_clusters(struct super_block *sb,\n\t\t\t\t\t    ext4_group_t block_group);\n\nstruct ext4_group_desc * ext4_get_group_desc(struct super_block *sb,\n\t\t\t\t\t     ext4_group_t block_group,\n\t\t\t\t\t     struct buffer_head **bh)\n{\n\tunsigned int group_desc;\n\tunsigned int offset;\n\text4_group_t ngroups = ext4_get_groups_count(sb);\n\tstruct ext4_group_desc *desc;\n\tstruct ext4_sb_info *sbi = EXT4_SB(sb);\n\n\tif (block_group >= ngroups) {\n\t\text4_error(sb, \"block_group >= groups_count - block_group = %u,\"\n\t\t\t   \" groups_count = %u\", block_group, ngroups);\n\n\t\treturn NULL;\n\t}\n\n\tgroup_desc = block_group >> EXT4_DESC_PER_BLOCK_BITS(sb);\n\toffset = block_group & (EXT4_DESC_PER_BLOCK(sb) - 1);\n\tif (!sbi->s_group_desc[group_desc]) {\n\t\text4_error(sb, \"Group descriptor not loaded - \"\n\t\t\t   \"block_group = %u, group_desc = %u, desc = %u\",\n\t\t\t   block_group, group_desc, offset);\n\t\treturn NULL;\n\t}\n\n\tdesc = (struct ext4_group_desc *)(\n\t\t(__u8 *)sbi->s_group_desc[group_desc]->b_data +\n\t\toffset * EXT4_DESC_SIZE(sb));\n\tif (bh)\n\t\t*bh = sbi->s_group_desc[group_desc];\n\treturn desc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "EXT4_BLOCKS_PER_GROUP",
          "args": [
            "sb"
          ],
          "line": 3281
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXT4_BLOCKS_PER_GROUP",
          "args": [
            "sb"
          ],
          "line": 3280
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "sbi->s_es->s_first_data_block"
          ],
          "line": 3279
        },
        "resolved": true,
        "details": {
          "function_name": "sle32_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "53-56",
          "snippet": "static inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "EXT4_HAS_RO_COMPAT_FEATURE",
          "args": [
            "sb",
            "EXT4_FEATURE_RO_COMPAT_BIGALLOC"
          ],
          "line": 3275
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_get_groups_count",
          "args": [
            "sb"
          ],
          "line": 3272
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXT4_SB",
          "args": [
            "sb"
          ],
          "line": 3269
        },
        "resolved": true,
        "details": {
          "function_name": "EXT4_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ext4.h",
          "lines": "1356-1359",
          "snippet": "static inline struct ext4_sb_info *EXT4_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include \"extents_status.h\"",
            "#include <linux/compat.h>",
            "#include <linux/falloc.h>",
            "#include <crypto/hash.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/wait.h>",
            "#include <linux/timer.h>",
            "#include <linux/mutex.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/quota.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extents_status.h\"\n#include <linux/compat.h>\n#include <linux/falloc.h>\n#include <crypto/hash.h>\n#include <linux/ratelimit.h>\n#include <linux/percpu_counter.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/wait.h>\n#include <linux/timer.h>\n#include <linux/mutex.h>\n#include <linux/seqlock.h>\n#include <linux/rbtree.h>\n#include <linux/rwsem.h>\n#include <linux/quota.h>\n#include <linux/jbd2.h>\n#include <linux/magic.h>\n#include <linux/blkdev.h>\n#include <linux/types.h>\n\nstatic inline struct ext4_sb_info *EXT4_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"mballoc.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4_extents.h\"\t/* Needed for trace points definition */\n#include \"ext4.h\"\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <asm/uaccess.h>\n#include <linux/cleancache.h>\n#include <linux/crc16.h>\n#include <linux/log2.h>\n#include <linux/ctype.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/random.h>\n#include <linux/vfs.h>\n#include <linux/exportfs.h>\n#include <linux/buffer_head.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/jbd2.h>\n#include <linux/vmalloc.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n#include <linux/string.h>\n#include <linux/module.h>\n\nstatic int ext4_statfs(struct dentry *dentry, struct kstatfs *buf);\nstatic int ext4_unfreeze(struct super_block *sb);\nstatic int ext4_freeze(struct super_block *sb);\nstatic inline int ext2_feature_set_ok(struct super_block *sb);\nstatic inline int ext3_feature_set_ok(struct super_block *sb);\nstatic void ext4_unregister_li_request(struct super_block *sb);\nstatic int ext4_reserve_clusters(struct ext4_sb_info *, ext4_fsblk_t);\n\nstatic int count_overhead(struct super_block *sb, ext4_group_t grp,\n\t\t\t  char *buf)\n{\n\tstruct ext4_sb_info\t*sbi = EXT4_SB(sb);\n\tstruct ext4_group_desc\t*gdp;\n\text4_fsblk_t\t\tfirst_block, last_block, b;\n\text4_group_t\t\ti, ngroups = ext4_get_groups_count(sb);\n\tint\t\t\ts, j, count = 0;\n\n\tif (!EXT4_HAS_RO_COMPAT_FEATURE(sb, EXT4_FEATURE_RO_COMPAT_BIGALLOC))\n\t\treturn (ext4_bg_has_super(sb, grp) + ext4_bg_num_gdb(sb, grp) +\n\t\t\tsbi->s_itb_per_group + 2);\n\n\tfirst_block = le32_to_cpu(sbi->s_es->s_first_data_block) +\n\t\t(grp * EXT4_BLOCKS_PER_GROUP(sb));\n\tlast_block = first_block + EXT4_BLOCKS_PER_GROUP(sb) - 1;\n\tfor (i = 0; i < ngroups; i++) {\n\t\tgdp = ext4_get_group_desc(sb, i, NULL);\n\t\tb = ext4_block_bitmap(sb, gdp);\n\t\tif (b >= first_block && b <= last_block) {\n\t\t\text4_set_bit(EXT4_B2C(sbi, b - first_block), buf);\n\t\t\tcount++;\n\t\t}\n\t\tb = ext4_inode_bitmap(sb, gdp);\n\t\tif (b >= first_block && b <= last_block) {\n\t\t\text4_set_bit(EXT4_B2C(sbi, b - first_block), buf);\n\t\t\tcount++;\n\t\t}\n\t\tb = ext4_inode_table(sb, gdp);\n\t\tif (b >= first_block && b + sbi->s_itb_per_group <= last_block)\n\t\t\tfor (j = 0; j < sbi->s_itb_per_group; j++, b++) {\n\t\t\t\tint c = EXT4_B2C(sbi, b - first_block);\n\t\t\t\text4_set_bit(c, buf);\n\t\t\t\tcount++;\n\t\t\t}\n\t\tif (i != grp)\n\t\t\tcontinue;\n\t\ts = 0;\n\t\tif (ext4_bg_has_super(sb, grp)) {\n\t\t\text4_set_bit(s++, buf);\n\t\t\tcount++;\n\t\t}\n\t\tfor (j = ext4_bg_num_gdb(sb, grp); j > 0; j--) {\n\t\t\text4_set_bit(EXT4_B2C(sbi, s++), buf);\n\t\t\tcount++;\n\t\t}\n\t}\n\tif (!count)\n\t\treturn 0;\n\treturn EXT4_CLUSTERS_PER_GROUP(sb) -\n\t\text4_count_free(buf, EXT4_CLUSTERS_PER_GROUP(sb) / 8);\n}"
  },
  {
    "function_name": "set_journal_csum_feature_set",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/super.c",
    "lines": "3212-3249",
    "snippet": "static int set_journal_csum_feature_set(struct super_block *sb)\n{\n\tint ret = 1;\n\tint compat, incompat;\n\tstruct ext4_sb_info *sbi = EXT4_SB(sb);\n\n\tif (ext4_has_metadata_csum(sb)) {\n\t\t/* journal checksum v3 */\n\t\tcompat = 0;\n\t\tincompat = JBD2_FEATURE_INCOMPAT_CSUM_V3;\n\t} else {\n\t\t/* journal checksum v1 */\n\t\tcompat = JBD2_FEATURE_COMPAT_CHECKSUM;\n\t\tincompat = 0;\n\t}\n\n\tjbd2_journal_clear_features(sbi->s_journal,\n\t\t\tJBD2_FEATURE_COMPAT_CHECKSUM, 0,\n\t\t\tJBD2_FEATURE_INCOMPAT_CSUM_V3 |\n\t\t\tJBD2_FEATURE_INCOMPAT_CSUM_V2);\n\tif (test_opt(sb, JOURNAL_ASYNC_COMMIT)) {\n\t\tret = jbd2_journal_set_features(sbi->s_journal,\n\t\t\t\tcompat, 0,\n\t\t\t\tJBD2_FEATURE_INCOMPAT_ASYNC_COMMIT |\n\t\t\t\tincompat);\n\t} else if (test_opt(sb, JOURNAL_CHECKSUM)) {\n\t\tret = jbd2_journal_set_features(sbi->s_journal,\n\t\t\t\tcompat, 0,\n\t\t\t\tincompat);\n\t\tjbd2_journal_clear_features(sbi->s_journal, 0, 0,\n\t\t\t\tJBD2_FEATURE_INCOMPAT_ASYNC_COMMIT);\n\t} else {\n\t\tjbd2_journal_clear_features(sbi->s_journal, 0, 0,\n\t\t\t\tJBD2_FEATURE_INCOMPAT_ASYNC_COMMIT);\n\t}\n\n\treturn ret;\n}",
    "includes": [
      "#include <trace/events/ext4.h>",
      "#include \"mballoc.h\"",
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"ext4_jbd2.h\"",
      "#include \"ext4_extents.h\"\t/* Needed for trace points definition */",
      "#include \"ext4.h\"",
      "#include <linux/freezer.h>",
      "#include <linux/kthread.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/cleancache.h>",
      "#include <linux/crc16.h>",
      "#include <linux/log2.h>",
      "#include <linux/ctype.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/namei.h>",
      "#include <linux/mount.h>",
      "#include <linux/random.h>",
      "#include <linux/vfs.h>",
      "#include <linux/exportfs.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/parser.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/init.h>",
      "#include <linux/slab.h>",
      "#include <linux/jbd2.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/time.h>",
      "#include <linux/fs.h>",
      "#include <linux/string.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ext4_unfreeze(struct super_block *sb);",
      "static int ext4_freeze(struct super_block *sb);",
      "static inline int ext2_feature_set_ok(struct super_block *sb);",
      "static inline int ext3_feature_set_ok(struct super_block *sb);",
      "static void ext4_unregister_li_request(struct super_block *sb);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "jbd2_journal_clear_features",
          "args": [
            "sbi->s_journal",
            "0",
            "0",
            "JBD2_FEATURE_INCOMPAT_ASYNC_COMMIT"
          ],
          "line": 3244
        },
        "resolved": true,
        "details": {
          "function_name": "jbd2_journal_clear_features",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd2/journal.c",
          "lines": "1889-1902",
          "snippet": "void jbd2_journal_clear_features(journal_t *journal, unsigned long compat,\n\t\t\t\tunsigned long ro, unsigned long incompat)\n{\n\tjournal_superblock_t *sb;\n\n\tjbd_debug(1, \"Clear features 0x%lx/0x%lx/0x%lx\\n\",\n\t\t  compat, ro, incompat);\n\n\tsb = journal->j_superblock;\n\n\tsb->s_feature_compat    &= ~cpu_to_be32(compat);\n\tsb->s_feature_ro_compat &= ~cpu_to_be32(ro);\n\tsb->s_feature_incompat  &= ~cpu_to_be32(incompat);\n}",
          "includes": [
            "#include <asm/page.h>",
            "#include <asm/uaccess.h>",
            "#include <trace/events/jbd2.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/bitops.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/log2.h>",
            "#include <linux/hash.h>",
            "#include <linux/math64.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/poison.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <trace/events/jbd2.h>\n#include <linux/ratelimit.h>\n#include <linux/bitops.h>\n#include <linux/backing-dev.h>\n#include <linux/vmalloc.h>\n#include <linux/log2.h>\n#include <linux/hash.h>\n#include <linux/math64.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/poison.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/freezer.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd2.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/module.h>\n\nvoid jbd2_journal_clear_features(journal_t *journal, unsigned long compat,\n\t\t\t\tunsigned long ro, unsigned long incompat)\n{\n\tjournal_superblock_t *sb;\n\n\tjbd_debug(1, \"Clear features 0x%lx/0x%lx/0x%lx\\n\",\n\t\t  compat, ro, incompat);\n\n\tsb = journal->j_superblock;\n\n\tsb->s_feature_compat    &= ~cpu_to_be32(compat);\n\tsb->s_feature_ro_compat &= ~cpu_to_be32(ro);\n\tsb->s_feature_incompat  &= ~cpu_to_be32(incompat);\n}"
        }
      },
      {
        "call_info": {
          "callee": "jbd2_journal_set_features",
          "args": [
            "sbi->s_journal",
            "compat",
            "0",
            "incompat"
          ],
          "line": 3238
        },
        "resolved": true,
        "details": {
          "function_name": "jbd2_journal_set_features",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd2/journal.c",
          "lines": "1808-1876",
          "snippet": "int jbd2_journal_set_features (journal_t *journal, unsigned long compat,\n\t\t\t  unsigned long ro, unsigned long incompat)\n{\n#define INCOMPAT_FEATURE_ON(f) \\\n\t\t((incompat & (f)) && !(sb->s_feature_incompat & cpu_to_be32(f)))\n#define COMPAT_FEATURE_ON(f) \\\n\t\t((compat & (f)) && !(sb->s_feature_compat & cpu_to_be32(f)))\n\tjournal_superblock_t *sb;\n\n\tif (jbd2_journal_check_used_features(journal, compat, ro, incompat))\n\t\treturn 1;\n\n\tif (!jbd2_journal_check_available_features(journal, compat, ro, incompat))\n\t\treturn 0;\n\n\t/* If enabling v2 checksums, turn on v3 instead */\n\tif (incompat & JBD2_FEATURE_INCOMPAT_CSUM_V2) {\n\t\tincompat &= ~JBD2_FEATURE_INCOMPAT_CSUM_V2;\n\t\tincompat |= JBD2_FEATURE_INCOMPAT_CSUM_V3;\n\t}\n\n\t/* Asking for checksumming v3 and v1?  Only give them v3. */\n\tif (incompat & JBD2_FEATURE_INCOMPAT_CSUM_V3 &&\n\t    compat & JBD2_FEATURE_COMPAT_CHECKSUM)\n\t\tcompat &= ~JBD2_FEATURE_COMPAT_CHECKSUM;\n\n\tjbd_debug(1, \"Setting new features 0x%lx/0x%lx/0x%lx\\n\",\n\t\t  compat, ro, incompat);\n\n\tsb = journal->j_superblock;\n\n\t/* If enabling v3 checksums, update superblock */\n\tif (INCOMPAT_FEATURE_ON(JBD2_FEATURE_INCOMPAT_CSUM_V3)) {\n\t\tsb->s_checksum_type = JBD2_CRC32C_CHKSUM;\n\t\tsb->s_feature_compat &=\n\t\t\t~cpu_to_be32(JBD2_FEATURE_COMPAT_CHECKSUM);\n\n\t\t/* Load the checksum driver */\n\t\tif (journal->j_chksum_driver == NULL) {\n\t\t\tjournal->j_chksum_driver = crypto_alloc_shash(\"crc32c\",\n\t\t\t\t\t\t\t\t      0, 0);\n\t\t\tif (IS_ERR(journal->j_chksum_driver)) {\n\t\t\t\tprintk(KERN_ERR \"JBD2: Cannot load crc32c \"\n\t\t\t\t       \"driver.\\n\");\n\t\t\t\tjournal->j_chksum_driver = NULL;\n\t\t\t\treturn 0;\n\t\t\t}\n\n\t\t\t/* Precompute checksum seed for all metadata */\n\t\t\tjournal->j_csum_seed = jbd2_chksum(journal, ~0,\n\t\t\t\t\t\t\t   sb->s_uuid,\n\t\t\t\t\t\t\t   sizeof(sb->s_uuid));\n\t\t}\n\t}\n\n\t/* If enabling v1 checksums, downgrade superblock */\n\tif (COMPAT_FEATURE_ON(JBD2_FEATURE_COMPAT_CHECKSUM))\n\t\tsb->s_feature_incompat &=\n\t\t\t~cpu_to_be32(JBD2_FEATURE_INCOMPAT_CSUM_V2 |\n\t\t\t\t     JBD2_FEATURE_INCOMPAT_CSUM_V3);\n\n\tsb->s_feature_compat    |= cpu_to_be32(compat);\n\tsb->s_feature_ro_compat |= cpu_to_be32(ro);\n\tsb->s_feature_incompat  |= cpu_to_be32(incompat);\n\n\treturn 1;\n#undef COMPAT_FEATURE_ON\n#undef INCOMPAT_FEATURE_ON\n}",
          "includes": [
            "#include <asm/page.h>",
            "#include <asm/uaccess.h>",
            "#include <trace/events/jbd2.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/bitops.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/log2.h>",
            "#include <linux/hash.h>",
            "#include <linux/math64.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/poison.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <trace/events/jbd2.h>\n#include <linux/ratelimit.h>\n#include <linux/bitops.h>\n#include <linux/backing-dev.h>\n#include <linux/vmalloc.h>\n#include <linux/log2.h>\n#include <linux/hash.h>\n#include <linux/math64.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/poison.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/freezer.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd2.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/module.h>\n\nint jbd2_journal_set_features (journal_t *journal, unsigned long compat,\n\t\t\t  unsigned long ro, unsigned long incompat)\n{\n#define INCOMPAT_FEATURE_ON(f) \\\n\t\t((incompat & (f)) && !(sb->s_feature_incompat & cpu_to_be32(f)))\n#define COMPAT_FEATURE_ON(f) \\\n\t\t((compat & (f)) && !(sb->s_feature_compat & cpu_to_be32(f)))\n\tjournal_superblock_t *sb;\n\n\tif (jbd2_journal_check_used_features(journal, compat, ro, incompat))\n\t\treturn 1;\n\n\tif (!jbd2_journal_check_available_features(journal, compat, ro, incompat))\n\t\treturn 0;\n\n\t/* If enabling v2 checksums, turn on v3 instead */\n\tif (incompat & JBD2_FEATURE_INCOMPAT_CSUM_V2) {\n\t\tincompat &= ~JBD2_FEATURE_INCOMPAT_CSUM_V2;\n\t\tincompat |= JBD2_FEATURE_INCOMPAT_CSUM_V3;\n\t}\n\n\t/* Asking for checksumming v3 and v1?  Only give them v3. */\n\tif (incompat & JBD2_FEATURE_INCOMPAT_CSUM_V3 &&\n\t    compat & JBD2_FEATURE_COMPAT_CHECKSUM)\n\t\tcompat &= ~JBD2_FEATURE_COMPAT_CHECKSUM;\n\n\tjbd_debug(1, \"Setting new features 0x%lx/0x%lx/0x%lx\\n\",\n\t\t  compat, ro, incompat);\n\n\tsb = journal->j_superblock;\n\n\t/* If enabling v3 checksums, update superblock */\n\tif (INCOMPAT_FEATURE_ON(JBD2_FEATURE_INCOMPAT_CSUM_V3)) {\n\t\tsb->s_checksum_type = JBD2_CRC32C_CHKSUM;\n\t\tsb->s_feature_compat &=\n\t\t\t~cpu_to_be32(JBD2_FEATURE_COMPAT_CHECKSUM);\n\n\t\t/* Load the checksum driver */\n\t\tif (journal->j_chksum_driver == NULL) {\n\t\t\tjournal->j_chksum_driver = crypto_alloc_shash(\"crc32c\",\n\t\t\t\t\t\t\t\t      0, 0);\n\t\t\tif (IS_ERR(journal->j_chksum_driver)) {\n\t\t\t\tprintk(KERN_ERR \"JBD2: Cannot load crc32c \"\n\t\t\t\t       \"driver.\\n\");\n\t\t\t\tjournal->j_chksum_driver = NULL;\n\t\t\t\treturn 0;\n\t\t\t}\n\n\t\t\t/* Precompute checksum seed for all metadata */\n\t\t\tjournal->j_csum_seed = jbd2_chksum(journal, ~0,\n\t\t\t\t\t\t\t   sb->s_uuid,\n\t\t\t\t\t\t\t   sizeof(sb->s_uuid));\n\t\t}\n\t}\n\n\t/* If enabling v1 checksums, downgrade superblock */\n\tif (COMPAT_FEATURE_ON(JBD2_FEATURE_COMPAT_CHECKSUM))\n\t\tsb->s_feature_incompat &=\n\t\t\t~cpu_to_be32(JBD2_FEATURE_INCOMPAT_CSUM_V2 |\n\t\t\t\t     JBD2_FEATURE_INCOMPAT_CSUM_V3);\n\n\tsb->s_feature_compat    |= cpu_to_be32(compat);\n\tsb->s_feature_ro_compat |= cpu_to_be32(ro);\n\tsb->s_feature_incompat  |= cpu_to_be32(incompat);\n\n\treturn 1;\n#undef COMPAT_FEATURE_ON\n#undef INCOMPAT_FEATURE_ON\n}"
        }
      },
      {
        "call_info": {
          "callee": "test_opt",
          "args": [
            "sb",
            "JOURNAL_CHECKSUM"
          ],
          "line": 3237
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_opt",
          "args": [
            "sb",
            "JOURNAL_ASYNC_COMMIT"
          ],
          "line": 3232
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_has_metadata_csum",
          "args": [
            "sb"
          ],
          "line": 3218
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXT4_SB",
          "args": [
            "sb"
          ],
          "line": 3216
        },
        "resolved": true,
        "details": {
          "function_name": "EXT4_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ext4.h",
          "lines": "1356-1359",
          "snippet": "static inline struct ext4_sb_info *EXT4_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include \"extents_status.h\"",
            "#include <linux/compat.h>",
            "#include <linux/falloc.h>",
            "#include <crypto/hash.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/wait.h>",
            "#include <linux/timer.h>",
            "#include <linux/mutex.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/quota.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extents_status.h\"\n#include <linux/compat.h>\n#include <linux/falloc.h>\n#include <crypto/hash.h>\n#include <linux/ratelimit.h>\n#include <linux/percpu_counter.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/wait.h>\n#include <linux/timer.h>\n#include <linux/mutex.h>\n#include <linux/seqlock.h>\n#include <linux/rbtree.h>\n#include <linux/rwsem.h>\n#include <linux/quota.h>\n#include <linux/jbd2.h>\n#include <linux/magic.h>\n#include <linux/blkdev.h>\n#include <linux/types.h>\n\nstatic inline struct ext4_sb_info *EXT4_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"mballoc.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4_extents.h\"\t/* Needed for trace points definition */\n#include \"ext4.h\"\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <asm/uaccess.h>\n#include <linux/cleancache.h>\n#include <linux/crc16.h>\n#include <linux/log2.h>\n#include <linux/ctype.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/random.h>\n#include <linux/vfs.h>\n#include <linux/exportfs.h>\n#include <linux/buffer_head.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/jbd2.h>\n#include <linux/vmalloc.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n#include <linux/string.h>\n#include <linux/module.h>\n\nstatic int ext4_unfreeze(struct super_block *sb);\nstatic int ext4_freeze(struct super_block *sb);\nstatic inline int ext2_feature_set_ok(struct super_block *sb);\nstatic inline int ext3_feature_set_ok(struct super_block *sb);\nstatic void ext4_unregister_li_request(struct super_block *sb);\n\nstatic int set_journal_csum_feature_set(struct super_block *sb)\n{\n\tint ret = 1;\n\tint compat, incompat;\n\tstruct ext4_sb_info *sbi = EXT4_SB(sb);\n\n\tif (ext4_has_metadata_csum(sb)) {\n\t\t/* journal checksum v3 */\n\t\tcompat = 0;\n\t\tincompat = JBD2_FEATURE_INCOMPAT_CSUM_V3;\n\t} else {\n\t\t/* journal checksum v1 */\n\t\tcompat = JBD2_FEATURE_COMPAT_CHECKSUM;\n\t\tincompat = 0;\n\t}\n\n\tjbd2_journal_clear_features(sbi->s_journal,\n\t\t\tJBD2_FEATURE_COMPAT_CHECKSUM, 0,\n\t\t\tJBD2_FEATURE_INCOMPAT_CSUM_V3 |\n\t\t\tJBD2_FEATURE_INCOMPAT_CSUM_V2);\n\tif (test_opt(sb, JOURNAL_ASYNC_COMMIT)) {\n\t\tret = jbd2_journal_set_features(sbi->s_journal,\n\t\t\t\tcompat, 0,\n\t\t\t\tJBD2_FEATURE_INCOMPAT_ASYNC_COMMIT |\n\t\t\t\tincompat);\n\t} else if (test_opt(sb, JOURNAL_CHECKSUM)) {\n\t\tret = jbd2_journal_set_features(sbi->s_journal,\n\t\t\t\tcompat, 0,\n\t\t\t\tincompat);\n\t\tjbd2_journal_clear_features(sbi->s_journal, 0, 0,\n\t\t\t\tJBD2_FEATURE_INCOMPAT_ASYNC_COMMIT);\n\t} else {\n\t\tjbd2_journal_clear_features(sbi->s_journal, 0, 0,\n\t\t\t\tJBD2_FEATURE_INCOMPAT_ASYNC_COMMIT);\n\t}\n\n\treturn ret;\n}"
  },
  {
    "function_name": "ext4_destroy_lazyinit_thread",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/super.c",
    "lines": "3200-3210",
    "snippet": "static void ext4_destroy_lazyinit_thread(void)\n{\n\t/*\n\t * If thread exited earlier\n\t * there's nothing to be done.\n\t */\n\tif (!ext4_li_info || !ext4_lazyinit_task)\n\t\treturn;\n\n\tkthread_stop(ext4_lazyinit_task);\n}",
    "includes": [
      "#include <trace/events/ext4.h>",
      "#include \"mballoc.h\"",
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"ext4_jbd2.h\"",
      "#include \"ext4_extents.h\"\t/* Needed for trace points definition */",
      "#include \"ext4.h\"",
      "#include <linux/freezer.h>",
      "#include <linux/kthread.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/cleancache.h>",
      "#include <linux/crc16.h>",
      "#include <linux/log2.h>",
      "#include <linux/ctype.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/namei.h>",
      "#include <linux/mount.h>",
      "#include <linux/random.h>",
      "#include <linux/vfs.h>",
      "#include <linux/exportfs.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/parser.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/init.h>",
      "#include <linux/slab.h>",
      "#include <linux/jbd2.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/time.h>",
      "#include <linux/fs.h>",
      "#include <linux/string.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct ext4_lazy_init *ext4_li_info;",
      "static void ext4_destroy_lazyinit_thread(void);",
      "static struct task_struct *ext4_lazyinit_task;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kthread_stop",
          "args": [
            "ext4_lazyinit_task"
          ],
          "line": 3209
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"mballoc.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4_extents.h\"\t/* Needed for trace points definition */\n#include \"ext4.h\"\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <asm/uaccess.h>\n#include <linux/cleancache.h>\n#include <linux/crc16.h>\n#include <linux/log2.h>\n#include <linux/ctype.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/random.h>\n#include <linux/vfs.h>\n#include <linux/exportfs.h>\n#include <linux/buffer_head.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/jbd2.h>\n#include <linux/vmalloc.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n#include <linux/string.h>\n#include <linux/module.h>\n\nstatic struct ext4_lazy_init *ext4_li_info;\nstatic void ext4_destroy_lazyinit_thread(void);\nstatic struct task_struct *ext4_lazyinit_task;\n\nstatic void ext4_destroy_lazyinit_thread(void)\n{\n\t/*\n\t * If thread exited earlier\n\t * there's nothing to be done.\n\t */\n\tif (!ext4_li_info || !ext4_lazyinit_task)\n\t\treturn;\n\n\tkthread_stop(ext4_lazyinit_task);\n}"
  },
  {
    "function_name": "ext4_register_li_request",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/super.c",
    "lines": "3137-3194",
    "snippet": "int ext4_register_li_request(struct super_block *sb,\n\t\t\t     ext4_group_t first_not_zeroed)\n{\n\tstruct ext4_sb_info *sbi = EXT4_SB(sb);\n\tstruct ext4_li_request *elr = NULL;\n\text4_group_t ngroups = EXT4_SB(sb)->s_groups_count;\n\tint ret = 0;\n\n\tmutex_lock(&ext4_li_mtx);\n\tif (sbi->s_li_request != NULL) {\n\t\t/*\n\t\t * Reset timeout so it can be computed again, because\n\t\t * s_li_wait_mult might have changed.\n\t\t */\n\t\tsbi->s_li_request->lr_timeout = 0;\n\t\tgoto out;\n\t}\n\n\tif (first_not_zeroed == ngroups ||\n\t    (sb->s_flags & MS_RDONLY) ||\n\t    !test_opt(sb, INIT_INODE_TABLE))\n\t\tgoto out;\n\n\telr = ext4_li_request_new(sb, first_not_zeroed);\n\tif (!elr) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tif (NULL == ext4_li_info) {\n\t\tret = ext4_li_info_new();\n\t\tif (ret)\n\t\t\tgoto out;\n\t}\n\n\tmutex_lock(&ext4_li_info->li_list_mtx);\n\tlist_add(&elr->lr_request, &ext4_li_info->li_request_list);\n\tmutex_unlock(&ext4_li_info->li_list_mtx);\n\n\tsbi->s_li_request = elr;\n\t/*\n\t * set elr to NULL here since it has been inserted to\n\t * the request_list and the removal and free of it is\n\t * handled by ext4_clear_request_list from now on.\n\t */\n\telr = NULL;\n\n\tif (!(ext4_li_info->li_state & EXT4_LAZYINIT_RUNNING)) {\n\t\tret = ext4_run_lazyinit_thread();\n\t\tif (ret)\n\t\t\tgoto out;\n\t}\nout:\n\tmutex_unlock(&ext4_li_mtx);\n\tif (ret)\n\t\tkfree(elr);\n\treturn ret;\n}",
    "includes": [
      "#include <trace/events/ext4.h>",
      "#include \"mballoc.h\"",
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"ext4_jbd2.h\"",
      "#include \"ext4_extents.h\"\t/* Needed for trace points definition */",
      "#include \"ext4.h\"",
      "#include <linux/freezer.h>",
      "#include <linux/kthread.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/cleancache.h>",
      "#include <linux/crc16.h>",
      "#include <linux/log2.h>",
      "#include <linux/ctype.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/namei.h>",
      "#include <linux/mount.h>",
      "#include <linux/random.h>",
      "#include <linux/vfs.h>",
      "#include <linux/exportfs.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/parser.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/init.h>",
      "#include <linux/slab.h>",
      "#include <linux/jbd2.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/time.h>",
      "#include <linux/fs.h>",
      "#include <linux/string.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct ext4_lazy_init *ext4_li_info;",
      "static struct mutex ext4_li_mtx;",
      "static int ext4_unfreeze(struct super_block *sb);",
      "static int ext4_freeze(struct super_block *sb);",
      "static inline int ext2_feature_set_ok(struct super_block *sb);",
      "static inline int ext3_feature_set_ok(struct super_block *sb);",
      "static void ext4_unregister_li_request(struct super_block *sb);",
      "static void ext4_clear_request_list(void);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "elr"
          ],
          "line": 3192
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&ext4_li_mtx"
          ],
          "line": 3190
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_run_lazyinit_thread",
          "args": [],
          "line": 3185
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_run_lazyinit_thread",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/super.c",
          "lines": "3054-3070",
          "snippet": "static int ext4_run_lazyinit_thread(void)\n{\n\text4_lazyinit_task = kthread_run(ext4_lazyinit_thread,\n\t\t\t\t\t ext4_li_info, \"ext4lazyinit\");\n\tif (IS_ERR(ext4_lazyinit_task)) {\n\t\tint err = PTR_ERR(ext4_lazyinit_task);\n\t\text4_clear_request_list();\n\t\tkfree(ext4_li_info);\n\t\text4_li_info = NULL;\n\t\tprintk(KERN_CRIT \"EXT4-fs: error %d creating inode table \"\n\t\t\t\t \"initialization thread\\n\",\n\t\t\t\t err);\n\t\treturn err;\n\t}\n\text4_li_info->li_state |= EXT4_LAZYINIT_RUNNING;\n\treturn 0;\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"mballoc.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include \"ext4_extents.h\"\t/* Needed for trace points definition */",
            "#include \"ext4.h\"",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/crc16.h>",
            "#include <linux/log2.h>",
            "#include <linux/ctype.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/random.h>",
            "#include <linux/vfs.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/parser.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/time.h>",
            "#include <linux/fs.h>",
            "#include <linux/string.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct ext4_lazy_init *ext4_li_info;",
            "static void ext4_clear_request_list(void);",
            "static struct task_struct *ext4_lazyinit_task;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"mballoc.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4_extents.h\"\t/* Needed for trace points definition */\n#include \"ext4.h\"\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <asm/uaccess.h>\n#include <linux/cleancache.h>\n#include <linux/crc16.h>\n#include <linux/log2.h>\n#include <linux/ctype.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/random.h>\n#include <linux/vfs.h>\n#include <linux/exportfs.h>\n#include <linux/buffer_head.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/jbd2.h>\n#include <linux/vmalloc.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n#include <linux/string.h>\n#include <linux/module.h>\n\nstatic struct ext4_lazy_init *ext4_li_info;\nstatic void ext4_clear_request_list(void);\nstatic struct task_struct *ext4_lazyinit_task;\n\nstatic int ext4_run_lazyinit_thread(void)\n{\n\text4_lazyinit_task = kthread_run(ext4_lazyinit_thread,\n\t\t\t\t\t ext4_li_info, \"ext4lazyinit\");\n\tif (IS_ERR(ext4_lazyinit_task)) {\n\t\tint err = PTR_ERR(ext4_lazyinit_task);\n\t\text4_clear_request_list();\n\t\tkfree(ext4_li_info);\n\t\text4_li_info = NULL;\n\t\tprintk(KERN_CRIT \"EXT4-fs: error %d creating inode table \"\n\t\t\t\t \"initialization thread\\n\",\n\t\t\t\t err);\n\t\treturn err;\n\t}\n\text4_li_info->li_state |= EXT4_LAZYINIT_RUNNING;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&ext4_li_info->li_list_mtx"
          ],
          "line": 3174
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_add",
          "args": [
            "&elr->lr_request",
            "&ext4_li_info->li_request_list"
          ],
          "line": 3173
        },
        "resolved": true,
        "details": {
          "function_name": "simple_xattr_list_add",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xattr.c",
          "lines": "966-972",
          "snippet": "void simple_xattr_list_add(struct simple_xattrs *xattrs,\n\t\t\t   struct simple_xattr *new_xattr)\n{\n\tspin_lock(&xattrs->lock);\n\tlist_add(&new_xattr->list, &xattrs->head);\n\tspin_unlock(&xattrs->lock);\n}",
          "includes": [
            "#include <asm/uaccess.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/audit.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/evm.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/xattr.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/uaccess.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/vmalloc.h>\n#include <linux/audit.h>\n#include <linux/fsnotify.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n#include <linux/evm.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/xattr.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nvoid simple_xattr_list_add(struct simple_xattrs *xattrs,\n\t\t\t   struct simple_xattr *new_xattr)\n{\n\tspin_lock(&xattrs->lock);\n\tlist_add(&new_xattr->list, &xattrs->head);\n\tspin_unlock(&xattrs->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&ext4_li_info->li_list_mtx"
          ],
          "line": 3172
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_li_info_new",
          "args": [],
          "line": 3167
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_li_info_new",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/super.c",
          "lines": "3095-3111",
          "snippet": "static int ext4_li_info_new(void)\n{\n\tstruct ext4_lazy_init *eli = NULL;\n\n\teli = kzalloc(sizeof(*eli), GFP_KERNEL);\n\tif (!eli)\n\t\treturn -ENOMEM;\n\n\tINIT_LIST_HEAD(&eli->li_request_list);\n\tmutex_init(&eli->li_list_mtx);\n\n\teli->li_state |= EXT4_LAZYINIT_QUIT;\n\n\text4_li_info = eli;\n\n\treturn 0;\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"mballoc.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include \"ext4_extents.h\"\t/* Needed for trace points definition */",
            "#include \"ext4.h\"",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/crc16.h>",
            "#include <linux/log2.h>",
            "#include <linux/ctype.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/random.h>",
            "#include <linux/vfs.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/parser.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/time.h>",
            "#include <linux/fs.h>",
            "#include <linux/string.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct ext4_lazy_init *ext4_li_info;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"mballoc.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4_extents.h\"\t/* Needed for trace points definition */\n#include \"ext4.h\"\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <asm/uaccess.h>\n#include <linux/cleancache.h>\n#include <linux/crc16.h>\n#include <linux/log2.h>\n#include <linux/ctype.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/random.h>\n#include <linux/vfs.h>\n#include <linux/exportfs.h>\n#include <linux/buffer_head.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/jbd2.h>\n#include <linux/vmalloc.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n#include <linux/string.h>\n#include <linux/module.h>\n\nstatic struct ext4_lazy_init *ext4_li_info;\n\nstatic int ext4_li_info_new(void)\n{\n\tstruct ext4_lazy_init *eli = NULL;\n\n\teli = kzalloc(sizeof(*eli), GFP_KERNEL);\n\tif (!eli)\n\t\treturn -ENOMEM;\n\n\tINIT_LIST_HEAD(&eli->li_request_list);\n\tmutex_init(&eli->li_list_mtx);\n\n\teli->li_state |= EXT4_LAZYINIT_QUIT;\n\n\text4_li_info = eli;\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_li_request_new",
          "args": [
            "sb",
            "first_not_zeroed"
          ],
          "line": 3160
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_li_request_new",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/super.c",
          "lines": "3113-3135",
          "snippet": "static struct ext4_li_request *ext4_li_request_new(struct super_block *sb,\n\t\t\t\t\t    ext4_group_t start)\n{\n\tstruct ext4_sb_info *sbi = EXT4_SB(sb);\n\tstruct ext4_li_request *elr;\n\n\telr = kzalloc(sizeof(*elr), GFP_KERNEL);\n\tif (!elr)\n\t\treturn NULL;\n\n\telr->lr_super = sb;\n\telr->lr_sbi = sbi;\n\telr->lr_next_group = start;\n\n\t/*\n\t * Randomize first schedule time of the request to\n\t * spread the inode table initialization requests\n\t * better.\n\t */\n\telr->lr_next_sched = jiffies + (prandom_u32() %\n\t\t\t\t(EXT4_DEF_LI_MAX_START_DELAY * HZ));\n\treturn elr;\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"mballoc.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include \"ext4_extents.h\"\t/* Needed for trace points definition */",
            "#include \"ext4.h\"",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/crc16.h>",
            "#include <linux/log2.h>",
            "#include <linux/ctype.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/random.h>",
            "#include <linux/vfs.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/parser.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/time.h>",
            "#include <linux/fs.h>",
            "#include <linux/string.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ext4_unfreeze(struct super_block *sb);",
            "static int ext4_freeze(struct super_block *sb);",
            "static inline int ext2_feature_set_ok(struct super_block *sb);",
            "static inline int ext3_feature_set_ok(struct super_block *sb);",
            "static void ext4_unregister_li_request(struct super_block *sb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"mballoc.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4_extents.h\"\t/* Needed for trace points definition */\n#include \"ext4.h\"\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <asm/uaccess.h>\n#include <linux/cleancache.h>\n#include <linux/crc16.h>\n#include <linux/log2.h>\n#include <linux/ctype.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/random.h>\n#include <linux/vfs.h>\n#include <linux/exportfs.h>\n#include <linux/buffer_head.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/jbd2.h>\n#include <linux/vmalloc.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n#include <linux/string.h>\n#include <linux/module.h>\n\nstatic int ext4_unfreeze(struct super_block *sb);\nstatic int ext4_freeze(struct super_block *sb);\nstatic inline int ext2_feature_set_ok(struct super_block *sb);\nstatic inline int ext3_feature_set_ok(struct super_block *sb);\nstatic void ext4_unregister_li_request(struct super_block *sb);\n\nstatic struct ext4_li_request *ext4_li_request_new(struct super_block *sb,\n\t\t\t\t\t    ext4_group_t start)\n{\n\tstruct ext4_sb_info *sbi = EXT4_SB(sb);\n\tstruct ext4_li_request *elr;\n\n\telr = kzalloc(sizeof(*elr), GFP_KERNEL);\n\tif (!elr)\n\t\treturn NULL;\n\n\telr->lr_super = sb;\n\telr->lr_sbi = sbi;\n\telr->lr_next_group = start;\n\n\t/*\n\t * Randomize first schedule time of the request to\n\t * spread the inode table initialization requests\n\t * better.\n\t */\n\telr->lr_next_sched = jiffies + (prandom_u32() %\n\t\t\t\t(EXT4_DEF_LI_MAX_START_DELAY * HZ));\n\treturn elr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "test_opt",
          "args": [
            "sb",
            "INIT_INODE_TABLE"
          ],
          "line": 3157
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&ext4_li_mtx"
          ],
          "line": 3145
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXT4_SB",
          "args": [
            "sb"
          ],
          "line": 3142
        },
        "resolved": true,
        "details": {
          "function_name": "EXT4_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ext4.h",
          "lines": "1356-1359",
          "snippet": "static inline struct ext4_sb_info *EXT4_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include \"extents_status.h\"",
            "#include <linux/compat.h>",
            "#include <linux/falloc.h>",
            "#include <crypto/hash.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/wait.h>",
            "#include <linux/timer.h>",
            "#include <linux/mutex.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/quota.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extents_status.h\"\n#include <linux/compat.h>\n#include <linux/falloc.h>\n#include <crypto/hash.h>\n#include <linux/ratelimit.h>\n#include <linux/percpu_counter.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/wait.h>\n#include <linux/timer.h>\n#include <linux/mutex.h>\n#include <linux/seqlock.h>\n#include <linux/rbtree.h>\n#include <linux/rwsem.h>\n#include <linux/quota.h>\n#include <linux/jbd2.h>\n#include <linux/magic.h>\n#include <linux/blkdev.h>\n#include <linux/types.h>\n\nstatic inline struct ext4_sb_info *EXT4_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"mballoc.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4_extents.h\"\t/* Needed for trace points definition */\n#include \"ext4.h\"\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <asm/uaccess.h>\n#include <linux/cleancache.h>\n#include <linux/crc16.h>\n#include <linux/log2.h>\n#include <linux/ctype.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/random.h>\n#include <linux/vfs.h>\n#include <linux/exportfs.h>\n#include <linux/buffer_head.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/jbd2.h>\n#include <linux/vmalloc.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n#include <linux/string.h>\n#include <linux/module.h>\n\nstatic struct ext4_lazy_init *ext4_li_info;\nstatic struct mutex ext4_li_mtx;\nstatic int ext4_unfreeze(struct super_block *sb);\nstatic int ext4_freeze(struct super_block *sb);\nstatic inline int ext2_feature_set_ok(struct super_block *sb);\nstatic inline int ext3_feature_set_ok(struct super_block *sb);\nstatic void ext4_unregister_li_request(struct super_block *sb);\nstatic void ext4_clear_request_list(void);\n\nint ext4_register_li_request(struct super_block *sb,\n\t\t\t     ext4_group_t first_not_zeroed)\n{\n\tstruct ext4_sb_info *sbi = EXT4_SB(sb);\n\tstruct ext4_li_request *elr = NULL;\n\text4_group_t ngroups = EXT4_SB(sb)->s_groups_count;\n\tint ret = 0;\n\n\tmutex_lock(&ext4_li_mtx);\n\tif (sbi->s_li_request != NULL) {\n\t\t/*\n\t\t * Reset timeout so it can be computed again, because\n\t\t * s_li_wait_mult might have changed.\n\t\t */\n\t\tsbi->s_li_request->lr_timeout = 0;\n\t\tgoto out;\n\t}\n\n\tif (first_not_zeroed == ngroups ||\n\t    (sb->s_flags & MS_RDONLY) ||\n\t    !test_opt(sb, INIT_INODE_TABLE))\n\t\tgoto out;\n\n\telr = ext4_li_request_new(sb, first_not_zeroed);\n\tif (!elr) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tif (NULL == ext4_li_info) {\n\t\tret = ext4_li_info_new();\n\t\tif (ret)\n\t\t\tgoto out;\n\t}\n\n\tmutex_lock(&ext4_li_info->li_list_mtx);\n\tlist_add(&elr->lr_request, &ext4_li_info->li_request_list);\n\tmutex_unlock(&ext4_li_info->li_list_mtx);\n\n\tsbi->s_li_request = elr;\n\t/*\n\t * set elr to NULL here since it has been inserted to\n\t * the request_list and the removal and free of it is\n\t * handled by ext4_clear_request_list from now on.\n\t */\n\telr = NULL;\n\n\tif (!(ext4_li_info->li_state & EXT4_LAZYINIT_RUNNING)) {\n\t\tret = ext4_run_lazyinit_thread();\n\t\tif (ret)\n\t\t\tgoto out;\n\t}\nout:\n\tmutex_unlock(&ext4_li_mtx);\n\tif (ret)\n\t\tkfree(elr);\n\treturn ret;\n}"
  },
  {
    "function_name": "ext4_li_request_new",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/super.c",
    "lines": "3113-3135",
    "snippet": "static struct ext4_li_request *ext4_li_request_new(struct super_block *sb,\n\t\t\t\t\t    ext4_group_t start)\n{\n\tstruct ext4_sb_info *sbi = EXT4_SB(sb);\n\tstruct ext4_li_request *elr;\n\n\telr = kzalloc(sizeof(*elr), GFP_KERNEL);\n\tif (!elr)\n\t\treturn NULL;\n\n\telr->lr_super = sb;\n\telr->lr_sbi = sbi;\n\telr->lr_next_group = start;\n\n\t/*\n\t * Randomize first schedule time of the request to\n\t * spread the inode table initialization requests\n\t * better.\n\t */\n\telr->lr_next_sched = jiffies + (prandom_u32() %\n\t\t\t\t(EXT4_DEF_LI_MAX_START_DELAY * HZ));\n\treturn elr;\n}",
    "includes": [
      "#include <trace/events/ext4.h>",
      "#include \"mballoc.h\"",
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"ext4_jbd2.h\"",
      "#include \"ext4_extents.h\"\t/* Needed for trace points definition */",
      "#include \"ext4.h\"",
      "#include <linux/freezer.h>",
      "#include <linux/kthread.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/cleancache.h>",
      "#include <linux/crc16.h>",
      "#include <linux/log2.h>",
      "#include <linux/ctype.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/namei.h>",
      "#include <linux/mount.h>",
      "#include <linux/random.h>",
      "#include <linux/vfs.h>",
      "#include <linux/exportfs.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/parser.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/init.h>",
      "#include <linux/slab.h>",
      "#include <linux/jbd2.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/time.h>",
      "#include <linux/fs.h>",
      "#include <linux/string.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ext4_unfreeze(struct super_block *sb);",
      "static int ext4_freeze(struct super_block *sb);",
      "static inline int ext2_feature_set_ok(struct super_block *sb);",
      "static inline int ext3_feature_set_ok(struct super_block *sb);",
      "static void ext4_unregister_li_request(struct super_block *sb);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "prandom_u32",
          "args": [],
          "line": 3132
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "sizeof(*elr)",
            "GFP_KERNEL"
          ],
          "line": 3119
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXT4_SB",
          "args": [
            "sb"
          ],
          "line": 3116
        },
        "resolved": true,
        "details": {
          "function_name": "EXT4_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ext4.h",
          "lines": "1356-1359",
          "snippet": "static inline struct ext4_sb_info *EXT4_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include \"extents_status.h\"",
            "#include <linux/compat.h>",
            "#include <linux/falloc.h>",
            "#include <crypto/hash.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/wait.h>",
            "#include <linux/timer.h>",
            "#include <linux/mutex.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/quota.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extents_status.h\"\n#include <linux/compat.h>\n#include <linux/falloc.h>\n#include <crypto/hash.h>\n#include <linux/ratelimit.h>\n#include <linux/percpu_counter.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/wait.h>\n#include <linux/timer.h>\n#include <linux/mutex.h>\n#include <linux/seqlock.h>\n#include <linux/rbtree.h>\n#include <linux/rwsem.h>\n#include <linux/quota.h>\n#include <linux/jbd2.h>\n#include <linux/magic.h>\n#include <linux/blkdev.h>\n#include <linux/types.h>\n\nstatic inline struct ext4_sb_info *EXT4_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"mballoc.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4_extents.h\"\t/* Needed for trace points definition */\n#include \"ext4.h\"\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <asm/uaccess.h>\n#include <linux/cleancache.h>\n#include <linux/crc16.h>\n#include <linux/log2.h>\n#include <linux/ctype.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/random.h>\n#include <linux/vfs.h>\n#include <linux/exportfs.h>\n#include <linux/buffer_head.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/jbd2.h>\n#include <linux/vmalloc.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n#include <linux/string.h>\n#include <linux/module.h>\n\nstatic int ext4_unfreeze(struct super_block *sb);\nstatic int ext4_freeze(struct super_block *sb);\nstatic inline int ext2_feature_set_ok(struct super_block *sb);\nstatic inline int ext3_feature_set_ok(struct super_block *sb);\nstatic void ext4_unregister_li_request(struct super_block *sb);\n\nstatic struct ext4_li_request *ext4_li_request_new(struct super_block *sb,\n\t\t\t\t\t    ext4_group_t start)\n{\n\tstruct ext4_sb_info *sbi = EXT4_SB(sb);\n\tstruct ext4_li_request *elr;\n\n\telr = kzalloc(sizeof(*elr), GFP_KERNEL);\n\tif (!elr)\n\t\treturn NULL;\n\n\telr->lr_super = sb;\n\telr->lr_sbi = sbi;\n\telr->lr_next_group = start;\n\n\t/*\n\t * Randomize first schedule time of the request to\n\t * spread the inode table initialization requests\n\t * better.\n\t */\n\telr->lr_next_sched = jiffies + (prandom_u32() %\n\t\t\t\t(EXT4_DEF_LI_MAX_START_DELAY * HZ));\n\treturn elr;\n}"
  },
  {
    "function_name": "ext4_li_info_new",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/super.c",
    "lines": "3095-3111",
    "snippet": "static int ext4_li_info_new(void)\n{\n\tstruct ext4_lazy_init *eli = NULL;\n\n\teli = kzalloc(sizeof(*eli), GFP_KERNEL);\n\tif (!eli)\n\t\treturn -ENOMEM;\n\n\tINIT_LIST_HEAD(&eli->li_request_list);\n\tmutex_init(&eli->li_list_mtx);\n\n\teli->li_state |= EXT4_LAZYINIT_QUIT;\n\n\text4_li_info = eli;\n\n\treturn 0;\n}",
    "includes": [
      "#include <trace/events/ext4.h>",
      "#include \"mballoc.h\"",
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"ext4_jbd2.h\"",
      "#include \"ext4_extents.h\"\t/* Needed for trace points definition */",
      "#include \"ext4.h\"",
      "#include <linux/freezer.h>",
      "#include <linux/kthread.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/cleancache.h>",
      "#include <linux/crc16.h>",
      "#include <linux/log2.h>",
      "#include <linux/ctype.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/namei.h>",
      "#include <linux/mount.h>",
      "#include <linux/random.h>",
      "#include <linux/vfs.h>",
      "#include <linux/exportfs.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/parser.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/init.h>",
      "#include <linux/slab.h>",
      "#include <linux/jbd2.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/time.h>",
      "#include <linux/fs.h>",
      "#include <linux/string.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct ext4_lazy_init *ext4_li_info;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_init",
          "args": [
            "&eli->li_list_mtx"
          ],
          "line": 3104
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&eli->li_request_list"
          ],
          "line": 3103
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "sizeof(*eli)",
            "GFP_KERNEL"
          ],
          "line": 3099
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"mballoc.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4_extents.h\"\t/* Needed for trace points definition */\n#include \"ext4.h\"\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <asm/uaccess.h>\n#include <linux/cleancache.h>\n#include <linux/crc16.h>\n#include <linux/log2.h>\n#include <linux/ctype.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/random.h>\n#include <linux/vfs.h>\n#include <linux/exportfs.h>\n#include <linux/buffer_head.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/jbd2.h>\n#include <linux/vmalloc.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n#include <linux/string.h>\n#include <linux/module.h>\n\nstatic struct ext4_lazy_init *ext4_li_info;\n\nstatic int ext4_li_info_new(void)\n{\n\tstruct ext4_lazy_init *eli = NULL;\n\n\teli = kzalloc(sizeof(*eli), GFP_KERNEL);\n\tif (!eli)\n\t\treturn -ENOMEM;\n\n\tINIT_LIST_HEAD(&eli->li_request_list);\n\tmutex_init(&eli->li_list_mtx);\n\n\teli->li_state |= EXT4_LAZYINIT_QUIT;\n\n\text4_li_info = eli;\n\n\treturn 0;\n}"
  },
  {
    "function_name": "ext4_has_uninit_itable",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/super.c",
    "lines": "3078-3093",
    "snippet": "static ext4_group_t ext4_has_uninit_itable(struct super_block *sb)\n{\n\text4_group_t group, ngroups = EXT4_SB(sb)->s_groups_count;\n\tstruct ext4_group_desc *gdp = NULL;\n\n\tfor (group = 0; group < ngroups; group++) {\n\t\tgdp = ext4_get_group_desc(sb, group, NULL);\n\t\tif (!gdp)\n\t\t\tcontinue;\n\n\t\tif (!(gdp->bg_flags & cpu_to_le16(EXT4_BG_INODE_ZEROED)))\n\t\t\tbreak;\n\t}\n\n\treturn group;\n}",
    "includes": [
      "#include <trace/events/ext4.h>",
      "#include \"mballoc.h\"",
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"ext4_jbd2.h\"",
      "#include \"ext4_extents.h\"\t/* Needed for trace points definition */",
      "#include \"ext4.h\"",
      "#include <linux/freezer.h>",
      "#include <linux/kthread.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/cleancache.h>",
      "#include <linux/crc16.h>",
      "#include <linux/log2.h>",
      "#include <linux/ctype.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/namei.h>",
      "#include <linux/mount.h>",
      "#include <linux/random.h>",
      "#include <linux/vfs.h>",
      "#include <linux/exportfs.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/parser.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/init.h>",
      "#include <linux/slab.h>",
      "#include <linux/jbd2.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/time.h>",
      "#include <linux/fs.h>",
      "#include <linux/string.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ext4_unfreeze(struct super_block *sb);",
      "static int ext4_freeze(struct super_block *sb);",
      "static inline int ext2_feature_set_ok(struct super_block *sb);",
      "static inline int ext3_feature_set_ok(struct super_block *sb);",
      "static void ext4_unregister_li_request(struct super_block *sb);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "EXT4_BG_INODE_ZEROED"
          ],
          "line": 3088
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_get_group_desc",
          "args": [
            "sb",
            "group",
            "NULL"
          ],
          "line": 3084
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_get_group_desc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/balloc.c",
          "lines": "277-309",
          "snippet": "struct ext4_group_desc * ext4_get_group_desc(struct super_block *sb,\n\t\t\t\t\t     ext4_group_t block_group,\n\t\t\t\t\t     struct buffer_head **bh)\n{\n\tunsigned int group_desc;\n\tunsigned int offset;\n\text4_group_t ngroups = ext4_get_groups_count(sb);\n\tstruct ext4_group_desc *desc;\n\tstruct ext4_sb_info *sbi = EXT4_SB(sb);\n\n\tif (block_group >= ngroups) {\n\t\text4_error(sb, \"block_group >= groups_count - block_group = %u,\"\n\t\t\t   \" groups_count = %u\", block_group, ngroups);\n\n\t\treturn NULL;\n\t}\n\n\tgroup_desc = block_group >> EXT4_DESC_PER_BLOCK_BITS(sb);\n\toffset = block_group & (EXT4_DESC_PER_BLOCK(sb) - 1);\n\tif (!sbi->s_group_desc[group_desc]) {\n\t\text4_error(sb, \"Group descriptor not loaded - \"\n\t\t\t   \"block_group = %u, group_desc = %u, desc = %u\",\n\t\t\t   block_group, group_desc, offset);\n\t\treturn NULL;\n\t}\n\n\tdesc = (struct ext4_group_desc *)(\n\t\t(__u8 *)sbi->s_group_desc[group_desc]->b_data +\n\t\toffset * EXT4_DESC_SIZE(sb));\n\tif (bh)\n\t\t*bh = sbi->s_group_desc[group_desc];\n\treturn desc;\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"mballoc.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include \"ext4.h\"",
            "#include <linux/buffer_head.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/fs.h>",
            "#include <linux/capability.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static unsigned ext4_num_base_meta_clusters(struct super_block *sb,\n\t\t\t\t\t    ext4_group_t block_group);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"mballoc.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4.h\"\n#include <linux/buffer_head.h>\n#include <linux/quotaops.h>\n#include <linux/jbd2.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n#include <linux/time.h>\n\nstatic unsigned ext4_num_base_meta_clusters(struct super_block *sb,\n\t\t\t\t\t    ext4_group_t block_group);\n\nstruct ext4_group_desc * ext4_get_group_desc(struct super_block *sb,\n\t\t\t\t\t     ext4_group_t block_group,\n\t\t\t\t\t     struct buffer_head **bh)\n{\n\tunsigned int group_desc;\n\tunsigned int offset;\n\text4_group_t ngroups = ext4_get_groups_count(sb);\n\tstruct ext4_group_desc *desc;\n\tstruct ext4_sb_info *sbi = EXT4_SB(sb);\n\n\tif (block_group >= ngroups) {\n\t\text4_error(sb, \"block_group >= groups_count - block_group = %u,\"\n\t\t\t   \" groups_count = %u\", block_group, ngroups);\n\n\t\treturn NULL;\n\t}\n\n\tgroup_desc = block_group >> EXT4_DESC_PER_BLOCK_BITS(sb);\n\toffset = block_group & (EXT4_DESC_PER_BLOCK(sb) - 1);\n\tif (!sbi->s_group_desc[group_desc]) {\n\t\text4_error(sb, \"Group descriptor not loaded - \"\n\t\t\t   \"block_group = %u, group_desc = %u, desc = %u\",\n\t\t\t   block_group, group_desc, offset);\n\t\treturn NULL;\n\t}\n\n\tdesc = (struct ext4_group_desc *)(\n\t\t(__u8 *)sbi->s_group_desc[group_desc]->b_data +\n\t\toffset * EXT4_DESC_SIZE(sb));\n\tif (bh)\n\t\t*bh = sbi->s_group_desc[group_desc];\n\treturn desc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "EXT4_SB",
          "args": [
            "sb"
          ],
          "line": 3080
        },
        "resolved": true,
        "details": {
          "function_name": "EXT4_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ext4.h",
          "lines": "1356-1359",
          "snippet": "static inline struct ext4_sb_info *EXT4_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include \"extents_status.h\"",
            "#include <linux/compat.h>",
            "#include <linux/falloc.h>",
            "#include <crypto/hash.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/wait.h>",
            "#include <linux/timer.h>",
            "#include <linux/mutex.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/quota.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extents_status.h\"\n#include <linux/compat.h>\n#include <linux/falloc.h>\n#include <crypto/hash.h>\n#include <linux/ratelimit.h>\n#include <linux/percpu_counter.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/wait.h>\n#include <linux/timer.h>\n#include <linux/mutex.h>\n#include <linux/seqlock.h>\n#include <linux/rbtree.h>\n#include <linux/rwsem.h>\n#include <linux/quota.h>\n#include <linux/jbd2.h>\n#include <linux/magic.h>\n#include <linux/blkdev.h>\n#include <linux/types.h>\n\nstatic inline struct ext4_sb_info *EXT4_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"mballoc.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4_extents.h\"\t/* Needed for trace points definition */\n#include \"ext4.h\"\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <asm/uaccess.h>\n#include <linux/cleancache.h>\n#include <linux/crc16.h>\n#include <linux/log2.h>\n#include <linux/ctype.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/random.h>\n#include <linux/vfs.h>\n#include <linux/exportfs.h>\n#include <linux/buffer_head.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/jbd2.h>\n#include <linux/vmalloc.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n#include <linux/string.h>\n#include <linux/module.h>\n\nstatic int ext4_unfreeze(struct super_block *sb);\nstatic int ext4_freeze(struct super_block *sb);\nstatic inline int ext2_feature_set_ok(struct super_block *sb);\nstatic inline int ext3_feature_set_ok(struct super_block *sb);\nstatic void ext4_unregister_li_request(struct super_block *sb);\n\nstatic ext4_group_t ext4_has_uninit_itable(struct super_block *sb)\n{\n\text4_group_t group, ngroups = EXT4_SB(sb)->s_groups_count;\n\tstruct ext4_group_desc *gdp = NULL;\n\n\tfor (group = 0; group < ngroups; group++) {\n\t\tgdp = ext4_get_group_desc(sb, group, NULL);\n\t\tif (!gdp)\n\t\t\tcontinue;\n\n\t\tif (!(gdp->bg_flags & cpu_to_le16(EXT4_BG_INODE_ZEROED)))\n\t\t\tbreak;\n\t}\n\n\treturn group;\n}"
  },
  {
    "function_name": "ext4_run_lazyinit_thread",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/super.c",
    "lines": "3054-3070",
    "snippet": "static int ext4_run_lazyinit_thread(void)\n{\n\text4_lazyinit_task = kthread_run(ext4_lazyinit_thread,\n\t\t\t\t\t ext4_li_info, \"ext4lazyinit\");\n\tif (IS_ERR(ext4_lazyinit_task)) {\n\t\tint err = PTR_ERR(ext4_lazyinit_task);\n\t\text4_clear_request_list();\n\t\tkfree(ext4_li_info);\n\t\text4_li_info = NULL;\n\t\tprintk(KERN_CRIT \"EXT4-fs: error %d creating inode table \"\n\t\t\t\t \"initialization thread\\n\",\n\t\t\t\t err);\n\t\treturn err;\n\t}\n\text4_li_info->li_state |= EXT4_LAZYINIT_RUNNING;\n\treturn 0;\n}",
    "includes": [
      "#include <trace/events/ext4.h>",
      "#include \"mballoc.h\"",
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"ext4_jbd2.h\"",
      "#include \"ext4_extents.h\"\t/* Needed for trace points definition */",
      "#include \"ext4.h\"",
      "#include <linux/freezer.h>",
      "#include <linux/kthread.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/cleancache.h>",
      "#include <linux/crc16.h>",
      "#include <linux/log2.h>",
      "#include <linux/ctype.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/namei.h>",
      "#include <linux/mount.h>",
      "#include <linux/random.h>",
      "#include <linux/vfs.h>",
      "#include <linux/exportfs.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/parser.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/init.h>",
      "#include <linux/slab.h>",
      "#include <linux/jbd2.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/time.h>",
      "#include <linux/fs.h>",
      "#include <linux/string.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct ext4_lazy_init *ext4_li_info;",
      "static void ext4_clear_request_list(void);",
      "static struct task_struct *ext4_lazyinit_task;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_CRIT \"EXT4-fs: error %d creating inode table \"\n\t\t\t\t \"initialization thread\\n\"",
            "err"
          ],
          "line": 3063
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_printk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/super.c",
          "lines": "186-213",
          "snippet": "void btrfs_printk(const struct btrfs_fs_info *fs_info, const char *fmt, ...)\n{\n\tstruct super_block *sb = fs_info->sb;\n\tchar lvl[4];\n\tstruct va_format vaf;\n\tva_list args;\n\tconst char *type = logtypes[4];\n\tint kern_level;\n\n\tva_start(args, fmt);\n\n\tkern_level = printk_get_level(fmt);\n\tif (kern_level) {\n\t\tsize_t size = printk_skip_level(fmt) - fmt;\n\t\tmemcpy(lvl, fmt,  size);\n\t\tlvl[size] = '\\0';\n\t\tfmt += size;\n\t\ttype = logtypes[kern_level - '0'];\n\t} else\n\t\t*lvl = '\\0';\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\tprintk(\"%sBTRFS %s (device %s): %pV\\n\", lvl, type, sb->s_id, &vaf);\n\n\tva_end(args);\n}",
          "includes": [
            "#include <trace/events/btrfs.h>",
            "#include \"qgroup.h\"",
            "#include \"tests/btrfs-tests.h\"",
            "#include \"backref.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"dev-replace.h\"",
            "#include \"rcu-string.h\"",
            "#include \"compression.h\"",
            "#include \"export.h\"",
            "#include \"volumes.h\"",
            "#include \"xattr.h\"",
            "#include \"props.h\"",
            "#include \"hash.h\"",
            "#include \"print-tree.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include \"delayed-inode.h\"",
            "#include <linux/btrfs.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/slab.h>",
            "#include <linux/magic.h>",
            "#include <linux/miscdevice.h>",
            "#include <linux/namei.h>",
            "#include <linux/ctype.h>",
            "#include <linux/parser.h>",
            "#include <linux/compat.h>",
            "#include <linux/statfs.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/mpage.h>",
            "#include <linux/mount.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/string.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/init.h>",
            "#include <linux/time.h>",
            "#include <linux/highmem.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/module.h>",
            "#include <linux/blkdev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/btrfs.h>\n#include \"qgroup.h\"\n#include \"tests/btrfs-tests.h\"\n#include \"backref.h\"\n#include \"free-space-cache.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"compression.h\"\n#include \"export.h\"\n#include \"volumes.h\"\n#include \"xattr.h\"\n#include \"props.h\"\n#include \"hash.h\"\n#include \"print-tree.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include \"delayed-inode.h\"\n#include <linux/btrfs.h>\n#include <linux/ratelimit.h>\n#include <linux/cleancache.h>\n#include <linux/slab.h>\n#include <linux/magic.h>\n#include <linux/miscdevice.h>\n#include <linux/namei.h>\n#include <linux/ctype.h>\n#include <linux/parser.h>\n#include <linux/compat.h>\n#include <linux/statfs.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/mpage.h>\n#include <linux/mount.h>\n#include <linux/backing-dev.h>\n#include <linux/string.h>\n#include <linux/seq_file.h>\n#include <linux/init.h>\n#include <linux/time.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n#include <linux/buffer_head.h>\n#include <linux/module.h>\n#include <linux/blkdev.h>\n\nvoid btrfs_printk(const struct btrfs_fs_info *fs_info, const char *fmt, ...)\n{\n\tstruct super_block *sb = fs_info->sb;\n\tchar lvl[4];\n\tstruct va_format vaf;\n\tva_list args;\n\tconst char *type = logtypes[4];\n\tint kern_level;\n\n\tva_start(args, fmt);\n\n\tkern_level = printk_get_level(fmt);\n\tif (kern_level) {\n\t\tsize_t size = printk_skip_level(fmt) - fmt;\n\t\tmemcpy(lvl, fmt,  size);\n\t\tlvl[size] = '\\0';\n\t\tfmt += size;\n\t\ttype = logtypes[kern_level - '0'];\n\t} else\n\t\t*lvl = '\\0';\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\tprintk(\"%sBTRFS %s (device %s): %pV\\n\", lvl, type, sb->s_id, &vaf);\n\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "ext4_li_info"
          ],
          "line": 3061
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_clear_request_list",
          "args": [],
          "line": 3060
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_clear_request_list",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/super.c",
          "lines": "3040-3052",
          "snippet": "static void ext4_clear_request_list(void)\n{\n\tstruct list_head *pos, *n;\n\tstruct ext4_li_request *elr;\n\n\tmutex_lock(&ext4_li_info->li_list_mtx);\n\tlist_for_each_safe(pos, n, &ext4_li_info->li_request_list) {\n\t\telr = list_entry(pos, struct ext4_li_request,\n\t\t\t\t lr_request);\n\t\text4_remove_li_request(elr);\n\t}\n\tmutex_unlock(&ext4_li_info->li_list_mtx);\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"mballoc.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include \"ext4_extents.h\"\t/* Needed for trace points definition */",
            "#include \"ext4.h\"",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/crc16.h>",
            "#include <linux/log2.h>",
            "#include <linux/ctype.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/random.h>",
            "#include <linux/vfs.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/parser.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/time.h>",
            "#include <linux/fs.h>",
            "#include <linux/string.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct ext4_lazy_init *ext4_li_info;",
            "static void ext4_clear_request_list(void);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"mballoc.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4_extents.h\"\t/* Needed for trace points definition */\n#include \"ext4.h\"\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <asm/uaccess.h>\n#include <linux/cleancache.h>\n#include <linux/crc16.h>\n#include <linux/log2.h>\n#include <linux/ctype.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/random.h>\n#include <linux/vfs.h>\n#include <linux/exportfs.h>\n#include <linux/buffer_head.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/jbd2.h>\n#include <linux/vmalloc.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n#include <linux/string.h>\n#include <linux/module.h>\n\nstatic struct ext4_lazy_init *ext4_li_info;\nstatic void ext4_clear_request_list(void);\n\nstatic void ext4_clear_request_list(void)\n{\n\tstruct list_head *pos, *n;\n\tstruct ext4_li_request *elr;\n\n\tmutex_lock(&ext4_li_info->li_list_mtx);\n\tlist_for_each_safe(pos, n, &ext4_li_info->li_request_list) {\n\t\telr = list_entry(pos, struct ext4_li_request,\n\t\t\t\t lr_request);\n\t\text4_remove_li_request(elr);\n\t}\n\tmutex_unlock(&ext4_li_info->li_list_mtx);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "ext4_lazyinit_task"
          ],
          "line": 3059
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "ext4_lazyinit_task"
          ],
          "line": 3058
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kthread_run",
          "args": [
            "ext4_lazyinit_thread",
            "ext4_li_info",
            "\"ext4lazyinit\""
          ],
          "line": 3056
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"mballoc.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4_extents.h\"\t/* Needed for trace points definition */\n#include \"ext4.h\"\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <asm/uaccess.h>\n#include <linux/cleancache.h>\n#include <linux/crc16.h>\n#include <linux/log2.h>\n#include <linux/ctype.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/random.h>\n#include <linux/vfs.h>\n#include <linux/exportfs.h>\n#include <linux/buffer_head.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/jbd2.h>\n#include <linux/vmalloc.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n#include <linux/string.h>\n#include <linux/module.h>\n\nstatic struct ext4_lazy_init *ext4_li_info;\nstatic void ext4_clear_request_list(void);\nstatic struct task_struct *ext4_lazyinit_task;\n\nstatic int ext4_run_lazyinit_thread(void)\n{\n\text4_lazyinit_task = kthread_run(ext4_lazyinit_thread,\n\t\t\t\t\t ext4_li_info, \"ext4lazyinit\");\n\tif (IS_ERR(ext4_lazyinit_task)) {\n\t\tint err = PTR_ERR(ext4_lazyinit_task);\n\t\text4_clear_request_list();\n\t\tkfree(ext4_li_info);\n\t\text4_li_info = NULL;\n\t\tprintk(KERN_CRIT \"EXT4-fs: error %d creating inode table \"\n\t\t\t\t \"initialization thread\\n\",\n\t\t\t\t err);\n\t\treturn err;\n\t}\n\text4_li_info->li_state |= EXT4_LAZYINIT_RUNNING;\n\treturn 0;\n}"
  },
  {
    "function_name": "ext4_clear_request_list",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/super.c",
    "lines": "3040-3052",
    "snippet": "static void ext4_clear_request_list(void)\n{\n\tstruct list_head *pos, *n;\n\tstruct ext4_li_request *elr;\n\n\tmutex_lock(&ext4_li_info->li_list_mtx);\n\tlist_for_each_safe(pos, n, &ext4_li_info->li_request_list) {\n\t\telr = list_entry(pos, struct ext4_li_request,\n\t\t\t\t lr_request);\n\t\text4_remove_li_request(elr);\n\t}\n\tmutex_unlock(&ext4_li_info->li_list_mtx);\n}",
    "includes": [
      "#include <trace/events/ext4.h>",
      "#include \"mballoc.h\"",
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"ext4_jbd2.h\"",
      "#include \"ext4_extents.h\"\t/* Needed for trace points definition */",
      "#include \"ext4.h\"",
      "#include <linux/freezer.h>",
      "#include <linux/kthread.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/cleancache.h>",
      "#include <linux/crc16.h>",
      "#include <linux/log2.h>",
      "#include <linux/ctype.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/namei.h>",
      "#include <linux/mount.h>",
      "#include <linux/random.h>",
      "#include <linux/vfs.h>",
      "#include <linux/exportfs.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/parser.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/init.h>",
      "#include <linux/slab.h>",
      "#include <linux/jbd2.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/time.h>",
      "#include <linux/fs.h>",
      "#include <linux/string.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct ext4_lazy_init *ext4_li_info;",
      "static void ext4_clear_request_list(void);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&ext4_li_info->li_list_mtx"
          ],
          "line": 3051
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_remove_li_request",
          "args": [
            "elr"
          ],
          "line": 3049
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_remove_li_request",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/super.c",
          "lines": "2924-2936",
          "snippet": "static void ext4_remove_li_request(struct ext4_li_request *elr)\n{\n\tstruct ext4_sb_info *sbi;\n\n\tif (!elr)\n\t\treturn;\n\n\tsbi = elr->lr_sbi;\n\n\tlist_del(&elr->lr_request);\n\tsbi->s_li_request = NULL;\n\tkfree(elr);\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"mballoc.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include \"ext4_extents.h\"\t/* Needed for trace points definition */",
            "#include \"ext4.h\"",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/crc16.h>",
            "#include <linux/log2.h>",
            "#include <linux/ctype.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/random.h>",
            "#include <linux/vfs.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/parser.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/time.h>",
            "#include <linux/fs.h>",
            "#include <linux/string.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"mballoc.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4_extents.h\"\t/* Needed for trace points definition */\n#include \"ext4.h\"\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <asm/uaccess.h>\n#include <linux/cleancache.h>\n#include <linux/crc16.h>\n#include <linux/log2.h>\n#include <linux/ctype.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/random.h>\n#include <linux/vfs.h>\n#include <linux/exportfs.h>\n#include <linux/buffer_head.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/jbd2.h>\n#include <linux/vmalloc.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n#include <linux/string.h>\n#include <linux/module.h>\n\nstatic void ext4_remove_li_request(struct ext4_li_request *elr)\n{\n\tstruct ext4_sb_info *sbi;\n\n\tif (!elr)\n\t\treturn;\n\n\tsbi = elr->lr_sbi;\n\n\tlist_del(&elr->lr_request);\n\tsbi->s_li_request = NULL;\n\tkfree(elr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_entry",
          "args": [
            "pos",
            "structext4_li_request",
            "lr_request"
          ],
          "line": 3047
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_safe",
          "args": [
            "pos",
            "n",
            "&ext4_li_info->li_request_list"
          ],
          "line": 3046
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&ext4_li_info->li_list_mtx"
          ],
          "line": 3045
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"mballoc.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4_extents.h\"\t/* Needed for trace points definition */\n#include \"ext4.h\"\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <asm/uaccess.h>\n#include <linux/cleancache.h>\n#include <linux/crc16.h>\n#include <linux/log2.h>\n#include <linux/ctype.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/random.h>\n#include <linux/vfs.h>\n#include <linux/exportfs.h>\n#include <linux/buffer_head.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/jbd2.h>\n#include <linux/vmalloc.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n#include <linux/string.h>\n#include <linux/module.h>\n\nstatic struct ext4_lazy_init *ext4_li_info;\nstatic void ext4_clear_request_list(void);\n\nstatic void ext4_clear_request_list(void)\n{\n\tstruct list_head *pos, *n;\n\tstruct ext4_li_request *elr;\n\n\tmutex_lock(&ext4_li_info->li_list_mtx);\n\tlist_for_each_safe(pos, n, &ext4_li_info->li_request_list) {\n\t\telr = list_entry(pos, struct ext4_li_request,\n\t\t\t\t lr_request);\n\t\text4_remove_li_request(elr);\n\t}\n\tmutex_unlock(&ext4_li_info->li_list_mtx);\n}"
  },
  {
    "function_name": "ext4_lazyinit_thread",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/super.c",
    "lines": "2963-3038",
    "snippet": "static int ext4_lazyinit_thread(void *arg)\n{\n\tstruct ext4_lazy_init *eli = (struct ext4_lazy_init *)arg;\n\tstruct list_head *pos, *n;\n\tstruct ext4_li_request *elr;\n\tunsigned long next_wakeup, cur;\n\n\tBUG_ON(NULL == eli);\n\ncont_thread:\n\twhile (true) {\n\t\tnext_wakeup = MAX_JIFFY_OFFSET;\n\n\t\tmutex_lock(&eli->li_list_mtx);\n\t\tif (list_empty(&eli->li_request_list)) {\n\t\t\tmutex_unlock(&eli->li_list_mtx);\n\t\t\tgoto exit_thread;\n\t\t}\n\n\t\tlist_for_each_safe(pos, n, &eli->li_request_list) {\n\t\t\telr = list_entry(pos, struct ext4_li_request,\n\t\t\t\t\t lr_request);\n\n\t\t\tif (time_after_eq(jiffies, elr->lr_next_sched)) {\n\t\t\t\tif (ext4_run_li_request(elr) != 0) {\n\t\t\t\t\t/* error, remove the lazy_init job */\n\t\t\t\t\text4_remove_li_request(elr);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (time_before(elr->lr_next_sched, next_wakeup))\n\t\t\t\tnext_wakeup = elr->lr_next_sched;\n\t\t}\n\t\tmutex_unlock(&eli->li_list_mtx);\n\n\t\ttry_to_freeze();\n\n\t\tcur = jiffies;\n\t\tif ((time_after_eq(cur, next_wakeup)) ||\n\t\t    (MAX_JIFFY_OFFSET == next_wakeup)) {\n\t\t\tcond_resched();\n\t\t\tcontinue;\n\t\t}\n\n\t\tschedule_timeout_interruptible(next_wakeup - cur);\n\n\t\tif (kthread_should_stop()) {\n\t\t\text4_clear_request_list();\n\t\t\tgoto exit_thread;\n\t\t}\n\t}\n\nexit_thread:\n\t/*\n\t * It looks like the request list is empty, but we need\n\t * to check it under the li_list_mtx lock, to prevent any\n\t * additions into it, and of course we should lock ext4_li_mtx\n\t * to atomically free the list and ext4_li_info, because at\n\t * this point another ext4 filesystem could be registering\n\t * new one.\n\t */\n\tmutex_lock(&ext4_li_mtx);\n\tmutex_lock(&eli->li_list_mtx);\n\tif (!list_empty(&eli->li_request_list)) {\n\t\tmutex_unlock(&eli->li_list_mtx);\n\t\tmutex_unlock(&ext4_li_mtx);\n\t\tgoto cont_thread;\n\t}\n\tmutex_unlock(&eli->li_list_mtx);\n\tkfree(ext4_li_info);\n\text4_li_info = NULL;\n\tmutex_unlock(&ext4_li_mtx);\n\n\treturn 0;\n}",
    "includes": [
      "#include <trace/events/ext4.h>",
      "#include \"mballoc.h\"",
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"ext4_jbd2.h\"",
      "#include \"ext4_extents.h\"\t/* Needed for trace points definition */",
      "#include \"ext4.h\"",
      "#include <linux/freezer.h>",
      "#include <linux/kthread.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/cleancache.h>",
      "#include <linux/crc16.h>",
      "#include <linux/log2.h>",
      "#include <linux/ctype.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/namei.h>",
      "#include <linux/mount.h>",
      "#include <linux/random.h>",
      "#include <linux/vfs.h>",
      "#include <linux/exportfs.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/parser.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/init.h>",
      "#include <linux/slab.h>",
      "#include <linux/jbd2.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/time.h>",
      "#include <linux/fs.h>",
      "#include <linux/string.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct ext4_lazy_init *ext4_li_info;",
      "static struct mutex ext4_li_mtx;",
      "static void ext4_clear_request_list(void);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&ext4_li_mtx"
          ],
          "line": 3035
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "ext4_li_info"
          ],
          "line": 3033
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&eli->li_list_mtx"
          ],
          "line": 3032
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&ext4_li_mtx"
          ],
          "line": 3029
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&eli->li_list_mtx"
          ],
          "line": 3028
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&eli->li_request_list"
          ],
          "line": 3027
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_dirty_list_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmthread.c",
          "lines": "505-514",
          "snippet": "static int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/timer.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_flush_asts(struct dlm_ctxt *dlm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/timer.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_flush_asts(struct dlm_ctxt *dlm);\n\nstatic int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&eli->li_list_mtx"
          ],
          "line": 3026
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&ext4_li_mtx"
          ],
          "line": 3025
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_clear_request_list",
          "args": [],
          "line": 3011
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_clear_request_list",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/super.c",
          "lines": "3040-3052",
          "snippet": "static void ext4_clear_request_list(void)\n{\n\tstruct list_head *pos, *n;\n\tstruct ext4_li_request *elr;\n\n\tmutex_lock(&ext4_li_info->li_list_mtx);\n\tlist_for_each_safe(pos, n, &ext4_li_info->li_request_list) {\n\t\telr = list_entry(pos, struct ext4_li_request,\n\t\t\t\t lr_request);\n\t\text4_remove_li_request(elr);\n\t}\n\tmutex_unlock(&ext4_li_info->li_list_mtx);\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"mballoc.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include \"ext4_extents.h\"\t/* Needed for trace points definition */",
            "#include \"ext4.h\"",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/crc16.h>",
            "#include <linux/log2.h>",
            "#include <linux/ctype.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/random.h>",
            "#include <linux/vfs.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/parser.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/time.h>",
            "#include <linux/fs.h>",
            "#include <linux/string.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct ext4_lazy_init *ext4_li_info;",
            "static void ext4_clear_request_list(void);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"mballoc.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4_extents.h\"\t/* Needed for trace points definition */\n#include \"ext4.h\"\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <asm/uaccess.h>\n#include <linux/cleancache.h>\n#include <linux/crc16.h>\n#include <linux/log2.h>\n#include <linux/ctype.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/random.h>\n#include <linux/vfs.h>\n#include <linux/exportfs.h>\n#include <linux/buffer_head.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/jbd2.h>\n#include <linux/vmalloc.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n#include <linux/string.h>\n#include <linux/module.h>\n\nstatic struct ext4_lazy_init *ext4_li_info;\nstatic void ext4_clear_request_list(void);\n\nstatic void ext4_clear_request_list(void)\n{\n\tstruct list_head *pos, *n;\n\tstruct ext4_li_request *elr;\n\n\tmutex_lock(&ext4_li_info->li_list_mtx);\n\tlist_for_each_safe(pos, n, &ext4_li_info->li_request_list) {\n\t\telr = list_entry(pos, struct ext4_li_request,\n\t\t\t\t lr_request);\n\t\text4_remove_li_request(elr);\n\t}\n\tmutex_unlock(&ext4_li_info->li_list_mtx);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kthread_should_stop",
          "args": [],
          "line": 3010
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "schedule_timeout_interruptible",
          "args": [
            "next_wakeup - cur"
          ],
          "line": 3008
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cond_resched",
          "args": [],
          "line": 3004
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "time_after_eq",
          "args": [
            "cur",
            "next_wakeup"
          ],
          "line": 3002
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "try_to_freeze",
          "args": [],
          "line": 2999
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&eli->li_list_mtx"
          ],
          "line": 2997
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "time_before",
          "args": [
            "elr->lr_next_sched",
            "next_wakeup"
          ],
          "line": 2994
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_remove_li_request",
          "args": [
            "elr"
          ],
          "line": 2989
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_remove_li_request",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/super.c",
          "lines": "2924-2936",
          "snippet": "static void ext4_remove_li_request(struct ext4_li_request *elr)\n{\n\tstruct ext4_sb_info *sbi;\n\n\tif (!elr)\n\t\treturn;\n\n\tsbi = elr->lr_sbi;\n\n\tlist_del(&elr->lr_request);\n\tsbi->s_li_request = NULL;\n\tkfree(elr);\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"mballoc.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include \"ext4_extents.h\"\t/* Needed for trace points definition */",
            "#include \"ext4.h\"",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/crc16.h>",
            "#include <linux/log2.h>",
            "#include <linux/ctype.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/random.h>",
            "#include <linux/vfs.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/parser.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/time.h>",
            "#include <linux/fs.h>",
            "#include <linux/string.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"mballoc.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4_extents.h\"\t/* Needed for trace points definition */\n#include \"ext4.h\"\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <asm/uaccess.h>\n#include <linux/cleancache.h>\n#include <linux/crc16.h>\n#include <linux/log2.h>\n#include <linux/ctype.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/random.h>\n#include <linux/vfs.h>\n#include <linux/exportfs.h>\n#include <linux/buffer_head.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/jbd2.h>\n#include <linux/vmalloc.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n#include <linux/string.h>\n#include <linux/module.h>\n\nstatic void ext4_remove_li_request(struct ext4_li_request *elr)\n{\n\tstruct ext4_sb_info *sbi;\n\n\tif (!elr)\n\t\treturn;\n\n\tsbi = elr->lr_sbi;\n\n\tlist_del(&elr->lr_request);\n\tsbi->s_li_request = NULL;\n\tkfree(elr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_run_li_request",
          "args": [
            "elr"
          ],
          "line": 2987
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_run_li_request",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/super.c",
          "lines": "2877-2918",
          "snippet": "static int ext4_run_li_request(struct ext4_li_request *elr)\n{\n\tstruct ext4_group_desc *gdp = NULL;\n\text4_group_t group, ngroups;\n\tstruct super_block *sb;\n\tunsigned long timeout = 0;\n\tint ret = 0;\n\n\tsb = elr->lr_super;\n\tngroups = EXT4_SB(sb)->s_groups_count;\n\n\tsb_start_write(sb);\n\tfor (group = elr->lr_next_group; group < ngroups; group++) {\n\t\tgdp = ext4_get_group_desc(sb, group, NULL);\n\t\tif (!gdp) {\n\t\t\tret = 1;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (!(gdp->bg_flags & cpu_to_le16(EXT4_BG_INODE_ZEROED)))\n\t\t\tbreak;\n\t}\n\n\tif (group >= ngroups)\n\t\tret = 1;\n\n\tif (!ret) {\n\t\ttimeout = jiffies;\n\t\tret = ext4_init_inode_table(sb, group,\n\t\t\t\t\t    elr->lr_timeout ? 0 : 1);\n\t\tif (elr->lr_timeout == 0) {\n\t\t\ttimeout = (jiffies - timeout) *\n\t\t\t\t  elr->lr_sbi->s_li_wait_mult;\n\t\t\telr->lr_timeout = timeout;\n\t\t}\n\t\telr->lr_next_sched = jiffies + elr->lr_timeout;\n\t\telr->lr_next_group = group + 1;\n\t}\n\tsb_end_write(sb);\n\n\treturn ret;\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"mballoc.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include \"ext4_extents.h\"\t/* Needed for trace points definition */",
            "#include \"ext4.h\"",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/crc16.h>",
            "#include <linux/log2.h>",
            "#include <linux/ctype.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/random.h>",
            "#include <linux/vfs.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/parser.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/time.h>",
            "#include <linux/fs.h>",
            "#include <linux/string.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ext4_unfreeze(struct super_block *sb);",
            "static int ext4_freeze(struct super_block *sb);",
            "static inline int ext2_feature_set_ok(struct super_block *sb);",
            "static inline int ext3_feature_set_ok(struct super_block *sb);",
            "static void ext4_unregister_li_request(struct super_block *sb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"mballoc.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4_extents.h\"\t/* Needed for trace points definition */\n#include \"ext4.h\"\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <asm/uaccess.h>\n#include <linux/cleancache.h>\n#include <linux/crc16.h>\n#include <linux/log2.h>\n#include <linux/ctype.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/random.h>\n#include <linux/vfs.h>\n#include <linux/exportfs.h>\n#include <linux/buffer_head.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/jbd2.h>\n#include <linux/vmalloc.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n#include <linux/string.h>\n#include <linux/module.h>\n\nstatic int ext4_unfreeze(struct super_block *sb);\nstatic int ext4_freeze(struct super_block *sb);\nstatic inline int ext2_feature_set_ok(struct super_block *sb);\nstatic inline int ext3_feature_set_ok(struct super_block *sb);\nstatic void ext4_unregister_li_request(struct super_block *sb);\n\nstatic int ext4_run_li_request(struct ext4_li_request *elr)\n{\n\tstruct ext4_group_desc *gdp = NULL;\n\text4_group_t group, ngroups;\n\tstruct super_block *sb;\n\tunsigned long timeout = 0;\n\tint ret = 0;\n\n\tsb = elr->lr_super;\n\tngroups = EXT4_SB(sb)->s_groups_count;\n\n\tsb_start_write(sb);\n\tfor (group = elr->lr_next_group; group < ngroups; group++) {\n\t\tgdp = ext4_get_group_desc(sb, group, NULL);\n\t\tif (!gdp) {\n\t\t\tret = 1;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (!(gdp->bg_flags & cpu_to_le16(EXT4_BG_INODE_ZEROED)))\n\t\t\tbreak;\n\t}\n\n\tif (group >= ngroups)\n\t\tret = 1;\n\n\tif (!ret) {\n\t\ttimeout = jiffies;\n\t\tret = ext4_init_inode_table(sb, group,\n\t\t\t\t\t    elr->lr_timeout ? 0 : 1);\n\t\tif (elr->lr_timeout == 0) {\n\t\t\ttimeout = (jiffies - timeout) *\n\t\t\t\t  elr->lr_sbi->s_li_wait_mult;\n\t\t\telr->lr_timeout = timeout;\n\t\t}\n\t\telr->lr_next_sched = jiffies + elr->lr_timeout;\n\t\telr->lr_next_group = group + 1;\n\t}\n\tsb_end_write(sb);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "time_after_eq",
          "args": [
            "jiffies",
            "elr->lr_next_sched"
          ],
          "line": 2986
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_entry",
          "args": [
            "pos",
            "structext4_li_request",
            "lr_request"
          ],
          "line": 2983
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_safe",
          "args": [
            "pos",
            "n",
            "&eli->li_request_list"
          ],
          "line": 2982
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&eli->li_list_mtx"
          ],
          "line": 2978
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&eli->li_list_mtx"
          ],
          "line": 2976
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "NULL == eli"
          ],
          "line": 2970
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"mballoc.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4_extents.h\"\t/* Needed for trace points definition */\n#include \"ext4.h\"\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <asm/uaccess.h>\n#include <linux/cleancache.h>\n#include <linux/crc16.h>\n#include <linux/log2.h>\n#include <linux/ctype.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/random.h>\n#include <linux/vfs.h>\n#include <linux/exportfs.h>\n#include <linux/buffer_head.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/jbd2.h>\n#include <linux/vmalloc.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n#include <linux/string.h>\n#include <linux/module.h>\n\nstatic struct ext4_lazy_init *ext4_li_info;\nstatic struct mutex ext4_li_mtx;\nstatic void ext4_clear_request_list(void);\n\nstatic int ext4_lazyinit_thread(void *arg)\n{\n\tstruct ext4_lazy_init *eli = (struct ext4_lazy_init *)arg;\n\tstruct list_head *pos, *n;\n\tstruct ext4_li_request *elr;\n\tunsigned long next_wakeup, cur;\n\n\tBUG_ON(NULL == eli);\n\ncont_thread:\n\twhile (true) {\n\t\tnext_wakeup = MAX_JIFFY_OFFSET;\n\n\t\tmutex_lock(&eli->li_list_mtx);\n\t\tif (list_empty(&eli->li_request_list)) {\n\t\t\tmutex_unlock(&eli->li_list_mtx);\n\t\t\tgoto exit_thread;\n\t\t}\n\n\t\tlist_for_each_safe(pos, n, &eli->li_request_list) {\n\t\t\telr = list_entry(pos, struct ext4_li_request,\n\t\t\t\t\t lr_request);\n\n\t\t\tif (time_after_eq(jiffies, elr->lr_next_sched)) {\n\t\t\t\tif (ext4_run_li_request(elr) != 0) {\n\t\t\t\t\t/* error, remove the lazy_init job */\n\t\t\t\t\text4_remove_li_request(elr);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (time_before(elr->lr_next_sched, next_wakeup))\n\t\t\t\tnext_wakeup = elr->lr_next_sched;\n\t\t}\n\t\tmutex_unlock(&eli->li_list_mtx);\n\n\t\ttry_to_freeze();\n\n\t\tcur = jiffies;\n\t\tif ((time_after_eq(cur, next_wakeup)) ||\n\t\t    (MAX_JIFFY_OFFSET == next_wakeup)) {\n\t\t\tcond_resched();\n\t\t\tcontinue;\n\t\t}\n\n\t\tschedule_timeout_interruptible(next_wakeup - cur);\n\n\t\tif (kthread_should_stop()) {\n\t\t\text4_clear_request_list();\n\t\t\tgoto exit_thread;\n\t\t}\n\t}\n\nexit_thread:\n\t/*\n\t * It looks like the request list is empty, but we need\n\t * to check it under the li_list_mtx lock, to prevent any\n\t * additions into it, and of course we should lock ext4_li_mtx\n\t * to atomically free the list and ext4_li_info, because at\n\t * this point another ext4 filesystem could be registering\n\t * new one.\n\t */\n\tmutex_lock(&ext4_li_mtx);\n\tmutex_lock(&eli->li_list_mtx);\n\tif (!list_empty(&eli->li_request_list)) {\n\t\tmutex_unlock(&eli->li_list_mtx);\n\t\tmutex_unlock(&ext4_li_mtx);\n\t\tgoto cont_thread;\n\t}\n\tmutex_unlock(&eli->li_list_mtx);\n\tkfree(ext4_li_info);\n\text4_li_info = NULL;\n\tmutex_unlock(&ext4_li_mtx);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "ext4_unregister_li_request",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/super.c",
    "lines": "2938-2950",
    "snippet": "static void ext4_unregister_li_request(struct super_block *sb)\n{\n\tmutex_lock(&ext4_li_mtx);\n\tif (!ext4_li_info) {\n\t\tmutex_unlock(&ext4_li_mtx);\n\t\treturn;\n\t}\n\n\tmutex_lock(&ext4_li_info->li_list_mtx);\n\text4_remove_li_request(EXT4_SB(sb)->s_li_request);\n\tmutex_unlock(&ext4_li_info->li_list_mtx);\n\tmutex_unlock(&ext4_li_mtx);\n}",
    "includes": [
      "#include <trace/events/ext4.h>",
      "#include \"mballoc.h\"",
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"ext4_jbd2.h\"",
      "#include \"ext4_extents.h\"\t/* Needed for trace points definition */",
      "#include \"ext4.h\"",
      "#include <linux/freezer.h>",
      "#include <linux/kthread.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/cleancache.h>",
      "#include <linux/crc16.h>",
      "#include <linux/log2.h>",
      "#include <linux/ctype.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/namei.h>",
      "#include <linux/mount.h>",
      "#include <linux/random.h>",
      "#include <linux/vfs.h>",
      "#include <linux/exportfs.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/parser.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/init.h>",
      "#include <linux/slab.h>",
      "#include <linux/jbd2.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/time.h>",
      "#include <linux/fs.h>",
      "#include <linux/string.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct ext4_lazy_init *ext4_li_info;",
      "static struct mutex ext4_li_mtx;",
      "static int ext4_unfreeze(struct super_block *sb);",
      "static int ext4_freeze(struct super_block *sb);",
      "static inline int ext2_feature_set_ok(struct super_block *sb);",
      "static inline int ext3_feature_set_ok(struct super_block *sb);",
      "static void ext4_unregister_li_request(struct super_block *sb);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&ext4_li_mtx"
          ],
          "line": 2949
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&ext4_li_info->li_list_mtx"
          ],
          "line": 2948
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_remove_li_request",
          "args": [
            "EXT4_SB(sb)->s_li_request"
          ],
          "line": 2947
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_remove_li_request",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/super.c",
          "lines": "2924-2936",
          "snippet": "static void ext4_remove_li_request(struct ext4_li_request *elr)\n{\n\tstruct ext4_sb_info *sbi;\n\n\tif (!elr)\n\t\treturn;\n\n\tsbi = elr->lr_sbi;\n\n\tlist_del(&elr->lr_request);\n\tsbi->s_li_request = NULL;\n\tkfree(elr);\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"mballoc.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include \"ext4_extents.h\"\t/* Needed for trace points definition */",
            "#include \"ext4.h\"",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/crc16.h>",
            "#include <linux/log2.h>",
            "#include <linux/ctype.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/random.h>",
            "#include <linux/vfs.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/parser.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/time.h>",
            "#include <linux/fs.h>",
            "#include <linux/string.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"mballoc.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4_extents.h\"\t/* Needed for trace points definition */\n#include \"ext4.h\"\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <asm/uaccess.h>\n#include <linux/cleancache.h>\n#include <linux/crc16.h>\n#include <linux/log2.h>\n#include <linux/ctype.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/random.h>\n#include <linux/vfs.h>\n#include <linux/exportfs.h>\n#include <linux/buffer_head.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/jbd2.h>\n#include <linux/vmalloc.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n#include <linux/string.h>\n#include <linux/module.h>\n\nstatic void ext4_remove_li_request(struct ext4_li_request *elr)\n{\n\tstruct ext4_sb_info *sbi;\n\n\tif (!elr)\n\t\treturn;\n\n\tsbi = elr->lr_sbi;\n\n\tlist_del(&elr->lr_request);\n\tsbi->s_li_request = NULL;\n\tkfree(elr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "EXT4_SB",
          "args": [
            "sb"
          ],
          "line": 2947
        },
        "resolved": true,
        "details": {
          "function_name": "EXT4_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ext4.h",
          "lines": "1356-1359",
          "snippet": "static inline struct ext4_sb_info *EXT4_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include \"extents_status.h\"",
            "#include <linux/compat.h>",
            "#include <linux/falloc.h>",
            "#include <crypto/hash.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/wait.h>",
            "#include <linux/timer.h>",
            "#include <linux/mutex.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/quota.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extents_status.h\"\n#include <linux/compat.h>\n#include <linux/falloc.h>\n#include <crypto/hash.h>\n#include <linux/ratelimit.h>\n#include <linux/percpu_counter.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/wait.h>\n#include <linux/timer.h>\n#include <linux/mutex.h>\n#include <linux/seqlock.h>\n#include <linux/rbtree.h>\n#include <linux/rwsem.h>\n#include <linux/quota.h>\n#include <linux/jbd2.h>\n#include <linux/magic.h>\n#include <linux/blkdev.h>\n#include <linux/types.h>\n\nstatic inline struct ext4_sb_info *EXT4_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&ext4_li_info->li_list_mtx"
          ],
          "line": 2946
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&ext4_li_mtx"
          ],
          "line": 2942
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&ext4_li_mtx"
          ],
          "line": 2940
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"mballoc.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4_extents.h\"\t/* Needed for trace points definition */\n#include \"ext4.h\"\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <asm/uaccess.h>\n#include <linux/cleancache.h>\n#include <linux/crc16.h>\n#include <linux/log2.h>\n#include <linux/ctype.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/random.h>\n#include <linux/vfs.h>\n#include <linux/exportfs.h>\n#include <linux/buffer_head.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/jbd2.h>\n#include <linux/vmalloc.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n#include <linux/string.h>\n#include <linux/module.h>\n\nstatic struct ext4_lazy_init *ext4_li_info;\nstatic struct mutex ext4_li_mtx;\nstatic int ext4_unfreeze(struct super_block *sb);\nstatic int ext4_freeze(struct super_block *sb);\nstatic inline int ext2_feature_set_ok(struct super_block *sb);\nstatic inline int ext3_feature_set_ok(struct super_block *sb);\nstatic void ext4_unregister_li_request(struct super_block *sb);\n\nstatic void ext4_unregister_li_request(struct super_block *sb)\n{\n\tmutex_lock(&ext4_li_mtx);\n\tif (!ext4_li_info) {\n\t\tmutex_unlock(&ext4_li_mtx);\n\t\treturn;\n\t}\n\n\tmutex_lock(&ext4_li_info->li_list_mtx);\n\text4_remove_li_request(EXT4_SB(sb)->s_li_request);\n\tmutex_unlock(&ext4_li_info->li_list_mtx);\n\tmutex_unlock(&ext4_li_mtx);\n}"
  },
  {
    "function_name": "ext4_remove_li_request",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/super.c",
    "lines": "2924-2936",
    "snippet": "static void ext4_remove_li_request(struct ext4_li_request *elr)\n{\n\tstruct ext4_sb_info *sbi;\n\n\tif (!elr)\n\t\treturn;\n\n\tsbi = elr->lr_sbi;\n\n\tlist_del(&elr->lr_request);\n\tsbi->s_li_request = NULL;\n\tkfree(elr);\n}",
    "includes": [
      "#include <trace/events/ext4.h>",
      "#include \"mballoc.h\"",
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"ext4_jbd2.h\"",
      "#include \"ext4_extents.h\"\t/* Needed for trace points definition */",
      "#include \"ext4.h\"",
      "#include <linux/freezer.h>",
      "#include <linux/kthread.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/cleancache.h>",
      "#include <linux/crc16.h>",
      "#include <linux/log2.h>",
      "#include <linux/ctype.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/namei.h>",
      "#include <linux/mount.h>",
      "#include <linux/random.h>",
      "#include <linux/vfs.h>",
      "#include <linux/exportfs.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/parser.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/init.h>",
      "#include <linux/slab.h>",
      "#include <linux/jbd2.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/time.h>",
      "#include <linux/fs.h>",
      "#include <linux/string.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "elr"
          ],
          "line": 2935
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_del",
          "args": [
            "&elr->lr_request"
          ],
          "line": 2933
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_es_list_del",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/extents_status.c",
          "lines": "316-328",
          "snippet": "static void ext4_es_list_del(struct inode *inode)\n{\n\tstruct ext4_inode_info *ei = EXT4_I(inode);\n\tstruct ext4_sb_info *sbi = EXT4_SB(inode->i_sb);\n\n\tspin_lock(&sbi->s_es_lock);\n\tif (!list_empty(&ei->i_es_list)) {\n\t\tlist_del_init(&ei->i_es_list);\n\t\tsbi->s_es_nr_inode--;\n\t\tWARN_ON_ONCE(sbi->s_es_nr_inode < 0);\n\t}\n\tspin_unlock(&sbi->s_es_lock);\n}",
          "includes": [
            "#include \"ext4_extents.h\"\t/* Needed when ES_AGGRESSIVE_TEST is defined */",
            "#include <trace/events/ext4.h>",
            "#include \"extents_status.h\"",
            "#include \"ext4.h\"",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/list_sort.h>",
            "#include <linux/rbtree.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ext4_extents.h\"\t/* Needed when ES_AGGRESSIVE_TEST is defined */\n#include <trace/events/ext4.h>\n#include \"extents_status.h\"\n#include \"ext4.h\"\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/list_sort.h>\n#include <linux/rbtree.h>\n\nstatic void ext4_es_list_del(struct inode *inode)\n{\n\tstruct ext4_inode_info *ei = EXT4_I(inode);\n\tstruct ext4_sb_info *sbi = EXT4_SB(inode->i_sb);\n\n\tspin_lock(&sbi->s_es_lock);\n\tif (!list_empty(&ei->i_es_list)) {\n\t\tlist_del_init(&ei->i_es_list);\n\t\tsbi->s_es_nr_inode--;\n\t\tWARN_ON_ONCE(sbi->s_es_nr_inode < 0);\n\t}\n\tspin_unlock(&sbi->s_es_lock);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"mballoc.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4_extents.h\"\t/* Needed for trace points definition */\n#include \"ext4.h\"\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <asm/uaccess.h>\n#include <linux/cleancache.h>\n#include <linux/crc16.h>\n#include <linux/log2.h>\n#include <linux/ctype.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/random.h>\n#include <linux/vfs.h>\n#include <linux/exportfs.h>\n#include <linux/buffer_head.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/jbd2.h>\n#include <linux/vmalloc.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n#include <linux/string.h>\n#include <linux/module.h>\n\nstatic void ext4_remove_li_request(struct ext4_li_request *elr)\n{\n\tstruct ext4_sb_info *sbi;\n\n\tif (!elr)\n\t\treturn;\n\n\tsbi = elr->lr_sbi;\n\n\tlist_del(&elr->lr_request);\n\tsbi->s_li_request = NULL;\n\tkfree(elr);\n}"
  },
  {
    "function_name": "ext4_run_li_request",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/super.c",
    "lines": "2877-2918",
    "snippet": "static int ext4_run_li_request(struct ext4_li_request *elr)\n{\n\tstruct ext4_group_desc *gdp = NULL;\n\text4_group_t group, ngroups;\n\tstruct super_block *sb;\n\tunsigned long timeout = 0;\n\tint ret = 0;\n\n\tsb = elr->lr_super;\n\tngroups = EXT4_SB(sb)->s_groups_count;\n\n\tsb_start_write(sb);\n\tfor (group = elr->lr_next_group; group < ngroups; group++) {\n\t\tgdp = ext4_get_group_desc(sb, group, NULL);\n\t\tif (!gdp) {\n\t\t\tret = 1;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (!(gdp->bg_flags & cpu_to_le16(EXT4_BG_INODE_ZEROED)))\n\t\t\tbreak;\n\t}\n\n\tif (group >= ngroups)\n\t\tret = 1;\n\n\tif (!ret) {\n\t\ttimeout = jiffies;\n\t\tret = ext4_init_inode_table(sb, group,\n\t\t\t\t\t    elr->lr_timeout ? 0 : 1);\n\t\tif (elr->lr_timeout == 0) {\n\t\t\ttimeout = (jiffies - timeout) *\n\t\t\t\t  elr->lr_sbi->s_li_wait_mult;\n\t\t\telr->lr_timeout = timeout;\n\t\t}\n\t\telr->lr_next_sched = jiffies + elr->lr_timeout;\n\t\telr->lr_next_group = group + 1;\n\t}\n\tsb_end_write(sb);\n\n\treturn ret;\n}",
    "includes": [
      "#include <trace/events/ext4.h>",
      "#include \"mballoc.h\"",
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"ext4_jbd2.h\"",
      "#include \"ext4_extents.h\"\t/* Needed for trace points definition */",
      "#include \"ext4.h\"",
      "#include <linux/freezer.h>",
      "#include <linux/kthread.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/cleancache.h>",
      "#include <linux/crc16.h>",
      "#include <linux/log2.h>",
      "#include <linux/ctype.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/namei.h>",
      "#include <linux/mount.h>",
      "#include <linux/random.h>",
      "#include <linux/vfs.h>",
      "#include <linux/exportfs.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/parser.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/init.h>",
      "#include <linux/slab.h>",
      "#include <linux/jbd2.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/time.h>",
      "#include <linux/fs.h>",
      "#include <linux/string.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ext4_unfreeze(struct super_block *sb);",
      "static int ext4_freeze(struct super_block *sb);",
      "static inline int ext2_feature_set_ok(struct super_block *sb);",
      "static inline int ext3_feature_set_ok(struct super_block *sb);",
      "static void ext4_unregister_li_request(struct super_block *sb);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "sb_end_write",
          "args": [
            "sb"
          ],
          "line": 2915
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_init_inode_table",
          "args": [
            "sb",
            "group",
            "elr->lr_timeout ? 0 : 1"
          ],
          "line": 2905
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_init_inode_table",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ialloc.c",
          "lines": "1232-1328",
          "snippet": "int ext4_init_inode_table(struct super_block *sb, ext4_group_t group,\n\t\t\t\t int barrier)\n{\n\tstruct ext4_group_info *grp = ext4_get_group_info(sb, group);\n\tstruct ext4_sb_info *sbi = EXT4_SB(sb);\n\tstruct ext4_group_desc *gdp = NULL;\n\tstruct buffer_head *group_desc_bh;\n\thandle_t *handle;\n\text4_fsblk_t blk;\n\tint num, ret = 0, used_blks = 0;\n\n\t/* This should not happen, but just to be sure check this */\n\tif (sb->s_flags & MS_RDONLY) {\n\t\tret = 1;\n\t\tgoto out;\n\t}\n\n\tgdp = ext4_get_group_desc(sb, group, &group_desc_bh);\n\tif (!gdp)\n\t\tgoto out;\n\n\t/*\n\t * We do not need to lock this, because we are the only one\n\t * handling this flag.\n\t */\n\tif (gdp->bg_flags & cpu_to_le16(EXT4_BG_INODE_ZEROED))\n\t\tgoto out;\n\n\thandle = ext4_journal_start_sb(sb, EXT4_HT_MISC, 1);\n\tif (IS_ERR(handle)) {\n\t\tret = PTR_ERR(handle);\n\t\tgoto out;\n\t}\n\n\tdown_write(&grp->alloc_sem);\n\t/*\n\t * If inode bitmap was already initialized there may be some\n\t * used inodes so we need to skip blocks with used inodes in\n\t * inode table.\n\t */\n\tif (!(gdp->bg_flags & cpu_to_le16(EXT4_BG_INODE_UNINIT)))\n\t\tused_blks = DIV_ROUND_UP((EXT4_INODES_PER_GROUP(sb) -\n\t\t\t    ext4_itable_unused_count(sb, gdp)),\n\t\t\t    sbi->s_inodes_per_block);\n\n\tif ((used_blks < 0) || (used_blks > sbi->s_itb_per_group)) {\n\t\text4_error(sb, \"Something is wrong with group %u: \"\n\t\t\t   \"used itable blocks: %d; \"\n\t\t\t   \"itable unused count: %u\",\n\t\t\t   group, used_blks,\n\t\t\t   ext4_itable_unused_count(sb, gdp));\n\t\tret = 1;\n\t\tgoto err_out;\n\t}\n\n\tblk = ext4_inode_table(sb, gdp) + used_blks;\n\tnum = sbi->s_itb_per_group - used_blks;\n\n\tBUFFER_TRACE(group_desc_bh, \"get_write_access\");\n\tret = ext4_journal_get_write_access(handle,\n\t\t\t\t\t    group_desc_bh);\n\tif (ret)\n\t\tgoto err_out;\n\n\t/*\n\t * Skip zeroout if the inode table is full. But we set the ZEROED\n\t * flag anyway, because obviously, when it is full it does not need\n\t * further zeroing.\n\t */\n\tif (unlikely(num == 0))\n\t\tgoto skip_zeroout;\n\n\text4_debug(\"going to zero out inode table in group %d\\n\",\n\t\t   group);\n\tret = sb_issue_zeroout(sb, blk, num, GFP_NOFS);\n\tif (ret < 0)\n\t\tgoto err_out;\n\tif (barrier)\n\t\tblkdev_issue_flush(sb->s_bdev, GFP_NOFS, NULL);\n\nskip_zeroout:\n\text4_lock_group(sb, group);\n\tgdp->bg_flags |= cpu_to_le16(EXT4_BG_INODE_ZEROED);\n\text4_group_desc_csum_set(sb, group, gdp);\n\text4_unlock_group(sb, group);\n\n\tBUFFER_TRACE(group_desc_bh,\n\t\t     \"call ext4_handle_dirty_metadata\");\n\tret = ext4_handle_dirty_metadata(handle, NULL,\n\t\t\t\t\t group_desc_bh);\n\nerr_out:\n\tup_write(&grp->alloc_sem);\n\text4_journal_stop(handle);\nout:\n\treturn ret;\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include \"ext4.h\"",
            "#include <asm/byteorder.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/bitops.h>",
            "#include <linux/random.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4.h\"\n#include <asm/byteorder.h>\n#include <linux/blkdev.h>\n#include <linux/bitops.h>\n#include <linux/random.h>\n#include <linux/buffer_head.h>\n#include <linux/quotaops.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/jbd2.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n\nint ext4_init_inode_table(struct super_block *sb, ext4_group_t group,\n\t\t\t\t int barrier)\n{\n\tstruct ext4_group_info *grp = ext4_get_group_info(sb, group);\n\tstruct ext4_sb_info *sbi = EXT4_SB(sb);\n\tstruct ext4_group_desc *gdp = NULL;\n\tstruct buffer_head *group_desc_bh;\n\thandle_t *handle;\n\text4_fsblk_t blk;\n\tint num, ret = 0, used_blks = 0;\n\n\t/* This should not happen, but just to be sure check this */\n\tif (sb->s_flags & MS_RDONLY) {\n\t\tret = 1;\n\t\tgoto out;\n\t}\n\n\tgdp = ext4_get_group_desc(sb, group, &group_desc_bh);\n\tif (!gdp)\n\t\tgoto out;\n\n\t/*\n\t * We do not need to lock this, because we are the only one\n\t * handling this flag.\n\t */\n\tif (gdp->bg_flags & cpu_to_le16(EXT4_BG_INODE_ZEROED))\n\t\tgoto out;\n\n\thandle = ext4_journal_start_sb(sb, EXT4_HT_MISC, 1);\n\tif (IS_ERR(handle)) {\n\t\tret = PTR_ERR(handle);\n\t\tgoto out;\n\t}\n\n\tdown_write(&grp->alloc_sem);\n\t/*\n\t * If inode bitmap was already initialized there may be some\n\t * used inodes so we need to skip blocks with used inodes in\n\t * inode table.\n\t */\n\tif (!(gdp->bg_flags & cpu_to_le16(EXT4_BG_INODE_UNINIT)))\n\t\tused_blks = DIV_ROUND_UP((EXT4_INODES_PER_GROUP(sb) -\n\t\t\t    ext4_itable_unused_count(sb, gdp)),\n\t\t\t    sbi->s_inodes_per_block);\n\n\tif ((used_blks < 0) || (used_blks > sbi->s_itb_per_group)) {\n\t\text4_error(sb, \"Something is wrong with group %u: \"\n\t\t\t   \"used itable blocks: %d; \"\n\t\t\t   \"itable unused count: %u\",\n\t\t\t   group, used_blks,\n\t\t\t   ext4_itable_unused_count(sb, gdp));\n\t\tret = 1;\n\t\tgoto err_out;\n\t}\n\n\tblk = ext4_inode_table(sb, gdp) + used_blks;\n\tnum = sbi->s_itb_per_group - used_blks;\n\n\tBUFFER_TRACE(group_desc_bh, \"get_write_access\");\n\tret = ext4_journal_get_write_access(handle,\n\t\t\t\t\t    group_desc_bh);\n\tif (ret)\n\t\tgoto err_out;\n\n\t/*\n\t * Skip zeroout if the inode table is full. But we set the ZEROED\n\t * flag anyway, because obviously, when it is full it does not need\n\t * further zeroing.\n\t */\n\tif (unlikely(num == 0))\n\t\tgoto skip_zeroout;\n\n\text4_debug(\"going to zero out inode table in group %d\\n\",\n\t\t   group);\n\tret = sb_issue_zeroout(sb, blk, num, GFP_NOFS);\n\tif (ret < 0)\n\t\tgoto err_out;\n\tif (barrier)\n\t\tblkdev_issue_flush(sb->s_bdev, GFP_NOFS, NULL);\n\nskip_zeroout:\n\text4_lock_group(sb, group);\n\tgdp->bg_flags |= cpu_to_le16(EXT4_BG_INODE_ZEROED);\n\text4_group_desc_csum_set(sb, group, gdp);\n\text4_unlock_group(sb, group);\n\n\tBUFFER_TRACE(group_desc_bh,\n\t\t     \"call ext4_handle_dirty_metadata\");\n\tret = ext4_handle_dirty_metadata(handle, NULL,\n\t\t\t\t\t group_desc_bh);\n\nerr_out:\n\tup_write(&grp->alloc_sem);\n\text4_journal_stop(handle);\nout:\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "EXT4_BG_INODE_ZEROED"
          ],
          "line": 2896
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_get_group_desc",
          "args": [
            "sb",
            "group",
            "NULL"
          ],
          "line": 2890
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_get_group_desc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/balloc.c",
          "lines": "277-309",
          "snippet": "struct ext4_group_desc * ext4_get_group_desc(struct super_block *sb,\n\t\t\t\t\t     ext4_group_t block_group,\n\t\t\t\t\t     struct buffer_head **bh)\n{\n\tunsigned int group_desc;\n\tunsigned int offset;\n\text4_group_t ngroups = ext4_get_groups_count(sb);\n\tstruct ext4_group_desc *desc;\n\tstruct ext4_sb_info *sbi = EXT4_SB(sb);\n\n\tif (block_group >= ngroups) {\n\t\text4_error(sb, \"block_group >= groups_count - block_group = %u,\"\n\t\t\t   \" groups_count = %u\", block_group, ngroups);\n\n\t\treturn NULL;\n\t}\n\n\tgroup_desc = block_group >> EXT4_DESC_PER_BLOCK_BITS(sb);\n\toffset = block_group & (EXT4_DESC_PER_BLOCK(sb) - 1);\n\tif (!sbi->s_group_desc[group_desc]) {\n\t\text4_error(sb, \"Group descriptor not loaded - \"\n\t\t\t   \"block_group = %u, group_desc = %u, desc = %u\",\n\t\t\t   block_group, group_desc, offset);\n\t\treturn NULL;\n\t}\n\n\tdesc = (struct ext4_group_desc *)(\n\t\t(__u8 *)sbi->s_group_desc[group_desc]->b_data +\n\t\toffset * EXT4_DESC_SIZE(sb));\n\tif (bh)\n\t\t*bh = sbi->s_group_desc[group_desc];\n\treturn desc;\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"mballoc.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include \"ext4.h\"",
            "#include <linux/buffer_head.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/fs.h>",
            "#include <linux/capability.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static unsigned ext4_num_base_meta_clusters(struct super_block *sb,\n\t\t\t\t\t    ext4_group_t block_group);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"mballoc.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4.h\"\n#include <linux/buffer_head.h>\n#include <linux/quotaops.h>\n#include <linux/jbd2.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n#include <linux/time.h>\n\nstatic unsigned ext4_num_base_meta_clusters(struct super_block *sb,\n\t\t\t\t\t    ext4_group_t block_group);\n\nstruct ext4_group_desc * ext4_get_group_desc(struct super_block *sb,\n\t\t\t\t\t     ext4_group_t block_group,\n\t\t\t\t\t     struct buffer_head **bh)\n{\n\tunsigned int group_desc;\n\tunsigned int offset;\n\text4_group_t ngroups = ext4_get_groups_count(sb);\n\tstruct ext4_group_desc *desc;\n\tstruct ext4_sb_info *sbi = EXT4_SB(sb);\n\n\tif (block_group >= ngroups) {\n\t\text4_error(sb, \"block_group >= groups_count - block_group = %u,\"\n\t\t\t   \" groups_count = %u\", block_group, ngroups);\n\n\t\treturn NULL;\n\t}\n\n\tgroup_desc = block_group >> EXT4_DESC_PER_BLOCK_BITS(sb);\n\toffset = block_group & (EXT4_DESC_PER_BLOCK(sb) - 1);\n\tif (!sbi->s_group_desc[group_desc]) {\n\t\text4_error(sb, \"Group descriptor not loaded - \"\n\t\t\t   \"block_group = %u, group_desc = %u, desc = %u\",\n\t\t\t   block_group, group_desc, offset);\n\t\treturn NULL;\n\t}\n\n\tdesc = (struct ext4_group_desc *)(\n\t\t(__u8 *)sbi->s_group_desc[group_desc]->b_data +\n\t\toffset * EXT4_DESC_SIZE(sb));\n\tif (bh)\n\t\t*bh = sbi->s_group_desc[group_desc];\n\treturn desc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sb_start_write",
          "args": [
            "sb"
          ],
          "line": 2888
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXT4_SB",
          "args": [
            "sb"
          ],
          "line": 2886
        },
        "resolved": true,
        "details": {
          "function_name": "EXT4_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ext4.h",
          "lines": "1356-1359",
          "snippet": "static inline struct ext4_sb_info *EXT4_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include \"extents_status.h\"",
            "#include <linux/compat.h>",
            "#include <linux/falloc.h>",
            "#include <crypto/hash.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/wait.h>",
            "#include <linux/timer.h>",
            "#include <linux/mutex.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/quota.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extents_status.h\"\n#include <linux/compat.h>\n#include <linux/falloc.h>\n#include <crypto/hash.h>\n#include <linux/ratelimit.h>\n#include <linux/percpu_counter.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/wait.h>\n#include <linux/timer.h>\n#include <linux/mutex.h>\n#include <linux/seqlock.h>\n#include <linux/rbtree.h>\n#include <linux/rwsem.h>\n#include <linux/quota.h>\n#include <linux/jbd2.h>\n#include <linux/magic.h>\n#include <linux/blkdev.h>\n#include <linux/types.h>\n\nstatic inline struct ext4_sb_info *EXT4_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"mballoc.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4_extents.h\"\t/* Needed for trace points definition */\n#include \"ext4.h\"\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <asm/uaccess.h>\n#include <linux/cleancache.h>\n#include <linux/crc16.h>\n#include <linux/log2.h>\n#include <linux/ctype.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/random.h>\n#include <linux/vfs.h>\n#include <linux/exportfs.h>\n#include <linux/buffer_head.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/jbd2.h>\n#include <linux/vmalloc.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n#include <linux/string.h>\n#include <linux/module.h>\n\nstatic int ext4_unfreeze(struct super_block *sb);\nstatic int ext4_freeze(struct super_block *sb);\nstatic inline int ext2_feature_set_ok(struct super_block *sb);\nstatic inline int ext3_feature_set_ok(struct super_block *sb);\nstatic void ext4_unregister_li_request(struct super_block *sb);\n\nstatic int ext4_run_li_request(struct ext4_li_request *elr)\n{\n\tstruct ext4_group_desc *gdp = NULL;\n\text4_group_t group, ngroups;\n\tstruct super_block *sb;\n\tunsigned long timeout = 0;\n\tint ret = 0;\n\n\tsb = elr->lr_super;\n\tngroups = EXT4_SB(sb)->s_groups_count;\n\n\tsb_start_write(sb);\n\tfor (group = elr->lr_next_group; group < ngroups; group++) {\n\t\tgdp = ext4_get_group_desc(sb, group, NULL);\n\t\tif (!gdp) {\n\t\t\tret = 1;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (!(gdp->bg_flags & cpu_to_le16(EXT4_BG_INODE_ZEROED)))\n\t\t\tbreak;\n\t}\n\n\tif (group >= ngroups)\n\t\tret = 1;\n\n\tif (!ret) {\n\t\ttimeout = jiffies;\n\t\tret = ext4_init_inode_table(sb, group,\n\t\t\t\t\t    elr->lr_timeout ? 0 : 1);\n\t\tif (elr->lr_timeout == 0) {\n\t\t\ttimeout = (jiffies - timeout) *\n\t\t\t\t  elr->lr_sbi->s_li_wait_mult;\n\t\t\telr->lr_timeout = timeout;\n\t\t}\n\t\telr->lr_next_sched = jiffies + elr->lr_timeout;\n\t\telr->lr_next_group = group + 1;\n\t}\n\tsb_end_write(sb);\n\n\treturn ret;\n}"
  },
  {
    "function_name": "print_daily_error_info",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/super.c",
    "lines": "2832-2874",
    "snippet": "static void print_daily_error_info(unsigned long arg)\n{\n\tstruct super_block *sb = (struct super_block *) arg;\n\tstruct ext4_sb_info *sbi;\n\tstruct ext4_super_block *es;\n\n\tsbi = EXT4_SB(sb);\n\tes = sbi->s_es;\n\n\tif (es->s_error_count)\n\t\t/* fsck newer than v1.41.13 is needed to clean this condition. */\n\t\text4_msg(sb, KERN_NOTICE, \"error count since last fsck: %u\",\n\t\t\t le32_to_cpu(es->s_error_count));\n\tif (es->s_first_error_time) {\n\t\tprintk(KERN_NOTICE \"EXT4-fs (%s): initial error at time %u: %.*s:%d\",\n\t\t       sb->s_id, le32_to_cpu(es->s_first_error_time),\n\t\t       (int) sizeof(es->s_first_error_func),\n\t\t       es->s_first_error_func,\n\t\t       le32_to_cpu(es->s_first_error_line));\n\t\tif (es->s_first_error_ino)\n\t\t\tprintk(\": inode %u\",\n\t\t\t       le32_to_cpu(es->s_first_error_ino));\n\t\tif (es->s_first_error_block)\n\t\t\tprintk(\": block %llu\", (unsigned long long)\n\t\t\t       le64_to_cpu(es->s_first_error_block));\n\t\tprintk(\"\\n\");\n\t}\n\tif (es->s_last_error_time) {\n\t\tprintk(KERN_NOTICE \"EXT4-fs (%s): last error at time %u: %.*s:%d\",\n\t\t       sb->s_id, le32_to_cpu(es->s_last_error_time),\n\t\t       (int) sizeof(es->s_last_error_func),\n\t\t       es->s_last_error_func,\n\t\t       le32_to_cpu(es->s_last_error_line));\n\t\tif (es->s_last_error_ino)\n\t\t\tprintk(\": inode %u\",\n\t\t\t       le32_to_cpu(es->s_last_error_ino));\n\t\tif (es->s_last_error_block)\n\t\t\tprintk(\": block %llu\", (unsigned long long)\n\t\t\t       le64_to_cpu(es->s_last_error_block));\n\t\tprintk(\"\\n\");\n\t}\n\tmod_timer(&sbi->s_err_report, jiffies + 24*60*60*HZ);  /* Once a day */\n}",
    "includes": [
      "#include <trace/events/ext4.h>",
      "#include \"mballoc.h\"",
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"ext4_jbd2.h\"",
      "#include \"ext4_extents.h\"\t/* Needed for trace points definition */",
      "#include \"ext4.h\"",
      "#include <linux/freezer.h>",
      "#include <linux/kthread.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/cleancache.h>",
      "#include <linux/crc16.h>",
      "#include <linux/log2.h>",
      "#include <linux/ctype.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/namei.h>",
      "#include <linux/mount.h>",
      "#include <linux/random.h>",
      "#include <linux/vfs.h>",
      "#include <linux/exportfs.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/parser.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/init.h>",
      "#include <linux/slab.h>",
      "#include <linux/jbd2.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/time.h>",
      "#include <linux/fs.h>",
      "#include <linux/string.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void ext4_mark_recovery_complete(struct super_block *sb,\n\t\t\t\t\tstruct ext4_super_block *es);",
      "static void ext4_clear_journal_err(struct super_block *sb,\n\t\t\t\t   struct ext4_super_block *es);",
      "static int ext4_unfreeze(struct super_block *sb);",
      "static int ext4_freeze(struct super_block *sb);",
      "static inline int ext2_feature_set_ok(struct super_block *sb);",
      "static inline int ext3_feature_set_ok(struct super_block *sb);",
      "static void ext4_unregister_li_request(struct super_block *sb);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mod_timer",
          "args": [
            "&sbi->s_err_report",
            "jiffies + 24*60*60*HZ"
          ],
          "line": 2873
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "\"\\n\""
          ],
          "line": 2871
        },
        "resolved": true,
        "details": {
          "function_name": "compat_printk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/compat.c",
          "lines": "59-69",
          "snippet": "int compat_printk(const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\tif (!compat_log)\n\t\treturn 0;\n\tva_start(ap, fmt);\n\tret = vprintk(fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/ioctls.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/aio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/mm.h>",
            "#include <linux/poll.h>",
            "#include <linux/signal.h>",
            "#include <linux/highmem.h>",
            "#include <linux/security.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/personality.h>",
            "#include <linux/highuid.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/dirent.h>",
            "#include <linux/ctype.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/nfs4_mount.h>",
            "#include <linux/ncp_mount.h>",
            "#include <linux/init.h>",
            "#include <linux/ioctl.h>",
            "#include <linux/vfs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/namei.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/errno.h>",
            "#include <linux/compat.h>",
            "#include <linux/linkage.h>",
            "#include <linux/kernel.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int compat_log = 1;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/ioctls.h>\n#include <asm/mmu_context.h>\n#include <asm/uaccess.h>\n#include <linux/aio.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/fs_struct.h>\n#include <linux/mm.h>\n#include <linux/poll.h>\n#include <linux/signal.h>\n#include <linux/highmem.h>\n#include <linux/security.h>\n#include <linux/tsacct_kern.h>\n#include <linux/rwsem.h>\n#include <linux/personality.h>\n#include <linux/highuid.h>\n#include <linux/fsnotify.h>\n#include <linux/dirent.h>\n#include <linux/ctype.h>\n#include <linux/syscalls.h>\n#include <linux/nfs4_mount.h>\n#include <linux/ncp_mount.h>\n#include <linux/init.h>\n#include <linux/ioctl.h>\n#include <linux/vfs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/namei.h>\n#include <linux/fcntl.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <linux/compat.h>\n#include <linux/linkage.h>\n#include <linux/kernel.h>\n#include <linux/stddef.h>\n\nint compat_log = 1;\n\nint compat_printk(const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\tif (!compat_log)\n\t\treturn 0;\n\tva_start(ap, fmt);\n\tret = vprintk(fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "\": block %llu\"",
            "(unsigned long long)\n\t\t\t       le64_to_cpu(es->s_last_error_block)"
          ],
          "line": 2869
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_printk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/super.c",
          "lines": "186-213",
          "snippet": "void btrfs_printk(const struct btrfs_fs_info *fs_info, const char *fmt, ...)\n{\n\tstruct super_block *sb = fs_info->sb;\n\tchar lvl[4];\n\tstruct va_format vaf;\n\tva_list args;\n\tconst char *type = logtypes[4];\n\tint kern_level;\n\n\tva_start(args, fmt);\n\n\tkern_level = printk_get_level(fmt);\n\tif (kern_level) {\n\t\tsize_t size = printk_skip_level(fmt) - fmt;\n\t\tmemcpy(lvl, fmt,  size);\n\t\tlvl[size] = '\\0';\n\t\tfmt += size;\n\t\ttype = logtypes[kern_level - '0'];\n\t} else\n\t\t*lvl = '\\0';\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\tprintk(\"%sBTRFS %s (device %s): %pV\\n\", lvl, type, sb->s_id, &vaf);\n\n\tva_end(args);\n}",
          "includes": [
            "#include <trace/events/btrfs.h>",
            "#include \"qgroup.h\"",
            "#include \"tests/btrfs-tests.h\"",
            "#include \"backref.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"dev-replace.h\"",
            "#include \"rcu-string.h\"",
            "#include \"compression.h\"",
            "#include \"export.h\"",
            "#include \"volumes.h\"",
            "#include \"xattr.h\"",
            "#include \"props.h\"",
            "#include \"hash.h\"",
            "#include \"print-tree.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include \"delayed-inode.h\"",
            "#include <linux/btrfs.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/slab.h>",
            "#include <linux/magic.h>",
            "#include <linux/miscdevice.h>",
            "#include <linux/namei.h>",
            "#include <linux/ctype.h>",
            "#include <linux/parser.h>",
            "#include <linux/compat.h>",
            "#include <linux/statfs.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/mpage.h>",
            "#include <linux/mount.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/string.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/init.h>",
            "#include <linux/time.h>",
            "#include <linux/highmem.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/module.h>",
            "#include <linux/blkdev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/btrfs.h>\n#include \"qgroup.h\"\n#include \"tests/btrfs-tests.h\"\n#include \"backref.h\"\n#include \"free-space-cache.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"compression.h\"\n#include \"export.h\"\n#include \"volumes.h\"\n#include \"xattr.h\"\n#include \"props.h\"\n#include \"hash.h\"\n#include \"print-tree.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include \"delayed-inode.h\"\n#include <linux/btrfs.h>\n#include <linux/ratelimit.h>\n#include <linux/cleancache.h>\n#include <linux/slab.h>\n#include <linux/magic.h>\n#include <linux/miscdevice.h>\n#include <linux/namei.h>\n#include <linux/ctype.h>\n#include <linux/parser.h>\n#include <linux/compat.h>\n#include <linux/statfs.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/mpage.h>\n#include <linux/mount.h>\n#include <linux/backing-dev.h>\n#include <linux/string.h>\n#include <linux/seq_file.h>\n#include <linux/init.h>\n#include <linux/time.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n#include <linux/buffer_head.h>\n#include <linux/module.h>\n#include <linux/blkdev.h>\n\nvoid btrfs_printk(const struct btrfs_fs_info *fs_info, const char *fmt, ...)\n{\n\tstruct super_block *sb = fs_info->sb;\n\tchar lvl[4];\n\tstruct va_format vaf;\n\tva_list args;\n\tconst char *type = logtypes[4];\n\tint kern_level;\n\n\tva_start(args, fmt);\n\n\tkern_level = printk_get_level(fmt);\n\tif (kern_level) {\n\t\tsize_t size = printk_skip_level(fmt) - fmt;\n\t\tmemcpy(lvl, fmt,  size);\n\t\tlvl[size] = '\\0';\n\t\tfmt += size;\n\t\ttype = logtypes[kern_level - '0'];\n\t} else\n\t\t*lvl = '\\0';\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\tprintk(\"%sBTRFS %s (device %s): %pV\\n\", lvl, type, sb->s_id, &vaf);\n\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "le64_to_cpu",
          "args": [
            "es->s_last_error_block"
          ],
          "line": 2870
        },
        "resolved": true,
        "details": {
          "function_name": "sle64_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "58-61",
          "snippet": "static inline s64 sle64_to_cpup(sle64 *x)\n{\n\treturn le64_to_cpu(*(__force le64*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s64 sle64_to_cpup(sle64 *x)\n{\n\treturn le64_to_cpu(*(__force le64*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "es->s_last_error_ino"
          ],
          "line": 2867
        },
        "resolved": true,
        "details": {
          "function_name": "sle32_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "53-56",
          "snippet": "static inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_msg",
          "args": [
            "sb",
            "KERN_NOTICE",
            "\"error count since last fsck: %u\"",
            "le32_to_cpu(es->s_error_count)"
          ],
          "line": 2843
        },
        "resolved": true,
        "details": {
          "function_name": "__ext4_msg",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/super.c",
          "lines": "593-607",
          "snippet": "void __ext4_msg(struct super_block *sb,\n\t\tconst char *prefix, const char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tif (!___ratelimit(&(EXT4_SB(sb)->s_msg_ratelimit_state), \"EXT4-fs\"))\n\t\treturn;\n\n\tva_start(args, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\tprintk(\"%sEXT4-fs (%s): %pV\\n\", prefix, sb->s_id, &vaf);\n\tva_end(args);\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"mballoc.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include \"ext4_extents.h\"\t/* Needed for trace points definition */",
            "#include \"ext4.h\"",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/crc16.h>",
            "#include <linux/log2.h>",
            "#include <linux/ctype.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/random.h>",
            "#include <linux/vfs.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/parser.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/time.h>",
            "#include <linux/fs.h>",
            "#include <linux/string.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ext4_unfreeze(struct super_block *sb);",
            "static int ext4_freeze(struct super_block *sb);",
            "static inline int ext2_feature_set_ok(struct super_block *sb);",
            "static inline int ext3_feature_set_ok(struct super_block *sb);",
            "static void ext4_unregister_li_request(struct super_block *sb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"mballoc.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4_extents.h\"\t/* Needed for trace points definition */\n#include \"ext4.h\"\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <asm/uaccess.h>\n#include <linux/cleancache.h>\n#include <linux/crc16.h>\n#include <linux/log2.h>\n#include <linux/ctype.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/random.h>\n#include <linux/vfs.h>\n#include <linux/exportfs.h>\n#include <linux/buffer_head.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/jbd2.h>\n#include <linux/vmalloc.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n#include <linux/string.h>\n#include <linux/module.h>\n\nstatic int ext4_unfreeze(struct super_block *sb);\nstatic int ext4_freeze(struct super_block *sb);\nstatic inline int ext2_feature_set_ok(struct super_block *sb);\nstatic inline int ext3_feature_set_ok(struct super_block *sb);\nstatic void ext4_unregister_li_request(struct super_block *sb);\n\nvoid __ext4_msg(struct super_block *sb,\n\t\tconst char *prefix, const char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tif (!___ratelimit(&(EXT4_SB(sb)->s_msg_ratelimit_state), \"EXT4-fs\"))\n\t\treturn;\n\n\tva_start(args, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\tprintk(\"%sEXT4-fs (%s): %pV\\n\", prefix, sb->s_id, &vaf);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "EXT4_SB",
          "args": [
            "sb"
          ],
          "line": 2838
        },
        "resolved": true,
        "details": {
          "function_name": "EXT4_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ext4.h",
          "lines": "1356-1359",
          "snippet": "static inline struct ext4_sb_info *EXT4_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include \"extents_status.h\"",
            "#include <linux/compat.h>",
            "#include <linux/falloc.h>",
            "#include <crypto/hash.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/wait.h>",
            "#include <linux/timer.h>",
            "#include <linux/mutex.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/quota.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extents_status.h\"\n#include <linux/compat.h>\n#include <linux/falloc.h>\n#include <crypto/hash.h>\n#include <linux/ratelimit.h>\n#include <linux/percpu_counter.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/wait.h>\n#include <linux/timer.h>\n#include <linux/mutex.h>\n#include <linux/seqlock.h>\n#include <linux/rbtree.h>\n#include <linux/rwsem.h>\n#include <linux/quota.h>\n#include <linux/jbd2.h>\n#include <linux/magic.h>\n#include <linux/blkdev.h>\n#include <linux/types.h>\n\nstatic inline struct ext4_sb_info *EXT4_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"mballoc.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4_extents.h\"\t/* Needed for trace points definition */\n#include \"ext4.h\"\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <asm/uaccess.h>\n#include <linux/cleancache.h>\n#include <linux/crc16.h>\n#include <linux/log2.h>\n#include <linux/ctype.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/random.h>\n#include <linux/vfs.h>\n#include <linux/exportfs.h>\n#include <linux/buffer_head.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/jbd2.h>\n#include <linux/vmalloc.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n#include <linux/string.h>\n#include <linux/module.h>\n\nstatic void ext4_mark_recovery_complete(struct super_block *sb,\n\t\t\t\t\tstruct ext4_super_block *es);\nstatic void ext4_clear_journal_err(struct super_block *sb,\n\t\t\t\t   struct ext4_super_block *es);\nstatic int ext4_unfreeze(struct super_block *sb);\nstatic int ext4_freeze(struct super_block *sb);\nstatic inline int ext2_feature_set_ok(struct super_block *sb);\nstatic inline int ext3_feature_set_ok(struct super_block *sb);\nstatic void ext4_unregister_li_request(struct super_block *sb);\n\nstatic void print_daily_error_info(unsigned long arg)\n{\n\tstruct super_block *sb = (struct super_block *) arg;\n\tstruct ext4_sb_info *sbi;\n\tstruct ext4_super_block *es;\n\n\tsbi = EXT4_SB(sb);\n\tes = sbi->s_es;\n\n\tif (es->s_error_count)\n\t\t/* fsck newer than v1.41.13 is needed to clean this condition. */\n\t\text4_msg(sb, KERN_NOTICE, \"error count since last fsck: %u\",\n\t\t\t le32_to_cpu(es->s_error_count));\n\tif (es->s_first_error_time) {\n\t\tprintk(KERN_NOTICE \"EXT4-fs (%s): initial error at time %u: %.*s:%d\",\n\t\t       sb->s_id, le32_to_cpu(es->s_first_error_time),\n\t\t       (int) sizeof(es->s_first_error_func),\n\t\t       es->s_first_error_func,\n\t\t       le32_to_cpu(es->s_first_error_line));\n\t\tif (es->s_first_error_ino)\n\t\t\tprintk(\": inode %u\",\n\t\t\t       le32_to_cpu(es->s_first_error_ino));\n\t\tif (es->s_first_error_block)\n\t\t\tprintk(\": block %llu\", (unsigned long long)\n\t\t\t       le64_to_cpu(es->s_first_error_block));\n\t\tprintk(\"\\n\");\n\t}\n\tif (es->s_last_error_time) {\n\t\tprintk(KERN_NOTICE \"EXT4-fs (%s): last error at time %u: %.*s:%d\",\n\t\t       sb->s_id, le32_to_cpu(es->s_last_error_time),\n\t\t       (int) sizeof(es->s_last_error_func),\n\t\t       es->s_last_error_func,\n\t\t       le32_to_cpu(es->s_last_error_line));\n\t\tif (es->s_last_error_ino)\n\t\t\tprintk(\": inode %u\",\n\t\t\t       le32_to_cpu(es->s_last_error_ino));\n\t\tif (es->s_last_error_block)\n\t\t\tprintk(\": block %llu\", (unsigned long long)\n\t\t\t       le64_to_cpu(es->s_last_error_block));\n\t\tprintk(\"\\n\");\n\t}\n\tmod_timer(&sbi->s_err_report, jiffies + 24*60*60*HZ);  /* Once a day */\n}"
  },
  {
    "function_name": "ext4_feature_set_ok",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/super.c",
    "lines": "2768-2826",
    "snippet": "static int ext4_feature_set_ok(struct super_block *sb, int readonly)\n{\n\tif (EXT4_HAS_INCOMPAT_FEATURE(sb, ~EXT4_FEATURE_INCOMPAT_SUPP)) {\n\t\text4_msg(sb, KERN_ERR,\n\t\t\t\"Couldn't mount because of \"\n\t\t\t\"unsupported optional features (%x)\",\n\t\t\t(le32_to_cpu(EXT4_SB(sb)->s_es->s_feature_incompat) &\n\t\t\t~EXT4_FEATURE_INCOMPAT_SUPP));\n\t\treturn 0;\n\t}\n\n\tif (readonly)\n\t\treturn 1;\n\n\tif (EXT4_HAS_RO_COMPAT_FEATURE(sb, EXT4_FEATURE_RO_COMPAT_READONLY)) {\n\t\text4_msg(sb, KERN_INFO, \"filesystem is read-only\");\n\t\tsb->s_flags |= MS_RDONLY;\n\t\treturn 1;\n\t}\n\n\t/* Check that feature set is OK for a read-write mount */\n\tif (EXT4_HAS_RO_COMPAT_FEATURE(sb, ~EXT4_FEATURE_RO_COMPAT_SUPP)) {\n\t\text4_msg(sb, KERN_ERR, \"couldn't mount RDWR because of \"\n\t\t\t \"unsupported optional features (%x)\",\n\t\t\t (le32_to_cpu(EXT4_SB(sb)->s_es->s_feature_ro_compat) &\n\t\t\t\t~EXT4_FEATURE_RO_COMPAT_SUPP));\n\t\treturn 0;\n\t}\n\t/*\n\t * Large file size enabled file system can only be mounted\n\t * read-write on 32-bit systems if kernel is built with CONFIG_LBDAF\n\t */\n\tif (EXT4_HAS_RO_COMPAT_FEATURE(sb, EXT4_FEATURE_RO_COMPAT_HUGE_FILE)) {\n\t\tif (sizeof(blkcnt_t) < sizeof(u64)) {\n\t\t\text4_msg(sb, KERN_ERR, \"Filesystem with huge files \"\n\t\t\t\t \"cannot be mounted RDWR without \"\n\t\t\t\t \"CONFIG_LBDAF\");\n\t\t\treturn 0;\n\t\t}\n\t}\n\tif (EXT4_HAS_RO_COMPAT_FEATURE(sb, EXT4_FEATURE_RO_COMPAT_BIGALLOC) &&\n\t    !EXT4_HAS_INCOMPAT_FEATURE(sb, EXT4_FEATURE_INCOMPAT_EXTENTS)) {\n\t\text4_msg(sb, KERN_ERR,\n\t\t\t \"Can't support bigalloc feature without \"\n\t\t\t \"extents feature\\n\");\n\t\treturn 0;\n\t}\n\n#ifndef CONFIG_QUOTA\n\tif (EXT4_HAS_RO_COMPAT_FEATURE(sb, EXT4_FEATURE_RO_COMPAT_QUOTA) &&\n\t    !readonly) {\n\t\text4_msg(sb, KERN_ERR,\n\t\t\t \"Filesystem with quota feature cannot be mounted RDWR \"\n\t\t\t \"without CONFIG_QUOTA\");\n\t\treturn 0;\n\t}\n#endif  /* CONFIG_QUOTA */\n\treturn 1;\n}",
    "includes": [
      "#include <trace/events/ext4.h>",
      "#include \"mballoc.h\"",
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"ext4_jbd2.h\"",
      "#include \"ext4_extents.h\"\t/* Needed for trace points definition */",
      "#include \"ext4.h\"",
      "#include <linux/freezer.h>",
      "#include <linux/kthread.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/cleancache.h>",
      "#include <linux/crc16.h>",
      "#include <linux/log2.h>",
      "#include <linux/ctype.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/namei.h>",
      "#include <linux/mount.h>",
      "#include <linux/random.h>",
      "#include <linux/vfs.h>",
      "#include <linux/exportfs.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/parser.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/init.h>",
      "#include <linux/slab.h>",
      "#include <linux/jbd2.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/time.h>",
      "#include <linux/fs.h>",
      "#include <linux/string.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ext4_unfreeze(struct super_block *sb);",
      "static int ext4_freeze(struct super_block *sb);",
      "static inline int ext2_feature_set_ok(struct super_block *sb);",
      "static inline int ext3_feature_set_ok(struct super_block *sb);",
      "static int ext4_feature_set_ok(struct super_block *sb, int readonly);",
      "static void ext4_unregister_li_request(struct super_block *sb);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ext4_msg",
          "args": [
            "sb",
            "KERN_ERR",
            "\"Filesystem with quota feature cannot be mounted RDWR \"\n\t\t\t \"without CONFIG_QUOTA\""
          ],
          "line": 2819
        },
        "resolved": true,
        "details": {
          "function_name": "__ext4_msg",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/super.c",
          "lines": "593-607",
          "snippet": "void __ext4_msg(struct super_block *sb,\n\t\tconst char *prefix, const char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tif (!___ratelimit(&(EXT4_SB(sb)->s_msg_ratelimit_state), \"EXT4-fs\"))\n\t\treturn;\n\n\tva_start(args, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\tprintk(\"%sEXT4-fs (%s): %pV\\n\", prefix, sb->s_id, &vaf);\n\tva_end(args);\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"mballoc.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include \"ext4_extents.h\"\t/* Needed for trace points definition */",
            "#include \"ext4.h\"",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/crc16.h>",
            "#include <linux/log2.h>",
            "#include <linux/ctype.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/random.h>",
            "#include <linux/vfs.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/parser.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/time.h>",
            "#include <linux/fs.h>",
            "#include <linux/string.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ext4_unfreeze(struct super_block *sb);",
            "static int ext4_freeze(struct super_block *sb);",
            "static inline int ext2_feature_set_ok(struct super_block *sb);",
            "static inline int ext3_feature_set_ok(struct super_block *sb);",
            "static void ext4_unregister_li_request(struct super_block *sb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"mballoc.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4_extents.h\"\t/* Needed for trace points definition */\n#include \"ext4.h\"\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <asm/uaccess.h>\n#include <linux/cleancache.h>\n#include <linux/crc16.h>\n#include <linux/log2.h>\n#include <linux/ctype.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/random.h>\n#include <linux/vfs.h>\n#include <linux/exportfs.h>\n#include <linux/buffer_head.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/jbd2.h>\n#include <linux/vmalloc.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n#include <linux/string.h>\n#include <linux/module.h>\n\nstatic int ext4_unfreeze(struct super_block *sb);\nstatic int ext4_freeze(struct super_block *sb);\nstatic inline int ext2_feature_set_ok(struct super_block *sb);\nstatic inline int ext3_feature_set_ok(struct super_block *sb);\nstatic void ext4_unregister_li_request(struct super_block *sb);\n\nvoid __ext4_msg(struct super_block *sb,\n\t\tconst char *prefix, const char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tif (!___ratelimit(&(EXT4_SB(sb)->s_msg_ratelimit_state), \"EXT4-fs\"))\n\t\treturn;\n\n\tva_start(args, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\tprintk(\"%sEXT4-fs (%s): %pV\\n\", prefix, sb->s_id, &vaf);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "EXT4_HAS_RO_COMPAT_FEATURE",
          "args": [
            "sb",
            "EXT4_FEATURE_RO_COMPAT_QUOTA"
          ],
          "line": 2817
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXT4_HAS_INCOMPAT_FEATURE",
          "args": [
            "sb",
            "EXT4_FEATURE_INCOMPAT_EXTENTS"
          ],
          "line": 2809
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXT4_HAS_RO_COMPAT_FEATURE",
          "args": [
            "sb",
            "EXT4_FEATURE_RO_COMPAT_BIGALLOC"
          ],
          "line": 2808
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXT4_HAS_RO_COMPAT_FEATURE",
          "args": [
            "sb",
            "EXT4_FEATURE_RO_COMPAT_HUGE_FILE"
          ],
          "line": 2800
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "EXT4_SB(sb)->s_es->s_feature_ro_compat"
          ],
          "line": 2792
        },
        "resolved": true,
        "details": {
          "function_name": "sle32_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "53-56",
          "snippet": "static inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "EXT4_SB",
          "args": [
            "sb"
          ],
          "line": 2792
        },
        "resolved": true,
        "details": {
          "function_name": "EXT4_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ext4.h",
          "lines": "1356-1359",
          "snippet": "static inline struct ext4_sb_info *EXT4_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include \"extents_status.h\"",
            "#include <linux/compat.h>",
            "#include <linux/falloc.h>",
            "#include <crypto/hash.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/wait.h>",
            "#include <linux/timer.h>",
            "#include <linux/mutex.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/quota.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extents_status.h\"\n#include <linux/compat.h>\n#include <linux/falloc.h>\n#include <crypto/hash.h>\n#include <linux/ratelimit.h>\n#include <linux/percpu_counter.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/wait.h>\n#include <linux/timer.h>\n#include <linux/mutex.h>\n#include <linux/seqlock.h>\n#include <linux/rbtree.h>\n#include <linux/rwsem.h>\n#include <linux/quota.h>\n#include <linux/jbd2.h>\n#include <linux/magic.h>\n#include <linux/blkdev.h>\n#include <linux/types.h>\n\nstatic inline struct ext4_sb_info *EXT4_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      },
      {
        "call_info": {
          "callee": "EXT4_HAS_RO_COMPAT_FEATURE",
          "args": [
            "sb",
            "~EXT4_FEATURE_RO_COMPAT_SUPP"
          ],
          "line": 2789
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXT4_HAS_RO_COMPAT_FEATURE",
          "args": [
            "sb",
            "EXT4_FEATURE_RO_COMPAT_READONLY"
          ],
          "line": 2782
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXT4_HAS_INCOMPAT_FEATURE",
          "args": [
            "sb",
            "~EXT4_FEATURE_INCOMPAT_SUPP"
          ],
          "line": 2770
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"mballoc.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4_extents.h\"\t/* Needed for trace points definition */\n#include \"ext4.h\"\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <asm/uaccess.h>\n#include <linux/cleancache.h>\n#include <linux/crc16.h>\n#include <linux/log2.h>\n#include <linux/ctype.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/random.h>\n#include <linux/vfs.h>\n#include <linux/exportfs.h>\n#include <linux/buffer_head.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/jbd2.h>\n#include <linux/vmalloc.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n#include <linux/string.h>\n#include <linux/module.h>\n\nstatic int ext4_unfreeze(struct super_block *sb);\nstatic int ext4_freeze(struct super_block *sb);\nstatic inline int ext2_feature_set_ok(struct super_block *sb);\nstatic inline int ext3_feature_set_ok(struct super_block *sb);\nstatic int ext4_feature_set_ok(struct super_block *sb, int readonly);\nstatic void ext4_unregister_li_request(struct super_block *sb);\n\nstatic int ext4_feature_set_ok(struct super_block *sb, int readonly)\n{\n\tif (EXT4_HAS_INCOMPAT_FEATURE(sb, ~EXT4_FEATURE_INCOMPAT_SUPP)) {\n\t\text4_msg(sb, KERN_ERR,\n\t\t\t\"Couldn't mount because of \"\n\t\t\t\"unsupported optional features (%x)\",\n\t\t\t(le32_to_cpu(EXT4_SB(sb)->s_es->s_feature_incompat) &\n\t\t\t~EXT4_FEATURE_INCOMPAT_SUPP));\n\t\treturn 0;\n\t}\n\n\tif (readonly)\n\t\treturn 1;\n\n\tif (EXT4_HAS_RO_COMPAT_FEATURE(sb, EXT4_FEATURE_RO_COMPAT_READONLY)) {\n\t\text4_msg(sb, KERN_INFO, \"filesystem is read-only\");\n\t\tsb->s_flags |= MS_RDONLY;\n\t\treturn 1;\n\t}\n\n\t/* Check that feature set is OK for a read-write mount */\n\tif (EXT4_HAS_RO_COMPAT_FEATURE(sb, ~EXT4_FEATURE_RO_COMPAT_SUPP)) {\n\t\text4_msg(sb, KERN_ERR, \"couldn't mount RDWR because of \"\n\t\t\t \"unsupported optional features (%x)\",\n\t\t\t (le32_to_cpu(EXT4_SB(sb)->s_es->s_feature_ro_compat) &\n\t\t\t\t~EXT4_FEATURE_RO_COMPAT_SUPP));\n\t\treturn 0;\n\t}\n\t/*\n\t * Large file size enabled file system can only be mounted\n\t * read-write on 32-bit systems if kernel is built with CONFIG_LBDAF\n\t */\n\tif (EXT4_HAS_RO_COMPAT_FEATURE(sb, EXT4_FEATURE_RO_COMPAT_HUGE_FILE)) {\n\t\tif (sizeof(blkcnt_t) < sizeof(u64)) {\n\t\t\text4_msg(sb, KERN_ERR, \"Filesystem with huge files \"\n\t\t\t\t \"cannot be mounted RDWR without \"\n\t\t\t\t \"CONFIG_LBDAF\");\n\t\t\treturn 0;\n\t\t}\n\t}\n\tif (EXT4_HAS_RO_COMPAT_FEATURE(sb, EXT4_FEATURE_RO_COMPAT_BIGALLOC) &&\n\t    !EXT4_HAS_INCOMPAT_FEATURE(sb, EXT4_FEATURE_INCOMPAT_EXTENTS)) {\n\t\text4_msg(sb, KERN_ERR,\n\t\t\t \"Can't support bigalloc feature without \"\n\t\t\t \"extents feature\\n\");\n\t\treturn 0;\n\t}\n\n#ifndef CONFIG_QUOTA\n\tif (EXT4_HAS_RO_COMPAT_FEATURE(sb, EXT4_FEATURE_RO_COMPAT_QUOTA) &&\n\t    !readonly) {\n\t\text4_msg(sb, KERN_ERR,\n\t\t\t \"Filesystem with quota feature cannot be mounted RDWR \"\n\t\t\t \"without CONFIG_QUOTA\");\n\t\treturn 0;\n\t}\n#endif  /* CONFIG_QUOTA */\n\treturn 1;\n}"
  },
  {
    "function_name": "ext4_feat_show",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/super.c",
    "lines": "2740-2744",
    "snippet": "static ssize_t ext4_feat_show(struct kobject *kobj,\n\t\t\t      struct attribute *attr, char *buf)\n{\n\treturn snprintf(buf, PAGE_SIZE, \"supported\\n\");\n}",
    "includes": [
      "#include <trace/events/ext4.h>",
      "#include \"mballoc.h\"",
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"ext4_jbd2.h\"",
      "#include \"ext4_extents.h\"\t/* Needed for trace points definition */",
      "#include \"ext4.h\"",
      "#include <linux/freezer.h>",
      "#include <linux/kthread.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/cleancache.h>",
      "#include <linux/crc16.h>",
      "#include <linux/log2.h>",
      "#include <linux/ctype.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/namei.h>",
      "#include <linux/mount.h>",
      "#include <linux/random.h>",
      "#include <linux/vfs.h>",
      "#include <linux/exportfs.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/parser.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/init.h>",
      "#include <linux/slab.h>",
      "#include <linux/jbd2.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/time.h>",
      "#include <linux/fs.h>",
      "#include <linux/string.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ext4_statfs(struct dentry *dentry, struct kstatfs *buf);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "buf",
            "PAGE_SIZE",
            "\"supported\\n\""
          ],
          "line": 2743
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"mballoc.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4_extents.h\"\t/* Needed for trace points definition */\n#include \"ext4.h\"\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <asm/uaccess.h>\n#include <linux/cleancache.h>\n#include <linux/crc16.h>\n#include <linux/log2.h>\n#include <linux/ctype.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/random.h>\n#include <linux/vfs.h>\n#include <linux/exportfs.h>\n#include <linux/buffer_head.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/jbd2.h>\n#include <linux/vmalloc.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n#include <linux/string.h>\n#include <linux/module.h>\n\nstatic int ext4_statfs(struct dentry *dentry, struct kstatfs *buf);\n\nstatic ssize_t ext4_feat_show(struct kobject *kobj,\n\t\t\t      struct attribute *attr, char *buf)\n{\n\treturn snprintf(buf, PAGE_SIZE, \"supported\\n\");\n}"
  },
  {
    "function_name": "ext4_feat_release",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/super.c",
    "lines": "2735-2738",
    "snippet": "static void ext4_feat_release(struct kobject *kobj)\n{\n\tcomplete(&ext4_feat->f_kobj_unregister);\n}",
    "includes": [
      "#include <trace/events/ext4.h>",
      "#include \"mballoc.h\"",
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"ext4_jbd2.h\"",
      "#include \"ext4_extents.h\"\t/* Needed for trace points definition */",
      "#include \"ext4.h\"",
      "#include <linux/freezer.h>",
      "#include <linux/kthread.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/cleancache.h>",
      "#include <linux/crc16.h>",
      "#include <linux/log2.h>",
      "#include <linux/ctype.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/namei.h>",
      "#include <linux/mount.h>",
      "#include <linux/random.h>",
      "#include <linux/vfs.h>",
      "#include <linux/exportfs.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/parser.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/init.h>",
      "#include <linux/slab.h>",
      "#include <linux/jbd2.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/time.h>",
      "#include <linux/fs.h>",
      "#include <linux/string.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct ext4_features *ext4_feat;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "complete",
          "args": [
            "&ext4_feat->f_kobj_unregister"
          ],
          "line": 2737
        },
        "resolved": true,
        "details": {
          "function_name": "ceph_dir_is_complete_ordered",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/super.h",
          "lines": "486-494",
          "snippet": "static inline bool ceph_dir_is_complete_ordered(struct inode *inode)\n{\n\tstruct ceph_inode_info *ci = ceph_inode(inode);\n\tbool ret;\n\tspin_lock(&ci->i_ceph_lock);\n\tret = __ceph_dir_is_complete_ordered(ci);\n\tspin_unlock(&ci->i_ceph_lock);\n\treturn ret;\n}",
          "includes": [
            "#include <linux/fscache.h>",
            "#include <linux/ceph/libceph.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/slab.h>",
            "#include <linux/writeback.h>",
            "#include <linux/wait.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mempool.h>",
            "#include <linux/fs.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/completion.h>",
            "#include <linux/backing-dev.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/fscache.h>\n#include <linux/ceph/libceph.h>\n#include <linux/posix_acl.h>\n#include <linux/slab.h>\n#include <linux/writeback.h>\n#include <linux/wait.h>\n#include <linux/pagemap.h>\n#include <linux/mempool.h>\n#include <linux/fs.h>\n#include <linux/exportfs.h>\n#include <linux/completion.h>\n#include <linux/backing-dev.h>\n#include <asm/unaligned.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic inline bool ceph_dir_is_complete_ordered(struct inode *inode)\n{\n\tstruct ceph_inode_info *ci = ceph_inode(inode);\n\tbool ret;\n\tspin_lock(&ci->i_ceph_lock);\n\tret = __ceph_dir_is_complete_ordered(ci);\n\tspin_unlock(&ci->i_ceph_lock);\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"mballoc.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4_extents.h\"\t/* Needed for trace points definition */\n#include \"ext4.h\"\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <asm/uaccess.h>\n#include <linux/cleancache.h>\n#include <linux/crc16.h>\n#include <linux/log2.h>\n#include <linux/ctype.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/random.h>\n#include <linux/vfs.h>\n#include <linux/exportfs.h>\n#include <linux/buffer_head.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/jbd2.h>\n#include <linux/vmalloc.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n#include <linux/string.h>\n#include <linux/module.h>\n\nstatic struct ext4_features *ext4_feat;\n\nstatic void ext4_feat_release(struct kobject *kobj)\n{\n\tcomplete(&ext4_feat->f_kobj_unregister);\n}"
  },
  {
    "function_name": "ext4_sb_release",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/super.c",
    "lines": "2717-2722",
    "snippet": "static void ext4_sb_release(struct kobject *kobj)\n{\n\tstruct ext4_sb_info *sbi = container_of(kobj, struct ext4_sb_info,\n\t\t\t\t\t\ts_kobj);\n\tcomplete(&sbi->s_kobj_unregister);\n}",
    "includes": [
      "#include <trace/events/ext4.h>",
      "#include \"mballoc.h\"",
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"ext4_jbd2.h\"",
      "#include \"ext4_extents.h\"\t/* Needed for trace points definition */",
      "#include \"ext4.h\"",
      "#include <linux/freezer.h>",
      "#include <linux/kthread.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/cleancache.h>",
      "#include <linux/crc16.h>",
      "#include <linux/log2.h>",
      "#include <linux/ctype.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/namei.h>",
      "#include <linux/mount.h>",
      "#include <linux/random.h>",
      "#include <linux/vfs.h>",
      "#include <linux/exportfs.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/parser.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/init.h>",
      "#include <linux/slab.h>",
      "#include <linux/jbd2.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/time.h>",
      "#include <linux/fs.h>",
      "#include <linux/string.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "complete",
          "args": [
            "&sbi->s_kobj_unregister"
          ],
          "line": 2721
        },
        "resolved": true,
        "details": {
          "function_name": "ceph_dir_is_complete_ordered",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/super.h",
          "lines": "486-494",
          "snippet": "static inline bool ceph_dir_is_complete_ordered(struct inode *inode)\n{\n\tstruct ceph_inode_info *ci = ceph_inode(inode);\n\tbool ret;\n\tspin_lock(&ci->i_ceph_lock);\n\tret = __ceph_dir_is_complete_ordered(ci);\n\tspin_unlock(&ci->i_ceph_lock);\n\treturn ret;\n}",
          "includes": [
            "#include <linux/fscache.h>",
            "#include <linux/ceph/libceph.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/slab.h>",
            "#include <linux/writeback.h>",
            "#include <linux/wait.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mempool.h>",
            "#include <linux/fs.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/completion.h>",
            "#include <linux/backing-dev.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/fscache.h>\n#include <linux/ceph/libceph.h>\n#include <linux/posix_acl.h>\n#include <linux/slab.h>\n#include <linux/writeback.h>\n#include <linux/wait.h>\n#include <linux/pagemap.h>\n#include <linux/mempool.h>\n#include <linux/fs.h>\n#include <linux/exportfs.h>\n#include <linux/completion.h>\n#include <linux/backing-dev.h>\n#include <asm/unaligned.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic inline bool ceph_dir_is_complete_ordered(struct inode *inode)\n{\n\tstruct ceph_inode_info *ci = ceph_inode(inode);\n\tbool ret;\n\tspin_lock(&ci->i_ceph_lock);\n\tret = __ceph_dir_is_complete_ordered(ci);\n\tspin_unlock(&ci->i_ceph_lock);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "kobj",
            "structext4_sb_info",
            "s_kobj"
          ],
          "line": 2719
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"mballoc.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4_extents.h\"\t/* Needed for trace points definition */\n#include \"ext4.h\"\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <asm/uaccess.h>\n#include <linux/cleancache.h>\n#include <linux/crc16.h>\n#include <linux/log2.h>\n#include <linux/ctype.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/random.h>\n#include <linux/vfs.h>\n#include <linux/exportfs.h>\n#include <linux/buffer_head.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/jbd2.h>\n#include <linux/vmalloc.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n#include <linux/string.h>\n#include <linux/module.h>\n\nstatic void ext4_sb_release(struct kobject *kobj)\n{\n\tstruct ext4_sb_info *sbi = container_of(kobj, struct ext4_sb_info,\n\t\t\t\t\t\ts_kobj);\n\tcomplete(&sbi->s_kobj_unregister);\n}"
  },
  {
    "function_name": "ext4_attr_store",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/super.c",
    "lines": "2706-2715",
    "snippet": "static ssize_t ext4_attr_store(struct kobject *kobj,\n\t\t\t       struct attribute *attr,\n\t\t\t       const char *buf, size_t len)\n{\n\tstruct ext4_sb_info *sbi = container_of(kobj, struct ext4_sb_info,\n\t\t\t\t\t\ts_kobj);\n\tstruct ext4_attr *a = container_of(attr, struct ext4_attr, attr);\n\n\treturn a->store ? a->store(a, sbi, buf, len) : 0;\n}",
    "includes": [
      "#include <trace/events/ext4.h>",
      "#include \"mballoc.h\"",
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"ext4_jbd2.h\"",
      "#include \"ext4_extents.h\"\t/* Needed for trace points definition */",
      "#include \"ext4.h\"",
      "#include <linux/freezer.h>",
      "#include <linux/kthread.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/cleancache.h>",
      "#include <linux/crc16.h>",
      "#include <linux/log2.h>",
      "#include <linux/ctype.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/namei.h>",
      "#include <linux/mount.h>",
      "#include <linux/random.h>",
      "#include <linux/vfs.h>",
      "#include <linux/exportfs.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/parser.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/init.h>",
      "#include <linux/slab.h>",
      "#include <linux/jbd2.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/time.h>",
      "#include <linux/fs.h>",
      "#include <linux/string.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ext4_statfs(struct dentry *dentry, struct kstatfs *buf);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "a->store",
          "args": [
            "a",
            "sbi",
            "buf",
            "len"
          ],
          "line": 2714
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "attr",
            "structext4_attr",
            "attr"
          ],
          "line": 2712
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "kobj",
            "structext4_sb_info",
            "s_kobj"
          ],
          "line": 2710
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"mballoc.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4_extents.h\"\t/* Needed for trace points definition */\n#include \"ext4.h\"\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <asm/uaccess.h>\n#include <linux/cleancache.h>\n#include <linux/crc16.h>\n#include <linux/log2.h>\n#include <linux/ctype.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/random.h>\n#include <linux/vfs.h>\n#include <linux/exportfs.h>\n#include <linux/buffer_head.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/jbd2.h>\n#include <linux/vmalloc.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n#include <linux/string.h>\n#include <linux/module.h>\n\nstatic int ext4_statfs(struct dentry *dentry, struct kstatfs *buf);\n\nstatic ssize_t ext4_attr_store(struct kobject *kobj,\n\t\t\t       struct attribute *attr,\n\t\t\t       const char *buf, size_t len)\n{\n\tstruct ext4_sb_info *sbi = container_of(kobj, struct ext4_sb_info,\n\t\t\t\t\t\ts_kobj);\n\tstruct ext4_attr *a = container_of(attr, struct ext4_attr, attr);\n\n\treturn a->store ? a->store(a, sbi, buf, len) : 0;\n}"
  },
  {
    "function_name": "ext4_attr_show",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/super.c",
    "lines": "2696-2704",
    "snippet": "static ssize_t ext4_attr_show(struct kobject *kobj,\n\t\t\t      struct attribute *attr, char *buf)\n{\n\tstruct ext4_sb_info *sbi = container_of(kobj, struct ext4_sb_info,\n\t\t\t\t\t\ts_kobj);\n\tstruct ext4_attr *a = container_of(attr, struct ext4_attr, attr);\n\n\treturn a->show ? a->show(a, sbi, buf) : 0;\n}",
    "includes": [
      "#include <trace/events/ext4.h>",
      "#include \"mballoc.h\"",
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"ext4_jbd2.h\"",
      "#include \"ext4_extents.h\"\t/* Needed for trace points definition */",
      "#include \"ext4.h\"",
      "#include <linux/freezer.h>",
      "#include <linux/kthread.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/cleancache.h>",
      "#include <linux/crc16.h>",
      "#include <linux/log2.h>",
      "#include <linux/ctype.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/namei.h>",
      "#include <linux/mount.h>",
      "#include <linux/random.h>",
      "#include <linux/vfs.h>",
      "#include <linux/exportfs.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/parser.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/init.h>",
      "#include <linux/slab.h>",
      "#include <linux/jbd2.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/time.h>",
      "#include <linux/fs.h>",
      "#include <linux/string.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ext4_statfs(struct dentry *dentry, struct kstatfs *buf);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "a->show",
          "args": [
            "a",
            "sbi",
            "buf"
          ],
          "line": 2703
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "attr",
            "structext4_attr",
            "attr"
          ],
          "line": 2701
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "kobj",
            "structext4_sb_info",
            "s_kobj"
          ],
          "line": 2699
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"mballoc.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4_extents.h\"\t/* Needed for trace points definition */\n#include \"ext4.h\"\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <asm/uaccess.h>\n#include <linux/cleancache.h>\n#include <linux/crc16.h>\n#include <linux/log2.h>\n#include <linux/ctype.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/random.h>\n#include <linux/vfs.h>\n#include <linux/exportfs.h>\n#include <linux/buffer_head.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/jbd2.h>\n#include <linux/vmalloc.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n#include <linux/string.h>\n#include <linux/module.h>\n\nstatic int ext4_statfs(struct dentry *dentry, struct kstatfs *buf);\n\nstatic ssize_t ext4_attr_show(struct kobject *kobj,\n\t\t\t      struct attribute *attr, char *buf)\n{\n\tstruct ext4_sb_info *sbi = container_of(kobj, struct ext4_sb_info,\n\t\t\t\t\t\ts_kobj);\n\tstruct ext4_attr *a = container_of(attr, struct ext4_attr, attr);\n\n\treturn a->show ? a->show(a, sbi, buf) : 0;\n}"
  },
  {
    "function_name": "sbi_deprecated_show",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/super.c",
    "lines": "2582-2586",
    "snippet": "static ssize_t sbi_deprecated_show(struct ext4_attr *a,\n\t\t\t\t   struct ext4_sb_info *sbi, char *buf)\n{\n\treturn snprintf(buf, PAGE_SIZE, \"%d\\n\", a->u.deprecated_val);\n}",
    "includes": [
      "#include <trace/events/ext4.h>",
      "#include \"mballoc.h\"",
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"ext4_jbd2.h\"",
      "#include \"ext4_extents.h\"\t/* Needed for trace points definition */",
      "#include \"ext4.h\"",
      "#include <linux/freezer.h>",
      "#include <linux/kthread.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/cleancache.h>",
      "#include <linux/crc16.h>",
      "#include <linux/log2.h>",
      "#include <linux/ctype.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/namei.h>",
      "#include <linux/mount.h>",
      "#include <linux/random.h>",
      "#include <linux/vfs.h>",
      "#include <linux/exportfs.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/parser.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/init.h>",
      "#include <linux/slab.h>",
      "#include <linux/jbd2.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/time.h>",
      "#include <linux/fs.h>",
      "#include <linux/string.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ext4_statfs(struct dentry *dentry, struct kstatfs *buf);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "buf",
            "PAGE_SIZE",
            "\"%d\\n\"",
            "a->u.deprecated_val"
          ],
          "line": 2585
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"mballoc.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4_extents.h\"\t/* Needed for trace points definition */\n#include \"ext4.h\"\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <asm/uaccess.h>\n#include <linux/cleancache.h>\n#include <linux/crc16.h>\n#include <linux/log2.h>\n#include <linux/ctype.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/random.h>\n#include <linux/vfs.h>\n#include <linux/exportfs.h>\n#include <linux/buffer_head.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/jbd2.h>\n#include <linux/vmalloc.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n#include <linux/string.h>\n#include <linux/module.h>\n\nstatic int ext4_statfs(struct dentry *dentry, struct kstatfs *buf);\n\nstatic ssize_t sbi_deprecated_show(struct ext4_attr *a,\n\t\t\t\t   struct ext4_sb_info *sbi, char *buf)\n{\n\treturn snprintf(buf, PAGE_SIZE, \"%d\\n\", a->u.deprecated_val);\n}"
  },
  {
    "function_name": "trigger_test_error",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/super.c",
    "lines": "2565-2580",
    "snippet": "static ssize_t trigger_test_error(struct ext4_attr *a,\n\t\t\t\t  struct ext4_sb_info *sbi,\n\t\t\t\t  const char *buf, size_t count)\n{\n\tint len = count;\n\n\tif (!capable(CAP_SYS_ADMIN))\n\t\treturn -EPERM;\n\n\tif (len && buf[len-1] == '\\n')\n\t\tlen--;\n\n\tif (len)\n\t\text4_error(sbi->s_sb, \"%.*s\", len, buf);\n\treturn count;\n}",
    "includes": [
      "#include <trace/events/ext4.h>",
      "#include \"mballoc.h\"",
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"ext4_jbd2.h\"",
      "#include \"ext4_extents.h\"\t/* Needed for trace points definition */",
      "#include \"ext4.h\"",
      "#include <linux/freezer.h>",
      "#include <linux/kthread.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/cleancache.h>",
      "#include <linux/crc16.h>",
      "#include <linux/log2.h>",
      "#include <linux/ctype.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/namei.h>",
      "#include <linux/mount.h>",
      "#include <linux/random.h>",
      "#include <linux/vfs.h>",
      "#include <linux/exportfs.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/parser.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/init.h>",
      "#include <linux/slab.h>",
      "#include <linux/jbd2.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/time.h>",
      "#include <linux/fs.h>",
      "#include <linux/string.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ext4_statfs(struct dentry *dentry, struct kstatfs *buf);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ext4_error",
          "args": [
            "sbi->s_sb",
            "\"%.*s\"",
            "len",
            "buf"
          ],
          "line": 2578
        },
        "resolved": true,
        "details": {
          "function_name": "__ext4_error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/super.c",
          "lines": "407-424",
          "snippet": "void __ext4_error(struct super_block *sb, const char *function,\n\t\t  unsigned int line, const char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tif (ext4_error_ratelimit(sb)) {\n\t\tva_start(args, fmt);\n\t\tvaf.fmt = fmt;\n\t\tvaf.va = &args;\n\t\tprintk(KERN_CRIT\n\t\t       \"EXT4-fs error (device %s): %s:%d: comm %s: %pV\\n\",\n\t\t       sb->s_id, function, line, current->comm, &vaf);\n\t\tva_end(args);\n\t}\n\tsave_error_info(sb, function, line);\n\text4_handle_error(sb);\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"mballoc.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include \"ext4_extents.h\"\t/* Needed for trace points definition */",
            "#include \"ext4.h\"",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/crc16.h>",
            "#include <linux/log2.h>",
            "#include <linux/ctype.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/random.h>",
            "#include <linux/vfs.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/parser.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/time.h>",
            "#include <linux/fs.h>",
            "#include <linux/string.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ext4_unfreeze(struct super_block *sb);",
            "static int ext4_freeze(struct super_block *sb);",
            "static inline int ext2_feature_set_ok(struct super_block *sb);",
            "static inline int ext3_feature_set_ok(struct super_block *sb);",
            "static void ext4_unregister_li_request(struct super_block *sb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"mballoc.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4_extents.h\"\t/* Needed for trace points definition */\n#include \"ext4.h\"\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <asm/uaccess.h>\n#include <linux/cleancache.h>\n#include <linux/crc16.h>\n#include <linux/log2.h>\n#include <linux/ctype.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/random.h>\n#include <linux/vfs.h>\n#include <linux/exportfs.h>\n#include <linux/buffer_head.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/jbd2.h>\n#include <linux/vmalloc.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n#include <linux/string.h>\n#include <linux/module.h>\n\nstatic int ext4_unfreeze(struct super_block *sb);\nstatic int ext4_freeze(struct super_block *sb);\nstatic inline int ext2_feature_set_ok(struct super_block *sb);\nstatic inline int ext3_feature_set_ok(struct super_block *sb);\nstatic void ext4_unregister_li_request(struct super_block *sb);\n\nvoid __ext4_error(struct super_block *sb, const char *function,\n\t\t  unsigned int line, const char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tif (ext4_error_ratelimit(sb)) {\n\t\tva_start(args, fmt);\n\t\tvaf.fmt = fmt;\n\t\tvaf.va = &args;\n\t\tprintk(KERN_CRIT\n\t\t       \"EXT4-fs error (device %s): %s:%d: comm %s: %pV\\n\",\n\t\t       sb->s_id, function, line, current->comm, &vaf);\n\t\tva_end(args);\n\t}\n\tsave_error_info(sb, function, line);\n\text4_handle_error(sb);\n}"
        }
      },
      {
        "call_info": {
          "callee": "capable",
          "args": [
            "CAP_SYS_ADMIN"
          ],
          "line": 2571
        },
        "resolved": true,
        "details": {
          "function_name": "inode_owner_or_capable",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "1901-1912",
          "snippet": "bool inode_owner_or_capable(const struct inode *inode)\n{\n\tstruct user_namespace *ns;\n\n\tif (uid_eq(current_fsuid(), inode->i_uid))\n\t\treturn true;\n\n\tns = current_user_ns();\n\tif (ns_capable(ns, CAP_FOWNER) && kuid_has_mapping(ns, inode->i_uid))\n\t\treturn true;\n\treturn false;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nbool inode_owner_or_capable(const struct inode *inode)\n{\n\tstruct user_namespace *ns;\n\n\tif (uid_eq(current_fsuid(), inode->i_uid))\n\t\treturn true;\n\n\tns = current_user_ns();\n\tif (ns_capable(ns, CAP_FOWNER) && kuid_has_mapping(ns, inode->i_uid))\n\t\treturn true;\n\treturn false;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"mballoc.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4_extents.h\"\t/* Needed for trace points definition */\n#include \"ext4.h\"\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <asm/uaccess.h>\n#include <linux/cleancache.h>\n#include <linux/crc16.h>\n#include <linux/log2.h>\n#include <linux/ctype.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/random.h>\n#include <linux/vfs.h>\n#include <linux/exportfs.h>\n#include <linux/buffer_head.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/jbd2.h>\n#include <linux/vmalloc.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n#include <linux/string.h>\n#include <linux/module.h>\n\nstatic int ext4_statfs(struct dentry *dentry, struct kstatfs *buf);\n\nstatic ssize_t trigger_test_error(struct ext4_attr *a,\n\t\t\t\t  struct ext4_sb_info *sbi,\n\t\t\t\t  const char *buf, size_t count)\n{\n\tint len = count;\n\n\tif (!capable(CAP_SYS_ADMIN))\n\t\treturn -EPERM;\n\n\tif (len && buf[len-1] == '\\n')\n\t\tlen--;\n\n\tif (len)\n\t\text4_error(sbi->s_sb, \"%.*s\", len, buf);\n\treturn count;\n}"
  },
  {
    "function_name": "reserved_clusters_store",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/super.c",
    "lines": "2551-2563",
    "snippet": "static ssize_t reserved_clusters_store(struct ext4_attr *a,\n\t\t\t\t   struct ext4_sb_info *sbi,\n\t\t\t\t   const char *buf, size_t count)\n{\n\tunsigned long long val;\n\tint ret;\n\n\tif (parse_strtoull(buf, -1ULL, &val))\n\t\treturn -EINVAL;\n\tret = ext4_reserve_clusters(sbi, val);\n\n\treturn ret ? ret : count;\n}",
    "includes": [
      "#include <trace/events/ext4.h>",
      "#include \"mballoc.h\"",
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"ext4_jbd2.h\"",
      "#include \"ext4_extents.h\"\t/* Needed for trace points definition */",
      "#include \"ext4.h\"",
      "#include <linux/freezer.h>",
      "#include <linux/kthread.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/cleancache.h>",
      "#include <linux/crc16.h>",
      "#include <linux/log2.h>",
      "#include <linux/ctype.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/namei.h>",
      "#include <linux/mount.h>",
      "#include <linux/random.h>",
      "#include <linux/vfs.h>",
      "#include <linux/exportfs.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/parser.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/init.h>",
      "#include <linux/slab.h>",
      "#include <linux/jbd2.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/time.h>",
      "#include <linux/fs.h>",
      "#include <linux/string.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ext4_statfs(struct dentry *dentry, struct kstatfs *buf);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ext4_reserve_clusters",
          "args": [
            "sbi",
            "val"
          ],
          "line": 2560
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_reserve_clusters",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/super.c",
          "lines": "3397-3407",
          "snippet": "static int ext4_reserve_clusters(struct ext4_sb_info *sbi, ext4_fsblk_t count)\n{\n\text4_fsblk_t clusters = ext4_blocks_count(sbi->s_es) >>\n\t\t\t\tsbi->s_cluster_bits;\n\n\tif (count >= clusters)\n\t\treturn -EINVAL;\n\n\tatomic64_set(&sbi->s_resv_clusters, count);\n\treturn 0;\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"mballoc.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include \"ext4_extents.h\"\t/* Needed for trace points definition */",
            "#include \"ext4.h\"",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/crc16.h>",
            "#include <linux/log2.h>",
            "#include <linux/ctype.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/random.h>",
            "#include <linux/vfs.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/parser.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/time.h>",
            "#include <linux/fs.h>",
            "#include <linux/string.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ext4_reserve_clusters(struct ext4_sb_info *, ext4_fsblk_t);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"mballoc.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4_extents.h\"\t/* Needed for trace points definition */\n#include \"ext4.h\"\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <asm/uaccess.h>\n#include <linux/cleancache.h>\n#include <linux/crc16.h>\n#include <linux/log2.h>\n#include <linux/ctype.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/random.h>\n#include <linux/vfs.h>\n#include <linux/exportfs.h>\n#include <linux/buffer_head.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/jbd2.h>\n#include <linux/vmalloc.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n#include <linux/string.h>\n#include <linux/module.h>\n\nstatic int ext4_reserve_clusters(struct ext4_sb_info *, ext4_fsblk_t);\n\nstatic int ext4_reserve_clusters(struct ext4_sb_info *sbi, ext4_fsblk_t count)\n{\n\text4_fsblk_t clusters = ext4_blocks_count(sbi->s_es) >>\n\t\t\t\tsbi->s_cluster_bits;\n\n\tif (count >= clusters)\n\t\treturn -EINVAL;\n\n\tatomic64_set(&sbi->s_resv_clusters, count);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "parse_strtoull",
          "args": [
            "buf",
            "-1ULL",
            "&val"
          ],
          "line": 2558
        },
        "resolved": true,
        "details": {
          "function_name": "parse_strtoull",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/super.c",
          "lines": "2448-2457",
          "snippet": "static int parse_strtoull(const char *buf,\n\t\tunsigned long long max, unsigned long long *value)\n{\n\tint ret;\n\n\tret = kstrtoull(skip_spaces(buf), 0, value);\n\tif (!ret && *value > max)\n\t\tret = -EINVAL;\n\treturn ret;\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"mballoc.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include \"ext4_extents.h\"\t/* Needed for trace points definition */",
            "#include \"ext4.h\"",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/crc16.h>",
            "#include <linux/log2.h>",
            "#include <linux/ctype.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/random.h>",
            "#include <linux/vfs.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/parser.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/time.h>",
            "#include <linux/fs.h>",
            "#include <linux/string.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ext4_statfs(struct dentry *dentry, struct kstatfs *buf);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"mballoc.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4_extents.h\"\t/* Needed for trace points definition */\n#include \"ext4.h\"\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <asm/uaccess.h>\n#include <linux/cleancache.h>\n#include <linux/crc16.h>\n#include <linux/log2.h>\n#include <linux/ctype.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/random.h>\n#include <linux/vfs.h>\n#include <linux/exportfs.h>\n#include <linux/buffer_head.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/jbd2.h>\n#include <linux/vmalloc.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n#include <linux/string.h>\n#include <linux/module.h>\n\nstatic int ext4_statfs(struct dentry *dentry, struct kstatfs *buf);\n\nstatic int parse_strtoull(const char *buf,\n\t\tunsigned long long max, unsigned long long *value)\n{\n\tint ret;\n\n\tret = kstrtoull(skip_spaces(buf), 0, value);\n\tif (!ret && *value > max)\n\t\tret = -EINVAL;\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"mballoc.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4_extents.h\"\t/* Needed for trace points definition */\n#include \"ext4.h\"\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <asm/uaccess.h>\n#include <linux/cleancache.h>\n#include <linux/crc16.h>\n#include <linux/log2.h>\n#include <linux/ctype.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/random.h>\n#include <linux/vfs.h>\n#include <linux/exportfs.h>\n#include <linux/buffer_head.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/jbd2.h>\n#include <linux/vmalloc.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n#include <linux/string.h>\n#include <linux/module.h>\n\nstatic int ext4_statfs(struct dentry *dentry, struct kstatfs *buf);\n\nstatic ssize_t reserved_clusters_store(struct ext4_attr *a,\n\t\t\t\t   struct ext4_sb_info *sbi,\n\t\t\t\t   const char *buf, size_t count)\n{\n\tunsigned long long val;\n\tint ret;\n\n\tif (parse_strtoull(buf, -1ULL, &val))\n\t\treturn -EINVAL;\n\tret = ext4_reserve_clusters(sbi, val);\n\n\treturn ret ? ret : count;\n}"
  },
  {
    "function_name": "reserved_clusters_show",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/super.c",
    "lines": "2544-2549",
    "snippet": "static ssize_t reserved_clusters_show(struct ext4_attr *a,\n\t\t\t\t  struct ext4_sb_info *sbi, char *buf)\n{\n\treturn snprintf(buf, PAGE_SIZE, \"%llu\\n\",\n\t\t(unsigned long long) atomic64_read(&sbi->s_resv_clusters));\n}",
    "includes": [
      "#include <trace/events/ext4.h>",
      "#include \"mballoc.h\"",
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"ext4_jbd2.h\"",
      "#include \"ext4_extents.h\"\t/* Needed for trace points definition */",
      "#include \"ext4.h\"",
      "#include <linux/freezer.h>",
      "#include <linux/kthread.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/cleancache.h>",
      "#include <linux/crc16.h>",
      "#include <linux/log2.h>",
      "#include <linux/ctype.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/namei.h>",
      "#include <linux/mount.h>",
      "#include <linux/random.h>",
      "#include <linux/vfs.h>",
      "#include <linux/exportfs.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/parser.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/init.h>",
      "#include <linux/slab.h>",
      "#include <linux/jbd2.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/time.h>",
      "#include <linux/fs.h>",
      "#include <linux/string.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ext4_statfs(struct dentry *dentry, struct kstatfs *buf);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "buf",
            "PAGE_SIZE",
            "\"%llu\\n\"",
            "(unsigned long long) atomic64_read(&sbi->s_resv_clusters)"
          ],
          "line": 2547
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic64_read",
          "args": [
            "&sbi->s_resv_clusters"
          ],
          "line": 2548
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"mballoc.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4_extents.h\"\t/* Needed for trace points definition */\n#include \"ext4.h\"\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <asm/uaccess.h>\n#include <linux/cleancache.h>\n#include <linux/crc16.h>\n#include <linux/log2.h>\n#include <linux/ctype.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/random.h>\n#include <linux/vfs.h>\n#include <linux/exportfs.h>\n#include <linux/buffer_head.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/jbd2.h>\n#include <linux/vmalloc.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n#include <linux/string.h>\n#include <linux/module.h>\n\nstatic int ext4_statfs(struct dentry *dentry, struct kstatfs *buf);\n\nstatic ssize_t reserved_clusters_show(struct ext4_attr *a,\n\t\t\t\t  struct ext4_sb_info *sbi, char *buf)\n{\n\treturn snprintf(buf, PAGE_SIZE, \"%llu\\n\",\n\t\t(unsigned long long) atomic64_read(&sbi->s_resv_clusters));\n}"
  },
  {
    "function_name": "es_ui_show",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/super.c",
    "lines": "2534-2542",
    "snippet": "static ssize_t es_ui_show(struct ext4_attr *a,\n\t\t\t   struct ext4_sb_info *sbi, char *buf)\n{\n\n\tunsigned int *ui = (unsigned int *) (((char *) sbi->s_es) +\n\t\t\t   a->u.offset);\n\n\treturn snprintf(buf, PAGE_SIZE, \"%u\\n\", *ui);\n}",
    "includes": [
      "#include <trace/events/ext4.h>",
      "#include \"mballoc.h\"",
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"ext4_jbd2.h\"",
      "#include \"ext4_extents.h\"\t/* Needed for trace points definition */",
      "#include \"ext4.h\"",
      "#include <linux/freezer.h>",
      "#include <linux/kthread.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/cleancache.h>",
      "#include <linux/crc16.h>",
      "#include <linux/log2.h>",
      "#include <linux/ctype.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/namei.h>",
      "#include <linux/mount.h>",
      "#include <linux/random.h>",
      "#include <linux/vfs.h>",
      "#include <linux/exportfs.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/parser.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/init.h>",
      "#include <linux/slab.h>",
      "#include <linux/jbd2.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/time.h>",
      "#include <linux/fs.h>",
      "#include <linux/string.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ext4_statfs(struct dentry *dentry, struct kstatfs *buf);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "buf",
            "PAGE_SIZE",
            "\"%u\\n\"",
            "*ui"
          ],
          "line": 2541
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"mballoc.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4_extents.h\"\t/* Needed for trace points definition */\n#include \"ext4.h\"\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <asm/uaccess.h>\n#include <linux/cleancache.h>\n#include <linux/crc16.h>\n#include <linux/log2.h>\n#include <linux/ctype.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/random.h>\n#include <linux/vfs.h>\n#include <linux/exportfs.h>\n#include <linux/buffer_head.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/jbd2.h>\n#include <linux/vmalloc.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n#include <linux/string.h>\n#include <linux/module.h>\n\nstatic int ext4_statfs(struct dentry *dentry, struct kstatfs *buf);\n\nstatic ssize_t es_ui_show(struct ext4_attr *a,\n\t\t\t   struct ext4_sb_info *sbi, char *buf)\n{\n\n\tunsigned int *ui = (unsigned int *) (((char *) sbi->s_es) +\n\t\t\t   a->u.offset);\n\n\treturn snprintf(buf, PAGE_SIZE, \"%u\\n\", *ui);\n}"
  },
  {
    "function_name": "sbi_ui_store",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/super.c",
    "lines": "2519-2532",
    "snippet": "static ssize_t sbi_ui_store(struct ext4_attr *a,\n\t\t\t    struct ext4_sb_info *sbi,\n\t\t\t    const char *buf, size_t count)\n{\n\tunsigned int *ui = (unsigned int *) (((char *) sbi) + a->u.offset);\n\tunsigned long t;\n\tint ret;\n\n\tret = kstrtoul(skip_spaces(buf), 0, &t);\n\tif (ret)\n\t\treturn ret;\n\t*ui = t;\n\treturn count;\n}",
    "includes": [
      "#include <trace/events/ext4.h>",
      "#include \"mballoc.h\"",
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"ext4_jbd2.h\"",
      "#include \"ext4_extents.h\"\t/* Needed for trace points definition */",
      "#include \"ext4.h\"",
      "#include <linux/freezer.h>",
      "#include <linux/kthread.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/cleancache.h>",
      "#include <linux/crc16.h>",
      "#include <linux/log2.h>",
      "#include <linux/ctype.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/namei.h>",
      "#include <linux/mount.h>",
      "#include <linux/random.h>",
      "#include <linux/vfs.h>",
      "#include <linux/exportfs.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/parser.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/init.h>",
      "#include <linux/slab.h>",
      "#include <linux/jbd2.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/time.h>",
      "#include <linux/fs.h>",
      "#include <linux/string.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ext4_statfs(struct dentry *dentry, struct kstatfs *buf);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kstrtoul",
          "args": [
            "skip_spaces(buf)",
            "0",
            "&t"
          ],
          "line": 2527
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "skip_spaces",
          "args": [
            "buf"
          ],
          "line": 2527
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"mballoc.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4_extents.h\"\t/* Needed for trace points definition */\n#include \"ext4.h\"\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <asm/uaccess.h>\n#include <linux/cleancache.h>\n#include <linux/crc16.h>\n#include <linux/log2.h>\n#include <linux/ctype.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/random.h>\n#include <linux/vfs.h>\n#include <linux/exportfs.h>\n#include <linux/buffer_head.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/jbd2.h>\n#include <linux/vmalloc.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n#include <linux/string.h>\n#include <linux/module.h>\n\nstatic int ext4_statfs(struct dentry *dentry, struct kstatfs *buf);\n\nstatic ssize_t sbi_ui_store(struct ext4_attr *a,\n\t\t\t    struct ext4_sb_info *sbi,\n\t\t\t    const char *buf, size_t count)\n{\n\tunsigned int *ui = (unsigned int *) (((char *) sbi) + a->u.offset);\n\tunsigned long t;\n\tint ret;\n\n\tret = kstrtoul(skip_spaces(buf), 0, &t);\n\tif (ret)\n\t\treturn ret;\n\t*ui = t;\n\treturn count;\n}"
  },
  {
    "function_name": "sbi_ui_show",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/super.c",
    "lines": "2511-2517",
    "snippet": "static ssize_t sbi_ui_show(struct ext4_attr *a,\n\t\t\t   struct ext4_sb_info *sbi, char *buf)\n{\n\tunsigned int *ui = (unsigned int *) (((char *) sbi) + a->u.offset);\n\n\treturn snprintf(buf, PAGE_SIZE, \"%u\\n\", *ui);\n}",
    "includes": [
      "#include <trace/events/ext4.h>",
      "#include \"mballoc.h\"",
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"ext4_jbd2.h\"",
      "#include \"ext4_extents.h\"\t/* Needed for trace points definition */",
      "#include \"ext4.h\"",
      "#include <linux/freezer.h>",
      "#include <linux/kthread.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/cleancache.h>",
      "#include <linux/crc16.h>",
      "#include <linux/log2.h>",
      "#include <linux/ctype.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/namei.h>",
      "#include <linux/mount.h>",
      "#include <linux/random.h>",
      "#include <linux/vfs.h>",
      "#include <linux/exportfs.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/parser.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/init.h>",
      "#include <linux/slab.h>",
      "#include <linux/jbd2.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/time.h>",
      "#include <linux/fs.h>",
      "#include <linux/string.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ext4_statfs(struct dentry *dentry, struct kstatfs *buf);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "buf",
            "PAGE_SIZE",
            "\"%u\\n\"",
            "*ui"
          ],
          "line": 2516
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"mballoc.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4_extents.h\"\t/* Needed for trace points definition */\n#include \"ext4.h\"\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <asm/uaccess.h>\n#include <linux/cleancache.h>\n#include <linux/crc16.h>\n#include <linux/log2.h>\n#include <linux/ctype.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/random.h>\n#include <linux/vfs.h>\n#include <linux/exportfs.h>\n#include <linux/buffer_head.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/jbd2.h>\n#include <linux/vmalloc.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n#include <linux/string.h>\n#include <linux/module.h>\n\nstatic int ext4_statfs(struct dentry *dentry, struct kstatfs *buf);\n\nstatic ssize_t sbi_ui_show(struct ext4_attr *a,\n\t\t\t   struct ext4_sb_info *sbi, char *buf)\n{\n\tunsigned int *ui = (unsigned int *) (((char *) sbi) + a->u.offset);\n\n\treturn snprintf(buf, PAGE_SIZE, \"%u\\n\", *ui);\n}"
  },
  {
    "function_name": "inode_readahead_blks_store",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/super.c",
    "lines": "2493-2509",
    "snippet": "static ssize_t inode_readahead_blks_store(struct ext4_attr *a,\n\t\t\t\t\t  struct ext4_sb_info *sbi,\n\t\t\t\t\t  const char *buf, size_t count)\n{\n\tunsigned long t;\n\tint ret;\n\n\tret = kstrtoul(skip_spaces(buf), 0, &t);\n\tif (ret)\n\t\treturn ret;\n\n\tif (t && (!is_power_of_2(t) || t > 0x40000000))\n\t\treturn -EINVAL;\n\n\tsbi->s_inode_readahead_blks = t;\n\treturn count;\n}",
    "includes": [
      "#include <trace/events/ext4.h>",
      "#include \"mballoc.h\"",
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"ext4_jbd2.h\"",
      "#include \"ext4_extents.h\"\t/* Needed for trace points definition */",
      "#include \"ext4.h\"",
      "#include <linux/freezer.h>",
      "#include <linux/kthread.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/cleancache.h>",
      "#include <linux/crc16.h>",
      "#include <linux/log2.h>",
      "#include <linux/ctype.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/namei.h>",
      "#include <linux/mount.h>",
      "#include <linux/random.h>",
      "#include <linux/vfs.h>",
      "#include <linux/exportfs.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/parser.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/init.h>",
      "#include <linux/slab.h>",
      "#include <linux/jbd2.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/time.h>",
      "#include <linux/fs.h>",
      "#include <linux/string.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ext4_statfs(struct dentry *dentry, struct kstatfs *buf);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "is_power_of_2",
          "args": [
            "t"
          ],
          "line": 2504
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kstrtoul",
          "args": [
            "skip_spaces(buf)",
            "0",
            "&t"
          ],
          "line": 2500
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "skip_spaces",
          "args": [
            "buf"
          ],
          "line": 2500
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"mballoc.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4_extents.h\"\t/* Needed for trace points definition */\n#include \"ext4.h\"\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <asm/uaccess.h>\n#include <linux/cleancache.h>\n#include <linux/crc16.h>\n#include <linux/log2.h>\n#include <linux/ctype.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/random.h>\n#include <linux/vfs.h>\n#include <linux/exportfs.h>\n#include <linux/buffer_head.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/jbd2.h>\n#include <linux/vmalloc.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n#include <linux/string.h>\n#include <linux/module.h>\n\nstatic int ext4_statfs(struct dentry *dentry, struct kstatfs *buf);\n\nstatic ssize_t inode_readahead_blks_store(struct ext4_attr *a,\n\t\t\t\t\t  struct ext4_sb_info *sbi,\n\t\t\t\t\t  const char *buf, size_t count)\n{\n\tunsigned long t;\n\tint ret;\n\n\tret = kstrtoul(skip_spaces(buf), 0, &t);\n\tif (ret)\n\t\treturn ret;\n\n\tif (t && (!is_power_of_2(t) || t > 0x40000000))\n\t\treturn -EINVAL;\n\n\tsbi->s_inode_readahead_blks = t;\n\treturn count;\n}"
  },
  {
    "function_name": "lifetime_write_kbytes_show",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/super.c",
    "lines": "2480-2491",
    "snippet": "static ssize_t lifetime_write_kbytes_show(struct ext4_attr *a,\n\t\t\t\t\t  struct ext4_sb_info *sbi, char *buf)\n{\n\tstruct super_block *sb = sbi->s_buddy_cache->i_sb;\n\n\tif (!sb->s_bdev->bd_part)\n\t\treturn snprintf(buf, PAGE_SIZE, \"0\\n\");\n\treturn snprintf(buf, PAGE_SIZE, \"%llu\\n\",\n\t\t\t(unsigned long long)(sbi->s_kbytes_written +\n\t\t\t((part_stat_read(sb->s_bdev->bd_part, sectors[1]) -\n\t\t\t  EXT4_SB(sb)->s_sectors_written_start) >> 1)));\n}",
    "includes": [
      "#include <trace/events/ext4.h>",
      "#include \"mballoc.h\"",
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"ext4_jbd2.h\"",
      "#include \"ext4_extents.h\"\t/* Needed for trace points definition */",
      "#include \"ext4.h\"",
      "#include <linux/freezer.h>",
      "#include <linux/kthread.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/cleancache.h>",
      "#include <linux/crc16.h>",
      "#include <linux/log2.h>",
      "#include <linux/ctype.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/namei.h>",
      "#include <linux/mount.h>",
      "#include <linux/random.h>",
      "#include <linux/vfs.h>",
      "#include <linux/exportfs.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/parser.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/init.h>",
      "#include <linux/slab.h>",
      "#include <linux/jbd2.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/time.h>",
      "#include <linux/fs.h>",
      "#include <linux/string.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ext4_statfs(struct dentry *dentry, struct kstatfs *buf);",
      "static int ext4_unfreeze(struct super_block *sb);",
      "static int ext4_freeze(struct super_block *sb);",
      "static inline int ext2_feature_set_ok(struct super_block *sb);",
      "static inline int ext3_feature_set_ok(struct super_block *sb);",
      "static void ext4_unregister_li_request(struct super_block *sb);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "buf",
            "PAGE_SIZE",
            "\"%llu\\n\"",
            "(unsigned long long)(sbi->s_kbytes_written +\n\t\t\t((part_stat_read(sb->s_bdev->bd_part, sectors[1]) -\n\t\t\t  EXT4_SB(sb)->s_sectors_written_start) >> 1))"
          ],
          "line": 2487
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXT4_SB",
          "args": [
            "sb"
          ],
          "line": 2490
        },
        "resolved": true,
        "details": {
          "function_name": "EXT4_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ext4.h",
          "lines": "1356-1359",
          "snippet": "static inline struct ext4_sb_info *EXT4_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include \"extents_status.h\"",
            "#include <linux/compat.h>",
            "#include <linux/falloc.h>",
            "#include <crypto/hash.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/wait.h>",
            "#include <linux/timer.h>",
            "#include <linux/mutex.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/quota.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extents_status.h\"\n#include <linux/compat.h>\n#include <linux/falloc.h>\n#include <crypto/hash.h>\n#include <linux/ratelimit.h>\n#include <linux/percpu_counter.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/wait.h>\n#include <linux/timer.h>\n#include <linux/mutex.h>\n#include <linux/seqlock.h>\n#include <linux/rbtree.h>\n#include <linux/rwsem.h>\n#include <linux/quota.h>\n#include <linux/jbd2.h>\n#include <linux/magic.h>\n#include <linux/blkdev.h>\n#include <linux/types.h>\n\nstatic inline struct ext4_sb_info *EXT4_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      },
      {
        "call_info": {
          "callee": "part_stat_read",
          "args": [
            "sb->s_bdev->bd_part",
            "sectors[1]"
          ],
          "line": 2489
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "buf",
            "PAGE_SIZE",
            "\"0\\n\""
          ],
          "line": 2486
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"mballoc.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4_extents.h\"\t/* Needed for trace points definition */\n#include \"ext4.h\"\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <asm/uaccess.h>\n#include <linux/cleancache.h>\n#include <linux/crc16.h>\n#include <linux/log2.h>\n#include <linux/ctype.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/random.h>\n#include <linux/vfs.h>\n#include <linux/exportfs.h>\n#include <linux/buffer_head.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/jbd2.h>\n#include <linux/vmalloc.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n#include <linux/string.h>\n#include <linux/module.h>\n\nstatic int ext4_statfs(struct dentry *dentry, struct kstatfs *buf);\nstatic int ext4_unfreeze(struct super_block *sb);\nstatic int ext4_freeze(struct super_block *sb);\nstatic inline int ext2_feature_set_ok(struct super_block *sb);\nstatic inline int ext3_feature_set_ok(struct super_block *sb);\nstatic void ext4_unregister_li_request(struct super_block *sb);\n\nstatic ssize_t lifetime_write_kbytes_show(struct ext4_attr *a,\n\t\t\t\t\t  struct ext4_sb_info *sbi, char *buf)\n{\n\tstruct super_block *sb = sbi->s_buddy_cache->i_sb;\n\n\tif (!sb->s_bdev->bd_part)\n\t\treturn snprintf(buf, PAGE_SIZE, \"0\\n\");\n\treturn snprintf(buf, PAGE_SIZE, \"%llu\\n\",\n\t\t\t(unsigned long long)(sbi->s_kbytes_written +\n\t\t\t((part_stat_read(sb->s_bdev->bd_part, sectors[1]) -\n\t\t\t  EXT4_SB(sb)->s_sectors_written_start) >> 1)));\n}"
  },
  {
    "function_name": "session_write_kbytes_show",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/super.c",
    "lines": "2468-2478",
    "snippet": "static ssize_t session_write_kbytes_show(struct ext4_attr *a,\n\t\t\t\t\t struct ext4_sb_info *sbi, char *buf)\n{\n\tstruct super_block *sb = sbi->s_buddy_cache->i_sb;\n\n\tif (!sb->s_bdev->bd_part)\n\t\treturn snprintf(buf, PAGE_SIZE, \"0\\n\");\n\treturn snprintf(buf, PAGE_SIZE, \"%lu\\n\",\n\t\t\t(part_stat_read(sb->s_bdev->bd_part, sectors[1]) -\n\t\t\t sbi->s_sectors_written_start) >> 1);\n}",
    "includes": [
      "#include <trace/events/ext4.h>",
      "#include \"mballoc.h\"",
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"ext4_jbd2.h\"",
      "#include \"ext4_extents.h\"\t/* Needed for trace points definition */",
      "#include \"ext4.h\"",
      "#include <linux/freezer.h>",
      "#include <linux/kthread.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/cleancache.h>",
      "#include <linux/crc16.h>",
      "#include <linux/log2.h>",
      "#include <linux/ctype.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/namei.h>",
      "#include <linux/mount.h>",
      "#include <linux/random.h>",
      "#include <linux/vfs.h>",
      "#include <linux/exportfs.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/parser.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/init.h>",
      "#include <linux/slab.h>",
      "#include <linux/jbd2.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/time.h>",
      "#include <linux/fs.h>",
      "#include <linux/string.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ext4_statfs(struct dentry *dentry, struct kstatfs *buf);",
      "static int ext4_unfreeze(struct super_block *sb);",
      "static int ext4_freeze(struct super_block *sb);",
      "static inline int ext2_feature_set_ok(struct super_block *sb);",
      "static inline int ext3_feature_set_ok(struct super_block *sb);",
      "static void ext4_unregister_li_request(struct super_block *sb);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "buf",
            "PAGE_SIZE",
            "\"%lu\\n\"",
            "(part_stat_read(sb->s_bdev->bd_part, sectors[1]) -\n\t\t\t sbi->s_sectors_written_start) >> 1"
          ],
          "line": 2475
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "part_stat_read",
          "args": [
            "sb->s_bdev->bd_part",
            "sectors[1]"
          ],
          "line": 2476
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "buf",
            "PAGE_SIZE",
            "\"0\\n\""
          ],
          "line": 2474
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"mballoc.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4_extents.h\"\t/* Needed for trace points definition */\n#include \"ext4.h\"\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <asm/uaccess.h>\n#include <linux/cleancache.h>\n#include <linux/crc16.h>\n#include <linux/log2.h>\n#include <linux/ctype.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/random.h>\n#include <linux/vfs.h>\n#include <linux/exportfs.h>\n#include <linux/buffer_head.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/jbd2.h>\n#include <linux/vmalloc.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n#include <linux/string.h>\n#include <linux/module.h>\n\nstatic int ext4_statfs(struct dentry *dentry, struct kstatfs *buf);\nstatic int ext4_unfreeze(struct super_block *sb);\nstatic int ext4_freeze(struct super_block *sb);\nstatic inline int ext2_feature_set_ok(struct super_block *sb);\nstatic inline int ext3_feature_set_ok(struct super_block *sb);\nstatic void ext4_unregister_li_request(struct super_block *sb);\n\nstatic ssize_t session_write_kbytes_show(struct ext4_attr *a,\n\t\t\t\t\t struct ext4_sb_info *sbi, char *buf)\n{\n\tstruct super_block *sb = sbi->s_buddy_cache->i_sb;\n\n\tif (!sb->s_bdev->bd_part)\n\t\treturn snprintf(buf, PAGE_SIZE, \"0\\n\");\n\treturn snprintf(buf, PAGE_SIZE, \"%lu\\n\",\n\t\t\t(part_stat_read(sb->s_bdev->bd_part, sectors[1]) -\n\t\t\t sbi->s_sectors_written_start) >> 1);\n}"
  },
  {
    "function_name": "delayed_allocation_blocks_show",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/super.c",
    "lines": "2459-2466",
    "snippet": "static ssize_t delayed_allocation_blocks_show(struct ext4_attr *a,\n\t\t\t\t\t      struct ext4_sb_info *sbi,\n\t\t\t\t\t      char *buf)\n{\n\treturn snprintf(buf, PAGE_SIZE, \"%llu\\n\",\n\t\t(s64) EXT4_C2B(sbi,\n\t\t\tpercpu_counter_sum(&sbi->s_dirtyclusters_counter)));\n}",
    "includes": [
      "#include <trace/events/ext4.h>",
      "#include \"mballoc.h\"",
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"ext4_jbd2.h\"",
      "#include \"ext4_extents.h\"\t/* Needed for trace points definition */",
      "#include \"ext4.h\"",
      "#include <linux/freezer.h>",
      "#include <linux/kthread.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/cleancache.h>",
      "#include <linux/crc16.h>",
      "#include <linux/log2.h>",
      "#include <linux/ctype.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/namei.h>",
      "#include <linux/mount.h>",
      "#include <linux/random.h>",
      "#include <linux/vfs.h>",
      "#include <linux/exportfs.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/parser.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/init.h>",
      "#include <linux/slab.h>",
      "#include <linux/jbd2.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/time.h>",
      "#include <linux/fs.h>",
      "#include <linux/string.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ext4_statfs(struct dentry *dentry, struct kstatfs *buf);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "buf",
            "PAGE_SIZE",
            "\"%llu\\n\"",
            "(s64) EXT4_C2B(sbi,\n\t\t\tpercpu_counter_sum(&sbi->s_dirtyclusters_counter))"
          ],
          "line": 2463
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXT4_C2B",
          "args": [
            "sbi",
            "percpu_counter_sum(&sbi->s_dirtyclusters_counter)"
          ],
          "line": 2464
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "percpu_counter_sum",
          "args": [
            "&sbi->s_dirtyclusters_counter"
          ],
          "line": 2465
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"mballoc.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4_extents.h\"\t/* Needed for trace points definition */\n#include \"ext4.h\"\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <asm/uaccess.h>\n#include <linux/cleancache.h>\n#include <linux/crc16.h>\n#include <linux/log2.h>\n#include <linux/ctype.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/random.h>\n#include <linux/vfs.h>\n#include <linux/exportfs.h>\n#include <linux/buffer_head.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/jbd2.h>\n#include <linux/vmalloc.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n#include <linux/string.h>\n#include <linux/module.h>\n\nstatic int ext4_statfs(struct dentry *dentry, struct kstatfs *buf);\n\nstatic ssize_t delayed_allocation_blocks_show(struct ext4_attr *a,\n\t\t\t\t\t      struct ext4_sb_info *sbi,\n\t\t\t\t\t      char *buf)\n{\n\treturn snprintf(buf, PAGE_SIZE, \"%llu\\n\",\n\t\t(s64) EXT4_C2B(sbi,\n\t\t\tpercpu_counter_sum(&sbi->s_dirtyclusters_counter)));\n}"
  },
  {
    "function_name": "parse_strtoull",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/super.c",
    "lines": "2448-2457",
    "snippet": "static int parse_strtoull(const char *buf,\n\t\tunsigned long long max, unsigned long long *value)\n{\n\tint ret;\n\n\tret = kstrtoull(skip_spaces(buf), 0, value);\n\tif (!ret && *value > max)\n\t\tret = -EINVAL;\n\treturn ret;\n}",
    "includes": [
      "#include <trace/events/ext4.h>",
      "#include \"mballoc.h\"",
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"ext4_jbd2.h\"",
      "#include \"ext4_extents.h\"\t/* Needed for trace points definition */",
      "#include \"ext4.h\"",
      "#include <linux/freezer.h>",
      "#include <linux/kthread.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/cleancache.h>",
      "#include <linux/crc16.h>",
      "#include <linux/log2.h>",
      "#include <linux/ctype.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/namei.h>",
      "#include <linux/mount.h>",
      "#include <linux/random.h>",
      "#include <linux/vfs.h>",
      "#include <linux/exportfs.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/parser.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/init.h>",
      "#include <linux/slab.h>",
      "#include <linux/jbd2.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/time.h>",
      "#include <linux/fs.h>",
      "#include <linux/string.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ext4_statfs(struct dentry *dentry, struct kstatfs *buf);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kstrtoull",
          "args": [
            "skip_spaces(buf)",
            "0",
            "value"
          ],
          "line": 2453
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "skip_spaces",
          "args": [
            "buf"
          ],
          "line": 2453
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"mballoc.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4_extents.h\"\t/* Needed for trace points definition */\n#include \"ext4.h\"\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <asm/uaccess.h>\n#include <linux/cleancache.h>\n#include <linux/crc16.h>\n#include <linux/log2.h>\n#include <linux/ctype.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/random.h>\n#include <linux/vfs.h>\n#include <linux/exportfs.h>\n#include <linux/buffer_head.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/jbd2.h>\n#include <linux/vmalloc.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n#include <linux/string.h>\n#include <linux/module.h>\n\nstatic int ext4_statfs(struct dentry *dentry, struct kstatfs *buf);\n\nstatic int parse_strtoull(const char *buf,\n\t\tunsigned long long max, unsigned long long *value)\n{\n\tint ret;\n\n\tret = kstrtoull(skip_spaces(buf), 0, value);\n\tif (!ret && *value > max)\n\t\tret = -EINVAL;\n\treturn ret;\n}"
  },
  {
    "function_name": "ext4_get_stripe_size",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/super.c",
    "lines": "2409-2433",
    "snippet": "static unsigned long ext4_get_stripe_size(struct ext4_sb_info *sbi)\n{\n\tunsigned long stride = le16_to_cpu(sbi->s_es->s_raid_stride);\n\tunsigned long stripe_width =\n\t\t\tle32_to_cpu(sbi->s_es->s_raid_stripe_width);\n\tint ret;\n\n\tif (sbi->s_stripe && sbi->s_stripe <= sbi->s_blocks_per_group)\n\t\tret = sbi->s_stripe;\n\telse if (stripe_width <= sbi->s_blocks_per_group)\n\t\tret = stripe_width;\n\telse if (stride <= sbi->s_blocks_per_group)\n\t\tret = stride;\n\telse\n\t\tret = 0;\n\n\t/*\n\t * If the stripe width is 1, this makes no sense and\n\t * we set it to 0 to turn off stripe handling code.\n\t */\n\tif (ret <= 1)\n\t\tret = 0;\n\n\treturn ret;\n}",
    "includes": [
      "#include <trace/events/ext4.h>",
      "#include \"mballoc.h\"",
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"ext4_jbd2.h\"",
      "#include \"ext4_extents.h\"\t/* Needed for trace points definition */",
      "#include \"ext4.h\"",
      "#include <linux/freezer.h>",
      "#include <linux/kthread.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/cleancache.h>",
      "#include <linux/crc16.h>",
      "#include <linux/log2.h>",
      "#include <linux/ctype.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/namei.h>",
      "#include <linux/mount.h>",
      "#include <linux/random.h>",
      "#include <linux/vfs.h>",
      "#include <linux/exportfs.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/parser.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/init.h>",
      "#include <linux/slab.h>",
      "#include <linux/jbd2.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/time.h>",
      "#include <linux/fs.h>",
      "#include <linux/string.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "sbi->s_es->s_raid_stripe_width"
          ],
          "line": 2413
        },
        "resolved": true,
        "details": {
          "function_name": "sle32_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "53-56",
          "snippet": "static inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "le16_to_cpu",
          "args": [
            "sbi->s_es->s_raid_stride"
          ],
          "line": 2411
        },
        "resolved": true,
        "details": {
          "function_name": "sle16_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "48-51",
          "snippet": "static inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"mballoc.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4_extents.h\"\t/* Needed for trace points definition */\n#include \"ext4.h\"\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <asm/uaccess.h>\n#include <linux/cleancache.h>\n#include <linux/crc16.h>\n#include <linux/log2.h>\n#include <linux/ctype.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/random.h>\n#include <linux/vfs.h>\n#include <linux/exportfs.h>\n#include <linux/buffer_head.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/jbd2.h>\n#include <linux/vmalloc.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n#include <linux/string.h>\n#include <linux/module.h>\n\nstatic unsigned long ext4_get_stripe_size(struct ext4_sb_info *sbi)\n{\n\tunsigned long stride = le16_to_cpu(sbi->s_es->s_raid_stride);\n\tunsigned long stripe_width =\n\t\t\tle32_to_cpu(sbi->s_es->s_raid_stripe_width);\n\tint ret;\n\n\tif (sbi->s_stripe && sbi->s_stripe <= sbi->s_blocks_per_group)\n\t\tret = sbi->s_stripe;\n\telse if (stripe_width <= sbi->s_blocks_per_group)\n\t\tret = stripe_width;\n\telse if (stride <= sbi->s_blocks_per_group)\n\t\tret = stride;\n\telse\n\t\tret = 0;\n\n\t/*\n\t * If the stripe width is 1, this makes no sense and\n\t * we set it to 0 to turn off stripe handling code.\n\t */\n\tif (ret <= 1)\n\t\tret = 0;\n\n\treturn ret;\n}"
  },
  {
    "function_name": "descriptor_loc",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/super.c",
    "lines": "2369-2396",
    "snippet": "static ext4_fsblk_t descriptor_loc(struct super_block *sb,\n\t\t\t\t   ext4_fsblk_t logical_sb_block, int nr)\n{\n\tstruct ext4_sb_info *sbi = EXT4_SB(sb);\n\text4_group_t bg, first_meta_bg;\n\tint has_super = 0;\n\n\tfirst_meta_bg = le32_to_cpu(sbi->s_es->s_first_meta_bg);\n\n\tif (!EXT4_HAS_INCOMPAT_FEATURE(sb, EXT4_FEATURE_INCOMPAT_META_BG) ||\n\t    nr < first_meta_bg)\n\t\treturn logical_sb_block + nr + 1;\n\tbg = sbi->s_desc_per_block * nr;\n\tif (ext4_bg_has_super(sb, bg))\n\t\thas_super = 1;\n\n\t/*\n\t * If we have a meta_bg fs with 1k blocks, group 0's GDT is at\n\t * block 2, not 1.  If s_first_data_block == 0 (bigalloc is enabled\n\t * on modern mke2fs or blksize > 1k on older mke2fs) then we must\n\t * compensate.\n\t */\n\tif (sb->s_blocksize == 1024 && nr == 0 &&\n\t    le32_to_cpu(EXT4_SB(sb)->s_es->s_first_data_block) == 0)\n\t\thas_super++;\n\n\treturn (has_super + ext4_group_first_block_no(sb, bg));\n}",
    "includes": [
      "#include <trace/events/ext4.h>",
      "#include \"mballoc.h\"",
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"ext4_jbd2.h\"",
      "#include \"ext4_extents.h\"\t/* Needed for trace points definition */",
      "#include \"ext4.h\"",
      "#include <linux/freezer.h>",
      "#include <linux/kthread.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/cleancache.h>",
      "#include <linux/crc16.h>",
      "#include <linux/log2.h>",
      "#include <linux/ctype.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/namei.h>",
      "#include <linux/mount.h>",
      "#include <linux/random.h>",
      "#include <linux/vfs.h>",
      "#include <linux/exportfs.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/parser.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/init.h>",
      "#include <linux/slab.h>",
      "#include <linux/jbd2.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/time.h>",
      "#include <linux/fs.h>",
      "#include <linux/string.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ext4_unfreeze(struct super_block *sb);",
      "static int ext4_freeze(struct super_block *sb);",
      "static inline int ext2_feature_set_ok(struct super_block *sb);",
      "static inline int ext3_feature_set_ok(struct super_block *sb);",
      "static void ext4_unregister_li_request(struct super_block *sb);",
      "static int ext4_reserve_clusters(struct ext4_sb_info *, ext4_fsblk_t);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ext4_group_first_block_no",
          "args": [
            "sb",
            "bg"
          ],
          "line": 2395
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_group_first_block_no",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ext4.h",
          "lines": "1831-1836",
          "snippet": "static inline ext4_fsblk_t\next4_group_first_block_no(struct super_block *sb, ext4_group_t group_no)\n{\n\treturn group_no * (ext4_fsblk_t)EXT4_BLOCKS_PER_GROUP(sb) +\n\t\tle32_to_cpu(EXT4_SB(sb)->s_es->s_first_data_block);\n}",
          "includes": [
            "#include \"extents_status.h\"",
            "#include <linux/compat.h>",
            "#include <linux/falloc.h>",
            "#include <crypto/hash.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/wait.h>",
            "#include <linux/timer.h>",
            "#include <linux/mutex.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/quota.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extents_status.h\"\n#include <linux/compat.h>\n#include <linux/falloc.h>\n#include <crypto/hash.h>\n#include <linux/ratelimit.h>\n#include <linux/percpu_counter.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/wait.h>\n#include <linux/timer.h>\n#include <linux/mutex.h>\n#include <linux/seqlock.h>\n#include <linux/rbtree.h>\n#include <linux/rwsem.h>\n#include <linux/quota.h>\n#include <linux/jbd2.h>\n#include <linux/magic.h>\n#include <linux/blkdev.h>\n#include <linux/types.h>\n\nstatic inline ext4_fsblk_t\next4_group_first_block_no(struct super_block *sb, ext4_group_t group_no)\n{\n\treturn group_no * (ext4_fsblk_t)EXT4_BLOCKS_PER_GROUP(sb) +\n\t\tle32_to_cpu(EXT4_SB(sb)->s_es->s_first_data_block);\n}"
        }
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "EXT4_SB(sb)->s_es->s_first_data_block"
          ],
          "line": 2392
        },
        "resolved": true,
        "details": {
          "function_name": "sle32_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "53-56",
          "snippet": "static inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "EXT4_SB",
          "args": [
            "sb"
          ],
          "line": 2392
        },
        "resolved": true,
        "details": {
          "function_name": "EXT4_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ext4.h",
          "lines": "1356-1359",
          "snippet": "static inline struct ext4_sb_info *EXT4_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include \"extents_status.h\"",
            "#include <linux/compat.h>",
            "#include <linux/falloc.h>",
            "#include <crypto/hash.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/wait.h>",
            "#include <linux/timer.h>",
            "#include <linux/mutex.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/quota.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extents_status.h\"\n#include <linux/compat.h>\n#include <linux/falloc.h>\n#include <crypto/hash.h>\n#include <linux/ratelimit.h>\n#include <linux/percpu_counter.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/wait.h>\n#include <linux/timer.h>\n#include <linux/mutex.h>\n#include <linux/seqlock.h>\n#include <linux/rbtree.h>\n#include <linux/rwsem.h>\n#include <linux/quota.h>\n#include <linux/jbd2.h>\n#include <linux/magic.h>\n#include <linux/blkdev.h>\n#include <linux/types.h>\n\nstatic inline struct ext4_sb_info *EXT4_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_bg_has_super",
          "args": [
            "sb",
            "bg"
          ],
          "line": 2382
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_bg_has_super",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/balloc.c",
          "lines": "740-762",
          "snippet": "int ext4_bg_has_super(struct super_block *sb, ext4_group_t group)\n{\n\tstruct ext4_super_block *es = EXT4_SB(sb)->s_es;\n\n\tif (group == 0)\n\t\treturn 1;\n\tif (EXT4_HAS_COMPAT_FEATURE(sb, EXT4_FEATURE_COMPAT_SPARSE_SUPER2)) {\n\t\tif (group == le32_to_cpu(es->s_backup_bgs[0]) ||\n\t\t    group == le32_to_cpu(es->s_backup_bgs[1]))\n\t\t\treturn 1;\n\t\treturn 0;\n\t}\n\tif ((group <= 1) || !EXT4_HAS_RO_COMPAT_FEATURE(sb,\n\t\t\t\t\tEXT4_FEATURE_RO_COMPAT_SPARSE_SUPER))\n\t\treturn 1;\n\tif (!(group & 1))\n\t\treturn 0;\n\tif (test_root(group, 3) || (test_root(group, 5)) ||\n\t    test_root(group, 7))\n\t\treturn 1;\n\n\treturn 0;\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"mballoc.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include \"ext4.h\"",
            "#include <linux/buffer_head.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/fs.h>",
            "#include <linux/capability.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"mballoc.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4.h\"\n#include <linux/buffer_head.h>\n#include <linux/quotaops.h>\n#include <linux/jbd2.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n#include <linux/time.h>\n\nint ext4_bg_has_super(struct super_block *sb, ext4_group_t group)\n{\n\tstruct ext4_super_block *es = EXT4_SB(sb)->s_es;\n\n\tif (group == 0)\n\t\treturn 1;\n\tif (EXT4_HAS_COMPAT_FEATURE(sb, EXT4_FEATURE_COMPAT_SPARSE_SUPER2)) {\n\t\tif (group == le32_to_cpu(es->s_backup_bgs[0]) ||\n\t\t    group == le32_to_cpu(es->s_backup_bgs[1]))\n\t\t\treturn 1;\n\t\treturn 0;\n\t}\n\tif ((group <= 1) || !EXT4_HAS_RO_COMPAT_FEATURE(sb,\n\t\t\t\t\tEXT4_FEATURE_RO_COMPAT_SPARSE_SUPER))\n\t\treturn 1;\n\tif (!(group & 1))\n\t\treturn 0;\n\tif (test_root(group, 3) || (test_root(group, 5)) ||\n\t    test_root(group, 7))\n\t\treturn 1;\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "EXT4_HAS_INCOMPAT_FEATURE",
          "args": [
            "sb",
            "EXT4_FEATURE_INCOMPAT_META_BG"
          ],
          "line": 2378
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"mballoc.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4_extents.h\"\t/* Needed for trace points definition */\n#include \"ext4.h\"\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <asm/uaccess.h>\n#include <linux/cleancache.h>\n#include <linux/crc16.h>\n#include <linux/log2.h>\n#include <linux/ctype.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/random.h>\n#include <linux/vfs.h>\n#include <linux/exportfs.h>\n#include <linux/buffer_head.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/jbd2.h>\n#include <linux/vmalloc.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n#include <linux/string.h>\n#include <linux/module.h>\n\nstatic int ext4_unfreeze(struct super_block *sb);\nstatic int ext4_freeze(struct super_block *sb);\nstatic inline int ext2_feature_set_ok(struct super_block *sb);\nstatic inline int ext3_feature_set_ok(struct super_block *sb);\nstatic void ext4_unregister_li_request(struct super_block *sb);\nstatic int ext4_reserve_clusters(struct ext4_sb_info *, ext4_fsblk_t);\n\nstatic ext4_fsblk_t descriptor_loc(struct super_block *sb,\n\t\t\t\t   ext4_fsblk_t logical_sb_block, int nr)\n{\n\tstruct ext4_sb_info *sbi = EXT4_SB(sb);\n\text4_group_t bg, first_meta_bg;\n\tint has_super = 0;\n\n\tfirst_meta_bg = le32_to_cpu(sbi->s_es->s_first_meta_bg);\n\n\tif (!EXT4_HAS_INCOMPAT_FEATURE(sb, EXT4_FEATURE_INCOMPAT_META_BG) ||\n\t    nr < first_meta_bg)\n\t\treturn logical_sb_block + nr + 1;\n\tbg = sbi->s_desc_per_block * nr;\n\tif (ext4_bg_has_super(sb, bg))\n\t\thas_super = 1;\n\n\t/*\n\t * If we have a meta_bg fs with 1k blocks, group 0's GDT is at\n\t * block 2, not 1.  If s_first_data_block == 0 (bigalloc is enabled\n\t * on modern mke2fs or blksize > 1k on older mke2fs) then we must\n\t * compensate.\n\t */\n\tif (sb->s_blocksize == 1024 && nr == 0 &&\n\t    le32_to_cpu(EXT4_SB(sb)->s_es->s_first_data_block) == 0)\n\t\thas_super++;\n\n\treturn (has_super + ext4_group_first_block_no(sb, bg));\n}"
  },
  {
    "function_name": "ext4_max_bitmap_size",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/super.c",
    "lines": "2311-2367",
    "snippet": "static loff_t ext4_max_bitmap_size(int bits, int has_huge_files)\n{\n\tloff_t res = EXT4_NDIR_BLOCKS;\n\tint meta_blocks;\n\tloff_t upper_limit;\n\t/* This is calculated to be the largest file size for a dense, block\n\t * mapped file such that the file's total number of 512-byte sectors,\n\t * including data and all indirect blocks, does not exceed (2^48 - 1).\n\t *\n\t * __u32 i_blocks_lo and _u16 i_blocks_high represent the total\n\t * number of 512-byte sectors of the file.\n\t */\n\n\tif (!has_huge_files || sizeof(blkcnt_t) < sizeof(u64)) {\n\t\t/*\n\t\t * !has_huge_files or CONFIG_LBDAF not enabled implies that\n\t\t * the inode i_block field represents total file blocks in\n\t\t * 2^32 512-byte sectors == size of vfs inode i_blocks * 8\n\t\t */\n\t\tupper_limit = (1LL << 32) - 1;\n\n\t\t/* total blocks in file system block size */\n\t\tupper_limit >>= (bits - 9);\n\n\t} else {\n\t\t/*\n\t\t * We use 48 bit ext4_inode i_blocks\n\t\t * With EXT4_HUGE_FILE_FL set the i_blocks\n\t\t * represent total number of blocks in\n\t\t * file system block size\n\t\t */\n\t\tupper_limit = (1LL << 48) - 1;\n\n\t}\n\n\t/* indirect blocks */\n\tmeta_blocks = 1;\n\t/* double indirect blocks */\n\tmeta_blocks += 1 + (1LL << (bits-2));\n\t/* tripple indirect blocks */\n\tmeta_blocks += 1 + (1LL << (bits-2)) + (1LL << (2*(bits-2)));\n\n\tupper_limit -= meta_blocks;\n\tupper_limit <<= bits;\n\n\tres += 1LL << (bits-2);\n\tres += 1LL << (2*(bits-2));\n\tres += 1LL << (3*(bits-2));\n\tres <<= bits;\n\tif (res > upper_limit)\n\t\tres = upper_limit;\n\n\tif (res > MAX_LFS_FILESIZE)\n\t\tres = MAX_LFS_FILESIZE;\n\n\treturn res;\n}",
    "includes": [
      "#include <trace/events/ext4.h>",
      "#include \"mballoc.h\"",
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"ext4_jbd2.h\"",
      "#include \"ext4_extents.h\"\t/* Needed for trace points definition */",
      "#include \"ext4.h\"",
      "#include <linux/freezer.h>",
      "#include <linux/kthread.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/cleancache.h>",
      "#include <linux/crc16.h>",
      "#include <linux/log2.h>",
      "#include <linux/ctype.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/namei.h>",
      "#include <linux/mount.h>",
      "#include <linux/random.h>",
      "#include <linux/vfs.h>",
      "#include <linux/exportfs.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/parser.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/init.h>",
      "#include <linux/slab.h>",
      "#include <linux/jbd2.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/time.h>",
      "#include <linux/fs.h>",
      "#include <linux/string.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ext4_remount(struct super_block *sb, int *flags, char *data);",
      "static struct dentry *ext4_mount(struct file_system_type *fs_type, int flags,\n\t\t       const char *dev_name, void *data);"
    ],
    "called_functions": [],
    "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"mballoc.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4_extents.h\"\t/* Needed for trace points definition */\n#include \"ext4.h\"\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <asm/uaccess.h>\n#include <linux/cleancache.h>\n#include <linux/crc16.h>\n#include <linux/log2.h>\n#include <linux/ctype.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/random.h>\n#include <linux/vfs.h>\n#include <linux/exportfs.h>\n#include <linux/buffer_head.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/jbd2.h>\n#include <linux/vmalloc.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n#include <linux/string.h>\n#include <linux/module.h>\n\nstatic int ext4_remount(struct super_block *sb, int *flags, char *data);\nstatic struct dentry *ext4_mount(struct file_system_type *fs_type, int flags,\n\t\t       const char *dev_name, void *data);\n\nstatic loff_t ext4_max_bitmap_size(int bits, int has_huge_files)\n{\n\tloff_t res = EXT4_NDIR_BLOCKS;\n\tint meta_blocks;\n\tloff_t upper_limit;\n\t/* This is calculated to be the largest file size for a dense, block\n\t * mapped file such that the file's total number of 512-byte sectors,\n\t * including data and all indirect blocks, does not exceed (2^48 - 1).\n\t *\n\t * __u32 i_blocks_lo and _u16 i_blocks_high represent the total\n\t * number of 512-byte sectors of the file.\n\t */\n\n\tif (!has_huge_files || sizeof(blkcnt_t) < sizeof(u64)) {\n\t\t/*\n\t\t * !has_huge_files or CONFIG_LBDAF not enabled implies that\n\t\t * the inode i_block field represents total file blocks in\n\t\t * 2^32 512-byte sectors == size of vfs inode i_blocks * 8\n\t\t */\n\t\tupper_limit = (1LL << 32) - 1;\n\n\t\t/* total blocks in file system block size */\n\t\tupper_limit >>= (bits - 9);\n\n\t} else {\n\t\t/*\n\t\t * We use 48 bit ext4_inode i_blocks\n\t\t * With EXT4_HUGE_FILE_FL set the i_blocks\n\t\t * represent total number of blocks in\n\t\t * file system block size\n\t\t */\n\t\tupper_limit = (1LL << 48) - 1;\n\n\t}\n\n\t/* indirect blocks */\n\tmeta_blocks = 1;\n\t/* double indirect blocks */\n\tmeta_blocks += 1 + (1LL << (bits-2));\n\t/* tripple indirect blocks */\n\tmeta_blocks += 1 + (1LL << (bits-2)) + (1LL << (2*(bits-2)));\n\n\tupper_limit -= meta_blocks;\n\tupper_limit <<= bits;\n\n\tres += 1LL << (bits-2);\n\tres += 1LL << (2*(bits-2));\n\tres += 1LL << (3*(bits-2));\n\tres <<= bits;\n\tif (res > upper_limit)\n\t\tres = upper_limit;\n\n\tif (res > MAX_LFS_FILESIZE)\n\t\tres = MAX_LFS_FILESIZE;\n\n\treturn res;\n}"
  },
  {
    "function_name": "ext4_max_size",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/super.c",
    "lines": "2272-2304",
    "snippet": "static loff_t ext4_max_size(int blkbits, int has_huge_files)\n{\n\tloff_t res;\n\tloff_t upper_limit = MAX_LFS_FILESIZE;\n\n\t/* small i_blocks in vfs inode? */\n\tif (!has_huge_files || sizeof(blkcnt_t) < sizeof(u64)) {\n\t\t/*\n\t\t * CONFIG_LBDAF is not enabled implies the inode\n\t\t * i_block represent total blocks in 512 bytes\n\t\t * 32 == size of vfs inode i_blocks * 8\n\t\t */\n\t\tupper_limit = (1LL << 32) - 1;\n\n\t\t/* total blocks in file system block size */\n\t\tupper_limit >>= (blkbits - 9);\n\t\tupper_limit <<= blkbits;\n\t}\n\n\t/*\n\t * 32-bit extent-start container, ee_block. We lower the maxbytes\n\t * by one fs block, so ee_len can cover the extent of maximum file\n\t * size\n\t */\n\tres = (1LL << 32) - 1;\n\tres <<= blkbits;\n\n\t/* Sanity check against vm- & vfs- imposed limits */\n\tif (res > upper_limit)\n\t\tres = upper_limit;\n\n\treturn res;\n}",
    "includes": [
      "#include <trace/events/ext4.h>",
      "#include \"mballoc.h\"",
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"ext4_jbd2.h\"",
      "#include \"ext4_extents.h\"\t/* Needed for trace points definition */",
      "#include \"ext4.h\"",
      "#include <linux/freezer.h>",
      "#include <linux/kthread.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/cleancache.h>",
      "#include <linux/crc16.h>",
      "#include <linux/log2.h>",
      "#include <linux/ctype.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/namei.h>",
      "#include <linux/mount.h>",
      "#include <linux/random.h>",
      "#include <linux/vfs.h>",
      "#include <linux/exportfs.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/parser.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/init.h>",
      "#include <linux/slab.h>",
      "#include <linux/jbd2.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/time.h>",
      "#include <linux/fs.h>",
      "#include <linux/string.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"mballoc.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4_extents.h\"\t/* Needed for trace points definition */\n#include \"ext4.h\"\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <asm/uaccess.h>\n#include <linux/cleancache.h>\n#include <linux/crc16.h>\n#include <linux/log2.h>\n#include <linux/ctype.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/random.h>\n#include <linux/vfs.h>\n#include <linux/exportfs.h>\n#include <linux/buffer_head.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/jbd2.h>\n#include <linux/vmalloc.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n#include <linux/string.h>\n#include <linux/module.h>\n\nstatic loff_t ext4_max_size(int blkbits, int has_huge_files)\n{\n\tloff_t res;\n\tloff_t upper_limit = MAX_LFS_FILESIZE;\n\n\t/* small i_blocks in vfs inode? */\n\tif (!has_huge_files || sizeof(blkcnt_t) < sizeof(u64)) {\n\t\t/*\n\t\t * CONFIG_LBDAF is not enabled implies the inode\n\t\t * i_block represent total blocks in 512 bytes\n\t\t * 32 == size of vfs inode i_blocks * 8\n\t\t */\n\t\tupper_limit = (1LL << 32) - 1;\n\n\t\t/* total blocks in file system block size */\n\t\tupper_limit >>= (blkbits - 9);\n\t\tupper_limit <<= blkbits;\n\t}\n\n\t/*\n\t * 32-bit extent-start container, ee_block. We lower the maxbytes\n\t * by one fs block, so ee_len can cover the extent of maximum file\n\t * size\n\t */\n\tres = (1LL << 32) - 1;\n\tres <<= blkbits;\n\n\t/* Sanity check against vm- & vfs- imposed limits */\n\tif (res > upper_limit)\n\t\tres = upper_limit;\n\n\treturn res;\n}"
  },
  {
    "function_name": "ext4_orphan_cleanup",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/super.c",
    "lines": "2148-2255",
    "snippet": "static void ext4_orphan_cleanup(struct super_block *sb,\n\t\t\t\tstruct ext4_super_block *es)\n{\n\tunsigned int s_flags = sb->s_flags;\n\tint nr_orphans = 0, nr_truncates = 0;\n#ifdef CONFIG_QUOTA\n\tint i;\n#endif\n\tif (!es->s_last_orphan) {\n\t\tjbd_debug(4, \"no orphan inodes to clean up\\n\");\n\t\treturn;\n\t}\n\n\tif (bdev_read_only(sb->s_bdev)) {\n\t\text4_msg(sb, KERN_ERR, \"write access \"\n\t\t\t\"unavailable, skipping orphan cleanup\");\n\t\treturn;\n\t}\n\n\t/* Check if feature set would not allow a r/w mount */\n\tif (!ext4_feature_set_ok(sb, 0)) {\n\t\text4_msg(sb, KERN_INFO, \"Skipping orphan cleanup due to \"\n\t\t\t \"unknown ROCOMPAT features\");\n\t\treturn;\n\t}\n\n\tif (EXT4_SB(sb)->s_mount_state & EXT4_ERROR_FS) {\n\t\t/* don't clear list on RO mount w/ errors */\n\t\tif (es->s_last_orphan && !(s_flags & MS_RDONLY)) {\n\t\t\text4_msg(sb, KERN_INFO, \"Errors on filesystem, \"\n\t\t\t\t  \"clearing orphan list.\\n\");\n\t\t\tes->s_last_orphan = 0;\n\t\t}\n\t\tjbd_debug(1, \"Skipping orphan recovery on fs with errors.\\n\");\n\t\treturn;\n\t}\n\n\tif (s_flags & MS_RDONLY) {\n\t\text4_msg(sb, KERN_INFO, \"orphan cleanup on readonly fs\");\n\t\tsb->s_flags &= ~MS_RDONLY;\n\t}\n#ifdef CONFIG_QUOTA\n\t/* Needed for iput() to work correctly and not trash data */\n\tsb->s_flags |= MS_ACTIVE;\n\t/* Turn on quotas so that they are updated correctly */\n\tfor (i = 0; i < EXT4_MAXQUOTAS; i++) {\n\t\tif (EXT4_SB(sb)->s_qf_names[i]) {\n\t\t\tint ret = ext4_quota_on_mount(sb, i);\n\t\t\tif (ret < 0)\n\t\t\t\text4_msg(sb, KERN_ERR,\n\t\t\t\t\t\"Cannot turn on journaled \"\n\t\t\t\t\t\"quota: error %d\", ret);\n\t\t}\n\t}\n#endif\n\n\twhile (es->s_last_orphan) {\n\t\tstruct inode *inode;\n\n\t\tinode = ext4_orphan_get(sb, le32_to_cpu(es->s_last_orphan));\n\t\tif (IS_ERR(inode)) {\n\t\t\tes->s_last_orphan = 0;\n\t\t\tbreak;\n\t\t}\n\n\t\tlist_add(&EXT4_I(inode)->i_orphan, &EXT4_SB(sb)->s_orphan);\n\t\tdquot_initialize(inode);\n\t\tif (inode->i_nlink) {\n\t\t\tif (test_opt(sb, DEBUG))\n\t\t\t\text4_msg(sb, KERN_DEBUG,\n\t\t\t\t\t\"%s: truncating inode %lu to %lld bytes\",\n\t\t\t\t\t__func__, inode->i_ino, inode->i_size);\n\t\t\tjbd_debug(2, \"truncating inode %lu to %lld bytes\\n\",\n\t\t\t\t  inode->i_ino, inode->i_size);\n\t\t\tmutex_lock(&inode->i_mutex);\n\t\t\ttruncate_inode_pages(inode->i_mapping, inode->i_size);\n\t\t\text4_truncate(inode);\n\t\t\tmutex_unlock(&inode->i_mutex);\n\t\t\tnr_truncates++;\n\t\t} else {\n\t\t\tif (test_opt(sb, DEBUG))\n\t\t\t\text4_msg(sb, KERN_DEBUG,\n\t\t\t\t\t\"%s: deleting unreferenced inode %lu\",\n\t\t\t\t\t__func__, inode->i_ino);\n\t\t\tjbd_debug(2, \"deleting unreferenced inode %lu\\n\",\n\t\t\t\t  inode->i_ino);\n\t\t\tnr_orphans++;\n\t\t}\n\t\tiput(inode);  /* The delete magic happens here! */\n\t}\n\n#define PLURAL(x) (x), ((x) == 1) ? \"\" : \"s\"\n\n\tif (nr_orphans)\n\t\text4_msg(sb, KERN_INFO, \"%d orphan inode%s deleted\",\n\t\t       PLURAL(nr_orphans));\n\tif (nr_truncates)\n\t\text4_msg(sb, KERN_INFO, \"%d truncate%s cleaned up\",\n\t\t       PLURAL(nr_truncates));\n#ifdef CONFIG_QUOTA\n\t/* Turn quotas off */\n\tfor (i = 0; i < EXT4_MAXQUOTAS; i++) {\n\t\tif (sb_dqopt(sb)->files[i])\n\t\t\tdquot_quota_off(sb, i);\n\t}\n#endif\n\tsb->s_flags = s_flags; /* Restore MS_RDONLY status */\n}",
    "includes": [
      "#include <trace/events/ext4.h>",
      "#include \"mballoc.h\"",
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"ext4_jbd2.h\"",
      "#include \"ext4_extents.h\"\t/* Needed for trace points definition */",
      "#include \"ext4.h\"",
      "#include <linux/freezer.h>",
      "#include <linux/kthread.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/cleancache.h>",
      "#include <linux/crc16.h>",
      "#include <linux/log2.h>",
      "#include <linux/ctype.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/namei.h>",
      "#include <linux/mount.h>",
      "#include <linux/random.h>",
      "#include <linux/vfs.h>",
      "#include <linux/exportfs.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/parser.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/init.h>",
      "#include <linux/slab.h>",
      "#include <linux/jbd2.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/time.h>",
      "#include <linux/fs.h>",
      "#include <linux/string.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void ext4_mark_recovery_complete(struct super_block *sb,\n\t\t\t\t\tstruct ext4_super_block *es);",
      "static void ext4_clear_journal_err(struct super_block *sb,\n\t\t\t\t   struct ext4_super_block *es);",
      "static int ext4_remount(struct super_block *sb, int *flags, char *data);",
      "static int ext4_unfreeze(struct super_block *sb);",
      "static int ext4_freeze(struct super_block *sb);",
      "static struct dentry *ext4_mount(struct file_system_type *fs_type, int flags,\n\t\t       const char *dev_name, void *data);",
      "static inline int ext2_feature_set_ok(struct super_block *sb);",
      "static inline int ext3_feature_set_ok(struct super_block *sb);",
      "static int ext4_feature_set_ok(struct super_block *sb, int readonly);",
      "static void ext4_unregister_li_request(struct super_block *sb);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "dquot_quota_off",
          "args": [
            "sb",
            "i"
          ],
          "line": 2251
        },
        "resolved": true,
        "details": {
          "function_name": "dquot_quota_off",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/quota/dquot.c",
          "lines": "2130-2134",
          "snippet": "int dquot_quota_off(struct super_block *sb, int type)\n{\n\treturn dquot_disable(sb, type,\n\t\t\t     DQUOT_USAGE_ENABLED | DQUOT_LIMITS_ENABLED);\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include \"../internal.h\" /* ugh */",
            "#include <linux/quotaops.h>",
            "#include <linux/capability.h>",
            "#include <linux/namei.h>",
            "#include <linux/kmod.h>",
            "#include <linux/sched.h>",
            "#include <linux/security.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>",
            "#include <linux/tty.h>",
            "#include <linux/stat.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/time.h>",
            "#include <linux/mm.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __dquot_initialize(struct inode *inode, int type);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include \"../internal.h\" /* ugh */\n#include <linux/quotaops.h>\n#include <linux/capability.h>\n#include <linux/namei.h>\n#include <linux/kmod.h>\n#include <linux/sched.h>\n#include <linux/security.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/sysctl.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/tty.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/time.h>\n#include <linux/mm.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/kernel.h>\n#include <linux/errno.h>\n\nstatic void __dquot_initialize(struct inode *inode, int type);\n\nint dquot_quota_off(struct super_block *sb, int type)\n{\n\treturn dquot_disable(sb, type,\n\t\t\t     DQUOT_USAGE_ENABLED | DQUOT_LIMITS_ENABLED);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sb_dqopt",
          "args": [
            "sb"
          ],
          "line": 2250
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_msg",
          "args": [
            "sb",
            "KERN_INFO",
            "\"%d truncate%s cleaned up\"",
            "PLURAL(nr_truncates)"
          ],
          "line": 2245
        },
        "resolved": true,
        "details": {
          "function_name": "__ext4_msg",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/super.c",
          "lines": "593-607",
          "snippet": "void __ext4_msg(struct super_block *sb,\n\t\tconst char *prefix, const char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tif (!___ratelimit(&(EXT4_SB(sb)->s_msg_ratelimit_state), \"EXT4-fs\"))\n\t\treturn;\n\n\tva_start(args, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\tprintk(\"%sEXT4-fs (%s): %pV\\n\", prefix, sb->s_id, &vaf);\n\tva_end(args);\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"mballoc.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include \"ext4_extents.h\"\t/* Needed for trace points definition */",
            "#include \"ext4.h\"",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/crc16.h>",
            "#include <linux/log2.h>",
            "#include <linux/ctype.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/random.h>",
            "#include <linux/vfs.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/parser.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/time.h>",
            "#include <linux/fs.h>",
            "#include <linux/string.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ext4_unfreeze(struct super_block *sb);",
            "static int ext4_freeze(struct super_block *sb);",
            "static inline int ext2_feature_set_ok(struct super_block *sb);",
            "static inline int ext3_feature_set_ok(struct super_block *sb);",
            "static void ext4_unregister_li_request(struct super_block *sb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"mballoc.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4_extents.h\"\t/* Needed for trace points definition */\n#include \"ext4.h\"\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <asm/uaccess.h>\n#include <linux/cleancache.h>\n#include <linux/crc16.h>\n#include <linux/log2.h>\n#include <linux/ctype.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/random.h>\n#include <linux/vfs.h>\n#include <linux/exportfs.h>\n#include <linux/buffer_head.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/jbd2.h>\n#include <linux/vmalloc.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n#include <linux/string.h>\n#include <linux/module.h>\n\nstatic int ext4_unfreeze(struct super_block *sb);\nstatic int ext4_freeze(struct super_block *sb);\nstatic inline int ext2_feature_set_ok(struct super_block *sb);\nstatic inline int ext3_feature_set_ok(struct super_block *sb);\nstatic void ext4_unregister_li_request(struct super_block *sb);\n\nvoid __ext4_msg(struct super_block *sb,\n\t\tconst char *prefix, const char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tif (!___ratelimit(&(EXT4_SB(sb)->s_msg_ratelimit_state), \"EXT4-fs\"))\n\t\treturn;\n\n\tva_start(args, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\tprintk(\"%sEXT4-fs (%s): %pV\\n\", prefix, sb->s_id, &vaf);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PLURAL",
          "args": [
            "nr_truncates"
          ],
          "line": 2246
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PLURAL",
          "args": [
            "nr_orphans"
          ],
          "line": 2243
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "iput",
          "args": [
            "inode"
          ],
          "line": 2236
        },
        "resolved": true,
        "details": {
          "function_name": "dentry_iput",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "308-327",
          "snippet": "static void dentry_iput(struct dentry * dentry)\n\t__releases(dentry->d_lock)\n\t__releases(dentry->d_inode->i_lock)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tif (inode) {\n\t\tdentry->d_inode = NULL;\n\t\thlist_del_init(&dentry->d_u.d_alias);\n\t\tspin_unlock(&dentry->d_lock);\n\t\tspin_unlock(&inode->i_lock);\n\t\tif (!inode->i_nlink)\n\t\t\tfsnotify_inoderemove(inode);\n\t\tif (dentry->d_op && dentry->d_op->d_iput)\n\t\t\tdentry->d_op->d_iput(dentry, inode);\n\t\telse\n\t\t\tiput(inode);\n\t} else {\n\t\tspin_unlock(&dentry->d_lock);\n\t}\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nstatic void dentry_iput(struct dentry * dentry)\n\t__releases(dentry->d_lock)\n\t__releases(dentry->d_inode->i_lock)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tif (inode) {\n\t\tdentry->d_inode = NULL;\n\t\thlist_del_init(&dentry->d_u.d_alias);\n\t\tspin_unlock(&dentry->d_lock);\n\t\tspin_unlock(&inode->i_lock);\n\t\tif (!inode->i_nlink)\n\t\t\tfsnotify_inoderemove(inode);\n\t\tif (dentry->d_op && dentry->d_op->d_iput)\n\t\t\tdentry->d_op->d_iput(dentry, inode);\n\t\telse\n\t\t\tiput(inode);\n\t} else {\n\t\tspin_unlock(&dentry->d_lock);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "jbd_debug",
          "args": [
            "2",
            "\"deleting unreferenced inode %lu\\n\"",
            "inode->i_ino"
          ],
          "line": 2232
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_opt",
          "args": [
            "sb",
            "DEBUG"
          ],
          "line": 2228
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&inode->i_mutex"
          ],
          "line": 2225
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_truncate",
          "args": [
            "inode"
          ],
          "line": 2224
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_truncate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/inode.c",
          "lines": "3577-3671",
          "snippet": "void ext4_truncate(struct inode *inode)\n{\n\tstruct ext4_inode_info *ei = EXT4_I(inode);\n\tunsigned int credits;\n\thandle_t *handle;\n\tstruct address_space *mapping = inode->i_mapping;\n\n\t/*\n\t * There is a possibility that we're either freeing the inode\n\t * or it's a completely new inode. In those cases we might not\n\t * have i_mutex locked because it's not necessary.\n\t */\n\tif (!(inode->i_state & (I_NEW|I_FREEING)))\n\t\tWARN_ON(!mutex_is_locked(&inode->i_mutex));\n\ttrace_ext4_truncate_enter(inode);\n\n\tif (!ext4_can_truncate(inode))\n\t\treturn;\n\n\text4_clear_inode_flag(inode, EXT4_INODE_EOFBLOCKS);\n\n\tif (inode->i_size == 0 && !test_opt(inode->i_sb, NO_AUTO_DA_ALLOC))\n\t\text4_set_inode_state(inode, EXT4_STATE_DA_ALLOC_CLOSE);\n\n\tif (ext4_has_inline_data(inode)) {\n\t\tint has_inline = 1;\n\n\t\text4_inline_data_truncate(inode, &has_inline);\n\t\tif (has_inline)\n\t\t\treturn;\n\t}\n\n\t/* If we zero-out tail of the page, we have to create jinode for jbd2 */\n\tif (inode->i_size & (inode->i_sb->s_blocksize - 1)) {\n\t\tif (ext4_inode_attach_jinode(inode) < 0)\n\t\t\treturn;\n\t}\n\n\tif (ext4_test_inode_flag(inode, EXT4_INODE_EXTENTS))\n\t\tcredits = ext4_writepage_trans_blocks(inode);\n\telse\n\t\tcredits = ext4_blocks_for_truncate(inode);\n\n\thandle = ext4_journal_start(inode, EXT4_HT_TRUNCATE, credits);\n\tif (IS_ERR(handle)) {\n\t\text4_std_error(inode->i_sb, PTR_ERR(handle));\n\t\treturn;\n\t}\n\n\tif (inode->i_size & (inode->i_sb->s_blocksize - 1))\n\t\text4_block_truncate_page(handle, mapping, inode->i_size);\n\n\t/*\n\t * We add the inode to the orphan list, so that if this\n\t * truncate spans multiple transactions, and we crash, we will\n\t * resume the truncate when the filesystem recovers.  It also\n\t * marks the inode dirty, to catch the new size.\n\t *\n\t * Implication: the file must always be in a sane, consistent\n\t * truncatable state while each transaction commits.\n\t */\n\tif (ext4_orphan_add(handle, inode))\n\t\tgoto out_stop;\n\n\tdown_write(&EXT4_I(inode)->i_data_sem);\n\n\text4_discard_preallocations(inode);\n\n\tif (ext4_test_inode_flag(inode, EXT4_INODE_EXTENTS))\n\t\text4_ext_truncate(handle, inode);\n\telse\n\t\text4_ind_truncate(handle, inode);\n\n\tup_write(&ei->i_data_sem);\n\n\tif (IS_SYNC(inode))\n\t\text4_handle_sync(handle);\n\nout_stop:\n\t/*\n\t * If this was a simple ftruncate() and the file will remain alive,\n\t * then we need to clear up the orphan record which we created above.\n\t * However, if this was a real unlink then we were called by\n\t * ext4_evict_inode(), and we allow that function to clean up the\n\t * orphan info for us.\n\t */\n\tif (inode->i_nlink)\n\t\text4_orphan_del(handle, inode);\n\n\tinode->i_mtime = inode->i_ctime = ext4_current_time(inode);\n\text4_mark_inode_dirty(handle, inode);\n\text4_journal_stop(handle);\n\n\ttrace_ext4_truncate_exit(inode);\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"truncate.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include <linux/bitops.h>",
            "#include <linux/aio.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/printk.h>",
            "#include <linux/kernel.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/bio.h>",
            "#include <linux/uio.h>",
            "#include <linux/namei.h>",
            "#include <linux/mpage.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highuid.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/time.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ext4_get_block_write_nolock(struct inode *inode, sector_t iblock,\n\t\t   struct buffer_head *bh_result, int create);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"truncate.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include <linux/bitops.h>\n#include <linux/aio.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/printk.h>\n#include <linux/kernel.h>\n#include <linux/workqueue.h>\n#include <linux/bio.h>\n#include <linux/uio.h>\n#include <linux/namei.h>\n#include <linux/mpage.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/highuid.h>\n#include <linux/jbd2.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n\nstatic int ext4_get_block_write_nolock(struct inode *inode, sector_t iblock,\n\t\t   struct buffer_head *bh_result, int create);\n\nvoid ext4_truncate(struct inode *inode)\n{\n\tstruct ext4_inode_info *ei = EXT4_I(inode);\n\tunsigned int credits;\n\thandle_t *handle;\n\tstruct address_space *mapping = inode->i_mapping;\n\n\t/*\n\t * There is a possibility that we're either freeing the inode\n\t * or it's a completely new inode. In those cases we might not\n\t * have i_mutex locked because it's not necessary.\n\t */\n\tif (!(inode->i_state & (I_NEW|I_FREEING)))\n\t\tWARN_ON(!mutex_is_locked(&inode->i_mutex));\n\ttrace_ext4_truncate_enter(inode);\n\n\tif (!ext4_can_truncate(inode))\n\t\treturn;\n\n\text4_clear_inode_flag(inode, EXT4_INODE_EOFBLOCKS);\n\n\tif (inode->i_size == 0 && !test_opt(inode->i_sb, NO_AUTO_DA_ALLOC))\n\t\text4_set_inode_state(inode, EXT4_STATE_DA_ALLOC_CLOSE);\n\n\tif (ext4_has_inline_data(inode)) {\n\t\tint has_inline = 1;\n\n\t\text4_inline_data_truncate(inode, &has_inline);\n\t\tif (has_inline)\n\t\t\treturn;\n\t}\n\n\t/* If we zero-out tail of the page, we have to create jinode for jbd2 */\n\tif (inode->i_size & (inode->i_sb->s_blocksize - 1)) {\n\t\tif (ext4_inode_attach_jinode(inode) < 0)\n\t\t\treturn;\n\t}\n\n\tif (ext4_test_inode_flag(inode, EXT4_INODE_EXTENTS))\n\t\tcredits = ext4_writepage_trans_blocks(inode);\n\telse\n\t\tcredits = ext4_blocks_for_truncate(inode);\n\n\thandle = ext4_journal_start(inode, EXT4_HT_TRUNCATE, credits);\n\tif (IS_ERR(handle)) {\n\t\text4_std_error(inode->i_sb, PTR_ERR(handle));\n\t\treturn;\n\t}\n\n\tif (inode->i_size & (inode->i_sb->s_blocksize - 1))\n\t\text4_block_truncate_page(handle, mapping, inode->i_size);\n\n\t/*\n\t * We add the inode to the orphan list, so that if this\n\t * truncate spans multiple transactions, and we crash, we will\n\t * resume the truncate when the filesystem recovers.  It also\n\t * marks the inode dirty, to catch the new size.\n\t *\n\t * Implication: the file must always be in a sane, consistent\n\t * truncatable state while each transaction commits.\n\t */\n\tif (ext4_orphan_add(handle, inode))\n\t\tgoto out_stop;\n\n\tdown_write(&EXT4_I(inode)->i_data_sem);\n\n\text4_discard_preallocations(inode);\n\n\tif (ext4_test_inode_flag(inode, EXT4_INODE_EXTENTS))\n\t\text4_ext_truncate(handle, inode);\n\telse\n\t\text4_ind_truncate(handle, inode);\n\n\tup_write(&ei->i_data_sem);\n\n\tif (IS_SYNC(inode))\n\t\text4_handle_sync(handle);\n\nout_stop:\n\t/*\n\t * If this was a simple ftruncate() and the file will remain alive,\n\t * then we need to clear up the orphan record which we created above.\n\t * However, if this was a real unlink then we were called by\n\t * ext4_evict_inode(), and we allow that function to clean up the\n\t * orphan info for us.\n\t */\n\tif (inode->i_nlink)\n\t\text4_orphan_del(handle, inode);\n\n\tinode->i_mtime = inode->i_ctime = ext4_current_time(inode);\n\text4_mark_inode_dirty(handle, inode);\n\text4_journal_stop(handle);\n\n\ttrace_ext4_truncate_exit(inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "truncate_inode_pages",
          "args": [
            "inode->i_mapping",
            "inode->i_size"
          ],
          "line": 2223
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&inode->i_mutex"
          ],
          "line": 2222
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "jbd_debug",
          "args": [
            "2",
            "\"truncating inode %lu to %lld bytes\\n\"",
            "inode->i_ino",
            "inode->i_size"
          ],
          "line": 2220
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_opt",
          "args": [
            "sb",
            "DEBUG"
          ],
          "line": 2216
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dquot_initialize",
          "args": [
            "inode"
          ],
          "line": 2214
        },
        "resolved": true,
        "details": {
          "function_name": "dquot_initialize",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/quota/dquot.c",
          "lines": "1459-1462",
          "snippet": "void dquot_initialize(struct inode *inode)\n{\n\t__dquot_initialize(inode, -1);\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include \"../internal.h\" /* ugh */",
            "#include <linux/quotaops.h>",
            "#include <linux/capability.h>",
            "#include <linux/namei.h>",
            "#include <linux/kmod.h>",
            "#include <linux/sched.h>",
            "#include <linux/security.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>",
            "#include <linux/tty.h>",
            "#include <linux/stat.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/time.h>",
            "#include <linux/mm.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static qsize_t inode_get_rsv_space(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include \"../internal.h\" /* ugh */\n#include <linux/quotaops.h>\n#include <linux/capability.h>\n#include <linux/namei.h>\n#include <linux/kmod.h>\n#include <linux/sched.h>\n#include <linux/security.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/sysctl.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/tty.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/time.h>\n#include <linux/mm.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/kernel.h>\n#include <linux/errno.h>\n\nstatic qsize_t inode_get_rsv_space(struct inode *inode);\n\nvoid dquot_initialize(struct inode *inode)\n{\n\t__dquot_initialize(inode, -1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_add",
          "args": [
            "&EXT4_I(inode)->i_orphan",
            "&EXT4_SB(sb)->s_orphan"
          ],
          "line": 2213
        },
        "resolved": true,
        "details": {
          "function_name": "simple_xattr_list_add",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xattr.c",
          "lines": "966-972",
          "snippet": "void simple_xattr_list_add(struct simple_xattrs *xattrs,\n\t\t\t   struct simple_xattr *new_xattr)\n{\n\tspin_lock(&xattrs->lock);\n\tlist_add(&new_xattr->list, &xattrs->head);\n\tspin_unlock(&xattrs->lock);\n}",
          "includes": [
            "#include <asm/uaccess.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/audit.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/evm.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/xattr.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/uaccess.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/vmalloc.h>\n#include <linux/audit.h>\n#include <linux/fsnotify.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n#include <linux/evm.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/xattr.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nvoid simple_xattr_list_add(struct simple_xattrs *xattrs,\n\t\t\t   struct simple_xattr *new_xattr)\n{\n\tspin_lock(&xattrs->lock);\n\tlist_add(&new_xattr->list, &xattrs->head);\n\tspin_unlock(&xattrs->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "EXT4_SB",
          "args": [
            "sb"
          ],
          "line": 2213
        },
        "resolved": true,
        "details": {
          "function_name": "EXT4_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ext4.h",
          "lines": "1356-1359",
          "snippet": "static inline struct ext4_sb_info *EXT4_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include \"extents_status.h\"",
            "#include <linux/compat.h>",
            "#include <linux/falloc.h>",
            "#include <crypto/hash.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/wait.h>",
            "#include <linux/timer.h>",
            "#include <linux/mutex.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/quota.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extents_status.h\"\n#include <linux/compat.h>\n#include <linux/falloc.h>\n#include <crypto/hash.h>\n#include <linux/ratelimit.h>\n#include <linux/percpu_counter.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/wait.h>\n#include <linux/timer.h>\n#include <linux/mutex.h>\n#include <linux/seqlock.h>\n#include <linux/rbtree.h>\n#include <linux/rwsem.h>\n#include <linux/quota.h>\n#include <linux/jbd2.h>\n#include <linux/magic.h>\n#include <linux/blkdev.h>\n#include <linux/types.h>\n\nstatic inline struct ext4_sb_info *EXT4_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      },
      {
        "call_info": {
          "callee": "EXT4_I",
          "args": [
            "inode"
          ],
          "line": 2213
        },
        "resolved": true,
        "details": {
          "function_name": "EXT4_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ext4.h",
          "lines": "1360-1363",
          "snippet": "static inline struct ext4_inode_info *EXT4_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ext4_inode_info, vfs_inode);\n}",
          "includes": [
            "#include \"extents_status.h\"",
            "#include <linux/compat.h>",
            "#include <linux/falloc.h>",
            "#include <crypto/hash.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/wait.h>",
            "#include <linux/timer.h>",
            "#include <linux/mutex.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/quota.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extents_status.h\"\n#include <linux/compat.h>\n#include <linux/falloc.h>\n#include <crypto/hash.h>\n#include <linux/ratelimit.h>\n#include <linux/percpu_counter.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/wait.h>\n#include <linux/timer.h>\n#include <linux/mutex.h>\n#include <linux/seqlock.h>\n#include <linux/rbtree.h>\n#include <linux/rwsem.h>\n#include <linux/quota.h>\n#include <linux/jbd2.h>\n#include <linux/magic.h>\n#include <linux/blkdev.h>\n#include <linux/types.h>\n\nstatic inline struct ext4_inode_info *EXT4_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ext4_inode_info, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "inode"
          ],
          "line": 2208
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_orphan_get",
          "args": [
            "sb",
            "le32_to_cpu(es->s_last_orphan)"
          ],
          "line": 2207
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_orphan_get",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ialloc.c",
          "lines": "1088-1159",
          "snippet": "struct inode *ext4_orphan_get(struct super_block *sb, unsigned long ino)\n{\n\tunsigned long max_ino = le32_to_cpu(EXT4_SB(sb)->s_es->s_inodes_count);\n\text4_group_t block_group;\n\tint bit;\n\tstruct buffer_head *bitmap_bh;\n\tstruct inode *inode = NULL;\n\tlong err = -EIO;\n\n\t/* Error cases - e2fsck has already cleaned up for us */\n\tif (ino > max_ino) {\n\t\text4_warning(sb, \"bad orphan ino %lu!  e2fsck was run?\", ino);\n\t\tgoto error;\n\t}\n\n\tblock_group = (ino - 1) / EXT4_INODES_PER_GROUP(sb);\n\tbit = (ino - 1) % EXT4_INODES_PER_GROUP(sb);\n\tbitmap_bh = ext4_read_inode_bitmap(sb, block_group);\n\tif (!bitmap_bh) {\n\t\text4_warning(sb, \"inode bitmap error for orphan %lu\", ino);\n\t\tgoto error;\n\t}\n\n\t/* Having the inode bit set should be a 100% indicator that this\n\t * is a valid orphan (no e2fsck run on fs).  Orphans also include\n\t * inodes that were being truncated, so we can't check i_nlink==0.\n\t */\n\tif (!ext4_test_bit(bit, bitmap_bh->b_data))\n\t\tgoto bad_orphan;\n\n\tinode = ext4_iget(sb, ino);\n\tif (IS_ERR(inode))\n\t\tgoto iget_failed;\n\n\t/*\n\t * If the orphans has i_nlinks > 0 then it should be able to be\n\t * truncated, otherwise it won't be removed from the orphan list\n\t * during processing and an infinite loop will result.\n\t */\n\tif (inode->i_nlink && !ext4_can_truncate(inode))\n\t\tgoto bad_orphan;\n\n\tif (NEXT_ORPHAN(inode) > max_ino)\n\t\tgoto bad_orphan;\n\tbrelse(bitmap_bh);\n\treturn inode;\n\niget_failed:\n\terr = PTR_ERR(inode);\n\tinode = NULL;\nbad_orphan:\n\text4_warning(sb, \"bad orphan inode %lu!  e2fsck was run?\", ino);\n\tprintk(KERN_WARNING \"ext4_test_bit(bit=%d, block=%llu) = %d\\n\",\n\t       bit, (unsigned long long)bitmap_bh->b_blocknr,\n\t       ext4_test_bit(bit, bitmap_bh->b_data));\n\tprintk(KERN_WARNING \"inode=%p\\n\", inode);\n\tif (inode) {\n\t\tprintk(KERN_WARNING \"is_bad_inode(inode)=%d\\n\",\n\t\t       is_bad_inode(inode));\n\t\tprintk(KERN_WARNING \"NEXT_ORPHAN(inode)=%u\\n\",\n\t\t       NEXT_ORPHAN(inode));\n\t\tprintk(KERN_WARNING \"max_ino=%lu\\n\", max_ino);\n\t\tprintk(KERN_WARNING \"i_nlink=%u\\n\", inode->i_nlink);\n\t\t/* Avoid freeing blocks if we got a bad deleted inode */\n\t\tif (inode->i_nlink == 0)\n\t\t\tinode->i_blocks = 0;\n\t\tiput(inode);\n\t}\n\tbrelse(bitmap_bh);\nerror:\n\treturn ERR_PTR(err);\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include \"ext4.h\"",
            "#include <asm/byteorder.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/bitops.h>",
            "#include <linux/random.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4.h\"\n#include <asm/byteorder.h>\n#include <linux/blkdev.h>\n#include <linux/bitops.h>\n#include <linux/random.h>\n#include <linux/buffer_head.h>\n#include <linux/quotaops.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/jbd2.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n\nstruct inode *ext4_orphan_get(struct super_block *sb, unsigned long ino)\n{\n\tunsigned long max_ino = le32_to_cpu(EXT4_SB(sb)->s_es->s_inodes_count);\n\text4_group_t block_group;\n\tint bit;\n\tstruct buffer_head *bitmap_bh;\n\tstruct inode *inode = NULL;\n\tlong err = -EIO;\n\n\t/* Error cases - e2fsck has already cleaned up for us */\n\tif (ino > max_ino) {\n\t\text4_warning(sb, \"bad orphan ino %lu!  e2fsck was run?\", ino);\n\t\tgoto error;\n\t}\n\n\tblock_group = (ino - 1) / EXT4_INODES_PER_GROUP(sb);\n\tbit = (ino - 1) % EXT4_INODES_PER_GROUP(sb);\n\tbitmap_bh = ext4_read_inode_bitmap(sb, block_group);\n\tif (!bitmap_bh) {\n\t\text4_warning(sb, \"inode bitmap error for orphan %lu\", ino);\n\t\tgoto error;\n\t}\n\n\t/* Having the inode bit set should be a 100% indicator that this\n\t * is a valid orphan (no e2fsck run on fs).  Orphans also include\n\t * inodes that were being truncated, so we can't check i_nlink==0.\n\t */\n\tif (!ext4_test_bit(bit, bitmap_bh->b_data))\n\t\tgoto bad_orphan;\n\n\tinode = ext4_iget(sb, ino);\n\tif (IS_ERR(inode))\n\t\tgoto iget_failed;\n\n\t/*\n\t * If the orphans has i_nlinks > 0 then it should be able to be\n\t * truncated, otherwise it won't be removed from the orphan list\n\t * during processing and an infinite loop will result.\n\t */\n\tif (inode->i_nlink && !ext4_can_truncate(inode))\n\t\tgoto bad_orphan;\n\n\tif (NEXT_ORPHAN(inode) > max_ino)\n\t\tgoto bad_orphan;\n\tbrelse(bitmap_bh);\n\treturn inode;\n\niget_failed:\n\terr = PTR_ERR(inode);\n\tinode = NULL;\nbad_orphan:\n\text4_warning(sb, \"bad orphan inode %lu!  e2fsck was run?\", ino);\n\tprintk(KERN_WARNING \"ext4_test_bit(bit=%d, block=%llu) = %d\\n\",\n\t       bit, (unsigned long long)bitmap_bh->b_blocknr,\n\t       ext4_test_bit(bit, bitmap_bh->b_data));\n\tprintk(KERN_WARNING \"inode=%p\\n\", inode);\n\tif (inode) {\n\t\tprintk(KERN_WARNING \"is_bad_inode(inode)=%d\\n\",\n\t\t       is_bad_inode(inode));\n\t\tprintk(KERN_WARNING \"NEXT_ORPHAN(inode)=%u\\n\",\n\t\t       NEXT_ORPHAN(inode));\n\t\tprintk(KERN_WARNING \"max_ino=%lu\\n\", max_ino);\n\t\tprintk(KERN_WARNING \"i_nlink=%u\\n\", inode->i_nlink);\n\t\t/* Avoid freeing blocks if we got a bad deleted inode */\n\t\tif (inode->i_nlink == 0)\n\t\t\tinode->i_blocks = 0;\n\t\tiput(inode);\n\t}\n\tbrelse(bitmap_bh);\nerror:\n\treturn ERR_PTR(err);\n}"
        }
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "es->s_last_orphan"
          ],
          "line": 2207
        },
        "resolved": true,
        "details": {
          "function_name": "sle32_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "53-56",
          "snippet": "static inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_quota_on_mount",
          "args": [
            "sb",
            "i"
          ],
          "line": 2195
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_quota_on_mount",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/super.c",
          "lines": "5216-5220",
          "snippet": "static int ext4_quota_on_mount(struct super_block *sb, int type)\n{\n\treturn dquot_quota_on_mount(sb, EXT4_SB(sb)->s_qf_names[type],\n\t\t\t\t\tEXT4_SB(sb)->s_jquota_fmt, type);\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"mballoc.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include \"ext4_extents.h\"\t/* Needed for trace points definition */",
            "#include \"ext4.h\"",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/crc16.h>",
            "#include <linux/log2.h>",
            "#include <linux/ctype.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/random.h>",
            "#include <linux/vfs.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/parser.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/time.h>",
            "#include <linux/fs.h>",
            "#include <linux/string.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ext4_unfreeze(struct super_block *sb);",
            "static int ext4_freeze(struct super_block *sb);",
            "static inline int ext2_feature_set_ok(struct super_block *sb);",
            "static inline int ext3_feature_set_ok(struct super_block *sb);",
            "static void ext4_unregister_li_request(struct super_block *sb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"mballoc.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4_extents.h\"\t/* Needed for trace points definition */\n#include \"ext4.h\"\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <asm/uaccess.h>\n#include <linux/cleancache.h>\n#include <linux/crc16.h>\n#include <linux/log2.h>\n#include <linux/ctype.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/random.h>\n#include <linux/vfs.h>\n#include <linux/exportfs.h>\n#include <linux/buffer_head.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/jbd2.h>\n#include <linux/vmalloc.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n#include <linux/string.h>\n#include <linux/module.h>\n\nstatic int ext4_unfreeze(struct super_block *sb);\nstatic int ext4_freeze(struct super_block *sb);\nstatic inline int ext2_feature_set_ok(struct super_block *sb);\nstatic inline int ext3_feature_set_ok(struct super_block *sb);\nstatic void ext4_unregister_li_request(struct super_block *sb);\n\nstatic int ext4_quota_on_mount(struct super_block *sb, int type)\n{\n\treturn dquot_quota_on_mount(sb, EXT4_SB(sb)->s_qf_names[type],\n\t\t\t\t\tEXT4_SB(sb)->s_jquota_fmt, type);\n}"
        }
      },
      {
        "call_info": {
          "callee": "jbd_debug",
          "args": [
            "1",
            "\"Skipping orphan recovery on fs with errors.\\n\""
          ],
          "line": 2181
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_feature_set_ok",
          "args": [
            "sb",
            "0"
          ],
          "line": 2168
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_feature_set_ok",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/super.c",
          "lines": "2768-2826",
          "snippet": "static int ext4_feature_set_ok(struct super_block *sb, int readonly)\n{\n\tif (EXT4_HAS_INCOMPAT_FEATURE(sb, ~EXT4_FEATURE_INCOMPAT_SUPP)) {\n\t\text4_msg(sb, KERN_ERR,\n\t\t\t\"Couldn't mount because of \"\n\t\t\t\"unsupported optional features (%x)\",\n\t\t\t(le32_to_cpu(EXT4_SB(sb)->s_es->s_feature_incompat) &\n\t\t\t~EXT4_FEATURE_INCOMPAT_SUPP));\n\t\treturn 0;\n\t}\n\n\tif (readonly)\n\t\treturn 1;\n\n\tif (EXT4_HAS_RO_COMPAT_FEATURE(sb, EXT4_FEATURE_RO_COMPAT_READONLY)) {\n\t\text4_msg(sb, KERN_INFO, \"filesystem is read-only\");\n\t\tsb->s_flags |= MS_RDONLY;\n\t\treturn 1;\n\t}\n\n\t/* Check that feature set is OK for a read-write mount */\n\tif (EXT4_HAS_RO_COMPAT_FEATURE(sb, ~EXT4_FEATURE_RO_COMPAT_SUPP)) {\n\t\text4_msg(sb, KERN_ERR, \"couldn't mount RDWR because of \"\n\t\t\t \"unsupported optional features (%x)\",\n\t\t\t (le32_to_cpu(EXT4_SB(sb)->s_es->s_feature_ro_compat) &\n\t\t\t\t~EXT4_FEATURE_RO_COMPAT_SUPP));\n\t\treturn 0;\n\t}\n\t/*\n\t * Large file size enabled file system can only be mounted\n\t * read-write on 32-bit systems if kernel is built with CONFIG_LBDAF\n\t */\n\tif (EXT4_HAS_RO_COMPAT_FEATURE(sb, EXT4_FEATURE_RO_COMPAT_HUGE_FILE)) {\n\t\tif (sizeof(blkcnt_t) < sizeof(u64)) {\n\t\t\text4_msg(sb, KERN_ERR, \"Filesystem with huge files \"\n\t\t\t\t \"cannot be mounted RDWR without \"\n\t\t\t\t \"CONFIG_LBDAF\");\n\t\t\treturn 0;\n\t\t}\n\t}\n\tif (EXT4_HAS_RO_COMPAT_FEATURE(sb, EXT4_FEATURE_RO_COMPAT_BIGALLOC) &&\n\t    !EXT4_HAS_INCOMPAT_FEATURE(sb, EXT4_FEATURE_INCOMPAT_EXTENTS)) {\n\t\text4_msg(sb, KERN_ERR,\n\t\t\t \"Can't support bigalloc feature without \"\n\t\t\t \"extents feature\\n\");\n\t\treturn 0;\n\t}\n\n#ifndef CONFIG_QUOTA\n\tif (EXT4_HAS_RO_COMPAT_FEATURE(sb, EXT4_FEATURE_RO_COMPAT_QUOTA) &&\n\t    !readonly) {\n\t\text4_msg(sb, KERN_ERR,\n\t\t\t \"Filesystem with quota feature cannot be mounted RDWR \"\n\t\t\t \"without CONFIG_QUOTA\");\n\t\treturn 0;\n\t}\n#endif  /* CONFIG_QUOTA */\n\treturn 1;\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"mballoc.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include \"ext4_extents.h\"\t/* Needed for trace points definition */",
            "#include \"ext4.h\"",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/crc16.h>",
            "#include <linux/log2.h>",
            "#include <linux/ctype.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/random.h>",
            "#include <linux/vfs.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/parser.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/time.h>",
            "#include <linux/fs.h>",
            "#include <linux/string.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ext4_unfreeze(struct super_block *sb);",
            "static int ext4_freeze(struct super_block *sb);",
            "static inline int ext2_feature_set_ok(struct super_block *sb);",
            "static inline int ext3_feature_set_ok(struct super_block *sb);",
            "static int ext4_feature_set_ok(struct super_block *sb, int readonly);",
            "static void ext4_unregister_li_request(struct super_block *sb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"mballoc.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4_extents.h\"\t/* Needed for trace points definition */\n#include \"ext4.h\"\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <asm/uaccess.h>\n#include <linux/cleancache.h>\n#include <linux/crc16.h>\n#include <linux/log2.h>\n#include <linux/ctype.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/random.h>\n#include <linux/vfs.h>\n#include <linux/exportfs.h>\n#include <linux/buffer_head.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/jbd2.h>\n#include <linux/vmalloc.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n#include <linux/string.h>\n#include <linux/module.h>\n\nstatic int ext4_unfreeze(struct super_block *sb);\nstatic int ext4_freeze(struct super_block *sb);\nstatic inline int ext2_feature_set_ok(struct super_block *sb);\nstatic inline int ext3_feature_set_ok(struct super_block *sb);\nstatic int ext4_feature_set_ok(struct super_block *sb, int readonly);\nstatic void ext4_unregister_li_request(struct super_block *sb);\n\nstatic int ext4_feature_set_ok(struct super_block *sb, int readonly)\n{\n\tif (EXT4_HAS_INCOMPAT_FEATURE(sb, ~EXT4_FEATURE_INCOMPAT_SUPP)) {\n\t\text4_msg(sb, KERN_ERR,\n\t\t\t\"Couldn't mount because of \"\n\t\t\t\"unsupported optional features (%x)\",\n\t\t\t(le32_to_cpu(EXT4_SB(sb)->s_es->s_feature_incompat) &\n\t\t\t~EXT4_FEATURE_INCOMPAT_SUPP));\n\t\treturn 0;\n\t}\n\n\tif (readonly)\n\t\treturn 1;\n\n\tif (EXT4_HAS_RO_COMPAT_FEATURE(sb, EXT4_FEATURE_RO_COMPAT_READONLY)) {\n\t\text4_msg(sb, KERN_INFO, \"filesystem is read-only\");\n\t\tsb->s_flags |= MS_RDONLY;\n\t\treturn 1;\n\t}\n\n\t/* Check that feature set is OK for a read-write mount */\n\tif (EXT4_HAS_RO_COMPAT_FEATURE(sb, ~EXT4_FEATURE_RO_COMPAT_SUPP)) {\n\t\text4_msg(sb, KERN_ERR, \"couldn't mount RDWR because of \"\n\t\t\t \"unsupported optional features (%x)\",\n\t\t\t (le32_to_cpu(EXT4_SB(sb)->s_es->s_feature_ro_compat) &\n\t\t\t\t~EXT4_FEATURE_RO_COMPAT_SUPP));\n\t\treturn 0;\n\t}\n\t/*\n\t * Large file size enabled file system can only be mounted\n\t * read-write on 32-bit systems if kernel is built with CONFIG_LBDAF\n\t */\n\tif (EXT4_HAS_RO_COMPAT_FEATURE(sb, EXT4_FEATURE_RO_COMPAT_HUGE_FILE)) {\n\t\tif (sizeof(blkcnt_t) < sizeof(u64)) {\n\t\t\text4_msg(sb, KERN_ERR, \"Filesystem with huge files \"\n\t\t\t\t \"cannot be mounted RDWR without \"\n\t\t\t\t \"CONFIG_LBDAF\");\n\t\t\treturn 0;\n\t\t}\n\t}\n\tif (EXT4_HAS_RO_COMPAT_FEATURE(sb, EXT4_FEATURE_RO_COMPAT_BIGALLOC) &&\n\t    !EXT4_HAS_INCOMPAT_FEATURE(sb, EXT4_FEATURE_INCOMPAT_EXTENTS)) {\n\t\text4_msg(sb, KERN_ERR,\n\t\t\t \"Can't support bigalloc feature without \"\n\t\t\t \"extents feature\\n\");\n\t\treturn 0;\n\t}\n\n#ifndef CONFIG_QUOTA\n\tif (EXT4_HAS_RO_COMPAT_FEATURE(sb, EXT4_FEATURE_RO_COMPAT_QUOTA) &&\n\t    !readonly) {\n\t\text4_msg(sb, KERN_ERR,\n\t\t\t \"Filesystem with quota feature cannot be mounted RDWR \"\n\t\t\t \"without CONFIG_QUOTA\");\n\t\treturn 0;\n\t}\n#endif  /* CONFIG_QUOTA */\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "bdev_read_only",
          "args": [
            "sb->s_bdev"
          ],
          "line": 2161
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "jbd_debug",
          "args": [
            "4",
            "\"no orphan inodes to clean up\\n\""
          ],
          "line": 2157
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"mballoc.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4_extents.h\"\t/* Needed for trace points definition */\n#include \"ext4.h\"\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <asm/uaccess.h>\n#include <linux/cleancache.h>\n#include <linux/crc16.h>\n#include <linux/log2.h>\n#include <linux/ctype.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/random.h>\n#include <linux/vfs.h>\n#include <linux/exportfs.h>\n#include <linux/buffer_head.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/jbd2.h>\n#include <linux/vmalloc.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n#include <linux/string.h>\n#include <linux/module.h>\n\nstatic void ext4_mark_recovery_complete(struct super_block *sb,\n\t\t\t\t\tstruct ext4_super_block *es);\nstatic void ext4_clear_journal_err(struct super_block *sb,\n\t\t\t\t   struct ext4_super_block *es);\nstatic int ext4_remount(struct super_block *sb, int *flags, char *data);\nstatic int ext4_unfreeze(struct super_block *sb);\nstatic int ext4_freeze(struct super_block *sb);\nstatic struct dentry *ext4_mount(struct file_system_type *fs_type, int flags,\n\t\t       const char *dev_name, void *data);\nstatic inline int ext2_feature_set_ok(struct super_block *sb);\nstatic inline int ext3_feature_set_ok(struct super_block *sb);\nstatic int ext4_feature_set_ok(struct super_block *sb, int readonly);\nstatic void ext4_unregister_li_request(struct super_block *sb);\n\nstatic void ext4_orphan_cleanup(struct super_block *sb,\n\t\t\t\tstruct ext4_super_block *es)\n{\n\tunsigned int s_flags = sb->s_flags;\n\tint nr_orphans = 0, nr_truncates = 0;\n#ifdef CONFIG_QUOTA\n\tint i;\n#endif\n\tif (!es->s_last_orphan) {\n\t\tjbd_debug(4, \"no orphan inodes to clean up\\n\");\n\t\treturn;\n\t}\n\n\tif (bdev_read_only(sb->s_bdev)) {\n\t\text4_msg(sb, KERN_ERR, \"write access \"\n\t\t\t\"unavailable, skipping orphan cleanup\");\n\t\treturn;\n\t}\n\n\t/* Check if feature set would not allow a r/w mount */\n\tif (!ext4_feature_set_ok(sb, 0)) {\n\t\text4_msg(sb, KERN_INFO, \"Skipping orphan cleanup due to \"\n\t\t\t \"unknown ROCOMPAT features\");\n\t\treturn;\n\t}\n\n\tif (EXT4_SB(sb)->s_mount_state & EXT4_ERROR_FS) {\n\t\t/* don't clear list on RO mount w/ errors */\n\t\tif (es->s_last_orphan && !(s_flags & MS_RDONLY)) {\n\t\t\text4_msg(sb, KERN_INFO, \"Errors on filesystem, \"\n\t\t\t\t  \"clearing orphan list.\\n\");\n\t\t\tes->s_last_orphan = 0;\n\t\t}\n\t\tjbd_debug(1, \"Skipping orphan recovery on fs with errors.\\n\");\n\t\treturn;\n\t}\n\n\tif (s_flags & MS_RDONLY) {\n\t\text4_msg(sb, KERN_INFO, \"orphan cleanup on readonly fs\");\n\t\tsb->s_flags &= ~MS_RDONLY;\n\t}\n#ifdef CONFIG_QUOTA\n\t/* Needed for iput() to work correctly and not trash data */\n\tsb->s_flags |= MS_ACTIVE;\n\t/* Turn on quotas so that they are updated correctly */\n\tfor (i = 0; i < EXT4_MAXQUOTAS; i++) {\n\t\tif (EXT4_SB(sb)->s_qf_names[i]) {\n\t\t\tint ret = ext4_quota_on_mount(sb, i);\n\t\t\tif (ret < 0)\n\t\t\t\text4_msg(sb, KERN_ERR,\n\t\t\t\t\t\"Cannot turn on journaled \"\n\t\t\t\t\t\"quota: error %d\", ret);\n\t\t}\n\t}\n#endif\n\n\twhile (es->s_last_orphan) {\n\t\tstruct inode *inode;\n\n\t\tinode = ext4_orphan_get(sb, le32_to_cpu(es->s_last_orphan));\n\t\tif (IS_ERR(inode)) {\n\t\t\tes->s_last_orphan = 0;\n\t\t\tbreak;\n\t\t}\n\n\t\tlist_add(&EXT4_I(inode)->i_orphan, &EXT4_SB(sb)->s_orphan);\n\t\tdquot_initialize(inode);\n\t\tif (inode->i_nlink) {\n\t\t\tif (test_opt(sb, DEBUG))\n\t\t\t\text4_msg(sb, KERN_DEBUG,\n\t\t\t\t\t\"%s: truncating inode %lu to %lld bytes\",\n\t\t\t\t\t__func__, inode->i_ino, inode->i_size);\n\t\t\tjbd_debug(2, \"truncating inode %lu to %lld bytes\\n\",\n\t\t\t\t  inode->i_ino, inode->i_size);\n\t\t\tmutex_lock(&inode->i_mutex);\n\t\t\ttruncate_inode_pages(inode->i_mapping, inode->i_size);\n\t\t\text4_truncate(inode);\n\t\t\tmutex_unlock(&inode->i_mutex);\n\t\t\tnr_truncates++;\n\t\t} else {\n\t\t\tif (test_opt(sb, DEBUG))\n\t\t\t\text4_msg(sb, KERN_DEBUG,\n\t\t\t\t\t\"%s: deleting unreferenced inode %lu\",\n\t\t\t\t\t__func__, inode->i_ino);\n\t\t\tjbd_debug(2, \"deleting unreferenced inode %lu\\n\",\n\t\t\t\t  inode->i_ino);\n\t\t\tnr_orphans++;\n\t\t}\n\t\tiput(inode);  /* The delete magic happens here! */\n\t}\n\n#define PLURAL(x) (x), ((x) == 1) ? \"\" : \"s\"\n\n\tif (nr_orphans)\n\t\text4_msg(sb, KERN_INFO, \"%d orphan inode%s deleted\",\n\t\t       PLURAL(nr_orphans));\n\tif (nr_truncates)\n\t\text4_msg(sb, KERN_INFO, \"%d truncate%s cleaned up\",\n\t\t       PLURAL(nr_truncates));\n#ifdef CONFIG_QUOTA\n\t/* Turn quotas off */\n\tfor (i = 0; i < EXT4_MAXQUOTAS; i++) {\n\t\tif (sb_dqopt(sb)->files[i])\n\t\t\tdquot_quota_off(sb, i);\n\t}\n#endif\n\tsb->s_flags = s_flags; /* Restore MS_RDONLY status */\n}"
  },
  {
    "function_name": "ext4_check_descriptors",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/super.c",
    "lines": "2059-2129",
    "snippet": "static int ext4_check_descriptors(struct super_block *sb,\n\t\t\t\t  ext4_group_t *first_not_zeroed)\n{\n\tstruct ext4_sb_info *sbi = EXT4_SB(sb);\n\text4_fsblk_t first_block = le32_to_cpu(sbi->s_es->s_first_data_block);\n\text4_fsblk_t last_block;\n\text4_fsblk_t block_bitmap;\n\text4_fsblk_t inode_bitmap;\n\text4_fsblk_t inode_table;\n\tint flexbg_flag = 0;\n\text4_group_t i, grp = sbi->s_groups_count;\n\n\tif (EXT4_HAS_INCOMPAT_FEATURE(sb, EXT4_FEATURE_INCOMPAT_FLEX_BG))\n\t\tflexbg_flag = 1;\n\n\text4_debug(\"Checking group descriptors\");\n\n\tfor (i = 0; i < sbi->s_groups_count; i++) {\n\t\tstruct ext4_group_desc *gdp = ext4_get_group_desc(sb, i, NULL);\n\n\t\tif (i == sbi->s_groups_count - 1 || flexbg_flag)\n\t\t\tlast_block = ext4_blocks_count(sbi->s_es) - 1;\n\t\telse\n\t\t\tlast_block = first_block +\n\t\t\t\t(EXT4_BLOCKS_PER_GROUP(sb) - 1);\n\n\t\tif ((grp == sbi->s_groups_count) &&\n\t\t   !(gdp->bg_flags & cpu_to_le16(EXT4_BG_INODE_ZEROED)))\n\t\t\tgrp = i;\n\n\t\tblock_bitmap = ext4_block_bitmap(sb, gdp);\n\t\tif (block_bitmap < first_block || block_bitmap > last_block) {\n\t\t\text4_msg(sb, KERN_ERR, \"ext4_check_descriptors: \"\n\t\t\t       \"Block bitmap for group %u not in group \"\n\t\t\t       \"(block %llu)!\", i, block_bitmap);\n\t\t\treturn 0;\n\t\t}\n\t\tinode_bitmap = ext4_inode_bitmap(sb, gdp);\n\t\tif (inode_bitmap < first_block || inode_bitmap > last_block) {\n\t\t\text4_msg(sb, KERN_ERR, \"ext4_check_descriptors: \"\n\t\t\t       \"Inode bitmap for group %u not in group \"\n\t\t\t       \"(block %llu)!\", i, inode_bitmap);\n\t\t\treturn 0;\n\t\t}\n\t\tinode_table = ext4_inode_table(sb, gdp);\n\t\tif (inode_table < first_block ||\n\t\t    inode_table + sbi->s_itb_per_group - 1 > last_block) {\n\t\t\text4_msg(sb, KERN_ERR, \"ext4_check_descriptors: \"\n\t\t\t       \"Inode table for group %u not in group \"\n\t\t\t       \"(block %llu)!\", i, inode_table);\n\t\t\treturn 0;\n\t\t}\n\t\text4_lock_group(sb, i);\n\t\tif (!ext4_group_desc_csum_verify(sb, i, gdp)) {\n\t\t\text4_msg(sb, KERN_ERR, \"ext4_check_descriptors: \"\n\t\t\t\t \"Checksum for group %u failed (%u!=%u)\",\n\t\t\t\t i, le16_to_cpu(ext4_group_desc_csum(sbi, i,\n\t\t\t\t     gdp)), le16_to_cpu(gdp->bg_checksum));\n\t\t\tif (!(sb->s_flags & MS_RDONLY)) {\n\t\t\t\text4_unlock_group(sb, i);\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\t\text4_unlock_group(sb, i);\n\t\tif (!flexbg_flag)\n\t\t\tfirst_block += EXT4_BLOCKS_PER_GROUP(sb);\n\t}\n\tif (NULL != first_not_zeroed)\n\t\t*first_not_zeroed = grp;\n\treturn 1;\n}",
    "includes": [
      "#include <trace/events/ext4.h>",
      "#include \"mballoc.h\"",
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"ext4_jbd2.h\"",
      "#include \"ext4_extents.h\"\t/* Needed for trace points definition */",
      "#include \"ext4.h\"",
      "#include <linux/freezer.h>",
      "#include <linux/kthread.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/cleancache.h>",
      "#include <linux/crc16.h>",
      "#include <linux/log2.h>",
      "#include <linux/ctype.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/namei.h>",
      "#include <linux/mount.h>",
      "#include <linux/random.h>",
      "#include <linux/vfs.h>",
      "#include <linux/exportfs.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/parser.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/init.h>",
      "#include <linux/slab.h>",
      "#include <linux/jbd2.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/time.h>",
      "#include <linux/fs.h>",
      "#include <linux/string.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ext4_unfreeze(struct super_block *sb);",
      "static int ext4_freeze(struct super_block *sb);",
      "static inline int ext2_feature_set_ok(struct super_block *sb);",
      "static inline int ext3_feature_set_ok(struct super_block *sb);",
      "static void ext4_unregister_li_request(struct super_block *sb);",
      "static int ext4_reserve_clusters(struct ext4_sb_info *, ext4_fsblk_t);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "EXT4_BLOCKS_PER_GROUP",
          "args": [
            "sb"
          ],
          "line": 2124
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_unlock_group",
          "args": [
            "sb",
            "i"
          ],
          "line": 2122
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_unlock_group",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ext4.h",
          "lines": "2567-2571",
          "snippet": "static inline void ext4_unlock_group(struct super_block *sb,\n\t\t\t\t\text4_group_t group)\n{\n\tspin_unlock(ext4_group_lock_ptr(sb, group));\n}",
          "includes": [
            "#include \"extents_status.h\"",
            "#include <linux/compat.h>",
            "#include <linux/falloc.h>",
            "#include <crypto/hash.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/wait.h>",
            "#include <linux/timer.h>",
            "#include <linux/mutex.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/quota.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extents_status.h\"\n#include <linux/compat.h>\n#include <linux/falloc.h>\n#include <crypto/hash.h>\n#include <linux/ratelimit.h>\n#include <linux/percpu_counter.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/wait.h>\n#include <linux/timer.h>\n#include <linux/mutex.h>\n#include <linux/seqlock.h>\n#include <linux/rbtree.h>\n#include <linux/rwsem.h>\n#include <linux/quota.h>\n#include <linux/jbd2.h>\n#include <linux/magic.h>\n#include <linux/blkdev.h>\n#include <linux/types.h>\n\nstatic inline void ext4_unlock_group(struct super_block *sb,\n\t\t\t\t\text4_group_t group)\n{\n\tspin_unlock(ext4_group_lock_ptr(sb, group));\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_msg",
          "args": [
            "sb",
            "KERN_ERR",
            "\"ext4_check_descriptors: \"\n\t\t\t\t \"Checksum for group %u failed (%u!=%u)\"",
            "i",
            "le16_to_cpu(ext4_group_desc_csum(sbi, i,\n\t\t\t\t     gdp))",
            "le16_to_cpu(gdp->bg_checksum)"
          ],
          "line": 2113
        },
        "resolved": true,
        "details": {
          "function_name": "__ext4_msg",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/super.c",
          "lines": "593-607",
          "snippet": "void __ext4_msg(struct super_block *sb,\n\t\tconst char *prefix, const char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tif (!___ratelimit(&(EXT4_SB(sb)->s_msg_ratelimit_state), \"EXT4-fs\"))\n\t\treturn;\n\n\tva_start(args, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\tprintk(\"%sEXT4-fs (%s): %pV\\n\", prefix, sb->s_id, &vaf);\n\tva_end(args);\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"mballoc.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include \"ext4_extents.h\"\t/* Needed for trace points definition */",
            "#include \"ext4.h\"",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/crc16.h>",
            "#include <linux/log2.h>",
            "#include <linux/ctype.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/random.h>",
            "#include <linux/vfs.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/parser.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/time.h>",
            "#include <linux/fs.h>",
            "#include <linux/string.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ext4_unfreeze(struct super_block *sb);",
            "static int ext4_freeze(struct super_block *sb);",
            "static inline int ext2_feature_set_ok(struct super_block *sb);",
            "static inline int ext3_feature_set_ok(struct super_block *sb);",
            "static void ext4_unregister_li_request(struct super_block *sb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"mballoc.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4_extents.h\"\t/* Needed for trace points definition */\n#include \"ext4.h\"\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <asm/uaccess.h>\n#include <linux/cleancache.h>\n#include <linux/crc16.h>\n#include <linux/log2.h>\n#include <linux/ctype.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/random.h>\n#include <linux/vfs.h>\n#include <linux/exportfs.h>\n#include <linux/buffer_head.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/jbd2.h>\n#include <linux/vmalloc.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n#include <linux/string.h>\n#include <linux/module.h>\n\nstatic int ext4_unfreeze(struct super_block *sb);\nstatic int ext4_freeze(struct super_block *sb);\nstatic inline int ext2_feature_set_ok(struct super_block *sb);\nstatic inline int ext3_feature_set_ok(struct super_block *sb);\nstatic void ext4_unregister_li_request(struct super_block *sb);\n\nvoid __ext4_msg(struct super_block *sb,\n\t\tconst char *prefix, const char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tif (!___ratelimit(&(EXT4_SB(sb)->s_msg_ratelimit_state), \"EXT4-fs\"))\n\t\treturn;\n\n\tva_start(args, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\tprintk(\"%sEXT4-fs (%s): %pV\\n\", prefix, sb->s_id, &vaf);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "le16_to_cpu",
          "args": [
            "gdp->bg_checksum"
          ],
          "line": 2116
        },
        "resolved": true,
        "details": {
          "function_name": "sle16_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "48-51",
          "snippet": "static inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_group_desc_csum",
          "args": [
            "sbi",
            "i",
            "gdp"
          ],
          "line": 2115
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_group_desc_csum_set",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/super.c",
          "lines": "2050-2056",
          "snippet": "void ext4_group_desc_csum_set(struct super_block *sb, __u32 block_group,\n\t\t\t      struct ext4_group_desc *gdp)\n{\n\tif (!ext4_has_group_desc_csum(sb))\n\t\treturn;\n\tgdp->bg_checksum = ext4_group_desc_csum(EXT4_SB(sb), block_group, gdp);\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"mballoc.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include \"ext4_extents.h\"\t/* Needed for trace points definition */",
            "#include \"ext4.h\"",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/crc16.h>",
            "#include <linux/log2.h>",
            "#include <linux/ctype.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/random.h>",
            "#include <linux/vfs.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/parser.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/time.h>",
            "#include <linux/fs.h>",
            "#include <linux/string.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ext4_unfreeze(struct super_block *sb);",
            "static int ext4_freeze(struct super_block *sb);",
            "static inline int ext2_feature_set_ok(struct super_block *sb);",
            "static inline int ext3_feature_set_ok(struct super_block *sb);",
            "static void ext4_unregister_li_request(struct super_block *sb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"mballoc.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4_extents.h\"\t/* Needed for trace points definition */\n#include \"ext4.h\"\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <asm/uaccess.h>\n#include <linux/cleancache.h>\n#include <linux/crc16.h>\n#include <linux/log2.h>\n#include <linux/ctype.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/random.h>\n#include <linux/vfs.h>\n#include <linux/exportfs.h>\n#include <linux/buffer_head.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/jbd2.h>\n#include <linux/vmalloc.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n#include <linux/string.h>\n#include <linux/module.h>\n\nstatic int ext4_unfreeze(struct super_block *sb);\nstatic int ext4_freeze(struct super_block *sb);\nstatic inline int ext2_feature_set_ok(struct super_block *sb);\nstatic inline int ext3_feature_set_ok(struct super_block *sb);\nstatic void ext4_unregister_li_request(struct super_block *sb);\n\nvoid ext4_group_desc_csum_set(struct super_block *sb, __u32 block_group,\n\t\t\t      struct ext4_group_desc *gdp)\n{\n\tif (!ext4_has_group_desc_csum(sb))\n\t\treturn;\n\tgdp->bg_checksum = ext4_group_desc_csum(EXT4_SB(sb), block_group, gdp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_group_desc_csum_verify",
          "args": [
            "sb",
            "i",
            "gdp"
          ],
          "line": 2112
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_group_desc_csum_verify",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/super.c",
          "lines": "2039-2048",
          "snippet": "int ext4_group_desc_csum_verify(struct super_block *sb, __u32 block_group,\n\t\t\t\tstruct ext4_group_desc *gdp)\n{\n\tif (ext4_has_group_desc_csum(sb) &&\n\t    (gdp->bg_checksum != ext4_group_desc_csum(EXT4_SB(sb),\n\t\t\t\t\t\t      block_group, gdp)))\n\t\treturn 0;\n\n\treturn 1;\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"mballoc.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include \"ext4_extents.h\"\t/* Needed for trace points definition */",
            "#include \"ext4.h\"",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/crc16.h>",
            "#include <linux/log2.h>",
            "#include <linux/ctype.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/random.h>",
            "#include <linux/vfs.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/parser.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/time.h>",
            "#include <linux/fs.h>",
            "#include <linux/string.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ext4_unfreeze(struct super_block *sb);",
            "static int ext4_freeze(struct super_block *sb);",
            "static inline int ext2_feature_set_ok(struct super_block *sb);",
            "static inline int ext3_feature_set_ok(struct super_block *sb);",
            "static void ext4_unregister_li_request(struct super_block *sb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"mballoc.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4_extents.h\"\t/* Needed for trace points definition */\n#include \"ext4.h\"\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <asm/uaccess.h>\n#include <linux/cleancache.h>\n#include <linux/crc16.h>\n#include <linux/log2.h>\n#include <linux/ctype.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/random.h>\n#include <linux/vfs.h>\n#include <linux/exportfs.h>\n#include <linux/buffer_head.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/jbd2.h>\n#include <linux/vmalloc.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n#include <linux/string.h>\n#include <linux/module.h>\n\nstatic int ext4_unfreeze(struct super_block *sb);\nstatic int ext4_freeze(struct super_block *sb);\nstatic inline int ext2_feature_set_ok(struct super_block *sb);\nstatic inline int ext3_feature_set_ok(struct super_block *sb);\nstatic void ext4_unregister_li_request(struct super_block *sb);\n\nint ext4_group_desc_csum_verify(struct super_block *sb, __u32 block_group,\n\t\t\t\tstruct ext4_group_desc *gdp)\n{\n\tif (ext4_has_group_desc_csum(sb) &&\n\t    (gdp->bg_checksum != ext4_group_desc_csum(EXT4_SB(sb),\n\t\t\t\t\t\t      block_group, gdp)))\n\t\treturn 0;\n\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_lock_group",
          "args": [
            "sb",
            "i"
          ],
          "line": 2111
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_lock_group",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ext4.h",
          "lines": "2547-2565",
          "snippet": "static inline void ext4_lock_group(struct super_block *sb, ext4_group_t group)\n{\n\tspinlock_t *lock = ext4_group_lock_ptr(sb, group);\n\tif (spin_trylock(lock))\n\t\t/*\n\t\t * We're able to grab the lock right away, so drop the\n\t\t * lock contention counter.\n\t\t */\n\t\tatomic_add_unless(&EXT4_SB(sb)->s_lock_busy, -1, 0);\n\telse {\n\t\t/*\n\t\t * The lock is busy, so bump the contention counter,\n\t\t * and then wait on the spin lock.\n\t\t */\n\t\tatomic_add_unless(&EXT4_SB(sb)->s_lock_busy, 1,\n\t\t\t\t  EXT4_MAX_CONTENTION);\n\t\tspin_lock(lock);\n\t}\n}",
          "includes": [
            "#include \"extents_status.h\"",
            "#include <linux/compat.h>",
            "#include <linux/falloc.h>",
            "#include <crypto/hash.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/wait.h>",
            "#include <linux/timer.h>",
            "#include <linux/mutex.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/quota.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extents_status.h\"\n#include <linux/compat.h>\n#include <linux/falloc.h>\n#include <crypto/hash.h>\n#include <linux/ratelimit.h>\n#include <linux/percpu_counter.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/wait.h>\n#include <linux/timer.h>\n#include <linux/mutex.h>\n#include <linux/seqlock.h>\n#include <linux/rbtree.h>\n#include <linux/rwsem.h>\n#include <linux/quota.h>\n#include <linux/jbd2.h>\n#include <linux/magic.h>\n#include <linux/blkdev.h>\n#include <linux/types.h>\n\nstatic inline void ext4_lock_group(struct super_block *sb, ext4_group_t group)\n{\n\tspinlock_t *lock = ext4_group_lock_ptr(sb, group);\n\tif (spin_trylock(lock))\n\t\t/*\n\t\t * We're able to grab the lock right away, so drop the\n\t\t * lock contention counter.\n\t\t */\n\t\tatomic_add_unless(&EXT4_SB(sb)->s_lock_busy, -1, 0);\n\telse {\n\t\t/*\n\t\t * The lock is busy, so bump the contention counter,\n\t\t * and then wait on the spin lock.\n\t\t */\n\t\tatomic_add_unless(&EXT4_SB(sb)->s_lock_busy, 1,\n\t\t\t\t  EXT4_MAX_CONTENTION);\n\t\tspin_lock(lock);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_inode_table",
          "args": [
            "sb",
            "gdp"
          ],
          "line": 2103
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_inode_table",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/super.c",
          "lines": "195-201",
          "snippet": "ext4_fsblk_t ext4_inode_table(struct super_block *sb,\n\t\t\t      struct ext4_group_desc *bg)\n{\n\treturn le32_to_cpu(bg->bg_inode_table_lo) |\n\t\t(EXT4_DESC_SIZE(sb) >= EXT4_MIN_DESC_SIZE_64BIT ?\n\t\t (ext4_fsblk_t)le32_to_cpu(bg->bg_inode_table_hi) << 32 : 0);\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"mballoc.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include \"ext4_extents.h\"\t/* Needed for trace points definition */",
            "#include \"ext4.h\"",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/crc16.h>",
            "#include <linux/log2.h>",
            "#include <linux/ctype.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/random.h>",
            "#include <linux/vfs.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/parser.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/time.h>",
            "#include <linux/fs.h>",
            "#include <linux/string.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ext4_unfreeze(struct super_block *sb);",
            "static int ext4_freeze(struct super_block *sb);",
            "static inline int ext2_feature_set_ok(struct super_block *sb);",
            "static inline int ext3_feature_set_ok(struct super_block *sb);",
            "static void ext4_unregister_li_request(struct super_block *sb);",
            "static int ext4_reserve_clusters(struct ext4_sb_info *, ext4_fsblk_t);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"mballoc.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4_extents.h\"\t/* Needed for trace points definition */\n#include \"ext4.h\"\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <asm/uaccess.h>\n#include <linux/cleancache.h>\n#include <linux/crc16.h>\n#include <linux/log2.h>\n#include <linux/ctype.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/random.h>\n#include <linux/vfs.h>\n#include <linux/exportfs.h>\n#include <linux/buffer_head.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/jbd2.h>\n#include <linux/vmalloc.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n#include <linux/string.h>\n#include <linux/module.h>\n\nstatic int ext4_unfreeze(struct super_block *sb);\nstatic int ext4_freeze(struct super_block *sb);\nstatic inline int ext2_feature_set_ok(struct super_block *sb);\nstatic inline int ext3_feature_set_ok(struct super_block *sb);\nstatic void ext4_unregister_li_request(struct super_block *sb);\nstatic int ext4_reserve_clusters(struct ext4_sb_info *, ext4_fsblk_t);\n\next4_fsblk_t ext4_inode_table(struct super_block *sb,\n\t\t\t      struct ext4_group_desc *bg)\n{\n\treturn le32_to_cpu(bg->bg_inode_table_lo) |\n\t\t(EXT4_DESC_SIZE(sb) >= EXT4_MIN_DESC_SIZE_64BIT ?\n\t\t (ext4_fsblk_t)le32_to_cpu(bg->bg_inode_table_hi) << 32 : 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_inode_bitmap",
          "args": [
            "sb",
            "gdp"
          ],
          "line": 2096
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_inode_bitmap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/super.c",
          "lines": "187-193",
          "snippet": "ext4_fsblk_t ext4_inode_bitmap(struct super_block *sb,\n\t\t\t       struct ext4_group_desc *bg)\n{\n\treturn le32_to_cpu(bg->bg_inode_bitmap_lo) |\n\t\t(EXT4_DESC_SIZE(sb) >= EXT4_MIN_DESC_SIZE_64BIT ?\n\t\t (ext4_fsblk_t)le32_to_cpu(bg->bg_inode_bitmap_hi) << 32 : 0);\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"mballoc.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include \"ext4_extents.h\"\t/* Needed for trace points definition */",
            "#include \"ext4.h\"",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/crc16.h>",
            "#include <linux/log2.h>",
            "#include <linux/ctype.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/random.h>",
            "#include <linux/vfs.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/parser.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/time.h>",
            "#include <linux/fs.h>",
            "#include <linux/string.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ext4_unfreeze(struct super_block *sb);",
            "static int ext4_freeze(struct super_block *sb);",
            "static inline int ext2_feature_set_ok(struct super_block *sb);",
            "static inline int ext3_feature_set_ok(struct super_block *sb);",
            "static void ext4_unregister_li_request(struct super_block *sb);",
            "static int ext4_reserve_clusters(struct ext4_sb_info *, ext4_fsblk_t);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"mballoc.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4_extents.h\"\t/* Needed for trace points definition */\n#include \"ext4.h\"\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <asm/uaccess.h>\n#include <linux/cleancache.h>\n#include <linux/crc16.h>\n#include <linux/log2.h>\n#include <linux/ctype.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/random.h>\n#include <linux/vfs.h>\n#include <linux/exportfs.h>\n#include <linux/buffer_head.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/jbd2.h>\n#include <linux/vmalloc.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n#include <linux/string.h>\n#include <linux/module.h>\n\nstatic int ext4_unfreeze(struct super_block *sb);\nstatic int ext4_freeze(struct super_block *sb);\nstatic inline int ext2_feature_set_ok(struct super_block *sb);\nstatic inline int ext3_feature_set_ok(struct super_block *sb);\nstatic void ext4_unregister_li_request(struct super_block *sb);\nstatic int ext4_reserve_clusters(struct ext4_sb_info *, ext4_fsblk_t);\n\next4_fsblk_t ext4_inode_bitmap(struct super_block *sb,\n\t\t\t       struct ext4_group_desc *bg)\n{\n\treturn le32_to_cpu(bg->bg_inode_bitmap_lo) |\n\t\t(EXT4_DESC_SIZE(sb) >= EXT4_MIN_DESC_SIZE_64BIT ?\n\t\t (ext4_fsblk_t)le32_to_cpu(bg->bg_inode_bitmap_hi) << 32 : 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_block_bitmap",
          "args": [
            "sb",
            "gdp"
          ],
          "line": 2089
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_block_bitmap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/super.c",
          "lines": "179-185",
          "snippet": "ext4_fsblk_t ext4_block_bitmap(struct super_block *sb,\n\t\t\t       struct ext4_group_desc *bg)\n{\n\treturn le32_to_cpu(bg->bg_block_bitmap_lo) |\n\t\t(EXT4_DESC_SIZE(sb) >= EXT4_MIN_DESC_SIZE_64BIT ?\n\t\t (ext4_fsblk_t)le32_to_cpu(bg->bg_block_bitmap_hi) << 32 : 0);\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"mballoc.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include \"ext4_extents.h\"\t/* Needed for trace points definition */",
            "#include \"ext4.h\"",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/crc16.h>",
            "#include <linux/log2.h>",
            "#include <linux/ctype.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/random.h>",
            "#include <linux/vfs.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/parser.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/time.h>",
            "#include <linux/fs.h>",
            "#include <linux/string.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ext4_unfreeze(struct super_block *sb);",
            "static int ext4_freeze(struct super_block *sb);",
            "static inline int ext2_feature_set_ok(struct super_block *sb);",
            "static inline int ext3_feature_set_ok(struct super_block *sb);",
            "static void ext4_unregister_li_request(struct super_block *sb);",
            "static int ext4_reserve_clusters(struct ext4_sb_info *, ext4_fsblk_t);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"mballoc.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4_extents.h\"\t/* Needed for trace points definition */\n#include \"ext4.h\"\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <asm/uaccess.h>\n#include <linux/cleancache.h>\n#include <linux/crc16.h>\n#include <linux/log2.h>\n#include <linux/ctype.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/random.h>\n#include <linux/vfs.h>\n#include <linux/exportfs.h>\n#include <linux/buffer_head.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/jbd2.h>\n#include <linux/vmalloc.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n#include <linux/string.h>\n#include <linux/module.h>\n\nstatic int ext4_unfreeze(struct super_block *sb);\nstatic int ext4_freeze(struct super_block *sb);\nstatic inline int ext2_feature_set_ok(struct super_block *sb);\nstatic inline int ext3_feature_set_ok(struct super_block *sb);\nstatic void ext4_unregister_li_request(struct super_block *sb);\nstatic int ext4_reserve_clusters(struct ext4_sb_info *, ext4_fsblk_t);\n\next4_fsblk_t ext4_block_bitmap(struct super_block *sb,\n\t\t\t       struct ext4_group_desc *bg)\n{\n\treturn le32_to_cpu(bg->bg_block_bitmap_lo) |\n\t\t(EXT4_DESC_SIZE(sb) >= EXT4_MIN_DESC_SIZE_64BIT ?\n\t\t (ext4_fsblk_t)le32_to_cpu(bg->bg_block_bitmap_hi) << 32 : 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "EXT4_BG_INODE_ZEROED"
          ],
          "line": 2086
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXT4_BLOCKS_PER_GROUP",
          "args": [
            "sb"
          ],
          "line": 2083
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_blocks_count",
          "args": [
            "sbi->s_es"
          ],
          "line": 2080
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_get_group_desc",
          "args": [
            "sb",
            "i",
            "NULL"
          ],
          "line": 2077
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_get_group_desc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/balloc.c",
          "lines": "277-309",
          "snippet": "struct ext4_group_desc * ext4_get_group_desc(struct super_block *sb,\n\t\t\t\t\t     ext4_group_t block_group,\n\t\t\t\t\t     struct buffer_head **bh)\n{\n\tunsigned int group_desc;\n\tunsigned int offset;\n\text4_group_t ngroups = ext4_get_groups_count(sb);\n\tstruct ext4_group_desc *desc;\n\tstruct ext4_sb_info *sbi = EXT4_SB(sb);\n\n\tif (block_group >= ngroups) {\n\t\text4_error(sb, \"block_group >= groups_count - block_group = %u,\"\n\t\t\t   \" groups_count = %u\", block_group, ngroups);\n\n\t\treturn NULL;\n\t}\n\n\tgroup_desc = block_group >> EXT4_DESC_PER_BLOCK_BITS(sb);\n\toffset = block_group & (EXT4_DESC_PER_BLOCK(sb) - 1);\n\tif (!sbi->s_group_desc[group_desc]) {\n\t\text4_error(sb, \"Group descriptor not loaded - \"\n\t\t\t   \"block_group = %u, group_desc = %u, desc = %u\",\n\t\t\t   block_group, group_desc, offset);\n\t\treturn NULL;\n\t}\n\n\tdesc = (struct ext4_group_desc *)(\n\t\t(__u8 *)sbi->s_group_desc[group_desc]->b_data +\n\t\toffset * EXT4_DESC_SIZE(sb));\n\tif (bh)\n\t\t*bh = sbi->s_group_desc[group_desc];\n\treturn desc;\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"mballoc.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include \"ext4.h\"",
            "#include <linux/buffer_head.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/fs.h>",
            "#include <linux/capability.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static unsigned ext4_num_base_meta_clusters(struct super_block *sb,\n\t\t\t\t\t    ext4_group_t block_group);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"mballoc.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4.h\"\n#include <linux/buffer_head.h>\n#include <linux/quotaops.h>\n#include <linux/jbd2.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n#include <linux/time.h>\n\nstatic unsigned ext4_num_base_meta_clusters(struct super_block *sb,\n\t\t\t\t\t    ext4_group_t block_group);\n\nstruct ext4_group_desc * ext4_get_group_desc(struct super_block *sb,\n\t\t\t\t\t     ext4_group_t block_group,\n\t\t\t\t\t     struct buffer_head **bh)\n{\n\tunsigned int group_desc;\n\tunsigned int offset;\n\text4_group_t ngroups = ext4_get_groups_count(sb);\n\tstruct ext4_group_desc *desc;\n\tstruct ext4_sb_info *sbi = EXT4_SB(sb);\n\n\tif (block_group >= ngroups) {\n\t\text4_error(sb, \"block_group >= groups_count - block_group = %u,\"\n\t\t\t   \" groups_count = %u\", block_group, ngroups);\n\n\t\treturn NULL;\n\t}\n\n\tgroup_desc = block_group >> EXT4_DESC_PER_BLOCK_BITS(sb);\n\toffset = block_group & (EXT4_DESC_PER_BLOCK(sb) - 1);\n\tif (!sbi->s_group_desc[group_desc]) {\n\t\text4_error(sb, \"Group descriptor not loaded - \"\n\t\t\t   \"block_group = %u, group_desc = %u, desc = %u\",\n\t\t\t   block_group, group_desc, offset);\n\t\treturn NULL;\n\t}\n\n\tdesc = (struct ext4_group_desc *)(\n\t\t(__u8 *)sbi->s_group_desc[group_desc]->b_data +\n\t\toffset * EXT4_DESC_SIZE(sb));\n\tif (bh)\n\t\t*bh = sbi->s_group_desc[group_desc];\n\treturn desc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_debug",
          "args": [
            "\"Checking group descriptors\""
          ],
          "line": 2074
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXT4_HAS_INCOMPAT_FEATURE",
          "args": [
            "sb",
            "EXT4_FEATURE_INCOMPAT_FLEX_BG"
          ],
          "line": 2071
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "sbi->s_es->s_first_data_block"
          ],
          "line": 2063
        },
        "resolved": true,
        "details": {
          "function_name": "sle32_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "53-56",
          "snippet": "static inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "EXT4_SB",
          "args": [
            "sb"
          ],
          "line": 2062
        },
        "resolved": true,
        "details": {
          "function_name": "EXT4_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ext4.h",
          "lines": "1356-1359",
          "snippet": "static inline struct ext4_sb_info *EXT4_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include \"extents_status.h\"",
            "#include <linux/compat.h>",
            "#include <linux/falloc.h>",
            "#include <crypto/hash.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/wait.h>",
            "#include <linux/timer.h>",
            "#include <linux/mutex.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/quota.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extents_status.h\"\n#include <linux/compat.h>\n#include <linux/falloc.h>\n#include <crypto/hash.h>\n#include <linux/ratelimit.h>\n#include <linux/percpu_counter.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/wait.h>\n#include <linux/timer.h>\n#include <linux/mutex.h>\n#include <linux/seqlock.h>\n#include <linux/rbtree.h>\n#include <linux/rwsem.h>\n#include <linux/quota.h>\n#include <linux/jbd2.h>\n#include <linux/magic.h>\n#include <linux/blkdev.h>\n#include <linux/types.h>\n\nstatic inline struct ext4_sb_info *EXT4_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"mballoc.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4_extents.h\"\t/* Needed for trace points definition */\n#include \"ext4.h\"\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <asm/uaccess.h>\n#include <linux/cleancache.h>\n#include <linux/crc16.h>\n#include <linux/log2.h>\n#include <linux/ctype.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/random.h>\n#include <linux/vfs.h>\n#include <linux/exportfs.h>\n#include <linux/buffer_head.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/jbd2.h>\n#include <linux/vmalloc.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n#include <linux/string.h>\n#include <linux/module.h>\n\nstatic int ext4_unfreeze(struct super_block *sb);\nstatic int ext4_freeze(struct super_block *sb);\nstatic inline int ext2_feature_set_ok(struct super_block *sb);\nstatic inline int ext3_feature_set_ok(struct super_block *sb);\nstatic void ext4_unregister_li_request(struct super_block *sb);\nstatic int ext4_reserve_clusters(struct ext4_sb_info *, ext4_fsblk_t);\n\nstatic int ext4_check_descriptors(struct super_block *sb,\n\t\t\t\t  ext4_group_t *first_not_zeroed)\n{\n\tstruct ext4_sb_info *sbi = EXT4_SB(sb);\n\text4_fsblk_t first_block = le32_to_cpu(sbi->s_es->s_first_data_block);\n\text4_fsblk_t last_block;\n\text4_fsblk_t block_bitmap;\n\text4_fsblk_t inode_bitmap;\n\text4_fsblk_t inode_table;\n\tint flexbg_flag = 0;\n\text4_group_t i, grp = sbi->s_groups_count;\n\n\tif (EXT4_HAS_INCOMPAT_FEATURE(sb, EXT4_FEATURE_INCOMPAT_FLEX_BG))\n\t\tflexbg_flag = 1;\n\n\text4_debug(\"Checking group descriptors\");\n\n\tfor (i = 0; i < sbi->s_groups_count; i++) {\n\t\tstruct ext4_group_desc *gdp = ext4_get_group_desc(sb, i, NULL);\n\n\t\tif (i == sbi->s_groups_count - 1 || flexbg_flag)\n\t\t\tlast_block = ext4_blocks_count(sbi->s_es) - 1;\n\t\telse\n\t\t\tlast_block = first_block +\n\t\t\t\t(EXT4_BLOCKS_PER_GROUP(sb) - 1);\n\n\t\tif ((grp == sbi->s_groups_count) &&\n\t\t   !(gdp->bg_flags & cpu_to_le16(EXT4_BG_INODE_ZEROED)))\n\t\t\tgrp = i;\n\n\t\tblock_bitmap = ext4_block_bitmap(sb, gdp);\n\t\tif (block_bitmap < first_block || block_bitmap > last_block) {\n\t\t\text4_msg(sb, KERN_ERR, \"ext4_check_descriptors: \"\n\t\t\t       \"Block bitmap for group %u not in group \"\n\t\t\t       \"(block %llu)!\", i, block_bitmap);\n\t\t\treturn 0;\n\t\t}\n\t\tinode_bitmap = ext4_inode_bitmap(sb, gdp);\n\t\tif (inode_bitmap < first_block || inode_bitmap > last_block) {\n\t\t\text4_msg(sb, KERN_ERR, \"ext4_check_descriptors: \"\n\t\t\t       \"Inode bitmap for group %u not in group \"\n\t\t\t       \"(block %llu)!\", i, inode_bitmap);\n\t\t\treturn 0;\n\t\t}\n\t\tinode_table = ext4_inode_table(sb, gdp);\n\t\tif (inode_table < first_block ||\n\t\t    inode_table + sbi->s_itb_per_group - 1 > last_block) {\n\t\t\text4_msg(sb, KERN_ERR, \"ext4_check_descriptors: \"\n\t\t\t       \"Inode table for group %u not in group \"\n\t\t\t       \"(block %llu)!\", i, inode_table);\n\t\t\treturn 0;\n\t\t}\n\t\text4_lock_group(sb, i);\n\t\tif (!ext4_group_desc_csum_verify(sb, i, gdp)) {\n\t\t\text4_msg(sb, KERN_ERR, \"ext4_check_descriptors: \"\n\t\t\t\t \"Checksum for group %u failed (%u!=%u)\",\n\t\t\t\t i, le16_to_cpu(ext4_group_desc_csum(sbi, i,\n\t\t\t\t     gdp)), le16_to_cpu(gdp->bg_checksum));\n\t\t\tif (!(sb->s_flags & MS_RDONLY)) {\n\t\t\t\text4_unlock_group(sb, i);\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\t\text4_unlock_group(sb, i);\n\t\tif (!flexbg_flag)\n\t\t\tfirst_block += EXT4_BLOCKS_PER_GROUP(sb);\n\t}\n\tif (NULL != first_not_zeroed)\n\t\t*first_not_zeroed = grp;\n\treturn 1;\n}"
  },
  {
    "function_name": "ext4_group_desc_csum_set",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/super.c",
    "lines": "2050-2056",
    "snippet": "void ext4_group_desc_csum_set(struct super_block *sb, __u32 block_group,\n\t\t\t      struct ext4_group_desc *gdp)\n{\n\tif (!ext4_has_group_desc_csum(sb))\n\t\treturn;\n\tgdp->bg_checksum = ext4_group_desc_csum(EXT4_SB(sb), block_group, gdp);\n}",
    "includes": [
      "#include <trace/events/ext4.h>",
      "#include \"mballoc.h\"",
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"ext4_jbd2.h\"",
      "#include \"ext4_extents.h\"\t/* Needed for trace points definition */",
      "#include \"ext4.h\"",
      "#include <linux/freezer.h>",
      "#include <linux/kthread.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/cleancache.h>",
      "#include <linux/crc16.h>",
      "#include <linux/log2.h>",
      "#include <linux/ctype.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/namei.h>",
      "#include <linux/mount.h>",
      "#include <linux/random.h>",
      "#include <linux/vfs.h>",
      "#include <linux/exportfs.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/parser.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/init.h>",
      "#include <linux/slab.h>",
      "#include <linux/jbd2.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/time.h>",
      "#include <linux/fs.h>",
      "#include <linux/string.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ext4_unfreeze(struct super_block *sb);",
      "static int ext4_freeze(struct super_block *sb);",
      "static inline int ext2_feature_set_ok(struct super_block *sb);",
      "static inline int ext3_feature_set_ok(struct super_block *sb);",
      "static void ext4_unregister_li_request(struct super_block *sb);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ext4_group_desc_csum",
          "args": [
            "EXT4_SB(sb)",
            "block_group",
            "gdp"
          ],
          "line": 2055
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_group_desc_csum_set",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/super.c",
          "lines": "2050-2056",
          "snippet": "void ext4_group_desc_csum_set(struct super_block *sb, __u32 block_group,\n\t\t\t      struct ext4_group_desc *gdp)\n{\n\tif (!ext4_has_group_desc_csum(sb))\n\t\treturn;\n\tgdp->bg_checksum = ext4_group_desc_csum(EXT4_SB(sb), block_group, gdp);\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "EXT4_SB",
          "args": [
            "sb"
          ],
          "line": 2055
        },
        "resolved": true,
        "details": {
          "function_name": "EXT4_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ext4.h",
          "lines": "1356-1359",
          "snippet": "static inline struct ext4_sb_info *EXT4_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include \"extents_status.h\"",
            "#include <linux/compat.h>",
            "#include <linux/falloc.h>",
            "#include <crypto/hash.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/wait.h>",
            "#include <linux/timer.h>",
            "#include <linux/mutex.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/quota.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extents_status.h\"\n#include <linux/compat.h>\n#include <linux/falloc.h>\n#include <crypto/hash.h>\n#include <linux/ratelimit.h>\n#include <linux/percpu_counter.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/wait.h>\n#include <linux/timer.h>\n#include <linux/mutex.h>\n#include <linux/seqlock.h>\n#include <linux/rbtree.h>\n#include <linux/rwsem.h>\n#include <linux/quota.h>\n#include <linux/jbd2.h>\n#include <linux/magic.h>\n#include <linux/blkdev.h>\n#include <linux/types.h>\n\nstatic inline struct ext4_sb_info *EXT4_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_has_group_desc_csum",
          "args": [
            "sb"
          ],
          "line": 2053
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"mballoc.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4_extents.h\"\t/* Needed for trace points definition */\n#include \"ext4.h\"\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <asm/uaccess.h>\n#include <linux/cleancache.h>\n#include <linux/crc16.h>\n#include <linux/log2.h>\n#include <linux/ctype.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/random.h>\n#include <linux/vfs.h>\n#include <linux/exportfs.h>\n#include <linux/buffer_head.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/jbd2.h>\n#include <linux/vmalloc.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n#include <linux/string.h>\n#include <linux/module.h>\n\nstatic int ext4_unfreeze(struct super_block *sb);\nstatic int ext4_freeze(struct super_block *sb);\nstatic inline int ext2_feature_set_ok(struct super_block *sb);\nstatic inline int ext3_feature_set_ok(struct super_block *sb);\nstatic void ext4_unregister_li_request(struct super_block *sb);\n\nvoid ext4_group_desc_csum_set(struct super_block *sb, __u32 block_group,\n\t\t\t      struct ext4_group_desc *gdp)\n{\n\tif (!ext4_has_group_desc_csum(sb))\n\t\treturn;\n\tgdp->bg_checksum = ext4_group_desc_csum(EXT4_SB(sb), block_group, gdp);\n}"
  },
  {
    "function_name": "ext4_group_desc_csum_verify",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/super.c",
    "lines": "2039-2048",
    "snippet": "int ext4_group_desc_csum_verify(struct super_block *sb, __u32 block_group,\n\t\t\t\tstruct ext4_group_desc *gdp)\n{\n\tif (ext4_has_group_desc_csum(sb) &&\n\t    (gdp->bg_checksum != ext4_group_desc_csum(EXT4_SB(sb),\n\t\t\t\t\t\t      block_group, gdp)))\n\t\treturn 0;\n\n\treturn 1;\n}",
    "includes": [
      "#include <trace/events/ext4.h>",
      "#include \"mballoc.h\"",
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"ext4_jbd2.h\"",
      "#include \"ext4_extents.h\"\t/* Needed for trace points definition */",
      "#include \"ext4.h\"",
      "#include <linux/freezer.h>",
      "#include <linux/kthread.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/cleancache.h>",
      "#include <linux/crc16.h>",
      "#include <linux/log2.h>",
      "#include <linux/ctype.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/namei.h>",
      "#include <linux/mount.h>",
      "#include <linux/random.h>",
      "#include <linux/vfs.h>",
      "#include <linux/exportfs.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/parser.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/init.h>",
      "#include <linux/slab.h>",
      "#include <linux/jbd2.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/time.h>",
      "#include <linux/fs.h>",
      "#include <linux/string.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ext4_unfreeze(struct super_block *sb);",
      "static int ext4_freeze(struct super_block *sb);",
      "static inline int ext2_feature_set_ok(struct super_block *sb);",
      "static inline int ext3_feature_set_ok(struct super_block *sb);",
      "static void ext4_unregister_li_request(struct super_block *sb);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ext4_group_desc_csum",
          "args": [
            "EXT4_SB(sb)",
            "block_group",
            "gdp"
          ],
          "line": 2043
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_group_desc_csum_set",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/super.c",
          "lines": "2050-2056",
          "snippet": "void ext4_group_desc_csum_set(struct super_block *sb, __u32 block_group,\n\t\t\t      struct ext4_group_desc *gdp)\n{\n\tif (!ext4_has_group_desc_csum(sb))\n\t\treturn;\n\tgdp->bg_checksum = ext4_group_desc_csum(EXT4_SB(sb), block_group, gdp);\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"mballoc.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include \"ext4_extents.h\"\t/* Needed for trace points definition */",
            "#include \"ext4.h\"",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/crc16.h>",
            "#include <linux/log2.h>",
            "#include <linux/ctype.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/random.h>",
            "#include <linux/vfs.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/parser.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/time.h>",
            "#include <linux/fs.h>",
            "#include <linux/string.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ext4_unfreeze(struct super_block *sb);",
            "static int ext4_freeze(struct super_block *sb);",
            "static inline int ext2_feature_set_ok(struct super_block *sb);",
            "static inline int ext3_feature_set_ok(struct super_block *sb);",
            "static void ext4_unregister_li_request(struct super_block *sb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"mballoc.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4_extents.h\"\t/* Needed for trace points definition */\n#include \"ext4.h\"\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <asm/uaccess.h>\n#include <linux/cleancache.h>\n#include <linux/crc16.h>\n#include <linux/log2.h>\n#include <linux/ctype.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/random.h>\n#include <linux/vfs.h>\n#include <linux/exportfs.h>\n#include <linux/buffer_head.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/jbd2.h>\n#include <linux/vmalloc.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n#include <linux/string.h>\n#include <linux/module.h>\n\nstatic int ext4_unfreeze(struct super_block *sb);\nstatic int ext4_freeze(struct super_block *sb);\nstatic inline int ext2_feature_set_ok(struct super_block *sb);\nstatic inline int ext3_feature_set_ok(struct super_block *sb);\nstatic void ext4_unregister_li_request(struct super_block *sb);\n\nvoid ext4_group_desc_csum_set(struct super_block *sb, __u32 block_group,\n\t\t\t      struct ext4_group_desc *gdp)\n{\n\tif (!ext4_has_group_desc_csum(sb))\n\t\treturn;\n\tgdp->bg_checksum = ext4_group_desc_csum(EXT4_SB(sb), block_group, gdp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "EXT4_SB",
          "args": [
            "sb"
          ],
          "line": 2043
        },
        "resolved": true,
        "details": {
          "function_name": "EXT4_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ext4.h",
          "lines": "1356-1359",
          "snippet": "static inline struct ext4_sb_info *EXT4_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include \"extents_status.h\"",
            "#include <linux/compat.h>",
            "#include <linux/falloc.h>",
            "#include <crypto/hash.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/wait.h>",
            "#include <linux/timer.h>",
            "#include <linux/mutex.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/quota.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extents_status.h\"\n#include <linux/compat.h>\n#include <linux/falloc.h>\n#include <crypto/hash.h>\n#include <linux/ratelimit.h>\n#include <linux/percpu_counter.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/wait.h>\n#include <linux/timer.h>\n#include <linux/mutex.h>\n#include <linux/seqlock.h>\n#include <linux/rbtree.h>\n#include <linux/rwsem.h>\n#include <linux/quota.h>\n#include <linux/jbd2.h>\n#include <linux/magic.h>\n#include <linux/blkdev.h>\n#include <linux/types.h>\n\nstatic inline struct ext4_sb_info *EXT4_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_has_group_desc_csum",
          "args": [
            "sb"
          ],
          "line": 2042
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"mballoc.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4_extents.h\"\t/* Needed for trace points definition */\n#include \"ext4.h\"\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <asm/uaccess.h>\n#include <linux/cleancache.h>\n#include <linux/crc16.h>\n#include <linux/log2.h>\n#include <linux/ctype.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/random.h>\n#include <linux/vfs.h>\n#include <linux/exportfs.h>\n#include <linux/buffer_head.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/jbd2.h>\n#include <linux/vmalloc.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n#include <linux/string.h>\n#include <linux/module.h>\n\nstatic int ext4_unfreeze(struct super_block *sb);\nstatic int ext4_freeze(struct super_block *sb);\nstatic inline int ext2_feature_set_ok(struct super_block *sb);\nstatic inline int ext3_feature_set_ok(struct super_block *sb);\nstatic void ext4_unregister_li_request(struct super_block *sb);\n\nint ext4_group_desc_csum_verify(struct super_block *sb, __u32 block_group,\n\t\t\t\tstruct ext4_group_desc *gdp)\n{\n\tif (ext4_has_group_desc_csum(sb) &&\n\t    (gdp->bg_checksum != ext4_group_desc_csum(EXT4_SB(sb),\n\t\t\t\t\t\t      block_group, gdp)))\n\t\treturn 0;\n\n\treturn 1;\n}"
  },
  {
    "function_name": "ext4_group_desc_csum",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/super.c",
    "lines": "1992-2037",
    "snippet": "static __le16 ext4_group_desc_csum(struct ext4_sb_info *sbi, __u32 block_group,\n\t\t\t\t   struct ext4_group_desc *gdp)\n{\n\tint offset;\n\t__u16 crc = 0;\n\t__le32 le_group = cpu_to_le32(block_group);\n\n\tif (ext4_has_metadata_csum(sbi->s_sb)) {\n\t\t/* Use new metadata_csum algorithm */\n\t\t__le16 save_csum;\n\t\t__u32 csum32;\n\n\t\tsave_csum = gdp->bg_checksum;\n\t\tgdp->bg_checksum = 0;\n\t\tcsum32 = ext4_chksum(sbi, sbi->s_csum_seed, (__u8 *)&le_group,\n\t\t\t\t     sizeof(le_group));\n\t\tcsum32 = ext4_chksum(sbi, csum32, (__u8 *)gdp,\n\t\t\t\t     sbi->s_desc_size);\n\t\tgdp->bg_checksum = save_csum;\n\n\t\tcrc = csum32 & 0xFFFF;\n\t\tgoto out;\n\t}\n\n\t/* old crc16 code */\n\tif (!(sbi->s_es->s_feature_ro_compat &\n\t      cpu_to_le32(EXT4_FEATURE_RO_COMPAT_GDT_CSUM)))\n\t\treturn 0;\n\n\toffset = offsetof(struct ext4_group_desc, bg_checksum);\n\n\tcrc = crc16(~0, sbi->s_es->s_uuid, sizeof(sbi->s_es->s_uuid));\n\tcrc = crc16(crc, (__u8 *)&le_group, sizeof(le_group));\n\tcrc = crc16(crc, (__u8 *)gdp, offset);\n\toffset += sizeof(gdp->bg_checksum); /* skip checksum */\n\t/* for checksum of struct ext4_group_desc do the rest...*/\n\tif ((sbi->s_es->s_feature_incompat &\n\t     cpu_to_le32(EXT4_FEATURE_INCOMPAT_64BIT)) &&\n\t    offset < le16_to_cpu(sbi->s_es->s_desc_size))\n\t\tcrc = crc16(crc, (__u8 *)gdp + offset,\n\t\t\t    le16_to_cpu(sbi->s_es->s_desc_size) -\n\t\t\t\toffset);\n\nout:\n\treturn cpu_to_le16(crc);\n}",
    "includes": [
      "#include <trace/events/ext4.h>",
      "#include \"mballoc.h\"",
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"ext4_jbd2.h\"",
      "#include \"ext4_extents.h\"\t/* Needed for trace points definition */",
      "#include \"ext4.h\"",
      "#include <linux/freezer.h>",
      "#include <linux/kthread.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/cleancache.h>",
      "#include <linux/crc16.h>",
      "#include <linux/log2.h>",
      "#include <linux/ctype.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/namei.h>",
      "#include <linux/mount.h>",
      "#include <linux/random.h>",
      "#include <linux/vfs.h>",
      "#include <linux/exportfs.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/parser.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/init.h>",
      "#include <linux/slab.h>",
      "#include <linux/jbd2.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/time.h>",
      "#include <linux/fs.h>",
      "#include <linux/string.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "crc"
          ],
          "line": 2036
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "crc16",
          "args": [
            "crc",
            "(__u8 *)gdp + offset",
            "le16_to_cpu(sbi->s_es->s_desc_size) -\n\t\t\t\toffset"
          ],
          "line": 2031
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le16_to_cpu",
          "args": [
            "sbi->s_es->s_desc_size"
          ],
          "line": 2032
        },
        "resolved": true,
        "details": {
          "function_name": "sle16_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "48-51",
          "snippet": "static inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "EXT4_FEATURE_INCOMPAT_64BIT"
          ],
          "line": 2029
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "crc16",
          "args": [
            "crc",
            "(__u8 *)gdp",
            "offset"
          ],
          "line": 2025
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "crc16",
          "args": [
            "crc",
            "(__u8 *)&le_group",
            "sizeof(le_group)"
          ],
          "line": 2024
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "crc16",
          "args": [
            "~0",
            "sbi->s_es->s_uuid",
            "sizeof(sbi->s_es->s_uuid)"
          ],
          "line": 2023
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "EXT4_FEATURE_RO_COMPAT_GDT_CSUM"
          ],
          "line": 2018
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_chksum",
          "args": [
            "sbi",
            "csum32",
            "(__u8 *)gdp",
            "sbi->s_desc_size"
          ],
          "line": 2008
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_chksum",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ext4.h",
          "lines": "1756-1775",
          "snippet": "static inline u32 ext4_chksum(struct ext4_sb_info *sbi, u32 crc,\n\t\t\t      const void *address, unsigned int length)\n{\n\tstruct {\n\t\tstruct shash_desc shash;\n\t\tchar ctx[4];\n\t} desc;\n\tint err;\n\n\tBUG_ON(crypto_shash_descsize(sbi->s_chksum_driver)!=sizeof(desc.ctx));\n\n\tdesc.shash.tfm = sbi->s_chksum_driver;\n\tdesc.shash.flags = 0;\n\t*(u32 *)desc.ctx = crc;\n\n\terr = crypto_shash_update(&desc.shash, address, length);\n\tBUG_ON(err);\n\n\treturn *(u32 *)desc.ctx;\n}",
          "includes": [
            "#include \"extents_status.h\"",
            "#include <linux/compat.h>",
            "#include <linux/falloc.h>",
            "#include <crypto/hash.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/wait.h>",
            "#include <linux/timer.h>",
            "#include <linux/mutex.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/quota.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extents_status.h\"\n#include <linux/compat.h>\n#include <linux/falloc.h>\n#include <crypto/hash.h>\n#include <linux/ratelimit.h>\n#include <linux/percpu_counter.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/wait.h>\n#include <linux/timer.h>\n#include <linux/mutex.h>\n#include <linux/seqlock.h>\n#include <linux/rbtree.h>\n#include <linux/rwsem.h>\n#include <linux/quota.h>\n#include <linux/jbd2.h>\n#include <linux/magic.h>\n#include <linux/blkdev.h>\n#include <linux/types.h>\n\nstatic inline u32 ext4_chksum(struct ext4_sb_info *sbi, u32 crc,\n\t\t\t      const void *address, unsigned int length)\n{\n\tstruct {\n\t\tstruct shash_desc shash;\n\t\tchar ctx[4];\n\t} desc;\n\tint err;\n\n\tBUG_ON(crypto_shash_descsize(sbi->s_chksum_driver)!=sizeof(desc.ctx));\n\n\tdesc.shash.tfm = sbi->s_chksum_driver;\n\tdesc.shash.flags = 0;\n\t*(u32 *)desc.ctx = crc;\n\n\terr = crypto_shash_update(&desc.shash, address, length);\n\tBUG_ON(err);\n\n\treturn *(u32 *)desc.ctx;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_has_metadata_csum",
          "args": [
            "sbi->s_sb"
          ],
          "line": 1999
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "block_group"
          ],
          "line": 1997
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"mballoc.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4_extents.h\"\t/* Needed for trace points definition */\n#include \"ext4.h\"\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <asm/uaccess.h>\n#include <linux/cleancache.h>\n#include <linux/crc16.h>\n#include <linux/log2.h>\n#include <linux/ctype.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/random.h>\n#include <linux/vfs.h>\n#include <linux/exportfs.h>\n#include <linux/buffer_head.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/jbd2.h>\n#include <linux/vmalloc.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n#include <linux/string.h>\n#include <linux/module.h>\n\nstatic __le16 ext4_group_desc_csum(struct ext4_sb_info *sbi, __u32 block_group,\n\t\t\t\t   struct ext4_group_desc *gdp)\n{\n\tint offset;\n\t__u16 crc = 0;\n\t__le32 le_group = cpu_to_le32(block_group);\n\n\tif (ext4_has_metadata_csum(sbi->s_sb)) {\n\t\t/* Use new metadata_csum algorithm */\n\t\t__le16 save_csum;\n\t\t__u32 csum32;\n\n\t\tsave_csum = gdp->bg_checksum;\n\t\tgdp->bg_checksum = 0;\n\t\tcsum32 = ext4_chksum(sbi, sbi->s_csum_seed, (__u8 *)&le_group,\n\t\t\t\t     sizeof(le_group));\n\t\tcsum32 = ext4_chksum(sbi, csum32, (__u8 *)gdp,\n\t\t\t\t     sbi->s_desc_size);\n\t\tgdp->bg_checksum = save_csum;\n\n\t\tcrc = csum32 & 0xFFFF;\n\t\tgoto out;\n\t}\n\n\t/* old crc16 code */\n\tif (!(sbi->s_es->s_feature_ro_compat &\n\t      cpu_to_le32(EXT4_FEATURE_RO_COMPAT_GDT_CSUM)))\n\t\treturn 0;\n\n\toffset = offsetof(struct ext4_group_desc, bg_checksum);\n\n\tcrc = crc16(~0, sbi->s_es->s_uuid, sizeof(sbi->s_es->s_uuid));\n\tcrc = crc16(crc, (__u8 *)&le_group, sizeof(le_group));\n\tcrc = crc16(crc, (__u8 *)gdp, offset);\n\toffset += sizeof(gdp->bg_checksum); /* skip checksum */\n\t/* for checksum of struct ext4_group_desc do the rest...*/\n\tif ((sbi->s_es->s_feature_incompat &\n\t     cpu_to_le32(EXT4_FEATURE_INCOMPAT_64BIT)) &&\n\t    offset < le16_to_cpu(sbi->s_es->s_desc_size))\n\t\tcrc = crc16(crc, (__u8 *)gdp + offset,\n\t\t\t    le16_to_cpu(sbi->s_es->s_desc_size) -\n\t\t\t\toffset);\n\nout:\n\treturn cpu_to_le16(crc);\n}"
  },
  {
    "function_name": "ext4_fill_flex_info",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/super.c",
    "lines": "1958-1990",
    "snippet": "static int ext4_fill_flex_info(struct super_block *sb)\n{\n\tstruct ext4_sb_info *sbi = EXT4_SB(sb);\n\tstruct ext4_group_desc *gdp = NULL;\n\text4_group_t flex_group;\n\tint i, err;\n\n\tsbi->s_log_groups_per_flex = sbi->s_es->s_log_groups_per_flex;\n\tif (sbi->s_log_groups_per_flex < 1 || sbi->s_log_groups_per_flex > 31) {\n\t\tsbi->s_log_groups_per_flex = 0;\n\t\treturn 1;\n\t}\n\n\terr = ext4_alloc_flex_bg_array(sb, sbi->s_groups_count);\n\tif (err)\n\t\tgoto failed;\n\n\tfor (i = 0; i < sbi->s_groups_count; i++) {\n\t\tgdp = ext4_get_group_desc(sb, i, NULL);\n\n\t\tflex_group = ext4_flex_group(sbi, i);\n\t\tatomic_add(ext4_free_inodes_count(sb, gdp),\n\t\t\t   &sbi->s_flex_groups[flex_group].free_inodes);\n\t\tatomic64_add(ext4_free_group_clusters(sb, gdp),\n\t\t\t     &sbi->s_flex_groups[flex_group].free_clusters);\n\t\tatomic_add(ext4_used_dirs_count(sb, gdp),\n\t\t\t   &sbi->s_flex_groups[flex_group].used_dirs);\n\t}\n\n\treturn 1;\nfailed:\n\treturn 0;\n}",
    "includes": [
      "#include <trace/events/ext4.h>",
      "#include \"mballoc.h\"",
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"ext4_jbd2.h\"",
      "#include \"ext4_extents.h\"\t/* Needed for trace points definition */",
      "#include \"ext4.h\"",
      "#include <linux/freezer.h>",
      "#include <linux/kthread.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/cleancache.h>",
      "#include <linux/crc16.h>",
      "#include <linux/log2.h>",
      "#include <linux/ctype.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/namei.h>",
      "#include <linux/mount.h>",
      "#include <linux/random.h>",
      "#include <linux/vfs.h>",
      "#include <linux/exportfs.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/parser.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/init.h>",
      "#include <linux/slab.h>",
      "#include <linux/jbd2.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/time.h>",
      "#include <linux/fs.h>",
      "#include <linux/string.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ext4_unfreeze(struct super_block *sb);",
      "static int ext4_freeze(struct super_block *sb);",
      "static inline int ext2_feature_set_ok(struct super_block *sb);",
      "static inline int ext3_feature_set_ok(struct super_block *sb);",
      "static void ext4_unregister_li_request(struct super_block *sb);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "atomic_add",
          "args": [
            "ext4_used_dirs_count(sb, gdp)",
            "&sbi->s_flex_groups[flex_group].used_dirs"
          ],
          "line": 1983
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_used_dirs_count",
          "args": [
            "sb",
            "gdp"
          ],
          "line": 1983
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_used_dirs_count",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/super.c",
          "lines": "219-225",
          "snippet": "__u32 ext4_used_dirs_count(struct super_block *sb,\n\t\t\t      struct ext4_group_desc *bg)\n{\n\treturn le16_to_cpu(bg->bg_used_dirs_count_lo) |\n\t\t(EXT4_DESC_SIZE(sb) >= EXT4_MIN_DESC_SIZE_64BIT ?\n\t\t (__u32)le16_to_cpu(bg->bg_used_dirs_count_hi) << 16 : 0);\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"mballoc.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include \"ext4_extents.h\"\t/* Needed for trace points definition */",
            "#include \"ext4.h\"",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/crc16.h>",
            "#include <linux/log2.h>",
            "#include <linux/ctype.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/random.h>",
            "#include <linux/vfs.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/parser.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/time.h>",
            "#include <linux/fs.h>",
            "#include <linux/string.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ext4_unfreeze(struct super_block *sb);",
            "static int ext4_freeze(struct super_block *sb);",
            "static inline int ext2_feature_set_ok(struct super_block *sb);",
            "static inline int ext3_feature_set_ok(struct super_block *sb);",
            "static void ext4_unregister_li_request(struct super_block *sb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"mballoc.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4_extents.h\"\t/* Needed for trace points definition */\n#include \"ext4.h\"\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <asm/uaccess.h>\n#include <linux/cleancache.h>\n#include <linux/crc16.h>\n#include <linux/log2.h>\n#include <linux/ctype.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/random.h>\n#include <linux/vfs.h>\n#include <linux/exportfs.h>\n#include <linux/buffer_head.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/jbd2.h>\n#include <linux/vmalloc.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n#include <linux/string.h>\n#include <linux/module.h>\n\nstatic int ext4_unfreeze(struct super_block *sb);\nstatic int ext4_freeze(struct super_block *sb);\nstatic inline int ext2_feature_set_ok(struct super_block *sb);\nstatic inline int ext3_feature_set_ok(struct super_block *sb);\nstatic void ext4_unregister_li_request(struct super_block *sb);\n\n__u32 ext4_used_dirs_count(struct super_block *sb,\n\t\t\t      struct ext4_group_desc *bg)\n{\n\treturn le16_to_cpu(bg->bg_used_dirs_count_lo) |\n\t\t(EXT4_DESC_SIZE(sb) >= EXT4_MIN_DESC_SIZE_64BIT ?\n\t\t (__u32)le16_to_cpu(bg->bg_used_dirs_count_hi) << 16 : 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic64_add",
          "args": [
            "ext4_free_group_clusters(sb, gdp)",
            "&sbi->s_flex_groups[flex_group].free_clusters"
          ],
          "line": 1981
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_free_group_clusters",
          "args": [
            "sb",
            "gdp"
          ],
          "line": 1981
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_free_group_clusters",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/super.c",
          "lines": "203-209",
          "snippet": "__u32 ext4_free_group_clusters(struct super_block *sb,\n\t\t\t       struct ext4_group_desc *bg)\n{\n\treturn le16_to_cpu(bg->bg_free_blocks_count_lo) |\n\t\t(EXT4_DESC_SIZE(sb) >= EXT4_MIN_DESC_SIZE_64BIT ?\n\t\t (__u32)le16_to_cpu(bg->bg_free_blocks_count_hi) << 16 : 0);\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"mballoc.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include \"ext4_extents.h\"\t/* Needed for trace points definition */",
            "#include \"ext4.h\"",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/crc16.h>",
            "#include <linux/log2.h>",
            "#include <linux/ctype.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/random.h>",
            "#include <linux/vfs.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/parser.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/time.h>",
            "#include <linux/fs.h>",
            "#include <linux/string.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ext4_unfreeze(struct super_block *sb);",
            "static int ext4_freeze(struct super_block *sb);",
            "static inline int ext2_feature_set_ok(struct super_block *sb);",
            "static inline int ext3_feature_set_ok(struct super_block *sb);",
            "static void ext4_unregister_li_request(struct super_block *sb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"mballoc.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4_extents.h\"\t/* Needed for trace points definition */\n#include \"ext4.h\"\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <asm/uaccess.h>\n#include <linux/cleancache.h>\n#include <linux/crc16.h>\n#include <linux/log2.h>\n#include <linux/ctype.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/random.h>\n#include <linux/vfs.h>\n#include <linux/exportfs.h>\n#include <linux/buffer_head.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/jbd2.h>\n#include <linux/vmalloc.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n#include <linux/string.h>\n#include <linux/module.h>\n\nstatic int ext4_unfreeze(struct super_block *sb);\nstatic int ext4_freeze(struct super_block *sb);\nstatic inline int ext2_feature_set_ok(struct super_block *sb);\nstatic inline int ext3_feature_set_ok(struct super_block *sb);\nstatic void ext4_unregister_li_request(struct super_block *sb);\n\n__u32 ext4_free_group_clusters(struct super_block *sb,\n\t\t\t       struct ext4_group_desc *bg)\n{\n\treturn le16_to_cpu(bg->bg_free_blocks_count_lo) |\n\t\t(EXT4_DESC_SIZE(sb) >= EXT4_MIN_DESC_SIZE_64BIT ?\n\t\t (__u32)le16_to_cpu(bg->bg_free_blocks_count_hi) << 16 : 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_add",
          "args": [
            "ext4_free_inodes_count(sb, gdp)",
            "&sbi->s_flex_groups[flex_group].free_inodes"
          ],
          "line": 1979
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_free_inodes_count",
          "args": [
            "sb",
            "gdp"
          ],
          "line": 1979
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_free_inodes_count",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/super.c",
          "lines": "211-217",
          "snippet": "__u32 ext4_free_inodes_count(struct super_block *sb,\n\t\t\t      struct ext4_group_desc *bg)\n{\n\treturn le16_to_cpu(bg->bg_free_inodes_count_lo) |\n\t\t(EXT4_DESC_SIZE(sb) >= EXT4_MIN_DESC_SIZE_64BIT ?\n\t\t (__u32)le16_to_cpu(bg->bg_free_inodes_count_hi) << 16 : 0);\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"mballoc.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include \"ext4_extents.h\"\t/* Needed for trace points definition */",
            "#include \"ext4.h\"",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/crc16.h>",
            "#include <linux/log2.h>",
            "#include <linux/ctype.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/random.h>",
            "#include <linux/vfs.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/parser.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/time.h>",
            "#include <linux/fs.h>",
            "#include <linux/string.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ext4_unfreeze(struct super_block *sb);",
            "static int ext4_freeze(struct super_block *sb);",
            "static inline int ext2_feature_set_ok(struct super_block *sb);",
            "static inline int ext3_feature_set_ok(struct super_block *sb);",
            "static void ext4_unregister_li_request(struct super_block *sb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"mballoc.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4_extents.h\"\t/* Needed for trace points definition */\n#include \"ext4.h\"\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <asm/uaccess.h>\n#include <linux/cleancache.h>\n#include <linux/crc16.h>\n#include <linux/log2.h>\n#include <linux/ctype.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/random.h>\n#include <linux/vfs.h>\n#include <linux/exportfs.h>\n#include <linux/buffer_head.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/jbd2.h>\n#include <linux/vmalloc.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n#include <linux/string.h>\n#include <linux/module.h>\n\nstatic int ext4_unfreeze(struct super_block *sb);\nstatic int ext4_freeze(struct super_block *sb);\nstatic inline int ext2_feature_set_ok(struct super_block *sb);\nstatic inline int ext3_feature_set_ok(struct super_block *sb);\nstatic void ext4_unregister_li_request(struct super_block *sb);\n\n__u32 ext4_free_inodes_count(struct super_block *sb,\n\t\t\t      struct ext4_group_desc *bg)\n{\n\treturn le16_to_cpu(bg->bg_free_inodes_count_lo) |\n\t\t(EXT4_DESC_SIZE(sb) >= EXT4_MIN_DESC_SIZE_64BIT ?\n\t\t (__u32)le16_to_cpu(bg->bg_free_inodes_count_hi) << 16 : 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_flex_group",
          "args": [
            "sbi",
            "i"
          ],
          "line": 1978
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_get_group_desc",
          "args": [
            "sb",
            "i",
            "NULL"
          ],
          "line": 1976
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_get_group_desc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/balloc.c",
          "lines": "277-309",
          "snippet": "struct ext4_group_desc * ext4_get_group_desc(struct super_block *sb,\n\t\t\t\t\t     ext4_group_t block_group,\n\t\t\t\t\t     struct buffer_head **bh)\n{\n\tunsigned int group_desc;\n\tunsigned int offset;\n\text4_group_t ngroups = ext4_get_groups_count(sb);\n\tstruct ext4_group_desc *desc;\n\tstruct ext4_sb_info *sbi = EXT4_SB(sb);\n\n\tif (block_group >= ngroups) {\n\t\text4_error(sb, \"block_group >= groups_count - block_group = %u,\"\n\t\t\t   \" groups_count = %u\", block_group, ngroups);\n\n\t\treturn NULL;\n\t}\n\n\tgroup_desc = block_group >> EXT4_DESC_PER_BLOCK_BITS(sb);\n\toffset = block_group & (EXT4_DESC_PER_BLOCK(sb) - 1);\n\tif (!sbi->s_group_desc[group_desc]) {\n\t\text4_error(sb, \"Group descriptor not loaded - \"\n\t\t\t   \"block_group = %u, group_desc = %u, desc = %u\",\n\t\t\t   block_group, group_desc, offset);\n\t\treturn NULL;\n\t}\n\n\tdesc = (struct ext4_group_desc *)(\n\t\t(__u8 *)sbi->s_group_desc[group_desc]->b_data +\n\t\toffset * EXT4_DESC_SIZE(sb));\n\tif (bh)\n\t\t*bh = sbi->s_group_desc[group_desc];\n\treturn desc;\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"mballoc.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include \"ext4.h\"",
            "#include <linux/buffer_head.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/fs.h>",
            "#include <linux/capability.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static unsigned ext4_num_base_meta_clusters(struct super_block *sb,\n\t\t\t\t\t    ext4_group_t block_group);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"mballoc.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4.h\"\n#include <linux/buffer_head.h>\n#include <linux/quotaops.h>\n#include <linux/jbd2.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n#include <linux/time.h>\n\nstatic unsigned ext4_num_base_meta_clusters(struct super_block *sb,\n\t\t\t\t\t    ext4_group_t block_group);\n\nstruct ext4_group_desc * ext4_get_group_desc(struct super_block *sb,\n\t\t\t\t\t     ext4_group_t block_group,\n\t\t\t\t\t     struct buffer_head **bh)\n{\n\tunsigned int group_desc;\n\tunsigned int offset;\n\text4_group_t ngroups = ext4_get_groups_count(sb);\n\tstruct ext4_group_desc *desc;\n\tstruct ext4_sb_info *sbi = EXT4_SB(sb);\n\n\tif (block_group >= ngroups) {\n\t\text4_error(sb, \"block_group >= groups_count - block_group = %u,\"\n\t\t\t   \" groups_count = %u\", block_group, ngroups);\n\n\t\treturn NULL;\n\t}\n\n\tgroup_desc = block_group >> EXT4_DESC_PER_BLOCK_BITS(sb);\n\toffset = block_group & (EXT4_DESC_PER_BLOCK(sb) - 1);\n\tif (!sbi->s_group_desc[group_desc]) {\n\t\text4_error(sb, \"Group descriptor not loaded - \"\n\t\t\t   \"block_group = %u, group_desc = %u, desc = %u\",\n\t\t\t   block_group, group_desc, offset);\n\t\treturn NULL;\n\t}\n\n\tdesc = (struct ext4_group_desc *)(\n\t\t(__u8 *)sbi->s_group_desc[group_desc]->b_data +\n\t\toffset * EXT4_DESC_SIZE(sb));\n\tif (bh)\n\t\t*bh = sbi->s_group_desc[group_desc];\n\treturn desc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_alloc_flex_bg_array",
          "args": [
            "sb",
            "sbi->s_groups_count"
          ],
          "line": 1971
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_alloc_flex_bg_array",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/super.c",
          "lines": "1926-1956",
          "snippet": "int ext4_alloc_flex_bg_array(struct super_block *sb, ext4_group_t ngroup)\n{\n\tstruct ext4_sb_info *sbi = EXT4_SB(sb);\n\tstruct flex_groups *new_groups;\n\tint size;\n\n\tif (!sbi->s_log_groups_per_flex)\n\t\treturn 0;\n\n\tsize = ext4_flex_group(sbi, ngroup - 1) + 1;\n\tif (size <= sbi->s_flex_groups_allocated)\n\t\treturn 0;\n\n\tsize = roundup_pow_of_two(size * sizeof(struct flex_groups));\n\tnew_groups = ext4_kvzalloc(size, GFP_KERNEL);\n\tif (!new_groups) {\n\t\text4_msg(sb, KERN_ERR, \"not enough memory for %d flex groups\",\n\t\t\t size / (int) sizeof(struct flex_groups));\n\t\treturn -ENOMEM;\n\t}\n\n\tif (sbi->s_flex_groups) {\n\t\tmemcpy(new_groups, sbi->s_flex_groups,\n\t\t       (sbi->s_flex_groups_allocated *\n\t\t\tsizeof(struct flex_groups)));\n\t\tkvfree(sbi->s_flex_groups);\n\t}\n\tsbi->s_flex_groups = new_groups;\n\tsbi->s_flex_groups_allocated = size / sizeof(struct flex_groups);\n\treturn 0;\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"mballoc.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include \"ext4_extents.h\"\t/* Needed for trace points definition */",
            "#include \"ext4.h\"",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/crc16.h>",
            "#include <linux/log2.h>",
            "#include <linux/ctype.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/random.h>",
            "#include <linux/vfs.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/parser.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/time.h>",
            "#include <linux/fs.h>",
            "#include <linux/string.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ext4_unfreeze(struct super_block *sb);",
            "static int ext4_freeze(struct super_block *sb);",
            "static inline int ext2_feature_set_ok(struct super_block *sb);",
            "static inline int ext3_feature_set_ok(struct super_block *sb);",
            "static void ext4_unregister_li_request(struct super_block *sb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"mballoc.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4_extents.h\"\t/* Needed for trace points definition */\n#include \"ext4.h\"\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <asm/uaccess.h>\n#include <linux/cleancache.h>\n#include <linux/crc16.h>\n#include <linux/log2.h>\n#include <linux/ctype.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/random.h>\n#include <linux/vfs.h>\n#include <linux/exportfs.h>\n#include <linux/buffer_head.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/jbd2.h>\n#include <linux/vmalloc.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n#include <linux/string.h>\n#include <linux/module.h>\n\nstatic int ext4_unfreeze(struct super_block *sb);\nstatic int ext4_freeze(struct super_block *sb);\nstatic inline int ext2_feature_set_ok(struct super_block *sb);\nstatic inline int ext3_feature_set_ok(struct super_block *sb);\nstatic void ext4_unregister_li_request(struct super_block *sb);\n\nint ext4_alloc_flex_bg_array(struct super_block *sb, ext4_group_t ngroup)\n{\n\tstruct ext4_sb_info *sbi = EXT4_SB(sb);\n\tstruct flex_groups *new_groups;\n\tint size;\n\n\tif (!sbi->s_log_groups_per_flex)\n\t\treturn 0;\n\n\tsize = ext4_flex_group(sbi, ngroup - 1) + 1;\n\tif (size <= sbi->s_flex_groups_allocated)\n\t\treturn 0;\n\n\tsize = roundup_pow_of_two(size * sizeof(struct flex_groups));\n\tnew_groups = ext4_kvzalloc(size, GFP_KERNEL);\n\tif (!new_groups) {\n\t\text4_msg(sb, KERN_ERR, \"not enough memory for %d flex groups\",\n\t\t\t size / (int) sizeof(struct flex_groups));\n\t\treturn -ENOMEM;\n\t}\n\n\tif (sbi->s_flex_groups) {\n\t\tmemcpy(new_groups, sbi->s_flex_groups,\n\t\t       (sbi->s_flex_groups_allocated *\n\t\t\tsizeof(struct flex_groups)));\n\t\tkvfree(sbi->s_flex_groups);\n\t}\n\tsbi->s_flex_groups = new_groups;\n\tsbi->s_flex_groups_allocated = size / sizeof(struct flex_groups);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "EXT4_SB",
          "args": [
            "sb"
          ],
          "line": 1960
        },
        "resolved": true,
        "details": {
          "function_name": "EXT4_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ext4.h",
          "lines": "1356-1359",
          "snippet": "static inline struct ext4_sb_info *EXT4_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include \"extents_status.h\"",
            "#include <linux/compat.h>",
            "#include <linux/falloc.h>",
            "#include <crypto/hash.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/wait.h>",
            "#include <linux/timer.h>",
            "#include <linux/mutex.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/quota.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extents_status.h\"\n#include <linux/compat.h>\n#include <linux/falloc.h>\n#include <crypto/hash.h>\n#include <linux/ratelimit.h>\n#include <linux/percpu_counter.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/wait.h>\n#include <linux/timer.h>\n#include <linux/mutex.h>\n#include <linux/seqlock.h>\n#include <linux/rbtree.h>\n#include <linux/rwsem.h>\n#include <linux/quota.h>\n#include <linux/jbd2.h>\n#include <linux/magic.h>\n#include <linux/blkdev.h>\n#include <linux/types.h>\n\nstatic inline struct ext4_sb_info *EXT4_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"mballoc.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4_extents.h\"\t/* Needed for trace points definition */\n#include \"ext4.h\"\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <asm/uaccess.h>\n#include <linux/cleancache.h>\n#include <linux/crc16.h>\n#include <linux/log2.h>\n#include <linux/ctype.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/random.h>\n#include <linux/vfs.h>\n#include <linux/exportfs.h>\n#include <linux/buffer_head.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/jbd2.h>\n#include <linux/vmalloc.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n#include <linux/string.h>\n#include <linux/module.h>\n\nstatic int ext4_unfreeze(struct super_block *sb);\nstatic int ext4_freeze(struct super_block *sb);\nstatic inline int ext2_feature_set_ok(struct super_block *sb);\nstatic inline int ext3_feature_set_ok(struct super_block *sb);\nstatic void ext4_unregister_li_request(struct super_block *sb);\n\nstatic int ext4_fill_flex_info(struct super_block *sb)\n{\n\tstruct ext4_sb_info *sbi = EXT4_SB(sb);\n\tstruct ext4_group_desc *gdp = NULL;\n\text4_group_t flex_group;\n\tint i, err;\n\n\tsbi->s_log_groups_per_flex = sbi->s_es->s_log_groups_per_flex;\n\tif (sbi->s_log_groups_per_flex < 1 || sbi->s_log_groups_per_flex > 31) {\n\t\tsbi->s_log_groups_per_flex = 0;\n\t\treturn 1;\n\t}\n\n\terr = ext4_alloc_flex_bg_array(sb, sbi->s_groups_count);\n\tif (err)\n\t\tgoto failed;\n\n\tfor (i = 0; i < sbi->s_groups_count; i++) {\n\t\tgdp = ext4_get_group_desc(sb, i, NULL);\n\n\t\tflex_group = ext4_flex_group(sbi, i);\n\t\tatomic_add(ext4_free_inodes_count(sb, gdp),\n\t\t\t   &sbi->s_flex_groups[flex_group].free_inodes);\n\t\tatomic64_add(ext4_free_group_clusters(sb, gdp),\n\t\t\t     &sbi->s_flex_groups[flex_group].free_clusters);\n\t\tatomic_add(ext4_used_dirs_count(sb, gdp),\n\t\t\t   &sbi->s_flex_groups[flex_group].used_dirs);\n\t}\n\n\treturn 1;\nfailed:\n\treturn 0;\n}"
  },
  {
    "function_name": "ext4_alloc_flex_bg_array",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/super.c",
    "lines": "1926-1956",
    "snippet": "int ext4_alloc_flex_bg_array(struct super_block *sb, ext4_group_t ngroup)\n{\n\tstruct ext4_sb_info *sbi = EXT4_SB(sb);\n\tstruct flex_groups *new_groups;\n\tint size;\n\n\tif (!sbi->s_log_groups_per_flex)\n\t\treturn 0;\n\n\tsize = ext4_flex_group(sbi, ngroup - 1) + 1;\n\tif (size <= sbi->s_flex_groups_allocated)\n\t\treturn 0;\n\n\tsize = roundup_pow_of_two(size * sizeof(struct flex_groups));\n\tnew_groups = ext4_kvzalloc(size, GFP_KERNEL);\n\tif (!new_groups) {\n\t\text4_msg(sb, KERN_ERR, \"not enough memory for %d flex groups\",\n\t\t\t size / (int) sizeof(struct flex_groups));\n\t\treturn -ENOMEM;\n\t}\n\n\tif (sbi->s_flex_groups) {\n\t\tmemcpy(new_groups, sbi->s_flex_groups,\n\t\t       (sbi->s_flex_groups_allocated *\n\t\t\tsizeof(struct flex_groups)));\n\t\tkvfree(sbi->s_flex_groups);\n\t}\n\tsbi->s_flex_groups = new_groups;\n\tsbi->s_flex_groups_allocated = size / sizeof(struct flex_groups);\n\treturn 0;\n}",
    "includes": [
      "#include <trace/events/ext4.h>",
      "#include \"mballoc.h\"",
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"ext4_jbd2.h\"",
      "#include \"ext4_extents.h\"\t/* Needed for trace points definition */",
      "#include \"ext4.h\"",
      "#include <linux/freezer.h>",
      "#include <linux/kthread.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/cleancache.h>",
      "#include <linux/crc16.h>",
      "#include <linux/log2.h>",
      "#include <linux/ctype.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/namei.h>",
      "#include <linux/mount.h>",
      "#include <linux/random.h>",
      "#include <linux/vfs.h>",
      "#include <linux/exportfs.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/parser.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/init.h>",
      "#include <linux/slab.h>",
      "#include <linux/jbd2.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/time.h>",
      "#include <linux/fs.h>",
      "#include <linux/string.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ext4_unfreeze(struct super_block *sb);",
      "static int ext4_freeze(struct super_block *sb);",
      "static inline int ext2_feature_set_ok(struct super_block *sb);",
      "static inline int ext3_feature_set_ok(struct super_block *sb);",
      "static void ext4_unregister_li_request(struct super_block *sb);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kvfree",
          "args": [
            "sbi->s_flex_groups"
          ],
          "line": 1951
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "new_groups",
            "sbi->s_flex_groups",
            "(sbi->s_flex_groups_allocated *\n\t\t\tsizeof(struct flex_groups))"
          ],
          "line": 1948
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_msg",
          "args": [
            "sb",
            "KERN_ERR",
            "\"not enough memory for %d flex groups\"",
            "size / (int) sizeof(struct flex_groups)"
          ],
          "line": 1942
        },
        "resolved": true,
        "details": {
          "function_name": "__ext4_msg",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/super.c",
          "lines": "593-607",
          "snippet": "void __ext4_msg(struct super_block *sb,\n\t\tconst char *prefix, const char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tif (!___ratelimit(&(EXT4_SB(sb)->s_msg_ratelimit_state), \"EXT4-fs\"))\n\t\treturn;\n\n\tva_start(args, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\tprintk(\"%sEXT4-fs (%s): %pV\\n\", prefix, sb->s_id, &vaf);\n\tva_end(args);\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"mballoc.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include \"ext4_extents.h\"\t/* Needed for trace points definition */",
            "#include \"ext4.h\"",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/crc16.h>",
            "#include <linux/log2.h>",
            "#include <linux/ctype.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/random.h>",
            "#include <linux/vfs.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/parser.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/time.h>",
            "#include <linux/fs.h>",
            "#include <linux/string.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ext4_unfreeze(struct super_block *sb);",
            "static int ext4_freeze(struct super_block *sb);",
            "static inline int ext2_feature_set_ok(struct super_block *sb);",
            "static inline int ext3_feature_set_ok(struct super_block *sb);",
            "static void ext4_unregister_li_request(struct super_block *sb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"mballoc.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4_extents.h\"\t/* Needed for trace points definition */\n#include \"ext4.h\"\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <asm/uaccess.h>\n#include <linux/cleancache.h>\n#include <linux/crc16.h>\n#include <linux/log2.h>\n#include <linux/ctype.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/random.h>\n#include <linux/vfs.h>\n#include <linux/exportfs.h>\n#include <linux/buffer_head.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/jbd2.h>\n#include <linux/vmalloc.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n#include <linux/string.h>\n#include <linux/module.h>\n\nstatic int ext4_unfreeze(struct super_block *sb);\nstatic int ext4_freeze(struct super_block *sb);\nstatic inline int ext2_feature_set_ok(struct super_block *sb);\nstatic inline int ext3_feature_set_ok(struct super_block *sb);\nstatic void ext4_unregister_li_request(struct super_block *sb);\n\nvoid __ext4_msg(struct super_block *sb,\n\t\tconst char *prefix, const char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tif (!___ratelimit(&(EXT4_SB(sb)->s_msg_ratelimit_state), \"EXT4-fs\"))\n\t\treturn;\n\n\tva_start(args, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\tprintk(\"%sEXT4-fs (%s): %pV\\n\", prefix, sb->s_id, &vaf);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_kvzalloc",
          "args": [
            "size",
            "GFP_KERNEL"
          ],
          "line": 1940
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_kvzalloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/super.c",
          "lines": "169-177",
          "snippet": "void *ext4_kvzalloc(size_t size, gfp_t flags)\n{\n\tvoid *ret;\n\n\tret = kzalloc(size, flags | __GFP_NOWARN);\n\tif (!ret)\n\t\tret = __vmalloc(size, flags | __GFP_ZERO, PAGE_KERNEL);\n\treturn ret;\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"mballoc.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include \"ext4_extents.h\"\t/* Needed for trace points definition */",
            "#include \"ext4.h\"",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/crc16.h>",
            "#include <linux/log2.h>",
            "#include <linux/ctype.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/random.h>",
            "#include <linux/vfs.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/parser.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/time.h>",
            "#include <linux/fs.h>",
            "#include <linux/string.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"mballoc.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4_extents.h\"\t/* Needed for trace points definition */\n#include \"ext4.h\"\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <asm/uaccess.h>\n#include <linux/cleancache.h>\n#include <linux/crc16.h>\n#include <linux/log2.h>\n#include <linux/ctype.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/random.h>\n#include <linux/vfs.h>\n#include <linux/exportfs.h>\n#include <linux/buffer_head.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/jbd2.h>\n#include <linux/vmalloc.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n#include <linux/string.h>\n#include <linux/module.h>\n\nvoid *ext4_kvzalloc(size_t size, gfp_t flags)\n{\n\tvoid *ret;\n\n\tret = kzalloc(size, flags | __GFP_NOWARN);\n\tif (!ret)\n\t\tret = __vmalloc(size, flags | __GFP_ZERO, PAGE_KERNEL);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "roundup_pow_of_two",
          "args": [
            "size * sizeof(struct flex_groups)"
          ],
          "line": 1939
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_flex_group",
          "args": [
            "sbi",
            "ngroup - 1"
          ],
          "line": 1935
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXT4_SB",
          "args": [
            "sb"
          ],
          "line": 1928
        },
        "resolved": true,
        "details": {
          "function_name": "EXT4_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ext4.h",
          "lines": "1356-1359",
          "snippet": "static inline struct ext4_sb_info *EXT4_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include \"extents_status.h\"",
            "#include <linux/compat.h>",
            "#include <linux/falloc.h>",
            "#include <crypto/hash.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/wait.h>",
            "#include <linux/timer.h>",
            "#include <linux/mutex.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/quota.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extents_status.h\"\n#include <linux/compat.h>\n#include <linux/falloc.h>\n#include <crypto/hash.h>\n#include <linux/ratelimit.h>\n#include <linux/percpu_counter.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/wait.h>\n#include <linux/timer.h>\n#include <linux/mutex.h>\n#include <linux/seqlock.h>\n#include <linux/rbtree.h>\n#include <linux/rwsem.h>\n#include <linux/quota.h>\n#include <linux/jbd2.h>\n#include <linux/magic.h>\n#include <linux/blkdev.h>\n#include <linux/types.h>\n\nstatic inline struct ext4_sb_info *EXT4_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"mballoc.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4_extents.h\"\t/* Needed for trace points definition */\n#include \"ext4.h\"\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <asm/uaccess.h>\n#include <linux/cleancache.h>\n#include <linux/crc16.h>\n#include <linux/log2.h>\n#include <linux/ctype.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/random.h>\n#include <linux/vfs.h>\n#include <linux/exportfs.h>\n#include <linux/buffer_head.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/jbd2.h>\n#include <linux/vmalloc.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n#include <linux/string.h>\n#include <linux/module.h>\n\nstatic int ext4_unfreeze(struct super_block *sb);\nstatic int ext4_freeze(struct super_block *sb);\nstatic inline int ext2_feature_set_ok(struct super_block *sb);\nstatic inline int ext3_feature_set_ok(struct super_block *sb);\nstatic void ext4_unregister_li_request(struct super_block *sb);\n\nint ext4_alloc_flex_bg_array(struct super_block *sb, ext4_group_t ngroup)\n{\n\tstruct ext4_sb_info *sbi = EXT4_SB(sb);\n\tstruct flex_groups *new_groups;\n\tint size;\n\n\tif (!sbi->s_log_groups_per_flex)\n\t\treturn 0;\n\n\tsize = ext4_flex_group(sbi, ngroup - 1) + 1;\n\tif (size <= sbi->s_flex_groups_allocated)\n\t\treturn 0;\n\n\tsize = roundup_pow_of_two(size * sizeof(struct flex_groups));\n\tnew_groups = ext4_kvzalloc(size, GFP_KERNEL);\n\tif (!new_groups) {\n\t\text4_msg(sb, KERN_ERR, \"not enough memory for %d flex groups\",\n\t\t\t size / (int) sizeof(struct flex_groups));\n\t\treturn -ENOMEM;\n\t}\n\n\tif (sbi->s_flex_groups) {\n\t\tmemcpy(new_groups, sbi->s_flex_groups,\n\t\t       (sbi->s_flex_groups_allocated *\n\t\t\tsizeof(struct flex_groups)));\n\t\tkvfree(sbi->s_flex_groups);\n\t}\n\tsbi->s_flex_groups = new_groups;\n\tsbi->s_flex_groups_allocated = size / sizeof(struct flex_groups);\n\treturn 0;\n}"
  },
  {
    "function_name": "ext4_setup_super",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/super.c",
    "lines": "1869-1924",
    "snippet": "static int ext4_setup_super(struct super_block *sb, struct ext4_super_block *es,\n\t\t\t    int read_only)\n{\n\tstruct ext4_sb_info *sbi = EXT4_SB(sb);\n\tint res = 0;\n\n\tif (le32_to_cpu(es->s_rev_level) > EXT4_MAX_SUPP_REV) {\n\t\text4_msg(sb, KERN_ERR, \"revision level too high, \"\n\t\t\t \"forcing read-only mode\");\n\t\tres = MS_RDONLY;\n\t}\n\tif (read_only)\n\t\tgoto done;\n\tif (!(sbi->s_mount_state & EXT4_VALID_FS))\n\t\text4_msg(sb, KERN_WARNING, \"warning: mounting unchecked fs, \"\n\t\t\t \"running e2fsck is recommended\");\n\telse if (sbi->s_mount_state & EXT4_ERROR_FS)\n\t\text4_msg(sb, KERN_WARNING,\n\t\t\t \"warning: mounting fs with errors, \"\n\t\t\t \"running e2fsck is recommended\");\n\telse if ((__s16) le16_to_cpu(es->s_max_mnt_count) > 0 &&\n\t\t le16_to_cpu(es->s_mnt_count) >=\n\t\t (unsigned short) (__s16) le16_to_cpu(es->s_max_mnt_count))\n\t\text4_msg(sb, KERN_WARNING,\n\t\t\t \"warning: maximal mount count reached, \"\n\t\t\t \"running e2fsck is recommended\");\n\telse if (le32_to_cpu(es->s_checkinterval) &&\n\t\t(le32_to_cpu(es->s_lastcheck) +\n\t\t\tle32_to_cpu(es->s_checkinterval) <= get_seconds()))\n\t\text4_msg(sb, KERN_WARNING,\n\t\t\t \"warning: checktime reached, \"\n\t\t\t \"running e2fsck is recommended\");\n\tif (!sbi->s_journal)\n\t\tes->s_state &= cpu_to_le16(~EXT4_VALID_FS);\n\tif (!(__s16) le16_to_cpu(es->s_max_mnt_count))\n\t\tes->s_max_mnt_count = cpu_to_le16(EXT4_DFL_MAX_MNT_COUNT);\n\tle16_add_cpu(&es->s_mnt_count, 1);\n\tes->s_mtime = cpu_to_le32(get_seconds());\n\text4_update_dynamic_rev(sb);\n\tif (sbi->s_journal)\n\t\tEXT4_SET_INCOMPAT_FEATURE(sb, EXT4_FEATURE_INCOMPAT_RECOVER);\n\n\text4_commit_super(sb, 1);\ndone:\n\tif (test_opt(sb, DEBUG))\n\t\tprintk(KERN_INFO \"[EXT4 FS bs=%lu, gc=%u, \"\n\t\t\t\t\"bpg=%lu, ipg=%lu, mo=%04x, mo2=%04x]\\n\",\n\t\t\tsb->s_blocksize,\n\t\t\tsbi->s_groups_count,\n\t\t\tEXT4_BLOCKS_PER_GROUP(sb),\n\t\t\tEXT4_INODES_PER_GROUP(sb),\n\t\t\tsbi->s_mount_opt, sbi->s_mount_opt2);\n\n\tcleancache_init_fs(sb);\n\treturn res;\n}",
    "includes": [
      "#include <trace/events/ext4.h>",
      "#include \"mballoc.h\"",
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"ext4_jbd2.h\"",
      "#include \"ext4_extents.h\"\t/* Needed for trace points definition */",
      "#include \"ext4.h\"",
      "#include <linux/freezer.h>",
      "#include <linux/kthread.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/cleancache.h>",
      "#include <linux/crc16.h>",
      "#include <linux/log2.h>",
      "#include <linux/ctype.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/namei.h>",
      "#include <linux/mount.h>",
      "#include <linux/random.h>",
      "#include <linux/vfs.h>",
      "#include <linux/exportfs.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/parser.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/init.h>",
      "#include <linux/slab.h>",
      "#include <linux/jbd2.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/time.h>",
      "#include <linux/fs.h>",
      "#include <linux/string.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void ext4_mark_recovery_complete(struct super_block *sb,\n\t\t\t\t\tstruct ext4_super_block *es);",
      "static void ext4_clear_journal_err(struct super_block *sb,\n\t\t\t\t   struct ext4_super_block *es);",
      "static int ext4_unfreeze(struct super_block *sb);",
      "static int ext4_freeze(struct super_block *sb);",
      "static inline int ext2_feature_set_ok(struct super_block *sb);",
      "static inline int ext3_feature_set_ok(struct super_block *sb);",
      "static void ext4_unregister_li_request(struct super_block *sb);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "cleancache_init_fs",
          "args": [
            "sb"
          ],
          "line": 1922
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_INFO \"[EXT4 FS bs=%lu, gc=%u, \"\n\t\t\t\t\"bpg=%lu, ipg=%lu, mo=%04x, mo2=%04x]\\n\"",
            "sb->s_blocksize",
            "sbi->s_groups_count",
            "EXT4_BLOCKS_PER_GROUP(sb)",
            "EXT4_INODES_PER_GROUP(sb)",
            "sbi->s_mount_opt",
            "sbi->s_mount_opt2"
          ],
          "line": 1914
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_printk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/super.c",
          "lines": "186-213",
          "snippet": "void btrfs_printk(const struct btrfs_fs_info *fs_info, const char *fmt, ...)\n{\n\tstruct super_block *sb = fs_info->sb;\n\tchar lvl[4];\n\tstruct va_format vaf;\n\tva_list args;\n\tconst char *type = logtypes[4];\n\tint kern_level;\n\n\tva_start(args, fmt);\n\n\tkern_level = printk_get_level(fmt);\n\tif (kern_level) {\n\t\tsize_t size = printk_skip_level(fmt) - fmt;\n\t\tmemcpy(lvl, fmt,  size);\n\t\tlvl[size] = '\\0';\n\t\tfmt += size;\n\t\ttype = logtypes[kern_level - '0'];\n\t} else\n\t\t*lvl = '\\0';\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\tprintk(\"%sBTRFS %s (device %s): %pV\\n\", lvl, type, sb->s_id, &vaf);\n\n\tva_end(args);\n}",
          "includes": [
            "#include <trace/events/btrfs.h>",
            "#include \"qgroup.h\"",
            "#include \"tests/btrfs-tests.h\"",
            "#include \"backref.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"dev-replace.h\"",
            "#include \"rcu-string.h\"",
            "#include \"compression.h\"",
            "#include \"export.h\"",
            "#include \"volumes.h\"",
            "#include \"xattr.h\"",
            "#include \"props.h\"",
            "#include \"hash.h\"",
            "#include \"print-tree.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include \"delayed-inode.h\"",
            "#include <linux/btrfs.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/slab.h>",
            "#include <linux/magic.h>",
            "#include <linux/miscdevice.h>",
            "#include <linux/namei.h>",
            "#include <linux/ctype.h>",
            "#include <linux/parser.h>",
            "#include <linux/compat.h>",
            "#include <linux/statfs.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/mpage.h>",
            "#include <linux/mount.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/string.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/init.h>",
            "#include <linux/time.h>",
            "#include <linux/highmem.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/module.h>",
            "#include <linux/blkdev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/btrfs.h>\n#include \"qgroup.h\"\n#include \"tests/btrfs-tests.h\"\n#include \"backref.h\"\n#include \"free-space-cache.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"compression.h\"\n#include \"export.h\"\n#include \"volumes.h\"\n#include \"xattr.h\"\n#include \"props.h\"\n#include \"hash.h\"\n#include \"print-tree.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include \"delayed-inode.h\"\n#include <linux/btrfs.h>\n#include <linux/ratelimit.h>\n#include <linux/cleancache.h>\n#include <linux/slab.h>\n#include <linux/magic.h>\n#include <linux/miscdevice.h>\n#include <linux/namei.h>\n#include <linux/ctype.h>\n#include <linux/parser.h>\n#include <linux/compat.h>\n#include <linux/statfs.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/mpage.h>\n#include <linux/mount.h>\n#include <linux/backing-dev.h>\n#include <linux/string.h>\n#include <linux/seq_file.h>\n#include <linux/init.h>\n#include <linux/time.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n#include <linux/buffer_head.h>\n#include <linux/module.h>\n#include <linux/blkdev.h>\n\nvoid btrfs_printk(const struct btrfs_fs_info *fs_info, const char *fmt, ...)\n{\n\tstruct super_block *sb = fs_info->sb;\n\tchar lvl[4];\n\tstruct va_format vaf;\n\tva_list args;\n\tconst char *type = logtypes[4];\n\tint kern_level;\n\n\tva_start(args, fmt);\n\n\tkern_level = printk_get_level(fmt);\n\tif (kern_level) {\n\t\tsize_t size = printk_skip_level(fmt) - fmt;\n\t\tmemcpy(lvl, fmt,  size);\n\t\tlvl[size] = '\\0';\n\t\tfmt += size;\n\t\ttype = logtypes[kern_level - '0'];\n\t} else\n\t\t*lvl = '\\0';\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\tprintk(\"%sBTRFS %s (device %s): %pV\\n\", lvl, type, sb->s_id, &vaf);\n\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "EXT4_INODES_PER_GROUP",
          "args": [
            "sb"
          ],
          "line": 1919
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXT4_BLOCKS_PER_GROUP",
          "args": [
            "sb"
          ],
          "line": 1918
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_opt",
          "args": [
            "sb",
            "DEBUG"
          ],
          "line": 1913
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_commit_super",
          "args": [
            "sb",
            "1"
          ],
          "line": 1911
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_commit_super",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/super.c",
          "lines": "4567-4634",
          "snippet": "static int ext4_commit_super(struct super_block *sb, int sync)\n{\n\tstruct ext4_super_block *es = EXT4_SB(sb)->s_es;\n\tstruct buffer_head *sbh = EXT4_SB(sb)->s_sbh;\n\tint error = 0;\n\n\tif (!sbh || block_device_ejected(sb))\n\t\treturn error;\n\tif (buffer_write_io_error(sbh)) {\n\t\t/*\n\t\t * Oh, dear.  A previous attempt to write the\n\t\t * superblock failed.  This could happen because the\n\t\t * USB device was yanked out.  Or it could happen to\n\t\t * be a transient write error and maybe the block will\n\t\t * be remapped.  Nothing we can do but to retry the\n\t\t * write and hope for the best.\n\t\t */\n\t\text4_msg(sb, KERN_ERR, \"previous I/O error to \"\n\t\t       \"superblock detected\");\n\t\tclear_buffer_write_io_error(sbh);\n\t\tset_buffer_uptodate(sbh);\n\t}\n\t/*\n\t * If the file system is mounted read-only, don't update the\n\t * superblock write time.  This avoids updating the superblock\n\t * write time when we are mounting the root file system\n\t * read/only but we need to replay the journal; at that point,\n\t * for people who are east of GMT and who make their clock\n\t * tick in localtime for Windows bug-for-bug compatibility,\n\t * the clock is set in the future, and this will cause e2fsck\n\t * to complain and force a full file system check.\n\t */\n\tif (!(sb->s_flags & MS_RDONLY))\n\t\tes->s_wtime = cpu_to_le32(get_seconds());\n\tif (sb->s_bdev->bd_part)\n\t\tes->s_kbytes_written =\n\t\t\tcpu_to_le64(EXT4_SB(sb)->s_kbytes_written +\n\t\t\t    ((part_stat_read(sb->s_bdev->bd_part, sectors[1]) -\n\t\t\t      EXT4_SB(sb)->s_sectors_written_start) >> 1));\n\telse\n\t\tes->s_kbytes_written =\n\t\t\tcpu_to_le64(EXT4_SB(sb)->s_kbytes_written);\n\tif (percpu_counter_initialized(&EXT4_SB(sb)->s_freeclusters_counter))\n\t\text4_free_blocks_count_set(es,\n\t\t\tEXT4_C2B(EXT4_SB(sb), percpu_counter_sum_positive(\n\t\t\t\t&EXT4_SB(sb)->s_freeclusters_counter)));\n\tif (percpu_counter_initialized(&EXT4_SB(sb)->s_freeinodes_counter))\n\t\tes->s_free_inodes_count =\n\t\t\tcpu_to_le32(percpu_counter_sum_positive(\n\t\t\t\t&EXT4_SB(sb)->s_freeinodes_counter));\n\tBUFFER_TRACE(sbh, \"marking dirty\");\n\text4_superblock_csum_set(sb);\n\tmark_buffer_dirty(sbh);\n\tif (sync) {\n\t\terror = sync_dirty_buffer(sbh);\n\t\tif (error)\n\t\t\treturn error;\n\n\t\terror = buffer_write_io_error(sbh);\n\t\tif (error) {\n\t\t\text4_msg(sb, KERN_ERR, \"I/O error while writing \"\n\t\t\t       \"superblock\");\n\t\t\tclear_buffer_write_io_error(sbh);\n\t\t\tset_buffer_uptodate(sbh);\n\t\t}\n\t}\n\treturn error;\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"mballoc.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include \"ext4_extents.h\"\t/* Needed for trace points definition */",
            "#include \"ext4.h\"",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/crc16.h>",
            "#include <linux/log2.h>",
            "#include <linux/ctype.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/random.h>",
            "#include <linux/vfs.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/parser.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/time.h>",
            "#include <linux/fs.h>",
            "#include <linux/string.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ext4_show_options(struct seq_file *seq, struct dentry *root);",
            "static int ext4_commit_super(struct super_block *sb, int sync);",
            "static void ext4_mark_recovery_complete(struct super_block *sb,\n\t\t\t\t\tstruct ext4_super_block *es);",
            "static void ext4_clear_journal_err(struct super_block *sb,\n\t\t\t\t   struct ext4_super_block *es);",
            "static int ext4_unfreeze(struct super_block *sb);",
            "static int ext4_freeze(struct super_block *sb);",
            "static inline int ext2_feature_set_ok(struct super_block *sb);",
            "static inline int ext3_feature_set_ok(struct super_block *sb);",
            "static void ext4_unregister_li_request(struct super_block *sb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"mballoc.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4_extents.h\"\t/* Needed for trace points definition */\n#include \"ext4.h\"\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <asm/uaccess.h>\n#include <linux/cleancache.h>\n#include <linux/crc16.h>\n#include <linux/log2.h>\n#include <linux/ctype.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/random.h>\n#include <linux/vfs.h>\n#include <linux/exportfs.h>\n#include <linux/buffer_head.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/jbd2.h>\n#include <linux/vmalloc.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n#include <linux/string.h>\n#include <linux/module.h>\n\nstatic int ext4_show_options(struct seq_file *seq, struct dentry *root);\nstatic int ext4_commit_super(struct super_block *sb, int sync);\nstatic void ext4_mark_recovery_complete(struct super_block *sb,\n\t\t\t\t\tstruct ext4_super_block *es);\nstatic void ext4_clear_journal_err(struct super_block *sb,\n\t\t\t\t   struct ext4_super_block *es);\nstatic int ext4_unfreeze(struct super_block *sb);\nstatic int ext4_freeze(struct super_block *sb);\nstatic inline int ext2_feature_set_ok(struct super_block *sb);\nstatic inline int ext3_feature_set_ok(struct super_block *sb);\nstatic void ext4_unregister_li_request(struct super_block *sb);\n\nstatic int ext4_commit_super(struct super_block *sb, int sync)\n{\n\tstruct ext4_super_block *es = EXT4_SB(sb)->s_es;\n\tstruct buffer_head *sbh = EXT4_SB(sb)->s_sbh;\n\tint error = 0;\n\n\tif (!sbh || block_device_ejected(sb))\n\t\treturn error;\n\tif (buffer_write_io_error(sbh)) {\n\t\t/*\n\t\t * Oh, dear.  A previous attempt to write the\n\t\t * superblock failed.  This could happen because the\n\t\t * USB device was yanked out.  Or it could happen to\n\t\t * be a transient write error and maybe the block will\n\t\t * be remapped.  Nothing we can do but to retry the\n\t\t * write and hope for the best.\n\t\t */\n\t\text4_msg(sb, KERN_ERR, \"previous I/O error to \"\n\t\t       \"superblock detected\");\n\t\tclear_buffer_write_io_error(sbh);\n\t\tset_buffer_uptodate(sbh);\n\t}\n\t/*\n\t * If the file system is mounted read-only, don't update the\n\t * superblock write time.  This avoids updating the superblock\n\t * write time when we are mounting the root file system\n\t * read/only but we need to replay the journal; at that point,\n\t * for people who are east of GMT and who make their clock\n\t * tick in localtime for Windows bug-for-bug compatibility,\n\t * the clock is set in the future, and this will cause e2fsck\n\t * to complain and force a full file system check.\n\t */\n\tif (!(sb->s_flags & MS_RDONLY))\n\t\tes->s_wtime = cpu_to_le32(get_seconds());\n\tif (sb->s_bdev->bd_part)\n\t\tes->s_kbytes_written =\n\t\t\tcpu_to_le64(EXT4_SB(sb)->s_kbytes_written +\n\t\t\t    ((part_stat_read(sb->s_bdev->bd_part, sectors[1]) -\n\t\t\t      EXT4_SB(sb)->s_sectors_written_start) >> 1));\n\telse\n\t\tes->s_kbytes_written =\n\t\t\tcpu_to_le64(EXT4_SB(sb)->s_kbytes_written);\n\tif (percpu_counter_initialized(&EXT4_SB(sb)->s_freeclusters_counter))\n\t\text4_free_blocks_count_set(es,\n\t\t\tEXT4_C2B(EXT4_SB(sb), percpu_counter_sum_positive(\n\t\t\t\t&EXT4_SB(sb)->s_freeclusters_counter)));\n\tif (percpu_counter_initialized(&EXT4_SB(sb)->s_freeinodes_counter))\n\t\tes->s_free_inodes_count =\n\t\t\tcpu_to_le32(percpu_counter_sum_positive(\n\t\t\t\t&EXT4_SB(sb)->s_freeinodes_counter));\n\tBUFFER_TRACE(sbh, \"marking dirty\");\n\text4_superblock_csum_set(sb);\n\tmark_buffer_dirty(sbh);\n\tif (sync) {\n\t\terror = sync_dirty_buffer(sbh);\n\t\tif (error)\n\t\t\treturn error;\n\n\t\terror = buffer_write_io_error(sbh);\n\t\tif (error) {\n\t\t\text4_msg(sb, KERN_ERR, \"I/O error while writing \"\n\t\t\t       \"superblock\");\n\t\t\tclear_buffer_write_io_error(sbh);\n\t\t\tset_buffer_uptodate(sbh);\n\t\t}\n\t}\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "EXT4_SET_INCOMPAT_FEATURE",
          "args": [
            "sb",
            "EXT4_FEATURE_INCOMPAT_RECOVER"
          ],
          "line": 1909
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_update_dynamic_rev",
          "args": [
            "sb"
          ],
          "line": 1907
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_update_dynamic_rev",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/super.c",
          "lines": "679-702",
          "snippet": "void ext4_update_dynamic_rev(struct super_block *sb)\n{\n\tstruct ext4_super_block *es = EXT4_SB(sb)->s_es;\n\n\tif (le32_to_cpu(es->s_rev_level) > EXT4_GOOD_OLD_REV)\n\t\treturn;\n\n\text4_warning(sb,\n\t\t     \"updating to rev %d because of new feature flag, \"\n\t\t     \"running e2fsck is recommended\",\n\t\t     EXT4_DYNAMIC_REV);\n\n\tes->s_first_ino = cpu_to_le32(EXT4_GOOD_OLD_FIRST_INO);\n\tes->s_inode_size = cpu_to_le16(EXT4_GOOD_OLD_INODE_SIZE);\n\tes->s_rev_level = cpu_to_le32(EXT4_DYNAMIC_REV);\n\t/* leave es->s_feature_*compat flags alone */\n\t/* es->s_uuid will be set by e2fsck if empty */\n\n\t/*\n\t * The rest of the superblock fields should be zero, and if not it\n\t * means they are likely already in use, so leave them alone.  We\n\t * can leave it up to e2fsck to clean up any inconsistencies there.\n\t */\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"mballoc.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include \"ext4_extents.h\"\t/* Needed for trace points definition */",
            "#include \"ext4.h\"",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/crc16.h>",
            "#include <linux/log2.h>",
            "#include <linux/ctype.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/random.h>",
            "#include <linux/vfs.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/parser.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/time.h>",
            "#include <linux/fs.h>",
            "#include <linux/string.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void ext4_mark_recovery_complete(struct super_block *sb,\n\t\t\t\t\tstruct ext4_super_block *es);",
            "static void ext4_clear_journal_err(struct super_block *sb,\n\t\t\t\t   struct ext4_super_block *es);",
            "static int ext4_unfreeze(struct super_block *sb);",
            "static int ext4_freeze(struct super_block *sb);",
            "static inline int ext2_feature_set_ok(struct super_block *sb);",
            "static inline int ext3_feature_set_ok(struct super_block *sb);",
            "static void ext4_unregister_li_request(struct super_block *sb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"mballoc.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4_extents.h\"\t/* Needed for trace points definition */\n#include \"ext4.h\"\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <asm/uaccess.h>\n#include <linux/cleancache.h>\n#include <linux/crc16.h>\n#include <linux/log2.h>\n#include <linux/ctype.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/random.h>\n#include <linux/vfs.h>\n#include <linux/exportfs.h>\n#include <linux/buffer_head.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/jbd2.h>\n#include <linux/vmalloc.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n#include <linux/string.h>\n#include <linux/module.h>\n\nstatic void ext4_mark_recovery_complete(struct super_block *sb,\n\t\t\t\t\tstruct ext4_super_block *es);\nstatic void ext4_clear_journal_err(struct super_block *sb,\n\t\t\t\t   struct ext4_super_block *es);\nstatic int ext4_unfreeze(struct super_block *sb);\nstatic int ext4_freeze(struct super_block *sb);\nstatic inline int ext2_feature_set_ok(struct super_block *sb);\nstatic inline int ext3_feature_set_ok(struct super_block *sb);\nstatic void ext4_unregister_li_request(struct super_block *sb);\n\nvoid ext4_update_dynamic_rev(struct super_block *sb)\n{\n\tstruct ext4_super_block *es = EXT4_SB(sb)->s_es;\n\n\tif (le32_to_cpu(es->s_rev_level) > EXT4_GOOD_OLD_REV)\n\t\treturn;\n\n\text4_warning(sb,\n\t\t     \"updating to rev %d because of new feature flag, \"\n\t\t     \"running e2fsck is recommended\",\n\t\t     EXT4_DYNAMIC_REV);\n\n\tes->s_first_ino = cpu_to_le32(EXT4_GOOD_OLD_FIRST_INO);\n\tes->s_inode_size = cpu_to_le16(EXT4_GOOD_OLD_INODE_SIZE);\n\tes->s_rev_level = cpu_to_le32(EXT4_DYNAMIC_REV);\n\t/* leave es->s_feature_*compat flags alone */\n\t/* es->s_uuid will be set by e2fsck if empty */\n\n\t/*\n\t * The rest of the superblock fields should be zero, and if not it\n\t * means they are likely already in use, so leave them alone.  We\n\t * can leave it up to e2fsck to clean up any inconsistencies there.\n\t */\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "get_seconds()"
          ],
          "line": 1906
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_seconds",
          "args": [],
          "line": 1906
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le16_add_cpu",
          "args": [
            "&es->s_mnt_count",
            "1"
          ],
          "line": 1905
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "EXT4_DFL_MAX_MNT_COUNT"
          ],
          "line": 1904
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le16_to_cpu",
          "args": [
            "es->s_max_mnt_count"
          ],
          "line": 1903
        },
        "resolved": true,
        "details": {
          "function_name": "sle16_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "48-51",
          "snippet": "static inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "~EXT4_VALID_FS"
          ],
          "line": 1902
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_msg",
          "args": [
            "sb",
            "KERN_WARNING",
            "\"warning: checktime reached, \"\n\t\t\t \"running e2fsck is recommended\""
          ],
          "line": 1898
        },
        "resolved": true,
        "details": {
          "function_name": "__ext4_msg",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/super.c",
          "lines": "593-607",
          "snippet": "void __ext4_msg(struct super_block *sb,\n\t\tconst char *prefix, const char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tif (!___ratelimit(&(EXT4_SB(sb)->s_msg_ratelimit_state), \"EXT4-fs\"))\n\t\treturn;\n\n\tva_start(args, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\tprintk(\"%sEXT4-fs (%s): %pV\\n\", prefix, sb->s_id, &vaf);\n\tva_end(args);\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"mballoc.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include \"ext4_extents.h\"\t/* Needed for trace points definition */",
            "#include \"ext4.h\"",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/crc16.h>",
            "#include <linux/log2.h>",
            "#include <linux/ctype.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/random.h>",
            "#include <linux/vfs.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/parser.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/time.h>",
            "#include <linux/fs.h>",
            "#include <linux/string.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ext4_unfreeze(struct super_block *sb);",
            "static int ext4_freeze(struct super_block *sb);",
            "static inline int ext2_feature_set_ok(struct super_block *sb);",
            "static inline int ext3_feature_set_ok(struct super_block *sb);",
            "static void ext4_unregister_li_request(struct super_block *sb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"mballoc.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4_extents.h\"\t/* Needed for trace points definition */\n#include \"ext4.h\"\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <asm/uaccess.h>\n#include <linux/cleancache.h>\n#include <linux/crc16.h>\n#include <linux/log2.h>\n#include <linux/ctype.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/random.h>\n#include <linux/vfs.h>\n#include <linux/exportfs.h>\n#include <linux/buffer_head.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/jbd2.h>\n#include <linux/vmalloc.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n#include <linux/string.h>\n#include <linux/module.h>\n\nstatic int ext4_unfreeze(struct super_block *sb);\nstatic int ext4_freeze(struct super_block *sb);\nstatic inline int ext2_feature_set_ok(struct super_block *sb);\nstatic inline int ext3_feature_set_ok(struct super_block *sb);\nstatic void ext4_unregister_li_request(struct super_block *sb);\n\nvoid __ext4_msg(struct super_block *sb,\n\t\tconst char *prefix, const char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tif (!___ratelimit(&(EXT4_SB(sb)->s_msg_ratelimit_state), \"EXT4-fs\"))\n\t\treturn;\n\n\tva_start(args, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\tprintk(\"%sEXT4-fs (%s): %pV\\n\", prefix, sb->s_id, &vaf);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_seconds",
          "args": [],
          "line": 1897
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "es->s_checkinterval"
          ],
          "line": 1897
        },
        "resolved": true,
        "details": {
          "function_name": "sle32_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "53-56",
          "snippet": "static inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "EXT4_SB",
          "args": [
            "sb"
          ],
          "line": 1872
        },
        "resolved": true,
        "details": {
          "function_name": "EXT4_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ext4.h",
          "lines": "1356-1359",
          "snippet": "static inline struct ext4_sb_info *EXT4_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include \"extents_status.h\"",
            "#include <linux/compat.h>",
            "#include <linux/falloc.h>",
            "#include <crypto/hash.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/wait.h>",
            "#include <linux/timer.h>",
            "#include <linux/mutex.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/quota.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extents_status.h\"\n#include <linux/compat.h>\n#include <linux/falloc.h>\n#include <crypto/hash.h>\n#include <linux/ratelimit.h>\n#include <linux/percpu_counter.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/wait.h>\n#include <linux/timer.h>\n#include <linux/mutex.h>\n#include <linux/seqlock.h>\n#include <linux/rbtree.h>\n#include <linux/rwsem.h>\n#include <linux/quota.h>\n#include <linux/jbd2.h>\n#include <linux/magic.h>\n#include <linux/blkdev.h>\n#include <linux/types.h>\n\nstatic inline struct ext4_sb_info *EXT4_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"mballoc.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4_extents.h\"\t/* Needed for trace points definition */\n#include \"ext4.h\"\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <asm/uaccess.h>\n#include <linux/cleancache.h>\n#include <linux/crc16.h>\n#include <linux/log2.h>\n#include <linux/ctype.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/random.h>\n#include <linux/vfs.h>\n#include <linux/exportfs.h>\n#include <linux/buffer_head.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/jbd2.h>\n#include <linux/vmalloc.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n#include <linux/string.h>\n#include <linux/module.h>\n\nstatic void ext4_mark_recovery_complete(struct super_block *sb,\n\t\t\t\t\tstruct ext4_super_block *es);\nstatic void ext4_clear_journal_err(struct super_block *sb,\n\t\t\t\t   struct ext4_super_block *es);\nstatic int ext4_unfreeze(struct super_block *sb);\nstatic int ext4_freeze(struct super_block *sb);\nstatic inline int ext2_feature_set_ok(struct super_block *sb);\nstatic inline int ext3_feature_set_ok(struct super_block *sb);\nstatic void ext4_unregister_li_request(struct super_block *sb);\n\nstatic int ext4_setup_super(struct super_block *sb, struct ext4_super_block *es,\n\t\t\t    int read_only)\n{\n\tstruct ext4_sb_info *sbi = EXT4_SB(sb);\n\tint res = 0;\n\n\tif (le32_to_cpu(es->s_rev_level) > EXT4_MAX_SUPP_REV) {\n\t\text4_msg(sb, KERN_ERR, \"revision level too high, \"\n\t\t\t \"forcing read-only mode\");\n\t\tres = MS_RDONLY;\n\t}\n\tif (read_only)\n\t\tgoto done;\n\tif (!(sbi->s_mount_state & EXT4_VALID_FS))\n\t\text4_msg(sb, KERN_WARNING, \"warning: mounting unchecked fs, \"\n\t\t\t \"running e2fsck is recommended\");\n\telse if (sbi->s_mount_state & EXT4_ERROR_FS)\n\t\text4_msg(sb, KERN_WARNING,\n\t\t\t \"warning: mounting fs with errors, \"\n\t\t\t \"running e2fsck is recommended\");\n\telse if ((__s16) le16_to_cpu(es->s_max_mnt_count) > 0 &&\n\t\t le16_to_cpu(es->s_mnt_count) >=\n\t\t (unsigned short) (__s16) le16_to_cpu(es->s_max_mnt_count))\n\t\text4_msg(sb, KERN_WARNING,\n\t\t\t \"warning: maximal mount count reached, \"\n\t\t\t \"running e2fsck is recommended\");\n\telse if (le32_to_cpu(es->s_checkinterval) &&\n\t\t(le32_to_cpu(es->s_lastcheck) +\n\t\t\tle32_to_cpu(es->s_checkinterval) <= get_seconds()))\n\t\text4_msg(sb, KERN_WARNING,\n\t\t\t \"warning: checktime reached, \"\n\t\t\t \"running e2fsck is recommended\");\n\tif (!sbi->s_journal)\n\t\tes->s_state &= cpu_to_le16(~EXT4_VALID_FS);\n\tif (!(__s16) le16_to_cpu(es->s_max_mnt_count))\n\t\tes->s_max_mnt_count = cpu_to_le16(EXT4_DFL_MAX_MNT_COUNT);\n\tle16_add_cpu(&es->s_mnt_count, 1);\n\tes->s_mtime = cpu_to_le32(get_seconds());\n\text4_update_dynamic_rev(sb);\n\tif (sbi->s_journal)\n\t\tEXT4_SET_INCOMPAT_FEATURE(sb, EXT4_FEATURE_INCOMPAT_RECOVER);\n\n\text4_commit_super(sb, 1);\ndone:\n\tif (test_opt(sb, DEBUG))\n\t\tprintk(KERN_INFO \"[EXT4 FS bs=%lu, gc=%u, \"\n\t\t\t\t\"bpg=%lu, ipg=%lu, mo=%04x, mo2=%04x]\\n\",\n\t\t\tsb->s_blocksize,\n\t\t\tsbi->s_groups_count,\n\t\t\tEXT4_BLOCKS_PER_GROUP(sb),\n\t\t\tEXT4_INODES_PER_GROUP(sb),\n\t\t\tsbi->s_mount_opt, sbi->s_mount_opt2);\n\n\tcleancache_init_fs(sb);\n\treturn res;\n}"
  },
  {
    "function_name": "options_open_fs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/super.c",
    "lines": "1856-1859",
    "snippet": "static int options_open_fs(struct inode *inode, struct file *file)\n{\n\treturn single_open(file, options_seq_show, PDE_DATA(inode));\n}",
    "includes": [
      "#include <trace/events/ext4.h>",
      "#include \"mballoc.h\"",
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"ext4_jbd2.h\"",
      "#include \"ext4_extents.h\"\t/* Needed for trace points definition */",
      "#include \"ext4.h\"",
      "#include <linux/freezer.h>",
      "#include <linux/kthread.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/cleancache.h>",
      "#include <linux/crc16.h>",
      "#include <linux/log2.h>",
      "#include <linux/ctype.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/namei.h>",
      "#include <linux/mount.h>",
      "#include <linux/random.h>",
      "#include <linux/vfs.h>",
      "#include <linux/exportfs.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/parser.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/init.h>",
      "#include <linux/slab.h>",
      "#include <linux/jbd2.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/time.h>",
      "#include <linux/fs.h>",
      "#include <linux/string.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "single_open",
          "args": [
            "file",
            "options_seq_show",
            "PDE_DATA(inode)"
          ],
          "line": 1858
        },
        "resolved": true,
        "details": {
          "function_name": "single_open",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/seq_file.c",
          "lines": "557-575",
          "snippet": "int single_open(struct file *file, int (*show)(struct seq_file *, void *),\n\t\tvoid *data)\n{\n\tstruct seq_operations *op = kmalloc(sizeof(*op), GFP_KERNEL);\n\tint res = -ENOMEM;\n\n\tif (op) {\n\t\top->start = single_start;\n\t\top->next = single_next;\n\t\top->stop = single_stop;\n\t\top->show = show;\n\t\tres = seq_open(file, op);\n\t\tif (!res)\n\t\t\t((struct seq_file *)file->private_data)->private = data;\n\t\telse\n\t\t\tkfree(op);\n\t}\n\treturn res;\n}",
          "includes": [
            "#include <asm/page.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/mm.h>",
            "#include <linux/cred.h>",
            "#include <linux/slab.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/export.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <linux/mm.h>\n#include <linux/cred.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/seq_file.h>\n#include <linux/export.h>\n#include <linux/fs.h>\n\nint single_open(struct file *file, int (*show)(struct seq_file *, void *),\n\t\tvoid *data)\n{\n\tstruct seq_operations *op = kmalloc(sizeof(*op), GFP_KERNEL);\n\tint res = -ENOMEM;\n\n\tif (op) {\n\t\top->start = single_start;\n\t\top->next = single_next;\n\t\top->stop = single_stop;\n\t\top->show = show;\n\t\tres = seq_open(file, op);\n\t\tif (!res)\n\t\t\t((struct seq_file *)file->private_data)->private = data;\n\t\telse\n\t\t\tkfree(op);\n\t}\n\treturn res;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PDE_DATA",
          "args": [
            "inode"
          ],
          "line": 1858
        },
        "resolved": true,
        "details": {
          "function_name": "__PDE_DATA",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/internal.h",
          "lines": "85-88",
          "snippet": "static inline void *__PDE_DATA(const struct inode *inode)\n{\n\treturn PDE(inode)->data;\n}",
          "includes": [
            "#include <linux/binfmts.h>",
            "#include <linux/atomic.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/proc_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/binfmts.h>\n#include <linux/atomic.h>\n#include <linux/spinlock.h>\n#include <linux/proc_ns.h>\n#include <linux/proc_fs.h>\n\nstatic inline void *__PDE_DATA(const struct inode *inode)\n{\n\treturn PDE(inode)->data;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"mballoc.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4_extents.h\"\t/* Needed for trace points definition */\n#include \"ext4.h\"\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <asm/uaccess.h>\n#include <linux/cleancache.h>\n#include <linux/crc16.h>\n#include <linux/log2.h>\n#include <linux/ctype.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/random.h>\n#include <linux/vfs.h>\n#include <linux/exportfs.h>\n#include <linux/buffer_head.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/jbd2.h>\n#include <linux/vmalloc.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n#include <linux/string.h>\n#include <linux/module.h>\n\nstatic int options_open_fs(struct inode *inode, struct file *file)\n{\n\treturn single_open(file, options_seq_show, PDE_DATA(inode));\n}"
  },
  {
    "function_name": "options_seq_show",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/super.c",
    "lines": "1845-1854",
    "snippet": "static int options_seq_show(struct seq_file *seq, void *offset)\n{\n\tstruct super_block *sb = seq->private;\n\tint rc;\n\n\tseq_puts(seq, (sb->s_flags & MS_RDONLY) ? \"ro\" : \"rw\");\n\trc = _ext4_show_options(seq, sb, 1);\n\tseq_puts(seq, \"\\n\");\n\treturn rc;\n}",
    "includes": [
      "#include <trace/events/ext4.h>",
      "#include \"mballoc.h\"",
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"ext4_jbd2.h\"",
      "#include \"ext4_extents.h\"\t/* Needed for trace points definition */",
      "#include \"ext4.h\"",
      "#include <linux/freezer.h>",
      "#include <linux/kthread.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/cleancache.h>",
      "#include <linux/crc16.h>",
      "#include <linux/log2.h>",
      "#include <linux/ctype.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/namei.h>",
      "#include <linux/mount.h>",
      "#include <linux/random.h>",
      "#include <linux/vfs.h>",
      "#include <linux/exportfs.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/parser.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/init.h>",
      "#include <linux/slab.h>",
      "#include <linux/jbd2.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/time.h>",
      "#include <linux/fs.h>",
      "#include <linux/string.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ext4_unfreeze(struct super_block *sb);",
      "static int ext4_freeze(struct super_block *sb);",
      "static inline int ext2_feature_set_ok(struct super_block *sb);",
      "static inline int ext3_feature_set_ok(struct super_block *sb);",
      "static void ext4_unregister_li_request(struct super_block *sb);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "seq_puts",
          "args": [
            "seq",
            "\"\\n\""
          ],
          "line": 1852
        },
        "resolved": true,
        "details": {
          "function_name": "seq_puts",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/seq_file.c",
          "lines": "658-668",
          "snippet": "int seq_puts(struct seq_file *m, const char *s)\n{\n\tint len = strlen(s);\n\tif (m->count + len < m->size) {\n\t\tmemcpy(m->buf + m->count, s, len);\n\t\tm->count += len;\n\t\treturn 0;\n\t}\n\tseq_set_overflow(m);\n\treturn -1;\n}",
          "includes": [
            "#include <asm/page.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/mm.h>",
            "#include <linux/cred.h>",
            "#include <linux/slab.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/export.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <linux/mm.h>\n#include <linux/cred.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/seq_file.h>\n#include <linux/export.h>\n#include <linux/fs.h>\n\nint seq_puts(struct seq_file *m, const char *s)\n{\n\tint len = strlen(s);\n\tif (m->count + len < m->size) {\n\t\tmemcpy(m->buf + m->count, s, len);\n\t\tm->count += len;\n\t\treturn 0;\n\t}\n\tseq_set_overflow(m);\n\treturn -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "_ext4_show_options",
          "args": [
            "seq",
            "sb",
            "1"
          ],
          "line": 1851
        },
        "resolved": true,
        "details": {
          "function_name": "_ext4_show_options",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/super.c",
          "lines": "1763-1838",
          "snippet": "static int _ext4_show_options(struct seq_file *seq, struct super_block *sb,\n\t\t\t      int nodefs)\n{\n\tstruct ext4_sb_info *sbi = EXT4_SB(sb);\n\tstruct ext4_super_block *es = sbi->s_es;\n\tint def_errors, def_mount_opt = nodefs ? 0 : sbi->s_def_mount_opt;\n\tconst struct mount_opts *m;\n\tchar sep = nodefs ? '\\n' : ',';\n\n#define SEQ_OPTS_PUTS(str) seq_printf(seq, \"%c\" str, sep)\n#define SEQ_OPTS_PRINT(str, arg) seq_printf(seq, \"%c\" str, sep, arg)\n\n\tif (sbi->s_sb_block != 1)\n\t\tSEQ_OPTS_PRINT(\"sb=%llu\", sbi->s_sb_block);\n\n\tfor (m = ext4_mount_opts; m->token != Opt_err; m++) {\n\t\tint want_set = m->flags & MOPT_SET;\n\t\tif (((m->flags & (MOPT_SET|MOPT_CLEAR)) == 0) ||\n\t\t    (m->flags & MOPT_CLEAR_ERR))\n\t\t\tcontinue;\n\t\tif (!(m->mount_opt & (sbi->s_mount_opt ^ def_mount_opt)))\n\t\t\tcontinue; /* skip if same as the default */\n\t\tif ((want_set &&\n\t\t     (sbi->s_mount_opt & m->mount_opt) != m->mount_opt) ||\n\t\t    (!want_set && (sbi->s_mount_opt & m->mount_opt)))\n\t\t\tcontinue; /* select Opt_noFoo vs Opt_Foo */\n\t\tSEQ_OPTS_PRINT(\"%s\", token2str(m->token));\n\t}\n\n\tif (nodefs || !uid_eq(sbi->s_resuid, make_kuid(&init_user_ns, EXT4_DEF_RESUID)) ||\n\t    le16_to_cpu(es->s_def_resuid) != EXT4_DEF_RESUID)\n\t\tSEQ_OPTS_PRINT(\"resuid=%u\",\n\t\t\t\tfrom_kuid_munged(&init_user_ns, sbi->s_resuid));\n\tif (nodefs || !gid_eq(sbi->s_resgid, make_kgid(&init_user_ns, EXT4_DEF_RESGID)) ||\n\t    le16_to_cpu(es->s_def_resgid) != EXT4_DEF_RESGID)\n\t\tSEQ_OPTS_PRINT(\"resgid=%u\",\n\t\t\t\tfrom_kgid_munged(&init_user_ns, sbi->s_resgid));\n\tdef_errors = nodefs ? -1 : le16_to_cpu(es->s_errors);\n\tif (test_opt(sb, ERRORS_RO) && def_errors != EXT4_ERRORS_RO)\n\t\tSEQ_OPTS_PUTS(\"errors=remount-ro\");\n\tif (test_opt(sb, ERRORS_CONT) && def_errors != EXT4_ERRORS_CONTINUE)\n\t\tSEQ_OPTS_PUTS(\"errors=continue\");\n\tif (test_opt(sb, ERRORS_PANIC) && def_errors != EXT4_ERRORS_PANIC)\n\t\tSEQ_OPTS_PUTS(\"errors=panic\");\n\tif (nodefs || sbi->s_commit_interval != JBD2_DEFAULT_MAX_COMMIT_AGE*HZ)\n\t\tSEQ_OPTS_PRINT(\"commit=%lu\", sbi->s_commit_interval / HZ);\n\tif (nodefs || sbi->s_min_batch_time != EXT4_DEF_MIN_BATCH_TIME)\n\t\tSEQ_OPTS_PRINT(\"min_batch_time=%u\", sbi->s_min_batch_time);\n\tif (nodefs || sbi->s_max_batch_time != EXT4_DEF_MAX_BATCH_TIME)\n\t\tSEQ_OPTS_PRINT(\"max_batch_time=%u\", sbi->s_max_batch_time);\n\tif (sb->s_flags & MS_I_VERSION)\n\t\tSEQ_OPTS_PUTS(\"i_version\");\n\tif (nodefs || sbi->s_stripe)\n\t\tSEQ_OPTS_PRINT(\"stripe=%lu\", sbi->s_stripe);\n\tif (EXT4_MOUNT_DATA_FLAGS & (sbi->s_mount_opt ^ def_mount_opt)) {\n\t\tif (test_opt(sb, DATA_FLAGS) == EXT4_MOUNT_JOURNAL_DATA)\n\t\t\tSEQ_OPTS_PUTS(\"data=journal\");\n\t\telse if (test_opt(sb, DATA_FLAGS) == EXT4_MOUNT_ORDERED_DATA)\n\t\t\tSEQ_OPTS_PUTS(\"data=ordered\");\n\t\telse if (test_opt(sb, DATA_FLAGS) == EXT4_MOUNT_WRITEBACK_DATA)\n\t\t\tSEQ_OPTS_PUTS(\"data=writeback\");\n\t}\n\tif (nodefs ||\n\t    sbi->s_inode_readahead_blks != EXT4_DEF_INODE_READAHEAD_BLKS)\n\t\tSEQ_OPTS_PRINT(\"inode_readahead_blks=%u\",\n\t\t\t       sbi->s_inode_readahead_blks);\n\n\tif (nodefs || (test_opt(sb, INIT_INODE_TABLE) &&\n\t\t       (sbi->s_li_wait_mult != EXT4_DEF_LI_WAIT_MULT)))\n\t\tSEQ_OPTS_PRINT(\"init_itable=%u\", sbi->s_li_wait_mult);\n\tif (nodefs || sbi->s_max_dir_size_kb)\n\t\tSEQ_OPTS_PRINT(\"max_dir_size_kb=%u\", sbi->s_max_dir_size_kb);\n\n\text4_show_quota_options(seq, sb);\n\treturn 0;\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"mballoc.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include \"ext4_extents.h\"\t/* Needed for trace points definition */",
            "#include \"ext4.h\"",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/crc16.h>",
            "#include <linux/log2.h>",
            "#include <linux/ctype.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/random.h>",
            "#include <linux/vfs.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/parser.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/time.h>",
            "#include <linux/fs.h>",
            "#include <linux/string.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [
            "#define MOPT_CLEAR_ERR\t0x0010",
            "#define MOPT_CLEAR\t0x0002",
            "#define MOPT_SET\t0x0001"
          ],
          "globals_used": [
            "static void ext4_mark_recovery_complete(struct super_block *sb,\n\t\t\t\t\tstruct ext4_super_block *es);",
            "static void ext4_clear_journal_err(struct super_block *sb,\n\t\t\t\t   struct ext4_super_block *es);",
            "static int ext4_remount(struct super_block *sb, int *flags, char *data);",
            "static int ext4_unfreeze(struct super_block *sb);",
            "static int ext4_freeze(struct super_block *sb);",
            "static struct dentry *ext4_mount(struct file_system_type *fs_type, int flags,\n\t\t       const char *dev_name, void *data);",
            "static inline int ext2_feature_set_ok(struct super_block *sb);",
            "static inline int ext3_feature_set_ok(struct super_block *sb);",
            "static void ext4_unregister_li_request(struct super_block *sb);",
            "static const struct mount_opts {\n\tint\ttoken;\n\tint\tmount_opt;\n\tint\tflags;\n} ext4_mount_opts[] = {\n\t{Opt_minix_df, EXT4_MOUNT_MINIX_DF, MOPT_SET},\n\t{Opt_bsd_df, EXT4_MOUNT_MINIX_DF, MOPT_CLEAR},\n\t{Opt_grpid, EXT4_MOUNT_GRPID, MOPT_SET},\n\t{Opt_nogrpid, EXT4_MOUNT_GRPID, MOPT_CLEAR},\n\t{Opt_block_validity, EXT4_MOUNT_BLOCK_VALIDITY, MOPT_SET},\n\t{Opt_noblock_validity, EXT4_MOUNT_BLOCK_VALIDITY, MOPT_CLEAR},\n\t{Opt_dioread_nolock, EXT4_MOUNT_DIOREAD_NOLOCK,\n\t MOPT_EXT4_ONLY | MOPT_SET},\n\t{Opt_dioread_lock, EXT4_MOUNT_DIOREAD_NOLOCK,\n\t MOPT_EXT4_ONLY | MOPT_CLEAR},\n\t{Opt_discard, EXT4_MOUNT_DISCARD, MOPT_SET},\n\t{Opt_nodiscard, EXT4_MOUNT_DISCARD, MOPT_CLEAR},\n\t{Opt_delalloc, EXT4_MOUNT_DELALLOC,\n\t MOPT_EXT4_ONLY | MOPT_SET | MOPT_EXPLICIT},\n\t{Opt_nodelalloc, EXT4_MOUNT_DELALLOC,\n\t MOPT_EXT4_ONLY | MOPT_CLEAR},\n\t{Opt_nojournal_checksum, EXT4_MOUNT_JOURNAL_CHECKSUM,\n\t MOPT_EXT4_ONLY | MOPT_CLEAR},\n\t{Opt_journal_checksum, EXT4_MOUNT_JOURNAL_CHECKSUM,\n\t MOPT_EXT4_ONLY | MOPT_SET},\n\t{Opt_journal_async_commit, (EXT4_MOUNT_JOURNAL_ASYNC_COMMIT |\n\t\t\t\t    EXT4_MOUNT_JOURNAL_CHECKSUM),\n\t MOPT_EXT4_ONLY | MOPT_SET},\n\t{Opt_noload, EXT4_MOUNT_NOLOAD, MOPT_NO_EXT2 | MOPT_SET},\n\t{Opt_err_panic, EXT4_MOUNT_ERRORS_PANIC, MOPT_SET | MOPT_CLEAR_ERR},\n\t{Opt_err_ro, EXT4_MOUNT_ERRORS_RO, MOPT_SET | MOPT_CLEAR_ERR},\n\t{Opt_err_cont, EXT4_MOUNT_ERRORS_CONT, MOPT_SET | MOPT_CLEAR_ERR},\n\t{Opt_data_err_abort, EXT4_MOUNT_DATA_ERR_ABORT,\n\t MOPT_NO_EXT2 | MOPT_SET},\n\t{Opt_data_err_ignore, EXT4_MOUNT_DATA_ERR_ABORT,\n\t MOPT_NO_EXT2 | MOPT_CLEAR},\n\t{Opt_barrier, EXT4_MOUNT_BARRIER, MOPT_SET},\n\t{Opt_nobarrier, EXT4_MOUNT_BARRIER, MOPT_CLEAR},\n\t{Opt_noauto_da_alloc, EXT4_MOUNT_NO_AUTO_DA_ALLOC, MOPT_SET},\n\t{Opt_auto_da_alloc, EXT4_MOUNT_NO_AUTO_DA_ALLOC, MOPT_CLEAR},\n\t{Opt_noinit_itable, EXT4_MOUNT_INIT_INODE_TABLE, MOPT_CLEAR},\n\t{Opt_commit, 0, MOPT_GTE0},\n\t{Opt_max_batch_time, 0, MOPT_GTE0},\n\t{Opt_min_batch_time, 0, MOPT_GTE0},\n\t{Opt_inode_readahead_blks, 0, MOPT_GTE0},\n\t{Opt_init_itable, 0, MOPT_GTE0},\n\t{Opt_dax, EXT4_MOUNT_DAX, MOPT_SET},\n\t{Opt_stripe, 0, MOPT_GTE0},\n\t{Opt_resuid, 0, MOPT_GTE0},\n\t{Opt_resgid, 0, MOPT_GTE0},\n\t{Opt_journal_dev, 0, MOPT_GTE0},\n\t{Opt_journal_path, 0, MOPT_STRING},\n\t{Opt_journal_ioprio, 0, MOPT_GTE0},\n\t{Opt_data_journal, EXT4_MOUNT_JOURNAL_DATA, MOPT_NO_EXT2 | MOPT_DATAJ},\n\t{Opt_data_ordered, EXT4_MOUNT_ORDERED_DATA, MOPT_NO_EXT2 | MOPT_DATAJ},\n\t{Opt_data_writeback, EXT4_MOUNT_WRITEBACK_DATA,\n\t MOPT_NO_EXT2 | MOPT_DATAJ},\n\t{Opt_user_xattr, EXT4_MOUNT_XATTR_USER, MOPT_SET},\n\t{Opt_nouser_xattr, EXT4_MOUNT_XATTR_USER, MOPT_CLEAR},\n#ifdef CONFIG_EXT4_FS_POSIX_ACL\n\t{Opt_acl, EXT4_MOUNT_POSIX_ACL, MOPT_SET},\n\t{Opt_noacl, EXT4_MOUNT_POSIX_ACL, MOPT_CLEAR},\n#else\n\t{Opt_acl, 0, MOPT_NOSUPPORT},\n\t{Opt_noacl, 0, MOPT_NOSUPPORT},\n#endif\n\t{Opt_nouid32, EXT4_MOUNT_NO_UID32, MOPT_SET},\n\t{Opt_debug, EXT4_MOUNT_DEBUG, MOPT_SET},\n\t{Opt_quota, EXT4_MOUNT_QUOTA | EXT4_MOUNT_USRQUOTA, MOPT_SET | MOPT_Q},\n\t{Opt_usrquota, EXT4_MOUNT_QUOTA | EXT4_MOUNT_USRQUOTA,\n\t\t\t\t\t\t\tMOPT_SET | MOPT_Q},\n\t{Opt_grpquota, EXT4_MOUNT_QUOTA | EXT4_MOUNT_GRPQUOTA,\n\t\t\t\t\t\t\tMOPT_SET | MOPT_Q},\n\t{Opt_noquota, (EXT4_MOUNT_QUOTA | EXT4_MOUNT_USRQUOTA |\n\t\t       EXT4_MOUNT_GRPQUOTA), MOPT_CLEAR | MOPT_Q},\n\t{Opt_usrjquota, 0, MOPT_Q},\n\t{Opt_grpjquota, 0, MOPT_Q},\n\t{Opt_offusrjquota, 0, MOPT_Q},\n\t{Opt_offgrpjquota, 0, MOPT_Q},\n\t{Opt_jqfmt_vfsold, QFMT_VFS_OLD, MOPT_QFMT},\n\t{Opt_jqfmt_vfsv0, QFMT_VFS_V0, MOPT_QFMT},\n\t{Opt_jqfmt_vfsv1, QFMT_VFS_V1, MOPT_QFMT},\n\t{Opt_max_dir_size_kb, 0, MOPT_GTE0},\n\t{Opt_err, 0, 0}\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"mballoc.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4_extents.h\"\t/* Needed for trace points definition */\n#include \"ext4.h\"\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <asm/uaccess.h>\n#include <linux/cleancache.h>\n#include <linux/crc16.h>\n#include <linux/log2.h>\n#include <linux/ctype.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/random.h>\n#include <linux/vfs.h>\n#include <linux/exportfs.h>\n#include <linux/buffer_head.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/jbd2.h>\n#include <linux/vmalloc.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n#include <linux/string.h>\n#include <linux/module.h>\n\n#define MOPT_CLEAR_ERR\t0x0010\n#define MOPT_CLEAR\t0x0002\n#define MOPT_SET\t0x0001\n\nstatic void ext4_mark_recovery_complete(struct super_block *sb,\n\t\t\t\t\tstruct ext4_super_block *es);\nstatic void ext4_clear_journal_err(struct super_block *sb,\n\t\t\t\t   struct ext4_super_block *es);\nstatic int ext4_remount(struct super_block *sb, int *flags, char *data);\nstatic int ext4_unfreeze(struct super_block *sb);\nstatic int ext4_freeze(struct super_block *sb);\nstatic struct dentry *ext4_mount(struct file_system_type *fs_type, int flags,\n\t\t       const char *dev_name, void *data);\nstatic inline int ext2_feature_set_ok(struct super_block *sb);\nstatic inline int ext3_feature_set_ok(struct super_block *sb);\nstatic void ext4_unregister_li_request(struct super_block *sb);\nstatic const struct mount_opts {\n\tint\ttoken;\n\tint\tmount_opt;\n\tint\tflags;\n} ext4_mount_opts[] = {\n\t{Opt_minix_df, EXT4_MOUNT_MINIX_DF, MOPT_SET},\n\t{Opt_bsd_df, EXT4_MOUNT_MINIX_DF, MOPT_CLEAR},\n\t{Opt_grpid, EXT4_MOUNT_GRPID, MOPT_SET},\n\t{Opt_nogrpid, EXT4_MOUNT_GRPID, MOPT_CLEAR},\n\t{Opt_block_validity, EXT4_MOUNT_BLOCK_VALIDITY, MOPT_SET},\n\t{Opt_noblock_validity, EXT4_MOUNT_BLOCK_VALIDITY, MOPT_CLEAR},\n\t{Opt_dioread_nolock, EXT4_MOUNT_DIOREAD_NOLOCK,\n\t MOPT_EXT4_ONLY | MOPT_SET},\n\t{Opt_dioread_lock, EXT4_MOUNT_DIOREAD_NOLOCK,\n\t MOPT_EXT4_ONLY | MOPT_CLEAR},\n\t{Opt_discard, EXT4_MOUNT_DISCARD, MOPT_SET},\n\t{Opt_nodiscard, EXT4_MOUNT_DISCARD, MOPT_CLEAR},\n\t{Opt_delalloc, EXT4_MOUNT_DELALLOC,\n\t MOPT_EXT4_ONLY | MOPT_SET | MOPT_EXPLICIT},\n\t{Opt_nodelalloc, EXT4_MOUNT_DELALLOC,\n\t MOPT_EXT4_ONLY | MOPT_CLEAR},\n\t{Opt_nojournal_checksum, EXT4_MOUNT_JOURNAL_CHECKSUM,\n\t MOPT_EXT4_ONLY | MOPT_CLEAR},\n\t{Opt_journal_checksum, EXT4_MOUNT_JOURNAL_CHECKSUM,\n\t MOPT_EXT4_ONLY | MOPT_SET},\n\t{Opt_journal_async_commit, (EXT4_MOUNT_JOURNAL_ASYNC_COMMIT |\n\t\t\t\t    EXT4_MOUNT_JOURNAL_CHECKSUM),\n\t MOPT_EXT4_ONLY | MOPT_SET},\n\t{Opt_noload, EXT4_MOUNT_NOLOAD, MOPT_NO_EXT2 | MOPT_SET},\n\t{Opt_err_panic, EXT4_MOUNT_ERRORS_PANIC, MOPT_SET | MOPT_CLEAR_ERR},\n\t{Opt_err_ro, EXT4_MOUNT_ERRORS_RO, MOPT_SET | MOPT_CLEAR_ERR},\n\t{Opt_err_cont, EXT4_MOUNT_ERRORS_CONT, MOPT_SET | MOPT_CLEAR_ERR},\n\t{Opt_data_err_abort, EXT4_MOUNT_DATA_ERR_ABORT,\n\t MOPT_NO_EXT2 | MOPT_SET},\n\t{Opt_data_err_ignore, EXT4_MOUNT_DATA_ERR_ABORT,\n\t MOPT_NO_EXT2 | MOPT_CLEAR},\n\t{Opt_barrier, EXT4_MOUNT_BARRIER, MOPT_SET},\n\t{Opt_nobarrier, EXT4_MOUNT_BARRIER, MOPT_CLEAR},\n\t{Opt_noauto_da_alloc, EXT4_MOUNT_NO_AUTO_DA_ALLOC, MOPT_SET},\n\t{Opt_auto_da_alloc, EXT4_MOUNT_NO_AUTO_DA_ALLOC, MOPT_CLEAR},\n\t{Opt_noinit_itable, EXT4_MOUNT_INIT_INODE_TABLE, MOPT_CLEAR},\n\t{Opt_commit, 0, MOPT_GTE0},\n\t{Opt_max_batch_time, 0, MOPT_GTE0},\n\t{Opt_min_batch_time, 0, MOPT_GTE0},\n\t{Opt_inode_readahead_blks, 0, MOPT_GTE0},\n\t{Opt_init_itable, 0, MOPT_GTE0},\n\t{Opt_dax, EXT4_MOUNT_DAX, MOPT_SET},\n\t{Opt_stripe, 0, MOPT_GTE0},\n\t{Opt_resuid, 0, MOPT_GTE0},\n\t{Opt_resgid, 0, MOPT_GTE0},\n\t{Opt_journal_dev, 0, MOPT_GTE0},\n\t{Opt_journal_path, 0, MOPT_STRING},\n\t{Opt_journal_ioprio, 0, MOPT_GTE0},\n\t{Opt_data_journal, EXT4_MOUNT_JOURNAL_DATA, MOPT_NO_EXT2 | MOPT_DATAJ},\n\t{Opt_data_ordered, EXT4_MOUNT_ORDERED_DATA, MOPT_NO_EXT2 | MOPT_DATAJ},\n\t{Opt_data_writeback, EXT4_MOUNT_WRITEBACK_DATA,\n\t MOPT_NO_EXT2 | MOPT_DATAJ},\n\t{Opt_user_xattr, EXT4_MOUNT_XATTR_USER, MOPT_SET},\n\t{Opt_nouser_xattr, EXT4_MOUNT_XATTR_USER, MOPT_CLEAR},\n#ifdef CONFIG_EXT4_FS_POSIX_ACL\n\t{Opt_acl, EXT4_MOUNT_POSIX_ACL, MOPT_SET},\n\t{Opt_noacl, EXT4_MOUNT_POSIX_ACL, MOPT_CLEAR},\n#else\n\t{Opt_acl, 0, MOPT_NOSUPPORT},\n\t{Opt_noacl, 0, MOPT_NOSUPPORT},\n#endif\n\t{Opt_nouid32, EXT4_MOUNT_NO_UID32, MOPT_SET},\n\t{Opt_debug, EXT4_MOUNT_DEBUG, MOPT_SET},\n\t{Opt_quota, EXT4_MOUNT_QUOTA | EXT4_MOUNT_USRQUOTA, MOPT_SET | MOPT_Q},\n\t{Opt_usrquota, EXT4_MOUNT_QUOTA | EXT4_MOUNT_USRQUOTA,\n\t\t\t\t\t\t\tMOPT_SET | MOPT_Q},\n\t{Opt_grpquota, EXT4_MOUNT_QUOTA | EXT4_MOUNT_GRPQUOTA,\n\t\t\t\t\t\t\tMOPT_SET | MOPT_Q},\n\t{Opt_noquota, (EXT4_MOUNT_QUOTA | EXT4_MOUNT_USRQUOTA |\n\t\t       EXT4_MOUNT_GRPQUOTA), MOPT_CLEAR | MOPT_Q},\n\t{Opt_usrjquota, 0, MOPT_Q},\n\t{Opt_grpjquota, 0, MOPT_Q},\n\t{Opt_offusrjquota, 0, MOPT_Q},\n\t{Opt_offgrpjquota, 0, MOPT_Q},\n\t{Opt_jqfmt_vfsold, QFMT_VFS_OLD, MOPT_QFMT},\n\t{Opt_jqfmt_vfsv0, QFMT_VFS_V0, MOPT_QFMT},\n\t{Opt_jqfmt_vfsv1, QFMT_VFS_V1, MOPT_QFMT},\n\t{Opt_max_dir_size_kb, 0, MOPT_GTE0},\n\t{Opt_err, 0, 0}\n};\n\nstatic int _ext4_show_options(struct seq_file *seq, struct super_block *sb,\n\t\t\t      int nodefs)\n{\n\tstruct ext4_sb_info *sbi = EXT4_SB(sb);\n\tstruct ext4_super_block *es = sbi->s_es;\n\tint def_errors, def_mount_opt = nodefs ? 0 : sbi->s_def_mount_opt;\n\tconst struct mount_opts *m;\n\tchar sep = nodefs ? '\\n' : ',';\n\n#define SEQ_OPTS_PUTS(str) seq_printf(seq, \"%c\" str, sep)\n#define SEQ_OPTS_PRINT(str, arg) seq_printf(seq, \"%c\" str, sep, arg)\n\n\tif (sbi->s_sb_block != 1)\n\t\tSEQ_OPTS_PRINT(\"sb=%llu\", sbi->s_sb_block);\n\n\tfor (m = ext4_mount_opts; m->token != Opt_err; m++) {\n\t\tint want_set = m->flags & MOPT_SET;\n\t\tif (((m->flags & (MOPT_SET|MOPT_CLEAR)) == 0) ||\n\t\t    (m->flags & MOPT_CLEAR_ERR))\n\t\t\tcontinue;\n\t\tif (!(m->mount_opt & (sbi->s_mount_opt ^ def_mount_opt)))\n\t\t\tcontinue; /* skip if same as the default */\n\t\tif ((want_set &&\n\t\t     (sbi->s_mount_opt & m->mount_opt) != m->mount_opt) ||\n\t\t    (!want_set && (sbi->s_mount_opt & m->mount_opt)))\n\t\t\tcontinue; /* select Opt_noFoo vs Opt_Foo */\n\t\tSEQ_OPTS_PRINT(\"%s\", token2str(m->token));\n\t}\n\n\tif (nodefs || !uid_eq(sbi->s_resuid, make_kuid(&init_user_ns, EXT4_DEF_RESUID)) ||\n\t    le16_to_cpu(es->s_def_resuid) != EXT4_DEF_RESUID)\n\t\tSEQ_OPTS_PRINT(\"resuid=%u\",\n\t\t\t\tfrom_kuid_munged(&init_user_ns, sbi->s_resuid));\n\tif (nodefs || !gid_eq(sbi->s_resgid, make_kgid(&init_user_ns, EXT4_DEF_RESGID)) ||\n\t    le16_to_cpu(es->s_def_resgid) != EXT4_DEF_RESGID)\n\t\tSEQ_OPTS_PRINT(\"resgid=%u\",\n\t\t\t\tfrom_kgid_munged(&init_user_ns, sbi->s_resgid));\n\tdef_errors = nodefs ? -1 : le16_to_cpu(es->s_errors);\n\tif (test_opt(sb, ERRORS_RO) && def_errors != EXT4_ERRORS_RO)\n\t\tSEQ_OPTS_PUTS(\"errors=remount-ro\");\n\tif (test_opt(sb, ERRORS_CONT) && def_errors != EXT4_ERRORS_CONTINUE)\n\t\tSEQ_OPTS_PUTS(\"errors=continue\");\n\tif (test_opt(sb, ERRORS_PANIC) && def_errors != EXT4_ERRORS_PANIC)\n\t\tSEQ_OPTS_PUTS(\"errors=panic\");\n\tif (nodefs || sbi->s_commit_interval != JBD2_DEFAULT_MAX_COMMIT_AGE*HZ)\n\t\tSEQ_OPTS_PRINT(\"commit=%lu\", sbi->s_commit_interval / HZ);\n\tif (nodefs || sbi->s_min_batch_time != EXT4_DEF_MIN_BATCH_TIME)\n\t\tSEQ_OPTS_PRINT(\"min_batch_time=%u\", sbi->s_min_batch_time);\n\tif (nodefs || sbi->s_max_batch_time != EXT4_DEF_MAX_BATCH_TIME)\n\t\tSEQ_OPTS_PRINT(\"max_batch_time=%u\", sbi->s_max_batch_time);\n\tif (sb->s_flags & MS_I_VERSION)\n\t\tSEQ_OPTS_PUTS(\"i_version\");\n\tif (nodefs || sbi->s_stripe)\n\t\tSEQ_OPTS_PRINT(\"stripe=%lu\", sbi->s_stripe);\n\tif (EXT4_MOUNT_DATA_FLAGS & (sbi->s_mount_opt ^ def_mount_opt)) {\n\t\tif (test_opt(sb, DATA_FLAGS) == EXT4_MOUNT_JOURNAL_DATA)\n\t\t\tSEQ_OPTS_PUTS(\"data=journal\");\n\t\telse if (test_opt(sb, DATA_FLAGS) == EXT4_MOUNT_ORDERED_DATA)\n\t\t\tSEQ_OPTS_PUTS(\"data=ordered\");\n\t\telse if (test_opt(sb, DATA_FLAGS) == EXT4_MOUNT_WRITEBACK_DATA)\n\t\t\tSEQ_OPTS_PUTS(\"data=writeback\");\n\t}\n\tif (nodefs ||\n\t    sbi->s_inode_readahead_blks != EXT4_DEF_INODE_READAHEAD_BLKS)\n\t\tSEQ_OPTS_PRINT(\"inode_readahead_blks=%u\",\n\t\t\t       sbi->s_inode_readahead_blks);\n\n\tif (nodefs || (test_opt(sb, INIT_INODE_TABLE) &&\n\t\t       (sbi->s_li_wait_mult != EXT4_DEF_LI_WAIT_MULT)))\n\t\tSEQ_OPTS_PRINT(\"init_itable=%u\", sbi->s_li_wait_mult);\n\tif (nodefs || sbi->s_max_dir_size_kb)\n\t\tSEQ_OPTS_PRINT(\"max_dir_size_kb=%u\", sbi->s_max_dir_size_kb);\n\n\text4_show_quota_options(seq, sb);\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"mballoc.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4_extents.h\"\t/* Needed for trace points definition */\n#include \"ext4.h\"\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <asm/uaccess.h>\n#include <linux/cleancache.h>\n#include <linux/crc16.h>\n#include <linux/log2.h>\n#include <linux/ctype.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/random.h>\n#include <linux/vfs.h>\n#include <linux/exportfs.h>\n#include <linux/buffer_head.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/jbd2.h>\n#include <linux/vmalloc.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n#include <linux/string.h>\n#include <linux/module.h>\n\nstatic int ext4_unfreeze(struct super_block *sb);\nstatic int ext4_freeze(struct super_block *sb);\nstatic inline int ext2_feature_set_ok(struct super_block *sb);\nstatic inline int ext3_feature_set_ok(struct super_block *sb);\nstatic void ext4_unregister_li_request(struct super_block *sb);\n\nstatic int options_seq_show(struct seq_file *seq, void *offset)\n{\n\tstruct super_block *sb = seq->private;\n\tint rc;\n\n\tseq_puts(seq, (sb->s_flags & MS_RDONLY) ? \"ro\" : \"rw\");\n\trc = _ext4_show_options(seq, sb, 1);\n\tseq_puts(seq, \"\\n\");\n\treturn rc;\n}"
  },
  {
    "function_name": "ext4_show_options",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/super.c",
    "lines": "1840-1843",
    "snippet": "static int ext4_show_options(struct seq_file *seq, struct dentry *root)\n{\n\treturn _ext4_show_options(seq, root->d_sb, 0);\n}",
    "includes": [
      "#include <trace/events/ext4.h>",
      "#include \"mballoc.h\"",
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"ext4_jbd2.h\"",
      "#include \"ext4_extents.h\"\t/* Needed for trace points definition */",
      "#include \"ext4.h\"",
      "#include <linux/freezer.h>",
      "#include <linux/kthread.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/cleancache.h>",
      "#include <linux/crc16.h>",
      "#include <linux/log2.h>",
      "#include <linux/ctype.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/namei.h>",
      "#include <linux/mount.h>",
      "#include <linux/random.h>",
      "#include <linux/vfs.h>",
      "#include <linux/exportfs.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/parser.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/init.h>",
      "#include <linux/slab.h>",
      "#include <linux/jbd2.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/time.h>",
      "#include <linux/fs.h>",
      "#include <linux/string.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ext4_show_options(struct seq_file *seq, struct dentry *root);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "_ext4_show_options",
          "args": [
            "seq",
            "root->d_sb",
            "0"
          ],
          "line": 1842
        },
        "resolved": true,
        "details": {
          "function_name": "_ext4_show_options",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/super.c",
          "lines": "1763-1838",
          "snippet": "static int _ext4_show_options(struct seq_file *seq, struct super_block *sb,\n\t\t\t      int nodefs)\n{\n\tstruct ext4_sb_info *sbi = EXT4_SB(sb);\n\tstruct ext4_super_block *es = sbi->s_es;\n\tint def_errors, def_mount_opt = nodefs ? 0 : sbi->s_def_mount_opt;\n\tconst struct mount_opts *m;\n\tchar sep = nodefs ? '\\n' : ',';\n\n#define SEQ_OPTS_PUTS(str) seq_printf(seq, \"%c\" str, sep)\n#define SEQ_OPTS_PRINT(str, arg) seq_printf(seq, \"%c\" str, sep, arg)\n\n\tif (sbi->s_sb_block != 1)\n\t\tSEQ_OPTS_PRINT(\"sb=%llu\", sbi->s_sb_block);\n\n\tfor (m = ext4_mount_opts; m->token != Opt_err; m++) {\n\t\tint want_set = m->flags & MOPT_SET;\n\t\tif (((m->flags & (MOPT_SET|MOPT_CLEAR)) == 0) ||\n\t\t    (m->flags & MOPT_CLEAR_ERR))\n\t\t\tcontinue;\n\t\tif (!(m->mount_opt & (sbi->s_mount_opt ^ def_mount_opt)))\n\t\t\tcontinue; /* skip if same as the default */\n\t\tif ((want_set &&\n\t\t     (sbi->s_mount_opt & m->mount_opt) != m->mount_opt) ||\n\t\t    (!want_set && (sbi->s_mount_opt & m->mount_opt)))\n\t\t\tcontinue; /* select Opt_noFoo vs Opt_Foo */\n\t\tSEQ_OPTS_PRINT(\"%s\", token2str(m->token));\n\t}\n\n\tif (nodefs || !uid_eq(sbi->s_resuid, make_kuid(&init_user_ns, EXT4_DEF_RESUID)) ||\n\t    le16_to_cpu(es->s_def_resuid) != EXT4_DEF_RESUID)\n\t\tSEQ_OPTS_PRINT(\"resuid=%u\",\n\t\t\t\tfrom_kuid_munged(&init_user_ns, sbi->s_resuid));\n\tif (nodefs || !gid_eq(sbi->s_resgid, make_kgid(&init_user_ns, EXT4_DEF_RESGID)) ||\n\t    le16_to_cpu(es->s_def_resgid) != EXT4_DEF_RESGID)\n\t\tSEQ_OPTS_PRINT(\"resgid=%u\",\n\t\t\t\tfrom_kgid_munged(&init_user_ns, sbi->s_resgid));\n\tdef_errors = nodefs ? -1 : le16_to_cpu(es->s_errors);\n\tif (test_opt(sb, ERRORS_RO) && def_errors != EXT4_ERRORS_RO)\n\t\tSEQ_OPTS_PUTS(\"errors=remount-ro\");\n\tif (test_opt(sb, ERRORS_CONT) && def_errors != EXT4_ERRORS_CONTINUE)\n\t\tSEQ_OPTS_PUTS(\"errors=continue\");\n\tif (test_opt(sb, ERRORS_PANIC) && def_errors != EXT4_ERRORS_PANIC)\n\t\tSEQ_OPTS_PUTS(\"errors=panic\");\n\tif (nodefs || sbi->s_commit_interval != JBD2_DEFAULT_MAX_COMMIT_AGE*HZ)\n\t\tSEQ_OPTS_PRINT(\"commit=%lu\", sbi->s_commit_interval / HZ);\n\tif (nodefs || sbi->s_min_batch_time != EXT4_DEF_MIN_BATCH_TIME)\n\t\tSEQ_OPTS_PRINT(\"min_batch_time=%u\", sbi->s_min_batch_time);\n\tif (nodefs || sbi->s_max_batch_time != EXT4_DEF_MAX_BATCH_TIME)\n\t\tSEQ_OPTS_PRINT(\"max_batch_time=%u\", sbi->s_max_batch_time);\n\tif (sb->s_flags & MS_I_VERSION)\n\t\tSEQ_OPTS_PUTS(\"i_version\");\n\tif (nodefs || sbi->s_stripe)\n\t\tSEQ_OPTS_PRINT(\"stripe=%lu\", sbi->s_stripe);\n\tif (EXT4_MOUNT_DATA_FLAGS & (sbi->s_mount_opt ^ def_mount_opt)) {\n\t\tif (test_opt(sb, DATA_FLAGS) == EXT4_MOUNT_JOURNAL_DATA)\n\t\t\tSEQ_OPTS_PUTS(\"data=journal\");\n\t\telse if (test_opt(sb, DATA_FLAGS) == EXT4_MOUNT_ORDERED_DATA)\n\t\t\tSEQ_OPTS_PUTS(\"data=ordered\");\n\t\telse if (test_opt(sb, DATA_FLAGS) == EXT4_MOUNT_WRITEBACK_DATA)\n\t\t\tSEQ_OPTS_PUTS(\"data=writeback\");\n\t}\n\tif (nodefs ||\n\t    sbi->s_inode_readahead_blks != EXT4_DEF_INODE_READAHEAD_BLKS)\n\t\tSEQ_OPTS_PRINT(\"inode_readahead_blks=%u\",\n\t\t\t       sbi->s_inode_readahead_blks);\n\n\tif (nodefs || (test_opt(sb, INIT_INODE_TABLE) &&\n\t\t       (sbi->s_li_wait_mult != EXT4_DEF_LI_WAIT_MULT)))\n\t\tSEQ_OPTS_PRINT(\"init_itable=%u\", sbi->s_li_wait_mult);\n\tif (nodefs || sbi->s_max_dir_size_kb)\n\t\tSEQ_OPTS_PRINT(\"max_dir_size_kb=%u\", sbi->s_max_dir_size_kb);\n\n\text4_show_quota_options(seq, sb);\n\treturn 0;\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"mballoc.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include \"ext4_extents.h\"\t/* Needed for trace points definition */",
            "#include \"ext4.h\"",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/crc16.h>",
            "#include <linux/log2.h>",
            "#include <linux/ctype.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/random.h>",
            "#include <linux/vfs.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/parser.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/time.h>",
            "#include <linux/fs.h>",
            "#include <linux/string.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [
            "#define MOPT_CLEAR_ERR\t0x0010",
            "#define MOPT_CLEAR\t0x0002",
            "#define MOPT_SET\t0x0001"
          ],
          "globals_used": [
            "static void ext4_mark_recovery_complete(struct super_block *sb,\n\t\t\t\t\tstruct ext4_super_block *es);",
            "static void ext4_clear_journal_err(struct super_block *sb,\n\t\t\t\t   struct ext4_super_block *es);",
            "static int ext4_remount(struct super_block *sb, int *flags, char *data);",
            "static int ext4_unfreeze(struct super_block *sb);",
            "static int ext4_freeze(struct super_block *sb);",
            "static struct dentry *ext4_mount(struct file_system_type *fs_type, int flags,\n\t\t       const char *dev_name, void *data);",
            "static inline int ext2_feature_set_ok(struct super_block *sb);",
            "static inline int ext3_feature_set_ok(struct super_block *sb);",
            "static void ext4_unregister_li_request(struct super_block *sb);",
            "static const struct mount_opts {\n\tint\ttoken;\n\tint\tmount_opt;\n\tint\tflags;\n} ext4_mount_opts[] = {\n\t{Opt_minix_df, EXT4_MOUNT_MINIX_DF, MOPT_SET},\n\t{Opt_bsd_df, EXT4_MOUNT_MINIX_DF, MOPT_CLEAR},\n\t{Opt_grpid, EXT4_MOUNT_GRPID, MOPT_SET},\n\t{Opt_nogrpid, EXT4_MOUNT_GRPID, MOPT_CLEAR},\n\t{Opt_block_validity, EXT4_MOUNT_BLOCK_VALIDITY, MOPT_SET},\n\t{Opt_noblock_validity, EXT4_MOUNT_BLOCK_VALIDITY, MOPT_CLEAR},\n\t{Opt_dioread_nolock, EXT4_MOUNT_DIOREAD_NOLOCK,\n\t MOPT_EXT4_ONLY | MOPT_SET},\n\t{Opt_dioread_lock, EXT4_MOUNT_DIOREAD_NOLOCK,\n\t MOPT_EXT4_ONLY | MOPT_CLEAR},\n\t{Opt_discard, EXT4_MOUNT_DISCARD, MOPT_SET},\n\t{Opt_nodiscard, EXT4_MOUNT_DISCARD, MOPT_CLEAR},\n\t{Opt_delalloc, EXT4_MOUNT_DELALLOC,\n\t MOPT_EXT4_ONLY | MOPT_SET | MOPT_EXPLICIT},\n\t{Opt_nodelalloc, EXT4_MOUNT_DELALLOC,\n\t MOPT_EXT4_ONLY | MOPT_CLEAR},\n\t{Opt_nojournal_checksum, EXT4_MOUNT_JOURNAL_CHECKSUM,\n\t MOPT_EXT4_ONLY | MOPT_CLEAR},\n\t{Opt_journal_checksum, EXT4_MOUNT_JOURNAL_CHECKSUM,\n\t MOPT_EXT4_ONLY | MOPT_SET},\n\t{Opt_journal_async_commit, (EXT4_MOUNT_JOURNAL_ASYNC_COMMIT |\n\t\t\t\t    EXT4_MOUNT_JOURNAL_CHECKSUM),\n\t MOPT_EXT4_ONLY | MOPT_SET},\n\t{Opt_noload, EXT4_MOUNT_NOLOAD, MOPT_NO_EXT2 | MOPT_SET},\n\t{Opt_err_panic, EXT4_MOUNT_ERRORS_PANIC, MOPT_SET | MOPT_CLEAR_ERR},\n\t{Opt_err_ro, EXT4_MOUNT_ERRORS_RO, MOPT_SET | MOPT_CLEAR_ERR},\n\t{Opt_err_cont, EXT4_MOUNT_ERRORS_CONT, MOPT_SET | MOPT_CLEAR_ERR},\n\t{Opt_data_err_abort, EXT4_MOUNT_DATA_ERR_ABORT,\n\t MOPT_NO_EXT2 | MOPT_SET},\n\t{Opt_data_err_ignore, EXT4_MOUNT_DATA_ERR_ABORT,\n\t MOPT_NO_EXT2 | MOPT_CLEAR},\n\t{Opt_barrier, EXT4_MOUNT_BARRIER, MOPT_SET},\n\t{Opt_nobarrier, EXT4_MOUNT_BARRIER, MOPT_CLEAR},\n\t{Opt_noauto_da_alloc, EXT4_MOUNT_NO_AUTO_DA_ALLOC, MOPT_SET},\n\t{Opt_auto_da_alloc, EXT4_MOUNT_NO_AUTO_DA_ALLOC, MOPT_CLEAR},\n\t{Opt_noinit_itable, EXT4_MOUNT_INIT_INODE_TABLE, MOPT_CLEAR},\n\t{Opt_commit, 0, MOPT_GTE0},\n\t{Opt_max_batch_time, 0, MOPT_GTE0},\n\t{Opt_min_batch_time, 0, MOPT_GTE0},\n\t{Opt_inode_readahead_blks, 0, MOPT_GTE0},\n\t{Opt_init_itable, 0, MOPT_GTE0},\n\t{Opt_dax, EXT4_MOUNT_DAX, MOPT_SET},\n\t{Opt_stripe, 0, MOPT_GTE0},\n\t{Opt_resuid, 0, MOPT_GTE0},\n\t{Opt_resgid, 0, MOPT_GTE0},\n\t{Opt_journal_dev, 0, MOPT_GTE0},\n\t{Opt_journal_path, 0, MOPT_STRING},\n\t{Opt_journal_ioprio, 0, MOPT_GTE0},\n\t{Opt_data_journal, EXT4_MOUNT_JOURNAL_DATA, MOPT_NO_EXT2 | MOPT_DATAJ},\n\t{Opt_data_ordered, EXT4_MOUNT_ORDERED_DATA, MOPT_NO_EXT2 | MOPT_DATAJ},\n\t{Opt_data_writeback, EXT4_MOUNT_WRITEBACK_DATA,\n\t MOPT_NO_EXT2 | MOPT_DATAJ},\n\t{Opt_user_xattr, EXT4_MOUNT_XATTR_USER, MOPT_SET},\n\t{Opt_nouser_xattr, EXT4_MOUNT_XATTR_USER, MOPT_CLEAR},\n#ifdef CONFIG_EXT4_FS_POSIX_ACL\n\t{Opt_acl, EXT4_MOUNT_POSIX_ACL, MOPT_SET},\n\t{Opt_noacl, EXT4_MOUNT_POSIX_ACL, MOPT_CLEAR},\n#else\n\t{Opt_acl, 0, MOPT_NOSUPPORT},\n\t{Opt_noacl, 0, MOPT_NOSUPPORT},\n#endif\n\t{Opt_nouid32, EXT4_MOUNT_NO_UID32, MOPT_SET},\n\t{Opt_debug, EXT4_MOUNT_DEBUG, MOPT_SET},\n\t{Opt_quota, EXT4_MOUNT_QUOTA | EXT4_MOUNT_USRQUOTA, MOPT_SET | MOPT_Q},\n\t{Opt_usrquota, EXT4_MOUNT_QUOTA | EXT4_MOUNT_USRQUOTA,\n\t\t\t\t\t\t\tMOPT_SET | MOPT_Q},\n\t{Opt_grpquota, EXT4_MOUNT_QUOTA | EXT4_MOUNT_GRPQUOTA,\n\t\t\t\t\t\t\tMOPT_SET | MOPT_Q},\n\t{Opt_noquota, (EXT4_MOUNT_QUOTA | EXT4_MOUNT_USRQUOTA |\n\t\t       EXT4_MOUNT_GRPQUOTA), MOPT_CLEAR | MOPT_Q},\n\t{Opt_usrjquota, 0, MOPT_Q},\n\t{Opt_grpjquota, 0, MOPT_Q},\n\t{Opt_offusrjquota, 0, MOPT_Q},\n\t{Opt_offgrpjquota, 0, MOPT_Q},\n\t{Opt_jqfmt_vfsold, QFMT_VFS_OLD, MOPT_QFMT},\n\t{Opt_jqfmt_vfsv0, QFMT_VFS_V0, MOPT_QFMT},\n\t{Opt_jqfmt_vfsv1, QFMT_VFS_V1, MOPT_QFMT},\n\t{Opt_max_dir_size_kb, 0, MOPT_GTE0},\n\t{Opt_err, 0, 0}\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"mballoc.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4_extents.h\"\t/* Needed for trace points definition */\n#include \"ext4.h\"\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <asm/uaccess.h>\n#include <linux/cleancache.h>\n#include <linux/crc16.h>\n#include <linux/log2.h>\n#include <linux/ctype.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/random.h>\n#include <linux/vfs.h>\n#include <linux/exportfs.h>\n#include <linux/buffer_head.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/jbd2.h>\n#include <linux/vmalloc.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n#include <linux/string.h>\n#include <linux/module.h>\n\n#define MOPT_CLEAR_ERR\t0x0010\n#define MOPT_CLEAR\t0x0002\n#define MOPT_SET\t0x0001\n\nstatic void ext4_mark_recovery_complete(struct super_block *sb,\n\t\t\t\t\tstruct ext4_super_block *es);\nstatic void ext4_clear_journal_err(struct super_block *sb,\n\t\t\t\t   struct ext4_super_block *es);\nstatic int ext4_remount(struct super_block *sb, int *flags, char *data);\nstatic int ext4_unfreeze(struct super_block *sb);\nstatic int ext4_freeze(struct super_block *sb);\nstatic struct dentry *ext4_mount(struct file_system_type *fs_type, int flags,\n\t\t       const char *dev_name, void *data);\nstatic inline int ext2_feature_set_ok(struct super_block *sb);\nstatic inline int ext3_feature_set_ok(struct super_block *sb);\nstatic void ext4_unregister_li_request(struct super_block *sb);\nstatic const struct mount_opts {\n\tint\ttoken;\n\tint\tmount_opt;\n\tint\tflags;\n} ext4_mount_opts[] = {\n\t{Opt_minix_df, EXT4_MOUNT_MINIX_DF, MOPT_SET},\n\t{Opt_bsd_df, EXT4_MOUNT_MINIX_DF, MOPT_CLEAR},\n\t{Opt_grpid, EXT4_MOUNT_GRPID, MOPT_SET},\n\t{Opt_nogrpid, EXT4_MOUNT_GRPID, MOPT_CLEAR},\n\t{Opt_block_validity, EXT4_MOUNT_BLOCK_VALIDITY, MOPT_SET},\n\t{Opt_noblock_validity, EXT4_MOUNT_BLOCK_VALIDITY, MOPT_CLEAR},\n\t{Opt_dioread_nolock, EXT4_MOUNT_DIOREAD_NOLOCK,\n\t MOPT_EXT4_ONLY | MOPT_SET},\n\t{Opt_dioread_lock, EXT4_MOUNT_DIOREAD_NOLOCK,\n\t MOPT_EXT4_ONLY | MOPT_CLEAR},\n\t{Opt_discard, EXT4_MOUNT_DISCARD, MOPT_SET},\n\t{Opt_nodiscard, EXT4_MOUNT_DISCARD, MOPT_CLEAR},\n\t{Opt_delalloc, EXT4_MOUNT_DELALLOC,\n\t MOPT_EXT4_ONLY | MOPT_SET | MOPT_EXPLICIT},\n\t{Opt_nodelalloc, EXT4_MOUNT_DELALLOC,\n\t MOPT_EXT4_ONLY | MOPT_CLEAR},\n\t{Opt_nojournal_checksum, EXT4_MOUNT_JOURNAL_CHECKSUM,\n\t MOPT_EXT4_ONLY | MOPT_CLEAR},\n\t{Opt_journal_checksum, EXT4_MOUNT_JOURNAL_CHECKSUM,\n\t MOPT_EXT4_ONLY | MOPT_SET},\n\t{Opt_journal_async_commit, (EXT4_MOUNT_JOURNAL_ASYNC_COMMIT |\n\t\t\t\t    EXT4_MOUNT_JOURNAL_CHECKSUM),\n\t MOPT_EXT4_ONLY | MOPT_SET},\n\t{Opt_noload, EXT4_MOUNT_NOLOAD, MOPT_NO_EXT2 | MOPT_SET},\n\t{Opt_err_panic, EXT4_MOUNT_ERRORS_PANIC, MOPT_SET | MOPT_CLEAR_ERR},\n\t{Opt_err_ro, EXT4_MOUNT_ERRORS_RO, MOPT_SET | MOPT_CLEAR_ERR},\n\t{Opt_err_cont, EXT4_MOUNT_ERRORS_CONT, MOPT_SET | MOPT_CLEAR_ERR},\n\t{Opt_data_err_abort, EXT4_MOUNT_DATA_ERR_ABORT,\n\t MOPT_NO_EXT2 | MOPT_SET},\n\t{Opt_data_err_ignore, EXT4_MOUNT_DATA_ERR_ABORT,\n\t MOPT_NO_EXT2 | MOPT_CLEAR},\n\t{Opt_barrier, EXT4_MOUNT_BARRIER, MOPT_SET},\n\t{Opt_nobarrier, EXT4_MOUNT_BARRIER, MOPT_CLEAR},\n\t{Opt_noauto_da_alloc, EXT4_MOUNT_NO_AUTO_DA_ALLOC, MOPT_SET},\n\t{Opt_auto_da_alloc, EXT4_MOUNT_NO_AUTO_DA_ALLOC, MOPT_CLEAR},\n\t{Opt_noinit_itable, EXT4_MOUNT_INIT_INODE_TABLE, MOPT_CLEAR},\n\t{Opt_commit, 0, MOPT_GTE0},\n\t{Opt_max_batch_time, 0, MOPT_GTE0},\n\t{Opt_min_batch_time, 0, MOPT_GTE0},\n\t{Opt_inode_readahead_blks, 0, MOPT_GTE0},\n\t{Opt_init_itable, 0, MOPT_GTE0},\n\t{Opt_dax, EXT4_MOUNT_DAX, MOPT_SET},\n\t{Opt_stripe, 0, MOPT_GTE0},\n\t{Opt_resuid, 0, MOPT_GTE0},\n\t{Opt_resgid, 0, MOPT_GTE0},\n\t{Opt_journal_dev, 0, MOPT_GTE0},\n\t{Opt_journal_path, 0, MOPT_STRING},\n\t{Opt_journal_ioprio, 0, MOPT_GTE0},\n\t{Opt_data_journal, EXT4_MOUNT_JOURNAL_DATA, MOPT_NO_EXT2 | MOPT_DATAJ},\n\t{Opt_data_ordered, EXT4_MOUNT_ORDERED_DATA, MOPT_NO_EXT2 | MOPT_DATAJ},\n\t{Opt_data_writeback, EXT4_MOUNT_WRITEBACK_DATA,\n\t MOPT_NO_EXT2 | MOPT_DATAJ},\n\t{Opt_user_xattr, EXT4_MOUNT_XATTR_USER, MOPT_SET},\n\t{Opt_nouser_xattr, EXT4_MOUNT_XATTR_USER, MOPT_CLEAR},\n#ifdef CONFIG_EXT4_FS_POSIX_ACL\n\t{Opt_acl, EXT4_MOUNT_POSIX_ACL, MOPT_SET},\n\t{Opt_noacl, EXT4_MOUNT_POSIX_ACL, MOPT_CLEAR},\n#else\n\t{Opt_acl, 0, MOPT_NOSUPPORT},\n\t{Opt_noacl, 0, MOPT_NOSUPPORT},\n#endif\n\t{Opt_nouid32, EXT4_MOUNT_NO_UID32, MOPT_SET},\n\t{Opt_debug, EXT4_MOUNT_DEBUG, MOPT_SET},\n\t{Opt_quota, EXT4_MOUNT_QUOTA | EXT4_MOUNT_USRQUOTA, MOPT_SET | MOPT_Q},\n\t{Opt_usrquota, EXT4_MOUNT_QUOTA | EXT4_MOUNT_USRQUOTA,\n\t\t\t\t\t\t\tMOPT_SET | MOPT_Q},\n\t{Opt_grpquota, EXT4_MOUNT_QUOTA | EXT4_MOUNT_GRPQUOTA,\n\t\t\t\t\t\t\tMOPT_SET | MOPT_Q},\n\t{Opt_noquota, (EXT4_MOUNT_QUOTA | EXT4_MOUNT_USRQUOTA |\n\t\t       EXT4_MOUNT_GRPQUOTA), MOPT_CLEAR | MOPT_Q},\n\t{Opt_usrjquota, 0, MOPT_Q},\n\t{Opt_grpjquota, 0, MOPT_Q},\n\t{Opt_offusrjquota, 0, MOPT_Q},\n\t{Opt_offgrpjquota, 0, MOPT_Q},\n\t{Opt_jqfmt_vfsold, QFMT_VFS_OLD, MOPT_QFMT},\n\t{Opt_jqfmt_vfsv0, QFMT_VFS_V0, MOPT_QFMT},\n\t{Opt_jqfmt_vfsv1, QFMT_VFS_V1, MOPT_QFMT},\n\t{Opt_max_dir_size_kb, 0, MOPT_GTE0},\n\t{Opt_err, 0, 0}\n};\n\nstatic int _ext4_show_options(struct seq_file *seq, struct super_block *sb,\n\t\t\t      int nodefs)\n{\n\tstruct ext4_sb_info *sbi = EXT4_SB(sb);\n\tstruct ext4_super_block *es = sbi->s_es;\n\tint def_errors, def_mount_opt = nodefs ? 0 : sbi->s_def_mount_opt;\n\tconst struct mount_opts *m;\n\tchar sep = nodefs ? '\\n' : ',';\n\n#define SEQ_OPTS_PUTS(str) seq_printf(seq, \"%c\" str, sep)\n#define SEQ_OPTS_PRINT(str, arg) seq_printf(seq, \"%c\" str, sep, arg)\n\n\tif (sbi->s_sb_block != 1)\n\t\tSEQ_OPTS_PRINT(\"sb=%llu\", sbi->s_sb_block);\n\n\tfor (m = ext4_mount_opts; m->token != Opt_err; m++) {\n\t\tint want_set = m->flags & MOPT_SET;\n\t\tif (((m->flags & (MOPT_SET|MOPT_CLEAR)) == 0) ||\n\t\t    (m->flags & MOPT_CLEAR_ERR))\n\t\t\tcontinue;\n\t\tif (!(m->mount_opt & (sbi->s_mount_opt ^ def_mount_opt)))\n\t\t\tcontinue; /* skip if same as the default */\n\t\tif ((want_set &&\n\t\t     (sbi->s_mount_opt & m->mount_opt) != m->mount_opt) ||\n\t\t    (!want_set && (sbi->s_mount_opt & m->mount_opt)))\n\t\t\tcontinue; /* select Opt_noFoo vs Opt_Foo */\n\t\tSEQ_OPTS_PRINT(\"%s\", token2str(m->token));\n\t}\n\n\tif (nodefs || !uid_eq(sbi->s_resuid, make_kuid(&init_user_ns, EXT4_DEF_RESUID)) ||\n\t    le16_to_cpu(es->s_def_resuid) != EXT4_DEF_RESUID)\n\t\tSEQ_OPTS_PRINT(\"resuid=%u\",\n\t\t\t\tfrom_kuid_munged(&init_user_ns, sbi->s_resuid));\n\tif (nodefs || !gid_eq(sbi->s_resgid, make_kgid(&init_user_ns, EXT4_DEF_RESGID)) ||\n\t    le16_to_cpu(es->s_def_resgid) != EXT4_DEF_RESGID)\n\t\tSEQ_OPTS_PRINT(\"resgid=%u\",\n\t\t\t\tfrom_kgid_munged(&init_user_ns, sbi->s_resgid));\n\tdef_errors = nodefs ? -1 : le16_to_cpu(es->s_errors);\n\tif (test_opt(sb, ERRORS_RO) && def_errors != EXT4_ERRORS_RO)\n\t\tSEQ_OPTS_PUTS(\"errors=remount-ro\");\n\tif (test_opt(sb, ERRORS_CONT) && def_errors != EXT4_ERRORS_CONTINUE)\n\t\tSEQ_OPTS_PUTS(\"errors=continue\");\n\tif (test_opt(sb, ERRORS_PANIC) && def_errors != EXT4_ERRORS_PANIC)\n\t\tSEQ_OPTS_PUTS(\"errors=panic\");\n\tif (nodefs || sbi->s_commit_interval != JBD2_DEFAULT_MAX_COMMIT_AGE*HZ)\n\t\tSEQ_OPTS_PRINT(\"commit=%lu\", sbi->s_commit_interval / HZ);\n\tif (nodefs || sbi->s_min_batch_time != EXT4_DEF_MIN_BATCH_TIME)\n\t\tSEQ_OPTS_PRINT(\"min_batch_time=%u\", sbi->s_min_batch_time);\n\tif (nodefs || sbi->s_max_batch_time != EXT4_DEF_MAX_BATCH_TIME)\n\t\tSEQ_OPTS_PRINT(\"max_batch_time=%u\", sbi->s_max_batch_time);\n\tif (sb->s_flags & MS_I_VERSION)\n\t\tSEQ_OPTS_PUTS(\"i_version\");\n\tif (nodefs || sbi->s_stripe)\n\t\tSEQ_OPTS_PRINT(\"stripe=%lu\", sbi->s_stripe);\n\tif (EXT4_MOUNT_DATA_FLAGS & (sbi->s_mount_opt ^ def_mount_opt)) {\n\t\tif (test_opt(sb, DATA_FLAGS) == EXT4_MOUNT_JOURNAL_DATA)\n\t\t\tSEQ_OPTS_PUTS(\"data=journal\");\n\t\telse if (test_opt(sb, DATA_FLAGS) == EXT4_MOUNT_ORDERED_DATA)\n\t\t\tSEQ_OPTS_PUTS(\"data=ordered\");\n\t\telse if (test_opt(sb, DATA_FLAGS) == EXT4_MOUNT_WRITEBACK_DATA)\n\t\t\tSEQ_OPTS_PUTS(\"data=writeback\");\n\t}\n\tif (nodefs ||\n\t    sbi->s_inode_readahead_blks != EXT4_DEF_INODE_READAHEAD_BLKS)\n\t\tSEQ_OPTS_PRINT(\"inode_readahead_blks=%u\",\n\t\t\t       sbi->s_inode_readahead_blks);\n\n\tif (nodefs || (test_opt(sb, INIT_INODE_TABLE) &&\n\t\t       (sbi->s_li_wait_mult != EXT4_DEF_LI_WAIT_MULT)))\n\t\tSEQ_OPTS_PRINT(\"init_itable=%u\", sbi->s_li_wait_mult);\n\tif (nodefs || sbi->s_max_dir_size_kb)\n\t\tSEQ_OPTS_PRINT(\"max_dir_size_kb=%u\", sbi->s_max_dir_size_kb);\n\n\text4_show_quota_options(seq, sb);\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"mballoc.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4_extents.h\"\t/* Needed for trace points definition */\n#include \"ext4.h\"\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <asm/uaccess.h>\n#include <linux/cleancache.h>\n#include <linux/crc16.h>\n#include <linux/log2.h>\n#include <linux/ctype.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/random.h>\n#include <linux/vfs.h>\n#include <linux/exportfs.h>\n#include <linux/buffer_head.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/jbd2.h>\n#include <linux/vmalloc.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n#include <linux/string.h>\n#include <linux/module.h>\n\nstatic int ext4_show_options(struct seq_file *seq, struct dentry *root);\n\nstatic int ext4_show_options(struct seq_file *seq, struct dentry *root)\n{\n\treturn _ext4_show_options(seq, root->d_sb, 0);\n}"
  },
  {
    "function_name": "_ext4_show_options",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/super.c",
    "lines": "1763-1838",
    "snippet": "static int _ext4_show_options(struct seq_file *seq, struct super_block *sb,\n\t\t\t      int nodefs)\n{\n\tstruct ext4_sb_info *sbi = EXT4_SB(sb);\n\tstruct ext4_super_block *es = sbi->s_es;\n\tint def_errors, def_mount_opt = nodefs ? 0 : sbi->s_def_mount_opt;\n\tconst struct mount_opts *m;\n\tchar sep = nodefs ? '\\n' : ',';\n\n#define SEQ_OPTS_PUTS(str) seq_printf(seq, \"%c\" str, sep)\n#define SEQ_OPTS_PRINT(str, arg) seq_printf(seq, \"%c\" str, sep, arg)\n\n\tif (sbi->s_sb_block != 1)\n\t\tSEQ_OPTS_PRINT(\"sb=%llu\", sbi->s_sb_block);\n\n\tfor (m = ext4_mount_opts; m->token != Opt_err; m++) {\n\t\tint want_set = m->flags & MOPT_SET;\n\t\tif (((m->flags & (MOPT_SET|MOPT_CLEAR)) == 0) ||\n\t\t    (m->flags & MOPT_CLEAR_ERR))\n\t\t\tcontinue;\n\t\tif (!(m->mount_opt & (sbi->s_mount_opt ^ def_mount_opt)))\n\t\t\tcontinue; /* skip if same as the default */\n\t\tif ((want_set &&\n\t\t     (sbi->s_mount_opt & m->mount_opt) != m->mount_opt) ||\n\t\t    (!want_set && (sbi->s_mount_opt & m->mount_opt)))\n\t\t\tcontinue; /* select Opt_noFoo vs Opt_Foo */\n\t\tSEQ_OPTS_PRINT(\"%s\", token2str(m->token));\n\t}\n\n\tif (nodefs || !uid_eq(sbi->s_resuid, make_kuid(&init_user_ns, EXT4_DEF_RESUID)) ||\n\t    le16_to_cpu(es->s_def_resuid) != EXT4_DEF_RESUID)\n\t\tSEQ_OPTS_PRINT(\"resuid=%u\",\n\t\t\t\tfrom_kuid_munged(&init_user_ns, sbi->s_resuid));\n\tif (nodefs || !gid_eq(sbi->s_resgid, make_kgid(&init_user_ns, EXT4_DEF_RESGID)) ||\n\t    le16_to_cpu(es->s_def_resgid) != EXT4_DEF_RESGID)\n\t\tSEQ_OPTS_PRINT(\"resgid=%u\",\n\t\t\t\tfrom_kgid_munged(&init_user_ns, sbi->s_resgid));\n\tdef_errors = nodefs ? -1 : le16_to_cpu(es->s_errors);\n\tif (test_opt(sb, ERRORS_RO) && def_errors != EXT4_ERRORS_RO)\n\t\tSEQ_OPTS_PUTS(\"errors=remount-ro\");\n\tif (test_opt(sb, ERRORS_CONT) && def_errors != EXT4_ERRORS_CONTINUE)\n\t\tSEQ_OPTS_PUTS(\"errors=continue\");\n\tif (test_opt(sb, ERRORS_PANIC) && def_errors != EXT4_ERRORS_PANIC)\n\t\tSEQ_OPTS_PUTS(\"errors=panic\");\n\tif (nodefs || sbi->s_commit_interval != JBD2_DEFAULT_MAX_COMMIT_AGE*HZ)\n\t\tSEQ_OPTS_PRINT(\"commit=%lu\", sbi->s_commit_interval / HZ);\n\tif (nodefs || sbi->s_min_batch_time != EXT4_DEF_MIN_BATCH_TIME)\n\t\tSEQ_OPTS_PRINT(\"min_batch_time=%u\", sbi->s_min_batch_time);\n\tif (nodefs || sbi->s_max_batch_time != EXT4_DEF_MAX_BATCH_TIME)\n\t\tSEQ_OPTS_PRINT(\"max_batch_time=%u\", sbi->s_max_batch_time);\n\tif (sb->s_flags & MS_I_VERSION)\n\t\tSEQ_OPTS_PUTS(\"i_version\");\n\tif (nodefs || sbi->s_stripe)\n\t\tSEQ_OPTS_PRINT(\"stripe=%lu\", sbi->s_stripe);\n\tif (EXT4_MOUNT_DATA_FLAGS & (sbi->s_mount_opt ^ def_mount_opt)) {\n\t\tif (test_opt(sb, DATA_FLAGS) == EXT4_MOUNT_JOURNAL_DATA)\n\t\t\tSEQ_OPTS_PUTS(\"data=journal\");\n\t\telse if (test_opt(sb, DATA_FLAGS) == EXT4_MOUNT_ORDERED_DATA)\n\t\t\tSEQ_OPTS_PUTS(\"data=ordered\");\n\t\telse if (test_opt(sb, DATA_FLAGS) == EXT4_MOUNT_WRITEBACK_DATA)\n\t\t\tSEQ_OPTS_PUTS(\"data=writeback\");\n\t}\n\tif (nodefs ||\n\t    sbi->s_inode_readahead_blks != EXT4_DEF_INODE_READAHEAD_BLKS)\n\t\tSEQ_OPTS_PRINT(\"inode_readahead_blks=%u\",\n\t\t\t       sbi->s_inode_readahead_blks);\n\n\tif (nodefs || (test_opt(sb, INIT_INODE_TABLE) &&\n\t\t       (sbi->s_li_wait_mult != EXT4_DEF_LI_WAIT_MULT)))\n\t\tSEQ_OPTS_PRINT(\"init_itable=%u\", sbi->s_li_wait_mult);\n\tif (nodefs || sbi->s_max_dir_size_kb)\n\t\tSEQ_OPTS_PRINT(\"max_dir_size_kb=%u\", sbi->s_max_dir_size_kb);\n\n\text4_show_quota_options(seq, sb);\n\treturn 0;\n}",
    "includes": [
      "#include <trace/events/ext4.h>",
      "#include \"mballoc.h\"",
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"ext4_jbd2.h\"",
      "#include \"ext4_extents.h\"\t/* Needed for trace points definition */",
      "#include \"ext4.h\"",
      "#include <linux/freezer.h>",
      "#include <linux/kthread.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/cleancache.h>",
      "#include <linux/crc16.h>",
      "#include <linux/log2.h>",
      "#include <linux/ctype.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/namei.h>",
      "#include <linux/mount.h>",
      "#include <linux/random.h>",
      "#include <linux/vfs.h>",
      "#include <linux/exportfs.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/parser.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/init.h>",
      "#include <linux/slab.h>",
      "#include <linux/jbd2.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/time.h>",
      "#include <linux/fs.h>",
      "#include <linux/string.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [
      "#define MOPT_CLEAR_ERR\t0x0010",
      "#define MOPT_CLEAR\t0x0002",
      "#define MOPT_SET\t0x0001"
    ],
    "globals_used": [
      "static void ext4_mark_recovery_complete(struct super_block *sb,\n\t\t\t\t\tstruct ext4_super_block *es);",
      "static void ext4_clear_journal_err(struct super_block *sb,\n\t\t\t\t   struct ext4_super_block *es);",
      "static int ext4_remount(struct super_block *sb, int *flags, char *data);",
      "static int ext4_unfreeze(struct super_block *sb);",
      "static int ext4_freeze(struct super_block *sb);",
      "static struct dentry *ext4_mount(struct file_system_type *fs_type, int flags,\n\t\t       const char *dev_name, void *data);",
      "static inline int ext2_feature_set_ok(struct super_block *sb);",
      "static inline int ext3_feature_set_ok(struct super_block *sb);",
      "static void ext4_unregister_li_request(struct super_block *sb);",
      "static const struct mount_opts {\n\tint\ttoken;\n\tint\tmount_opt;\n\tint\tflags;\n} ext4_mount_opts[] = {\n\t{Opt_minix_df, EXT4_MOUNT_MINIX_DF, MOPT_SET},\n\t{Opt_bsd_df, EXT4_MOUNT_MINIX_DF, MOPT_CLEAR},\n\t{Opt_grpid, EXT4_MOUNT_GRPID, MOPT_SET},\n\t{Opt_nogrpid, EXT4_MOUNT_GRPID, MOPT_CLEAR},\n\t{Opt_block_validity, EXT4_MOUNT_BLOCK_VALIDITY, MOPT_SET},\n\t{Opt_noblock_validity, EXT4_MOUNT_BLOCK_VALIDITY, MOPT_CLEAR},\n\t{Opt_dioread_nolock, EXT4_MOUNT_DIOREAD_NOLOCK,\n\t MOPT_EXT4_ONLY | MOPT_SET},\n\t{Opt_dioread_lock, EXT4_MOUNT_DIOREAD_NOLOCK,\n\t MOPT_EXT4_ONLY | MOPT_CLEAR},\n\t{Opt_discard, EXT4_MOUNT_DISCARD, MOPT_SET},\n\t{Opt_nodiscard, EXT4_MOUNT_DISCARD, MOPT_CLEAR},\n\t{Opt_delalloc, EXT4_MOUNT_DELALLOC,\n\t MOPT_EXT4_ONLY | MOPT_SET | MOPT_EXPLICIT},\n\t{Opt_nodelalloc, EXT4_MOUNT_DELALLOC,\n\t MOPT_EXT4_ONLY | MOPT_CLEAR},\n\t{Opt_nojournal_checksum, EXT4_MOUNT_JOURNAL_CHECKSUM,\n\t MOPT_EXT4_ONLY | MOPT_CLEAR},\n\t{Opt_journal_checksum, EXT4_MOUNT_JOURNAL_CHECKSUM,\n\t MOPT_EXT4_ONLY | MOPT_SET},\n\t{Opt_journal_async_commit, (EXT4_MOUNT_JOURNAL_ASYNC_COMMIT |\n\t\t\t\t    EXT4_MOUNT_JOURNAL_CHECKSUM),\n\t MOPT_EXT4_ONLY | MOPT_SET},\n\t{Opt_noload, EXT4_MOUNT_NOLOAD, MOPT_NO_EXT2 | MOPT_SET},\n\t{Opt_err_panic, EXT4_MOUNT_ERRORS_PANIC, MOPT_SET | MOPT_CLEAR_ERR},\n\t{Opt_err_ro, EXT4_MOUNT_ERRORS_RO, MOPT_SET | MOPT_CLEAR_ERR},\n\t{Opt_err_cont, EXT4_MOUNT_ERRORS_CONT, MOPT_SET | MOPT_CLEAR_ERR},\n\t{Opt_data_err_abort, EXT4_MOUNT_DATA_ERR_ABORT,\n\t MOPT_NO_EXT2 | MOPT_SET},\n\t{Opt_data_err_ignore, EXT4_MOUNT_DATA_ERR_ABORT,\n\t MOPT_NO_EXT2 | MOPT_CLEAR},\n\t{Opt_barrier, EXT4_MOUNT_BARRIER, MOPT_SET},\n\t{Opt_nobarrier, EXT4_MOUNT_BARRIER, MOPT_CLEAR},\n\t{Opt_noauto_da_alloc, EXT4_MOUNT_NO_AUTO_DA_ALLOC, MOPT_SET},\n\t{Opt_auto_da_alloc, EXT4_MOUNT_NO_AUTO_DA_ALLOC, MOPT_CLEAR},\n\t{Opt_noinit_itable, EXT4_MOUNT_INIT_INODE_TABLE, MOPT_CLEAR},\n\t{Opt_commit, 0, MOPT_GTE0},\n\t{Opt_max_batch_time, 0, MOPT_GTE0},\n\t{Opt_min_batch_time, 0, MOPT_GTE0},\n\t{Opt_inode_readahead_blks, 0, MOPT_GTE0},\n\t{Opt_init_itable, 0, MOPT_GTE0},\n\t{Opt_dax, EXT4_MOUNT_DAX, MOPT_SET},\n\t{Opt_stripe, 0, MOPT_GTE0},\n\t{Opt_resuid, 0, MOPT_GTE0},\n\t{Opt_resgid, 0, MOPT_GTE0},\n\t{Opt_journal_dev, 0, MOPT_GTE0},\n\t{Opt_journal_path, 0, MOPT_STRING},\n\t{Opt_journal_ioprio, 0, MOPT_GTE0},\n\t{Opt_data_journal, EXT4_MOUNT_JOURNAL_DATA, MOPT_NO_EXT2 | MOPT_DATAJ},\n\t{Opt_data_ordered, EXT4_MOUNT_ORDERED_DATA, MOPT_NO_EXT2 | MOPT_DATAJ},\n\t{Opt_data_writeback, EXT4_MOUNT_WRITEBACK_DATA,\n\t MOPT_NO_EXT2 | MOPT_DATAJ},\n\t{Opt_user_xattr, EXT4_MOUNT_XATTR_USER, MOPT_SET},\n\t{Opt_nouser_xattr, EXT4_MOUNT_XATTR_USER, MOPT_CLEAR},\n#ifdef CONFIG_EXT4_FS_POSIX_ACL\n\t{Opt_acl, EXT4_MOUNT_POSIX_ACL, MOPT_SET},\n\t{Opt_noacl, EXT4_MOUNT_POSIX_ACL, MOPT_CLEAR},\n#else\n\t{Opt_acl, 0, MOPT_NOSUPPORT},\n\t{Opt_noacl, 0, MOPT_NOSUPPORT},\n#endif\n\t{Opt_nouid32, EXT4_MOUNT_NO_UID32, MOPT_SET},\n\t{Opt_debug, EXT4_MOUNT_DEBUG, MOPT_SET},\n\t{Opt_quota, EXT4_MOUNT_QUOTA | EXT4_MOUNT_USRQUOTA, MOPT_SET | MOPT_Q},\n\t{Opt_usrquota, EXT4_MOUNT_QUOTA | EXT4_MOUNT_USRQUOTA,\n\t\t\t\t\t\t\tMOPT_SET | MOPT_Q},\n\t{Opt_grpquota, EXT4_MOUNT_QUOTA | EXT4_MOUNT_GRPQUOTA,\n\t\t\t\t\t\t\tMOPT_SET | MOPT_Q},\n\t{Opt_noquota, (EXT4_MOUNT_QUOTA | EXT4_MOUNT_USRQUOTA |\n\t\t       EXT4_MOUNT_GRPQUOTA), MOPT_CLEAR | MOPT_Q},\n\t{Opt_usrjquota, 0, MOPT_Q},\n\t{Opt_grpjquota, 0, MOPT_Q},\n\t{Opt_offusrjquota, 0, MOPT_Q},\n\t{Opt_offgrpjquota, 0, MOPT_Q},\n\t{Opt_jqfmt_vfsold, QFMT_VFS_OLD, MOPT_QFMT},\n\t{Opt_jqfmt_vfsv0, QFMT_VFS_V0, MOPT_QFMT},\n\t{Opt_jqfmt_vfsv1, QFMT_VFS_V1, MOPT_QFMT},\n\t{Opt_max_dir_size_kb, 0, MOPT_GTE0},\n\t{Opt_err, 0, 0}\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ext4_show_quota_options",
          "args": [
            "seq",
            "sb"
          ],
          "line": 1836
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_show_quota_options",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/super.c",
          "lines": "1717-1746",
          "snippet": "static inline void ext4_show_quota_options(struct seq_file *seq,\n\t\t\t\t\t   struct super_block *sb)\n{\n#if defined(CONFIG_QUOTA)\n\tstruct ext4_sb_info *sbi = EXT4_SB(sb);\n\n\tif (sbi->s_jquota_fmt) {\n\t\tchar *fmtname = \"\";\n\n\t\tswitch (sbi->s_jquota_fmt) {\n\t\tcase QFMT_VFS_OLD:\n\t\t\tfmtname = \"vfsold\";\n\t\t\tbreak;\n\t\tcase QFMT_VFS_V0:\n\t\t\tfmtname = \"vfsv0\";\n\t\t\tbreak;\n\t\tcase QFMT_VFS_V1:\n\t\t\tfmtname = \"vfsv1\";\n\t\t\tbreak;\n\t\t}\n\t\tseq_printf(seq, \",jqfmt=%s\", fmtname);\n\t}\n\n\tif (sbi->s_qf_names[USRQUOTA])\n\t\tseq_printf(seq, \",usrjquota=%s\", sbi->s_qf_names[USRQUOTA]);\n\n\tif (sbi->s_qf_names[GRPQUOTA])\n\t\tseq_printf(seq, \",grpjquota=%s\", sbi->s_qf_names[GRPQUOTA]);\n#endif\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"mballoc.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include \"ext4_extents.h\"\t/* Needed for trace points definition */",
            "#include \"ext4.h\"",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/crc16.h>",
            "#include <linux/log2.h>",
            "#include <linux/ctype.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/random.h>",
            "#include <linux/vfs.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/parser.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/time.h>",
            "#include <linux/fs.h>",
            "#include <linux/string.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ext4_unfreeze(struct super_block *sb);",
            "static int ext4_freeze(struct super_block *sb);",
            "static inline int ext2_feature_set_ok(struct super_block *sb);",
            "static inline int ext3_feature_set_ok(struct super_block *sb);",
            "static void ext4_unregister_li_request(struct super_block *sb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"mballoc.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4_extents.h\"\t/* Needed for trace points definition */\n#include \"ext4.h\"\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <asm/uaccess.h>\n#include <linux/cleancache.h>\n#include <linux/crc16.h>\n#include <linux/log2.h>\n#include <linux/ctype.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/random.h>\n#include <linux/vfs.h>\n#include <linux/exportfs.h>\n#include <linux/buffer_head.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/jbd2.h>\n#include <linux/vmalloc.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n#include <linux/string.h>\n#include <linux/module.h>\n\nstatic int ext4_unfreeze(struct super_block *sb);\nstatic int ext4_freeze(struct super_block *sb);\nstatic inline int ext2_feature_set_ok(struct super_block *sb);\nstatic inline int ext3_feature_set_ok(struct super_block *sb);\nstatic void ext4_unregister_li_request(struct super_block *sb);\n\nstatic inline void ext4_show_quota_options(struct seq_file *seq,\n\t\t\t\t\t   struct super_block *sb)\n{\n#if defined(CONFIG_QUOTA)\n\tstruct ext4_sb_info *sbi = EXT4_SB(sb);\n\n\tif (sbi->s_jquota_fmt) {\n\t\tchar *fmtname = \"\";\n\n\t\tswitch (sbi->s_jquota_fmt) {\n\t\tcase QFMT_VFS_OLD:\n\t\t\tfmtname = \"vfsold\";\n\t\t\tbreak;\n\t\tcase QFMT_VFS_V0:\n\t\t\tfmtname = \"vfsv0\";\n\t\t\tbreak;\n\t\tcase QFMT_VFS_V1:\n\t\t\tfmtname = \"vfsv1\";\n\t\t\tbreak;\n\t\t}\n\t\tseq_printf(seq, \",jqfmt=%s\", fmtname);\n\t}\n\n\tif (sbi->s_qf_names[USRQUOTA])\n\t\tseq_printf(seq, \",usrjquota=%s\", sbi->s_qf_names[USRQUOTA]);\n\n\tif (sbi->s_qf_names[GRPQUOTA])\n\t\tseq_printf(seq, \",grpjquota=%s\", sbi->s_qf_names[GRPQUOTA]);\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "SEQ_OPTS_PRINT",
          "args": [
            "\"max_dir_size_kb=%u\"",
            "sbi->s_max_dir_size_kb"
          ],
          "line": 1834
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SEQ_OPTS_PRINT",
          "args": [
            "\"init_itable=%u\"",
            "sbi->s_li_wait_mult"
          ],
          "line": 1832
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_opt",
          "args": [
            "sb",
            "INIT_INODE_TABLE"
          ],
          "line": 1830
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SEQ_OPTS_PRINT",
          "args": [
            "\"inode_readahead_blks=%u\"",
            "sbi->s_inode_readahead_blks"
          ],
          "line": 1827
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SEQ_OPTS_PUTS",
          "args": [
            "\"data=writeback\""
          ],
          "line": 1823
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_opt",
          "args": [
            "sb",
            "DATA_FLAGS"
          ],
          "line": 1822
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SEQ_OPTS_PUTS",
          "args": [
            "\"data=ordered\""
          ],
          "line": 1821
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_opt",
          "args": [
            "sb",
            "DATA_FLAGS"
          ],
          "line": 1820
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SEQ_OPTS_PUTS",
          "args": [
            "\"data=journal\""
          ],
          "line": 1819
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_opt",
          "args": [
            "sb",
            "DATA_FLAGS"
          ],
          "line": 1818
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SEQ_OPTS_PRINT",
          "args": [
            "\"stripe=%lu\"",
            "sbi->s_stripe"
          ],
          "line": 1816
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SEQ_OPTS_PUTS",
          "args": [
            "\"i_version\""
          ],
          "line": 1814
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SEQ_OPTS_PRINT",
          "args": [
            "\"max_batch_time=%u\"",
            "sbi->s_max_batch_time"
          ],
          "line": 1812
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SEQ_OPTS_PRINT",
          "args": [
            "\"min_batch_time=%u\"",
            "sbi->s_min_batch_time"
          ],
          "line": 1810
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SEQ_OPTS_PRINT",
          "args": [
            "\"commit=%lu\"",
            "sbi->s_commit_interval / HZ"
          ],
          "line": 1808
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SEQ_OPTS_PUTS",
          "args": [
            "\"errors=panic\""
          ],
          "line": 1806
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_opt",
          "args": [
            "sb",
            "ERRORS_PANIC"
          ],
          "line": 1805
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SEQ_OPTS_PUTS",
          "args": [
            "\"errors=continue\""
          ],
          "line": 1804
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_opt",
          "args": [
            "sb",
            "ERRORS_CONT"
          ],
          "line": 1803
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SEQ_OPTS_PUTS",
          "args": [
            "\"errors=remount-ro\""
          ],
          "line": 1802
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_opt",
          "args": [
            "sb",
            "ERRORS_RO"
          ],
          "line": 1801
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le16_to_cpu",
          "args": [
            "es->s_errors"
          ],
          "line": 1800
        },
        "resolved": true,
        "details": {
          "function_name": "sle16_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "48-51",
          "snippet": "static inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "SEQ_OPTS_PRINT",
          "args": [
            "\"resgid=%u\"",
            "from_kgid_munged(&init_user_ns, sbi->s_resgid)"
          ],
          "line": 1798
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "from_kgid_munged",
          "args": [
            "&init_user_ns",
            "sbi->s_resgid"
          ],
          "line": 1799
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gid_eq",
          "args": [
            "sbi->s_resgid",
            "make_kgid(&init_user_ns, EXT4_DEF_RESGID)"
          ],
          "line": 1796
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "make_kgid",
          "args": [
            "&init_user_ns",
            "EXT4_DEF_RESGID"
          ],
          "line": 1796
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SEQ_OPTS_PRINT",
          "args": [
            "\"resuid=%u\"",
            "from_kuid_munged(&init_user_ns, sbi->s_resuid)"
          ],
          "line": 1794
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "from_kuid_munged",
          "args": [
            "&init_user_ns",
            "sbi->s_resuid"
          ],
          "line": 1795
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "uid_eq",
          "args": [
            "sbi->s_resuid",
            "make_kuid(&init_user_ns, EXT4_DEF_RESUID)"
          ],
          "line": 1792
        },
        "resolved": true,
        "details": {
          "function_name": "uuid_equal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/uuid.c",
          "lines": "59-63",
          "snippet": "int\nuuid_equal(uuid_t *uuid1, uuid_t *uuid2)\n{\n\treturn memcmp(uuid1, uuid2, sizeof(uuid_t)) ? 0 : 1;\n}",
          "includes": [
            "#include <xfs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <xfs.h>\n\nint\nuuid_equal(uuid_t *uuid1, uuid_t *uuid2)\n{\n\treturn memcmp(uuid1, uuid2, sizeof(uuid_t)) ? 0 : 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "make_kuid",
          "args": [
            "&init_user_ns",
            "EXT4_DEF_RESUID"
          ],
          "line": 1792
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SEQ_OPTS_PRINT",
          "args": [
            "\"%s\"",
            "token2str(m->token)"
          ],
          "line": 1789
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "token2str",
          "args": [
            "m->token"
          ],
          "line": 1789
        },
        "resolved": true,
        "details": {
          "function_name": "token2str",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/super.c",
          "lines": "1748-1756",
          "snippet": "static const char *token2str(int token)\n{\n\tconst struct match_token *t;\n\n\tfor (t = tokens; t->token != Opt_err; t++)\n\t\tif (t->token == token && !strchr(t->pattern, '='))\n\t\t\tbreak;\n\treturn t->pattern;\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"mballoc.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include \"ext4_extents.h\"\t/* Needed for trace points definition */",
            "#include \"ext4.h\"",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/crc16.h>",
            "#include <linux/log2.h>",
            "#include <linux/ctype.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/random.h>",
            "#include <linux/vfs.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/parser.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/time.h>",
            "#include <linux/fs.h>",
            "#include <linux/string.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const match_table_t tokens = {\n\t{Opt_bsd_df, \"bsddf\"},\n\t{Opt_minix_df, \"minixdf\"},\n\t{Opt_grpid, \"grpid\"},\n\t{Opt_grpid, \"bsdgroups\"},\n\t{Opt_nogrpid, \"nogrpid\"},\n\t{Opt_nogrpid, \"sysvgroups\"},\n\t{Opt_resgid, \"resgid=%u\"},\n\t{Opt_resuid, \"resuid=%u\"},\n\t{Opt_sb, \"sb=%u\"},\n\t{Opt_err_cont, \"errors=continue\"},\n\t{Opt_err_panic, \"errors=panic\"},\n\t{Opt_err_ro, \"errors=remount-ro\"},\n\t{Opt_nouid32, \"nouid32\"},\n\t{Opt_debug, \"debug\"},\n\t{Opt_removed, \"oldalloc\"},\n\t{Opt_removed, \"orlov\"},\n\t{Opt_user_xattr, \"user_xattr\"},\n\t{Opt_nouser_xattr, \"nouser_xattr\"},\n\t{Opt_acl, \"acl\"},\n\t{Opt_noacl, \"noacl\"},\n\t{Opt_noload, \"norecovery\"},\n\t{Opt_noload, \"noload\"},\n\t{Opt_removed, \"nobh\"},\n\t{Opt_removed, \"bh\"},\n\t{Opt_commit, \"commit=%u\"},\n\t{Opt_min_batch_time, \"min_batch_time=%u\"},\n\t{Opt_max_batch_time, \"max_batch_time=%u\"},\n\t{Opt_journal_dev, \"journal_dev=%u\"},\n\t{Opt_journal_path, \"journal_path=%s\"},\n\t{Opt_journal_checksum, \"journal_checksum\"},\n\t{Opt_nojournal_checksum, \"nojournal_checksum\"},\n\t{Opt_journal_async_commit, \"journal_async_commit\"},\n\t{Opt_abort, \"abort\"},\n\t{Opt_data_journal, \"data=journal\"},\n\t{Opt_data_ordered, \"data=ordered\"},\n\t{Opt_data_writeback, \"data=writeback\"},\n\t{Opt_data_err_abort, \"data_err=abort\"},\n\t{Opt_data_err_ignore, \"data_err=ignore\"},\n\t{Opt_offusrjquota, \"usrjquota=\"},\n\t{Opt_usrjquota, \"usrjquota=%s\"},\n\t{Opt_offgrpjquota, \"grpjquota=\"},\n\t{Opt_grpjquota, \"grpjquota=%s\"},\n\t{Opt_jqfmt_vfsold, \"jqfmt=vfsold\"},\n\t{Opt_jqfmt_vfsv0, \"jqfmt=vfsv0\"},\n\t{Opt_jqfmt_vfsv1, \"jqfmt=vfsv1\"},\n\t{Opt_grpquota, \"grpquota\"},\n\t{Opt_noquota, \"noquota\"},\n\t{Opt_quota, \"quota\"},\n\t{Opt_usrquota, \"usrquota\"},\n\t{Opt_barrier, \"barrier=%u\"},\n\t{Opt_barrier, \"barrier\"},\n\t{Opt_nobarrier, \"nobarrier\"},\n\t{Opt_i_version, \"i_version\"},\n\t{Opt_dax, \"dax\"},\n\t{Opt_stripe, \"stripe=%u\"},\n\t{Opt_delalloc, \"delalloc\"},\n\t{Opt_lazytime, \"lazytime\"},\n\t{Opt_nolazytime, \"nolazytime\"},\n\t{Opt_nodelalloc, \"nodelalloc\"},\n\t{Opt_removed, \"mblk_io_submit\"},\n\t{Opt_removed, \"nomblk_io_submit\"},\n\t{Opt_block_validity, \"block_validity\"},\n\t{Opt_noblock_validity, \"noblock_validity\"},\n\t{Opt_inode_readahead_blks, \"inode_readahead_blks=%u\"},\n\t{Opt_journal_ioprio, \"journal_ioprio=%u\"},\n\t{Opt_auto_da_alloc, \"auto_da_alloc=%u\"},\n\t{Opt_auto_da_alloc, \"auto_da_alloc\"},\n\t{Opt_noauto_da_alloc, \"noauto_da_alloc\"},\n\t{Opt_dioread_nolock, \"dioread_nolock\"},\n\t{Opt_dioread_lock, \"dioread_lock\"},\n\t{Opt_discard, \"discard\"},\n\t{Opt_nodiscard, \"nodiscard\"},\n\t{Opt_init_itable, \"init_itable=%u\"},\n\t{Opt_init_itable, \"init_itable\"},\n\t{Opt_noinit_itable, \"noinit_itable\"},\n\t{Opt_max_dir_size_kb, \"max_dir_size_kb=%u\"},\n\t{Opt_removed, \"check=none\"},\t/* mount option from ext2/3 */\n\t{Opt_removed, \"nocheck\"},\t/* mount option from ext2/3 */\n\t{Opt_removed, \"reservation\"},\t/* mount option from ext2/3 */\n\t{Opt_removed, \"noreservation\"}, /* mount option from ext2/3 */\n\t{Opt_removed, \"journal=%u\"},\t/* mount option from ext2/3 */\n\t{Opt_err, NULL},\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"mballoc.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4_extents.h\"\t/* Needed for trace points definition */\n#include \"ext4.h\"\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <asm/uaccess.h>\n#include <linux/cleancache.h>\n#include <linux/crc16.h>\n#include <linux/log2.h>\n#include <linux/ctype.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/random.h>\n#include <linux/vfs.h>\n#include <linux/exportfs.h>\n#include <linux/buffer_head.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/jbd2.h>\n#include <linux/vmalloc.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n#include <linux/string.h>\n#include <linux/module.h>\n\nstatic const match_table_t tokens = {\n\t{Opt_bsd_df, \"bsddf\"},\n\t{Opt_minix_df, \"minixdf\"},\n\t{Opt_grpid, \"grpid\"},\n\t{Opt_grpid, \"bsdgroups\"},\n\t{Opt_nogrpid, \"nogrpid\"},\n\t{Opt_nogrpid, \"sysvgroups\"},\n\t{Opt_resgid, \"resgid=%u\"},\n\t{Opt_resuid, \"resuid=%u\"},\n\t{Opt_sb, \"sb=%u\"},\n\t{Opt_err_cont, \"errors=continue\"},\n\t{Opt_err_panic, \"errors=panic\"},\n\t{Opt_err_ro, \"errors=remount-ro\"},\n\t{Opt_nouid32, \"nouid32\"},\n\t{Opt_debug, \"debug\"},\n\t{Opt_removed, \"oldalloc\"},\n\t{Opt_removed, \"orlov\"},\n\t{Opt_user_xattr, \"user_xattr\"},\n\t{Opt_nouser_xattr, \"nouser_xattr\"},\n\t{Opt_acl, \"acl\"},\n\t{Opt_noacl, \"noacl\"},\n\t{Opt_noload, \"norecovery\"},\n\t{Opt_noload, \"noload\"},\n\t{Opt_removed, \"nobh\"},\n\t{Opt_removed, \"bh\"},\n\t{Opt_commit, \"commit=%u\"},\n\t{Opt_min_batch_time, \"min_batch_time=%u\"},\n\t{Opt_max_batch_time, \"max_batch_time=%u\"},\n\t{Opt_journal_dev, \"journal_dev=%u\"},\n\t{Opt_journal_path, \"journal_path=%s\"},\n\t{Opt_journal_checksum, \"journal_checksum\"},\n\t{Opt_nojournal_checksum, \"nojournal_checksum\"},\n\t{Opt_journal_async_commit, \"journal_async_commit\"},\n\t{Opt_abort, \"abort\"},\n\t{Opt_data_journal, \"data=journal\"},\n\t{Opt_data_ordered, \"data=ordered\"},\n\t{Opt_data_writeback, \"data=writeback\"},\n\t{Opt_data_err_abort, \"data_err=abort\"},\n\t{Opt_data_err_ignore, \"data_err=ignore\"},\n\t{Opt_offusrjquota, \"usrjquota=\"},\n\t{Opt_usrjquota, \"usrjquota=%s\"},\n\t{Opt_offgrpjquota, \"grpjquota=\"},\n\t{Opt_grpjquota, \"grpjquota=%s\"},\n\t{Opt_jqfmt_vfsold, \"jqfmt=vfsold\"},\n\t{Opt_jqfmt_vfsv0, \"jqfmt=vfsv0\"},\n\t{Opt_jqfmt_vfsv1, \"jqfmt=vfsv1\"},\n\t{Opt_grpquota, \"grpquota\"},\n\t{Opt_noquota, \"noquota\"},\n\t{Opt_quota, \"quota\"},\n\t{Opt_usrquota, \"usrquota\"},\n\t{Opt_barrier, \"barrier=%u\"},\n\t{Opt_barrier, \"barrier\"},\n\t{Opt_nobarrier, \"nobarrier\"},\n\t{Opt_i_version, \"i_version\"},\n\t{Opt_dax, \"dax\"},\n\t{Opt_stripe, \"stripe=%u\"},\n\t{Opt_delalloc, \"delalloc\"},\n\t{Opt_lazytime, \"lazytime\"},\n\t{Opt_nolazytime, \"nolazytime\"},\n\t{Opt_nodelalloc, \"nodelalloc\"},\n\t{Opt_removed, \"mblk_io_submit\"},\n\t{Opt_removed, \"nomblk_io_submit\"},\n\t{Opt_block_validity, \"block_validity\"},\n\t{Opt_noblock_validity, \"noblock_validity\"},\n\t{Opt_inode_readahead_blks, \"inode_readahead_blks=%u\"},\n\t{Opt_journal_ioprio, \"journal_ioprio=%u\"},\n\t{Opt_auto_da_alloc, \"auto_da_alloc=%u\"},\n\t{Opt_auto_da_alloc, \"auto_da_alloc\"},\n\t{Opt_noauto_da_alloc, \"noauto_da_alloc\"},\n\t{Opt_dioread_nolock, \"dioread_nolock\"},\n\t{Opt_dioread_lock, \"dioread_lock\"},\n\t{Opt_discard, \"discard\"},\n\t{Opt_nodiscard, \"nodiscard\"},\n\t{Opt_init_itable, \"init_itable=%u\"},\n\t{Opt_init_itable, \"init_itable\"},\n\t{Opt_noinit_itable, \"noinit_itable\"},\n\t{Opt_max_dir_size_kb, \"max_dir_size_kb=%u\"},\n\t{Opt_removed, \"check=none\"},\t/* mount option from ext2/3 */\n\t{Opt_removed, \"nocheck\"},\t/* mount option from ext2/3 */\n\t{Opt_removed, \"reservation\"},\t/* mount option from ext2/3 */\n\t{Opt_removed, \"noreservation\"}, /* mount option from ext2/3 */\n\t{Opt_removed, \"journal=%u\"},\t/* mount option from ext2/3 */\n\t{Opt_err, NULL},\n};\n\nstatic const char *token2str(int token)\n{\n\tconst struct match_token *t;\n\n\tfor (t = tokens; t->token != Opt_err; t++)\n\t\tif (t->token == token && !strchr(t->pattern, '='))\n\t\t\tbreak;\n\treturn t->pattern;\n}"
        }
      },
      {
        "call_info": {
          "callee": "SEQ_OPTS_PRINT",
          "args": [
            "\"sb=%llu\"",
            "sbi->s_sb_block"
          ],
          "line": 1776
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXT4_SB",
          "args": [
            "sb"
          ],
          "line": 1766
        },
        "resolved": true,
        "details": {
          "function_name": "EXT4_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ext4.h",
          "lines": "1356-1359",
          "snippet": "static inline struct ext4_sb_info *EXT4_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include \"extents_status.h\"",
            "#include <linux/compat.h>",
            "#include <linux/falloc.h>",
            "#include <crypto/hash.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/wait.h>",
            "#include <linux/timer.h>",
            "#include <linux/mutex.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/quota.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extents_status.h\"\n#include <linux/compat.h>\n#include <linux/falloc.h>\n#include <crypto/hash.h>\n#include <linux/ratelimit.h>\n#include <linux/percpu_counter.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/wait.h>\n#include <linux/timer.h>\n#include <linux/mutex.h>\n#include <linux/seqlock.h>\n#include <linux/rbtree.h>\n#include <linux/rwsem.h>\n#include <linux/quota.h>\n#include <linux/jbd2.h>\n#include <linux/magic.h>\n#include <linux/blkdev.h>\n#include <linux/types.h>\n\nstatic inline struct ext4_sb_info *EXT4_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"mballoc.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4_extents.h\"\t/* Needed for trace points definition */\n#include \"ext4.h\"\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <asm/uaccess.h>\n#include <linux/cleancache.h>\n#include <linux/crc16.h>\n#include <linux/log2.h>\n#include <linux/ctype.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/random.h>\n#include <linux/vfs.h>\n#include <linux/exportfs.h>\n#include <linux/buffer_head.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/jbd2.h>\n#include <linux/vmalloc.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n#include <linux/string.h>\n#include <linux/module.h>\n\n#define MOPT_CLEAR_ERR\t0x0010\n#define MOPT_CLEAR\t0x0002\n#define MOPT_SET\t0x0001\n\nstatic void ext4_mark_recovery_complete(struct super_block *sb,\n\t\t\t\t\tstruct ext4_super_block *es);\nstatic void ext4_clear_journal_err(struct super_block *sb,\n\t\t\t\t   struct ext4_super_block *es);\nstatic int ext4_remount(struct super_block *sb, int *flags, char *data);\nstatic int ext4_unfreeze(struct super_block *sb);\nstatic int ext4_freeze(struct super_block *sb);\nstatic struct dentry *ext4_mount(struct file_system_type *fs_type, int flags,\n\t\t       const char *dev_name, void *data);\nstatic inline int ext2_feature_set_ok(struct super_block *sb);\nstatic inline int ext3_feature_set_ok(struct super_block *sb);\nstatic void ext4_unregister_li_request(struct super_block *sb);\nstatic const struct mount_opts {\n\tint\ttoken;\n\tint\tmount_opt;\n\tint\tflags;\n} ext4_mount_opts[] = {\n\t{Opt_minix_df, EXT4_MOUNT_MINIX_DF, MOPT_SET},\n\t{Opt_bsd_df, EXT4_MOUNT_MINIX_DF, MOPT_CLEAR},\n\t{Opt_grpid, EXT4_MOUNT_GRPID, MOPT_SET},\n\t{Opt_nogrpid, EXT4_MOUNT_GRPID, MOPT_CLEAR},\n\t{Opt_block_validity, EXT4_MOUNT_BLOCK_VALIDITY, MOPT_SET},\n\t{Opt_noblock_validity, EXT4_MOUNT_BLOCK_VALIDITY, MOPT_CLEAR},\n\t{Opt_dioread_nolock, EXT4_MOUNT_DIOREAD_NOLOCK,\n\t MOPT_EXT4_ONLY | MOPT_SET},\n\t{Opt_dioread_lock, EXT4_MOUNT_DIOREAD_NOLOCK,\n\t MOPT_EXT4_ONLY | MOPT_CLEAR},\n\t{Opt_discard, EXT4_MOUNT_DISCARD, MOPT_SET},\n\t{Opt_nodiscard, EXT4_MOUNT_DISCARD, MOPT_CLEAR},\n\t{Opt_delalloc, EXT4_MOUNT_DELALLOC,\n\t MOPT_EXT4_ONLY | MOPT_SET | MOPT_EXPLICIT},\n\t{Opt_nodelalloc, EXT4_MOUNT_DELALLOC,\n\t MOPT_EXT4_ONLY | MOPT_CLEAR},\n\t{Opt_nojournal_checksum, EXT4_MOUNT_JOURNAL_CHECKSUM,\n\t MOPT_EXT4_ONLY | MOPT_CLEAR},\n\t{Opt_journal_checksum, EXT4_MOUNT_JOURNAL_CHECKSUM,\n\t MOPT_EXT4_ONLY | MOPT_SET},\n\t{Opt_journal_async_commit, (EXT4_MOUNT_JOURNAL_ASYNC_COMMIT |\n\t\t\t\t    EXT4_MOUNT_JOURNAL_CHECKSUM),\n\t MOPT_EXT4_ONLY | MOPT_SET},\n\t{Opt_noload, EXT4_MOUNT_NOLOAD, MOPT_NO_EXT2 | MOPT_SET},\n\t{Opt_err_panic, EXT4_MOUNT_ERRORS_PANIC, MOPT_SET | MOPT_CLEAR_ERR},\n\t{Opt_err_ro, EXT4_MOUNT_ERRORS_RO, MOPT_SET | MOPT_CLEAR_ERR},\n\t{Opt_err_cont, EXT4_MOUNT_ERRORS_CONT, MOPT_SET | MOPT_CLEAR_ERR},\n\t{Opt_data_err_abort, EXT4_MOUNT_DATA_ERR_ABORT,\n\t MOPT_NO_EXT2 | MOPT_SET},\n\t{Opt_data_err_ignore, EXT4_MOUNT_DATA_ERR_ABORT,\n\t MOPT_NO_EXT2 | MOPT_CLEAR},\n\t{Opt_barrier, EXT4_MOUNT_BARRIER, MOPT_SET},\n\t{Opt_nobarrier, EXT4_MOUNT_BARRIER, MOPT_CLEAR},\n\t{Opt_noauto_da_alloc, EXT4_MOUNT_NO_AUTO_DA_ALLOC, MOPT_SET},\n\t{Opt_auto_da_alloc, EXT4_MOUNT_NO_AUTO_DA_ALLOC, MOPT_CLEAR},\n\t{Opt_noinit_itable, EXT4_MOUNT_INIT_INODE_TABLE, MOPT_CLEAR},\n\t{Opt_commit, 0, MOPT_GTE0},\n\t{Opt_max_batch_time, 0, MOPT_GTE0},\n\t{Opt_min_batch_time, 0, MOPT_GTE0},\n\t{Opt_inode_readahead_blks, 0, MOPT_GTE0},\n\t{Opt_init_itable, 0, MOPT_GTE0},\n\t{Opt_dax, EXT4_MOUNT_DAX, MOPT_SET},\n\t{Opt_stripe, 0, MOPT_GTE0},\n\t{Opt_resuid, 0, MOPT_GTE0},\n\t{Opt_resgid, 0, MOPT_GTE0},\n\t{Opt_journal_dev, 0, MOPT_GTE0},\n\t{Opt_journal_path, 0, MOPT_STRING},\n\t{Opt_journal_ioprio, 0, MOPT_GTE0},\n\t{Opt_data_journal, EXT4_MOUNT_JOURNAL_DATA, MOPT_NO_EXT2 | MOPT_DATAJ},\n\t{Opt_data_ordered, EXT4_MOUNT_ORDERED_DATA, MOPT_NO_EXT2 | MOPT_DATAJ},\n\t{Opt_data_writeback, EXT4_MOUNT_WRITEBACK_DATA,\n\t MOPT_NO_EXT2 | MOPT_DATAJ},\n\t{Opt_user_xattr, EXT4_MOUNT_XATTR_USER, MOPT_SET},\n\t{Opt_nouser_xattr, EXT4_MOUNT_XATTR_USER, MOPT_CLEAR},\n#ifdef CONFIG_EXT4_FS_POSIX_ACL\n\t{Opt_acl, EXT4_MOUNT_POSIX_ACL, MOPT_SET},\n\t{Opt_noacl, EXT4_MOUNT_POSIX_ACL, MOPT_CLEAR},\n#else\n\t{Opt_acl, 0, MOPT_NOSUPPORT},\n\t{Opt_noacl, 0, MOPT_NOSUPPORT},\n#endif\n\t{Opt_nouid32, EXT4_MOUNT_NO_UID32, MOPT_SET},\n\t{Opt_debug, EXT4_MOUNT_DEBUG, MOPT_SET},\n\t{Opt_quota, EXT4_MOUNT_QUOTA | EXT4_MOUNT_USRQUOTA, MOPT_SET | MOPT_Q},\n\t{Opt_usrquota, EXT4_MOUNT_QUOTA | EXT4_MOUNT_USRQUOTA,\n\t\t\t\t\t\t\tMOPT_SET | MOPT_Q},\n\t{Opt_grpquota, EXT4_MOUNT_QUOTA | EXT4_MOUNT_GRPQUOTA,\n\t\t\t\t\t\t\tMOPT_SET | MOPT_Q},\n\t{Opt_noquota, (EXT4_MOUNT_QUOTA | EXT4_MOUNT_USRQUOTA |\n\t\t       EXT4_MOUNT_GRPQUOTA), MOPT_CLEAR | MOPT_Q},\n\t{Opt_usrjquota, 0, MOPT_Q},\n\t{Opt_grpjquota, 0, MOPT_Q},\n\t{Opt_offusrjquota, 0, MOPT_Q},\n\t{Opt_offgrpjquota, 0, MOPT_Q},\n\t{Opt_jqfmt_vfsold, QFMT_VFS_OLD, MOPT_QFMT},\n\t{Opt_jqfmt_vfsv0, QFMT_VFS_V0, MOPT_QFMT},\n\t{Opt_jqfmt_vfsv1, QFMT_VFS_V1, MOPT_QFMT},\n\t{Opt_max_dir_size_kb, 0, MOPT_GTE0},\n\t{Opt_err, 0, 0}\n};\n\nstatic int _ext4_show_options(struct seq_file *seq, struct super_block *sb,\n\t\t\t      int nodefs)\n{\n\tstruct ext4_sb_info *sbi = EXT4_SB(sb);\n\tstruct ext4_super_block *es = sbi->s_es;\n\tint def_errors, def_mount_opt = nodefs ? 0 : sbi->s_def_mount_opt;\n\tconst struct mount_opts *m;\n\tchar sep = nodefs ? '\\n' : ',';\n\n#define SEQ_OPTS_PUTS(str) seq_printf(seq, \"%c\" str, sep)\n#define SEQ_OPTS_PRINT(str, arg) seq_printf(seq, \"%c\" str, sep, arg)\n\n\tif (sbi->s_sb_block != 1)\n\t\tSEQ_OPTS_PRINT(\"sb=%llu\", sbi->s_sb_block);\n\n\tfor (m = ext4_mount_opts; m->token != Opt_err; m++) {\n\t\tint want_set = m->flags & MOPT_SET;\n\t\tif (((m->flags & (MOPT_SET|MOPT_CLEAR)) == 0) ||\n\t\t    (m->flags & MOPT_CLEAR_ERR))\n\t\t\tcontinue;\n\t\tif (!(m->mount_opt & (sbi->s_mount_opt ^ def_mount_opt)))\n\t\t\tcontinue; /* skip if same as the default */\n\t\tif ((want_set &&\n\t\t     (sbi->s_mount_opt & m->mount_opt) != m->mount_opt) ||\n\t\t    (!want_set && (sbi->s_mount_opt & m->mount_opt)))\n\t\t\tcontinue; /* select Opt_noFoo vs Opt_Foo */\n\t\tSEQ_OPTS_PRINT(\"%s\", token2str(m->token));\n\t}\n\n\tif (nodefs || !uid_eq(sbi->s_resuid, make_kuid(&init_user_ns, EXT4_DEF_RESUID)) ||\n\t    le16_to_cpu(es->s_def_resuid) != EXT4_DEF_RESUID)\n\t\tSEQ_OPTS_PRINT(\"resuid=%u\",\n\t\t\t\tfrom_kuid_munged(&init_user_ns, sbi->s_resuid));\n\tif (nodefs || !gid_eq(sbi->s_resgid, make_kgid(&init_user_ns, EXT4_DEF_RESGID)) ||\n\t    le16_to_cpu(es->s_def_resgid) != EXT4_DEF_RESGID)\n\t\tSEQ_OPTS_PRINT(\"resgid=%u\",\n\t\t\t\tfrom_kgid_munged(&init_user_ns, sbi->s_resgid));\n\tdef_errors = nodefs ? -1 : le16_to_cpu(es->s_errors);\n\tif (test_opt(sb, ERRORS_RO) && def_errors != EXT4_ERRORS_RO)\n\t\tSEQ_OPTS_PUTS(\"errors=remount-ro\");\n\tif (test_opt(sb, ERRORS_CONT) && def_errors != EXT4_ERRORS_CONTINUE)\n\t\tSEQ_OPTS_PUTS(\"errors=continue\");\n\tif (test_opt(sb, ERRORS_PANIC) && def_errors != EXT4_ERRORS_PANIC)\n\t\tSEQ_OPTS_PUTS(\"errors=panic\");\n\tif (nodefs || sbi->s_commit_interval != JBD2_DEFAULT_MAX_COMMIT_AGE*HZ)\n\t\tSEQ_OPTS_PRINT(\"commit=%lu\", sbi->s_commit_interval / HZ);\n\tif (nodefs || sbi->s_min_batch_time != EXT4_DEF_MIN_BATCH_TIME)\n\t\tSEQ_OPTS_PRINT(\"min_batch_time=%u\", sbi->s_min_batch_time);\n\tif (nodefs || sbi->s_max_batch_time != EXT4_DEF_MAX_BATCH_TIME)\n\t\tSEQ_OPTS_PRINT(\"max_batch_time=%u\", sbi->s_max_batch_time);\n\tif (sb->s_flags & MS_I_VERSION)\n\t\tSEQ_OPTS_PUTS(\"i_version\");\n\tif (nodefs || sbi->s_stripe)\n\t\tSEQ_OPTS_PRINT(\"stripe=%lu\", sbi->s_stripe);\n\tif (EXT4_MOUNT_DATA_FLAGS & (sbi->s_mount_opt ^ def_mount_opt)) {\n\t\tif (test_opt(sb, DATA_FLAGS) == EXT4_MOUNT_JOURNAL_DATA)\n\t\t\tSEQ_OPTS_PUTS(\"data=journal\");\n\t\telse if (test_opt(sb, DATA_FLAGS) == EXT4_MOUNT_ORDERED_DATA)\n\t\t\tSEQ_OPTS_PUTS(\"data=ordered\");\n\t\telse if (test_opt(sb, DATA_FLAGS) == EXT4_MOUNT_WRITEBACK_DATA)\n\t\t\tSEQ_OPTS_PUTS(\"data=writeback\");\n\t}\n\tif (nodefs ||\n\t    sbi->s_inode_readahead_blks != EXT4_DEF_INODE_READAHEAD_BLKS)\n\t\tSEQ_OPTS_PRINT(\"inode_readahead_blks=%u\",\n\t\t\t       sbi->s_inode_readahead_blks);\n\n\tif (nodefs || (test_opt(sb, INIT_INODE_TABLE) &&\n\t\t       (sbi->s_li_wait_mult != EXT4_DEF_LI_WAIT_MULT)))\n\t\tSEQ_OPTS_PRINT(\"init_itable=%u\", sbi->s_li_wait_mult);\n\tif (nodefs || sbi->s_max_dir_size_kb)\n\t\tSEQ_OPTS_PRINT(\"max_dir_size_kb=%u\", sbi->s_max_dir_size_kb);\n\n\text4_show_quota_options(seq, sb);\n\treturn 0;\n}"
  },
  {
    "function_name": "token2str",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/super.c",
    "lines": "1748-1756",
    "snippet": "static const char *token2str(int token)\n{\n\tconst struct match_token *t;\n\n\tfor (t = tokens; t->token != Opt_err; t++)\n\t\tif (t->token == token && !strchr(t->pattern, '='))\n\t\t\tbreak;\n\treturn t->pattern;\n}",
    "includes": [
      "#include <trace/events/ext4.h>",
      "#include \"mballoc.h\"",
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"ext4_jbd2.h\"",
      "#include \"ext4_extents.h\"\t/* Needed for trace points definition */",
      "#include \"ext4.h\"",
      "#include <linux/freezer.h>",
      "#include <linux/kthread.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/cleancache.h>",
      "#include <linux/crc16.h>",
      "#include <linux/log2.h>",
      "#include <linux/ctype.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/namei.h>",
      "#include <linux/mount.h>",
      "#include <linux/random.h>",
      "#include <linux/vfs.h>",
      "#include <linux/exportfs.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/parser.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/init.h>",
      "#include <linux/slab.h>",
      "#include <linux/jbd2.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/time.h>",
      "#include <linux/fs.h>",
      "#include <linux/string.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static const match_table_t tokens = {\n\t{Opt_bsd_df, \"bsddf\"},\n\t{Opt_minix_df, \"minixdf\"},\n\t{Opt_grpid, \"grpid\"},\n\t{Opt_grpid, \"bsdgroups\"},\n\t{Opt_nogrpid, \"nogrpid\"},\n\t{Opt_nogrpid, \"sysvgroups\"},\n\t{Opt_resgid, \"resgid=%u\"},\n\t{Opt_resuid, \"resuid=%u\"},\n\t{Opt_sb, \"sb=%u\"},\n\t{Opt_err_cont, \"errors=continue\"},\n\t{Opt_err_panic, \"errors=panic\"},\n\t{Opt_err_ro, \"errors=remount-ro\"},\n\t{Opt_nouid32, \"nouid32\"},\n\t{Opt_debug, \"debug\"},\n\t{Opt_removed, \"oldalloc\"},\n\t{Opt_removed, \"orlov\"},\n\t{Opt_user_xattr, \"user_xattr\"},\n\t{Opt_nouser_xattr, \"nouser_xattr\"},\n\t{Opt_acl, \"acl\"},\n\t{Opt_noacl, \"noacl\"},\n\t{Opt_noload, \"norecovery\"},\n\t{Opt_noload, \"noload\"},\n\t{Opt_removed, \"nobh\"},\n\t{Opt_removed, \"bh\"},\n\t{Opt_commit, \"commit=%u\"},\n\t{Opt_min_batch_time, \"min_batch_time=%u\"},\n\t{Opt_max_batch_time, \"max_batch_time=%u\"},\n\t{Opt_journal_dev, \"journal_dev=%u\"},\n\t{Opt_journal_path, \"journal_path=%s\"},\n\t{Opt_journal_checksum, \"journal_checksum\"},\n\t{Opt_nojournal_checksum, \"nojournal_checksum\"},\n\t{Opt_journal_async_commit, \"journal_async_commit\"},\n\t{Opt_abort, \"abort\"},\n\t{Opt_data_journal, \"data=journal\"},\n\t{Opt_data_ordered, \"data=ordered\"},\n\t{Opt_data_writeback, \"data=writeback\"},\n\t{Opt_data_err_abort, \"data_err=abort\"},\n\t{Opt_data_err_ignore, \"data_err=ignore\"},\n\t{Opt_offusrjquota, \"usrjquota=\"},\n\t{Opt_usrjquota, \"usrjquota=%s\"},\n\t{Opt_offgrpjquota, \"grpjquota=\"},\n\t{Opt_grpjquota, \"grpjquota=%s\"},\n\t{Opt_jqfmt_vfsold, \"jqfmt=vfsold\"},\n\t{Opt_jqfmt_vfsv0, \"jqfmt=vfsv0\"},\n\t{Opt_jqfmt_vfsv1, \"jqfmt=vfsv1\"},\n\t{Opt_grpquota, \"grpquota\"},\n\t{Opt_noquota, \"noquota\"},\n\t{Opt_quota, \"quota\"},\n\t{Opt_usrquota, \"usrquota\"},\n\t{Opt_barrier, \"barrier=%u\"},\n\t{Opt_barrier, \"barrier\"},\n\t{Opt_nobarrier, \"nobarrier\"},\n\t{Opt_i_version, \"i_version\"},\n\t{Opt_dax, \"dax\"},\n\t{Opt_stripe, \"stripe=%u\"},\n\t{Opt_delalloc, \"delalloc\"},\n\t{Opt_lazytime, \"lazytime\"},\n\t{Opt_nolazytime, \"nolazytime\"},\n\t{Opt_nodelalloc, \"nodelalloc\"},\n\t{Opt_removed, \"mblk_io_submit\"},\n\t{Opt_removed, \"nomblk_io_submit\"},\n\t{Opt_block_validity, \"block_validity\"},\n\t{Opt_noblock_validity, \"noblock_validity\"},\n\t{Opt_inode_readahead_blks, \"inode_readahead_blks=%u\"},\n\t{Opt_journal_ioprio, \"journal_ioprio=%u\"},\n\t{Opt_auto_da_alloc, \"auto_da_alloc=%u\"},\n\t{Opt_auto_da_alloc, \"auto_da_alloc\"},\n\t{Opt_noauto_da_alloc, \"noauto_da_alloc\"},\n\t{Opt_dioread_nolock, \"dioread_nolock\"},\n\t{Opt_dioread_lock, \"dioread_lock\"},\n\t{Opt_discard, \"discard\"},\n\t{Opt_nodiscard, \"nodiscard\"},\n\t{Opt_init_itable, \"init_itable=%u\"},\n\t{Opt_init_itable, \"init_itable\"},\n\t{Opt_noinit_itable, \"noinit_itable\"},\n\t{Opt_max_dir_size_kb, \"max_dir_size_kb=%u\"},\n\t{Opt_removed, \"check=none\"},\t/* mount option from ext2/3 */\n\t{Opt_removed, \"nocheck\"},\t/* mount option from ext2/3 */\n\t{Opt_removed, \"reservation\"},\t/* mount option from ext2/3 */\n\t{Opt_removed, \"noreservation\"}, /* mount option from ext2/3 */\n\t{Opt_removed, \"journal=%u\"},\t/* mount option from ext2/3 */\n\t{Opt_err, NULL},\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "strchr",
          "args": [
            "t->pattern",
            "'='"
          ],
          "line": 1753
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"mballoc.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4_extents.h\"\t/* Needed for trace points definition */\n#include \"ext4.h\"\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <asm/uaccess.h>\n#include <linux/cleancache.h>\n#include <linux/crc16.h>\n#include <linux/log2.h>\n#include <linux/ctype.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/random.h>\n#include <linux/vfs.h>\n#include <linux/exportfs.h>\n#include <linux/buffer_head.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/jbd2.h>\n#include <linux/vmalloc.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n#include <linux/string.h>\n#include <linux/module.h>\n\nstatic const match_table_t tokens = {\n\t{Opt_bsd_df, \"bsddf\"},\n\t{Opt_minix_df, \"minixdf\"},\n\t{Opt_grpid, \"grpid\"},\n\t{Opt_grpid, \"bsdgroups\"},\n\t{Opt_nogrpid, \"nogrpid\"},\n\t{Opt_nogrpid, \"sysvgroups\"},\n\t{Opt_resgid, \"resgid=%u\"},\n\t{Opt_resuid, \"resuid=%u\"},\n\t{Opt_sb, \"sb=%u\"},\n\t{Opt_err_cont, \"errors=continue\"},\n\t{Opt_err_panic, \"errors=panic\"},\n\t{Opt_err_ro, \"errors=remount-ro\"},\n\t{Opt_nouid32, \"nouid32\"},\n\t{Opt_debug, \"debug\"},\n\t{Opt_removed, \"oldalloc\"},\n\t{Opt_removed, \"orlov\"},\n\t{Opt_user_xattr, \"user_xattr\"},\n\t{Opt_nouser_xattr, \"nouser_xattr\"},\n\t{Opt_acl, \"acl\"},\n\t{Opt_noacl, \"noacl\"},\n\t{Opt_noload, \"norecovery\"},\n\t{Opt_noload, \"noload\"},\n\t{Opt_removed, \"nobh\"},\n\t{Opt_removed, \"bh\"},\n\t{Opt_commit, \"commit=%u\"},\n\t{Opt_min_batch_time, \"min_batch_time=%u\"},\n\t{Opt_max_batch_time, \"max_batch_time=%u\"},\n\t{Opt_journal_dev, \"journal_dev=%u\"},\n\t{Opt_journal_path, \"journal_path=%s\"},\n\t{Opt_journal_checksum, \"journal_checksum\"},\n\t{Opt_nojournal_checksum, \"nojournal_checksum\"},\n\t{Opt_journal_async_commit, \"journal_async_commit\"},\n\t{Opt_abort, \"abort\"},\n\t{Opt_data_journal, \"data=journal\"},\n\t{Opt_data_ordered, \"data=ordered\"},\n\t{Opt_data_writeback, \"data=writeback\"},\n\t{Opt_data_err_abort, \"data_err=abort\"},\n\t{Opt_data_err_ignore, \"data_err=ignore\"},\n\t{Opt_offusrjquota, \"usrjquota=\"},\n\t{Opt_usrjquota, \"usrjquota=%s\"},\n\t{Opt_offgrpjquota, \"grpjquota=\"},\n\t{Opt_grpjquota, \"grpjquota=%s\"},\n\t{Opt_jqfmt_vfsold, \"jqfmt=vfsold\"},\n\t{Opt_jqfmt_vfsv0, \"jqfmt=vfsv0\"},\n\t{Opt_jqfmt_vfsv1, \"jqfmt=vfsv1\"},\n\t{Opt_grpquota, \"grpquota\"},\n\t{Opt_noquota, \"noquota\"},\n\t{Opt_quota, \"quota\"},\n\t{Opt_usrquota, \"usrquota\"},\n\t{Opt_barrier, \"barrier=%u\"},\n\t{Opt_barrier, \"barrier\"},\n\t{Opt_nobarrier, \"nobarrier\"},\n\t{Opt_i_version, \"i_version\"},\n\t{Opt_dax, \"dax\"},\n\t{Opt_stripe, \"stripe=%u\"},\n\t{Opt_delalloc, \"delalloc\"},\n\t{Opt_lazytime, \"lazytime\"},\n\t{Opt_nolazytime, \"nolazytime\"},\n\t{Opt_nodelalloc, \"nodelalloc\"},\n\t{Opt_removed, \"mblk_io_submit\"},\n\t{Opt_removed, \"nomblk_io_submit\"},\n\t{Opt_block_validity, \"block_validity\"},\n\t{Opt_noblock_validity, \"noblock_validity\"},\n\t{Opt_inode_readahead_blks, \"inode_readahead_blks=%u\"},\n\t{Opt_journal_ioprio, \"journal_ioprio=%u\"},\n\t{Opt_auto_da_alloc, \"auto_da_alloc=%u\"},\n\t{Opt_auto_da_alloc, \"auto_da_alloc\"},\n\t{Opt_noauto_da_alloc, \"noauto_da_alloc\"},\n\t{Opt_dioread_nolock, \"dioread_nolock\"},\n\t{Opt_dioread_lock, \"dioread_lock\"},\n\t{Opt_discard, \"discard\"},\n\t{Opt_nodiscard, \"nodiscard\"},\n\t{Opt_init_itable, \"init_itable=%u\"},\n\t{Opt_init_itable, \"init_itable\"},\n\t{Opt_noinit_itable, \"noinit_itable\"},\n\t{Opt_max_dir_size_kb, \"max_dir_size_kb=%u\"},\n\t{Opt_removed, \"check=none\"},\t/* mount option from ext2/3 */\n\t{Opt_removed, \"nocheck\"},\t/* mount option from ext2/3 */\n\t{Opt_removed, \"reservation\"},\t/* mount option from ext2/3 */\n\t{Opt_removed, \"noreservation\"}, /* mount option from ext2/3 */\n\t{Opt_removed, \"journal=%u\"},\t/* mount option from ext2/3 */\n\t{Opt_err, NULL},\n};\n\nstatic const char *token2str(int token)\n{\n\tconst struct match_token *t;\n\n\tfor (t = tokens; t->token != Opt_err; t++)\n\t\tif (t->token == token && !strchr(t->pattern, '='))\n\t\t\tbreak;\n\treturn t->pattern;\n}"
  },
  {
    "function_name": "ext4_show_quota_options",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/super.c",
    "lines": "1717-1746",
    "snippet": "static inline void ext4_show_quota_options(struct seq_file *seq,\n\t\t\t\t\t   struct super_block *sb)\n{\n#if defined(CONFIG_QUOTA)\n\tstruct ext4_sb_info *sbi = EXT4_SB(sb);\n\n\tif (sbi->s_jquota_fmt) {\n\t\tchar *fmtname = \"\";\n\n\t\tswitch (sbi->s_jquota_fmt) {\n\t\tcase QFMT_VFS_OLD:\n\t\t\tfmtname = \"vfsold\";\n\t\t\tbreak;\n\t\tcase QFMT_VFS_V0:\n\t\t\tfmtname = \"vfsv0\";\n\t\t\tbreak;\n\t\tcase QFMT_VFS_V1:\n\t\t\tfmtname = \"vfsv1\";\n\t\t\tbreak;\n\t\t}\n\t\tseq_printf(seq, \",jqfmt=%s\", fmtname);\n\t}\n\n\tif (sbi->s_qf_names[USRQUOTA])\n\t\tseq_printf(seq, \",usrjquota=%s\", sbi->s_qf_names[USRQUOTA]);\n\n\tif (sbi->s_qf_names[GRPQUOTA])\n\t\tseq_printf(seq, \",grpjquota=%s\", sbi->s_qf_names[GRPQUOTA]);\n#endif\n}",
    "includes": [
      "#include <trace/events/ext4.h>",
      "#include \"mballoc.h\"",
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"ext4_jbd2.h\"",
      "#include \"ext4_extents.h\"\t/* Needed for trace points definition */",
      "#include \"ext4.h\"",
      "#include <linux/freezer.h>",
      "#include <linux/kthread.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/cleancache.h>",
      "#include <linux/crc16.h>",
      "#include <linux/log2.h>",
      "#include <linux/ctype.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/namei.h>",
      "#include <linux/mount.h>",
      "#include <linux/random.h>",
      "#include <linux/vfs.h>",
      "#include <linux/exportfs.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/parser.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/init.h>",
      "#include <linux/slab.h>",
      "#include <linux/jbd2.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/time.h>",
      "#include <linux/fs.h>",
      "#include <linux/string.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ext4_unfreeze(struct super_block *sb);",
      "static int ext4_freeze(struct super_block *sb);",
      "static inline int ext2_feature_set_ok(struct super_block *sb);",
      "static inline int ext3_feature_set_ok(struct super_block *sb);",
      "static void ext4_unregister_li_request(struct super_block *sb);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "seq_printf",
          "args": [
            "seq",
            "\",grpjquota=%s\"",
            "sbi->s_qf_names[GRPQUOTA]"
          ],
          "line": 1744
        },
        "resolved": true,
        "details": {
          "function_name": "seq_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/seq_file.c",
          "lines": "416-426",
          "snippet": "int seq_printf(struct seq_file *m, const char *f, ...)\n{\n\tint ret;\n\tva_list args;\n\n\tva_start(args, f);\n\tret = seq_vprintf(m, f, args);\n\tva_end(args);\n\n\treturn ret;\n}",
          "includes": [
            "#include <asm/page.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/mm.h>",
            "#include <linux/cred.h>",
            "#include <linux/slab.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/export.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <linux/mm.h>\n#include <linux/cred.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/seq_file.h>\n#include <linux/export.h>\n#include <linux/fs.h>\n\nint seq_printf(struct seq_file *m, const char *f, ...)\n{\n\tint ret;\n\tva_list args;\n\n\tva_start(args, f);\n\tret = seq_vprintf(m, f, args);\n\tva_end(args);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "EXT4_SB",
          "args": [
            "sb"
          ],
          "line": 1721
        },
        "resolved": true,
        "details": {
          "function_name": "EXT4_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ext4.h",
          "lines": "1356-1359",
          "snippet": "static inline struct ext4_sb_info *EXT4_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include \"extents_status.h\"",
            "#include <linux/compat.h>",
            "#include <linux/falloc.h>",
            "#include <crypto/hash.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/wait.h>",
            "#include <linux/timer.h>",
            "#include <linux/mutex.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/quota.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extents_status.h\"\n#include <linux/compat.h>\n#include <linux/falloc.h>\n#include <crypto/hash.h>\n#include <linux/ratelimit.h>\n#include <linux/percpu_counter.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/wait.h>\n#include <linux/timer.h>\n#include <linux/mutex.h>\n#include <linux/seqlock.h>\n#include <linux/rbtree.h>\n#include <linux/rwsem.h>\n#include <linux/quota.h>\n#include <linux/jbd2.h>\n#include <linux/magic.h>\n#include <linux/blkdev.h>\n#include <linux/types.h>\n\nstatic inline struct ext4_sb_info *EXT4_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"mballoc.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4_extents.h\"\t/* Needed for trace points definition */\n#include \"ext4.h\"\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <asm/uaccess.h>\n#include <linux/cleancache.h>\n#include <linux/crc16.h>\n#include <linux/log2.h>\n#include <linux/ctype.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/random.h>\n#include <linux/vfs.h>\n#include <linux/exportfs.h>\n#include <linux/buffer_head.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/jbd2.h>\n#include <linux/vmalloc.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n#include <linux/string.h>\n#include <linux/module.h>\n\nstatic int ext4_unfreeze(struct super_block *sb);\nstatic int ext4_freeze(struct super_block *sb);\nstatic inline int ext2_feature_set_ok(struct super_block *sb);\nstatic inline int ext3_feature_set_ok(struct super_block *sb);\nstatic void ext4_unregister_li_request(struct super_block *sb);\n\nstatic inline void ext4_show_quota_options(struct seq_file *seq,\n\t\t\t\t\t   struct super_block *sb)\n{\n#if defined(CONFIG_QUOTA)\n\tstruct ext4_sb_info *sbi = EXT4_SB(sb);\n\n\tif (sbi->s_jquota_fmt) {\n\t\tchar *fmtname = \"\";\n\n\t\tswitch (sbi->s_jquota_fmt) {\n\t\tcase QFMT_VFS_OLD:\n\t\t\tfmtname = \"vfsold\";\n\t\t\tbreak;\n\t\tcase QFMT_VFS_V0:\n\t\t\tfmtname = \"vfsv0\";\n\t\t\tbreak;\n\t\tcase QFMT_VFS_V1:\n\t\t\tfmtname = \"vfsv1\";\n\t\t\tbreak;\n\t\t}\n\t\tseq_printf(seq, \",jqfmt=%s\", fmtname);\n\t}\n\n\tif (sbi->s_qf_names[USRQUOTA])\n\t\tseq_printf(seq, \",usrjquota=%s\", sbi->s_qf_names[USRQUOTA]);\n\n\tif (sbi->s_qf_names[GRPQUOTA])\n\t\tseq_printf(seq, \",grpjquota=%s\", sbi->s_qf_names[GRPQUOTA]);\n#endif\n}"
  },
  {
    "function_name": "parse_options",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/super.c",
    "lines": "1645-1715",
    "snippet": "static int parse_options(char *options, struct super_block *sb,\n\t\t\t unsigned long *journal_devnum,\n\t\t\t unsigned int *journal_ioprio,\n\t\t\t int is_remount)\n{\n\tstruct ext4_sb_info *sbi = EXT4_SB(sb);\n\tchar *p;\n\tsubstring_t args[MAX_OPT_ARGS];\n\tint token;\n\n\tif (!options)\n\t\treturn 1;\n\n\twhile ((p = strsep(&options, \",\")) != NULL) {\n\t\tif (!*p)\n\t\t\tcontinue;\n\t\t/*\n\t\t * Initialize args struct so we know whether arg was\n\t\t * found; some options take optional arguments.\n\t\t */\n\t\targs[0].to = args[0].from = NULL;\n\t\ttoken = match_token(p, tokens, args);\n\t\tif (handle_mount_opt(sb, p, token, args, journal_devnum,\n\t\t\t\t     journal_ioprio, is_remount) < 0)\n\t\t\treturn 0;\n\t}\n#ifdef CONFIG_QUOTA\n\tif (EXT4_HAS_RO_COMPAT_FEATURE(sb, EXT4_FEATURE_RO_COMPAT_QUOTA) &&\n\t    (test_opt(sb, USRQUOTA) || test_opt(sb, GRPQUOTA))) {\n\t\text4_msg(sb, KERN_ERR, \"Cannot set quota options when QUOTA \"\n\t\t\t \"feature is enabled\");\n\t\treturn 0;\n\t}\n\tif (sbi->s_qf_names[USRQUOTA] || sbi->s_qf_names[GRPQUOTA]) {\n\t\tif (test_opt(sb, USRQUOTA) && sbi->s_qf_names[USRQUOTA])\n\t\t\tclear_opt(sb, USRQUOTA);\n\n\t\tif (test_opt(sb, GRPQUOTA) && sbi->s_qf_names[GRPQUOTA])\n\t\t\tclear_opt(sb, GRPQUOTA);\n\n\t\tif (test_opt(sb, GRPQUOTA) || test_opt(sb, USRQUOTA)) {\n\t\t\text4_msg(sb, KERN_ERR, \"old and new quota \"\n\t\t\t\t\t\"format mixing\");\n\t\t\treturn 0;\n\t\t}\n\n\t\tif (!sbi->s_jquota_fmt) {\n\t\t\text4_msg(sb, KERN_ERR, \"journaled quota format \"\n\t\t\t\t\t\"not specified\");\n\t\t\treturn 0;\n\t\t}\n\t}\n#endif\n\tif (test_opt(sb, DIOREAD_NOLOCK)) {\n\t\tint blocksize =\n\t\t\tBLOCK_SIZE << le32_to_cpu(sbi->s_es->s_log_block_size);\n\n\t\tif (blocksize < PAGE_CACHE_SIZE) {\n\t\t\text4_msg(sb, KERN_ERR, \"can't mount with \"\n\t\t\t\t \"dioread_nolock if block size != PAGE_SIZE\");\n\t\t\treturn 0;\n\t\t}\n\t}\n\tif (test_opt(sb, DATA_FLAGS) == EXT4_MOUNT_ORDERED_DATA &&\n\t    test_opt(sb, JOURNAL_ASYNC_COMMIT)) {\n\t\text4_msg(sb, KERN_ERR, \"can't mount with journal_async_commit \"\n\t\t\t \"in data=ordered mode\");\n\t\treturn 0;\n\t}\n\treturn 1;\n}",
    "includes": [
      "#include <trace/events/ext4.h>",
      "#include \"mballoc.h\"",
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"ext4_jbd2.h\"",
      "#include \"ext4_extents.h\"\t/* Needed for trace points definition */",
      "#include \"ext4.h\"",
      "#include <linux/freezer.h>",
      "#include <linux/kthread.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/cleancache.h>",
      "#include <linux/crc16.h>",
      "#include <linux/log2.h>",
      "#include <linux/ctype.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/namei.h>",
      "#include <linux/mount.h>",
      "#include <linux/random.h>",
      "#include <linux/vfs.h>",
      "#include <linux/exportfs.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/parser.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/init.h>",
      "#include <linux/slab.h>",
      "#include <linux/jbd2.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/time.h>",
      "#include <linux/fs.h>",
      "#include <linux/string.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ext4_load_journal(struct super_block *, struct ext4_super_block *,\n\t\t\t     unsigned long journal_devnum);",
      "static int ext4_remount(struct super_block *sb, int *flags, char *data);",
      "static int ext4_unfreeze(struct super_block *sb);",
      "static int ext4_freeze(struct super_block *sb);",
      "static struct dentry *ext4_mount(struct file_system_type *fs_type, int flags,\n\t\t       const char *dev_name, void *data);",
      "static inline int ext2_feature_set_ok(struct super_block *sb);",
      "static inline int ext3_feature_set_ok(struct super_block *sb);",
      "static void ext4_unregister_li_request(struct super_block *sb);",
      "static const match_table_t tokens = {\n\t{Opt_bsd_df, \"bsddf\"},\n\t{Opt_minix_df, \"minixdf\"},\n\t{Opt_grpid, \"grpid\"},\n\t{Opt_grpid, \"bsdgroups\"},\n\t{Opt_nogrpid, \"nogrpid\"},\n\t{Opt_nogrpid, \"sysvgroups\"},\n\t{Opt_resgid, \"resgid=%u\"},\n\t{Opt_resuid, \"resuid=%u\"},\n\t{Opt_sb, \"sb=%u\"},\n\t{Opt_err_cont, \"errors=continue\"},\n\t{Opt_err_panic, \"errors=panic\"},\n\t{Opt_err_ro, \"errors=remount-ro\"},\n\t{Opt_nouid32, \"nouid32\"},\n\t{Opt_debug, \"debug\"},\n\t{Opt_removed, \"oldalloc\"},\n\t{Opt_removed, \"orlov\"},\n\t{Opt_user_xattr, \"user_xattr\"},\n\t{Opt_nouser_xattr, \"nouser_xattr\"},\n\t{Opt_acl, \"acl\"},\n\t{Opt_noacl, \"noacl\"},\n\t{Opt_noload, \"norecovery\"},\n\t{Opt_noload, \"noload\"},\n\t{Opt_removed, \"nobh\"},\n\t{Opt_removed, \"bh\"},\n\t{Opt_commit, \"commit=%u\"},\n\t{Opt_min_batch_time, \"min_batch_time=%u\"},\n\t{Opt_max_batch_time, \"max_batch_time=%u\"},\n\t{Opt_journal_dev, \"journal_dev=%u\"},\n\t{Opt_journal_path, \"journal_path=%s\"},\n\t{Opt_journal_checksum, \"journal_checksum\"},\n\t{Opt_nojournal_checksum, \"nojournal_checksum\"},\n\t{Opt_journal_async_commit, \"journal_async_commit\"},\n\t{Opt_abort, \"abort\"},\n\t{Opt_data_journal, \"data=journal\"},\n\t{Opt_data_ordered, \"data=ordered\"},\n\t{Opt_data_writeback, \"data=writeback\"},\n\t{Opt_data_err_abort, \"data_err=abort\"},\n\t{Opt_data_err_ignore, \"data_err=ignore\"},\n\t{Opt_offusrjquota, \"usrjquota=\"},\n\t{Opt_usrjquota, \"usrjquota=%s\"},\n\t{Opt_offgrpjquota, \"grpjquota=\"},\n\t{Opt_grpjquota, \"grpjquota=%s\"},\n\t{Opt_jqfmt_vfsold, \"jqfmt=vfsold\"},\n\t{Opt_jqfmt_vfsv0, \"jqfmt=vfsv0\"},\n\t{Opt_jqfmt_vfsv1, \"jqfmt=vfsv1\"},\n\t{Opt_grpquota, \"grpquota\"},\n\t{Opt_noquota, \"noquota\"},\n\t{Opt_quota, \"quota\"},\n\t{Opt_usrquota, \"usrquota\"},\n\t{Opt_barrier, \"barrier=%u\"},\n\t{Opt_barrier, \"barrier\"},\n\t{Opt_nobarrier, \"nobarrier\"},\n\t{Opt_i_version, \"i_version\"},\n\t{Opt_dax, \"dax\"},\n\t{Opt_stripe, \"stripe=%u\"},\n\t{Opt_delalloc, \"delalloc\"},\n\t{Opt_lazytime, \"lazytime\"},\n\t{Opt_nolazytime, \"nolazytime\"},\n\t{Opt_nodelalloc, \"nodelalloc\"},\n\t{Opt_removed, \"mblk_io_submit\"},\n\t{Opt_removed, \"nomblk_io_submit\"},\n\t{Opt_block_validity, \"block_validity\"},\n\t{Opt_noblock_validity, \"noblock_validity\"},\n\t{Opt_inode_readahead_blks, \"inode_readahead_blks=%u\"},\n\t{Opt_journal_ioprio, \"journal_ioprio=%u\"},\n\t{Opt_auto_da_alloc, \"auto_da_alloc=%u\"},\n\t{Opt_auto_da_alloc, \"auto_da_alloc\"},\n\t{Opt_noauto_da_alloc, \"noauto_da_alloc\"},\n\t{Opt_dioread_nolock, \"dioread_nolock\"},\n\t{Opt_dioread_lock, \"dioread_lock\"},\n\t{Opt_discard, \"discard\"},\n\t{Opt_nodiscard, \"nodiscard\"},\n\t{Opt_init_itable, \"init_itable=%u\"},\n\t{Opt_init_itable, \"init_itable\"},\n\t{Opt_noinit_itable, \"noinit_itable\"},\n\t{Opt_max_dir_size_kb, \"max_dir_size_kb=%u\"},\n\t{Opt_removed, \"check=none\"},\t/* mount option from ext2/3 */\n\t{Opt_removed, \"nocheck\"},\t/* mount option from ext2/3 */\n\t{Opt_removed, \"reservation\"},\t/* mount option from ext2/3 */\n\t{Opt_removed, \"noreservation\"}, /* mount option from ext2/3 */\n\t{Opt_removed, \"journal=%u\"},\t/* mount option from ext2/3 */\n\t{Opt_err, NULL},\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ext4_msg",
          "args": [
            "sb",
            "KERN_ERR",
            "\"can't mount with journal_async_commit \"\n\t\t\t \"in data=ordered mode\""
          ],
          "line": 1710
        },
        "resolved": true,
        "details": {
          "function_name": "__ext4_msg",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/super.c",
          "lines": "593-607",
          "snippet": "void __ext4_msg(struct super_block *sb,\n\t\tconst char *prefix, const char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tif (!___ratelimit(&(EXT4_SB(sb)->s_msg_ratelimit_state), \"EXT4-fs\"))\n\t\treturn;\n\n\tva_start(args, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\tprintk(\"%sEXT4-fs (%s): %pV\\n\", prefix, sb->s_id, &vaf);\n\tva_end(args);\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"mballoc.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include \"ext4_extents.h\"\t/* Needed for trace points definition */",
            "#include \"ext4.h\"",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/crc16.h>",
            "#include <linux/log2.h>",
            "#include <linux/ctype.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/random.h>",
            "#include <linux/vfs.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/parser.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/time.h>",
            "#include <linux/fs.h>",
            "#include <linux/string.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ext4_unfreeze(struct super_block *sb);",
            "static int ext4_freeze(struct super_block *sb);",
            "static inline int ext2_feature_set_ok(struct super_block *sb);",
            "static inline int ext3_feature_set_ok(struct super_block *sb);",
            "static void ext4_unregister_li_request(struct super_block *sb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"mballoc.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4_extents.h\"\t/* Needed for trace points definition */\n#include \"ext4.h\"\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <asm/uaccess.h>\n#include <linux/cleancache.h>\n#include <linux/crc16.h>\n#include <linux/log2.h>\n#include <linux/ctype.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/random.h>\n#include <linux/vfs.h>\n#include <linux/exportfs.h>\n#include <linux/buffer_head.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/jbd2.h>\n#include <linux/vmalloc.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n#include <linux/string.h>\n#include <linux/module.h>\n\nstatic int ext4_unfreeze(struct super_block *sb);\nstatic int ext4_freeze(struct super_block *sb);\nstatic inline int ext2_feature_set_ok(struct super_block *sb);\nstatic inline int ext3_feature_set_ok(struct super_block *sb);\nstatic void ext4_unregister_li_request(struct super_block *sb);\n\nvoid __ext4_msg(struct super_block *sb,\n\t\tconst char *prefix, const char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tif (!___ratelimit(&(EXT4_SB(sb)->s_msg_ratelimit_state), \"EXT4-fs\"))\n\t\treturn;\n\n\tva_start(args, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\tprintk(\"%sEXT4-fs (%s): %pV\\n\", prefix, sb->s_id, &vaf);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "test_opt",
          "args": [
            "sb",
            "JOURNAL_ASYNC_COMMIT"
          ],
          "line": 1709
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_opt",
          "args": [
            "sb",
            "DATA_FLAGS"
          ],
          "line": 1708
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "sbi->s_es->s_log_block_size"
          ],
          "line": 1700
        },
        "resolved": true,
        "details": {
          "function_name": "sle32_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "53-56",
          "snippet": "static inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "test_opt",
          "args": [
            "sb",
            "DIOREAD_NOLOCK"
          ],
          "line": 1698
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_opt",
          "args": [
            "sb",
            "USRQUOTA"
          ],
          "line": 1685
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_opt",
          "args": [
            "sb",
            "GRPQUOTA"
          ],
          "line": 1685
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "clear_opt",
          "args": [
            "sb",
            "GRPQUOTA"
          ],
          "line": 1683
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_opt",
          "args": [
            "sb",
            "GRPQUOTA"
          ],
          "line": 1682
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "clear_opt",
          "args": [
            "sb",
            "USRQUOTA"
          ],
          "line": 1680
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_opt",
          "args": [
            "sb",
            "USRQUOTA"
          ],
          "line": 1679
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_opt",
          "args": [
            "sb",
            "GRPQUOTA"
          ],
          "line": 1673
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_opt",
          "args": [
            "sb",
            "USRQUOTA"
          ],
          "line": 1673
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXT4_HAS_RO_COMPAT_FEATURE",
          "args": [
            "sb",
            "EXT4_FEATURE_RO_COMPAT_QUOTA"
          ],
          "line": 1672
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "handle_mount_opt",
          "args": [
            "sb",
            "p",
            "token",
            "args",
            "journal_devnum",
            "journal_ioprio",
            "is_remount"
          ],
          "line": 1667
        },
        "resolved": true,
        "details": {
          "function_name": "handle_mount_opt",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/super.c",
          "lines": "1418-1643",
          "snippet": "static int handle_mount_opt(struct super_block *sb, char *opt, int token,\n\t\t\t    substring_t *args, unsigned long *journal_devnum,\n\t\t\t    unsigned int *journal_ioprio, int is_remount)\n{\n\tstruct ext4_sb_info *sbi = EXT4_SB(sb);\n\tconst struct mount_opts *m;\n\tkuid_t uid;\n\tkgid_t gid;\n\tint arg = 0;\n\n#ifdef CONFIG_QUOTA\n\tif (token == Opt_usrjquota)\n\t\treturn set_qf_name(sb, USRQUOTA, &args[0]);\n\telse if (token == Opt_grpjquota)\n\t\treturn set_qf_name(sb, GRPQUOTA, &args[0]);\n\telse if (token == Opt_offusrjquota)\n\t\treturn clear_qf_name(sb, USRQUOTA);\n\telse if (token == Opt_offgrpjquota)\n\t\treturn clear_qf_name(sb, GRPQUOTA);\n#endif\n\tswitch (token) {\n\tcase Opt_noacl:\n\tcase Opt_nouser_xattr:\n\t\text4_msg(sb, KERN_WARNING, deprecated_msg, opt, \"3.5\");\n\t\tbreak;\n\tcase Opt_sb:\n\t\treturn 1;\t/* handled by get_sb_block() */\n\tcase Opt_removed:\n\t\text4_msg(sb, KERN_WARNING, \"Ignoring removed %s option\", opt);\n\t\treturn 1;\n\tcase Opt_abort:\n\t\tsbi->s_mount_flags |= EXT4_MF_FS_ABORTED;\n\t\treturn 1;\n\tcase Opt_i_version:\n\t\tsb->s_flags |= MS_I_VERSION;\n\t\treturn 1;\n\tcase Opt_lazytime:\n\t\tsb->s_flags |= MS_LAZYTIME;\n\t\treturn 1;\n\tcase Opt_nolazytime:\n\t\tsb->s_flags &= ~MS_LAZYTIME;\n\t\treturn 1;\n\t}\n\n\tfor (m = ext4_mount_opts; m->token != Opt_err; m++)\n\t\tif (token == m->token)\n\t\t\tbreak;\n\n\tif (m->token == Opt_err) {\n\t\text4_msg(sb, KERN_ERR, \"Unrecognized mount option \\\"%s\\\" \"\n\t\t\t \"or missing value\", opt);\n\t\treturn -1;\n\t}\n\n\tif ((m->flags & MOPT_NO_EXT2) && IS_EXT2_SB(sb)) {\n\t\text4_msg(sb, KERN_ERR,\n\t\t\t \"Mount option \\\"%s\\\" incompatible with ext2\", opt);\n\t\treturn -1;\n\t}\n\tif ((m->flags & MOPT_NO_EXT3) && IS_EXT3_SB(sb)) {\n\t\text4_msg(sb, KERN_ERR,\n\t\t\t \"Mount option \\\"%s\\\" incompatible with ext3\", opt);\n\t\treturn -1;\n\t}\n\n\tif (args->from && !(m->flags & MOPT_STRING) && match_int(args, &arg))\n\t\treturn -1;\n\tif (args->from && (m->flags & MOPT_GTE0) && (arg < 0))\n\t\treturn -1;\n\tif (m->flags & MOPT_EXPLICIT)\n\t\tset_opt2(sb, EXPLICIT_DELALLOC);\n\tif (m->flags & MOPT_CLEAR_ERR)\n\t\tclear_opt(sb, ERRORS_MASK);\n\tif (token == Opt_noquota && sb_any_quota_loaded(sb)) {\n\t\text4_msg(sb, KERN_ERR, \"Cannot change quota \"\n\t\t\t \"options when quota turned on\");\n\t\treturn -1;\n\t}\n\n\tif (m->flags & MOPT_NOSUPPORT) {\n\t\text4_msg(sb, KERN_ERR, \"%s option not supported\", opt);\n\t} else if (token == Opt_commit) {\n\t\tif (arg == 0)\n\t\t\targ = JBD2_DEFAULT_MAX_COMMIT_AGE;\n\t\tsbi->s_commit_interval = HZ * arg;\n\t} else if (token == Opt_max_batch_time) {\n\t\tsbi->s_max_batch_time = arg;\n\t} else if (token == Opt_min_batch_time) {\n\t\tsbi->s_min_batch_time = arg;\n\t} else if (token == Opt_inode_readahead_blks) {\n\t\tif (arg && (arg > (1 << 30) || !is_power_of_2(arg))) {\n\t\t\text4_msg(sb, KERN_ERR,\n\t\t\t\t \"EXT4-fs: inode_readahead_blks must be \"\n\t\t\t\t \"0 or a power of 2 smaller than 2^31\");\n\t\t\treturn -1;\n\t\t}\n\t\tsbi->s_inode_readahead_blks = arg;\n\t} else if (token == Opt_init_itable) {\n\t\tset_opt(sb, INIT_INODE_TABLE);\n\t\tif (!args->from)\n\t\t\targ = EXT4_DEF_LI_WAIT_MULT;\n\t\tsbi->s_li_wait_mult = arg;\n\t} else if (token == Opt_max_dir_size_kb) {\n\t\tsbi->s_max_dir_size_kb = arg;\n\t} else if (token == Opt_stripe) {\n\t\tsbi->s_stripe = arg;\n\t} else if (token == Opt_resuid) {\n\t\tuid = make_kuid(current_user_ns(), arg);\n\t\tif (!uid_valid(uid)) {\n\t\t\text4_msg(sb, KERN_ERR, \"Invalid uid value %d\", arg);\n\t\t\treturn -1;\n\t\t}\n\t\tsbi->s_resuid = uid;\n\t} else if (token == Opt_resgid) {\n\t\tgid = make_kgid(current_user_ns(), arg);\n\t\tif (!gid_valid(gid)) {\n\t\t\text4_msg(sb, KERN_ERR, \"Invalid gid value %d\", arg);\n\t\t\treturn -1;\n\t\t}\n\t\tsbi->s_resgid = gid;\n\t} else if (token == Opt_journal_dev) {\n\t\tif (is_remount) {\n\t\t\text4_msg(sb, KERN_ERR,\n\t\t\t\t \"Cannot specify journal on remount\");\n\t\t\treturn -1;\n\t\t}\n\t\t*journal_devnum = arg;\n\t} else if (token == Opt_journal_path) {\n\t\tchar *journal_path;\n\t\tstruct inode *journal_inode;\n\t\tstruct path path;\n\t\tint error;\n\n\t\tif (is_remount) {\n\t\t\text4_msg(sb, KERN_ERR,\n\t\t\t\t \"Cannot specify journal on remount\");\n\t\t\treturn -1;\n\t\t}\n\t\tjournal_path = match_strdup(&args[0]);\n\t\tif (!journal_path) {\n\t\t\text4_msg(sb, KERN_ERR, \"error: could not dup \"\n\t\t\t\t\"journal device string\");\n\t\t\treturn -1;\n\t\t}\n\n\t\terror = kern_path(journal_path, LOOKUP_FOLLOW, &path);\n\t\tif (error) {\n\t\t\text4_msg(sb, KERN_ERR, \"error: could not find \"\n\t\t\t\t\"journal device path: error %d\", error);\n\t\t\tkfree(journal_path);\n\t\t\treturn -1;\n\t\t}\n\n\t\tjournal_inode = path.dentry->d_inode;\n\t\tif (!S_ISBLK(journal_inode->i_mode)) {\n\t\t\text4_msg(sb, KERN_ERR, \"error: journal path %s \"\n\t\t\t\t\"is not a block device\", journal_path);\n\t\t\tpath_put(&path);\n\t\t\tkfree(journal_path);\n\t\t\treturn -1;\n\t\t}\n\n\t\t*journal_devnum = new_encode_dev(journal_inode->i_rdev);\n\t\tpath_put(&path);\n\t\tkfree(journal_path);\n\t} else if (token == Opt_journal_ioprio) {\n\t\tif (arg > 7) {\n\t\t\text4_msg(sb, KERN_ERR, \"Invalid journal IO priority\"\n\t\t\t\t \" (must be 0-7)\");\n\t\t\treturn -1;\n\t\t}\n\t\t*journal_ioprio =\n\t\t\tIOPRIO_PRIO_VALUE(IOPRIO_CLASS_BE, arg);\n\t} else if (m->flags & MOPT_DATAJ) {\n\t\tif (is_remount) {\n\t\t\tif (!sbi->s_journal)\n\t\t\t\text4_msg(sb, KERN_WARNING, \"Remounting file system with no journal so ignoring journalled data option\");\n\t\t\telse if (test_opt(sb, DATA_FLAGS) != m->mount_opt) {\n\t\t\t\text4_msg(sb, KERN_ERR,\n\t\t\t\t\t \"Cannot change data mode on remount\");\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t} else {\n\t\t\tclear_opt(sb, DATA_FLAGS);\n\t\t\tsbi->s_mount_opt |= m->mount_opt;\n\t\t}\n#ifdef CONFIG_QUOTA\n\t} else if (m->flags & MOPT_QFMT) {\n\t\tif (sb_any_quota_loaded(sb) &&\n\t\t    sbi->s_jquota_fmt != m->mount_opt) {\n\t\t\text4_msg(sb, KERN_ERR, \"Cannot change journaled \"\n\t\t\t\t \"quota options when quota turned on\");\n\t\t\treturn -1;\n\t\t}\n\t\tif (EXT4_HAS_RO_COMPAT_FEATURE(sb,\n\t\t\t\t\t       EXT4_FEATURE_RO_COMPAT_QUOTA)) {\n\t\t\text4_msg(sb, KERN_ERR,\n\t\t\t\t \"Cannot set journaled quota options \"\n\t\t\t\t \"when QUOTA feature is enabled\");\n\t\t\treturn -1;\n\t\t}\n\t\tsbi->s_jquota_fmt = m->mount_opt;\n#endif\n#ifndef CONFIG_FS_DAX\n\t} else if (token == Opt_dax) {\n\t\text4_msg(sb, KERN_INFO, \"dax option not supported\");\n\t\treturn -1;\n#endif\n\t} else {\n\t\tif (!args->from)\n\t\t\targ = 1;\n\t\tif (m->flags & MOPT_CLEAR)\n\t\t\targ = !arg;\n\t\telse if (unlikely(!(m->flags & MOPT_SET))) {\n\t\t\text4_msg(sb, KERN_WARNING,\n\t\t\t\t \"buggy handling of option %s\", opt);\n\t\t\tWARN_ON(1);\n\t\t\treturn -1;\n\t\t}\n\t\tif (arg != 0)\n\t\t\tsbi->s_mount_opt |= m->mount_opt;\n\t\telse\n\t\t\tsbi->s_mount_opt &= ~m->mount_opt;\n\t}\n\treturn 1;\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"mballoc.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include \"ext4_extents.h\"\t/* Needed for trace points definition */",
            "#include \"ext4.h\"",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/crc16.h>",
            "#include <linux/log2.h>",
            "#include <linux/ctype.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/random.h>",
            "#include <linux/vfs.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/parser.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/time.h>",
            "#include <linux/fs.h>",
            "#include <linux/string.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [
            "#define MOPT_STRING\t0x0400",
            "#define MOPT_NO_EXT3\t0x0200",
            "#define MOPT_NO_EXT2\t0x0100",
            "#define MOPT_DATAJ\t0x0080",
            "#define MOPT_QFMT\tMOPT_NOSUPPORT",
            "#define MOPT_QFMT\t0x0040",
            "#define MOPT_GTE0\t0x0020",
            "#define MOPT_CLEAR_ERR\t0x0010",
            "#define MOPT_EXPLICIT\t0x0008",
            "#define MOPT_NOSUPPORT\t0x0004",
            "#define MOPT_CLEAR\t0x0002",
            "#define MOPT_SET\t0x0001"
          ],
          "globals_used": [
            "static int ext4_load_journal(struct super_block *, struct ext4_super_block *,\n\t\t\t     unsigned long journal_devnum);",
            "static int ext4_remount(struct super_block *sb, int *flags, char *data);",
            "static int ext4_unfreeze(struct super_block *sb);",
            "static int ext4_freeze(struct super_block *sb);",
            "static struct dentry *ext4_mount(struct file_system_type *fs_type, int flags,\n\t\t       const char *dev_name, void *data);",
            "static inline int ext2_feature_set_ok(struct super_block *sb);",
            "static inline int ext3_feature_set_ok(struct super_block *sb);",
            "static void ext4_unregister_li_request(struct super_block *sb);",
            "static char deprecated_msg[] = \"Mount option \\\"%s\\\" will be removed by %s\\n\"\n\t\"Contact linux-ext4@vger.kernel.org if you think we should keep it.\\n\";",
            "static const struct mount_opts {\n\tint\ttoken;\n\tint\tmount_opt;\n\tint\tflags;\n} ext4_mount_opts[] = {\n\t{Opt_minix_df, EXT4_MOUNT_MINIX_DF, MOPT_SET},\n\t{Opt_bsd_df, EXT4_MOUNT_MINIX_DF, MOPT_CLEAR},\n\t{Opt_grpid, EXT4_MOUNT_GRPID, MOPT_SET},\n\t{Opt_nogrpid, EXT4_MOUNT_GRPID, MOPT_CLEAR},\n\t{Opt_block_validity, EXT4_MOUNT_BLOCK_VALIDITY, MOPT_SET},\n\t{Opt_noblock_validity, EXT4_MOUNT_BLOCK_VALIDITY, MOPT_CLEAR},\n\t{Opt_dioread_nolock, EXT4_MOUNT_DIOREAD_NOLOCK,\n\t MOPT_EXT4_ONLY | MOPT_SET},\n\t{Opt_dioread_lock, EXT4_MOUNT_DIOREAD_NOLOCK,\n\t MOPT_EXT4_ONLY | MOPT_CLEAR},\n\t{Opt_discard, EXT4_MOUNT_DISCARD, MOPT_SET},\n\t{Opt_nodiscard, EXT4_MOUNT_DISCARD, MOPT_CLEAR},\n\t{Opt_delalloc, EXT4_MOUNT_DELALLOC,\n\t MOPT_EXT4_ONLY | MOPT_SET | MOPT_EXPLICIT},\n\t{Opt_nodelalloc, EXT4_MOUNT_DELALLOC,\n\t MOPT_EXT4_ONLY | MOPT_CLEAR},\n\t{Opt_nojournal_checksum, EXT4_MOUNT_JOURNAL_CHECKSUM,\n\t MOPT_EXT4_ONLY | MOPT_CLEAR},\n\t{Opt_journal_checksum, EXT4_MOUNT_JOURNAL_CHECKSUM,\n\t MOPT_EXT4_ONLY | MOPT_SET},\n\t{Opt_journal_async_commit, (EXT4_MOUNT_JOURNAL_ASYNC_COMMIT |\n\t\t\t\t    EXT4_MOUNT_JOURNAL_CHECKSUM),\n\t MOPT_EXT4_ONLY | MOPT_SET},\n\t{Opt_noload, EXT4_MOUNT_NOLOAD, MOPT_NO_EXT2 | MOPT_SET},\n\t{Opt_err_panic, EXT4_MOUNT_ERRORS_PANIC, MOPT_SET | MOPT_CLEAR_ERR},\n\t{Opt_err_ro, EXT4_MOUNT_ERRORS_RO, MOPT_SET | MOPT_CLEAR_ERR},\n\t{Opt_err_cont, EXT4_MOUNT_ERRORS_CONT, MOPT_SET | MOPT_CLEAR_ERR},\n\t{Opt_data_err_abort, EXT4_MOUNT_DATA_ERR_ABORT,\n\t MOPT_NO_EXT2 | MOPT_SET},\n\t{Opt_data_err_ignore, EXT4_MOUNT_DATA_ERR_ABORT,\n\t MOPT_NO_EXT2 | MOPT_CLEAR},\n\t{Opt_barrier, EXT4_MOUNT_BARRIER, MOPT_SET},\n\t{Opt_nobarrier, EXT4_MOUNT_BARRIER, MOPT_CLEAR},\n\t{Opt_noauto_da_alloc, EXT4_MOUNT_NO_AUTO_DA_ALLOC, MOPT_SET},\n\t{Opt_auto_da_alloc, EXT4_MOUNT_NO_AUTO_DA_ALLOC, MOPT_CLEAR},\n\t{Opt_noinit_itable, EXT4_MOUNT_INIT_INODE_TABLE, MOPT_CLEAR},\n\t{Opt_commit, 0, MOPT_GTE0},\n\t{Opt_max_batch_time, 0, MOPT_GTE0},\n\t{Opt_min_batch_time, 0, MOPT_GTE0},\n\t{Opt_inode_readahead_blks, 0, MOPT_GTE0},\n\t{Opt_init_itable, 0, MOPT_GTE0},\n\t{Opt_dax, EXT4_MOUNT_DAX, MOPT_SET},\n\t{Opt_stripe, 0, MOPT_GTE0},\n\t{Opt_resuid, 0, MOPT_GTE0},\n\t{Opt_resgid, 0, MOPT_GTE0},\n\t{Opt_journal_dev, 0, MOPT_GTE0},\n\t{Opt_journal_path, 0, MOPT_STRING},\n\t{Opt_journal_ioprio, 0, MOPT_GTE0},\n\t{Opt_data_journal, EXT4_MOUNT_JOURNAL_DATA, MOPT_NO_EXT2 | MOPT_DATAJ},\n\t{Opt_data_ordered, EXT4_MOUNT_ORDERED_DATA, MOPT_NO_EXT2 | MOPT_DATAJ},\n\t{Opt_data_writeback, EXT4_MOUNT_WRITEBACK_DATA,\n\t MOPT_NO_EXT2 | MOPT_DATAJ},\n\t{Opt_user_xattr, EXT4_MOUNT_XATTR_USER, MOPT_SET},\n\t{Opt_nouser_xattr, EXT4_MOUNT_XATTR_USER, MOPT_CLEAR},\n#ifdef CONFIG_EXT4_FS_POSIX_ACL\n\t{Opt_acl, EXT4_MOUNT_POSIX_ACL, MOPT_SET},\n\t{Opt_noacl, EXT4_MOUNT_POSIX_ACL, MOPT_CLEAR},\n#else\n\t{Opt_acl, 0, MOPT_NOSUPPORT},\n\t{Opt_noacl, 0, MOPT_NOSUPPORT},\n#endif\n\t{Opt_nouid32, EXT4_MOUNT_NO_UID32, MOPT_SET},\n\t{Opt_debug, EXT4_MOUNT_DEBUG, MOPT_SET},\n\t{Opt_quota, EXT4_MOUNT_QUOTA | EXT4_MOUNT_USRQUOTA, MOPT_SET | MOPT_Q},\n\t{Opt_usrquota, EXT4_MOUNT_QUOTA | EXT4_MOUNT_USRQUOTA,\n\t\t\t\t\t\t\tMOPT_SET | MOPT_Q},\n\t{Opt_grpquota, EXT4_MOUNT_QUOTA | EXT4_MOUNT_GRPQUOTA,\n\t\t\t\t\t\t\tMOPT_SET | MOPT_Q},\n\t{Opt_noquota, (EXT4_MOUNT_QUOTA | EXT4_MOUNT_USRQUOTA |\n\t\t       EXT4_MOUNT_GRPQUOTA), MOPT_CLEAR | MOPT_Q},\n\t{Opt_usrjquota, 0, MOPT_Q},\n\t{Opt_grpjquota, 0, MOPT_Q},\n\t{Opt_offusrjquota, 0, MOPT_Q},\n\t{Opt_offgrpjquota, 0, MOPT_Q},\n\t{Opt_jqfmt_vfsold, QFMT_VFS_OLD, MOPT_QFMT},\n\t{Opt_jqfmt_vfsv0, QFMT_VFS_V0, MOPT_QFMT},\n\t{Opt_jqfmt_vfsv1, QFMT_VFS_V1, MOPT_QFMT},\n\t{Opt_max_dir_size_kb, 0, MOPT_GTE0},\n\t{Opt_err, 0, 0}\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"mballoc.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4_extents.h\"\t/* Needed for trace points definition */\n#include \"ext4.h\"\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <asm/uaccess.h>\n#include <linux/cleancache.h>\n#include <linux/crc16.h>\n#include <linux/log2.h>\n#include <linux/ctype.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/random.h>\n#include <linux/vfs.h>\n#include <linux/exportfs.h>\n#include <linux/buffer_head.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/jbd2.h>\n#include <linux/vmalloc.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n#include <linux/string.h>\n#include <linux/module.h>\n\n#define MOPT_STRING\t0x0400\n#define MOPT_NO_EXT3\t0x0200\n#define MOPT_NO_EXT2\t0x0100\n#define MOPT_DATAJ\t0x0080\n#define MOPT_QFMT\tMOPT_NOSUPPORT\n#define MOPT_QFMT\t0x0040\n#define MOPT_GTE0\t0x0020\n#define MOPT_CLEAR_ERR\t0x0010\n#define MOPT_EXPLICIT\t0x0008\n#define MOPT_NOSUPPORT\t0x0004\n#define MOPT_CLEAR\t0x0002\n#define MOPT_SET\t0x0001\n\nstatic int ext4_load_journal(struct super_block *, struct ext4_super_block *,\n\t\t\t     unsigned long journal_devnum);\nstatic int ext4_remount(struct super_block *sb, int *flags, char *data);\nstatic int ext4_unfreeze(struct super_block *sb);\nstatic int ext4_freeze(struct super_block *sb);\nstatic struct dentry *ext4_mount(struct file_system_type *fs_type, int flags,\n\t\t       const char *dev_name, void *data);\nstatic inline int ext2_feature_set_ok(struct super_block *sb);\nstatic inline int ext3_feature_set_ok(struct super_block *sb);\nstatic void ext4_unregister_li_request(struct super_block *sb);\nstatic char deprecated_msg[] = \"Mount option \\\"%s\\\" will be removed by %s\\n\"\n\t\"Contact linux-ext4@vger.kernel.org if you think we should keep it.\\n\";\nstatic const struct mount_opts {\n\tint\ttoken;\n\tint\tmount_opt;\n\tint\tflags;\n} ext4_mount_opts[] = {\n\t{Opt_minix_df, EXT4_MOUNT_MINIX_DF, MOPT_SET},\n\t{Opt_bsd_df, EXT4_MOUNT_MINIX_DF, MOPT_CLEAR},\n\t{Opt_grpid, EXT4_MOUNT_GRPID, MOPT_SET},\n\t{Opt_nogrpid, EXT4_MOUNT_GRPID, MOPT_CLEAR},\n\t{Opt_block_validity, EXT4_MOUNT_BLOCK_VALIDITY, MOPT_SET},\n\t{Opt_noblock_validity, EXT4_MOUNT_BLOCK_VALIDITY, MOPT_CLEAR},\n\t{Opt_dioread_nolock, EXT4_MOUNT_DIOREAD_NOLOCK,\n\t MOPT_EXT4_ONLY | MOPT_SET},\n\t{Opt_dioread_lock, EXT4_MOUNT_DIOREAD_NOLOCK,\n\t MOPT_EXT4_ONLY | MOPT_CLEAR},\n\t{Opt_discard, EXT4_MOUNT_DISCARD, MOPT_SET},\n\t{Opt_nodiscard, EXT4_MOUNT_DISCARD, MOPT_CLEAR},\n\t{Opt_delalloc, EXT4_MOUNT_DELALLOC,\n\t MOPT_EXT4_ONLY | MOPT_SET | MOPT_EXPLICIT},\n\t{Opt_nodelalloc, EXT4_MOUNT_DELALLOC,\n\t MOPT_EXT4_ONLY | MOPT_CLEAR},\n\t{Opt_nojournal_checksum, EXT4_MOUNT_JOURNAL_CHECKSUM,\n\t MOPT_EXT4_ONLY | MOPT_CLEAR},\n\t{Opt_journal_checksum, EXT4_MOUNT_JOURNAL_CHECKSUM,\n\t MOPT_EXT4_ONLY | MOPT_SET},\n\t{Opt_journal_async_commit, (EXT4_MOUNT_JOURNAL_ASYNC_COMMIT |\n\t\t\t\t    EXT4_MOUNT_JOURNAL_CHECKSUM),\n\t MOPT_EXT4_ONLY | MOPT_SET},\n\t{Opt_noload, EXT4_MOUNT_NOLOAD, MOPT_NO_EXT2 | MOPT_SET},\n\t{Opt_err_panic, EXT4_MOUNT_ERRORS_PANIC, MOPT_SET | MOPT_CLEAR_ERR},\n\t{Opt_err_ro, EXT4_MOUNT_ERRORS_RO, MOPT_SET | MOPT_CLEAR_ERR},\n\t{Opt_err_cont, EXT4_MOUNT_ERRORS_CONT, MOPT_SET | MOPT_CLEAR_ERR},\n\t{Opt_data_err_abort, EXT4_MOUNT_DATA_ERR_ABORT,\n\t MOPT_NO_EXT2 | MOPT_SET},\n\t{Opt_data_err_ignore, EXT4_MOUNT_DATA_ERR_ABORT,\n\t MOPT_NO_EXT2 | MOPT_CLEAR},\n\t{Opt_barrier, EXT4_MOUNT_BARRIER, MOPT_SET},\n\t{Opt_nobarrier, EXT4_MOUNT_BARRIER, MOPT_CLEAR},\n\t{Opt_noauto_da_alloc, EXT4_MOUNT_NO_AUTO_DA_ALLOC, MOPT_SET},\n\t{Opt_auto_da_alloc, EXT4_MOUNT_NO_AUTO_DA_ALLOC, MOPT_CLEAR},\n\t{Opt_noinit_itable, EXT4_MOUNT_INIT_INODE_TABLE, MOPT_CLEAR},\n\t{Opt_commit, 0, MOPT_GTE0},\n\t{Opt_max_batch_time, 0, MOPT_GTE0},\n\t{Opt_min_batch_time, 0, MOPT_GTE0},\n\t{Opt_inode_readahead_blks, 0, MOPT_GTE0},\n\t{Opt_init_itable, 0, MOPT_GTE0},\n\t{Opt_dax, EXT4_MOUNT_DAX, MOPT_SET},\n\t{Opt_stripe, 0, MOPT_GTE0},\n\t{Opt_resuid, 0, MOPT_GTE0},\n\t{Opt_resgid, 0, MOPT_GTE0},\n\t{Opt_journal_dev, 0, MOPT_GTE0},\n\t{Opt_journal_path, 0, MOPT_STRING},\n\t{Opt_journal_ioprio, 0, MOPT_GTE0},\n\t{Opt_data_journal, EXT4_MOUNT_JOURNAL_DATA, MOPT_NO_EXT2 | MOPT_DATAJ},\n\t{Opt_data_ordered, EXT4_MOUNT_ORDERED_DATA, MOPT_NO_EXT2 | MOPT_DATAJ},\n\t{Opt_data_writeback, EXT4_MOUNT_WRITEBACK_DATA,\n\t MOPT_NO_EXT2 | MOPT_DATAJ},\n\t{Opt_user_xattr, EXT4_MOUNT_XATTR_USER, MOPT_SET},\n\t{Opt_nouser_xattr, EXT4_MOUNT_XATTR_USER, MOPT_CLEAR},\n#ifdef CONFIG_EXT4_FS_POSIX_ACL\n\t{Opt_acl, EXT4_MOUNT_POSIX_ACL, MOPT_SET},\n\t{Opt_noacl, EXT4_MOUNT_POSIX_ACL, MOPT_CLEAR},\n#else\n\t{Opt_acl, 0, MOPT_NOSUPPORT},\n\t{Opt_noacl, 0, MOPT_NOSUPPORT},\n#endif\n\t{Opt_nouid32, EXT4_MOUNT_NO_UID32, MOPT_SET},\n\t{Opt_debug, EXT4_MOUNT_DEBUG, MOPT_SET},\n\t{Opt_quota, EXT4_MOUNT_QUOTA | EXT4_MOUNT_USRQUOTA, MOPT_SET | MOPT_Q},\n\t{Opt_usrquota, EXT4_MOUNT_QUOTA | EXT4_MOUNT_USRQUOTA,\n\t\t\t\t\t\t\tMOPT_SET | MOPT_Q},\n\t{Opt_grpquota, EXT4_MOUNT_QUOTA | EXT4_MOUNT_GRPQUOTA,\n\t\t\t\t\t\t\tMOPT_SET | MOPT_Q},\n\t{Opt_noquota, (EXT4_MOUNT_QUOTA | EXT4_MOUNT_USRQUOTA |\n\t\t       EXT4_MOUNT_GRPQUOTA), MOPT_CLEAR | MOPT_Q},\n\t{Opt_usrjquota, 0, MOPT_Q},\n\t{Opt_grpjquota, 0, MOPT_Q},\n\t{Opt_offusrjquota, 0, MOPT_Q},\n\t{Opt_offgrpjquota, 0, MOPT_Q},\n\t{Opt_jqfmt_vfsold, QFMT_VFS_OLD, MOPT_QFMT},\n\t{Opt_jqfmt_vfsv0, QFMT_VFS_V0, MOPT_QFMT},\n\t{Opt_jqfmt_vfsv1, QFMT_VFS_V1, MOPT_QFMT},\n\t{Opt_max_dir_size_kb, 0, MOPT_GTE0},\n\t{Opt_err, 0, 0}\n};\n\nstatic int handle_mount_opt(struct super_block *sb, char *opt, int token,\n\t\t\t    substring_t *args, unsigned long *journal_devnum,\n\t\t\t    unsigned int *journal_ioprio, int is_remount)\n{\n\tstruct ext4_sb_info *sbi = EXT4_SB(sb);\n\tconst struct mount_opts *m;\n\tkuid_t uid;\n\tkgid_t gid;\n\tint arg = 0;\n\n#ifdef CONFIG_QUOTA\n\tif (token == Opt_usrjquota)\n\t\treturn set_qf_name(sb, USRQUOTA, &args[0]);\n\telse if (token == Opt_grpjquota)\n\t\treturn set_qf_name(sb, GRPQUOTA, &args[0]);\n\telse if (token == Opt_offusrjquota)\n\t\treturn clear_qf_name(sb, USRQUOTA);\n\telse if (token == Opt_offgrpjquota)\n\t\treturn clear_qf_name(sb, GRPQUOTA);\n#endif\n\tswitch (token) {\n\tcase Opt_noacl:\n\tcase Opt_nouser_xattr:\n\t\text4_msg(sb, KERN_WARNING, deprecated_msg, opt, \"3.5\");\n\t\tbreak;\n\tcase Opt_sb:\n\t\treturn 1;\t/* handled by get_sb_block() */\n\tcase Opt_removed:\n\t\text4_msg(sb, KERN_WARNING, \"Ignoring removed %s option\", opt);\n\t\treturn 1;\n\tcase Opt_abort:\n\t\tsbi->s_mount_flags |= EXT4_MF_FS_ABORTED;\n\t\treturn 1;\n\tcase Opt_i_version:\n\t\tsb->s_flags |= MS_I_VERSION;\n\t\treturn 1;\n\tcase Opt_lazytime:\n\t\tsb->s_flags |= MS_LAZYTIME;\n\t\treturn 1;\n\tcase Opt_nolazytime:\n\t\tsb->s_flags &= ~MS_LAZYTIME;\n\t\treturn 1;\n\t}\n\n\tfor (m = ext4_mount_opts; m->token != Opt_err; m++)\n\t\tif (token == m->token)\n\t\t\tbreak;\n\n\tif (m->token == Opt_err) {\n\t\text4_msg(sb, KERN_ERR, \"Unrecognized mount option \\\"%s\\\" \"\n\t\t\t \"or missing value\", opt);\n\t\treturn -1;\n\t}\n\n\tif ((m->flags & MOPT_NO_EXT2) && IS_EXT2_SB(sb)) {\n\t\text4_msg(sb, KERN_ERR,\n\t\t\t \"Mount option \\\"%s\\\" incompatible with ext2\", opt);\n\t\treturn -1;\n\t}\n\tif ((m->flags & MOPT_NO_EXT3) && IS_EXT3_SB(sb)) {\n\t\text4_msg(sb, KERN_ERR,\n\t\t\t \"Mount option \\\"%s\\\" incompatible with ext3\", opt);\n\t\treturn -1;\n\t}\n\n\tif (args->from && !(m->flags & MOPT_STRING) && match_int(args, &arg))\n\t\treturn -1;\n\tif (args->from && (m->flags & MOPT_GTE0) && (arg < 0))\n\t\treturn -1;\n\tif (m->flags & MOPT_EXPLICIT)\n\t\tset_opt2(sb, EXPLICIT_DELALLOC);\n\tif (m->flags & MOPT_CLEAR_ERR)\n\t\tclear_opt(sb, ERRORS_MASK);\n\tif (token == Opt_noquota && sb_any_quota_loaded(sb)) {\n\t\text4_msg(sb, KERN_ERR, \"Cannot change quota \"\n\t\t\t \"options when quota turned on\");\n\t\treturn -1;\n\t}\n\n\tif (m->flags & MOPT_NOSUPPORT) {\n\t\text4_msg(sb, KERN_ERR, \"%s option not supported\", opt);\n\t} else if (token == Opt_commit) {\n\t\tif (arg == 0)\n\t\t\targ = JBD2_DEFAULT_MAX_COMMIT_AGE;\n\t\tsbi->s_commit_interval = HZ * arg;\n\t} else if (token == Opt_max_batch_time) {\n\t\tsbi->s_max_batch_time = arg;\n\t} else if (token == Opt_min_batch_time) {\n\t\tsbi->s_min_batch_time = arg;\n\t} else if (token == Opt_inode_readahead_blks) {\n\t\tif (arg && (arg > (1 << 30) || !is_power_of_2(arg))) {\n\t\t\text4_msg(sb, KERN_ERR,\n\t\t\t\t \"EXT4-fs: inode_readahead_blks must be \"\n\t\t\t\t \"0 or a power of 2 smaller than 2^31\");\n\t\t\treturn -1;\n\t\t}\n\t\tsbi->s_inode_readahead_blks = arg;\n\t} else if (token == Opt_init_itable) {\n\t\tset_opt(sb, INIT_INODE_TABLE);\n\t\tif (!args->from)\n\t\t\targ = EXT4_DEF_LI_WAIT_MULT;\n\t\tsbi->s_li_wait_mult = arg;\n\t} else if (token == Opt_max_dir_size_kb) {\n\t\tsbi->s_max_dir_size_kb = arg;\n\t} else if (token == Opt_stripe) {\n\t\tsbi->s_stripe = arg;\n\t} else if (token == Opt_resuid) {\n\t\tuid = make_kuid(current_user_ns(), arg);\n\t\tif (!uid_valid(uid)) {\n\t\t\text4_msg(sb, KERN_ERR, \"Invalid uid value %d\", arg);\n\t\t\treturn -1;\n\t\t}\n\t\tsbi->s_resuid = uid;\n\t} else if (token == Opt_resgid) {\n\t\tgid = make_kgid(current_user_ns(), arg);\n\t\tif (!gid_valid(gid)) {\n\t\t\text4_msg(sb, KERN_ERR, \"Invalid gid value %d\", arg);\n\t\t\treturn -1;\n\t\t}\n\t\tsbi->s_resgid = gid;\n\t} else if (token == Opt_journal_dev) {\n\t\tif (is_remount) {\n\t\t\text4_msg(sb, KERN_ERR,\n\t\t\t\t \"Cannot specify journal on remount\");\n\t\t\treturn -1;\n\t\t}\n\t\t*journal_devnum = arg;\n\t} else if (token == Opt_journal_path) {\n\t\tchar *journal_path;\n\t\tstruct inode *journal_inode;\n\t\tstruct path path;\n\t\tint error;\n\n\t\tif (is_remount) {\n\t\t\text4_msg(sb, KERN_ERR,\n\t\t\t\t \"Cannot specify journal on remount\");\n\t\t\treturn -1;\n\t\t}\n\t\tjournal_path = match_strdup(&args[0]);\n\t\tif (!journal_path) {\n\t\t\text4_msg(sb, KERN_ERR, \"error: could not dup \"\n\t\t\t\t\"journal device string\");\n\t\t\treturn -1;\n\t\t}\n\n\t\terror = kern_path(journal_path, LOOKUP_FOLLOW, &path);\n\t\tif (error) {\n\t\t\text4_msg(sb, KERN_ERR, \"error: could not find \"\n\t\t\t\t\"journal device path: error %d\", error);\n\t\t\tkfree(journal_path);\n\t\t\treturn -1;\n\t\t}\n\n\t\tjournal_inode = path.dentry->d_inode;\n\t\tif (!S_ISBLK(journal_inode->i_mode)) {\n\t\t\text4_msg(sb, KERN_ERR, \"error: journal path %s \"\n\t\t\t\t\"is not a block device\", journal_path);\n\t\t\tpath_put(&path);\n\t\t\tkfree(journal_path);\n\t\t\treturn -1;\n\t\t}\n\n\t\t*journal_devnum = new_encode_dev(journal_inode->i_rdev);\n\t\tpath_put(&path);\n\t\tkfree(journal_path);\n\t} else if (token == Opt_journal_ioprio) {\n\t\tif (arg > 7) {\n\t\t\text4_msg(sb, KERN_ERR, \"Invalid journal IO priority\"\n\t\t\t\t \" (must be 0-7)\");\n\t\t\treturn -1;\n\t\t}\n\t\t*journal_ioprio =\n\t\t\tIOPRIO_PRIO_VALUE(IOPRIO_CLASS_BE, arg);\n\t} else if (m->flags & MOPT_DATAJ) {\n\t\tif (is_remount) {\n\t\t\tif (!sbi->s_journal)\n\t\t\t\text4_msg(sb, KERN_WARNING, \"Remounting file system with no journal so ignoring journalled data option\");\n\t\t\telse if (test_opt(sb, DATA_FLAGS) != m->mount_opt) {\n\t\t\t\text4_msg(sb, KERN_ERR,\n\t\t\t\t\t \"Cannot change data mode on remount\");\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t} else {\n\t\t\tclear_opt(sb, DATA_FLAGS);\n\t\t\tsbi->s_mount_opt |= m->mount_opt;\n\t\t}\n#ifdef CONFIG_QUOTA\n\t} else if (m->flags & MOPT_QFMT) {\n\t\tif (sb_any_quota_loaded(sb) &&\n\t\t    sbi->s_jquota_fmt != m->mount_opt) {\n\t\t\text4_msg(sb, KERN_ERR, \"Cannot change journaled \"\n\t\t\t\t \"quota options when quota turned on\");\n\t\t\treturn -1;\n\t\t}\n\t\tif (EXT4_HAS_RO_COMPAT_FEATURE(sb,\n\t\t\t\t\t       EXT4_FEATURE_RO_COMPAT_QUOTA)) {\n\t\t\text4_msg(sb, KERN_ERR,\n\t\t\t\t \"Cannot set journaled quota options \"\n\t\t\t\t \"when QUOTA feature is enabled\");\n\t\t\treturn -1;\n\t\t}\n\t\tsbi->s_jquota_fmt = m->mount_opt;\n#endif\n#ifndef CONFIG_FS_DAX\n\t} else if (token == Opt_dax) {\n\t\text4_msg(sb, KERN_INFO, \"dax option not supported\");\n\t\treturn -1;\n#endif\n\t} else {\n\t\tif (!args->from)\n\t\t\targ = 1;\n\t\tif (m->flags & MOPT_CLEAR)\n\t\t\targ = !arg;\n\t\telse if (unlikely(!(m->flags & MOPT_SET))) {\n\t\t\text4_msg(sb, KERN_WARNING,\n\t\t\t\t \"buggy handling of option %s\", opt);\n\t\t\tWARN_ON(1);\n\t\t\treturn -1;\n\t\t}\n\t\tif (arg != 0)\n\t\t\tsbi->s_mount_opt |= m->mount_opt;\n\t\telse\n\t\t\tsbi->s_mount_opt &= ~m->mount_opt;\n\t}\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "match_token",
          "args": [
            "p",
            "tokens",
            "args"
          ],
          "line": 1666
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strsep",
          "args": [
            "&options",
            "\",\""
          ],
          "line": 1658
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXT4_SB",
          "args": [
            "sb"
          ],
          "line": 1650
        },
        "resolved": true,
        "details": {
          "function_name": "EXT4_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ext4.h",
          "lines": "1356-1359",
          "snippet": "static inline struct ext4_sb_info *EXT4_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include \"extents_status.h\"",
            "#include <linux/compat.h>",
            "#include <linux/falloc.h>",
            "#include <crypto/hash.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/wait.h>",
            "#include <linux/timer.h>",
            "#include <linux/mutex.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/quota.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extents_status.h\"\n#include <linux/compat.h>\n#include <linux/falloc.h>\n#include <crypto/hash.h>\n#include <linux/ratelimit.h>\n#include <linux/percpu_counter.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/wait.h>\n#include <linux/timer.h>\n#include <linux/mutex.h>\n#include <linux/seqlock.h>\n#include <linux/rbtree.h>\n#include <linux/rwsem.h>\n#include <linux/quota.h>\n#include <linux/jbd2.h>\n#include <linux/magic.h>\n#include <linux/blkdev.h>\n#include <linux/types.h>\n\nstatic inline struct ext4_sb_info *EXT4_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"mballoc.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4_extents.h\"\t/* Needed for trace points definition */\n#include \"ext4.h\"\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <asm/uaccess.h>\n#include <linux/cleancache.h>\n#include <linux/crc16.h>\n#include <linux/log2.h>\n#include <linux/ctype.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/random.h>\n#include <linux/vfs.h>\n#include <linux/exportfs.h>\n#include <linux/buffer_head.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/jbd2.h>\n#include <linux/vmalloc.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n#include <linux/string.h>\n#include <linux/module.h>\n\nstatic int ext4_load_journal(struct super_block *, struct ext4_super_block *,\n\t\t\t     unsigned long journal_devnum);\nstatic int ext4_remount(struct super_block *sb, int *flags, char *data);\nstatic int ext4_unfreeze(struct super_block *sb);\nstatic int ext4_freeze(struct super_block *sb);\nstatic struct dentry *ext4_mount(struct file_system_type *fs_type, int flags,\n\t\t       const char *dev_name, void *data);\nstatic inline int ext2_feature_set_ok(struct super_block *sb);\nstatic inline int ext3_feature_set_ok(struct super_block *sb);\nstatic void ext4_unregister_li_request(struct super_block *sb);\nstatic const match_table_t tokens = {\n\t{Opt_bsd_df, \"bsddf\"},\n\t{Opt_minix_df, \"minixdf\"},\n\t{Opt_grpid, \"grpid\"},\n\t{Opt_grpid, \"bsdgroups\"},\n\t{Opt_nogrpid, \"nogrpid\"},\n\t{Opt_nogrpid, \"sysvgroups\"},\n\t{Opt_resgid, \"resgid=%u\"},\n\t{Opt_resuid, \"resuid=%u\"},\n\t{Opt_sb, \"sb=%u\"},\n\t{Opt_err_cont, \"errors=continue\"},\n\t{Opt_err_panic, \"errors=panic\"},\n\t{Opt_err_ro, \"errors=remount-ro\"},\n\t{Opt_nouid32, \"nouid32\"},\n\t{Opt_debug, \"debug\"},\n\t{Opt_removed, \"oldalloc\"},\n\t{Opt_removed, \"orlov\"},\n\t{Opt_user_xattr, \"user_xattr\"},\n\t{Opt_nouser_xattr, \"nouser_xattr\"},\n\t{Opt_acl, \"acl\"},\n\t{Opt_noacl, \"noacl\"},\n\t{Opt_noload, \"norecovery\"},\n\t{Opt_noload, \"noload\"},\n\t{Opt_removed, \"nobh\"},\n\t{Opt_removed, \"bh\"},\n\t{Opt_commit, \"commit=%u\"},\n\t{Opt_min_batch_time, \"min_batch_time=%u\"},\n\t{Opt_max_batch_time, \"max_batch_time=%u\"},\n\t{Opt_journal_dev, \"journal_dev=%u\"},\n\t{Opt_journal_path, \"journal_path=%s\"},\n\t{Opt_journal_checksum, \"journal_checksum\"},\n\t{Opt_nojournal_checksum, \"nojournal_checksum\"},\n\t{Opt_journal_async_commit, \"journal_async_commit\"},\n\t{Opt_abort, \"abort\"},\n\t{Opt_data_journal, \"data=journal\"},\n\t{Opt_data_ordered, \"data=ordered\"},\n\t{Opt_data_writeback, \"data=writeback\"},\n\t{Opt_data_err_abort, \"data_err=abort\"},\n\t{Opt_data_err_ignore, \"data_err=ignore\"},\n\t{Opt_offusrjquota, \"usrjquota=\"},\n\t{Opt_usrjquota, \"usrjquota=%s\"},\n\t{Opt_offgrpjquota, \"grpjquota=\"},\n\t{Opt_grpjquota, \"grpjquota=%s\"},\n\t{Opt_jqfmt_vfsold, \"jqfmt=vfsold\"},\n\t{Opt_jqfmt_vfsv0, \"jqfmt=vfsv0\"},\n\t{Opt_jqfmt_vfsv1, \"jqfmt=vfsv1\"},\n\t{Opt_grpquota, \"grpquota\"},\n\t{Opt_noquota, \"noquota\"},\n\t{Opt_quota, \"quota\"},\n\t{Opt_usrquota, \"usrquota\"},\n\t{Opt_barrier, \"barrier=%u\"},\n\t{Opt_barrier, \"barrier\"},\n\t{Opt_nobarrier, \"nobarrier\"},\n\t{Opt_i_version, \"i_version\"},\n\t{Opt_dax, \"dax\"},\n\t{Opt_stripe, \"stripe=%u\"},\n\t{Opt_delalloc, \"delalloc\"},\n\t{Opt_lazytime, \"lazytime\"},\n\t{Opt_nolazytime, \"nolazytime\"},\n\t{Opt_nodelalloc, \"nodelalloc\"},\n\t{Opt_removed, \"mblk_io_submit\"},\n\t{Opt_removed, \"nomblk_io_submit\"},\n\t{Opt_block_validity, \"block_validity\"},\n\t{Opt_noblock_validity, \"noblock_validity\"},\n\t{Opt_inode_readahead_blks, \"inode_readahead_blks=%u\"},\n\t{Opt_journal_ioprio, \"journal_ioprio=%u\"},\n\t{Opt_auto_da_alloc, \"auto_da_alloc=%u\"},\n\t{Opt_auto_da_alloc, \"auto_da_alloc\"},\n\t{Opt_noauto_da_alloc, \"noauto_da_alloc\"},\n\t{Opt_dioread_nolock, \"dioread_nolock\"},\n\t{Opt_dioread_lock, \"dioread_lock\"},\n\t{Opt_discard, \"discard\"},\n\t{Opt_nodiscard, \"nodiscard\"},\n\t{Opt_init_itable, \"init_itable=%u\"},\n\t{Opt_init_itable, \"init_itable\"},\n\t{Opt_noinit_itable, \"noinit_itable\"},\n\t{Opt_max_dir_size_kb, \"max_dir_size_kb=%u\"},\n\t{Opt_removed, \"check=none\"},\t/* mount option from ext2/3 */\n\t{Opt_removed, \"nocheck\"},\t/* mount option from ext2/3 */\n\t{Opt_removed, \"reservation\"},\t/* mount option from ext2/3 */\n\t{Opt_removed, \"noreservation\"}, /* mount option from ext2/3 */\n\t{Opt_removed, \"journal=%u\"},\t/* mount option from ext2/3 */\n\t{Opt_err, NULL},\n};\n\nstatic int parse_options(char *options, struct super_block *sb,\n\t\t\t unsigned long *journal_devnum,\n\t\t\t unsigned int *journal_ioprio,\n\t\t\t int is_remount)\n{\n\tstruct ext4_sb_info *sbi = EXT4_SB(sb);\n\tchar *p;\n\tsubstring_t args[MAX_OPT_ARGS];\n\tint token;\n\n\tif (!options)\n\t\treturn 1;\n\n\twhile ((p = strsep(&options, \",\")) != NULL) {\n\t\tif (!*p)\n\t\t\tcontinue;\n\t\t/*\n\t\t * Initialize args struct so we know whether arg was\n\t\t * found; some options take optional arguments.\n\t\t */\n\t\targs[0].to = args[0].from = NULL;\n\t\ttoken = match_token(p, tokens, args);\n\t\tif (handle_mount_opt(sb, p, token, args, journal_devnum,\n\t\t\t\t     journal_ioprio, is_remount) < 0)\n\t\t\treturn 0;\n\t}\n#ifdef CONFIG_QUOTA\n\tif (EXT4_HAS_RO_COMPAT_FEATURE(sb, EXT4_FEATURE_RO_COMPAT_QUOTA) &&\n\t    (test_opt(sb, USRQUOTA) || test_opt(sb, GRPQUOTA))) {\n\t\text4_msg(sb, KERN_ERR, \"Cannot set quota options when QUOTA \"\n\t\t\t \"feature is enabled\");\n\t\treturn 0;\n\t}\n\tif (sbi->s_qf_names[USRQUOTA] || sbi->s_qf_names[GRPQUOTA]) {\n\t\tif (test_opt(sb, USRQUOTA) && sbi->s_qf_names[USRQUOTA])\n\t\t\tclear_opt(sb, USRQUOTA);\n\n\t\tif (test_opt(sb, GRPQUOTA) && sbi->s_qf_names[GRPQUOTA])\n\t\t\tclear_opt(sb, GRPQUOTA);\n\n\t\tif (test_opt(sb, GRPQUOTA) || test_opt(sb, USRQUOTA)) {\n\t\t\text4_msg(sb, KERN_ERR, \"old and new quota \"\n\t\t\t\t\t\"format mixing\");\n\t\t\treturn 0;\n\t\t}\n\n\t\tif (!sbi->s_jquota_fmt) {\n\t\t\text4_msg(sb, KERN_ERR, \"journaled quota format \"\n\t\t\t\t\t\"not specified\");\n\t\t\treturn 0;\n\t\t}\n\t}\n#endif\n\tif (test_opt(sb, DIOREAD_NOLOCK)) {\n\t\tint blocksize =\n\t\t\tBLOCK_SIZE << le32_to_cpu(sbi->s_es->s_log_block_size);\n\n\t\tif (blocksize < PAGE_CACHE_SIZE) {\n\t\t\text4_msg(sb, KERN_ERR, \"can't mount with \"\n\t\t\t\t \"dioread_nolock if block size != PAGE_SIZE\");\n\t\t\treturn 0;\n\t\t}\n\t}\n\tif (test_opt(sb, DATA_FLAGS) == EXT4_MOUNT_ORDERED_DATA &&\n\t    test_opt(sb, JOURNAL_ASYNC_COMMIT)) {\n\t\text4_msg(sb, KERN_ERR, \"can't mount with journal_async_commit \"\n\t\t\t \"in data=ordered mode\");\n\t\treturn 0;\n\t}\n\treturn 1;\n}"
  },
  {
    "function_name": "handle_mount_opt",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/super.c",
    "lines": "1418-1643",
    "snippet": "static int handle_mount_opt(struct super_block *sb, char *opt, int token,\n\t\t\t    substring_t *args, unsigned long *journal_devnum,\n\t\t\t    unsigned int *journal_ioprio, int is_remount)\n{\n\tstruct ext4_sb_info *sbi = EXT4_SB(sb);\n\tconst struct mount_opts *m;\n\tkuid_t uid;\n\tkgid_t gid;\n\tint arg = 0;\n\n#ifdef CONFIG_QUOTA\n\tif (token == Opt_usrjquota)\n\t\treturn set_qf_name(sb, USRQUOTA, &args[0]);\n\telse if (token == Opt_grpjquota)\n\t\treturn set_qf_name(sb, GRPQUOTA, &args[0]);\n\telse if (token == Opt_offusrjquota)\n\t\treturn clear_qf_name(sb, USRQUOTA);\n\telse if (token == Opt_offgrpjquota)\n\t\treturn clear_qf_name(sb, GRPQUOTA);\n#endif\n\tswitch (token) {\n\tcase Opt_noacl:\n\tcase Opt_nouser_xattr:\n\t\text4_msg(sb, KERN_WARNING, deprecated_msg, opt, \"3.5\");\n\t\tbreak;\n\tcase Opt_sb:\n\t\treturn 1;\t/* handled by get_sb_block() */\n\tcase Opt_removed:\n\t\text4_msg(sb, KERN_WARNING, \"Ignoring removed %s option\", opt);\n\t\treturn 1;\n\tcase Opt_abort:\n\t\tsbi->s_mount_flags |= EXT4_MF_FS_ABORTED;\n\t\treturn 1;\n\tcase Opt_i_version:\n\t\tsb->s_flags |= MS_I_VERSION;\n\t\treturn 1;\n\tcase Opt_lazytime:\n\t\tsb->s_flags |= MS_LAZYTIME;\n\t\treturn 1;\n\tcase Opt_nolazytime:\n\t\tsb->s_flags &= ~MS_LAZYTIME;\n\t\treturn 1;\n\t}\n\n\tfor (m = ext4_mount_opts; m->token != Opt_err; m++)\n\t\tif (token == m->token)\n\t\t\tbreak;\n\n\tif (m->token == Opt_err) {\n\t\text4_msg(sb, KERN_ERR, \"Unrecognized mount option \\\"%s\\\" \"\n\t\t\t \"or missing value\", opt);\n\t\treturn -1;\n\t}\n\n\tif ((m->flags & MOPT_NO_EXT2) && IS_EXT2_SB(sb)) {\n\t\text4_msg(sb, KERN_ERR,\n\t\t\t \"Mount option \\\"%s\\\" incompatible with ext2\", opt);\n\t\treturn -1;\n\t}\n\tif ((m->flags & MOPT_NO_EXT3) && IS_EXT3_SB(sb)) {\n\t\text4_msg(sb, KERN_ERR,\n\t\t\t \"Mount option \\\"%s\\\" incompatible with ext3\", opt);\n\t\treturn -1;\n\t}\n\n\tif (args->from && !(m->flags & MOPT_STRING) && match_int(args, &arg))\n\t\treturn -1;\n\tif (args->from && (m->flags & MOPT_GTE0) && (arg < 0))\n\t\treturn -1;\n\tif (m->flags & MOPT_EXPLICIT)\n\t\tset_opt2(sb, EXPLICIT_DELALLOC);\n\tif (m->flags & MOPT_CLEAR_ERR)\n\t\tclear_opt(sb, ERRORS_MASK);\n\tif (token == Opt_noquota && sb_any_quota_loaded(sb)) {\n\t\text4_msg(sb, KERN_ERR, \"Cannot change quota \"\n\t\t\t \"options when quota turned on\");\n\t\treturn -1;\n\t}\n\n\tif (m->flags & MOPT_NOSUPPORT) {\n\t\text4_msg(sb, KERN_ERR, \"%s option not supported\", opt);\n\t} else if (token == Opt_commit) {\n\t\tif (arg == 0)\n\t\t\targ = JBD2_DEFAULT_MAX_COMMIT_AGE;\n\t\tsbi->s_commit_interval = HZ * arg;\n\t} else if (token == Opt_max_batch_time) {\n\t\tsbi->s_max_batch_time = arg;\n\t} else if (token == Opt_min_batch_time) {\n\t\tsbi->s_min_batch_time = arg;\n\t} else if (token == Opt_inode_readahead_blks) {\n\t\tif (arg && (arg > (1 << 30) || !is_power_of_2(arg))) {\n\t\t\text4_msg(sb, KERN_ERR,\n\t\t\t\t \"EXT4-fs: inode_readahead_blks must be \"\n\t\t\t\t \"0 or a power of 2 smaller than 2^31\");\n\t\t\treturn -1;\n\t\t}\n\t\tsbi->s_inode_readahead_blks = arg;\n\t} else if (token == Opt_init_itable) {\n\t\tset_opt(sb, INIT_INODE_TABLE);\n\t\tif (!args->from)\n\t\t\targ = EXT4_DEF_LI_WAIT_MULT;\n\t\tsbi->s_li_wait_mult = arg;\n\t} else if (token == Opt_max_dir_size_kb) {\n\t\tsbi->s_max_dir_size_kb = arg;\n\t} else if (token == Opt_stripe) {\n\t\tsbi->s_stripe = arg;\n\t} else if (token == Opt_resuid) {\n\t\tuid = make_kuid(current_user_ns(), arg);\n\t\tif (!uid_valid(uid)) {\n\t\t\text4_msg(sb, KERN_ERR, \"Invalid uid value %d\", arg);\n\t\t\treturn -1;\n\t\t}\n\t\tsbi->s_resuid = uid;\n\t} else if (token == Opt_resgid) {\n\t\tgid = make_kgid(current_user_ns(), arg);\n\t\tif (!gid_valid(gid)) {\n\t\t\text4_msg(sb, KERN_ERR, \"Invalid gid value %d\", arg);\n\t\t\treturn -1;\n\t\t}\n\t\tsbi->s_resgid = gid;\n\t} else if (token == Opt_journal_dev) {\n\t\tif (is_remount) {\n\t\t\text4_msg(sb, KERN_ERR,\n\t\t\t\t \"Cannot specify journal on remount\");\n\t\t\treturn -1;\n\t\t}\n\t\t*journal_devnum = arg;\n\t} else if (token == Opt_journal_path) {\n\t\tchar *journal_path;\n\t\tstruct inode *journal_inode;\n\t\tstruct path path;\n\t\tint error;\n\n\t\tif (is_remount) {\n\t\t\text4_msg(sb, KERN_ERR,\n\t\t\t\t \"Cannot specify journal on remount\");\n\t\t\treturn -1;\n\t\t}\n\t\tjournal_path = match_strdup(&args[0]);\n\t\tif (!journal_path) {\n\t\t\text4_msg(sb, KERN_ERR, \"error: could not dup \"\n\t\t\t\t\"journal device string\");\n\t\t\treturn -1;\n\t\t}\n\n\t\terror = kern_path(journal_path, LOOKUP_FOLLOW, &path);\n\t\tif (error) {\n\t\t\text4_msg(sb, KERN_ERR, \"error: could not find \"\n\t\t\t\t\"journal device path: error %d\", error);\n\t\t\tkfree(journal_path);\n\t\t\treturn -1;\n\t\t}\n\n\t\tjournal_inode = path.dentry->d_inode;\n\t\tif (!S_ISBLK(journal_inode->i_mode)) {\n\t\t\text4_msg(sb, KERN_ERR, \"error: journal path %s \"\n\t\t\t\t\"is not a block device\", journal_path);\n\t\t\tpath_put(&path);\n\t\t\tkfree(journal_path);\n\t\t\treturn -1;\n\t\t}\n\n\t\t*journal_devnum = new_encode_dev(journal_inode->i_rdev);\n\t\tpath_put(&path);\n\t\tkfree(journal_path);\n\t} else if (token == Opt_journal_ioprio) {\n\t\tif (arg > 7) {\n\t\t\text4_msg(sb, KERN_ERR, \"Invalid journal IO priority\"\n\t\t\t\t \" (must be 0-7)\");\n\t\t\treturn -1;\n\t\t}\n\t\t*journal_ioprio =\n\t\t\tIOPRIO_PRIO_VALUE(IOPRIO_CLASS_BE, arg);\n\t} else if (m->flags & MOPT_DATAJ) {\n\t\tif (is_remount) {\n\t\t\tif (!sbi->s_journal)\n\t\t\t\text4_msg(sb, KERN_WARNING, \"Remounting file system with no journal so ignoring journalled data option\");\n\t\t\telse if (test_opt(sb, DATA_FLAGS) != m->mount_opt) {\n\t\t\t\text4_msg(sb, KERN_ERR,\n\t\t\t\t\t \"Cannot change data mode on remount\");\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t} else {\n\t\t\tclear_opt(sb, DATA_FLAGS);\n\t\t\tsbi->s_mount_opt |= m->mount_opt;\n\t\t}\n#ifdef CONFIG_QUOTA\n\t} else if (m->flags & MOPT_QFMT) {\n\t\tif (sb_any_quota_loaded(sb) &&\n\t\t    sbi->s_jquota_fmt != m->mount_opt) {\n\t\t\text4_msg(sb, KERN_ERR, \"Cannot change journaled \"\n\t\t\t\t \"quota options when quota turned on\");\n\t\t\treturn -1;\n\t\t}\n\t\tif (EXT4_HAS_RO_COMPAT_FEATURE(sb,\n\t\t\t\t\t       EXT4_FEATURE_RO_COMPAT_QUOTA)) {\n\t\t\text4_msg(sb, KERN_ERR,\n\t\t\t\t \"Cannot set journaled quota options \"\n\t\t\t\t \"when QUOTA feature is enabled\");\n\t\t\treturn -1;\n\t\t}\n\t\tsbi->s_jquota_fmt = m->mount_opt;\n#endif\n#ifndef CONFIG_FS_DAX\n\t} else if (token == Opt_dax) {\n\t\text4_msg(sb, KERN_INFO, \"dax option not supported\");\n\t\treturn -1;\n#endif\n\t} else {\n\t\tif (!args->from)\n\t\t\targ = 1;\n\t\tif (m->flags & MOPT_CLEAR)\n\t\t\targ = !arg;\n\t\telse if (unlikely(!(m->flags & MOPT_SET))) {\n\t\t\text4_msg(sb, KERN_WARNING,\n\t\t\t\t \"buggy handling of option %s\", opt);\n\t\t\tWARN_ON(1);\n\t\t\treturn -1;\n\t\t}\n\t\tif (arg != 0)\n\t\t\tsbi->s_mount_opt |= m->mount_opt;\n\t\telse\n\t\t\tsbi->s_mount_opt &= ~m->mount_opt;\n\t}\n\treturn 1;\n}",
    "includes": [
      "#include <trace/events/ext4.h>",
      "#include \"mballoc.h\"",
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"ext4_jbd2.h\"",
      "#include \"ext4_extents.h\"\t/* Needed for trace points definition */",
      "#include \"ext4.h\"",
      "#include <linux/freezer.h>",
      "#include <linux/kthread.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/cleancache.h>",
      "#include <linux/crc16.h>",
      "#include <linux/log2.h>",
      "#include <linux/ctype.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/namei.h>",
      "#include <linux/mount.h>",
      "#include <linux/random.h>",
      "#include <linux/vfs.h>",
      "#include <linux/exportfs.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/parser.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/init.h>",
      "#include <linux/slab.h>",
      "#include <linux/jbd2.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/time.h>",
      "#include <linux/fs.h>",
      "#include <linux/string.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [
      "#define MOPT_STRING\t0x0400",
      "#define MOPT_NO_EXT3\t0x0200",
      "#define MOPT_NO_EXT2\t0x0100",
      "#define MOPT_DATAJ\t0x0080",
      "#define MOPT_QFMT\tMOPT_NOSUPPORT",
      "#define MOPT_QFMT\t0x0040",
      "#define MOPT_GTE0\t0x0020",
      "#define MOPT_CLEAR_ERR\t0x0010",
      "#define MOPT_EXPLICIT\t0x0008",
      "#define MOPT_NOSUPPORT\t0x0004",
      "#define MOPT_CLEAR\t0x0002",
      "#define MOPT_SET\t0x0001"
    ],
    "globals_used": [
      "static int ext4_load_journal(struct super_block *, struct ext4_super_block *,\n\t\t\t     unsigned long journal_devnum);",
      "static int ext4_remount(struct super_block *sb, int *flags, char *data);",
      "static int ext4_unfreeze(struct super_block *sb);",
      "static int ext4_freeze(struct super_block *sb);",
      "static struct dentry *ext4_mount(struct file_system_type *fs_type, int flags,\n\t\t       const char *dev_name, void *data);",
      "static inline int ext2_feature_set_ok(struct super_block *sb);",
      "static inline int ext3_feature_set_ok(struct super_block *sb);",
      "static void ext4_unregister_li_request(struct super_block *sb);",
      "static char deprecated_msg[] = \"Mount option \\\"%s\\\" will be removed by %s\\n\"\n\t\"Contact linux-ext4@vger.kernel.org if you think we should keep it.\\n\";",
      "static const struct mount_opts {\n\tint\ttoken;\n\tint\tmount_opt;\n\tint\tflags;\n} ext4_mount_opts[] = {\n\t{Opt_minix_df, EXT4_MOUNT_MINIX_DF, MOPT_SET},\n\t{Opt_bsd_df, EXT4_MOUNT_MINIX_DF, MOPT_CLEAR},\n\t{Opt_grpid, EXT4_MOUNT_GRPID, MOPT_SET},\n\t{Opt_nogrpid, EXT4_MOUNT_GRPID, MOPT_CLEAR},\n\t{Opt_block_validity, EXT4_MOUNT_BLOCK_VALIDITY, MOPT_SET},\n\t{Opt_noblock_validity, EXT4_MOUNT_BLOCK_VALIDITY, MOPT_CLEAR},\n\t{Opt_dioread_nolock, EXT4_MOUNT_DIOREAD_NOLOCK,\n\t MOPT_EXT4_ONLY | MOPT_SET},\n\t{Opt_dioread_lock, EXT4_MOUNT_DIOREAD_NOLOCK,\n\t MOPT_EXT4_ONLY | MOPT_CLEAR},\n\t{Opt_discard, EXT4_MOUNT_DISCARD, MOPT_SET},\n\t{Opt_nodiscard, EXT4_MOUNT_DISCARD, MOPT_CLEAR},\n\t{Opt_delalloc, EXT4_MOUNT_DELALLOC,\n\t MOPT_EXT4_ONLY | MOPT_SET | MOPT_EXPLICIT},\n\t{Opt_nodelalloc, EXT4_MOUNT_DELALLOC,\n\t MOPT_EXT4_ONLY | MOPT_CLEAR},\n\t{Opt_nojournal_checksum, EXT4_MOUNT_JOURNAL_CHECKSUM,\n\t MOPT_EXT4_ONLY | MOPT_CLEAR},\n\t{Opt_journal_checksum, EXT4_MOUNT_JOURNAL_CHECKSUM,\n\t MOPT_EXT4_ONLY | MOPT_SET},\n\t{Opt_journal_async_commit, (EXT4_MOUNT_JOURNAL_ASYNC_COMMIT |\n\t\t\t\t    EXT4_MOUNT_JOURNAL_CHECKSUM),\n\t MOPT_EXT4_ONLY | MOPT_SET},\n\t{Opt_noload, EXT4_MOUNT_NOLOAD, MOPT_NO_EXT2 | MOPT_SET},\n\t{Opt_err_panic, EXT4_MOUNT_ERRORS_PANIC, MOPT_SET | MOPT_CLEAR_ERR},\n\t{Opt_err_ro, EXT4_MOUNT_ERRORS_RO, MOPT_SET | MOPT_CLEAR_ERR},\n\t{Opt_err_cont, EXT4_MOUNT_ERRORS_CONT, MOPT_SET | MOPT_CLEAR_ERR},\n\t{Opt_data_err_abort, EXT4_MOUNT_DATA_ERR_ABORT,\n\t MOPT_NO_EXT2 | MOPT_SET},\n\t{Opt_data_err_ignore, EXT4_MOUNT_DATA_ERR_ABORT,\n\t MOPT_NO_EXT2 | MOPT_CLEAR},\n\t{Opt_barrier, EXT4_MOUNT_BARRIER, MOPT_SET},\n\t{Opt_nobarrier, EXT4_MOUNT_BARRIER, MOPT_CLEAR},\n\t{Opt_noauto_da_alloc, EXT4_MOUNT_NO_AUTO_DA_ALLOC, MOPT_SET},\n\t{Opt_auto_da_alloc, EXT4_MOUNT_NO_AUTO_DA_ALLOC, MOPT_CLEAR},\n\t{Opt_noinit_itable, EXT4_MOUNT_INIT_INODE_TABLE, MOPT_CLEAR},\n\t{Opt_commit, 0, MOPT_GTE0},\n\t{Opt_max_batch_time, 0, MOPT_GTE0},\n\t{Opt_min_batch_time, 0, MOPT_GTE0},\n\t{Opt_inode_readahead_blks, 0, MOPT_GTE0},\n\t{Opt_init_itable, 0, MOPT_GTE0},\n\t{Opt_dax, EXT4_MOUNT_DAX, MOPT_SET},\n\t{Opt_stripe, 0, MOPT_GTE0},\n\t{Opt_resuid, 0, MOPT_GTE0},\n\t{Opt_resgid, 0, MOPT_GTE0},\n\t{Opt_journal_dev, 0, MOPT_GTE0},\n\t{Opt_journal_path, 0, MOPT_STRING},\n\t{Opt_journal_ioprio, 0, MOPT_GTE0},\n\t{Opt_data_journal, EXT4_MOUNT_JOURNAL_DATA, MOPT_NO_EXT2 | MOPT_DATAJ},\n\t{Opt_data_ordered, EXT4_MOUNT_ORDERED_DATA, MOPT_NO_EXT2 | MOPT_DATAJ},\n\t{Opt_data_writeback, EXT4_MOUNT_WRITEBACK_DATA,\n\t MOPT_NO_EXT2 | MOPT_DATAJ},\n\t{Opt_user_xattr, EXT4_MOUNT_XATTR_USER, MOPT_SET},\n\t{Opt_nouser_xattr, EXT4_MOUNT_XATTR_USER, MOPT_CLEAR},\n#ifdef CONFIG_EXT4_FS_POSIX_ACL\n\t{Opt_acl, EXT4_MOUNT_POSIX_ACL, MOPT_SET},\n\t{Opt_noacl, EXT4_MOUNT_POSIX_ACL, MOPT_CLEAR},\n#else\n\t{Opt_acl, 0, MOPT_NOSUPPORT},\n\t{Opt_noacl, 0, MOPT_NOSUPPORT},\n#endif\n\t{Opt_nouid32, EXT4_MOUNT_NO_UID32, MOPT_SET},\n\t{Opt_debug, EXT4_MOUNT_DEBUG, MOPT_SET},\n\t{Opt_quota, EXT4_MOUNT_QUOTA | EXT4_MOUNT_USRQUOTA, MOPT_SET | MOPT_Q},\n\t{Opt_usrquota, EXT4_MOUNT_QUOTA | EXT4_MOUNT_USRQUOTA,\n\t\t\t\t\t\t\tMOPT_SET | MOPT_Q},\n\t{Opt_grpquota, EXT4_MOUNT_QUOTA | EXT4_MOUNT_GRPQUOTA,\n\t\t\t\t\t\t\tMOPT_SET | MOPT_Q},\n\t{Opt_noquota, (EXT4_MOUNT_QUOTA | EXT4_MOUNT_USRQUOTA |\n\t\t       EXT4_MOUNT_GRPQUOTA), MOPT_CLEAR | MOPT_Q},\n\t{Opt_usrjquota, 0, MOPT_Q},\n\t{Opt_grpjquota, 0, MOPT_Q},\n\t{Opt_offusrjquota, 0, MOPT_Q},\n\t{Opt_offgrpjquota, 0, MOPT_Q},\n\t{Opt_jqfmt_vfsold, QFMT_VFS_OLD, MOPT_QFMT},\n\t{Opt_jqfmt_vfsv0, QFMT_VFS_V0, MOPT_QFMT},\n\t{Opt_jqfmt_vfsv1, QFMT_VFS_V1, MOPT_QFMT},\n\t{Opt_max_dir_size_kb, 0, MOPT_GTE0},\n\t{Opt_err, 0, 0}\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "1"
          ],
          "line": 1634
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_msg",
          "args": [
            "sb",
            "KERN_WARNING",
            "\"buggy handling of option %s\"",
            "opt"
          ],
          "line": 1632
        },
        "resolved": true,
        "details": {
          "function_name": "__ext4_msg",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/super.c",
          "lines": "593-607",
          "snippet": "void __ext4_msg(struct super_block *sb,\n\t\tconst char *prefix, const char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tif (!___ratelimit(&(EXT4_SB(sb)->s_msg_ratelimit_state), \"EXT4-fs\"))\n\t\treturn;\n\n\tva_start(args, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\tprintk(\"%sEXT4-fs (%s): %pV\\n\", prefix, sb->s_id, &vaf);\n\tva_end(args);\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"mballoc.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include \"ext4_extents.h\"\t/* Needed for trace points definition */",
            "#include \"ext4.h\"",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/crc16.h>",
            "#include <linux/log2.h>",
            "#include <linux/ctype.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/random.h>",
            "#include <linux/vfs.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/parser.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/time.h>",
            "#include <linux/fs.h>",
            "#include <linux/string.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ext4_unfreeze(struct super_block *sb);",
            "static int ext4_freeze(struct super_block *sb);",
            "static inline int ext2_feature_set_ok(struct super_block *sb);",
            "static inline int ext3_feature_set_ok(struct super_block *sb);",
            "static void ext4_unregister_li_request(struct super_block *sb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"mballoc.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4_extents.h\"\t/* Needed for trace points definition */\n#include \"ext4.h\"\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <asm/uaccess.h>\n#include <linux/cleancache.h>\n#include <linux/crc16.h>\n#include <linux/log2.h>\n#include <linux/ctype.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/random.h>\n#include <linux/vfs.h>\n#include <linux/exportfs.h>\n#include <linux/buffer_head.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/jbd2.h>\n#include <linux/vmalloc.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n#include <linux/string.h>\n#include <linux/module.h>\n\nstatic int ext4_unfreeze(struct super_block *sb);\nstatic int ext4_freeze(struct super_block *sb);\nstatic inline int ext2_feature_set_ok(struct super_block *sb);\nstatic inline int ext3_feature_set_ok(struct super_block *sb);\nstatic void ext4_unregister_li_request(struct super_block *sb);\n\nvoid __ext4_msg(struct super_block *sb,\n\t\tconst char *prefix, const char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tif (!___ratelimit(&(EXT4_SB(sb)->s_msg_ratelimit_state), \"EXT4-fs\"))\n\t\treturn;\n\n\tva_start(args, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\tprintk(\"%sEXT4-fs (%s): %pV\\n\", prefix, sb->s_id, &vaf);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!(m->flags & MOPT_SET)"
          ],
          "line": 1631
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXT4_HAS_RO_COMPAT_FEATURE",
          "args": [
            "sb",
            "EXT4_FEATURE_RO_COMPAT_QUOTA"
          ],
          "line": 1612
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sb_any_quota_loaded",
          "args": [
            "sb"
          ],
          "line": 1606
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "clear_opt",
          "args": [
            "sb",
            "DATA_FLAGS"
          ],
          "line": 1601
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_opt",
          "args": [
            "sb",
            "DATA_FLAGS"
          ],
          "line": 1595
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IOPRIO_PRIO_VALUE",
          "args": [
            "IOPRIO_CLASS_BE",
            "arg"
          ],
          "line": 1590
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "journal_path"
          ],
          "line": 1582
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "path_put",
          "args": [
            "&path"
          ],
          "line": 1581
        },
        "resolved": true,
        "details": {
          "function_name": "path_put",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namei.c",
          "lines": "489-493",
          "snippet": "void path_put(const struct path *path)\n{\n\tdput(path->dentry);\n\tmntput(path->mnt);\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/hash.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/device_cgroup.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>",
            "#include <linux/audit.h>",
            "#include <linux/mount.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/ima.h>",
            "#include <linux/security.h>",
            "#include <linux/personality.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <linux/hash.h>\n#include <linux/posix_acl.h>\n#include <linux/fs_struct.h>\n#include <linux/device_cgroup.h>\n#include <linux/fcntl.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n#include <linux/audit.h>\n#include <linux/mount.h>\n#include <linux/syscalls.h>\n#include <linux/ima.h>\n#include <linux/security.h>\n#include <linux/personality.h>\n#include <linux/fsnotify.h>\n#include <linux/pagemap.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n#include <linux/init.h>\n\nvoid path_put(const struct path *path)\n{\n\tdput(path->dentry);\n\tmntput(path->mnt);\n}"
        }
      },
      {
        "call_info": {
          "callee": "new_encode_dev",
          "args": [
            "journal_inode->i_rdev"
          ],
          "line": 1580
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "journal_path"
          ],
          "line": 1576
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISBLK",
          "args": [
            "journal_inode->i_mode"
          ],
          "line": 1572
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "journal_path"
          ],
          "line": 1567
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kern_path",
          "args": [
            "journal_path",
            "LOOKUP_FOLLOW",
            "&path"
          ],
          "line": 1563
        },
        "resolved": true,
        "details": {
          "function_name": "kern_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namei.c",
          "lines": "2089-2096",
          "snippet": "int kern_path(const char *name, unsigned int flags, struct path *path)\n{\n\tstruct nameidata nd;\n\tint res = do_path_lookup(AT_FDCWD, name, flags, &nd);\n\tif (!res)\n\t\t*path = nd.path;\n\treturn res;\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/hash.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/device_cgroup.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>",
            "#include <linux/audit.h>",
            "#include <linux/mount.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/ima.h>",
            "#include <linux/security.h>",
            "#include <linux/personality.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int link_path_walk(const char *, struct nameidata *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <linux/hash.h>\n#include <linux/posix_acl.h>\n#include <linux/fs_struct.h>\n#include <linux/device_cgroup.h>\n#include <linux/fcntl.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n#include <linux/audit.h>\n#include <linux/mount.h>\n#include <linux/syscalls.h>\n#include <linux/ima.h>\n#include <linux/security.h>\n#include <linux/personality.h>\n#include <linux/fsnotify.h>\n#include <linux/pagemap.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n#include <linux/init.h>\n\nstatic int link_path_walk(const char *, struct nameidata *);\n\nint kern_path(const char *name, unsigned int flags, struct path *path)\n{\n\tstruct nameidata nd;\n\tint res = do_path_lookup(AT_FDCWD, name, flags, &nd);\n\tif (!res)\n\t\t*path = nd.path;\n\treturn res;\n}"
        }
      },
      {
        "call_info": {
          "callee": "match_strdup",
          "args": [
            "&args[0]"
          ],
          "line": 1556
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gid_valid",
          "args": [
            "gid"
          ],
          "line": 1533
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "make_kgid",
          "args": [
            "current_user_ns()",
            "arg"
          ],
          "line": 1532
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "current_user_ns",
          "args": [],
          "line": 1532
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "uid_valid",
          "args": [
            "uid"
          ],
          "line": 1526
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_uuid_valid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/sys.c",
          "lines": "73-82",
          "snippet": "static int gfs2_uuid_valid(const u8 *uuid)\n{\n\tint i;\n\n\tfor (i = 0; i < 16; i++) {\n\t\tif (uuid[i])\n\t\t\treturn 1;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"recovery.h\"",
            "#include \"glops.h\"",
            "#include \"util.h\"",
            "#include \"quota.h\"",
            "#include \"glock.h\"",
            "#include \"super.h\"",
            "#include \"sys.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/genhd.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/kobject.h>",
            "#include <linux/module.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"recovery.h\"\n#include \"glops.h\"\n#include \"util.h\"\n#include \"quota.h\"\n#include \"glock.h\"\n#include \"super.h\"\n#include \"sys.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/genhd.h>\n#include <linux/gfs2_ondisk.h>\n#include <asm/uaccess.h>\n#include <linux/kobject.h>\n#include <linux/module.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/sched.h>\n\nstatic int gfs2_uuid_valid(const u8 *uuid)\n{\n\tint i;\n\n\tfor (i = 0; i < 16; i++) {\n\t\tif (uuid[i])\n\t\t\treturn 1;\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "make_kuid",
          "args": [
            "current_user_ns()",
            "arg"
          ],
          "line": 1525
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "current_user_ns",
          "args": [],
          "line": 1525
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_opt",
          "args": [
            "sb",
            "INIT_INODE_TABLE"
          ],
          "line": 1516
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_check_set_options",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/super.c",
          "lines": "1239-1271",
          "snippet": "static int ocfs2_check_set_options(struct super_block *sb,\n\t\t\t\t   struct mount_options *options)\n{\n\tif (options->mount_opt & OCFS2_MOUNT_USRQUOTA &&\n\t    !OCFS2_HAS_RO_COMPAT_FEATURE(sb,\n\t\t\t\t\t OCFS2_FEATURE_RO_COMPAT_USRQUOTA)) {\n\t\tmlog(ML_ERROR, \"User quotas were requested, but this \"\n\t\t     \"filesystem does not have the feature enabled.\\n\");\n\t\treturn 0;\n\t}\n\tif (options->mount_opt & OCFS2_MOUNT_GRPQUOTA &&\n\t    !OCFS2_HAS_RO_COMPAT_FEATURE(sb,\n\t\t\t\t\t OCFS2_FEATURE_RO_COMPAT_GRPQUOTA)) {\n\t\tmlog(ML_ERROR, \"Group quotas were requested, but this \"\n\t\t     \"filesystem does not have the feature enabled.\\n\");\n\t\treturn 0;\n\t}\n\tif (options->mount_opt & OCFS2_MOUNT_POSIX_ACL &&\n\t    !OCFS2_HAS_INCOMPAT_FEATURE(sb, OCFS2_FEATURE_INCOMPAT_XATTR)) {\n\t\tmlog(ML_ERROR, \"ACL support requested but extended attributes \"\n\t\t     \"feature is not enabled\\n\");\n\t\treturn 0;\n\t}\n\t/* No ACL setting specified? Use XATTR feature... */\n\tif (!(options->mount_opt & (OCFS2_MOUNT_POSIX_ACL |\n\t\t\t\t    OCFS2_MOUNT_NO_POSIX_ACL))) {\n\t\tif (OCFS2_HAS_INCOMPAT_FEATURE(sb, OCFS2_FEATURE_INCOMPAT_XATTR))\n\t\t\toptions->mount_opt |= OCFS2_MOUNT_POSIX_ACL;\n\t\telse\n\t\t\toptions->mount_opt |= OCFS2_MOUNT_NO_POSIX_ACL;\n\t}\n\treturn 1;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"suballoc.h\"",
            "#include \"refcounttree.h\"",
            "#include \"quota.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"namei.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"extent_map.h\"",
            "#include \"export.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs1_fs_compat.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include \"ocfs2_trace.h\"",
            "#include <linux/cleancache.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mount.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/crc32.h>",
            "#include <linux/parser.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/statfs.h>",
            "#include <linux/random.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ocfs2_check_set_options(struct super_block *sb,\n\t\t\t\t   struct mount_options *options);",
            "static void ocfs2_put_super(struct super_block *sb);",
            "static int ocfs2_mount_volume(struct super_block *sb);",
            "static struct inode *ocfs2_alloc_inode(struct super_block *sb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"suballoc.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"namei.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"export.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs1_fs_compat.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include \"ocfs2_trace.h\"\n#include <linux/cleancache.h>\n#include <linux/quotaops.h>\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n#include <linux/debugfs.h>\n#include <linux/crc32.h>\n#include <linux/parser.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/moduleparam.h>\n#include <linux/statfs.h>\n#include <linux/random.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic int ocfs2_check_set_options(struct super_block *sb,\n\t\t\t\t   struct mount_options *options);\nstatic void ocfs2_put_super(struct super_block *sb);\nstatic int ocfs2_mount_volume(struct super_block *sb);\nstatic struct inode *ocfs2_alloc_inode(struct super_block *sb);\n\nstatic int ocfs2_check_set_options(struct super_block *sb,\n\t\t\t\t   struct mount_options *options)\n{\n\tif (options->mount_opt & OCFS2_MOUNT_USRQUOTA &&\n\t    !OCFS2_HAS_RO_COMPAT_FEATURE(sb,\n\t\t\t\t\t OCFS2_FEATURE_RO_COMPAT_USRQUOTA)) {\n\t\tmlog(ML_ERROR, \"User quotas were requested, but this \"\n\t\t     \"filesystem does not have the feature enabled.\\n\");\n\t\treturn 0;\n\t}\n\tif (options->mount_opt & OCFS2_MOUNT_GRPQUOTA &&\n\t    !OCFS2_HAS_RO_COMPAT_FEATURE(sb,\n\t\t\t\t\t OCFS2_FEATURE_RO_COMPAT_GRPQUOTA)) {\n\t\tmlog(ML_ERROR, \"Group quotas were requested, but this \"\n\t\t     \"filesystem does not have the feature enabled.\\n\");\n\t\treturn 0;\n\t}\n\tif (options->mount_opt & OCFS2_MOUNT_POSIX_ACL &&\n\t    !OCFS2_HAS_INCOMPAT_FEATURE(sb, OCFS2_FEATURE_INCOMPAT_XATTR)) {\n\t\tmlog(ML_ERROR, \"ACL support requested but extended attributes \"\n\t\t     \"feature is not enabled\\n\");\n\t\treturn 0;\n\t}\n\t/* No ACL setting specified? Use XATTR feature... */\n\tif (!(options->mount_opt & (OCFS2_MOUNT_POSIX_ACL |\n\t\t\t\t    OCFS2_MOUNT_NO_POSIX_ACL))) {\n\t\tif (OCFS2_HAS_INCOMPAT_FEATURE(sb, OCFS2_FEATURE_INCOMPAT_XATTR))\n\t\t\toptions->mount_opt |= OCFS2_MOUNT_POSIX_ACL;\n\t\telse\n\t\t\toptions->mount_opt |= OCFS2_MOUNT_NO_POSIX_ACL;\n\t}\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "is_power_of_2",
          "args": [
            "arg"
          ],
          "line": 1508
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sb_any_quota_loaded",
          "args": [
            "sb"
          ],
          "line": 1491
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "clear_opt",
          "args": [
            "sb",
            "ERRORS_MASK"
          ],
          "line": 1490
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_opt2",
          "args": [
            "sb",
            "EXPLICIT_DELALLOC"
          ],
          "line": 1488
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "match_int",
          "args": [
            "args",
            "&arg"
          ],
          "line": 1483
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_EXT3_SB",
          "args": [
            "sb"
          ],
          "line": 1477
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_EXT2_SB",
          "args": [
            "sb"
          ],
          "line": 1472
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "clear_qf_name",
          "args": [
            "sb",
            "GRPQUOTA"
          ],
          "line": 1436
        },
        "resolved": true,
        "details": {
          "function_name": "clear_qf_name",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/super.c",
          "lines": "1296-1310",
          "snippet": "static int clear_qf_name(struct super_block *sb, int qtype)\n{\n\n\tstruct ext4_sb_info *sbi = EXT4_SB(sb);\n\n\tif (sb_any_quota_loaded(sb) &&\n\t\tsbi->s_qf_names[qtype]) {\n\t\text4_msg(sb, KERN_ERR, \"Cannot change journaled quota options\"\n\t\t\t\" when quota turned on\");\n\t\treturn -1;\n\t}\n\tkfree(sbi->s_qf_names[qtype]);\n\tsbi->s_qf_names[qtype] = NULL;\n\treturn 1;\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"mballoc.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include \"ext4_extents.h\"\t/* Needed for trace points definition */",
            "#include \"ext4.h\"",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/crc16.h>",
            "#include <linux/log2.h>",
            "#include <linux/ctype.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/random.h>",
            "#include <linux/vfs.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/parser.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/time.h>",
            "#include <linux/fs.h>",
            "#include <linux/string.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ext4_unfreeze(struct super_block *sb);",
            "static int ext4_freeze(struct super_block *sb);",
            "static inline int ext2_feature_set_ok(struct super_block *sb);",
            "static inline int ext3_feature_set_ok(struct super_block *sb);",
            "static void ext4_unregister_li_request(struct super_block *sb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"mballoc.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4_extents.h\"\t/* Needed for trace points definition */\n#include \"ext4.h\"\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <asm/uaccess.h>\n#include <linux/cleancache.h>\n#include <linux/crc16.h>\n#include <linux/log2.h>\n#include <linux/ctype.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/random.h>\n#include <linux/vfs.h>\n#include <linux/exportfs.h>\n#include <linux/buffer_head.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/jbd2.h>\n#include <linux/vmalloc.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n#include <linux/string.h>\n#include <linux/module.h>\n\nstatic int ext4_unfreeze(struct super_block *sb);\nstatic int ext4_freeze(struct super_block *sb);\nstatic inline int ext2_feature_set_ok(struct super_block *sb);\nstatic inline int ext3_feature_set_ok(struct super_block *sb);\nstatic void ext4_unregister_li_request(struct super_block *sb);\n\nstatic int clear_qf_name(struct super_block *sb, int qtype)\n{\n\n\tstruct ext4_sb_info *sbi = EXT4_SB(sb);\n\n\tif (sb_any_quota_loaded(sb) &&\n\t\tsbi->s_qf_names[qtype]) {\n\t\text4_msg(sb, KERN_ERR, \"Cannot change journaled quota options\"\n\t\t\t\" when quota turned on\");\n\t\treturn -1;\n\t}\n\tkfree(sbi->s_qf_names[qtype]);\n\tsbi->s_qf_names[qtype] = NULL;\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_qf_name",
          "args": [
            "sb",
            "GRPQUOTA",
            "&args[0]"
          ],
          "line": 1432
        },
        "resolved": true,
        "details": {
          "function_name": "set_qf_name",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/super.c",
          "lines": "1250-1294",
          "snippet": "static int set_qf_name(struct super_block *sb, int qtype, substring_t *args)\n{\n\tstruct ext4_sb_info *sbi = EXT4_SB(sb);\n\tchar *qname;\n\tint ret = -1;\n\n\tif (sb_any_quota_loaded(sb) &&\n\t\t!sbi->s_qf_names[qtype]) {\n\t\text4_msg(sb, KERN_ERR,\n\t\t\t\"Cannot change journaled \"\n\t\t\t\"quota options when quota turned on\");\n\t\treturn -1;\n\t}\n\tif (EXT4_HAS_RO_COMPAT_FEATURE(sb, EXT4_FEATURE_RO_COMPAT_QUOTA)) {\n\t\text4_msg(sb, KERN_ERR, \"Cannot set journaled quota options \"\n\t\t\t \"when QUOTA feature is enabled\");\n\t\treturn -1;\n\t}\n\tqname = match_strdup(args);\n\tif (!qname) {\n\t\text4_msg(sb, KERN_ERR,\n\t\t\t\"Not enough memory for storing quotafile name\");\n\t\treturn -1;\n\t}\n\tif (sbi->s_qf_names[qtype]) {\n\t\tif (strcmp(sbi->s_qf_names[qtype], qname) == 0)\n\t\t\tret = 1;\n\t\telse\n\t\t\text4_msg(sb, KERN_ERR,\n\t\t\t\t \"%s quota file already specified\",\n\t\t\t\t QTYPE2NAME(qtype));\n\t\tgoto errout;\n\t}\n\tif (strchr(qname, '/')) {\n\t\text4_msg(sb, KERN_ERR,\n\t\t\t\"quotafile must be on filesystem root\");\n\t\tgoto errout;\n\t}\n\tsbi->s_qf_names[qtype] = qname;\n\tset_opt(sb, QUOTA);\n\treturn 1;\nerrout:\n\tkfree(qname);\n\treturn ret;\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"mballoc.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include \"ext4_extents.h\"\t/* Needed for trace points definition */",
            "#include \"ext4.h\"",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/crc16.h>",
            "#include <linux/log2.h>",
            "#include <linux/ctype.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/random.h>",
            "#include <linux/vfs.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/parser.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/time.h>",
            "#include <linux/fs.h>",
            "#include <linux/string.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ext4_show_options(struct seq_file *seq, struct dentry *root);",
            "static int ext4_unfreeze(struct super_block *sb);",
            "static int ext4_freeze(struct super_block *sb);",
            "static inline int ext2_feature_set_ok(struct super_block *sb);",
            "static inline int ext3_feature_set_ok(struct super_block *sb);",
            "static void ext4_unregister_li_request(struct super_block *sb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"mballoc.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4_extents.h\"\t/* Needed for trace points definition */\n#include \"ext4.h\"\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <asm/uaccess.h>\n#include <linux/cleancache.h>\n#include <linux/crc16.h>\n#include <linux/log2.h>\n#include <linux/ctype.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/random.h>\n#include <linux/vfs.h>\n#include <linux/exportfs.h>\n#include <linux/buffer_head.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/jbd2.h>\n#include <linux/vmalloc.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n#include <linux/string.h>\n#include <linux/module.h>\n\nstatic int ext4_show_options(struct seq_file *seq, struct dentry *root);\nstatic int ext4_unfreeze(struct super_block *sb);\nstatic int ext4_freeze(struct super_block *sb);\nstatic inline int ext2_feature_set_ok(struct super_block *sb);\nstatic inline int ext3_feature_set_ok(struct super_block *sb);\nstatic void ext4_unregister_li_request(struct super_block *sb);\n\nstatic int set_qf_name(struct super_block *sb, int qtype, substring_t *args)\n{\n\tstruct ext4_sb_info *sbi = EXT4_SB(sb);\n\tchar *qname;\n\tint ret = -1;\n\n\tif (sb_any_quota_loaded(sb) &&\n\t\t!sbi->s_qf_names[qtype]) {\n\t\text4_msg(sb, KERN_ERR,\n\t\t\t\"Cannot change journaled \"\n\t\t\t\"quota options when quota turned on\");\n\t\treturn -1;\n\t}\n\tif (EXT4_HAS_RO_COMPAT_FEATURE(sb, EXT4_FEATURE_RO_COMPAT_QUOTA)) {\n\t\text4_msg(sb, KERN_ERR, \"Cannot set journaled quota options \"\n\t\t\t \"when QUOTA feature is enabled\");\n\t\treturn -1;\n\t}\n\tqname = match_strdup(args);\n\tif (!qname) {\n\t\text4_msg(sb, KERN_ERR,\n\t\t\t\"Not enough memory for storing quotafile name\");\n\t\treturn -1;\n\t}\n\tif (sbi->s_qf_names[qtype]) {\n\t\tif (strcmp(sbi->s_qf_names[qtype], qname) == 0)\n\t\t\tret = 1;\n\t\telse\n\t\t\text4_msg(sb, KERN_ERR,\n\t\t\t\t \"%s quota file already specified\",\n\t\t\t\t QTYPE2NAME(qtype));\n\t\tgoto errout;\n\t}\n\tif (strchr(qname, '/')) {\n\t\text4_msg(sb, KERN_ERR,\n\t\t\t\"quotafile must be on filesystem root\");\n\t\tgoto errout;\n\t}\n\tsbi->s_qf_names[qtype] = qname;\n\tset_opt(sb, QUOTA);\n\treturn 1;\nerrout:\n\tkfree(qname);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "EXT4_SB",
          "args": [
            "sb"
          ],
          "line": 1422
        },
        "resolved": true,
        "details": {
          "function_name": "EXT4_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ext4.h",
          "lines": "1356-1359",
          "snippet": "static inline struct ext4_sb_info *EXT4_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include \"extents_status.h\"",
            "#include <linux/compat.h>",
            "#include <linux/falloc.h>",
            "#include <crypto/hash.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/wait.h>",
            "#include <linux/timer.h>",
            "#include <linux/mutex.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/quota.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extents_status.h\"\n#include <linux/compat.h>\n#include <linux/falloc.h>\n#include <crypto/hash.h>\n#include <linux/ratelimit.h>\n#include <linux/percpu_counter.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/wait.h>\n#include <linux/timer.h>\n#include <linux/mutex.h>\n#include <linux/seqlock.h>\n#include <linux/rbtree.h>\n#include <linux/rwsem.h>\n#include <linux/quota.h>\n#include <linux/jbd2.h>\n#include <linux/magic.h>\n#include <linux/blkdev.h>\n#include <linux/types.h>\n\nstatic inline struct ext4_sb_info *EXT4_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"mballoc.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4_extents.h\"\t/* Needed for trace points definition */\n#include \"ext4.h\"\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <asm/uaccess.h>\n#include <linux/cleancache.h>\n#include <linux/crc16.h>\n#include <linux/log2.h>\n#include <linux/ctype.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/random.h>\n#include <linux/vfs.h>\n#include <linux/exportfs.h>\n#include <linux/buffer_head.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/jbd2.h>\n#include <linux/vmalloc.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n#include <linux/string.h>\n#include <linux/module.h>\n\n#define MOPT_STRING\t0x0400\n#define MOPT_NO_EXT3\t0x0200\n#define MOPT_NO_EXT2\t0x0100\n#define MOPT_DATAJ\t0x0080\n#define MOPT_QFMT\tMOPT_NOSUPPORT\n#define MOPT_QFMT\t0x0040\n#define MOPT_GTE0\t0x0020\n#define MOPT_CLEAR_ERR\t0x0010\n#define MOPT_EXPLICIT\t0x0008\n#define MOPT_NOSUPPORT\t0x0004\n#define MOPT_CLEAR\t0x0002\n#define MOPT_SET\t0x0001\n\nstatic int ext4_load_journal(struct super_block *, struct ext4_super_block *,\n\t\t\t     unsigned long journal_devnum);\nstatic int ext4_remount(struct super_block *sb, int *flags, char *data);\nstatic int ext4_unfreeze(struct super_block *sb);\nstatic int ext4_freeze(struct super_block *sb);\nstatic struct dentry *ext4_mount(struct file_system_type *fs_type, int flags,\n\t\t       const char *dev_name, void *data);\nstatic inline int ext2_feature_set_ok(struct super_block *sb);\nstatic inline int ext3_feature_set_ok(struct super_block *sb);\nstatic void ext4_unregister_li_request(struct super_block *sb);\nstatic char deprecated_msg[] = \"Mount option \\\"%s\\\" will be removed by %s\\n\"\n\t\"Contact linux-ext4@vger.kernel.org if you think we should keep it.\\n\";\nstatic const struct mount_opts {\n\tint\ttoken;\n\tint\tmount_opt;\n\tint\tflags;\n} ext4_mount_opts[] = {\n\t{Opt_minix_df, EXT4_MOUNT_MINIX_DF, MOPT_SET},\n\t{Opt_bsd_df, EXT4_MOUNT_MINIX_DF, MOPT_CLEAR},\n\t{Opt_grpid, EXT4_MOUNT_GRPID, MOPT_SET},\n\t{Opt_nogrpid, EXT4_MOUNT_GRPID, MOPT_CLEAR},\n\t{Opt_block_validity, EXT4_MOUNT_BLOCK_VALIDITY, MOPT_SET},\n\t{Opt_noblock_validity, EXT4_MOUNT_BLOCK_VALIDITY, MOPT_CLEAR},\n\t{Opt_dioread_nolock, EXT4_MOUNT_DIOREAD_NOLOCK,\n\t MOPT_EXT4_ONLY | MOPT_SET},\n\t{Opt_dioread_lock, EXT4_MOUNT_DIOREAD_NOLOCK,\n\t MOPT_EXT4_ONLY | MOPT_CLEAR},\n\t{Opt_discard, EXT4_MOUNT_DISCARD, MOPT_SET},\n\t{Opt_nodiscard, EXT4_MOUNT_DISCARD, MOPT_CLEAR},\n\t{Opt_delalloc, EXT4_MOUNT_DELALLOC,\n\t MOPT_EXT4_ONLY | MOPT_SET | MOPT_EXPLICIT},\n\t{Opt_nodelalloc, EXT4_MOUNT_DELALLOC,\n\t MOPT_EXT4_ONLY | MOPT_CLEAR},\n\t{Opt_nojournal_checksum, EXT4_MOUNT_JOURNAL_CHECKSUM,\n\t MOPT_EXT4_ONLY | MOPT_CLEAR},\n\t{Opt_journal_checksum, EXT4_MOUNT_JOURNAL_CHECKSUM,\n\t MOPT_EXT4_ONLY | MOPT_SET},\n\t{Opt_journal_async_commit, (EXT4_MOUNT_JOURNAL_ASYNC_COMMIT |\n\t\t\t\t    EXT4_MOUNT_JOURNAL_CHECKSUM),\n\t MOPT_EXT4_ONLY | MOPT_SET},\n\t{Opt_noload, EXT4_MOUNT_NOLOAD, MOPT_NO_EXT2 | MOPT_SET},\n\t{Opt_err_panic, EXT4_MOUNT_ERRORS_PANIC, MOPT_SET | MOPT_CLEAR_ERR},\n\t{Opt_err_ro, EXT4_MOUNT_ERRORS_RO, MOPT_SET | MOPT_CLEAR_ERR},\n\t{Opt_err_cont, EXT4_MOUNT_ERRORS_CONT, MOPT_SET | MOPT_CLEAR_ERR},\n\t{Opt_data_err_abort, EXT4_MOUNT_DATA_ERR_ABORT,\n\t MOPT_NO_EXT2 | MOPT_SET},\n\t{Opt_data_err_ignore, EXT4_MOUNT_DATA_ERR_ABORT,\n\t MOPT_NO_EXT2 | MOPT_CLEAR},\n\t{Opt_barrier, EXT4_MOUNT_BARRIER, MOPT_SET},\n\t{Opt_nobarrier, EXT4_MOUNT_BARRIER, MOPT_CLEAR},\n\t{Opt_noauto_da_alloc, EXT4_MOUNT_NO_AUTO_DA_ALLOC, MOPT_SET},\n\t{Opt_auto_da_alloc, EXT4_MOUNT_NO_AUTO_DA_ALLOC, MOPT_CLEAR},\n\t{Opt_noinit_itable, EXT4_MOUNT_INIT_INODE_TABLE, MOPT_CLEAR},\n\t{Opt_commit, 0, MOPT_GTE0},\n\t{Opt_max_batch_time, 0, MOPT_GTE0},\n\t{Opt_min_batch_time, 0, MOPT_GTE0},\n\t{Opt_inode_readahead_blks, 0, MOPT_GTE0},\n\t{Opt_init_itable, 0, MOPT_GTE0},\n\t{Opt_dax, EXT4_MOUNT_DAX, MOPT_SET},\n\t{Opt_stripe, 0, MOPT_GTE0},\n\t{Opt_resuid, 0, MOPT_GTE0},\n\t{Opt_resgid, 0, MOPT_GTE0},\n\t{Opt_journal_dev, 0, MOPT_GTE0},\n\t{Opt_journal_path, 0, MOPT_STRING},\n\t{Opt_journal_ioprio, 0, MOPT_GTE0},\n\t{Opt_data_journal, EXT4_MOUNT_JOURNAL_DATA, MOPT_NO_EXT2 | MOPT_DATAJ},\n\t{Opt_data_ordered, EXT4_MOUNT_ORDERED_DATA, MOPT_NO_EXT2 | MOPT_DATAJ},\n\t{Opt_data_writeback, EXT4_MOUNT_WRITEBACK_DATA,\n\t MOPT_NO_EXT2 | MOPT_DATAJ},\n\t{Opt_user_xattr, EXT4_MOUNT_XATTR_USER, MOPT_SET},\n\t{Opt_nouser_xattr, EXT4_MOUNT_XATTR_USER, MOPT_CLEAR},\n#ifdef CONFIG_EXT4_FS_POSIX_ACL\n\t{Opt_acl, EXT4_MOUNT_POSIX_ACL, MOPT_SET},\n\t{Opt_noacl, EXT4_MOUNT_POSIX_ACL, MOPT_CLEAR},\n#else\n\t{Opt_acl, 0, MOPT_NOSUPPORT},\n\t{Opt_noacl, 0, MOPT_NOSUPPORT},\n#endif\n\t{Opt_nouid32, EXT4_MOUNT_NO_UID32, MOPT_SET},\n\t{Opt_debug, EXT4_MOUNT_DEBUG, MOPT_SET},\n\t{Opt_quota, EXT4_MOUNT_QUOTA | EXT4_MOUNT_USRQUOTA, MOPT_SET | MOPT_Q},\n\t{Opt_usrquota, EXT4_MOUNT_QUOTA | EXT4_MOUNT_USRQUOTA,\n\t\t\t\t\t\t\tMOPT_SET | MOPT_Q},\n\t{Opt_grpquota, EXT4_MOUNT_QUOTA | EXT4_MOUNT_GRPQUOTA,\n\t\t\t\t\t\t\tMOPT_SET | MOPT_Q},\n\t{Opt_noquota, (EXT4_MOUNT_QUOTA | EXT4_MOUNT_USRQUOTA |\n\t\t       EXT4_MOUNT_GRPQUOTA), MOPT_CLEAR | MOPT_Q},\n\t{Opt_usrjquota, 0, MOPT_Q},\n\t{Opt_grpjquota, 0, MOPT_Q},\n\t{Opt_offusrjquota, 0, MOPT_Q},\n\t{Opt_offgrpjquota, 0, MOPT_Q},\n\t{Opt_jqfmt_vfsold, QFMT_VFS_OLD, MOPT_QFMT},\n\t{Opt_jqfmt_vfsv0, QFMT_VFS_V0, MOPT_QFMT},\n\t{Opt_jqfmt_vfsv1, QFMT_VFS_V1, MOPT_QFMT},\n\t{Opt_max_dir_size_kb, 0, MOPT_GTE0},\n\t{Opt_err, 0, 0}\n};\n\nstatic int handle_mount_opt(struct super_block *sb, char *opt, int token,\n\t\t\t    substring_t *args, unsigned long *journal_devnum,\n\t\t\t    unsigned int *journal_ioprio, int is_remount)\n{\n\tstruct ext4_sb_info *sbi = EXT4_SB(sb);\n\tconst struct mount_opts *m;\n\tkuid_t uid;\n\tkgid_t gid;\n\tint arg = 0;\n\n#ifdef CONFIG_QUOTA\n\tif (token == Opt_usrjquota)\n\t\treturn set_qf_name(sb, USRQUOTA, &args[0]);\n\telse if (token == Opt_grpjquota)\n\t\treturn set_qf_name(sb, GRPQUOTA, &args[0]);\n\telse if (token == Opt_offusrjquota)\n\t\treturn clear_qf_name(sb, USRQUOTA);\n\telse if (token == Opt_offgrpjquota)\n\t\treturn clear_qf_name(sb, GRPQUOTA);\n#endif\n\tswitch (token) {\n\tcase Opt_noacl:\n\tcase Opt_nouser_xattr:\n\t\text4_msg(sb, KERN_WARNING, deprecated_msg, opt, \"3.5\");\n\t\tbreak;\n\tcase Opt_sb:\n\t\treturn 1;\t/* handled by get_sb_block() */\n\tcase Opt_removed:\n\t\text4_msg(sb, KERN_WARNING, \"Ignoring removed %s option\", opt);\n\t\treturn 1;\n\tcase Opt_abort:\n\t\tsbi->s_mount_flags |= EXT4_MF_FS_ABORTED;\n\t\treturn 1;\n\tcase Opt_i_version:\n\t\tsb->s_flags |= MS_I_VERSION;\n\t\treturn 1;\n\tcase Opt_lazytime:\n\t\tsb->s_flags |= MS_LAZYTIME;\n\t\treturn 1;\n\tcase Opt_nolazytime:\n\t\tsb->s_flags &= ~MS_LAZYTIME;\n\t\treturn 1;\n\t}\n\n\tfor (m = ext4_mount_opts; m->token != Opt_err; m++)\n\t\tif (token == m->token)\n\t\t\tbreak;\n\n\tif (m->token == Opt_err) {\n\t\text4_msg(sb, KERN_ERR, \"Unrecognized mount option \\\"%s\\\" \"\n\t\t\t \"or missing value\", opt);\n\t\treturn -1;\n\t}\n\n\tif ((m->flags & MOPT_NO_EXT2) && IS_EXT2_SB(sb)) {\n\t\text4_msg(sb, KERN_ERR,\n\t\t\t \"Mount option \\\"%s\\\" incompatible with ext2\", opt);\n\t\treturn -1;\n\t}\n\tif ((m->flags & MOPT_NO_EXT3) && IS_EXT3_SB(sb)) {\n\t\text4_msg(sb, KERN_ERR,\n\t\t\t \"Mount option \\\"%s\\\" incompatible with ext3\", opt);\n\t\treturn -1;\n\t}\n\n\tif (args->from && !(m->flags & MOPT_STRING) && match_int(args, &arg))\n\t\treturn -1;\n\tif (args->from && (m->flags & MOPT_GTE0) && (arg < 0))\n\t\treturn -1;\n\tif (m->flags & MOPT_EXPLICIT)\n\t\tset_opt2(sb, EXPLICIT_DELALLOC);\n\tif (m->flags & MOPT_CLEAR_ERR)\n\t\tclear_opt(sb, ERRORS_MASK);\n\tif (token == Opt_noquota && sb_any_quota_loaded(sb)) {\n\t\text4_msg(sb, KERN_ERR, \"Cannot change quota \"\n\t\t\t \"options when quota turned on\");\n\t\treturn -1;\n\t}\n\n\tif (m->flags & MOPT_NOSUPPORT) {\n\t\text4_msg(sb, KERN_ERR, \"%s option not supported\", opt);\n\t} else if (token == Opt_commit) {\n\t\tif (arg == 0)\n\t\t\targ = JBD2_DEFAULT_MAX_COMMIT_AGE;\n\t\tsbi->s_commit_interval = HZ * arg;\n\t} else if (token == Opt_max_batch_time) {\n\t\tsbi->s_max_batch_time = arg;\n\t} else if (token == Opt_min_batch_time) {\n\t\tsbi->s_min_batch_time = arg;\n\t} else if (token == Opt_inode_readahead_blks) {\n\t\tif (arg && (arg > (1 << 30) || !is_power_of_2(arg))) {\n\t\t\text4_msg(sb, KERN_ERR,\n\t\t\t\t \"EXT4-fs: inode_readahead_blks must be \"\n\t\t\t\t \"0 or a power of 2 smaller than 2^31\");\n\t\t\treturn -1;\n\t\t}\n\t\tsbi->s_inode_readahead_blks = arg;\n\t} else if (token == Opt_init_itable) {\n\t\tset_opt(sb, INIT_INODE_TABLE);\n\t\tif (!args->from)\n\t\t\targ = EXT4_DEF_LI_WAIT_MULT;\n\t\tsbi->s_li_wait_mult = arg;\n\t} else if (token == Opt_max_dir_size_kb) {\n\t\tsbi->s_max_dir_size_kb = arg;\n\t} else if (token == Opt_stripe) {\n\t\tsbi->s_stripe = arg;\n\t} else if (token == Opt_resuid) {\n\t\tuid = make_kuid(current_user_ns(), arg);\n\t\tif (!uid_valid(uid)) {\n\t\t\text4_msg(sb, KERN_ERR, \"Invalid uid value %d\", arg);\n\t\t\treturn -1;\n\t\t}\n\t\tsbi->s_resuid = uid;\n\t} else if (token == Opt_resgid) {\n\t\tgid = make_kgid(current_user_ns(), arg);\n\t\tif (!gid_valid(gid)) {\n\t\t\text4_msg(sb, KERN_ERR, \"Invalid gid value %d\", arg);\n\t\t\treturn -1;\n\t\t}\n\t\tsbi->s_resgid = gid;\n\t} else if (token == Opt_journal_dev) {\n\t\tif (is_remount) {\n\t\t\text4_msg(sb, KERN_ERR,\n\t\t\t\t \"Cannot specify journal on remount\");\n\t\t\treturn -1;\n\t\t}\n\t\t*journal_devnum = arg;\n\t} else if (token == Opt_journal_path) {\n\t\tchar *journal_path;\n\t\tstruct inode *journal_inode;\n\t\tstruct path path;\n\t\tint error;\n\n\t\tif (is_remount) {\n\t\t\text4_msg(sb, KERN_ERR,\n\t\t\t\t \"Cannot specify journal on remount\");\n\t\t\treturn -1;\n\t\t}\n\t\tjournal_path = match_strdup(&args[0]);\n\t\tif (!journal_path) {\n\t\t\text4_msg(sb, KERN_ERR, \"error: could not dup \"\n\t\t\t\t\"journal device string\");\n\t\t\treturn -1;\n\t\t}\n\n\t\terror = kern_path(journal_path, LOOKUP_FOLLOW, &path);\n\t\tif (error) {\n\t\t\text4_msg(sb, KERN_ERR, \"error: could not find \"\n\t\t\t\t\"journal device path: error %d\", error);\n\t\t\tkfree(journal_path);\n\t\t\treturn -1;\n\t\t}\n\n\t\tjournal_inode = path.dentry->d_inode;\n\t\tif (!S_ISBLK(journal_inode->i_mode)) {\n\t\t\text4_msg(sb, KERN_ERR, \"error: journal path %s \"\n\t\t\t\t\"is not a block device\", journal_path);\n\t\t\tpath_put(&path);\n\t\t\tkfree(journal_path);\n\t\t\treturn -1;\n\t\t}\n\n\t\t*journal_devnum = new_encode_dev(journal_inode->i_rdev);\n\t\tpath_put(&path);\n\t\tkfree(journal_path);\n\t} else if (token == Opt_journal_ioprio) {\n\t\tif (arg > 7) {\n\t\t\text4_msg(sb, KERN_ERR, \"Invalid journal IO priority\"\n\t\t\t\t \" (must be 0-7)\");\n\t\t\treturn -1;\n\t\t}\n\t\t*journal_ioprio =\n\t\t\tIOPRIO_PRIO_VALUE(IOPRIO_CLASS_BE, arg);\n\t} else if (m->flags & MOPT_DATAJ) {\n\t\tif (is_remount) {\n\t\t\tif (!sbi->s_journal)\n\t\t\t\text4_msg(sb, KERN_WARNING, \"Remounting file system with no journal so ignoring journalled data option\");\n\t\t\telse if (test_opt(sb, DATA_FLAGS) != m->mount_opt) {\n\t\t\t\text4_msg(sb, KERN_ERR,\n\t\t\t\t\t \"Cannot change data mode on remount\");\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t} else {\n\t\t\tclear_opt(sb, DATA_FLAGS);\n\t\t\tsbi->s_mount_opt |= m->mount_opt;\n\t\t}\n#ifdef CONFIG_QUOTA\n\t} else if (m->flags & MOPT_QFMT) {\n\t\tif (sb_any_quota_loaded(sb) &&\n\t\t    sbi->s_jquota_fmt != m->mount_opt) {\n\t\t\text4_msg(sb, KERN_ERR, \"Cannot change journaled \"\n\t\t\t\t \"quota options when quota turned on\");\n\t\t\treturn -1;\n\t\t}\n\t\tif (EXT4_HAS_RO_COMPAT_FEATURE(sb,\n\t\t\t\t\t       EXT4_FEATURE_RO_COMPAT_QUOTA)) {\n\t\t\text4_msg(sb, KERN_ERR,\n\t\t\t\t \"Cannot set journaled quota options \"\n\t\t\t\t \"when QUOTA feature is enabled\");\n\t\t\treturn -1;\n\t\t}\n\t\tsbi->s_jquota_fmt = m->mount_opt;\n#endif\n#ifndef CONFIG_FS_DAX\n\t} else if (token == Opt_dax) {\n\t\text4_msg(sb, KERN_INFO, \"dax option not supported\");\n\t\treturn -1;\n#endif\n\t} else {\n\t\tif (!args->from)\n\t\t\targ = 1;\n\t\tif (m->flags & MOPT_CLEAR)\n\t\t\targ = !arg;\n\t\telse if (unlikely(!(m->flags & MOPT_SET))) {\n\t\t\text4_msg(sb, KERN_WARNING,\n\t\t\t\t \"buggy handling of option %s\", opt);\n\t\t\tWARN_ON(1);\n\t\t\treturn -1;\n\t\t}\n\t\tif (arg != 0)\n\t\t\tsbi->s_mount_opt |= m->mount_opt;\n\t\telse\n\t\t\tsbi->s_mount_opt &= ~m->mount_opt;\n\t}\n\treturn 1;\n}"
  },
  {
    "function_name": "clear_qf_name",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/super.c",
    "lines": "1296-1310",
    "snippet": "static int clear_qf_name(struct super_block *sb, int qtype)\n{\n\n\tstruct ext4_sb_info *sbi = EXT4_SB(sb);\n\n\tif (sb_any_quota_loaded(sb) &&\n\t\tsbi->s_qf_names[qtype]) {\n\t\text4_msg(sb, KERN_ERR, \"Cannot change journaled quota options\"\n\t\t\t\" when quota turned on\");\n\t\treturn -1;\n\t}\n\tkfree(sbi->s_qf_names[qtype]);\n\tsbi->s_qf_names[qtype] = NULL;\n\treturn 1;\n}",
    "includes": [
      "#include <trace/events/ext4.h>",
      "#include \"mballoc.h\"",
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"ext4_jbd2.h\"",
      "#include \"ext4_extents.h\"\t/* Needed for trace points definition */",
      "#include \"ext4.h\"",
      "#include <linux/freezer.h>",
      "#include <linux/kthread.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/cleancache.h>",
      "#include <linux/crc16.h>",
      "#include <linux/log2.h>",
      "#include <linux/ctype.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/namei.h>",
      "#include <linux/mount.h>",
      "#include <linux/random.h>",
      "#include <linux/vfs.h>",
      "#include <linux/exportfs.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/parser.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/init.h>",
      "#include <linux/slab.h>",
      "#include <linux/jbd2.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/time.h>",
      "#include <linux/fs.h>",
      "#include <linux/string.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ext4_unfreeze(struct super_block *sb);",
      "static int ext4_freeze(struct super_block *sb);",
      "static inline int ext2_feature_set_ok(struct super_block *sb);",
      "static inline int ext3_feature_set_ok(struct super_block *sb);",
      "static void ext4_unregister_li_request(struct super_block *sb);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "sbi->s_qf_names[qtype]"
          ],
          "line": 1307
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_msg",
          "args": [
            "sb",
            "KERN_ERR",
            "\"Cannot change journaled quota options\"\n\t\t\t\" when quota turned on\""
          ],
          "line": 1303
        },
        "resolved": true,
        "details": {
          "function_name": "__ext4_msg",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/super.c",
          "lines": "593-607",
          "snippet": "void __ext4_msg(struct super_block *sb,\n\t\tconst char *prefix, const char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tif (!___ratelimit(&(EXT4_SB(sb)->s_msg_ratelimit_state), \"EXT4-fs\"))\n\t\treturn;\n\n\tva_start(args, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\tprintk(\"%sEXT4-fs (%s): %pV\\n\", prefix, sb->s_id, &vaf);\n\tva_end(args);\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"mballoc.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include \"ext4_extents.h\"\t/* Needed for trace points definition */",
            "#include \"ext4.h\"",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/crc16.h>",
            "#include <linux/log2.h>",
            "#include <linux/ctype.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/random.h>",
            "#include <linux/vfs.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/parser.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/time.h>",
            "#include <linux/fs.h>",
            "#include <linux/string.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ext4_unfreeze(struct super_block *sb);",
            "static int ext4_freeze(struct super_block *sb);",
            "static inline int ext2_feature_set_ok(struct super_block *sb);",
            "static inline int ext3_feature_set_ok(struct super_block *sb);",
            "static void ext4_unregister_li_request(struct super_block *sb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"mballoc.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4_extents.h\"\t/* Needed for trace points definition */\n#include \"ext4.h\"\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <asm/uaccess.h>\n#include <linux/cleancache.h>\n#include <linux/crc16.h>\n#include <linux/log2.h>\n#include <linux/ctype.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/random.h>\n#include <linux/vfs.h>\n#include <linux/exportfs.h>\n#include <linux/buffer_head.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/jbd2.h>\n#include <linux/vmalloc.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n#include <linux/string.h>\n#include <linux/module.h>\n\nstatic int ext4_unfreeze(struct super_block *sb);\nstatic int ext4_freeze(struct super_block *sb);\nstatic inline int ext2_feature_set_ok(struct super_block *sb);\nstatic inline int ext3_feature_set_ok(struct super_block *sb);\nstatic void ext4_unregister_li_request(struct super_block *sb);\n\nvoid __ext4_msg(struct super_block *sb,\n\t\tconst char *prefix, const char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tif (!___ratelimit(&(EXT4_SB(sb)->s_msg_ratelimit_state), \"EXT4-fs\"))\n\t\treturn;\n\n\tva_start(args, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\tprintk(\"%sEXT4-fs (%s): %pV\\n\", prefix, sb->s_id, &vaf);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sb_any_quota_loaded",
          "args": [
            "sb"
          ],
          "line": 1301
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXT4_SB",
          "args": [
            "sb"
          ],
          "line": 1299
        },
        "resolved": true,
        "details": {
          "function_name": "EXT4_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ext4.h",
          "lines": "1356-1359",
          "snippet": "static inline struct ext4_sb_info *EXT4_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include \"extents_status.h\"",
            "#include <linux/compat.h>",
            "#include <linux/falloc.h>",
            "#include <crypto/hash.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/wait.h>",
            "#include <linux/timer.h>",
            "#include <linux/mutex.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/quota.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extents_status.h\"\n#include <linux/compat.h>\n#include <linux/falloc.h>\n#include <crypto/hash.h>\n#include <linux/ratelimit.h>\n#include <linux/percpu_counter.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/wait.h>\n#include <linux/timer.h>\n#include <linux/mutex.h>\n#include <linux/seqlock.h>\n#include <linux/rbtree.h>\n#include <linux/rwsem.h>\n#include <linux/quota.h>\n#include <linux/jbd2.h>\n#include <linux/magic.h>\n#include <linux/blkdev.h>\n#include <linux/types.h>\n\nstatic inline struct ext4_sb_info *EXT4_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"mballoc.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4_extents.h\"\t/* Needed for trace points definition */\n#include \"ext4.h\"\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <asm/uaccess.h>\n#include <linux/cleancache.h>\n#include <linux/crc16.h>\n#include <linux/log2.h>\n#include <linux/ctype.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/random.h>\n#include <linux/vfs.h>\n#include <linux/exportfs.h>\n#include <linux/buffer_head.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/jbd2.h>\n#include <linux/vmalloc.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n#include <linux/string.h>\n#include <linux/module.h>\n\nstatic int ext4_unfreeze(struct super_block *sb);\nstatic int ext4_freeze(struct super_block *sb);\nstatic inline int ext2_feature_set_ok(struct super_block *sb);\nstatic inline int ext3_feature_set_ok(struct super_block *sb);\nstatic void ext4_unregister_li_request(struct super_block *sb);\n\nstatic int clear_qf_name(struct super_block *sb, int qtype)\n{\n\n\tstruct ext4_sb_info *sbi = EXT4_SB(sb);\n\n\tif (sb_any_quota_loaded(sb) &&\n\t\tsbi->s_qf_names[qtype]) {\n\t\text4_msg(sb, KERN_ERR, \"Cannot change journaled quota options\"\n\t\t\t\" when quota turned on\");\n\t\treturn -1;\n\t}\n\tkfree(sbi->s_qf_names[qtype]);\n\tsbi->s_qf_names[qtype] = NULL;\n\treturn 1;\n}"
  },
  {
    "function_name": "set_qf_name",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/super.c",
    "lines": "1250-1294",
    "snippet": "static int set_qf_name(struct super_block *sb, int qtype, substring_t *args)\n{\n\tstruct ext4_sb_info *sbi = EXT4_SB(sb);\n\tchar *qname;\n\tint ret = -1;\n\n\tif (sb_any_quota_loaded(sb) &&\n\t\t!sbi->s_qf_names[qtype]) {\n\t\text4_msg(sb, KERN_ERR,\n\t\t\t\"Cannot change journaled \"\n\t\t\t\"quota options when quota turned on\");\n\t\treturn -1;\n\t}\n\tif (EXT4_HAS_RO_COMPAT_FEATURE(sb, EXT4_FEATURE_RO_COMPAT_QUOTA)) {\n\t\text4_msg(sb, KERN_ERR, \"Cannot set journaled quota options \"\n\t\t\t \"when QUOTA feature is enabled\");\n\t\treturn -1;\n\t}\n\tqname = match_strdup(args);\n\tif (!qname) {\n\t\text4_msg(sb, KERN_ERR,\n\t\t\t\"Not enough memory for storing quotafile name\");\n\t\treturn -1;\n\t}\n\tif (sbi->s_qf_names[qtype]) {\n\t\tif (strcmp(sbi->s_qf_names[qtype], qname) == 0)\n\t\t\tret = 1;\n\t\telse\n\t\t\text4_msg(sb, KERN_ERR,\n\t\t\t\t \"%s quota file already specified\",\n\t\t\t\t QTYPE2NAME(qtype));\n\t\tgoto errout;\n\t}\n\tif (strchr(qname, '/')) {\n\t\text4_msg(sb, KERN_ERR,\n\t\t\t\"quotafile must be on filesystem root\");\n\t\tgoto errout;\n\t}\n\tsbi->s_qf_names[qtype] = qname;\n\tset_opt(sb, QUOTA);\n\treturn 1;\nerrout:\n\tkfree(qname);\n\treturn ret;\n}",
    "includes": [
      "#include <trace/events/ext4.h>",
      "#include \"mballoc.h\"",
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"ext4_jbd2.h\"",
      "#include \"ext4_extents.h\"\t/* Needed for trace points definition */",
      "#include \"ext4.h\"",
      "#include <linux/freezer.h>",
      "#include <linux/kthread.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/cleancache.h>",
      "#include <linux/crc16.h>",
      "#include <linux/log2.h>",
      "#include <linux/ctype.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/namei.h>",
      "#include <linux/mount.h>",
      "#include <linux/random.h>",
      "#include <linux/vfs.h>",
      "#include <linux/exportfs.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/parser.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/init.h>",
      "#include <linux/slab.h>",
      "#include <linux/jbd2.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/time.h>",
      "#include <linux/fs.h>",
      "#include <linux/string.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ext4_show_options(struct seq_file *seq, struct dentry *root);",
      "static int ext4_unfreeze(struct super_block *sb);",
      "static int ext4_freeze(struct super_block *sb);",
      "static inline int ext2_feature_set_ok(struct super_block *sb);",
      "static inline int ext3_feature_set_ok(struct super_block *sb);",
      "static void ext4_unregister_li_request(struct super_block *sb);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "qname"
          ],
          "line": 1292
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_opt",
          "args": [
            "sb",
            "QUOTA"
          ],
          "line": 1289
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_check_set_options",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/super.c",
          "lines": "1239-1271",
          "snippet": "static int ocfs2_check_set_options(struct super_block *sb,\n\t\t\t\t   struct mount_options *options)\n{\n\tif (options->mount_opt & OCFS2_MOUNT_USRQUOTA &&\n\t    !OCFS2_HAS_RO_COMPAT_FEATURE(sb,\n\t\t\t\t\t OCFS2_FEATURE_RO_COMPAT_USRQUOTA)) {\n\t\tmlog(ML_ERROR, \"User quotas were requested, but this \"\n\t\t     \"filesystem does not have the feature enabled.\\n\");\n\t\treturn 0;\n\t}\n\tif (options->mount_opt & OCFS2_MOUNT_GRPQUOTA &&\n\t    !OCFS2_HAS_RO_COMPAT_FEATURE(sb,\n\t\t\t\t\t OCFS2_FEATURE_RO_COMPAT_GRPQUOTA)) {\n\t\tmlog(ML_ERROR, \"Group quotas were requested, but this \"\n\t\t     \"filesystem does not have the feature enabled.\\n\");\n\t\treturn 0;\n\t}\n\tif (options->mount_opt & OCFS2_MOUNT_POSIX_ACL &&\n\t    !OCFS2_HAS_INCOMPAT_FEATURE(sb, OCFS2_FEATURE_INCOMPAT_XATTR)) {\n\t\tmlog(ML_ERROR, \"ACL support requested but extended attributes \"\n\t\t     \"feature is not enabled\\n\");\n\t\treturn 0;\n\t}\n\t/* No ACL setting specified? Use XATTR feature... */\n\tif (!(options->mount_opt & (OCFS2_MOUNT_POSIX_ACL |\n\t\t\t\t    OCFS2_MOUNT_NO_POSIX_ACL))) {\n\t\tif (OCFS2_HAS_INCOMPAT_FEATURE(sb, OCFS2_FEATURE_INCOMPAT_XATTR))\n\t\t\toptions->mount_opt |= OCFS2_MOUNT_POSIX_ACL;\n\t\telse\n\t\t\toptions->mount_opt |= OCFS2_MOUNT_NO_POSIX_ACL;\n\t}\n\treturn 1;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"suballoc.h\"",
            "#include \"refcounttree.h\"",
            "#include \"quota.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"namei.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"extent_map.h\"",
            "#include \"export.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs1_fs_compat.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include \"ocfs2_trace.h\"",
            "#include <linux/cleancache.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mount.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/crc32.h>",
            "#include <linux/parser.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/statfs.h>",
            "#include <linux/random.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ocfs2_check_set_options(struct super_block *sb,\n\t\t\t\t   struct mount_options *options);",
            "static void ocfs2_put_super(struct super_block *sb);",
            "static int ocfs2_mount_volume(struct super_block *sb);",
            "static struct inode *ocfs2_alloc_inode(struct super_block *sb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"suballoc.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"namei.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"export.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs1_fs_compat.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include \"ocfs2_trace.h\"\n#include <linux/cleancache.h>\n#include <linux/quotaops.h>\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n#include <linux/debugfs.h>\n#include <linux/crc32.h>\n#include <linux/parser.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/moduleparam.h>\n#include <linux/statfs.h>\n#include <linux/random.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic int ocfs2_check_set_options(struct super_block *sb,\n\t\t\t\t   struct mount_options *options);\nstatic void ocfs2_put_super(struct super_block *sb);\nstatic int ocfs2_mount_volume(struct super_block *sb);\nstatic struct inode *ocfs2_alloc_inode(struct super_block *sb);\n\nstatic int ocfs2_check_set_options(struct super_block *sb,\n\t\t\t\t   struct mount_options *options)\n{\n\tif (options->mount_opt & OCFS2_MOUNT_USRQUOTA &&\n\t    !OCFS2_HAS_RO_COMPAT_FEATURE(sb,\n\t\t\t\t\t OCFS2_FEATURE_RO_COMPAT_USRQUOTA)) {\n\t\tmlog(ML_ERROR, \"User quotas were requested, but this \"\n\t\t     \"filesystem does not have the feature enabled.\\n\");\n\t\treturn 0;\n\t}\n\tif (options->mount_opt & OCFS2_MOUNT_GRPQUOTA &&\n\t    !OCFS2_HAS_RO_COMPAT_FEATURE(sb,\n\t\t\t\t\t OCFS2_FEATURE_RO_COMPAT_GRPQUOTA)) {\n\t\tmlog(ML_ERROR, \"Group quotas were requested, but this \"\n\t\t     \"filesystem does not have the feature enabled.\\n\");\n\t\treturn 0;\n\t}\n\tif (options->mount_opt & OCFS2_MOUNT_POSIX_ACL &&\n\t    !OCFS2_HAS_INCOMPAT_FEATURE(sb, OCFS2_FEATURE_INCOMPAT_XATTR)) {\n\t\tmlog(ML_ERROR, \"ACL support requested but extended attributes \"\n\t\t     \"feature is not enabled\\n\");\n\t\treturn 0;\n\t}\n\t/* No ACL setting specified? Use XATTR feature... */\n\tif (!(options->mount_opt & (OCFS2_MOUNT_POSIX_ACL |\n\t\t\t\t    OCFS2_MOUNT_NO_POSIX_ACL))) {\n\t\tif (OCFS2_HAS_INCOMPAT_FEATURE(sb, OCFS2_FEATURE_INCOMPAT_XATTR))\n\t\t\toptions->mount_opt |= OCFS2_MOUNT_POSIX_ACL;\n\t\telse\n\t\t\toptions->mount_opt |= OCFS2_MOUNT_NO_POSIX_ACL;\n\t}\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_msg",
          "args": [
            "sb",
            "KERN_ERR",
            "\"quotafile must be on filesystem root\""
          ],
          "line": 1284
        },
        "resolved": true,
        "details": {
          "function_name": "__ext4_msg",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/super.c",
          "lines": "593-607",
          "snippet": "void __ext4_msg(struct super_block *sb,\n\t\tconst char *prefix, const char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tif (!___ratelimit(&(EXT4_SB(sb)->s_msg_ratelimit_state), \"EXT4-fs\"))\n\t\treturn;\n\n\tva_start(args, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\tprintk(\"%sEXT4-fs (%s): %pV\\n\", prefix, sb->s_id, &vaf);\n\tva_end(args);\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"mballoc.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include \"ext4_extents.h\"\t/* Needed for trace points definition */",
            "#include \"ext4.h\"",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/crc16.h>",
            "#include <linux/log2.h>",
            "#include <linux/ctype.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/random.h>",
            "#include <linux/vfs.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/parser.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/time.h>",
            "#include <linux/fs.h>",
            "#include <linux/string.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ext4_unfreeze(struct super_block *sb);",
            "static int ext4_freeze(struct super_block *sb);",
            "static inline int ext2_feature_set_ok(struct super_block *sb);",
            "static inline int ext3_feature_set_ok(struct super_block *sb);",
            "static void ext4_unregister_li_request(struct super_block *sb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"mballoc.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4_extents.h\"\t/* Needed for trace points definition */\n#include \"ext4.h\"\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <asm/uaccess.h>\n#include <linux/cleancache.h>\n#include <linux/crc16.h>\n#include <linux/log2.h>\n#include <linux/ctype.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/random.h>\n#include <linux/vfs.h>\n#include <linux/exportfs.h>\n#include <linux/buffer_head.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/jbd2.h>\n#include <linux/vmalloc.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n#include <linux/string.h>\n#include <linux/module.h>\n\nstatic int ext4_unfreeze(struct super_block *sb);\nstatic int ext4_freeze(struct super_block *sb);\nstatic inline int ext2_feature_set_ok(struct super_block *sb);\nstatic inline int ext3_feature_set_ok(struct super_block *sb);\nstatic void ext4_unregister_li_request(struct super_block *sb);\n\nvoid __ext4_msg(struct super_block *sb,\n\t\tconst char *prefix, const char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tif (!___ratelimit(&(EXT4_SB(sb)->s_msg_ratelimit_state), \"EXT4-fs\"))\n\t\treturn;\n\n\tva_start(args, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\tprintk(\"%sEXT4-fs (%s): %pV\\n\", prefix, sb->s_id, &vaf);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strchr",
          "args": [
            "qname",
            "'/'"
          ],
          "line": 1283
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "QTYPE2NAME",
          "args": [
            "qtype"
          ],
          "line": 1280
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "sbi->s_qf_names[qtype]",
            "qname"
          ],
          "line": 1275
        },
        "resolved": true,
        "details": {
          "function_name": "strcmp_null",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/super.c",
          "lines": "292-301",
          "snippet": "static int strcmp_null(const char *s1, const char *s2)\n{\n\tif (!s1 && !s2)\n\t\treturn 0;\n\tif (s1 && !s2)\n\t\treturn -1;\n\tif (!s1 && s2)\n\t\treturn 1;\n\treturn strcmp(s1, s2);\n}",
          "includes": [
            "#include <linux/ceph/debugfs.h>",
            "#include <linux/ceph/auth.h>",
            "#include <linux/ceph/mon_client.h>",
            "#include <linux/ceph/decode.h>",
            "#include <linux/ceph/ceph_features.h>",
            "#include \"cache.h\"",
            "#include \"mds_client.h\"",
            "#include \"super.h\"",
            "#include <linux/string.h>",
            "#include <linux/statfs.h>",
            "#include <linux/slab.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/sched.h>",
            "#include <linux/parser.h>",
            "#include <linux/mount.h>",
            "#include <linux/module.h>",
            "#include <linux/in6.h>",
            "#include <linux/inet.h>",
            "#include <linux/fs.h>",
            "#include <linux/ctype.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ceph/debugfs.h>\n#include <linux/ceph/auth.h>\n#include <linux/ceph/mon_client.h>\n#include <linux/ceph/decode.h>\n#include <linux/ceph/ceph_features.h>\n#include \"cache.h\"\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/string.h>\n#include <linux/statfs.h>\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/sched.h>\n#include <linux/parser.h>\n#include <linux/mount.h>\n#include <linux/module.h>\n#include <linux/in6.h>\n#include <linux/inet.h>\n#include <linux/fs.h>\n#include <linux/ctype.h>\n#include <linux/backing-dev.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic int strcmp_null(const char *s1, const char *s2)\n{\n\tif (!s1 && !s2)\n\t\treturn 0;\n\tif (s1 && !s2)\n\t\treturn -1;\n\tif (!s1 && s2)\n\t\treturn 1;\n\treturn strcmp(s1, s2);\n}"
        }
      },
      {
        "call_info": {
          "callee": "match_strdup",
          "args": [
            "args"
          ],
          "line": 1268
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXT4_HAS_RO_COMPAT_FEATURE",
          "args": [
            "sb",
            "EXT4_FEATURE_RO_COMPAT_QUOTA"
          ],
          "line": 1263
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sb_any_quota_loaded",
          "args": [
            "sb"
          ],
          "line": 1256
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXT4_SB",
          "args": [
            "sb"
          ],
          "line": 1252
        },
        "resolved": true,
        "details": {
          "function_name": "EXT4_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ext4.h",
          "lines": "1356-1359",
          "snippet": "static inline struct ext4_sb_info *EXT4_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include \"extents_status.h\"",
            "#include <linux/compat.h>",
            "#include <linux/falloc.h>",
            "#include <crypto/hash.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/wait.h>",
            "#include <linux/timer.h>",
            "#include <linux/mutex.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/quota.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extents_status.h\"\n#include <linux/compat.h>\n#include <linux/falloc.h>\n#include <crypto/hash.h>\n#include <linux/ratelimit.h>\n#include <linux/percpu_counter.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/wait.h>\n#include <linux/timer.h>\n#include <linux/mutex.h>\n#include <linux/seqlock.h>\n#include <linux/rbtree.h>\n#include <linux/rwsem.h>\n#include <linux/quota.h>\n#include <linux/jbd2.h>\n#include <linux/magic.h>\n#include <linux/blkdev.h>\n#include <linux/types.h>\n\nstatic inline struct ext4_sb_info *EXT4_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"mballoc.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4_extents.h\"\t/* Needed for trace points definition */\n#include \"ext4.h\"\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <asm/uaccess.h>\n#include <linux/cleancache.h>\n#include <linux/crc16.h>\n#include <linux/log2.h>\n#include <linux/ctype.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/random.h>\n#include <linux/vfs.h>\n#include <linux/exportfs.h>\n#include <linux/buffer_head.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/jbd2.h>\n#include <linux/vmalloc.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n#include <linux/string.h>\n#include <linux/module.h>\n\nstatic int ext4_show_options(struct seq_file *seq, struct dentry *root);\nstatic int ext4_unfreeze(struct super_block *sb);\nstatic int ext4_freeze(struct super_block *sb);\nstatic inline int ext2_feature_set_ok(struct super_block *sb);\nstatic inline int ext3_feature_set_ok(struct super_block *sb);\nstatic void ext4_unregister_li_request(struct super_block *sb);\n\nstatic int set_qf_name(struct super_block *sb, int qtype, substring_t *args)\n{\n\tstruct ext4_sb_info *sbi = EXT4_SB(sb);\n\tchar *qname;\n\tint ret = -1;\n\n\tif (sb_any_quota_loaded(sb) &&\n\t\t!sbi->s_qf_names[qtype]) {\n\t\text4_msg(sb, KERN_ERR,\n\t\t\t\"Cannot change journaled \"\n\t\t\t\"quota options when quota turned on\");\n\t\treturn -1;\n\t}\n\tif (EXT4_HAS_RO_COMPAT_FEATURE(sb, EXT4_FEATURE_RO_COMPAT_QUOTA)) {\n\t\text4_msg(sb, KERN_ERR, \"Cannot set journaled quota options \"\n\t\t\t \"when QUOTA feature is enabled\");\n\t\treturn -1;\n\t}\n\tqname = match_strdup(args);\n\tif (!qname) {\n\t\text4_msg(sb, KERN_ERR,\n\t\t\t\"Not enough memory for storing quotafile name\");\n\t\treturn -1;\n\t}\n\tif (sbi->s_qf_names[qtype]) {\n\t\tif (strcmp(sbi->s_qf_names[qtype], qname) == 0)\n\t\t\tret = 1;\n\t\telse\n\t\t\text4_msg(sb, KERN_ERR,\n\t\t\t\t \"%s quota file already specified\",\n\t\t\t\t QTYPE2NAME(qtype));\n\t\tgoto errout;\n\t}\n\tif (strchr(qname, '/')) {\n\t\text4_msg(sb, KERN_ERR,\n\t\t\t\"quotafile must be on filesystem root\");\n\t\tgoto errout;\n\t}\n\tsbi->s_qf_names[qtype] = qname;\n\tset_opt(sb, QUOTA);\n\treturn 1;\nerrout:\n\tkfree(qname);\n\treturn ret;\n}"
  },
  {
    "function_name": "get_sb_block",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/super.c",
    "lines": "1222-1243",
    "snippet": "static ext4_fsblk_t get_sb_block(void **data)\n{\n\text4_fsblk_t\tsb_block;\n\tchar\t\t*options = (char *) *data;\n\n\tif (!options || strncmp(options, \"sb=\", 3) != 0)\n\t\treturn 1;\t/* Default location */\n\n\toptions += 3;\n\t/* TODO: use simple_strtoll with >32bit ext4 */\n\tsb_block = simple_strtoul(options, &options, 0);\n\tif (*options && *options != ',') {\n\t\tprintk(KERN_ERR \"EXT4-fs: Invalid sb specification: %s\\n\",\n\t\t       (char *) *data);\n\t\treturn 1;\n\t}\n\tif (*options == ',')\n\t\toptions++;\n\t*data = (void *) options;\n\n\treturn sb_block;\n}",
    "includes": [
      "#include <trace/events/ext4.h>",
      "#include \"mballoc.h\"",
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"ext4_jbd2.h\"",
      "#include \"ext4_extents.h\"\t/* Needed for trace points definition */",
      "#include \"ext4.h\"",
      "#include <linux/freezer.h>",
      "#include <linux/kthread.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/cleancache.h>",
      "#include <linux/crc16.h>",
      "#include <linux/log2.h>",
      "#include <linux/ctype.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/namei.h>",
      "#include <linux/mount.h>",
      "#include <linux/random.h>",
      "#include <linux/vfs.h>",
      "#include <linux/exportfs.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/parser.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/init.h>",
      "#include <linux/slab.h>",
      "#include <linux/jbd2.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/time.h>",
      "#include <linux/fs.h>",
      "#include <linux/string.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ext4_remount(struct super_block *sb, int *flags, char *data);",
      "static int ext4_unfreeze(struct super_block *sb);",
      "static int ext4_freeze(struct super_block *sb);",
      "static struct dentry *ext4_mount(struct file_system_type *fs_type, int flags,\n\t\t       const char *dev_name, void *data);",
      "static inline int ext2_feature_set_ok(struct super_block *sb);",
      "static inline int ext3_feature_set_ok(struct super_block *sb);",
      "static void ext4_unregister_li_request(struct super_block *sb);",
      "static int ext4_reserve_clusters(struct ext4_sb_info *, ext4_fsblk_t);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_ERR \"EXT4-fs: Invalid sb specification: %s\\n\"",
            "(char *) *data"
          ],
          "line": 1234
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_printk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/super.c",
          "lines": "186-213",
          "snippet": "void btrfs_printk(const struct btrfs_fs_info *fs_info, const char *fmt, ...)\n{\n\tstruct super_block *sb = fs_info->sb;\n\tchar lvl[4];\n\tstruct va_format vaf;\n\tva_list args;\n\tconst char *type = logtypes[4];\n\tint kern_level;\n\n\tva_start(args, fmt);\n\n\tkern_level = printk_get_level(fmt);\n\tif (kern_level) {\n\t\tsize_t size = printk_skip_level(fmt) - fmt;\n\t\tmemcpy(lvl, fmt,  size);\n\t\tlvl[size] = '\\0';\n\t\tfmt += size;\n\t\ttype = logtypes[kern_level - '0'];\n\t} else\n\t\t*lvl = '\\0';\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\tprintk(\"%sBTRFS %s (device %s): %pV\\n\", lvl, type, sb->s_id, &vaf);\n\n\tva_end(args);\n}",
          "includes": [
            "#include <trace/events/btrfs.h>",
            "#include \"qgroup.h\"",
            "#include \"tests/btrfs-tests.h\"",
            "#include \"backref.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"dev-replace.h\"",
            "#include \"rcu-string.h\"",
            "#include \"compression.h\"",
            "#include \"export.h\"",
            "#include \"volumes.h\"",
            "#include \"xattr.h\"",
            "#include \"props.h\"",
            "#include \"hash.h\"",
            "#include \"print-tree.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include \"delayed-inode.h\"",
            "#include <linux/btrfs.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/slab.h>",
            "#include <linux/magic.h>",
            "#include <linux/miscdevice.h>",
            "#include <linux/namei.h>",
            "#include <linux/ctype.h>",
            "#include <linux/parser.h>",
            "#include <linux/compat.h>",
            "#include <linux/statfs.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/mpage.h>",
            "#include <linux/mount.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/string.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/init.h>",
            "#include <linux/time.h>",
            "#include <linux/highmem.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/module.h>",
            "#include <linux/blkdev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/btrfs.h>\n#include \"qgroup.h\"\n#include \"tests/btrfs-tests.h\"\n#include \"backref.h\"\n#include \"free-space-cache.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"compression.h\"\n#include \"export.h\"\n#include \"volumes.h\"\n#include \"xattr.h\"\n#include \"props.h\"\n#include \"hash.h\"\n#include \"print-tree.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include \"delayed-inode.h\"\n#include <linux/btrfs.h>\n#include <linux/ratelimit.h>\n#include <linux/cleancache.h>\n#include <linux/slab.h>\n#include <linux/magic.h>\n#include <linux/miscdevice.h>\n#include <linux/namei.h>\n#include <linux/ctype.h>\n#include <linux/parser.h>\n#include <linux/compat.h>\n#include <linux/statfs.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/mpage.h>\n#include <linux/mount.h>\n#include <linux/backing-dev.h>\n#include <linux/string.h>\n#include <linux/seq_file.h>\n#include <linux/init.h>\n#include <linux/time.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n#include <linux/buffer_head.h>\n#include <linux/module.h>\n#include <linux/blkdev.h>\n\nvoid btrfs_printk(const struct btrfs_fs_info *fs_info, const char *fmt, ...)\n{\n\tstruct super_block *sb = fs_info->sb;\n\tchar lvl[4];\n\tstruct va_format vaf;\n\tva_list args;\n\tconst char *type = logtypes[4];\n\tint kern_level;\n\n\tva_start(args, fmt);\n\n\tkern_level = printk_get_level(fmt);\n\tif (kern_level) {\n\t\tsize_t size = printk_skip_level(fmt) - fmt;\n\t\tmemcpy(lvl, fmt,  size);\n\t\tlvl[size] = '\\0';\n\t\tfmt += size;\n\t\ttype = logtypes[kern_level - '0'];\n\t} else\n\t\t*lvl = '\\0';\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\tprintk(\"%sBTRFS %s (device %s): %pV\\n\", lvl, type, sb->s_id, &vaf);\n\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "simple_strtoul",
          "args": [
            "options",
            "&options",
            "0"
          ],
          "line": 1232
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "options",
            "\"sb=\"",
            "3"
          ],
          "line": 1227
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"mballoc.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4_extents.h\"\t/* Needed for trace points definition */\n#include \"ext4.h\"\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <asm/uaccess.h>\n#include <linux/cleancache.h>\n#include <linux/crc16.h>\n#include <linux/log2.h>\n#include <linux/ctype.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/random.h>\n#include <linux/vfs.h>\n#include <linux/exportfs.h>\n#include <linux/buffer_head.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/jbd2.h>\n#include <linux/vmalloc.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n#include <linux/string.h>\n#include <linux/module.h>\n\nstatic int ext4_remount(struct super_block *sb, int *flags, char *data);\nstatic int ext4_unfreeze(struct super_block *sb);\nstatic int ext4_freeze(struct super_block *sb);\nstatic struct dentry *ext4_mount(struct file_system_type *fs_type, int flags,\n\t\t       const char *dev_name, void *data);\nstatic inline int ext2_feature_set_ok(struct super_block *sb);\nstatic inline int ext3_feature_set_ok(struct super_block *sb);\nstatic void ext4_unregister_li_request(struct super_block *sb);\nstatic int ext4_reserve_clusters(struct ext4_sb_info *, ext4_fsblk_t);\n\nstatic ext4_fsblk_t get_sb_block(void **data)\n{\n\text4_fsblk_t\tsb_block;\n\tchar\t\t*options = (char *) *data;\n\n\tif (!options || strncmp(options, \"sb=\", 3) != 0)\n\t\treturn 1;\t/* Default location */\n\n\toptions += 3;\n\t/* TODO: use simple_strtoll with >32bit ext4 */\n\tsb_block = simple_strtoul(options, &options, 0);\n\tif (*options && *options != ',') {\n\t\tprintk(KERN_ERR \"EXT4-fs: Invalid sb specification: %s\\n\",\n\t\t       (char *) *data);\n\t\treturn 1;\n\t}\n\tif (*options == ',')\n\t\toptions++;\n\t*data = (void *) options;\n\n\treturn sb_block;\n}"
  },
  {
    "function_name": "ext4_get_dquots",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/super.c",
    "lines": "1059-1062",
    "snippet": "static struct dquot **ext4_get_dquots(struct inode *inode)\n{\n\treturn EXT4_I(inode)->i_dquot;\n}",
    "includes": [
      "#include <trace/events/ext4.h>",
      "#include \"mballoc.h\"",
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"ext4_jbd2.h\"",
      "#include \"ext4_extents.h\"\t/* Needed for trace points definition */",
      "#include \"ext4.h\"",
      "#include <linux/freezer.h>",
      "#include <linux/kthread.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/cleancache.h>",
      "#include <linux/crc16.h>",
      "#include <linux/log2.h>",
      "#include <linux/ctype.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/namei.h>",
      "#include <linux/mount.h>",
      "#include <linux/random.h>",
      "#include <linux/vfs.h>",
      "#include <linux/exportfs.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/parser.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/init.h>",
      "#include <linux/slab.h>",
      "#include <linux/jbd2.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/time.h>",
      "#include <linux/fs.h>",
      "#include <linux/string.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "EXT4_I",
          "args": [
            "inode"
          ],
          "line": 1061
        },
        "resolved": true,
        "details": {
          "function_name": "EXT4_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ext4.h",
          "lines": "1360-1363",
          "snippet": "static inline struct ext4_inode_info *EXT4_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ext4_inode_info, vfs_inode);\n}",
          "includes": [
            "#include \"extents_status.h\"",
            "#include <linux/compat.h>",
            "#include <linux/falloc.h>",
            "#include <crypto/hash.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/wait.h>",
            "#include <linux/timer.h>",
            "#include <linux/mutex.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/quota.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extents_status.h\"\n#include <linux/compat.h>\n#include <linux/falloc.h>\n#include <crypto/hash.h>\n#include <linux/ratelimit.h>\n#include <linux/percpu_counter.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/wait.h>\n#include <linux/timer.h>\n#include <linux/mutex.h>\n#include <linux/seqlock.h>\n#include <linux/rbtree.h>\n#include <linux/rwsem.h>\n#include <linux/quota.h>\n#include <linux/jbd2.h>\n#include <linux/magic.h>\n#include <linux/blkdev.h>\n#include <linux/types.h>\n\nstatic inline struct ext4_inode_info *EXT4_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ext4_inode_info, vfs_inode);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"mballoc.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4_extents.h\"\t/* Needed for trace points definition */\n#include \"ext4.h\"\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <asm/uaccess.h>\n#include <linux/cleancache.h>\n#include <linux/crc16.h>\n#include <linux/log2.h>\n#include <linux/ctype.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/random.h>\n#include <linux/vfs.h>\n#include <linux/exportfs.h>\n#include <linux/buffer_head.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/jbd2.h>\n#include <linux/vmalloc.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n#include <linux/string.h>\n#include <linux/module.h>\n\nstatic struct dquot **ext4_get_dquots(struct inode *inode)\n{\n\treturn EXT4_I(inode)->i_dquot;\n}"
  },
  {
    "function_name": "bdev_try_to_free_page",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/super.c",
    "lines": "1024-1036",
    "snippet": "static int bdev_try_to_free_page(struct super_block *sb, struct page *page,\n\t\t\t\t gfp_t wait)\n{\n\tjournal_t *journal = EXT4_SB(sb)->s_journal;\n\n\tWARN_ON(PageChecked(page));\n\tif (!page_has_buffers(page))\n\t\treturn 0;\n\tif (journal)\n\t\treturn jbd2_journal_try_to_free_buffers(journal, page,\n\t\t\t\t\t\t\twait & ~__GFP_WAIT);\n\treturn try_to_free_buffers(page);\n}",
    "includes": [
      "#include <trace/events/ext4.h>",
      "#include \"mballoc.h\"",
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"ext4_jbd2.h\"",
      "#include \"ext4_extents.h\"\t/* Needed for trace points definition */",
      "#include \"ext4.h\"",
      "#include <linux/freezer.h>",
      "#include <linux/kthread.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/cleancache.h>",
      "#include <linux/crc16.h>",
      "#include <linux/log2.h>",
      "#include <linux/ctype.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/namei.h>",
      "#include <linux/mount.h>",
      "#include <linux/random.h>",
      "#include <linux/vfs.h>",
      "#include <linux/exportfs.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/parser.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/init.h>",
      "#include <linux/slab.h>",
      "#include <linux/jbd2.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/time.h>",
      "#include <linux/fs.h>",
      "#include <linux/string.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ext4_sync_fs(struct super_block *sb, int wait);",
      "static int ext4_unfreeze(struct super_block *sb);",
      "static int ext4_freeze(struct super_block *sb);",
      "static inline int ext2_feature_set_ok(struct super_block *sb);",
      "static inline int ext3_feature_set_ok(struct super_block *sb);",
      "static void ext4_unregister_li_request(struct super_block *sb);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "try_to_free_buffers",
          "args": [
            "page"
          ],
          "line": 1035
        },
        "resolved": true,
        "details": {
          "function_name": "try_to_free_buffers",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "3214-3260",
          "snippet": "int try_to_free_buffers(struct page *page)\n{\n\tstruct address_space * const mapping = page->mapping;\n\tstruct buffer_head *buffers_to_free = NULL;\n\tint ret = 0;\n\n\tBUG_ON(!PageLocked(page));\n\tif (PageWriteback(page))\n\t\treturn 0;\n\n\tif (mapping == NULL) {\t\t/* can this still happen? */\n\t\tret = drop_buffers(page, &buffers_to_free);\n\t\tgoto out;\n\t}\n\n\tspin_lock(&mapping->private_lock);\n\tret = drop_buffers(page, &buffers_to_free);\n\n\t/*\n\t * If the filesystem writes its buffers by hand (eg ext3)\n\t * then we can have clean buffers against a dirty page.  We\n\t * clean the page here; otherwise the VM will never notice\n\t * that the filesystem did any IO at all.\n\t *\n\t * Also, during truncate, discard_buffer will have marked all\n\t * the page's buffers clean.  We discover that here and clean\n\t * the page also.\n\t *\n\t * private_lock must be held over this entire operation in order\n\t * to synchronise against __set_page_dirty_buffers and prevent the\n\t * dirty bit from being lost.\n\t */\n\tif (ret)\n\t\tcancel_dirty_page(page, PAGE_CACHE_SIZE);\n\tspin_unlock(&mapping->private_lock);\nout:\n\tif (buffers_to_free) {\n\t\tstruct buffer_head *bh = buffers_to_free;\n\n\t\tdo {\n\t\t\tstruct buffer_head *next = bh->b_this_page;\n\t\t\tfree_buffer_head(bh);\n\t\t\tbh = next;\n\t\t} while (bh != buffers_to_free);\n\t}\n\treturn ret;\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nint try_to_free_buffers(struct page *page)\n{\n\tstruct address_space * const mapping = page->mapping;\n\tstruct buffer_head *buffers_to_free = NULL;\n\tint ret = 0;\n\n\tBUG_ON(!PageLocked(page));\n\tif (PageWriteback(page))\n\t\treturn 0;\n\n\tif (mapping == NULL) {\t\t/* can this still happen? */\n\t\tret = drop_buffers(page, &buffers_to_free);\n\t\tgoto out;\n\t}\n\n\tspin_lock(&mapping->private_lock);\n\tret = drop_buffers(page, &buffers_to_free);\n\n\t/*\n\t * If the filesystem writes its buffers by hand (eg ext3)\n\t * then we can have clean buffers against a dirty page.  We\n\t * clean the page here; otherwise the VM will never notice\n\t * that the filesystem did any IO at all.\n\t *\n\t * Also, during truncate, discard_buffer will have marked all\n\t * the page's buffers clean.  We discover that here and clean\n\t * the page also.\n\t *\n\t * private_lock must be held over this entire operation in order\n\t * to synchronise against __set_page_dirty_buffers and prevent the\n\t * dirty bit from being lost.\n\t */\n\tif (ret)\n\t\tcancel_dirty_page(page, PAGE_CACHE_SIZE);\n\tspin_unlock(&mapping->private_lock);\nout:\n\tif (buffers_to_free) {\n\t\tstruct buffer_head *bh = buffers_to_free;\n\n\t\tdo {\n\t\t\tstruct buffer_head *next = bh->b_this_page;\n\t\t\tfree_buffer_head(bh);\n\t\t\tbh = next;\n\t\t} while (bh != buffers_to_free);\n\t}\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "jbd2_journal_try_to_free_buffers",
          "args": [
            "journal",
            "page",
            "wait & ~__GFP_WAIT"
          ],
          "line": 1033
        },
        "resolved": true,
        "details": {
          "function_name": "jbd2_journal_try_to_free_buffers",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd2/transaction.c",
          "lines": "1871-1906",
          "snippet": "int jbd2_journal_try_to_free_buffers(journal_t *journal,\n\t\t\t\tstruct page *page, gfp_t gfp_mask)\n{\n\tstruct buffer_head *head;\n\tstruct buffer_head *bh;\n\tint ret = 0;\n\n\tJ_ASSERT(PageLocked(page));\n\n\thead = page_buffers(page);\n\tbh = head;\n\tdo {\n\t\tstruct journal_head *jh;\n\n\t\t/*\n\t\t * We take our own ref against the journal_head here to avoid\n\t\t * having to add tons of locking around each instance of\n\t\t * jbd2_journal_put_journal_head().\n\t\t */\n\t\tjh = jbd2_journal_grab_journal_head(bh);\n\t\tif (!jh)\n\t\t\tcontinue;\n\n\t\tjbd_lock_bh_state(bh);\n\t\t__journal_try_to_free_buffer(journal, bh);\n\t\tjbd2_journal_put_journal_head(jh);\n\t\tjbd_unlock_bh_state(bh);\n\t\tif (buffer_jbd(bh))\n\t\t\tgoto busy;\n\t} while ((bh = bh->b_this_page) != head);\n\n\tret = try_to_free_buffers(page);\n\nbusy:\n\treturn ret;\n}",
          "includes": [
            "#include <trace/events/jbd2.h>",
            "#include <linux/module.h>",
            "#include <linux/bug.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/timer.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __jbd2_journal_temp_unlink_buffer(struct journal_head *jh);",
            "static void __jbd2_journal_unfile_buffer(struct journal_head *jh);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/jbd2.h>\n#include <linux/module.h>\n#include <linux/bug.h>\n#include <linux/backing-dev.h>\n#include <linux/hrtimer.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/timer.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd2.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n\nstatic void __jbd2_journal_temp_unlink_buffer(struct journal_head *jh);\nstatic void __jbd2_journal_unfile_buffer(struct journal_head *jh);\n\nint jbd2_journal_try_to_free_buffers(journal_t *journal,\n\t\t\t\tstruct page *page, gfp_t gfp_mask)\n{\n\tstruct buffer_head *head;\n\tstruct buffer_head *bh;\n\tint ret = 0;\n\n\tJ_ASSERT(PageLocked(page));\n\n\thead = page_buffers(page);\n\tbh = head;\n\tdo {\n\t\tstruct journal_head *jh;\n\n\t\t/*\n\t\t * We take our own ref against the journal_head here to avoid\n\t\t * having to add tons of locking around each instance of\n\t\t * jbd2_journal_put_journal_head().\n\t\t */\n\t\tjh = jbd2_journal_grab_journal_head(bh);\n\t\tif (!jh)\n\t\t\tcontinue;\n\n\t\tjbd_lock_bh_state(bh);\n\t\t__journal_try_to_free_buffer(journal, bh);\n\t\tjbd2_journal_put_journal_head(jh);\n\t\tjbd_unlock_bh_state(bh);\n\t\tif (buffer_jbd(bh))\n\t\t\tgoto busy;\n\t} while ((bh = bh->b_this_page) != head);\n\n\tret = try_to_free_buffers(page);\n\nbusy:\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "page_has_buffers",
          "args": [
            "page"
          ],
          "line": 1030
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "PageChecked(page)"
          ],
          "line": 1029
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageChecked",
          "args": [
            "page"
          ],
          "line": 1029
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXT4_SB",
          "args": [
            "sb"
          ],
          "line": 1027
        },
        "resolved": true,
        "details": {
          "function_name": "EXT4_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ext4.h",
          "lines": "1356-1359",
          "snippet": "static inline struct ext4_sb_info *EXT4_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include \"extents_status.h\"",
            "#include <linux/compat.h>",
            "#include <linux/falloc.h>",
            "#include <crypto/hash.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/wait.h>",
            "#include <linux/timer.h>",
            "#include <linux/mutex.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/quota.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extents_status.h\"\n#include <linux/compat.h>\n#include <linux/falloc.h>\n#include <crypto/hash.h>\n#include <linux/ratelimit.h>\n#include <linux/percpu_counter.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/wait.h>\n#include <linux/timer.h>\n#include <linux/mutex.h>\n#include <linux/seqlock.h>\n#include <linux/rbtree.h>\n#include <linux/rwsem.h>\n#include <linux/quota.h>\n#include <linux/jbd2.h>\n#include <linux/magic.h>\n#include <linux/blkdev.h>\n#include <linux/types.h>\n\nstatic inline struct ext4_sb_info *EXT4_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"mballoc.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4_extents.h\"\t/* Needed for trace points definition */\n#include \"ext4.h\"\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <asm/uaccess.h>\n#include <linux/cleancache.h>\n#include <linux/crc16.h>\n#include <linux/log2.h>\n#include <linux/ctype.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/random.h>\n#include <linux/vfs.h>\n#include <linux/exportfs.h>\n#include <linux/buffer_head.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/jbd2.h>\n#include <linux/vmalloc.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n#include <linux/string.h>\n#include <linux/module.h>\n\nstatic int ext4_sync_fs(struct super_block *sb, int wait);\nstatic int ext4_unfreeze(struct super_block *sb);\nstatic int ext4_freeze(struct super_block *sb);\nstatic inline int ext2_feature_set_ok(struct super_block *sb);\nstatic inline int ext3_feature_set_ok(struct super_block *sb);\nstatic void ext4_unregister_li_request(struct super_block *sb);\n\nstatic int bdev_try_to_free_page(struct super_block *sb, struct page *page,\n\t\t\t\t gfp_t wait)\n{\n\tjournal_t *journal = EXT4_SB(sb)->s_journal;\n\n\tWARN_ON(PageChecked(page));\n\tif (!page_has_buffers(page))\n\t\treturn 0;\n\tif (journal)\n\t\treturn jbd2_journal_try_to_free_buffers(journal, page,\n\t\t\t\t\t\t\twait & ~__GFP_WAIT);\n\treturn try_to_free_buffers(page);\n}"
  },
  {
    "function_name": "ext4_fh_to_parent",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/super.c",
    "lines": "1011-1016",
    "snippet": "static struct dentry *ext4_fh_to_parent(struct super_block *sb, struct fid *fid,\n\t\t\t\t\tint fh_len, int fh_type)\n{\n\treturn generic_fh_to_parent(sb, fid, fh_len, fh_type,\n\t\t\t\t    ext4_nfs_get_inode);\n}",
    "includes": [
      "#include <trace/events/ext4.h>",
      "#include \"mballoc.h\"",
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"ext4_jbd2.h\"",
      "#include \"ext4_extents.h\"\t/* Needed for trace points definition */",
      "#include \"ext4.h\"",
      "#include <linux/freezer.h>",
      "#include <linux/kthread.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/cleancache.h>",
      "#include <linux/crc16.h>",
      "#include <linux/log2.h>",
      "#include <linux/ctype.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/namei.h>",
      "#include <linux/mount.h>",
      "#include <linux/random.h>",
      "#include <linux/vfs.h>",
      "#include <linux/exportfs.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/parser.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/init.h>",
      "#include <linux/slab.h>",
      "#include <linux/jbd2.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/time.h>",
      "#include <linux/fs.h>",
      "#include <linux/string.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ext4_unfreeze(struct super_block *sb);",
      "static int ext4_freeze(struct super_block *sb);",
      "static inline int ext2_feature_set_ok(struct super_block *sb);",
      "static inline int ext3_feature_set_ok(struct super_block *sb);",
      "static void ext4_unregister_li_request(struct super_block *sb);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "generic_fh_to_parent",
          "args": [
            "sb",
            "fid",
            "fh_len",
            "fh_type",
            "ext4_nfs_get_inode"
          ],
          "line": 1014
        },
        "resolved": true,
        "details": {
          "function_name": "generic_fh_to_parent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/libfs.c",
          "lines": "906-923",
          "snippet": "struct dentry *generic_fh_to_parent(struct super_block *sb, struct fid *fid,\n\t\tint fh_len, int fh_type, struct inode *(*get_inode)\n\t\t\t(struct super_block *sb, u64 ino, u32 gen))\n{\n\tstruct inode *inode = NULL;\n\n\tif (fh_len <= 2)\n\t\treturn NULL;\n\n\tswitch (fh_type) {\n\tcase FILEID_INO32_GEN_PARENT:\n\t\tinode = get_inode(sb, fid->i32.parent_ino,\n\t\t\t\t  (fh_len > 3 ? fid->i32.parent_gen : 0));\n\t\tbreak;\n\t}\n\n\treturn d_obtain_alias(inode);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/buffer_head.h> /* sync_mapping_buffers */",
            "#include <linux/writeback.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/namei.h>",
            "#include <linux/mutex.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/vfs.h>",
            "#include <linux/mount.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/export.h>",
            "#include <linux/blkdev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <linux/buffer_head.h> /* sync_mapping_buffers */\n#include <linux/writeback.h>\n#include <linux/exportfs.h>\n#include <linux/namei.h>\n#include <linux/mutex.h>\n#include <linux/quotaops.h>\n#include <linux/vfs.h>\n#include <linux/mount.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include <linux/export.h>\n#include <linux/blkdev.h>\n\nstruct dentry *generic_fh_to_parent(struct super_block *sb, struct fid *fid,\n\t\tint fh_len, int fh_type, struct inode *(*get_inode)\n\t\t\t(struct super_block *sb, u64 ino, u32 gen))\n{\n\tstruct inode *inode = NULL;\n\n\tif (fh_len <= 2)\n\t\treturn NULL;\n\n\tswitch (fh_type) {\n\tcase FILEID_INO32_GEN_PARENT:\n\t\tinode = get_inode(sb, fid->i32.parent_ino,\n\t\t\t\t  (fh_len > 3 ? fid->i32.parent_gen : 0));\n\t\tbreak;\n\t}\n\n\treturn d_obtain_alias(inode);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"mballoc.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4_extents.h\"\t/* Needed for trace points definition */\n#include \"ext4.h\"\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <asm/uaccess.h>\n#include <linux/cleancache.h>\n#include <linux/crc16.h>\n#include <linux/log2.h>\n#include <linux/ctype.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/random.h>\n#include <linux/vfs.h>\n#include <linux/exportfs.h>\n#include <linux/buffer_head.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/jbd2.h>\n#include <linux/vmalloc.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n#include <linux/string.h>\n#include <linux/module.h>\n\nstatic int ext4_unfreeze(struct super_block *sb);\nstatic int ext4_freeze(struct super_block *sb);\nstatic inline int ext2_feature_set_ok(struct super_block *sb);\nstatic inline int ext3_feature_set_ok(struct super_block *sb);\nstatic void ext4_unregister_li_request(struct super_block *sb);\n\nstatic struct dentry *ext4_fh_to_parent(struct super_block *sb, struct fid *fid,\n\t\t\t\t\tint fh_len, int fh_type)\n{\n\treturn generic_fh_to_parent(sb, fid, fh_len, fh_type,\n\t\t\t\t    ext4_nfs_get_inode);\n}"
  },
  {
    "function_name": "ext4_fh_to_dentry",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/super.c",
    "lines": "1004-1009",
    "snippet": "static struct dentry *ext4_fh_to_dentry(struct super_block *sb, struct fid *fid,\n\t\t\t\t\tint fh_len, int fh_type)\n{\n\treturn generic_fh_to_dentry(sb, fid, fh_len, fh_type,\n\t\t\t\t    ext4_nfs_get_inode);\n}",
    "includes": [
      "#include <trace/events/ext4.h>",
      "#include \"mballoc.h\"",
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"ext4_jbd2.h\"",
      "#include \"ext4_extents.h\"\t/* Needed for trace points definition */",
      "#include \"ext4.h\"",
      "#include <linux/freezer.h>",
      "#include <linux/kthread.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/cleancache.h>",
      "#include <linux/crc16.h>",
      "#include <linux/log2.h>",
      "#include <linux/ctype.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/namei.h>",
      "#include <linux/mount.h>",
      "#include <linux/random.h>",
      "#include <linux/vfs.h>",
      "#include <linux/exportfs.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/parser.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/init.h>",
      "#include <linux/slab.h>",
      "#include <linux/jbd2.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/time.h>",
      "#include <linux/fs.h>",
      "#include <linux/string.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ext4_unfreeze(struct super_block *sb);",
      "static int ext4_freeze(struct super_block *sb);",
      "static inline int ext2_feature_set_ok(struct super_block *sb);",
      "static inline int ext3_feature_set_ok(struct super_block *sb);",
      "static void ext4_unregister_li_request(struct super_block *sb);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "generic_fh_to_dentry",
          "args": [
            "sb",
            "fid",
            "fh_len",
            "fh_type",
            "ext4_nfs_get_inode"
          ],
          "line": 1007
        },
        "resolved": true,
        "details": {
          "function_name": "generic_fh_to_dentry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/libfs.c",
          "lines": "873-890",
          "snippet": "struct dentry *generic_fh_to_dentry(struct super_block *sb, struct fid *fid,\n\t\tint fh_len, int fh_type, struct inode *(*get_inode)\n\t\t\t(struct super_block *sb, u64 ino, u32 gen))\n{\n\tstruct inode *inode = NULL;\n\n\tif (fh_len < 2)\n\t\treturn NULL;\n\n\tswitch (fh_type) {\n\tcase FILEID_INO32_GEN:\n\tcase FILEID_INO32_GEN_PARENT:\n\t\tinode = get_inode(sb, fid->i32.ino, fid->i32.gen);\n\t\tbreak;\n\t}\n\n\treturn d_obtain_alias(inode);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/buffer_head.h> /* sync_mapping_buffers */",
            "#include <linux/writeback.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/namei.h>",
            "#include <linux/mutex.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/vfs.h>",
            "#include <linux/mount.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/export.h>",
            "#include <linux/blkdev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <linux/buffer_head.h> /* sync_mapping_buffers */\n#include <linux/writeback.h>\n#include <linux/exportfs.h>\n#include <linux/namei.h>\n#include <linux/mutex.h>\n#include <linux/quotaops.h>\n#include <linux/vfs.h>\n#include <linux/mount.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include <linux/export.h>\n#include <linux/blkdev.h>\n\nstruct dentry *generic_fh_to_dentry(struct super_block *sb, struct fid *fid,\n\t\tint fh_len, int fh_type, struct inode *(*get_inode)\n\t\t\t(struct super_block *sb, u64 ino, u32 gen))\n{\n\tstruct inode *inode = NULL;\n\n\tif (fh_len < 2)\n\t\treturn NULL;\n\n\tswitch (fh_type) {\n\tcase FILEID_INO32_GEN:\n\tcase FILEID_INO32_GEN_PARENT:\n\t\tinode = get_inode(sb, fid->i32.ino, fid->i32.gen);\n\t\tbreak;\n\t}\n\n\treturn d_obtain_alias(inode);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"mballoc.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4_extents.h\"\t/* Needed for trace points definition */\n#include \"ext4.h\"\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <asm/uaccess.h>\n#include <linux/cleancache.h>\n#include <linux/crc16.h>\n#include <linux/log2.h>\n#include <linux/ctype.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/random.h>\n#include <linux/vfs.h>\n#include <linux/exportfs.h>\n#include <linux/buffer_head.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/jbd2.h>\n#include <linux/vmalloc.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n#include <linux/string.h>\n#include <linux/module.h>\n\nstatic int ext4_unfreeze(struct super_block *sb);\nstatic int ext4_freeze(struct super_block *sb);\nstatic inline int ext2_feature_set_ok(struct super_block *sb);\nstatic inline int ext3_feature_set_ok(struct super_block *sb);\nstatic void ext4_unregister_li_request(struct super_block *sb);\n\nstatic struct dentry *ext4_fh_to_dentry(struct super_block *sb, struct fid *fid,\n\t\t\t\t\tint fh_len, int fh_type)\n{\n\treturn generic_fh_to_dentry(sb, fid, fh_len, fh_type,\n\t\t\t\t    ext4_nfs_get_inode);\n}"
  },
  {
    "function_name": "ext4_nfs_get_inode",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/super.c",
    "lines": "975-1002",
    "snippet": "static struct inode *ext4_nfs_get_inode(struct super_block *sb,\n\t\t\t\t\tu64 ino, u32 generation)\n{\n\tstruct inode *inode;\n\n\tif (ino < EXT4_FIRST_INO(sb) && ino != EXT4_ROOT_INO)\n\t\treturn ERR_PTR(-ESTALE);\n\tif (ino > le32_to_cpu(EXT4_SB(sb)->s_es->s_inodes_count))\n\t\treturn ERR_PTR(-ESTALE);\n\n\t/* iget isn't really right if the inode is currently unallocated!!\n\t *\n\t * ext4_read_inode will return a bad_inode if the inode had been\n\t * deleted, so we should be safe.\n\t *\n\t * Currently we don't know the generation for parent directory, so\n\t * a generation of 0 means \"accept any\"\n\t */\n\tinode = ext4_iget_normal(sb, ino);\n\tif (IS_ERR(inode))\n\t\treturn ERR_CAST(inode);\n\tif (generation && inode->i_generation != generation) {\n\t\tiput(inode);\n\t\treturn ERR_PTR(-ESTALE);\n\t}\n\n\treturn inode;\n}",
    "includes": [
      "#include <trace/events/ext4.h>",
      "#include \"mballoc.h\"",
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"ext4_jbd2.h\"",
      "#include \"ext4_extents.h\"\t/* Needed for trace points definition */",
      "#include \"ext4.h\"",
      "#include <linux/freezer.h>",
      "#include <linux/kthread.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/cleancache.h>",
      "#include <linux/crc16.h>",
      "#include <linux/log2.h>",
      "#include <linux/ctype.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/namei.h>",
      "#include <linux/mount.h>",
      "#include <linux/random.h>",
      "#include <linux/vfs.h>",
      "#include <linux/exportfs.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/parser.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/init.h>",
      "#include <linux/slab.h>",
      "#include <linux/jbd2.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/time.h>",
      "#include <linux/fs.h>",
      "#include <linux/string.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ext4_unfreeze(struct super_block *sb);",
      "static int ext4_freeze(struct super_block *sb);",
      "static inline int ext2_feature_set_ok(struct super_block *sb);",
      "static inline int ext3_feature_set_ok(struct super_block *sb);",
      "static void ext4_unregister_li_request(struct super_block *sb);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-ESTALE"
          ],
          "line": 998
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "iput",
          "args": [
            "inode"
          ],
          "line": 997
        },
        "resolved": true,
        "details": {
          "function_name": "dentry_iput",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "308-327",
          "snippet": "static void dentry_iput(struct dentry * dentry)\n\t__releases(dentry->d_lock)\n\t__releases(dentry->d_inode->i_lock)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tif (inode) {\n\t\tdentry->d_inode = NULL;\n\t\thlist_del_init(&dentry->d_u.d_alias);\n\t\tspin_unlock(&dentry->d_lock);\n\t\tspin_unlock(&inode->i_lock);\n\t\tif (!inode->i_nlink)\n\t\t\tfsnotify_inoderemove(inode);\n\t\tif (dentry->d_op && dentry->d_op->d_iput)\n\t\t\tdentry->d_op->d_iput(dentry, inode);\n\t\telse\n\t\t\tiput(inode);\n\t} else {\n\t\tspin_unlock(&dentry->d_lock);\n\t}\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nstatic void dentry_iput(struct dentry * dentry)\n\t__releases(dentry->d_lock)\n\t__releases(dentry->d_inode->i_lock)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tif (inode) {\n\t\tdentry->d_inode = NULL;\n\t\thlist_del_init(&dentry->d_u.d_alias);\n\t\tspin_unlock(&dentry->d_lock);\n\t\tspin_unlock(&inode->i_lock);\n\t\tif (!inode->i_nlink)\n\t\t\tfsnotify_inoderemove(inode);\n\t\tif (dentry->d_op && dentry->d_op->d_iput)\n\t\t\tdentry->d_op->d_iput(dentry, inode);\n\t\telse\n\t\t\tiput(inode);\n\t} else {\n\t\tspin_unlock(&dentry->d_lock);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERR_CAST",
          "args": [
            "inode"
          ],
          "line": 995
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "inode"
          ],
          "line": 994
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_iget_normal",
          "args": [
            "sb",
            "ino"
          ],
          "line": 993
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_iget_normal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/inode.c",
          "lines": "4138-4143",
          "snippet": "struct inode *ext4_iget_normal(struct super_block *sb, unsigned long ino)\n{\n\tif (ino < EXT4_FIRST_INO(sb) && ino != EXT4_ROOT_INO)\n\t\treturn ERR_PTR(-EIO);\n\treturn ext4_iget(sb, ino);\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"truncate.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include <linux/bitops.h>",
            "#include <linux/aio.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/printk.h>",
            "#include <linux/kernel.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/bio.h>",
            "#include <linux/uio.h>",
            "#include <linux/namei.h>",
            "#include <linux/mpage.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highuid.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/time.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"truncate.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include <linux/bitops.h>\n#include <linux/aio.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/printk.h>\n#include <linux/kernel.h>\n#include <linux/workqueue.h>\n#include <linux/bio.h>\n#include <linux/uio.h>\n#include <linux/namei.h>\n#include <linux/mpage.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/highuid.h>\n#include <linux/jbd2.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n\nstruct inode *ext4_iget_normal(struct super_block *sb, unsigned long ino)\n{\n\tif (ino < EXT4_FIRST_INO(sb) && ino != EXT4_ROOT_INO)\n\t\treturn ERR_PTR(-EIO);\n\treturn ext4_iget(sb, ino);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-ESTALE"
          ],
          "line": 983
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "EXT4_SB(sb)->s_es->s_inodes_count"
          ],
          "line": 982
        },
        "resolved": true,
        "details": {
          "function_name": "sle32_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "53-56",
          "snippet": "static inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "EXT4_SB",
          "args": [
            "sb"
          ],
          "line": 982
        },
        "resolved": true,
        "details": {
          "function_name": "EXT4_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ext4.h",
          "lines": "1356-1359",
          "snippet": "static inline struct ext4_sb_info *EXT4_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include \"extents_status.h\"",
            "#include <linux/compat.h>",
            "#include <linux/falloc.h>",
            "#include <crypto/hash.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/wait.h>",
            "#include <linux/timer.h>",
            "#include <linux/mutex.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/quota.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extents_status.h\"\n#include <linux/compat.h>\n#include <linux/falloc.h>\n#include <crypto/hash.h>\n#include <linux/ratelimit.h>\n#include <linux/percpu_counter.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/wait.h>\n#include <linux/timer.h>\n#include <linux/mutex.h>\n#include <linux/seqlock.h>\n#include <linux/rbtree.h>\n#include <linux/rwsem.h>\n#include <linux/quota.h>\n#include <linux/jbd2.h>\n#include <linux/magic.h>\n#include <linux/blkdev.h>\n#include <linux/types.h>\n\nstatic inline struct ext4_sb_info *EXT4_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-ESTALE"
          ],
          "line": 981
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXT4_FIRST_INO",
          "args": [
            "sb"
          ],
          "line": 980
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"mballoc.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4_extents.h\"\t/* Needed for trace points definition */\n#include \"ext4.h\"\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <asm/uaccess.h>\n#include <linux/cleancache.h>\n#include <linux/crc16.h>\n#include <linux/log2.h>\n#include <linux/ctype.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/random.h>\n#include <linux/vfs.h>\n#include <linux/exportfs.h>\n#include <linux/buffer_head.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/jbd2.h>\n#include <linux/vmalloc.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n#include <linux/string.h>\n#include <linux/module.h>\n\nstatic int ext4_unfreeze(struct super_block *sb);\nstatic int ext4_freeze(struct super_block *sb);\nstatic inline int ext2_feature_set_ok(struct super_block *sb);\nstatic inline int ext3_feature_set_ok(struct super_block *sb);\nstatic void ext4_unregister_li_request(struct super_block *sb);\n\nstatic struct inode *ext4_nfs_get_inode(struct super_block *sb,\n\t\t\t\t\tu64 ino, u32 generation)\n{\n\tstruct inode *inode;\n\n\tif (ino < EXT4_FIRST_INO(sb) && ino != EXT4_ROOT_INO)\n\t\treturn ERR_PTR(-ESTALE);\n\tif (ino > le32_to_cpu(EXT4_SB(sb)->s_es->s_inodes_count))\n\t\treturn ERR_PTR(-ESTALE);\n\n\t/* iget isn't really right if the inode is currently unallocated!!\n\t *\n\t * ext4_read_inode will return a bad_inode if the inode had been\n\t * deleted, so we should be safe.\n\t *\n\t * Currently we don't know the generation for parent directory, so\n\t * a generation of 0 means \"accept any\"\n\t */\n\tinode = ext4_iget_normal(sb, ino);\n\tif (IS_ERR(inode))\n\t\treturn ERR_CAST(inode);\n\tif (generation && inode->i_generation != generation) {\n\t\tiput(inode);\n\t\treturn ERR_PTR(-ESTALE);\n\t}\n\n\treturn inode;\n}"
  },
  {
    "function_name": "ext4_clear_inode",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/super.c",
    "lines": "960-973",
    "snippet": "void ext4_clear_inode(struct inode *inode)\n{\n\tinvalidate_inode_buffers(inode);\n\tclear_inode(inode);\n\tdquot_drop(inode);\n\text4_discard_preallocations(inode);\n\text4_es_remove_extent(inode, 0, EXT_MAX_BLOCKS);\n\tif (EXT4_I(inode)->jinode) {\n\t\tjbd2_journal_release_jbd_inode(EXT4_JOURNAL(inode),\n\t\t\t\t\t       EXT4_I(inode)->jinode);\n\t\tjbd2_free_inode(EXT4_I(inode)->jinode);\n\t\tEXT4_I(inode)->jinode = NULL;\n\t}\n}",
    "includes": [
      "#include <trace/events/ext4.h>",
      "#include \"mballoc.h\"",
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"ext4_jbd2.h\"",
      "#include \"ext4_extents.h\"\t/* Needed for trace points definition */",
      "#include \"ext4.h\"",
      "#include <linux/freezer.h>",
      "#include <linux/kthread.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/cleancache.h>",
      "#include <linux/crc16.h>",
      "#include <linux/log2.h>",
      "#include <linux/ctype.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/namei.h>",
      "#include <linux/mount.h>",
      "#include <linux/random.h>",
      "#include <linux/vfs.h>",
      "#include <linux/exportfs.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/parser.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/init.h>",
      "#include <linux/slab.h>",
      "#include <linux/jbd2.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/time.h>",
      "#include <linux/fs.h>",
      "#include <linux/string.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "EXT4_I",
          "args": [
            "inode"
          ],
          "line": 971
        },
        "resolved": true,
        "details": {
          "function_name": "EXT4_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ext4.h",
          "lines": "1360-1363",
          "snippet": "static inline struct ext4_inode_info *EXT4_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ext4_inode_info, vfs_inode);\n}",
          "includes": [
            "#include \"extents_status.h\"",
            "#include <linux/compat.h>",
            "#include <linux/falloc.h>",
            "#include <crypto/hash.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/wait.h>",
            "#include <linux/timer.h>",
            "#include <linux/mutex.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/quota.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extents_status.h\"\n#include <linux/compat.h>\n#include <linux/falloc.h>\n#include <crypto/hash.h>\n#include <linux/ratelimit.h>\n#include <linux/percpu_counter.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/wait.h>\n#include <linux/timer.h>\n#include <linux/mutex.h>\n#include <linux/seqlock.h>\n#include <linux/rbtree.h>\n#include <linux/rwsem.h>\n#include <linux/quota.h>\n#include <linux/jbd2.h>\n#include <linux/magic.h>\n#include <linux/blkdev.h>\n#include <linux/types.h>\n\nstatic inline struct ext4_inode_info *EXT4_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ext4_inode_info, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "jbd2_free_inode",
          "args": [
            "EXT4_I(inode)->jinode"
          ],
          "line": 970
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "jbd2_journal_release_jbd_inode",
          "args": [
            "EXT4_JOURNAL(inode)",
            "EXT4_I(inode)->jinode"
          ],
          "line": 968
        },
        "resolved": true,
        "details": {
          "function_name": "jbd2_journal_release_jbd_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd2/journal.c",
          "lines": "2539-2563",
          "snippet": "void jbd2_journal_release_jbd_inode(journal_t *journal,\n\t\t\t\t    struct jbd2_inode *jinode)\n{\n\tif (!journal)\n\t\treturn;\nrestart:\n\tspin_lock(&journal->j_list_lock);\n\t/* Is commit writing out inode - we have to wait */\n\tif (test_bit(__JI_COMMIT_RUNNING, &jinode->i_flags)) {\n\t\twait_queue_head_t *wq;\n\t\tDEFINE_WAIT_BIT(wait, &jinode->i_flags, __JI_COMMIT_RUNNING);\n\t\twq = bit_waitqueue(&jinode->i_flags, __JI_COMMIT_RUNNING);\n\t\tprepare_to_wait(wq, &wait.wait, TASK_UNINTERRUPTIBLE);\n\t\tspin_unlock(&journal->j_list_lock);\n\t\tschedule();\n\t\tfinish_wait(wq, &wait.wait);\n\t\tgoto restart;\n\t}\n\n\tif (jinode->i_transaction) {\n\t\tlist_del(&jinode->i_list);\n\t\tjinode->i_transaction = NULL;\n\t}\n\tspin_unlock(&journal->j_list_lock);\n}",
          "includes": [
            "#include <asm/page.h>",
            "#include <asm/uaccess.h>",
            "#include <trace/events/jbd2.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/bitops.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/log2.h>",
            "#include <linux/hash.h>",
            "#include <linux/math64.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/poison.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <trace/events/jbd2.h>\n#include <linux/ratelimit.h>\n#include <linux/bitops.h>\n#include <linux/backing-dev.h>\n#include <linux/vmalloc.h>\n#include <linux/log2.h>\n#include <linux/hash.h>\n#include <linux/math64.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/poison.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/freezer.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd2.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/module.h>\n\nvoid jbd2_journal_release_jbd_inode(journal_t *journal,\n\t\t\t\t    struct jbd2_inode *jinode)\n{\n\tif (!journal)\n\t\treturn;\nrestart:\n\tspin_lock(&journal->j_list_lock);\n\t/* Is commit writing out inode - we have to wait */\n\tif (test_bit(__JI_COMMIT_RUNNING, &jinode->i_flags)) {\n\t\twait_queue_head_t *wq;\n\t\tDEFINE_WAIT_BIT(wait, &jinode->i_flags, __JI_COMMIT_RUNNING);\n\t\twq = bit_waitqueue(&jinode->i_flags, __JI_COMMIT_RUNNING);\n\t\tprepare_to_wait(wq, &wait.wait, TASK_UNINTERRUPTIBLE);\n\t\tspin_unlock(&journal->j_list_lock);\n\t\tschedule();\n\t\tfinish_wait(wq, &wait.wait);\n\t\tgoto restart;\n\t}\n\n\tif (jinode->i_transaction) {\n\t\tlist_del(&jinode->i_list);\n\t\tjinode->i_transaction = NULL;\n\t}\n\tspin_unlock(&journal->j_list_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "EXT4_JOURNAL",
          "args": [
            "inode"
          ],
          "line": 968
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_es_remove_extent",
          "args": [
            "inode",
            "0",
            "EXT_MAX_BLOCKS"
          ],
          "line": 966
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_es_remove_extent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/extents_status.c",
          "lines": "938-964",
          "snippet": "int ext4_es_remove_extent(struct inode *inode, ext4_lblk_t lblk,\n\t\t\t  ext4_lblk_t len)\n{\n\text4_lblk_t end;\n\tint err = 0;\n\n\ttrace_ext4_es_remove_extent(inode, lblk, len);\n\tes_debug(\"remove [%u/%u) from extent status tree of inode %lu\\n\",\n\t\t lblk, len, inode->i_ino);\n\n\tif (!len)\n\t\treturn err;\n\n\tend = lblk + len - 1;\n\tBUG_ON(end < lblk);\n\n\t/*\n\t * ext4_clear_inode() depends on us taking i_es_lock unconditionally\n\t * so that we are sure __es_shrink() is done with the inode before it\n\t * is reclaimed.\n\t */\n\twrite_lock(&EXT4_I(inode)->i_es_lock);\n\terr = __es_remove_extent(inode, lblk, end);\n\twrite_unlock(&EXT4_I(inode)->i_es_lock);\n\text4_es_print_tree(inode);\n\treturn err;\n}",
          "includes": [
            "#include \"ext4_extents.h\"\t/* Needed when ES_AGGRESSIVE_TEST is defined */",
            "#include <trace/events/ext4.h>",
            "#include \"extents_status.h\"",
            "#include \"ext4.h\"",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/list_sort.h>",
            "#include <linux/rbtree.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int __es_remove_extent(struct inode *inode, ext4_lblk_t lblk,\n\t\t\t      ext4_lblk_t end);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ext4_extents.h\"\t/* Needed when ES_AGGRESSIVE_TEST is defined */\n#include <trace/events/ext4.h>\n#include \"extents_status.h\"\n#include \"ext4.h\"\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/list_sort.h>\n#include <linux/rbtree.h>\n\nstatic int __es_remove_extent(struct inode *inode, ext4_lblk_t lblk,\n\t\t\t      ext4_lblk_t end);\n\nint ext4_es_remove_extent(struct inode *inode, ext4_lblk_t lblk,\n\t\t\t  ext4_lblk_t len)\n{\n\text4_lblk_t end;\n\tint err = 0;\n\n\ttrace_ext4_es_remove_extent(inode, lblk, len);\n\tes_debug(\"remove [%u/%u) from extent status tree of inode %lu\\n\",\n\t\t lblk, len, inode->i_ino);\n\n\tif (!len)\n\t\treturn err;\n\n\tend = lblk + len - 1;\n\tBUG_ON(end < lblk);\n\n\t/*\n\t * ext4_clear_inode() depends on us taking i_es_lock unconditionally\n\t * so that we are sure __es_shrink() is done with the inode before it\n\t * is reclaimed.\n\t */\n\twrite_lock(&EXT4_I(inode)->i_es_lock);\n\terr = __es_remove_extent(inode, lblk, end);\n\twrite_unlock(&EXT4_I(inode)->i_es_lock);\n\text4_es_print_tree(inode);\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_discard_preallocations",
          "args": [
            "inode"
          ],
          "line": 965
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_discard_preallocations",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/mballoc.c",
          "lines": "3920-4020",
          "snippet": "void ext4_discard_preallocations(struct inode *inode)\n{\n\tstruct ext4_inode_info *ei = EXT4_I(inode);\n\tstruct super_block *sb = inode->i_sb;\n\tstruct buffer_head *bitmap_bh = NULL;\n\tstruct ext4_prealloc_space *pa, *tmp;\n\text4_group_t group = 0;\n\tstruct list_head list;\n\tstruct ext4_buddy e4b;\n\tint err;\n\n\tif (!S_ISREG(inode->i_mode)) {\n\t\t/*BUG_ON(!list_empty(&ei->i_prealloc_list));*/\n\t\treturn;\n\t}\n\n\tmb_debug(1, \"discard preallocation for inode %lu\\n\", inode->i_ino);\n\ttrace_ext4_discard_preallocations(inode);\n\n\tINIT_LIST_HEAD(&list);\n\nrepeat:\n\t/* first, collect all pa's in the inode */\n\tspin_lock(&ei->i_prealloc_lock);\n\twhile (!list_empty(&ei->i_prealloc_list)) {\n\t\tpa = list_entry(ei->i_prealloc_list.next,\n\t\t\t\tstruct ext4_prealloc_space, pa_inode_list);\n\t\tBUG_ON(pa->pa_obj_lock != &ei->i_prealloc_lock);\n\t\tspin_lock(&pa->pa_lock);\n\t\tif (atomic_read(&pa->pa_count)) {\n\t\t\t/* this shouldn't happen often - nobody should\n\t\t\t * use preallocation while we're discarding it */\n\t\t\tspin_unlock(&pa->pa_lock);\n\t\t\tspin_unlock(&ei->i_prealloc_lock);\n\t\t\text4_msg(sb, KERN_ERR,\n\t\t\t\t \"uh-oh! used pa while discarding\");\n\t\t\tWARN_ON(1);\n\t\t\tschedule_timeout_uninterruptible(HZ);\n\t\t\tgoto repeat;\n\n\t\t}\n\t\tif (pa->pa_deleted == 0) {\n\t\t\tpa->pa_deleted = 1;\n\t\t\tspin_unlock(&pa->pa_lock);\n\t\t\tlist_del_rcu(&pa->pa_inode_list);\n\t\t\tlist_add(&pa->u.pa_tmp_list, &list);\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* someone is deleting pa right now */\n\t\tspin_unlock(&pa->pa_lock);\n\t\tspin_unlock(&ei->i_prealloc_lock);\n\n\t\t/* we have to wait here because pa_deleted\n\t\t * doesn't mean pa is already unlinked from\n\t\t * the list. as we might be called from\n\t\t * ->clear_inode() the inode will get freed\n\t\t * and concurrent thread which is unlinking\n\t\t * pa from inode's list may access already\n\t\t * freed memory, bad-bad-bad */\n\n\t\t/* XXX: if this happens too often, we can\n\t\t * add a flag to force wait only in case\n\t\t * of ->clear_inode(), but not in case of\n\t\t * regular truncate */\n\t\tschedule_timeout_uninterruptible(HZ);\n\t\tgoto repeat;\n\t}\n\tspin_unlock(&ei->i_prealloc_lock);\n\n\tlist_for_each_entry_safe(pa, tmp, &list, u.pa_tmp_list) {\n\t\tBUG_ON(pa->pa_type != MB_INODE_PA);\n\t\tgroup = ext4_get_group_number(sb, pa->pa_pstart);\n\n\t\terr = ext4_mb_load_buddy(sb, group, &e4b);\n\t\tif (err) {\n\t\t\text4_error(sb, \"Error loading buddy information for %u\",\n\t\t\t\t\tgroup);\n\t\t\tcontinue;\n\t\t}\n\n\t\tbitmap_bh = ext4_read_block_bitmap(sb, group);\n\t\tif (bitmap_bh == NULL) {\n\t\t\text4_error(sb, \"Error reading block bitmap for %u\",\n\t\t\t\t\tgroup);\n\t\t\text4_mb_unload_buddy(&e4b);\n\t\t\tcontinue;\n\t\t}\n\n\t\text4_lock_group(sb, group);\n\t\tlist_del(&pa->pa_group_list);\n\t\text4_mb_release_inode_pa(&e4b, bitmap_bh, pa);\n\t\text4_unlock_group(sb, group);\n\n\t\text4_mb_unload_buddy(&e4b);\n\t\tput_bh(bitmap_bh);\n\n\t\tlist_del(&pa->u.pa_tmp_list);\n\t\tcall_rcu(&(pa)->u.pa_rcu, ext4_mb_pa_callback);\n\t}\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/log2.h>",
            "#include \"mballoc.h\"",
            "#include \"ext4_jbd2.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void ext4_mb_generate_from_pa(struct super_block *sb, void *bitmap,\n\t\t\t\t\text4_group_t group);",
            "static void ext4_mb_generate_from_freelist(struct super_block *sb, void *bitmap,\n\t\t\t\t\t\text4_group_t group);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/log2.h>\n#include \"mballoc.h\"\n#include \"ext4_jbd2.h\"\n\nstatic void ext4_mb_generate_from_pa(struct super_block *sb, void *bitmap,\n\t\t\t\t\text4_group_t group);\nstatic void ext4_mb_generate_from_freelist(struct super_block *sb, void *bitmap,\n\t\t\t\t\t\text4_group_t group);\n\nvoid ext4_discard_preallocations(struct inode *inode)\n{\n\tstruct ext4_inode_info *ei = EXT4_I(inode);\n\tstruct super_block *sb = inode->i_sb;\n\tstruct buffer_head *bitmap_bh = NULL;\n\tstruct ext4_prealloc_space *pa, *tmp;\n\text4_group_t group = 0;\n\tstruct list_head list;\n\tstruct ext4_buddy e4b;\n\tint err;\n\n\tif (!S_ISREG(inode->i_mode)) {\n\t\t/*BUG_ON(!list_empty(&ei->i_prealloc_list));*/\n\t\treturn;\n\t}\n\n\tmb_debug(1, \"discard preallocation for inode %lu\\n\", inode->i_ino);\n\ttrace_ext4_discard_preallocations(inode);\n\n\tINIT_LIST_HEAD(&list);\n\nrepeat:\n\t/* first, collect all pa's in the inode */\n\tspin_lock(&ei->i_prealloc_lock);\n\twhile (!list_empty(&ei->i_prealloc_list)) {\n\t\tpa = list_entry(ei->i_prealloc_list.next,\n\t\t\t\tstruct ext4_prealloc_space, pa_inode_list);\n\t\tBUG_ON(pa->pa_obj_lock != &ei->i_prealloc_lock);\n\t\tspin_lock(&pa->pa_lock);\n\t\tif (atomic_read(&pa->pa_count)) {\n\t\t\t/* this shouldn't happen often - nobody should\n\t\t\t * use preallocation while we're discarding it */\n\t\t\tspin_unlock(&pa->pa_lock);\n\t\t\tspin_unlock(&ei->i_prealloc_lock);\n\t\t\text4_msg(sb, KERN_ERR,\n\t\t\t\t \"uh-oh! used pa while discarding\");\n\t\t\tWARN_ON(1);\n\t\t\tschedule_timeout_uninterruptible(HZ);\n\t\t\tgoto repeat;\n\n\t\t}\n\t\tif (pa->pa_deleted == 0) {\n\t\t\tpa->pa_deleted = 1;\n\t\t\tspin_unlock(&pa->pa_lock);\n\t\t\tlist_del_rcu(&pa->pa_inode_list);\n\t\t\tlist_add(&pa->u.pa_tmp_list, &list);\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* someone is deleting pa right now */\n\t\tspin_unlock(&pa->pa_lock);\n\t\tspin_unlock(&ei->i_prealloc_lock);\n\n\t\t/* we have to wait here because pa_deleted\n\t\t * doesn't mean pa is already unlinked from\n\t\t * the list. as we might be called from\n\t\t * ->clear_inode() the inode will get freed\n\t\t * and concurrent thread which is unlinking\n\t\t * pa from inode's list may access already\n\t\t * freed memory, bad-bad-bad */\n\n\t\t/* XXX: if this happens too often, we can\n\t\t * add a flag to force wait only in case\n\t\t * of ->clear_inode(), but not in case of\n\t\t * regular truncate */\n\t\tschedule_timeout_uninterruptible(HZ);\n\t\tgoto repeat;\n\t}\n\tspin_unlock(&ei->i_prealloc_lock);\n\n\tlist_for_each_entry_safe(pa, tmp, &list, u.pa_tmp_list) {\n\t\tBUG_ON(pa->pa_type != MB_INODE_PA);\n\t\tgroup = ext4_get_group_number(sb, pa->pa_pstart);\n\n\t\terr = ext4_mb_load_buddy(sb, group, &e4b);\n\t\tif (err) {\n\t\t\text4_error(sb, \"Error loading buddy information for %u\",\n\t\t\t\t\tgroup);\n\t\t\tcontinue;\n\t\t}\n\n\t\tbitmap_bh = ext4_read_block_bitmap(sb, group);\n\t\tif (bitmap_bh == NULL) {\n\t\t\text4_error(sb, \"Error reading block bitmap for %u\",\n\t\t\t\t\tgroup);\n\t\t\text4_mb_unload_buddy(&e4b);\n\t\t\tcontinue;\n\t\t}\n\n\t\text4_lock_group(sb, group);\n\t\tlist_del(&pa->pa_group_list);\n\t\text4_mb_release_inode_pa(&e4b, bitmap_bh, pa);\n\t\text4_unlock_group(sb, group);\n\n\t\text4_mb_unload_buddy(&e4b);\n\t\tput_bh(bitmap_bh);\n\n\t\tlist_del(&pa->u.pa_tmp_list);\n\t\tcall_rcu(&(pa)->u.pa_rcu, ext4_mb_pa_callback);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "dquot_drop",
          "args": [
            "inode"
          ],
          "line": 964
        },
        "resolved": true,
        "details": {
          "function_name": "dquot_drop",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/quota/dquot.c",
          "lines": "1487-1508",
          "snippet": "void dquot_drop(struct inode *inode)\n{\n\tint cnt;\n\n\tif (IS_NOQUOTA(inode))\n\t\treturn;\n\n\t/*\n\t * Test before calling to rule out calls from proc and such\n\t * where we are not allowed to block. Note that this is\n\t * actually reliable test even without the lock - the caller\n\t * must assure that nobody can come after the DQUOT_DROP and\n\t * add quota pointers back anyway.\n\t */\n\tfor (cnt = 0; cnt < MAXQUOTAS; cnt++) {\n\t\tif (i_dquot(inode)[cnt])\n\t\t\tbreak;\n\t}\n\n\tif (cnt < MAXQUOTAS)\n\t\t__dquot_drop(inode);\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include \"../internal.h\" /* ugh */",
            "#include <linux/quotaops.h>",
            "#include <linux/capability.h>",
            "#include <linux/namei.h>",
            "#include <linux/kmod.h>",
            "#include <linux/sched.h>",
            "#include <linux/security.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>",
            "#include <linux/tty.h>",
            "#include <linux/stat.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/time.h>",
            "#include <linux/mm.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static qsize_t inode_get_rsv_space(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include \"../internal.h\" /* ugh */\n#include <linux/quotaops.h>\n#include <linux/capability.h>\n#include <linux/namei.h>\n#include <linux/kmod.h>\n#include <linux/sched.h>\n#include <linux/security.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/sysctl.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/tty.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/time.h>\n#include <linux/mm.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/kernel.h>\n#include <linux/errno.h>\n\nstatic qsize_t inode_get_rsv_space(struct inode *inode);\n\nvoid dquot_drop(struct inode *inode)\n{\n\tint cnt;\n\n\tif (IS_NOQUOTA(inode))\n\t\treturn;\n\n\t/*\n\t * Test before calling to rule out calls from proc and such\n\t * where we are not allowed to block. Note that this is\n\t * actually reliable test even without the lock - the caller\n\t * must assure that nobody can come after the DQUOT_DROP and\n\t * add quota pointers back anyway.\n\t */\n\tfor (cnt = 0; cnt < MAXQUOTAS; cnt++) {\n\t\tif (i_dquot(inode)[cnt])\n\t\t\tbreak;\n\t}\n\n\tif (cnt < MAXQUOTAS)\n\t\t__dquot_drop(inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "clear_inode",
          "args": [
            "inode"
          ],
          "line": 963
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_clear_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/super.c",
          "lines": "960-973",
          "snippet": "void ext4_clear_inode(struct inode *inode)\n{\n\tinvalidate_inode_buffers(inode);\n\tclear_inode(inode);\n\tdquot_drop(inode);\n\text4_discard_preallocations(inode);\n\text4_es_remove_extent(inode, 0, EXT_MAX_BLOCKS);\n\tif (EXT4_I(inode)->jinode) {\n\t\tjbd2_journal_release_jbd_inode(EXT4_JOURNAL(inode),\n\t\t\t\t\t       EXT4_I(inode)->jinode);\n\t\tjbd2_free_inode(EXT4_I(inode)->jinode);\n\t\tEXT4_I(inode)->jinode = NULL;\n\t}\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "invalidate_inode_buffers",
          "args": [
            "inode"
          ],
          "line": 962
        },
        "resolved": true,
        "details": {
          "function_name": "invalidate_inode_buffers",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "802-814",
          "snippet": "void invalidate_inode_buffers(struct inode *inode)\n{\n\tif (inode_has_buffers(inode)) {\n\t\tstruct address_space *mapping = &inode->i_data;\n\t\tstruct list_head *list = &mapping->private_list;\n\t\tstruct address_space *buffer_mapping = mapping->private_data;\n\n\t\tspin_lock(&buffer_mapping->private_lock);\n\t\twhile (!list_empty(list))\n\t\t\t__remove_assoc_queue(BH_ENTRY(list->next));\n\t\tspin_unlock(&buffer_mapping->private_lock);\n\t}\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int fsync_buffers_list(spinlock_t *lock, struct list_head *list);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nstatic int fsync_buffers_list(spinlock_t *lock, struct list_head *list);\n\nvoid invalidate_inode_buffers(struct inode *inode)\n{\n\tif (inode_has_buffers(inode)) {\n\t\tstruct address_space *mapping = &inode->i_data;\n\t\tstruct list_head *list = &mapping->private_list;\n\t\tstruct address_space *buffer_mapping = mapping->private_data;\n\n\t\tspin_lock(&buffer_mapping->private_lock);\n\t\twhile (!list_empty(list))\n\t\t\t__remove_assoc_queue(BH_ENTRY(list->next));\n\t\tspin_unlock(&buffer_mapping->private_lock);\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"mballoc.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4_extents.h\"\t/* Needed for trace points definition */\n#include \"ext4.h\"\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <asm/uaccess.h>\n#include <linux/cleancache.h>\n#include <linux/crc16.h>\n#include <linux/log2.h>\n#include <linux/ctype.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/random.h>\n#include <linux/vfs.h>\n#include <linux/exportfs.h>\n#include <linux/buffer_head.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/jbd2.h>\n#include <linux/vmalloc.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n#include <linux/string.h>\n#include <linux/module.h>\n\nvoid ext4_clear_inode(struct inode *inode)\n{\n\tinvalidate_inode_buffers(inode);\n\tclear_inode(inode);\n\tdquot_drop(inode);\n\text4_discard_preallocations(inode);\n\text4_es_remove_extent(inode, 0, EXT_MAX_BLOCKS);\n\tif (EXT4_I(inode)->jinode) {\n\t\tjbd2_journal_release_jbd_inode(EXT4_JOURNAL(inode),\n\t\t\t\t\t       EXT4_I(inode)->jinode);\n\t\tjbd2_free_inode(EXT4_I(inode)->jinode);\n\t\tEXT4_I(inode)->jinode = NULL;\n\t}\n}"
  },
  {
    "function_name": "destroy_inodecache",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/super.c",
    "lines": "950-958",
    "snippet": "static void destroy_inodecache(void)\n{\n\t/*\n\t * Make sure all delayed rcu free inodes are flushed before we\n\t * destroy cache.\n\t */\n\trcu_barrier();\n\tkmem_cache_destroy(ext4_inode_cachep);\n}",
    "includes": [
      "#include <trace/events/ext4.h>",
      "#include \"mballoc.h\"",
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"ext4_jbd2.h\"",
      "#include \"ext4_extents.h\"\t/* Needed for trace points definition */",
      "#include \"ext4.h\"",
      "#include <linux/freezer.h>",
      "#include <linux/kthread.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/cleancache.h>",
      "#include <linux/crc16.h>",
      "#include <linux/log2.h>",
      "#include <linux/ctype.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/namei.h>",
      "#include <linux/mount.h>",
      "#include <linux/random.h>",
      "#include <linux/vfs.h>",
      "#include <linux/exportfs.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/parser.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/init.h>",
      "#include <linux/slab.h>",
      "#include <linux/jbd2.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/time.h>",
      "#include <linux/fs.h>",
      "#include <linux/string.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct kmem_cache *ext4_inode_cachep;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kmem_cache_destroy",
          "args": [
            "ext4_inode_cachep"
          ],
          "line": 957
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_barrier",
          "args": [],
          "line": 956
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"mballoc.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4_extents.h\"\t/* Needed for trace points definition */\n#include \"ext4.h\"\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <asm/uaccess.h>\n#include <linux/cleancache.h>\n#include <linux/crc16.h>\n#include <linux/log2.h>\n#include <linux/ctype.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/random.h>\n#include <linux/vfs.h>\n#include <linux/exportfs.h>\n#include <linux/buffer_head.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/jbd2.h>\n#include <linux/vmalloc.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n#include <linux/string.h>\n#include <linux/module.h>\n\nstatic struct kmem_cache *ext4_inode_cachep;\n\nstatic void destroy_inodecache(void)\n{\n\t/*\n\t * Make sure all delayed rcu free inodes are flushed before we\n\t * destroy cache.\n\t */\n\trcu_barrier();\n\tkmem_cache_destroy(ext4_inode_cachep);\n}"
  },
  {
    "function_name": "init_inodecache",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/super.c",
    "lines": "938-948",
    "snippet": "static int __init init_inodecache(void)\n{\n\text4_inode_cachep = kmem_cache_create(\"ext4_inode_cache\",\n\t\t\t\t\t     sizeof(struct ext4_inode_info),\n\t\t\t\t\t     0, (SLAB_RECLAIM_ACCOUNT|\n\t\t\t\t\t\tSLAB_MEM_SPREAD),\n\t\t\t\t\t     init_once);\n\tif (ext4_inode_cachep == NULL)\n\t\treturn -ENOMEM;\n\treturn 0;\n}",
    "includes": [
      "#include <trace/events/ext4.h>",
      "#include \"mballoc.h\"",
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"ext4_jbd2.h\"",
      "#include \"ext4_extents.h\"\t/* Needed for trace points definition */",
      "#include \"ext4.h\"",
      "#include <linux/freezer.h>",
      "#include <linux/kthread.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/cleancache.h>",
      "#include <linux/crc16.h>",
      "#include <linux/log2.h>",
      "#include <linux/ctype.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/namei.h>",
      "#include <linux/mount.h>",
      "#include <linux/random.h>",
      "#include <linux/vfs.h>",
      "#include <linux/exportfs.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/parser.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/init.h>",
      "#include <linux/slab.h>",
      "#include <linux/jbd2.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/time.h>",
      "#include <linux/fs.h>",
      "#include <linux/string.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct kmem_cache *ext4_inode_cachep;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kmem_cache_create",
          "args": [
            "\"ext4_inode_cache\"",
            "sizeof(struct ext4_inode_info)",
            "0",
            "(SLAB_RECLAIM_ACCOUNT|\n\t\t\t\t\t\tSLAB_MEM_SPREAD)",
            "init_once"
          ],
          "line": 940
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"mballoc.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4_extents.h\"\t/* Needed for trace points definition */\n#include \"ext4.h\"\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <asm/uaccess.h>\n#include <linux/cleancache.h>\n#include <linux/crc16.h>\n#include <linux/log2.h>\n#include <linux/ctype.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/random.h>\n#include <linux/vfs.h>\n#include <linux/exportfs.h>\n#include <linux/buffer_head.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/jbd2.h>\n#include <linux/vmalloc.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n#include <linux/string.h>\n#include <linux/module.h>\n\nstatic struct kmem_cache *ext4_inode_cachep;\n\nstatic int __init init_inodecache(void)\n{\n\text4_inode_cachep = kmem_cache_create(\"ext4_inode_cache\",\n\t\t\t\t\t     sizeof(struct ext4_inode_info),\n\t\t\t\t\t     0, (SLAB_RECLAIM_ACCOUNT|\n\t\t\t\t\t\tSLAB_MEM_SPREAD),\n\t\t\t\t\t     init_once);\n\tif (ext4_inode_cachep == NULL)\n\t\treturn -ENOMEM;\n\treturn 0;\n}"
  },
  {
    "function_name": "init_once",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/super.c",
    "lines": "928-936",
    "snippet": "static void init_once(void *foo)\n{\n\tstruct ext4_inode_info *ei = (struct ext4_inode_info *) foo;\n\n\tINIT_LIST_HEAD(&ei->i_orphan);\n\tinit_rwsem(&ei->xattr_sem);\n\tinit_rwsem(&ei->i_data_sem);\n\tinode_init_once(&ei->vfs_inode);\n}",
    "includes": [
      "#include <trace/events/ext4.h>",
      "#include \"mballoc.h\"",
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"ext4_jbd2.h\"",
      "#include \"ext4_extents.h\"\t/* Needed for trace points definition */",
      "#include \"ext4.h\"",
      "#include <linux/freezer.h>",
      "#include <linux/kthread.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/cleancache.h>",
      "#include <linux/crc16.h>",
      "#include <linux/log2.h>",
      "#include <linux/ctype.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/namei.h>",
      "#include <linux/mount.h>",
      "#include <linux/random.h>",
      "#include <linux/vfs.h>",
      "#include <linux/exportfs.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/parser.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/init.h>",
      "#include <linux/slab.h>",
      "#include <linux/jbd2.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/time.h>",
      "#include <linux/fs.h>",
      "#include <linux/string.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "inode_init_once",
          "args": [
            "&ei->vfs_inode"
          ],
          "line": 935
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_inode_init_once",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/super.c",
          "lines": "1725-1755",
          "snippet": "static void ocfs2_inode_init_once(void *data)\n{\n\tstruct ocfs2_inode_info *oi = data;\n\n\toi->ip_flags = 0;\n\toi->ip_open_count = 0;\n\tspin_lock_init(&oi->ip_lock);\n\tocfs2_extent_map_init(&oi->vfs_inode);\n\tINIT_LIST_HEAD(&oi->ip_io_markers);\n\toi->ip_dir_start_lookup = 0;\n\tmutex_init(&oi->ip_unaligned_aio);\n\tinit_rwsem(&oi->ip_alloc_sem);\n\tinit_rwsem(&oi->ip_xattr_sem);\n\tmutex_init(&oi->ip_io_mutex);\n\n\toi->ip_blkno = 0ULL;\n\toi->ip_clusters = 0;\n\n\tocfs2_resv_init_once(&oi->ip_la_data_resv);\n\n\tocfs2_lock_res_init_once(&oi->ip_rw_lockres);\n\tocfs2_lock_res_init_once(&oi->ip_inode_lockres);\n\tocfs2_lock_res_init_once(&oi->ip_open_lockres);\n\n\tinit_waitqueue_head(&oi->append_dio_wq);\n\n\tocfs2_metadata_cache_init(INODE_CACHE(&oi->vfs_inode),\n\t\t\t\t  &ocfs2_inode_caching_ops);\n\n\tinode_init_once(&oi->vfs_inode);\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"suballoc.h\"",
            "#include \"refcounttree.h\"",
            "#include \"quota.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"namei.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"extent_map.h\"",
            "#include \"export.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs1_fs_compat.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include \"ocfs2_trace.h\"",
            "#include <linux/cleancache.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mount.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/crc32.h>",
            "#include <linux/parser.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/statfs.h>",
            "#include <linux/random.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ocfs2_remount(struct super_block *sb, int *flags, char *data);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"suballoc.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"namei.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"export.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs1_fs_compat.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include \"ocfs2_trace.h\"\n#include <linux/cleancache.h>\n#include <linux/quotaops.h>\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n#include <linux/debugfs.h>\n#include <linux/crc32.h>\n#include <linux/parser.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/moduleparam.h>\n#include <linux/statfs.h>\n#include <linux/random.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic int ocfs2_remount(struct super_block *sb, int *flags, char *data);\n\nstatic void ocfs2_inode_init_once(void *data)\n{\n\tstruct ocfs2_inode_info *oi = data;\n\n\toi->ip_flags = 0;\n\toi->ip_open_count = 0;\n\tspin_lock_init(&oi->ip_lock);\n\tocfs2_extent_map_init(&oi->vfs_inode);\n\tINIT_LIST_HEAD(&oi->ip_io_markers);\n\toi->ip_dir_start_lookup = 0;\n\tmutex_init(&oi->ip_unaligned_aio);\n\tinit_rwsem(&oi->ip_alloc_sem);\n\tinit_rwsem(&oi->ip_xattr_sem);\n\tmutex_init(&oi->ip_io_mutex);\n\n\toi->ip_blkno = 0ULL;\n\toi->ip_clusters = 0;\n\n\tocfs2_resv_init_once(&oi->ip_la_data_resv);\n\n\tocfs2_lock_res_init_once(&oi->ip_rw_lockres);\n\tocfs2_lock_res_init_once(&oi->ip_inode_lockres);\n\tocfs2_lock_res_init_once(&oi->ip_open_lockres);\n\n\tinit_waitqueue_head(&oi->append_dio_wq);\n\n\tocfs2_metadata_cache_init(INODE_CACHE(&oi->vfs_inode),\n\t\t\t\t  &ocfs2_inode_caching_ops);\n\n\tinode_init_once(&oi->vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "init_rwsem",
          "args": [
            "&ei->i_data_sem"
          ],
          "line": 934
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "init_rwsem",
          "args": [
            "&ei->xattr_sem"
          ],
          "line": 933
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&ei->i_orphan"
          ],
          "line": 932
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"mballoc.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4_extents.h\"\t/* Needed for trace points definition */\n#include \"ext4.h\"\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <asm/uaccess.h>\n#include <linux/cleancache.h>\n#include <linux/crc16.h>\n#include <linux/log2.h>\n#include <linux/ctype.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/random.h>\n#include <linux/vfs.h>\n#include <linux/exportfs.h>\n#include <linux/buffer_head.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/jbd2.h>\n#include <linux/vmalloc.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n#include <linux/string.h>\n#include <linux/module.h>\n\nstatic void init_once(void *foo)\n{\n\tstruct ext4_inode_info *ei = (struct ext4_inode_info *) foo;\n\n\tINIT_LIST_HEAD(&ei->i_orphan);\n\tinit_rwsem(&ei->xattr_sem);\n\tinit_rwsem(&ei->i_data_sem);\n\tinode_init_once(&ei->vfs_inode);\n}"
  },
  {
    "function_name": "ext4_destroy_inode",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/super.c",
    "lines": "914-926",
    "snippet": "static void ext4_destroy_inode(struct inode *inode)\n{\n\tif (!list_empty(&(EXT4_I(inode)->i_orphan))) {\n\t\text4_msg(inode->i_sb, KERN_ERR,\n\t\t\t \"Inode %lu (%p): orphan list check failed!\",\n\t\t\t inode->i_ino, EXT4_I(inode));\n\t\tprint_hex_dump(KERN_INFO, \"\", DUMP_PREFIX_ADDRESS, 16, 4,\n\t\t\t\tEXT4_I(inode), sizeof(struct ext4_inode_info),\n\t\t\t\ttrue);\n\t\tdump_stack();\n\t}\n\tcall_rcu(&inode->i_rcu, ext4_i_callback);\n}",
    "includes": [
      "#include <trace/events/ext4.h>",
      "#include \"mballoc.h\"",
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"ext4_jbd2.h\"",
      "#include \"ext4_extents.h\"\t/* Needed for trace points definition */",
      "#include \"ext4.h\"",
      "#include <linux/freezer.h>",
      "#include <linux/kthread.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/cleancache.h>",
      "#include <linux/crc16.h>",
      "#include <linux/log2.h>",
      "#include <linux/ctype.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/namei.h>",
      "#include <linux/mount.h>",
      "#include <linux/random.h>",
      "#include <linux/vfs.h>",
      "#include <linux/exportfs.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/parser.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/init.h>",
      "#include <linux/slab.h>",
      "#include <linux/jbd2.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/time.h>",
      "#include <linux/fs.h>",
      "#include <linux/string.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "call_rcu",
          "args": [
            "&inode->i_rcu",
            "ext4_i_callback"
          ],
          "line": 925
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dump_stack",
          "args": [],
          "line": 923
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "print_hex_dump",
          "args": [
            "KERN_INFO",
            "\"\"",
            "DUMP_PREFIX_ADDRESS",
            "16",
            "4",
            "EXT4_I(inode)",
            "sizeof(struct ext4_inode_info)",
            "true"
          ],
          "line": 920
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXT4_I",
          "args": [
            "inode"
          ],
          "line": 921
        },
        "resolved": true,
        "details": {
          "function_name": "EXT4_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ext4.h",
          "lines": "1360-1363",
          "snippet": "static inline struct ext4_inode_info *EXT4_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ext4_inode_info, vfs_inode);\n}",
          "includes": [
            "#include \"extents_status.h\"",
            "#include <linux/compat.h>",
            "#include <linux/falloc.h>",
            "#include <crypto/hash.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/wait.h>",
            "#include <linux/timer.h>",
            "#include <linux/mutex.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/quota.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extents_status.h\"\n#include <linux/compat.h>\n#include <linux/falloc.h>\n#include <crypto/hash.h>\n#include <linux/ratelimit.h>\n#include <linux/percpu_counter.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/wait.h>\n#include <linux/timer.h>\n#include <linux/mutex.h>\n#include <linux/seqlock.h>\n#include <linux/rbtree.h>\n#include <linux/rwsem.h>\n#include <linux/quota.h>\n#include <linux/jbd2.h>\n#include <linux/magic.h>\n#include <linux/blkdev.h>\n#include <linux/types.h>\n\nstatic inline struct ext4_inode_info *EXT4_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ext4_inode_info, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_msg",
          "args": [
            "inode->i_sb",
            "KERN_ERR",
            "\"Inode %lu (%p): orphan list check failed!\"",
            "inode->i_ino",
            "EXT4_I(inode)"
          ],
          "line": 917
        },
        "resolved": true,
        "details": {
          "function_name": "__ext4_msg",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/super.c",
          "lines": "593-607",
          "snippet": "void __ext4_msg(struct super_block *sb,\n\t\tconst char *prefix, const char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tif (!___ratelimit(&(EXT4_SB(sb)->s_msg_ratelimit_state), \"EXT4-fs\"))\n\t\treturn;\n\n\tva_start(args, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\tprintk(\"%sEXT4-fs (%s): %pV\\n\", prefix, sb->s_id, &vaf);\n\tva_end(args);\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"mballoc.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include \"ext4_extents.h\"\t/* Needed for trace points definition */",
            "#include \"ext4.h\"",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/crc16.h>",
            "#include <linux/log2.h>",
            "#include <linux/ctype.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/random.h>",
            "#include <linux/vfs.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/parser.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/time.h>",
            "#include <linux/fs.h>",
            "#include <linux/string.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ext4_unfreeze(struct super_block *sb);",
            "static int ext4_freeze(struct super_block *sb);",
            "static inline int ext2_feature_set_ok(struct super_block *sb);",
            "static inline int ext3_feature_set_ok(struct super_block *sb);",
            "static void ext4_unregister_li_request(struct super_block *sb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"mballoc.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4_extents.h\"\t/* Needed for trace points definition */\n#include \"ext4.h\"\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <asm/uaccess.h>\n#include <linux/cleancache.h>\n#include <linux/crc16.h>\n#include <linux/log2.h>\n#include <linux/ctype.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/random.h>\n#include <linux/vfs.h>\n#include <linux/exportfs.h>\n#include <linux/buffer_head.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/jbd2.h>\n#include <linux/vmalloc.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n#include <linux/string.h>\n#include <linux/module.h>\n\nstatic int ext4_unfreeze(struct super_block *sb);\nstatic int ext4_freeze(struct super_block *sb);\nstatic inline int ext2_feature_set_ok(struct super_block *sb);\nstatic inline int ext3_feature_set_ok(struct super_block *sb);\nstatic void ext4_unregister_li_request(struct super_block *sb);\n\nvoid __ext4_msg(struct super_block *sb,\n\t\tconst char *prefix, const char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tif (!___ratelimit(&(EXT4_SB(sb)->s_msg_ratelimit_state), \"EXT4-fs\"))\n\t\treturn;\n\n\tva_start(args, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\tprintk(\"%sEXT4-fs (%s): %pV\\n\", prefix, sb->s_id, &vaf);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&(EXT4_I(inode)->i_orphan)"
          ],
          "line": 916
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_dirty_list_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmthread.c",
          "lines": "505-514",
          "snippet": "static int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/timer.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_flush_asts(struct dlm_ctxt *dlm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/timer.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_flush_asts(struct dlm_ctxt *dlm);\n\nstatic int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"mballoc.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4_extents.h\"\t/* Needed for trace points definition */\n#include \"ext4.h\"\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <asm/uaccess.h>\n#include <linux/cleancache.h>\n#include <linux/crc16.h>\n#include <linux/log2.h>\n#include <linux/ctype.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/random.h>\n#include <linux/vfs.h>\n#include <linux/exportfs.h>\n#include <linux/buffer_head.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/jbd2.h>\n#include <linux/vmalloc.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n#include <linux/string.h>\n#include <linux/module.h>\n\nstatic void ext4_destroy_inode(struct inode *inode)\n{\n\tif (!list_empty(&(EXT4_I(inode)->i_orphan))) {\n\t\text4_msg(inode->i_sb, KERN_ERR,\n\t\t\t \"Inode %lu (%p): orphan list check failed!\",\n\t\t\t inode->i_ino, EXT4_I(inode));\n\t\tprint_hex_dump(KERN_INFO, \"\", DUMP_PREFIX_ADDRESS, 16, 4,\n\t\t\t\tEXT4_I(inode), sizeof(struct ext4_inode_info),\n\t\t\t\ttrue);\n\t\tdump_stack();\n\t}\n\tcall_rcu(&inode->i_rcu, ext4_i_callback);\n}"
  },
  {
    "function_name": "ext4_i_callback",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/super.c",
    "lines": "908-912",
    "snippet": "static void ext4_i_callback(struct rcu_head *head)\n{\n\tstruct inode *inode = container_of(head, struct inode, i_rcu);\n\tkmem_cache_free(ext4_inode_cachep, EXT4_I(inode));\n}",
    "includes": [
      "#include <trace/events/ext4.h>",
      "#include \"mballoc.h\"",
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"ext4_jbd2.h\"",
      "#include \"ext4_extents.h\"\t/* Needed for trace points definition */",
      "#include \"ext4.h\"",
      "#include <linux/freezer.h>",
      "#include <linux/kthread.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/cleancache.h>",
      "#include <linux/crc16.h>",
      "#include <linux/log2.h>",
      "#include <linux/ctype.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/namei.h>",
      "#include <linux/mount.h>",
      "#include <linux/random.h>",
      "#include <linux/vfs.h>",
      "#include <linux/exportfs.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/parser.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/init.h>",
      "#include <linux/slab.h>",
      "#include <linux/jbd2.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/time.h>",
      "#include <linux/fs.h>",
      "#include <linux/string.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct kmem_cache *ext4_inode_cachep;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kmem_cache_free",
          "args": [
            "ext4_inode_cachep",
            "EXT4_I(inode)"
          ],
          "line": 911
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXT4_I",
          "args": [
            "inode"
          ],
          "line": 911
        },
        "resolved": true,
        "details": {
          "function_name": "EXT4_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ext4.h",
          "lines": "1360-1363",
          "snippet": "static inline struct ext4_inode_info *EXT4_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ext4_inode_info, vfs_inode);\n}",
          "includes": [
            "#include \"extents_status.h\"",
            "#include <linux/compat.h>",
            "#include <linux/falloc.h>",
            "#include <crypto/hash.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/wait.h>",
            "#include <linux/timer.h>",
            "#include <linux/mutex.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/quota.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extents_status.h\"\n#include <linux/compat.h>\n#include <linux/falloc.h>\n#include <crypto/hash.h>\n#include <linux/ratelimit.h>\n#include <linux/percpu_counter.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/wait.h>\n#include <linux/timer.h>\n#include <linux/mutex.h>\n#include <linux/seqlock.h>\n#include <linux/rbtree.h>\n#include <linux/rwsem.h>\n#include <linux/quota.h>\n#include <linux/jbd2.h>\n#include <linux/magic.h>\n#include <linux/blkdev.h>\n#include <linux/types.h>\n\nstatic inline struct ext4_inode_info *EXT4_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ext4_inode_info, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "head",
            "structinode",
            "i_rcu"
          ],
          "line": 910
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"mballoc.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4_extents.h\"\t/* Needed for trace points definition */\n#include \"ext4.h\"\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <asm/uaccess.h>\n#include <linux/cleancache.h>\n#include <linux/crc16.h>\n#include <linux/log2.h>\n#include <linux/ctype.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/random.h>\n#include <linux/vfs.h>\n#include <linux/exportfs.h>\n#include <linux/buffer_head.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/jbd2.h>\n#include <linux/vmalloc.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n#include <linux/string.h>\n#include <linux/module.h>\n\nstatic struct kmem_cache *ext4_inode_cachep;\n\nstatic void ext4_i_callback(struct rcu_head *head)\n{\n\tstruct inode *inode = container_of(head, struct inode, i_rcu);\n\tkmem_cache_free(ext4_inode_cachep, EXT4_I(inode));\n}"
  },
  {
    "function_name": "ext4_drop_inode",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/super.c",
    "lines": "900-906",
    "snippet": "static int ext4_drop_inode(struct inode *inode)\n{\n\tint drop = generic_drop_inode(inode);\n\n\ttrace_ext4_drop_inode(inode, drop);\n\treturn drop;\n}",
    "includes": [
      "#include <trace/events/ext4.h>",
      "#include \"mballoc.h\"",
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"ext4_jbd2.h\"",
      "#include \"ext4_extents.h\"\t/* Needed for trace points definition */",
      "#include \"ext4.h\"",
      "#include <linux/freezer.h>",
      "#include <linux/kthread.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/cleancache.h>",
      "#include <linux/crc16.h>",
      "#include <linux/log2.h>",
      "#include <linux/ctype.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/namei.h>",
      "#include <linux/mount.h>",
      "#include <linux/random.h>",
      "#include <linux/vfs.h>",
      "#include <linux/exportfs.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/parser.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/init.h>",
      "#include <linux/slab.h>",
      "#include <linux/jbd2.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/time.h>",
      "#include <linux/fs.h>",
      "#include <linux/string.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "trace_ext4_drop_inode",
          "args": [
            "inode",
            "drop"
          ],
          "line": 904
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "generic_drop_inode",
          "args": [
            "inode"
          ],
          "line": 902
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"mballoc.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4_extents.h\"\t/* Needed for trace points definition */\n#include \"ext4.h\"\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <asm/uaccess.h>\n#include <linux/cleancache.h>\n#include <linux/crc16.h>\n#include <linux/log2.h>\n#include <linux/ctype.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/random.h>\n#include <linux/vfs.h>\n#include <linux/exportfs.h>\n#include <linux/buffer_head.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/jbd2.h>\n#include <linux/vmalloc.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n#include <linux/string.h>\n#include <linux/module.h>\n\nstatic int ext4_drop_inode(struct inode *inode)\n{\n\tint drop = generic_drop_inode(inode);\n\n\ttrace_ext4_drop_inode(inode, drop);\n\treturn drop;\n}"
  },
  {
    "function_name": "ext4_alloc_inode",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/super.c",
    "lines": "860-898",
    "snippet": "static struct inode *ext4_alloc_inode(struct super_block *sb)\n{\n\tstruct ext4_inode_info *ei;\n\n\tei = kmem_cache_alloc(ext4_inode_cachep, GFP_NOFS);\n\tif (!ei)\n\t\treturn NULL;\n\n\tei->vfs_inode.i_version = 1;\n\tspin_lock_init(&ei->i_raw_lock);\n\tINIT_LIST_HEAD(&ei->i_prealloc_list);\n\tspin_lock_init(&ei->i_prealloc_lock);\n\text4_es_init_tree(&ei->i_es_tree);\n\trwlock_init(&ei->i_es_lock);\n\tINIT_LIST_HEAD(&ei->i_es_list);\n\tei->i_es_all_nr = 0;\n\tei->i_es_shk_nr = 0;\n\tei->i_es_shrink_lblk = 0;\n\tei->i_reserved_data_blocks = 0;\n\tei->i_reserved_meta_blocks = 0;\n\tei->i_allocated_meta_blocks = 0;\n\tei->i_da_metadata_calc_len = 0;\n\tei->i_da_metadata_calc_last_lblock = 0;\n\tspin_lock_init(&(ei->i_block_reservation_lock));\n#ifdef CONFIG_QUOTA\n\tei->i_reserved_quota = 0;\n\tmemset(&ei->i_dquot, 0, sizeof(ei->i_dquot));\n#endif\n\tei->jinode = NULL;\n\tINIT_LIST_HEAD(&ei->i_rsv_conversion_list);\n\tspin_lock_init(&ei->i_completed_io_lock);\n\tei->i_sync_tid = 0;\n\tei->i_datasync_tid = 0;\n\tatomic_set(&ei->i_ioend_count, 0);\n\tatomic_set(&ei->i_unwritten, 0);\n\tINIT_WORK(&ei->i_rsv_conversion_work, ext4_end_io_rsv_work);\n\n\treturn &ei->vfs_inode;\n}",
    "includes": [
      "#include <trace/events/ext4.h>",
      "#include \"mballoc.h\"",
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"ext4_jbd2.h\"",
      "#include \"ext4_extents.h\"\t/* Needed for trace points definition */",
      "#include \"ext4.h\"",
      "#include <linux/freezer.h>",
      "#include <linux/kthread.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/cleancache.h>",
      "#include <linux/crc16.h>",
      "#include <linux/log2.h>",
      "#include <linux/ctype.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/namei.h>",
      "#include <linux/mount.h>",
      "#include <linux/random.h>",
      "#include <linux/vfs.h>",
      "#include <linux/exportfs.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/parser.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/init.h>",
      "#include <linux/slab.h>",
      "#include <linux/jbd2.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/time.h>",
      "#include <linux/fs.h>",
      "#include <linux/string.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ext4_unfreeze(struct super_block *sb);",
      "static int ext4_freeze(struct super_block *sb);",
      "static inline int ext2_feature_set_ok(struct super_block *sb);",
      "static inline int ext3_feature_set_ok(struct super_block *sb);",
      "static void ext4_unregister_li_request(struct super_block *sb);",
      "static struct kmem_cache *ext4_inode_cachep;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "INIT_WORK",
          "args": [
            "&ei->i_rsv_conversion_work",
            "ext4_end_io_rsv_work"
          ],
          "line": 895
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_set",
          "args": [
            "&ei->i_unwritten",
            "0"
          ],
          "line": 894
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_set",
          "args": [
            "&ei->i_ioend_count",
            "0"
          ],
          "line": 893
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock_init",
          "args": [
            "&ei->i_completed_io_lock"
          ],
          "line": 890
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&ei->i_rsv_conversion_list"
          ],
          "line": 889
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&ei->i_dquot",
            "0",
            "sizeof(ei->i_dquot)"
          ],
          "line": 886
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock_init",
          "args": [
            "&(ei->i_block_reservation_lock)"
          ],
          "line": 883
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&ei->i_es_list"
          ],
          "line": 874
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rwlock_init",
          "args": [
            "&ei->i_es_lock"
          ],
          "line": 873
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_es_init_tree",
          "args": [
            "&ei->i_es_tree"
          ],
          "line": 872
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_es_init_tree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/extents_status.c",
          "lines": "170-174",
          "snippet": "void ext4_es_init_tree(struct ext4_es_tree *tree)\n{\n\ttree->root = RB_ROOT;\n\ttree->cache_es = NULL;\n}",
          "includes": [
            "#include \"ext4_extents.h\"\t/* Needed when ES_AGGRESSIVE_TEST is defined */",
            "#include <trace/events/ext4.h>",
            "#include \"extents_status.h\"",
            "#include \"ext4.h\"",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/list_sort.h>",
            "#include <linux/rbtree.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ext4_extents.h\"\t/* Needed when ES_AGGRESSIVE_TEST is defined */\n#include <trace/events/ext4.h>\n#include \"extents_status.h\"\n#include \"ext4.h\"\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/list_sort.h>\n#include <linux/rbtree.h>\n\nvoid ext4_es_init_tree(struct ext4_es_tree *tree)\n{\n\ttree->root = RB_ROOT;\n\ttree->cache_es = NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock_init",
          "args": [
            "&ei->i_prealloc_lock"
          ],
          "line": 871
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&ei->i_prealloc_list"
          ],
          "line": 870
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock_init",
          "args": [
            "&ei->i_raw_lock"
          ],
          "line": 869
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmem_cache_alloc",
          "args": [
            "ext4_inode_cachep",
            "GFP_NOFS"
          ],
          "line": 864
        },
        "resolved": true,
        "details": {
          "function_name": "f2fs_kmem_cache_alloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "1064-1076",
          "snippet": "static inline void *f2fs_kmem_cache_alloc(struct kmem_cache *cachep,\n\t\t\t\t\t\tgfp_t flags)\n{\n\tvoid *entry;\nretry:\n\tentry = kmem_cache_alloc(cachep, flags);\n\tif (!entry) {\n\t\tcond_resched();\n\t\tgoto retry;\n\t}\n\n\treturn entry;\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline void *f2fs_kmem_cache_alloc(struct kmem_cache *cachep,\n\t\t\t\t\t\tgfp_t flags)\n{\n\tvoid *entry;\nretry:\n\tentry = kmem_cache_alloc(cachep, flags);\n\tif (!entry) {\n\t\tcond_resched();\n\t\tgoto retry;\n\t}\n\n\treturn entry;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"mballoc.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4_extents.h\"\t/* Needed for trace points definition */\n#include \"ext4.h\"\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <asm/uaccess.h>\n#include <linux/cleancache.h>\n#include <linux/crc16.h>\n#include <linux/log2.h>\n#include <linux/ctype.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/random.h>\n#include <linux/vfs.h>\n#include <linux/exportfs.h>\n#include <linux/buffer_head.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/jbd2.h>\n#include <linux/vmalloc.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n#include <linux/string.h>\n#include <linux/module.h>\n\nstatic int ext4_unfreeze(struct super_block *sb);\nstatic int ext4_freeze(struct super_block *sb);\nstatic inline int ext2_feature_set_ok(struct super_block *sb);\nstatic inline int ext3_feature_set_ok(struct super_block *sb);\nstatic void ext4_unregister_li_request(struct super_block *sb);\nstatic struct kmem_cache *ext4_inode_cachep;\n\nstatic struct inode *ext4_alloc_inode(struct super_block *sb)\n{\n\tstruct ext4_inode_info *ei;\n\n\tei = kmem_cache_alloc(ext4_inode_cachep, GFP_NOFS);\n\tif (!ei)\n\t\treturn NULL;\n\n\tei->vfs_inode.i_version = 1;\n\tspin_lock_init(&ei->i_raw_lock);\n\tINIT_LIST_HEAD(&ei->i_prealloc_list);\n\tspin_lock_init(&ei->i_prealloc_lock);\n\text4_es_init_tree(&ei->i_es_tree);\n\trwlock_init(&ei->i_es_lock);\n\tINIT_LIST_HEAD(&ei->i_es_list);\n\tei->i_es_all_nr = 0;\n\tei->i_es_shk_nr = 0;\n\tei->i_es_shrink_lblk = 0;\n\tei->i_reserved_data_blocks = 0;\n\tei->i_reserved_meta_blocks = 0;\n\tei->i_allocated_meta_blocks = 0;\n\tei->i_da_metadata_calc_len = 0;\n\tei->i_da_metadata_calc_last_lblock = 0;\n\tspin_lock_init(&(ei->i_block_reservation_lock));\n#ifdef CONFIG_QUOTA\n\tei->i_reserved_quota = 0;\n\tmemset(&ei->i_dquot, 0, sizeof(ei->i_dquot));\n#endif\n\tei->jinode = NULL;\n\tINIT_LIST_HEAD(&ei->i_rsv_conversion_list);\n\tspin_lock_init(&ei->i_completed_io_lock);\n\tei->i_sync_tid = 0;\n\tei->i_datasync_tid = 0;\n\tatomic_set(&ei->i_ioend_count, 0);\n\tatomic_set(&ei->i_unwritten, 0);\n\tINIT_WORK(&ei->i_rsv_conversion_work, ext4_end_io_rsv_work);\n\n\treturn &ei->vfs_inode;\n}"
  },
  {
    "function_name": "ext4_put_super",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/super.c",
    "lines": "764-853",
    "snippet": "static void ext4_put_super(struct super_block *sb)\n{\n\tstruct ext4_sb_info *sbi = EXT4_SB(sb);\n\tstruct ext4_super_block *es = sbi->s_es;\n\tint i, err;\n\n\text4_unregister_li_request(sb);\n\tdquot_disable(sb, -1, DQUOT_USAGE_ENABLED | DQUOT_LIMITS_ENABLED);\n\n\tflush_workqueue(sbi->rsv_conversion_wq);\n\tdestroy_workqueue(sbi->rsv_conversion_wq);\n\n\tif (sbi->s_journal) {\n\t\terr = jbd2_journal_destroy(sbi->s_journal);\n\t\tsbi->s_journal = NULL;\n\t\tif (err < 0)\n\t\t\text4_abort(sb, \"Couldn't clean up the journal\");\n\t}\n\n\text4_es_unregister_shrinker(sbi);\n\tdel_timer_sync(&sbi->s_err_report);\n\text4_release_system_zone(sb);\n\text4_mb_release(sb);\n\text4_ext_release(sb);\n\text4_xattr_put_super(sb);\n\n\tif (!(sb->s_flags & MS_RDONLY)) {\n\t\tEXT4_CLEAR_INCOMPAT_FEATURE(sb, EXT4_FEATURE_INCOMPAT_RECOVER);\n\t\tes->s_state = cpu_to_le16(sbi->s_mount_state);\n\t}\n\tif (!(sb->s_flags & MS_RDONLY))\n\t\text4_commit_super(sb, 1);\n\n\tif (sbi->s_proc) {\n\t\tremove_proc_entry(\"options\", sbi->s_proc);\n\t\tremove_proc_entry(sb->s_id, ext4_proc_root);\n\t}\n\tkobject_del(&sbi->s_kobj);\n\n\tfor (i = 0; i < sbi->s_gdb_count; i++)\n\t\tbrelse(sbi->s_group_desc[i]);\n\tkvfree(sbi->s_group_desc);\n\tkvfree(sbi->s_flex_groups);\n\tpercpu_counter_destroy(&sbi->s_freeclusters_counter);\n\tpercpu_counter_destroy(&sbi->s_freeinodes_counter);\n\tpercpu_counter_destroy(&sbi->s_dirs_counter);\n\tpercpu_counter_destroy(&sbi->s_dirtyclusters_counter);\n\tbrelse(sbi->s_sbh);\n#ifdef CONFIG_QUOTA\n\tfor (i = 0; i < EXT4_MAXQUOTAS; i++)\n\t\tkfree(sbi->s_qf_names[i]);\n#endif\n\n\t/* Debugging code just in case the in-memory inode orphan list\n\t * isn't empty.  The on-disk one can be non-empty if we've\n\t * detected an error and taken the fs readonly, but the\n\t * in-memory list had better be clean by this point. */\n\tif (!list_empty(&sbi->s_orphan))\n\t\tdump_orphan_list(sb, sbi);\n\tJ_ASSERT(list_empty(&sbi->s_orphan));\n\n\tinvalidate_bdev(sb->s_bdev);\n\tif (sbi->journal_bdev && sbi->journal_bdev != sb->s_bdev) {\n\t\t/*\n\t\t * Invalidate the journal device's buffers.  We don't want them\n\t\t * floating about in memory - the physical journal device may\n\t\t * hotswapped, and it breaks the `ro-after' testing code.\n\t\t */\n\t\tsync_blockdev(sbi->journal_bdev);\n\t\tinvalidate_bdev(sbi->journal_bdev);\n\t\text4_blkdev_remove(sbi);\n\t}\n\tif (sbi->s_mb_cache) {\n\t\text4_xattr_destroy_cache(sbi->s_mb_cache);\n\t\tsbi->s_mb_cache = NULL;\n\t}\n\tif (sbi->s_mmp_tsk)\n\t\tkthread_stop(sbi->s_mmp_tsk);\n\tsb->s_fs_info = NULL;\n\t/*\n\t * Now that we are completely done shutting down the\n\t * superblock, we need to actually destroy the kobject.\n\t */\n\tkobject_put(&sbi->s_kobj);\n\twait_for_completion(&sbi->s_kobj_unregister);\n\tif (sbi->s_chksum_driver)\n\t\tcrypto_free_shash(sbi->s_chksum_driver);\n\tkfree(sbi->s_blockgroup_lock);\n\tkfree(sbi);\n}",
    "includes": [
      "#include <trace/events/ext4.h>",
      "#include \"mballoc.h\"",
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"ext4_jbd2.h\"",
      "#include \"ext4_extents.h\"\t/* Needed for trace points definition */",
      "#include \"ext4.h\"",
      "#include <linux/freezer.h>",
      "#include <linux/kthread.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/cleancache.h>",
      "#include <linux/crc16.h>",
      "#include <linux/log2.h>",
      "#include <linux/ctype.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/namei.h>",
      "#include <linux/mount.h>",
      "#include <linux/random.h>",
      "#include <linux/vfs.h>",
      "#include <linux/exportfs.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/parser.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/init.h>",
      "#include <linux/slab.h>",
      "#include <linux/jbd2.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/time.h>",
      "#include <linux/fs.h>",
      "#include <linux/string.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct proc_dir_entry *ext4_proc_root;",
      "static void ext4_mark_recovery_complete(struct super_block *sb,\n\t\t\t\t\tstruct ext4_super_block *es);",
      "static void ext4_clear_journal_err(struct super_block *sb,\n\t\t\t\t   struct ext4_super_block *es);",
      "static int ext4_unfreeze(struct super_block *sb);",
      "static int ext4_freeze(struct super_block *sb);",
      "static inline int ext2_feature_set_ok(struct super_block *sb);",
      "static inline int ext3_feature_set_ok(struct super_block *sb);",
      "static int ext4_feature_set_ok(struct super_block *sb, int readonly);",
      "static void ext4_unregister_li_request(struct super_block *sb);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "sbi"
          ],
          "line": 852
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "sbi->s_blockgroup_lock"
          ],
          "line": 851
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "crypto_free_shash",
          "args": [
            "sbi->s_chksum_driver"
          ],
          "line": 850
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wait_for_completion",
          "args": [
            "&sbi->s_kobj_unregister"
          ],
          "line": 848
        },
        "resolved": true,
        "details": {
          "function_name": "nfs4_wait_for_completion_rpc_task",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/nfs4proc.c",
          "lines": "1116-1122",
          "snippet": "static int nfs4_wait_for_completion_rpc_task(struct rpc_task *task)\n{\n\tint ret;\n\n\tret = rpc_wait_for_completion_task(task);\n\treturn ret;\n}",
          "includes": [
            "#include \"nfs4trace.h\"",
            "#include \"fscache.h\"",
            "#include \"nfs4session.h\"",
            "#include \"netns.h\"",
            "#include \"pnfs.h\"",
            "#include \"callback.h\"",
            "#include \"iostat.h\"",
            "#include \"internal.h\"",
            "#include \"delegation.h\"",
            "#include \"nfs4_fs.h\"",
            "#include <linux/freezer.h>",
            "#include <linux/utsname.h>",
            "#include <linux/xattr.h>",
            "#include <linux/nfs_idmap.h>",
            "#include <linux/module.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/nfs_mount.h>",
            "#include <linux/nfs_page.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/nfs4.h>",
            "#include <linux/nfs.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/slab.h>",
            "#include <linux/printk.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/string.h>",
            "#include <linux/errno.h>",
            "#include <linux/delay.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"nfs4trace.h\"\n#include \"fscache.h\"\n#include \"nfs4session.h\"\n#include \"netns.h\"\n#include \"pnfs.h\"\n#include \"callback.h\"\n#include \"iostat.h\"\n#include \"internal.h\"\n#include \"delegation.h\"\n#include \"nfs4_fs.h\"\n#include <linux/freezer.h>\n#include <linux/utsname.h>\n#include <linux/xattr.h>\n#include <linux/nfs_idmap.h>\n#include <linux/module.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/nfs_mount.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_fs.h>\n#include <linux/nfs4.h>\n#include <linux/nfs.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/slab.h>\n#include <linux/printk.h>\n#include <linux/ratelimit.h>\n#include <linux/string.h>\n#include <linux/errno.h>\n#include <linux/delay.h>\n#include <linux/mm.h>\n\nstatic int nfs4_wait_for_completion_rpc_task(struct rpc_task *task)\n{\n\tint ret;\n\n\tret = rpc_wait_for_completion_task(task);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kobject_put",
          "args": [
            "&sbi->s_kobj"
          ],
          "line": 847
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kthread_stop",
          "args": [
            "sbi->s_mmp_tsk"
          ],
          "line": 841
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_xattr_destroy_cache",
          "args": [
            "sbi->s_mb_cache"
          ],
          "line": 837
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_xattr_destroy_cache",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/xattr.c",
          "lines": "1724-1728",
          "snippet": "void ext4_xattr_destroy_cache(struct mb_cache *cache)\n{\n\tif (cache)\n\t\tmb_cache_destroy(cache);\n}",
          "includes": [
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include <linux/rwsem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4.h\"\n#include \"ext4_jbd2.h\"\n#include <linux/rwsem.h>\n#include <linux/quotaops.h>\n#include <linux/mbcache.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n\nvoid ext4_xattr_destroy_cache(struct mb_cache *cache)\n{\n\tif (cache)\n\t\tmb_cache_destroy(cache);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_blkdev_remove",
          "args": [
            "sbi"
          ],
          "line": 834
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_blkdev_remove",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/super.c",
          "lines": "731-739",
          "snippet": "static void ext4_blkdev_remove(struct ext4_sb_info *sbi)\n{\n\tstruct block_device *bdev;\n\tbdev = sbi->journal_bdev;\n\tif (bdev) {\n\t\text4_blkdev_put(bdev);\n\t\tsbi->journal_bdev = NULL;\n\t}\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"mballoc.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include \"ext4_extents.h\"\t/* Needed for trace points definition */",
            "#include \"ext4.h\"",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/crc16.h>",
            "#include <linux/log2.h>",
            "#include <linux/ctype.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/random.h>",
            "#include <linux/vfs.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/parser.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/time.h>",
            "#include <linux/fs.h>",
            "#include <linux/string.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"mballoc.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4_extents.h\"\t/* Needed for trace points definition */\n#include \"ext4.h\"\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <asm/uaccess.h>\n#include <linux/cleancache.h>\n#include <linux/crc16.h>\n#include <linux/log2.h>\n#include <linux/ctype.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/random.h>\n#include <linux/vfs.h>\n#include <linux/exportfs.h>\n#include <linux/buffer_head.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/jbd2.h>\n#include <linux/vmalloc.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n#include <linux/string.h>\n#include <linux/module.h>\n\nstatic void ext4_blkdev_remove(struct ext4_sb_info *sbi)\n{\n\tstruct block_device *bdev;\n\tbdev = sbi->journal_bdev;\n\tif (bdev) {\n\t\text4_blkdev_put(bdev);\n\t\tsbi->journal_bdev = NULL;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "invalidate_bdev",
          "args": [
            "sbi->journal_bdev"
          ],
          "line": 833
        },
        "resolved": true,
        "details": {
          "function_name": "invalidate_bdev",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/block_dev.c",
          "lines": "77-91",
          "snippet": "void invalidate_bdev(struct block_device *bdev)\n{\n\tstruct address_space *mapping = bdev->bd_inode->i_mapping;\n\n\tif (mapping->nrpages == 0)\n\t\treturn;\n\n\tinvalidate_bh_lrus();\n\tlru_add_drain_all();\t/* make sure all lru add caches are flushed */\n\tinvalidate_mapping_pages(mapping, 0, -1);\n\t/* 99% of the time, we don't need to flush the cleancache on the bdev.\n\t * But, for the strange corners, lets be cautious\n\t */\n\tcleancache_invalidate_inode(mapping);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/aio.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/log2.h>",
            "#include <linux/namei.h>",
            "#include <linux/uio.h>",
            "#include <linux/mount.h>",
            "#include <linux/mpage.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/swap.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkpg.h>",
            "#include <linux/module.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/highmem.h>",
            "#include <linux/device_cgroup.h>",
            "#include <linux/major.h>",
            "#include <linux/kmod.h>",
            "#include <linux/slab.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <linux/aio.h>\n#include <linux/cleancache.h>\n#include <linux/log2.h>\n#include <linux/namei.h>\n#include <linux/uio.h>\n#include <linux/mount.h>\n#include <linux/mpage.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/swap.h>\n#include <linux/buffer_head.h>\n#include <linux/magic.h>\n#include <linux/blkpg.h>\n#include <linux/module.h>\n#include <linux/blkdev.h>\n#include <linux/highmem.h>\n#include <linux/device_cgroup.h>\n#include <linux/major.h>\n#include <linux/kmod.h>\n#include <linux/slab.h>\n#include <linux/fcntl.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n\nvoid invalidate_bdev(struct block_device *bdev)\n{\n\tstruct address_space *mapping = bdev->bd_inode->i_mapping;\n\n\tif (mapping->nrpages == 0)\n\t\treturn;\n\n\tinvalidate_bh_lrus();\n\tlru_add_drain_all();\t/* make sure all lru add caches are flushed */\n\tinvalidate_mapping_pages(mapping, 0, -1);\n\t/* 99% of the time, we don't need to flush the cleancache on the bdev.\n\t * But, for the strange corners, lets be cautious\n\t */\n\tcleancache_invalidate_inode(mapping);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sync_blockdev",
          "args": [
            "sbi->journal_bdev"
          ],
          "line": 832
        },
        "resolved": true,
        "details": {
          "function_name": "sync_blockdev",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/block_dev.c",
          "lines": "174-177",
          "snippet": "int sync_blockdev(struct block_device *bdev)\n{\n\treturn __sync_blockdev(bdev, 1);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/aio.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/log2.h>",
            "#include <linux/namei.h>",
            "#include <linux/uio.h>",
            "#include <linux/mount.h>",
            "#include <linux/mpage.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/swap.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkpg.h>",
            "#include <linux/module.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/highmem.h>",
            "#include <linux/device_cgroup.h>",
            "#include <linux/major.h>",
            "#include <linux/kmod.h>",
            "#include <linux/slab.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <linux/aio.h>\n#include <linux/cleancache.h>\n#include <linux/log2.h>\n#include <linux/namei.h>\n#include <linux/uio.h>\n#include <linux/mount.h>\n#include <linux/mpage.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/swap.h>\n#include <linux/buffer_head.h>\n#include <linux/magic.h>\n#include <linux/blkpg.h>\n#include <linux/module.h>\n#include <linux/blkdev.h>\n#include <linux/highmem.h>\n#include <linux/device_cgroup.h>\n#include <linux/major.h>\n#include <linux/kmod.h>\n#include <linux/slab.h>\n#include <linux/fcntl.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n\nint sync_blockdev(struct block_device *bdev)\n{\n\treturn __sync_blockdev(bdev, 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "J_ASSERT",
          "args": [
            "list_empty(&sbi->s_orphan)"
          ],
          "line": 823
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&sbi->s_orphan"
          ],
          "line": 823
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_dirty_list_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmthread.c",
          "lines": "505-514",
          "snippet": "static int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/timer.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_flush_asts(struct dlm_ctxt *dlm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/timer.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_flush_asts(struct dlm_ctxt *dlm);\n\nstatic int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dump_orphan_list",
          "args": [
            "sb",
            "sbi"
          ],
          "line": 822
        },
        "resolved": true,
        "details": {
          "function_name": "dump_orphan_list",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/super.c",
          "lines": "746-762",
          "snippet": "static void dump_orphan_list(struct super_block *sb, struct ext4_sb_info *sbi)\n{\n\tstruct list_head *l;\n\n\text4_msg(sb, KERN_ERR, \"sb orphan head is %d\",\n\t\t le32_to_cpu(sbi->s_es->s_last_orphan));\n\n\tprintk(KERN_ERR \"sb_info orphan list:\\n\");\n\tlist_for_each(l, &sbi->s_orphan) {\n\t\tstruct inode *inode = orphan_list_entry(l);\n\t\tprintk(KERN_ERR \"  \"\n\t\t       \"inode %s:%lu at %p: mode %o, nlink %d, next %d\\n\",\n\t\t       inode->i_sb->s_id, inode->i_ino, inode,\n\t\t       inode->i_mode, inode->i_nlink,\n\t\t       NEXT_ORPHAN(inode));\n\t}\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"mballoc.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include \"ext4_extents.h\"\t/* Needed for trace points definition */",
            "#include \"ext4.h\"",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/crc16.h>",
            "#include <linux/log2.h>",
            "#include <linux/ctype.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/random.h>",
            "#include <linux/vfs.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/parser.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/time.h>",
            "#include <linux/fs.h>",
            "#include <linux/string.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ext4_unfreeze(struct super_block *sb);",
            "static int ext4_freeze(struct super_block *sb);",
            "static inline int ext2_feature_set_ok(struct super_block *sb);",
            "static inline int ext3_feature_set_ok(struct super_block *sb);",
            "static void ext4_unregister_li_request(struct super_block *sb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"mballoc.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4_extents.h\"\t/* Needed for trace points definition */\n#include \"ext4.h\"\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <asm/uaccess.h>\n#include <linux/cleancache.h>\n#include <linux/crc16.h>\n#include <linux/log2.h>\n#include <linux/ctype.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/random.h>\n#include <linux/vfs.h>\n#include <linux/exportfs.h>\n#include <linux/buffer_head.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/jbd2.h>\n#include <linux/vmalloc.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n#include <linux/string.h>\n#include <linux/module.h>\n\nstatic int ext4_unfreeze(struct super_block *sb);\nstatic int ext4_freeze(struct super_block *sb);\nstatic inline int ext2_feature_set_ok(struct super_block *sb);\nstatic inline int ext3_feature_set_ok(struct super_block *sb);\nstatic void ext4_unregister_li_request(struct super_block *sb);\n\nstatic void dump_orphan_list(struct super_block *sb, struct ext4_sb_info *sbi)\n{\n\tstruct list_head *l;\n\n\text4_msg(sb, KERN_ERR, \"sb orphan head is %d\",\n\t\t le32_to_cpu(sbi->s_es->s_last_orphan));\n\n\tprintk(KERN_ERR \"sb_info orphan list:\\n\");\n\tlist_for_each(l, &sbi->s_orphan) {\n\t\tstruct inode *inode = orphan_list_entry(l);\n\t\tprintk(KERN_ERR \"  \"\n\t\t       \"inode %s:%lu at %p: mode %o, nlink %d, next %d\\n\",\n\t\t       inode->i_sb->s_id, inode->i_ino, inode,\n\t\t       inode->i_mode, inode->i_nlink,\n\t\t       NEXT_ORPHAN(inode));\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "sbi->s_qf_names[i]"
          ],
          "line": 814
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "brelse",
          "args": [
            "sbi->s_sbh"
          ],
          "line": 811
        },
        "resolved": true,
        "details": {
          "function_name": "__brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1177-1184",
          "snippet": "void __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "percpu_counter_destroy",
          "args": [
            "&sbi->s_dirtyclusters_counter"
          ],
          "line": 810
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "percpu_counter_destroy",
          "args": [
            "&sbi->s_dirs_counter"
          ],
          "line": 809
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "percpu_counter_destroy",
          "args": [
            "&sbi->s_freeinodes_counter"
          ],
          "line": 808
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "percpu_counter_destroy",
          "args": [
            "&sbi->s_freeclusters_counter"
          ],
          "line": 807
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvfree",
          "args": [
            "sbi->s_flex_groups"
          ],
          "line": 806
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvfree",
          "args": [
            "sbi->s_group_desc"
          ],
          "line": 805
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kobject_del",
          "args": [
            "&sbi->s_kobj"
          ],
          "line": 801
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "remove_proc_entry",
          "args": [
            "sb->s_id",
            "ext4_proc_root"
          ],
          "line": 799
        },
        "resolved": true,
        "details": {
          "function_name": "remove_proc_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/generic.c",
          "lines": "523-554",
          "snippet": "void remove_proc_entry(const char *name, struct proc_dir_entry *parent)\n{\n\tstruct proc_dir_entry *de = NULL;\n\tconst char *fn = name;\n\tunsigned int len;\n\n\tspin_lock(&proc_subdir_lock);\n\tif (__xlate_proc_name(name, &parent, &fn) != 0) {\n\t\tspin_unlock(&proc_subdir_lock);\n\t\treturn;\n\t}\n\tlen = strlen(fn);\n\n\tde = pde_subdir_find(parent, fn, len);\n\tif (de)\n\t\trb_erase(&de->subdir_node, &parent->subdir);\n\tspin_unlock(&proc_subdir_lock);\n\tif (!de) {\n\t\tWARN(1, \"name '%s'\\n\", name);\n\t\treturn;\n\t}\n\n\tproc_entry_rundown(de);\n\n\tif (S_ISDIR(de->mode))\n\t\tparent->nlink--;\n\tde->nlink = 0;\n\tWARN(pde_subdir_first(de),\n\t     \"%s: removing non-empty directory '%s/%s', leaking at least '%s'\\n\",\n\t     __func__, de->parent->name, de->name, pde_subdir_first(de)->name);\n\tpde_put(de);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/bitops.h>",
            "#include <linux/idr.h>",
            "#include <linux/init.h>",
            "#include <linux/mount.h>",
            "#include <linux/printk.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/stat.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/time.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_SPINLOCK(proc_subdir_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/bitops.h>\n#include <linux/idr.h>\n#include <linux/init.h>\n#include <linux/mount.h>\n#include <linux/printk.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/stat.h>\n#include <linux/proc_fs.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n\nstatic DEFINE_SPINLOCK(proc_subdir_lock);\n\nvoid remove_proc_entry(const char *name, struct proc_dir_entry *parent)\n{\n\tstruct proc_dir_entry *de = NULL;\n\tconst char *fn = name;\n\tunsigned int len;\n\n\tspin_lock(&proc_subdir_lock);\n\tif (__xlate_proc_name(name, &parent, &fn) != 0) {\n\t\tspin_unlock(&proc_subdir_lock);\n\t\treturn;\n\t}\n\tlen = strlen(fn);\n\n\tde = pde_subdir_find(parent, fn, len);\n\tif (de)\n\t\trb_erase(&de->subdir_node, &parent->subdir);\n\tspin_unlock(&proc_subdir_lock);\n\tif (!de) {\n\t\tWARN(1, \"name '%s'\\n\", name);\n\t\treturn;\n\t}\n\n\tproc_entry_rundown(de);\n\n\tif (S_ISDIR(de->mode))\n\t\tparent->nlink--;\n\tde->nlink = 0;\n\tWARN(pde_subdir_first(de),\n\t     \"%s: removing non-empty directory '%s/%s', leaking at least '%s'\\n\",\n\t     __func__, de->parent->name, de->name, pde_subdir_first(de)->name);\n\tpde_put(de);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_commit_super",
          "args": [
            "sb",
            "1"
          ],
          "line": 795
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_commit_super",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/super.c",
          "lines": "4567-4634",
          "snippet": "static int ext4_commit_super(struct super_block *sb, int sync)\n{\n\tstruct ext4_super_block *es = EXT4_SB(sb)->s_es;\n\tstruct buffer_head *sbh = EXT4_SB(sb)->s_sbh;\n\tint error = 0;\n\n\tif (!sbh || block_device_ejected(sb))\n\t\treturn error;\n\tif (buffer_write_io_error(sbh)) {\n\t\t/*\n\t\t * Oh, dear.  A previous attempt to write the\n\t\t * superblock failed.  This could happen because the\n\t\t * USB device was yanked out.  Or it could happen to\n\t\t * be a transient write error and maybe the block will\n\t\t * be remapped.  Nothing we can do but to retry the\n\t\t * write and hope for the best.\n\t\t */\n\t\text4_msg(sb, KERN_ERR, \"previous I/O error to \"\n\t\t       \"superblock detected\");\n\t\tclear_buffer_write_io_error(sbh);\n\t\tset_buffer_uptodate(sbh);\n\t}\n\t/*\n\t * If the file system is mounted read-only, don't update the\n\t * superblock write time.  This avoids updating the superblock\n\t * write time when we are mounting the root file system\n\t * read/only but we need to replay the journal; at that point,\n\t * for people who are east of GMT and who make their clock\n\t * tick in localtime for Windows bug-for-bug compatibility,\n\t * the clock is set in the future, and this will cause e2fsck\n\t * to complain and force a full file system check.\n\t */\n\tif (!(sb->s_flags & MS_RDONLY))\n\t\tes->s_wtime = cpu_to_le32(get_seconds());\n\tif (sb->s_bdev->bd_part)\n\t\tes->s_kbytes_written =\n\t\t\tcpu_to_le64(EXT4_SB(sb)->s_kbytes_written +\n\t\t\t    ((part_stat_read(sb->s_bdev->bd_part, sectors[1]) -\n\t\t\t      EXT4_SB(sb)->s_sectors_written_start) >> 1));\n\telse\n\t\tes->s_kbytes_written =\n\t\t\tcpu_to_le64(EXT4_SB(sb)->s_kbytes_written);\n\tif (percpu_counter_initialized(&EXT4_SB(sb)->s_freeclusters_counter))\n\t\text4_free_blocks_count_set(es,\n\t\t\tEXT4_C2B(EXT4_SB(sb), percpu_counter_sum_positive(\n\t\t\t\t&EXT4_SB(sb)->s_freeclusters_counter)));\n\tif (percpu_counter_initialized(&EXT4_SB(sb)->s_freeinodes_counter))\n\t\tes->s_free_inodes_count =\n\t\t\tcpu_to_le32(percpu_counter_sum_positive(\n\t\t\t\t&EXT4_SB(sb)->s_freeinodes_counter));\n\tBUFFER_TRACE(sbh, \"marking dirty\");\n\text4_superblock_csum_set(sb);\n\tmark_buffer_dirty(sbh);\n\tif (sync) {\n\t\terror = sync_dirty_buffer(sbh);\n\t\tif (error)\n\t\t\treturn error;\n\n\t\terror = buffer_write_io_error(sbh);\n\t\tif (error) {\n\t\t\text4_msg(sb, KERN_ERR, \"I/O error while writing \"\n\t\t\t       \"superblock\");\n\t\t\tclear_buffer_write_io_error(sbh);\n\t\t\tset_buffer_uptodate(sbh);\n\t\t}\n\t}\n\treturn error;\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"mballoc.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include \"ext4_extents.h\"\t/* Needed for trace points definition */",
            "#include \"ext4.h\"",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/crc16.h>",
            "#include <linux/log2.h>",
            "#include <linux/ctype.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/random.h>",
            "#include <linux/vfs.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/parser.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/time.h>",
            "#include <linux/fs.h>",
            "#include <linux/string.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ext4_show_options(struct seq_file *seq, struct dentry *root);",
            "static int ext4_commit_super(struct super_block *sb, int sync);",
            "static void ext4_mark_recovery_complete(struct super_block *sb,\n\t\t\t\t\tstruct ext4_super_block *es);",
            "static void ext4_clear_journal_err(struct super_block *sb,\n\t\t\t\t   struct ext4_super_block *es);",
            "static int ext4_unfreeze(struct super_block *sb);",
            "static int ext4_freeze(struct super_block *sb);",
            "static inline int ext2_feature_set_ok(struct super_block *sb);",
            "static inline int ext3_feature_set_ok(struct super_block *sb);",
            "static void ext4_unregister_li_request(struct super_block *sb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"mballoc.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4_extents.h\"\t/* Needed for trace points definition */\n#include \"ext4.h\"\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <asm/uaccess.h>\n#include <linux/cleancache.h>\n#include <linux/crc16.h>\n#include <linux/log2.h>\n#include <linux/ctype.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/random.h>\n#include <linux/vfs.h>\n#include <linux/exportfs.h>\n#include <linux/buffer_head.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/jbd2.h>\n#include <linux/vmalloc.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n#include <linux/string.h>\n#include <linux/module.h>\n\nstatic int ext4_show_options(struct seq_file *seq, struct dentry *root);\nstatic int ext4_commit_super(struct super_block *sb, int sync);\nstatic void ext4_mark_recovery_complete(struct super_block *sb,\n\t\t\t\t\tstruct ext4_super_block *es);\nstatic void ext4_clear_journal_err(struct super_block *sb,\n\t\t\t\t   struct ext4_super_block *es);\nstatic int ext4_unfreeze(struct super_block *sb);\nstatic int ext4_freeze(struct super_block *sb);\nstatic inline int ext2_feature_set_ok(struct super_block *sb);\nstatic inline int ext3_feature_set_ok(struct super_block *sb);\nstatic void ext4_unregister_li_request(struct super_block *sb);\n\nstatic int ext4_commit_super(struct super_block *sb, int sync)\n{\n\tstruct ext4_super_block *es = EXT4_SB(sb)->s_es;\n\tstruct buffer_head *sbh = EXT4_SB(sb)->s_sbh;\n\tint error = 0;\n\n\tif (!sbh || block_device_ejected(sb))\n\t\treturn error;\n\tif (buffer_write_io_error(sbh)) {\n\t\t/*\n\t\t * Oh, dear.  A previous attempt to write the\n\t\t * superblock failed.  This could happen because the\n\t\t * USB device was yanked out.  Or it could happen to\n\t\t * be a transient write error and maybe the block will\n\t\t * be remapped.  Nothing we can do but to retry the\n\t\t * write and hope for the best.\n\t\t */\n\t\text4_msg(sb, KERN_ERR, \"previous I/O error to \"\n\t\t       \"superblock detected\");\n\t\tclear_buffer_write_io_error(sbh);\n\t\tset_buffer_uptodate(sbh);\n\t}\n\t/*\n\t * If the file system is mounted read-only, don't update the\n\t * superblock write time.  This avoids updating the superblock\n\t * write time when we are mounting the root file system\n\t * read/only but we need to replay the journal; at that point,\n\t * for people who are east of GMT and who make their clock\n\t * tick in localtime for Windows bug-for-bug compatibility,\n\t * the clock is set in the future, and this will cause e2fsck\n\t * to complain and force a full file system check.\n\t */\n\tif (!(sb->s_flags & MS_RDONLY))\n\t\tes->s_wtime = cpu_to_le32(get_seconds());\n\tif (sb->s_bdev->bd_part)\n\t\tes->s_kbytes_written =\n\t\t\tcpu_to_le64(EXT4_SB(sb)->s_kbytes_written +\n\t\t\t    ((part_stat_read(sb->s_bdev->bd_part, sectors[1]) -\n\t\t\t      EXT4_SB(sb)->s_sectors_written_start) >> 1));\n\telse\n\t\tes->s_kbytes_written =\n\t\t\tcpu_to_le64(EXT4_SB(sb)->s_kbytes_written);\n\tif (percpu_counter_initialized(&EXT4_SB(sb)->s_freeclusters_counter))\n\t\text4_free_blocks_count_set(es,\n\t\t\tEXT4_C2B(EXT4_SB(sb), percpu_counter_sum_positive(\n\t\t\t\t&EXT4_SB(sb)->s_freeclusters_counter)));\n\tif (percpu_counter_initialized(&EXT4_SB(sb)->s_freeinodes_counter))\n\t\tes->s_free_inodes_count =\n\t\t\tcpu_to_le32(percpu_counter_sum_positive(\n\t\t\t\t&EXT4_SB(sb)->s_freeinodes_counter));\n\tBUFFER_TRACE(sbh, \"marking dirty\");\n\text4_superblock_csum_set(sb);\n\tmark_buffer_dirty(sbh);\n\tif (sync) {\n\t\terror = sync_dirty_buffer(sbh);\n\t\tif (error)\n\t\t\treturn error;\n\n\t\terror = buffer_write_io_error(sbh);\n\t\tif (error) {\n\t\t\text4_msg(sb, KERN_ERR, \"I/O error while writing \"\n\t\t\t       \"superblock\");\n\t\t\tclear_buffer_write_io_error(sbh);\n\t\t\tset_buffer_uptodate(sbh);\n\t\t}\n\t}\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "sbi->s_mount_state"
          ],
          "line": 792
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXT4_CLEAR_INCOMPAT_FEATURE",
          "args": [
            "sb",
            "EXT4_FEATURE_INCOMPAT_RECOVER"
          ],
          "line": 791
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_xattr_put_super",
          "args": [
            "sb"
          ],
          "line": 788
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_xattr_put_super",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/xattr.c",
          "lines": "1519-1523",
          "snippet": "void\next4_xattr_put_super(struct super_block *sb)\n{\n\tmb_cache_shrink(sb->s_bdev);\n}",
          "includes": [
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include <linux/rwsem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4.h\"\n#include \"ext4_jbd2.h\"\n#include <linux/rwsem.h>\n#include <linux/quotaops.h>\n#include <linux/mbcache.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n\nvoid\next4_xattr_put_super(struct super_block *sb)\n{\n\tmb_cache_shrink(sb->s_bdev);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_ext_release",
          "args": [
            "sb"
          ],
          "line": 787
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_ext_release",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/extents.c",
          "lines": "3087-3102",
          "snippet": "void ext4_ext_release(struct super_block *sb)\n{\n\tif (!EXT4_HAS_INCOMPAT_FEATURE(sb, EXT4_FEATURE_INCOMPAT_EXTENTS))\n\t\treturn;\n\n#ifdef EXTENTS_STATS\n\tif (EXT4_SB(sb)->s_ext_blocks && EXT4_SB(sb)->s_ext_extents) {\n\t\tstruct ext4_sb_info *sbi = EXT4_SB(sb);\n\t\tprintk(KERN_ERR \"EXT4-fs: %lu blocks in %lu extents (%lu ave)\\n\",\n\t\t\tsbi->s_ext_blocks, sbi->s_ext_extents,\n\t\t\tsbi->s_ext_blocks / sbi->s_ext_extents);\n\t\tprintk(KERN_ERR \"EXT4-fs: extents: %lu min, %lu max, max depth %lu\\n\",\n\t\t\tsbi->s_ext_min, sbi->s_ext_max, sbi->s_depth_max);\n\t}\n#endif\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"xattr.h\"",
            "#include \"ext4_extents.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include <linux/fiemap.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/string.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highuid.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/time.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"xattr.h\"\n#include \"ext4_extents.h\"\n#include \"ext4_jbd2.h\"\n#include <linux/fiemap.h>\n#include <asm/uaccess.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/highuid.h>\n#include <linux/jbd2.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n\nvoid ext4_ext_release(struct super_block *sb)\n{\n\tif (!EXT4_HAS_INCOMPAT_FEATURE(sb, EXT4_FEATURE_INCOMPAT_EXTENTS))\n\t\treturn;\n\n#ifdef EXTENTS_STATS\n\tif (EXT4_SB(sb)->s_ext_blocks && EXT4_SB(sb)->s_ext_extents) {\n\t\tstruct ext4_sb_info *sbi = EXT4_SB(sb);\n\t\tprintk(KERN_ERR \"EXT4-fs: %lu blocks in %lu extents (%lu ave)\\n\",\n\t\t\tsbi->s_ext_blocks, sbi->s_ext_extents,\n\t\t\tsbi->s_ext_blocks / sbi->s_ext_extents);\n\t\tprintk(KERN_ERR \"EXT4-fs: extents: %lu min, %lu max, max depth %lu\\n\",\n\t\t\tsbi->s_ext_min, sbi->s_ext_max, sbi->s_depth_max);\n\t}\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_mb_release",
          "args": [
            "sb"
          ],
          "line": 786
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_mb_release_context",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/mballoc.c",
          "lines": "4329-4367",
          "snippet": "static int ext4_mb_release_context(struct ext4_allocation_context *ac)\n{\n\tstruct ext4_sb_info *sbi = EXT4_SB(ac->ac_sb);\n\tstruct ext4_prealloc_space *pa = ac->ac_pa;\n\tif (pa) {\n\t\tif (pa->pa_type == MB_GROUP_PA) {\n\t\t\t/* see comment in ext4_mb_use_group_pa() */\n\t\t\tspin_lock(&pa->pa_lock);\n\t\t\tpa->pa_pstart += EXT4_C2B(sbi, ac->ac_b_ex.fe_len);\n\t\t\tpa->pa_lstart += EXT4_C2B(sbi, ac->ac_b_ex.fe_len);\n\t\t\tpa->pa_free -= ac->ac_b_ex.fe_len;\n\t\t\tpa->pa_len -= ac->ac_b_ex.fe_len;\n\t\t\tspin_unlock(&pa->pa_lock);\n\t\t}\n\t}\n\tif (pa) {\n\t\t/*\n\t\t * We want to add the pa to the right bucket.\n\t\t * Remove it from the list and while adding\n\t\t * make sure the list to which we are adding\n\t\t * doesn't grow big.\n\t\t */\n\t\tif ((pa->pa_type == MB_GROUP_PA) && likely(pa->pa_free)) {\n\t\t\tspin_lock(pa->pa_obj_lock);\n\t\t\tlist_del_rcu(&pa->pa_inode_list);\n\t\t\tspin_unlock(pa->pa_obj_lock);\n\t\t\text4_mb_add_n_trim(ac);\n\t\t}\n\t\text4_mb_put_pa(ac, ac->ac_sb, pa);\n\t}\n\tif (ac->ac_bitmap_page)\n\t\tpage_cache_release(ac->ac_bitmap_page);\n\tif (ac->ac_buddy_page)\n\t\tpage_cache_release(ac->ac_buddy_page);\n\tif (ac->ac_flags & EXT4_MB_HINT_GROUP_ALLOC)\n\t\tmutex_unlock(&ac->ac_lg->lg_mutex);\n\text4_mb_collect_stats(ac);\n\treturn 0;\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/log2.h>",
            "#include \"mballoc.h\"",
            "#include \"ext4_jbd2.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/log2.h>\n#include \"mballoc.h\"\n#include \"ext4_jbd2.h\"\n\nstatic int ext4_mb_release_context(struct ext4_allocation_context *ac)\n{\n\tstruct ext4_sb_info *sbi = EXT4_SB(ac->ac_sb);\n\tstruct ext4_prealloc_space *pa = ac->ac_pa;\n\tif (pa) {\n\t\tif (pa->pa_type == MB_GROUP_PA) {\n\t\t\t/* see comment in ext4_mb_use_group_pa() */\n\t\t\tspin_lock(&pa->pa_lock);\n\t\t\tpa->pa_pstart += EXT4_C2B(sbi, ac->ac_b_ex.fe_len);\n\t\t\tpa->pa_lstart += EXT4_C2B(sbi, ac->ac_b_ex.fe_len);\n\t\t\tpa->pa_free -= ac->ac_b_ex.fe_len;\n\t\t\tpa->pa_len -= ac->ac_b_ex.fe_len;\n\t\t\tspin_unlock(&pa->pa_lock);\n\t\t}\n\t}\n\tif (pa) {\n\t\t/*\n\t\t * We want to add the pa to the right bucket.\n\t\t * Remove it from the list and while adding\n\t\t * make sure the list to which we are adding\n\t\t * doesn't grow big.\n\t\t */\n\t\tif ((pa->pa_type == MB_GROUP_PA) && likely(pa->pa_free)) {\n\t\t\tspin_lock(pa->pa_obj_lock);\n\t\t\tlist_del_rcu(&pa->pa_inode_list);\n\t\t\tspin_unlock(pa->pa_obj_lock);\n\t\t\text4_mb_add_n_trim(ac);\n\t\t}\n\t\text4_mb_put_pa(ac, ac->ac_sb, pa);\n\t}\n\tif (ac->ac_bitmap_page)\n\t\tpage_cache_release(ac->ac_bitmap_page);\n\tif (ac->ac_buddy_page)\n\t\tpage_cache_release(ac->ac_buddy_page);\n\tif (ac->ac_flags & EXT4_MB_HINT_GROUP_ALLOC)\n\t\tmutex_unlock(&ac->ac_lg->lg_mutex);\n\text4_mb_collect_stats(ac);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_release_system_zone",
          "args": [
            "sb"
          ],
          "line": 785
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_release_system_zone",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/block_validity.c",
          "lines": "181-190",
          "snippet": "void ext4_release_system_zone(struct super_block *sb)\n{\n\tstruct ext4_system_zone\t*entry, *n;\n\n\trbtree_postorder_for_each_entry_safe(entry, n,\n\t\t\t&EXT4_SB(sb)->system_blks, node)\n\t\tkmem_cache_free(ext4_system_zone_cachep, entry);\n\n\tEXT4_SB(sb)->system_blks = RB_ROOT;\n}",
          "includes": [
            "#include \"ext4.h\"",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kmem_cache *ext4_system_zone_cachep;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ext4.h\"\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/blkdev.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/buffer_head.h>\n#include <linux/quotaops.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n\nstatic struct kmem_cache *ext4_system_zone_cachep;\n\nvoid ext4_release_system_zone(struct super_block *sb)\n{\n\tstruct ext4_system_zone\t*entry, *n;\n\n\trbtree_postorder_for_each_entry_safe(entry, n,\n\t\t\t&EXT4_SB(sb)->system_blks, node)\n\t\tkmem_cache_free(ext4_system_zone_cachep, entry);\n\n\tEXT4_SB(sb)->system_blks = RB_ROOT;\n}"
        }
      },
      {
        "call_info": {
          "callee": "del_timer_sync",
          "args": [
            "&sbi->s_err_report"
          ],
          "line": 784
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_es_unregister_shrinker",
          "args": [
            "sbi"
          ],
          "line": 783
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_es_unregister_shrinker",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/extents_status.c",
          "lines": "1220-1227",
          "snippet": "void ext4_es_unregister_shrinker(struct ext4_sb_info *sbi)\n{\n\tif (sbi->s_proc)\n\t\tremove_proc_entry(\"es_shrinker_info\", sbi->s_proc);\n\tpercpu_counter_destroy(&sbi->s_es_stats.es_stats_all_cnt);\n\tpercpu_counter_destroy(&sbi->s_es_stats.es_stats_shk_cnt);\n\tunregister_shrinker(&sbi->s_es_shrinker);\n}",
          "includes": [
            "#include \"ext4_extents.h\"\t/* Needed when ES_AGGRESSIVE_TEST is defined */",
            "#include <trace/events/ext4.h>",
            "#include \"extents_status.h\"",
            "#include \"ext4.h\"",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/list_sort.h>",
            "#include <linux/rbtree.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ext4_extents.h\"\t/* Needed when ES_AGGRESSIVE_TEST is defined */\n#include <trace/events/ext4.h>\n#include \"extents_status.h\"\n#include \"ext4.h\"\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/list_sort.h>\n#include <linux/rbtree.h>\n\nvoid ext4_es_unregister_shrinker(struct ext4_sb_info *sbi)\n{\n\tif (sbi->s_proc)\n\t\tremove_proc_entry(\"es_shrinker_info\", sbi->s_proc);\n\tpercpu_counter_destroy(&sbi->s_es_stats.es_stats_all_cnt);\n\tpercpu_counter_destroy(&sbi->s_es_stats.es_stats_shk_cnt);\n\tunregister_shrinker(&sbi->s_es_shrinker);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_abort",
          "args": [
            "sb",
            "\"Couldn't clean up the journal\""
          ],
          "line": 780
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "jbd2_journal_destroy",
          "args": [
            "sbi->s_journal"
          ],
          "line": 777
        },
        "resolved": true,
        "details": {
          "function_name": "jbd2_journal_destroy_revoke",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd2/revoke.c",
          "lines": "293-300",
          "snippet": "void jbd2_journal_destroy_revoke(journal_t *journal)\n{\n\tjournal->j_revoke = NULL;\n\tif (journal->j_revoke_table[0])\n\t\tjbd2_journal_destroy_revoke_table(journal->j_revoke_table[0]);\n\tif (journal->j_revoke_table[1])\n\t\tjbd2_journal_destroy_revoke_table(journal->j_revoke_table[1]);\n}",
          "includes": [
            "#include <linux/hash.h>",
            "#include <linux/log2.h>",
            "#include <linux/bio.h>",
            "#include <linux/init.h>",
            "#include <linux/list.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include \"jfs_user.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/hash.h>\n#include <linux/log2.h>\n#include <linux/bio.h>\n#include <linux/init.h>\n#include <linux/list.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd2.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include \"jfs_user.h\"\n\nvoid jbd2_journal_destroy_revoke(journal_t *journal)\n{\n\tjournal->j_revoke = NULL;\n\tif (journal->j_revoke_table[0])\n\t\tjbd2_journal_destroy_revoke_table(journal->j_revoke_table[0]);\n\tif (journal->j_revoke_table[1])\n\t\tjbd2_journal_destroy_revoke_table(journal->j_revoke_table[1]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "destroy_workqueue",
          "args": [
            "sbi->rsv_conversion_wq"
          ],
          "line": 774
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_destroy_workqueue",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/async-thread.c",
          "lines": "343-351",
          "snippet": "void btrfs_destroy_workqueue(struct btrfs_workqueue *wq)\n{\n\tif (!wq)\n\t\treturn;\n\tif (wq->high)\n\t\t__btrfs_destroy_workqueue(wq->high);\n\t__btrfs_destroy_workqueue(wq->normal);\n\tkfree(wq);\n}",
          "includes": [
            "#include \"ctree.h\"",
            "#include \"async-thread.h\"",
            "#include <linux/freezer.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/list.h>",
            "#include <linux/slab.h>",
            "#include <linux/kthread.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static inline void\n__btrfs_destroy_workqueue(struct __btrfs_workqueue *wq);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ctree.h\"\n#include \"async-thread.h\"\n#include <linux/freezer.h>\n#include <linux/spinlock.h>\n#include <linux/list.h>\n#include <linux/slab.h>\n#include <linux/kthread.h>\n\nstatic inline void\n__btrfs_destroy_workqueue(struct __btrfs_workqueue *wq);\n\nvoid btrfs_destroy_workqueue(struct btrfs_workqueue *wq)\n{\n\tif (!wq)\n\t\treturn;\n\tif (wq->high)\n\t\t__btrfs_destroy_workqueue(wq->high);\n\t__btrfs_destroy_workqueue(wq->normal);\n\tkfree(wq);\n}"
        }
      },
      {
        "call_info": {
          "callee": "flush_workqueue",
          "args": [
            "sbi->rsv_conversion_wq"
          ],
          "line": 773
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dquot_disable",
          "args": [
            "sb",
            "-1",
            "DQUOT_USAGE_ENABLED | DQUOT_LIMITS_ENABLED"
          ],
          "line": 771
        },
        "resolved": true,
        "details": {
          "function_name": "dquot_disable",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/quota/dquot.c",
          "lines": "1999-2127",
          "snippet": "int dquot_disable(struct super_block *sb, int type, unsigned int flags)\n{\n\tint cnt, ret = 0;\n\tstruct quota_info *dqopt = sb_dqopt(sb);\n\tstruct inode *toputinode[MAXQUOTAS];\n\n\t/* Cannot turn off usage accounting without turning off limits, or\n\t * suspend quotas and simultaneously turn quotas off. */\n\tif ((flags & DQUOT_USAGE_ENABLED && !(flags & DQUOT_LIMITS_ENABLED))\n\t    || (flags & DQUOT_SUSPENDED && flags & (DQUOT_LIMITS_ENABLED |\n\t    DQUOT_USAGE_ENABLED)))\n\t\treturn -EINVAL;\n\n\t/* We need to serialize quota_off() for device */\n\tmutex_lock(&dqopt->dqonoff_mutex);\n\n\t/*\n\t * Skip everything if there's nothing to do. We have to do this because\n\t * sometimes we are called when fill_super() failed and calling\n\t * sync_fs() in such cases does no good.\n\t */\n\tif (!sb_any_quota_loaded(sb)) {\n\t\tmutex_unlock(&dqopt->dqonoff_mutex);\n\t\treturn 0;\n\t}\n\tfor (cnt = 0; cnt < MAXQUOTAS; cnt++) {\n\t\ttoputinode[cnt] = NULL;\n\t\tif (type != -1 && cnt != type)\n\t\t\tcontinue;\n\t\tif (!sb_has_quota_loaded(sb, cnt))\n\t\t\tcontinue;\n\n\t\tif (flags & DQUOT_SUSPENDED) {\n\t\t\tspin_lock(&dq_state_lock);\n\t\t\tdqopt->flags |=\n\t\t\t\tdquot_state_flag(DQUOT_SUSPENDED, cnt);\n\t\t\tspin_unlock(&dq_state_lock);\n\t\t} else {\n\t\t\tspin_lock(&dq_state_lock);\n\t\t\tdqopt->flags &= ~dquot_state_flag(flags, cnt);\n\t\t\t/* Turning off suspended quotas? */\n\t\t\tif (!sb_has_quota_loaded(sb, cnt) &&\n\t\t\t    sb_has_quota_suspended(sb, cnt)) {\n\t\t\t\tdqopt->flags &=\t~dquot_state_flag(\n\t\t\t\t\t\t\tDQUOT_SUSPENDED, cnt);\n\t\t\t\tspin_unlock(&dq_state_lock);\n\t\t\t\tiput(dqopt->files[cnt]);\n\t\t\t\tdqopt->files[cnt] = NULL;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tspin_unlock(&dq_state_lock);\n\t\t}\n\n\t\t/* We still have to keep quota loaded? */\n\t\tif (sb_has_quota_loaded(sb, cnt) && !(flags & DQUOT_SUSPENDED))\n\t\t\tcontinue;\n\n\t\t/* Note: these are blocking operations */\n\t\tdrop_dquot_ref(sb, cnt);\n\t\tinvalidate_dquots(sb, cnt);\n\t\t/*\n\t\t * Now all dquots should be invalidated, all writes done so we\n\t\t * should be only users of the info. No locks needed.\n\t\t */\n\t\tif (info_dirty(&dqopt->info[cnt]))\n\t\t\tsb->dq_op->write_info(sb, cnt);\n\t\tif (dqopt->ops[cnt]->free_file_info)\n\t\t\tdqopt->ops[cnt]->free_file_info(sb, cnt);\n\t\tput_quota_format(dqopt->info[cnt].dqi_format);\n\n\t\ttoputinode[cnt] = dqopt->files[cnt];\n\t\tif (!sb_has_quota_loaded(sb, cnt))\n\t\t\tdqopt->files[cnt] = NULL;\n\t\tdqopt->info[cnt].dqi_flags = 0;\n\t\tdqopt->info[cnt].dqi_igrace = 0;\n\t\tdqopt->info[cnt].dqi_bgrace = 0;\n\t\tdqopt->ops[cnt] = NULL;\n\t}\n\tmutex_unlock(&dqopt->dqonoff_mutex);\n\n\t/* Skip syncing and setting flags if quota files are hidden */\n\tif (dqopt->flags & DQUOT_QUOTA_SYS_FILE)\n\t\tgoto put_inodes;\n\n\t/* Sync the superblock so that buffers with quota data are written to\n\t * disk (and so userspace sees correct data afterwards). */\n\tif (sb->s_op->sync_fs)\n\t\tsb->s_op->sync_fs(sb, 1);\n\tsync_blockdev(sb->s_bdev);\n\t/* Now the quota files are just ordinary files and we can set the\n\t * inode flags back. Moreover we discard the pagecache so that\n\t * userspace sees the writes we did bypassing the pagecache. We\n\t * must also discard the blockdev buffers so that we see the\n\t * changes done by userspace on the next quotaon() */\n\tfor (cnt = 0; cnt < MAXQUOTAS; cnt++)\n\t\tif (toputinode[cnt]) {\n\t\t\tmutex_lock(&dqopt->dqonoff_mutex);\n\t\t\t/* If quota was reenabled in the meantime, we have\n\t\t\t * nothing to do */\n\t\t\tif (!sb_has_quota_loaded(sb, cnt)) {\n\t\t\t\tmutex_lock(&toputinode[cnt]->i_mutex);\n\t\t\t\ttoputinode[cnt]->i_flags &= ~(S_IMMUTABLE |\n\t\t\t\t  S_NOATIME | S_NOQUOTA);\n\t\t\t\ttruncate_inode_pages(&toputinode[cnt]->i_data,\n\t\t\t\t\t\t     0);\n\t\t\t\tmutex_unlock(&toputinode[cnt]->i_mutex);\n\t\t\t\tmark_inode_dirty_sync(toputinode[cnt]);\n\t\t\t}\n\t\t\tmutex_unlock(&dqopt->dqonoff_mutex);\n\t\t}\n\tif (sb->s_bdev)\n\t\tinvalidate_bdev(sb->s_bdev);\nput_inodes:\n\tfor (cnt = 0; cnt < MAXQUOTAS; cnt++)\n\t\tif (toputinode[cnt]) {\n\t\t\t/* On remount RO, we keep the inode pointer so that we\n\t\t\t * can reenable quota on the subsequent remount RW. We\n\t\t\t * have to check 'flags' variable and not use sb_has_\n\t\t\t * function because another quotaon / quotaoff could\n\t\t\t * change global state before we got here. We refuse\n\t\t\t * to suspend quotas when there is pending delete on\n\t\t\t * the quota file... */\n\t\t\tif (!(flags & DQUOT_SUSPENDED))\n\t\t\t\tiput(toputinode[cnt]);\n\t\t\telse if (!toputinode[cnt]->i_nlink)\n\t\t\t\tret = -EBUSY;\n\t\t}\n\treturn ret;\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include \"../internal.h\" /* ugh */",
            "#include <linux/quotaops.h>",
            "#include <linux/capability.h>",
            "#include <linux/namei.h>",
            "#include <linux/kmod.h>",
            "#include <linux/sched.h>",
            "#include <linux/security.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>",
            "#include <linux/tty.h>",
            "#include <linux/stat.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/time.h>",
            "#include <linux/mm.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __cacheline_aligned_in_smp DEFINE_SPINLOCK(dq_state_lock);",
            "static qsize_t inode_get_rsv_space(struct inode *inode);",
            "static void __dquot_initialize(struct inode *inode, int type);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include \"../internal.h\" /* ugh */\n#include <linux/quotaops.h>\n#include <linux/capability.h>\n#include <linux/namei.h>\n#include <linux/kmod.h>\n#include <linux/sched.h>\n#include <linux/security.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/sysctl.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/tty.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/time.h>\n#include <linux/mm.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/kernel.h>\n#include <linux/errno.h>\n\nstatic __cacheline_aligned_in_smp DEFINE_SPINLOCK(dq_state_lock);\nstatic qsize_t inode_get_rsv_space(struct inode *inode);\nstatic void __dquot_initialize(struct inode *inode, int type);\n\nint dquot_disable(struct super_block *sb, int type, unsigned int flags)\n{\n\tint cnt, ret = 0;\n\tstruct quota_info *dqopt = sb_dqopt(sb);\n\tstruct inode *toputinode[MAXQUOTAS];\n\n\t/* Cannot turn off usage accounting without turning off limits, or\n\t * suspend quotas and simultaneously turn quotas off. */\n\tif ((flags & DQUOT_USAGE_ENABLED && !(flags & DQUOT_LIMITS_ENABLED))\n\t    || (flags & DQUOT_SUSPENDED && flags & (DQUOT_LIMITS_ENABLED |\n\t    DQUOT_USAGE_ENABLED)))\n\t\treturn -EINVAL;\n\n\t/* We need to serialize quota_off() for device */\n\tmutex_lock(&dqopt->dqonoff_mutex);\n\n\t/*\n\t * Skip everything if there's nothing to do. We have to do this because\n\t * sometimes we are called when fill_super() failed and calling\n\t * sync_fs() in such cases does no good.\n\t */\n\tif (!sb_any_quota_loaded(sb)) {\n\t\tmutex_unlock(&dqopt->dqonoff_mutex);\n\t\treturn 0;\n\t}\n\tfor (cnt = 0; cnt < MAXQUOTAS; cnt++) {\n\t\ttoputinode[cnt] = NULL;\n\t\tif (type != -1 && cnt != type)\n\t\t\tcontinue;\n\t\tif (!sb_has_quota_loaded(sb, cnt))\n\t\t\tcontinue;\n\n\t\tif (flags & DQUOT_SUSPENDED) {\n\t\t\tspin_lock(&dq_state_lock);\n\t\t\tdqopt->flags |=\n\t\t\t\tdquot_state_flag(DQUOT_SUSPENDED, cnt);\n\t\t\tspin_unlock(&dq_state_lock);\n\t\t} else {\n\t\t\tspin_lock(&dq_state_lock);\n\t\t\tdqopt->flags &= ~dquot_state_flag(flags, cnt);\n\t\t\t/* Turning off suspended quotas? */\n\t\t\tif (!sb_has_quota_loaded(sb, cnt) &&\n\t\t\t    sb_has_quota_suspended(sb, cnt)) {\n\t\t\t\tdqopt->flags &=\t~dquot_state_flag(\n\t\t\t\t\t\t\tDQUOT_SUSPENDED, cnt);\n\t\t\t\tspin_unlock(&dq_state_lock);\n\t\t\t\tiput(dqopt->files[cnt]);\n\t\t\t\tdqopt->files[cnt] = NULL;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tspin_unlock(&dq_state_lock);\n\t\t}\n\n\t\t/* We still have to keep quota loaded? */\n\t\tif (sb_has_quota_loaded(sb, cnt) && !(flags & DQUOT_SUSPENDED))\n\t\t\tcontinue;\n\n\t\t/* Note: these are blocking operations */\n\t\tdrop_dquot_ref(sb, cnt);\n\t\tinvalidate_dquots(sb, cnt);\n\t\t/*\n\t\t * Now all dquots should be invalidated, all writes done so we\n\t\t * should be only users of the info. No locks needed.\n\t\t */\n\t\tif (info_dirty(&dqopt->info[cnt]))\n\t\t\tsb->dq_op->write_info(sb, cnt);\n\t\tif (dqopt->ops[cnt]->free_file_info)\n\t\t\tdqopt->ops[cnt]->free_file_info(sb, cnt);\n\t\tput_quota_format(dqopt->info[cnt].dqi_format);\n\n\t\ttoputinode[cnt] = dqopt->files[cnt];\n\t\tif (!sb_has_quota_loaded(sb, cnt))\n\t\t\tdqopt->files[cnt] = NULL;\n\t\tdqopt->info[cnt].dqi_flags = 0;\n\t\tdqopt->info[cnt].dqi_igrace = 0;\n\t\tdqopt->info[cnt].dqi_bgrace = 0;\n\t\tdqopt->ops[cnt] = NULL;\n\t}\n\tmutex_unlock(&dqopt->dqonoff_mutex);\n\n\t/* Skip syncing and setting flags if quota files are hidden */\n\tif (dqopt->flags & DQUOT_QUOTA_SYS_FILE)\n\t\tgoto put_inodes;\n\n\t/* Sync the superblock so that buffers with quota data are written to\n\t * disk (and so userspace sees correct data afterwards). */\n\tif (sb->s_op->sync_fs)\n\t\tsb->s_op->sync_fs(sb, 1);\n\tsync_blockdev(sb->s_bdev);\n\t/* Now the quota files are just ordinary files and we can set the\n\t * inode flags back. Moreover we discard the pagecache so that\n\t * userspace sees the writes we did bypassing the pagecache. We\n\t * must also discard the blockdev buffers so that we see the\n\t * changes done by userspace on the next quotaon() */\n\tfor (cnt = 0; cnt < MAXQUOTAS; cnt++)\n\t\tif (toputinode[cnt]) {\n\t\t\tmutex_lock(&dqopt->dqonoff_mutex);\n\t\t\t/* If quota was reenabled in the meantime, we have\n\t\t\t * nothing to do */\n\t\t\tif (!sb_has_quota_loaded(sb, cnt)) {\n\t\t\t\tmutex_lock(&toputinode[cnt]->i_mutex);\n\t\t\t\ttoputinode[cnt]->i_flags &= ~(S_IMMUTABLE |\n\t\t\t\t  S_NOATIME | S_NOQUOTA);\n\t\t\t\ttruncate_inode_pages(&toputinode[cnt]->i_data,\n\t\t\t\t\t\t     0);\n\t\t\t\tmutex_unlock(&toputinode[cnt]->i_mutex);\n\t\t\t\tmark_inode_dirty_sync(toputinode[cnt]);\n\t\t\t}\n\t\t\tmutex_unlock(&dqopt->dqonoff_mutex);\n\t\t}\n\tif (sb->s_bdev)\n\t\tinvalidate_bdev(sb->s_bdev);\nput_inodes:\n\tfor (cnt = 0; cnt < MAXQUOTAS; cnt++)\n\t\tif (toputinode[cnt]) {\n\t\t\t/* On remount RO, we keep the inode pointer so that we\n\t\t\t * can reenable quota on the subsequent remount RW. We\n\t\t\t * have to check 'flags' variable and not use sb_has_\n\t\t\t * function because another quotaon / quotaoff could\n\t\t\t * change global state before we got here. We refuse\n\t\t\t * to suspend quotas when there is pending delete on\n\t\t\t * the quota file... */\n\t\t\tif (!(flags & DQUOT_SUSPENDED))\n\t\t\t\tiput(toputinode[cnt]);\n\t\t\telse if (!toputinode[cnt]->i_nlink)\n\t\t\t\tret = -EBUSY;\n\t\t}\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_unregister_li_request",
          "args": [
            "sb"
          ],
          "line": 770
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_unregister_li_request",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/super.c",
          "lines": "2938-2950",
          "snippet": "static void ext4_unregister_li_request(struct super_block *sb)\n{\n\tmutex_lock(&ext4_li_mtx);\n\tif (!ext4_li_info) {\n\t\tmutex_unlock(&ext4_li_mtx);\n\t\treturn;\n\t}\n\n\tmutex_lock(&ext4_li_info->li_list_mtx);\n\text4_remove_li_request(EXT4_SB(sb)->s_li_request);\n\tmutex_unlock(&ext4_li_info->li_list_mtx);\n\tmutex_unlock(&ext4_li_mtx);\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"mballoc.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include \"ext4_extents.h\"\t/* Needed for trace points definition */",
            "#include \"ext4.h\"",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/crc16.h>",
            "#include <linux/log2.h>",
            "#include <linux/ctype.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/random.h>",
            "#include <linux/vfs.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/parser.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/time.h>",
            "#include <linux/fs.h>",
            "#include <linux/string.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct ext4_lazy_init *ext4_li_info;",
            "static struct mutex ext4_li_mtx;",
            "static int ext4_unfreeze(struct super_block *sb);",
            "static int ext4_freeze(struct super_block *sb);",
            "static inline int ext2_feature_set_ok(struct super_block *sb);",
            "static inline int ext3_feature_set_ok(struct super_block *sb);",
            "static void ext4_unregister_li_request(struct super_block *sb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"mballoc.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4_extents.h\"\t/* Needed for trace points definition */\n#include \"ext4.h\"\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <asm/uaccess.h>\n#include <linux/cleancache.h>\n#include <linux/crc16.h>\n#include <linux/log2.h>\n#include <linux/ctype.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/random.h>\n#include <linux/vfs.h>\n#include <linux/exportfs.h>\n#include <linux/buffer_head.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/jbd2.h>\n#include <linux/vmalloc.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n#include <linux/string.h>\n#include <linux/module.h>\n\nstatic struct ext4_lazy_init *ext4_li_info;\nstatic struct mutex ext4_li_mtx;\nstatic int ext4_unfreeze(struct super_block *sb);\nstatic int ext4_freeze(struct super_block *sb);\nstatic inline int ext2_feature_set_ok(struct super_block *sb);\nstatic inline int ext3_feature_set_ok(struct super_block *sb);\nstatic void ext4_unregister_li_request(struct super_block *sb);\n\nstatic void ext4_unregister_li_request(struct super_block *sb)\n{\n\tmutex_lock(&ext4_li_mtx);\n\tif (!ext4_li_info) {\n\t\tmutex_unlock(&ext4_li_mtx);\n\t\treturn;\n\t}\n\n\tmutex_lock(&ext4_li_info->li_list_mtx);\n\text4_remove_li_request(EXT4_SB(sb)->s_li_request);\n\tmutex_unlock(&ext4_li_info->li_list_mtx);\n\tmutex_unlock(&ext4_li_mtx);\n}"
        }
      },
      {
        "call_info": {
          "callee": "EXT4_SB",
          "args": [
            "sb"
          ],
          "line": 766
        },
        "resolved": true,
        "details": {
          "function_name": "EXT4_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ext4.h",
          "lines": "1356-1359",
          "snippet": "static inline struct ext4_sb_info *EXT4_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include \"extents_status.h\"",
            "#include <linux/compat.h>",
            "#include <linux/falloc.h>",
            "#include <crypto/hash.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/wait.h>",
            "#include <linux/timer.h>",
            "#include <linux/mutex.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/quota.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extents_status.h\"\n#include <linux/compat.h>\n#include <linux/falloc.h>\n#include <crypto/hash.h>\n#include <linux/ratelimit.h>\n#include <linux/percpu_counter.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/wait.h>\n#include <linux/timer.h>\n#include <linux/mutex.h>\n#include <linux/seqlock.h>\n#include <linux/rbtree.h>\n#include <linux/rwsem.h>\n#include <linux/quota.h>\n#include <linux/jbd2.h>\n#include <linux/magic.h>\n#include <linux/blkdev.h>\n#include <linux/types.h>\n\nstatic inline struct ext4_sb_info *EXT4_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"mballoc.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4_extents.h\"\t/* Needed for trace points definition */\n#include \"ext4.h\"\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <asm/uaccess.h>\n#include <linux/cleancache.h>\n#include <linux/crc16.h>\n#include <linux/log2.h>\n#include <linux/ctype.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/random.h>\n#include <linux/vfs.h>\n#include <linux/exportfs.h>\n#include <linux/buffer_head.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/jbd2.h>\n#include <linux/vmalloc.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n#include <linux/string.h>\n#include <linux/module.h>\n\nstatic struct proc_dir_entry *ext4_proc_root;\nstatic void ext4_mark_recovery_complete(struct super_block *sb,\n\t\t\t\t\tstruct ext4_super_block *es);\nstatic void ext4_clear_journal_err(struct super_block *sb,\n\t\t\t\t   struct ext4_super_block *es);\nstatic int ext4_unfreeze(struct super_block *sb);\nstatic int ext4_freeze(struct super_block *sb);\nstatic inline int ext2_feature_set_ok(struct super_block *sb);\nstatic inline int ext3_feature_set_ok(struct super_block *sb);\nstatic int ext4_feature_set_ok(struct super_block *sb, int readonly);\nstatic void ext4_unregister_li_request(struct super_block *sb);\n\nstatic void ext4_put_super(struct super_block *sb)\n{\n\tstruct ext4_sb_info *sbi = EXT4_SB(sb);\n\tstruct ext4_super_block *es = sbi->s_es;\n\tint i, err;\n\n\text4_unregister_li_request(sb);\n\tdquot_disable(sb, -1, DQUOT_USAGE_ENABLED | DQUOT_LIMITS_ENABLED);\n\n\tflush_workqueue(sbi->rsv_conversion_wq);\n\tdestroy_workqueue(sbi->rsv_conversion_wq);\n\n\tif (sbi->s_journal) {\n\t\terr = jbd2_journal_destroy(sbi->s_journal);\n\t\tsbi->s_journal = NULL;\n\t\tif (err < 0)\n\t\t\text4_abort(sb, \"Couldn't clean up the journal\");\n\t}\n\n\text4_es_unregister_shrinker(sbi);\n\tdel_timer_sync(&sbi->s_err_report);\n\text4_release_system_zone(sb);\n\text4_mb_release(sb);\n\text4_ext_release(sb);\n\text4_xattr_put_super(sb);\n\n\tif (!(sb->s_flags & MS_RDONLY)) {\n\t\tEXT4_CLEAR_INCOMPAT_FEATURE(sb, EXT4_FEATURE_INCOMPAT_RECOVER);\n\t\tes->s_state = cpu_to_le16(sbi->s_mount_state);\n\t}\n\tif (!(sb->s_flags & MS_RDONLY))\n\t\text4_commit_super(sb, 1);\n\n\tif (sbi->s_proc) {\n\t\tremove_proc_entry(\"options\", sbi->s_proc);\n\t\tremove_proc_entry(sb->s_id, ext4_proc_root);\n\t}\n\tkobject_del(&sbi->s_kobj);\n\n\tfor (i = 0; i < sbi->s_gdb_count; i++)\n\t\tbrelse(sbi->s_group_desc[i]);\n\tkvfree(sbi->s_group_desc);\n\tkvfree(sbi->s_flex_groups);\n\tpercpu_counter_destroy(&sbi->s_freeclusters_counter);\n\tpercpu_counter_destroy(&sbi->s_freeinodes_counter);\n\tpercpu_counter_destroy(&sbi->s_dirs_counter);\n\tpercpu_counter_destroy(&sbi->s_dirtyclusters_counter);\n\tbrelse(sbi->s_sbh);\n#ifdef CONFIG_QUOTA\n\tfor (i = 0; i < EXT4_MAXQUOTAS; i++)\n\t\tkfree(sbi->s_qf_names[i]);\n#endif\n\n\t/* Debugging code just in case the in-memory inode orphan list\n\t * isn't empty.  The on-disk one can be non-empty if we've\n\t * detected an error and taken the fs readonly, but the\n\t * in-memory list had better be clean by this point. */\n\tif (!list_empty(&sbi->s_orphan))\n\t\tdump_orphan_list(sb, sbi);\n\tJ_ASSERT(list_empty(&sbi->s_orphan));\n\n\tinvalidate_bdev(sb->s_bdev);\n\tif (sbi->journal_bdev && sbi->journal_bdev != sb->s_bdev) {\n\t\t/*\n\t\t * Invalidate the journal device's buffers.  We don't want them\n\t\t * floating about in memory - the physical journal device may\n\t\t * hotswapped, and it breaks the `ro-after' testing code.\n\t\t */\n\t\tsync_blockdev(sbi->journal_bdev);\n\t\tinvalidate_bdev(sbi->journal_bdev);\n\t\text4_blkdev_remove(sbi);\n\t}\n\tif (sbi->s_mb_cache) {\n\t\text4_xattr_destroy_cache(sbi->s_mb_cache);\n\t\tsbi->s_mb_cache = NULL;\n\t}\n\tif (sbi->s_mmp_tsk)\n\t\tkthread_stop(sbi->s_mmp_tsk);\n\tsb->s_fs_info = NULL;\n\t/*\n\t * Now that we are completely done shutting down the\n\t * superblock, we need to actually destroy the kobject.\n\t */\n\tkobject_put(&sbi->s_kobj);\n\twait_for_completion(&sbi->s_kobj_unregister);\n\tif (sbi->s_chksum_driver)\n\t\tcrypto_free_shash(sbi->s_chksum_driver);\n\tkfree(sbi->s_blockgroup_lock);\n\tkfree(sbi);\n}"
  },
  {
    "function_name": "dump_orphan_list",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/super.c",
    "lines": "746-762",
    "snippet": "static void dump_orphan_list(struct super_block *sb, struct ext4_sb_info *sbi)\n{\n\tstruct list_head *l;\n\n\text4_msg(sb, KERN_ERR, \"sb orphan head is %d\",\n\t\t le32_to_cpu(sbi->s_es->s_last_orphan));\n\n\tprintk(KERN_ERR \"sb_info orphan list:\\n\");\n\tlist_for_each(l, &sbi->s_orphan) {\n\t\tstruct inode *inode = orphan_list_entry(l);\n\t\tprintk(KERN_ERR \"  \"\n\t\t       \"inode %s:%lu at %p: mode %o, nlink %d, next %d\\n\",\n\t\t       inode->i_sb->s_id, inode->i_ino, inode,\n\t\t       inode->i_mode, inode->i_nlink,\n\t\t       NEXT_ORPHAN(inode));\n\t}\n}",
    "includes": [
      "#include <trace/events/ext4.h>",
      "#include \"mballoc.h\"",
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"ext4_jbd2.h\"",
      "#include \"ext4_extents.h\"\t/* Needed for trace points definition */",
      "#include \"ext4.h\"",
      "#include <linux/freezer.h>",
      "#include <linux/kthread.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/cleancache.h>",
      "#include <linux/crc16.h>",
      "#include <linux/log2.h>",
      "#include <linux/ctype.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/namei.h>",
      "#include <linux/mount.h>",
      "#include <linux/random.h>",
      "#include <linux/vfs.h>",
      "#include <linux/exportfs.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/parser.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/init.h>",
      "#include <linux/slab.h>",
      "#include <linux/jbd2.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/time.h>",
      "#include <linux/fs.h>",
      "#include <linux/string.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ext4_unfreeze(struct super_block *sb);",
      "static int ext4_freeze(struct super_block *sb);",
      "static inline int ext2_feature_set_ok(struct super_block *sb);",
      "static inline int ext3_feature_set_ok(struct super_block *sb);",
      "static void ext4_unregister_li_request(struct super_block *sb);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_ERR \"  \"\n\t\t       \"inode %s:%lu at %p: mode %o, nlink %d, next %d\\n\"",
            "inode->i_sb->s_id",
            "inode->i_ino",
            "inode",
            "inode->i_mode",
            "inode->i_nlink",
            "NEXT_ORPHAN(inode)"
          ],
          "line": 756
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_printk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/super.c",
          "lines": "186-213",
          "snippet": "void btrfs_printk(const struct btrfs_fs_info *fs_info, const char *fmt, ...)\n{\n\tstruct super_block *sb = fs_info->sb;\n\tchar lvl[4];\n\tstruct va_format vaf;\n\tva_list args;\n\tconst char *type = logtypes[4];\n\tint kern_level;\n\n\tva_start(args, fmt);\n\n\tkern_level = printk_get_level(fmt);\n\tif (kern_level) {\n\t\tsize_t size = printk_skip_level(fmt) - fmt;\n\t\tmemcpy(lvl, fmt,  size);\n\t\tlvl[size] = '\\0';\n\t\tfmt += size;\n\t\ttype = logtypes[kern_level - '0'];\n\t} else\n\t\t*lvl = '\\0';\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\tprintk(\"%sBTRFS %s (device %s): %pV\\n\", lvl, type, sb->s_id, &vaf);\n\n\tva_end(args);\n}",
          "includes": [
            "#include <trace/events/btrfs.h>",
            "#include \"qgroup.h\"",
            "#include \"tests/btrfs-tests.h\"",
            "#include \"backref.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"dev-replace.h\"",
            "#include \"rcu-string.h\"",
            "#include \"compression.h\"",
            "#include \"export.h\"",
            "#include \"volumes.h\"",
            "#include \"xattr.h\"",
            "#include \"props.h\"",
            "#include \"hash.h\"",
            "#include \"print-tree.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include \"delayed-inode.h\"",
            "#include <linux/btrfs.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/slab.h>",
            "#include <linux/magic.h>",
            "#include <linux/miscdevice.h>",
            "#include <linux/namei.h>",
            "#include <linux/ctype.h>",
            "#include <linux/parser.h>",
            "#include <linux/compat.h>",
            "#include <linux/statfs.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/mpage.h>",
            "#include <linux/mount.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/string.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/init.h>",
            "#include <linux/time.h>",
            "#include <linux/highmem.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/module.h>",
            "#include <linux/blkdev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/btrfs.h>\n#include \"qgroup.h\"\n#include \"tests/btrfs-tests.h\"\n#include \"backref.h\"\n#include \"free-space-cache.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"compression.h\"\n#include \"export.h\"\n#include \"volumes.h\"\n#include \"xattr.h\"\n#include \"props.h\"\n#include \"hash.h\"\n#include \"print-tree.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include \"delayed-inode.h\"\n#include <linux/btrfs.h>\n#include <linux/ratelimit.h>\n#include <linux/cleancache.h>\n#include <linux/slab.h>\n#include <linux/magic.h>\n#include <linux/miscdevice.h>\n#include <linux/namei.h>\n#include <linux/ctype.h>\n#include <linux/parser.h>\n#include <linux/compat.h>\n#include <linux/statfs.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/mpage.h>\n#include <linux/mount.h>\n#include <linux/backing-dev.h>\n#include <linux/string.h>\n#include <linux/seq_file.h>\n#include <linux/init.h>\n#include <linux/time.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n#include <linux/buffer_head.h>\n#include <linux/module.h>\n#include <linux/blkdev.h>\n\nvoid btrfs_printk(const struct btrfs_fs_info *fs_info, const char *fmt, ...)\n{\n\tstruct super_block *sb = fs_info->sb;\n\tchar lvl[4];\n\tstruct va_format vaf;\n\tva_list args;\n\tconst char *type = logtypes[4];\n\tint kern_level;\n\n\tva_start(args, fmt);\n\n\tkern_level = printk_get_level(fmt);\n\tif (kern_level) {\n\t\tsize_t size = printk_skip_level(fmt) - fmt;\n\t\tmemcpy(lvl, fmt,  size);\n\t\tlvl[size] = '\\0';\n\t\tfmt += size;\n\t\ttype = logtypes[kern_level - '0'];\n\t} else\n\t\t*lvl = '\\0';\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\tprintk(\"%sBTRFS %s (device %s): %pV\\n\", lvl, type, sb->s_id, &vaf);\n\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "NEXT_ORPHAN",
          "args": [
            "inode"
          ],
          "line": 760
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "orphan_list_entry",
          "args": [
            "l"
          ],
          "line": 755
        },
        "resolved": true,
        "details": {
          "function_name": "orphan_list_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/super.c",
          "lines": "741-744",
          "snippet": "static inline struct inode *orphan_list_entry(struct list_head *l)\n{\n\treturn &list_entry(l, struct ext4_inode_info, i_orphan)->vfs_inode;\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"mballoc.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include \"ext4_extents.h\"\t/* Needed for trace points definition */",
            "#include \"ext4.h\"",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/crc16.h>",
            "#include <linux/log2.h>",
            "#include <linux/ctype.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/random.h>",
            "#include <linux/vfs.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/parser.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/time.h>",
            "#include <linux/fs.h>",
            "#include <linux/string.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"mballoc.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4_extents.h\"\t/* Needed for trace points definition */\n#include \"ext4.h\"\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <asm/uaccess.h>\n#include <linux/cleancache.h>\n#include <linux/crc16.h>\n#include <linux/log2.h>\n#include <linux/ctype.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/random.h>\n#include <linux/vfs.h>\n#include <linux/exportfs.h>\n#include <linux/buffer_head.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/jbd2.h>\n#include <linux/vmalloc.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n#include <linux/string.h>\n#include <linux/module.h>\n\nstatic inline struct inode *orphan_list_entry(struct list_head *l)\n{\n\treturn &list_entry(l, struct ext4_inode_info, i_orphan)->vfs_inode;\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each",
          "args": [
            "l",
            "&sbi->s_orphan"
          ],
          "line": 754
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_ERR \"sb_info orphan list:\\n\""
          ],
          "line": 753
        },
        "resolved": true,
        "details": {
          "function_name": "compat_printk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/compat.c",
          "lines": "59-69",
          "snippet": "int compat_printk(const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\tif (!compat_log)\n\t\treturn 0;\n\tva_start(ap, fmt);\n\tret = vprintk(fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/ioctls.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/aio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/mm.h>",
            "#include <linux/poll.h>",
            "#include <linux/signal.h>",
            "#include <linux/highmem.h>",
            "#include <linux/security.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/personality.h>",
            "#include <linux/highuid.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/dirent.h>",
            "#include <linux/ctype.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/nfs4_mount.h>",
            "#include <linux/ncp_mount.h>",
            "#include <linux/init.h>",
            "#include <linux/ioctl.h>",
            "#include <linux/vfs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/namei.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/errno.h>",
            "#include <linux/compat.h>",
            "#include <linux/linkage.h>",
            "#include <linux/kernel.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int compat_log = 1;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/ioctls.h>\n#include <asm/mmu_context.h>\n#include <asm/uaccess.h>\n#include <linux/aio.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/fs_struct.h>\n#include <linux/mm.h>\n#include <linux/poll.h>\n#include <linux/signal.h>\n#include <linux/highmem.h>\n#include <linux/security.h>\n#include <linux/tsacct_kern.h>\n#include <linux/rwsem.h>\n#include <linux/personality.h>\n#include <linux/highuid.h>\n#include <linux/fsnotify.h>\n#include <linux/dirent.h>\n#include <linux/ctype.h>\n#include <linux/syscalls.h>\n#include <linux/nfs4_mount.h>\n#include <linux/ncp_mount.h>\n#include <linux/init.h>\n#include <linux/ioctl.h>\n#include <linux/vfs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/namei.h>\n#include <linux/fcntl.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <linux/compat.h>\n#include <linux/linkage.h>\n#include <linux/kernel.h>\n#include <linux/stddef.h>\n\nint compat_log = 1;\n\nint compat_printk(const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\tif (!compat_log)\n\t\treturn 0;\n\tva_start(ap, fmt);\n\tret = vprintk(fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_msg",
          "args": [
            "sb",
            "KERN_ERR",
            "\"sb orphan head is %d\"",
            "le32_to_cpu(sbi->s_es->s_last_orphan)"
          ],
          "line": 750
        },
        "resolved": true,
        "details": {
          "function_name": "__ext4_msg",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/super.c",
          "lines": "593-607",
          "snippet": "void __ext4_msg(struct super_block *sb,\n\t\tconst char *prefix, const char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tif (!___ratelimit(&(EXT4_SB(sb)->s_msg_ratelimit_state), \"EXT4-fs\"))\n\t\treturn;\n\n\tva_start(args, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\tprintk(\"%sEXT4-fs (%s): %pV\\n\", prefix, sb->s_id, &vaf);\n\tva_end(args);\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"mballoc.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include \"ext4_extents.h\"\t/* Needed for trace points definition */",
            "#include \"ext4.h\"",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/crc16.h>",
            "#include <linux/log2.h>",
            "#include <linux/ctype.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/random.h>",
            "#include <linux/vfs.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/parser.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/time.h>",
            "#include <linux/fs.h>",
            "#include <linux/string.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ext4_unfreeze(struct super_block *sb);",
            "static int ext4_freeze(struct super_block *sb);",
            "static inline int ext2_feature_set_ok(struct super_block *sb);",
            "static inline int ext3_feature_set_ok(struct super_block *sb);",
            "static void ext4_unregister_li_request(struct super_block *sb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"mballoc.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4_extents.h\"\t/* Needed for trace points definition */\n#include \"ext4.h\"\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <asm/uaccess.h>\n#include <linux/cleancache.h>\n#include <linux/crc16.h>\n#include <linux/log2.h>\n#include <linux/ctype.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/random.h>\n#include <linux/vfs.h>\n#include <linux/exportfs.h>\n#include <linux/buffer_head.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/jbd2.h>\n#include <linux/vmalloc.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n#include <linux/string.h>\n#include <linux/module.h>\n\nstatic int ext4_unfreeze(struct super_block *sb);\nstatic int ext4_freeze(struct super_block *sb);\nstatic inline int ext2_feature_set_ok(struct super_block *sb);\nstatic inline int ext3_feature_set_ok(struct super_block *sb);\nstatic void ext4_unregister_li_request(struct super_block *sb);\n\nvoid __ext4_msg(struct super_block *sb,\n\t\tconst char *prefix, const char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tif (!___ratelimit(&(EXT4_SB(sb)->s_msg_ratelimit_state), \"EXT4-fs\"))\n\t\treturn;\n\n\tva_start(args, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\tprintk(\"%sEXT4-fs (%s): %pV\\n\", prefix, sb->s_id, &vaf);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "sbi->s_es->s_last_orphan"
          ],
          "line": 751
        },
        "resolved": true,
        "details": {
          "function_name": "sle32_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "53-56",
          "snippet": "static inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"mballoc.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4_extents.h\"\t/* Needed for trace points definition */\n#include \"ext4.h\"\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <asm/uaccess.h>\n#include <linux/cleancache.h>\n#include <linux/crc16.h>\n#include <linux/log2.h>\n#include <linux/ctype.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/random.h>\n#include <linux/vfs.h>\n#include <linux/exportfs.h>\n#include <linux/buffer_head.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/jbd2.h>\n#include <linux/vmalloc.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n#include <linux/string.h>\n#include <linux/module.h>\n\nstatic int ext4_unfreeze(struct super_block *sb);\nstatic int ext4_freeze(struct super_block *sb);\nstatic inline int ext2_feature_set_ok(struct super_block *sb);\nstatic inline int ext3_feature_set_ok(struct super_block *sb);\nstatic void ext4_unregister_li_request(struct super_block *sb);\n\nstatic void dump_orphan_list(struct super_block *sb, struct ext4_sb_info *sbi)\n{\n\tstruct list_head *l;\n\n\text4_msg(sb, KERN_ERR, \"sb orphan head is %d\",\n\t\t le32_to_cpu(sbi->s_es->s_last_orphan));\n\n\tprintk(KERN_ERR \"sb_info orphan list:\\n\");\n\tlist_for_each(l, &sbi->s_orphan) {\n\t\tstruct inode *inode = orphan_list_entry(l);\n\t\tprintk(KERN_ERR \"  \"\n\t\t       \"inode %s:%lu at %p: mode %o, nlink %d, next %d\\n\",\n\t\t       inode->i_sb->s_id, inode->i_ino, inode,\n\t\t       inode->i_mode, inode->i_nlink,\n\t\t       NEXT_ORPHAN(inode));\n\t}\n}"
  },
  {
    "function_name": "orphan_list_entry",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/super.c",
    "lines": "741-744",
    "snippet": "static inline struct inode *orphan_list_entry(struct list_head *l)\n{\n\treturn &list_entry(l, struct ext4_inode_info, i_orphan)->vfs_inode;\n}",
    "includes": [
      "#include <trace/events/ext4.h>",
      "#include \"mballoc.h\"",
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"ext4_jbd2.h\"",
      "#include \"ext4_extents.h\"\t/* Needed for trace points definition */",
      "#include \"ext4.h\"",
      "#include <linux/freezer.h>",
      "#include <linux/kthread.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/cleancache.h>",
      "#include <linux/crc16.h>",
      "#include <linux/log2.h>",
      "#include <linux/ctype.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/namei.h>",
      "#include <linux/mount.h>",
      "#include <linux/random.h>",
      "#include <linux/vfs.h>",
      "#include <linux/exportfs.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/parser.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/init.h>",
      "#include <linux/slab.h>",
      "#include <linux/jbd2.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/time.h>",
      "#include <linux/fs.h>",
      "#include <linux/string.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "list_entry",
          "args": [
            "l",
            "structext4_inode_info",
            "i_orphan"
          ],
          "line": 743
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"mballoc.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4_extents.h\"\t/* Needed for trace points definition */\n#include \"ext4.h\"\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <asm/uaccess.h>\n#include <linux/cleancache.h>\n#include <linux/crc16.h>\n#include <linux/log2.h>\n#include <linux/ctype.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/random.h>\n#include <linux/vfs.h>\n#include <linux/exportfs.h>\n#include <linux/buffer_head.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/jbd2.h>\n#include <linux/vmalloc.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n#include <linux/string.h>\n#include <linux/module.h>\n\nstatic inline struct inode *orphan_list_entry(struct list_head *l)\n{\n\treturn &list_entry(l, struct ext4_inode_info, i_orphan)->vfs_inode;\n}"
  },
  {
    "function_name": "ext4_blkdev_remove",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/super.c",
    "lines": "731-739",
    "snippet": "static void ext4_blkdev_remove(struct ext4_sb_info *sbi)\n{\n\tstruct block_device *bdev;\n\tbdev = sbi->journal_bdev;\n\tif (bdev) {\n\t\text4_blkdev_put(bdev);\n\t\tsbi->journal_bdev = NULL;\n\t}\n}",
    "includes": [
      "#include <trace/events/ext4.h>",
      "#include \"mballoc.h\"",
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"ext4_jbd2.h\"",
      "#include \"ext4_extents.h\"\t/* Needed for trace points definition */",
      "#include \"ext4.h\"",
      "#include <linux/freezer.h>",
      "#include <linux/kthread.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/cleancache.h>",
      "#include <linux/crc16.h>",
      "#include <linux/log2.h>",
      "#include <linux/ctype.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/namei.h>",
      "#include <linux/mount.h>",
      "#include <linux/random.h>",
      "#include <linux/vfs.h>",
      "#include <linux/exportfs.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/parser.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/init.h>",
      "#include <linux/slab.h>",
      "#include <linux/jbd2.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/time.h>",
      "#include <linux/fs.h>",
      "#include <linux/string.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ext4_blkdev_put",
          "args": [
            "bdev"
          ],
          "line": 736
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_blkdev_put",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/super.c",
          "lines": "726-729",
          "snippet": "static void ext4_blkdev_put(struct block_device *bdev)\n{\n\tblkdev_put(bdev, FMODE_READ|FMODE_WRITE|FMODE_EXCL);\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"mballoc.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include \"ext4_extents.h\"\t/* Needed for trace points definition */",
            "#include \"ext4.h\"",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/crc16.h>",
            "#include <linux/log2.h>",
            "#include <linux/ctype.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/random.h>",
            "#include <linux/vfs.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/parser.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/time.h>",
            "#include <linux/fs.h>",
            "#include <linux/string.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"mballoc.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4_extents.h\"\t/* Needed for trace points definition */\n#include \"ext4.h\"\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <asm/uaccess.h>\n#include <linux/cleancache.h>\n#include <linux/crc16.h>\n#include <linux/log2.h>\n#include <linux/ctype.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/random.h>\n#include <linux/vfs.h>\n#include <linux/exportfs.h>\n#include <linux/buffer_head.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/jbd2.h>\n#include <linux/vmalloc.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n#include <linux/string.h>\n#include <linux/module.h>\n\nstatic void ext4_blkdev_put(struct block_device *bdev)\n{\n\tblkdev_put(bdev, FMODE_READ|FMODE_WRITE|FMODE_EXCL);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"mballoc.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4_extents.h\"\t/* Needed for trace points definition */\n#include \"ext4.h\"\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <asm/uaccess.h>\n#include <linux/cleancache.h>\n#include <linux/crc16.h>\n#include <linux/log2.h>\n#include <linux/ctype.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/random.h>\n#include <linux/vfs.h>\n#include <linux/exportfs.h>\n#include <linux/buffer_head.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/jbd2.h>\n#include <linux/vmalloc.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n#include <linux/string.h>\n#include <linux/module.h>\n\nstatic void ext4_blkdev_remove(struct ext4_sb_info *sbi)\n{\n\tstruct block_device *bdev;\n\tbdev = sbi->journal_bdev;\n\tif (bdev) {\n\t\text4_blkdev_put(bdev);\n\t\tsbi->journal_bdev = NULL;\n\t}\n}"
  },
  {
    "function_name": "ext4_blkdev_put",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/super.c",
    "lines": "726-729",
    "snippet": "static void ext4_blkdev_put(struct block_device *bdev)\n{\n\tblkdev_put(bdev, FMODE_READ|FMODE_WRITE|FMODE_EXCL);\n}",
    "includes": [
      "#include <trace/events/ext4.h>",
      "#include \"mballoc.h\"",
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"ext4_jbd2.h\"",
      "#include \"ext4_extents.h\"\t/* Needed for trace points definition */",
      "#include \"ext4.h\"",
      "#include <linux/freezer.h>",
      "#include <linux/kthread.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/cleancache.h>",
      "#include <linux/crc16.h>",
      "#include <linux/log2.h>",
      "#include <linux/ctype.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/namei.h>",
      "#include <linux/mount.h>",
      "#include <linux/random.h>",
      "#include <linux/vfs.h>",
      "#include <linux/exportfs.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/parser.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/init.h>",
      "#include <linux/slab.h>",
      "#include <linux/jbd2.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/time.h>",
      "#include <linux/fs.h>",
      "#include <linux/string.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "blkdev_put",
          "args": [
            "bdev",
            "FMODE_READ|FMODE_WRITE|FMODE_EXCL"
          ],
          "line": 728
        },
        "resolved": true,
        "details": {
          "function_name": "blkdev_put",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/block_dev.c",
          "lines": "1519-1564",
          "snippet": "void blkdev_put(struct block_device *bdev, fmode_t mode)\n{\n\tmutex_lock(&bdev->bd_mutex);\n\n\tif (mode & FMODE_EXCL) {\n\t\tbool bdev_free;\n\n\t\t/*\n\t\t * Release a claim on the device.  The holder fields\n\t\t * are protected with bdev_lock.  bd_mutex is to\n\t\t * synchronize disk_holder unlinking.\n\t\t */\n\t\tspin_lock(&bdev_lock);\n\n\t\tWARN_ON_ONCE(--bdev->bd_holders < 0);\n\t\tWARN_ON_ONCE(--bdev->bd_contains->bd_holders < 0);\n\n\t\t/* bd_contains might point to self, check in a separate step */\n\t\tif ((bdev_free = !bdev->bd_holders))\n\t\t\tbdev->bd_holder = NULL;\n\t\tif (!bdev->bd_contains->bd_holders)\n\t\t\tbdev->bd_contains->bd_holder = NULL;\n\n\t\tspin_unlock(&bdev_lock);\n\n\t\t/*\n\t\t * If this was the last claim, remove holder link and\n\t\t * unblock evpoll if it was a write holder.\n\t\t */\n\t\tif (bdev_free && bdev->bd_write_holder) {\n\t\t\tdisk_unblock_events(bdev->bd_disk);\n\t\t\tbdev->bd_write_holder = false;\n\t\t}\n\t}\n\n\t/*\n\t * Trigger event checking and tell drivers to flush MEDIA_CHANGE\n\t * event.  This is to ensure detection of media removal commanded\n\t * from userland - e.g. eject(1).\n\t */\n\tdisk_flush_events(bdev->bd_disk, DISK_EVENT_MEDIA_CHANGE);\n\n\tmutex_unlock(&bdev->bd_mutex);\n\n\t__blkdev_put(bdev, mode, 0);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/aio.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/log2.h>",
            "#include <linux/namei.h>",
            "#include <linux/uio.h>",
            "#include <linux/mount.h>",
            "#include <linux/mpage.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/swap.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkpg.h>",
            "#include <linux/module.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/highmem.h>",
            "#include <linux/device_cgroup.h>",
            "#include <linux/major.h>",
            "#include <linux/kmod.h>",
            "#include <linux/slab.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static  __cacheline_aligned_in_smp DEFINE_SPINLOCK(bdev_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <linux/aio.h>\n#include <linux/cleancache.h>\n#include <linux/log2.h>\n#include <linux/namei.h>\n#include <linux/uio.h>\n#include <linux/mount.h>\n#include <linux/mpage.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/swap.h>\n#include <linux/buffer_head.h>\n#include <linux/magic.h>\n#include <linux/blkpg.h>\n#include <linux/module.h>\n#include <linux/blkdev.h>\n#include <linux/highmem.h>\n#include <linux/device_cgroup.h>\n#include <linux/major.h>\n#include <linux/kmod.h>\n#include <linux/slab.h>\n#include <linux/fcntl.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n\nstatic  __cacheline_aligned_in_smp DEFINE_SPINLOCK(bdev_lock);\n\nvoid blkdev_put(struct block_device *bdev, fmode_t mode)\n{\n\tmutex_lock(&bdev->bd_mutex);\n\n\tif (mode & FMODE_EXCL) {\n\t\tbool bdev_free;\n\n\t\t/*\n\t\t * Release a claim on the device.  The holder fields\n\t\t * are protected with bdev_lock.  bd_mutex is to\n\t\t * synchronize disk_holder unlinking.\n\t\t */\n\t\tspin_lock(&bdev_lock);\n\n\t\tWARN_ON_ONCE(--bdev->bd_holders < 0);\n\t\tWARN_ON_ONCE(--bdev->bd_contains->bd_holders < 0);\n\n\t\t/* bd_contains might point to self, check in a separate step */\n\t\tif ((bdev_free = !bdev->bd_holders))\n\t\t\tbdev->bd_holder = NULL;\n\t\tif (!bdev->bd_contains->bd_holders)\n\t\t\tbdev->bd_contains->bd_holder = NULL;\n\n\t\tspin_unlock(&bdev_lock);\n\n\t\t/*\n\t\t * If this was the last claim, remove holder link and\n\t\t * unblock evpoll if it was a write holder.\n\t\t */\n\t\tif (bdev_free && bdev->bd_write_holder) {\n\t\t\tdisk_unblock_events(bdev->bd_disk);\n\t\t\tbdev->bd_write_holder = false;\n\t\t}\n\t}\n\n\t/*\n\t * Trigger event checking and tell drivers to flush MEDIA_CHANGE\n\t * event.  This is to ensure detection of media removal commanded\n\t * from userland - e.g. eject(1).\n\t */\n\tdisk_flush_events(bdev->bd_disk, DISK_EVENT_MEDIA_CHANGE);\n\n\tmutex_unlock(&bdev->bd_mutex);\n\n\t__blkdev_put(bdev, mode, 0);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"mballoc.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4_extents.h\"\t/* Needed for trace points definition */\n#include \"ext4.h\"\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <asm/uaccess.h>\n#include <linux/cleancache.h>\n#include <linux/crc16.h>\n#include <linux/log2.h>\n#include <linux/ctype.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/random.h>\n#include <linux/vfs.h>\n#include <linux/exportfs.h>\n#include <linux/buffer_head.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/jbd2.h>\n#include <linux/vmalloc.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n#include <linux/string.h>\n#include <linux/module.h>\n\nstatic void ext4_blkdev_put(struct block_device *bdev)\n{\n\tblkdev_put(bdev, FMODE_READ|FMODE_WRITE|FMODE_EXCL);\n}"
  },
  {
    "function_name": "ext4_blkdev_get",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/super.c",
    "lines": "707-721",
    "snippet": "static struct block_device *ext4_blkdev_get(dev_t dev, struct super_block *sb)\n{\n\tstruct block_device *bdev;\n\tchar b[BDEVNAME_SIZE];\n\n\tbdev = blkdev_get_by_dev(dev, FMODE_READ|FMODE_WRITE|FMODE_EXCL, sb);\n\tif (IS_ERR(bdev))\n\t\tgoto fail;\n\treturn bdev;\n\nfail:\n\text4_msg(sb, KERN_ERR, \"failed to open journal device %s: %ld\",\n\t\t\t__bdevname(dev, b), PTR_ERR(bdev));\n\treturn NULL;\n}",
    "includes": [
      "#include <trace/events/ext4.h>",
      "#include \"mballoc.h\"",
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"ext4_jbd2.h\"",
      "#include \"ext4_extents.h\"\t/* Needed for trace points definition */",
      "#include \"ext4.h\"",
      "#include <linux/freezer.h>",
      "#include <linux/kthread.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/cleancache.h>",
      "#include <linux/crc16.h>",
      "#include <linux/log2.h>",
      "#include <linux/ctype.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/namei.h>",
      "#include <linux/mount.h>",
      "#include <linux/random.h>",
      "#include <linux/vfs.h>",
      "#include <linux/exportfs.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/parser.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/init.h>",
      "#include <linux/slab.h>",
      "#include <linux/jbd2.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/time.h>",
      "#include <linux/fs.h>",
      "#include <linux/string.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ext4_unfreeze(struct super_block *sb);",
      "static int ext4_freeze(struct super_block *sb);",
      "static inline int ext2_feature_set_ok(struct super_block *sb);",
      "static inline int ext3_feature_set_ok(struct super_block *sb);",
      "static void ext4_unregister_li_request(struct super_block *sb);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ext4_msg",
          "args": [
            "sb",
            "KERN_ERR",
            "\"failed to open journal device %s: %ld\"",
            "__bdevname(dev, b)",
            "PTR_ERR(bdev)"
          ],
          "line": 718
        },
        "resolved": true,
        "details": {
          "function_name": "__ext4_msg",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/super.c",
          "lines": "593-607",
          "snippet": "void __ext4_msg(struct super_block *sb,\n\t\tconst char *prefix, const char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tif (!___ratelimit(&(EXT4_SB(sb)->s_msg_ratelimit_state), \"EXT4-fs\"))\n\t\treturn;\n\n\tva_start(args, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\tprintk(\"%sEXT4-fs (%s): %pV\\n\", prefix, sb->s_id, &vaf);\n\tva_end(args);\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"mballoc.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include \"ext4_extents.h\"\t/* Needed for trace points definition */",
            "#include \"ext4.h\"",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/crc16.h>",
            "#include <linux/log2.h>",
            "#include <linux/ctype.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/random.h>",
            "#include <linux/vfs.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/parser.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/time.h>",
            "#include <linux/fs.h>",
            "#include <linux/string.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ext4_unfreeze(struct super_block *sb);",
            "static int ext4_freeze(struct super_block *sb);",
            "static inline int ext2_feature_set_ok(struct super_block *sb);",
            "static inline int ext3_feature_set_ok(struct super_block *sb);",
            "static void ext4_unregister_li_request(struct super_block *sb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"mballoc.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4_extents.h\"\t/* Needed for trace points definition */\n#include \"ext4.h\"\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <asm/uaccess.h>\n#include <linux/cleancache.h>\n#include <linux/crc16.h>\n#include <linux/log2.h>\n#include <linux/ctype.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/random.h>\n#include <linux/vfs.h>\n#include <linux/exportfs.h>\n#include <linux/buffer_head.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/jbd2.h>\n#include <linux/vmalloc.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n#include <linux/string.h>\n#include <linux/module.h>\n\nstatic int ext4_unfreeze(struct super_block *sb);\nstatic int ext4_freeze(struct super_block *sb);\nstatic inline int ext2_feature_set_ok(struct super_block *sb);\nstatic inline int ext3_feature_set_ok(struct super_block *sb);\nstatic void ext4_unregister_li_request(struct super_block *sb);\n\nvoid __ext4_msg(struct super_block *sb,\n\t\tconst char *prefix, const char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tif (!___ratelimit(&(EXT4_SB(sb)->s_msg_ratelimit_state), \"EXT4-fs\"))\n\t\treturn;\n\n\tva_start(args, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\tprintk(\"%sEXT4-fs (%s): %pV\\n\", prefix, sb->s_id, &vaf);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "bdev"
          ],
          "line": 719
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__bdevname",
          "args": [
            "dev",
            "b"
          ],
          "line": 719
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "bdev"
          ],
          "line": 713
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "blkdev_get_by_dev",
          "args": [
            "dev",
            "FMODE_READ|FMODE_WRITE|FMODE_EXCL",
            "sb"
          ],
          "line": 712
        },
        "resolved": true,
        "details": {
          "function_name": "blkdev_get_by_dev",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/block_dev.c",
          "lines": "1432-1446",
          "snippet": "struct block_device *blkdev_get_by_dev(dev_t dev, fmode_t mode, void *holder)\n{\n\tstruct block_device *bdev;\n\tint err;\n\n\tbdev = bdget(dev);\n\tif (!bdev)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\terr = blkdev_get(bdev, mode, holder);\n\tif (err)\n\t\treturn ERR_PTR(err);\n\n\treturn bdev;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/aio.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/log2.h>",
            "#include <linux/namei.h>",
            "#include <linux/uio.h>",
            "#include <linux/mount.h>",
            "#include <linux/mpage.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/swap.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkpg.h>",
            "#include <linux/module.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/highmem.h>",
            "#include <linux/device_cgroup.h>",
            "#include <linux/major.h>",
            "#include <linux/kmod.h>",
            "#include <linux/slab.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <linux/aio.h>\n#include <linux/cleancache.h>\n#include <linux/log2.h>\n#include <linux/namei.h>\n#include <linux/uio.h>\n#include <linux/mount.h>\n#include <linux/mpage.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/swap.h>\n#include <linux/buffer_head.h>\n#include <linux/magic.h>\n#include <linux/blkpg.h>\n#include <linux/module.h>\n#include <linux/blkdev.h>\n#include <linux/highmem.h>\n#include <linux/device_cgroup.h>\n#include <linux/major.h>\n#include <linux/kmod.h>\n#include <linux/slab.h>\n#include <linux/fcntl.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n\nstruct block_device *blkdev_get_by_dev(dev_t dev, fmode_t mode, void *holder)\n{\n\tstruct block_device *bdev;\n\tint err;\n\n\tbdev = bdget(dev);\n\tif (!bdev)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\terr = blkdev_get(bdev, mode, holder);\n\tif (err)\n\t\treturn ERR_PTR(err);\n\n\treturn bdev;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"mballoc.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4_extents.h\"\t/* Needed for trace points definition */\n#include \"ext4.h\"\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <asm/uaccess.h>\n#include <linux/cleancache.h>\n#include <linux/crc16.h>\n#include <linux/log2.h>\n#include <linux/ctype.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/random.h>\n#include <linux/vfs.h>\n#include <linux/exportfs.h>\n#include <linux/buffer_head.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/jbd2.h>\n#include <linux/vmalloc.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n#include <linux/string.h>\n#include <linux/module.h>\n\nstatic int ext4_unfreeze(struct super_block *sb);\nstatic int ext4_freeze(struct super_block *sb);\nstatic inline int ext2_feature_set_ok(struct super_block *sb);\nstatic inline int ext3_feature_set_ok(struct super_block *sb);\nstatic void ext4_unregister_li_request(struct super_block *sb);\n\nstatic struct block_device *ext4_blkdev_get(dev_t dev, struct super_block *sb)\n{\n\tstruct block_device *bdev;\n\tchar b[BDEVNAME_SIZE];\n\n\tbdev = blkdev_get_by_dev(dev, FMODE_READ|FMODE_WRITE|FMODE_EXCL, sb);\n\tif (IS_ERR(bdev))\n\t\tgoto fail;\n\treturn bdev;\n\nfail:\n\text4_msg(sb, KERN_ERR, \"failed to open journal device %s: %ld\",\n\t\t\t__bdevname(dev, b), PTR_ERR(bdev));\n\treturn NULL;\n}"
  },
  {
    "function_name": "ext4_update_dynamic_rev",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/super.c",
    "lines": "679-702",
    "snippet": "void ext4_update_dynamic_rev(struct super_block *sb)\n{\n\tstruct ext4_super_block *es = EXT4_SB(sb)->s_es;\n\n\tif (le32_to_cpu(es->s_rev_level) > EXT4_GOOD_OLD_REV)\n\t\treturn;\n\n\text4_warning(sb,\n\t\t     \"updating to rev %d because of new feature flag, \"\n\t\t     \"running e2fsck is recommended\",\n\t\t     EXT4_DYNAMIC_REV);\n\n\tes->s_first_ino = cpu_to_le32(EXT4_GOOD_OLD_FIRST_INO);\n\tes->s_inode_size = cpu_to_le16(EXT4_GOOD_OLD_INODE_SIZE);\n\tes->s_rev_level = cpu_to_le32(EXT4_DYNAMIC_REV);\n\t/* leave es->s_feature_*compat flags alone */\n\t/* es->s_uuid will be set by e2fsck if empty */\n\n\t/*\n\t * The rest of the superblock fields should be zero, and if not it\n\t * means they are likely already in use, so leave them alone.  We\n\t * can leave it up to e2fsck to clean up any inconsistencies there.\n\t */\n}",
    "includes": [
      "#include <trace/events/ext4.h>",
      "#include \"mballoc.h\"",
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"ext4_jbd2.h\"",
      "#include \"ext4_extents.h\"\t/* Needed for trace points definition */",
      "#include \"ext4.h\"",
      "#include <linux/freezer.h>",
      "#include <linux/kthread.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/cleancache.h>",
      "#include <linux/crc16.h>",
      "#include <linux/log2.h>",
      "#include <linux/ctype.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/namei.h>",
      "#include <linux/mount.h>",
      "#include <linux/random.h>",
      "#include <linux/vfs.h>",
      "#include <linux/exportfs.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/parser.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/init.h>",
      "#include <linux/slab.h>",
      "#include <linux/jbd2.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/time.h>",
      "#include <linux/fs.h>",
      "#include <linux/string.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void ext4_mark_recovery_complete(struct super_block *sb,\n\t\t\t\t\tstruct ext4_super_block *es);",
      "static void ext4_clear_journal_err(struct super_block *sb,\n\t\t\t\t   struct ext4_super_block *es);",
      "static int ext4_unfreeze(struct super_block *sb);",
      "static int ext4_freeze(struct super_block *sb);",
      "static inline int ext2_feature_set_ok(struct super_block *sb);",
      "static inline int ext3_feature_set_ok(struct super_block *sb);",
      "static void ext4_unregister_li_request(struct super_block *sb);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "EXT4_DYNAMIC_REV"
          ],
          "line": 693
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "EXT4_GOOD_OLD_INODE_SIZE"
          ],
          "line": 692
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "EXT4_GOOD_OLD_FIRST_INO"
          ],
          "line": 691
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_warning",
          "args": [
            "sb",
            "\"updating to rev %d because of new feature flag, \"\n\t\t     \"running e2fsck is recommended\"",
            "EXT4_DYNAMIC_REV"
          ],
          "line": 686
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "es->s_rev_level"
          ],
          "line": 683
        },
        "resolved": true,
        "details": {
          "function_name": "sle32_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "53-56",
          "snippet": "static inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "EXT4_SB",
          "args": [
            "sb"
          ],
          "line": 681
        },
        "resolved": true,
        "details": {
          "function_name": "EXT4_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ext4.h",
          "lines": "1356-1359",
          "snippet": "static inline struct ext4_sb_info *EXT4_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include \"extents_status.h\"",
            "#include <linux/compat.h>",
            "#include <linux/falloc.h>",
            "#include <crypto/hash.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/wait.h>",
            "#include <linux/timer.h>",
            "#include <linux/mutex.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/quota.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extents_status.h\"\n#include <linux/compat.h>\n#include <linux/falloc.h>\n#include <crypto/hash.h>\n#include <linux/ratelimit.h>\n#include <linux/percpu_counter.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/wait.h>\n#include <linux/timer.h>\n#include <linux/mutex.h>\n#include <linux/seqlock.h>\n#include <linux/rbtree.h>\n#include <linux/rwsem.h>\n#include <linux/quota.h>\n#include <linux/jbd2.h>\n#include <linux/magic.h>\n#include <linux/blkdev.h>\n#include <linux/types.h>\n\nstatic inline struct ext4_sb_info *EXT4_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"mballoc.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4_extents.h\"\t/* Needed for trace points definition */\n#include \"ext4.h\"\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <asm/uaccess.h>\n#include <linux/cleancache.h>\n#include <linux/crc16.h>\n#include <linux/log2.h>\n#include <linux/ctype.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/random.h>\n#include <linux/vfs.h>\n#include <linux/exportfs.h>\n#include <linux/buffer_head.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/jbd2.h>\n#include <linux/vmalloc.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n#include <linux/string.h>\n#include <linux/module.h>\n\nstatic void ext4_mark_recovery_complete(struct super_block *sb,\n\t\t\t\t\tstruct ext4_super_block *es);\nstatic void ext4_clear_journal_err(struct super_block *sb,\n\t\t\t\t   struct ext4_super_block *es);\nstatic int ext4_unfreeze(struct super_block *sb);\nstatic int ext4_freeze(struct super_block *sb);\nstatic inline int ext2_feature_set_ok(struct super_block *sb);\nstatic inline int ext3_feature_set_ok(struct super_block *sb);\nstatic void ext4_unregister_li_request(struct super_block *sb);\n\nvoid ext4_update_dynamic_rev(struct super_block *sb)\n{\n\tstruct ext4_super_block *es = EXT4_SB(sb)->s_es;\n\n\tif (le32_to_cpu(es->s_rev_level) > EXT4_GOOD_OLD_REV)\n\t\treturn;\n\n\text4_warning(sb,\n\t\t     \"updating to rev %d because of new feature flag, \"\n\t\t     \"running e2fsck is recommended\",\n\t\t     EXT4_DYNAMIC_REV);\n\n\tes->s_first_ino = cpu_to_le32(EXT4_GOOD_OLD_FIRST_INO);\n\tes->s_inode_size = cpu_to_le16(EXT4_GOOD_OLD_INODE_SIZE);\n\tes->s_rev_level = cpu_to_le32(EXT4_DYNAMIC_REV);\n\t/* leave es->s_feature_*compat flags alone */\n\t/* es->s_uuid will be set by e2fsck if empty */\n\n\t/*\n\t * The rest of the superblock fields should be zero, and if not it\n\t * means they are likely already in use, so leave them alone.  We\n\t * can leave it up to e2fsck to clean up any inconsistencies there.\n\t */\n}"
  },
  {
    "function_name": "__ext4_grp_locked_error",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/super.c",
    "lines": "627-677",
    "snippet": "void __ext4_grp_locked_error(const char *function, unsigned int line,\n\t\t\t     struct super_block *sb, ext4_group_t grp,\n\t\t\t     unsigned long ino, ext4_fsblk_t block,\n\t\t\t     const char *fmt, ...)\n__releases(bitlock)\n__acquires(bitlock)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\tstruct ext4_super_block *es = EXT4_SB(sb)->s_es;\n\n\tes->s_last_error_ino = cpu_to_le32(ino);\n\tes->s_last_error_block = cpu_to_le64(block);\n\t__save_error_info(sb, function, line);\n\n\tif (ext4_error_ratelimit(sb)) {\n\t\tva_start(args, fmt);\n\t\tvaf.fmt = fmt;\n\t\tvaf.va = &args;\n\t\tprintk(KERN_CRIT \"EXT4-fs error (device %s): %s:%d: group %u, \",\n\t\t       sb->s_id, function, line, grp);\n\t\tif (ino)\n\t\t\tprintk(KERN_CONT \"inode %lu: \", ino);\n\t\tif (block)\n\t\t\tprintk(KERN_CONT \"block %llu:\",\n\t\t\t       (unsigned long long) block);\n\t\tprintk(KERN_CONT \"%pV\\n\", &vaf);\n\t\tva_end(args);\n\t}\n\n\tif (test_opt(sb, ERRORS_CONT)) {\n\t\text4_commit_super(sb, 0);\n\t\treturn;\n\t}\n\n\text4_unlock_group(sb, grp);\n\text4_handle_error(sb);\n\t/*\n\t * We only get here in the ERRORS_RO case; relocking the group\n\t * may be dangerous, but nothing bad will happen since the\n\t * filesystem will have already been marked read/only and the\n\t * journal has been aborted.  We return 1 as a hint to callers\n\t * who might what to use the return value from\n\t * ext4_grp_locked_error() to distinguish between the\n\t * ERRORS_CONT and ERRORS_RO case, and perhaps return more\n\t * aggressively from the ext4 function in question, with a\n\t * more appropriate error code.\n\t */\n\text4_lock_group(sb, grp);\n\treturn;\n}",
    "includes": [
      "#include <trace/events/ext4.h>",
      "#include \"mballoc.h\"",
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"ext4_jbd2.h\"",
      "#include \"ext4_extents.h\"\t/* Needed for trace points definition */",
      "#include \"ext4.h\"",
      "#include <linux/freezer.h>",
      "#include <linux/kthread.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/cleancache.h>",
      "#include <linux/crc16.h>",
      "#include <linux/log2.h>",
      "#include <linux/ctype.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/namei.h>",
      "#include <linux/mount.h>",
      "#include <linux/random.h>",
      "#include <linux/vfs.h>",
      "#include <linux/exportfs.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/parser.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/init.h>",
      "#include <linux/slab.h>",
      "#include <linux/jbd2.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/time.h>",
      "#include <linux/fs.h>",
      "#include <linux/string.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void ext4_mark_recovery_complete(struct super_block *sb,\n\t\t\t\t\tstruct ext4_super_block *es);",
      "static void ext4_clear_journal_err(struct super_block *sb,\n\t\t\t\t   struct ext4_super_block *es);",
      "static int ext4_unfreeze(struct super_block *sb);",
      "static int ext4_freeze(struct super_block *sb);",
      "static inline int ext2_feature_set_ok(struct super_block *sb);",
      "static inline int ext3_feature_set_ok(struct super_block *sb);",
      "static void ext4_unregister_li_request(struct super_block *sb);",
      "static int ext4_reserve_clusters(struct ext4_sb_info *, ext4_fsblk_t);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ext4_lock_group",
          "args": [
            "sb",
            "grp"
          ],
          "line": 675
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_lock_group",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ext4.h",
          "lines": "2547-2565",
          "snippet": "static inline void ext4_lock_group(struct super_block *sb, ext4_group_t group)\n{\n\tspinlock_t *lock = ext4_group_lock_ptr(sb, group);\n\tif (spin_trylock(lock))\n\t\t/*\n\t\t * We're able to grab the lock right away, so drop the\n\t\t * lock contention counter.\n\t\t */\n\t\tatomic_add_unless(&EXT4_SB(sb)->s_lock_busy, -1, 0);\n\telse {\n\t\t/*\n\t\t * The lock is busy, so bump the contention counter,\n\t\t * and then wait on the spin lock.\n\t\t */\n\t\tatomic_add_unless(&EXT4_SB(sb)->s_lock_busy, 1,\n\t\t\t\t  EXT4_MAX_CONTENTION);\n\t\tspin_lock(lock);\n\t}\n}",
          "includes": [
            "#include \"extents_status.h\"",
            "#include <linux/compat.h>",
            "#include <linux/falloc.h>",
            "#include <crypto/hash.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/wait.h>",
            "#include <linux/timer.h>",
            "#include <linux/mutex.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/quota.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extents_status.h\"\n#include <linux/compat.h>\n#include <linux/falloc.h>\n#include <crypto/hash.h>\n#include <linux/ratelimit.h>\n#include <linux/percpu_counter.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/wait.h>\n#include <linux/timer.h>\n#include <linux/mutex.h>\n#include <linux/seqlock.h>\n#include <linux/rbtree.h>\n#include <linux/rwsem.h>\n#include <linux/quota.h>\n#include <linux/jbd2.h>\n#include <linux/magic.h>\n#include <linux/blkdev.h>\n#include <linux/types.h>\n\nstatic inline void ext4_lock_group(struct super_block *sb, ext4_group_t group)\n{\n\tspinlock_t *lock = ext4_group_lock_ptr(sb, group);\n\tif (spin_trylock(lock))\n\t\t/*\n\t\t * We're able to grab the lock right away, so drop the\n\t\t * lock contention counter.\n\t\t */\n\t\tatomic_add_unless(&EXT4_SB(sb)->s_lock_busy, -1, 0);\n\telse {\n\t\t/*\n\t\t * The lock is busy, so bump the contention counter,\n\t\t * and then wait on the spin lock.\n\t\t */\n\t\tatomic_add_unless(&EXT4_SB(sb)->s_lock_busy, 1,\n\t\t\t\t  EXT4_MAX_CONTENTION);\n\t\tspin_lock(lock);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_handle_error",
          "args": [
            "sb"
          ],
          "line": 663
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_handle_error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/super.c",
          "lines": "377-401",
          "snippet": "static void ext4_handle_error(struct super_block *sb)\n{\n\tif (sb->s_flags & MS_RDONLY)\n\t\treturn;\n\n\tif (!test_opt(sb, ERRORS_CONT)) {\n\t\tjournal_t *journal = EXT4_SB(sb)->s_journal;\n\n\t\tEXT4_SB(sb)->s_mount_flags |= EXT4_MF_FS_ABORTED;\n\t\tif (journal)\n\t\t\tjbd2_journal_abort(journal, -EIO);\n\t}\n\tif (test_opt(sb, ERRORS_RO)) {\n\t\text4_msg(sb, KERN_CRIT, \"Remounting filesystem read-only\");\n\t\t/*\n\t\t * Make sure updated value of ->s_mount_flags will be visible\n\t\t * before ->s_flags update\n\t\t */\n\t\tsmp_wmb();\n\t\tsb->s_flags |= MS_RDONLY;\n\t}\n\tif (test_opt(sb, ERRORS_PANIC))\n\t\tpanic(\"EXT4-fs (device %s): panic forced after error\\n\",\n\t\t\tsb->s_id);\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"mballoc.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include \"ext4_extents.h\"\t/* Needed for trace points definition */",
            "#include \"ext4.h\"",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/crc16.h>",
            "#include <linux/log2.h>",
            "#include <linux/ctype.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/random.h>",
            "#include <linux/vfs.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/parser.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/time.h>",
            "#include <linux/fs.h>",
            "#include <linux/string.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ext4_unfreeze(struct super_block *sb);",
            "static int ext4_freeze(struct super_block *sb);",
            "static inline int ext2_feature_set_ok(struct super_block *sb);",
            "static inline int ext3_feature_set_ok(struct super_block *sb);",
            "static void ext4_unregister_li_request(struct super_block *sb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"mballoc.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4_extents.h\"\t/* Needed for trace points definition */\n#include \"ext4.h\"\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <asm/uaccess.h>\n#include <linux/cleancache.h>\n#include <linux/crc16.h>\n#include <linux/log2.h>\n#include <linux/ctype.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/random.h>\n#include <linux/vfs.h>\n#include <linux/exportfs.h>\n#include <linux/buffer_head.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/jbd2.h>\n#include <linux/vmalloc.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n#include <linux/string.h>\n#include <linux/module.h>\n\nstatic int ext4_unfreeze(struct super_block *sb);\nstatic int ext4_freeze(struct super_block *sb);\nstatic inline int ext2_feature_set_ok(struct super_block *sb);\nstatic inline int ext3_feature_set_ok(struct super_block *sb);\nstatic void ext4_unregister_li_request(struct super_block *sb);\n\nstatic void ext4_handle_error(struct super_block *sb)\n{\n\tif (sb->s_flags & MS_RDONLY)\n\t\treturn;\n\n\tif (!test_opt(sb, ERRORS_CONT)) {\n\t\tjournal_t *journal = EXT4_SB(sb)->s_journal;\n\n\t\tEXT4_SB(sb)->s_mount_flags |= EXT4_MF_FS_ABORTED;\n\t\tif (journal)\n\t\t\tjbd2_journal_abort(journal, -EIO);\n\t}\n\tif (test_opt(sb, ERRORS_RO)) {\n\t\text4_msg(sb, KERN_CRIT, \"Remounting filesystem read-only\");\n\t\t/*\n\t\t * Make sure updated value of ->s_mount_flags will be visible\n\t\t * before ->s_flags update\n\t\t */\n\t\tsmp_wmb();\n\t\tsb->s_flags |= MS_RDONLY;\n\t}\n\tif (test_opt(sb, ERRORS_PANIC))\n\t\tpanic(\"EXT4-fs (device %s): panic forced after error\\n\",\n\t\t\tsb->s_id);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_unlock_group",
          "args": [
            "sb",
            "grp"
          ],
          "line": 662
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_unlock_group",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ext4.h",
          "lines": "2567-2571",
          "snippet": "static inline void ext4_unlock_group(struct super_block *sb,\n\t\t\t\t\text4_group_t group)\n{\n\tspin_unlock(ext4_group_lock_ptr(sb, group));\n}",
          "includes": [
            "#include \"extents_status.h\"",
            "#include <linux/compat.h>",
            "#include <linux/falloc.h>",
            "#include <crypto/hash.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/wait.h>",
            "#include <linux/timer.h>",
            "#include <linux/mutex.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/quota.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extents_status.h\"\n#include <linux/compat.h>\n#include <linux/falloc.h>\n#include <crypto/hash.h>\n#include <linux/ratelimit.h>\n#include <linux/percpu_counter.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/wait.h>\n#include <linux/timer.h>\n#include <linux/mutex.h>\n#include <linux/seqlock.h>\n#include <linux/rbtree.h>\n#include <linux/rwsem.h>\n#include <linux/quota.h>\n#include <linux/jbd2.h>\n#include <linux/magic.h>\n#include <linux/blkdev.h>\n#include <linux/types.h>\n\nstatic inline void ext4_unlock_group(struct super_block *sb,\n\t\t\t\t\text4_group_t group)\n{\n\tspin_unlock(ext4_group_lock_ptr(sb, group));\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_commit_super",
          "args": [
            "sb",
            "0"
          ],
          "line": 658
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_commit_super",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/super.c",
          "lines": "4567-4634",
          "snippet": "static int ext4_commit_super(struct super_block *sb, int sync)\n{\n\tstruct ext4_super_block *es = EXT4_SB(sb)->s_es;\n\tstruct buffer_head *sbh = EXT4_SB(sb)->s_sbh;\n\tint error = 0;\n\n\tif (!sbh || block_device_ejected(sb))\n\t\treturn error;\n\tif (buffer_write_io_error(sbh)) {\n\t\t/*\n\t\t * Oh, dear.  A previous attempt to write the\n\t\t * superblock failed.  This could happen because the\n\t\t * USB device was yanked out.  Or it could happen to\n\t\t * be a transient write error and maybe the block will\n\t\t * be remapped.  Nothing we can do but to retry the\n\t\t * write and hope for the best.\n\t\t */\n\t\text4_msg(sb, KERN_ERR, \"previous I/O error to \"\n\t\t       \"superblock detected\");\n\t\tclear_buffer_write_io_error(sbh);\n\t\tset_buffer_uptodate(sbh);\n\t}\n\t/*\n\t * If the file system is mounted read-only, don't update the\n\t * superblock write time.  This avoids updating the superblock\n\t * write time when we are mounting the root file system\n\t * read/only but we need to replay the journal; at that point,\n\t * for people who are east of GMT and who make their clock\n\t * tick in localtime for Windows bug-for-bug compatibility,\n\t * the clock is set in the future, and this will cause e2fsck\n\t * to complain and force a full file system check.\n\t */\n\tif (!(sb->s_flags & MS_RDONLY))\n\t\tes->s_wtime = cpu_to_le32(get_seconds());\n\tif (sb->s_bdev->bd_part)\n\t\tes->s_kbytes_written =\n\t\t\tcpu_to_le64(EXT4_SB(sb)->s_kbytes_written +\n\t\t\t    ((part_stat_read(sb->s_bdev->bd_part, sectors[1]) -\n\t\t\t      EXT4_SB(sb)->s_sectors_written_start) >> 1));\n\telse\n\t\tes->s_kbytes_written =\n\t\t\tcpu_to_le64(EXT4_SB(sb)->s_kbytes_written);\n\tif (percpu_counter_initialized(&EXT4_SB(sb)->s_freeclusters_counter))\n\t\text4_free_blocks_count_set(es,\n\t\t\tEXT4_C2B(EXT4_SB(sb), percpu_counter_sum_positive(\n\t\t\t\t&EXT4_SB(sb)->s_freeclusters_counter)));\n\tif (percpu_counter_initialized(&EXT4_SB(sb)->s_freeinodes_counter))\n\t\tes->s_free_inodes_count =\n\t\t\tcpu_to_le32(percpu_counter_sum_positive(\n\t\t\t\t&EXT4_SB(sb)->s_freeinodes_counter));\n\tBUFFER_TRACE(sbh, \"marking dirty\");\n\text4_superblock_csum_set(sb);\n\tmark_buffer_dirty(sbh);\n\tif (sync) {\n\t\terror = sync_dirty_buffer(sbh);\n\t\tif (error)\n\t\t\treturn error;\n\n\t\terror = buffer_write_io_error(sbh);\n\t\tif (error) {\n\t\t\text4_msg(sb, KERN_ERR, \"I/O error while writing \"\n\t\t\t       \"superblock\");\n\t\t\tclear_buffer_write_io_error(sbh);\n\t\t\tset_buffer_uptodate(sbh);\n\t\t}\n\t}\n\treturn error;\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"mballoc.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include \"ext4_extents.h\"\t/* Needed for trace points definition */",
            "#include \"ext4.h\"",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/crc16.h>",
            "#include <linux/log2.h>",
            "#include <linux/ctype.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/random.h>",
            "#include <linux/vfs.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/parser.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/time.h>",
            "#include <linux/fs.h>",
            "#include <linux/string.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ext4_show_options(struct seq_file *seq, struct dentry *root);",
            "static int ext4_commit_super(struct super_block *sb, int sync);",
            "static void ext4_mark_recovery_complete(struct super_block *sb,\n\t\t\t\t\tstruct ext4_super_block *es);",
            "static void ext4_clear_journal_err(struct super_block *sb,\n\t\t\t\t   struct ext4_super_block *es);",
            "static int ext4_unfreeze(struct super_block *sb);",
            "static int ext4_freeze(struct super_block *sb);",
            "static inline int ext2_feature_set_ok(struct super_block *sb);",
            "static inline int ext3_feature_set_ok(struct super_block *sb);",
            "static void ext4_unregister_li_request(struct super_block *sb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"mballoc.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4_extents.h\"\t/* Needed for trace points definition */\n#include \"ext4.h\"\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <asm/uaccess.h>\n#include <linux/cleancache.h>\n#include <linux/crc16.h>\n#include <linux/log2.h>\n#include <linux/ctype.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/random.h>\n#include <linux/vfs.h>\n#include <linux/exportfs.h>\n#include <linux/buffer_head.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/jbd2.h>\n#include <linux/vmalloc.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n#include <linux/string.h>\n#include <linux/module.h>\n\nstatic int ext4_show_options(struct seq_file *seq, struct dentry *root);\nstatic int ext4_commit_super(struct super_block *sb, int sync);\nstatic void ext4_mark_recovery_complete(struct super_block *sb,\n\t\t\t\t\tstruct ext4_super_block *es);\nstatic void ext4_clear_journal_err(struct super_block *sb,\n\t\t\t\t   struct ext4_super_block *es);\nstatic int ext4_unfreeze(struct super_block *sb);\nstatic int ext4_freeze(struct super_block *sb);\nstatic inline int ext2_feature_set_ok(struct super_block *sb);\nstatic inline int ext3_feature_set_ok(struct super_block *sb);\nstatic void ext4_unregister_li_request(struct super_block *sb);\n\nstatic int ext4_commit_super(struct super_block *sb, int sync)\n{\n\tstruct ext4_super_block *es = EXT4_SB(sb)->s_es;\n\tstruct buffer_head *sbh = EXT4_SB(sb)->s_sbh;\n\tint error = 0;\n\n\tif (!sbh || block_device_ejected(sb))\n\t\treturn error;\n\tif (buffer_write_io_error(sbh)) {\n\t\t/*\n\t\t * Oh, dear.  A previous attempt to write the\n\t\t * superblock failed.  This could happen because the\n\t\t * USB device was yanked out.  Or it could happen to\n\t\t * be a transient write error and maybe the block will\n\t\t * be remapped.  Nothing we can do but to retry the\n\t\t * write and hope for the best.\n\t\t */\n\t\text4_msg(sb, KERN_ERR, \"previous I/O error to \"\n\t\t       \"superblock detected\");\n\t\tclear_buffer_write_io_error(sbh);\n\t\tset_buffer_uptodate(sbh);\n\t}\n\t/*\n\t * If the file system is mounted read-only, don't update the\n\t * superblock write time.  This avoids updating the superblock\n\t * write time when we are mounting the root file system\n\t * read/only but we need to replay the journal; at that point,\n\t * for people who are east of GMT and who make their clock\n\t * tick in localtime for Windows bug-for-bug compatibility,\n\t * the clock is set in the future, and this will cause e2fsck\n\t * to complain and force a full file system check.\n\t */\n\tif (!(sb->s_flags & MS_RDONLY))\n\t\tes->s_wtime = cpu_to_le32(get_seconds());\n\tif (sb->s_bdev->bd_part)\n\t\tes->s_kbytes_written =\n\t\t\tcpu_to_le64(EXT4_SB(sb)->s_kbytes_written +\n\t\t\t    ((part_stat_read(sb->s_bdev->bd_part, sectors[1]) -\n\t\t\t      EXT4_SB(sb)->s_sectors_written_start) >> 1));\n\telse\n\t\tes->s_kbytes_written =\n\t\t\tcpu_to_le64(EXT4_SB(sb)->s_kbytes_written);\n\tif (percpu_counter_initialized(&EXT4_SB(sb)->s_freeclusters_counter))\n\t\text4_free_blocks_count_set(es,\n\t\t\tEXT4_C2B(EXT4_SB(sb), percpu_counter_sum_positive(\n\t\t\t\t&EXT4_SB(sb)->s_freeclusters_counter)));\n\tif (percpu_counter_initialized(&EXT4_SB(sb)->s_freeinodes_counter))\n\t\tes->s_free_inodes_count =\n\t\t\tcpu_to_le32(percpu_counter_sum_positive(\n\t\t\t\t&EXT4_SB(sb)->s_freeinodes_counter));\n\tBUFFER_TRACE(sbh, \"marking dirty\");\n\text4_superblock_csum_set(sb);\n\tmark_buffer_dirty(sbh);\n\tif (sync) {\n\t\terror = sync_dirty_buffer(sbh);\n\t\tif (error)\n\t\t\treturn error;\n\n\t\terror = buffer_write_io_error(sbh);\n\t\tif (error) {\n\t\t\text4_msg(sb, KERN_ERR, \"I/O error while writing \"\n\t\t\t       \"superblock\");\n\t\t\tclear_buffer_write_io_error(sbh);\n\t\t\tset_buffer_uptodate(sbh);\n\t\t}\n\t}\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "test_opt",
          "args": [
            "sb",
            "ERRORS_CONT"
          ],
          "line": 657
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "va_end",
          "args": [
            "args"
          ],
          "line": 654
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_CONT \"%pV\\n\"",
            "&vaf"
          ],
          "line": 653
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_printk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/super.c",
          "lines": "186-213",
          "snippet": "void btrfs_printk(const struct btrfs_fs_info *fs_info, const char *fmt, ...)\n{\n\tstruct super_block *sb = fs_info->sb;\n\tchar lvl[4];\n\tstruct va_format vaf;\n\tva_list args;\n\tconst char *type = logtypes[4];\n\tint kern_level;\n\n\tva_start(args, fmt);\n\n\tkern_level = printk_get_level(fmt);\n\tif (kern_level) {\n\t\tsize_t size = printk_skip_level(fmt) - fmt;\n\t\tmemcpy(lvl, fmt,  size);\n\t\tlvl[size] = '\\0';\n\t\tfmt += size;\n\t\ttype = logtypes[kern_level - '0'];\n\t} else\n\t\t*lvl = '\\0';\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\tprintk(\"%sBTRFS %s (device %s): %pV\\n\", lvl, type, sb->s_id, &vaf);\n\n\tva_end(args);\n}",
          "includes": [
            "#include <trace/events/btrfs.h>",
            "#include \"qgroup.h\"",
            "#include \"tests/btrfs-tests.h\"",
            "#include \"backref.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"dev-replace.h\"",
            "#include \"rcu-string.h\"",
            "#include \"compression.h\"",
            "#include \"export.h\"",
            "#include \"volumes.h\"",
            "#include \"xattr.h\"",
            "#include \"props.h\"",
            "#include \"hash.h\"",
            "#include \"print-tree.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include \"delayed-inode.h\"",
            "#include <linux/btrfs.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/slab.h>",
            "#include <linux/magic.h>",
            "#include <linux/miscdevice.h>",
            "#include <linux/namei.h>",
            "#include <linux/ctype.h>",
            "#include <linux/parser.h>",
            "#include <linux/compat.h>",
            "#include <linux/statfs.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/mpage.h>",
            "#include <linux/mount.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/string.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/init.h>",
            "#include <linux/time.h>",
            "#include <linux/highmem.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/module.h>",
            "#include <linux/blkdev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/btrfs.h>\n#include \"qgroup.h\"\n#include \"tests/btrfs-tests.h\"\n#include \"backref.h\"\n#include \"free-space-cache.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"compression.h\"\n#include \"export.h\"\n#include \"volumes.h\"\n#include \"xattr.h\"\n#include \"props.h\"\n#include \"hash.h\"\n#include \"print-tree.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include \"delayed-inode.h\"\n#include <linux/btrfs.h>\n#include <linux/ratelimit.h>\n#include <linux/cleancache.h>\n#include <linux/slab.h>\n#include <linux/magic.h>\n#include <linux/miscdevice.h>\n#include <linux/namei.h>\n#include <linux/ctype.h>\n#include <linux/parser.h>\n#include <linux/compat.h>\n#include <linux/statfs.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/mpage.h>\n#include <linux/mount.h>\n#include <linux/backing-dev.h>\n#include <linux/string.h>\n#include <linux/seq_file.h>\n#include <linux/init.h>\n#include <linux/time.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n#include <linux/buffer_head.h>\n#include <linux/module.h>\n#include <linux/blkdev.h>\n\nvoid btrfs_printk(const struct btrfs_fs_info *fs_info, const char *fmt, ...)\n{\n\tstruct super_block *sb = fs_info->sb;\n\tchar lvl[4];\n\tstruct va_format vaf;\n\tva_list args;\n\tconst char *type = logtypes[4];\n\tint kern_level;\n\n\tva_start(args, fmt);\n\n\tkern_level = printk_get_level(fmt);\n\tif (kern_level) {\n\t\tsize_t size = printk_skip_level(fmt) - fmt;\n\t\tmemcpy(lvl, fmt,  size);\n\t\tlvl[size] = '\\0';\n\t\tfmt += size;\n\t\ttype = logtypes[kern_level - '0'];\n\t} else\n\t\t*lvl = '\\0';\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\tprintk(\"%sBTRFS %s (device %s): %pV\\n\", lvl, type, sb->s_id, &vaf);\n\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "va_start",
          "args": [
            "args",
            "fmt"
          ],
          "line": 643
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_error_ratelimit",
          "args": [
            "sb"
          ],
          "line": 642
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__save_error_info",
          "args": [
            "sb",
            "function",
            "line"
          ],
          "line": 640
        },
        "resolved": true,
        "details": {
          "function_name": "__save_error_info",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/super.c",
          "lines": "292-317",
          "snippet": "static void __save_error_info(struct super_block *sb, const char *func,\n\t\t\t    unsigned int line)\n{\n\tstruct ext4_super_block *es = EXT4_SB(sb)->s_es;\n\n\tEXT4_SB(sb)->s_mount_state |= EXT4_ERROR_FS;\n\tes->s_state |= cpu_to_le16(EXT4_ERROR_FS);\n\tes->s_last_error_time = cpu_to_le32(get_seconds());\n\tstrncpy(es->s_last_error_func, func, sizeof(es->s_last_error_func));\n\tes->s_last_error_line = cpu_to_le32(line);\n\tif (!es->s_first_error_time) {\n\t\tes->s_first_error_time = es->s_last_error_time;\n\t\tstrncpy(es->s_first_error_func, func,\n\t\t\tsizeof(es->s_first_error_func));\n\t\tes->s_first_error_line = cpu_to_le32(line);\n\t\tes->s_first_error_ino = es->s_last_error_ino;\n\t\tes->s_first_error_block = es->s_last_error_block;\n\t}\n\t/*\n\t * Start the daily error reporting function if it hasn't been\n\t * started already\n\t */\n\tif (!es->s_error_count)\n\t\tmod_timer(&EXT4_SB(sb)->s_err_report, jiffies + 24*60*60*HZ);\n\tle32_add_cpu(&es->s_error_count, 1);\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"mballoc.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include \"ext4_extents.h\"\t/* Needed for trace points definition */",
            "#include \"ext4.h\"",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/crc16.h>",
            "#include <linux/log2.h>",
            "#include <linux/ctype.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/random.h>",
            "#include <linux/vfs.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/parser.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/time.h>",
            "#include <linux/fs.h>",
            "#include <linux/string.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void ext4_mark_recovery_complete(struct super_block *sb,\n\t\t\t\t\tstruct ext4_super_block *es);",
            "static void ext4_clear_journal_err(struct super_block *sb,\n\t\t\t\t   struct ext4_super_block *es);",
            "static int ext4_unfreeze(struct super_block *sb);",
            "static int ext4_freeze(struct super_block *sb);",
            "static inline int ext2_feature_set_ok(struct super_block *sb);",
            "static inline int ext3_feature_set_ok(struct super_block *sb);",
            "static void ext4_unregister_li_request(struct super_block *sb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"mballoc.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4_extents.h\"\t/* Needed for trace points definition */\n#include \"ext4.h\"\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <asm/uaccess.h>\n#include <linux/cleancache.h>\n#include <linux/crc16.h>\n#include <linux/log2.h>\n#include <linux/ctype.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/random.h>\n#include <linux/vfs.h>\n#include <linux/exportfs.h>\n#include <linux/buffer_head.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/jbd2.h>\n#include <linux/vmalloc.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n#include <linux/string.h>\n#include <linux/module.h>\n\nstatic void ext4_mark_recovery_complete(struct super_block *sb,\n\t\t\t\t\tstruct ext4_super_block *es);\nstatic void ext4_clear_journal_err(struct super_block *sb,\n\t\t\t\t   struct ext4_super_block *es);\nstatic int ext4_unfreeze(struct super_block *sb);\nstatic int ext4_freeze(struct super_block *sb);\nstatic inline int ext2_feature_set_ok(struct super_block *sb);\nstatic inline int ext3_feature_set_ok(struct super_block *sb);\nstatic void ext4_unregister_li_request(struct super_block *sb);\n\nstatic void __save_error_info(struct super_block *sb, const char *func,\n\t\t\t    unsigned int line)\n{\n\tstruct ext4_super_block *es = EXT4_SB(sb)->s_es;\n\n\tEXT4_SB(sb)->s_mount_state |= EXT4_ERROR_FS;\n\tes->s_state |= cpu_to_le16(EXT4_ERROR_FS);\n\tes->s_last_error_time = cpu_to_le32(get_seconds());\n\tstrncpy(es->s_last_error_func, func, sizeof(es->s_last_error_func));\n\tes->s_last_error_line = cpu_to_le32(line);\n\tif (!es->s_first_error_time) {\n\t\tes->s_first_error_time = es->s_last_error_time;\n\t\tstrncpy(es->s_first_error_func, func,\n\t\t\tsizeof(es->s_first_error_func));\n\t\tes->s_first_error_line = cpu_to_le32(line);\n\t\tes->s_first_error_ino = es->s_last_error_ino;\n\t\tes->s_first_error_block = es->s_last_error_block;\n\t}\n\t/*\n\t * Start the daily error reporting function if it hasn't been\n\t * started already\n\t */\n\tif (!es->s_error_count)\n\t\tmod_timer(&EXT4_SB(sb)->s_err_report, jiffies + 24*60*60*HZ);\n\tle32_add_cpu(&es->s_error_count, 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_le64",
          "args": [
            "block"
          ],
          "line": 639
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "ino"
          ],
          "line": 638
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXT4_SB",
          "args": [
            "sb"
          ],
          "line": 636
        },
        "resolved": true,
        "details": {
          "function_name": "EXT4_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ext4.h",
          "lines": "1356-1359",
          "snippet": "static inline struct ext4_sb_info *EXT4_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include \"extents_status.h\"",
            "#include <linux/compat.h>",
            "#include <linux/falloc.h>",
            "#include <crypto/hash.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/wait.h>",
            "#include <linux/timer.h>",
            "#include <linux/mutex.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/quota.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extents_status.h\"\n#include <linux/compat.h>\n#include <linux/falloc.h>\n#include <crypto/hash.h>\n#include <linux/ratelimit.h>\n#include <linux/percpu_counter.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/wait.h>\n#include <linux/timer.h>\n#include <linux/mutex.h>\n#include <linux/seqlock.h>\n#include <linux/rbtree.h>\n#include <linux/rwsem.h>\n#include <linux/quota.h>\n#include <linux/jbd2.h>\n#include <linux/magic.h>\n#include <linux/blkdev.h>\n#include <linux/types.h>\n\nstatic inline struct ext4_sb_info *EXT4_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      },
      {
        "call_info": {
          "callee": "__acquires",
          "args": [
            "bitlock"
          ],
          "line": 632
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__releases",
          "args": [
            "bitlock"
          ],
          "line": 631
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"mballoc.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4_extents.h\"\t/* Needed for trace points definition */\n#include \"ext4.h\"\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <asm/uaccess.h>\n#include <linux/cleancache.h>\n#include <linux/crc16.h>\n#include <linux/log2.h>\n#include <linux/ctype.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/random.h>\n#include <linux/vfs.h>\n#include <linux/exportfs.h>\n#include <linux/buffer_head.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/jbd2.h>\n#include <linux/vmalloc.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n#include <linux/string.h>\n#include <linux/module.h>\n\nstatic void ext4_mark_recovery_complete(struct super_block *sb,\n\t\t\t\t\tstruct ext4_super_block *es);\nstatic void ext4_clear_journal_err(struct super_block *sb,\n\t\t\t\t   struct ext4_super_block *es);\nstatic int ext4_unfreeze(struct super_block *sb);\nstatic int ext4_freeze(struct super_block *sb);\nstatic inline int ext2_feature_set_ok(struct super_block *sb);\nstatic inline int ext3_feature_set_ok(struct super_block *sb);\nstatic void ext4_unregister_li_request(struct super_block *sb);\nstatic int ext4_reserve_clusters(struct ext4_sb_info *, ext4_fsblk_t);\n\nvoid __ext4_grp_locked_error(const char *function, unsigned int line,\n\t\t\t     struct super_block *sb, ext4_group_t grp,\n\t\t\t     unsigned long ino, ext4_fsblk_t block,\n\t\t\t     const char *fmt, ...)\n__releases(bitlock)\n__acquires(bitlock)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\tstruct ext4_super_block *es = EXT4_SB(sb)->s_es;\n\n\tes->s_last_error_ino = cpu_to_le32(ino);\n\tes->s_last_error_block = cpu_to_le64(block);\n\t__save_error_info(sb, function, line);\n\n\tif (ext4_error_ratelimit(sb)) {\n\t\tva_start(args, fmt);\n\t\tvaf.fmt = fmt;\n\t\tvaf.va = &args;\n\t\tprintk(KERN_CRIT \"EXT4-fs error (device %s): %s:%d: group %u, \",\n\t\t       sb->s_id, function, line, grp);\n\t\tif (ino)\n\t\t\tprintk(KERN_CONT \"inode %lu: \", ino);\n\t\tif (block)\n\t\t\tprintk(KERN_CONT \"block %llu:\",\n\t\t\t       (unsigned long long) block);\n\t\tprintk(KERN_CONT \"%pV\\n\", &vaf);\n\t\tva_end(args);\n\t}\n\n\tif (test_opt(sb, ERRORS_CONT)) {\n\t\text4_commit_super(sb, 0);\n\t\treturn;\n\t}\n\n\text4_unlock_group(sb, grp);\n\text4_handle_error(sb);\n\t/*\n\t * We only get here in the ERRORS_RO case; relocking the group\n\t * may be dangerous, but nothing bad will happen since the\n\t * filesystem will have already been marked read/only and the\n\t * journal has been aborted.  We return 1 as a hint to callers\n\t * who might what to use the return value from\n\t * ext4_grp_locked_error() to distinguish between the\n\t * ERRORS_CONT and ERRORS_RO case, and perhaps return more\n\t * aggressively from the ext4 function in question, with a\n\t * more appropriate error code.\n\t */\n\text4_lock_group(sb, grp);\n\treturn;\n}"
  },
  {
    "function_name": "__ext4_warning",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/super.c",
    "lines": "609-625",
    "snippet": "void __ext4_warning(struct super_block *sb, const char *function,\n\t\t    unsigned int line, const char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tif (!___ratelimit(&(EXT4_SB(sb)->s_warning_ratelimit_state),\n\t\t\t  \"EXT4-fs warning\"))\n\t\treturn;\n\n\tva_start(args, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\tprintk(KERN_WARNING \"EXT4-fs warning (device %s): %s:%d: %pV\\n\",\n\t       sb->s_id, function, line, &vaf);\n\tva_end(args);\n}",
    "includes": [
      "#include <trace/events/ext4.h>",
      "#include \"mballoc.h\"",
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"ext4_jbd2.h\"",
      "#include \"ext4_extents.h\"\t/* Needed for trace points definition */",
      "#include \"ext4.h\"",
      "#include <linux/freezer.h>",
      "#include <linux/kthread.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/cleancache.h>",
      "#include <linux/crc16.h>",
      "#include <linux/log2.h>",
      "#include <linux/ctype.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/namei.h>",
      "#include <linux/mount.h>",
      "#include <linux/random.h>",
      "#include <linux/vfs.h>",
      "#include <linux/exportfs.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/parser.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/init.h>",
      "#include <linux/slab.h>",
      "#include <linux/jbd2.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/time.h>",
      "#include <linux/fs.h>",
      "#include <linux/string.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ext4_unfreeze(struct super_block *sb);",
      "static int ext4_freeze(struct super_block *sb);",
      "static inline int ext2_feature_set_ok(struct super_block *sb);",
      "static inline int ext3_feature_set_ok(struct super_block *sb);",
      "static void ext4_unregister_li_request(struct super_block *sb);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "va_end",
          "args": [
            "args"
          ],
          "line": 624
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_WARNING \"EXT4-fs warning (device %s): %s:%d: %pV\\n\"",
            "sb->s_id",
            "function",
            "line",
            "&vaf"
          ],
          "line": 622
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_printk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/super.c",
          "lines": "186-213",
          "snippet": "void btrfs_printk(const struct btrfs_fs_info *fs_info, const char *fmt, ...)\n{\n\tstruct super_block *sb = fs_info->sb;\n\tchar lvl[4];\n\tstruct va_format vaf;\n\tva_list args;\n\tconst char *type = logtypes[4];\n\tint kern_level;\n\n\tva_start(args, fmt);\n\n\tkern_level = printk_get_level(fmt);\n\tif (kern_level) {\n\t\tsize_t size = printk_skip_level(fmt) - fmt;\n\t\tmemcpy(lvl, fmt,  size);\n\t\tlvl[size] = '\\0';\n\t\tfmt += size;\n\t\ttype = logtypes[kern_level - '0'];\n\t} else\n\t\t*lvl = '\\0';\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\tprintk(\"%sBTRFS %s (device %s): %pV\\n\", lvl, type, sb->s_id, &vaf);\n\n\tva_end(args);\n}",
          "includes": [
            "#include <trace/events/btrfs.h>",
            "#include \"qgroup.h\"",
            "#include \"tests/btrfs-tests.h\"",
            "#include \"backref.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"dev-replace.h\"",
            "#include \"rcu-string.h\"",
            "#include \"compression.h\"",
            "#include \"export.h\"",
            "#include \"volumes.h\"",
            "#include \"xattr.h\"",
            "#include \"props.h\"",
            "#include \"hash.h\"",
            "#include \"print-tree.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include \"delayed-inode.h\"",
            "#include <linux/btrfs.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/slab.h>",
            "#include <linux/magic.h>",
            "#include <linux/miscdevice.h>",
            "#include <linux/namei.h>",
            "#include <linux/ctype.h>",
            "#include <linux/parser.h>",
            "#include <linux/compat.h>",
            "#include <linux/statfs.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/mpage.h>",
            "#include <linux/mount.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/string.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/init.h>",
            "#include <linux/time.h>",
            "#include <linux/highmem.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/module.h>",
            "#include <linux/blkdev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/btrfs.h>\n#include \"qgroup.h\"\n#include \"tests/btrfs-tests.h\"\n#include \"backref.h\"\n#include \"free-space-cache.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"compression.h\"\n#include \"export.h\"\n#include \"volumes.h\"\n#include \"xattr.h\"\n#include \"props.h\"\n#include \"hash.h\"\n#include \"print-tree.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include \"delayed-inode.h\"\n#include <linux/btrfs.h>\n#include <linux/ratelimit.h>\n#include <linux/cleancache.h>\n#include <linux/slab.h>\n#include <linux/magic.h>\n#include <linux/miscdevice.h>\n#include <linux/namei.h>\n#include <linux/ctype.h>\n#include <linux/parser.h>\n#include <linux/compat.h>\n#include <linux/statfs.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/mpage.h>\n#include <linux/mount.h>\n#include <linux/backing-dev.h>\n#include <linux/string.h>\n#include <linux/seq_file.h>\n#include <linux/init.h>\n#include <linux/time.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n#include <linux/buffer_head.h>\n#include <linux/module.h>\n#include <linux/blkdev.h>\n\nvoid btrfs_printk(const struct btrfs_fs_info *fs_info, const char *fmt, ...)\n{\n\tstruct super_block *sb = fs_info->sb;\n\tchar lvl[4];\n\tstruct va_format vaf;\n\tva_list args;\n\tconst char *type = logtypes[4];\n\tint kern_level;\n\n\tva_start(args, fmt);\n\n\tkern_level = printk_get_level(fmt);\n\tif (kern_level) {\n\t\tsize_t size = printk_skip_level(fmt) - fmt;\n\t\tmemcpy(lvl, fmt,  size);\n\t\tlvl[size] = '\\0';\n\t\tfmt += size;\n\t\ttype = logtypes[kern_level - '0'];\n\t} else\n\t\t*lvl = '\\0';\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\tprintk(\"%sBTRFS %s (device %s): %pV\\n\", lvl, type, sb->s_id, &vaf);\n\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "va_start",
          "args": [
            "args",
            "fmt"
          ],
          "line": 619
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "___ratelimit",
          "args": [
            "&(EXT4_SB(sb)->s_warning_ratelimit_state)",
            "\"EXT4-fs warning\""
          ],
          "line": 615
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXT4_SB",
          "args": [
            "sb"
          ],
          "line": 615
        },
        "resolved": true,
        "details": {
          "function_name": "EXT4_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ext4.h",
          "lines": "1356-1359",
          "snippet": "static inline struct ext4_sb_info *EXT4_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include \"extents_status.h\"",
            "#include <linux/compat.h>",
            "#include <linux/falloc.h>",
            "#include <crypto/hash.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/wait.h>",
            "#include <linux/timer.h>",
            "#include <linux/mutex.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/quota.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extents_status.h\"\n#include <linux/compat.h>\n#include <linux/falloc.h>\n#include <crypto/hash.h>\n#include <linux/ratelimit.h>\n#include <linux/percpu_counter.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/wait.h>\n#include <linux/timer.h>\n#include <linux/mutex.h>\n#include <linux/seqlock.h>\n#include <linux/rbtree.h>\n#include <linux/rwsem.h>\n#include <linux/quota.h>\n#include <linux/jbd2.h>\n#include <linux/magic.h>\n#include <linux/blkdev.h>\n#include <linux/types.h>\n\nstatic inline struct ext4_sb_info *EXT4_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"mballoc.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4_extents.h\"\t/* Needed for trace points definition */\n#include \"ext4.h\"\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <asm/uaccess.h>\n#include <linux/cleancache.h>\n#include <linux/crc16.h>\n#include <linux/log2.h>\n#include <linux/ctype.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/random.h>\n#include <linux/vfs.h>\n#include <linux/exportfs.h>\n#include <linux/buffer_head.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/jbd2.h>\n#include <linux/vmalloc.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n#include <linux/string.h>\n#include <linux/module.h>\n\nstatic int ext4_unfreeze(struct super_block *sb);\nstatic int ext4_freeze(struct super_block *sb);\nstatic inline int ext2_feature_set_ok(struct super_block *sb);\nstatic inline int ext3_feature_set_ok(struct super_block *sb);\nstatic void ext4_unregister_li_request(struct super_block *sb);\n\nvoid __ext4_warning(struct super_block *sb, const char *function,\n\t\t    unsigned int line, const char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tif (!___ratelimit(&(EXT4_SB(sb)->s_warning_ratelimit_state),\n\t\t\t  \"EXT4-fs warning\"))\n\t\treturn;\n\n\tva_start(args, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\tprintk(KERN_WARNING \"EXT4-fs warning (device %s): %s:%d: %pV\\n\",\n\t       sb->s_id, function, line, &vaf);\n\tva_end(args);\n}"
  },
  {
    "function_name": "__ext4_msg",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/super.c",
    "lines": "593-607",
    "snippet": "void __ext4_msg(struct super_block *sb,\n\t\tconst char *prefix, const char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tif (!___ratelimit(&(EXT4_SB(sb)->s_msg_ratelimit_state), \"EXT4-fs\"))\n\t\treturn;\n\n\tva_start(args, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\tprintk(\"%sEXT4-fs (%s): %pV\\n\", prefix, sb->s_id, &vaf);\n\tva_end(args);\n}",
    "includes": [
      "#include <trace/events/ext4.h>",
      "#include \"mballoc.h\"",
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"ext4_jbd2.h\"",
      "#include \"ext4_extents.h\"\t/* Needed for trace points definition */",
      "#include \"ext4.h\"",
      "#include <linux/freezer.h>",
      "#include <linux/kthread.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/cleancache.h>",
      "#include <linux/crc16.h>",
      "#include <linux/log2.h>",
      "#include <linux/ctype.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/namei.h>",
      "#include <linux/mount.h>",
      "#include <linux/random.h>",
      "#include <linux/vfs.h>",
      "#include <linux/exportfs.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/parser.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/init.h>",
      "#include <linux/slab.h>",
      "#include <linux/jbd2.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/time.h>",
      "#include <linux/fs.h>",
      "#include <linux/string.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ext4_unfreeze(struct super_block *sb);",
      "static int ext4_freeze(struct super_block *sb);",
      "static inline int ext2_feature_set_ok(struct super_block *sb);",
      "static inline int ext3_feature_set_ok(struct super_block *sb);",
      "static void ext4_unregister_li_request(struct super_block *sb);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "va_end",
          "args": [
            "args"
          ],
          "line": 606
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "\"%sEXT4-fs (%s): %pV\\n\"",
            "prefix",
            "sb->s_id",
            "&vaf"
          ],
          "line": 605
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_printk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/super.c",
          "lines": "186-213",
          "snippet": "void btrfs_printk(const struct btrfs_fs_info *fs_info, const char *fmt, ...)\n{\n\tstruct super_block *sb = fs_info->sb;\n\tchar lvl[4];\n\tstruct va_format vaf;\n\tva_list args;\n\tconst char *type = logtypes[4];\n\tint kern_level;\n\n\tva_start(args, fmt);\n\n\tkern_level = printk_get_level(fmt);\n\tif (kern_level) {\n\t\tsize_t size = printk_skip_level(fmt) - fmt;\n\t\tmemcpy(lvl, fmt,  size);\n\t\tlvl[size] = '\\0';\n\t\tfmt += size;\n\t\ttype = logtypes[kern_level - '0'];\n\t} else\n\t\t*lvl = '\\0';\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\tprintk(\"%sBTRFS %s (device %s): %pV\\n\", lvl, type, sb->s_id, &vaf);\n\n\tva_end(args);\n}",
          "includes": [
            "#include <trace/events/btrfs.h>",
            "#include \"qgroup.h\"",
            "#include \"tests/btrfs-tests.h\"",
            "#include \"backref.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"dev-replace.h\"",
            "#include \"rcu-string.h\"",
            "#include \"compression.h\"",
            "#include \"export.h\"",
            "#include \"volumes.h\"",
            "#include \"xattr.h\"",
            "#include \"props.h\"",
            "#include \"hash.h\"",
            "#include \"print-tree.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include \"delayed-inode.h\"",
            "#include <linux/btrfs.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/slab.h>",
            "#include <linux/magic.h>",
            "#include <linux/miscdevice.h>",
            "#include <linux/namei.h>",
            "#include <linux/ctype.h>",
            "#include <linux/parser.h>",
            "#include <linux/compat.h>",
            "#include <linux/statfs.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/mpage.h>",
            "#include <linux/mount.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/string.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/init.h>",
            "#include <linux/time.h>",
            "#include <linux/highmem.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/module.h>",
            "#include <linux/blkdev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/btrfs.h>\n#include \"qgroup.h\"\n#include \"tests/btrfs-tests.h\"\n#include \"backref.h\"\n#include \"free-space-cache.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"compression.h\"\n#include \"export.h\"\n#include \"volumes.h\"\n#include \"xattr.h\"\n#include \"props.h\"\n#include \"hash.h\"\n#include \"print-tree.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include \"delayed-inode.h\"\n#include <linux/btrfs.h>\n#include <linux/ratelimit.h>\n#include <linux/cleancache.h>\n#include <linux/slab.h>\n#include <linux/magic.h>\n#include <linux/miscdevice.h>\n#include <linux/namei.h>\n#include <linux/ctype.h>\n#include <linux/parser.h>\n#include <linux/compat.h>\n#include <linux/statfs.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/mpage.h>\n#include <linux/mount.h>\n#include <linux/backing-dev.h>\n#include <linux/string.h>\n#include <linux/seq_file.h>\n#include <linux/init.h>\n#include <linux/time.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n#include <linux/buffer_head.h>\n#include <linux/module.h>\n#include <linux/blkdev.h>\n\nvoid btrfs_printk(const struct btrfs_fs_info *fs_info, const char *fmt, ...)\n{\n\tstruct super_block *sb = fs_info->sb;\n\tchar lvl[4];\n\tstruct va_format vaf;\n\tva_list args;\n\tconst char *type = logtypes[4];\n\tint kern_level;\n\n\tva_start(args, fmt);\n\n\tkern_level = printk_get_level(fmt);\n\tif (kern_level) {\n\t\tsize_t size = printk_skip_level(fmt) - fmt;\n\t\tmemcpy(lvl, fmt,  size);\n\t\tlvl[size] = '\\0';\n\t\tfmt += size;\n\t\ttype = logtypes[kern_level - '0'];\n\t} else\n\t\t*lvl = '\\0';\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\tprintk(\"%sBTRFS %s (device %s): %pV\\n\", lvl, type, sb->s_id, &vaf);\n\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "va_start",
          "args": [
            "args",
            "fmt"
          ],
          "line": 602
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "___ratelimit",
          "args": [
            "&(EXT4_SB(sb)->s_msg_ratelimit_state)",
            "\"EXT4-fs\""
          ],
          "line": 599
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXT4_SB",
          "args": [
            "sb"
          ],
          "line": 599
        },
        "resolved": true,
        "details": {
          "function_name": "EXT4_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ext4.h",
          "lines": "1356-1359",
          "snippet": "static inline struct ext4_sb_info *EXT4_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include \"extents_status.h\"",
            "#include <linux/compat.h>",
            "#include <linux/falloc.h>",
            "#include <crypto/hash.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/wait.h>",
            "#include <linux/timer.h>",
            "#include <linux/mutex.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/quota.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extents_status.h\"\n#include <linux/compat.h>\n#include <linux/falloc.h>\n#include <crypto/hash.h>\n#include <linux/ratelimit.h>\n#include <linux/percpu_counter.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/wait.h>\n#include <linux/timer.h>\n#include <linux/mutex.h>\n#include <linux/seqlock.h>\n#include <linux/rbtree.h>\n#include <linux/rwsem.h>\n#include <linux/quota.h>\n#include <linux/jbd2.h>\n#include <linux/magic.h>\n#include <linux/blkdev.h>\n#include <linux/types.h>\n\nstatic inline struct ext4_sb_info *EXT4_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"mballoc.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4_extents.h\"\t/* Needed for trace points definition */\n#include \"ext4.h\"\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <asm/uaccess.h>\n#include <linux/cleancache.h>\n#include <linux/crc16.h>\n#include <linux/log2.h>\n#include <linux/ctype.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/random.h>\n#include <linux/vfs.h>\n#include <linux/exportfs.h>\n#include <linux/buffer_head.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/jbd2.h>\n#include <linux/vmalloc.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n#include <linux/string.h>\n#include <linux/module.h>\n\nstatic int ext4_unfreeze(struct super_block *sb);\nstatic int ext4_freeze(struct super_block *sb);\nstatic inline int ext2_feature_set_ok(struct super_block *sb);\nstatic inline int ext3_feature_set_ok(struct super_block *sb);\nstatic void ext4_unregister_li_request(struct super_block *sb);\n\nvoid __ext4_msg(struct super_block *sb,\n\t\tconst char *prefix, const char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tif (!___ratelimit(&(EXT4_SB(sb)->s_msg_ratelimit_state), \"EXT4-fs\"))\n\t\treturn;\n\n\tva_start(args, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\tprintk(\"%sEXT4-fs (%s): %pV\\n\", prefix, sb->s_id, &vaf);\n\tva_end(args);\n}"
  },
  {
    "function_name": "__ext4_abort",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/super.c",
    "lines": "563-591",
    "snippet": "void __ext4_abort(struct super_block *sb, const char *function,\n\t\tunsigned int line, const char *fmt, ...)\n{\n\tva_list args;\n\n\tsave_error_info(sb, function, line);\n\tva_start(args, fmt);\n\tprintk(KERN_CRIT \"EXT4-fs error (device %s): %s:%d: \", sb->s_id,\n\t       function, line);\n\tvprintk(fmt, args);\n\tprintk(\"\\n\");\n\tva_end(args);\n\n\tif ((sb->s_flags & MS_RDONLY) == 0) {\n\t\text4_msg(sb, KERN_CRIT, \"Remounting filesystem read-only\");\n\t\tEXT4_SB(sb)->s_mount_flags |= EXT4_MF_FS_ABORTED;\n\t\t/*\n\t\t * Make sure updated value of ->s_mount_flags will be visible\n\t\t * before ->s_flags update\n\t\t */\n\t\tsmp_wmb();\n\t\tsb->s_flags |= MS_RDONLY;\n\t\tif (EXT4_SB(sb)->s_journal)\n\t\t\tjbd2_journal_abort(EXT4_SB(sb)->s_journal, -EIO);\n\t\tsave_error_info(sb, function, line);\n\t}\n\tif (test_opt(sb, ERRORS_PANIC))\n\t\tpanic(\"EXT4-fs panic from previous error\\n\");\n}",
    "includes": [
      "#include <trace/events/ext4.h>",
      "#include \"mballoc.h\"",
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"ext4_jbd2.h\"",
      "#include \"ext4_extents.h\"\t/* Needed for trace points definition */",
      "#include \"ext4.h\"",
      "#include <linux/freezer.h>",
      "#include <linux/kthread.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/cleancache.h>",
      "#include <linux/crc16.h>",
      "#include <linux/log2.h>",
      "#include <linux/ctype.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/namei.h>",
      "#include <linux/mount.h>",
      "#include <linux/random.h>",
      "#include <linux/vfs.h>",
      "#include <linux/exportfs.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/parser.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/init.h>",
      "#include <linux/slab.h>",
      "#include <linux/jbd2.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/time.h>",
      "#include <linux/fs.h>",
      "#include <linux/string.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ext4_unfreeze(struct super_block *sb);",
      "static int ext4_freeze(struct super_block *sb);",
      "static inline int ext2_feature_set_ok(struct super_block *sb);",
      "static inline int ext3_feature_set_ok(struct super_block *sb);",
      "static void ext4_unregister_li_request(struct super_block *sb);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "panic",
          "args": [
            "\"EXT4-fs panic from previous error\\n\""
          ],
          "line": 590
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_opt",
          "args": [
            "sb",
            "ERRORS_PANIC"
          ],
          "line": 589
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "save_error_info",
          "args": [
            "sb",
            "function",
            "line"
          ],
          "line": 587
        },
        "resolved": true,
        "details": {
          "function_name": "save_error_info",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/super.c",
          "lines": "319-324",
          "snippet": "static void save_error_info(struct super_block *sb, const char *func,\n\t\t\t    unsigned int line)\n{\n\t__save_error_info(sb, func, line);\n\text4_commit_super(sb, 1);\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"mballoc.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include \"ext4_extents.h\"\t/* Needed for trace points definition */",
            "#include \"ext4.h\"",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/crc16.h>",
            "#include <linux/log2.h>",
            "#include <linux/ctype.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/random.h>",
            "#include <linux/vfs.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/parser.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/time.h>",
            "#include <linux/fs.h>",
            "#include <linux/string.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ext4_unfreeze(struct super_block *sb);",
            "static int ext4_freeze(struct super_block *sb);",
            "static inline int ext2_feature_set_ok(struct super_block *sb);",
            "static inline int ext3_feature_set_ok(struct super_block *sb);",
            "static void ext4_unregister_li_request(struct super_block *sb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"mballoc.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4_extents.h\"\t/* Needed for trace points definition */\n#include \"ext4.h\"\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <asm/uaccess.h>\n#include <linux/cleancache.h>\n#include <linux/crc16.h>\n#include <linux/log2.h>\n#include <linux/ctype.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/random.h>\n#include <linux/vfs.h>\n#include <linux/exportfs.h>\n#include <linux/buffer_head.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/jbd2.h>\n#include <linux/vmalloc.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n#include <linux/string.h>\n#include <linux/module.h>\n\nstatic int ext4_unfreeze(struct super_block *sb);\nstatic int ext4_freeze(struct super_block *sb);\nstatic inline int ext2_feature_set_ok(struct super_block *sb);\nstatic inline int ext3_feature_set_ok(struct super_block *sb);\nstatic void ext4_unregister_li_request(struct super_block *sb);\n\nstatic void save_error_info(struct super_block *sb, const char *func,\n\t\t\t    unsigned int line)\n{\n\t__save_error_info(sb, func, line);\n\text4_commit_super(sb, 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "jbd2_journal_abort",
          "args": [
            "EXT4_SB(sb)->s_journal",
            "-EIO"
          ],
          "line": 586
        },
        "resolved": true,
        "details": {
          "function_name": "jbd2_journal_abort",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd2/journal.c",
          "lines": "2106-2109",
          "snippet": "void jbd2_journal_abort(journal_t *journal, int errno)\n{\n\t__journal_abort_soft(journal, errno);\n}",
          "includes": [
            "#include <asm/page.h>",
            "#include <asm/uaccess.h>",
            "#include <trace/events/jbd2.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/bitops.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/log2.h>",
            "#include <linux/hash.h>",
            "#include <linux/math64.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/poison.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __journal_abort_soft (journal_t *journal, int errno);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <trace/events/jbd2.h>\n#include <linux/ratelimit.h>\n#include <linux/bitops.h>\n#include <linux/backing-dev.h>\n#include <linux/vmalloc.h>\n#include <linux/log2.h>\n#include <linux/hash.h>\n#include <linux/math64.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/poison.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/freezer.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd2.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/module.h>\n\nstatic void __journal_abort_soft (journal_t *journal, int errno);\n\nvoid jbd2_journal_abort(journal_t *journal, int errno)\n{\n\t__journal_abort_soft(journal, errno);\n}"
        }
      },
      {
        "call_info": {
          "callee": "EXT4_SB",
          "args": [
            "sb"
          ],
          "line": 586
        },
        "resolved": true,
        "details": {
          "function_name": "EXT4_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ext4.h",
          "lines": "1356-1359",
          "snippet": "static inline struct ext4_sb_info *EXT4_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include \"extents_status.h\"",
            "#include <linux/compat.h>",
            "#include <linux/falloc.h>",
            "#include <crypto/hash.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/wait.h>",
            "#include <linux/timer.h>",
            "#include <linux/mutex.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/quota.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extents_status.h\"\n#include <linux/compat.h>\n#include <linux/falloc.h>\n#include <crypto/hash.h>\n#include <linux/ratelimit.h>\n#include <linux/percpu_counter.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/wait.h>\n#include <linux/timer.h>\n#include <linux/mutex.h>\n#include <linux/seqlock.h>\n#include <linux/rbtree.h>\n#include <linux/rwsem.h>\n#include <linux/quota.h>\n#include <linux/jbd2.h>\n#include <linux/magic.h>\n#include <linux/blkdev.h>\n#include <linux/types.h>\n\nstatic inline struct ext4_sb_info *EXT4_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      },
      {
        "call_info": {
          "callee": "smp_wmb",
          "args": [],
          "line": 583
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_msg",
          "args": [
            "sb",
            "KERN_CRIT",
            "\"Remounting filesystem read-only\""
          ],
          "line": 577
        },
        "resolved": true,
        "details": {
          "function_name": "__ext4_msg",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/super.c",
          "lines": "593-607",
          "snippet": "void __ext4_msg(struct super_block *sb,\n\t\tconst char *prefix, const char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tif (!___ratelimit(&(EXT4_SB(sb)->s_msg_ratelimit_state), \"EXT4-fs\"))\n\t\treturn;\n\n\tva_start(args, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\tprintk(\"%sEXT4-fs (%s): %pV\\n\", prefix, sb->s_id, &vaf);\n\tva_end(args);\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"mballoc.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include \"ext4_extents.h\"\t/* Needed for trace points definition */",
            "#include \"ext4.h\"",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/crc16.h>",
            "#include <linux/log2.h>",
            "#include <linux/ctype.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/random.h>",
            "#include <linux/vfs.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/parser.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/time.h>",
            "#include <linux/fs.h>",
            "#include <linux/string.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ext4_unfreeze(struct super_block *sb);",
            "static int ext4_freeze(struct super_block *sb);",
            "static inline int ext2_feature_set_ok(struct super_block *sb);",
            "static inline int ext3_feature_set_ok(struct super_block *sb);",
            "static void ext4_unregister_li_request(struct super_block *sb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"mballoc.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4_extents.h\"\t/* Needed for trace points definition */\n#include \"ext4.h\"\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <asm/uaccess.h>\n#include <linux/cleancache.h>\n#include <linux/crc16.h>\n#include <linux/log2.h>\n#include <linux/ctype.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/random.h>\n#include <linux/vfs.h>\n#include <linux/exportfs.h>\n#include <linux/buffer_head.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/jbd2.h>\n#include <linux/vmalloc.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n#include <linux/string.h>\n#include <linux/module.h>\n\nstatic int ext4_unfreeze(struct super_block *sb);\nstatic int ext4_freeze(struct super_block *sb);\nstatic inline int ext2_feature_set_ok(struct super_block *sb);\nstatic inline int ext3_feature_set_ok(struct super_block *sb);\nstatic void ext4_unregister_li_request(struct super_block *sb);\n\nvoid __ext4_msg(struct super_block *sb,\n\t\tconst char *prefix, const char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tif (!___ratelimit(&(EXT4_SB(sb)->s_msg_ratelimit_state), \"EXT4-fs\"))\n\t\treturn;\n\n\tva_start(args, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\tprintk(\"%sEXT4-fs (%s): %pV\\n\", prefix, sb->s_id, &vaf);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "va_end",
          "args": [
            "args"
          ],
          "line": 574
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "\"\\n\""
          ],
          "line": 573
        },
        "resolved": true,
        "details": {
          "function_name": "compat_printk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/compat.c",
          "lines": "59-69",
          "snippet": "int compat_printk(const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\tif (!compat_log)\n\t\treturn 0;\n\tva_start(ap, fmt);\n\tret = vprintk(fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/ioctls.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/aio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/mm.h>",
            "#include <linux/poll.h>",
            "#include <linux/signal.h>",
            "#include <linux/highmem.h>",
            "#include <linux/security.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/personality.h>",
            "#include <linux/highuid.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/dirent.h>",
            "#include <linux/ctype.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/nfs4_mount.h>",
            "#include <linux/ncp_mount.h>",
            "#include <linux/init.h>",
            "#include <linux/ioctl.h>",
            "#include <linux/vfs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/namei.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/errno.h>",
            "#include <linux/compat.h>",
            "#include <linux/linkage.h>",
            "#include <linux/kernel.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int compat_log = 1;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/ioctls.h>\n#include <asm/mmu_context.h>\n#include <asm/uaccess.h>\n#include <linux/aio.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/fs_struct.h>\n#include <linux/mm.h>\n#include <linux/poll.h>\n#include <linux/signal.h>\n#include <linux/highmem.h>\n#include <linux/security.h>\n#include <linux/tsacct_kern.h>\n#include <linux/rwsem.h>\n#include <linux/personality.h>\n#include <linux/highuid.h>\n#include <linux/fsnotify.h>\n#include <linux/dirent.h>\n#include <linux/ctype.h>\n#include <linux/syscalls.h>\n#include <linux/nfs4_mount.h>\n#include <linux/ncp_mount.h>\n#include <linux/init.h>\n#include <linux/ioctl.h>\n#include <linux/vfs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/namei.h>\n#include <linux/fcntl.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <linux/compat.h>\n#include <linux/linkage.h>\n#include <linux/kernel.h>\n#include <linux/stddef.h>\n\nint compat_log = 1;\n\nint compat_printk(const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\tif (!compat_log)\n\t\treturn 0;\n\tva_start(ap, fmt);\n\tret = vprintk(fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "vprintk",
          "args": [
            "fmt",
            "args"
          ],
          "line": 572
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_CRIT \"EXT4-fs error (device %s): %s:%d: \"",
            "sb->s_id",
            "function",
            "line"
          ],
          "line": 570
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_printk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/super.c",
          "lines": "186-213",
          "snippet": "void btrfs_printk(const struct btrfs_fs_info *fs_info, const char *fmt, ...)\n{\n\tstruct super_block *sb = fs_info->sb;\n\tchar lvl[4];\n\tstruct va_format vaf;\n\tva_list args;\n\tconst char *type = logtypes[4];\n\tint kern_level;\n\n\tva_start(args, fmt);\n\n\tkern_level = printk_get_level(fmt);\n\tif (kern_level) {\n\t\tsize_t size = printk_skip_level(fmt) - fmt;\n\t\tmemcpy(lvl, fmt,  size);\n\t\tlvl[size] = '\\0';\n\t\tfmt += size;\n\t\ttype = logtypes[kern_level - '0'];\n\t} else\n\t\t*lvl = '\\0';\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\tprintk(\"%sBTRFS %s (device %s): %pV\\n\", lvl, type, sb->s_id, &vaf);\n\n\tva_end(args);\n}",
          "includes": [
            "#include <trace/events/btrfs.h>",
            "#include \"qgroup.h\"",
            "#include \"tests/btrfs-tests.h\"",
            "#include \"backref.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"dev-replace.h\"",
            "#include \"rcu-string.h\"",
            "#include \"compression.h\"",
            "#include \"export.h\"",
            "#include \"volumes.h\"",
            "#include \"xattr.h\"",
            "#include \"props.h\"",
            "#include \"hash.h\"",
            "#include \"print-tree.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include \"delayed-inode.h\"",
            "#include <linux/btrfs.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/slab.h>",
            "#include <linux/magic.h>",
            "#include <linux/miscdevice.h>",
            "#include <linux/namei.h>",
            "#include <linux/ctype.h>",
            "#include <linux/parser.h>",
            "#include <linux/compat.h>",
            "#include <linux/statfs.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/mpage.h>",
            "#include <linux/mount.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/string.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/init.h>",
            "#include <linux/time.h>",
            "#include <linux/highmem.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/module.h>",
            "#include <linux/blkdev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/btrfs.h>\n#include \"qgroup.h\"\n#include \"tests/btrfs-tests.h\"\n#include \"backref.h\"\n#include \"free-space-cache.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"compression.h\"\n#include \"export.h\"\n#include \"volumes.h\"\n#include \"xattr.h\"\n#include \"props.h\"\n#include \"hash.h\"\n#include \"print-tree.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include \"delayed-inode.h\"\n#include <linux/btrfs.h>\n#include <linux/ratelimit.h>\n#include <linux/cleancache.h>\n#include <linux/slab.h>\n#include <linux/magic.h>\n#include <linux/miscdevice.h>\n#include <linux/namei.h>\n#include <linux/ctype.h>\n#include <linux/parser.h>\n#include <linux/compat.h>\n#include <linux/statfs.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/mpage.h>\n#include <linux/mount.h>\n#include <linux/backing-dev.h>\n#include <linux/string.h>\n#include <linux/seq_file.h>\n#include <linux/init.h>\n#include <linux/time.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n#include <linux/buffer_head.h>\n#include <linux/module.h>\n#include <linux/blkdev.h>\n\nvoid btrfs_printk(const struct btrfs_fs_info *fs_info, const char *fmt, ...)\n{\n\tstruct super_block *sb = fs_info->sb;\n\tchar lvl[4];\n\tstruct va_format vaf;\n\tva_list args;\n\tconst char *type = logtypes[4];\n\tint kern_level;\n\n\tva_start(args, fmt);\n\n\tkern_level = printk_get_level(fmt);\n\tif (kern_level) {\n\t\tsize_t size = printk_skip_level(fmt) - fmt;\n\t\tmemcpy(lvl, fmt,  size);\n\t\tlvl[size] = '\\0';\n\t\tfmt += size;\n\t\ttype = logtypes[kern_level - '0'];\n\t} else\n\t\t*lvl = '\\0';\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\tprintk(\"%sBTRFS %s (device %s): %pV\\n\", lvl, type, sb->s_id, &vaf);\n\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "va_start",
          "args": [
            "args",
            "fmt"
          ],
          "line": 569
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"mballoc.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4_extents.h\"\t/* Needed for trace points definition */\n#include \"ext4.h\"\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <asm/uaccess.h>\n#include <linux/cleancache.h>\n#include <linux/crc16.h>\n#include <linux/log2.h>\n#include <linux/ctype.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/random.h>\n#include <linux/vfs.h>\n#include <linux/exportfs.h>\n#include <linux/buffer_head.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/jbd2.h>\n#include <linux/vmalloc.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n#include <linux/string.h>\n#include <linux/module.h>\n\nstatic int ext4_unfreeze(struct super_block *sb);\nstatic int ext4_freeze(struct super_block *sb);\nstatic inline int ext2_feature_set_ok(struct super_block *sb);\nstatic inline int ext3_feature_set_ok(struct super_block *sb);\nstatic void ext4_unregister_li_request(struct super_block *sb);\n\nvoid __ext4_abort(struct super_block *sb, const char *function,\n\t\tunsigned int line, const char *fmt, ...)\n{\n\tva_list args;\n\n\tsave_error_info(sb, function, line);\n\tva_start(args, fmt);\n\tprintk(KERN_CRIT \"EXT4-fs error (device %s): %s:%d: \", sb->s_id,\n\t       function, line);\n\tvprintk(fmt, args);\n\tprintk(\"\\n\");\n\tva_end(args);\n\n\tif ((sb->s_flags & MS_RDONLY) == 0) {\n\t\text4_msg(sb, KERN_CRIT, \"Remounting filesystem read-only\");\n\t\tEXT4_SB(sb)->s_mount_flags |= EXT4_MF_FS_ABORTED;\n\t\t/*\n\t\t * Make sure updated value of ->s_mount_flags will be visible\n\t\t * before ->s_flags update\n\t\t */\n\t\tsmp_wmb();\n\t\tsb->s_flags |= MS_RDONLY;\n\t\tif (EXT4_SB(sb)->s_journal)\n\t\t\tjbd2_journal_abort(EXT4_SB(sb)->s_journal, -EIO);\n\t\tsave_error_info(sb, function, line);\n\t}\n\tif (test_opt(sb, ERRORS_PANIC))\n\t\tpanic(\"EXT4-fs panic from previous error\\n\");\n}"
  },
  {
    "function_name": "__ext4_std_error",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/super.c",
    "lines": "530-551",
    "snippet": "void __ext4_std_error(struct super_block *sb, const char *function,\n\t\t      unsigned int line, int errno)\n{\n\tchar nbuf[16];\n\tconst char *errstr;\n\n\t/* Special case: if the error is EROFS, and we're not already\n\t * inside a transaction, then there's really no point in logging\n\t * an error. */\n\tif (errno == -EROFS && journal_current_handle() == NULL &&\n\t    (sb->s_flags & MS_RDONLY))\n\t\treturn;\n\n\tif (ext4_error_ratelimit(sb)) {\n\t\terrstr = ext4_decode_error(sb, errno, nbuf);\n\t\tprintk(KERN_CRIT \"EXT4-fs error (device %s) in %s:%d: %s\\n\",\n\t\t       sb->s_id, function, line, errstr);\n\t}\n\n\tsave_error_info(sb, function, line);\n\text4_handle_error(sb);\n}",
    "includes": [
      "#include <trace/events/ext4.h>",
      "#include \"mballoc.h\"",
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"ext4_jbd2.h\"",
      "#include \"ext4_extents.h\"\t/* Needed for trace points definition */",
      "#include \"ext4.h\"",
      "#include <linux/freezer.h>",
      "#include <linux/kthread.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/cleancache.h>",
      "#include <linux/crc16.h>",
      "#include <linux/log2.h>",
      "#include <linux/ctype.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/namei.h>",
      "#include <linux/mount.h>",
      "#include <linux/random.h>",
      "#include <linux/vfs.h>",
      "#include <linux/exportfs.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/parser.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/init.h>",
      "#include <linux/slab.h>",
      "#include <linux/jbd2.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/time.h>",
      "#include <linux/fs.h>",
      "#include <linux/string.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ext4_unfreeze(struct super_block *sb);",
      "static int ext4_freeze(struct super_block *sb);",
      "static inline int ext2_feature_set_ok(struct super_block *sb);",
      "static inline int ext3_feature_set_ok(struct super_block *sb);",
      "static void ext4_unregister_li_request(struct super_block *sb);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ext4_handle_error",
          "args": [
            "sb"
          ],
          "line": 550
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_handle_error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/super.c",
          "lines": "377-401",
          "snippet": "static void ext4_handle_error(struct super_block *sb)\n{\n\tif (sb->s_flags & MS_RDONLY)\n\t\treturn;\n\n\tif (!test_opt(sb, ERRORS_CONT)) {\n\t\tjournal_t *journal = EXT4_SB(sb)->s_journal;\n\n\t\tEXT4_SB(sb)->s_mount_flags |= EXT4_MF_FS_ABORTED;\n\t\tif (journal)\n\t\t\tjbd2_journal_abort(journal, -EIO);\n\t}\n\tif (test_opt(sb, ERRORS_RO)) {\n\t\text4_msg(sb, KERN_CRIT, \"Remounting filesystem read-only\");\n\t\t/*\n\t\t * Make sure updated value of ->s_mount_flags will be visible\n\t\t * before ->s_flags update\n\t\t */\n\t\tsmp_wmb();\n\t\tsb->s_flags |= MS_RDONLY;\n\t}\n\tif (test_opt(sb, ERRORS_PANIC))\n\t\tpanic(\"EXT4-fs (device %s): panic forced after error\\n\",\n\t\t\tsb->s_id);\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"mballoc.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include \"ext4_extents.h\"\t/* Needed for trace points definition */",
            "#include \"ext4.h\"",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/crc16.h>",
            "#include <linux/log2.h>",
            "#include <linux/ctype.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/random.h>",
            "#include <linux/vfs.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/parser.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/time.h>",
            "#include <linux/fs.h>",
            "#include <linux/string.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ext4_unfreeze(struct super_block *sb);",
            "static int ext4_freeze(struct super_block *sb);",
            "static inline int ext2_feature_set_ok(struct super_block *sb);",
            "static inline int ext3_feature_set_ok(struct super_block *sb);",
            "static void ext4_unregister_li_request(struct super_block *sb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"mballoc.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4_extents.h\"\t/* Needed for trace points definition */\n#include \"ext4.h\"\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <asm/uaccess.h>\n#include <linux/cleancache.h>\n#include <linux/crc16.h>\n#include <linux/log2.h>\n#include <linux/ctype.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/random.h>\n#include <linux/vfs.h>\n#include <linux/exportfs.h>\n#include <linux/buffer_head.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/jbd2.h>\n#include <linux/vmalloc.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n#include <linux/string.h>\n#include <linux/module.h>\n\nstatic int ext4_unfreeze(struct super_block *sb);\nstatic int ext4_freeze(struct super_block *sb);\nstatic inline int ext2_feature_set_ok(struct super_block *sb);\nstatic inline int ext3_feature_set_ok(struct super_block *sb);\nstatic void ext4_unregister_li_request(struct super_block *sb);\n\nstatic void ext4_handle_error(struct super_block *sb)\n{\n\tif (sb->s_flags & MS_RDONLY)\n\t\treturn;\n\n\tif (!test_opt(sb, ERRORS_CONT)) {\n\t\tjournal_t *journal = EXT4_SB(sb)->s_journal;\n\n\t\tEXT4_SB(sb)->s_mount_flags |= EXT4_MF_FS_ABORTED;\n\t\tif (journal)\n\t\t\tjbd2_journal_abort(journal, -EIO);\n\t}\n\tif (test_opt(sb, ERRORS_RO)) {\n\t\text4_msg(sb, KERN_CRIT, \"Remounting filesystem read-only\");\n\t\t/*\n\t\t * Make sure updated value of ->s_mount_flags will be visible\n\t\t * before ->s_flags update\n\t\t */\n\t\tsmp_wmb();\n\t\tsb->s_flags |= MS_RDONLY;\n\t}\n\tif (test_opt(sb, ERRORS_PANIC))\n\t\tpanic(\"EXT4-fs (device %s): panic forced after error\\n\",\n\t\t\tsb->s_id);\n}"
        }
      },
      {
        "call_info": {
          "callee": "save_error_info",
          "args": [
            "sb",
            "function",
            "line"
          ],
          "line": 549
        },
        "resolved": true,
        "details": {
          "function_name": "save_error_info",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/super.c",
          "lines": "319-324",
          "snippet": "static void save_error_info(struct super_block *sb, const char *func,\n\t\t\t    unsigned int line)\n{\n\t__save_error_info(sb, func, line);\n\text4_commit_super(sb, 1);\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"mballoc.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include \"ext4_extents.h\"\t/* Needed for trace points definition */",
            "#include \"ext4.h\"",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/crc16.h>",
            "#include <linux/log2.h>",
            "#include <linux/ctype.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/random.h>",
            "#include <linux/vfs.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/parser.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/time.h>",
            "#include <linux/fs.h>",
            "#include <linux/string.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ext4_unfreeze(struct super_block *sb);",
            "static int ext4_freeze(struct super_block *sb);",
            "static inline int ext2_feature_set_ok(struct super_block *sb);",
            "static inline int ext3_feature_set_ok(struct super_block *sb);",
            "static void ext4_unregister_li_request(struct super_block *sb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"mballoc.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4_extents.h\"\t/* Needed for trace points definition */\n#include \"ext4.h\"\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <asm/uaccess.h>\n#include <linux/cleancache.h>\n#include <linux/crc16.h>\n#include <linux/log2.h>\n#include <linux/ctype.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/random.h>\n#include <linux/vfs.h>\n#include <linux/exportfs.h>\n#include <linux/buffer_head.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/jbd2.h>\n#include <linux/vmalloc.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n#include <linux/string.h>\n#include <linux/module.h>\n\nstatic int ext4_unfreeze(struct super_block *sb);\nstatic int ext4_freeze(struct super_block *sb);\nstatic inline int ext2_feature_set_ok(struct super_block *sb);\nstatic inline int ext3_feature_set_ok(struct super_block *sb);\nstatic void ext4_unregister_li_request(struct super_block *sb);\n\nstatic void save_error_info(struct super_block *sb, const char *func,\n\t\t\t    unsigned int line)\n{\n\t__save_error_info(sb, func, line);\n\text4_commit_super(sb, 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_CRIT \"EXT4-fs error (device %s) in %s:%d: %s\\n\"",
            "sb->s_id",
            "function",
            "line",
            "errstr"
          ],
          "line": 545
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_printk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/super.c",
          "lines": "186-213",
          "snippet": "void btrfs_printk(const struct btrfs_fs_info *fs_info, const char *fmt, ...)\n{\n\tstruct super_block *sb = fs_info->sb;\n\tchar lvl[4];\n\tstruct va_format vaf;\n\tva_list args;\n\tconst char *type = logtypes[4];\n\tint kern_level;\n\n\tva_start(args, fmt);\n\n\tkern_level = printk_get_level(fmt);\n\tif (kern_level) {\n\t\tsize_t size = printk_skip_level(fmt) - fmt;\n\t\tmemcpy(lvl, fmt,  size);\n\t\tlvl[size] = '\\0';\n\t\tfmt += size;\n\t\ttype = logtypes[kern_level - '0'];\n\t} else\n\t\t*lvl = '\\0';\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\tprintk(\"%sBTRFS %s (device %s): %pV\\n\", lvl, type, sb->s_id, &vaf);\n\n\tva_end(args);\n}",
          "includes": [
            "#include <trace/events/btrfs.h>",
            "#include \"qgroup.h\"",
            "#include \"tests/btrfs-tests.h\"",
            "#include \"backref.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"dev-replace.h\"",
            "#include \"rcu-string.h\"",
            "#include \"compression.h\"",
            "#include \"export.h\"",
            "#include \"volumes.h\"",
            "#include \"xattr.h\"",
            "#include \"props.h\"",
            "#include \"hash.h\"",
            "#include \"print-tree.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include \"delayed-inode.h\"",
            "#include <linux/btrfs.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/slab.h>",
            "#include <linux/magic.h>",
            "#include <linux/miscdevice.h>",
            "#include <linux/namei.h>",
            "#include <linux/ctype.h>",
            "#include <linux/parser.h>",
            "#include <linux/compat.h>",
            "#include <linux/statfs.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/mpage.h>",
            "#include <linux/mount.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/string.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/init.h>",
            "#include <linux/time.h>",
            "#include <linux/highmem.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/module.h>",
            "#include <linux/blkdev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/btrfs.h>\n#include \"qgroup.h\"\n#include \"tests/btrfs-tests.h\"\n#include \"backref.h\"\n#include \"free-space-cache.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"compression.h\"\n#include \"export.h\"\n#include \"volumes.h\"\n#include \"xattr.h\"\n#include \"props.h\"\n#include \"hash.h\"\n#include \"print-tree.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include \"delayed-inode.h\"\n#include <linux/btrfs.h>\n#include <linux/ratelimit.h>\n#include <linux/cleancache.h>\n#include <linux/slab.h>\n#include <linux/magic.h>\n#include <linux/miscdevice.h>\n#include <linux/namei.h>\n#include <linux/ctype.h>\n#include <linux/parser.h>\n#include <linux/compat.h>\n#include <linux/statfs.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/mpage.h>\n#include <linux/mount.h>\n#include <linux/backing-dev.h>\n#include <linux/string.h>\n#include <linux/seq_file.h>\n#include <linux/init.h>\n#include <linux/time.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n#include <linux/buffer_head.h>\n#include <linux/module.h>\n#include <linux/blkdev.h>\n\nvoid btrfs_printk(const struct btrfs_fs_info *fs_info, const char *fmt, ...)\n{\n\tstruct super_block *sb = fs_info->sb;\n\tchar lvl[4];\n\tstruct va_format vaf;\n\tva_list args;\n\tconst char *type = logtypes[4];\n\tint kern_level;\n\n\tva_start(args, fmt);\n\n\tkern_level = printk_get_level(fmt);\n\tif (kern_level) {\n\t\tsize_t size = printk_skip_level(fmt) - fmt;\n\t\tmemcpy(lvl, fmt,  size);\n\t\tlvl[size] = '\\0';\n\t\tfmt += size;\n\t\ttype = logtypes[kern_level - '0'];\n\t} else\n\t\t*lvl = '\\0';\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\tprintk(\"%sBTRFS %s (device %s): %pV\\n\", lvl, type, sb->s_id, &vaf);\n\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_decode_error",
          "args": [
            "sb",
            "errno",
            "nbuf"
          ],
          "line": 544
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_decode_error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/super.c",
          "lines": "493-525",
          "snippet": "const char *ext4_decode_error(struct super_block *sb, int errno,\n\t\t\t      char nbuf[16])\n{\n\tchar *errstr = NULL;\n\n\tswitch (errno) {\n\tcase -EIO:\n\t\terrstr = \"IO failure\";\n\t\tbreak;\n\tcase -ENOMEM:\n\t\terrstr = \"Out of memory\";\n\t\tbreak;\n\tcase -EROFS:\n\t\tif (!sb || (EXT4_SB(sb)->s_journal &&\n\t\t\t    EXT4_SB(sb)->s_journal->j_flags & JBD2_ABORT))\n\t\t\terrstr = \"Journal has aborted\";\n\t\telse\n\t\t\terrstr = \"Readonly filesystem\";\n\t\tbreak;\n\tdefault:\n\t\t/* If the caller passed in an extra buffer for unknown\n\t\t * errors, textualise them now.  Else we just return\n\t\t * NULL. */\n\t\tif (nbuf) {\n\t\t\t/* Check for truncated error codes... */\n\t\t\tif (snprintf(nbuf, 16, \"error %d\", -errno) >= 0)\n\t\t\t\terrstr = nbuf;\n\t\t}\n\t\tbreak;\n\t}\n\n\treturn errstr;\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"mballoc.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include \"ext4_extents.h\"\t/* Needed for trace points definition */",
            "#include \"ext4.h\"",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/crc16.h>",
            "#include <linux/log2.h>",
            "#include <linux/ctype.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/random.h>",
            "#include <linux/vfs.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/parser.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/time.h>",
            "#include <linux/fs.h>",
            "#include <linux/string.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ext4_unfreeze(struct super_block *sb);",
            "static int ext4_freeze(struct super_block *sb);",
            "static inline int ext2_feature_set_ok(struct super_block *sb);",
            "static inline int ext3_feature_set_ok(struct super_block *sb);",
            "static void ext4_unregister_li_request(struct super_block *sb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"mballoc.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4_extents.h\"\t/* Needed for trace points definition */\n#include \"ext4.h\"\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <asm/uaccess.h>\n#include <linux/cleancache.h>\n#include <linux/crc16.h>\n#include <linux/log2.h>\n#include <linux/ctype.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/random.h>\n#include <linux/vfs.h>\n#include <linux/exportfs.h>\n#include <linux/buffer_head.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/jbd2.h>\n#include <linux/vmalloc.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n#include <linux/string.h>\n#include <linux/module.h>\n\nstatic int ext4_unfreeze(struct super_block *sb);\nstatic int ext4_freeze(struct super_block *sb);\nstatic inline int ext2_feature_set_ok(struct super_block *sb);\nstatic inline int ext3_feature_set_ok(struct super_block *sb);\nstatic void ext4_unregister_li_request(struct super_block *sb);\n\nconst char *ext4_decode_error(struct super_block *sb, int errno,\n\t\t\t      char nbuf[16])\n{\n\tchar *errstr = NULL;\n\n\tswitch (errno) {\n\tcase -EIO:\n\t\terrstr = \"IO failure\";\n\t\tbreak;\n\tcase -ENOMEM:\n\t\terrstr = \"Out of memory\";\n\t\tbreak;\n\tcase -EROFS:\n\t\tif (!sb || (EXT4_SB(sb)->s_journal &&\n\t\t\t    EXT4_SB(sb)->s_journal->j_flags & JBD2_ABORT))\n\t\t\terrstr = \"Journal has aborted\";\n\t\telse\n\t\t\terrstr = \"Readonly filesystem\";\n\t\tbreak;\n\tdefault:\n\t\t/* If the caller passed in an extra buffer for unknown\n\t\t * errors, textualise them now.  Else we just return\n\t\t * NULL. */\n\t\tif (nbuf) {\n\t\t\t/* Check for truncated error codes... */\n\t\t\tif (snprintf(nbuf, 16, \"error %d\", -errno) >= 0)\n\t\t\t\terrstr = nbuf;\n\t\t}\n\t\tbreak;\n\t}\n\n\treturn errstr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_error_ratelimit",
          "args": [
            "sb"
          ],
          "line": 543
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "journal_current_handle",
          "args": [],
          "line": 539
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_journal_current_handle",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ext4_jbd2.h",
          "lines": "331-334",
          "snippet": "static inline handle_t *ext4_journal_current_handle(void)\n{\n\treturn journal_current_handle();\n}",
          "includes": [
            "#include \"ext4.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ext4.h\"\n#include <linux/jbd2.h>\n#include <linux/fs.h>\n\nstatic inline handle_t *ext4_journal_current_handle(void)\n{\n\treturn journal_current_handle();\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"mballoc.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4_extents.h\"\t/* Needed for trace points definition */\n#include \"ext4.h\"\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <asm/uaccess.h>\n#include <linux/cleancache.h>\n#include <linux/crc16.h>\n#include <linux/log2.h>\n#include <linux/ctype.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/random.h>\n#include <linux/vfs.h>\n#include <linux/exportfs.h>\n#include <linux/buffer_head.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/jbd2.h>\n#include <linux/vmalloc.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n#include <linux/string.h>\n#include <linux/module.h>\n\nstatic int ext4_unfreeze(struct super_block *sb);\nstatic int ext4_freeze(struct super_block *sb);\nstatic inline int ext2_feature_set_ok(struct super_block *sb);\nstatic inline int ext3_feature_set_ok(struct super_block *sb);\nstatic void ext4_unregister_li_request(struct super_block *sb);\n\nvoid __ext4_std_error(struct super_block *sb, const char *function,\n\t\t      unsigned int line, int errno)\n{\n\tchar nbuf[16];\n\tconst char *errstr;\n\n\t/* Special case: if the error is EROFS, and we're not already\n\t * inside a transaction, then there's really no point in logging\n\t * an error. */\n\tif (errno == -EROFS && journal_current_handle() == NULL &&\n\t    (sb->s_flags & MS_RDONLY))\n\t\treturn;\n\n\tif (ext4_error_ratelimit(sb)) {\n\t\terrstr = ext4_decode_error(sb, errno, nbuf);\n\t\tprintk(KERN_CRIT \"EXT4-fs error (device %s) in %s:%d: %s\\n\",\n\t\t       sb->s_id, function, line, errstr);\n\t}\n\n\tsave_error_info(sb, function, line);\n\text4_handle_error(sb);\n}"
  },
  {
    "function_name": "ext4_decode_error",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/super.c",
    "lines": "493-525",
    "snippet": "const char *ext4_decode_error(struct super_block *sb, int errno,\n\t\t\t      char nbuf[16])\n{\n\tchar *errstr = NULL;\n\n\tswitch (errno) {\n\tcase -EIO:\n\t\terrstr = \"IO failure\";\n\t\tbreak;\n\tcase -ENOMEM:\n\t\terrstr = \"Out of memory\";\n\t\tbreak;\n\tcase -EROFS:\n\t\tif (!sb || (EXT4_SB(sb)->s_journal &&\n\t\t\t    EXT4_SB(sb)->s_journal->j_flags & JBD2_ABORT))\n\t\t\terrstr = \"Journal has aborted\";\n\t\telse\n\t\t\terrstr = \"Readonly filesystem\";\n\t\tbreak;\n\tdefault:\n\t\t/* If the caller passed in an extra buffer for unknown\n\t\t * errors, textualise them now.  Else we just return\n\t\t * NULL. */\n\t\tif (nbuf) {\n\t\t\t/* Check for truncated error codes... */\n\t\t\tif (snprintf(nbuf, 16, \"error %d\", -errno) >= 0)\n\t\t\t\terrstr = nbuf;\n\t\t}\n\t\tbreak;\n\t}\n\n\treturn errstr;\n}",
    "includes": [
      "#include <trace/events/ext4.h>",
      "#include \"mballoc.h\"",
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"ext4_jbd2.h\"",
      "#include \"ext4_extents.h\"\t/* Needed for trace points definition */",
      "#include \"ext4.h\"",
      "#include <linux/freezer.h>",
      "#include <linux/kthread.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/cleancache.h>",
      "#include <linux/crc16.h>",
      "#include <linux/log2.h>",
      "#include <linux/ctype.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/namei.h>",
      "#include <linux/mount.h>",
      "#include <linux/random.h>",
      "#include <linux/vfs.h>",
      "#include <linux/exportfs.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/parser.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/init.h>",
      "#include <linux/slab.h>",
      "#include <linux/jbd2.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/time.h>",
      "#include <linux/fs.h>",
      "#include <linux/string.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ext4_unfreeze(struct super_block *sb);",
      "static int ext4_freeze(struct super_block *sb);",
      "static inline int ext2_feature_set_ok(struct super_block *sb);",
      "static inline int ext3_feature_set_ok(struct super_block *sb);",
      "static void ext4_unregister_li_request(struct super_block *sb);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "nbuf",
            "16",
            "\"error %d\"",
            "-errno"
          ],
          "line": 518
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXT4_SB",
          "args": [
            "sb"
          ],
          "line": 507
        },
        "resolved": true,
        "details": {
          "function_name": "EXT4_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ext4.h",
          "lines": "1356-1359",
          "snippet": "static inline struct ext4_sb_info *EXT4_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include \"extents_status.h\"",
            "#include <linux/compat.h>",
            "#include <linux/falloc.h>",
            "#include <crypto/hash.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/wait.h>",
            "#include <linux/timer.h>",
            "#include <linux/mutex.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/quota.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extents_status.h\"\n#include <linux/compat.h>\n#include <linux/falloc.h>\n#include <crypto/hash.h>\n#include <linux/ratelimit.h>\n#include <linux/percpu_counter.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/wait.h>\n#include <linux/timer.h>\n#include <linux/mutex.h>\n#include <linux/seqlock.h>\n#include <linux/rbtree.h>\n#include <linux/rwsem.h>\n#include <linux/quota.h>\n#include <linux/jbd2.h>\n#include <linux/magic.h>\n#include <linux/blkdev.h>\n#include <linux/types.h>\n\nstatic inline struct ext4_sb_info *EXT4_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"mballoc.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4_extents.h\"\t/* Needed for trace points definition */\n#include \"ext4.h\"\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <asm/uaccess.h>\n#include <linux/cleancache.h>\n#include <linux/crc16.h>\n#include <linux/log2.h>\n#include <linux/ctype.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/random.h>\n#include <linux/vfs.h>\n#include <linux/exportfs.h>\n#include <linux/buffer_head.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/jbd2.h>\n#include <linux/vmalloc.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n#include <linux/string.h>\n#include <linux/module.h>\n\nstatic int ext4_unfreeze(struct super_block *sb);\nstatic int ext4_freeze(struct super_block *sb);\nstatic inline int ext2_feature_set_ok(struct super_block *sb);\nstatic inline int ext3_feature_set_ok(struct super_block *sb);\nstatic void ext4_unregister_li_request(struct super_block *sb);\n\nconst char *ext4_decode_error(struct super_block *sb, int errno,\n\t\t\t      char nbuf[16])\n{\n\tchar *errstr = NULL;\n\n\tswitch (errno) {\n\tcase -EIO:\n\t\terrstr = \"IO failure\";\n\t\tbreak;\n\tcase -ENOMEM:\n\t\terrstr = \"Out of memory\";\n\t\tbreak;\n\tcase -EROFS:\n\t\tif (!sb || (EXT4_SB(sb)->s_journal &&\n\t\t\t    EXT4_SB(sb)->s_journal->j_flags & JBD2_ABORT))\n\t\t\terrstr = \"Journal has aborted\";\n\t\telse\n\t\t\terrstr = \"Readonly filesystem\";\n\t\tbreak;\n\tdefault:\n\t\t/* If the caller passed in an extra buffer for unknown\n\t\t * errors, textualise them now.  Else we just return\n\t\t * NULL. */\n\t\tif (nbuf) {\n\t\t\t/* Check for truncated error codes... */\n\t\t\tif (snprintf(nbuf, 16, \"error %d\", -errno) >= 0)\n\t\t\t\terrstr = nbuf;\n\t\t}\n\t\tbreak;\n\t}\n\n\treturn errstr;\n}"
  },
  {
    "function_name": "__ext4_error_file",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/super.c",
    "lines": "456-491",
    "snippet": "void __ext4_error_file(struct file *file, const char *function,\n\t\t       unsigned int line, ext4_fsblk_t block,\n\t\t       const char *fmt, ...)\n{\n\tva_list args;\n\tstruct va_format vaf;\n\tstruct ext4_super_block *es;\n\tstruct inode *inode = file_inode(file);\n\tchar pathname[80], *path;\n\n\tes = EXT4_SB(inode->i_sb)->s_es;\n\tes->s_last_error_ino = cpu_to_le32(inode->i_ino);\n\tif (ext4_error_ratelimit(inode->i_sb)) {\n\t\tpath = d_path(&(file->f_path), pathname, sizeof(pathname));\n\t\tif (IS_ERR(path))\n\t\t\tpath = \"(unknown)\";\n\t\tva_start(args, fmt);\n\t\tvaf.fmt = fmt;\n\t\tvaf.va = &args;\n\t\tif (block)\n\t\t\tprintk(KERN_CRIT\n\t\t\t       \"EXT4-fs error (device %s): %s:%d: inode #%lu: \"\n\t\t\t       \"block %llu: comm %s: path %s: %pV\\n\",\n\t\t\t       inode->i_sb->s_id, function, line, inode->i_ino,\n\t\t\t       block, current->comm, path, &vaf);\n\t\telse\n\t\t\tprintk(KERN_CRIT\n\t\t\t       \"EXT4-fs error (device %s): %s:%d: inode #%lu: \"\n\t\t\t       \"comm %s: path %s: %pV\\n\",\n\t\t\t       inode->i_sb->s_id, function, line, inode->i_ino,\n\t\t\t       current->comm, path, &vaf);\n\t\tva_end(args);\n\t}\n\tsave_error_info(inode->i_sb, function, line);\n\text4_handle_error(inode->i_sb);\n}",
    "includes": [
      "#include <trace/events/ext4.h>",
      "#include \"mballoc.h\"",
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"ext4_jbd2.h\"",
      "#include \"ext4_extents.h\"\t/* Needed for trace points definition */",
      "#include \"ext4.h\"",
      "#include <linux/freezer.h>",
      "#include <linux/kthread.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/cleancache.h>",
      "#include <linux/crc16.h>",
      "#include <linux/log2.h>",
      "#include <linux/ctype.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/namei.h>",
      "#include <linux/mount.h>",
      "#include <linux/random.h>",
      "#include <linux/vfs.h>",
      "#include <linux/exportfs.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/parser.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/init.h>",
      "#include <linux/slab.h>",
      "#include <linux/jbd2.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/time.h>",
      "#include <linux/fs.h>",
      "#include <linux/string.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void ext4_mark_recovery_complete(struct super_block *sb,\n\t\t\t\t\tstruct ext4_super_block *es);",
      "static void ext4_clear_journal_err(struct super_block *sb,\n\t\t\t\t   struct ext4_super_block *es);",
      "static int ext4_reserve_clusters(struct ext4_sb_info *, ext4_fsblk_t);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ext4_handle_error",
          "args": [
            "inode->i_sb"
          ],
          "line": 490
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_handle_error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/super.c",
          "lines": "377-401",
          "snippet": "static void ext4_handle_error(struct super_block *sb)\n{\n\tif (sb->s_flags & MS_RDONLY)\n\t\treturn;\n\n\tif (!test_opt(sb, ERRORS_CONT)) {\n\t\tjournal_t *journal = EXT4_SB(sb)->s_journal;\n\n\t\tEXT4_SB(sb)->s_mount_flags |= EXT4_MF_FS_ABORTED;\n\t\tif (journal)\n\t\t\tjbd2_journal_abort(journal, -EIO);\n\t}\n\tif (test_opt(sb, ERRORS_RO)) {\n\t\text4_msg(sb, KERN_CRIT, \"Remounting filesystem read-only\");\n\t\t/*\n\t\t * Make sure updated value of ->s_mount_flags will be visible\n\t\t * before ->s_flags update\n\t\t */\n\t\tsmp_wmb();\n\t\tsb->s_flags |= MS_RDONLY;\n\t}\n\tif (test_opt(sb, ERRORS_PANIC))\n\t\tpanic(\"EXT4-fs (device %s): panic forced after error\\n\",\n\t\t\tsb->s_id);\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"mballoc.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include \"ext4_extents.h\"\t/* Needed for trace points definition */",
            "#include \"ext4.h\"",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/crc16.h>",
            "#include <linux/log2.h>",
            "#include <linux/ctype.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/random.h>",
            "#include <linux/vfs.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/parser.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/time.h>",
            "#include <linux/fs.h>",
            "#include <linux/string.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ext4_unfreeze(struct super_block *sb);",
            "static int ext4_freeze(struct super_block *sb);",
            "static inline int ext2_feature_set_ok(struct super_block *sb);",
            "static inline int ext3_feature_set_ok(struct super_block *sb);",
            "static void ext4_unregister_li_request(struct super_block *sb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"mballoc.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4_extents.h\"\t/* Needed for trace points definition */\n#include \"ext4.h\"\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <asm/uaccess.h>\n#include <linux/cleancache.h>\n#include <linux/crc16.h>\n#include <linux/log2.h>\n#include <linux/ctype.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/random.h>\n#include <linux/vfs.h>\n#include <linux/exportfs.h>\n#include <linux/buffer_head.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/jbd2.h>\n#include <linux/vmalloc.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n#include <linux/string.h>\n#include <linux/module.h>\n\nstatic int ext4_unfreeze(struct super_block *sb);\nstatic int ext4_freeze(struct super_block *sb);\nstatic inline int ext2_feature_set_ok(struct super_block *sb);\nstatic inline int ext3_feature_set_ok(struct super_block *sb);\nstatic void ext4_unregister_li_request(struct super_block *sb);\n\nstatic void ext4_handle_error(struct super_block *sb)\n{\n\tif (sb->s_flags & MS_RDONLY)\n\t\treturn;\n\n\tif (!test_opt(sb, ERRORS_CONT)) {\n\t\tjournal_t *journal = EXT4_SB(sb)->s_journal;\n\n\t\tEXT4_SB(sb)->s_mount_flags |= EXT4_MF_FS_ABORTED;\n\t\tif (journal)\n\t\t\tjbd2_journal_abort(journal, -EIO);\n\t}\n\tif (test_opt(sb, ERRORS_RO)) {\n\t\text4_msg(sb, KERN_CRIT, \"Remounting filesystem read-only\");\n\t\t/*\n\t\t * Make sure updated value of ->s_mount_flags will be visible\n\t\t * before ->s_flags update\n\t\t */\n\t\tsmp_wmb();\n\t\tsb->s_flags |= MS_RDONLY;\n\t}\n\tif (test_opt(sb, ERRORS_PANIC))\n\t\tpanic(\"EXT4-fs (device %s): panic forced after error\\n\",\n\t\t\tsb->s_id);\n}"
        }
      },
      {
        "call_info": {
          "callee": "save_error_info",
          "args": [
            "inode->i_sb",
            "function",
            "line"
          ],
          "line": 489
        },
        "resolved": true,
        "details": {
          "function_name": "save_error_info",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/super.c",
          "lines": "319-324",
          "snippet": "static void save_error_info(struct super_block *sb, const char *func,\n\t\t\t    unsigned int line)\n{\n\t__save_error_info(sb, func, line);\n\text4_commit_super(sb, 1);\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"mballoc.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include \"ext4_extents.h\"\t/* Needed for trace points definition */",
            "#include \"ext4.h\"",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/crc16.h>",
            "#include <linux/log2.h>",
            "#include <linux/ctype.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/random.h>",
            "#include <linux/vfs.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/parser.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/time.h>",
            "#include <linux/fs.h>",
            "#include <linux/string.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ext4_unfreeze(struct super_block *sb);",
            "static int ext4_freeze(struct super_block *sb);",
            "static inline int ext2_feature_set_ok(struct super_block *sb);",
            "static inline int ext3_feature_set_ok(struct super_block *sb);",
            "static void ext4_unregister_li_request(struct super_block *sb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"mballoc.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4_extents.h\"\t/* Needed for trace points definition */\n#include \"ext4.h\"\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <asm/uaccess.h>\n#include <linux/cleancache.h>\n#include <linux/crc16.h>\n#include <linux/log2.h>\n#include <linux/ctype.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/random.h>\n#include <linux/vfs.h>\n#include <linux/exportfs.h>\n#include <linux/buffer_head.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/jbd2.h>\n#include <linux/vmalloc.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n#include <linux/string.h>\n#include <linux/module.h>\n\nstatic int ext4_unfreeze(struct super_block *sb);\nstatic int ext4_freeze(struct super_block *sb);\nstatic inline int ext2_feature_set_ok(struct super_block *sb);\nstatic inline int ext3_feature_set_ok(struct super_block *sb);\nstatic void ext4_unregister_li_request(struct super_block *sb);\n\nstatic void save_error_info(struct super_block *sb, const char *func,\n\t\t\t    unsigned int line)\n{\n\t__save_error_info(sb, func, line);\n\text4_commit_super(sb, 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "va_end",
          "args": [
            "args"
          ],
          "line": 487
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_CRIT\n\t\t\t       \"EXT4-fs error (device %s): %s:%d: inode #%lu: \"\n\t\t\t       \"comm %s: path %s: %pV\\n\"",
            "inode->i_sb->s_id",
            "function",
            "line",
            "inode->i_ino",
            "current->comm",
            "path",
            "&vaf"
          ],
          "line": 482
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_printk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/super.c",
          "lines": "186-213",
          "snippet": "void btrfs_printk(const struct btrfs_fs_info *fs_info, const char *fmt, ...)\n{\n\tstruct super_block *sb = fs_info->sb;\n\tchar lvl[4];\n\tstruct va_format vaf;\n\tva_list args;\n\tconst char *type = logtypes[4];\n\tint kern_level;\n\n\tva_start(args, fmt);\n\n\tkern_level = printk_get_level(fmt);\n\tif (kern_level) {\n\t\tsize_t size = printk_skip_level(fmt) - fmt;\n\t\tmemcpy(lvl, fmt,  size);\n\t\tlvl[size] = '\\0';\n\t\tfmt += size;\n\t\ttype = logtypes[kern_level - '0'];\n\t} else\n\t\t*lvl = '\\0';\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\tprintk(\"%sBTRFS %s (device %s): %pV\\n\", lvl, type, sb->s_id, &vaf);\n\n\tva_end(args);\n}",
          "includes": [
            "#include <trace/events/btrfs.h>",
            "#include \"qgroup.h\"",
            "#include \"tests/btrfs-tests.h\"",
            "#include \"backref.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"dev-replace.h\"",
            "#include \"rcu-string.h\"",
            "#include \"compression.h\"",
            "#include \"export.h\"",
            "#include \"volumes.h\"",
            "#include \"xattr.h\"",
            "#include \"props.h\"",
            "#include \"hash.h\"",
            "#include \"print-tree.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include \"delayed-inode.h\"",
            "#include <linux/btrfs.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/slab.h>",
            "#include <linux/magic.h>",
            "#include <linux/miscdevice.h>",
            "#include <linux/namei.h>",
            "#include <linux/ctype.h>",
            "#include <linux/parser.h>",
            "#include <linux/compat.h>",
            "#include <linux/statfs.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/mpage.h>",
            "#include <linux/mount.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/string.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/init.h>",
            "#include <linux/time.h>",
            "#include <linux/highmem.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/module.h>",
            "#include <linux/blkdev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/btrfs.h>\n#include \"qgroup.h\"\n#include \"tests/btrfs-tests.h\"\n#include \"backref.h\"\n#include \"free-space-cache.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"compression.h\"\n#include \"export.h\"\n#include \"volumes.h\"\n#include \"xattr.h\"\n#include \"props.h\"\n#include \"hash.h\"\n#include \"print-tree.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include \"delayed-inode.h\"\n#include <linux/btrfs.h>\n#include <linux/ratelimit.h>\n#include <linux/cleancache.h>\n#include <linux/slab.h>\n#include <linux/magic.h>\n#include <linux/miscdevice.h>\n#include <linux/namei.h>\n#include <linux/ctype.h>\n#include <linux/parser.h>\n#include <linux/compat.h>\n#include <linux/statfs.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/mpage.h>\n#include <linux/mount.h>\n#include <linux/backing-dev.h>\n#include <linux/string.h>\n#include <linux/seq_file.h>\n#include <linux/init.h>\n#include <linux/time.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n#include <linux/buffer_head.h>\n#include <linux/module.h>\n#include <linux/blkdev.h>\n\nvoid btrfs_printk(const struct btrfs_fs_info *fs_info, const char *fmt, ...)\n{\n\tstruct super_block *sb = fs_info->sb;\n\tchar lvl[4];\n\tstruct va_format vaf;\n\tva_list args;\n\tconst char *type = logtypes[4];\n\tint kern_level;\n\n\tva_start(args, fmt);\n\n\tkern_level = printk_get_level(fmt);\n\tif (kern_level) {\n\t\tsize_t size = printk_skip_level(fmt) - fmt;\n\t\tmemcpy(lvl, fmt,  size);\n\t\tlvl[size] = '\\0';\n\t\tfmt += size;\n\t\ttype = logtypes[kern_level - '0'];\n\t} else\n\t\t*lvl = '\\0';\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\tprintk(\"%sBTRFS %s (device %s): %pV\\n\", lvl, type, sb->s_id, &vaf);\n\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "va_start",
          "args": [
            "args",
            "fmt"
          ],
          "line": 472
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "path"
          ],
          "line": 470
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "d_path",
          "args": [
            "&(file->f_path)",
            "pathname",
            "sizeof(pathname)"
          ],
          "line": 469
        },
        "resolved": true,
        "details": {
          "function_name": "d_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "3047-3076",
          "snippet": "char *d_path(const struct path *path, char *buf, int buflen)\n{\n\tchar *res = buf + buflen;\n\tstruct path root;\n\tint error;\n\n\t/*\n\t * We have various synthetic filesystems that never get mounted.  On\n\t * these filesystems dentries are never used for lookup purposes, and\n\t * thus don't need to be hashed.  They also don't need a name until a\n\t * user wants to identify the object in /proc/pid/fd/.  The little hack\n\t * below allows us to generate a name for these objects on demand:\n\t *\n\t * Some pseudo inodes are mountable.  When they are mounted\n\t * path->dentry == path->mnt->mnt_root.  In that case don't call d_dname\n\t * and instead have d_path return the mounted path.\n\t */\n\tif (path->dentry->d_op && path->dentry->d_op->d_dname &&\n\t    (!IS_ROOT(path->dentry) || path->dentry != path->mnt->mnt_root))\n\t\treturn path->dentry->d_op->d_dname(path->dentry, buf, buflen);\n\n\trcu_read_lock();\n\tget_fs_root_rcu(current->fs, &root);\n\terror = path_with_deleted(path, &root, &res, &buflen);\n\trcu_read_unlock();\n\n\tif (error < 0)\n\t\tres = ERR_PTR(error);\n\treturn res;\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nchar *d_path(const struct path *path, char *buf, int buflen)\n{\n\tchar *res = buf + buflen;\n\tstruct path root;\n\tint error;\n\n\t/*\n\t * We have various synthetic filesystems that never get mounted.  On\n\t * these filesystems dentries are never used for lookup purposes, and\n\t * thus don't need to be hashed.  They also don't need a name until a\n\t * user wants to identify the object in /proc/pid/fd/.  The little hack\n\t * below allows us to generate a name for these objects on demand:\n\t *\n\t * Some pseudo inodes are mountable.  When they are mounted\n\t * path->dentry == path->mnt->mnt_root.  In that case don't call d_dname\n\t * and instead have d_path return the mounted path.\n\t */\n\tif (path->dentry->d_op && path->dentry->d_op->d_dname &&\n\t    (!IS_ROOT(path->dentry) || path->dentry != path->mnt->mnt_root))\n\t\treturn path->dentry->d_op->d_dname(path->dentry, buf, buflen);\n\n\trcu_read_lock();\n\tget_fs_root_rcu(current->fs, &root);\n\terror = path_with_deleted(path, &root, &res, &buflen);\n\trcu_read_unlock();\n\n\tif (error < 0)\n\t\tres = ERR_PTR(error);\n\treturn res;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_error_ratelimit",
          "args": [
            "inode->i_sb"
          ],
          "line": 468
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "inode->i_ino"
          ],
          "line": 467
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXT4_SB",
          "args": [
            "inode->i_sb"
          ],
          "line": 466
        },
        "resolved": true,
        "details": {
          "function_name": "EXT4_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ext4.h",
          "lines": "1356-1359",
          "snippet": "static inline struct ext4_sb_info *EXT4_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include \"extents_status.h\"",
            "#include <linux/compat.h>",
            "#include <linux/falloc.h>",
            "#include <crypto/hash.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/wait.h>",
            "#include <linux/timer.h>",
            "#include <linux/mutex.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/quota.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extents_status.h\"\n#include <linux/compat.h>\n#include <linux/falloc.h>\n#include <crypto/hash.h>\n#include <linux/ratelimit.h>\n#include <linux/percpu_counter.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/wait.h>\n#include <linux/timer.h>\n#include <linux/mutex.h>\n#include <linux/seqlock.h>\n#include <linux/rbtree.h>\n#include <linux/rwsem.h>\n#include <linux/quota.h>\n#include <linux/jbd2.h>\n#include <linux/magic.h>\n#include <linux/blkdev.h>\n#include <linux/types.h>\n\nstatic inline struct ext4_sb_info *EXT4_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      },
      {
        "call_info": {
          "callee": "file_inode",
          "args": [
            "file"
          ],
          "line": 463
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_init_file_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/file.c",
          "lines": "3009-3013",
          "snippet": "void fuse_init_file_inode(struct inode *inode)\n{\n\tinode->i_fop = &fuse_file_operations;\n\tinode->i_data.a_ops = &fuse_file_aops;\n}",
          "includes": [
            "#include <linux/falloc.h>",
            "#include <linux/aio.h>",
            "#include <linux/swap.h>",
            "#include <linux/compat.h>",
            "#include <linux/module.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct file_operations fuse_file_operations = {\n\t.llseek\t\t= fuse_file_llseek,\n\t.read\t\t= new_sync_read,\n\t.read_iter\t= fuse_file_read_iter,\n\t.write\t\t= new_sync_write,\n\t.write_iter\t= fuse_file_write_iter,\n\t.mmap\t\t= fuse_file_mmap,\n\t.open\t\t= fuse_open,\n\t.flush\t\t= fuse_flush,\n\t.release\t= fuse_release,\n\t.fsync\t\t= fuse_fsync,\n\t.lock\t\t= fuse_file_lock,\n\t.flock\t\t= fuse_file_flock,\n\t.splice_read\t= generic_file_splice_read,\n\t.unlocked_ioctl\t= fuse_file_ioctl,\n\t.compat_ioctl\t= fuse_file_compat_ioctl,\n\t.poll\t\t= fuse_file_poll,\n\t.fallocate\t= fuse_file_fallocate,\n};",
            "static const struct address_space_operations fuse_file_aops  = {\n\t.readpage\t= fuse_readpage,\n\t.writepage\t= fuse_writepage,\n\t.writepages\t= fuse_writepages,\n\t.launder_page\t= fuse_launder_page,\n\t.readpages\t= fuse_readpages,\n\t.set_page_dirty\t= __set_page_dirty_nobuffers,\n\t.bmap\t\t= fuse_bmap,\n\t.direct_IO\t= fuse_direct_IO,\n\t.write_begin\t= fuse_write_begin,\n\t.write_end\t= fuse_write_end,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/falloc.h>\n#include <linux/aio.h>\n#include <linux/swap.h>\n#include <linux/compat.h>\n#include <linux/module.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nstatic const struct file_operations fuse_file_operations = {\n\t.llseek\t\t= fuse_file_llseek,\n\t.read\t\t= new_sync_read,\n\t.read_iter\t= fuse_file_read_iter,\n\t.write\t\t= new_sync_write,\n\t.write_iter\t= fuse_file_write_iter,\n\t.mmap\t\t= fuse_file_mmap,\n\t.open\t\t= fuse_open,\n\t.flush\t\t= fuse_flush,\n\t.release\t= fuse_release,\n\t.fsync\t\t= fuse_fsync,\n\t.lock\t\t= fuse_file_lock,\n\t.flock\t\t= fuse_file_flock,\n\t.splice_read\t= generic_file_splice_read,\n\t.unlocked_ioctl\t= fuse_file_ioctl,\n\t.compat_ioctl\t= fuse_file_compat_ioctl,\n\t.poll\t\t= fuse_file_poll,\n\t.fallocate\t= fuse_file_fallocate,\n};\nstatic const struct address_space_operations fuse_file_aops  = {\n\t.readpage\t= fuse_readpage,\n\t.writepage\t= fuse_writepage,\n\t.writepages\t= fuse_writepages,\n\t.launder_page\t= fuse_launder_page,\n\t.readpages\t= fuse_readpages,\n\t.set_page_dirty\t= __set_page_dirty_nobuffers,\n\t.bmap\t\t= fuse_bmap,\n\t.direct_IO\t= fuse_direct_IO,\n\t.write_begin\t= fuse_write_begin,\n\t.write_end\t= fuse_write_end,\n};\n\nvoid fuse_init_file_inode(struct inode *inode)\n{\n\tinode->i_fop = &fuse_file_operations;\n\tinode->i_data.a_ops = &fuse_file_aops;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"mballoc.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4_extents.h\"\t/* Needed for trace points definition */\n#include \"ext4.h\"\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <asm/uaccess.h>\n#include <linux/cleancache.h>\n#include <linux/crc16.h>\n#include <linux/log2.h>\n#include <linux/ctype.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/random.h>\n#include <linux/vfs.h>\n#include <linux/exportfs.h>\n#include <linux/buffer_head.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/jbd2.h>\n#include <linux/vmalloc.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n#include <linux/string.h>\n#include <linux/module.h>\n\nstatic void ext4_mark_recovery_complete(struct super_block *sb,\n\t\t\t\t\tstruct ext4_super_block *es);\nstatic void ext4_clear_journal_err(struct super_block *sb,\n\t\t\t\t   struct ext4_super_block *es);\nstatic int ext4_reserve_clusters(struct ext4_sb_info *, ext4_fsblk_t);\n\nvoid __ext4_error_file(struct file *file, const char *function,\n\t\t       unsigned int line, ext4_fsblk_t block,\n\t\t       const char *fmt, ...)\n{\n\tva_list args;\n\tstruct va_format vaf;\n\tstruct ext4_super_block *es;\n\tstruct inode *inode = file_inode(file);\n\tchar pathname[80], *path;\n\n\tes = EXT4_SB(inode->i_sb)->s_es;\n\tes->s_last_error_ino = cpu_to_le32(inode->i_ino);\n\tif (ext4_error_ratelimit(inode->i_sb)) {\n\t\tpath = d_path(&(file->f_path), pathname, sizeof(pathname));\n\t\tif (IS_ERR(path))\n\t\t\tpath = \"(unknown)\";\n\t\tva_start(args, fmt);\n\t\tvaf.fmt = fmt;\n\t\tvaf.va = &args;\n\t\tif (block)\n\t\t\tprintk(KERN_CRIT\n\t\t\t       \"EXT4-fs error (device %s): %s:%d: inode #%lu: \"\n\t\t\t       \"block %llu: comm %s: path %s: %pV\\n\",\n\t\t\t       inode->i_sb->s_id, function, line, inode->i_ino,\n\t\t\t       block, current->comm, path, &vaf);\n\t\telse\n\t\t\tprintk(KERN_CRIT\n\t\t\t       \"EXT4-fs error (device %s): %s:%d: inode #%lu: \"\n\t\t\t       \"comm %s: path %s: %pV\\n\",\n\t\t\t       inode->i_sb->s_id, function, line, inode->i_ino,\n\t\t\t       current->comm, path, &vaf);\n\t\tva_end(args);\n\t}\n\tsave_error_info(inode->i_sb, function, line);\n\text4_handle_error(inode->i_sb);\n}"
  },
  {
    "function_name": "__ext4_error_inode",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/super.c",
    "lines": "426-454",
    "snippet": "void __ext4_error_inode(struct inode *inode, const char *function,\n\t\t\tunsigned int line, ext4_fsblk_t block,\n\t\t\tconst char *fmt, ...)\n{\n\tva_list args;\n\tstruct va_format vaf;\n\tstruct ext4_super_block *es = EXT4_SB(inode->i_sb)->s_es;\n\n\tes->s_last_error_ino = cpu_to_le32(inode->i_ino);\n\tes->s_last_error_block = cpu_to_le64(block);\n\tif (ext4_error_ratelimit(inode->i_sb)) {\n\t\tva_start(args, fmt);\n\t\tvaf.fmt = fmt;\n\t\tvaf.va = &args;\n\t\tif (block)\n\t\t\tprintk(KERN_CRIT \"EXT4-fs error (device %s): %s:%d: \"\n\t\t\t       \"inode #%lu: block %llu: comm %s: %pV\\n\",\n\t\t\t       inode->i_sb->s_id, function, line, inode->i_ino,\n\t\t\t       block, current->comm, &vaf);\n\t\telse\n\t\t\tprintk(KERN_CRIT \"EXT4-fs error (device %s): %s:%d: \"\n\t\t\t       \"inode #%lu: comm %s: %pV\\n\",\n\t\t\t       inode->i_sb->s_id, function, line, inode->i_ino,\n\t\t\t       current->comm, &vaf);\n\t\tva_end(args);\n\t}\n\tsave_error_info(inode->i_sb, function, line);\n\text4_handle_error(inode->i_sb);\n}",
    "includes": [
      "#include <trace/events/ext4.h>",
      "#include \"mballoc.h\"",
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"ext4_jbd2.h\"",
      "#include \"ext4_extents.h\"\t/* Needed for trace points definition */",
      "#include \"ext4.h\"",
      "#include <linux/freezer.h>",
      "#include <linux/kthread.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/cleancache.h>",
      "#include <linux/crc16.h>",
      "#include <linux/log2.h>",
      "#include <linux/ctype.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/namei.h>",
      "#include <linux/mount.h>",
      "#include <linux/random.h>",
      "#include <linux/vfs.h>",
      "#include <linux/exportfs.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/parser.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/init.h>",
      "#include <linux/slab.h>",
      "#include <linux/jbd2.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/time.h>",
      "#include <linux/fs.h>",
      "#include <linux/string.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void ext4_mark_recovery_complete(struct super_block *sb,\n\t\t\t\t\tstruct ext4_super_block *es);",
      "static void ext4_clear_journal_err(struct super_block *sb,\n\t\t\t\t   struct ext4_super_block *es);",
      "static int ext4_reserve_clusters(struct ext4_sb_info *, ext4_fsblk_t);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ext4_handle_error",
          "args": [
            "inode->i_sb"
          ],
          "line": 453
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_handle_error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/super.c",
          "lines": "377-401",
          "snippet": "static void ext4_handle_error(struct super_block *sb)\n{\n\tif (sb->s_flags & MS_RDONLY)\n\t\treturn;\n\n\tif (!test_opt(sb, ERRORS_CONT)) {\n\t\tjournal_t *journal = EXT4_SB(sb)->s_journal;\n\n\t\tEXT4_SB(sb)->s_mount_flags |= EXT4_MF_FS_ABORTED;\n\t\tif (journal)\n\t\t\tjbd2_journal_abort(journal, -EIO);\n\t}\n\tif (test_opt(sb, ERRORS_RO)) {\n\t\text4_msg(sb, KERN_CRIT, \"Remounting filesystem read-only\");\n\t\t/*\n\t\t * Make sure updated value of ->s_mount_flags will be visible\n\t\t * before ->s_flags update\n\t\t */\n\t\tsmp_wmb();\n\t\tsb->s_flags |= MS_RDONLY;\n\t}\n\tif (test_opt(sb, ERRORS_PANIC))\n\t\tpanic(\"EXT4-fs (device %s): panic forced after error\\n\",\n\t\t\tsb->s_id);\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"mballoc.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include \"ext4_extents.h\"\t/* Needed for trace points definition */",
            "#include \"ext4.h\"",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/crc16.h>",
            "#include <linux/log2.h>",
            "#include <linux/ctype.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/random.h>",
            "#include <linux/vfs.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/parser.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/time.h>",
            "#include <linux/fs.h>",
            "#include <linux/string.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ext4_unfreeze(struct super_block *sb);",
            "static int ext4_freeze(struct super_block *sb);",
            "static inline int ext2_feature_set_ok(struct super_block *sb);",
            "static inline int ext3_feature_set_ok(struct super_block *sb);",
            "static void ext4_unregister_li_request(struct super_block *sb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"mballoc.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4_extents.h\"\t/* Needed for trace points definition */\n#include \"ext4.h\"\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <asm/uaccess.h>\n#include <linux/cleancache.h>\n#include <linux/crc16.h>\n#include <linux/log2.h>\n#include <linux/ctype.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/random.h>\n#include <linux/vfs.h>\n#include <linux/exportfs.h>\n#include <linux/buffer_head.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/jbd2.h>\n#include <linux/vmalloc.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n#include <linux/string.h>\n#include <linux/module.h>\n\nstatic int ext4_unfreeze(struct super_block *sb);\nstatic int ext4_freeze(struct super_block *sb);\nstatic inline int ext2_feature_set_ok(struct super_block *sb);\nstatic inline int ext3_feature_set_ok(struct super_block *sb);\nstatic void ext4_unregister_li_request(struct super_block *sb);\n\nstatic void ext4_handle_error(struct super_block *sb)\n{\n\tif (sb->s_flags & MS_RDONLY)\n\t\treturn;\n\n\tif (!test_opt(sb, ERRORS_CONT)) {\n\t\tjournal_t *journal = EXT4_SB(sb)->s_journal;\n\n\t\tEXT4_SB(sb)->s_mount_flags |= EXT4_MF_FS_ABORTED;\n\t\tif (journal)\n\t\t\tjbd2_journal_abort(journal, -EIO);\n\t}\n\tif (test_opt(sb, ERRORS_RO)) {\n\t\text4_msg(sb, KERN_CRIT, \"Remounting filesystem read-only\");\n\t\t/*\n\t\t * Make sure updated value of ->s_mount_flags will be visible\n\t\t * before ->s_flags update\n\t\t */\n\t\tsmp_wmb();\n\t\tsb->s_flags |= MS_RDONLY;\n\t}\n\tif (test_opt(sb, ERRORS_PANIC))\n\t\tpanic(\"EXT4-fs (device %s): panic forced after error\\n\",\n\t\t\tsb->s_id);\n}"
        }
      },
      {
        "call_info": {
          "callee": "save_error_info",
          "args": [
            "inode->i_sb",
            "function",
            "line"
          ],
          "line": 452
        },
        "resolved": true,
        "details": {
          "function_name": "save_error_info",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/super.c",
          "lines": "319-324",
          "snippet": "static void save_error_info(struct super_block *sb, const char *func,\n\t\t\t    unsigned int line)\n{\n\t__save_error_info(sb, func, line);\n\text4_commit_super(sb, 1);\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"mballoc.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include \"ext4_extents.h\"\t/* Needed for trace points definition */",
            "#include \"ext4.h\"",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/crc16.h>",
            "#include <linux/log2.h>",
            "#include <linux/ctype.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/random.h>",
            "#include <linux/vfs.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/parser.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/time.h>",
            "#include <linux/fs.h>",
            "#include <linux/string.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ext4_unfreeze(struct super_block *sb);",
            "static int ext4_freeze(struct super_block *sb);",
            "static inline int ext2_feature_set_ok(struct super_block *sb);",
            "static inline int ext3_feature_set_ok(struct super_block *sb);",
            "static void ext4_unregister_li_request(struct super_block *sb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"mballoc.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4_extents.h\"\t/* Needed for trace points definition */\n#include \"ext4.h\"\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <asm/uaccess.h>\n#include <linux/cleancache.h>\n#include <linux/crc16.h>\n#include <linux/log2.h>\n#include <linux/ctype.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/random.h>\n#include <linux/vfs.h>\n#include <linux/exportfs.h>\n#include <linux/buffer_head.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/jbd2.h>\n#include <linux/vmalloc.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n#include <linux/string.h>\n#include <linux/module.h>\n\nstatic int ext4_unfreeze(struct super_block *sb);\nstatic int ext4_freeze(struct super_block *sb);\nstatic inline int ext2_feature_set_ok(struct super_block *sb);\nstatic inline int ext3_feature_set_ok(struct super_block *sb);\nstatic void ext4_unregister_li_request(struct super_block *sb);\n\nstatic void save_error_info(struct super_block *sb, const char *func,\n\t\t\t    unsigned int line)\n{\n\t__save_error_info(sb, func, line);\n\text4_commit_super(sb, 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "va_end",
          "args": [
            "args"
          ],
          "line": 450
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_CRIT \"EXT4-fs error (device %s): %s:%d: \"\n\t\t\t       \"inode #%lu: comm %s: %pV\\n\"",
            "inode->i_sb->s_id",
            "function",
            "line",
            "inode->i_ino",
            "current->comm",
            "&vaf"
          ],
          "line": 446
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_printk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/super.c",
          "lines": "186-213",
          "snippet": "void btrfs_printk(const struct btrfs_fs_info *fs_info, const char *fmt, ...)\n{\n\tstruct super_block *sb = fs_info->sb;\n\tchar lvl[4];\n\tstruct va_format vaf;\n\tva_list args;\n\tconst char *type = logtypes[4];\n\tint kern_level;\n\n\tva_start(args, fmt);\n\n\tkern_level = printk_get_level(fmt);\n\tif (kern_level) {\n\t\tsize_t size = printk_skip_level(fmt) - fmt;\n\t\tmemcpy(lvl, fmt,  size);\n\t\tlvl[size] = '\\0';\n\t\tfmt += size;\n\t\ttype = logtypes[kern_level - '0'];\n\t} else\n\t\t*lvl = '\\0';\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\tprintk(\"%sBTRFS %s (device %s): %pV\\n\", lvl, type, sb->s_id, &vaf);\n\n\tva_end(args);\n}",
          "includes": [
            "#include <trace/events/btrfs.h>",
            "#include \"qgroup.h\"",
            "#include \"tests/btrfs-tests.h\"",
            "#include \"backref.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"dev-replace.h\"",
            "#include \"rcu-string.h\"",
            "#include \"compression.h\"",
            "#include \"export.h\"",
            "#include \"volumes.h\"",
            "#include \"xattr.h\"",
            "#include \"props.h\"",
            "#include \"hash.h\"",
            "#include \"print-tree.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include \"delayed-inode.h\"",
            "#include <linux/btrfs.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/slab.h>",
            "#include <linux/magic.h>",
            "#include <linux/miscdevice.h>",
            "#include <linux/namei.h>",
            "#include <linux/ctype.h>",
            "#include <linux/parser.h>",
            "#include <linux/compat.h>",
            "#include <linux/statfs.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/mpage.h>",
            "#include <linux/mount.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/string.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/init.h>",
            "#include <linux/time.h>",
            "#include <linux/highmem.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/module.h>",
            "#include <linux/blkdev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/btrfs.h>\n#include \"qgroup.h\"\n#include \"tests/btrfs-tests.h\"\n#include \"backref.h\"\n#include \"free-space-cache.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"compression.h\"\n#include \"export.h\"\n#include \"volumes.h\"\n#include \"xattr.h\"\n#include \"props.h\"\n#include \"hash.h\"\n#include \"print-tree.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include \"delayed-inode.h\"\n#include <linux/btrfs.h>\n#include <linux/ratelimit.h>\n#include <linux/cleancache.h>\n#include <linux/slab.h>\n#include <linux/magic.h>\n#include <linux/miscdevice.h>\n#include <linux/namei.h>\n#include <linux/ctype.h>\n#include <linux/parser.h>\n#include <linux/compat.h>\n#include <linux/statfs.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/mpage.h>\n#include <linux/mount.h>\n#include <linux/backing-dev.h>\n#include <linux/string.h>\n#include <linux/seq_file.h>\n#include <linux/init.h>\n#include <linux/time.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n#include <linux/buffer_head.h>\n#include <linux/module.h>\n#include <linux/blkdev.h>\n\nvoid btrfs_printk(const struct btrfs_fs_info *fs_info, const char *fmt, ...)\n{\n\tstruct super_block *sb = fs_info->sb;\n\tchar lvl[4];\n\tstruct va_format vaf;\n\tva_list args;\n\tconst char *type = logtypes[4];\n\tint kern_level;\n\n\tva_start(args, fmt);\n\n\tkern_level = printk_get_level(fmt);\n\tif (kern_level) {\n\t\tsize_t size = printk_skip_level(fmt) - fmt;\n\t\tmemcpy(lvl, fmt,  size);\n\t\tlvl[size] = '\\0';\n\t\tfmt += size;\n\t\ttype = logtypes[kern_level - '0'];\n\t} else\n\t\t*lvl = '\\0';\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\tprintk(\"%sBTRFS %s (device %s): %pV\\n\", lvl, type, sb->s_id, &vaf);\n\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "va_start",
          "args": [
            "args",
            "fmt"
          ],
          "line": 437
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_error_ratelimit",
          "args": [
            "inode->i_sb"
          ],
          "line": 436
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le64",
          "args": [
            "block"
          ],
          "line": 435
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "inode->i_ino"
          ],
          "line": 434
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXT4_SB",
          "args": [
            "inode->i_sb"
          ],
          "line": 432
        },
        "resolved": true,
        "details": {
          "function_name": "EXT4_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ext4.h",
          "lines": "1356-1359",
          "snippet": "static inline struct ext4_sb_info *EXT4_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include \"extents_status.h\"",
            "#include <linux/compat.h>",
            "#include <linux/falloc.h>",
            "#include <crypto/hash.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/wait.h>",
            "#include <linux/timer.h>",
            "#include <linux/mutex.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/quota.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extents_status.h\"\n#include <linux/compat.h>\n#include <linux/falloc.h>\n#include <crypto/hash.h>\n#include <linux/ratelimit.h>\n#include <linux/percpu_counter.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/wait.h>\n#include <linux/timer.h>\n#include <linux/mutex.h>\n#include <linux/seqlock.h>\n#include <linux/rbtree.h>\n#include <linux/rwsem.h>\n#include <linux/quota.h>\n#include <linux/jbd2.h>\n#include <linux/magic.h>\n#include <linux/blkdev.h>\n#include <linux/types.h>\n\nstatic inline struct ext4_sb_info *EXT4_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"mballoc.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4_extents.h\"\t/* Needed for trace points definition */\n#include \"ext4.h\"\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <asm/uaccess.h>\n#include <linux/cleancache.h>\n#include <linux/crc16.h>\n#include <linux/log2.h>\n#include <linux/ctype.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/random.h>\n#include <linux/vfs.h>\n#include <linux/exportfs.h>\n#include <linux/buffer_head.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/jbd2.h>\n#include <linux/vmalloc.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n#include <linux/string.h>\n#include <linux/module.h>\n\nstatic void ext4_mark_recovery_complete(struct super_block *sb,\n\t\t\t\t\tstruct ext4_super_block *es);\nstatic void ext4_clear_journal_err(struct super_block *sb,\n\t\t\t\t   struct ext4_super_block *es);\nstatic int ext4_reserve_clusters(struct ext4_sb_info *, ext4_fsblk_t);\n\nvoid __ext4_error_inode(struct inode *inode, const char *function,\n\t\t\tunsigned int line, ext4_fsblk_t block,\n\t\t\tconst char *fmt, ...)\n{\n\tva_list args;\n\tstruct va_format vaf;\n\tstruct ext4_super_block *es = EXT4_SB(inode->i_sb)->s_es;\n\n\tes->s_last_error_ino = cpu_to_le32(inode->i_ino);\n\tes->s_last_error_block = cpu_to_le64(block);\n\tif (ext4_error_ratelimit(inode->i_sb)) {\n\t\tva_start(args, fmt);\n\t\tvaf.fmt = fmt;\n\t\tvaf.va = &args;\n\t\tif (block)\n\t\t\tprintk(KERN_CRIT \"EXT4-fs error (device %s): %s:%d: \"\n\t\t\t       \"inode #%lu: block %llu: comm %s: %pV\\n\",\n\t\t\t       inode->i_sb->s_id, function, line, inode->i_ino,\n\t\t\t       block, current->comm, &vaf);\n\t\telse\n\t\t\tprintk(KERN_CRIT \"EXT4-fs error (device %s): %s:%d: \"\n\t\t\t       \"inode #%lu: comm %s: %pV\\n\",\n\t\t\t       inode->i_sb->s_id, function, line, inode->i_ino,\n\t\t\t       current->comm, &vaf);\n\t\tva_end(args);\n\t}\n\tsave_error_info(inode->i_sb, function, line);\n\text4_handle_error(inode->i_sb);\n}"
  },
  {
    "function_name": "__ext4_error",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/super.c",
    "lines": "407-424",
    "snippet": "void __ext4_error(struct super_block *sb, const char *function,\n\t\t  unsigned int line, const char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tif (ext4_error_ratelimit(sb)) {\n\t\tva_start(args, fmt);\n\t\tvaf.fmt = fmt;\n\t\tvaf.va = &args;\n\t\tprintk(KERN_CRIT\n\t\t       \"EXT4-fs error (device %s): %s:%d: comm %s: %pV\\n\",\n\t\t       sb->s_id, function, line, current->comm, &vaf);\n\t\tva_end(args);\n\t}\n\tsave_error_info(sb, function, line);\n\text4_handle_error(sb);\n}",
    "includes": [
      "#include <trace/events/ext4.h>",
      "#include \"mballoc.h\"",
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"ext4_jbd2.h\"",
      "#include \"ext4_extents.h\"\t/* Needed for trace points definition */",
      "#include \"ext4.h\"",
      "#include <linux/freezer.h>",
      "#include <linux/kthread.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/cleancache.h>",
      "#include <linux/crc16.h>",
      "#include <linux/log2.h>",
      "#include <linux/ctype.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/namei.h>",
      "#include <linux/mount.h>",
      "#include <linux/random.h>",
      "#include <linux/vfs.h>",
      "#include <linux/exportfs.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/parser.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/init.h>",
      "#include <linux/slab.h>",
      "#include <linux/jbd2.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/time.h>",
      "#include <linux/fs.h>",
      "#include <linux/string.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ext4_unfreeze(struct super_block *sb);",
      "static int ext4_freeze(struct super_block *sb);",
      "static inline int ext2_feature_set_ok(struct super_block *sb);",
      "static inline int ext3_feature_set_ok(struct super_block *sb);",
      "static void ext4_unregister_li_request(struct super_block *sb);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ext4_handle_error",
          "args": [
            "sb"
          ],
          "line": 423
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_handle_error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/super.c",
          "lines": "377-401",
          "snippet": "static void ext4_handle_error(struct super_block *sb)\n{\n\tif (sb->s_flags & MS_RDONLY)\n\t\treturn;\n\n\tif (!test_opt(sb, ERRORS_CONT)) {\n\t\tjournal_t *journal = EXT4_SB(sb)->s_journal;\n\n\t\tEXT4_SB(sb)->s_mount_flags |= EXT4_MF_FS_ABORTED;\n\t\tif (journal)\n\t\t\tjbd2_journal_abort(journal, -EIO);\n\t}\n\tif (test_opt(sb, ERRORS_RO)) {\n\t\text4_msg(sb, KERN_CRIT, \"Remounting filesystem read-only\");\n\t\t/*\n\t\t * Make sure updated value of ->s_mount_flags will be visible\n\t\t * before ->s_flags update\n\t\t */\n\t\tsmp_wmb();\n\t\tsb->s_flags |= MS_RDONLY;\n\t}\n\tif (test_opt(sb, ERRORS_PANIC))\n\t\tpanic(\"EXT4-fs (device %s): panic forced after error\\n\",\n\t\t\tsb->s_id);\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"mballoc.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include \"ext4_extents.h\"\t/* Needed for trace points definition */",
            "#include \"ext4.h\"",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/crc16.h>",
            "#include <linux/log2.h>",
            "#include <linux/ctype.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/random.h>",
            "#include <linux/vfs.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/parser.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/time.h>",
            "#include <linux/fs.h>",
            "#include <linux/string.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ext4_unfreeze(struct super_block *sb);",
            "static int ext4_freeze(struct super_block *sb);",
            "static inline int ext2_feature_set_ok(struct super_block *sb);",
            "static inline int ext3_feature_set_ok(struct super_block *sb);",
            "static void ext4_unregister_li_request(struct super_block *sb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"mballoc.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4_extents.h\"\t/* Needed for trace points definition */\n#include \"ext4.h\"\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <asm/uaccess.h>\n#include <linux/cleancache.h>\n#include <linux/crc16.h>\n#include <linux/log2.h>\n#include <linux/ctype.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/random.h>\n#include <linux/vfs.h>\n#include <linux/exportfs.h>\n#include <linux/buffer_head.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/jbd2.h>\n#include <linux/vmalloc.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n#include <linux/string.h>\n#include <linux/module.h>\n\nstatic int ext4_unfreeze(struct super_block *sb);\nstatic int ext4_freeze(struct super_block *sb);\nstatic inline int ext2_feature_set_ok(struct super_block *sb);\nstatic inline int ext3_feature_set_ok(struct super_block *sb);\nstatic void ext4_unregister_li_request(struct super_block *sb);\n\nstatic void ext4_handle_error(struct super_block *sb)\n{\n\tif (sb->s_flags & MS_RDONLY)\n\t\treturn;\n\n\tif (!test_opt(sb, ERRORS_CONT)) {\n\t\tjournal_t *journal = EXT4_SB(sb)->s_journal;\n\n\t\tEXT4_SB(sb)->s_mount_flags |= EXT4_MF_FS_ABORTED;\n\t\tif (journal)\n\t\t\tjbd2_journal_abort(journal, -EIO);\n\t}\n\tif (test_opt(sb, ERRORS_RO)) {\n\t\text4_msg(sb, KERN_CRIT, \"Remounting filesystem read-only\");\n\t\t/*\n\t\t * Make sure updated value of ->s_mount_flags will be visible\n\t\t * before ->s_flags update\n\t\t */\n\t\tsmp_wmb();\n\t\tsb->s_flags |= MS_RDONLY;\n\t}\n\tif (test_opt(sb, ERRORS_PANIC))\n\t\tpanic(\"EXT4-fs (device %s): panic forced after error\\n\",\n\t\t\tsb->s_id);\n}"
        }
      },
      {
        "call_info": {
          "callee": "save_error_info",
          "args": [
            "sb",
            "function",
            "line"
          ],
          "line": 422
        },
        "resolved": true,
        "details": {
          "function_name": "save_error_info",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/super.c",
          "lines": "319-324",
          "snippet": "static void save_error_info(struct super_block *sb, const char *func,\n\t\t\t    unsigned int line)\n{\n\t__save_error_info(sb, func, line);\n\text4_commit_super(sb, 1);\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"mballoc.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include \"ext4_extents.h\"\t/* Needed for trace points definition */",
            "#include \"ext4.h\"",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/crc16.h>",
            "#include <linux/log2.h>",
            "#include <linux/ctype.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/random.h>",
            "#include <linux/vfs.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/parser.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/time.h>",
            "#include <linux/fs.h>",
            "#include <linux/string.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ext4_unfreeze(struct super_block *sb);",
            "static int ext4_freeze(struct super_block *sb);",
            "static inline int ext2_feature_set_ok(struct super_block *sb);",
            "static inline int ext3_feature_set_ok(struct super_block *sb);",
            "static void ext4_unregister_li_request(struct super_block *sb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"mballoc.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4_extents.h\"\t/* Needed for trace points definition */\n#include \"ext4.h\"\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <asm/uaccess.h>\n#include <linux/cleancache.h>\n#include <linux/crc16.h>\n#include <linux/log2.h>\n#include <linux/ctype.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/random.h>\n#include <linux/vfs.h>\n#include <linux/exportfs.h>\n#include <linux/buffer_head.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/jbd2.h>\n#include <linux/vmalloc.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n#include <linux/string.h>\n#include <linux/module.h>\n\nstatic int ext4_unfreeze(struct super_block *sb);\nstatic int ext4_freeze(struct super_block *sb);\nstatic inline int ext2_feature_set_ok(struct super_block *sb);\nstatic inline int ext3_feature_set_ok(struct super_block *sb);\nstatic void ext4_unregister_li_request(struct super_block *sb);\n\nstatic void save_error_info(struct super_block *sb, const char *func,\n\t\t\t    unsigned int line)\n{\n\t__save_error_info(sb, func, line);\n\text4_commit_super(sb, 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "va_end",
          "args": [
            "args"
          ],
          "line": 420
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_CRIT\n\t\t       \"EXT4-fs error (device %s): %s:%d: comm %s: %pV\\n\"",
            "sb->s_id",
            "function",
            "line",
            "current->comm",
            "&vaf"
          ],
          "line": 417
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_printk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/super.c",
          "lines": "186-213",
          "snippet": "void btrfs_printk(const struct btrfs_fs_info *fs_info, const char *fmt, ...)\n{\n\tstruct super_block *sb = fs_info->sb;\n\tchar lvl[4];\n\tstruct va_format vaf;\n\tva_list args;\n\tconst char *type = logtypes[4];\n\tint kern_level;\n\n\tva_start(args, fmt);\n\n\tkern_level = printk_get_level(fmt);\n\tif (kern_level) {\n\t\tsize_t size = printk_skip_level(fmt) - fmt;\n\t\tmemcpy(lvl, fmt,  size);\n\t\tlvl[size] = '\\0';\n\t\tfmt += size;\n\t\ttype = logtypes[kern_level - '0'];\n\t} else\n\t\t*lvl = '\\0';\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\tprintk(\"%sBTRFS %s (device %s): %pV\\n\", lvl, type, sb->s_id, &vaf);\n\n\tva_end(args);\n}",
          "includes": [
            "#include <trace/events/btrfs.h>",
            "#include \"qgroup.h\"",
            "#include \"tests/btrfs-tests.h\"",
            "#include \"backref.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"dev-replace.h\"",
            "#include \"rcu-string.h\"",
            "#include \"compression.h\"",
            "#include \"export.h\"",
            "#include \"volumes.h\"",
            "#include \"xattr.h\"",
            "#include \"props.h\"",
            "#include \"hash.h\"",
            "#include \"print-tree.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include \"delayed-inode.h\"",
            "#include <linux/btrfs.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/slab.h>",
            "#include <linux/magic.h>",
            "#include <linux/miscdevice.h>",
            "#include <linux/namei.h>",
            "#include <linux/ctype.h>",
            "#include <linux/parser.h>",
            "#include <linux/compat.h>",
            "#include <linux/statfs.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/mpage.h>",
            "#include <linux/mount.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/string.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/init.h>",
            "#include <linux/time.h>",
            "#include <linux/highmem.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/module.h>",
            "#include <linux/blkdev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/btrfs.h>\n#include \"qgroup.h\"\n#include \"tests/btrfs-tests.h\"\n#include \"backref.h\"\n#include \"free-space-cache.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"compression.h\"\n#include \"export.h\"\n#include \"volumes.h\"\n#include \"xattr.h\"\n#include \"props.h\"\n#include \"hash.h\"\n#include \"print-tree.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include \"delayed-inode.h\"\n#include <linux/btrfs.h>\n#include <linux/ratelimit.h>\n#include <linux/cleancache.h>\n#include <linux/slab.h>\n#include <linux/magic.h>\n#include <linux/miscdevice.h>\n#include <linux/namei.h>\n#include <linux/ctype.h>\n#include <linux/parser.h>\n#include <linux/compat.h>\n#include <linux/statfs.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/mpage.h>\n#include <linux/mount.h>\n#include <linux/backing-dev.h>\n#include <linux/string.h>\n#include <linux/seq_file.h>\n#include <linux/init.h>\n#include <linux/time.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n#include <linux/buffer_head.h>\n#include <linux/module.h>\n#include <linux/blkdev.h>\n\nvoid btrfs_printk(const struct btrfs_fs_info *fs_info, const char *fmt, ...)\n{\n\tstruct super_block *sb = fs_info->sb;\n\tchar lvl[4];\n\tstruct va_format vaf;\n\tva_list args;\n\tconst char *type = logtypes[4];\n\tint kern_level;\n\n\tva_start(args, fmt);\n\n\tkern_level = printk_get_level(fmt);\n\tif (kern_level) {\n\t\tsize_t size = printk_skip_level(fmt) - fmt;\n\t\tmemcpy(lvl, fmt,  size);\n\t\tlvl[size] = '\\0';\n\t\tfmt += size;\n\t\ttype = logtypes[kern_level - '0'];\n\t} else\n\t\t*lvl = '\\0';\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\tprintk(\"%sBTRFS %s (device %s): %pV\\n\", lvl, type, sb->s_id, &vaf);\n\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "va_start",
          "args": [
            "args",
            "fmt"
          ],
          "line": 414
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_error_ratelimit",
          "args": [
            "sb"
          ],
          "line": 413
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"mballoc.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4_extents.h\"\t/* Needed for trace points definition */\n#include \"ext4.h\"\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <asm/uaccess.h>\n#include <linux/cleancache.h>\n#include <linux/crc16.h>\n#include <linux/log2.h>\n#include <linux/ctype.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/random.h>\n#include <linux/vfs.h>\n#include <linux/exportfs.h>\n#include <linux/buffer_head.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/jbd2.h>\n#include <linux/vmalloc.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n#include <linux/string.h>\n#include <linux/module.h>\n\nstatic int ext4_unfreeze(struct super_block *sb);\nstatic int ext4_freeze(struct super_block *sb);\nstatic inline int ext2_feature_set_ok(struct super_block *sb);\nstatic inline int ext3_feature_set_ok(struct super_block *sb);\nstatic void ext4_unregister_li_request(struct super_block *sb);\n\nvoid __ext4_error(struct super_block *sb, const char *function,\n\t\t  unsigned int line, const char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tif (ext4_error_ratelimit(sb)) {\n\t\tva_start(args, fmt);\n\t\tvaf.fmt = fmt;\n\t\tvaf.va = &args;\n\t\tprintk(KERN_CRIT\n\t\t       \"EXT4-fs error (device %s): %s:%d: comm %s: %pV\\n\",\n\t\t       sb->s_id, function, line, current->comm, &vaf);\n\t\tva_end(args);\n\t}\n\tsave_error_info(sb, function, line);\n\text4_handle_error(sb);\n}"
  },
  {
    "function_name": "ext4_handle_error",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/super.c",
    "lines": "377-401",
    "snippet": "static void ext4_handle_error(struct super_block *sb)\n{\n\tif (sb->s_flags & MS_RDONLY)\n\t\treturn;\n\n\tif (!test_opt(sb, ERRORS_CONT)) {\n\t\tjournal_t *journal = EXT4_SB(sb)->s_journal;\n\n\t\tEXT4_SB(sb)->s_mount_flags |= EXT4_MF_FS_ABORTED;\n\t\tif (journal)\n\t\t\tjbd2_journal_abort(journal, -EIO);\n\t}\n\tif (test_opt(sb, ERRORS_RO)) {\n\t\text4_msg(sb, KERN_CRIT, \"Remounting filesystem read-only\");\n\t\t/*\n\t\t * Make sure updated value of ->s_mount_flags will be visible\n\t\t * before ->s_flags update\n\t\t */\n\t\tsmp_wmb();\n\t\tsb->s_flags |= MS_RDONLY;\n\t}\n\tif (test_opt(sb, ERRORS_PANIC))\n\t\tpanic(\"EXT4-fs (device %s): panic forced after error\\n\",\n\t\t\tsb->s_id);\n}",
    "includes": [
      "#include <trace/events/ext4.h>",
      "#include \"mballoc.h\"",
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"ext4_jbd2.h\"",
      "#include \"ext4_extents.h\"\t/* Needed for trace points definition */",
      "#include \"ext4.h\"",
      "#include <linux/freezer.h>",
      "#include <linux/kthread.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/cleancache.h>",
      "#include <linux/crc16.h>",
      "#include <linux/log2.h>",
      "#include <linux/ctype.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/namei.h>",
      "#include <linux/mount.h>",
      "#include <linux/random.h>",
      "#include <linux/vfs.h>",
      "#include <linux/exportfs.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/parser.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/init.h>",
      "#include <linux/slab.h>",
      "#include <linux/jbd2.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/time.h>",
      "#include <linux/fs.h>",
      "#include <linux/string.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ext4_unfreeze(struct super_block *sb);",
      "static int ext4_freeze(struct super_block *sb);",
      "static inline int ext2_feature_set_ok(struct super_block *sb);",
      "static inline int ext3_feature_set_ok(struct super_block *sb);",
      "static void ext4_unregister_li_request(struct super_block *sb);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "panic",
          "args": [
            "\"EXT4-fs (device %s): panic forced after error\\n\"",
            "sb->s_id"
          ],
          "line": 399
        },
        "resolved": true,
        "details": {
          "function_name": "extent_io_tree_panic",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_io.c",
          "lines": "553-558",
          "snippet": "static void extent_io_tree_panic(struct extent_io_tree *tree, int err)\n{\n\tbtrfs_panic(tree_fs_info(tree), err, \"Locking error: \"\n\t\t    \"Extent tree was modified by another \"\n\t\t    \"thread while locked.\");\n}",
          "includes": [
            "#include \"backref.h\"",
            "#include \"rcu-string.h\"",
            "#include \"locking.h\"",
            "#include \"check-integrity.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"ctree.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/cleancache.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/bio.h>",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"backref.h\"\n#include \"rcu-string.h\"\n#include \"locking.h\"\n#include \"check-integrity.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"ctree.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/cleancache.h>\n#include <linux/prefetch.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/spinlock.h>\n#include <linux/page-flags.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/bio.h>\n#include <linux/slab.h>\n#include <linux/bitops.h>\n\nstatic void extent_io_tree_panic(struct extent_io_tree *tree, int err)\n{\n\tbtrfs_panic(tree_fs_info(tree), err, \"Locking error: \"\n\t\t    \"Extent tree was modified by another \"\n\t\t    \"thread while locked.\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "test_opt",
          "args": [
            "sb",
            "ERRORS_PANIC"
          ],
          "line": 398
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "smp_wmb",
          "args": [],
          "line": 395
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_msg",
          "args": [
            "sb",
            "KERN_CRIT",
            "\"Remounting filesystem read-only\""
          ],
          "line": 390
        },
        "resolved": true,
        "details": {
          "function_name": "__ext4_msg",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/super.c",
          "lines": "593-607",
          "snippet": "void __ext4_msg(struct super_block *sb,\n\t\tconst char *prefix, const char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tif (!___ratelimit(&(EXT4_SB(sb)->s_msg_ratelimit_state), \"EXT4-fs\"))\n\t\treturn;\n\n\tva_start(args, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\tprintk(\"%sEXT4-fs (%s): %pV\\n\", prefix, sb->s_id, &vaf);\n\tva_end(args);\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"mballoc.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include \"ext4_extents.h\"\t/* Needed for trace points definition */",
            "#include \"ext4.h\"",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/crc16.h>",
            "#include <linux/log2.h>",
            "#include <linux/ctype.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/random.h>",
            "#include <linux/vfs.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/parser.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/time.h>",
            "#include <linux/fs.h>",
            "#include <linux/string.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ext4_unfreeze(struct super_block *sb);",
            "static int ext4_freeze(struct super_block *sb);",
            "static inline int ext2_feature_set_ok(struct super_block *sb);",
            "static inline int ext3_feature_set_ok(struct super_block *sb);",
            "static void ext4_unregister_li_request(struct super_block *sb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"mballoc.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4_extents.h\"\t/* Needed for trace points definition */\n#include \"ext4.h\"\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <asm/uaccess.h>\n#include <linux/cleancache.h>\n#include <linux/crc16.h>\n#include <linux/log2.h>\n#include <linux/ctype.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/random.h>\n#include <linux/vfs.h>\n#include <linux/exportfs.h>\n#include <linux/buffer_head.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/jbd2.h>\n#include <linux/vmalloc.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n#include <linux/string.h>\n#include <linux/module.h>\n\nstatic int ext4_unfreeze(struct super_block *sb);\nstatic int ext4_freeze(struct super_block *sb);\nstatic inline int ext2_feature_set_ok(struct super_block *sb);\nstatic inline int ext3_feature_set_ok(struct super_block *sb);\nstatic void ext4_unregister_li_request(struct super_block *sb);\n\nvoid __ext4_msg(struct super_block *sb,\n\t\tconst char *prefix, const char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tif (!___ratelimit(&(EXT4_SB(sb)->s_msg_ratelimit_state), \"EXT4-fs\"))\n\t\treturn;\n\n\tva_start(args, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\tprintk(\"%sEXT4-fs (%s): %pV\\n\", prefix, sb->s_id, &vaf);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "test_opt",
          "args": [
            "sb",
            "ERRORS_RO"
          ],
          "line": 389
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "jbd2_journal_abort",
          "args": [
            "journal",
            "-EIO"
          ],
          "line": 387
        },
        "resolved": true,
        "details": {
          "function_name": "jbd2_journal_abort",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd2/journal.c",
          "lines": "2106-2109",
          "snippet": "void jbd2_journal_abort(journal_t *journal, int errno)\n{\n\t__journal_abort_soft(journal, errno);\n}",
          "includes": [
            "#include <asm/page.h>",
            "#include <asm/uaccess.h>",
            "#include <trace/events/jbd2.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/bitops.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/log2.h>",
            "#include <linux/hash.h>",
            "#include <linux/math64.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/poison.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __journal_abort_soft (journal_t *journal, int errno);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <trace/events/jbd2.h>\n#include <linux/ratelimit.h>\n#include <linux/bitops.h>\n#include <linux/backing-dev.h>\n#include <linux/vmalloc.h>\n#include <linux/log2.h>\n#include <linux/hash.h>\n#include <linux/math64.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/poison.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/freezer.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd2.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/module.h>\n\nstatic void __journal_abort_soft (journal_t *journal, int errno);\n\nvoid jbd2_journal_abort(journal_t *journal, int errno)\n{\n\t__journal_abort_soft(journal, errno);\n}"
        }
      },
      {
        "call_info": {
          "callee": "EXT4_SB",
          "args": [
            "sb"
          ],
          "line": 385
        },
        "resolved": true,
        "details": {
          "function_name": "EXT4_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ext4.h",
          "lines": "1356-1359",
          "snippet": "static inline struct ext4_sb_info *EXT4_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include \"extents_status.h\"",
            "#include <linux/compat.h>",
            "#include <linux/falloc.h>",
            "#include <crypto/hash.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/wait.h>",
            "#include <linux/timer.h>",
            "#include <linux/mutex.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/quota.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extents_status.h\"\n#include <linux/compat.h>\n#include <linux/falloc.h>\n#include <crypto/hash.h>\n#include <linux/ratelimit.h>\n#include <linux/percpu_counter.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/wait.h>\n#include <linux/timer.h>\n#include <linux/mutex.h>\n#include <linux/seqlock.h>\n#include <linux/rbtree.h>\n#include <linux/rwsem.h>\n#include <linux/quota.h>\n#include <linux/jbd2.h>\n#include <linux/magic.h>\n#include <linux/blkdev.h>\n#include <linux/types.h>\n\nstatic inline struct ext4_sb_info *EXT4_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      },
      {
        "call_info": {
          "callee": "test_opt",
          "args": [
            "sb",
            "ERRORS_CONT"
          ],
          "line": 382
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"mballoc.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4_extents.h\"\t/* Needed for trace points definition */\n#include \"ext4.h\"\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <asm/uaccess.h>\n#include <linux/cleancache.h>\n#include <linux/crc16.h>\n#include <linux/log2.h>\n#include <linux/ctype.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/random.h>\n#include <linux/vfs.h>\n#include <linux/exportfs.h>\n#include <linux/buffer_head.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/jbd2.h>\n#include <linux/vmalloc.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n#include <linux/string.h>\n#include <linux/module.h>\n\nstatic int ext4_unfreeze(struct super_block *sb);\nstatic int ext4_freeze(struct super_block *sb);\nstatic inline int ext2_feature_set_ok(struct super_block *sb);\nstatic inline int ext3_feature_set_ok(struct super_block *sb);\nstatic void ext4_unregister_li_request(struct super_block *sb);\n\nstatic void ext4_handle_error(struct super_block *sb)\n{\n\tif (sb->s_flags & MS_RDONLY)\n\t\treturn;\n\n\tif (!test_opt(sb, ERRORS_CONT)) {\n\t\tjournal_t *journal = EXT4_SB(sb)->s_journal;\n\n\t\tEXT4_SB(sb)->s_mount_flags |= EXT4_MF_FS_ABORTED;\n\t\tif (journal)\n\t\t\tjbd2_journal_abort(journal, -EIO);\n\t}\n\tif (test_opt(sb, ERRORS_RO)) {\n\t\text4_msg(sb, KERN_CRIT, \"Remounting filesystem read-only\");\n\t\t/*\n\t\t * Make sure updated value of ->s_mount_flags will be visible\n\t\t * before ->s_flags update\n\t\t */\n\t\tsmp_wmb();\n\t\tsb->s_flags |= MS_RDONLY;\n\t}\n\tif (test_opt(sb, ERRORS_PANIC))\n\t\tpanic(\"EXT4-fs (device %s): panic forced after error\\n\",\n\t\t\tsb->s_id);\n}"
  },
  {
    "function_name": "ext4_journal_commit_callback",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/super.c",
    "lines": "342-360",
    "snippet": "static void ext4_journal_commit_callback(journal_t *journal, transaction_t *txn)\n{\n\tstruct super_block\t\t*sb = journal->j_private;\n\tstruct ext4_sb_info\t\t*sbi = EXT4_SB(sb);\n\tint\t\t\t\terror = is_journal_aborted(journal);\n\tstruct ext4_journal_cb_entry\t*jce;\n\n\tBUG_ON(txn->t_state == T_FINISHED);\n\tspin_lock(&sbi->s_md_lock);\n\twhile (!list_empty(&txn->t_private_list)) {\n\t\tjce = list_entry(txn->t_private_list.next,\n\t\t\t\t struct ext4_journal_cb_entry, jce_list);\n\t\tlist_del_init(&jce->jce_list);\n\t\tspin_unlock(&sbi->s_md_lock);\n\t\tjce->jce_func(sb, jce, error);\n\t\tspin_lock(&sbi->s_md_lock);\n\t}\n\tspin_unlock(&sbi->s_md_lock);\n}",
    "includes": [
      "#include <trace/events/ext4.h>",
      "#include \"mballoc.h\"",
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"ext4_jbd2.h\"",
      "#include \"ext4_extents.h\"\t/* Needed for trace points definition */",
      "#include \"ext4.h\"",
      "#include <linux/freezer.h>",
      "#include <linux/kthread.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/cleancache.h>",
      "#include <linux/crc16.h>",
      "#include <linux/log2.h>",
      "#include <linux/ctype.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/namei.h>",
      "#include <linux/mount.h>",
      "#include <linux/random.h>",
      "#include <linux/vfs.h>",
      "#include <linux/exportfs.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/parser.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/init.h>",
      "#include <linux/slab.h>",
      "#include <linux/jbd2.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/time.h>",
      "#include <linux/fs.h>",
      "#include <linux/string.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ext4_unfreeze(struct super_block *sb);",
      "static int ext4_freeze(struct super_block *sb);",
      "static inline int ext2_feature_set_ok(struct super_block *sb);",
      "static inline int ext3_feature_set_ok(struct super_block *sb);",
      "static void ext4_unregister_li_request(struct super_block *sb);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&sbi->s_md_lock"
          ],
          "line": 359
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&sbi->s_md_lock"
          ],
          "line": 357
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "jce->jce_func",
          "args": [
            "sb",
            "jce",
            "error"
          ],
          "line": 356
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_del_init",
          "args": [
            "&jce->jce_list"
          ],
          "line": 354
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_entry",
          "args": [
            "txn->t_private_list.next",
            "structext4_journal_cb_entry",
            "jce_list"
          ],
          "line": 352
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&txn->t_private_list"
          ],
          "line": 351
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_dirty_list_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmthread.c",
          "lines": "505-514",
          "snippet": "static int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/timer.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_flush_asts(struct dlm_ctxt *dlm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/timer.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_flush_asts(struct dlm_ctxt *dlm);\n\nstatic int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "txn->t_state == T_FINISHED"
          ],
          "line": 349
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_journal_aborted",
          "args": [
            "journal"
          ],
          "line": 346
        },
        "resolved": true,
        "details": {
          "function_name": "__reiserfs_is_journal_aborted",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/reiserfs.h",
          "lines": "760-764",
          "snippet": "static inline int __reiserfs_is_journal_aborted(struct reiserfs_journal\n\t\t\t\t\t\t*journal)\n{\n\treturn test_bit(J_ABORTED, &journal->j_state);\n}",
          "includes": [
            "#include <linux/buffer_head.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/bitops.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/bug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/slab.h>",
            "#include <linux/reiserfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/buffer_head.h>\n#include <linux/proc_fs.h>\n#include <linux/bitops.h>\n#include <asm/unaligned.h>\n#include <linux/workqueue.h>\n#include <linux/bug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/slab.h>\n#include <linux/reiserfs_fs.h>\n\nstatic inline int __reiserfs_is_journal_aborted(struct reiserfs_journal\n\t\t\t\t\t\t*journal)\n{\n\treturn test_bit(J_ABORTED, &journal->j_state);\n}"
        }
      },
      {
        "call_info": {
          "callee": "EXT4_SB",
          "args": [
            "sb"
          ],
          "line": 345
        },
        "resolved": true,
        "details": {
          "function_name": "EXT4_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ext4.h",
          "lines": "1356-1359",
          "snippet": "static inline struct ext4_sb_info *EXT4_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include \"extents_status.h\"",
            "#include <linux/compat.h>",
            "#include <linux/falloc.h>",
            "#include <crypto/hash.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/wait.h>",
            "#include <linux/timer.h>",
            "#include <linux/mutex.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/quota.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extents_status.h\"\n#include <linux/compat.h>\n#include <linux/falloc.h>\n#include <crypto/hash.h>\n#include <linux/ratelimit.h>\n#include <linux/percpu_counter.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/wait.h>\n#include <linux/timer.h>\n#include <linux/mutex.h>\n#include <linux/seqlock.h>\n#include <linux/rbtree.h>\n#include <linux/rwsem.h>\n#include <linux/quota.h>\n#include <linux/jbd2.h>\n#include <linux/magic.h>\n#include <linux/blkdev.h>\n#include <linux/types.h>\n\nstatic inline struct ext4_sb_info *EXT4_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"mballoc.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4_extents.h\"\t/* Needed for trace points definition */\n#include \"ext4.h\"\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <asm/uaccess.h>\n#include <linux/cleancache.h>\n#include <linux/crc16.h>\n#include <linux/log2.h>\n#include <linux/ctype.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/random.h>\n#include <linux/vfs.h>\n#include <linux/exportfs.h>\n#include <linux/buffer_head.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/jbd2.h>\n#include <linux/vmalloc.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n#include <linux/string.h>\n#include <linux/module.h>\n\nstatic int ext4_unfreeze(struct super_block *sb);\nstatic int ext4_freeze(struct super_block *sb);\nstatic inline int ext2_feature_set_ok(struct super_block *sb);\nstatic inline int ext3_feature_set_ok(struct super_block *sb);\nstatic void ext4_unregister_li_request(struct super_block *sb);\n\nstatic void ext4_journal_commit_callback(journal_t *journal, transaction_t *txn)\n{\n\tstruct super_block\t\t*sb = journal->j_private;\n\tstruct ext4_sb_info\t\t*sbi = EXT4_SB(sb);\n\tint\t\t\t\terror = is_journal_aborted(journal);\n\tstruct ext4_journal_cb_entry\t*jce;\n\n\tBUG_ON(txn->t_state == T_FINISHED);\n\tspin_lock(&sbi->s_md_lock);\n\twhile (!list_empty(&txn->t_private_list)) {\n\t\tjce = list_entry(txn->t_private_list.next,\n\t\t\t\t struct ext4_journal_cb_entry, jce_list);\n\t\tlist_del_init(&jce->jce_list);\n\t\tspin_unlock(&sbi->s_md_lock);\n\t\tjce->jce_func(sb, jce, error);\n\t\tspin_lock(&sbi->s_md_lock);\n\t}\n\tspin_unlock(&sbi->s_md_lock);\n}"
  },
  {
    "function_name": "block_device_ejected",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/super.c",
    "lines": "334-340",
    "snippet": "static int block_device_ejected(struct super_block *sb)\n{\n\tstruct inode *bd_inode = sb->s_bdev->bd_inode;\n\tstruct backing_dev_info *bdi = inode_to_bdi(bd_inode);\n\n\treturn bdi->dev == NULL;\n}",
    "includes": [
      "#include <trace/events/ext4.h>",
      "#include \"mballoc.h\"",
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"ext4_jbd2.h\"",
      "#include \"ext4_extents.h\"\t/* Needed for trace points definition */",
      "#include \"ext4.h\"",
      "#include <linux/freezer.h>",
      "#include <linux/kthread.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/cleancache.h>",
      "#include <linux/crc16.h>",
      "#include <linux/log2.h>",
      "#include <linux/ctype.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/namei.h>",
      "#include <linux/mount.h>",
      "#include <linux/random.h>",
      "#include <linux/vfs.h>",
      "#include <linux/exportfs.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/parser.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/init.h>",
      "#include <linux/slab.h>",
      "#include <linux/jbd2.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/time.h>",
      "#include <linux/fs.h>",
      "#include <linux/string.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ext4_unfreeze(struct super_block *sb);",
      "static int ext4_freeze(struct super_block *sb);",
      "static inline int ext2_feature_set_ok(struct super_block *sb);",
      "static inline int ext3_feature_set_ok(struct super_block *sb);",
      "static void ext4_unregister_li_request(struct super_block *sb);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "inode_to_bdi",
          "args": [
            "bd_inode"
          ],
          "line": 337
        },
        "resolved": true,
        "details": {
          "function_name": "inode_to_bdi",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fs-writeback.c",
          "lines": "69-82",
          "snippet": "struct backing_dev_info *inode_to_bdi(struct inode *inode)\n{\n\tstruct super_block *sb;\n\n\tif (!inode)\n\t\treturn &noop_backing_dev_info;\n\n\tsb = inode->i_sb;\n#ifdef CONFIG_BLOCK\n\tif (sb_is_blkdev_sb(sb))\n\t\treturn blk_get_backing_dev_info(I_BDEV(inode));\n#endif\n\treturn sb->s_bdi;\n}",
          "includes": [
            "#include <trace/events/writeback.h>",
            "#include \"internal.h\"",
            "#include <linux/device.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/writeback.h>\n#include \"internal.h\"\n#include <linux/device.h>\n#include <linux/tracepoint.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nstruct backing_dev_info *inode_to_bdi(struct inode *inode)\n{\n\tstruct super_block *sb;\n\n\tif (!inode)\n\t\treturn &noop_backing_dev_info;\n\n\tsb = inode->i_sb;\n#ifdef CONFIG_BLOCK\n\tif (sb_is_blkdev_sb(sb))\n\t\treturn blk_get_backing_dev_info(I_BDEV(inode));\n#endif\n\treturn sb->s_bdi;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"mballoc.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4_extents.h\"\t/* Needed for trace points definition */\n#include \"ext4.h\"\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <asm/uaccess.h>\n#include <linux/cleancache.h>\n#include <linux/crc16.h>\n#include <linux/log2.h>\n#include <linux/ctype.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/random.h>\n#include <linux/vfs.h>\n#include <linux/exportfs.h>\n#include <linux/buffer_head.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/jbd2.h>\n#include <linux/vmalloc.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n#include <linux/string.h>\n#include <linux/module.h>\n\nstatic int ext4_unfreeze(struct super_block *sb);\nstatic int ext4_freeze(struct super_block *sb);\nstatic inline int ext2_feature_set_ok(struct super_block *sb);\nstatic inline int ext3_feature_set_ok(struct super_block *sb);\nstatic void ext4_unregister_li_request(struct super_block *sb);\n\nstatic int block_device_ejected(struct super_block *sb)\n{\n\tstruct inode *bd_inode = sb->s_bdev->bd_inode;\n\tstruct backing_dev_info *bdi = inode_to_bdi(bd_inode);\n\n\treturn bdi->dev == NULL;\n}"
  },
  {
    "function_name": "save_error_info",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/super.c",
    "lines": "319-324",
    "snippet": "static void save_error_info(struct super_block *sb, const char *func,\n\t\t\t    unsigned int line)\n{\n\t__save_error_info(sb, func, line);\n\text4_commit_super(sb, 1);\n}",
    "includes": [
      "#include <trace/events/ext4.h>",
      "#include \"mballoc.h\"",
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"ext4_jbd2.h\"",
      "#include \"ext4_extents.h\"\t/* Needed for trace points definition */",
      "#include \"ext4.h\"",
      "#include <linux/freezer.h>",
      "#include <linux/kthread.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/cleancache.h>",
      "#include <linux/crc16.h>",
      "#include <linux/log2.h>",
      "#include <linux/ctype.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/namei.h>",
      "#include <linux/mount.h>",
      "#include <linux/random.h>",
      "#include <linux/vfs.h>",
      "#include <linux/exportfs.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/parser.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/init.h>",
      "#include <linux/slab.h>",
      "#include <linux/jbd2.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/time.h>",
      "#include <linux/fs.h>",
      "#include <linux/string.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ext4_unfreeze(struct super_block *sb);",
      "static int ext4_freeze(struct super_block *sb);",
      "static inline int ext2_feature_set_ok(struct super_block *sb);",
      "static inline int ext3_feature_set_ok(struct super_block *sb);",
      "static void ext4_unregister_li_request(struct super_block *sb);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ext4_commit_super",
          "args": [
            "sb",
            "1"
          ],
          "line": 323
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_commit_super",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/super.c",
          "lines": "4567-4634",
          "snippet": "static int ext4_commit_super(struct super_block *sb, int sync)\n{\n\tstruct ext4_super_block *es = EXT4_SB(sb)->s_es;\n\tstruct buffer_head *sbh = EXT4_SB(sb)->s_sbh;\n\tint error = 0;\n\n\tif (!sbh || block_device_ejected(sb))\n\t\treturn error;\n\tif (buffer_write_io_error(sbh)) {\n\t\t/*\n\t\t * Oh, dear.  A previous attempt to write the\n\t\t * superblock failed.  This could happen because the\n\t\t * USB device was yanked out.  Or it could happen to\n\t\t * be a transient write error and maybe the block will\n\t\t * be remapped.  Nothing we can do but to retry the\n\t\t * write and hope for the best.\n\t\t */\n\t\text4_msg(sb, KERN_ERR, \"previous I/O error to \"\n\t\t       \"superblock detected\");\n\t\tclear_buffer_write_io_error(sbh);\n\t\tset_buffer_uptodate(sbh);\n\t}\n\t/*\n\t * If the file system is mounted read-only, don't update the\n\t * superblock write time.  This avoids updating the superblock\n\t * write time when we are mounting the root file system\n\t * read/only but we need to replay the journal; at that point,\n\t * for people who are east of GMT and who make their clock\n\t * tick in localtime for Windows bug-for-bug compatibility,\n\t * the clock is set in the future, and this will cause e2fsck\n\t * to complain and force a full file system check.\n\t */\n\tif (!(sb->s_flags & MS_RDONLY))\n\t\tes->s_wtime = cpu_to_le32(get_seconds());\n\tif (sb->s_bdev->bd_part)\n\t\tes->s_kbytes_written =\n\t\t\tcpu_to_le64(EXT4_SB(sb)->s_kbytes_written +\n\t\t\t    ((part_stat_read(sb->s_bdev->bd_part, sectors[1]) -\n\t\t\t      EXT4_SB(sb)->s_sectors_written_start) >> 1));\n\telse\n\t\tes->s_kbytes_written =\n\t\t\tcpu_to_le64(EXT4_SB(sb)->s_kbytes_written);\n\tif (percpu_counter_initialized(&EXT4_SB(sb)->s_freeclusters_counter))\n\t\text4_free_blocks_count_set(es,\n\t\t\tEXT4_C2B(EXT4_SB(sb), percpu_counter_sum_positive(\n\t\t\t\t&EXT4_SB(sb)->s_freeclusters_counter)));\n\tif (percpu_counter_initialized(&EXT4_SB(sb)->s_freeinodes_counter))\n\t\tes->s_free_inodes_count =\n\t\t\tcpu_to_le32(percpu_counter_sum_positive(\n\t\t\t\t&EXT4_SB(sb)->s_freeinodes_counter));\n\tBUFFER_TRACE(sbh, \"marking dirty\");\n\text4_superblock_csum_set(sb);\n\tmark_buffer_dirty(sbh);\n\tif (sync) {\n\t\terror = sync_dirty_buffer(sbh);\n\t\tif (error)\n\t\t\treturn error;\n\n\t\terror = buffer_write_io_error(sbh);\n\t\tif (error) {\n\t\t\text4_msg(sb, KERN_ERR, \"I/O error while writing \"\n\t\t\t       \"superblock\");\n\t\t\tclear_buffer_write_io_error(sbh);\n\t\t\tset_buffer_uptodate(sbh);\n\t\t}\n\t}\n\treturn error;\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"mballoc.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include \"ext4_extents.h\"\t/* Needed for trace points definition */",
            "#include \"ext4.h\"",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/crc16.h>",
            "#include <linux/log2.h>",
            "#include <linux/ctype.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/random.h>",
            "#include <linux/vfs.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/parser.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/time.h>",
            "#include <linux/fs.h>",
            "#include <linux/string.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ext4_show_options(struct seq_file *seq, struct dentry *root);",
            "static int ext4_commit_super(struct super_block *sb, int sync);",
            "static void ext4_mark_recovery_complete(struct super_block *sb,\n\t\t\t\t\tstruct ext4_super_block *es);",
            "static void ext4_clear_journal_err(struct super_block *sb,\n\t\t\t\t   struct ext4_super_block *es);",
            "static int ext4_unfreeze(struct super_block *sb);",
            "static int ext4_freeze(struct super_block *sb);",
            "static inline int ext2_feature_set_ok(struct super_block *sb);",
            "static inline int ext3_feature_set_ok(struct super_block *sb);",
            "static void ext4_unregister_li_request(struct super_block *sb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"mballoc.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4_extents.h\"\t/* Needed for trace points definition */\n#include \"ext4.h\"\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <asm/uaccess.h>\n#include <linux/cleancache.h>\n#include <linux/crc16.h>\n#include <linux/log2.h>\n#include <linux/ctype.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/random.h>\n#include <linux/vfs.h>\n#include <linux/exportfs.h>\n#include <linux/buffer_head.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/jbd2.h>\n#include <linux/vmalloc.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n#include <linux/string.h>\n#include <linux/module.h>\n\nstatic int ext4_show_options(struct seq_file *seq, struct dentry *root);\nstatic int ext4_commit_super(struct super_block *sb, int sync);\nstatic void ext4_mark_recovery_complete(struct super_block *sb,\n\t\t\t\t\tstruct ext4_super_block *es);\nstatic void ext4_clear_journal_err(struct super_block *sb,\n\t\t\t\t   struct ext4_super_block *es);\nstatic int ext4_unfreeze(struct super_block *sb);\nstatic int ext4_freeze(struct super_block *sb);\nstatic inline int ext2_feature_set_ok(struct super_block *sb);\nstatic inline int ext3_feature_set_ok(struct super_block *sb);\nstatic void ext4_unregister_li_request(struct super_block *sb);\n\nstatic int ext4_commit_super(struct super_block *sb, int sync)\n{\n\tstruct ext4_super_block *es = EXT4_SB(sb)->s_es;\n\tstruct buffer_head *sbh = EXT4_SB(sb)->s_sbh;\n\tint error = 0;\n\n\tif (!sbh || block_device_ejected(sb))\n\t\treturn error;\n\tif (buffer_write_io_error(sbh)) {\n\t\t/*\n\t\t * Oh, dear.  A previous attempt to write the\n\t\t * superblock failed.  This could happen because the\n\t\t * USB device was yanked out.  Or it could happen to\n\t\t * be a transient write error and maybe the block will\n\t\t * be remapped.  Nothing we can do but to retry the\n\t\t * write and hope for the best.\n\t\t */\n\t\text4_msg(sb, KERN_ERR, \"previous I/O error to \"\n\t\t       \"superblock detected\");\n\t\tclear_buffer_write_io_error(sbh);\n\t\tset_buffer_uptodate(sbh);\n\t}\n\t/*\n\t * If the file system is mounted read-only, don't update the\n\t * superblock write time.  This avoids updating the superblock\n\t * write time when we are mounting the root file system\n\t * read/only but we need to replay the journal; at that point,\n\t * for people who are east of GMT and who make their clock\n\t * tick in localtime for Windows bug-for-bug compatibility,\n\t * the clock is set in the future, and this will cause e2fsck\n\t * to complain and force a full file system check.\n\t */\n\tif (!(sb->s_flags & MS_RDONLY))\n\t\tes->s_wtime = cpu_to_le32(get_seconds());\n\tif (sb->s_bdev->bd_part)\n\t\tes->s_kbytes_written =\n\t\t\tcpu_to_le64(EXT4_SB(sb)->s_kbytes_written +\n\t\t\t    ((part_stat_read(sb->s_bdev->bd_part, sectors[1]) -\n\t\t\t      EXT4_SB(sb)->s_sectors_written_start) >> 1));\n\telse\n\t\tes->s_kbytes_written =\n\t\t\tcpu_to_le64(EXT4_SB(sb)->s_kbytes_written);\n\tif (percpu_counter_initialized(&EXT4_SB(sb)->s_freeclusters_counter))\n\t\text4_free_blocks_count_set(es,\n\t\t\tEXT4_C2B(EXT4_SB(sb), percpu_counter_sum_positive(\n\t\t\t\t&EXT4_SB(sb)->s_freeclusters_counter)));\n\tif (percpu_counter_initialized(&EXT4_SB(sb)->s_freeinodes_counter))\n\t\tes->s_free_inodes_count =\n\t\t\tcpu_to_le32(percpu_counter_sum_positive(\n\t\t\t\t&EXT4_SB(sb)->s_freeinodes_counter));\n\tBUFFER_TRACE(sbh, \"marking dirty\");\n\text4_superblock_csum_set(sb);\n\tmark_buffer_dirty(sbh);\n\tif (sync) {\n\t\terror = sync_dirty_buffer(sbh);\n\t\tif (error)\n\t\t\treturn error;\n\n\t\terror = buffer_write_io_error(sbh);\n\t\tif (error) {\n\t\t\text4_msg(sb, KERN_ERR, \"I/O error while writing \"\n\t\t\t       \"superblock\");\n\t\t\tclear_buffer_write_io_error(sbh);\n\t\t\tset_buffer_uptodate(sbh);\n\t\t}\n\t}\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "__save_error_info",
          "args": [
            "sb",
            "func",
            "line"
          ],
          "line": 322
        },
        "resolved": true,
        "details": {
          "function_name": "__save_error_info",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/super.c",
          "lines": "292-317",
          "snippet": "static void __save_error_info(struct super_block *sb, const char *func,\n\t\t\t    unsigned int line)\n{\n\tstruct ext4_super_block *es = EXT4_SB(sb)->s_es;\n\n\tEXT4_SB(sb)->s_mount_state |= EXT4_ERROR_FS;\n\tes->s_state |= cpu_to_le16(EXT4_ERROR_FS);\n\tes->s_last_error_time = cpu_to_le32(get_seconds());\n\tstrncpy(es->s_last_error_func, func, sizeof(es->s_last_error_func));\n\tes->s_last_error_line = cpu_to_le32(line);\n\tif (!es->s_first_error_time) {\n\t\tes->s_first_error_time = es->s_last_error_time;\n\t\tstrncpy(es->s_first_error_func, func,\n\t\t\tsizeof(es->s_first_error_func));\n\t\tes->s_first_error_line = cpu_to_le32(line);\n\t\tes->s_first_error_ino = es->s_last_error_ino;\n\t\tes->s_first_error_block = es->s_last_error_block;\n\t}\n\t/*\n\t * Start the daily error reporting function if it hasn't been\n\t * started already\n\t */\n\tif (!es->s_error_count)\n\t\tmod_timer(&EXT4_SB(sb)->s_err_report, jiffies + 24*60*60*HZ);\n\tle32_add_cpu(&es->s_error_count, 1);\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"mballoc.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include \"ext4_extents.h\"\t/* Needed for trace points definition */",
            "#include \"ext4.h\"",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/crc16.h>",
            "#include <linux/log2.h>",
            "#include <linux/ctype.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/random.h>",
            "#include <linux/vfs.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/parser.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/time.h>",
            "#include <linux/fs.h>",
            "#include <linux/string.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void ext4_mark_recovery_complete(struct super_block *sb,\n\t\t\t\t\tstruct ext4_super_block *es);",
            "static void ext4_clear_journal_err(struct super_block *sb,\n\t\t\t\t   struct ext4_super_block *es);",
            "static int ext4_unfreeze(struct super_block *sb);",
            "static int ext4_freeze(struct super_block *sb);",
            "static inline int ext2_feature_set_ok(struct super_block *sb);",
            "static inline int ext3_feature_set_ok(struct super_block *sb);",
            "static void ext4_unregister_li_request(struct super_block *sb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"mballoc.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4_extents.h\"\t/* Needed for trace points definition */\n#include \"ext4.h\"\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <asm/uaccess.h>\n#include <linux/cleancache.h>\n#include <linux/crc16.h>\n#include <linux/log2.h>\n#include <linux/ctype.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/random.h>\n#include <linux/vfs.h>\n#include <linux/exportfs.h>\n#include <linux/buffer_head.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/jbd2.h>\n#include <linux/vmalloc.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n#include <linux/string.h>\n#include <linux/module.h>\n\nstatic void ext4_mark_recovery_complete(struct super_block *sb,\n\t\t\t\t\tstruct ext4_super_block *es);\nstatic void ext4_clear_journal_err(struct super_block *sb,\n\t\t\t\t   struct ext4_super_block *es);\nstatic int ext4_unfreeze(struct super_block *sb);\nstatic int ext4_freeze(struct super_block *sb);\nstatic inline int ext2_feature_set_ok(struct super_block *sb);\nstatic inline int ext3_feature_set_ok(struct super_block *sb);\nstatic void ext4_unregister_li_request(struct super_block *sb);\n\nstatic void __save_error_info(struct super_block *sb, const char *func,\n\t\t\t    unsigned int line)\n{\n\tstruct ext4_super_block *es = EXT4_SB(sb)->s_es;\n\n\tEXT4_SB(sb)->s_mount_state |= EXT4_ERROR_FS;\n\tes->s_state |= cpu_to_le16(EXT4_ERROR_FS);\n\tes->s_last_error_time = cpu_to_le32(get_seconds());\n\tstrncpy(es->s_last_error_func, func, sizeof(es->s_last_error_func));\n\tes->s_last_error_line = cpu_to_le32(line);\n\tif (!es->s_first_error_time) {\n\t\tes->s_first_error_time = es->s_last_error_time;\n\t\tstrncpy(es->s_first_error_func, func,\n\t\t\tsizeof(es->s_first_error_func));\n\t\tes->s_first_error_line = cpu_to_le32(line);\n\t\tes->s_first_error_ino = es->s_last_error_ino;\n\t\tes->s_first_error_block = es->s_last_error_block;\n\t}\n\t/*\n\t * Start the daily error reporting function if it hasn't been\n\t * started already\n\t */\n\tif (!es->s_error_count)\n\t\tmod_timer(&EXT4_SB(sb)->s_err_report, jiffies + 24*60*60*HZ);\n\tle32_add_cpu(&es->s_error_count, 1);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"mballoc.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4_extents.h\"\t/* Needed for trace points definition */\n#include \"ext4.h\"\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <asm/uaccess.h>\n#include <linux/cleancache.h>\n#include <linux/crc16.h>\n#include <linux/log2.h>\n#include <linux/ctype.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/random.h>\n#include <linux/vfs.h>\n#include <linux/exportfs.h>\n#include <linux/buffer_head.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/jbd2.h>\n#include <linux/vmalloc.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n#include <linux/string.h>\n#include <linux/module.h>\n\nstatic int ext4_unfreeze(struct super_block *sb);\nstatic int ext4_freeze(struct super_block *sb);\nstatic inline int ext2_feature_set_ok(struct super_block *sb);\nstatic inline int ext3_feature_set_ok(struct super_block *sb);\nstatic void ext4_unregister_li_request(struct super_block *sb);\n\nstatic void save_error_info(struct super_block *sb, const char *func,\n\t\t\t    unsigned int line)\n{\n\t__save_error_info(sb, func, line);\n\text4_commit_super(sb, 1);\n}"
  },
  {
    "function_name": "__save_error_info",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/super.c",
    "lines": "292-317",
    "snippet": "static void __save_error_info(struct super_block *sb, const char *func,\n\t\t\t    unsigned int line)\n{\n\tstruct ext4_super_block *es = EXT4_SB(sb)->s_es;\n\n\tEXT4_SB(sb)->s_mount_state |= EXT4_ERROR_FS;\n\tes->s_state |= cpu_to_le16(EXT4_ERROR_FS);\n\tes->s_last_error_time = cpu_to_le32(get_seconds());\n\tstrncpy(es->s_last_error_func, func, sizeof(es->s_last_error_func));\n\tes->s_last_error_line = cpu_to_le32(line);\n\tif (!es->s_first_error_time) {\n\t\tes->s_first_error_time = es->s_last_error_time;\n\t\tstrncpy(es->s_first_error_func, func,\n\t\t\tsizeof(es->s_first_error_func));\n\t\tes->s_first_error_line = cpu_to_le32(line);\n\t\tes->s_first_error_ino = es->s_last_error_ino;\n\t\tes->s_first_error_block = es->s_last_error_block;\n\t}\n\t/*\n\t * Start the daily error reporting function if it hasn't been\n\t * started already\n\t */\n\tif (!es->s_error_count)\n\t\tmod_timer(&EXT4_SB(sb)->s_err_report, jiffies + 24*60*60*HZ);\n\tle32_add_cpu(&es->s_error_count, 1);\n}",
    "includes": [
      "#include <trace/events/ext4.h>",
      "#include \"mballoc.h\"",
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"ext4_jbd2.h\"",
      "#include \"ext4_extents.h\"\t/* Needed for trace points definition */",
      "#include \"ext4.h\"",
      "#include <linux/freezer.h>",
      "#include <linux/kthread.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/cleancache.h>",
      "#include <linux/crc16.h>",
      "#include <linux/log2.h>",
      "#include <linux/ctype.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/namei.h>",
      "#include <linux/mount.h>",
      "#include <linux/random.h>",
      "#include <linux/vfs.h>",
      "#include <linux/exportfs.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/parser.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/init.h>",
      "#include <linux/slab.h>",
      "#include <linux/jbd2.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/time.h>",
      "#include <linux/fs.h>",
      "#include <linux/string.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void ext4_mark_recovery_complete(struct super_block *sb,\n\t\t\t\t\tstruct ext4_super_block *es);",
      "static void ext4_clear_journal_err(struct super_block *sb,\n\t\t\t\t   struct ext4_super_block *es);",
      "static int ext4_unfreeze(struct super_block *sb);",
      "static int ext4_freeze(struct super_block *sb);",
      "static inline int ext2_feature_set_ok(struct super_block *sb);",
      "static inline int ext3_feature_set_ok(struct super_block *sb);",
      "static void ext4_unregister_li_request(struct super_block *sb);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "le32_add_cpu",
          "args": [
            "&es->s_error_count",
            "1"
          ],
          "line": 316
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mod_timer",
          "args": [
            "&EXT4_SB(sb)->s_err_report",
            "jiffies + 24*60*60*HZ"
          ],
          "line": 315
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXT4_SB",
          "args": [
            "sb"
          ],
          "line": 315
        },
        "resolved": true,
        "details": {
          "function_name": "EXT4_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ext4.h",
          "lines": "1356-1359",
          "snippet": "static inline struct ext4_sb_info *EXT4_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include \"extents_status.h\"",
            "#include <linux/compat.h>",
            "#include <linux/falloc.h>",
            "#include <crypto/hash.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/wait.h>",
            "#include <linux/timer.h>",
            "#include <linux/mutex.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/quota.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extents_status.h\"\n#include <linux/compat.h>\n#include <linux/falloc.h>\n#include <crypto/hash.h>\n#include <linux/ratelimit.h>\n#include <linux/percpu_counter.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/wait.h>\n#include <linux/timer.h>\n#include <linux/mutex.h>\n#include <linux/seqlock.h>\n#include <linux/rbtree.h>\n#include <linux/rwsem.h>\n#include <linux/quota.h>\n#include <linux/jbd2.h>\n#include <linux/magic.h>\n#include <linux/blkdev.h>\n#include <linux/types.h>\n\nstatic inline struct ext4_sb_info *EXT4_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "line"
          ],
          "line": 306
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncpy",
          "args": [
            "es->s_first_error_func",
            "func",
            "sizeof(es->s_first_error_func)"
          ],
          "line": 304
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "line"
          ],
          "line": 301
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncpy",
          "args": [
            "es->s_last_error_func",
            "func",
            "sizeof(es->s_last_error_func)"
          ],
          "line": 300
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "get_seconds()"
          ],
          "line": 299
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_seconds",
          "args": [],
          "line": 299
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "EXT4_ERROR_FS"
          ],
          "line": 298
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"mballoc.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4_extents.h\"\t/* Needed for trace points definition */\n#include \"ext4.h\"\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <asm/uaccess.h>\n#include <linux/cleancache.h>\n#include <linux/crc16.h>\n#include <linux/log2.h>\n#include <linux/ctype.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/random.h>\n#include <linux/vfs.h>\n#include <linux/exportfs.h>\n#include <linux/buffer_head.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/jbd2.h>\n#include <linux/vmalloc.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n#include <linux/string.h>\n#include <linux/module.h>\n\nstatic void ext4_mark_recovery_complete(struct super_block *sb,\n\t\t\t\t\tstruct ext4_super_block *es);\nstatic void ext4_clear_journal_err(struct super_block *sb,\n\t\t\t\t   struct ext4_super_block *es);\nstatic int ext4_unfreeze(struct super_block *sb);\nstatic int ext4_freeze(struct super_block *sb);\nstatic inline int ext2_feature_set_ok(struct super_block *sb);\nstatic inline int ext3_feature_set_ok(struct super_block *sb);\nstatic void ext4_unregister_li_request(struct super_block *sb);\n\nstatic void __save_error_info(struct super_block *sb, const char *func,\n\t\t\t    unsigned int line)\n{\n\tstruct ext4_super_block *es = EXT4_SB(sb)->s_es;\n\n\tEXT4_SB(sb)->s_mount_state |= EXT4_ERROR_FS;\n\tes->s_state |= cpu_to_le16(EXT4_ERROR_FS);\n\tes->s_last_error_time = cpu_to_le32(get_seconds());\n\tstrncpy(es->s_last_error_func, func, sizeof(es->s_last_error_func));\n\tes->s_last_error_line = cpu_to_le32(line);\n\tif (!es->s_first_error_time) {\n\t\tes->s_first_error_time = es->s_last_error_time;\n\t\tstrncpy(es->s_first_error_func, func,\n\t\t\tsizeof(es->s_first_error_func));\n\t\tes->s_first_error_line = cpu_to_le32(line);\n\t\tes->s_first_error_ino = es->s_last_error_ino;\n\t\tes->s_first_error_block = es->s_last_error_block;\n\t}\n\t/*\n\t * Start the daily error reporting function if it hasn't been\n\t * started already\n\t */\n\tif (!es->s_error_count)\n\t\tmod_timer(&EXT4_SB(sb)->s_err_report, jiffies + 24*60*60*HZ);\n\tle32_add_cpu(&es->s_error_count, 1);\n}"
  },
  {
    "function_name": "ext4_itable_unused_set",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/super.c",
    "lines": "283-289",
    "snippet": "void ext4_itable_unused_set(struct super_block *sb,\n\t\t\t  struct ext4_group_desc *bg, __u32 count)\n{\n\tbg->bg_itable_unused_lo = cpu_to_le16((__u16)count);\n\tif (EXT4_DESC_SIZE(sb) >= EXT4_MIN_DESC_SIZE_64BIT)\n\t\tbg->bg_itable_unused_hi = cpu_to_le16(count >> 16);\n}",
    "includes": [
      "#include <trace/events/ext4.h>",
      "#include \"mballoc.h\"",
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"ext4_jbd2.h\"",
      "#include \"ext4_extents.h\"\t/* Needed for trace points definition */",
      "#include \"ext4.h\"",
      "#include <linux/freezer.h>",
      "#include <linux/kthread.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/cleancache.h>",
      "#include <linux/crc16.h>",
      "#include <linux/log2.h>",
      "#include <linux/ctype.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/namei.h>",
      "#include <linux/mount.h>",
      "#include <linux/random.h>",
      "#include <linux/vfs.h>",
      "#include <linux/exportfs.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/parser.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/init.h>",
      "#include <linux/slab.h>",
      "#include <linux/jbd2.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/time.h>",
      "#include <linux/fs.h>",
      "#include <linux/string.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ext4_unfreeze(struct super_block *sb);",
      "static int ext4_freeze(struct super_block *sb);",
      "static inline int ext2_feature_set_ok(struct super_block *sb);",
      "static inline int ext3_feature_set_ok(struct super_block *sb);",
      "static void ext4_unregister_li_request(struct super_block *sb);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "count >> 16"
          ],
          "line": 288
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXT4_DESC_SIZE",
          "args": [
            "sb"
          ],
          "line": 287
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "(__u16)count"
          ],
          "line": 286
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"mballoc.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4_extents.h\"\t/* Needed for trace points definition */\n#include \"ext4.h\"\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <asm/uaccess.h>\n#include <linux/cleancache.h>\n#include <linux/crc16.h>\n#include <linux/log2.h>\n#include <linux/ctype.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/random.h>\n#include <linux/vfs.h>\n#include <linux/exportfs.h>\n#include <linux/buffer_head.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/jbd2.h>\n#include <linux/vmalloc.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n#include <linux/string.h>\n#include <linux/module.h>\n\nstatic int ext4_unfreeze(struct super_block *sb);\nstatic int ext4_freeze(struct super_block *sb);\nstatic inline int ext2_feature_set_ok(struct super_block *sb);\nstatic inline int ext3_feature_set_ok(struct super_block *sb);\nstatic void ext4_unregister_li_request(struct super_block *sb);\n\nvoid ext4_itable_unused_set(struct super_block *sb,\n\t\t\t  struct ext4_group_desc *bg, __u32 count)\n{\n\tbg->bg_itable_unused_lo = cpu_to_le16((__u16)count);\n\tif (EXT4_DESC_SIZE(sb) >= EXT4_MIN_DESC_SIZE_64BIT)\n\t\tbg->bg_itable_unused_hi = cpu_to_le16(count >> 16);\n}"
  },
  {
    "function_name": "ext4_used_dirs_set",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/super.c",
    "lines": "275-281",
    "snippet": "void ext4_used_dirs_set(struct super_block *sb,\n\t\t\t  struct ext4_group_desc *bg, __u32 count)\n{\n\tbg->bg_used_dirs_count_lo = cpu_to_le16((__u16)count);\n\tif (EXT4_DESC_SIZE(sb) >= EXT4_MIN_DESC_SIZE_64BIT)\n\t\tbg->bg_used_dirs_count_hi = cpu_to_le16(count >> 16);\n}",
    "includes": [
      "#include <trace/events/ext4.h>",
      "#include \"mballoc.h\"",
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"ext4_jbd2.h\"",
      "#include \"ext4_extents.h\"\t/* Needed for trace points definition */",
      "#include \"ext4.h\"",
      "#include <linux/freezer.h>",
      "#include <linux/kthread.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/cleancache.h>",
      "#include <linux/crc16.h>",
      "#include <linux/log2.h>",
      "#include <linux/ctype.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/namei.h>",
      "#include <linux/mount.h>",
      "#include <linux/random.h>",
      "#include <linux/vfs.h>",
      "#include <linux/exportfs.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/parser.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/init.h>",
      "#include <linux/slab.h>",
      "#include <linux/jbd2.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/time.h>",
      "#include <linux/fs.h>",
      "#include <linux/string.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ext4_unfreeze(struct super_block *sb);",
      "static int ext4_freeze(struct super_block *sb);",
      "static inline int ext2_feature_set_ok(struct super_block *sb);",
      "static inline int ext3_feature_set_ok(struct super_block *sb);",
      "static void ext4_unregister_li_request(struct super_block *sb);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "count >> 16"
          ],
          "line": 280
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXT4_DESC_SIZE",
          "args": [
            "sb"
          ],
          "line": 279
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "(__u16)count"
          ],
          "line": 278
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"mballoc.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4_extents.h\"\t/* Needed for trace points definition */\n#include \"ext4.h\"\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <asm/uaccess.h>\n#include <linux/cleancache.h>\n#include <linux/crc16.h>\n#include <linux/log2.h>\n#include <linux/ctype.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/random.h>\n#include <linux/vfs.h>\n#include <linux/exportfs.h>\n#include <linux/buffer_head.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/jbd2.h>\n#include <linux/vmalloc.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n#include <linux/string.h>\n#include <linux/module.h>\n\nstatic int ext4_unfreeze(struct super_block *sb);\nstatic int ext4_freeze(struct super_block *sb);\nstatic inline int ext2_feature_set_ok(struct super_block *sb);\nstatic inline int ext3_feature_set_ok(struct super_block *sb);\nstatic void ext4_unregister_li_request(struct super_block *sb);\n\nvoid ext4_used_dirs_set(struct super_block *sb,\n\t\t\t  struct ext4_group_desc *bg, __u32 count)\n{\n\tbg->bg_used_dirs_count_lo = cpu_to_le16((__u16)count);\n\tif (EXT4_DESC_SIZE(sb) >= EXT4_MIN_DESC_SIZE_64BIT)\n\t\tbg->bg_used_dirs_count_hi = cpu_to_le16(count >> 16);\n}"
  },
  {
    "function_name": "ext4_free_inodes_set",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/super.c",
    "lines": "267-273",
    "snippet": "void ext4_free_inodes_set(struct super_block *sb,\n\t\t\t  struct ext4_group_desc *bg, __u32 count)\n{\n\tbg->bg_free_inodes_count_lo = cpu_to_le16((__u16)count);\n\tif (EXT4_DESC_SIZE(sb) >= EXT4_MIN_DESC_SIZE_64BIT)\n\t\tbg->bg_free_inodes_count_hi = cpu_to_le16(count >> 16);\n}",
    "includes": [
      "#include <trace/events/ext4.h>",
      "#include \"mballoc.h\"",
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"ext4_jbd2.h\"",
      "#include \"ext4_extents.h\"\t/* Needed for trace points definition */",
      "#include \"ext4.h\"",
      "#include <linux/freezer.h>",
      "#include <linux/kthread.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/cleancache.h>",
      "#include <linux/crc16.h>",
      "#include <linux/log2.h>",
      "#include <linux/ctype.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/namei.h>",
      "#include <linux/mount.h>",
      "#include <linux/random.h>",
      "#include <linux/vfs.h>",
      "#include <linux/exportfs.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/parser.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/init.h>",
      "#include <linux/slab.h>",
      "#include <linux/jbd2.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/time.h>",
      "#include <linux/fs.h>",
      "#include <linux/string.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ext4_unfreeze(struct super_block *sb);",
      "static int ext4_freeze(struct super_block *sb);",
      "static inline int ext2_feature_set_ok(struct super_block *sb);",
      "static inline int ext3_feature_set_ok(struct super_block *sb);",
      "static void ext4_unregister_li_request(struct super_block *sb);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "count >> 16"
          ],
          "line": 272
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXT4_DESC_SIZE",
          "args": [
            "sb"
          ],
          "line": 271
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "(__u16)count"
          ],
          "line": 270
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"mballoc.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4_extents.h\"\t/* Needed for trace points definition */\n#include \"ext4.h\"\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <asm/uaccess.h>\n#include <linux/cleancache.h>\n#include <linux/crc16.h>\n#include <linux/log2.h>\n#include <linux/ctype.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/random.h>\n#include <linux/vfs.h>\n#include <linux/exportfs.h>\n#include <linux/buffer_head.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/jbd2.h>\n#include <linux/vmalloc.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n#include <linux/string.h>\n#include <linux/module.h>\n\nstatic int ext4_unfreeze(struct super_block *sb);\nstatic int ext4_freeze(struct super_block *sb);\nstatic inline int ext2_feature_set_ok(struct super_block *sb);\nstatic inline int ext3_feature_set_ok(struct super_block *sb);\nstatic void ext4_unregister_li_request(struct super_block *sb);\n\nvoid ext4_free_inodes_set(struct super_block *sb,\n\t\t\t  struct ext4_group_desc *bg, __u32 count)\n{\n\tbg->bg_free_inodes_count_lo = cpu_to_le16((__u16)count);\n\tif (EXT4_DESC_SIZE(sb) >= EXT4_MIN_DESC_SIZE_64BIT)\n\t\tbg->bg_free_inodes_count_hi = cpu_to_le16(count >> 16);\n}"
  },
  {
    "function_name": "ext4_free_group_clusters_set",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/super.c",
    "lines": "259-265",
    "snippet": "void ext4_free_group_clusters_set(struct super_block *sb,\n\t\t\t\t  struct ext4_group_desc *bg, __u32 count)\n{\n\tbg->bg_free_blocks_count_lo = cpu_to_le16((__u16)count);\n\tif (EXT4_DESC_SIZE(sb) >= EXT4_MIN_DESC_SIZE_64BIT)\n\t\tbg->bg_free_blocks_count_hi = cpu_to_le16(count >> 16);\n}",
    "includes": [
      "#include <trace/events/ext4.h>",
      "#include \"mballoc.h\"",
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"ext4_jbd2.h\"",
      "#include \"ext4_extents.h\"\t/* Needed for trace points definition */",
      "#include \"ext4.h\"",
      "#include <linux/freezer.h>",
      "#include <linux/kthread.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/cleancache.h>",
      "#include <linux/crc16.h>",
      "#include <linux/log2.h>",
      "#include <linux/ctype.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/namei.h>",
      "#include <linux/mount.h>",
      "#include <linux/random.h>",
      "#include <linux/vfs.h>",
      "#include <linux/exportfs.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/parser.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/init.h>",
      "#include <linux/slab.h>",
      "#include <linux/jbd2.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/time.h>",
      "#include <linux/fs.h>",
      "#include <linux/string.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ext4_unfreeze(struct super_block *sb);",
      "static int ext4_freeze(struct super_block *sb);",
      "static inline int ext2_feature_set_ok(struct super_block *sb);",
      "static inline int ext3_feature_set_ok(struct super_block *sb);",
      "static void ext4_unregister_li_request(struct super_block *sb);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "count >> 16"
          ],
          "line": 264
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXT4_DESC_SIZE",
          "args": [
            "sb"
          ],
          "line": 263
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "(__u16)count"
          ],
          "line": 262
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"mballoc.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4_extents.h\"\t/* Needed for trace points definition */\n#include \"ext4.h\"\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <asm/uaccess.h>\n#include <linux/cleancache.h>\n#include <linux/crc16.h>\n#include <linux/log2.h>\n#include <linux/ctype.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/random.h>\n#include <linux/vfs.h>\n#include <linux/exportfs.h>\n#include <linux/buffer_head.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/jbd2.h>\n#include <linux/vmalloc.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n#include <linux/string.h>\n#include <linux/module.h>\n\nstatic int ext4_unfreeze(struct super_block *sb);\nstatic int ext4_freeze(struct super_block *sb);\nstatic inline int ext2_feature_set_ok(struct super_block *sb);\nstatic inline int ext3_feature_set_ok(struct super_block *sb);\nstatic void ext4_unregister_li_request(struct super_block *sb);\n\nvoid ext4_free_group_clusters_set(struct super_block *sb,\n\t\t\t\t  struct ext4_group_desc *bg, __u32 count)\n{\n\tbg->bg_free_blocks_count_lo = cpu_to_le16((__u16)count);\n\tif (EXT4_DESC_SIZE(sb) >= EXT4_MIN_DESC_SIZE_64BIT)\n\t\tbg->bg_free_blocks_count_hi = cpu_to_le16(count >> 16);\n}"
  },
  {
    "function_name": "ext4_inode_table_set",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/super.c",
    "lines": "251-257",
    "snippet": "void ext4_inode_table_set(struct super_block *sb,\n\t\t\t  struct ext4_group_desc *bg, ext4_fsblk_t blk)\n{\n\tbg->bg_inode_table_lo = cpu_to_le32((u32)blk);\n\tif (EXT4_DESC_SIZE(sb) >= EXT4_MIN_DESC_SIZE_64BIT)\n\t\tbg->bg_inode_table_hi = cpu_to_le32(blk >> 32);\n}",
    "includes": [
      "#include <trace/events/ext4.h>",
      "#include \"mballoc.h\"",
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"ext4_jbd2.h\"",
      "#include \"ext4_extents.h\"\t/* Needed for trace points definition */",
      "#include \"ext4.h\"",
      "#include <linux/freezer.h>",
      "#include <linux/kthread.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/cleancache.h>",
      "#include <linux/crc16.h>",
      "#include <linux/log2.h>",
      "#include <linux/ctype.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/namei.h>",
      "#include <linux/mount.h>",
      "#include <linux/random.h>",
      "#include <linux/vfs.h>",
      "#include <linux/exportfs.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/parser.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/init.h>",
      "#include <linux/slab.h>",
      "#include <linux/jbd2.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/time.h>",
      "#include <linux/fs.h>",
      "#include <linux/string.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ext4_unfreeze(struct super_block *sb);",
      "static int ext4_freeze(struct super_block *sb);",
      "static inline int ext2_feature_set_ok(struct super_block *sb);",
      "static inline int ext3_feature_set_ok(struct super_block *sb);",
      "static void ext4_unregister_li_request(struct super_block *sb);",
      "static int ext4_reserve_clusters(struct ext4_sb_info *, ext4_fsblk_t);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "blk >> 32"
          ],
          "line": 256
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXT4_DESC_SIZE",
          "args": [
            "sb"
          ],
          "line": 255
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "(u32)blk"
          ],
          "line": 254
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"mballoc.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4_extents.h\"\t/* Needed for trace points definition */\n#include \"ext4.h\"\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <asm/uaccess.h>\n#include <linux/cleancache.h>\n#include <linux/crc16.h>\n#include <linux/log2.h>\n#include <linux/ctype.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/random.h>\n#include <linux/vfs.h>\n#include <linux/exportfs.h>\n#include <linux/buffer_head.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/jbd2.h>\n#include <linux/vmalloc.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n#include <linux/string.h>\n#include <linux/module.h>\n\nstatic int ext4_unfreeze(struct super_block *sb);\nstatic int ext4_freeze(struct super_block *sb);\nstatic inline int ext2_feature_set_ok(struct super_block *sb);\nstatic inline int ext3_feature_set_ok(struct super_block *sb);\nstatic void ext4_unregister_li_request(struct super_block *sb);\nstatic int ext4_reserve_clusters(struct ext4_sb_info *, ext4_fsblk_t);\n\nvoid ext4_inode_table_set(struct super_block *sb,\n\t\t\t  struct ext4_group_desc *bg, ext4_fsblk_t blk)\n{\n\tbg->bg_inode_table_lo = cpu_to_le32((u32)blk);\n\tif (EXT4_DESC_SIZE(sb) >= EXT4_MIN_DESC_SIZE_64BIT)\n\t\tbg->bg_inode_table_hi = cpu_to_le32(blk >> 32);\n}"
  },
  {
    "function_name": "ext4_inode_bitmap_set",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/super.c",
    "lines": "243-249",
    "snippet": "void ext4_inode_bitmap_set(struct super_block *sb,\n\t\t\t   struct ext4_group_desc *bg, ext4_fsblk_t blk)\n{\n\tbg->bg_inode_bitmap_lo  = cpu_to_le32((u32)blk);\n\tif (EXT4_DESC_SIZE(sb) >= EXT4_MIN_DESC_SIZE_64BIT)\n\t\tbg->bg_inode_bitmap_hi = cpu_to_le32(blk >> 32);\n}",
    "includes": [
      "#include <trace/events/ext4.h>",
      "#include \"mballoc.h\"",
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"ext4_jbd2.h\"",
      "#include \"ext4_extents.h\"\t/* Needed for trace points definition */",
      "#include \"ext4.h\"",
      "#include <linux/freezer.h>",
      "#include <linux/kthread.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/cleancache.h>",
      "#include <linux/crc16.h>",
      "#include <linux/log2.h>",
      "#include <linux/ctype.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/namei.h>",
      "#include <linux/mount.h>",
      "#include <linux/random.h>",
      "#include <linux/vfs.h>",
      "#include <linux/exportfs.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/parser.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/init.h>",
      "#include <linux/slab.h>",
      "#include <linux/jbd2.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/time.h>",
      "#include <linux/fs.h>",
      "#include <linux/string.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ext4_unfreeze(struct super_block *sb);",
      "static int ext4_freeze(struct super_block *sb);",
      "static inline int ext2_feature_set_ok(struct super_block *sb);",
      "static inline int ext3_feature_set_ok(struct super_block *sb);",
      "static void ext4_unregister_li_request(struct super_block *sb);",
      "static int ext4_reserve_clusters(struct ext4_sb_info *, ext4_fsblk_t);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "blk >> 32"
          ],
          "line": 248
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXT4_DESC_SIZE",
          "args": [
            "sb"
          ],
          "line": 247
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "(u32)blk"
          ],
          "line": 246
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"mballoc.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4_extents.h\"\t/* Needed for trace points definition */\n#include \"ext4.h\"\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <asm/uaccess.h>\n#include <linux/cleancache.h>\n#include <linux/crc16.h>\n#include <linux/log2.h>\n#include <linux/ctype.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/random.h>\n#include <linux/vfs.h>\n#include <linux/exportfs.h>\n#include <linux/buffer_head.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/jbd2.h>\n#include <linux/vmalloc.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n#include <linux/string.h>\n#include <linux/module.h>\n\nstatic int ext4_unfreeze(struct super_block *sb);\nstatic int ext4_freeze(struct super_block *sb);\nstatic inline int ext2_feature_set_ok(struct super_block *sb);\nstatic inline int ext3_feature_set_ok(struct super_block *sb);\nstatic void ext4_unregister_li_request(struct super_block *sb);\nstatic int ext4_reserve_clusters(struct ext4_sb_info *, ext4_fsblk_t);\n\nvoid ext4_inode_bitmap_set(struct super_block *sb,\n\t\t\t   struct ext4_group_desc *bg, ext4_fsblk_t blk)\n{\n\tbg->bg_inode_bitmap_lo  = cpu_to_le32((u32)blk);\n\tif (EXT4_DESC_SIZE(sb) >= EXT4_MIN_DESC_SIZE_64BIT)\n\t\tbg->bg_inode_bitmap_hi = cpu_to_le32(blk >> 32);\n}"
  },
  {
    "function_name": "ext4_block_bitmap_set",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/super.c",
    "lines": "235-241",
    "snippet": "void ext4_block_bitmap_set(struct super_block *sb,\n\t\t\t   struct ext4_group_desc *bg, ext4_fsblk_t blk)\n{\n\tbg->bg_block_bitmap_lo = cpu_to_le32((u32)blk);\n\tif (EXT4_DESC_SIZE(sb) >= EXT4_MIN_DESC_SIZE_64BIT)\n\t\tbg->bg_block_bitmap_hi = cpu_to_le32(blk >> 32);\n}",
    "includes": [
      "#include <trace/events/ext4.h>",
      "#include \"mballoc.h\"",
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"ext4_jbd2.h\"",
      "#include \"ext4_extents.h\"\t/* Needed for trace points definition */",
      "#include \"ext4.h\"",
      "#include <linux/freezer.h>",
      "#include <linux/kthread.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/cleancache.h>",
      "#include <linux/crc16.h>",
      "#include <linux/log2.h>",
      "#include <linux/ctype.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/namei.h>",
      "#include <linux/mount.h>",
      "#include <linux/random.h>",
      "#include <linux/vfs.h>",
      "#include <linux/exportfs.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/parser.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/init.h>",
      "#include <linux/slab.h>",
      "#include <linux/jbd2.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/time.h>",
      "#include <linux/fs.h>",
      "#include <linux/string.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ext4_unfreeze(struct super_block *sb);",
      "static int ext4_freeze(struct super_block *sb);",
      "static inline int ext2_feature_set_ok(struct super_block *sb);",
      "static inline int ext3_feature_set_ok(struct super_block *sb);",
      "static void ext4_unregister_li_request(struct super_block *sb);",
      "static int ext4_reserve_clusters(struct ext4_sb_info *, ext4_fsblk_t);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "blk >> 32"
          ],
          "line": 240
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXT4_DESC_SIZE",
          "args": [
            "sb"
          ],
          "line": 239
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "(u32)blk"
          ],
          "line": 238
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"mballoc.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4_extents.h\"\t/* Needed for trace points definition */\n#include \"ext4.h\"\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <asm/uaccess.h>\n#include <linux/cleancache.h>\n#include <linux/crc16.h>\n#include <linux/log2.h>\n#include <linux/ctype.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/random.h>\n#include <linux/vfs.h>\n#include <linux/exportfs.h>\n#include <linux/buffer_head.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/jbd2.h>\n#include <linux/vmalloc.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n#include <linux/string.h>\n#include <linux/module.h>\n\nstatic int ext4_unfreeze(struct super_block *sb);\nstatic int ext4_freeze(struct super_block *sb);\nstatic inline int ext2_feature_set_ok(struct super_block *sb);\nstatic inline int ext3_feature_set_ok(struct super_block *sb);\nstatic void ext4_unregister_li_request(struct super_block *sb);\nstatic int ext4_reserve_clusters(struct ext4_sb_info *, ext4_fsblk_t);\n\nvoid ext4_block_bitmap_set(struct super_block *sb,\n\t\t\t   struct ext4_group_desc *bg, ext4_fsblk_t blk)\n{\n\tbg->bg_block_bitmap_lo = cpu_to_le32((u32)blk);\n\tif (EXT4_DESC_SIZE(sb) >= EXT4_MIN_DESC_SIZE_64BIT)\n\t\tbg->bg_block_bitmap_hi = cpu_to_le32(blk >> 32);\n}"
  },
  {
    "function_name": "ext4_itable_unused_count",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/super.c",
    "lines": "227-233",
    "snippet": "__u32 ext4_itable_unused_count(struct super_block *sb,\n\t\t\t      struct ext4_group_desc *bg)\n{\n\treturn le16_to_cpu(bg->bg_itable_unused_lo) |\n\t\t(EXT4_DESC_SIZE(sb) >= EXT4_MIN_DESC_SIZE_64BIT ?\n\t\t (__u32)le16_to_cpu(bg->bg_itable_unused_hi) << 16 : 0);\n}",
    "includes": [
      "#include <trace/events/ext4.h>",
      "#include \"mballoc.h\"",
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"ext4_jbd2.h\"",
      "#include \"ext4_extents.h\"\t/* Needed for trace points definition */",
      "#include \"ext4.h\"",
      "#include <linux/freezer.h>",
      "#include <linux/kthread.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/cleancache.h>",
      "#include <linux/crc16.h>",
      "#include <linux/log2.h>",
      "#include <linux/ctype.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/namei.h>",
      "#include <linux/mount.h>",
      "#include <linux/random.h>",
      "#include <linux/vfs.h>",
      "#include <linux/exportfs.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/parser.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/init.h>",
      "#include <linux/slab.h>",
      "#include <linux/jbd2.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/time.h>",
      "#include <linux/fs.h>",
      "#include <linux/string.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ext4_unfreeze(struct super_block *sb);",
      "static int ext4_freeze(struct super_block *sb);",
      "static inline int ext2_feature_set_ok(struct super_block *sb);",
      "static inline int ext3_feature_set_ok(struct super_block *sb);",
      "static void ext4_unregister_li_request(struct super_block *sb);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "le16_to_cpu",
          "args": [
            "bg->bg_itable_unused_hi"
          ],
          "line": 232
        },
        "resolved": true,
        "details": {
          "function_name": "sle16_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "48-51",
          "snippet": "static inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "EXT4_DESC_SIZE",
          "args": [
            "sb"
          ],
          "line": 231
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"mballoc.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4_extents.h\"\t/* Needed for trace points definition */\n#include \"ext4.h\"\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <asm/uaccess.h>\n#include <linux/cleancache.h>\n#include <linux/crc16.h>\n#include <linux/log2.h>\n#include <linux/ctype.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/random.h>\n#include <linux/vfs.h>\n#include <linux/exportfs.h>\n#include <linux/buffer_head.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/jbd2.h>\n#include <linux/vmalloc.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n#include <linux/string.h>\n#include <linux/module.h>\n\nstatic int ext4_unfreeze(struct super_block *sb);\nstatic int ext4_freeze(struct super_block *sb);\nstatic inline int ext2_feature_set_ok(struct super_block *sb);\nstatic inline int ext3_feature_set_ok(struct super_block *sb);\nstatic void ext4_unregister_li_request(struct super_block *sb);\n\n__u32 ext4_itable_unused_count(struct super_block *sb,\n\t\t\t      struct ext4_group_desc *bg)\n{\n\treturn le16_to_cpu(bg->bg_itable_unused_lo) |\n\t\t(EXT4_DESC_SIZE(sb) >= EXT4_MIN_DESC_SIZE_64BIT ?\n\t\t (__u32)le16_to_cpu(bg->bg_itable_unused_hi) << 16 : 0);\n}"
  },
  {
    "function_name": "ext4_used_dirs_count",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/super.c",
    "lines": "219-225",
    "snippet": "__u32 ext4_used_dirs_count(struct super_block *sb,\n\t\t\t      struct ext4_group_desc *bg)\n{\n\treturn le16_to_cpu(bg->bg_used_dirs_count_lo) |\n\t\t(EXT4_DESC_SIZE(sb) >= EXT4_MIN_DESC_SIZE_64BIT ?\n\t\t (__u32)le16_to_cpu(bg->bg_used_dirs_count_hi) << 16 : 0);\n}",
    "includes": [
      "#include <trace/events/ext4.h>",
      "#include \"mballoc.h\"",
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"ext4_jbd2.h\"",
      "#include \"ext4_extents.h\"\t/* Needed for trace points definition */",
      "#include \"ext4.h\"",
      "#include <linux/freezer.h>",
      "#include <linux/kthread.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/cleancache.h>",
      "#include <linux/crc16.h>",
      "#include <linux/log2.h>",
      "#include <linux/ctype.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/namei.h>",
      "#include <linux/mount.h>",
      "#include <linux/random.h>",
      "#include <linux/vfs.h>",
      "#include <linux/exportfs.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/parser.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/init.h>",
      "#include <linux/slab.h>",
      "#include <linux/jbd2.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/time.h>",
      "#include <linux/fs.h>",
      "#include <linux/string.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ext4_unfreeze(struct super_block *sb);",
      "static int ext4_freeze(struct super_block *sb);",
      "static inline int ext2_feature_set_ok(struct super_block *sb);",
      "static inline int ext3_feature_set_ok(struct super_block *sb);",
      "static void ext4_unregister_li_request(struct super_block *sb);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "le16_to_cpu",
          "args": [
            "bg->bg_used_dirs_count_hi"
          ],
          "line": 224
        },
        "resolved": true,
        "details": {
          "function_name": "sle16_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "48-51",
          "snippet": "static inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "EXT4_DESC_SIZE",
          "args": [
            "sb"
          ],
          "line": 223
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"mballoc.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4_extents.h\"\t/* Needed for trace points definition */\n#include \"ext4.h\"\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <asm/uaccess.h>\n#include <linux/cleancache.h>\n#include <linux/crc16.h>\n#include <linux/log2.h>\n#include <linux/ctype.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/random.h>\n#include <linux/vfs.h>\n#include <linux/exportfs.h>\n#include <linux/buffer_head.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/jbd2.h>\n#include <linux/vmalloc.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n#include <linux/string.h>\n#include <linux/module.h>\n\nstatic int ext4_unfreeze(struct super_block *sb);\nstatic int ext4_freeze(struct super_block *sb);\nstatic inline int ext2_feature_set_ok(struct super_block *sb);\nstatic inline int ext3_feature_set_ok(struct super_block *sb);\nstatic void ext4_unregister_li_request(struct super_block *sb);\n\n__u32 ext4_used_dirs_count(struct super_block *sb,\n\t\t\t      struct ext4_group_desc *bg)\n{\n\treturn le16_to_cpu(bg->bg_used_dirs_count_lo) |\n\t\t(EXT4_DESC_SIZE(sb) >= EXT4_MIN_DESC_SIZE_64BIT ?\n\t\t (__u32)le16_to_cpu(bg->bg_used_dirs_count_hi) << 16 : 0);\n}"
  },
  {
    "function_name": "ext4_free_inodes_count",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/super.c",
    "lines": "211-217",
    "snippet": "__u32 ext4_free_inodes_count(struct super_block *sb,\n\t\t\t      struct ext4_group_desc *bg)\n{\n\treturn le16_to_cpu(bg->bg_free_inodes_count_lo) |\n\t\t(EXT4_DESC_SIZE(sb) >= EXT4_MIN_DESC_SIZE_64BIT ?\n\t\t (__u32)le16_to_cpu(bg->bg_free_inodes_count_hi) << 16 : 0);\n}",
    "includes": [
      "#include <trace/events/ext4.h>",
      "#include \"mballoc.h\"",
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"ext4_jbd2.h\"",
      "#include \"ext4_extents.h\"\t/* Needed for trace points definition */",
      "#include \"ext4.h\"",
      "#include <linux/freezer.h>",
      "#include <linux/kthread.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/cleancache.h>",
      "#include <linux/crc16.h>",
      "#include <linux/log2.h>",
      "#include <linux/ctype.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/namei.h>",
      "#include <linux/mount.h>",
      "#include <linux/random.h>",
      "#include <linux/vfs.h>",
      "#include <linux/exportfs.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/parser.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/init.h>",
      "#include <linux/slab.h>",
      "#include <linux/jbd2.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/time.h>",
      "#include <linux/fs.h>",
      "#include <linux/string.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ext4_unfreeze(struct super_block *sb);",
      "static int ext4_freeze(struct super_block *sb);",
      "static inline int ext2_feature_set_ok(struct super_block *sb);",
      "static inline int ext3_feature_set_ok(struct super_block *sb);",
      "static void ext4_unregister_li_request(struct super_block *sb);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "le16_to_cpu",
          "args": [
            "bg->bg_free_inodes_count_hi"
          ],
          "line": 216
        },
        "resolved": true,
        "details": {
          "function_name": "sle16_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "48-51",
          "snippet": "static inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "EXT4_DESC_SIZE",
          "args": [
            "sb"
          ],
          "line": 215
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"mballoc.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4_extents.h\"\t/* Needed for trace points definition */\n#include \"ext4.h\"\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <asm/uaccess.h>\n#include <linux/cleancache.h>\n#include <linux/crc16.h>\n#include <linux/log2.h>\n#include <linux/ctype.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/random.h>\n#include <linux/vfs.h>\n#include <linux/exportfs.h>\n#include <linux/buffer_head.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/jbd2.h>\n#include <linux/vmalloc.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n#include <linux/string.h>\n#include <linux/module.h>\n\nstatic int ext4_unfreeze(struct super_block *sb);\nstatic int ext4_freeze(struct super_block *sb);\nstatic inline int ext2_feature_set_ok(struct super_block *sb);\nstatic inline int ext3_feature_set_ok(struct super_block *sb);\nstatic void ext4_unregister_li_request(struct super_block *sb);\n\n__u32 ext4_free_inodes_count(struct super_block *sb,\n\t\t\t      struct ext4_group_desc *bg)\n{\n\treturn le16_to_cpu(bg->bg_free_inodes_count_lo) |\n\t\t(EXT4_DESC_SIZE(sb) >= EXT4_MIN_DESC_SIZE_64BIT ?\n\t\t (__u32)le16_to_cpu(bg->bg_free_inodes_count_hi) << 16 : 0);\n}"
  },
  {
    "function_name": "ext4_free_group_clusters",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/super.c",
    "lines": "203-209",
    "snippet": "__u32 ext4_free_group_clusters(struct super_block *sb,\n\t\t\t       struct ext4_group_desc *bg)\n{\n\treturn le16_to_cpu(bg->bg_free_blocks_count_lo) |\n\t\t(EXT4_DESC_SIZE(sb) >= EXT4_MIN_DESC_SIZE_64BIT ?\n\t\t (__u32)le16_to_cpu(bg->bg_free_blocks_count_hi) << 16 : 0);\n}",
    "includes": [
      "#include <trace/events/ext4.h>",
      "#include \"mballoc.h\"",
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"ext4_jbd2.h\"",
      "#include \"ext4_extents.h\"\t/* Needed for trace points definition */",
      "#include \"ext4.h\"",
      "#include <linux/freezer.h>",
      "#include <linux/kthread.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/cleancache.h>",
      "#include <linux/crc16.h>",
      "#include <linux/log2.h>",
      "#include <linux/ctype.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/namei.h>",
      "#include <linux/mount.h>",
      "#include <linux/random.h>",
      "#include <linux/vfs.h>",
      "#include <linux/exportfs.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/parser.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/init.h>",
      "#include <linux/slab.h>",
      "#include <linux/jbd2.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/time.h>",
      "#include <linux/fs.h>",
      "#include <linux/string.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ext4_unfreeze(struct super_block *sb);",
      "static int ext4_freeze(struct super_block *sb);",
      "static inline int ext2_feature_set_ok(struct super_block *sb);",
      "static inline int ext3_feature_set_ok(struct super_block *sb);",
      "static void ext4_unregister_li_request(struct super_block *sb);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "le16_to_cpu",
          "args": [
            "bg->bg_free_blocks_count_hi"
          ],
          "line": 208
        },
        "resolved": true,
        "details": {
          "function_name": "sle16_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "48-51",
          "snippet": "static inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "EXT4_DESC_SIZE",
          "args": [
            "sb"
          ],
          "line": 207
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"mballoc.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4_extents.h\"\t/* Needed for trace points definition */\n#include \"ext4.h\"\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <asm/uaccess.h>\n#include <linux/cleancache.h>\n#include <linux/crc16.h>\n#include <linux/log2.h>\n#include <linux/ctype.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/random.h>\n#include <linux/vfs.h>\n#include <linux/exportfs.h>\n#include <linux/buffer_head.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/jbd2.h>\n#include <linux/vmalloc.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n#include <linux/string.h>\n#include <linux/module.h>\n\nstatic int ext4_unfreeze(struct super_block *sb);\nstatic int ext4_freeze(struct super_block *sb);\nstatic inline int ext2_feature_set_ok(struct super_block *sb);\nstatic inline int ext3_feature_set_ok(struct super_block *sb);\nstatic void ext4_unregister_li_request(struct super_block *sb);\n\n__u32 ext4_free_group_clusters(struct super_block *sb,\n\t\t\t       struct ext4_group_desc *bg)\n{\n\treturn le16_to_cpu(bg->bg_free_blocks_count_lo) |\n\t\t(EXT4_DESC_SIZE(sb) >= EXT4_MIN_DESC_SIZE_64BIT ?\n\t\t (__u32)le16_to_cpu(bg->bg_free_blocks_count_hi) << 16 : 0);\n}"
  },
  {
    "function_name": "ext4_inode_table",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/super.c",
    "lines": "195-201",
    "snippet": "ext4_fsblk_t ext4_inode_table(struct super_block *sb,\n\t\t\t      struct ext4_group_desc *bg)\n{\n\treturn le32_to_cpu(bg->bg_inode_table_lo) |\n\t\t(EXT4_DESC_SIZE(sb) >= EXT4_MIN_DESC_SIZE_64BIT ?\n\t\t (ext4_fsblk_t)le32_to_cpu(bg->bg_inode_table_hi) << 32 : 0);\n}",
    "includes": [
      "#include <trace/events/ext4.h>",
      "#include \"mballoc.h\"",
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"ext4_jbd2.h\"",
      "#include \"ext4_extents.h\"\t/* Needed for trace points definition */",
      "#include \"ext4.h\"",
      "#include <linux/freezer.h>",
      "#include <linux/kthread.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/cleancache.h>",
      "#include <linux/crc16.h>",
      "#include <linux/log2.h>",
      "#include <linux/ctype.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/namei.h>",
      "#include <linux/mount.h>",
      "#include <linux/random.h>",
      "#include <linux/vfs.h>",
      "#include <linux/exportfs.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/parser.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/init.h>",
      "#include <linux/slab.h>",
      "#include <linux/jbd2.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/time.h>",
      "#include <linux/fs.h>",
      "#include <linux/string.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ext4_unfreeze(struct super_block *sb);",
      "static int ext4_freeze(struct super_block *sb);",
      "static inline int ext2_feature_set_ok(struct super_block *sb);",
      "static inline int ext3_feature_set_ok(struct super_block *sb);",
      "static void ext4_unregister_li_request(struct super_block *sb);",
      "static int ext4_reserve_clusters(struct ext4_sb_info *, ext4_fsblk_t);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "bg->bg_inode_table_hi"
          ],
          "line": 200
        },
        "resolved": true,
        "details": {
          "function_name": "sle32_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "53-56",
          "snippet": "static inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "EXT4_DESC_SIZE",
          "args": [
            "sb"
          ],
          "line": 199
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"mballoc.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4_extents.h\"\t/* Needed for trace points definition */\n#include \"ext4.h\"\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <asm/uaccess.h>\n#include <linux/cleancache.h>\n#include <linux/crc16.h>\n#include <linux/log2.h>\n#include <linux/ctype.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/random.h>\n#include <linux/vfs.h>\n#include <linux/exportfs.h>\n#include <linux/buffer_head.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/jbd2.h>\n#include <linux/vmalloc.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n#include <linux/string.h>\n#include <linux/module.h>\n\nstatic int ext4_unfreeze(struct super_block *sb);\nstatic int ext4_freeze(struct super_block *sb);\nstatic inline int ext2_feature_set_ok(struct super_block *sb);\nstatic inline int ext3_feature_set_ok(struct super_block *sb);\nstatic void ext4_unregister_li_request(struct super_block *sb);\nstatic int ext4_reserve_clusters(struct ext4_sb_info *, ext4_fsblk_t);\n\next4_fsblk_t ext4_inode_table(struct super_block *sb,\n\t\t\t      struct ext4_group_desc *bg)\n{\n\treturn le32_to_cpu(bg->bg_inode_table_lo) |\n\t\t(EXT4_DESC_SIZE(sb) >= EXT4_MIN_DESC_SIZE_64BIT ?\n\t\t (ext4_fsblk_t)le32_to_cpu(bg->bg_inode_table_hi) << 32 : 0);\n}"
  },
  {
    "function_name": "ext4_inode_bitmap",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/super.c",
    "lines": "187-193",
    "snippet": "ext4_fsblk_t ext4_inode_bitmap(struct super_block *sb,\n\t\t\t       struct ext4_group_desc *bg)\n{\n\treturn le32_to_cpu(bg->bg_inode_bitmap_lo) |\n\t\t(EXT4_DESC_SIZE(sb) >= EXT4_MIN_DESC_SIZE_64BIT ?\n\t\t (ext4_fsblk_t)le32_to_cpu(bg->bg_inode_bitmap_hi) << 32 : 0);\n}",
    "includes": [
      "#include <trace/events/ext4.h>",
      "#include \"mballoc.h\"",
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"ext4_jbd2.h\"",
      "#include \"ext4_extents.h\"\t/* Needed for trace points definition */",
      "#include \"ext4.h\"",
      "#include <linux/freezer.h>",
      "#include <linux/kthread.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/cleancache.h>",
      "#include <linux/crc16.h>",
      "#include <linux/log2.h>",
      "#include <linux/ctype.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/namei.h>",
      "#include <linux/mount.h>",
      "#include <linux/random.h>",
      "#include <linux/vfs.h>",
      "#include <linux/exportfs.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/parser.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/init.h>",
      "#include <linux/slab.h>",
      "#include <linux/jbd2.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/time.h>",
      "#include <linux/fs.h>",
      "#include <linux/string.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ext4_unfreeze(struct super_block *sb);",
      "static int ext4_freeze(struct super_block *sb);",
      "static inline int ext2_feature_set_ok(struct super_block *sb);",
      "static inline int ext3_feature_set_ok(struct super_block *sb);",
      "static void ext4_unregister_li_request(struct super_block *sb);",
      "static int ext4_reserve_clusters(struct ext4_sb_info *, ext4_fsblk_t);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "bg->bg_inode_bitmap_hi"
          ],
          "line": 192
        },
        "resolved": true,
        "details": {
          "function_name": "sle32_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "53-56",
          "snippet": "static inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "EXT4_DESC_SIZE",
          "args": [
            "sb"
          ],
          "line": 191
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"mballoc.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4_extents.h\"\t/* Needed for trace points definition */\n#include \"ext4.h\"\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <asm/uaccess.h>\n#include <linux/cleancache.h>\n#include <linux/crc16.h>\n#include <linux/log2.h>\n#include <linux/ctype.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/random.h>\n#include <linux/vfs.h>\n#include <linux/exportfs.h>\n#include <linux/buffer_head.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/jbd2.h>\n#include <linux/vmalloc.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n#include <linux/string.h>\n#include <linux/module.h>\n\nstatic int ext4_unfreeze(struct super_block *sb);\nstatic int ext4_freeze(struct super_block *sb);\nstatic inline int ext2_feature_set_ok(struct super_block *sb);\nstatic inline int ext3_feature_set_ok(struct super_block *sb);\nstatic void ext4_unregister_li_request(struct super_block *sb);\nstatic int ext4_reserve_clusters(struct ext4_sb_info *, ext4_fsblk_t);\n\next4_fsblk_t ext4_inode_bitmap(struct super_block *sb,\n\t\t\t       struct ext4_group_desc *bg)\n{\n\treturn le32_to_cpu(bg->bg_inode_bitmap_lo) |\n\t\t(EXT4_DESC_SIZE(sb) >= EXT4_MIN_DESC_SIZE_64BIT ?\n\t\t (ext4_fsblk_t)le32_to_cpu(bg->bg_inode_bitmap_hi) << 32 : 0);\n}"
  },
  {
    "function_name": "ext4_block_bitmap",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/super.c",
    "lines": "179-185",
    "snippet": "ext4_fsblk_t ext4_block_bitmap(struct super_block *sb,\n\t\t\t       struct ext4_group_desc *bg)\n{\n\treturn le32_to_cpu(bg->bg_block_bitmap_lo) |\n\t\t(EXT4_DESC_SIZE(sb) >= EXT4_MIN_DESC_SIZE_64BIT ?\n\t\t (ext4_fsblk_t)le32_to_cpu(bg->bg_block_bitmap_hi) << 32 : 0);\n}",
    "includes": [
      "#include <trace/events/ext4.h>",
      "#include \"mballoc.h\"",
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"ext4_jbd2.h\"",
      "#include \"ext4_extents.h\"\t/* Needed for trace points definition */",
      "#include \"ext4.h\"",
      "#include <linux/freezer.h>",
      "#include <linux/kthread.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/cleancache.h>",
      "#include <linux/crc16.h>",
      "#include <linux/log2.h>",
      "#include <linux/ctype.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/namei.h>",
      "#include <linux/mount.h>",
      "#include <linux/random.h>",
      "#include <linux/vfs.h>",
      "#include <linux/exportfs.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/parser.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/init.h>",
      "#include <linux/slab.h>",
      "#include <linux/jbd2.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/time.h>",
      "#include <linux/fs.h>",
      "#include <linux/string.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ext4_unfreeze(struct super_block *sb);",
      "static int ext4_freeze(struct super_block *sb);",
      "static inline int ext2_feature_set_ok(struct super_block *sb);",
      "static inline int ext3_feature_set_ok(struct super_block *sb);",
      "static void ext4_unregister_li_request(struct super_block *sb);",
      "static int ext4_reserve_clusters(struct ext4_sb_info *, ext4_fsblk_t);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "bg->bg_block_bitmap_hi"
          ],
          "line": 184
        },
        "resolved": true,
        "details": {
          "function_name": "sle32_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "53-56",
          "snippet": "static inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "EXT4_DESC_SIZE",
          "args": [
            "sb"
          ],
          "line": 183
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"mballoc.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4_extents.h\"\t/* Needed for trace points definition */\n#include \"ext4.h\"\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <asm/uaccess.h>\n#include <linux/cleancache.h>\n#include <linux/crc16.h>\n#include <linux/log2.h>\n#include <linux/ctype.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/random.h>\n#include <linux/vfs.h>\n#include <linux/exportfs.h>\n#include <linux/buffer_head.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/jbd2.h>\n#include <linux/vmalloc.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n#include <linux/string.h>\n#include <linux/module.h>\n\nstatic int ext4_unfreeze(struct super_block *sb);\nstatic int ext4_freeze(struct super_block *sb);\nstatic inline int ext2_feature_set_ok(struct super_block *sb);\nstatic inline int ext3_feature_set_ok(struct super_block *sb);\nstatic void ext4_unregister_li_request(struct super_block *sb);\nstatic int ext4_reserve_clusters(struct ext4_sb_info *, ext4_fsblk_t);\n\next4_fsblk_t ext4_block_bitmap(struct super_block *sb,\n\t\t\t       struct ext4_group_desc *bg)\n{\n\treturn le32_to_cpu(bg->bg_block_bitmap_lo) |\n\t\t(EXT4_DESC_SIZE(sb) >= EXT4_MIN_DESC_SIZE_64BIT ?\n\t\t (ext4_fsblk_t)le32_to_cpu(bg->bg_block_bitmap_hi) << 32 : 0);\n}"
  },
  {
    "function_name": "ext4_kvzalloc",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/super.c",
    "lines": "169-177",
    "snippet": "void *ext4_kvzalloc(size_t size, gfp_t flags)\n{\n\tvoid *ret;\n\n\tret = kzalloc(size, flags | __GFP_NOWARN);\n\tif (!ret)\n\t\tret = __vmalloc(size, flags | __GFP_ZERO, PAGE_KERNEL);\n\treturn ret;\n}",
    "includes": [
      "#include <trace/events/ext4.h>",
      "#include \"mballoc.h\"",
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"ext4_jbd2.h\"",
      "#include \"ext4_extents.h\"\t/* Needed for trace points definition */",
      "#include \"ext4.h\"",
      "#include <linux/freezer.h>",
      "#include <linux/kthread.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/cleancache.h>",
      "#include <linux/crc16.h>",
      "#include <linux/log2.h>",
      "#include <linux/ctype.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/namei.h>",
      "#include <linux/mount.h>",
      "#include <linux/random.h>",
      "#include <linux/vfs.h>",
      "#include <linux/exportfs.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/parser.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/init.h>",
      "#include <linux/slab.h>",
      "#include <linux/jbd2.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/time.h>",
      "#include <linux/fs.h>",
      "#include <linux/string.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__vmalloc",
          "args": [
            "size",
            "flags | __GFP_ZERO",
            "PAGE_KERNEL"
          ],
          "line": 175
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "size",
            "flags | __GFP_NOWARN"
          ],
          "line": 173
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"mballoc.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4_extents.h\"\t/* Needed for trace points definition */\n#include \"ext4.h\"\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <asm/uaccess.h>\n#include <linux/cleancache.h>\n#include <linux/crc16.h>\n#include <linux/log2.h>\n#include <linux/ctype.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/random.h>\n#include <linux/vfs.h>\n#include <linux/exportfs.h>\n#include <linux/buffer_head.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/jbd2.h>\n#include <linux/vmalloc.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n#include <linux/string.h>\n#include <linux/module.h>\n\nvoid *ext4_kvzalloc(size_t size, gfp_t flags)\n{\n\tvoid *ret;\n\n\tret = kzalloc(size, flags | __GFP_NOWARN);\n\tif (!ret)\n\t\tret = __vmalloc(size, flags | __GFP_ZERO, PAGE_KERNEL);\n\treturn ret;\n}"
  },
  {
    "function_name": "ext4_kvmalloc",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/super.c",
    "lines": "159-167",
    "snippet": "void *ext4_kvmalloc(size_t size, gfp_t flags)\n{\n\tvoid *ret;\n\n\tret = kmalloc(size, flags | __GFP_NOWARN);\n\tif (!ret)\n\t\tret = __vmalloc(size, flags, PAGE_KERNEL);\n\treturn ret;\n}",
    "includes": [
      "#include <trace/events/ext4.h>",
      "#include \"mballoc.h\"",
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"ext4_jbd2.h\"",
      "#include \"ext4_extents.h\"\t/* Needed for trace points definition */",
      "#include \"ext4.h\"",
      "#include <linux/freezer.h>",
      "#include <linux/kthread.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/cleancache.h>",
      "#include <linux/crc16.h>",
      "#include <linux/log2.h>",
      "#include <linux/ctype.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/namei.h>",
      "#include <linux/mount.h>",
      "#include <linux/random.h>",
      "#include <linux/vfs.h>",
      "#include <linux/exportfs.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/parser.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/init.h>",
      "#include <linux/slab.h>",
      "#include <linux/jbd2.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/time.h>",
      "#include <linux/fs.h>",
      "#include <linux/string.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__vmalloc",
          "args": [
            "size",
            "flags",
            "PAGE_KERNEL"
          ],
          "line": 165
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmalloc",
          "args": [
            "size",
            "flags | __GFP_NOWARN"
          ],
          "line": 163
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_dx_dir_kmalloc_leaves",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
          "lines": "2534-2546",
          "snippet": "static struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"mballoc.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4_extents.h\"\t/* Needed for trace points definition */\n#include \"ext4.h\"\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <asm/uaccess.h>\n#include <linux/cleancache.h>\n#include <linux/crc16.h>\n#include <linux/log2.h>\n#include <linux/ctype.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/random.h>\n#include <linux/vfs.h>\n#include <linux/exportfs.h>\n#include <linux/buffer_head.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/jbd2.h>\n#include <linux/vmalloc.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n#include <linux/string.h>\n#include <linux/module.h>\n\nvoid *ext4_kvmalloc(size_t size, gfp_t flags)\n{\n\tvoid *ret;\n\n\tret = kmalloc(size, flags | __GFP_NOWARN);\n\tif (!ret)\n\t\tret = __vmalloc(size, flags, PAGE_KERNEL);\n\treturn ret;\n}"
  },
  {
    "function_name": "ext4_superblock_csum_set",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/super.c",
    "lines": "149-157",
    "snippet": "void ext4_superblock_csum_set(struct super_block *sb)\n{\n\tstruct ext4_super_block *es = EXT4_SB(sb)->s_es;\n\n\tif (!ext4_has_metadata_csum(sb))\n\t\treturn;\n\n\tes->s_checksum = ext4_superblock_csum(sb, es);\n}",
    "includes": [
      "#include <trace/events/ext4.h>",
      "#include \"mballoc.h\"",
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"ext4_jbd2.h\"",
      "#include \"ext4_extents.h\"\t/* Needed for trace points definition */",
      "#include \"ext4.h\"",
      "#include <linux/freezer.h>",
      "#include <linux/kthread.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/cleancache.h>",
      "#include <linux/crc16.h>",
      "#include <linux/log2.h>",
      "#include <linux/ctype.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/namei.h>",
      "#include <linux/mount.h>",
      "#include <linux/random.h>",
      "#include <linux/vfs.h>",
      "#include <linux/exportfs.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/parser.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/init.h>",
      "#include <linux/slab.h>",
      "#include <linux/jbd2.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/time.h>",
      "#include <linux/fs.h>",
      "#include <linux/string.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void ext4_mark_recovery_complete(struct super_block *sb,\n\t\t\t\t\tstruct ext4_super_block *es);",
      "static void ext4_clear_journal_err(struct super_block *sb,\n\t\t\t\t   struct ext4_super_block *es);",
      "static int ext4_unfreeze(struct super_block *sb);",
      "static int ext4_freeze(struct super_block *sb);",
      "static inline int ext2_feature_set_ok(struct super_block *sb);",
      "static inline int ext3_feature_set_ok(struct super_block *sb);",
      "static void ext4_unregister_li_request(struct super_block *sb);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ext4_superblock_csum",
          "args": [
            "sb",
            "es"
          ],
          "line": 156
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_superblock_csum_verify",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/super.c",
          "lines": "140-147",
          "snippet": "static int ext4_superblock_csum_verify(struct super_block *sb,\n\t\t\t\t       struct ext4_super_block *es)\n{\n\tif (!ext4_has_metadata_csum(sb))\n\t\treturn 1;\n\n\treturn es->s_checksum == ext4_superblock_csum(sb, es);\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"mballoc.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include \"ext4_extents.h\"\t/* Needed for trace points definition */",
            "#include \"ext4.h\"",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/crc16.h>",
            "#include <linux/log2.h>",
            "#include <linux/ctype.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/random.h>",
            "#include <linux/vfs.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/parser.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/time.h>",
            "#include <linux/fs.h>",
            "#include <linux/string.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void ext4_mark_recovery_complete(struct super_block *sb,\n\t\t\t\t\tstruct ext4_super_block *es);",
            "static void ext4_clear_journal_err(struct super_block *sb,\n\t\t\t\t   struct ext4_super_block *es);",
            "static int ext4_unfreeze(struct super_block *sb);",
            "static int ext4_freeze(struct super_block *sb);",
            "static inline int ext2_feature_set_ok(struct super_block *sb);",
            "static inline int ext3_feature_set_ok(struct super_block *sb);",
            "static void ext4_unregister_li_request(struct super_block *sb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"mballoc.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4_extents.h\"\t/* Needed for trace points definition */\n#include \"ext4.h\"\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <asm/uaccess.h>\n#include <linux/cleancache.h>\n#include <linux/crc16.h>\n#include <linux/log2.h>\n#include <linux/ctype.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/random.h>\n#include <linux/vfs.h>\n#include <linux/exportfs.h>\n#include <linux/buffer_head.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/jbd2.h>\n#include <linux/vmalloc.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n#include <linux/string.h>\n#include <linux/module.h>\n\nstatic void ext4_mark_recovery_complete(struct super_block *sb,\n\t\t\t\t\tstruct ext4_super_block *es);\nstatic void ext4_clear_journal_err(struct super_block *sb,\n\t\t\t\t   struct ext4_super_block *es);\nstatic int ext4_unfreeze(struct super_block *sb);\nstatic int ext4_freeze(struct super_block *sb);\nstatic inline int ext2_feature_set_ok(struct super_block *sb);\nstatic inline int ext3_feature_set_ok(struct super_block *sb);\nstatic void ext4_unregister_li_request(struct super_block *sb);\n\nstatic int ext4_superblock_csum_verify(struct super_block *sb,\n\t\t\t\t       struct ext4_super_block *es)\n{\n\tif (!ext4_has_metadata_csum(sb))\n\t\treturn 1;\n\n\treturn es->s_checksum == ext4_superblock_csum(sb, es);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_has_metadata_csum",
          "args": [
            "sb"
          ],
          "line": 153
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXT4_SB",
          "args": [
            "sb"
          ],
          "line": 151
        },
        "resolved": true,
        "details": {
          "function_name": "EXT4_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ext4.h",
          "lines": "1356-1359",
          "snippet": "static inline struct ext4_sb_info *EXT4_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include \"extents_status.h\"",
            "#include <linux/compat.h>",
            "#include <linux/falloc.h>",
            "#include <crypto/hash.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/wait.h>",
            "#include <linux/timer.h>",
            "#include <linux/mutex.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/quota.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extents_status.h\"\n#include <linux/compat.h>\n#include <linux/falloc.h>\n#include <crypto/hash.h>\n#include <linux/ratelimit.h>\n#include <linux/percpu_counter.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/wait.h>\n#include <linux/timer.h>\n#include <linux/mutex.h>\n#include <linux/seqlock.h>\n#include <linux/rbtree.h>\n#include <linux/rwsem.h>\n#include <linux/quota.h>\n#include <linux/jbd2.h>\n#include <linux/magic.h>\n#include <linux/blkdev.h>\n#include <linux/types.h>\n\nstatic inline struct ext4_sb_info *EXT4_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"mballoc.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4_extents.h\"\t/* Needed for trace points definition */\n#include \"ext4.h\"\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <asm/uaccess.h>\n#include <linux/cleancache.h>\n#include <linux/crc16.h>\n#include <linux/log2.h>\n#include <linux/ctype.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/random.h>\n#include <linux/vfs.h>\n#include <linux/exportfs.h>\n#include <linux/buffer_head.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/jbd2.h>\n#include <linux/vmalloc.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n#include <linux/string.h>\n#include <linux/module.h>\n\nstatic void ext4_mark_recovery_complete(struct super_block *sb,\n\t\t\t\t\tstruct ext4_super_block *es);\nstatic void ext4_clear_journal_err(struct super_block *sb,\n\t\t\t\t   struct ext4_super_block *es);\nstatic int ext4_unfreeze(struct super_block *sb);\nstatic int ext4_freeze(struct super_block *sb);\nstatic inline int ext2_feature_set_ok(struct super_block *sb);\nstatic inline int ext3_feature_set_ok(struct super_block *sb);\nstatic void ext4_unregister_li_request(struct super_block *sb);\n\nvoid ext4_superblock_csum_set(struct super_block *sb)\n{\n\tstruct ext4_super_block *es = EXT4_SB(sb)->s_es;\n\n\tif (!ext4_has_metadata_csum(sb))\n\t\treturn;\n\n\tes->s_checksum = ext4_superblock_csum(sb, es);\n}"
  },
  {
    "function_name": "ext4_superblock_csum_verify",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/super.c",
    "lines": "140-147",
    "snippet": "static int ext4_superblock_csum_verify(struct super_block *sb,\n\t\t\t\t       struct ext4_super_block *es)\n{\n\tif (!ext4_has_metadata_csum(sb))\n\t\treturn 1;\n\n\treturn es->s_checksum == ext4_superblock_csum(sb, es);\n}",
    "includes": [
      "#include <trace/events/ext4.h>",
      "#include \"mballoc.h\"",
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"ext4_jbd2.h\"",
      "#include \"ext4_extents.h\"\t/* Needed for trace points definition */",
      "#include \"ext4.h\"",
      "#include <linux/freezer.h>",
      "#include <linux/kthread.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/cleancache.h>",
      "#include <linux/crc16.h>",
      "#include <linux/log2.h>",
      "#include <linux/ctype.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/namei.h>",
      "#include <linux/mount.h>",
      "#include <linux/random.h>",
      "#include <linux/vfs.h>",
      "#include <linux/exportfs.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/parser.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/init.h>",
      "#include <linux/slab.h>",
      "#include <linux/jbd2.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/time.h>",
      "#include <linux/fs.h>",
      "#include <linux/string.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void ext4_mark_recovery_complete(struct super_block *sb,\n\t\t\t\t\tstruct ext4_super_block *es);",
      "static void ext4_clear_journal_err(struct super_block *sb,\n\t\t\t\t   struct ext4_super_block *es);",
      "static int ext4_unfreeze(struct super_block *sb);",
      "static int ext4_freeze(struct super_block *sb);",
      "static inline int ext2_feature_set_ok(struct super_block *sb);",
      "static inline int ext3_feature_set_ok(struct super_block *sb);",
      "static void ext4_unregister_li_request(struct super_block *sb);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ext4_superblock_csum",
          "args": [
            "sb",
            "es"
          ],
          "line": 146
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_superblock_csum_verify",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/super.c",
          "lines": "140-147",
          "snippet": "static int ext4_superblock_csum_verify(struct super_block *sb,\n\t\t\t\t       struct ext4_super_block *es)\n{\n\tif (!ext4_has_metadata_csum(sb))\n\t\treturn 1;\n\n\treturn es->s_checksum == ext4_superblock_csum(sb, es);\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "ext4_has_metadata_csum",
          "args": [
            "sb"
          ],
          "line": 143
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"mballoc.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4_extents.h\"\t/* Needed for trace points definition */\n#include \"ext4.h\"\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <asm/uaccess.h>\n#include <linux/cleancache.h>\n#include <linux/crc16.h>\n#include <linux/log2.h>\n#include <linux/ctype.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/random.h>\n#include <linux/vfs.h>\n#include <linux/exportfs.h>\n#include <linux/buffer_head.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/jbd2.h>\n#include <linux/vmalloc.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n#include <linux/string.h>\n#include <linux/module.h>\n\nstatic void ext4_mark_recovery_complete(struct super_block *sb,\n\t\t\t\t\tstruct ext4_super_block *es);\nstatic void ext4_clear_journal_err(struct super_block *sb,\n\t\t\t\t   struct ext4_super_block *es);\nstatic int ext4_unfreeze(struct super_block *sb);\nstatic int ext4_freeze(struct super_block *sb);\nstatic inline int ext2_feature_set_ok(struct super_block *sb);\nstatic inline int ext3_feature_set_ok(struct super_block *sb);\nstatic void ext4_unregister_li_request(struct super_block *sb);\n\nstatic int ext4_superblock_csum_verify(struct super_block *sb,\n\t\t\t\t       struct ext4_super_block *es)\n{\n\tif (!ext4_has_metadata_csum(sb))\n\t\treturn 1;\n\n\treturn es->s_checksum == ext4_superblock_csum(sb, es);\n}"
  },
  {
    "function_name": "ext4_superblock_csum",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/super.c",
    "lines": "128-138",
    "snippet": "static __le32 ext4_superblock_csum(struct super_block *sb,\n\t\t\t\t   struct ext4_super_block *es)\n{\n\tstruct ext4_sb_info *sbi = EXT4_SB(sb);\n\tint offset = offsetof(struct ext4_super_block, s_checksum);\n\t__u32 csum;\n\n\tcsum = ext4_chksum(sbi, ~0, (char *)es, offset);\n\n\treturn cpu_to_le32(csum);\n}",
    "includes": [
      "#include <trace/events/ext4.h>",
      "#include \"mballoc.h\"",
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"ext4_jbd2.h\"",
      "#include \"ext4_extents.h\"\t/* Needed for trace points definition */",
      "#include \"ext4.h\"",
      "#include <linux/freezer.h>",
      "#include <linux/kthread.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/cleancache.h>",
      "#include <linux/crc16.h>",
      "#include <linux/log2.h>",
      "#include <linux/ctype.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/namei.h>",
      "#include <linux/mount.h>",
      "#include <linux/random.h>",
      "#include <linux/vfs.h>",
      "#include <linux/exportfs.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/parser.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/init.h>",
      "#include <linux/slab.h>",
      "#include <linux/jbd2.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/time.h>",
      "#include <linux/fs.h>",
      "#include <linux/string.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void ext4_mark_recovery_complete(struct super_block *sb,\n\t\t\t\t\tstruct ext4_super_block *es);",
      "static void ext4_clear_journal_err(struct super_block *sb,\n\t\t\t\t   struct ext4_super_block *es);",
      "static int ext4_unfreeze(struct super_block *sb);",
      "static int ext4_freeze(struct super_block *sb);",
      "static inline int ext2_feature_set_ok(struct super_block *sb);",
      "static inline int ext3_feature_set_ok(struct super_block *sb);",
      "static void ext4_unregister_li_request(struct super_block *sb);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "csum"
          ],
          "line": 137
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_chksum",
          "args": [
            "sbi",
            "~0",
            "(char *)es",
            "offset"
          ],
          "line": 135
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_chksum",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ext4.h",
          "lines": "1756-1775",
          "snippet": "static inline u32 ext4_chksum(struct ext4_sb_info *sbi, u32 crc,\n\t\t\t      const void *address, unsigned int length)\n{\n\tstruct {\n\t\tstruct shash_desc shash;\n\t\tchar ctx[4];\n\t} desc;\n\tint err;\n\n\tBUG_ON(crypto_shash_descsize(sbi->s_chksum_driver)!=sizeof(desc.ctx));\n\n\tdesc.shash.tfm = sbi->s_chksum_driver;\n\tdesc.shash.flags = 0;\n\t*(u32 *)desc.ctx = crc;\n\n\terr = crypto_shash_update(&desc.shash, address, length);\n\tBUG_ON(err);\n\n\treturn *(u32 *)desc.ctx;\n}",
          "includes": [
            "#include \"extents_status.h\"",
            "#include <linux/compat.h>",
            "#include <linux/falloc.h>",
            "#include <crypto/hash.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/wait.h>",
            "#include <linux/timer.h>",
            "#include <linux/mutex.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/quota.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extents_status.h\"\n#include <linux/compat.h>\n#include <linux/falloc.h>\n#include <crypto/hash.h>\n#include <linux/ratelimit.h>\n#include <linux/percpu_counter.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/wait.h>\n#include <linux/timer.h>\n#include <linux/mutex.h>\n#include <linux/seqlock.h>\n#include <linux/rbtree.h>\n#include <linux/rwsem.h>\n#include <linux/quota.h>\n#include <linux/jbd2.h>\n#include <linux/magic.h>\n#include <linux/blkdev.h>\n#include <linux/types.h>\n\nstatic inline u32 ext4_chksum(struct ext4_sb_info *sbi, u32 crc,\n\t\t\t      const void *address, unsigned int length)\n{\n\tstruct {\n\t\tstruct shash_desc shash;\n\t\tchar ctx[4];\n\t} desc;\n\tint err;\n\n\tBUG_ON(crypto_shash_descsize(sbi->s_chksum_driver)!=sizeof(desc.ctx));\n\n\tdesc.shash.tfm = sbi->s_chksum_driver;\n\tdesc.shash.flags = 0;\n\t*(u32 *)desc.ctx = crc;\n\n\terr = crypto_shash_update(&desc.shash, address, length);\n\tBUG_ON(err);\n\n\treturn *(u32 *)desc.ctx;\n}"
        }
      },
      {
        "call_info": {
          "callee": "EXT4_SB",
          "args": [
            "sb"
          ],
          "line": 131
        },
        "resolved": true,
        "details": {
          "function_name": "EXT4_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ext4.h",
          "lines": "1356-1359",
          "snippet": "static inline struct ext4_sb_info *EXT4_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include \"extents_status.h\"",
            "#include <linux/compat.h>",
            "#include <linux/falloc.h>",
            "#include <crypto/hash.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/wait.h>",
            "#include <linux/timer.h>",
            "#include <linux/mutex.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/quota.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extents_status.h\"\n#include <linux/compat.h>\n#include <linux/falloc.h>\n#include <crypto/hash.h>\n#include <linux/ratelimit.h>\n#include <linux/percpu_counter.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/wait.h>\n#include <linux/timer.h>\n#include <linux/mutex.h>\n#include <linux/seqlock.h>\n#include <linux/rbtree.h>\n#include <linux/rwsem.h>\n#include <linux/quota.h>\n#include <linux/jbd2.h>\n#include <linux/magic.h>\n#include <linux/blkdev.h>\n#include <linux/types.h>\n\nstatic inline struct ext4_sb_info *EXT4_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"mballoc.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4_extents.h\"\t/* Needed for trace points definition */\n#include \"ext4.h\"\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <asm/uaccess.h>\n#include <linux/cleancache.h>\n#include <linux/crc16.h>\n#include <linux/log2.h>\n#include <linux/ctype.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/random.h>\n#include <linux/vfs.h>\n#include <linux/exportfs.h>\n#include <linux/buffer_head.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/jbd2.h>\n#include <linux/vmalloc.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n#include <linux/string.h>\n#include <linux/module.h>\n\nstatic void ext4_mark_recovery_complete(struct super_block *sb,\n\t\t\t\t\tstruct ext4_super_block *es);\nstatic void ext4_clear_journal_err(struct super_block *sb,\n\t\t\t\t   struct ext4_super_block *es);\nstatic int ext4_unfreeze(struct super_block *sb);\nstatic int ext4_freeze(struct super_block *sb);\nstatic inline int ext2_feature_set_ok(struct super_block *sb);\nstatic inline int ext3_feature_set_ok(struct super_block *sb);\nstatic void ext4_unregister_li_request(struct super_block *sb);\n\nstatic __le32 ext4_superblock_csum(struct super_block *sb,\n\t\t\t\t   struct ext4_super_block *es)\n{\n\tstruct ext4_sb_info *sbi = EXT4_SB(sb);\n\tint offset = offsetof(struct ext4_super_block, s_checksum);\n\t__u32 csum;\n\n\tcsum = ext4_chksum(sbi, ~0, (char *)es, offset);\n\n\treturn cpu_to_le32(csum);\n}"
  },
  {
    "function_name": "ext4_verify_csum_type",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/super.c",
    "lines": "118-126",
    "snippet": "static int ext4_verify_csum_type(struct super_block *sb,\n\t\t\t\t struct ext4_super_block *es)\n{\n\tif (!EXT4_HAS_RO_COMPAT_FEATURE(sb,\n\t\t\t\t\tEXT4_FEATURE_RO_COMPAT_METADATA_CSUM))\n\t\treturn 1;\n\n\treturn es->s_checksum_type == EXT4_CRC32C_CHKSUM;\n}",
    "includes": [
      "#include <trace/events/ext4.h>",
      "#include \"mballoc.h\"",
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"ext4_jbd2.h\"",
      "#include \"ext4_extents.h\"\t/* Needed for trace points definition */",
      "#include \"ext4.h\"",
      "#include <linux/freezer.h>",
      "#include <linux/kthread.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/cleancache.h>",
      "#include <linux/crc16.h>",
      "#include <linux/log2.h>",
      "#include <linux/ctype.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/namei.h>",
      "#include <linux/mount.h>",
      "#include <linux/random.h>",
      "#include <linux/vfs.h>",
      "#include <linux/exportfs.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/parser.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/init.h>",
      "#include <linux/slab.h>",
      "#include <linux/jbd2.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/time.h>",
      "#include <linux/fs.h>",
      "#include <linux/string.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void ext4_mark_recovery_complete(struct super_block *sb,\n\t\t\t\t\tstruct ext4_super_block *es);",
      "static void ext4_clear_journal_err(struct super_block *sb,\n\t\t\t\t   struct ext4_super_block *es);",
      "static int ext4_unfreeze(struct super_block *sb);",
      "static int ext4_freeze(struct super_block *sb);",
      "static inline int ext2_feature_set_ok(struct super_block *sb);",
      "static inline int ext3_feature_set_ok(struct super_block *sb);",
      "static void ext4_unregister_li_request(struct super_block *sb);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "EXT4_HAS_RO_COMPAT_FEATURE",
          "args": [
            "sb",
            "EXT4_FEATURE_RO_COMPAT_METADATA_CSUM"
          ],
          "line": 121
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"mballoc.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4_extents.h\"\t/* Needed for trace points definition */\n#include \"ext4.h\"\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <asm/uaccess.h>\n#include <linux/cleancache.h>\n#include <linux/crc16.h>\n#include <linux/log2.h>\n#include <linux/ctype.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/random.h>\n#include <linux/vfs.h>\n#include <linux/exportfs.h>\n#include <linux/buffer_head.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/jbd2.h>\n#include <linux/vmalloc.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n#include <linux/string.h>\n#include <linux/module.h>\n\nstatic void ext4_mark_recovery_complete(struct super_block *sb,\n\t\t\t\t\tstruct ext4_super_block *es);\nstatic void ext4_clear_journal_err(struct super_block *sb,\n\t\t\t\t   struct ext4_super_block *es);\nstatic int ext4_unfreeze(struct super_block *sb);\nstatic int ext4_freeze(struct super_block *sb);\nstatic inline int ext2_feature_set_ok(struct super_block *sb);\nstatic inline int ext3_feature_set_ok(struct super_block *sb);\nstatic void ext4_unregister_li_request(struct super_block *sb);\n\nstatic int ext4_verify_csum_type(struct super_block *sb,\n\t\t\t\t struct ext4_super_block *es)\n{\n\tif (!EXT4_HAS_RO_COMPAT_FEATURE(sb,\n\t\t\t\t\tEXT4_FEATURE_RO_COMPAT_METADATA_CSUM))\n\t\treturn 1;\n\n\treturn es->s_checksum_type == EXT4_CRC32C_CHKSUM;\n}"
  }
]