[
  {
    "function_name": "ext4_move_extents",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/move_extent.c",
    "lines": "543-684",
    "snippet": "int\next4_move_extents(struct file *o_filp, struct file *d_filp, __u64 orig_blk,\n\t\t  __u64 donor_blk, __u64 len, __u64 *moved_len)\n{\n\tstruct inode *orig_inode = file_inode(o_filp);\n\tstruct inode *donor_inode = file_inode(d_filp);\n\tstruct ext4_ext_path *path = NULL;\n\tint blocks_per_page = PAGE_CACHE_SIZE >> orig_inode->i_blkbits;\n\text4_lblk_t o_end, o_start = orig_blk;\n\text4_lblk_t d_start = donor_blk;\n\tint ret;\n\n\tif (orig_inode->i_sb != donor_inode->i_sb) {\n\t\text4_debug(\"ext4 move extent: The argument files \"\n\t\t\t\"should be in same FS [ino:orig %lu, donor %lu]\\n\",\n\t\t\torig_inode->i_ino, donor_inode->i_ino);\n\t\treturn -EINVAL;\n\t}\n\n\t/* orig and donor should be different inodes */\n\tif (orig_inode == donor_inode) {\n\t\text4_debug(\"ext4 move extent: The argument files should not \"\n\t\t\t\"be same inode [ino:orig %lu, donor %lu]\\n\",\n\t\t\torig_inode->i_ino, donor_inode->i_ino);\n\t\treturn -EINVAL;\n\t}\n\n\t/* Regular file check */\n\tif (!S_ISREG(orig_inode->i_mode) || !S_ISREG(donor_inode->i_mode)) {\n\t\text4_debug(\"ext4 move extent: The argument files should be \"\n\t\t\t\"regular file [ino:orig %lu, donor %lu]\\n\",\n\t\t\torig_inode->i_ino, donor_inode->i_ino);\n\t\treturn -EINVAL;\n\t}\n\t/* TODO: This is non obvious task to swap blocks for inodes with full\n\t   jornaling enabled */\n\tif (ext4_should_journal_data(orig_inode) ||\n\t    ext4_should_journal_data(donor_inode)) {\n\t\treturn -EINVAL;\n\t}\n\t/* Protect orig and donor inodes against a truncate */\n\tlock_two_nondirectories(orig_inode, donor_inode);\n\n\t/* Wait for all existing dio workers */\n\text4_inode_block_unlocked_dio(orig_inode);\n\text4_inode_block_unlocked_dio(donor_inode);\n\tinode_dio_wait(orig_inode);\n\tinode_dio_wait(donor_inode);\n\n\t/* Protect extent tree against block allocations via delalloc */\n\text4_double_down_write_data_sem(orig_inode, donor_inode);\n\t/* Check the filesystem environment whether move_extent can be done */\n\tret = mext_check_arguments(orig_inode, donor_inode, orig_blk,\n\t\t\t\t    donor_blk, &len);\n\tif (ret)\n\t\tgoto out;\n\to_end = o_start + len;\n\n\twhile (o_start < o_end) {\n\t\tstruct ext4_extent *ex;\n\t\text4_lblk_t cur_blk, next_blk;\n\t\tpgoff_t orig_page_index, donor_page_index;\n\t\tint offset_in_page;\n\t\tint unwritten, cur_len;\n\n\t\tret = get_ext_path(orig_inode, o_start, &path);\n\t\tif (ret)\n\t\t\tgoto out;\n\t\tex = path[path->p_depth].p_ext;\n\t\tnext_blk = ext4_ext_next_allocated_block(path);\n\t\tcur_blk = le32_to_cpu(ex->ee_block);\n\t\tcur_len = ext4_ext_get_actual_len(ex);\n\t\t/* Check hole before the start pos */\n\t\tif (cur_blk + cur_len - 1 < o_start) {\n\t\t\tif (next_blk == EXT_MAX_BLOCKS) {\n\t\t\t\to_start = o_end;\n\t\t\t\tret = -ENODATA;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\td_start += next_blk - o_start;\n\t\t\to_start = next_blk;\n\t\t\tcontinue;\n\t\t/* Check hole after the start pos */\n\t\t} else if (cur_blk > o_start) {\n\t\t\t/* Skip hole */\n\t\t\td_start += cur_blk - o_start;\n\t\t\to_start = cur_blk;\n\t\t\t/* Extent inside requested range ?*/\n\t\t\tif (cur_blk >= o_end)\n\t\t\t\tgoto out;\n\t\t} else { /* in_range(o_start, o_blk, o_len) */\n\t\t\tcur_len += cur_blk - o_start;\n\t\t}\n\t\tunwritten = ext4_ext_is_unwritten(ex);\n\t\tif (o_end - o_start < cur_len)\n\t\t\tcur_len = o_end - o_start;\n\n\t\torig_page_index = o_start >> (PAGE_CACHE_SHIFT -\n\t\t\t\t\t       orig_inode->i_blkbits);\n\t\tdonor_page_index = d_start >> (PAGE_CACHE_SHIFT -\n\t\t\t\t\t       donor_inode->i_blkbits);\n\t\toffset_in_page = o_start % blocks_per_page;\n\t\tif (cur_len > blocks_per_page- offset_in_page)\n\t\t\tcur_len = blocks_per_page - offset_in_page;\n\t\t/*\n\t\t * Up semaphore to avoid following problems:\n\t\t * a. transaction deadlock among ext4_journal_start,\n\t\t *    ->write_begin via pagefault, and jbd2_journal_commit\n\t\t * b. racing with ->readpage, ->write_begin, and ext4_get_block\n\t\t *    in move_extent_per_page\n\t\t */\n\t\text4_double_up_write_data_sem(orig_inode, donor_inode);\n\t\t/* Swap original branches with new branches */\n\t\tmove_extent_per_page(o_filp, donor_inode,\n\t\t\t\t     orig_page_index, donor_page_index,\n\t\t\t\t     offset_in_page, cur_len,\n\t\t\t\t     unwritten, &ret);\n\t\text4_double_down_write_data_sem(orig_inode, donor_inode);\n\t\tif (ret < 0)\n\t\t\tbreak;\n\t\to_start += cur_len;\n\t\td_start += cur_len;\n\t}\n\t*moved_len = o_start - orig_blk;\n\tif (*moved_len > len)\n\t\t*moved_len = len;\n\nout:\n\tif (*moved_len) {\n\t\text4_discard_preallocations(orig_inode);\n\t\text4_discard_preallocations(donor_inode);\n\t}\n\n\text4_ext_drop_refs(path);\n\tkfree(path);\n\text4_double_up_write_data_sem(orig_inode, donor_inode);\n\text4_inode_resume_unlocked_dio(orig_inode);\n\text4_inode_resume_unlocked_dio(donor_inode);\n\tunlock_two_nondirectories(orig_inode, donor_inode);\n\n\treturn ret;\n}",
    "includes": [
      "#include \"ext4_extents.h\"",
      "#include \"ext4.h\"",
      "#include \"ext4_jbd2.h\"",
      "#include <linux/slab.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "unlock_two_nondirectories",
          "args": [
            "orig_inode",
            "donor_inode"
          ],
          "line": 681
        },
        "resolved": true,
        "details": {
          "function_name": "unlock_two_nondirectories",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "962-968",
          "snippet": "void unlock_two_nondirectories(struct inode *inode1, struct inode *inode2)\n{\n\tif (inode1 && !S_ISDIR(inode1->i_mode))\n\t\tmutex_unlock(&inode1->i_mutex);\n\tif (inode2 && !S_ISDIR(inode2->i_mode) && inode2 != inode1)\n\t\tmutex_unlock(&inode2->i_mutex);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid unlock_two_nondirectories(struct inode *inode1, struct inode *inode2)\n{\n\tif (inode1 && !S_ISDIR(inode1->i_mode))\n\t\tmutex_unlock(&inode1->i_mutex);\n\tif (inode2 && !S_ISDIR(inode2->i_mode) && inode2 != inode1)\n\t\tmutex_unlock(&inode2->i_mutex);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_inode_resume_unlocked_dio",
          "args": [
            "donor_inode"
          ],
          "line": 680
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_inode_resume_unlocked_dio",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ext4.h",
          "lines": "2830-2834",
          "snippet": "static inline void ext4_inode_resume_unlocked_dio(struct inode *inode)\n{\n\tsmp_mb();\n\text4_clear_inode_state(inode, EXT4_STATE_DIOREAD_LOCK);\n}",
          "includes": [
            "#include \"extents_status.h\"",
            "#include <linux/compat.h>",
            "#include <linux/falloc.h>",
            "#include <crypto/hash.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/wait.h>",
            "#include <linux/timer.h>",
            "#include <linux/mutex.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/quota.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extents_status.h\"\n#include <linux/compat.h>\n#include <linux/falloc.h>\n#include <crypto/hash.h>\n#include <linux/ratelimit.h>\n#include <linux/percpu_counter.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/wait.h>\n#include <linux/timer.h>\n#include <linux/mutex.h>\n#include <linux/seqlock.h>\n#include <linux/rbtree.h>\n#include <linux/rwsem.h>\n#include <linux/quota.h>\n#include <linux/jbd2.h>\n#include <linux/magic.h>\n#include <linux/blkdev.h>\n#include <linux/types.h>\n\nstatic inline void ext4_inode_resume_unlocked_dio(struct inode *inode)\n{\n\tsmp_mb();\n\text4_clear_inode_state(inode, EXT4_STATE_DIOREAD_LOCK);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_double_up_write_data_sem",
          "args": [
            "orig_inode",
            "donor_inode"
          ],
          "line": 678
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_double_up_write_data_sem",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/move_extent.c",
          "lines": "78-84",
          "snippet": "void\next4_double_up_write_data_sem(struct inode *orig_inode,\n\t\t\t      struct inode *donor_inode)\n{\n\tup_write(&EXT4_I(orig_inode)->i_data_sem);\n\tup_write(&EXT4_I(donor_inode)->i_data_sem);\n}",
          "includes": [
            "#include \"ext4_extents.h\"",
            "#include \"ext4.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include <linux/slab.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ext4_extents.h\"\n#include \"ext4.h\"\n#include \"ext4_jbd2.h\"\n#include <linux/slab.h>\n#include <linux/quotaops.h>\n#include <linux/fs.h>\n\nvoid\next4_double_up_write_data_sem(struct inode *orig_inode,\n\t\t\t      struct inode *donor_inode)\n{\n\tup_write(&EXT4_I(orig_inode)->i_data_sem);\n\tup_write(&EXT4_I(donor_inode)->i_data_sem);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "path"
          ],
          "line": 677
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_ext_drop_refs",
          "args": [
            "path"
          ],
          "line": 676
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_ext_drop_refs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/extents.c",
          "lines": "708-720",
          "snippet": "void ext4_ext_drop_refs(struct ext4_ext_path *path)\n{\n\tint depth, i;\n\n\tif (!path)\n\t\treturn;\n\tdepth = path->p_depth;\n\tfor (i = 0; i <= depth; i++, path++)\n\t\tif (path->p_bh) {\n\t\t\tbrelse(path->p_bh);\n\t\t\tpath->p_bh = NULL;\n\t\t}\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"xattr.h\"",
            "#include \"ext4_extents.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include <linux/fiemap.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/string.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highuid.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/time.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"xattr.h\"\n#include \"ext4_extents.h\"\n#include \"ext4_jbd2.h\"\n#include <linux/fiemap.h>\n#include <asm/uaccess.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/highuid.h>\n#include <linux/jbd2.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n\nvoid ext4_ext_drop_refs(struct ext4_ext_path *path)\n{\n\tint depth, i;\n\n\tif (!path)\n\t\treturn;\n\tdepth = path->p_depth;\n\tfor (i = 0; i <= depth; i++, path++)\n\t\tif (path->p_bh) {\n\t\t\tbrelse(path->p_bh);\n\t\t\tpath->p_bh = NULL;\n\t\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_discard_preallocations",
          "args": [
            "donor_inode"
          ],
          "line": 673
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_discard_preallocations",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/mballoc.c",
          "lines": "3920-4020",
          "snippet": "void ext4_discard_preallocations(struct inode *inode)\n{\n\tstruct ext4_inode_info *ei = EXT4_I(inode);\n\tstruct super_block *sb = inode->i_sb;\n\tstruct buffer_head *bitmap_bh = NULL;\n\tstruct ext4_prealloc_space *pa, *tmp;\n\text4_group_t group = 0;\n\tstruct list_head list;\n\tstruct ext4_buddy e4b;\n\tint err;\n\n\tif (!S_ISREG(inode->i_mode)) {\n\t\t/*BUG_ON(!list_empty(&ei->i_prealloc_list));*/\n\t\treturn;\n\t}\n\n\tmb_debug(1, \"discard preallocation for inode %lu\\n\", inode->i_ino);\n\ttrace_ext4_discard_preallocations(inode);\n\n\tINIT_LIST_HEAD(&list);\n\nrepeat:\n\t/* first, collect all pa's in the inode */\n\tspin_lock(&ei->i_prealloc_lock);\n\twhile (!list_empty(&ei->i_prealloc_list)) {\n\t\tpa = list_entry(ei->i_prealloc_list.next,\n\t\t\t\tstruct ext4_prealloc_space, pa_inode_list);\n\t\tBUG_ON(pa->pa_obj_lock != &ei->i_prealloc_lock);\n\t\tspin_lock(&pa->pa_lock);\n\t\tif (atomic_read(&pa->pa_count)) {\n\t\t\t/* this shouldn't happen often - nobody should\n\t\t\t * use preallocation while we're discarding it */\n\t\t\tspin_unlock(&pa->pa_lock);\n\t\t\tspin_unlock(&ei->i_prealloc_lock);\n\t\t\text4_msg(sb, KERN_ERR,\n\t\t\t\t \"uh-oh! used pa while discarding\");\n\t\t\tWARN_ON(1);\n\t\t\tschedule_timeout_uninterruptible(HZ);\n\t\t\tgoto repeat;\n\n\t\t}\n\t\tif (pa->pa_deleted == 0) {\n\t\t\tpa->pa_deleted = 1;\n\t\t\tspin_unlock(&pa->pa_lock);\n\t\t\tlist_del_rcu(&pa->pa_inode_list);\n\t\t\tlist_add(&pa->u.pa_tmp_list, &list);\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* someone is deleting pa right now */\n\t\tspin_unlock(&pa->pa_lock);\n\t\tspin_unlock(&ei->i_prealloc_lock);\n\n\t\t/* we have to wait here because pa_deleted\n\t\t * doesn't mean pa is already unlinked from\n\t\t * the list. as we might be called from\n\t\t * ->clear_inode() the inode will get freed\n\t\t * and concurrent thread which is unlinking\n\t\t * pa from inode's list may access already\n\t\t * freed memory, bad-bad-bad */\n\n\t\t/* XXX: if this happens too often, we can\n\t\t * add a flag to force wait only in case\n\t\t * of ->clear_inode(), but not in case of\n\t\t * regular truncate */\n\t\tschedule_timeout_uninterruptible(HZ);\n\t\tgoto repeat;\n\t}\n\tspin_unlock(&ei->i_prealloc_lock);\n\n\tlist_for_each_entry_safe(pa, tmp, &list, u.pa_tmp_list) {\n\t\tBUG_ON(pa->pa_type != MB_INODE_PA);\n\t\tgroup = ext4_get_group_number(sb, pa->pa_pstart);\n\n\t\terr = ext4_mb_load_buddy(sb, group, &e4b);\n\t\tif (err) {\n\t\t\text4_error(sb, \"Error loading buddy information for %u\",\n\t\t\t\t\tgroup);\n\t\t\tcontinue;\n\t\t}\n\n\t\tbitmap_bh = ext4_read_block_bitmap(sb, group);\n\t\tif (bitmap_bh == NULL) {\n\t\t\text4_error(sb, \"Error reading block bitmap for %u\",\n\t\t\t\t\tgroup);\n\t\t\text4_mb_unload_buddy(&e4b);\n\t\t\tcontinue;\n\t\t}\n\n\t\text4_lock_group(sb, group);\n\t\tlist_del(&pa->pa_group_list);\n\t\text4_mb_release_inode_pa(&e4b, bitmap_bh, pa);\n\t\text4_unlock_group(sb, group);\n\n\t\text4_mb_unload_buddy(&e4b);\n\t\tput_bh(bitmap_bh);\n\n\t\tlist_del(&pa->u.pa_tmp_list);\n\t\tcall_rcu(&(pa)->u.pa_rcu, ext4_mb_pa_callback);\n\t}\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/log2.h>",
            "#include \"mballoc.h\"",
            "#include \"ext4_jbd2.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void ext4_mb_generate_from_pa(struct super_block *sb, void *bitmap,\n\t\t\t\t\text4_group_t group);",
            "static void ext4_mb_generate_from_freelist(struct super_block *sb, void *bitmap,\n\t\t\t\t\t\text4_group_t group);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/log2.h>\n#include \"mballoc.h\"\n#include \"ext4_jbd2.h\"\n\nstatic void ext4_mb_generate_from_pa(struct super_block *sb, void *bitmap,\n\t\t\t\t\text4_group_t group);\nstatic void ext4_mb_generate_from_freelist(struct super_block *sb, void *bitmap,\n\t\t\t\t\t\text4_group_t group);\n\nvoid ext4_discard_preallocations(struct inode *inode)\n{\n\tstruct ext4_inode_info *ei = EXT4_I(inode);\n\tstruct super_block *sb = inode->i_sb;\n\tstruct buffer_head *bitmap_bh = NULL;\n\tstruct ext4_prealloc_space *pa, *tmp;\n\text4_group_t group = 0;\n\tstruct list_head list;\n\tstruct ext4_buddy e4b;\n\tint err;\n\n\tif (!S_ISREG(inode->i_mode)) {\n\t\t/*BUG_ON(!list_empty(&ei->i_prealloc_list));*/\n\t\treturn;\n\t}\n\n\tmb_debug(1, \"discard preallocation for inode %lu\\n\", inode->i_ino);\n\ttrace_ext4_discard_preallocations(inode);\n\n\tINIT_LIST_HEAD(&list);\n\nrepeat:\n\t/* first, collect all pa's in the inode */\n\tspin_lock(&ei->i_prealloc_lock);\n\twhile (!list_empty(&ei->i_prealloc_list)) {\n\t\tpa = list_entry(ei->i_prealloc_list.next,\n\t\t\t\tstruct ext4_prealloc_space, pa_inode_list);\n\t\tBUG_ON(pa->pa_obj_lock != &ei->i_prealloc_lock);\n\t\tspin_lock(&pa->pa_lock);\n\t\tif (atomic_read(&pa->pa_count)) {\n\t\t\t/* this shouldn't happen often - nobody should\n\t\t\t * use preallocation while we're discarding it */\n\t\t\tspin_unlock(&pa->pa_lock);\n\t\t\tspin_unlock(&ei->i_prealloc_lock);\n\t\t\text4_msg(sb, KERN_ERR,\n\t\t\t\t \"uh-oh! used pa while discarding\");\n\t\t\tWARN_ON(1);\n\t\t\tschedule_timeout_uninterruptible(HZ);\n\t\t\tgoto repeat;\n\n\t\t}\n\t\tif (pa->pa_deleted == 0) {\n\t\t\tpa->pa_deleted = 1;\n\t\t\tspin_unlock(&pa->pa_lock);\n\t\t\tlist_del_rcu(&pa->pa_inode_list);\n\t\t\tlist_add(&pa->u.pa_tmp_list, &list);\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* someone is deleting pa right now */\n\t\tspin_unlock(&pa->pa_lock);\n\t\tspin_unlock(&ei->i_prealloc_lock);\n\n\t\t/* we have to wait here because pa_deleted\n\t\t * doesn't mean pa is already unlinked from\n\t\t * the list. as we might be called from\n\t\t * ->clear_inode() the inode will get freed\n\t\t * and concurrent thread which is unlinking\n\t\t * pa from inode's list may access already\n\t\t * freed memory, bad-bad-bad */\n\n\t\t/* XXX: if this happens too often, we can\n\t\t * add a flag to force wait only in case\n\t\t * of ->clear_inode(), but not in case of\n\t\t * regular truncate */\n\t\tschedule_timeout_uninterruptible(HZ);\n\t\tgoto repeat;\n\t}\n\tspin_unlock(&ei->i_prealloc_lock);\n\n\tlist_for_each_entry_safe(pa, tmp, &list, u.pa_tmp_list) {\n\t\tBUG_ON(pa->pa_type != MB_INODE_PA);\n\t\tgroup = ext4_get_group_number(sb, pa->pa_pstart);\n\n\t\terr = ext4_mb_load_buddy(sb, group, &e4b);\n\t\tif (err) {\n\t\t\text4_error(sb, \"Error loading buddy information for %u\",\n\t\t\t\t\tgroup);\n\t\t\tcontinue;\n\t\t}\n\n\t\tbitmap_bh = ext4_read_block_bitmap(sb, group);\n\t\tif (bitmap_bh == NULL) {\n\t\t\text4_error(sb, \"Error reading block bitmap for %u\",\n\t\t\t\t\tgroup);\n\t\t\text4_mb_unload_buddy(&e4b);\n\t\t\tcontinue;\n\t\t}\n\n\t\text4_lock_group(sb, group);\n\t\tlist_del(&pa->pa_group_list);\n\t\text4_mb_release_inode_pa(&e4b, bitmap_bh, pa);\n\t\text4_unlock_group(sb, group);\n\n\t\text4_mb_unload_buddy(&e4b);\n\t\tput_bh(bitmap_bh);\n\n\t\tlist_del(&pa->u.pa_tmp_list);\n\t\tcall_rcu(&(pa)->u.pa_rcu, ext4_mb_pa_callback);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_double_down_write_data_sem",
          "args": [
            "orig_inode",
            "donor_inode"
          ],
          "line": 660
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_double_down_write_data_sem",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/move_extent.c",
          "lines": "58-69",
          "snippet": "void\next4_double_down_write_data_sem(struct inode *first, struct inode *second)\n{\n\tif (first < second) {\n\t\tdown_write(&EXT4_I(first)->i_data_sem);\n\t\tdown_write_nested(&EXT4_I(second)->i_data_sem, SINGLE_DEPTH_NESTING);\n\t} else {\n\t\tdown_write(&EXT4_I(second)->i_data_sem);\n\t\tdown_write_nested(&EXT4_I(first)->i_data_sem, SINGLE_DEPTH_NESTING);\n\n\t}\n}",
          "includes": [
            "#include \"ext4_extents.h\"",
            "#include \"ext4.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include <linux/slab.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ext4_extents.h\"\n#include \"ext4.h\"\n#include \"ext4_jbd2.h\"\n#include <linux/slab.h>\n#include <linux/quotaops.h>\n#include <linux/fs.h>\n\nvoid\next4_double_down_write_data_sem(struct inode *first, struct inode *second)\n{\n\tif (first < second) {\n\t\tdown_write(&EXT4_I(first)->i_data_sem);\n\t\tdown_write_nested(&EXT4_I(second)->i_data_sem, SINGLE_DEPTH_NESTING);\n\t} else {\n\t\tdown_write(&EXT4_I(second)->i_data_sem);\n\t\tdown_write_nested(&EXT4_I(first)->i_data_sem, SINGLE_DEPTH_NESTING);\n\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "move_extent_per_page",
          "args": [
            "o_filp",
            "donor_inode",
            "orig_page_index",
            "donor_page_index",
            "offset_in_page",
            "cur_len",
            "unwritten",
            "&ret"
          ],
          "line": 656
        },
        "resolved": true,
        "details": {
          "function_name": "move_extent_per_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/move_extent.c",
          "lines": "259-434",
          "snippet": "static int\nmove_extent_per_page(struct file *o_filp, struct inode *donor_inode,\n\t\t     pgoff_t orig_page_offset, pgoff_t donor_page_offset,\n\t\t     int data_offset_in_page,\n\t\t     int block_len_in_page, int unwritten, int *err)\n{\n\tstruct inode *orig_inode = file_inode(o_filp);\n\tstruct page *pagep[2] = {NULL, NULL};\n\thandle_t *handle;\n\text4_lblk_t orig_blk_offset, donor_blk_offset;\n\tunsigned long blocksize = orig_inode->i_sb->s_blocksize;\n\tunsigned int tmp_data_size, data_size, replaced_size;\n\tint err2, jblocks, retries = 0;\n\tint replaced_count = 0;\n\tint from = data_offset_in_page << orig_inode->i_blkbits;\n\tint blocks_per_page = PAGE_CACHE_SIZE >> orig_inode->i_blkbits;\n\tstruct super_block *sb = orig_inode->i_sb;\n\n\t/*\n\t * It needs twice the amount of ordinary journal buffers because\n\t * inode and donor_inode may change each different metadata blocks.\n\t */\nagain:\n\t*err = 0;\n\tjblocks = ext4_writepage_trans_blocks(orig_inode) * 2;\n\thandle = ext4_journal_start(orig_inode, EXT4_HT_MOVE_EXTENTS, jblocks);\n\tif (IS_ERR(handle)) {\n\t\t*err = PTR_ERR(handle);\n\t\treturn 0;\n\t}\n\n\torig_blk_offset = orig_page_offset * blocks_per_page +\n\t\tdata_offset_in_page;\n\n\tdonor_blk_offset = donor_page_offset * blocks_per_page +\n\t\tdata_offset_in_page;\n\n\t/* Calculate data_size */\n\tif ((orig_blk_offset + block_len_in_page - 1) ==\n\t    ((orig_inode->i_size - 1) >> orig_inode->i_blkbits)) {\n\t\t/* Replace the last block */\n\t\ttmp_data_size = orig_inode->i_size & (blocksize - 1);\n\t\t/*\n\t\t * If data_size equal zero, it shows data_size is multiples of\n\t\t * blocksize. So we set appropriate value.\n\t\t */\n\t\tif (tmp_data_size == 0)\n\t\t\ttmp_data_size = blocksize;\n\n\t\tdata_size = tmp_data_size +\n\t\t\t((block_len_in_page - 1) << orig_inode->i_blkbits);\n\t} else\n\t\tdata_size = block_len_in_page << orig_inode->i_blkbits;\n\n\treplaced_size = data_size;\n\n\t*err = mext_page_double_lock(orig_inode, donor_inode, orig_page_offset,\n\t\t\t\t     donor_page_offset, pagep);\n\tif (unlikely(*err < 0))\n\t\tgoto stop_journal;\n\t/*\n\t * If orig extent was unwritten it can become initialized\n\t * at any time after i_data_sem was dropped, in order to\n\t * serialize with delalloc we have recheck extent while we\n\t * hold page's lock, if it is still the case data copy is not\n\t * necessary, just swap data blocks between orig and donor.\n\t */\n\tif (unwritten) {\n\t\text4_double_down_write_data_sem(orig_inode, donor_inode);\n\t\t/* If any of extents in range became initialized we have to\n\t\t * fallback to data copying */\n\t\tunwritten = mext_check_coverage(orig_inode, orig_blk_offset,\n\t\t\t\t\t\tblock_len_in_page, 1, err);\n\t\tif (*err)\n\t\t\tgoto drop_data_sem;\n\n\t\tunwritten &= mext_check_coverage(donor_inode, donor_blk_offset,\n\t\t\t\t\t\t block_len_in_page, 1, err);\n\t\tif (*err)\n\t\t\tgoto drop_data_sem;\n\n\t\tif (!unwritten) {\n\t\t\text4_double_up_write_data_sem(orig_inode, donor_inode);\n\t\t\tgoto data_copy;\n\t\t}\n\t\tif ((page_has_private(pagep[0]) &&\n\t\t     !try_to_release_page(pagep[0], 0)) ||\n\t\t    (page_has_private(pagep[1]) &&\n\t\t     !try_to_release_page(pagep[1], 0))) {\n\t\t\t*err = -EBUSY;\n\t\t\tgoto drop_data_sem;\n\t\t}\n\t\treplaced_count = ext4_swap_extents(handle, orig_inode,\n\t\t\t\t\t\t   donor_inode, orig_blk_offset,\n\t\t\t\t\t\t   donor_blk_offset,\n\t\t\t\t\t\t   block_len_in_page, 1, err);\n\tdrop_data_sem:\n\t\text4_double_up_write_data_sem(orig_inode, donor_inode);\n\t\tgoto unlock_pages;\n\t}\ndata_copy:\n\t*err = mext_page_mkuptodate(pagep[0], from, from + replaced_size);\n\tif (*err)\n\t\tgoto unlock_pages;\n\n\t/* At this point all buffers in range are uptodate, old mapping layout\n\t * is no longer required, try to drop it now. */\n\tif ((page_has_private(pagep[0]) && !try_to_release_page(pagep[0], 0)) ||\n\t    (page_has_private(pagep[1]) && !try_to_release_page(pagep[1], 0))) {\n\t\t*err = -EBUSY;\n\t\tgoto unlock_pages;\n\t}\n\text4_double_down_write_data_sem(orig_inode, donor_inode);\n\treplaced_count = ext4_swap_extents(handle, orig_inode, donor_inode,\n\t\t\t\t\t       orig_blk_offset, donor_blk_offset,\n\t\t\t\t\t   block_len_in_page, 1, err);\n\text4_double_up_write_data_sem(orig_inode, donor_inode);\n\tif (*err) {\n\t\tif (replaced_count) {\n\t\t\tblock_len_in_page = replaced_count;\n\t\t\treplaced_size =\n\t\t\t\tblock_len_in_page << orig_inode->i_blkbits;\n\t\t} else\n\t\t\tgoto unlock_pages;\n\t}\n\t/* Perform all necessary steps similar write_begin()/write_end()\n\t * but keeping in mind that i_size will not change */\n\t*err = __block_write_begin(pagep[0], from, replaced_size,\n\t\t\t\t   ext4_get_block);\n\tif (!*err)\n\t\t*err = block_commit_write(pagep[0], from, from + replaced_size);\n\n\tif (unlikely(*err < 0))\n\t\tgoto repair_branches;\n\n\t/* Even in case of data=writeback it is reasonable to pin\n\t * inode to transaction, to prevent unexpected data loss */\n\t*err = ext4_jbd2_file_inode(handle, orig_inode);\n\nunlock_pages:\n\tunlock_page(pagep[0]);\n\tpage_cache_release(pagep[0]);\n\tunlock_page(pagep[1]);\n\tpage_cache_release(pagep[1]);\nstop_journal:\n\text4_journal_stop(handle);\n\tif (*err == -ENOSPC &&\n\t    ext4_should_retry_alloc(sb, &retries))\n\t\tgoto again;\n\t/* Buffer was busy because probably is pinned to journal transaction,\n\t * force transaction commit may help to free it. */\n\tif (*err == -EBUSY && retries++ < 4 && EXT4_SB(sb)->s_journal &&\n\t    jbd2_journal_force_commit_nested(EXT4_SB(sb)->s_journal))\n\t\tgoto again;\n\treturn replaced_count;\n\nrepair_branches:\n\t/*\n\t * This should never ever happen!\n\t * Extents are swapped already, but we are not able to copy data.\n\t * Try to swap extents to it's original places\n\t */\n\text4_double_down_write_data_sem(orig_inode, donor_inode);\n\treplaced_count = ext4_swap_extents(handle, donor_inode, orig_inode,\n\t\t\t\t\t       orig_blk_offset, donor_blk_offset,\n\t\t\t\t\t   block_len_in_page, 0, &err2);\n\text4_double_up_write_data_sem(orig_inode, donor_inode);\n\tif (replaced_count != block_len_in_page) {\n\t\tEXT4_ERROR_INODE_BLOCK(orig_inode, (sector_t)(orig_blk_offset),\n\t\t\t\t       \"Unable to copy data block,\"\n\t\t\t\t       \" data will be lost.\");\n\t\t*err = -EIO;\n\t}\n\treplaced_count = 0;\n\tgoto unlock_pages;\n}",
          "includes": [
            "#include \"ext4_extents.h\"",
            "#include \"ext4.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include <linux/slab.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ext4_extents.h\"\n#include \"ext4.h\"\n#include \"ext4_jbd2.h\"\n#include <linux/slab.h>\n#include <linux/quotaops.h>\n#include <linux/fs.h>\n\nstatic int\nmove_extent_per_page(struct file *o_filp, struct inode *donor_inode,\n\t\t     pgoff_t orig_page_offset, pgoff_t donor_page_offset,\n\t\t     int data_offset_in_page,\n\t\t     int block_len_in_page, int unwritten, int *err)\n{\n\tstruct inode *orig_inode = file_inode(o_filp);\n\tstruct page *pagep[2] = {NULL, NULL};\n\thandle_t *handle;\n\text4_lblk_t orig_blk_offset, donor_blk_offset;\n\tunsigned long blocksize = orig_inode->i_sb->s_blocksize;\n\tunsigned int tmp_data_size, data_size, replaced_size;\n\tint err2, jblocks, retries = 0;\n\tint replaced_count = 0;\n\tint from = data_offset_in_page << orig_inode->i_blkbits;\n\tint blocks_per_page = PAGE_CACHE_SIZE >> orig_inode->i_blkbits;\n\tstruct super_block *sb = orig_inode->i_sb;\n\n\t/*\n\t * It needs twice the amount of ordinary journal buffers because\n\t * inode and donor_inode may change each different metadata blocks.\n\t */\nagain:\n\t*err = 0;\n\tjblocks = ext4_writepage_trans_blocks(orig_inode) * 2;\n\thandle = ext4_journal_start(orig_inode, EXT4_HT_MOVE_EXTENTS, jblocks);\n\tif (IS_ERR(handle)) {\n\t\t*err = PTR_ERR(handle);\n\t\treturn 0;\n\t}\n\n\torig_blk_offset = orig_page_offset * blocks_per_page +\n\t\tdata_offset_in_page;\n\n\tdonor_blk_offset = donor_page_offset * blocks_per_page +\n\t\tdata_offset_in_page;\n\n\t/* Calculate data_size */\n\tif ((orig_blk_offset + block_len_in_page - 1) ==\n\t    ((orig_inode->i_size - 1) >> orig_inode->i_blkbits)) {\n\t\t/* Replace the last block */\n\t\ttmp_data_size = orig_inode->i_size & (blocksize - 1);\n\t\t/*\n\t\t * If data_size equal zero, it shows data_size is multiples of\n\t\t * blocksize. So we set appropriate value.\n\t\t */\n\t\tif (tmp_data_size == 0)\n\t\t\ttmp_data_size = blocksize;\n\n\t\tdata_size = tmp_data_size +\n\t\t\t((block_len_in_page - 1) << orig_inode->i_blkbits);\n\t} else\n\t\tdata_size = block_len_in_page << orig_inode->i_blkbits;\n\n\treplaced_size = data_size;\n\n\t*err = mext_page_double_lock(orig_inode, donor_inode, orig_page_offset,\n\t\t\t\t     donor_page_offset, pagep);\n\tif (unlikely(*err < 0))\n\t\tgoto stop_journal;\n\t/*\n\t * If orig extent was unwritten it can become initialized\n\t * at any time after i_data_sem was dropped, in order to\n\t * serialize with delalloc we have recheck extent while we\n\t * hold page's lock, if it is still the case data copy is not\n\t * necessary, just swap data blocks between orig and donor.\n\t */\n\tif (unwritten) {\n\t\text4_double_down_write_data_sem(orig_inode, donor_inode);\n\t\t/* If any of extents in range became initialized we have to\n\t\t * fallback to data copying */\n\t\tunwritten = mext_check_coverage(orig_inode, orig_blk_offset,\n\t\t\t\t\t\tblock_len_in_page, 1, err);\n\t\tif (*err)\n\t\t\tgoto drop_data_sem;\n\n\t\tunwritten &= mext_check_coverage(donor_inode, donor_blk_offset,\n\t\t\t\t\t\t block_len_in_page, 1, err);\n\t\tif (*err)\n\t\t\tgoto drop_data_sem;\n\n\t\tif (!unwritten) {\n\t\t\text4_double_up_write_data_sem(orig_inode, donor_inode);\n\t\t\tgoto data_copy;\n\t\t}\n\t\tif ((page_has_private(pagep[0]) &&\n\t\t     !try_to_release_page(pagep[0], 0)) ||\n\t\t    (page_has_private(pagep[1]) &&\n\t\t     !try_to_release_page(pagep[1], 0))) {\n\t\t\t*err = -EBUSY;\n\t\t\tgoto drop_data_sem;\n\t\t}\n\t\treplaced_count = ext4_swap_extents(handle, orig_inode,\n\t\t\t\t\t\t   donor_inode, orig_blk_offset,\n\t\t\t\t\t\t   donor_blk_offset,\n\t\t\t\t\t\t   block_len_in_page, 1, err);\n\tdrop_data_sem:\n\t\text4_double_up_write_data_sem(orig_inode, donor_inode);\n\t\tgoto unlock_pages;\n\t}\ndata_copy:\n\t*err = mext_page_mkuptodate(pagep[0], from, from + replaced_size);\n\tif (*err)\n\t\tgoto unlock_pages;\n\n\t/* At this point all buffers in range are uptodate, old mapping layout\n\t * is no longer required, try to drop it now. */\n\tif ((page_has_private(pagep[0]) && !try_to_release_page(pagep[0], 0)) ||\n\t    (page_has_private(pagep[1]) && !try_to_release_page(pagep[1], 0))) {\n\t\t*err = -EBUSY;\n\t\tgoto unlock_pages;\n\t}\n\text4_double_down_write_data_sem(orig_inode, donor_inode);\n\treplaced_count = ext4_swap_extents(handle, orig_inode, donor_inode,\n\t\t\t\t\t       orig_blk_offset, donor_blk_offset,\n\t\t\t\t\t   block_len_in_page, 1, err);\n\text4_double_up_write_data_sem(orig_inode, donor_inode);\n\tif (*err) {\n\t\tif (replaced_count) {\n\t\t\tblock_len_in_page = replaced_count;\n\t\t\treplaced_size =\n\t\t\t\tblock_len_in_page << orig_inode->i_blkbits;\n\t\t} else\n\t\t\tgoto unlock_pages;\n\t}\n\t/* Perform all necessary steps similar write_begin()/write_end()\n\t * but keeping in mind that i_size will not change */\n\t*err = __block_write_begin(pagep[0], from, replaced_size,\n\t\t\t\t   ext4_get_block);\n\tif (!*err)\n\t\t*err = block_commit_write(pagep[0], from, from + replaced_size);\n\n\tif (unlikely(*err < 0))\n\t\tgoto repair_branches;\n\n\t/* Even in case of data=writeback it is reasonable to pin\n\t * inode to transaction, to prevent unexpected data loss */\n\t*err = ext4_jbd2_file_inode(handle, orig_inode);\n\nunlock_pages:\n\tunlock_page(pagep[0]);\n\tpage_cache_release(pagep[0]);\n\tunlock_page(pagep[1]);\n\tpage_cache_release(pagep[1]);\nstop_journal:\n\text4_journal_stop(handle);\n\tif (*err == -ENOSPC &&\n\t    ext4_should_retry_alloc(sb, &retries))\n\t\tgoto again;\n\t/* Buffer was busy because probably is pinned to journal transaction,\n\t * force transaction commit may help to free it. */\n\tif (*err == -EBUSY && retries++ < 4 && EXT4_SB(sb)->s_journal &&\n\t    jbd2_journal_force_commit_nested(EXT4_SB(sb)->s_journal))\n\t\tgoto again;\n\treturn replaced_count;\n\nrepair_branches:\n\t/*\n\t * This should never ever happen!\n\t * Extents are swapped already, but we are not able to copy data.\n\t * Try to swap extents to it's original places\n\t */\n\text4_double_down_write_data_sem(orig_inode, donor_inode);\n\treplaced_count = ext4_swap_extents(handle, donor_inode, orig_inode,\n\t\t\t\t\t       orig_blk_offset, donor_blk_offset,\n\t\t\t\t\t   block_len_in_page, 0, &err2);\n\text4_double_up_write_data_sem(orig_inode, donor_inode);\n\tif (replaced_count != block_len_in_page) {\n\t\tEXT4_ERROR_INODE_BLOCK(orig_inode, (sector_t)(orig_blk_offset),\n\t\t\t\t       \"Unable to copy data block,\"\n\t\t\t\t       \" data will be lost.\");\n\t\t*err = -EIO;\n\t}\n\treplaced_count = 0;\n\tgoto unlock_pages;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_ext_is_unwritten",
          "args": [
            "ex"
          ],
          "line": 636
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_ext_is_unwritten",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ext4_extents.h",
          "lines": "198-202",
          "snippet": "static inline int ext4_ext_is_unwritten(struct ext4_extent *ext)\n{\n\t/* Extent with ee_len of 0x8000 is treated as an initialized extent */\n\treturn (le16_to_cpu(ext->ee_len) > EXT_INIT_MAX_LEN);\n}",
          "includes": [
            "#include \"ext4.h\""
          ],
          "macros_used": [
            "#define EXT_INIT_MAX_LEN\t(1UL << 15)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ext4.h\"\n\n#define EXT_INIT_MAX_LEN\t(1UL << 15)\n\nstatic inline int ext4_ext_is_unwritten(struct ext4_extent *ext)\n{\n\t/* Extent with ee_len of 0x8000 is treated as an initialized extent */\n\treturn (le16_to_cpu(ext->ee_len) > EXT_INIT_MAX_LEN);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_ext_get_actual_len",
          "args": [
            "ex"
          ],
          "line": 614
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_ext_get_actual_len",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ext4_extents.h",
          "lines": "204-209",
          "snippet": "static inline int ext4_ext_get_actual_len(struct ext4_extent *ext)\n{\n\treturn (le16_to_cpu(ext->ee_len) <= EXT_INIT_MAX_LEN ?\n\t\tle16_to_cpu(ext->ee_len) :\n\t\t(le16_to_cpu(ext->ee_len) - EXT_INIT_MAX_LEN));\n}",
          "includes": [
            "#include \"ext4.h\""
          ],
          "macros_used": [
            "#define EXT_INIT_MAX_LEN\t(1UL << 15)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ext4.h\"\n\n#define EXT_INIT_MAX_LEN\t(1UL << 15)\n\nstatic inline int ext4_ext_get_actual_len(struct ext4_extent *ext)\n{\n\treturn (le16_to_cpu(ext->ee_len) <= EXT_INIT_MAX_LEN ?\n\t\tle16_to_cpu(ext->ee_len) :\n\t\t(le16_to_cpu(ext->ee_len) - EXT_INIT_MAX_LEN));\n}"
        }
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "ex->ee_block"
          ],
          "line": 613
        },
        "resolved": true,
        "details": {
          "function_name": "sle32_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "53-56",
          "snippet": "static inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_ext_next_allocated_block",
          "args": [
            "path"
          ],
          "line": 612
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_ext_next_allocated_block",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/extents.c",
          "lines": "1592-1620",
          "snippet": "ext4_lblk_t\next4_ext_next_allocated_block(struct ext4_ext_path *path)\n{\n\tint depth;\n\n\tBUG_ON(path == NULL);\n\tdepth = path->p_depth;\n\n\tif (depth == 0 && path->p_ext == NULL)\n\t\treturn EXT_MAX_BLOCKS;\n\n\twhile (depth >= 0) {\n\t\tif (depth == path->p_depth) {\n\t\t\t/* leaf */\n\t\t\tif (path[depth].p_ext &&\n\t\t\t\tpath[depth].p_ext !=\n\t\t\t\t\tEXT_LAST_EXTENT(path[depth].p_hdr))\n\t\t\t  return le32_to_cpu(path[depth].p_ext[1].ee_block);\n\t\t} else {\n\t\t\t/* index */\n\t\t\tif (path[depth].p_idx !=\n\t\t\t\t\tEXT_LAST_INDEX(path[depth].p_hdr))\n\t\t\t  return le32_to_cpu(path[depth].p_idx[1].ei_block);\n\t\t}\n\t\tdepth--;\n\t}\n\n\treturn EXT_MAX_BLOCKS;\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"xattr.h\"",
            "#include \"ext4_extents.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include <linux/fiemap.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/string.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highuid.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/time.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"xattr.h\"\n#include \"ext4_extents.h\"\n#include \"ext4_jbd2.h\"\n#include <linux/fiemap.h>\n#include <asm/uaccess.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/highuid.h>\n#include <linux/jbd2.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n\next4_lblk_t\next4_ext_next_allocated_block(struct ext4_ext_path *path)\n{\n\tint depth;\n\n\tBUG_ON(path == NULL);\n\tdepth = path->p_depth;\n\n\tif (depth == 0 && path->p_ext == NULL)\n\t\treturn EXT_MAX_BLOCKS;\n\n\twhile (depth >= 0) {\n\t\tif (depth == path->p_depth) {\n\t\t\t/* leaf */\n\t\t\tif (path[depth].p_ext &&\n\t\t\t\tpath[depth].p_ext !=\n\t\t\t\t\tEXT_LAST_EXTENT(path[depth].p_hdr))\n\t\t\t  return le32_to_cpu(path[depth].p_ext[1].ee_block);\n\t\t} else {\n\t\t\t/* index */\n\t\t\tif (path[depth].p_idx !=\n\t\t\t\t\tEXT_LAST_INDEX(path[depth].p_hdr))\n\t\t\t  return le32_to_cpu(path[depth].p_idx[1].ei_block);\n\t\t}\n\t\tdepth--;\n\t}\n\n\treturn EXT_MAX_BLOCKS;\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_ext_path",
          "args": [
            "orig_inode",
            "o_start",
            "&path"
          ],
          "line": 608
        },
        "resolved": true,
        "details": {
          "function_name": "get_ext_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/move_extent.c",
          "lines": "33-50",
          "snippet": "static inline int\nget_ext_path(struct inode *inode, ext4_lblk_t lblock,\n\t\tstruct ext4_ext_path **ppath)\n{\n\tstruct ext4_ext_path *path;\n\n\tpath = ext4_find_extent(inode, lblock, ppath, EXT4_EX_NOCACHE);\n\tif (IS_ERR(path))\n\t\treturn PTR_ERR(path);\n\tif (path[ext_depth(inode)].p_ext == NULL) {\n\t\text4_ext_drop_refs(path);\n\t\tkfree(path);\n\t\t*ppath = NULL;\n\t\treturn -ENODATA;\n\t}\n\t*ppath = path;\n\treturn 0;\n}",
          "includes": [
            "#include \"ext4_extents.h\"",
            "#include \"ext4.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include <linux/slab.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ext4_extents.h\"\n#include \"ext4.h\"\n#include \"ext4_jbd2.h\"\n#include <linux/slab.h>\n#include <linux/quotaops.h>\n#include <linux/fs.h>\n\nstatic inline int\nget_ext_path(struct inode *inode, ext4_lblk_t lblock,\n\t\tstruct ext4_ext_path **ppath)\n{\n\tstruct ext4_ext_path *path;\n\n\tpath = ext4_find_extent(inode, lblock, ppath, EXT4_EX_NOCACHE);\n\tif (IS_ERR(path))\n\t\treturn PTR_ERR(path);\n\tif (path[ext_depth(inode)].p_ext == NULL) {\n\t\text4_ext_drop_refs(path);\n\t\tkfree(path);\n\t\t*ppath = NULL;\n\t\treturn -ENODATA;\n\t}\n\t*ppath = path;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mext_check_arguments",
          "args": [
            "orig_inode",
            "donor_inode",
            "orig_blk",
            "donor_blk",
            "&len"
          ],
          "line": 595
        },
        "resolved": true,
        "details": {
          "function_name": "mext_check_arguments",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/move_extent.c",
          "lines": "449-527",
          "snippet": "static int\nmext_check_arguments(struct inode *orig_inode,\n\t\t     struct inode *donor_inode, __u64 orig_start,\n\t\t     __u64 donor_start, __u64 *len)\n{\n\t__u64 orig_eof, donor_eof;\n\tunsigned int blkbits = orig_inode->i_blkbits;\n\tunsigned int blocksize = 1 << blkbits;\n\n\torig_eof = (i_size_read(orig_inode) + blocksize - 1) >> blkbits;\n\tdonor_eof = (i_size_read(donor_inode) + blocksize - 1) >> blkbits;\n\n\n\tif (donor_inode->i_mode & (S_ISUID|S_ISGID)) {\n\t\text4_debug(\"ext4 move extent: suid or sgid is set\"\n\t\t\t   \" to donor file [ino:orig %lu, donor %lu]\\n\",\n\t\t\t   orig_inode->i_ino, donor_inode->i_ino);\n\t\treturn -EINVAL;\n\t}\n\n\tif (IS_IMMUTABLE(donor_inode) || IS_APPEND(donor_inode))\n\t\treturn -EPERM;\n\n\t/* Ext4 move extent does not support swapfile */\n\tif (IS_SWAPFILE(orig_inode) || IS_SWAPFILE(donor_inode)) {\n\t\text4_debug(\"ext4 move extent: The argument files should \"\n\t\t\t\"not be swapfile [ino:orig %lu, donor %lu]\\n\",\n\t\t\torig_inode->i_ino, donor_inode->i_ino);\n\t\treturn -EBUSY;\n\t}\n\n\t/* Ext4 move extent supports only extent based file */\n\tif (!(ext4_test_inode_flag(orig_inode, EXT4_INODE_EXTENTS))) {\n\t\text4_debug(\"ext4 move extent: orig file is not extents \"\n\t\t\t\"based file [ino:orig %lu]\\n\", orig_inode->i_ino);\n\t\treturn -EOPNOTSUPP;\n\t} else if (!(ext4_test_inode_flag(donor_inode, EXT4_INODE_EXTENTS))) {\n\t\text4_debug(\"ext4 move extent: donor file is not extents \"\n\t\t\t\"based file [ino:donor %lu]\\n\", donor_inode->i_ino);\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\tif ((!orig_inode->i_size) || (!donor_inode->i_size)) {\n\t\text4_debug(\"ext4 move extent: File size is 0 byte\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\t/* Start offset should be same */\n\tif ((orig_start & ~(PAGE_MASK >> orig_inode->i_blkbits)) !=\n\t    (donor_start & ~(PAGE_MASK >> orig_inode->i_blkbits))) {\n\t\text4_debug(\"ext4 move extent: orig and donor's start \"\n\t\t\t\"offset are not alligned [ino:orig %lu, donor %lu]\\n\",\n\t\t\torig_inode->i_ino, donor_inode->i_ino);\n\t\treturn -EINVAL;\n\t}\n\n\tif ((orig_start >= EXT_MAX_BLOCKS) ||\n\t    (donor_start >= EXT_MAX_BLOCKS) ||\n\t    (*len > EXT_MAX_BLOCKS) ||\n\t    (donor_start + *len >= EXT_MAX_BLOCKS) ||\n\t    (orig_start + *len >= EXT_MAX_BLOCKS))  {\n\t\text4_debug(\"ext4 move extent: Can't handle over [%u] blocks \"\n\t\t\t\"[ino:orig %lu, donor %lu]\\n\", EXT_MAX_BLOCKS,\n\t\t\torig_inode->i_ino, donor_inode->i_ino);\n\t\treturn -EINVAL;\n\t}\n\tif (orig_eof < orig_start + *len - 1)\n\t\t*len = orig_eof - orig_start;\n\tif (donor_eof < donor_start + *len - 1)\n\t\t*len = donor_eof - donor_start;\n\tif (!*len) {\n\t\text4_debug(\"ext4 move extent: len should not be 0 \"\n\t\t\t\"[ino:orig %lu, donor %lu]\\n\", orig_inode->i_ino,\n\t\t\tdonor_inode->i_ino);\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"ext4_extents.h\"",
            "#include \"ext4.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include <linux/slab.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ext4_extents.h\"\n#include \"ext4.h\"\n#include \"ext4_jbd2.h\"\n#include <linux/slab.h>\n#include <linux/quotaops.h>\n#include <linux/fs.h>\n\nstatic int\nmext_check_arguments(struct inode *orig_inode,\n\t\t     struct inode *donor_inode, __u64 orig_start,\n\t\t     __u64 donor_start, __u64 *len)\n{\n\t__u64 orig_eof, donor_eof;\n\tunsigned int blkbits = orig_inode->i_blkbits;\n\tunsigned int blocksize = 1 << blkbits;\n\n\torig_eof = (i_size_read(orig_inode) + blocksize - 1) >> blkbits;\n\tdonor_eof = (i_size_read(donor_inode) + blocksize - 1) >> blkbits;\n\n\n\tif (donor_inode->i_mode & (S_ISUID|S_ISGID)) {\n\t\text4_debug(\"ext4 move extent: suid or sgid is set\"\n\t\t\t   \" to donor file [ino:orig %lu, donor %lu]\\n\",\n\t\t\t   orig_inode->i_ino, donor_inode->i_ino);\n\t\treturn -EINVAL;\n\t}\n\n\tif (IS_IMMUTABLE(donor_inode) || IS_APPEND(donor_inode))\n\t\treturn -EPERM;\n\n\t/* Ext4 move extent does not support swapfile */\n\tif (IS_SWAPFILE(orig_inode) || IS_SWAPFILE(donor_inode)) {\n\t\text4_debug(\"ext4 move extent: The argument files should \"\n\t\t\t\"not be swapfile [ino:orig %lu, donor %lu]\\n\",\n\t\t\torig_inode->i_ino, donor_inode->i_ino);\n\t\treturn -EBUSY;\n\t}\n\n\t/* Ext4 move extent supports only extent based file */\n\tif (!(ext4_test_inode_flag(orig_inode, EXT4_INODE_EXTENTS))) {\n\t\text4_debug(\"ext4 move extent: orig file is not extents \"\n\t\t\t\"based file [ino:orig %lu]\\n\", orig_inode->i_ino);\n\t\treturn -EOPNOTSUPP;\n\t} else if (!(ext4_test_inode_flag(donor_inode, EXT4_INODE_EXTENTS))) {\n\t\text4_debug(\"ext4 move extent: donor file is not extents \"\n\t\t\t\"based file [ino:donor %lu]\\n\", donor_inode->i_ino);\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\tif ((!orig_inode->i_size) || (!donor_inode->i_size)) {\n\t\text4_debug(\"ext4 move extent: File size is 0 byte\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\t/* Start offset should be same */\n\tif ((orig_start & ~(PAGE_MASK >> orig_inode->i_blkbits)) !=\n\t    (donor_start & ~(PAGE_MASK >> orig_inode->i_blkbits))) {\n\t\text4_debug(\"ext4 move extent: orig and donor's start \"\n\t\t\t\"offset are not alligned [ino:orig %lu, donor %lu]\\n\",\n\t\t\torig_inode->i_ino, donor_inode->i_ino);\n\t\treturn -EINVAL;\n\t}\n\n\tif ((orig_start >= EXT_MAX_BLOCKS) ||\n\t    (donor_start >= EXT_MAX_BLOCKS) ||\n\t    (*len > EXT_MAX_BLOCKS) ||\n\t    (donor_start + *len >= EXT_MAX_BLOCKS) ||\n\t    (orig_start + *len >= EXT_MAX_BLOCKS))  {\n\t\text4_debug(\"ext4 move extent: Can't handle over [%u] blocks \"\n\t\t\t\"[ino:orig %lu, donor %lu]\\n\", EXT_MAX_BLOCKS,\n\t\t\torig_inode->i_ino, donor_inode->i_ino);\n\t\treturn -EINVAL;\n\t}\n\tif (orig_eof < orig_start + *len - 1)\n\t\t*len = orig_eof - orig_start;\n\tif (donor_eof < donor_start + *len - 1)\n\t\t*len = donor_eof - donor_start;\n\tif (!*len) {\n\t\text4_debug(\"ext4 move extent: len should not be 0 \"\n\t\t\t\"[ino:orig %lu, donor %lu]\\n\", orig_inode->i_ino,\n\t\t\tdonor_inode->i_ino);\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "inode_dio_wait",
          "args": [
            "donor_inode"
          ],
          "line": 590
        },
        "resolved": true,
        "details": {
          "function_name": "inode_dio_wait",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "1941-1945",
          "snippet": "void inode_dio_wait(struct inode *inode)\n{\n\tif (atomic_read(&inode->i_dio_count))\n\t\t__inode_dio_wait(inode);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid inode_dio_wait(struct inode *inode)\n{\n\tif (atomic_read(&inode->i_dio_count))\n\t\t__inode_dio_wait(inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_inode_block_unlocked_dio",
          "args": [
            "donor_inode"
          ],
          "line": 588
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_inode_block_unlocked_dio",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ext4.h",
          "lines": "2825-2829",
          "snippet": "static inline void ext4_inode_block_unlocked_dio(struct inode *inode)\n{\n\text4_set_inode_state(inode, EXT4_STATE_DIOREAD_LOCK);\n\tsmp_mb();\n}",
          "includes": [
            "#include \"extents_status.h\"",
            "#include <linux/compat.h>",
            "#include <linux/falloc.h>",
            "#include <crypto/hash.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/wait.h>",
            "#include <linux/timer.h>",
            "#include <linux/mutex.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/quota.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extents_status.h\"\n#include <linux/compat.h>\n#include <linux/falloc.h>\n#include <crypto/hash.h>\n#include <linux/ratelimit.h>\n#include <linux/percpu_counter.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/wait.h>\n#include <linux/timer.h>\n#include <linux/mutex.h>\n#include <linux/seqlock.h>\n#include <linux/rbtree.h>\n#include <linux/rwsem.h>\n#include <linux/quota.h>\n#include <linux/jbd2.h>\n#include <linux/magic.h>\n#include <linux/blkdev.h>\n#include <linux/types.h>\n\nstatic inline void ext4_inode_block_unlocked_dio(struct inode *inode)\n{\n\text4_set_inode_state(inode, EXT4_STATE_DIOREAD_LOCK);\n\tsmp_mb();\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_should_journal_data",
          "args": [
            "donor_inode"
          ],
          "line": 580
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_should_journal_data",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ext4_jbd2.h",
          "lines": "413-416",
          "snippet": "static inline int ext4_should_journal_data(struct inode *inode)\n{\n\treturn ext4_inode_journal_mode(inode) & EXT4_INODE_JOURNAL_DATA_MODE;\n}",
          "includes": [
            "#include \"ext4.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [
            "#define EXT4_INODE_JOURNAL_DATA_MODE\t0x01 /* journal data mode */"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ext4.h\"\n#include <linux/jbd2.h>\n#include <linux/fs.h>\n\n#define EXT4_INODE_JOURNAL_DATA_MODE\t0x01 /* journal data mode */\n\nstatic inline int ext4_should_journal_data(struct inode *inode)\n{\n\treturn ext4_inode_journal_mode(inode) & EXT4_INODE_JOURNAL_DATA_MODE;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_debug",
          "args": [
            "\"ext4 move extent: The argument files should be \"\n\t\t\t\"regular file [ino:orig %lu, donor %lu]\\n\"",
            "orig_inode->i_ino",
            "donor_inode->i_ino"
          ],
          "line": 572
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISREG",
          "args": [
            "donor_inode->i_mode"
          ],
          "line": 571
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISREG",
          "args": [
            "orig_inode->i_mode"
          ],
          "line": 571
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_debug",
          "args": [
            "\"ext4 move extent: The argument files should not \"\n\t\t\t\"be same inode [ino:orig %lu, donor %lu]\\n\"",
            "orig_inode->i_ino",
            "donor_inode->i_ino"
          ],
          "line": 564
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_debug",
          "args": [
            "\"ext4 move extent: The argument files \"\n\t\t\t\"should be in same FS [ino:orig %lu, donor %lu]\\n\"",
            "orig_inode->i_ino",
            "donor_inode->i_ino"
          ],
          "line": 556
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "file_inode",
          "args": [
            "d_filp"
          ],
          "line": 548
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_init_file_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/file.c",
          "lines": "3009-3013",
          "snippet": "void fuse_init_file_inode(struct inode *inode)\n{\n\tinode->i_fop = &fuse_file_operations;\n\tinode->i_data.a_ops = &fuse_file_aops;\n}",
          "includes": [
            "#include <linux/falloc.h>",
            "#include <linux/aio.h>",
            "#include <linux/swap.h>",
            "#include <linux/compat.h>",
            "#include <linux/module.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct file_operations fuse_file_operations = {\n\t.llseek\t\t= fuse_file_llseek,\n\t.read\t\t= new_sync_read,\n\t.read_iter\t= fuse_file_read_iter,\n\t.write\t\t= new_sync_write,\n\t.write_iter\t= fuse_file_write_iter,\n\t.mmap\t\t= fuse_file_mmap,\n\t.open\t\t= fuse_open,\n\t.flush\t\t= fuse_flush,\n\t.release\t= fuse_release,\n\t.fsync\t\t= fuse_fsync,\n\t.lock\t\t= fuse_file_lock,\n\t.flock\t\t= fuse_file_flock,\n\t.splice_read\t= generic_file_splice_read,\n\t.unlocked_ioctl\t= fuse_file_ioctl,\n\t.compat_ioctl\t= fuse_file_compat_ioctl,\n\t.poll\t\t= fuse_file_poll,\n\t.fallocate\t= fuse_file_fallocate,\n};",
            "static const struct address_space_operations fuse_file_aops  = {\n\t.readpage\t= fuse_readpage,\n\t.writepage\t= fuse_writepage,\n\t.writepages\t= fuse_writepages,\n\t.launder_page\t= fuse_launder_page,\n\t.readpages\t= fuse_readpages,\n\t.set_page_dirty\t= __set_page_dirty_nobuffers,\n\t.bmap\t\t= fuse_bmap,\n\t.direct_IO\t= fuse_direct_IO,\n\t.write_begin\t= fuse_write_begin,\n\t.write_end\t= fuse_write_end,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/falloc.h>\n#include <linux/aio.h>\n#include <linux/swap.h>\n#include <linux/compat.h>\n#include <linux/module.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nstatic const struct file_operations fuse_file_operations = {\n\t.llseek\t\t= fuse_file_llseek,\n\t.read\t\t= new_sync_read,\n\t.read_iter\t= fuse_file_read_iter,\n\t.write\t\t= new_sync_write,\n\t.write_iter\t= fuse_file_write_iter,\n\t.mmap\t\t= fuse_file_mmap,\n\t.open\t\t= fuse_open,\n\t.flush\t\t= fuse_flush,\n\t.release\t= fuse_release,\n\t.fsync\t\t= fuse_fsync,\n\t.lock\t\t= fuse_file_lock,\n\t.flock\t\t= fuse_file_flock,\n\t.splice_read\t= generic_file_splice_read,\n\t.unlocked_ioctl\t= fuse_file_ioctl,\n\t.compat_ioctl\t= fuse_file_compat_ioctl,\n\t.poll\t\t= fuse_file_poll,\n\t.fallocate\t= fuse_file_fallocate,\n};\nstatic const struct address_space_operations fuse_file_aops  = {\n\t.readpage\t= fuse_readpage,\n\t.writepage\t= fuse_writepage,\n\t.writepages\t= fuse_writepages,\n\t.launder_page\t= fuse_launder_page,\n\t.readpages\t= fuse_readpages,\n\t.set_page_dirty\t= __set_page_dirty_nobuffers,\n\t.bmap\t\t= fuse_bmap,\n\t.direct_IO\t= fuse_direct_IO,\n\t.write_begin\t= fuse_write_begin,\n\t.write_end\t= fuse_write_end,\n};\n\nvoid fuse_init_file_inode(struct inode *inode)\n{\n\tinode->i_fop = &fuse_file_operations;\n\tinode->i_data.a_ops = &fuse_file_aops;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ext4_extents.h\"\n#include \"ext4.h\"\n#include \"ext4_jbd2.h\"\n#include <linux/slab.h>\n#include <linux/quotaops.h>\n#include <linux/fs.h>\n\nint\next4_move_extents(struct file *o_filp, struct file *d_filp, __u64 orig_blk,\n\t\t  __u64 donor_blk, __u64 len, __u64 *moved_len)\n{\n\tstruct inode *orig_inode = file_inode(o_filp);\n\tstruct inode *donor_inode = file_inode(d_filp);\n\tstruct ext4_ext_path *path = NULL;\n\tint blocks_per_page = PAGE_CACHE_SIZE >> orig_inode->i_blkbits;\n\text4_lblk_t o_end, o_start = orig_blk;\n\text4_lblk_t d_start = donor_blk;\n\tint ret;\n\n\tif (orig_inode->i_sb != donor_inode->i_sb) {\n\t\text4_debug(\"ext4 move extent: The argument files \"\n\t\t\t\"should be in same FS [ino:orig %lu, donor %lu]\\n\",\n\t\t\torig_inode->i_ino, donor_inode->i_ino);\n\t\treturn -EINVAL;\n\t}\n\n\t/* orig and donor should be different inodes */\n\tif (orig_inode == donor_inode) {\n\t\text4_debug(\"ext4 move extent: The argument files should not \"\n\t\t\t\"be same inode [ino:orig %lu, donor %lu]\\n\",\n\t\t\torig_inode->i_ino, donor_inode->i_ino);\n\t\treturn -EINVAL;\n\t}\n\n\t/* Regular file check */\n\tif (!S_ISREG(orig_inode->i_mode) || !S_ISREG(donor_inode->i_mode)) {\n\t\text4_debug(\"ext4 move extent: The argument files should be \"\n\t\t\t\"regular file [ino:orig %lu, donor %lu]\\n\",\n\t\t\torig_inode->i_ino, donor_inode->i_ino);\n\t\treturn -EINVAL;\n\t}\n\t/* TODO: This is non obvious task to swap blocks for inodes with full\n\t   jornaling enabled */\n\tif (ext4_should_journal_data(orig_inode) ||\n\t    ext4_should_journal_data(donor_inode)) {\n\t\treturn -EINVAL;\n\t}\n\t/* Protect orig and donor inodes against a truncate */\n\tlock_two_nondirectories(orig_inode, donor_inode);\n\n\t/* Wait for all existing dio workers */\n\text4_inode_block_unlocked_dio(orig_inode);\n\text4_inode_block_unlocked_dio(donor_inode);\n\tinode_dio_wait(orig_inode);\n\tinode_dio_wait(donor_inode);\n\n\t/* Protect extent tree against block allocations via delalloc */\n\text4_double_down_write_data_sem(orig_inode, donor_inode);\n\t/* Check the filesystem environment whether move_extent can be done */\n\tret = mext_check_arguments(orig_inode, donor_inode, orig_blk,\n\t\t\t\t    donor_blk, &len);\n\tif (ret)\n\t\tgoto out;\n\to_end = o_start + len;\n\n\twhile (o_start < o_end) {\n\t\tstruct ext4_extent *ex;\n\t\text4_lblk_t cur_blk, next_blk;\n\t\tpgoff_t orig_page_index, donor_page_index;\n\t\tint offset_in_page;\n\t\tint unwritten, cur_len;\n\n\t\tret = get_ext_path(orig_inode, o_start, &path);\n\t\tif (ret)\n\t\t\tgoto out;\n\t\tex = path[path->p_depth].p_ext;\n\t\tnext_blk = ext4_ext_next_allocated_block(path);\n\t\tcur_blk = le32_to_cpu(ex->ee_block);\n\t\tcur_len = ext4_ext_get_actual_len(ex);\n\t\t/* Check hole before the start pos */\n\t\tif (cur_blk + cur_len - 1 < o_start) {\n\t\t\tif (next_blk == EXT_MAX_BLOCKS) {\n\t\t\t\to_start = o_end;\n\t\t\t\tret = -ENODATA;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\td_start += next_blk - o_start;\n\t\t\to_start = next_blk;\n\t\t\tcontinue;\n\t\t/* Check hole after the start pos */\n\t\t} else if (cur_blk > o_start) {\n\t\t\t/* Skip hole */\n\t\t\td_start += cur_blk - o_start;\n\t\t\to_start = cur_blk;\n\t\t\t/* Extent inside requested range ?*/\n\t\t\tif (cur_blk >= o_end)\n\t\t\t\tgoto out;\n\t\t} else { /* in_range(o_start, o_blk, o_len) */\n\t\t\tcur_len += cur_blk - o_start;\n\t\t}\n\t\tunwritten = ext4_ext_is_unwritten(ex);\n\t\tif (o_end - o_start < cur_len)\n\t\t\tcur_len = o_end - o_start;\n\n\t\torig_page_index = o_start >> (PAGE_CACHE_SHIFT -\n\t\t\t\t\t       orig_inode->i_blkbits);\n\t\tdonor_page_index = d_start >> (PAGE_CACHE_SHIFT -\n\t\t\t\t\t       donor_inode->i_blkbits);\n\t\toffset_in_page = o_start % blocks_per_page;\n\t\tif (cur_len > blocks_per_page- offset_in_page)\n\t\t\tcur_len = blocks_per_page - offset_in_page;\n\t\t/*\n\t\t * Up semaphore to avoid following problems:\n\t\t * a. transaction deadlock among ext4_journal_start,\n\t\t *    ->write_begin via pagefault, and jbd2_journal_commit\n\t\t * b. racing with ->readpage, ->write_begin, and ext4_get_block\n\t\t *    in move_extent_per_page\n\t\t */\n\t\text4_double_up_write_data_sem(orig_inode, donor_inode);\n\t\t/* Swap original branches with new branches */\n\t\tmove_extent_per_page(o_filp, donor_inode,\n\t\t\t\t     orig_page_index, donor_page_index,\n\t\t\t\t     offset_in_page, cur_len,\n\t\t\t\t     unwritten, &ret);\n\t\text4_double_down_write_data_sem(orig_inode, donor_inode);\n\t\tif (ret < 0)\n\t\t\tbreak;\n\t\to_start += cur_len;\n\t\td_start += cur_len;\n\t}\n\t*moved_len = o_start - orig_blk;\n\tif (*moved_len > len)\n\t\t*moved_len = len;\n\nout:\n\tif (*moved_len) {\n\t\text4_discard_preallocations(orig_inode);\n\t\text4_discard_preallocations(donor_inode);\n\t}\n\n\text4_ext_drop_refs(path);\n\tkfree(path);\n\text4_double_up_write_data_sem(orig_inode, donor_inode);\n\text4_inode_resume_unlocked_dio(orig_inode);\n\text4_inode_resume_unlocked_dio(donor_inode);\n\tunlock_two_nondirectories(orig_inode, donor_inode);\n\n\treturn ret;\n}"
  },
  {
    "function_name": "mext_check_arguments",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/move_extent.c",
    "lines": "449-527",
    "snippet": "static int\nmext_check_arguments(struct inode *orig_inode,\n\t\t     struct inode *donor_inode, __u64 orig_start,\n\t\t     __u64 donor_start, __u64 *len)\n{\n\t__u64 orig_eof, donor_eof;\n\tunsigned int blkbits = orig_inode->i_blkbits;\n\tunsigned int blocksize = 1 << blkbits;\n\n\torig_eof = (i_size_read(orig_inode) + blocksize - 1) >> blkbits;\n\tdonor_eof = (i_size_read(donor_inode) + blocksize - 1) >> blkbits;\n\n\n\tif (donor_inode->i_mode & (S_ISUID|S_ISGID)) {\n\t\text4_debug(\"ext4 move extent: suid or sgid is set\"\n\t\t\t   \" to donor file [ino:orig %lu, donor %lu]\\n\",\n\t\t\t   orig_inode->i_ino, donor_inode->i_ino);\n\t\treturn -EINVAL;\n\t}\n\n\tif (IS_IMMUTABLE(donor_inode) || IS_APPEND(donor_inode))\n\t\treturn -EPERM;\n\n\t/* Ext4 move extent does not support swapfile */\n\tif (IS_SWAPFILE(orig_inode) || IS_SWAPFILE(donor_inode)) {\n\t\text4_debug(\"ext4 move extent: The argument files should \"\n\t\t\t\"not be swapfile [ino:orig %lu, donor %lu]\\n\",\n\t\t\torig_inode->i_ino, donor_inode->i_ino);\n\t\treturn -EBUSY;\n\t}\n\n\t/* Ext4 move extent supports only extent based file */\n\tif (!(ext4_test_inode_flag(orig_inode, EXT4_INODE_EXTENTS))) {\n\t\text4_debug(\"ext4 move extent: orig file is not extents \"\n\t\t\t\"based file [ino:orig %lu]\\n\", orig_inode->i_ino);\n\t\treturn -EOPNOTSUPP;\n\t} else if (!(ext4_test_inode_flag(donor_inode, EXT4_INODE_EXTENTS))) {\n\t\text4_debug(\"ext4 move extent: donor file is not extents \"\n\t\t\t\"based file [ino:donor %lu]\\n\", donor_inode->i_ino);\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\tif ((!orig_inode->i_size) || (!donor_inode->i_size)) {\n\t\text4_debug(\"ext4 move extent: File size is 0 byte\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\t/* Start offset should be same */\n\tif ((orig_start & ~(PAGE_MASK >> orig_inode->i_blkbits)) !=\n\t    (donor_start & ~(PAGE_MASK >> orig_inode->i_blkbits))) {\n\t\text4_debug(\"ext4 move extent: orig and donor's start \"\n\t\t\t\"offset are not alligned [ino:orig %lu, donor %lu]\\n\",\n\t\t\torig_inode->i_ino, donor_inode->i_ino);\n\t\treturn -EINVAL;\n\t}\n\n\tif ((orig_start >= EXT_MAX_BLOCKS) ||\n\t    (donor_start >= EXT_MAX_BLOCKS) ||\n\t    (*len > EXT_MAX_BLOCKS) ||\n\t    (donor_start + *len >= EXT_MAX_BLOCKS) ||\n\t    (orig_start + *len >= EXT_MAX_BLOCKS))  {\n\t\text4_debug(\"ext4 move extent: Can't handle over [%u] blocks \"\n\t\t\t\"[ino:orig %lu, donor %lu]\\n\", EXT_MAX_BLOCKS,\n\t\t\torig_inode->i_ino, donor_inode->i_ino);\n\t\treturn -EINVAL;\n\t}\n\tif (orig_eof < orig_start + *len - 1)\n\t\t*len = orig_eof - orig_start;\n\tif (donor_eof < donor_start + *len - 1)\n\t\t*len = donor_eof - donor_start;\n\tif (!*len) {\n\t\text4_debug(\"ext4 move extent: len should not be 0 \"\n\t\t\t\"[ino:orig %lu, donor %lu]\\n\", orig_inode->i_ino,\n\t\t\tdonor_inode->i_ino);\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include \"ext4_extents.h\"",
      "#include \"ext4.h\"",
      "#include \"ext4_jbd2.h\"",
      "#include <linux/slab.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ext4_debug",
          "args": [
            "\"ext4 move extent: len should not be 0 \"\n\t\t\t\"[ino:orig %lu, donor %lu]\\n\"",
            "orig_inode->i_ino",
            "donor_inode->i_ino"
          ],
          "line": 520
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_debug",
          "args": [
            "\"ext4 move extent: Can't handle over [%u] blocks \"\n\t\t\t\"[ino:orig %lu, donor %lu]\\n\"",
            "EXT_MAX_BLOCKS",
            "orig_inode->i_ino",
            "donor_inode->i_ino"
          ],
          "line": 510
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_debug",
          "args": [
            "\"ext4 move extent: orig and donor's start \"\n\t\t\t\"offset are not alligned [ino:orig %lu, donor %lu]\\n\"",
            "orig_inode->i_ino",
            "donor_inode->i_ino"
          ],
          "line": 499
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_debug",
          "args": [
            "\"ext4 move extent: File size is 0 byte\\n\""
          ],
          "line": 492
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_debug",
          "args": [
            "\"ext4 move extent: donor file is not extents \"\n\t\t\t\"based file [ino:donor %lu]\\n\"",
            "donor_inode->i_ino"
          ],
          "line": 486
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_test_inode_flag",
          "args": [
            "donor_inode",
            "EXT4_INODE_EXTENTS"
          ],
          "line": 485
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_debug",
          "args": [
            "\"ext4 move extent: orig file is not extents \"\n\t\t\t\"based file [ino:orig %lu]\\n\"",
            "orig_inode->i_ino"
          ],
          "line": 482
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_test_inode_flag",
          "args": [
            "orig_inode",
            "EXT4_INODE_EXTENTS"
          ],
          "line": 481
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_debug",
          "args": [
            "\"ext4 move extent: The argument files should \"\n\t\t\t\"not be swapfile [ino:orig %lu, donor %lu]\\n\"",
            "orig_inode->i_ino",
            "donor_inode->i_ino"
          ],
          "line": 474
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_SWAPFILE",
          "args": [
            "donor_inode"
          ],
          "line": 473
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_SWAPFILE",
          "args": [
            "orig_inode"
          ],
          "line": 473
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_APPEND",
          "args": [
            "donor_inode"
          ],
          "line": 469
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_IMMUTABLE",
          "args": [
            "donor_inode"
          ],
          "line": 469
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_debug",
          "args": [
            "\"ext4 move extent: suid or sgid is set\"\n\t\t\t   \" to donor file [ino:orig %lu, donor %lu]\\n\"",
            "orig_inode->i_ino",
            "donor_inode->i_ino"
          ],
          "line": 463
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "i_size_read",
          "args": [
            "donor_inode"
          ],
          "line": 459
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "i_size_read",
          "args": [
            "orig_inode"
          ],
          "line": 458
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ext4_extents.h\"\n#include \"ext4.h\"\n#include \"ext4_jbd2.h\"\n#include <linux/slab.h>\n#include <linux/quotaops.h>\n#include <linux/fs.h>\n\nstatic int\nmext_check_arguments(struct inode *orig_inode,\n\t\t     struct inode *donor_inode, __u64 orig_start,\n\t\t     __u64 donor_start, __u64 *len)\n{\n\t__u64 orig_eof, donor_eof;\n\tunsigned int blkbits = orig_inode->i_blkbits;\n\tunsigned int blocksize = 1 << blkbits;\n\n\torig_eof = (i_size_read(orig_inode) + blocksize - 1) >> blkbits;\n\tdonor_eof = (i_size_read(donor_inode) + blocksize - 1) >> blkbits;\n\n\n\tif (donor_inode->i_mode & (S_ISUID|S_ISGID)) {\n\t\text4_debug(\"ext4 move extent: suid or sgid is set\"\n\t\t\t   \" to donor file [ino:orig %lu, donor %lu]\\n\",\n\t\t\t   orig_inode->i_ino, donor_inode->i_ino);\n\t\treturn -EINVAL;\n\t}\n\n\tif (IS_IMMUTABLE(donor_inode) || IS_APPEND(donor_inode))\n\t\treturn -EPERM;\n\n\t/* Ext4 move extent does not support swapfile */\n\tif (IS_SWAPFILE(orig_inode) || IS_SWAPFILE(donor_inode)) {\n\t\text4_debug(\"ext4 move extent: The argument files should \"\n\t\t\t\"not be swapfile [ino:orig %lu, donor %lu]\\n\",\n\t\t\torig_inode->i_ino, donor_inode->i_ino);\n\t\treturn -EBUSY;\n\t}\n\n\t/* Ext4 move extent supports only extent based file */\n\tif (!(ext4_test_inode_flag(orig_inode, EXT4_INODE_EXTENTS))) {\n\t\text4_debug(\"ext4 move extent: orig file is not extents \"\n\t\t\t\"based file [ino:orig %lu]\\n\", orig_inode->i_ino);\n\t\treturn -EOPNOTSUPP;\n\t} else if (!(ext4_test_inode_flag(donor_inode, EXT4_INODE_EXTENTS))) {\n\t\text4_debug(\"ext4 move extent: donor file is not extents \"\n\t\t\t\"based file [ino:donor %lu]\\n\", donor_inode->i_ino);\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\tif ((!orig_inode->i_size) || (!donor_inode->i_size)) {\n\t\text4_debug(\"ext4 move extent: File size is 0 byte\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\t/* Start offset should be same */\n\tif ((orig_start & ~(PAGE_MASK >> orig_inode->i_blkbits)) !=\n\t    (donor_start & ~(PAGE_MASK >> orig_inode->i_blkbits))) {\n\t\text4_debug(\"ext4 move extent: orig and donor's start \"\n\t\t\t\"offset are not alligned [ino:orig %lu, donor %lu]\\n\",\n\t\t\torig_inode->i_ino, donor_inode->i_ino);\n\t\treturn -EINVAL;\n\t}\n\n\tif ((orig_start >= EXT_MAX_BLOCKS) ||\n\t    (donor_start >= EXT_MAX_BLOCKS) ||\n\t    (*len > EXT_MAX_BLOCKS) ||\n\t    (donor_start + *len >= EXT_MAX_BLOCKS) ||\n\t    (orig_start + *len >= EXT_MAX_BLOCKS))  {\n\t\text4_debug(\"ext4 move extent: Can't handle over [%u] blocks \"\n\t\t\t\"[ino:orig %lu, donor %lu]\\n\", EXT_MAX_BLOCKS,\n\t\t\torig_inode->i_ino, donor_inode->i_ino);\n\t\treturn -EINVAL;\n\t}\n\tif (orig_eof < orig_start + *len - 1)\n\t\t*len = orig_eof - orig_start;\n\tif (donor_eof < donor_start + *len - 1)\n\t\t*len = donor_eof - donor_start;\n\tif (!*len) {\n\t\text4_debug(\"ext4 move extent: len should not be 0 \"\n\t\t\t\"[ino:orig %lu, donor %lu]\\n\", orig_inode->i_ino,\n\t\t\tdonor_inode->i_ino);\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "move_extent_per_page",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/move_extent.c",
    "lines": "259-434",
    "snippet": "static int\nmove_extent_per_page(struct file *o_filp, struct inode *donor_inode,\n\t\t     pgoff_t orig_page_offset, pgoff_t donor_page_offset,\n\t\t     int data_offset_in_page,\n\t\t     int block_len_in_page, int unwritten, int *err)\n{\n\tstruct inode *orig_inode = file_inode(o_filp);\n\tstruct page *pagep[2] = {NULL, NULL};\n\thandle_t *handle;\n\text4_lblk_t orig_blk_offset, donor_blk_offset;\n\tunsigned long blocksize = orig_inode->i_sb->s_blocksize;\n\tunsigned int tmp_data_size, data_size, replaced_size;\n\tint err2, jblocks, retries = 0;\n\tint replaced_count = 0;\n\tint from = data_offset_in_page << orig_inode->i_blkbits;\n\tint blocks_per_page = PAGE_CACHE_SIZE >> orig_inode->i_blkbits;\n\tstruct super_block *sb = orig_inode->i_sb;\n\n\t/*\n\t * It needs twice the amount of ordinary journal buffers because\n\t * inode and donor_inode may change each different metadata blocks.\n\t */\nagain:\n\t*err = 0;\n\tjblocks = ext4_writepage_trans_blocks(orig_inode) * 2;\n\thandle = ext4_journal_start(orig_inode, EXT4_HT_MOVE_EXTENTS, jblocks);\n\tif (IS_ERR(handle)) {\n\t\t*err = PTR_ERR(handle);\n\t\treturn 0;\n\t}\n\n\torig_blk_offset = orig_page_offset * blocks_per_page +\n\t\tdata_offset_in_page;\n\n\tdonor_blk_offset = donor_page_offset * blocks_per_page +\n\t\tdata_offset_in_page;\n\n\t/* Calculate data_size */\n\tif ((orig_blk_offset + block_len_in_page - 1) ==\n\t    ((orig_inode->i_size - 1) >> orig_inode->i_blkbits)) {\n\t\t/* Replace the last block */\n\t\ttmp_data_size = orig_inode->i_size & (blocksize - 1);\n\t\t/*\n\t\t * If data_size equal zero, it shows data_size is multiples of\n\t\t * blocksize. So we set appropriate value.\n\t\t */\n\t\tif (tmp_data_size == 0)\n\t\t\ttmp_data_size = blocksize;\n\n\t\tdata_size = tmp_data_size +\n\t\t\t((block_len_in_page - 1) << orig_inode->i_blkbits);\n\t} else\n\t\tdata_size = block_len_in_page << orig_inode->i_blkbits;\n\n\treplaced_size = data_size;\n\n\t*err = mext_page_double_lock(orig_inode, donor_inode, orig_page_offset,\n\t\t\t\t     donor_page_offset, pagep);\n\tif (unlikely(*err < 0))\n\t\tgoto stop_journal;\n\t/*\n\t * If orig extent was unwritten it can become initialized\n\t * at any time after i_data_sem was dropped, in order to\n\t * serialize with delalloc we have recheck extent while we\n\t * hold page's lock, if it is still the case data copy is not\n\t * necessary, just swap data blocks between orig and donor.\n\t */\n\tif (unwritten) {\n\t\text4_double_down_write_data_sem(orig_inode, donor_inode);\n\t\t/* If any of extents in range became initialized we have to\n\t\t * fallback to data copying */\n\t\tunwritten = mext_check_coverage(orig_inode, orig_blk_offset,\n\t\t\t\t\t\tblock_len_in_page, 1, err);\n\t\tif (*err)\n\t\t\tgoto drop_data_sem;\n\n\t\tunwritten &= mext_check_coverage(donor_inode, donor_blk_offset,\n\t\t\t\t\t\t block_len_in_page, 1, err);\n\t\tif (*err)\n\t\t\tgoto drop_data_sem;\n\n\t\tif (!unwritten) {\n\t\t\text4_double_up_write_data_sem(orig_inode, donor_inode);\n\t\t\tgoto data_copy;\n\t\t}\n\t\tif ((page_has_private(pagep[0]) &&\n\t\t     !try_to_release_page(pagep[0], 0)) ||\n\t\t    (page_has_private(pagep[1]) &&\n\t\t     !try_to_release_page(pagep[1], 0))) {\n\t\t\t*err = -EBUSY;\n\t\t\tgoto drop_data_sem;\n\t\t}\n\t\treplaced_count = ext4_swap_extents(handle, orig_inode,\n\t\t\t\t\t\t   donor_inode, orig_blk_offset,\n\t\t\t\t\t\t   donor_blk_offset,\n\t\t\t\t\t\t   block_len_in_page, 1, err);\n\tdrop_data_sem:\n\t\text4_double_up_write_data_sem(orig_inode, donor_inode);\n\t\tgoto unlock_pages;\n\t}\ndata_copy:\n\t*err = mext_page_mkuptodate(pagep[0], from, from + replaced_size);\n\tif (*err)\n\t\tgoto unlock_pages;\n\n\t/* At this point all buffers in range are uptodate, old mapping layout\n\t * is no longer required, try to drop it now. */\n\tif ((page_has_private(pagep[0]) && !try_to_release_page(pagep[0], 0)) ||\n\t    (page_has_private(pagep[1]) && !try_to_release_page(pagep[1], 0))) {\n\t\t*err = -EBUSY;\n\t\tgoto unlock_pages;\n\t}\n\text4_double_down_write_data_sem(orig_inode, donor_inode);\n\treplaced_count = ext4_swap_extents(handle, orig_inode, donor_inode,\n\t\t\t\t\t       orig_blk_offset, donor_blk_offset,\n\t\t\t\t\t   block_len_in_page, 1, err);\n\text4_double_up_write_data_sem(orig_inode, donor_inode);\n\tif (*err) {\n\t\tif (replaced_count) {\n\t\t\tblock_len_in_page = replaced_count;\n\t\t\treplaced_size =\n\t\t\t\tblock_len_in_page << orig_inode->i_blkbits;\n\t\t} else\n\t\t\tgoto unlock_pages;\n\t}\n\t/* Perform all necessary steps similar write_begin()/write_end()\n\t * but keeping in mind that i_size will not change */\n\t*err = __block_write_begin(pagep[0], from, replaced_size,\n\t\t\t\t   ext4_get_block);\n\tif (!*err)\n\t\t*err = block_commit_write(pagep[0], from, from + replaced_size);\n\n\tif (unlikely(*err < 0))\n\t\tgoto repair_branches;\n\n\t/* Even in case of data=writeback it is reasonable to pin\n\t * inode to transaction, to prevent unexpected data loss */\n\t*err = ext4_jbd2_file_inode(handle, orig_inode);\n\nunlock_pages:\n\tunlock_page(pagep[0]);\n\tpage_cache_release(pagep[0]);\n\tunlock_page(pagep[1]);\n\tpage_cache_release(pagep[1]);\nstop_journal:\n\text4_journal_stop(handle);\n\tif (*err == -ENOSPC &&\n\t    ext4_should_retry_alloc(sb, &retries))\n\t\tgoto again;\n\t/* Buffer was busy because probably is pinned to journal transaction,\n\t * force transaction commit may help to free it. */\n\tif (*err == -EBUSY && retries++ < 4 && EXT4_SB(sb)->s_journal &&\n\t    jbd2_journal_force_commit_nested(EXT4_SB(sb)->s_journal))\n\t\tgoto again;\n\treturn replaced_count;\n\nrepair_branches:\n\t/*\n\t * This should never ever happen!\n\t * Extents are swapped already, but we are not able to copy data.\n\t * Try to swap extents to it's original places\n\t */\n\text4_double_down_write_data_sem(orig_inode, donor_inode);\n\treplaced_count = ext4_swap_extents(handle, donor_inode, orig_inode,\n\t\t\t\t\t       orig_blk_offset, donor_blk_offset,\n\t\t\t\t\t   block_len_in_page, 0, &err2);\n\text4_double_up_write_data_sem(orig_inode, donor_inode);\n\tif (replaced_count != block_len_in_page) {\n\t\tEXT4_ERROR_INODE_BLOCK(orig_inode, (sector_t)(orig_blk_offset),\n\t\t\t\t       \"Unable to copy data block,\"\n\t\t\t\t       \" data will be lost.\");\n\t\t*err = -EIO;\n\t}\n\treplaced_count = 0;\n\tgoto unlock_pages;\n}",
    "includes": [
      "#include \"ext4_extents.h\"",
      "#include \"ext4.h\"",
      "#include \"ext4_jbd2.h\"",
      "#include <linux/slab.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "EXT4_ERROR_INODE_BLOCK",
          "args": [
            "orig_inode",
            "(sector_t)(orig_blk_offset)",
            "\"Unable to copy data block,\"\n\t\t\t\t       \" data will be lost.\""
          ],
          "line": 427
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "orig_blk_offset"
          ],
          "line": 427
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_double_up_write_data_sem",
          "args": [
            "orig_inode",
            "donor_inode"
          ],
          "line": 425
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_double_up_write_data_sem",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/move_extent.c",
          "lines": "78-84",
          "snippet": "void\next4_double_up_write_data_sem(struct inode *orig_inode,\n\t\t\t      struct inode *donor_inode)\n{\n\tup_write(&EXT4_I(orig_inode)->i_data_sem);\n\tup_write(&EXT4_I(donor_inode)->i_data_sem);\n}",
          "includes": [
            "#include \"ext4_extents.h\"",
            "#include \"ext4.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include <linux/slab.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ext4_extents.h\"\n#include \"ext4.h\"\n#include \"ext4_jbd2.h\"\n#include <linux/slab.h>\n#include <linux/quotaops.h>\n#include <linux/fs.h>\n\nvoid\next4_double_up_write_data_sem(struct inode *orig_inode,\n\t\t\t      struct inode *donor_inode)\n{\n\tup_write(&EXT4_I(orig_inode)->i_data_sem);\n\tup_write(&EXT4_I(donor_inode)->i_data_sem);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_swap_extents",
          "args": [
            "handle",
            "donor_inode",
            "orig_inode",
            "orig_blk_offset",
            "donor_blk_offset",
            "block_len_in_page",
            "0",
            "&err2"
          ],
          "line": 422
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_swap_extents",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/extents.c",
          "lines": "5531-5705",
          "snippet": "int\next4_swap_extents(handle_t *handle, struct inode *inode1,\n\t\t     struct inode *inode2, ext4_lblk_t lblk1, ext4_lblk_t lblk2,\n\t\t  ext4_lblk_t count, int unwritten, int *erp)\n{\n\tstruct ext4_ext_path *path1 = NULL;\n\tstruct ext4_ext_path *path2 = NULL;\n\tint replaced_count = 0;\n\n\tBUG_ON(!rwsem_is_locked(&EXT4_I(inode1)->i_data_sem));\n\tBUG_ON(!rwsem_is_locked(&EXT4_I(inode2)->i_data_sem));\n\tBUG_ON(!mutex_is_locked(&inode1->i_mutex));\n\tBUG_ON(!mutex_is_locked(&inode1->i_mutex));\n\n\t*erp = ext4_es_remove_extent(inode1, lblk1, count);\n\tif (unlikely(*erp))\n\t\treturn 0;\n\t*erp = ext4_es_remove_extent(inode2, lblk2, count);\n\tif (unlikely(*erp))\n\t\treturn 0;\n\n\twhile (count) {\n\t\tstruct ext4_extent *ex1, *ex2, tmp_ex;\n\t\text4_lblk_t e1_blk, e2_blk;\n\t\tint e1_len, e2_len, len;\n\t\tint split = 0;\n\n\t\tpath1 = ext4_find_extent(inode1, lblk1, NULL, EXT4_EX_NOCACHE);\n\t\tif (unlikely(IS_ERR(path1))) {\n\t\t\t*erp = PTR_ERR(path1);\n\t\t\tpath1 = NULL;\n\t\tfinish:\n\t\t\tcount = 0;\n\t\t\tgoto repeat;\n\t\t}\n\t\tpath2 = ext4_find_extent(inode2, lblk2, NULL, EXT4_EX_NOCACHE);\n\t\tif (unlikely(IS_ERR(path2))) {\n\t\t\t*erp = PTR_ERR(path2);\n\t\t\tpath2 = NULL;\n\t\t\tgoto finish;\n\t\t}\n\t\tex1 = path1[path1->p_depth].p_ext;\n\t\tex2 = path2[path2->p_depth].p_ext;\n\t\t/* Do we have somthing to swap ? */\n\t\tif (unlikely(!ex2 || !ex1))\n\t\t\tgoto finish;\n\n\t\te1_blk = le32_to_cpu(ex1->ee_block);\n\t\te2_blk = le32_to_cpu(ex2->ee_block);\n\t\te1_len = ext4_ext_get_actual_len(ex1);\n\t\te2_len = ext4_ext_get_actual_len(ex2);\n\n\t\t/* Hole handling */\n\t\tif (!in_range(lblk1, e1_blk, e1_len) ||\n\t\t    !in_range(lblk2, e2_blk, e2_len)) {\n\t\t\text4_lblk_t next1, next2;\n\n\t\t\t/* if hole after extent, then go to next extent */\n\t\t\tnext1 = ext4_ext_next_allocated_block(path1);\n\t\t\tnext2 = ext4_ext_next_allocated_block(path2);\n\t\t\t/* If hole before extent, then shift to that extent */\n\t\t\tif (e1_blk > lblk1)\n\t\t\t\tnext1 = e1_blk;\n\t\t\tif (e2_blk > lblk2)\n\t\t\t\tnext2 = e1_blk;\n\t\t\t/* Do we have something to swap */\n\t\t\tif (next1 == EXT_MAX_BLOCKS || next2 == EXT_MAX_BLOCKS)\n\t\t\t\tgoto finish;\n\t\t\t/* Move to the rightest boundary */\n\t\t\tlen = next1 - lblk1;\n\t\t\tif (len < next2 - lblk2)\n\t\t\t\tlen = next2 - lblk2;\n\t\t\tif (len > count)\n\t\t\t\tlen = count;\n\t\t\tlblk1 += len;\n\t\t\tlblk2 += len;\n\t\t\tcount -= len;\n\t\t\tgoto repeat;\n\t\t}\n\n\t\t/* Prepare left boundary */\n\t\tif (e1_blk < lblk1) {\n\t\t\tsplit = 1;\n\t\t\t*erp = ext4_force_split_extent_at(handle, inode1,\n\t\t\t\t\t\t&path1, lblk1, 0);\n\t\t\tif (unlikely(*erp))\n\t\t\t\tgoto finish;\n\t\t}\n\t\tif (e2_blk < lblk2) {\n\t\t\tsplit = 1;\n\t\t\t*erp = ext4_force_split_extent_at(handle, inode2,\n\t\t\t\t\t\t&path2,  lblk2, 0);\n\t\t\tif (unlikely(*erp))\n\t\t\t\tgoto finish;\n\t\t}\n\t\t/* ext4_split_extent_at() may result in leaf extent split,\n\t\t * path must to be revalidated. */\n\t\tif (split)\n\t\t\tgoto repeat;\n\n\t\t/* Prepare right boundary */\n\t\tlen = count;\n\t\tif (len > e1_blk + e1_len - lblk1)\n\t\t\tlen = e1_blk + e1_len - lblk1;\n\t\tif (len > e2_blk + e2_len - lblk2)\n\t\t\tlen = e2_blk + e2_len - lblk2;\n\n\t\tif (len != e1_len) {\n\t\t\tsplit = 1;\n\t\t\t*erp = ext4_force_split_extent_at(handle, inode1,\n\t\t\t\t\t\t&path1, lblk1 + len, 0);\n\t\t\tif (unlikely(*erp))\n\t\t\t\tgoto finish;\n\t\t}\n\t\tif (len != e2_len) {\n\t\t\tsplit = 1;\n\t\t\t*erp = ext4_force_split_extent_at(handle, inode2,\n\t\t\t\t\t\t&path2, lblk2 + len, 0);\n\t\t\tif (*erp)\n\t\t\t\tgoto finish;\n\t\t}\n\t\t/* ext4_split_extent_at() may result in leaf extent split,\n\t\t * path must to be revalidated. */\n\t\tif (split)\n\t\t\tgoto repeat;\n\n\t\tBUG_ON(e2_len != e1_len);\n\t\t*erp = ext4_ext_get_access(handle, inode1, path1 + path1->p_depth);\n\t\tif (unlikely(*erp))\n\t\t\tgoto finish;\n\t\t*erp = ext4_ext_get_access(handle, inode2, path2 + path2->p_depth);\n\t\tif (unlikely(*erp))\n\t\t\tgoto finish;\n\n\t\t/* Both extents are fully inside boundaries. Swap it now */\n\t\ttmp_ex = *ex1;\n\t\text4_ext_store_pblock(ex1, ext4_ext_pblock(ex2));\n\t\text4_ext_store_pblock(ex2, ext4_ext_pblock(&tmp_ex));\n\t\tex1->ee_len = cpu_to_le16(e2_len);\n\t\tex2->ee_len = cpu_to_le16(e1_len);\n\t\tif (unwritten)\n\t\t\text4_ext_mark_unwritten(ex2);\n\t\tif (ext4_ext_is_unwritten(&tmp_ex))\n\t\t\text4_ext_mark_unwritten(ex1);\n\n\t\text4_ext_try_to_merge(handle, inode2, path2, ex2);\n\t\text4_ext_try_to_merge(handle, inode1, path1, ex1);\n\t\t*erp = ext4_ext_dirty(handle, inode2, path2 +\n\t\t\t\t      path2->p_depth);\n\t\tif (unlikely(*erp))\n\t\t\tgoto finish;\n\t\t*erp = ext4_ext_dirty(handle, inode1, path1 +\n\t\t\t\t      path1->p_depth);\n\t\t/*\n\t\t * Looks scarry ah..? second inode already points to new blocks,\n\t\t * and it was successfully dirtied. But luckily error may happen\n\t\t * only due to journal error, so full transaction will be\n\t\t * aborted anyway.\n\t\t */\n\t\tif (unlikely(*erp))\n\t\t\tgoto finish;\n\t\tlblk1 += len;\n\t\tlblk2 += len;\n\t\treplaced_count += len;\n\t\tcount -= len;\n\n\trepeat:\n\t\text4_ext_drop_refs(path1);\n\t\tkfree(path1);\n\t\text4_ext_drop_refs(path2);\n\t\tkfree(path2);\n\t\tpath1 = path2 = NULL;\n\t}\n\treturn replaced_count;\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"xattr.h\"",
            "#include \"ext4_extents.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include <linux/fiemap.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/string.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highuid.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/time.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"xattr.h\"\n#include \"ext4_extents.h\"\n#include \"ext4_jbd2.h\"\n#include <linux/fiemap.h>\n#include <asm/uaccess.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/highuid.h>\n#include <linux/jbd2.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n\nint\next4_swap_extents(handle_t *handle, struct inode *inode1,\n\t\t     struct inode *inode2, ext4_lblk_t lblk1, ext4_lblk_t lblk2,\n\t\t  ext4_lblk_t count, int unwritten, int *erp)\n{\n\tstruct ext4_ext_path *path1 = NULL;\n\tstruct ext4_ext_path *path2 = NULL;\n\tint replaced_count = 0;\n\n\tBUG_ON(!rwsem_is_locked(&EXT4_I(inode1)->i_data_sem));\n\tBUG_ON(!rwsem_is_locked(&EXT4_I(inode2)->i_data_sem));\n\tBUG_ON(!mutex_is_locked(&inode1->i_mutex));\n\tBUG_ON(!mutex_is_locked(&inode1->i_mutex));\n\n\t*erp = ext4_es_remove_extent(inode1, lblk1, count);\n\tif (unlikely(*erp))\n\t\treturn 0;\n\t*erp = ext4_es_remove_extent(inode2, lblk2, count);\n\tif (unlikely(*erp))\n\t\treturn 0;\n\n\twhile (count) {\n\t\tstruct ext4_extent *ex1, *ex2, tmp_ex;\n\t\text4_lblk_t e1_blk, e2_blk;\n\t\tint e1_len, e2_len, len;\n\t\tint split = 0;\n\n\t\tpath1 = ext4_find_extent(inode1, lblk1, NULL, EXT4_EX_NOCACHE);\n\t\tif (unlikely(IS_ERR(path1))) {\n\t\t\t*erp = PTR_ERR(path1);\n\t\t\tpath1 = NULL;\n\t\tfinish:\n\t\t\tcount = 0;\n\t\t\tgoto repeat;\n\t\t}\n\t\tpath2 = ext4_find_extent(inode2, lblk2, NULL, EXT4_EX_NOCACHE);\n\t\tif (unlikely(IS_ERR(path2))) {\n\t\t\t*erp = PTR_ERR(path2);\n\t\t\tpath2 = NULL;\n\t\t\tgoto finish;\n\t\t}\n\t\tex1 = path1[path1->p_depth].p_ext;\n\t\tex2 = path2[path2->p_depth].p_ext;\n\t\t/* Do we have somthing to swap ? */\n\t\tif (unlikely(!ex2 || !ex1))\n\t\t\tgoto finish;\n\n\t\te1_blk = le32_to_cpu(ex1->ee_block);\n\t\te2_blk = le32_to_cpu(ex2->ee_block);\n\t\te1_len = ext4_ext_get_actual_len(ex1);\n\t\te2_len = ext4_ext_get_actual_len(ex2);\n\n\t\t/* Hole handling */\n\t\tif (!in_range(lblk1, e1_blk, e1_len) ||\n\t\t    !in_range(lblk2, e2_blk, e2_len)) {\n\t\t\text4_lblk_t next1, next2;\n\n\t\t\t/* if hole after extent, then go to next extent */\n\t\t\tnext1 = ext4_ext_next_allocated_block(path1);\n\t\t\tnext2 = ext4_ext_next_allocated_block(path2);\n\t\t\t/* If hole before extent, then shift to that extent */\n\t\t\tif (e1_blk > lblk1)\n\t\t\t\tnext1 = e1_blk;\n\t\t\tif (e2_blk > lblk2)\n\t\t\t\tnext2 = e1_blk;\n\t\t\t/* Do we have something to swap */\n\t\t\tif (next1 == EXT_MAX_BLOCKS || next2 == EXT_MAX_BLOCKS)\n\t\t\t\tgoto finish;\n\t\t\t/* Move to the rightest boundary */\n\t\t\tlen = next1 - lblk1;\n\t\t\tif (len < next2 - lblk2)\n\t\t\t\tlen = next2 - lblk2;\n\t\t\tif (len > count)\n\t\t\t\tlen = count;\n\t\t\tlblk1 += len;\n\t\t\tlblk2 += len;\n\t\t\tcount -= len;\n\t\t\tgoto repeat;\n\t\t}\n\n\t\t/* Prepare left boundary */\n\t\tif (e1_blk < lblk1) {\n\t\t\tsplit = 1;\n\t\t\t*erp = ext4_force_split_extent_at(handle, inode1,\n\t\t\t\t\t\t&path1, lblk1, 0);\n\t\t\tif (unlikely(*erp))\n\t\t\t\tgoto finish;\n\t\t}\n\t\tif (e2_blk < lblk2) {\n\t\t\tsplit = 1;\n\t\t\t*erp = ext4_force_split_extent_at(handle, inode2,\n\t\t\t\t\t\t&path2,  lblk2, 0);\n\t\t\tif (unlikely(*erp))\n\t\t\t\tgoto finish;\n\t\t}\n\t\t/* ext4_split_extent_at() may result in leaf extent split,\n\t\t * path must to be revalidated. */\n\t\tif (split)\n\t\t\tgoto repeat;\n\n\t\t/* Prepare right boundary */\n\t\tlen = count;\n\t\tif (len > e1_blk + e1_len - lblk1)\n\t\t\tlen = e1_blk + e1_len - lblk1;\n\t\tif (len > e2_blk + e2_len - lblk2)\n\t\t\tlen = e2_blk + e2_len - lblk2;\n\n\t\tif (len != e1_len) {\n\t\t\tsplit = 1;\n\t\t\t*erp = ext4_force_split_extent_at(handle, inode1,\n\t\t\t\t\t\t&path1, lblk1 + len, 0);\n\t\t\tif (unlikely(*erp))\n\t\t\t\tgoto finish;\n\t\t}\n\t\tif (len != e2_len) {\n\t\t\tsplit = 1;\n\t\t\t*erp = ext4_force_split_extent_at(handle, inode2,\n\t\t\t\t\t\t&path2, lblk2 + len, 0);\n\t\t\tif (*erp)\n\t\t\t\tgoto finish;\n\t\t}\n\t\t/* ext4_split_extent_at() may result in leaf extent split,\n\t\t * path must to be revalidated. */\n\t\tif (split)\n\t\t\tgoto repeat;\n\n\t\tBUG_ON(e2_len != e1_len);\n\t\t*erp = ext4_ext_get_access(handle, inode1, path1 + path1->p_depth);\n\t\tif (unlikely(*erp))\n\t\t\tgoto finish;\n\t\t*erp = ext4_ext_get_access(handle, inode2, path2 + path2->p_depth);\n\t\tif (unlikely(*erp))\n\t\t\tgoto finish;\n\n\t\t/* Both extents are fully inside boundaries. Swap it now */\n\t\ttmp_ex = *ex1;\n\t\text4_ext_store_pblock(ex1, ext4_ext_pblock(ex2));\n\t\text4_ext_store_pblock(ex2, ext4_ext_pblock(&tmp_ex));\n\t\tex1->ee_len = cpu_to_le16(e2_len);\n\t\tex2->ee_len = cpu_to_le16(e1_len);\n\t\tif (unwritten)\n\t\t\text4_ext_mark_unwritten(ex2);\n\t\tif (ext4_ext_is_unwritten(&tmp_ex))\n\t\t\text4_ext_mark_unwritten(ex1);\n\n\t\text4_ext_try_to_merge(handle, inode2, path2, ex2);\n\t\text4_ext_try_to_merge(handle, inode1, path1, ex1);\n\t\t*erp = ext4_ext_dirty(handle, inode2, path2 +\n\t\t\t\t      path2->p_depth);\n\t\tif (unlikely(*erp))\n\t\t\tgoto finish;\n\t\t*erp = ext4_ext_dirty(handle, inode1, path1 +\n\t\t\t\t      path1->p_depth);\n\t\t/*\n\t\t * Looks scarry ah..? second inode already points to new blocks,\n\t\t * and it was successfully dirtied. But luckily error may happen\n\t\t * only due to journal error, so full transaction will be\n\t\t * aborted anyway.\n\t\t */\n\t\tif (unlikely(*erp))\n\t\t\tgoto finish;\n\t\tlblk1 += len;\n\t\tlblk2 += len;\n\t\treplaced_count += len;\n\t\tcount -= len;\n\n\trepeat:\n\t\text4_ext_drop_refs(path1);\n\t\tkfree(path1);\n\t\text4_ext_drop_refs(path2);\n\t\tkfree(path2);\n\t\tpath1 = path2 = NULL;\n\t}\n\treturn replaced_count;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_double_down_write_data_sem",
          "args": [
            "orig_inode",
            "donor_inode"
          ],
          "line": 421
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_double_down_write_data_sem",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/move_extent.c",
          "lines": "58-69",
          "snippet": "void\next4_double_down_write_data_sem(struct inode *first, struct inode *second)\n{\n\tif (first < second) {\n\t\tdown_write(&EXT4_I(first)->i_data_sem);\n\t\tdown_write_nested(&EXT4_I(second)->i_data_sem, SINGLE_DEPTH_NESTING);\n\t} else {\n\t\tdown_write(&EXT4_I(second)->i_data_sem);\n\t\tdown_write_nested(&EXT4_I(first)->i_data_sem, SINGLE_DEPTH_NESTING);\n\n\t}\n}",
          "includes": [
            "#include \"ext4_extents.h\"",
            "#include \"ext4.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include <linux/slab.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ext4_extents.h\"\n#include \"ext4.h\"\n#include \"ext4_jbd2.h\"\n#include <linux/slab.h>\n#include <linux/quotaops.h>\n#include <linux/fs.h>\n\nvoid\next4_double_down_write_data_sem(struct inode *first, struct inode *second)\n{\n\tif (first < second) {\n\t\tdown_write(&EXT4_I(first)->i_data_sem);\n\t\tdown_write_nested(&EXT4_I(second)->i_data_sem, SINGLE_DEPTH_NESTING);\n\t} else {\n\t\tdown_write(&EXT4_I(second)->i_data_sem);\n\t\tdown_write_nested(&EXT4_I(first)->i_data_sem, SINGLE_DEPTH_NESTING);\n\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "jbd2_journal_force_commit_nested",
          "args": [
            "EXT4_SB(sb)->s_journal"
          ],
          "line": 411
        },
        "resolved": true,
        "details": {
          "function_name": "jbd2_journal_force_commit_nested",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd2/journal.c",
          "lines": "595-601",
          "snippet": "int jbd2_journal_force_commit_nested(journal_t *journal)\n{\n\tint ret;\n\n\tret = __jbd2_journal_force_commit(journal);\n\treturn ret > 0;\n}",
          "includes": [
            "#include <asm/page.h>",
            "#include <asm/uaccess.h>",
            "#include <trace/events/jbd2.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/bitops.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/log2.h>",
            "#include <linux/hash.h>",
            "#include <linux/math64.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/poison.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <trace/events/jbd2.h>\n#include <linux/ratelimit.h>\n#include <linux/bitops.h>\n#include <linux/backing-dev.h>\n#include <linux/vmalloc.h>\n#include <linux/log2.h>\n#include <linux/hash.h>\n#include <linux/math64.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/poison.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/freezer.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd2.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/module.h>\n\nint jbd2_journal_force_commit_nested(journal_t *journal)\n{\n\tint ret;\n\n\tret = __jbd2_journal_force_commit(journal);\n\treturn ret > 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "EXT4_SB",
          "args": [
            "sb"
          ],
          "line": 411
        },
        "resolved": true,
        "details": {
          "function_name": "EXT4_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ext4.h",
          "lines": "1356-1359",
          "snippet": "static inline struct ext4_sb_info *EXT4_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include \"extents_status.h\"",
            "#include <linux/compat.h>",
            "#include <linux/falloc.h>",
            "#include <crypto/hash.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/wait.h>",
            "#include <linux/timer.h>",
            "#include <linux/mutex.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/quota.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extents_status.h\"\n#include <linux/compat.h>\n#include <linux/falloc.h>\n#include <crypto/hash.h>\n#include <linux/ratelimit.h>\n#include <linux/percpu_counter.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/wait.h>\n#include <linux/timer.h>\n#include <linux/mutex.h>\n#include <linux/seqlock.h>\n#include <linux/rbtree.h>\n#include <linux/rwsem.h>\n#include <linux/quota.h>\n#include <linux/jbd2.h>\n#include <linux/magic.h>\n#include <linux/blkdev.h>\n#include <linux/types.h>\n\nstatic inline struct ext4_sb_info *EXT4_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_should_retry_alloc",
          "args": [
            "sb",
            "&retries"
          ],
          "line": 406
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_should_retry_alloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/balloc.c",
          "lines": "598-608",
          "snippet": "int ext4_should_retry_alloc(struct super_block *sb, int *retries)\n{\n\tif (!ext4_has_free_clusters(EXT4_SB(sb), 1, 0) ||\n\t    (*retries)++ > 3 ||\n\t    !EXT4_SB(sb)->s_journal)\n\t\treturn 0;\n\n\tjbd_debug(1, \"%s: retrying operation after ENOSPC\\n\", sb->s_id);\n\n\treturn jbd2_journal_force_commit_nested(EXT4_SB(sb)->s_journal);\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"mballoc.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include \"ext4.h\"",
            "#include <linux/buffer_head.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/fs.h>",
            "#include <linux/capability.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"mballoc.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4.h\"\n#include <linux/buffer_head.h>\n#include <linux/quotaops.h>\n#include <linux/jbd2.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n#include <linux/time.h>\n\nint ext4_should_retry_alloc(struct super_block *sb, int *retries)\n{\n\tif (!ext4_has_free_clusters(EXT4_SB(sb), 1, 0) ||\n\t    (*retries)++ > 3 ||\n\t    !EXT4_SB(sb)->s_journal)\n\t\treturn 0;\n\n\tjbd_debug(1, \"%s: retrying operation after ENOSPC\\n\", sb->s_id);\n\n\treturn jbd2_journal_force_commit_nested(EXT4_SB(sb)->s_journal);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_journal_stop",
          "args": [
            "handle"
          ],
          "line": 404
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_cache_release",
          "args": [
            "pagep[1]"
          ],
          "line": 402
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlock_page",
          "args": [
            "pagep[1]"
          ],
          "line": 401
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_unlock_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/aops.c",
          "lines": "1127-1148",
          "snippet": "static void ocfs2_unlock_pages(struct ocfs2_write_ctxt *wc)\n{\n\tint i;\n\n\t/*\n\t * w_target_locked is only set to true in the page_mkwrite() case.\n\t * The intent is to allow us to lock the target page from write_begin()\n\t * to write_end(). The caller must hold a ref on w_target_page.\n\t */\n\tif (wc->w_target_locked) {\n\t\tBUG_ON(!wc->w_target_page);\n\t\tfor (i = 0; i < wc->w_num_pages; i++) {\n\t\t\tif (wc->w_target_page == wc->w_pages[i]) {\n\t\t\t\twc->w_pages[i] = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tmark_page_accessed(wc->w_target_page);\n\t\tpage_cache_release(wc->w_target_page);\n\t}\n\tocfs2_unlock_and_free_pages(wc->w_pages, wc->w_num_pages);\n}",
          "includes": [
            "#include \"sysfile.h\"",
            "#include \"namei.h\"",
            "#include \"dir.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"symlink.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/mpage.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/swap.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sysfile.h\"\n#include \"namei.h\"\n#include \"dir.h\"\n#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"symlink.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/mpage.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/swap.h>\n#include <asm/byteorder.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic void ocfs2_unlock_pages(struct ocfs2_write_ctxt *wc)\n{\n\tint i;\n\n\t/*\n\t * w_target_locked is only set to true in the page_mkwrite() case.\n\t * The intent is to allow us to lock the target page from write_begin()\n\t * to write_end(). The caller must hold a ref on w_target_page.\n\t */\n\tif (wc->w_target_locked) {\n\t\tBUG_ON(!wc->w_target_page);\n\t\tfor (i = 0; i < wc->w_num_pages; i++) {\n\t\t\tif (wc->w_target_page == wc->w_pages[i]) {\n\t\t\t\twc->w_pages[i] = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tmark_page_accessed(wc->w_target_page);\n\t\tpage_cache_release(wc->w_target_page);\n\t}\n\tocfs2_unlock_and_free_pages(wc->w_pages, wc->w_num_pages);\n}"
        }
      },
      {
        "call_info": {
          "callee": "page_cache_release",
          "args": [
            "pagep[0]"
          ],
          "line": 400
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_jbd2_file_inode",
          "args": [
            "handle",
            "orig_inode"
          ],
          "line": 396
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_jbd2_file_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ext4_jbd2.h",
          "lines": "364-369",
          "snippet": "static inline int ext4_jbd2_file_inode(handle_t *handle, struct inode *inode)\n{\n\tif (ext4_handle_valid(handle))\n\t\treturn jbd2_journal_file_inode(handle, EXT4_I(inode)->jinode);\n\treturn 0;\n}",
          "includes": [
            "#include \"ext4.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ext4.h\"\n#include <linux/jbd2.h>\n#include <linux/fs.h>\n\nstatic inline int ext4_jbd2_file_inode(handle_t *handle, struct inode *inode)\n{\n\tif (ext4_handle_valid(handle))\n\t\treturn jbd2_journal_file_inode(handle, EXT4_I(inode)->jinode);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "*err < 0"
          ],
          "line": 391
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "block_commit_write",
          "args": [
            "pagep[0]",
            "from",
            "from + replaced_size"
          ],
          "line": 389
        },
        "resolved": true,
        "details": {
          "function_name": "block_commit_write",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "2376-2381",
          "snippet": "int block_commit_write(struct page *page, unsigned from, unsigned to)\n{\n\tstruct inode *inode = page->mapping->host;\n\t__block_commit_write(inode,page,from,to);\n\treturn 0;\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nint block_commit_write(struct page *page, unsigned from, unsigned to)\n{\n\tstruct inode *inode = page->mapping->host;\n\t__block_commit_write(inode,page,from,to);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "__block_write_begin",
          "args": [
            "pagep[0]",
            "from",
            "replaced_size",
            "ext4_get_block"
          ],
          "line": 386
        },
        "resolved": true,
        "details": {
          "function_name": "__block_write_begin",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1882-1961",
          "snippet": "int __block_write_begin(struct page *page, loff_t pos, unsigned len,\n\t\tget_block_t *get_block)\n{\n\tunsigned from = pos & (PAGE_CACHE_SIZE - 1);\n\tunsigned to = from + len;\n\tstruct inode *inode = page->mapping->host;\n\tunsigned block_start, block_end;\n\tsector_t block;\n\tint err = 0;\n\tunsigned blocksize, bbits;\n\tstruct buffer_head *bh, *head, *wait[2], **wait_bh=wait;\n\n\tBUG_ON(!PageLocked(page));\n\tBUG_ON(from > PAGE_CACHE_SIZE);\n\tBUG_ON(to > PAGE_CACHE_SIZE);\n\tBUG_ON(from > to);\n\n\thead = create_page_buffers(page, inode, 0);\n\tblocksize = head->b_size;\n\tbbits = block_size_bits(blocksize);\n\n\tblock = (sector_t)page->index << (PAGE_CACHE_SHIFT - bbits);\n\n\tfor(bh = head, block_start = 0; bh != head || !block_start;\n\t    block++, block_start=block_end, bh = bh->b_this_page) {\n\t\tblock_end = block_start + blocksize;\n\t\tif (block_end <= from || block_start >= to) {\n\t\t\tif (PageUptodate(page)) {\n\t\t\t\tif (!buffer_uptodate(bh))\n\t\t\t\t\tset_buffer_uptodate(bh);\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\t\tif (buffer_new(bh))\n\t\t\tclear_buffer_new(bh);\n\t\tif (!buffer_mapped(bh)) {\n\t\t\tWARN_ON(bh->b_size != blocksize);\n\t\t\terr = get_block(inode, block, bh, 1);\n\t\t\tif (err)\n\t\t\t\tbreak;\n\t\t\tif (buffer_new(bh)) {\n\t\t\t\tunmap_underlying_metadata(bh->b_bdev,\n\t\t\t\t\t\t\tbh->b_blocknr);\n\t\t\t\tif (PageUptodate(page)) {\n\t\t\t\t\tclear_buffer_new(bh);\n\t\t\t\t\tset_buffer_uptodate(bh);\n\t\t\t\t\tmark_buffer_dirty(bh);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (block_end > to || block_start < from)\n\t\t\t\t\tzero_user_segments(page,\n\t\t\t\t\t\tto, block_end,\n\t\t\t\t\t\tblock_start, from);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\t\tif (PageUptodate(page)) {\n\t\t\tif (!buffer_uptodate(bh))\n\t\t\t\tset_buffer_uptodate(bh);\n\t\t\tcontinue; \n\t\t}\n\t\tif (!buffer_uptodate(bh) && !buffer_delay(bh) &&\n\t\t    !buffer_unwritten(bh) &&\n\t\t     (block_start < from || block_end > to)) {\n\t\t\tll_rw_block(READ, 1, &bh);\n\t\t\t*wait_bh++=bh;\n\t\t}\n\t}\n\t/*\n\t * If we issued read requests - let them complete.\n\t */\n\twhile(wait_bh > wait) {\n\t\twait_on_buffer(*--wait_bh);\n\t\tif (!buffer_uptodate(*wait_bh))\n\t\t\terr = -EIO;\n\t}\n\tif (unlikely(err))\n\t\tpage_zero_new_buffers(page, from, to);\n\treturn err;\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nint __block_write_begin(struct page *page, loff_t pos, unsigned len,\n\t\tget_block_t *get_block)\n{\n\tunsigned from = pos & (PAGE_CACHE_SIZE - 1);\n\tunsigned to = from + len;\n\tstruct inode *inode = page->mapping->host;\n\tunsigned block_start, block_end;\n\tsector_t block;\n\tint err = 0;\n\tunsigned blocksize, bbits;\n\tstruct buffer_head *bh, *head, *wait[2], **wait_bh=wait;\n\n\tBUG_ON(!PageLocked(page));\n\tBUG_ON(from > PAGE_CACHE_SIZE);\n\tBUG_ON(to > PAGE_CACHE_SIZE);\n\tBUG_ON(from > to);\n\n\thead = create_page_buffers(page, inode, 0);\n\tblocksize = head->b_size;\n\tbbits = block_size_bits(blocksize);\n\n\tblock = (sector_t)page->index << (PAGE_CACHE_SHIFT - bbits);\n\n\tfor(bh = head, block_start = 0; bh != head || !block_start;\n\t    block++, block_start=block_end, bh = bh->b_this_page) {\n\t\tblock_end = block_start + blocksize;\n\t\tif (block_end <= from || block_start >= to) {\n\t\t\tif (PageUptodate(page)) {\n\t\t\t\tif (!buffer_uptodate(bh))\n\t\t\t\t\tset_buffer_uptodate(bh);\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\t\tif (buffer_new(bh))\n\t\t\tclear_buffer_new(bh);\n\t\tif (!buffer_mapped(bh)) {\n\t\t\tWARN_ON(bh->b_size != blocksize);\n\t\t\terr = get_block(inode, block, bh, 1);\n\t\t\tif (err)\n\t\t\t\tbreak;\n\t\t\tif (buffer_new(bh)) {\n\t\t\t\tunmap_underlying_metadata(bh->b_bdev,\n\t\t\t\t\t\t\tbh->b_blocknr);\n\t\t\t\tif (PageUptodate(page)) {\n\t\t\t\t\tclear_buffer_new(bh);\n\t\t\t\t\tset_buffer_uptodate(bh);\n\t\t\t\t\tmark_buffer_dirty(bh);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (block_end > to || block_start < from)\n\t\t\t\t\tzero_user_segments(page,\n\t\t\t\t\t\tto, block_end,\n\t\t\t\t\t\tblock_start, from);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\t\tif (PageUptodate(page)) {\n\t\t\tif (!buffer_uptodate(bh))\n\t\t\t\tset_buffer_uptodate(bh);\n\t\t\tcontinue; \n\t\t}\n\t\tif (!buffer_uptodate(bh) && !buffer_delay(bh) &&\n\t\t    !buffer_unwritten(bh) &&\n\t\t     (block_start < from || block_end > to)) {\n\t\t\tll_rw_block(READ, 1, &bh);\n\t\t\t*wait_bh++=bh;\n\t\t}\n\t}\n\t/*\n\t * If we issued read requests - let them complete.\n\t */\n\twhile(wait_bh > wait) {\n\t\twait_on_buffer(*--wait_bh);\n\t\tif (!buffer_uptodate(*wait_bh))\n\t\t\terr = -EIO;\n\t}\n\tif (unlikely(err))\n\t\tpage_zero_new_buffers(page, from, to);\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "try_to_release_page",
          "args": [
            "pagep[1]",
            "0"
          ],
          "line": 367
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_has_private",
          "args": [
            "pagep[1]"
          ],
          "line": 367
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "try_to_release_page",
          "args": [
            "pagep[0]",
            "0"
          ],
          "line": 366
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_has_private",
          "args": [
            "pagep[0]"
          ],
          "line": 366
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mext_page_mkuptodate",
          "args": [
            "pagep[0]",
            "from",
            "from + replaced_size"
          ],
          "line": 360
        },
        "resolved": true,
        "details": {
          "function_name": "mext_page_mkuptodate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/move_extent.c",
          "lines": "179-240",
          "snippet": "static int\nmext_page_mkuptodate(struct page *page, unsigned from, unsigned to)\n{\n\tstruct inode *inode = page->mapping->host;\n\tsector_t block;\n\tstruct buffer_head *bh, *head, *arr[MAX_BUF_PER_PAGE];\n\tunsigned int blocksize, block_start, block_end;\n\tint i, err,  nr = 0, partial = 0;\n\tBUG_ON(!PageLocked(page));\n\tBUG_ON(PageWriteback(page));\n\n\tif (PageUptodate(page))\n\t\treturn 0;\n\n\tblocksize = 1 << inode->i_blkbits;\n\tif (!page_has_buffers(page))\n\t\tcreate_empty_buffers(page, blocksize, 0);\n\n\thead = page_buffers(page);\n\tblock = (sector_t)page->index << (PAGE_CACHE_SHIFT - inode->i_blkbits);\n\tfor (bh = head, block_start = 0; bh != head || !block_start;\n\t     block++, block_start = block_end, bh = bh->b_this_page) {\n\t\tblock_end = block_start + blocksize;\n\t\tif (block_end <= from || block_start >= to) {\n\t\t\tif (!buffer_uptodate(bh))\n\t\t\t\tpartial = 1;\n\t\t\tcontinue;\n\t\t}\n\t\tif (buffer_uptodate(bh))\n\t\t\tcontinue;\n\t\tif (!buffer_mapped(bh)) {\n\t\t\terr = ext4_get_block(inode, block, bh, 0);\n\t\t\tif (err) {\n\t\t\t\tSetPageError(page);\n\t\t\t\treturn err;\n\t\t\t}\n\t\t\tif (!buffer_mapped(bh)) {\n\t\t\t\tzero_user(page, block_start, blocksize);\n\t\t\t\tset_buffer_uptodate(bh);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\t\tBUG_ON(nr >= MAX_BUF_PER_PAGE);\n\t\tarr[nr++] = bh;\n\t}\n\t/* No io required */\n\tif (!nr)\n\t\tgoto out;\n\n\tfor (i = 0; i < nr; i++) {\n\t\tbh = arr[i];\n\t\tif (!bh_uptodate_or_lock(bh)) {\n\t\t\terr = bh_submit_read(bh);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\t\t}\n\t}\nout:\n\tif (!partial)\n\t\tSetPageUptodate(page);\n\treturn 0;\n}",
          "includes": [
            "#include \"ext4_extents.h\"",
            "#include \"ext4.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include <linux/slab.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ext4_extents.h\"\n#include \"ext4.h\"\n#include \"ext4_jbd2.h\"\n#include <linux/slab.h>\n#include <linux/quotaops.h>\n#include <linux/fs.h>\n\nstatic int\nmext_page_mkuptodate(struct page *page, unsigned from, unsigned to)\n{\n\tstruct inode *inode = page->mapping->host;\n\tsector_t block;\n\tstruct buffer_head *bh, *head, *arr[MAX_BUF_PER_PAGE];\n\tunsigned int blocksize, block_start, block_end;\n\tint i, err,  nr = 0, partial = 0;\n\tBUG_ON(!PageLocked(page));\n\tBUG_ON(PageWriteback(page));\n\n\tif (PageUptodate(page))\n\t\treturn 0;\n\n\tblocksize = 1 << inode->i_blkbits;\n\tif (!page_has_buffers(page))\n\t\tcreate_empty_buffers(page, blocksize, 0);\n\n\thead = page_buffers(page);\n\tblock = (sector_t)page->index << (PAGE_CACHE_SHIFT - inode->i_blkbits);\n\tfor (bh = head, block_start = 0; bh != head || !block_start;\n\t     block++, block_start = block_end, bh = bh->b_this_page) {\n\t\tblock_end = block_start + blocksize;\n\t\tif (block_end <= from || block_start >= to) {\n\t\t\tif (!buffer_uptodate(bh))\n\t\t\t\tpartial = 1;\n\t\t\tcontinue;\n\t\t}\n\t\tif (buffer_uptodate(bh))\n\t\t\tcontinue;\n\t\tif (!buffer_mapped(bh)) {\n\t\t\terr = ext4_get_block(inode, block, bh, 0);\n\t\t\tif (err) {\n\t\t\t\tSetPageError(page);\n\t\t\t\treturn err;\n\t\t\t}\n\t\t\tif (!buffer_mapped(bh)) {\n\t\t\t\tzero_user(page, block_start, blocksize);\n\t\t\t\tset_buffer_uptodate(bh);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\t\tBUG_ON(nr >= MAX_BUF_PER_PAGE);\n\t\tarr[nr++] = bh;\n\t}\n\t/* No io required */\n\tif (!nr)\n\t\tgoto out;\n\n\tfor (i = 0; i < nr; i++) {\n\t\tbh = arr[i];\n\t\tif (!bh_uptodate_or_lock(bh)) {\n\t\t\terr = bh_submit_read(bh);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\t\t}\n\t}\nout:\n\tif (!partial)\n\t\tSetPageUptodate(page);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "try_to_release_page",
          "args": [
            "pagep[1]",
            "0"
          ],
          "line": 347
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_has_private",
          "args": [
            "pagep[1]"
          ],
          "line": 346
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "try_to_release_page",
          "args": [
            "pagep[0]",
            "0"
          ],
          "line": 345
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_has_private",
          "args": [
            "pagep[0]"
          ],
          "line": 344
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mext_check_coverage",
          "args": [
            "donor_inode",
            "donor_blk_offset",
            "block_len_in_page",
            "1",
            "err"
          ],
          "line": 335
        },
        "resolved": true,
        "details": {
          "function_name": "mext_check_coverage",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/move_extent.c",
          "lines": "97-120",
          "snippet": "static int\nmext_check_coverage(struct inode *inode, ext4_lblk_t from, ext4_lblk_t count,\n\t\t    int unwritten, int *err)\n{\n\tstruct ext4_ext_path *path = NULL;\n\tstruct ext4_extent *ext;\n\tint ret = 0;\n\text4_lblk_t last = from + count;\n\twhile (from < last) {\n\t\t*err = get_ext_path(inode, from, &path);\n\t\tif (*err)\n\t\t\tgoto out;\n\t\text = path[ext_depth(inode)].p_ext;\n\t\tif (unwritten != ext4_ext_is_unwritten(ext))\n\t\t\tgoto out;\n\t\tfrom += ext4_ext_get_actual_len(ext);\n\t\text4_ext_drop_refs(path);\n\t}\n\tret = 1;\nout:\n\text4_ext_drop_refs(path);\n\tkfree(path);\n\treturn ret;\n}",
          "includes": [
            "#include \"ext4_extents.h\"",
            "#include \"ext4.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include <linux/slab.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ext4_extents.h\"\n#include \"ext4.h\"\n#include \"ext4_jbd2.h\"\n#include <linux/slab.h>\n#include <linux/quotaops.h>\n#include <linux/fs.h>\n\nstatic int\nmext_check_coverage(struct inode *inode, ext4_lblk_t from, ext4_lblk_t count,\n\t\t    int unwritten, int *err)\n{\n\tstruct ext4_ext_path *path = NULL;\n\tstruct ext4_extent *ext;\n\tint ret = 0;\n\text4_lblk_t last = from + count;\n\twhile (from < last) {\n\t\t*err = get_ext_path(inode, from, &path);\n\t\tif (*err)\n\t\t\tgoto out;\n\t\text = path[ext_depth(inode)].p_ext;\n\t\tif (unwritten != ext4_ext_is_unwritten(ext))\n\t\t\tgoto out;\n\t\tfrom += ext4_ext_get_actual_len(ext);\n\t\text4_ext_drop_refs(path);\n\t}\n\tret = 1;\nout:\n\text4_ext_drop_refs(path);\n\tkfree(path);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "*err < 0"
          ],
          "line": 317
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mext_page_double_lock",
          "args": [
            "orig_inode",
            "donor_inode",
            "orig_page_offset",
            "donor_page_offset",
            "pagep"
          ],
          "line": 315
        },
        "resolved": true,
        "details": {
          "function_name": "mext_page_double_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/move_extent.c",
          "lines": "133-176",
          "snippet": "static int\nmext_page_double_lock(struct inode *inode1, struct inode *inode2,\n\t\t      pgoff_t index1, pgoff_t index2, struct page *page[2])\n{\n\tstruct address_space *mapping[2];\n\tunsigned fl = AOP_FLAG_NOFS;\n\n\tBUG_ON(!inode1 || !inode2);\n\tif (inode1 < inode2) {\n\t\tmapping[0] = inode1->i_mapping;\n\t\tmapping[1] = inode2->i_mapping;\n\t} else {\n\t\tpgoff_t tmp = index1;\n\t\tindex1 = index2;\n\t\tindex2 = tmp;\n\t\tmapping[0] = inode2->i_mapping;\n\t\tmapping[1] = inode1->i_mapping;\n\t}\n\n\tpage[0] = grab_cache_page_write_begin(mapping[0], index1, fl);\n\tif (!page[0])\n\t\treturn -ENOMEM;\n\n\tpage[1] = grab_cache_page_write_begin(mapping[1], index2, fl);\n\tif (!page[1]) {\n\t\tunlock_page(page[0]);\n\t\tpage_cache_release(page[0]);\n\t\treturn -ENOMEM;\n\t}\n\t/*\n\t * grab_cache_page_write_begin() may not wait on page's writeback if\n\t * BDI not demand that. But it is reasonable to be very conservative\n\t * here and explicitly wait on page's writeback\n\t */\n\twait_on_page_writeback(page[0]);\n\twait_on_page_writeback(page[1]);\n\tif (inode1 > inode2) {\n\t\tstruct page *tmp;\n\t\ttmp = page[0];\n\t\tpage[0] = page[1];\n\t\tpage[1] = tmp;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"ext4_extents.h\"",
            "#include \"ext4.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include <linux/slab.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ext4_extents.h\"\n#include \"ext4.h\"\n#include \"ext4_jbd2.h\"\n#include <linux/slab.h>\n#include <linux/quotaops.h>\n#include <linux/fs.h>\n\nstatic int\nmext_page_double_lock(struct inode *inode1, struct inode *inode2,\n\t\t      pgoff_t index1, pgoff_t index2, struct page *page[2])\n{\n\tstruct address_space *mapping[2];\n\tunsigned fl = AOP_FLAG_NOFS;\n\n\tBUG_ON(!inode1 || !inode2);\n\tif (inode1 < inode2) {\n\t\tmapping[0] = inode1->i_mapping;\n\t\tmapping[1] = inode2->i_mapping;\n\t} else {\n\t\tpgoff_t tmp = index1;\n\t\tindex1 = index2;\n\t\tindex2 = tmp;\n\t\tmapping[0] = inode2->i_mapping;\n\t\tmapping[1] = inode1->i_mapping;\n\t}\n\n\tpage[0] = grab_cache_page_write_begin(mapping[0], index1, fl);\n\tif (!page[0])\n\t\treturn -ENOMEM;\n\n\tpage[1] = grab_cache_page_write_begin(mapping[1], index2, fl);\n\tif (!page[1]) {\n\t\tunlock_page(page[0]);\n\t\tpage_cache_release(page[0]);\n\t\treturn -ENOMEM;\n\t}\n\t/*\n\t * grab_cache_page_write_begin() may not wait on page's writeback if\n\t * BDI not demand that. But it is reasonable to be very conservative\n\t * here and explicitly wait on page's writeback\n\t */\n\twait_on_page_writeback(page[0]);\n\twait_on_page_writeback(page[1]);\n\tif (inode1 > inode2) {\n\t\tstruct page *tmp;\n\t\ttmp = page[0];\n\t\tpage[0] = page[1];\n\t\tpage[1] = tmp;\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "handle"
          ],
          "line": 286
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "handle"
          ],
          "line": 285
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_journal_start",
          "args": [
            "orig_inode",
            "EXT4_HT_MOVE_EXTENTS",
            "jblocks"
          ],
          "line": 284
        },
        "resolved": true,
        "details": {
          "function_name": "__ext4_journal_start_reserved",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ext4_jbd2.c",
          "lines": "101-123",
          "snippet": "handle_t *__ext4_journal_start_reserved(handle_t *handle, unsigned int line,\n\t\t\t\t\tint type)\n{\n\tstruct super_block *sb;\n\tint err;\n\n\tif (!ext4_handle_valid(handle))\n\t\treturn ext4_get_nojournal();\n\n\tsb = handle->h_journal->j_private;\n\ttrace_ext4_journal_start_reserved(sb, handle->h_buffer_credits,\n\t\t\t\t\t  _RET_IP_);\n\terr = ext4_journal_check_start(sb);\n\tif (err < 0) {\n\t\tjbd2_journal_free_reserved(handle);\n\t\treturn ERR_PTR(err);\n\t}\n\n\terr = jbd2_journal_start_reserved(handle, type, line);\n\tif (err < 0)\n\t\treturn ERR_PTR(err);\n\treturn handle;\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"ext4_jbd2.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"ext4_jbd2.h\"\n\nhandle_t *__ext4_journal_start_reserved(handle_t *handle, unsigned int line,\n\t\t\t\t\tint type)\n{\n\tstruct super_block *sb;\n\tint err;\n\n\tif (!ext4_handle_valid(handle))\n\t\treturn ext4_get_nojournal();\n\n\tsb = handle->h_journal->j_private;\n\ttrace_ext4_journal_start_reserved(sb, handle->h_buffer_credits,\n\t\t\t\t\t  _RET_IP_);\n\terr = ext4_journal_check_start(sb);\n\tif (err < 0) {\n\t\tjbd2_journal_free_reserved(handle);\n\t\treturn ERR_PTR(err);\n\t}\n\n\terr = jbd2_journal_start_reserved(handle, type, line);\n\tif (err < 0)\n\t\treturn ERR_PTR(err);\n\treturn handle;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_writepage_trans_blocks",
          "args": [
            "orig_inode"
          ],
          "line": 283
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_writepage_trans_blocks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/inode.c",
          "lines": "4769-4780",
          "snippet": "int ext4_writepage_trans_blocks(struct inode *inode)\n{\n\tint bpp = ext4_journal_blocks_per_page(inode);\n\tint ret;\n\n\tret = ext4_meta_trans_blocks(inode, bpp, bpp);\n\n\t/* Account for data blocks for journalled mode */\n\tif (ext4_should_journal_data(inode))\n\t\tret += bpp;\n\treturn ret;\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"truncate.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include <linux/bitops.h>",
            "#include <linux/aio.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/printk.h>",
            "#include <linux/kernel.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/bio.h>",
            "#include <linux/uio.h>",
            "#include <linux/namei.h>",
            "#include <linux/mpage.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highuid.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/time.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"truncate.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include <linux/bitops.h>\n#include <linux/aio.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/printk.h>\n#include <linux/kernel.h>\n#include <linux/workqueue.h>\n#include <linux/bio.h>\n#include <linux/uio.h>\n#include <linux/namei.h>\n#include <linux/mpage.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/highuid.h>\n#include <linux/jbd2.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n\nint ext4_writepage_trans_blocks(struct inode *inode)\n{\n\tint bpp = ext4_journal_blocks_per_page(inode);\n\tint ret;\n\n\tret = ext4_meta_trans_blocks(inode, bpp, bpp);\n\n\t/* Account for data blocks for journalled mode */\n\tif (ext4_should_journal_data(inode))\n\t\tret += bpp;\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "file_inode",
          "args": [
            "o_filp"
          ],
          "line": 265
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_init_file_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/file.c",
          "lines": "3009-3013",
          "snippet": "void fuse_init_file_inode(struct inode *inode)\n{\n\tinode->i_fop = &fuse_file_operations;\n\tinode->i_data.a_ops = &fuse_file_aops;\n}",
          "includes": [
            "#include <linux/falloc.h>",
            "#include <linux/aio.h>",
            "#include <linux/swap.h>",
            "#include <linux/compat.h>",
            "#include <linux/module.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct file_operations fuse_file_operations = {\n\t.llseek\t\t= fuse_file_llseek,\n\t.read\t\t= new_sync_read,\n\t.read_iter\t= fuse_file_read_iter,\n\t.write\t\t= new_sync_write,\n\t.write_iter\t= fuse_file_write_iter,\n\t.mmap\t\t= fuse_file_mmap,\n\t.open\t\t= fuse_open,\n\t.flush\t\t= fuse_flush,\n\t.release\t= fuse_release,\n\t.fsync\t\t= fuse_fsync,\n\t.lock\t\t= fuse_file_lock,\n\t.flock\t\t= fuse_file_flock,\n\t.splice_read\t= generic_file_splice_read,\n\t.unlocked_ioctl\t= fuse_file_ioctl,\n\t.compat_ioctl\t= fuse_file_compat_ioctl,\n\t.poll\t\t= fuse_file_poll,\n\t.fallocate\t= fuse_file_fallocate,\n};",
            "static const struct address_space_operations fuse_file_aops  = {\n\t.readpage\t= fuse_readpage,\n\t.writepage\t= fuse_writepage,\n\t.writepages\t= fuse_writepages,\n\t.launder_page\t= fuse_launder_page,\n\t.readpages\t= fuse_readpages,\n\t.set_page_dirty\t= __set_page_dirty_nobuffers,\n\t.bmap\t\t= fuse_bmap,\n\t.direct_IO\t= fuse_direct_IO,\n\t.write_begin\t= fuse_write_begin,\n\t.write_end\t= fuse_write_end,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/falloc.h>\n#include <linux/aio.h>\n#include <linux/swap.h>\n#include <linux/compat.h>\n#include <linux/module.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nstatic const struct file_operations fuse_file_operations = {\n\t.llseek\t\t= fuse_file_llseek,\n\t.read\t\t= new_sync_read,\n\t.read_iter\t= fuse_file_read_iter,\n\t.write\t\t= new_sync_write,\n\t.write_iter\t= fuse_file_write_iter,\n\t.mmap\t\t= fuse_file_mmap,\n\t.open\t\t= fuse_open,\n\t.flush\t\t= fuse_flush,\n\t.release\t= fuse_release,\n\t.fsync\t\t= fuse_fsync,\n\t.lock\t\t= fuse_file_lock,\n\t.flock\t\t= fuse_file_flock,\n\t.splice_read\t= generic_file_splice_read,\n\t.unlocked_ioctl\t= fuse_file_ioctl,\n\t.compat_ioctl\t= fuse_file_compat_ioctl,\n\t.poll\t\t= fuse_file_poll,\n\t.fallocate\t= fuse_file_fallocate,\n};\nstatic const struct address_space_operations fuse_file_aops  = {\n\t.readpage\t= fuse_readpage,\n\t.writepage\t= fuse_writepage,\n\t.writepages\t= fuse_writepages,\n\t.launder_page\t= fuse_launder_page,\n\t.readpages\t= fuse_readpages,\n\t.set_page_dirty\t= __set_page_dirty_nobuffers,\n\t.bmap\t\t= fuse_bmap,\n\t.direct_IO\t= fuse_direct_IO,\n\t.write_begin\t= fuse_write_begin,\n\t.write_end\t= fuse_write_end,\n};\n\nvoid fuse_init_file_inode(struct inode *inode)\n{\n\tinode->i_fop = &fuse_file_operations;\n\tinode->i_data.a_ops = &fuse_file_aops;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ext4_extents.h\"\n#include \"ext4.h\"\n#include \"ext4_jbd2.h\"\n#include <linux/slab.h>\n#include <linux/quotaops.h>\n#include <linux/fs.h>\n\nstatic int\nmove_extent_per_page(struct file *o_filp, struct inode *donor_inode,\n\t\t     pgoff_t orig_page_offset, pgoff_t donor_page_offset,\n\t\t     int data_offset_in_page,\n\t\t     int block_len_in_page, int unwritten, int *err)\n{\n\tstruct inode *orig_inode = file_inode(o_filp);\n\tstruct page *pagep[2] = {NULL, NULL};\n\thandle_t *handle;\n\text4_lblk_t orig_blk_offset, donor_blk_offset;\n\tunsigned long blocksize = orig_inode->i_sb->s_blocksize;\n\tunsigned int tmp_data_size, data_size, replaced_size;\n\tint err2, jblocks, retries = 0;\n\tint replaced_count = 0;\n\tint from = data_offset_in_page << orig_inode->i_blkbits;\n\tint blocks_per_page = PAGE_CACHE_SIZE >> orig_inode->i_blkbits;\n\tstruct super_block *sb = orig_inode->i_sb;\n\n\t/*\n\t * It needs twice the amount of ordinary journal buffers because\n\t * inode and donor_inode may change each different metadata blocks.\n\t */\nagain:\n\t*err = 0;\n\tjblocks = ext4_writepage_trans_blocks(orig_inode) * 2;\n\thandle = ext4_journal_start(orig_inode, EXT4_HT_MOVE_EXTENTS, jblocks);\n\tif (IS_ERR(handle)) {\n\t\t*err = PTR_ERR(handle);\n\t\treturn 0;\n\t}\n\n\torig_blk_offset = orig_page_offset * blocks_per_page +\n\t\tdata_offset_in_page;\n\n\tdonor_blk_offset = donor_page_offset * blocks_per_page +\n\t\tdata_offset_in_page;\n\n\t/* Calculate data_size */\n\tif ((orig_blk_offset + block_len_in_page - 1) ==\n\t    ((orig_inode->i_size - 1) >> orig_inode->i_blkbits)) {\n\t\t/* Replace the last block */\n\t\ttmp_data_size = orig_inode->i_size & (blocksize - 1);\n\t\t/*\n\t\t * If data_size equal zero, it shows data_size is multiples of\n\t\t * blocksize. So we set appropriate value.\n\t\t */\n\t\tif (tmp_data_size == 0)\n\t\t\ttmp_data_size = blocksize;\n\n\t\tdata_size = tmp_data_size +\n\t\t\t((block_len_in_page - 1) << orig_inode->i_blkbits);\n\t} else\n\t\tdata_size = block_len_in_page << orig_inode->i_blkbits;\n\n\treplaced_size = data_size;\n\n\t*err = mext_page_double_lock(orig_inode, donor_inode, orig_page_offset,\n\t\t\t\t     donor_page_offset, pagep);\n\tif (unlikely(*err < 0))\n\t\tgoto stop_journal;\n\t/*\n\t * If orig extent was unwritten it can become initialized\n\t * at any time after i_data_sem was dropped, in order to\n\t * serialize with delalloc we have recheck extent while we\n\t * hold page's lock, if it is still the case data copy is not\n\t * necessary, just swap data blocks between orig and donor.\n\t */\n\tif (unwritten) {\n\t\text4_double_down_write_data_sem(orig_inode, donor_inode);\n\t\t/* If any of extents in range became initialized we have to\n\t\t * fallback to data copying */\n\t\tunwritten = mext_check_coverage(orig_inode, orig_blk_offset,\n\t\t\t\t\t\tblock_len_in_page, 1, err);\n\t\tif (*err)\n\t\t\tgoto drop_data_sem;\n\n\t\tunwritten &= mext_check_coverage(donor_inode, donor_blk_offset,\n\t\t\t\t\t\t block_len_in_page, 1, err);\n\t\tif (*err)\n\t\t\tgoto drop_data_sem;\n\n\t\tif (!unwritten) {\n\t\t\text4_double_up_write_data_sem(orig_inode, donor_inode);\n\t\t\tgoto data_copy;\n\t\t}\n\t\tif ((page_has_private(pagep[0]) &&\n\t\t     !try_to_release_page(pagep[0], 0)) ||\n\t\t    (page_has_private(pagep[1]) &&\n\t\t     !try_to_release_page(pagep[1], 0))) {\n\t\t\t*err = -EBUSY;\n\t\t\tgoto drop_data_sem;\n\t\t}\n\t\treplaced_count = ext4_swap_extents(handle, orig_inode,\n\t\t\t\t\t\t   donor_inode, orig_blk_offset,\n\t\t\t\t\t\t   donor_blk_offset,\n\t\t\t\t\t\t   block_len_in_page, 1, err);\n\tdrop_data_sem:\n\t\text4_double_up_write_data_sem(orig_inode, donor_inode);\n\t\tgoto unlock_pages;\n\t}\ndata_copy:\n\t*err = mext_page_mkuptodate(pagep[0], from, from + replaced_size);\n\tif (*err)\n\t\tgoto unlock_pages;\n\n\t/* At this point all buffers in range are uptodate, old mapping layout\n\t * is no longer required, try to drop it now. */\n\tif ((page_has_private(pagep[0]) && !try_to_release_page(pagep[0], 0)) ||\n\t    (page_has_private(pagep[1]) && !try_to_release_page(pagep[1], 0))) {\n\t\t*err = -EBUSY;\n\t\tgoto unlock_pages;\n\t}\n\text4_double_down_write_data_sem(orig_inode, donor_inode);\n\treplaced_count = ext4_swap_extents(handle, orig_inode, donor_inode,\n\t\t\t\t\t       orig_blk_offset, donor_blk_offset,\n\t\t\t\t\t   block_len_in_page, 1, err);\n\text4_double_up_write_data_sem(orig_inode, donor_inode);\n\tif (*err) {\n\t\tif (replaced_count) {\n\t\t\tblock_len_in_page = replaced_count;\n\t\t\treplaced_size =\n\t\t\t\tblock_len_in_page << orig_inode->i_blkbits;\n\t\t} else\n\t\t\tgoto unlock_pages;\n\t}\n\t/* Perform all necessary steps similar write_begin()/write_end()\n\t * but keeping in mind that i_size will not change */\n\t*err = __block_write_begin(pagep[0], from, replaced_size,\n\t\t\t\t   ext4_get_block);\n\tif (!*err)\n\t\t*err = block_commit_write(pagep[0], from, from + replaced_size);\n\n\tif (unlikely(*err < 0))\n\t\tgoto repair_branches;\n\n\t/* Even in case of data=writeback it is reasonable to pin\n\t * inode to transaction, to prevent unexpected data loss */\n\t*err = ext4_jbd2_file_inode(handle, orig_inode);\n\nunlock_pages:\n\tunlock_page(pagep[0]);\n\tpage_cache_release(pagep[0]);\n\tunlock_page(pagep[1]);\n\tpage_cache_release(pagep[1]);\nstop_journal:\n\text4_journal_stop(handle);\n\tif (*err == -ENOSPC &&\n\t    ext4_should_retry_alloc(sb, &retries))\n\t\tgoto again;\n\t/* Buffer was busy because probably is pinned to journal transaction,\n\t * force transaction commit may help to free it. */\n\tif (*err == -EBUSY && retries++ < 4 && EXT4_SB(sb)->s_journal &&\n\t    jbd2_journal_force_commit_nested(EXT4_SB(sb)->s_journal))\n\t\tgoto again;\n\treturn replaced_count;\n\nrepair_branches:\n\t/*\n\t * This should never ever happen!\n\t * Extents are swapped already, but we are not able to copy data.\n\t * Try to swap extents to it's original places\n\t */\n\text4_double_down_write_data_sem(orig_inode, donor_inode);\n\treplaced_count = ext4_swap_extents(handle, donor_inode, orig_inode,\n\t\t\t\t\t       orig_blk_offset, donor_blk_offset,\n\t\t\t\t\t   block_len_in_page, 0, &err2);\n\text4_double_up_write_data_sem(orig_inode, donor_inode);\n\tif (replaced_count != block_len_in_page) {\n\t\tEXT4_ERROR_INODE_BLOCK(orig_inode, (sector_t)(orig_blk_offset),\n\t\t\t\t       \"Unable to copy data block,\"\n\t\t\t\t       \" data will be lost.\");\n\t\t*err = -EIO;\n\t}\n\treplaced_count = 0;\n\tgoto unlock_pages;\n}"
  },
  {
    "function_name": "mext_page_mkuptodate",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/move_extent.c",
    "lines": "179-240",
    "snippet": "static int\nmext_page_mkuptodate(struct page *page, unsigned from, unsigned to)\n{\n\tstruct inode *inode = page->mapping->host;\n\tsector_t block;\n\tstruct buffer_head *bh, *head, *arr[MAX_BUF_PER_PAGE];\n\tunsigned int blocksize, block_start, block_end;\n\tint i, err,  nr = 0, partial = 0;\n\tBUG_ON(!PageLocked(page));\n\tBUG_ON(PageWriteback(page));\n\n\tif (PageUptodate(page))\n\t\treturn 0;\n\n\tblocksize = 1 << inode->i_blkbits;\n\tif (!page_has_buffers(page))\n\t\tcreate_empty_buffers(page, blocksize, 0);\n\n\thead = page_buffers(page);\n\tblock = (sector_t)page->index << (PAGE_CACHE_SHIFT - inode->i_blkbits);\n\tfor (bh = head, block_start = 0; bh != head || !block_start;\n\t     block++, block_start = block_end, bh = bh->b_this_page) {\n\t\tblock_end = block_start + blocksize;\n\t\tif (block_end <= from || block_start >= to) {\n\t\t\tif (!buffer_uptodate(bh))\n\t\t\t\tpartial = 1;\n\t\t\tcontinue;\n\t\t}\n\t\tif (buffer_uptodate(bh))\n\t\t\tcontinue;\n\t\tif (!buffer_mapped(bh)) {\n\t\t\terr = ext4_get_block(inode, block, bh, 0);\n\t\t\tif (err) {\n\t\t\t\tSetPageError(page);\n\t\t\t\treturn err;\n\t\t\t}\n\t\t\tif (!buffer_mapped(bh)) {\n\t\t\t\tzero_user(page, block_start, blocksize);\n\t\t\t\tset_buffer_uptodate(bh);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\t\tBUG_ON(nr >= MAX_BUF_PER_PAGE);\n\t\tarr[nr++] = bh;\n\t}\n\t/* No io required */\n\tif (!nr)\n\t\tgoto out;\n\n\tfor (i = 0; i < nr; i++) {\n\t\tbh = arr[i];\n\t\tif (!bh_uptodate_or_lock(bh)) {\n\t\t\terr = bh_submit_read(bh);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\t\t}\n\t}\nout:\n\tif (!partial)\n\t\tSetPageUptodate(page);\n\treturn 0;\n}",
    "includes": [
      "#include \"ext4_extents.h\"",
      "#include \"ext4.h\"",
      "#include \"ext4_jbd2.h\"",
      "#include <linux/slab.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "SetPageUptodate",
          "args": [
            "page"
          ],
          "line": 238
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bh_submit_read",
          "args": [
            "bh"
          ],
          "line": 231
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bh_uptodate_or_lock",
          "args": [
            "bh"
          ],
          "line": 230
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "nr >= MAX_BUF_PER_PAGE"
          ],
          "line": 221
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_buffer_uptodate",
          "args": [
            "bh"
          ],
          "line": 217
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_set_buffer_uptodate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/disk-io.c",
          "lines": "3758-3761",
          "snippet": "int btrfs_set_buffer_uptodate(struct extent_buffer *buf)\n{\n\treturn set_extent_buffer_uptodate(buf);\n}",
          "includes": [
            "#include <asm/cpufeature.h>",
            "#include \"qgroup.h\"",
            "#include \"sysfs.h\"",
            "#include \"raid56.h\"",
            "#include \"dev-replace.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"inode-map.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"tree-log.h\"",
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"hash.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/uuid.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/migrate.h>",
            "#include <linux/slab.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/writeback.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/swap.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/cpufeature.h>\n#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"raid56.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <asm/unaligned.h>\n#include <linux/semaphore.h>\n#include <linux/uuid.h>\n#include <linux/ratelimit.h>\n#include <linux/migrate.h>\n#include <linux/slab.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/writeback.h>\n#include <linux/radix-tree.h>\n#include <linux/swap.h>\n#include <linux/scatterlist.h>\n#include <linux/blkdev.h>\n#include <linux/fs.h>\n\nint btrfs_set_buffer_uptodate(struct extent_buffer *buf)\n{\n\treturn set_extent_buffer_uptodate(buf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "zero_user",
          "args": [
            "page",
            "block_start",
            "blocksize"
          ],
          "line": 216
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "buffer_mapped",
          "args": [
            "bh"
          ],
          "line": 215
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SetPageError",
          "args": [
            "page"
          ],
          "line": 212
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_get_block",
          "args": [
            "inode",
            "block",
            "bh",
            "0"
          ],
          "line": 210
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_get_block_write_nolock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/inode.c",
          "lines": "2908-2915",
          "snippet": "static int ext4_get_block_write_nolock(struct inode *inode, sector_t iblock,\n\t\t   struct buffer_head *bh_result, int create)\n{\n\text4_debug(\"ext4_get_block_write_nolock: inode %lu, create flag %d\\n\",\n\t\t   inode->i_ino, create);\n\treturn _ext4_get_block(inode, iblock, bh_result,\n\t\t\t       EXT4_GET_BLOCKS_NO_LOCK);\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"truncate.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include <linux/bitops.h>",
            "#include <linux/aio.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/printk.h>",
            "#include <linux/kernel.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/bio.h>",
            "#include <linux/uio.h>",
            "#include <linux/namei.h>",
            "#include <linux/mpage.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highuid.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/time.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ext4_get_block_write_nolock(struct inode *inode, sector_t iblock,\n\t\t   struct buffer_head *bh_result, int create);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"truncate.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include <linux/bitops.h>\n#include <linux/aio.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/printk.h>\n#include <linux/kernel.h>\n#include <linux/workqueue.h>\n#include <linux/bio.h>\n#include <linux/uio.h>\n#include <linux/namei.h>\n#include <linux/mpage.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/highuid.h>\n#include <linux/jbd2.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n\nstatic int ext4_get_block_write_nolock(struct inode *inode, sector_t iblock,\n\t\t   struct buffer_head *bh_result, int create);\n\nstatic int ext4_get_block_write_nolock(struct inode *inode, sector_t iblock,\n\t\t   struct buffer_head *bh_result, int create)\n{\n\text4_debug(\"ext4_get_block_write_nolock: inode %lu, create flag %d\\n\",\n\t\t   inode->i_ino, create);\n\treturn _ext4_get_block(inode, iblock, bh_result,\n\t\t\t       EXT4_GET_BLOCKS_NO_LOCK);\n}"
        }
      },
      {
        "call_info": {
          "callee": "buffer_mapped",
          "args": [
            "bh"
          ],
          "line": 209
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_buffers",
          "args": [
            "page"
          ],
          "line": 197
        },
        "resolved": true,
        "details": {
          "function_name": "__clear_page_buffers",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "123-129",
          "snippet": "static void\n__clear_page_buffers(struct page *page)\n{\n\tClearPagePrivate(page);\n\tset_page_private(page, 0);\n\tpage_cache_release(page);\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nstatic void\n__clear_page_buffers(struct page *page)\n{\n\tClearPagePrivate(page);\n\tset_page_private(page, 0);\n\tpage_cache_release(page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "create_empty_buffers",
          "args": [
            "page",
            "blocksize",
            "0"
          ],
          "line": 195
        },
        "resolved": true,
        "details": {
          "function_name": "create_empty_buffers",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1564-1591",
          "snippet": "void create_empty_buffers(struct page *page,\n\t\t\tunsigned long blocksize, unsigned long b_state)\n{\n\tstruct buffer_head *bh, *head, *tail;\n\n\thead = alloc_page_buffers(page, blocksize, 1);\n\tbh = head;\n\tdo {\n\t\tbh->b_state |= b_state;\n\t\ttail = bh;\n\t\tbh = bh->b_this_page;\n\t} while (bh);\n\ttail->b_this_page = head;\n\n\tspin_lock(&page->mapping->private_lock);\n\tif (PageUptodate(page) || PageDirty(page)) {\n\t\tbh = head;\n\t\tdo {\n\t\t\tif (PageDirty(page))\n\t\t\t\tset_buffer_dirty(bh);\n\t\t\tif (PageUptodate(page))\n\t\t\t\tset_buffer_uptodate(bh);\n\t\t\tbh = bh->b_this_page;\n\t\t} while (bh != head);\n\t}\n\tattach_page_buffers(page, head);\n\tspin_unlock(&page->mapping->private_lock);\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid create_empty_buffers(struct page *page,\n\t\t\tunsigned long blocksize, unsigned long b_state)\n{\n\tstruct buffer_head *bh, *head, *tail;\n\n\thead = alloc_page_buffers(page, blocksize, 1);\n\tbh = head;\n\tdo {\n\t\tbh->b_state |= b_state;\n\t\ttail = bh;\n\t\tbh = bh->b_this_page;\n\t} while (bh);\n\ttail->b_this_page = head;\n\n\tspin_lock(&page->mapping->private_lock);\n\tif (PageUptodate(page) || PageDirty(page)) {\n\t\tbh = head;\n\t\tdo {\n\t\t\tif (PageDirty(page))\n\t\t\t\tset_buffer_dirty(bh);\n\t\t\tif (PageUptodate(page))\n\t\t\t\tset_buffer_uptodate(bh);\n\t\t\tbh = bh->b_this_page;\n\t\t} while (bh != head);\n\t}\n\tattach_page_buffers(page, head);\n\tspin_unlock(&page->mapping->private_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "page_has_buffers",
          "args": [
            "page"
          ],
          "line": 194
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageUptodate",
          "args": [
            "page"
          ],
          "line": 190
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "PageWriteback(page)"
          ],
          "line": 188
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageWriteback",
          "args": [
            "page"
          ],
          "line": 188
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!PageLocked(page)"
          ],
          "line": 187
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageLocked",
          "args": [
            "page"
          ],
          "line": 187
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ext4_extents.h\"\n#include \"ext4.h\"\n#include \"ext4_jbd2.h\"\n#include <linux/slab.h>\n#include <linux/quotaops.h>\n#include <linux/fs.h>\n\nstatic int\nmext_page_mkuptodate(struct page *page, unsigned from, unsigned to)\n{\n\tstruct inode *inode = page->mapping->host;\n\tsector_t block;\n\tstruct buffer_head *bh, *head, *arr[MAX_BUF_PER_PAGE];\n\tunsigned int blocksize, block_start, block_end;\n\tint i, err,  nr = 0, partial = 0;\n\tBUG_ON(!PageLocked(page));\n\tBUG_ON(PageWriteback(page));\n\n\tif (PageUptodate(page))\n\t\treturn 0;\n\n\tblocksize = 1 << inode->i_blkbits;\n\tif (!page_has_buffers(page))\n\t\tcreate_empty_buffers(page, blocksize, 0);\n\n\thead = page_buffers(page);\n\tblock = (sector_t)page->index << (PAGE_CACHE_SHIFT - inode->i_blkbits);\n\tfor (bh = head, block_start = 0; bh != head || !block_start;\n\t     block++, block_start = block_end, bh = bh->b_this_page) {\n\t\tblock_end = block_start + blocksize;\n\t\tif (block_end <= from || block_start >= to) {\n\t\t\tif (!buffer_uptodate(bh))\n\t\t\t\tpartial = 1;\n\t\t\tcontinue;\n\t\t}\n\t\tif (buffer_uptodate(bh))\n\t\t\tcontinue;\n\t\tif (!buffer_mapped(bh)) {\n\t\t\terr = ext4_get_block(inode, block, bh, 0);\n\t\t\tif (err) {\n\t\t\t\tSetPageError(page);\n\t\t\t\treturn err;\n\t\t\t}\n\t\t\tif (!buffer_mapped(bh)) {\n\t\t\t\tzero_user(page, block_start, blocksize);\n\t\t\t\tset_buffer_uptodate(bh);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\t\tBUG_ON(nr >= MAX_BUF_PER_PAGE);\n\t\tarr[nr++] = bh;\n\t}\n\t/* No io required */\n\tif (!nr)\n\t\tgoto out;\n\n\tfor (i = 0; i < nr; i++) {\n\t\tbh = arr[i];\n\t\tif (!bh_uptodate_or_lock(bh)) {\n\t\t\terr = bh_submit_read(bh);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\t\t}\n\t}\nout:\n\tif (!partial)\n\t\tSetPageUptodate(page);\n\treturn 0;\n}"
  },
  {
    "function_name": "mext_page_double_lock",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/move_extent.c",
    "lines": "133-176",
    "snippet": "static int\nmext_page_double_lock(struct inode *inode1, struct inode *inode2,\n\t\t      pgoff_t index1, pgoff_t index2, struct page *page[2])\n{\n\tstruct address_space *mapping[2];\n\tunsigned fl = AOP_FLAG_NOFS;\n\n\tBUG_ON(!inode1 || !inode2);\n\tif (inode1 < inode2) {\n\t\tmapping[0] = inode1->i_mapping;\n\t\tmapping[1] = inode2->i_mapping;\n\t} else {\n\t\tpgoff_t tmp = index1;\n\t\tindex1 = index2;\n\t\tindex2 = tmp;\n\t\tmapping[0] = inode2->i_mapping;\n\t\tmapping[1] = inode1->i_mapping;\n\t}\n\n\tpage[0] = grab_cache_page_write_begin(mapping[0], index1, fl);\n\tif (!page[0])\n\t\treturn -ENOMEM;\n\n\tpage[1] = grab_cache_page_write_begin(mapping[1], index2, fl);\n\tif (!page[1]) {\n\t\tunlock_page(page[0]);\n\t\tpage_cache_release(page[0]);\n\t\treturn -ENOMEM;\n\t}\n\t/*\n\t * grab_cache_page_write_begin() may not wait on page's writeback if\n\t * BDI not demand that. But it is reasonable to be very conservative\n\t * here and explicitly wait on page's writeback\n\t */\n\twait_on_page_writeback(page[0]);\n\twait_on_page_writeback(page[1]);\n\tif (inode1 > inode2) {\n\t\tstruct page *tmp;\n\t\ttmp = page[0];\n\t\tpage[0] = page[1];\n\t\tpage[1] = tmp;\n\t}\n\treturn 0;\n}",
    "includes": [
      "#include \"ext4_extents.h\"",
      "#include \"ext4.h\"",
      "#include \"ext4_jbd2.h\"",
      "#include <linux/slab.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "wait_on_page_writeback",
          "args": [
            "page[1]"
          ],
          "line": 168
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wait_on_page_writeback",
          "args": [
            "page[0]"
          ],
          "line": 167
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_cache_release",
          "args": [
            "page[0]"
          ],
          "line": 159
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlock_page",
          "args": [
            "page[0]"
          ],
          "line": 158
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_unlock_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/aops.c",
          "lines": "1127-1148",
          "snippet": "static void ocfs2_unlock_pages(struct ocfs2_write_ctxt *wc)\n{\n\tint i;\n\n\t/*\n\t * w_target_locked is only set to true in the page_mkwrite() case.\n\t * The intent is to allow us to lock the target page from write_begin()\n\t * to write_end(). The caller must hold a ref on w_target_page.\n\t */\n\tif (wc->w_target_locked) {\n\t\tBUG_ON(!wc->w_target_page);\n\t\tfor (i = 0; i < wc->w_num_pages; i++) {\n\t\t\tif (wc->w_target_page == wc->w_pages[i]) {\n\t\t\t\twc->w_pages[i] = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tmark_page_accessed(wc->w_target_page);\n\t\tpage_cache_release(wc->w_target_page);\n\t}\n\tocfs2_unlock_and_free_pages(wc->w_pages, wc->w_num_pages);\n}",
          "includes": [
            "#include \"sysfile.h\"",
            "#include \"namei.h\"",
            "#include \"dir.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"symlink.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/mpage.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/swap.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sysfile.h\"\n#include \"namei.h\"\n#include \"dir.h\"\n#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"symlink.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/mpage.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/swap.h>\n#include <asm/byteorder.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic void ocfs2_unlock_pages(struct ocfs2_write_ctxt *wc)\n{\n\tint i;\n\n\t/*\n\t * w_target_locked is only set to true in the page_mkwrite() case.\n\t * The intent is to allow us to lock the target page from write_begin()\n\t * to write_end(). The caller must hold a ref on w_target_page.\n\t */\n\tif (wc->w_target_locked) {\n\t\tBUG_ON(!wc->w_target_page);\n\t\tfor (i = 0; i < wc->w_num_pages; i++) {\n\t\t\tif (wc->w_target_page == wc->w_pages[i]) {\n\t\t\t\twc->w_pages[i] = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tmark_page_accessed(wc->w_target_page);\n\t\tpage_cache_release(wc->w_target_page);\n\t}\n\tocfs2_unlock_and_free_pages(wc->w_pages, wc->w_num_pages);\n}"
        }
      },
      {
        "call_info": {
          "callee": "grab_cache_page_write_begin",
          "args": [
            "mapping[1]",
            "index2",
            "fl"
          ],
          "line": 156
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "grab_cache_page_write_begin",
          "args": [
            "mapping[0]",
            "index1",
            "fl"
          ],
          "line": 152
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!inode1 || !inode2"
          ],
          "line": 140
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ext4_extents.h\"\n#include \"ext4.h\"\n#include \"ext4_jbd2.h\"\n#include <linux/slab.h>\n#include <linux/quotaops.h>\n#include <linux/fs.h>\n\nstatic int\nmext_page_double_lock(struct inode *inode1, struct inode *inode2,\n\t\t      pgoff_t index1, pgoff_t index2, struct page *page[2])\n{\n\tstruct address_space *mapping[2];\n\tunsigned fl = AOP_FLAG_NOFS;\n\n\tBUG_ON(!inode1 || !inode2);\n\tif (inode1 < inode2) {\n\t\tmapping[0] = inode1->i_mapping;\n\t\tmapping[1] = inode2->i_mapping;\n\t} else {\n\t\tpgoff_t tmp = index1;\n\t\tindex1 = index2;\n\t\tindex2 = tmp;\n\t\tmapping[0] = inode2->i_mapping;\n\t\tmapping[1] = inode1->i_mapping;\n\t}\n\n\tpage[0] = grab_cache_page_write_begin(mapping[0], index1, fl);\n\tif (!page[0])\n\t\treturn -ENOMEM;\n\n\tpage[1] = grab_cache_page_write_begin(mapping[1], index2, fl);\n\tif (!page[1]) {\n\t\tunlock_page(page[0]);\n\t\tpage_cache_release(page[0]);\n\t\treturn -ENOMEM;\n\t}\n\t/*\n\t * grab_cache_page_write_begin() may not wait on page's writeback if\n\t * BDI not demand that. But it is reasonable to be very conservative\n\t * here and explicitly wait on page's writeback\n\t */\n\twait_on_page_writeback(page[0]);\n\twait_on_page_writeback(page[1]);\n\tif (inode1 > inode2) {\n\t\tstruct page *tmp;\n\t\ttmp = page[0];\n\t\tpage[0] = page[1];\n\t\tpage[1] = tmp;\n\t}\n\treturn 0;\n}"
  },
  {
    "function_name": "mext_check_coverage",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/move_extent.c",
    "lines": "97-120",
    "snippet": "static int\nmext_check_coverage(struct inode *inode, ext4_lblk_t from, ext4_lblk_t count,\n\t\t    int unwritten, int *err)\n{\n\tstruct ext4_ext_path *path = NULL;\n\tstruct ext4_extent *ext;\n\tint ret = 0;\n\text4_lblk_t last = from + count;\n\twhile (from < last) {\n\t\t*err = get_ext_path(inode, from, &path);\n\t\tif (*err)\n\t\t\tgoto out;\n\t\text = path[ext_depth(inode)].p_ext;\n\t\tif (unwritten != ext4_ext_is_unwritten(ext))\n\t\t\tgoto out;\n\t\tfrom += ext4_ext_get_actual_len(ext);\n\t\text4_ext_drop_refs(path);\n\t}\n\tret = 1;\nout:\n\text4_ext_drop_refs(path);\n\tkfree(path);\n\treturn ret;\n}",
    "includes": [
      "#include \"ext4_extents.h\"",
      "#include \"ext4.h\"",
      "#include \"ext4_jbd2.h\"",
      "#include <linux/slab.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "path"
          ],
          "line": 118
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_ext_drop_refs",
          "args": [
            "path"
          ],
          "line": 117
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_ext_drop_refs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/extents.c",
          "lines": "708-720",
          "snippet": "void ext4_ext_drop_refs(struct ext4_ext_path *path)\n{\n\tint depth, i;\n\n\tif (!path)\n\t\treturn;\n\tdepth = path->p_depth;\n\tfor (i = 0; i <= depth; i++, path++)\n\t\tif (path->p_bh) {\n\t\t\tbrelse(path->p_bh);\n\t\t\tpath->p_bh = NULL;\n\t\t}\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"xattr.h\"",
            "#include \"ext4_extents.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include <linux/fiemap.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/string.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highuid.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/time.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"xattr.h\"\n#include \"ext4_extents.h\"\n#include \"ext4_jbd2.h\"\n#include <linux/fiemap.h>\n#include <asm/uaccess.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/highuid.h>\n#include <linux/jbd2.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n\nvoid ext4_ext_drop_refs(struct ext4_ext_path *path)\n{\n\tint depth, i;\n\n\tif (!path)\n\t\treturn;\n\tdepth = path->p_depth;\n\tfor (i = 0; i <= depth; i++, path++)\n\t\tif (path->p_bh) {\n\t\t\tbrelse(path->p_bh);\n\t\t\tpath->p_bh = NULL;\n\t\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_ext_get_actual_len",
          "args": [
            "ext"
          ],
          "line": 112
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_ext_get_actual_len",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ext4_extents.h",
          "lines": "204-209",
          "snippet": "static inline int ext4_ext_get_actual_len(struct ext4_extent *ext)\n{\n\treturn (le16_to_cpu(ext->ee_len) <= EXT_INIT_MAX_LEN ?\n\t\tle16_to_cpu(ext->ee_len) :\n\t\t(le16_to_cpu(ext->ee_len) - EXT_INIT_MAX_LEN));\n}",
          "includes": [
            "#include \"ext4.h\""
          ],
          "macros_used": [
            "#define EXT_INIT_MAX_LEN\t(1UL << 15)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ext4.h\"\n\n#define EXT_INIT_MAX_LEN\t(1UL << 15)\n\nstatic inline int ext4_ext_get_actual_len(struct ext4_extent *ext)\n{\n\treturn (le16_to_cpu(ext->ee_len) <= EXT_INIT_MAX_LEN ?\n\t\tle16_to_cpu(ext->ee_len) :\n\t\t(le16_to_cpu(ext->ee_len) - EXT_INIT_MAX_LEN));\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_ext_is_unwritten",
          "args": [
            "ext"
          ],
          "line": 110
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_ext_is_unwritten",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ext4_extents.h",
          "lines": "198-202",
          "snippet": "static inline int ext4_ext_is_unwritten(struct ext4_extent *ext)\n{\n\t/* Extent with ee_len of 0x8000 is treated as an initialized extent */\n\treturn (le16_to_cpu(ext->ee_len) > EXT_INIT_MAX_LEN);\n}",
          "includes": [
            "#include \"ext4.h\""
          ],
          "macros_used": [
            "#define EXT_INIT_MAX_LEN\t(1UL << 15)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ext4.h\"\n\n#define EXT_INIT_MAX_LEN\t(1UL << 15)\n\nstatic inline int ext4_ext_is_unwritten(struct ext4_extent *ext)\n{\n\t/* Extent with ee_len of 0x8000 is treated as an initialized extent */\n\treturn (le16_to_cpu(ext->ee_len) > EXT_INIT_MAX_LEN);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext_depth",
          "args": [
            "inode"
          ],
          "line": 109
        },
        "resolved": true,
        "details": {
          "function_name": "ext_depth",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ext4_extents.h",
          "lines": "186-189",
          "snippet": "static inline unsigned short ext_depth(struct inode *inode)\n{\n\treturn le16_to_cpu(ext_inode_hdr(inode)->eh_depth);\n}",
          "includes": [
            "#include \"ext4.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ext4.h\"\n\nstatic inline unsigned short ext_depth(struct inode *inode)\n{\n\treturn le16_to_cpu(ext_inode_hdr(inode)->eh_depth);\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_ext_path",
          "args": [
            "inode",
            "from",
            "&path"
          ],
          "line": 106
        },
        "resolved": true,
        "details": {
          "function_name": "get_ext_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/move_extent.c",
          "lines": "33-50",
          "snippet": "static inline int\nget_ext_path(struct inode *inode, ext4_lblk_t lblock,\n\t\tstruct ext4_ext_path **ppath)\n{\n\tstruct ext4_ext_path *path;\n\n\tpath = ext4_find_extent(inode, lblock, ppath, EXT4_EX_NOCACHE);\n\tif (IS_ERR(path))\n\t\treturn PTR_ERR(path);\n\tif (path[ext_depth(inode)].p_ext == NULL) {\n\t\text4_ext_drop_refs(path);\n\t\tkfree(path);\n\t\t*ppath = NULL;\n\t\treturn -ENODATA;\n\t}\n\t*ppath = path;\n\treturn 0;\n}",
          "includes": [
            "#include \"ext4_extents.h\"",
            "#include \"ext4.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include <linux/slab.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ext4_extents.h\"\n#include \"ext4.h\"\n#include \"ext4_jbd2.h\"\n#include <linux/slab.h>\n#include <linux/quotaops.h>\n#include <linux/fs.h>\n\nstatic inline int\nget_ext_path(struct inode *inode, ext4_lblk_t lblock,\n\t\tstruct ext4_ext_path **ppath)\n{\n\tstruct ext4_ext_path *path;\n\n\tpath = ext4_find_extent(inode, lblock, ppath, EXT4_EX_NOCACHE);\n\tif (IS_ERR(path))\n\t\treturn PTR_ERR(path);\n\tif (path[ext_depth(inode)].p_ext == NULL) {\n\t\text4_ext_drop_refs(path);\n\t\tkfree(path);\n\t\t*ppath = NULL;\n\t\treturn -ENODATA;\n\t}\n\t*ppath = path;\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ext4_extents.h\"\n#include \"ext4.h\"\n#include \"ext4_jbd2.h\"\n#include <linux/slab.h>\n#include <linux/quotaops.h>\n#include <linux/fs.h>\n\nstatic int\nmext_check_coverage(struct inode *inode, ext4_lblk_t from, ext4_lblk_t count,\n\t\t    int unwritten, int *err)\n{\n\tstruct ext4_ext_path *path = NULL;\n\tstruct ext4_extent *ext;\n\tint ret = 0;\n\text4_lblk_t last = from + count;\n\twhile (from < last) {\n\t\t*err = get_ext_path(inode, from, &path);\n\t\tif (*err)\n\t\t\tgoto out;\n\t\text = path[ext_depth(inode)].p_ext;\n\t\tif (unwritten != ext4_ext_is_unwritten(ext))\n\t\t\tgoto out;\n\t\tfrom += ext4_ext_get_actual_len(ext);\n\t\text4_ext_drop_refs(path);\n\t}\n\tret = 1;\nout:\n\text4_ext_drop_refs(path);\n\tkfree(path);\n\treturn ret;\n}"
  },
  {
    "function_name": "ext4_double_up_write_data_sem",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/move_extent.c",
    "lines": "78-84",
    "snippet": "void\next4_double_up_write_data_sem(struct inode *orig_inode,\n\t\t\t      struct inode *donor_inode)\n{\n\tup_write(&EXT4_I(orig_inode)->i_data_sem);\n\tup_write(&EXT4_I(donor_inode)->i_data_sem);\n}",
    "includes": [
      "#include \"ext4_extents.h\"",
      "#include \"ext4.h\"",
      "#include \"ext4_jbd2.h\"",
      "#include <linux/slab.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "up_write",
          "args": [
            "&EXT4_I(donor_inode)->i_data_sem"
          ],
          "line": 83
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXT4_I",
          "args": [
            "donor_inode"
          ],
          "line": 83
        },
        "resolved": true,
        "details": {
          "function_name": "EXT4_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ext4.h",
          "lines": "1360-1363",
          "snippet": "static inline struct ext4_inode_info *EXT4_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ext4_inode_info, vfs_inode);\n}",
          "includes": [
            "#include \"extents_status.h\"",
            "#include <linux/compat.h>",
            "#include <linux/falloc.h>",
            "#include <crypto/hash.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/wait.h>",
            "#include <linux/timer.h>",
            "#include <linux/mutex.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/quota.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extents_status.h\"\n#include <linux/compat.h>\n#include <linux/falloc.h>\n#include <crypto/hash.h>\n#include <linux/ratelimit.h>\n#include <linux/percpu_counter.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/wait.h>\n#include <linux/timer.h>\n#include <linux/mutex.h>\n#include <linux/seqlock.h>\n#include <linux/rbtree.h>\n#include <linux/rwsem.h>\n#include <linux/quota.h>\n#include <linux/jbd2.h>\n#include <linux/magic.h>\n#include <linux/blkdev.h>\n#include <linux/types.h>\n\nstatic inline struct ext4_inode_info *EXT4_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ext4_inode_info, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "up_write",
          "args": [
            "&EXT4_I(orig_inode)->i_data_sem"
          ],
          "line": 82
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ext4_extents.h\"\n#include \"ext4.h\"\n#include \"ext4_jbd2.h\"\n#include <linux/slab.h>\n#include <linux/quotaops.h>\n#include <linux/fs.h>\n\nvoid\next4_double_up_write_data_sem(struct inode *orig_inode,\n\t\t\t      struct inode *donor_inode)\n{\n\tup_write(&EXT4_I(orig_inode)->i_data_sem);\n\tup_write(&EXT4_I(donor_inode)->i_data_sem);\n}"
  },
  {
    "function_name": "ext4_double_down_write_data_sem",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/move_extent.c",
    "lines": "58-69",
    "snippet": "void\next4_double_down_write_data_sem(struct inode *first, struct inode *second)\n{\n\tif (first < second) {\n\t\tdown_write(&EXT4_I(first)->i_data_sem);\n\t\tdown_write_nested(&EXT4_I(second)->i_data_sem, SINGLE_DEPTH_NESTING);\n\t} else {\n\t\tdown_write(&EXT4_I(second)->i_data_sem);\n\t\tdown_write_nested(&EXT4_I(first)->i_data_sem, SINGLE_DEPTH_NESTING);\n\n\t}\n}",
    "includes": [
      "#include \"ext4_extents.h\"",
      "#include \"ext4.h\"",
      "#include \"ext4_jbd2.h\"",
      "#include <linux/slab.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "down_write_nested",
          "args": [
            "&EXT4_I(first)->i_data_sem",
            "SINGLE_DEPTH_NESTING"
          ],
          "line": 66
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXT4_I",
          "args": [
            "first"
          ],
          "line": 66
        },
        "resolved": true,
        "details": {
          "function_name": "EXT4_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ext4.h",
          "lines": "1360-1363",
          "snippet": "static inline struct ext4_inode_info *EXT4_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ext4_inode_info, vfs_inode);\n}",
          "includes": [
            "#include \"extents_status.h\"",
            "#include <linux/compat.h>",
            "#include <linux/falloc.h>",
            "#include <crypto/hash.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/wait.h>",
            "#include <linux/timer.h>",
            "#include <linux/mutex.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/quota.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extents_status.h\"\n#include <linux/compat.h>\n#include <linux/falloc.h>\n#include <crypto/hash.h>\n#include <linux/ratelimit.h>\n#include <linux/percpu_counter.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/wait.h>\n#include <linux/timer.h>\n#include <linux/mutex.h>\n#include <linux/seqlock.h>\n#include <linux/rbtree.h>\n#include <linux/rwsem.h>\n#include <linux/quota.h>\n#include <linux/jbd2.h>\n#include <linux/magic.h>\n#include <linux/blkdev.h>\n#include <linux/types.h>\n\nstatic inline struct ext4_inode_info *EXT4_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ext4_inode_info, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "down_write",
          "args": [
            "&EXT4_I(second)->i_data_sem"
          ],
          "line": 65
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "down_write_nested",
          "args": [
            "&EXT4_I(second)->i_data_sem",
            "SINGLE_DEPTH_NESTING"
          ],
          "line": 63
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "down_write",
          "args": [
            "&EXT4_I(first)->i_data_sem"
          ],
          "line": 62
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ext4_extents.h\"\n#include \"ext4.h\"\n#include \"ext4_jbd2.h\"\n#include <linux/slab.h>\n#include <linux/quotaops.h>\n#include <linux/fs.h>\n\nvoid\next4_double_down_write_data_sem(struct inode *first, struct inode *second)\n{\n\tif (first < second) {\n\t\tdown_write(&EXT4_I(first)->i_data_sem);\n\t\tdown_write_nested(&EXT4_I(second)->i_data_sem, SINGLE_DEPTH_NESTING);\n\t} else {\n\t\tdown_write(&EXT4_I(second)->i_data_sem);\n\t\tdown_write_nested(&EXT4_I(first)->i_data_sem, SINGLE_DEPTH_NESTING);\n\n\t}\n}"
  },
  {
    "function_name": "get_ext_path",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/move_extent.c",
    "lines": "33-50",
    "snippet": "static inline int\nget_ext_path(struct inode *inode, ext4_lblk_t lblock,\n\t\tstruct ext4_ext_path **ppath)\n{\n\tstruct ext4_ext_path *path;\n\n\tpath = ext4_find_extent(inode, lblock, ppath, EXT4_EX_NOCACHE);\n\tif (IS_ERR(path))\n\t\treturn PTR_ERR(path);\n\tif (path[ext_depth(inode)].p_ext == NULL) {\n\t\text4_ext_drop_refs(path);\n\t\tkfree(path);\n\t\t*ppath = NULL;\n\t\treturn -ENODATA;\n\t}\n\t*ppath = path;\n\treturn 0;\n}",
    "includes": [
      "#include \"ext4_extents.h\"",
      "#include \"ext4.h\"",
      "#include \"ext4_jbd2.h\"",
      "#include <linux/slab.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "path"
          ],
          "line": 44
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_ext_drop_refs",
          "args": [
            "path"
          ],
          "line": 43
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_ext_drop_refs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/extents.c",
          "lines": "708-720",
          "snippet": "void ext4_ext_drop_refs(struct ext4_ext_path *path)\n{\n\tint depth, i;\n\n\tif (!path)\n\t\treturn;\n\tdepth = path->p_depth;\n\tfor (i = 0; i <= depth; i++, path++)\n\t\tif (path->p_bh) {\n\t\t\tbrelse(path->p_bh);\n\t\t\tpath->p_bh = NULL;\n\t\t}\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"xattr.h\"",
            "#include \"ext4_extents.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include <linux/fiemap.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/string.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highuid.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/time.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"xattr.h\"\n#include \"ext4_extents.h\"\n#include \"ext4_jbd2.h\"\n#include <linux/fiemap.h>\n#include <asm/uaccess.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/highuid.h>\n#include <linux/jbd2.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n\nvoid ext4_ext_drop_refs(struct ext4_ext_path *path)\n{\n\tint depth, i;\n\n\tif (!path)\n\t\treturn;\n\tdepth = path->p_depth;\n\tfor (i = 0; i <= depth; i++, path++)\n\t\tif (path->p_bh) {\n\t\t\tbrelse(path->p_bh);\n\t\t\tpath->p_bh = NULL;\n\t\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext_depth",
          "args": [
            "inode"
          ],
          "line": 42
        },
        "resolved": true,
        "details": {
          "function_name": "ext_depth",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ext4_extents.h",
          "lines": "186-189",
          "snippet": "static inline unsigned short ext_depth(struct inode *inode)\n{\n\treturn le16_to_cpu(ext_inode_hdr(inode)->eh_depth);\n}",
          "includes": [
            "#include \"ext4.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ext4.h\"\n\nstatic inline unsigned short ext_depth(struct inode *inode)\n{\n\treturn le16_to_cpu(ext_inode_hdr(inode)->eh_depth);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "path"
          ],
          "line": 41
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "path"
          ],
          "line": 40
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_find_extent",
          "args": [
            "inode",
            "lblock",
            "ppath",
            "EXT4_EX_NOCACHE"
          ],
          "line": 39
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_find_extent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/extents.c",
          "lines": "857-939",
          "snippet": "struct ext4_ext_path *\next4_find_extent(struct inode *inode, ext4_lblk_t block,\n\t\t struct ext4_ext_path **orig_path, int flags)\n{\n\tstruct ext4_extent_header *eh;\n\tstruct buffer_head *bh;\n\tstruct ext4_ext_path *path = orig_path ? *orig_path : NULL;\n\tshort int depth, i, ppos = 0;\n\tint ret;\n\n\teh = ext_inode_hdr(inode);\n\tdepth = ext_depth(inode);\n\n\tif (path) {\n\t\text4_ext_drop_refs(path);\n\t\tif (depth > path[0].p_maxdepth) {\n\t\t\tkfree(path);\n\t\t\t*orig_path = path = NULL;\n\t\t}\n\t}\n\tif (!path) {\n\t\t/* account possible depth increase */\n\t\tpath = kzalloc(sizeof(struct ext4_ext_path) * (depth + 2),\n\t\t\t\tGFP_NOFS);\n\t\tif (unlikely(!path))\n\t\t\treturn ERR_PTR(-ENOMEM);\n\t\tpath[0].p_maxdepth = depth + 1;\n\t}\n\tpath[0].p_hdr = eh;\n\tpath[0].p_bh = NULL;\n\n\ti = depth;\n\t/* walk through the tree */\n\twhile (i) {\n\t\text_debug(\"depth %d: num %d, max %d\\n\",\n\t\t\t  ppos, le16_to_cpu(eh->eh_entries), le16_to_cpu(eh->eh_max));\n\n\t\text4_ext_binsearch_idx(inode, path + ppos, block);\n\t\tpath[ppos].p_block = ext4_idx_pblock(path[ppos].p_idx);\n\t\tpath[ppos].p_depth = i;\n\t\tpath[ppos].p_ext = NULL;\n\n\t\tbh = read_extent_tree_block(inode, path[ppos].p_block, --i,\n\t\t\t\t\t    flags);\n\t\tif (unlikely(IS_ERR(bh))) {\n\t\t\tret = PTR_ERR(bh);\n\t\t\tgoto err;\n\t\t}\n\n\t\teh = ext_block_hdr(bh);\n\t\tppos++;\n\t\tif (unlikely(ppos > depth)) {\n\t\t\tput_bh(bh);\n\t\t\tEXT4_ERROR_INODE(inode,\n\t\t\t\t\t \"ppos %d > depth %d\", ppos, depth);\n\t\t\tret = -EIO;\n\t\t\tgoto err;\n\t\t}\n\t\tpath[ppos].p_bh = bh;\n\t\tpath[ppos].p_hdr = eh;\n\t}\n\n\tpath[ppos].p_depth = i;\n\tpath[ppos].p_ext = NULL;\n\tpath[ppos].p_idx = NULL;\n\n\t/* find extent */\n\text4_ext_binsearch(inode, path + ppos, block);\n\t/* if not an empty leaf */\n\tif (path[ppos].p_ext)\n\t\tpath[ppos].p_block = ext4_ext_pblock(path[ppos].p_ext);\n\n\text4_ext_show_path(inode, path);\n\n\treturn path;\n\nerr:\n\text4_ext_drop_refs(path);\n\tkfree(path);\n\tif (orig_path)\n\t\t*orig_path = NULL;\n\treturn ERR_PTR(ret);\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"xattr.h\"",
            "#include \"ext4_extents.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include <linux/fiemap.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/string.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highuid.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/time.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ext4_split_extent(handle_t *handle,\n\t\t\t\tstruct inode *inode,\n\t\t\t\tstruct ext4_ext_path **ppath,\n\t\t\t\tstruct ext4_map_blocks *map,\n\t\t\t\tint split_flag,\n\t\t\t\tint flags);",
            "static int ext4_split_extent_at(handle_t *handle,\n\t\t\t     struct inode *inode,\n\t\t\t     struct ext4_ext_path **ppath,\n\t\t\t     ext4_lblk_t split,\n\t\t\t     int split_flag,\n\t\t\t     int flags);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"xattr.h\"\n#include \"ext4_extents.h\"\n#include \"ext4_jbd2.h\"\n#include <linux/fiemap.h>\n#include <asm/uaccess.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/highuid.h>\n#include <linux/jbd2.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n\nstatic int ext4_split_extent(handle_t *handle,\n\t\t\t\tstruct inode *inode,\n\t\t\t\tstruct ext4_ext_path **ppath,\n\t\t\t\tstruct ext4_map_blocks *map,\n\t\t\t\tint split_flag,\n\t\t\t\tint flags);\nstatic int ext4_split_extent_at(handle_t *handle,\n\t\t\t     struct inode *inode,\n\t\t\t     struct ext4_ext_path **ppath,\n\t\t\t     ext4_lblk_t split,\n\t\t\t     int split_flag,\n\t\t\t     int flags);\n\nstruct ext4_ext_path *\next4_find_extent(struct inode *inode, ext4_lblk_t block,\n\t\t struct ext4_ext_path **orig_path, int flags)\n{\n\tstruct ext4_extent_header *eh;\n\tstruct buffer_head *bh;\n\tstruct ext4_ext_path *path = orig_path ? *orig_path : NULL;\n\tshort int depth, i, ppos = 0;\n\tint ret;\n\n\teh = ext_inode_hdr(inode);\n\tdepth = ext_depth(inode);\n\n\tif (path) {\n\t\text4_ext_drop_refs(path);\n\t\tif (depth > path[0].p_maxdepth) {\n\t\t\tkfree(path);\n\t\t\t*orig_path = path = NULL;\n\t\t}\n\t}\n\tif (!path) {\n\t\t/* account possible depth increase */\n\t\tpath = kzalloc(sizeof(struct ext4_ext_path) * (depth + 2),\n\t\t\t\tGFP_NOFS);\n\t\tif (unlikely(!path))\n\t\t\treturn ERR_PTR(-ENOMEM);\n\t\tpath[0].p_maxdepth = depth + 1;\n\t}\n\tpath[0].p_hdr = eh;\n\tpath[0].p_bh = NULL;\n\n\ti = depth;\n\t/* walk through the tree */\n\twhile (i) {\n\t\text_debug(\"depth %d: num %d, max %d\\n\",\n\t\t\t  ppos, le16_to_cpu(eh->eh_entries), le16_to_cpu(eh->eh_max));\n\n\t\text4_ext_binsearch_idx(inode, path + ppos, block);\n\t\tpath[ppos].p_block = ext4_idx_pblock(path[ppos].p_idx);\n\t\tpath[ppos].p_depth = i;\n\t\tpath[ppos].p_ext = NULL;\n\n\t\tbh = read_extent_tree_block(inode, path[ppos].p_block, --i,\n\t\t\t\t\t    flags);\n\t\tif (unlikely(IS_ERR(bh))) {\n\t\t\tret = PTR_ERR(bh);\n\t\t\tgoto err;\n\t\t}\n\n\t\teh = ext_block_hdr(bh);\n\t\tppos++;\n\t\tif (unlikely(ppos > depth)) {\n\t\t\tput_bh(bh);\n\t\t\tEXT4_ERROR_INODE(inode,\n\t\t\t\t\t \"ppos %d > depth %d\", ppos, depth);\n\t\t\tret = -EIO;\n\t\t\tgoto err;\n\t\t}\n\t\tpath[ppos].p_bh = bh;\n\t\tpath[ppos].p_hdr = eh;\n\t}\n\n\tpath[ppos].p_depth = i;\n\tpath[ppos].p_ext = NULL;\n\tpath[ppos].p_idx = NULL;\n\n\t/* find extent */\n\text4_ext_binsearch(inode, path + ppos, block);\n\t/* if not an empty leaf */\n\tif (path[ppos].p_ext)\n\t\tpath[ppos].p_block = ext4_ext_pblock(path[ppos].p_ext);\n\n\text4_ext_show_path(inode, path);\n\n\treturn path;\n\nerr:\n\text4_ext_drop_refs(path);\n\tkfree(path);\n\tif (orig_path)\n\t\t*orig_path = NULL;\n\treturn ERR_PTR(ret);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ext4_extents.h\"\n#include \"ext4.h\"\n#include \"ext4_jbd2.h\"\n#include <linux/slab.h>\n#include <linux/quotaops.h>\n#include <linux/fs.h>\n\nstatic inline int\nget_ext_path(struct inode *inode, ext4_lblk_t lblock,\n\t\tstruct ext4_ext_path **ppath)\n{\n\tstruct ext4_ext_path *path;\n\n\tpath = ext4_find_extent(inode, lblock, ppath, EXT4_EX_NOCACHE);\n\tif (IS_ERR(path))\n\t\treturn PTR_ERR(path);\n\tif (path[ext_depth(inode)].p_ext == NULL) {\n\t\text4_ext_drop_refs(path);\n\t\tkfree(path);\n\t\t*ppath = NULL;\n\t\treturn -ENODATA;\n\t}\n\t*ppath = path;\n\treturn 0;\n}"
  }
]