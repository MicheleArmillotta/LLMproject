[
  {
    "function_name": "ocfs2_fh_to_parent",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/export.c",
    "lines": "252-264",
    "snippet": "static struct dentry *ocfs2_fh_to_parent(struct super_block *sb,\n\t\tstruct fid *fid, int fh_len, int fh_type)\n{\n\tstruct ocfs2_inode_handle parent;\n\n\tif (fh_type != 2 || fh_len < 6)\n\t\treturn NULL;\n\n\tparent.ih_blkno = (u64)le32_to_cpu(fid->raw[3]) << 32;\n\tparent.ih_blkno |= (u64)le32_to_cpu(fid->raw[4]);\n\tparent.ih_generation = le32_to_cpu(fid->raw[5]);\n\treturn ocfs2_get_dentry(sb, &parent);\n}",
    "includes": [
      "#include \"ocfs2_trace.h\"",
      "#include \"suballoc.h\"",
      "#include \"buffer_head_io.h\"",
      "#include \"inode.h\"",
      "#include \"export.h\"",
      "#include \"dcache.h\"",
      "#include \"dlmglue.h\"",
      "#include \"dir.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ocfs2_get_dentry",
          "args": [
            "sb",
            "&parent"
          ],
          "line": 263
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_get_dentry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/export.c",
          "lines": "50-143",
          "snippet": "static struct dentry *ocfs2_get_dentry(struct super_block *sb,\n\t\tstruct ocfs2_inode_handle *handle)\n{\n\tstruct inode *inode;\n\tstruct ocfs2_super *osb = OCFS2_SB(sb);\n\tu64 blkno = handle->ih_blkno;\n\tint status, set;\n\tstruct dentry *result;\n\n\ttrace_ocfs2_get_dentry_begin(sb, handle, (unsigned long long)blkno);\n\n\tif (blkno == 0) {\n\t\tresult = ERR_PTR(-ESTALE);\n\t\tgoto bail;\n\t}\n\n\tinode = ocfs2_ilookup(sb, blkno);\n\t/*\n\t * If the inode exists in memory, we only need to check it's\n\t * generation number\n\t */\n\tif (inode)\n\t\tgoto check_gen;\n\n\t/*\n\t * This will synchronize us against ocfs2_delete_inode() on\n\t * all nodes\n\t */\n\tstatus = ocfs2_nfs_sync_lock(osb, 1);\n\tif (status < 0) {\n\t\tmlog(ML_ERROR, \"getting nfs sync lock(EX) failed %d\\n\", status);\n\t\tgoto check_err;\n\t}\n\n\tstatus = ocfs2_test_inode_bit(osb, blkno, &set);\n\ttrace_ocfs2_get_dentry_test_bit(status, set);\n\tif (status < 0) {\n\t\tif (status == -EINVAL) {\n\t\t\t/*\n\t\t\t * The blkno NFS gave us doesn't even show up\n\t\t\t * as an inode, we return -ESTALE to be\n\t\t\t * nice\n\t\t\t */\n\t\t\tstatus = -ESTALE;\n\t\t} else\n\t\t\tmlog(ML_ERROR, \"test inode bit failed %d\\n\", status);\n\t\tgoto unlock_nfs_sync;\n\t}\n\n\t/* If the inode allocator bit is clear, this inode must be stale */\n\tif (!set) {\n\t\tstatus = -ESTALE;\n\t\tgoto unlock_nfs_sync;\n\t}\n\n\tinode = ocfs2_iget(osb, blkno, 0, 0);\n\nunlock_nfs_sync:\n\tocfs2_nfs_sync_unlock(osb, 1);\n\ncheck_err:\n\tif (status < 0) {\n\t\tif (status == -ESTALE) {\n\t\t\ttrace_ocfs2_get_dentry_stale((unsigned long long)blkno,\n\t\t\t\t\t\t     handle->ih_generation);\n\t\t}\n\t\tresult = ERR_PTR(status);\n\t\tgoto bail;\n\t}\n\n\tif (IS_ERR(inode)) {\n\t\tmlog_errno(PTR_ERR(inode));\n\t\tresult = (void *)inode;\n\t\tgoto bail;\n\t}\n\ncheck_gen:\n\tif (handle->ih_generation != inode->i_generation) {\n\t\tiput(inode);\n\t\ttrace_ocfs2_get_dentry_generation((unsigned long long)blkno,\n\t\t\t\t\t\t  handle->ih_generation,\n\t\t\t\t\t\t  inode->i_generation);\n\t\tresult = ERR_PTR(-ESTALE);\n\t\tgoto bail;\n\t}\n\n\tresult = d_obtain_alias(inode);\n\tif (IS_ERR(result))\n\t\tmlog_errno(PTR_ERR(result));\n\nbail:\n\ttrace_ocfs2_get_dentry_end(result);\n\treturn result;\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"suballoc.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"inode.h\"",
            "#include \"export.h\"",
            "#include \"dcache.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"suballoc.h\"\n#include \"buffer_head_io.h\"\n#include \"inode.h\"\n#include \"export.h\"\n#include \"dcache.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic struct dentry *ocfs2_get_dentry(struct super_block *sb,\n\t\tstruct ocfs2_inode_handle *handle)\n{\n\tstruct inode *inode;\n\tstruct ocfs2_super *osb = OCFS2_SB(sb);\n\tu64 blkno = handle->ih_blkno;\n\tint status, set;\n\tstruct dentry *result;\n\n\ttrace_ocfs2_get_dentry_begin(sb, handle, (unsigned long long)blkno);\n\n\tif (blkno == 0) {\n\t\tresult = ERR_PTR(-ESTALE);\n\t\tgoto bail;\n\t}\n\n\tinode = ocfs2_ilookup(sb, blkno);\n\t/*\n\t * If the inode exists in memory, we only need to check it's\n\t * generation number\n\t */\n\tif (inode)\n\t\tgoto check_gen;\n\n\t/*\n\t * This will synchronize us against ocfs2_delete_inode() on\n\t * all nodes\n\t */\n\tstatus = ocfs2_nfs_sync_lock(osb, 1);\n\tif (status < 0) {\n\t\tmlog(ML_ERROR, \"getting nfs sync lock(EX) failed %d\\n\", status);\n\t\tgoto check_err;\n\t}\n\n\tstatus = ocfs2_test_inode_bit(osb, blkno, &set);\n\ttrace_ocfs2_get_dentry_test_bit(status, set);\n\tif (status < 0) {\n\t\tif (status == -EINVAL) {\n\t\t\t/*\n\t\t\t * The blkno NFS gave us doesn't even show up\n\t\t\t * as an inode, we return -ESTALE to be\n\t\t\t * nice\n\t\t\t */\n\t\t\tstatus = -ESTALE;\n\t\t} else\n\t\t\tmlog(ML_ERROR, \"test inode bit failed %d\\n\", status);\n\t\tgoto unlock_nfs_sync;\n\t}\n\n\t/* If the inode allocator bit is clear, this inode must be stale */\n\tif (!set) {\n\t\tstatus = -ESTALE;\n\t\tgoto unlock_nfs_sync;\n\t}\n\n\tinode = ocfs2_iget(osb, blkno, 0, 0);\n\nunlock_nfs_sync:\n\tocfs2_nfs_sync_unlock(osb, 1);\n\ncheck_err:\n\tif (status < 0) {\n\t\tif (status == -ESTALE) {\n\t\t\ttrace_ocfs2_get_dentry_stale((unsigned long long)blkno,\n\t\t\t\t\t\t     handle->ih_generation);\n\t\t}\n\t\tresult = ERR_PTR(status);\n\t\tgoto bail;\n\t}\n\n\tif (IS_ERR(inode)) {\n\t\tmlog_errno(PTR_ERR(inode));\n\t\tresult = (void *)inode;\n\t\tgoto bail;\n\t}\n\ncheck_gen:\n\tif (handle->ih_generation != inode->i_generation) {\n\t\tiput(inode);\n\t\ttrace_ocfs2_get_dentry_generation((unsigned long long)blkno,\n\t\t\t\t\t\t  handle->ih_generation,\n\t\t\t\t\t\t  inode->i_generation);\n\t\tresult = ERR_PTR(-ESTALE);\n\t\tgoto bail;\n\t}\n\n\tresult = d_obtain_alias(inode);\n\tif (IS_ERR(result))\n\t\tmlog_errno(PTR_ERR(result));\n\nbail:\n\ttrace_ocfs2_get_dentry_end(result);\n\treturn result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "fid->raw[5]"
          ],
          "line": 262
        },
        "resolved": true,
        "details": {
          "function_name": "sle32_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "53-56",
          "snippet": "static inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"suballoc.h\"\n#include \"buffer_head_io.h\"\n#include \"inode.h\"\n#include \"export.h\"\n#include \"dcache.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic struct dentry *ocfs2_fh_to_parent(struct super_block *sb,\n\t\tstruct fid *fid, int fh_len, int fh_type)\n{\n\tstruct ocfs2_inode_handle parent;\n\n\tif (fh_type != 2 || fh_len < 6)\n\t\treturn NULL;\n\n\tparent.ih_blkno = (u64)le32_to_cpu(fid->raw[3]) << 32;\n\tparent.ih_blkno |= (u64)le32_to_cpu(fid->raw[4]);\n\tparent.ih_generation = le32_to_cpu(fid->raw[5]);\n\treturn ocfs2_get_dentry(sb, &parent);\n}"
  },
  {
    "function_name": "ocfs2_fh_to_dentry",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/export.c",
    "lines": "238-250",
    "snippet": "static struct dentry *ocfs2_fh_to_dentry(struct super_block *sb,\n\t\tstruct fid *fid, int fh_len, int fh_type)\n{\n\tstruct ocfs2_inode_handle handle;\n\n\tif (fh_len < 3 || fh_type > 2)\n\t\treturn NULL;\n\n\thandle.ih_blkno = (u64)le32_to_cpu(fid->raw[0]) << 32;\n\thandle.ih_blkno |= (u64)le32_to_cpu(fid->raw[1]);\n\thandle.ih_generation = le32_to_cpu(fid->raw[2]);\n\treturn ocfs2_get_dentry(sb, &handle);\n}",
    "includes": [
      "#include \"ocfs2_trace.h\"",
      "#include \"suballoc.h\"",
      "#include \"buffer_head_io.h\"",
      "#include \"inode.h\"",
      "#include \"export.h\"",
      "#include \"dcache.h\"",
      "#include \"dlmglue.h\"",
      "#include \"dir.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ocfs2_get_dentry",
          "args": [
            "sb",
            "&handle"
          ],
          "line": 249
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_get_dentry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/export.c",
          "lines": "50-143",
          "snippet": "static struct dentry *ocfs2_get_dentry(struct super_block *sb,\n\t\tstruct ocfs2_inode_handle *handle)\n{\n\tstruct inode *inode;\n\tstruct ocfs2_super *osb = OCFS2_SB(sb);\n\tu64 blkno = handle->ih_blkno;\n\tint status, set;\n\tstruct dentry *result;\n\n\ttrace_ocfs2_get_dentry_begin(sb, handle, (unsigned long long)blkno);\n\n\tif (blkno == 0) {\n\t\tresult = ERR_PTR(-ESTALE);\n\t\tgoto bail;\n\t}\n\n\tinode = ocfs2_ilookup(sb, blkno);\n\t/*\n\t * If the inode exists in memory, we only need to check it's\n\t * generation number\n\t */\n\tif (inode)\n\t\tgoto check_gen;\n\n\t/*\n\t * This will synchronize us against ocfs2_delete_inode() on\n\t * all nodes\n\t */\n\tstatus = ocfs2_nfs_sync_lock(osb, 1);\n\tif (status < 0) {\n\t\tmlog(ML_ERROR, \"getting nfs sync lock(EX) failed %d\\n\", status);\n\t\tgoto check_err;\n\t}\n\n\tstatus = ocfs2_test_inode_bit(osb, blkno, &set);\n\ttrace_ocfs2_get_dentry_test_bit(status, set);\n\tif (status < 0) {\n\t\tif (status == -EINVAL) {\n\t\t\t/*\n\t\t\t * The blkno NFS gave us doesn't even show up\n\t\t\t * as an inode, we return -ESTALE to be\n\t\t\t * nice\n\t\t\t */\n\t\t\tstatus = -ESTALE;\n\t\t} else\n\t\t\tmlog(ML_ERROR, \"test inode bit failed %d\\n\", status);\n\t\tgoto unlock_nfs_sync;\n\t}\n\n\t/* If the inode allocator bit is clear, this inode must be stale */\n\tif (!set) {\n\t\tstatus = -ESTALE;\n\t\tgoto unlock_nfs_sync;\n\t}\n\n\tinode = ocfs2_iget(osb, blkno, 0, 0);\n\nunlock_nfs_sync:\n\tocfs2_nfs_sync_unlock(osb, 1);\n\ncheck_err:\n\tif (status < 0) {\n\t\tif (status == -ESTALE) {\n\t\t\ttrace_ocfs2_get_dentry_stale((unsigned long long)blkno,\n\t\t\t\t\t\t     handle->ih_generation);\n\t\t}\n\t\tresult = ERR_PTR(status);\n\t\tgoto bail;\n\t}\n\n\tif (IS_ERR(inode)) {\n\t\tmlog_errno(PTR_ERR(inode));\n\t\tresult = (void *)inode;\n\t\tgoto bail;\n\t}\n\ncheck_gen:\n\tif (handle->ih_generation != inode->i_generation) {\n\t\tiput(inode);\n\t\ttrace_ocfs2_get_dentry_generation((unsigned long long)blkno,\n\t\t\t\t\t\t  handle->ih_generation,\n\t\t\t\t\t\t  inode->i_generation);\n\t\tresult = ERR_PTR(-ESTALE);\n\t\tgoto bail;\n\t}\n\n\tresult = d_obtain_alias(inode);\n\tif (IS_ERR(result))\n\t\tmlog_errno(PTR_ERR(result));\n\nbail:\n\ttrace_ocfs2_get_dentry_end(result);\n\treturn result;\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"suballoc.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"inode.h\"",
            "#include \"export.h\"",
            "#include \"dcache.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"suballoc.h\"\n#include \"buffer_head_io.h\"\n#include \"inode.h\"\n#include \"export.h\"\n#include \"dcache.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic struct dentry *ocfs2_get_dentry(struct super_block *sb,\n\t\tstruct ocfs2_inode_handle *handle)\n{\n\tstruct inode *inode;\n\tstruct ocfs2_super *osb = OCFS2_SB(sb);\n\tu64 blkno = handle->ih_blkno;\n\tint status, set;\n\tstruct dentry *result;\n\n\ttrace_ocfs2_get_dentry_begin(sb, handle, (unsigned long long)blkno);\n\n\tif (blkno == 0) {\n\t\tresult = ERR_PTR(-ESTALE);\n\t\tgoto bail;\n\t}\n\n\tinode = ocfs2_ilookup(sb, blkno);\n\t/*\n\t * If the inode exists in memory, we only need to check it's\n\t * generation number\n\t */\n\tif (inode)\n\t\tgoto check_gen;\n\n\t/*\n\t * This will synchronize us against ocfs2_delete_inode() on\n\t * all nodes\n\t */\n\tstatus = ocfs2_nfs_sync_lock(osb, 1);\n\tif (status < 0) {\n\t\tmlog(ML_ERROR, \"getting nfs sync lock(EX) failed %d\\n\", status);\n\t\tgoto check_err;\n\t}\n\n\tstatus = ocfs2_test_inode_bit(osb, blkno, &set);\n\ttrace_ocfs2_get_dentry_test_bit(status, set);\n\tif (status < 0) {\n\t\tif (status == -EINVAL) {\n\t\t\t/*\n\t\t\t * The blkno NFS gave us doesn't even show up\n\t\t\t * as an inode, we return -ESTALE to be\n\t\t\t * nice\n\t\t\t */\n\t\t\tstatus = -ESTALE;\n\t\t} else\n\t\t\tmlog(ML_ERROR, \"test inode bit failed %d\\n\", status);\n\t\tgoto unlock_nfs_sync;\n\t}\n\n\t/* If the inode allocator bit is clear, this inode must be stale */\n\tif (!set) {\n\t\tstatus = -ESTALE;\n\t\tgoto unlock_nfs_sync;\n\t}\n\n\tinode = ocfs2_iget(osb, blkno, 0, 0);\n\nunlock_nfs_sync:\n\tocfs2_nfs_sync_unlock(osb, 1);\n\ncheck_err:\n\tif (status < 0) {\n\t\tif (status == -ESTALE) {\n\t\t\ttrace_ocfs2_get_dentry_stale((unsigned long long)blkno,\n\t\t\t\t\t\t     handle->ih_generation);\n\t\t}\n\t\tresult = ERR_PTR(status);\n\t\tgoto bail;\n\t}\n\n\tif (IS_ERR(inode)) {\n\t\tmlog_errno(PTR_ERR(inode));\n\t\tresult = (void *)inode;\n\t\tgoto bail;\n\t}\n\ncheck_gen:\n\tif (handle->ih_generation != inode->i_generation) {\n\t\tiput(inode);\n\t\ttrace_ocfs2_get_dentry_generation((unsigned long long)blkno,\n\t\t\t\t\t\t  handle->ih_generation,\n\t\t\t\t\t\t  inode->i_generation);\n\t\tresult = ERR_PTR(-ESTALE);\n\t\tgoto bail;\n\t}\n\n\tresult = d_obtain_alias(inode);\n\tif (IS_ERR(result))\n\t\tmlog_errno(PTR_ERR(result));\n\nbail:\n\ttrace_ocfs2_get_dentry_end(result);\n\treturn result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "fid->raw[2]"
          ],
          "line": 248
        },
        "resolved": true,
        "details": {
          "function_name": "sle32_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "53-56",
          "snippet": "static inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"suballoc.h\"\n#include \"buffer_head_io.h\"\n#include \"inode.h\"\n#include \"export.h\"\n#include \"dcache.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic struct dentry *ocfs2_fh_to_dentry(struct super_block *sb,\n\t\tstruct fid *fid, int fh_len, int fh_type)\n{\n\tstruct ocfs2_inode_handle handle;\n\n\tif (fh_len < 3 || fh_type > 2)\n\t\treturn NULL;\n\n\thandle.ih_blkno = (u64)le32_to_cpu(fid->raw[0]) << 32;\n\thandle.ih_blkno |= (u64)le32_to_cpu(fid->raw[1]);\n\thandle.ih_generation = le32_to_cpu(fid->raw[2]);\n\treturn ocfs2_get_dentry(sb, &handle);\n}"
  },
  {
    "function_name": "ocfs2_encode_fh",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/export.c",
    "lines": "180-236",
    "snippet": "static int ocfs2_encode_fh(struct inode *inode, u32 *fh_in, int *max_len,\n\t\t\t   struct inode *parent)\n{\n\tint len = *max_len;\n\tint type = 1;\n\tu64 blkno;\n\tu32 generation;\n\t__le32 *fh = (__force __le32 *) fh_in;\n\n#ifdef TRACE_HOOKS_ARE_NOT_BRAINDEAD_IN_YOUR_OPINION\n#error \"You go ahead and fix that mess, then.  Somehow\"\n\ttrace_ocfs2_encode_fh_begin(dentry, dentry->d_name.len,\n\t\t\t\t    dentry->d_name.name,\n\t\t\t\t    fh, len, connectable);\n#endif\n\n\tif (parent && (len < 6)) {\n\t\t*max_len = 6;\n\t\ttype = FILEID_INVALID;\n\t\tgoto bail;\n\t} else if (len < 3) {\n\t\t*max_len = 3;\n\t\ttype = FILEID_INVALID;\n\t\tgoto bail;\n\t}\n\n\tblkno = OCFS2_I(inode)->ip_blkno;\n\tgeneration = inode->i_generation;\n\n\ttrace_ocfs2_encode_fh_self((unsigned long long)blkno, generation);\n\n\tlen = 3;\n\tfh[0] = cpu_to_le32((u32)(blkno >> 32));\n\tfh[1] = cpu_to_le32((u32)(blkno & 0xffffffff));\n\tfh[2] = cpu_to_le32(generation);\n\n\tif (parent) {\n\t\tblkno = OCFS2_I(parent)->ip_blkno;\n\t\tgeneration = parent->i_generation;\n\n\t\tfh[3] = cpu_to_le32((u32)(blkno >> 32));\n\t\tfh[4] = cpu_to_le32((u32)(blkno & 0xffffffff));\n\t\tfh[5] = cpu_to_le32(generation);\n\n\t\tlen = 6;\n\t\ttype = 2;\n\n\t\ttrace_ocfs2_encode_fh_parent((unsigned long long)blkno,\n\t\t\t\t\t     generation);\n\t}\n\n\t*max_len = len;\n\nbail:\n\ttrace_ocfs2_encode_fh_type(type);\n\treturn type;\n}",
    "includes": [
      "#include \"ocfs2_trace.h\"",
      "#include \"suballoc.h\"",
      "#include \"buffer_head_io.h\"",
      "#include \"inode.h\"",
      "#include \"export.h\"",
      "#include \"dcache.h\"",
      "#include \"dlmglue.h\"",
      "#include \"dir.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "trace_ocfs2_encode_fh_type",
          "args": [
            "type"
          ],
          "line": 234
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_ocfs2_encode_fh_parent",
          "args": [
            "(unsigned long long)blkno",
            "generation"
          ],
          "line": 227
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "generation"
          ],
          "line": 222
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "(u32)(blkno & 0xffffffff)"
          ],
          "line": 221
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "blkno & 0xffffffff"
          ],
          "line": 221
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "(u32)(blkno >> 32)"
          ],
          "line": 220
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "blkno >> 32"
          ],
          "line": 220
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "OCFS2_I",
          "args": [
            "parent"
          ],
          "line": 217
        },
        "resolved": true,
        "details": {
          "function_name": "OCFS2_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/inode.h",
          "lines": "118-121",
          "snippet": "static inline struct ocfs2_inode_info *OCFS2_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ocfs2_inode_info, vfs_inode);\n}",
          "includes": [
            "#include \"extent_map.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extent_map.h\"\n\nstatic inline struct ocfs2_inode_info *OCFS2_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ocfs2_inode_info, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "generation"
          ],
          "line": 214
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "(u32)(blkno & 0xffffffff)"
          ],
          "line": 213
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "blkno & 0xffffffff"
          ],
          "line": 213
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "(u32)(blkno >> 32)"
          ],
          "line": 212
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "blkno >> 32"
          ],
          "line": 212
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_ocfs2_encode_fh_self",
          "args": [
            "(unsigned long long)blkno",
            "generation"
          ],
          "line": 209
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_ocfs2_encode_fh_begin",
          "args": [
            "dentry",
            "dentry->d_name.len",
            "dentry->d_name.name",
            "fh",
            "len",
            "connectable"
          ],
          "line": 191
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"suballoc.h\"\n#include \"buffer_head_io.h\"\n#include \"inode.h\"\n#include \"export.h\"\n#include \"dcache.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_encode_fh(struct inode *inode, u32 *fh_in, int *max_len,\n\t\t\t   struct inode *parent)\n{\n\tint len = *max_len;\n\tint type = 1;\n\tu64 blkno;\n\tu32 generation;\n\t__le32 *fh = (__force __le32 *) fh_in;\n\n#ifdef TRACE_HOOKS_ARE_NOT_BRAINDEAD_IN_YOUR_OPINION\n#error \"You go ahead and fix that mess, then.  Somehow\"\n\ttrace_ocfs2_encode_fh_begin(dentry, dentry->d_name.len,\n\t\t\t\t    dentry->d_name.name,\n\t\t\t\t    fh, len, connectable);\n#endif\n\n\tif (parent && (len < 6)) {\n\t\t*max_len = 6;\n\t\ttype = FILEID_INVALID;\n\t\tgoto bail;\n\t} else if (len < 3) {\n\t\t*max_len = 3;\n\t\ttype = FILEID_INVALID;\n\t\tgoto bail;\n\t}\n\n\tblkno = OCFS2_I(inode)->ip_blkno;\n\tgeneration = inode->i_generation;\n\n\ttrace_ocfs2_encode_fh_self((unsigned long long)blkno, generation);\n\n\tlen = 3;\n\tfh[0] = cpu_to_le32((u32)(blkno >> 32));\n\tfh[1] = cpu_to_le32((u32)(blkno & 0xffffffff));\n\tfh[2] = cpu_to_le32(generation);\n\n\tif (parent) {\n\t\tblkno = OCFS2_I(parent)->ip_blkno;\n\t\tgeneration = parent->i_generation;\n\n\t\tfh[3] = cpu_to_le32((u32)(blkno >> 32));\n\t\tfh[4] = cpu_to_le32((u32)(blkno & 0xffffffff));\n\t\tfh[5] = cpu_to_le32(generation);\n\n\t\tlen = 6;\n\t\ttype = 2;\n\n\t\ttrace_ocfs2_encode_fh_parent((unsigned long long)blkno,\n\t\t\t\t\t     generation);\n\t}\n\n\t*max_len = len;\n\nbail:\n\ttrace_ocfs2_encode_fh_type(type);\n\treturn type;\n}"
  },
  {
    "function_name": "ocfs2_get_parent",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/export.c",
    "lines": "145-178",
    "snippet": "static struct dentry *ocfs2_get_parent(struct dentry *child)\n{\n\tint status;\n\tu64 blkno;\n\tstruct dentry *parent;\n\tstruct inode *dir = child->d_inode;\n\n\ttrace_ocfs2_get_parent(child, child->d_name.len, child->d_name.name,\n\t\t\t       (unsigned long long)OCFS2_I(dir)->ip_blkno);\n\n\tstatus = ocfs2_inode_lock(dir, NULL, 0);\n\tif (status < 0) {\n\t\tif (status != -ENOENT)\n\t\t\tmlog_errno(status);\n\t\tparent = ERR_PTR(status);\n\t\tgoto bail;\n\t}\n\n\tstatus = ocfs2_lookup_ino_from_name(dir, \"..\", 2, &blkno);\n\tif (status < 0) {\n\t\tparent = ERR_PTR(-ENOENT);\n\t\tgoto bail_unlock;\n\t}\n\n\tparent = d_obtain_alias(ocfs2_iget(OCFS2_SB(dir->i_sb), blkno, 0, 0));\n\nbail_unlock:\n\tocfs2_inode_unlock(dir, 0);\n\nbail:\n\ttrace_ocfs2_get_parent_end(parent);\n\n\treturn parent;\n}",
    "includes": [
      "#include \"ocfs2_trace.h\"",
      "#include \"suballoc.h\"",
      "#include \"buffer_head_io.h\"",
      "#include \"inode.h\"",
      "#include \"export.h\"",
      "#include \"dcache.h\"",
      "#include \"dlmglue.h\"",
      "#include \"dir.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "trace_ocfs2_get_parent_end",
          "args": [
            "parent"
          ],
          "line": 175
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_inode_unlock",
          "args": [
            "dir",
            "0"
          ],
          "line": 172
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_inode_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlmglue.c",
          "lines": "2491-2505",
          "snippet": "void ocfs2_inode_unlock(struct inode *inode,\n\t\t       int ex)\n{\n\tint level = ex ? DLM_LOCK_EX : DLM_LOCK_PR;\n\tstruct ocfs2_lock_res *lockres = &OCFS2_I(inode)->ip_inode_lockres;\n\tstruct ocfs2_super *osb = OCFS2_SB(inode->i_sb);\n\n\tmlog(0, \"inode %llu drop %s META lock\\n\",\n\t     (unsigned long long)OCFS2_I(inode)->ip_blkno,\n\t     ex ? \"EXMODE\" : \"PRMODE\");\n\n\tif (!ocfs2_is_hard_readonly(OCFS2_SB(inode->i_sb)) &&\n\t    !ocfs2_mount_local(osb))\n\t\tocfs2_cluster_unlock(OCFS2_SB(inode->i_sb), lockres, level);\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"refcounttree.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"stackglue.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dcache.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2_lockingver.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/time.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/kthread.h>",
            "#include <linux/mm.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct ocfs2_super *ocfs2_get_dentry_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_inode_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_file_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_qinfo_osb(struct ocfs2_lock_res *lockres);",
            "static void ocfs2_set_meta_lvb(struct ocfs2_lock_res *lockres);",
            "static void ocfs2_dentry_post_unlock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres);",
            "static void ocfs2_set_qinfo_lvb(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_downconvert_action(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_convert_action(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_attach_action(struct ocfs2_lock_res *lockres);",
            "static int ocfs2_generic_handle_bast(struct ocfs2_lock_res *lockres, int level);",
            "static void ocfs2_schedule_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static void ocfs2_downconvert_on_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static void ocfs2_drop_osb_locks(struct ocfs2_super *osb);",
            "static inline int ocfs2_highest_compat_lock_level(int level);",
            "static int ocfs2_prepare_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\t        struct ocfs2_lock_res *lockres);",
            "static int ocfs2_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static void ocfs2_process_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *lockres);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"stackglue.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dcache.h\"\n#include \"alloc.h\"\n#include \"ocfs2_lockingver.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/quotaops.h>\n#include <linux/time.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/pagemap.h>\n#include <linux/kthread.h>\n#include <linux/mm.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic struct ocfs2_super *ocfs2_get_dentry_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_inode_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_file_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_qinfo_osb(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_set_meta_lvb(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_dentry_post_unlock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres);\nstatic void ocfs2_set_qinfo_lvb(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_downconvert_action(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_convert_action(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_attach_action(struct ocfs2_lock_res *lockres);\nstatic int ocfs2_generic_handle_bast(struct ocfs2_lock_res *lockres, int level);\nstatic void ocfs2_schedule_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_downconvert_on_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_drop_osb_locks(struct ocfs2_super *osb);\nstatic inline int ocfs2_highest_compat_lock_level(int level);\nstatic int ocfs2_prepare_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\t        struct ocfs2_lock_res *lockres);\nstatic int ocfs2_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_process_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *lockres);\n\nvoid ocfs2_inode_unlock(struct inode *inode,\n\t\t       int ex)\n{\n\tint level = ex ? DLM_LOCK_EX : DLM_LOCK_PR;\n\tstruct ocfs2_lock_res *lockres = &OCFS2_I(inode)->ip_inode_lockres;\n\tstruct ocfs2_super *osb = OCFS2_SB(inode->i_sb);\n\n\tmlog(0, \"inode %llu drop %s META lock\\n\",\n\t     (unsigned long long)OCFS2_I(inode)->ip_blkno,\n\t     ex ? \"EXMODE\" : \"PRMODE\");\n\n\tif (!ocfs2_is_hard_readonly(OCFS2_SB(inode->i_sb)) &&\n\t    !ocfs2_mount_local(osb))\n\t\tocfs2_cluster_unlock(OCFS2_SB(inode->i_sb), lockres, level);\n}"
        }
      },
      {
        "call_info": {
          "callee": "d_obtain_alias",
          "args": [
            "ocfs2_iget(OCFS2_SB(dir->i_sb), blkno, 0, 0)"
          ],
          "line": 169
        },
        "resolved": true,
        "details": {
          "function_name": "d_obtain_alias",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "1977-1980",
          "snippet": "struct dentry *d_obtain_alias(struct inode *inode)\n{\n\treturn __d_obtain_alias(inode, 1);\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nstruct dentry *d_obtain_alias(struct inode *inode)\n{\n\treturn __d_obtain_alias(inode, 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_iget",
          "args": [
            "OCFS2_SB(dir->i_sb)",
            "blkno",
            "0",
            "0"
          ],
          "line": 169
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_iget",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/inode.c",
          "lines": "127-206",
          "snippet": "struct inode *ocfs2_iget(struct ocfs2_super *osb, u64 blkno, unsigned flags,\n\t\t\t int sysfile_type)\n{\n\tstruct inode *inode = NULL;\n\tstruct super_block *sb = osb->sb;\n\tstruct ocfs2_find_inode_args args;\n\tjournal_t *journal = OCFS2_SB(sb)->journal->j_journal;\n\n\ttrace_ocfs2_iget_begin((unsigned long long)blkno, flags,\n\t\t\t       sysfile_type);\n\n\t/* Ok. By now we've either got the offsets passed to us by the\n\t * caller, or we just pulled them off the bh. Lets do some\n\t * sanity checks to make sure they're OK. */\n\tif (blkno == 0) {\n\t\tinode = ERR_PTR(-EINVAL);\n\t\tmlog_errno(PTR_ERR(inode));\n\t\tgoto bail;\n\t}\n\n\targs.fi_blkno = blkno;\n\targs.fi_flags = flags;\n\targs.fi_ino = ino_from_blkno(sb, blkno);\n\targs.fi_sysfile_type = sysfile_type;\n\n\tinode = iget5_locked(sb, args.fi_ino, ocfs2_find_actor,\n\t\t\t     ocfs2_init_locked_inode, &args);\n\t/* inode was *not* in the inode cache. 2.6.x requires\n\t * us to do our own read_inode call and unlock it\n\t * afterwards. */\n\tif (inode == NULL) {\n\t\tinode = ERR_PTR(-ENOMEM);\n\t\tmlog_errno(PTR_ERR(inode));\n\t\tgoto bail;\n\t}\n\ttrace_ocfs2_iget5_locked(inode->i_state);\n\tif (inode->i_state & I_NEW) {\n\t\tocfs2_read_locked_inode(inode, &args);\n\t\tunlock_new_inode(inode);\n\t}\n\tif (is_bad_inode(inode)) {\n\t\tiput(inode);\n\t\tinode = ERR_PTR(-ESTALE);\n\t\tgoto bail;\n\t}\n\n\t/*\n\t * Set transaction id's of transactions that have to be committed\n\t * to finish f[data]sync. We set them to currently running transaction\n\t * as we cannot be sure that the inode or some of its metadata isn't\n\t * part of the transaction - the inode could have been reclaimed and\n\t * now it is reread from disk.\n\t */\n\tif (journal) {\n\t\ttransaction_t *transaction;\n\t\ttid_t tid;\n\t\tstruct ocfs2_inode_info *oi = OCFS2_I(inode);\n\n\t\tread_lock(&journal->j_state_lock);\n\t\tif (journal->j_running_transaction)\n\t\t\ttransaction = journal->j_running_transaction;\n\t\telse\n\t\t\ttransaction = journal->j_committing_transaction;\n\t\tif (transaction)\n\t\t\ttid = transaction->t_tid;\n\t\telse\n\t\t\ttid = journal->j_commit_sequence;\n\t\tread_unlock(&journal->j_state_lock);\n\t\toi->i_sync_tid = tid;\n\t\toi->i_datasync_tid = tid;\n\t}\n\nbail:\n\tif (!IS_ERR(inode)) {\n\t\ttrace_ocfs2_iget_end(inode, \n\t\t\t(unsigned long long)OCFS2_I(inode)->ip_blkno);\n\t}\n\n\treturn inode;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"symlink.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"dir.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ocfs2_read_locked_inode(struct inode *inode,\n\t\t\t\t   struct ocfs2_find_inode_args *args);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"symlink.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"dir.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <asm/byteorder.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_read_locked_inode(struct inode *inode,\n\t\t\t\t   struct ocfs2_find_inode_args *args);\n\nstruct inode *ocfs2_iget(struct ocfs2_super *osb, u64 blkno, unsigned flags,\n\t\t\t int sysfile_type)\n{\n\tstruct inode *inode = NULL;\n\tstruct super_block *sb = osb->sb;\n\tstruct ocfs2_find_inode_args args;\n\tjournal_t *journal = OCFS2_SB(sb)->journal->j_journal;\n\n\ttrace_ocfs2_iget_begin((unsigned long long)blkno, flags,\n\t\t\t       sysfile_type);\n\n\t/* Ok. By now we've either got the offsets passed to us by the\n\t * caller, or we just pulled them off the bh. Lets do some\n\t * sanity checks to make sure they're OK. */\n\tif (blkno == 0) {\n\t\tinode = ERR_PTR(-EINVAL);\n\t\tmlog_errno(PTR_ERR(inode));\n\t\tgoto bail;\n\t}\n\n\targs.fi_blkno = blkno;\n\targs.fi_flags = flags;\n\targs.fi_ino = ino_from_blkno(sb, blkno);\n\targs.fi_sysfile_type = sysfile_type;\n\n\tinode = iget5_locked(sb, args.fi_ino, ocfs2_find_actor,\n\t\t\t     ocfs2_init_locked_inode, &args);\n\t/* inode was *not* in the inode cache. 2.6.x requires\n\t * us to do our own read_inode call and unlock it\n\t * afterwards. */\n\tif (inode == NULL) {\n\t\tinode = ERR_PTR(-ENOMEM);\n\t\tmlog_errno(PTR_ERR(inode));\n\t\tgoto bail;\n\t}\n\ttrace_ocfs2_iget5_locked(inode->i_state);\n\tif (inode->i_state & I_NEW) {\n\t\tocfs2_read_locked_inode(inode, &args);\n\t\tunlock_new_inode(inode);\n\t}\n\tif (is_bad_inode(inode)) {\n\t\tiput(inode);\n\t\tinode = ERR_PTR(-ESTALE);\n\t\tgoto bail;\n\t}\n\n\t/*\n\t * Set transaction id's of transactions that have to be committed\n\t * to finish f[data]sync. We set them to currently running transaction\n\t * as we cannot be sure that the inode or some of its metadata isn't\n\t * part of the transaction - the inode could have been reclaimed and\n\t * now it is reread from disk.\n\t */\n\tif (journal) {\n\t\ttransaction_t *transaction;\n\t\ttid_t tid;\n\t\tstruct ocfs2_inode_info *oi = OCFS2_I(inode);\n\n\t\tread_lock(&journal->j_state_lock);\n\t\tif (journal->j_running_transaction)\n\t\t\ttransaction = journal->j_running_transaction;\n\t\telse\n\t\t\ttransaction = journal->j_committing_transaction;\n\t\tif (transaction)\n\t\t\ttid = transaction->t_tid;\n\t\telse\n\t\t\ttid = journal->j_commit_sequence;\n\t\tread_unlock(&journal->j_state_lock);\n\t\toi->i_sync_tid = tid;\n\t\toi->i_datasync_tid = tid;\n\t}\n\nbail:\n\tif (!IS_ERR(inode)) {\n\t\ttrace_ocfs2_iget_end(inode, \n\t\t\t(unsigned long long)OCFS2_I(inode)->ip_blkno);\n\t}\n\n\treturn inode;\n}"
        }
      },
      {
        "call_info": {
          "callee": "OCFS2_SB",
          "args": [
            "dir->i_sb"
          ],
          "line": 169
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-ENOENT"
          ],
          "line": 165
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_lookup_ino_from_name",
          "args": [
            "dir",
            "\"..\"",
            "2",
            "&blkno"
          ],
          "line": 163
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_lookup_ino_from_name",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
          "lines": "2027-2037",
          "snippet": "int ocfs2_lookup_ino_from_name(struct inode *dir, const char *name,\n\t\t\t       int namelen, u64 *blkno)\n{\n\tint ret;\n\tstruct ocfs2_dir_lookup_result lookup = { NULL, };\n\n\tret = ocfs2_find_files_on_disk(name, namelen, blkno, dir, &lookup);\n\tocfs2_free_dir_lookup_result(&lookup);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ocfs2_dir_indexed(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_dir_indexed(struct inode *inode);\n\nint ocfs2_lookup_ino_from_name(struct inode *dir, const char *name,\n\t\t\t       int namelen, u64 *blkno)\n{\n\tint ret;\n\tstruct ocfs2_dir_lookup_result lookup = { NULL, };\n\n\tret = ocfs2_find_files_on_disk(name, namelen, blkno, dir, &lookup);\n\tocfs2_free_dir_lookup_result(&lookup);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "status"
          ],
          "line": 159
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "status"
          ],
          "line": 158
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_inode_lock",
          "args": [
            "dir",
            "NULL",
            "0"
          ],
          "line": 155
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_inode_lock_atime",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlmglue.c",
          "lines": "2455-2489",
          "snippet": "int ocfs2_inode_lock_atime(struct inode *inode,\n\t\t\t  struct vfsmount *vfsmnt,\n\t\t\t  int *level)\n{\n\tint ret;\n\n\tret = ocfs2_inode_lock(inode, NULL, 0);\n\tif (ret < 0) {\n\t\tmlog_errno(ret);\n\t\treturn ret;\n\t}\n\n\t/*\n\t * If we should update atime, we will get EX lock,\n\t * otherwise we just get PR lock.\n\t */\n\tif (ocfs2_should_update_atime(inode, vfsmnt)) {\n\t\tstruct buffer_head *bh = NULL;\n\n\t\tocfs2_inode_unlock(inode, 0);\n\t\tret = ocfs2_inode_lock(inode, &bh, 1);\n\t\tif (ret < 0) {\n\t\t\tmlog_errno(ret);\n\t\t\treturn ret;\n\t\t}\n\t\t*level = 1;\n\t\tif (ocfs2_should_update_atime(inode, vfsmnt))\n\t\t\tocfs2_update_inode_atime(inode, bh);\n\t\tif (bh)\n\t\t\tbrelse(bh);\n\t} else\n\t\t*level = 0;\n\n\treturn ret;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"refcounttree.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"stackglue.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dcache.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2_lockingver.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/time.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/kthread.h>",
            "#include <linux/mm.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ocfs2_generic_handle_bast(struct ocfs2_lock_res *lockres, int level);",
            "static int ocfs2_inode_lock_update(struct inode *inode,\n\t\t\t\t  struct buffer_head **bh);",
            "static inline int ocfs2_highest_compat_lock_level(int level);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"stackglue.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dcache.h\"\n#include \"alloc.h\"\n#include \"ocfs2_lockingver.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/quotaops.h>\n#include <linux/time.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/pagemap.h>\n#include <linux/kthread.h>\n#include <linux/mm.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic int ocfs2_generic_handle_bast(struct ocfs2_lock_res *lockres, int level);\nstatic int ocfs2_inode_lock_update(struct inode *inode,\n\t\t\t\t  struct buffer_head **bh);\nstatic inline int ocfs2_highest_compat_lock_level(int level);\n\nint ocfs2_inode_lock_atime(struct inode *inode,\n\t\t\t  struct vfsmount *vfsmnt,\n\t\t\t  int *level)\n{\n\tint ret;\n\n\tret = ocfs2_inode_lock(inode, NULL, 0);\n\tif (ret < 0) {\n\t\tmlog_errno(ret);\n\t\treturn ret;\n\t}\n\n\t/*\n\t * If we should update atime, we will get EX lock,\n\t * otherwise we just get PR lock.\n\t */\n\tif (ocfs2_should_update_atime(inode, vfsmnt)) {\n\t\tstruct buffer_head *bh = NULL;\n\n\t\tocfs2_inode_unlock(inode, 0);\n\t\tret = ocfs2_inode_lock(inode, &bh, 1);\n\t\tif (ret < 0) {\n\t\t\tmlog_errno(ret);\n\t\t\treturn ret;\n\t\t}\n\t\t*level = 1;\n\t\tif (ocfs2_should_update_atime(inode, vfsmnt))\n\t\t\tocfs2_update_inode_atime(inode, bh);\n\t\tif (bh)\n\t\t\tbrelse(bh);\n\t} else\n\t\t*level = 0;\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_ocfs2_get_parent",
          "args": [
            "child",
            "child->d_name.len",
            "child->d_name.name",
            "(unsigned long long)OCFS2_I(dir)->ip_blkno"
          ],
          "line": 152
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "OCFS2_I",
          "args": [
            "dir"
          ],
          "line": 153
        },
        "resolved": true,
        "details": {
          "function_name": "OCFS2_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/inode.h",
          "lines": "118-121",
          "snippet": "static inline struct ocfs2_inode_info *OCFS2_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ocfs2_inode_info, vfs_inode);\n}",
          "includes": [
            "#include \"extent_map.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extent_map.h\"\n\nstatic inline struct ocfs2_inode_info *OCFS2_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ocfs2_inode_info, vfs_inode);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"suballoc.h\"\n#include \"buffer_head_io.h\"\n#include \"inode.h\"\n#include \"export.h\"\n#include \"dcache.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic struct dentry *ocfs2_get_parent(struct dentry *child)\n{\n\tint status;\n\tu64 blkno;\n\tstruct dentry *parent;\n\tstruct inode *dir = child->d_inode;\n\n\ttrace_ocfs2_get_parent(child, child->d_name.len, child->d_name.name,\n\t\t\t       (unsigned long long)OCFS2_I(dir)->ip_blkno);\n\n\tstatus = ocfs2_inode_lock(dir, NULL, 0);\n\tif (status < 0) {\n\t\tif (status != -ENOENT)\n\t\t\tmlog_errno(status);\n\t\tparent = ERR_PTR(status);\n\t\tgoto bail;\n\t}\n\n\tstatus = ocfs2_lookup_ino_from_name(dir, \"..\", 2, &blkno);\n\tif (status < 0) {\n\t\tparent = ERR_PTR(-ENOENT);\n\t\tgoto bail_unlock;\n\t}\n\n\tparent = d_obtain_alias(ocfs2_iget(OCFS2_SB(dir->i_sb), blkno, 0, 0));\n\nbail_unlock:\n\tocfs2_inode_unlock(dir, 0);\n\nbail:\n\ttrace_ocfs2_get_parent_end(parent);\n\n\treturn parent;\n}"
  },
  {
    "function_name": "ocfs2_get_dentry",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/export.c",
    "lines": "50-143",
    "snippet": "static struct dentry *ocfs2_get_dentry(struct super_block *sb,\n\t\tstruct ocfs2_inode_handle *handle)\n{\n\tstruct inode *inode;\n\tstruct ocfs2_super *osb = OCFS2_SB(sb);\n\tu64 blkno = handle->ih_blkno;\n\tint status, set;\n\tstruct dentry *result;\n\n\ttrace_ocfs2_get_dentry_begin(sb, handle, (unsigned long long)blkno);\n\n\tif (blkno == 0) {\n\t\tresult = ERR_PTR(-ESTALE);\n\t\tgoto bail;\n\t}\n\n\tinode = ocfs2_ilookup(sb, blkno);\n\t/*\n\t * If the inode exists in memory, we only need to check it's\n\t * generation number\n\t */\n\tif (inode)\n\t\tgoto check_gen;\n\n\t/*\n\t * This will synchronize us against ocfs2_delete_inode() on\n\t * all nodes\n\t */\n\tstatus = ocfs2_nfs_sync_lock(osb, 1);\n\tif (status < 0) {\n\t\tmlog(ML_ERROR, \"getting nfs sync lock(EX) failed %d\\n\", status);\n\t\tgoto check_err;\n\t}\n\n\tstatus = ocfs2_test_inode_bit(osb, blkno, &set);\n\ttrace_ocfs2_get_dentry_test_bit(status, set);\n\tif (status < 0) {\n\t\tif (status == -EINVAL) {\n\t\t\t/*\n\t\t\t * The blkno NFS gave us doesn't even show up\n\t\t\t * as an inode, we return -ESTALE to be\n\t\t\t * nice\n\t\t\t */\n\t\t\tstatus = -ESTALE;\n\t\t} else\n\t\t\tmlog(ML_ERROR, \"test inode bit failed %d\\n\", status);\n\t\tgoto unlock_nfs_sync;\n\t}\n\n\t/* If the inode allocator bit is clear, this inode must be stale */\n\tif (!set) {\n\t\tstatus = -ESTALE;\n\t\tgoto unlock_nfs_sync;\n\t}\n\n\tinode = ocfs2_iget(osb, blkno, 0, 0);\n\nunlock_nfs_sync:\n\tocfs2_nfs_sync_unlock(osb, 1);\n\ncheck_err:\n\tif (status < 0) {\n\t\tif (status == -ESTALE) {\n\t\t\ttrace_ocfs2_get_dentry_stale((unsigned long long)blkno,\n\t\t\t\t\t\t     handle->ih_generation);\n\t\t}\n\t\tresult = ERR_PTR(status);\n\t\tgoto bail;\n\t}\n\n\tif (IS_ERR(inode)) {\n\t\tmlog_errno(PTR_ERR(inode));\n\t\tresult = (void *)inode;\n\t\tgoto bail;\n\t}\n\ncheck_gen:\n\tif (handle->ih_generation != inode->i_generation) {\n\t\tiput(inode);\n\t\ttrace_ocfs2_get_dentry_generation((unsigned long long)blkno,\n\t\t\t\t\t\t  handle->ih_generation,\n\t\t\t\t\t\t  inode->i_generation);\n\t\tresult = ERR_PTR(-ESTALE);\n\t\tgoto bail;\n\t}\n\n\tresult = d_obtain_alias(inode);\n\tif (IS_ERR(result))\n\t\tmlog_errno(PTR_ERR(result));\n\nbail:\n\ttrace_ocfs2_get_dentry_end(result);\n\treturn result;\n}",
    "includes": [
      "#include \"ocfs2_trace.h\"",
      "#include \"suballoc.h\"",
      "#include \"buffer_head_io.h\"",
      "#include \"inode.h\"",
      "#include \"export.h\"",
      "#include \"dcache.h\"",
      "#include \"dlmglue.h\"",
      "#include \"dir.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "trace_ocfs2_get_dentry_end",
          "args": [
            "result"
          ],
          "line": 141
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "PTR_ERR(result)"
          ],
          "line": 138
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "result"
          ],
          "line": 138
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "result"
          ],
          "line": 137
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "d_obtain_alias",
          "args": [
            "inode"
          ],
          "line": 136
        },
        "resolved": true,
        "details": {
          "function_name": "d_obtain_alias",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "1977-1980",
          "snippet": "struct dentry *d_obtain_alias(struct inode *inode)\n{\n\treturn __d_obtain_alias(inode, 1);\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nstruct dentry *d_obtain_alias(struct inode *inode)\n{\n\treturn __d_obtain_alias(inode, 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-ESTALE"
          ],
          "line": 132
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_ocfs2_get_dentry_generation",
          "args": [
            "(unsigned long long)blkno",
            "handle->ih_generation",
            "inode->i_generation"
          ],
          "line": 129
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "iput",
          "args": [
            "inode"
          ],
          "line": 128
        },
        "resolved": true,
        "details": {
          "function_name": "dentry_iput",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "308-327",
          "snippet": "static void dentry_iput(struct dentry * dentry)\n\t__releases(dentry->d_lock)\n\t__releases(dentry->d_inode->i_lock)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tif (inode) {\n\t\tdentry->d_inode = NULL;\n\t\thlist_del_init(&dentry->d_u.d_alias);\n\t\tspin_unlock(&dentry->d_lock);\n\t\tspin_unlock(&inode->i_lock);\n\t\tif (!inode->i_nlink)\n\t\t\tfsnotify_inoderemove(inode);\n\t\tif (dentry->d_op && dentry->d_op->d_iput)\n\t\t\tdentry->d_op->d_iput(dentry, inode);\n\t\telse\n\t\t\tiput(inode);\n\t} else {\n\t\tspin_unlock(&dentry->d_lock);\n\t}\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nstatic void dentry_iput(struct dentry * dentry)\n\t__releases(dentry->d_lock)\n\t__releases(dentry->d_inode->i_lock)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tif (inode) {\n\t\tdentry->d_inode = NULL;\n\t\thlist_del_init(&dentry->d_u.d_alias);\n\t\tspin_unlock(&dentry->d_lock);\n\t\tspin_unlock(&inode->i_lock);\n\t\tif (!inode->i_nlink)\n\t\t\tfsnotify_inoderemove(inode);\n\t\tif (dentry->d_op && dentry->d_op->d_iput)\n\t\t\tdentry->d_op->d_iput(dentry, inode);\n\t\telse\n\t\t\tiput(inode);\n\t} else {\n\t\tspin_unlock(&dentry->d_lock);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "PTR_ERR(inode)"
          ],
          "line": 121
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "inode"
          ],
          "line": 121
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "inode"
          ],
          "line": 120
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "status"
          ],
          "line": 116
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_ocfs2_get_dentry_stale",
          "args": [
            "(unsigned long long)blkno",
            "handle->ih_generation"
          ],
          "line": 113
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_nfs_sync_unlock",
          "args": [
            "osb",
            "1"
          ],
          "line": 108
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_nfs_sync_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlmglue.c",
          "lines": "2642-2649",
          "snippet": "void ocfs2_nfs_sync_unlock(struct ocfs2_super *osb, int ex)\n{\n\tstruct ocfs2_lock_res *lockres = &osb->osb_nfs_sync_lockres;\n\n\tif (!ocfs2_mount_local(osb))\n\t\tocfs2_cluster_unlock(osb, lockres,\n\t\t\t\t     ex ? LKM_EXMODE : LKM_PRMODE);\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"refcounttree.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"stackglue.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dcache.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2_lockingver.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/time.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/kthread.h>",
            "#include <linux/mm.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct ocfs2_super *ocfs2_get_dentry_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_inode_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_file_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_qinfo_osb(struct ocfs2_lock_res *lockres);",
            "static void ocfs2_set_meta_lvb(struct ocfs2_lock_res *lockres);",
            "static void ocfs2_dentry_post_unlock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres);",
            "static void ocfs2_set_qinfo_lvb(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_downconvert_action(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_convert_action(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_attach_action(struct ocfs2_lock_res *lockres);",
            "static void ocfs2_schedule_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static void ocfs2_downconvert_on_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static void ocfs2_drop_osb_locks(struct ocfs2_super *osb);",
            "static int ocfs2_prepare_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\t        struct ocfs2_lock_res *lockres);",
            "static int ocfs2_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static void ocfs2_process_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *lockres);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"stackglue.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dcache.h\"\n#include \"alloc.h\"\n#include \"ocfs2_lockingver.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/quotaops.h>\n#include <linux/time.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/pagemap.h>\n#include <linux/kthread.h>\n#include <linux/mm.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic struct ocfs2_super *ocfs2_get_dentry_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_inode_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_file_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_qinfo_osb(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_set_meta_lvb(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_dentry_post_unlock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres);\nstatic void ocfs2_set_qinfo_lvb(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_downconvert_action(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_convert_action(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_attach_action(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_schedule_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_downconvert_on_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_drop_osb_locks(struct ocfs2_super *osb);\nstatic int ocfs2_prepare_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\t        struct ocfs2_lock_res *lockres);\nstatic int ocfs2_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_process_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *lockres);\n\nvoid ocfs2_nfs_sync_unlock(struct ocfs2_super *osb, int ex)\n{\n\tstruct ocfs2_lock_res *lockres = &osb->osb_nfs_sync_lockres;\n\n\tif (!ocfs2_mount_local(osb))\n\t\tocfs2_cluster_unlock(osb, lockres,\n\t\t\t\t     ex ? LKM_EXMODE : LKM_PRMODE);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_iget",
          "args": [
            "osb",
            "blkno",
            "0",
            "0"
          ],
          "line": 105
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_iget",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/inode.c",
          "lines": "127-206",
          "snippet": "struct inode *ocfs2_iget(struct ocfs2_super *osb, u64 blkno, unsigned flags,\n\t\t\t int sysfile_type)\n{\n\tstruct inode *inode = NULL;\n\tstruct super_block *sb = osb->sb;\n\tstruct ocfs2_find_inode_args args;\n\tjournal_t *journal = OCFS2_SB(sb)->journal->j_journal;\n\n\ttrace_ocfs2_iget_begin((unsigned long long)blkno, flags,\n\t\t\t       sysfile_type);\n\n\t/* Ok. By now we've either got the offsets passed to us by the\n\t * caller, or we just pulled them off the bh. Lets do some\n\t * sanity checks to make sure they're OK. */\n\tif (blkno == 0) {\n\t\tinode = ERR_PTR(-EINVAL);\n\t\tmlog_errno(PTR_ERR(inode));\n\t\tgoto bail;\n\t}\n\n\targs.fi_blkno = blkno;\n\targs.fi_flags = flags;\n\targs.fi_ino = ino_from_blkno(sb, blkno);\n\targs.fi_sysfile_type = sysfile_type;\n\n\tinode = iget5_locked(sb, args.fi_ino, ocfs2_find_actor,\n\t\t\t     ocfs2_init_locked_inode, &args);\n\t/* inode was *not* in the inode cache. 2.6.x requires\n\t * us to do our own read_inode call and unlock it\n\t * afterwards. */\n\tif (inode == NULL) {\n\t\tinode = ERR_PTR(-ENOMEM);\n\t\tmlog_errno(PTR_ERR(inode));\n\t\tgoto bail;\n\t}\n\ttrace_ocfs2_iget5_locked(inode->i_state);\n\tif (inode->i_state & I_NEW) {\n\t\tocfs2_read_locked_inode(inode, &args);\n\t\tunlock_new_inode(inode);\n\t}\n\tif (is_bad_inode(inode)) {\n\t\tiput(inode);\n\t\tinode = ERR_PTR(-ESTALE);\n\t\tgoto bail;\n\t}\n\n\t/*\n\t * Set transaction id's of transactions that have to be committed\n\t * to finish f[data]sync. We set them to currently running transaction\n\t * as we cannot be sure that the inode or some of its metadata isn't\n\t * part of the transaction - the inode could have been reclaimed and\n\t * now it is reread from disk.\n\t */\n\tif (journal) {\n\t\ttransaction_t *transaction;\n\t\ttid_t tid;\n\t\tstruct ocfs2_inode_info *oi = OCFS2_I(inode);\n\n\t\tread_lock(&journal->j_state_lock);\n\t\tif (journal->j_running_transaction)\n\t\t\ttransaction = journal->j_running_transaction;\n\t\telse\n\t\t\ttransaction = journal->j_committing_transaction;\n\t\tif (transaction)\n\t\t\ttid = transaction->t_tid;\n\t\telse\n\t\t\ttid = journal->j_commit_sequence;\n\t\tread_unlock(&journal->j_state_lock);\n\t\toi->i_sync_tid = tid;\n\t\toi->i_datasync_tid = tid;\n\t}\n\nbail:\n\tif (!IS_ERR(inode)) {\n\t\ttrace_ocfs2_iget_end(inode, \n\t\t\t(unsigned long long)OCFS2_I(inode)->ip_blkno);\n\t}\n\n\treturn inode;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"symlink.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"dir.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ocfs2_read_locked_inode(struct inode *inode,\n\t\t\t\t   struct ocfs2_find_inode_args *args);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"symlink.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"dir.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <asm/byteorder.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_read_locked_inode(struct inode *inode,\n\t\t\t\t   struct ocfs2_find_inode_args *args);\n\nstruct inode *ocfs2_iget(struct ocfs2_super *osb, u64 blkno, unsigned flags,\n\t\t\t int sysfile_type)\n{\n\tstruct inode *inode = NULL;\n\tstruct super_block *sb = osb->sb;\n\tstruct ocfs2_find_inode_args args;\n\tjournal_t *journal = OCFS2_SB(sb)->journal->j_journal;\n\n\ttrace_ocfs2_iget_begin((unsigned long long)blkno, flags,\n\t\t\t       sysfile_type);\n\n\t/* Ok. By now we've either got the offsets passed to us by the\n\t * caller, or we just pulled them off the bh. Lets do some\n\t * sanity checks to make sure they're OK. */\n\tif (blkno == 0) {\n\t\tinode = ERR_PTR(-EINVAL);\n\t\tmlog_errno(PTR_ERR(inode));\n\t\tgoto bail;\n\t}\n\n\targs.fi_blkno = blkno;\n\targs.fi_flags = flags;\n\targs.fi_ino = ino_from_blkno(sb, blkno);\n\targs.fi_sysfile_type = sysfile_type;\n\n\tinode = iget5_locked(sb, args.fi_ino, ocfs2_find_actor,\n\t\t\t     ocfs2_init_locked_inode, &args);\n\t/* inode was *not* in the inode cache. 2.6.x requires\n\t * us to do our own read_inode call and unlock it\n\t * afterwards. */\n\tif (inode == NULL) {\n\t\tinode = ERR_PTR(-ENOMEM);\n\t\tmlog_errno(PTR_ERR(inode));\n\t\tgoto bail;\n\t}\n\ttrace_ocfs2_iget5_locked(inode->i_state);\n\tif (inode->i_state & I_NEW) {\n\t\tocfs2_read_locked_inode(inode, &args);\n\t\tunlock_new_inode(inode);\n\t}\n\tif (is_bad_inode(inode)) {\n\t\tiput(inode);\n\t\tinode = ERR_PTR(-ESTALE);\n\t\tgoto bail;\n\t}\n\n\t/*\n\t * Set transaction id's of transactions that have to be committed\n\t * to finish f[data]sync. We set them to currently running transaction\n\t * as we cannot be sure that the inode or some of its metadata isn't\n\t * part of the transaction - the inode could have been reclaimed and\n\t * now it is reread from disk.\n\t */\n\tif (journal) {\n\t\ttransaction_t *transaction;\n\t\ttid_t tid;\n\t\tstruct ocfs2_inode_info *oi = OCFS2_I(inode);\n\n\t\tread_lock(&journal->j_state_lock);\n\t\tif (journal->j_running_transaction)\n\t\t\ttransaction = journal->j_running_transaction;\n\t\telse\n\t\t\ttransaction = journal->j_committing_transaction;\n\t\tif (transaction)\n\t\t\ttid = transaction->t_tid;\n\t\telse\n\t\t\ttid = journal->j_commit_sequence;\n\t\tread_unlock(&journal->j_state_lock);\n\t\toi->i_sync_tid = tid;\n\t\toi->i_datasync_tid = tid;\n\t}\n\nbail:\n\tif (!IS_ERR(inode)) {\n\t\ttrace_ocfs2_iget_end(inode, \n\t\t\t(unsigned long long)OCFS2_I(inode)->ip_blkno);\n\t}\n\n\treturn inode;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog",
          "args": [
            "ML_ERROR",
            "\"test inode bit failed %d\\n\"",
            "status"
          ],
          "line": 95
        },
        "resolved": true,
        "details": {
          "function_name": "mlog_show",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/cluster/masklog.c",
          "lines": "107-113",
          "snippet": "static ssize_t mlog_show(struct kobject *obj, struct attribute *attr,\n\t\t\t char *buf)\n{\n\tstruct mlog_attribute *mlog_attr = to_mlog_attr(attr);\n\n\treturn mlog_mask_show(mlog_attr->mask, buf);\n}",
          "includes": [
            "#include \"masklog.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/string.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"masklog.h\"\n#include <asm/uaccess.h>\n#include <linux/string.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n\nstatic ssize_t mlog_show(struct kobject *obj, struct attribute *attr,\n\t\t\t char *buf)\n{\n\tstruct mlog_attribute *mlog_attr = to_mlog_attr(attr);\n\n\treturn mlog_mask_show(mlog_attr->mask, buf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_ocfs2_get_dentry_test_bit",
          "args": [
            "status",
            "set"
          ],
          "line": 85
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_test_inode_bit",
          "args": [
            "osb",
            "blkno",
            "&set"
          ],
          "line": 84
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_test_inode_bit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/suballoc.c",
          "lines": "2864-2917",
          "snippet": "int ocfs2_test_inode_bit(struct ocfs2_super *osb, u64 blkno, int *res)\n{\n\tint status;\n\tu64 group_blkno = 0;\n\tu16 suballoc_bit = 0, suballoc_slot = 0;\n\tstruct inode *inode_alloc_inode;\n\tstruct buffer_head *alloc_bh = NULL;\n\n\ttrace_ocfs2_test_inode_bit((unsigned long long)blkno);\n\n\tstatus = ocfs2_get_suballoc_slot_bit(osb, blkno, &suballoc_slot,\n\t\t\t\t\t     &group_blkno, &suballoc_bit);\n\tif (status < 0) {\n\t\tmlog(ML_ERROR, \"get alloc slot and bit failed %d\\n\", status);\n\t\tgoto bail;\n\t}\n\n\tinode_alloc_inode =\n\t\tocfs2_get_system_file_inode(osb, INODE_ALLOC_SYSTEM_INODE,\n\t\t\t\t\t    suballoc_slot);\n\tif (!inode_alloc_inode) {\n\t\t/* the error code could be inaccurate, but we are not able to\n\t\t * get the correct one. */\n\t\tstatus = -EINVAL;\n\t\tmlog(ML_ERROR, \"unable to get alloc inode in slot %u\\n\",\n\t\t     (u32)suballoc_slot);\n\t\tgoto bail;\n\t}\n\n\tmutex_lock(&inode_alloc_inode->i_mutex);\n\tstatus = ocfs2_inode_lock(inode_alloc_inode, &alloc_bh, 0);\n\tif (status < 0) {\n\t\tmutex_unlock(&inode_alloc_inode->i_mutex);\n\t\tiput(inode_alloc_inode);\n\t\tmlog(ML_ERROR, \"lock on alloc inode on slot %u failed %d\\n\",\n\t\t     (u32)suballoc_slot, status);\n\t\tgoto bail;\n\t}\n\n\tstatus = ocfs2_test_suballoc_bit(osb, inode_alloc_inode, alloc_bh,\n\t\t\t\t\t group_blkno, blkno, suballoc_bit, res);\n\tif (status < 0)\n\t\tmlog(ML_ERROR, \"test suballoc bit failed %d\\n\", status);\n\n\tocfs2_inode_unlock(inode_alloc_inode, 0);\n\tmutex_unlock(&inode_alloc_inode->i_mutex);\n\n\tiput(inode_alloc_inode);\n\tbrelse(alloc_bh);\nbail:\n\tif (status)\n\t\tmlog_errno(status);\n\treturn status;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ocfs2_cluster_group_search(struct inode *inode,\n\t\t\t\t      struct buffer_head *group_bh,\n\t\t\t\t      u32 bits_wanted, u32 min_bits,\n\t\t\t\t      u64 max_block,\n\t\t\t\t      struct ocfs2_suballoc_result *res);",
            "static int ocfs2_block_group_search(struct inode *inode,\n\t\t\t\t    struct buffer_head *group_bh,\n\t\t\t\t    u32 bits_wanted, u32 min_bits,\n\t\t\t\t    u64 max_block,\n\t\t\t\t    struct ocfs2_suballoc_result *res);",
            "static int ocfs2_claim_suballoc_bits(struct ocfs2_alloc_context *ac,\n\t\t\t\t     handle_t *handle,\n\t\t\t\t     u32 bits_wanted,\n\t\t\t\t     u32 min_bits,\n\t\t\t\t     struct ocfs2_suballoc_result *res);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_cluster_group_search(struct inode *inode,\n\t\t\t\t      struct buffer_head *group_bh,\n\t\t\t\t      u32 bits_wanted, u32 min_bits,\n\t\t\t\t      u64 max_block,\n\t\t\t\t      struct ocfs2_suballoc_result *res);\nstatic int ocfs2_block_group_search(struct inode *inode,\n\t\t\t\t    struct buffer_head *group_bh,\n\t\t\t\t    u32 bits_wanted, u32 min_bits,\n\t\t\t\t    u64 max_block,\n\t\t\t\t    struct ocfs2_suballoc_result *res);\nstatic int ocfs2_claim_suballoc_bits(struct ocfs2_alloc_context *ac,\n\t\t\t\t     handle_t *handle,\n\t\t\t\t     u32 bits_wanted,\n\t\t\t\t     u32 min_bits,\n\t\t\t\t     struct ocfs2_suballoc_result *res);\n\nint ocfs2_test_inode_bit(struct ocfs2_super *osb, u64 blkno, int *res)\n{\n\tint status;\n\tu64 group_blkno = 0;\n\tu16 suballoc_bit = 0, suballoc_slot = 0;\n\tstruct inode *inode_alloc_inode;\n\tstruct buffer_head *alloc_bh = NULL;\n\n\ttrace_ocfs2_test_inode_bit((unsigned long long)blkno);\n\n\tstatus = ocfs2_get_suballoc_slot_bit(osb, blkno, &suballoc_slot,\n\t\t\t\t\t     &group_blkno, &suballoc_bit);\n\tif (status < 0) {\n\t\tmlog(ML_ERROR, \"get alloc slot and bit failed %d\\n\", status);\n\t\tgoto bail;\n\t}\n\n\tinode_alloc_inode =\n\t\tocfs2_get_system_file_inode(osb, INODE_ALLOC_SYSTEM_INODE,\n\t\t\t\t\t    suballoc_slot);\n\tif (!inode_alloc_inode) {\n\t\t/* the error code could be inaccurate, but we are not able to\n\t\t * get the correct one. */\n\t\tstatus = -EINVAL;\n\t\tmlog(ML_ERROR, \"unable to get alloc inode in slot %u\\n\",\n\t\t     (u32)suballoc_slot);\n\t\tgoto bail;\n\t}\n\n\tmutex_lock(&inode_alloc_inode->i_mutex);\n\tstatus = ocfs2_inode_lock(inode_alloc_inode, &alloc_bh, 0);\n\tif (status < 0) {\n\t\tmutex_unlock(&inode_alloc_inode->i_mutex);\n\t\tiput(inode_alloc_inode);\n\t\tmlog(ML_ERROR, \"lock on alloc inode on slot %u failed %d\\n\",\n\t\t     (u32)suballoc_slot, status);\n\t\tgoto bail;\n\t}\n\n\tstatus = ocfs2_test_suballoc_bit(osb, inode_alloc_inode, alloc_bh,\n\t\t\t\t\t group_blkno, blkno, suballoc_bit, res);\n\tif (status < 0)\n\t\tmlog(ML_ERROR, \"test suballoc bit failed %d\\n\", status);\n\n\tocfs2_inode_unlock(inode_alloc_inode, 0);\n\tmutex_unlock(&inode_alloc_inode->i_mutex);\n\n\tiput(inode_alloc_inode);\n\tbrelse(alloc_bh);\nbail:\n\tif (status)\n\t\tmlog_errno(status);\n\treturn status;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_nfs_sync_lock",
          "args": [
            "osb",
            "1"
          ],
          "line": 78
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_nfs_sync_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlmglue.c",
          "lines": "2623-2640",
          "snippet": "int ocfs2_nfs_sync_lock(struct ocfs2_super *osb, int ex)\n{\n\tint status;\n\tstruct ocfs2_lock_res *lockres = &osb->osb_nfs_sync_lockres;\n\n\tif (ocfs2_is_hard_readonly(osb))\n\t\treturn -EROFS;\n\n\tif (ocfs2_mount_local(osb))\n\t\treturn 0;\n\n\tstatus = ocfs2_cluster_lock(osb, lockres, ex ? LKM_EXMODE : LKM_PRMODE,\n\t\t\t\t    0, 0);\n\tif (status < 0)\n\t\tmlog(ML_ERROR, \"lock on nfs sync lock failed %d\\n\", status);\n\n\treturn status;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"refcounttree.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"stackglue.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dcache.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2_lockingver.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/time.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/kthread.h>",
            "#include <linux/mm.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct ocfs2_super *ocfs2_get_dentry_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_inode_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_file_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_qinfo_osb(struct ocfs2_lock_res *lockres);",
            "static void ocfs2_set_meta_lvb(struct ocfs2_lock_res *lockres);",
            "static void ocfs2_dentry_post_unlock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres);",
            "static void ocfs2_set_qinfo_lvb(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_downconvert_action(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_convert_action(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_attach_action(struct ocfs2_lock_res *lockres);",
            "static void ocfs2_schedule_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static void ocfs2_downconvert_on_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static void ocfs2_drop_osb_locks(struct ocfs2_super *osb);",
            "static int ocfs2_prepare_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\t        struct ocfs2_lock_res *lockres);",
            "static int ocfs2_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static void ocfs2_process_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *lockres);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"stackglue.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dcache.h\"\n#include \"alloc.h\"\n#include \"ocfs2_lockingver.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/quotaops.h>\n#include <linux/time.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/pagemap.h>\n#include <linux/kthread.h>\n#include <linux/mm.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic struct ocfs2_super *ocfs2_get_dentry_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_inode_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_file_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_qinfo_osb(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_set_meta_lvb(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_dentry_post_unlock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres);\nstatic void ocfs2_set_qinfo_lvb(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_downconvert_action(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_convert_action(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_attach_action(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_schedule_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_downconvert_on_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_drop_osb_locks(struct ocfs2_super *osb);\nstatic int ocfs2_prepare_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\t        struct ocfs2_lock_res *lockres);\nstatic int ocfs2_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_process_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *lockres);\n\nint ocfs2_nfs_sync_lock(struct ocfs2_super *osb, int ex)\n{\n\tint status;\n\tstruct ocfs2_lock_res *lockres = &osb->osb_nfs_sync_lockres;\n\n\tif (ocfs2_is_hard_readonly(osb))\n\t\treturn -EROFS;\n\n\tif (ocfs2_mount_local(osb))\n\t\treturn 0;\n\n\tstatus = ocfs2_cluster_lock(osb, lockres, ex ? LKM_EXMODE : LKM_PRMODE,\n\t\t\t\t    0, 0);\n\tif (status < 0)\n\t\tmlog(ML_ERROR, \"lock on nfs sync lock failed %d\\n\", status);\n\n\treturn status;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_ilookup",
          "args": [
            "sb",
            "blkno"
          ],
          "line": 66
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_ilookup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/inode.c",
          "lines": "116-126",
          "snippet": "struct inode *ocfs2_ilookup(struct super_block *sb, u64 blkno)\n{\n\tstruct ocfs2_find_inode_args args;\n\n\targs.fi_blkno = blkno;\n\targs.fi_flags = 0;\n\targs.fi_ino = ino_from_blkno(sb, blkno);\n\targs.fi_sysfile_type = 0;\n\n\treturn ilookup5(sb, blkno, ocfs2_find_actor, &args);\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"symlink.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"dir.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ocfs2_read_locked_inode(struct inode *inode,\n\t\t\t\t   struct ocfs2_find_inode_args *args);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"symlink.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"dir.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <asm/byteorder.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_read_locked_inode(struct inode *inode,\n\t\t\t\t   struct ocfs2_find_inode_args *args);\n\nstruct inode *ocfs2_ilookup(struct super_block *sb, u64 blkno)\n{\n\tstruct ocfs2_find_inode_args args;\n\n\targs.fi_blkno = blkno;\n\targs.fi_flags = 0;\n\targs.fi_ino = ino_from_blkno(sb, blkno);\n\targs.fi_sysfile_type = 0;\n\n\treturn ilookup5(sb, blkno, ocfs2_find_actor, &args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-ESTALE"
          ],
          "line": 62
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_ocfs2_get_dentry_begin",
          "args": [
            "sb",
            "handle",
            "(unsigned long long)blkno"
          ],
          "line": 59
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "OCFS2_SB",
          "args": [
            "sb"
          ],
          "line": 54
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"suballoc.h\"\n#include \"buffer_head_io.h\"\n#include \"inode.h\"\n#include \"export.h\"\n#include \"dcache.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic struct dentry *ocfs2_get_dentry(struct super_block *sb,\n\t\tstruct ocfs2_inode_handle *handle)\n{\n\tstruct inode *inode;\n\tstruct ocfs2_super *osb = OCFS2_SB(sb);\n\tu64 blkno = handle->ih_blkno;\n\tint status, set;\n\tstruct dentry *result;\n\n\ttrace_ocfs2_get_dentry_begin(sb, handle, (unsigned long long)blkno);\n\n\tif (blkno == 0) {\n\t\tresult = ERR_PTR(-ESTALE);\n\t\tgoto bail;\n\t}\n\n\tinode = ocfs2_ilookup(sb, blkno);\n\t/*\n\t * If the inode exists in memory, we only need to check it's\n\t * generation number\n\t */\n\tif (inode)\n\t\tgoto check_gen;\n\n\t/*\n\t * This will synchronize us against ocfs2_delete_inode() on\n\t * all nodes\n\t */\n\tstatus = ocfs2_nfs_sync_lock(osb, 1);\n\tif (status < 0) {\n\t\tmlog(ML_ERROR, \"getting nfs sync lock(EX) failed %d\\n\", status);\n\t\tgoto check_err;\n\t}\n\n\tstatus = ocfs2_test_inode_bit(osb, blkno, &set);\n\ttrace_ocfs2_get_dentry_test_bit(status, set);\n\tif (status < 0) {\n\t\tif (status == -EINVAL) {\n\t\t\t/*\n\t\t\t * The blkno NFS gave us doesn't even show up\n\t\t\t * as an inode, we return -ESTALE to be\n\t\t\t * nice\n\t\t\t */\n\t\t\tstatus = -ESTALE;\n\t\t} else\n\t\t\tmlog(ML_ERROR, \"test inode bit failed %d\\n\", status);\n\t\tgoto unlock_nfs_sync;\n\t}\n\n\t/* If the inode allocator bit is clear, this inode must be stale */\n\tif (!set) {\n\t\tstatus = -ESTALE;\n\t\tgoto unlock_nfs_sync;\n\t}\n\n\tinode = ocfs2_iget(osb, blkno, 0, 0);\n\nunlock_nfs_sync:\n\tocfs2_nfs_sync_unlock(osb, 1);\n\ncheck_err:\n\tif (status < 0) {\n\t\tif (status == -ESTALE) {\n\t\t\ttrace_ocfs2_get_dentry_stale((unsigned long long)blkno,\n\t\t\t\t\t\t     handle->ih_generation);\n\t\t}\n\t\tresult = ERR_PTR(status);\n\t\tgoto bail;\n\t}\n\n\tif (IS_ERR(inode)) {\n\t\tmlog_errno(PTR_ERR(inode));\n\t\tresult = (void *)inode;\n\t\tgoto bail;\n\t}\n\ncheck_gen:\n\tif (handle->ih_generation != inode->i_generation) {\n\t\tiput(inode);\n\t\ttrace_ocfs2_get_dentry_generation((unsigned long long)blkno,\n\t\t\t\t\t\t  handle->ih_generation,\n\t\t\t\t\t\t  inode->i_generation);\n\t\tresult = ERR_PTR(-ESTALE);\n\t\tgoto bail;\n\t}\n\n\tresult = d_obtain_alias(inode);\n\tif (IS_ERR(result))\n\t\tmlog_errno(PTR_ERR(result));\n\nbail:\n\ttrace_ocfs2_get_dentry_end(result);\n\treturn result;\n}"
  }
]