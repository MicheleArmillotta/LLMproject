[
  {
    "function_name": "ntfs_extent_mft_record_free",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/mft.c",
    "lines": "2784-2916",
    "snippet": "int ntfs_extent_mft_record_free(ntfs_inode *ni, MFT_RECORD *m)\n{\n\tunsigned long mft_no = ni->mft_no;\n\tntfs_volume *vol = ni->vol;\n\tntfs_inode *base_ni;\n\tntfs_inode **extent_nis;\n\tint i, err;\n\tle16 old_seq_no;\n\tu16 seq_no;\n\t\n\tBUG_ON(NInoAttr(ni));\n\tBUG_ON(ni->nr_extents != -1);\n\n\tmutex_lock(&ni->extent_lock);\n\tbase_ni = ni->ext.base_ntfs_ino;\n\tmutex_unlock(&ni->extent_lock);\n\n\tBUG_ON(base_ni->nr_extents <= 0);\n\n\tntfs_debug(\"Entering for extent inode 0x%lx, base inode 0x%lx.\\n\",\n\t\t\tmft_no, base_ni->mft_no);\n\n\tmutex_lock(&base_ni->extent_lock);\n\n\t/* Make sure we are holding the only reference to the extent inode. */\n\tif (atomic_read(&ni->count) > 2) {\n\t\tntfs_error(vol->sb, \"Tried to free busy extent inode 0x%lx, \"\n\t\t\t\t\"not freeing.\", base_ni->mft_no);\n\t\tmutex_unlock(&base_ni->extent_lock);\n\t\treturn -EBUSY;\n\t}\n\n\t/* Dissociate the ntfs inode from the base inode. */\n\textent_nis = base_ni->ext.extent_ntfs_inos;\n\terr = -ENOENT;\n\tfor (i = 0; i < base_ni->nr_extents; i++) {\n\t\tif (ni != extent_nis[i])\n\t\t\tcontinue;\n\t\textent_nis += i;\n\t\tbase_ni->nr_extents--;\n\t\tmemmove(extent_nis, extent_nis + 1, (base_ni->nr_extents - i) *\n\t\t\t\tsizeof(ntfs_inode*));\n\t\terr = 0;\n\t\tbreak;\n\t}\n\n\tmutex_unlock(&base_ni->extent_lock);\n\n\tif (unlikely(err)) {\n\t\tntfs_error(vol->sb, \"Extent inode 0x%lx is not attached to \"\n\t\t\t\t\"its base inode 0x%lx.\", mft_no,\n\t\t\t\tbase_ni->mft_no);\n\t\tBUG();\n\t}\n\n\t/*\n\t * The extent inode is no longer attached to the base inode so no one\n\t * can get a reference to it any more.\n\t */\n\n\t/* Mark the mft record as not in use. */\n\tm->flags &= ~MFT_RECORD_IN_USE;\n\n\t/* Increment the sequence number, skipping zero, if it is not zero. */\n\told_seq_no = m->sequence_number;\n\tseq_no = le16_to_cpu(old_seq_no);\n\tif (seq_no == 0xffff)\n\t\tseq_no = 1;\n\telse if (seq_no)\n\t\tseq_no++;\n\tm->sequence_number = cpu_to_le16(seq_no);\n\n\t/*\n\t * Set the ntfs inode dirty and write it out.  We do not need to worry\n\t * about the base inode here since whatever caused the extent mft\n\t * record to be freed is guaranteed to do it already.\n\t */\n\tNInoSetDirty(ni);\n\terr = write_mft_record(ni, m, 0);\n\tif (unlikely(err)) {\n\t\tntfs_error(vol->sb, \"Failed to write mft record 0x%lx, not \"\n\t\t\t\t\"freeing.\", mft_no);\n\t\tgoto rollback;\n\t}\nrollback_error:\n\t/* Unmap and throw away the now freed extent inode. */\n\tunmap_extent_mft_record(ni);\n\tntfs_clear_extent_inode(ni);\n\n\t/* Clear the bit in the $MFT/$BITMAP corresponding to this record. */\n\tdown_write(&vol->mftbmp_lock);\n\terr = ntfs_bitmap_clear_bit(vol->mftbmp_ino, mft_no);\n\tup_write(&vol->mftbmp_lock);\n\tif (unlikely(err)) {\n\t\t/*\n\t\t * The extent inode is gone but we failed to deallocate it in\n\t\t * the mft bitmap.  Just emit a warning and leave the volume\n\t\t * dirty on umount.\n\t\t */\n\t\tntfs_error(vol->sb, \"Failed to clear bit in mft bitmap.%s\", es);\n\t\tNVolSetErrors(vol);\n\t}\n\treturn 0;\nrollback:\n\t/* Rollback what we did... */\n\tmutex_lock(&base_ni->extent_lock);\n\textent_nis = base_ni->ext.extent_ntfs_inos;\n\tif (!(base_ni->nr_extents & 3)) {\n\t\tint new_size = (base_ni->nr_extents + 4) * sizeof(ntfs_inode*);\n\n\t\textent_nis = kmalloc(new_size, GFP_NOFS);\n\t\tif (unlikely(!extent_nis)) {\n\t\t\tntfs_error(vol->sb, \"Failed to allocate internal \"\n\t\t\t\t\t\"buffer during rollback.%s\", es);\n\t\t\tmutex_unlock(&base_ni->extent_lock);\n\t\t\tNVolSetErrors(vol);\n\t\t\tgoto rollback_error;\n\t\t}\n\t\tif (base_ni->nr_extents) {\n\t\t\tBUG_ON(!base_ni->ext.extent_ntfs_inos);\n\t\t\tmemcpy(extent_nis, base_ni->ext.extent_ntfs_inos,\n\t\t\t\t\tnew_size - 4 * sizeof(ntfs_inode*));\n\t\t\tkfree(base_ni->ext.extent_ntfs_inos);\n\t\t}\n\t\tbase_ni->ext.extent_ntfs_inos = extent_nis;\n\t}\n\tm->flags |= MFT_RECORD_IN_USE;\n\tm->sequence_number = old_seq_no;\n\textent_nis[base_ni->nr_extents++] = ni;\n\tmutex_unlock(&base_ni->extent_lock);\n\tmark_mft_record_dirty(ni);\n\treturn err;\n}",
    "includes": [
      "#include \"ntfs.h\"",
      "#include \"mft.h\"",
      "#include \"malloc.h\"",
      "#include \"lcnalloc.h\"",
      "#include \"dir.h\"",
      "#include \"debug.h\"",
      "#include \"bitmap.h\"",
      "#include \"aops.h\"",
      "#include \"attrib.h\"",
      "#include <linux/swap.h>",
      "#include <linux/slab.h>",
      "#include <linux/buffer_head.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mark_mft_record_dirty",
          "args": [
            "ni"
          ],
          "line": 2914
        },
        "resolved": true,
        "details": {
          "function_name": "__mark_mft_record_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/mft.c",
          "lines": "395-410",
          "snippet": "void __mark_mft_record_dirty(ntfs_inode *ni)\n{\n\tntfs_inode *base_ni;\n\n\tntfs_debug(\"Entering for inode 0x%lx.\", ni->mft_no);\n\tBUG_ON(NInoAttr(ni));\n\tmark_ntfs_record_dirty(ni->page, ni->page_ofs);\n\t/* Determine the base vfs inode and mark it dirty, too. */\n\tmutex_lock(&ni->extent_lock);\n\tif (likely(ni->nr_extents >= 0))\n\t\tbase_ni = ni;\n\telse\n\t\tbase_ni = ni->ext.base_ntfs_ino;\n\tmutex_unlock(&ni->extent_lock);\n\t__mark_inode_dirty(VFS_I(base_ni), I_DIRTY_SYNC | I_DIRTY_DATASYNC);\n}",
          "includes": [
            "#include \"ntfs.h\"",
            "#include \"mft.h\"",
            "#include \"malloc.h\"",
            "#include \"lcnalloc.h\"",
            "#include \"dir.h\"",
            "#include \"debug.h\"",
            "#include \"bitmap.h\"",
            "#include \"aops.h\"",
            "#include \"attrib.h\"",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ntfs.h\"\n#include \"mft.h\"\n#include \"malloc.h\"\n#include \"lcnalloc.h\"\n#include \"dir.h\"\n#include \"debug.h\"\n#include \"bitmap.h\"\n#include \"aops.h\"\n#include \"attrib.h\"\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n\nvoid __mark_mft_record_dirty(ntfs_inode *ni)\n{\n\tntfs_inode *base_ni;\n\n\tntfs_debug(\"Entering for inode 0x%lx.\", ni->mft_no);\n\tBUG_ON(NInoAttr(ni));\n\tmark_ntfs_record_dirty(ni->page, ni->page_ofs);\n\t/* Determine the base vfs inode and mark it dirty, too. */\n\tmutex_lock(&ni->extent_lock);\n\tif (likely(ni->nr_extents >= 0))\n\t\tbase_ni = ni;\n\telse\n\t\tbase_ni = ni->ext.base_ntfs_ino;\n\tmutex_unlock(&ni->extent_lock);\n\t__mark_inode_dirty(VFS_I(base_ni), I_DIRTY_SYNC | I_DIRTY_DATASYNC);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&base_ni->extent_lock"
          ],
          "line": 2913
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "base_ni->ext.extent_ntfs_inos"
          ],
          "line": 2906
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "extent_nis",
            "base_ni->ext.extent_ntfs_inos",
            "new_size - 4 * sizeof(ntfs_inode*)"
          ],
          "line": 2904
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!base_ni->ext.extent_ntfs_inos"
          ],
          "line": 2903
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NVolSetErrors",
          "args": [
            "vol"
          ],
          "line": 2899
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&base_ni->extent_lock"
          ],
          "line": 2898
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntfs_error",
          "args": [
            "vol->sb",
            "\"Failed to allocate internal \"\n\t\t\t\t\t\"buffer during rollback.%s\"",
            "es"
          ],
          "line": 2896
        },
        "resolved": true,
        "details": {
          "function_name": "__ntfs_error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/debug.c",
          "lines": "86-108",
          "snippet": "void __ntfs_error(const char *function, const struct super_block *sb,\n\t\tconst char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\tint flen = 0;\n\n#ifndef DEBUG\n\tif (!printk_ratelimit())\n\t\treturn;\n#endif\n\tif (function)\n\t\tflen = strlen(function);\n\tva_start(args, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\tif (sb)\n\t\tpr_err(\"(device %s): %s(): %pV\\n\",\n\t\t       sb->s_id, flen ? function : \"\", &vaf);\n\telse\n\t\tpr_err(\"%s(): %pV\\n\", flen ? function : \"\", &vaf);\n\tva_end(args);\n}",
          "includes": [
            "#include \"debug.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"debug.h\"\n\nvoid __ntfs_error(const char *function, const struct super_block *sb,\n\t\tconst char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\tint flen = 0;\n\n#ifndef DEBUG\n\tif (!printk_ratelimit())\n\t\treturn;\n#endif\n\tif (function)\n\t\tflen = strlen(function);\n\tva_start(args, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\tif (sb)\n\t\tpr_err(\"(device %s): %s(): %pV\\n\",\n\t\t       sb->s_id, flen ? function : \"\", &vaf);\n\telse\n\t\tpr_err(\"%s(): %pV\\n\", flen ? function : \"\", &vaf);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!extent_nis"
          ],
          "line": 2895
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmalloc",
          "args": [
            "new_size",
            "GFP_NOFS"
          ],
          "line": 2894
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_dx_dir_kmalloc_leaves",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
          "lines": "2534-2546",
          "snippet": "static struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&base_ni->extent_lock"
          ],
          "line": 2889
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NVolSetErrors",
          "args": [
            "vol"
          ],
          "line": 2884
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "err"
          ],
          "line": 2877
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "up_write",
          "args": [
            "&vol->mftbmp_lock"
          ],
          "line": 2876
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntfs_bitmap_clear_bit",
          "args": [
            "vol->mftbmp_ino",
            "mft_no"
          ],
          "line": 2875
        },
        "resolved": true,
        "details": {
          "function_name": "ntfs_bitmap_clear_bit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/bitmap.h",
          "lines": "111-114",
          "snippet": "static inline int ntfs_bitmap_clear_bit(struct inode *vi, const s64 bit)\n{\n\treturn ntfs_bitmap_clear_run(vi, bit, 1);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <linux/fs.h>\n\nstatic inline int ntfs_bitmap_clear_bit(struct inode *vi, const s64 bit)\n{\n\treturn ntfs_bitmap_clear_run(vi, bit, 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "down_write",
          "args": [
            "&vol->mftbmp_lock"
          ],
          "line": 2874
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntfs_clear_extent_inode",
          "args": [
            "ni"
          ],
          "line": 2871
        },
        "resolved": true,
        "details": {
          "function_name": "ntfs_clear_extent_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/inode.c",
          "lines": "2227-2247",
          "snippet": "void ntfs_clear_extent_inode(ntfs_inode *ni)\n{\n\tntfs_debug(\"Entering for inode 0x%lx.\", ni->mft_no);\n\n\tBUG_ON(NInoAttr(ni));\n\tBUG_ON(ni->nr_extents != -1);\n\n#ifdef NTFS_RW\n\tif (NInoDirty(ni)) {\n\t\tif (!is_bad_inode(VFS_I(ni->ext.base_ntfs_ino)))\n\t\t\tntfs_error(ni->vol->sb, \"Clearing dirty extent inode!  \"\n\t\t\t\t\t\"Losing data!  This is a BUG!!!\");\n\t\t// FIXME:  Do something!!!\n\t}\n#endif /* NTFS_RW */\n\n\t__ntfs_clear_inode(ni);\n\n\t/* Bye, bye... */\n\tntfs_destroy_extent_inode(ni);\n}",
          "includes": [
            "#include \"ntfs.h\"",
            "#include \"time.h\"",
            "#include \"mft.h\"",
            "#include \"malloc.h\"",
            "#include \"lcnalloc.h\"",
            "#include \"inode.h\"",
            "#include \"debug.h\"",
            "#include \"dir.h\"",
            "#include \"bitmap.h\"",
            "#include \"attrib.h\"",
            "#include \"aops.h\"",
            "#include <linux/aio.h>",
            "#include <linux/log2.h>",
            "#include <linux/slab.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mutex.h>",
            "#include <linux/mount.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ntfs.h\"\n#include \"time.h\"\n#include \"mft.h\"\n#include \"malloc.h\"\n#include \"lcnalloc.h\"\n#include \"inode.h\"\n#include \"debug.h\"\n#include \"dir.h\"\n#include \"bitmap.h\"\n#include \"attrib.h\"\n#include \"aops.h\"\n#include <linux/aio.h>\n#include <linux/log2.h>\n#include <linux/slab.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/mutex.h>\n#include <linux/mount.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/buffer_head.h>\n\nvoid ntfs_clear_extent_inode(ntfs_inode *ni)\n{\n\tntfs_debug(\"Entering for inode 0x%lx.\", ni->mft_no);\n\n\tBUG_ON(NInoAttr(ni));\n\tBUG_ON(ni->nr_extents != -1);\n\n#ifdef NTFS_RW\n\tif (NInoDirty(ni)) {\n\t\tif (!is_bad_inode(VFS_I(ni->ext.base_ntfs_ino)))\n\t\t\tntfs_error(ni->vol->sb, \"Clearing dirty extent inode!  \"\n\t\t\t\t\t\"Losing data!  This is a BUG!!!\");\n\t\t// FIXME:  Do something!!!\n\t}\n#endif /* NTFS_RW */\n\n\t__ntfs_clear_inode(ni);\n\n\t/* Bye, bye... */\n\tntfs_destroy_extent_inode(ni);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unmap_extent_mft_record",
          "args": [
            "ni"
          ],
          "line": 2870
        },
        "resolved": true,
        "details": {
          "function_name": "unmap_extent_mft_record",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/mft.h",
          "lines": "38-42",
          "snippet": "static inline void unmap_extent_mft_record(ntfs_inode *ni)\n{\n\tunmap_mft_record(ni);\n\treturn;\n}",
          "includes": [
            "#include \"inode.h\"",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"inode.h\"\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/fs.h>\n\nstatic inline void unmap_extent_mft_record(ntfs_inode *ni)\n{\n\tunmap_mft_record(ni);\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "err"
          ],
          "line": 2863
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "write_mft_record",
          "args": [
            "ni",
            "m",
            "0"
          ],
          "line": 2862
        },
        "resolved": true,
        "details": {
          "function_name": "write_mft_record_nolock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/mft.c",
          "lines": "669-844",
          "snippet": "int write_mft_record_nolock(ntfs_inode *ni, MFT_RECORD *m, int sync)\n{\n\tntfs_volume *vol = ni->vol;\n\tstruct page *page = ni->page;\n\tunsigned int blocksize = vol->sb->s_blocksize;\n\tunsigned char blocksize_bits = vol->sb->s_blocksize_bits;\n\tint max_bhs = vol->mft_record_size / blocksize;\n\tstruct buffer_head *bhs[max_bhs];\n\tstruct buffer_head *bh, *head;\n\trunlist_element *rl;\n\tunsigned int block_start, block_end, m_start, m_end;\n\tint i_bhs, nr_bhs, err = 0;\n\n\tntfs_debug(\"Entering for inode 0x%lx.\", ni->mft_no);\n\tBUG_ON(NInoAttr(ni));\n\tBUG_ON(!max_bhs);\n\tBUG_ON(!PageLocked(page));\n\t/*\n\t * If the ntfs_inode is clean no need to do anything.  If it is dirty,\n\t * mark it as clean now so that it can be redirtied later on if needed.\n\t * There is no danger of races since the caller is holding the locks\n\t * for the mft record @m and the page it is in.\n\t */\n\tif (!NInoTestClearDirty(ni))\n\t\tgoto done;\n\tbh = head = page_buffers(page);\n\tBUG_ON(!bh);\n\trl = NULL;\n\tnr_bhs = 0;\n\tblock_start = 0;\n\tm_start = ni->page_ofs;\n\tm_end = m_start + vol->mft_record_size;\n\tdo {\n\t\tblock_end = block_start + blocksize;\n\t\t/* If the buffer is outside the mft record, skip it. */\n\t\tif (block_end <= m_start)\n\t\t\tcontinue;\n\t\tif (unlikely(block_start >= m_end))\n\t\t\tbreak;\n\t\t/*\n\t\t * If this block is not the first one in the record, we ignore\n\t\t * the buffer's dirty state because we could have raced with a\n\t\t * parallel mark_ntfs_record_dirty().\n\t\t */\n\t\tif (block_start == m_start) {\n\t\t\t/* This block is the first one in the record. */\n\t\t\tif (!buffer_dirty(bh)) {\n\t\t\t\tBUG_ON(nr_bhs);\n\t\t\t\t/* Clean records are not written out. */\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\t/* Need to map the buffer if it is not mapped already. */\n\t\tif (unlikely(!buffer_mapped(bh))) {\n\t\t\tVCN vcn;\n\t\t\tLCN lcn;\n\t\t\tunsigned int vcn_ofs;\n\n\t\t\tbh->b_bdev = vol->sb->s_bdev;\n\t\t\t/* Obtain the vcn and offset of the current block. */\n\t\t\tvcn = ((VCN)ni->mft_no << vol->mft_record_size_bits) +\n\t\t\t\t\t(block_start - m_start);\n\t\t\tvcn_ofs = vcn & vol->cluster_size_mask;\n\t\t\tvcn >>= vol->cluster_size_bits;\n\t\t\tif (!rl) {\n\t\t\t\tdown_read(&NTFS_I(vol->mft_ino)->runlist.lock);\n\t\t\t\trl = NTFS_I(vol->mft_ino)->runlist.rl;\n\t\t\t\tBUG_ON(!rl);\n\t\t\t}\n\t\t\t/* Seek to element containing target vcn. */\n\t\t\twhile (rl->length && rl[1].vcn <= vcn)\n\t\t\t\trl++;\n\t\t\tlcn = ntfs_rl_vcn_to_lcn(rl, vcn);\n\t\t\t/* For $MFT, only lcn >= 0 is a successful remap. */\n\t\t\tif (likely(lcn >= 0)) {\n\t\t\t\t/* Setup buffer head to correct block. */\n\t\t\t\tbh->b_blocknr = ((lcn <<\n\t\t\t\t\t\tvol->cluster_size_bits) +\n\t\t\t\t\t\tvcn_ofs) >> blocksize_bits;\n\t\t\t\tset_buffer_mapped(bh);\n\t\t\t} else {\n\t\t\t\tbh->b_blocknr = -1;\n\t\t\t\tntfs_error(vol->sb, \"Cannot write mft record \"\n\t\t\t\t\t\t\"0x%lx because its location \"\n\t\t\t\t\t\t\"on disk could not be \"\n\t\t\t\t\t\t\"determined (error code %lli).\",\n\t\t\t\t\t\tni->mft_no, (long long)lcn);\n\t\t\t\terr = -EIO;\n\t\t\t}\n\t\t}\n\t\tBUG_ON(!buffer_uptodate(bh));\n\t\tBUG_ON(!nr_bhs && (m_start != block_start));\n\t\tBUG_ON(nr_bhs >= max_bhs);\n\t\tbhs[nr_bhs++] = bh;\n\t\tBUG_ON((nr_bhs >= max_bhs) && (m_end != block_end));\n\t} while (block_start = block_end, (bh = bh->b_this_page) != head);\n\tif (unlikely(rl))\n\t\tup_read(&NTFS_I(vol->mft_ino)->runlist.lock);\n\tif (!nr_bhs)\n\t\tgoto done;\n\tif (unlikely(err))\n\t\tgoto cleanup_out;\n\t/* Apply the mst protection fixups. */\n\terr = pre_write_mst_fixup((NTFS_RECORD*)m, vol->mft_record_size);\n\tif (err) {\n\t\tntfs_error(vol->sb, \"Failed to apply mst fixups!\");\n\t\tgoto cleanup_out;\n\t}\n\tflush_dcache_mft_record_page(ni);\n\t/* Lock buffers and start synchronous write i/o on them. */\n\tfor (i_bhs = 0; i_bhs < nr_bhs; i_bhs++) {\n\t\tstruct buffer_head *tbh = bhs[i_bhs];\n\n\t\tif (!trylock_buffer(tbh))\n\t\t\tBUG();\n\t\tBUG_ON(!buffer_uptodate(tbh));\n\t\tclear_buffer_dirty(tbh);\n\t\tget_bh(tbh);\n\t\ttbh->b_end_io = end_buffer_write_sync;\n\t\tsubmit_bh(WRITE, tbh);\n\t}\n\t/* Synchronize the mft mirror now if not @sync. */\n\tif (!sync && ni->mft_no < vol->mftmirr_size)\n\t\tntfs_sync_mft_mirror(vol, ni->mft_no, m, sync);\n\t/* Wait on i/o completion of buffers. */\n\tfor (i_bhs = 0; i_bhs < nr_bhs; i_bhs++) {\n\t\tstruct buffer_head *tbh = bhs[i_bhs];\n\n\t\twait_on_buffer(tbh);\n\t\tif (unlikely(!buffer_uptodate(tbh))) {\n\t\t\terr = -EIO;\n\t\t\t/*\n\t\t\t * Set the buffer uptodate so the page and buffer\n\t\t\t * states do not become out of sync.\n\t\t\t */\n\t\t\tif (PageUptodate(page))\n\t\t\t\tset_buffer_uptodate(tbh);\n\t\t}\n\t}\n\t/* If @sync, now synchronize the mft mirror. */\n\tif (sync && ni->mft_no < vol->mftmirr_size)\n\t\tntfs_sync_mft_mirror(vol, ni->mft_no, m, sync);\n\t/* Remove the mst protection fixups again. */\n\tpost_write_mst_fixup((NTFS_RECORD*)m);\n\tflush_dcache_mft_record_page(ni);\n\tif (unlikely(err)) {\n\t\t/* I/O error during writing.  This is really bad! */\n\t\tntfs_error(vol->sb, \"I/O error while writing mft record \"\n\t\t\t\t\"0x%lx!  Marking base inode as bad.  You \"\n\t\t\t\t\"should unmount the volume and run chkdsk.\",\n\t\t\t\tni->mft_no);\n\t\tgoto err_out;\n\t}\ndone:\n\tntfs_debug(\"Done.\");\n\treturn 0;\ncleanup_out:\n\t/* Clean the buffers. */\n\tfor (i_bhs = 0; i_bhs < nr_bhs; i_bhs++)\n\t\tclear_buffer_dirty(bhs[i_bhs]);\nerr_out:\n\t/*\n\t * Current state: all buffers are clean, unlocked, and uptodate.\n\t * The caller should mark the base inode as bad so that no more i/o\n\t * happens.  ->clear_inode() will still be invoked so all extent inodes\n\t * and other allocated memory will be freed.\n\t */\n\tif (err == -ENOMEM) {\n\t\tntfs_error(vol->sb, \"Not enough memory to write mft record.  \"\n\t\t\t\t\"Redirtying so the write is retried later.\");\n\t\tmark_mft_record_dirty(ni);\n\t\terr = 0;\n\t} else\n\t\tNVolSetErrors(vol);\n\treturn err;\n}",
          "includes": [
            "#include \"ntfs.h\"",
            "#include \"mft.h\"",
            "#include \"malloc.h\"",
            "#include \"lcnalloc.h\"",
            "#include \"dir.h\"",
            "#include \"debug.h\"",
            "#include \"bitmap.h\"",
            "#include \"aops.h\"",
            "#include \"attrib.h\"",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ntfs.h\"\n#include \"mft.h\"\n#include \"malloc.h\"\n#include \"lcnalloc.h\"\n#include \"dir.h\"\n#include \"debug.h\"\n#include \"bitmap.h\"\n#include \"aops.h\"\n#include \"attrib.h\"\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n\nint write_mft_record_nolock(ntfs_inode *ni, MFT_RECORD *m, int sync)\n{\n\tntfs_volume *vol = ni->vol;\n\tstruct page *page = ni->page;\n\tunsigned int blocksize = vol->sb->s_blocksize;\n\tunsigned char blocksize_bits = vol->sb->s_blocksize_bits;\n\tint max_bhs = vol->mft_record_size / blocksize;\n\tstruct buffer_head *bhs[max_bhs];\n\tstruct buffer_head *bh, *head;\n\trunlist_element *rl;\n\tunsigned int block_start, block_end, m_start, m_end;\n\tint i_bhs, nr_bhs, err = 0;\n\n\tntfs_debug(\"Entering for inode 0x%lx.\", ni->mft_no);\n\tBUG_ON(NInoAttr(ni));\n\tBUG_ON(!max_bhs);\n\tBUG_ON(!PageLocked(page));\n\t/*\n\t * If the ntfs_inode is clean no need to do anything.  If it is dirty,\n\t * mark it as clean now so that it can be redirtied later on if needed.\n\t * There is no danger of races since the caller is holding the locks\n\t * for the mft record @m and the page it is in.\n\t */\n\tif (!NInoTestClearDirty(ni))\n\t\tgoto done;\n\tbh = head = page_buffers(page);\n\tBUG_ON(!bh);\n\trl = NULL;\n\tnr_bhs = 0;\n\tblock_start = 0;\n\tm_start = ni->page_ofs;\n\tm_end = m_start + vol->mft_record_size;\n\tdo {\n\t\tblock_end = block_start + blocksize;\n\t\t/* If the buffer is outside the mft record, skip it. */\n\t\tif (block_end <= m_start)\n\t\t\tcontinue;\n\t\tif (unlikely(block_start >= m_end))\n\t\t\tbreak;\n\t\t/*\n\t\t * If this block is not the first one in the record, we ignore\n\t\t * the buffer's dirty state because we could have raced with a\n\t\t * parallel mark_ntfs_record_dirty().\n\t\t */\n\t\tif (block_start == m_start) {\n\t\t\t/* This block is the first one in the record. */\n\t\t\tif (!buffer_dirty(bh)) {\n\t\t\t\tBUG_ON(nr_bhs);\n\t\t\t\t/* Clean records are not written out. */\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\t/* Need to map the buffer if it is not mapped already. */\n\t\tif (unlikely(!buffer_mapped(bh))) {\n\t\t\tVCN vcn;\n\t\t\tLCN lcn;\n\t\t\tunsigned int vcn_ofs;\n\n\t\t\tbh->b_bdev = vol->sb->s_bdev;\n\t\t\t/* Obtain the vcn and offset of the current block. */\n\t\t\tvcn = ((VCN)ni->mft_no << vol->mft_record_size_bits) +\n\t\t\t\t\t(block_start - m_start);\n\t\t\tvcn_ofs = vcn & vol->cluster_size_mask;\n\t\t\tvcn >>= vol->cluster_size_bits;\n\t\t\tif (!rl) {\n\t\t\t\tdown_read(&NTFS_I(vol->mft_ino)->runlist.lock);\n\t\t\t\trl = NTFS_I(vol->mft_ino)->runlist.rl;\n\t\t\t\tBUG_ON(!rl);\n\t\t\t}\n\t\t\t/* Seek to element containing target vcn. */\n\t\t\twhile (rl->length && rl[1].vcn <= vcn)\n\t\t\t\trl++;\n\t\t\tlcn = ntfs_rl_vcn_to_lcn(rl, vcn);\n\t\t\t/* For $MFT, only lcn >= 0 is a successful remap. */\n\t\t\tif (likely(lcn >= 0)) {\n\t\t\t\t/* Setup buffer head to correct block. */\n\t\t\t\tbh->b_blocknr = ((lcn <<\n\t\t\t\t\t\tvol->cluster_size_bits) +\n\t\t\t\t\t\tvcn_ofs) >> blocksize_bits;\n\t\t\t\tset_buffer_mapped(bh);\n\t\t\t} else {\n\t\t\t\tbh->b_blocknr = -1;\n\t\t\t\tntfs_error(vol->sb, \"Cannot write mft record \"\n\t\t\t\t\t\t\"0x%lx because its location \"\n\t\t\t\t\t\t\"on disk could not be \"\n\t\t\t\t\t\t\"determined (error code %lli).\",\n\t\t\t\t\t\tni->mft_no, (long long)lcn);\n\t\t\t\terr = -EIO;\n\t\t\t}\n\t\t}\n\t\tBUG_ON(!buffer_uptodate(bh));\n\t\tBUG_ON(!nr_bhs && (m_start != block_start));\n\t\tBUG_ON(nr_bhs >= max_bhs);\n\t\tbhs[nr_bhs++] = bh;\n\t\tBUG_ON((nr_bhs >= max_bhs) && (m_end != block_end));\n\t} while (block_start = block_end, (bh = bh->b_this_page) != head);\n\tif (unlikely(rl))\n\t\tup_read(&NTFS_I(vol->mft_ino)->runlist.lock);\n\tif (!nr_bhs)\n\t\tgoto done;\n\tif (unlikely(err))\n\t\tgoto cleanup_out;\n\t/* Apply the mst protection fixups. */\n\terr = pre_write_mst_fixup((NTFS_RECORD*)m, vol->mft_record_size);\n\tif (err) {\n\t\tntfs_error(vol->sb, \"Failed to apply mst fixups!\");\n\t\tgoto cleanup_out;\n\t}\n\tflush_dcache_mft_record_page(ni);\n\t/* Lock buffers and start synchronous write i/o on them. */\n\tfor (i_bhs = 0; i_bhs < nr_bhs; i_bhs++) {\n\t\tstruct buffer_head *tbh = bhs[i_bhs];\n\n\t\tif (!trylock_buffer(tbh))\n\t\t\tBUG();\n\t\tBUG_ON(!buffer_uptodate(tbh));\n\t\tclear_buffer_dirty(tbh);\n\t\tget_bh(tbh);\n\t\ttbh->b_end_io = end_buffer_write_sync;\n\t\tsubmit_bh(WRITE, tbh);\n\t}\n\t/* Synchronize the mft mirror now if not @sync. */\n\tif (!sync && ni->mft_no < vol->mftmirr_size)\n\t\tntfs_sync_mft_mirror(vol, ni->mft_no, m, sync);\n\t/* Wait on i/o completion of buffers. */\n\tfor (i_bhs = 0; i_bhs < nr_bhs; i_bhs++) {\n\t\tstruct buffer_head *tbh = bhs[i_bhs];\n\n\t\twait_on_buffer(tbh);\n\t\tif (unlikely(!buffer_uptodate(tbh))) {\n\t\t\terr = -EIO;\n\t\t\t/*\n\t\t\t * Set the buffer uptodate so the page and buffer\n\t\t\t * states do not become out of sync.\n\t\t\t */\n\t\t\tif (PageUptodate(page))\n\t\t\t\tset_buffer_uptodate(tbh);\n\t\t}\n\t}\n\t/* If @sync, now synchronize the mft mirror. */\n\tif (sync && ni->mft_no < vol->mftmirr_size)\n\t\tntfs_sync_mft_mirror(vol, ni->mft_no, m, sync);\n\t/* Remove the mst protection fixups again. */\n\tpost_write_mst_fixup((NTFS_RECORD*)m);\n\tflush_dcache_mft_record_page(ni);\n\tif (unlikely(err)) {\n\t\t/* I/O error during writing.  This is really bad! */\n\t\tntfs_error(vol->sb, \"I/O error while writing mft record \"\n\t\t\t\t\"0x%lx!  Marking base inode as bad.  You \"\n\t\t\t\t\"should unmount the volume and run chkdsk.\",\n\t\t\t\tni->mft_no);\n\t\tgoto err_out;\n\t}\ndone:\n\tntfs_debug(\"Done.\");\n\treturn 0;\ncleanup_out:\n\t/* Clean the buffers. */\n\tfor (i_bhs = 0; i_bhs < nr_bhs; i_bhs++)\n\t\tclear_buffer_dirty(bhs[i_bhs]);\nerr_out:\n\t/*\n\t * Current state: all buffers are clean, unlocked, and uptodate.\n\t * The caller should mark the base inode as bad so that no more i/o\n\t * happens.  ->clear_inode() will still be invoked so all extent inodes\n\t * and other allocated memory will be freed.\n\t */\n\tif (err == -ENOMEM) {\n\t\tntfs_error(vol->sb, \"Not enough memory to write mft record.  \"\n\t\t\t\t\"Redirtying so the write is retried later.\");\n\t\tmark_mft_record_dirty(ni);\n\t\terr = 0;\n\t} else\n\t\tNVolSetErrors(vol);\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "NInoSetDirty",
          "args": [
            "ni"
          ],
          "line": 2861
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "seq_no"
          ],
          "line": 2854
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le16_to_cpu",
          "args": [
            "old_seq_no"
          ],
          "line": 2849
        },
        "resolved": true,
        "details": {
          "function_name": "sle16_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "48-51",
          "snippet": "static inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG",
          "args": [],
          "line": 2836
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "err"
          ],
          "line": 2832
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&base_ni->extent_lock"
          ],
          "line": 2830
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memmove",
          "args": [
            "extent_nis",
            "extent_nis + 1",
            "(base_ni->nr_extents - i) *\n\t\t\t\tsizeof(ntfs_inode*)"
          ],
          "line": 2824
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&base_ni->extent_lock"
          ],
          "line": 2812
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&ni->count"
          ],
          "line": 2809
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&base_ni->extent_lock"
          ],
          "line": 2806
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntfs_debug",
          "args": [
            "\"Entering for extent inode 0x%lx, base inode 0x%lx.\\n\"",
            "mft_no",
            "base_ni->mft_no"
          ],
          "line": 2803
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "base_ni->nr_extents <= 0"
          ],
          "line": 2801
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&ni->extent_lock"
          ],
          "line": 2799
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&ni->extent_lock"
          ],
          "line": 2797
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "ni->nr_extents != -1"
          ],
          "line": 2795
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "NInoAttr(ni)"
          ],
          "line": 2794
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NInoAttr",
          "args": [
            "ni"
          ],
          "line": 2794
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ntfs.h\"\n#include \"mft.h\"\n#include \"malloc.h\"\n#include \"lcnalloc.h\"\n#include \"dir.h\"\n#include \"debug.h\"\n#include \"bitmap.h\"\n#include \"aops.h\"\n#include \"attrib.h\"\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n\nint ntfs_extent_mft_record_free(ntfs_inode *ni, MFT_RECORD *m)\n{\n\tunsigned long mft_no = ni->mft_no;\n\tntfs_volume *vol = ni->vol;\n\tntfs_inode *base_ni;\n\tntfs_inode **extent_nis;\n\tint i, err;\n\tle16 old_seq_no;\n\tu16 seq_no;\n\t\n\tBUG_ON(NInoAttr(ni));\n\tBUG_ON(ni->nr_extents != -1);\n\n\tmutex_lock(&ni->extent_lock);\n\tbase_ni = ni->ext.base_ntfs_ino;\n\tmutex_unlock(&ni->extent_lock);\n\n\tBUG_ON(base_ni->nr_extents <= 0);\n\n\tntfs_debug(\"Entering for extent inode 0x%lx, base inode 0x%lx.\\n\",\n\t\t\tmft_no, base_ni->mft_no);\n\n\tmutex_lock(&base_ni->extent_lock);\n\n\t/* Make sure we are holding the only reference to the extent inode. */\n\tif (atomic_read(&ni->count) > 2) {\n\t\tntfs_error(vol->sb, \"Tried to free busy extent inode 0x%lx, \"\n\t\t\t\t\"not freeing.\", base_ni->mft_no);\n\t\tmutex_unlock(&base_ni->extent_lock);\n\t\treturn -EBUSY;\n\t}\n\n\t/* Dissociate the ntfs inode from the base inode. */\n\textent_nis = base_ni->ext.extent_ntfs_inos;\n\terr = -ENOENT;\n\tfor (i = 0; i < base_ni->nr_extents; i++) {\n\t\tif (ni != extent_nis[i])\n\t\t\tcontinue;\n\t\textent_nis += i;\n\t\tbase_ni->nr_extents--;\n\t\tmemmove(extent_nis, extent_nis + 1, (base_ni->nr_extents - i) *\n\t\t\t\tsizeof(ntfs_inode*));\n\t\terr = 0;\n\t\tbreak;\n\t}\n\n\tmutex_unlock(&base_ni->extent_lock);\n\n\tif (unlikely(err)) {\n\t\tntfs_error(vol->sb, \"Extent inode 0x%lx is not attached to \"\n\t\t\t\t\"its base inode 0x%lx.\", mft_no,\n\t\t\t\tbase_ni->mft_no);\n\t\tBUG();\n\t}\n\n\t/*\n\t * The extent inode is no longer attached to the base inode so no one\n\t * can get a reference to it any more.\n\t */\n\n\t/* Mark the mft record as not in use. */\n\tm->flags &= ~MFT_RECORD_IN_USE;\n\n\t/* Increment the sequence number, skipping zero, if it is not zero. */\n\told_seq_no = m->sequence_number;\n\tseq_no = le16_to_cpu(old_seq_no);\n\tif (seq_no == 0xffff)\n\t\tseq_no = 1;\n\telse if (seq_no)\n\t\tseq_no++;\n\tm->sequence_number = cpu_to_le16(seq_no);\n\n\t/*\n\t * Set the ntfs inode dirty and write it out.  We do not need to worry\n\t * about the base inode here since whatever caused the extent mft\n\t * record to be freed is guaranteed to do it already.\n\t */\n\tNInoSetDirty(ni);\n\terr = write_mft_record(ni, m, 0);\n\tif (unlikely(err)) {\n\t\tntfs_error(vol->sb, \"Failed to write mft record 0x%lx, not \"\n\t\t\t\t\"freeing.\", mft_no);\n\t\tgoto rollback;\n\t}\nrollback_error:\n\t/* Unmap and throw away the now freed extent inode. */\n\tunmap_extent_mft_record(ni);\n\tntfs_clear_extent_inode(ni);\n\n\t/* Clear the bit in the $MFT/$BITMAP corresponding to this record. */\n\tdown_write(&vol->mftbmp_lock);\n\terr = ntfs_bitmap_clear_bit(vol->mftbmp_ino, mft_no);\n\tup_write(&vol->mftbmp_lock);\n\tif (unlikely(err)) {\n\t\t/*\n\t\t * The extent inode is gone but we failed to deallocate it in\n\t\t * the mft bitmap.  Just emit a warning and leave the volume\n\t\t * dirty on umount.\n\t\t */\n\t\tntfs_error(vol->sb, \"Failed to clear bit in mft bitmap.%s\", es);\n\t\tNVolSetErrors(vol);\n\t}\n\treturn 0;\nrollback:\n\t/* Rollback what we did... */\n\tmutex_lock(&base_ni->extent_lock);\n\textent_nis = base_ni->ext.extent_ntfs_inos;\n\tif (!(base_ni->nr_extents & 3)) {\n\t\tint new_size = (base_ni->nr_extents + 4) * sizeof(ntfs_inode*);\n\n\t\textent_nis = kmalloc(new_size, GFP_NOFS);\n\t\tif (unlikely(!extent_nis)) {\n\t\t\tntfs_error(vol->sb, \"Failed to allocate internal \"\n\t\t\t\t\t\"buffer during rollback.%s\", es);\n\t\t\tmutex_unlock(&base_ni->extent_lock);\n\t\t\tNVolSetErrors(vol);\n\t\t\tgoto rollback_error;\n\t\t}\n\t\tif (base_ni->nr_extents) {\n\t\t\tBUG_ON(!base_ni->ext.extent_ntfs_inos);\n\t\t\tmemcpy(extent_nis, base_ni->ext.extent_ntfs_inos,\n\t\t\t\t\tnew_size - 4 * sizeof(ntfs_inode*));\n\t\t\tkfree(base_ni->ext.extent_ntfs_inos);\n\t\t}\n\t\tbase_ni->ext.extent_ntfs_inos = extent_nis;\n\t}\n\tm->flags |= MFT_RECORD_IN_USE;\n\tm->sequence_number = old_seq_no;\n\textent_nis[base_ni->nr_extents++] = ni;\n\tmutex_unlock(&base_ni->extent_lock);\n\tmark_mft_record_dirty(ni);\n\treturn err;\n}"
  },
  {
    "function_name": "ntfs_mft_record_alloc",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/mft.c",
    "lines": "2243-2761",
    "snippet": "ntfs_inode *ntfs_mft_record_alloc(ntfs_volume *vol, const int mode,\n\t\tntfs_inode *base_ni, MFT_RECORD **mrec)\n{\n\ts64 ll, bit, old_data_initialized, old_data_size;\n\tunsigned long flags;\n\tstruct inode *vi;\n\tstruct page *page;\n\tntfs_inode *mft_ni, *mftbmp_ni, *ni;\n\tntfs_attr_search_ctx *ctx;\n\tMFT_RECORD *m;\n\tATTR_RECORD *a;\n\tpgoff_t index;\n\tunsigned int ofs;\n\tint err;\n\tle16 seq_no, usn;\n\tbool record_formatted = false;\n\n\tif (base_ni) {\n\t\tntfs_debug(\"Entering (allocating an extent mft record for \"\n\t\t\t\t\"base mft record 0x%llx).\",\n\t\t\t\t(long long)base_ni->mft_no);\n\t\t/* @mode and @base_ni are mutually exclusive. */\n\t\tBUG_ON(mode);\n\t} else\n\t\tntfs_debug(\"Entering (allocating a base mft record).\");\n\tif (mode) {\n\t\t/* @mode and @base_ni are mutually exclusive. */\n\t\tBUG_ON(base_ni);\n\t\t/* We only support creation of normal files and directories. */\n\t\tif (!S_ISREG(mode) && !S_ISDIR(mode))\n\t\t\treturn ERR_PTR(-EOPNOTSUPP);\n\t}\n\tBUG_ON(!mrec);\n\tmft_ni = NTFS_I(vol->mft_ino);\n\tmftbmp_ni = NTFS_I(vol->mftbmp_ino);\n\tdown_write(&vol->mftbmp_lock);\n\tbit = ntfs_mft_bitmap_find_and_alloc_free_rec_nolock(vol, base_ni);\n\tif (bit >= 0) {\n\t\tntfs_debug(\"Found and allocated free record (#1), bit 0x%llx.\",\n\t\t\t\t(long long)bit);\n\t\tgoto have_alloc_rec;\n\t}\n\tif (bit != -ENOSPC) {\n\t\tup_write(&vol->mftbmp_lock);\n\t\treturn ERR_PTR(bit);\n\t}\n\t/*\n\t * No free mft records left.  If the mft bitmap already covers more\n\t * than the currently used mft records, the next records are all free,\n\t * so we can simply allocate the first unused mft record.\n\t * Note: We also have to make sure that the mft bitmap at least covers\n\t * the first 24 mft records as they are special and whilst they may not\n\t * be in use, we do not allocate from them.\n\t */\n\tread_lock_irqsave(&mft_ni->size_lock, flags);\n\tll = mft_ni->initialized_size >> vol->mft_record_size_bits;\n\tread_unlock_irqrestore(&mft_ni->size_lock, flags);\n\tread_lock_irqsave(&mftbmp_ni->size_lock, flags);\n\told_data_initialized = mftbmp_ni->initialized_size;\n\tread_unlock_irqrestore(&mftbmp_ni->size_lock, flags);\n\tif (old_data_initialized << 3 > ll && old_data_initialized > 3) {\n\t\tbit = ll;\n\t\tif (bit < 24)\n\t\t\tbit = 24;\n\t\tif (unlikely(bit >= (1ll << 32)))\n\t\t\tgoto max_err_out;\n\t\tntfs_debug(\"Found free record (#2), bit 0x%llx.\",\n\t\t\t\t(long long)bit);\n\t\tgoto found_free_rec;\n\t}\n\t/*\n\t * The mft bitmap needs to be expanded until it covers the first unused\n\t * mft record that we can allocate.\n\t * Note: The smallest mft record we allocate is mft record 24.\n\t */\n\tbit = old_data_initialized << 3;\n\tif (unlikely(bit >= (1ll << 32)))\n\t\tgoto max_err_out;\n\tread_lock_irqsave(&mftbmp_ni->size_lock, flags);\n\told_data_size = mftbmp_ni->allocated_size;\n\tntfs_debug(\"Status of mftbmp before extension: allocated_size 0x%llx, \"\n\t\t\t\"data_size 0x%llx, initialized_size 0x%llx.\",\n\t\t\t(long long)old_data_size,\n\t\t\t(long long)i_size_read(vol->mftbmp_ino),\n\t\t\t(long long)old_data_initialized);\n\tread_unlock_irqrestore(&mftbmp_ni->size_lock, flags);\n\tif (old_data_initialized + 8 > old_data_size) {\n\t\t/* Need to extend bitmap by one more cluster. */\n\t\tntfs_debug(\"mftbmp: initialized_size + 8 > allocated_size.\");\n\t\terr = ntfs_mft_bitmap_extend_allocation_nolock(vol);\n\t\tif (unlikely(err)) {\n\t\t\tup_write(&vol->mftbmp_lock);\n\t\t\tgoto err_out;\n\t\t}\n#ifdef DEBUG\n\t\tread_lock_irqsave(&mftbmp_ni->size_lock, flags);\n\t\tntfs_debug(\"Status of mftbmp after allocation extension: \"\n\t\t\t\t\"allocated_size 0x%llx, data_size 0x%llx, \"\n\t\t\t\t\"initialized_size 0x%llx.\",\n\t\t\t\t(long long)mftbmp_ni->allocated_size,\n\t\t\t\t(long long)i_size_read(vol->mftbmp_ino),\n\t\t\t\t(long long)mftbmp_ni->initialized_size);\n\t\tread_unlock_irqrestore(&mftbmp_ni->size_lock, flags);\n#endif /* DEBUG */\n\t}\n\t/*\n\t * We now have sufficient allocated space, extend the initialized_size\n\t * as well as the data_size if necessary and fill the new space with\n\t * zeroes.\n\t */\n\terr = ntfs_mft_bitmap_extend_initialized_nolock(vol);\n\tif (unlikely(err)) {\n\t\tup_write(&vol->mftbmp_lock);\n\t\tgoto err_out;\n\t}\n#ifdef DEBUG\n\tread_lock_irqsave(&mftbmp_ni->size_lock, flags);\n\tntfs_debug(\"Status of mftbmp after initialized extension: \"\n\t\t\t\"allocated_size 0x%llx, data_size 0x%llx, \"\n\t\t\t\"initialized_size 0x%llx.\",\n\t\t\t(long long)mftbmp_ni->allocated_size,\n\t\t\t(long long)i_size_read(vol->mftbmp_ino),\n\t\t\t(long long)mftbmp_ni->initialized_size);\n\tread_unlock_irqrestore(&mftbmp_ni->size_lock, flags);\n#endif /* DEBUG */\n\tntfs_debug(\"Found free record (#3), bit 0x%llx.\", (long long)bit);\nfound_free_rec:\n\t/* @bit is the found free mft record, allocate it in the mft bitmap. */\n\tntfs_debug(\"At found_free_rec.\");\n\terr = ntfs_bitmap_set_bit(vol->mftbmp_ino, bit);\n\tif (unlikely(err)) {\n\t\tntfs_error(vol->sb, \"Failed to allocate bit in mft bitmap.\");\n\t\tup_write(&vol->mftbmp_lock);\n\t\tgoto err_out;\n\t}\n\tntfs_debug(\"Set bit 0x%llx in mft bitmap.\", (long long)bit);\nhave_alloc_rec:\n\t/*\n\t * The mft bitmap is now uptodate.  Deal with mft data attribute now.\n\t * Note, we keep hold of the mft bitmap lock for writing until all\n\t * modifications to the mft data attribute are complete, too, as they\n\t * will impact decisions for mft bitmap and mft record allocation done\n\t * by a parallel allocation and if the lock is not maintained a\n\t * parallel allocation could allocate the same mft record as this one.\n\t */\n\tll = (bit + 1) << vol->mft_record_size_bits;\n\tread_lock_irqsave(&mft_ni->size_lock, flags);\n\told_data_initialized = mft_ni->initialized_size;\n\tread_unlock_irqrestore(&mft_ni->size_lock, flags);\n\tif (ll <= old_data_initialized) {\n\t\tntfs_debug(\"Allocated mft record already initialized.\");\n\t\tgoto mft_rec_already_initialized;\n\t}\n\tntfs_debug(\"Initializing allocated mft record.\");\n\t/*\n\t * The mft record is outside the initialized data.  Extend the mft data\n\t * attribute until it covers the allocated record.  The loop is only\n\t * actually traversed more than once when a freshly formatted volume is\n\t * first written to so it optimizes away nicely in the common case.\n\t */\n\tread_lock_irqsave(&mft_ni->size_lock, flags);\n\tntfs_debug(\"Status of mft data before extension: \"\n\t\t\t\"allocated_size 0x%llx, data_size 0x%llx, \"\n\t\t\t\"initialized_size 0x%llx.\",\n\t\t\t(long long)mft_ni->allocated_size,\n\t\t\t(long long)i_size_read(vol->mft_ino),\n\t\t\t(long long)mft_ni->initialized_size);\n\twhile (ll > mft_ni->allocated_size) {\n\t\tread_unlock_irqrestore(&mft_ni->size_lock, flags);\n\t\terr = ntfs_mft_data_extend_allocation_nolock(vol);\n\t\tif (unlikely(err)) {\n\t\t\tntfs_error(vol->sb, \"Failed to extend mft data \"\n\t\t\t\t\t\"allocation.\");\n\t\t\tgoto undo_mftbmp_alloc_nolock;\n\t\t}\n\t\tread_lock_irqsave(&mft_ni->size_lock, flags);\n\t\tntfs_debug(\"Status of mft data after allocation extension: \"\n\t\t\t\t\"allocated_size 0x%llx, data_size 0x%llx, \"\n\t\t\t\t\"initialized_size 0x%llx.\",\n\t\t\t\t(long long)mft_ni->allocated_size,\n\t\t\t\t(long long)i_size_read(vol->mft_ino),\n\t\t\t\t(long long)mft_ni->initialized_size);\n\t}\n\tread_unlock_irqrestore(&mft_ni->size_lock, flags);\n\t/*\n\t * Extend mft data initialized size (and data size of course) to reach\n\t * the allocated mft record, formatting the mft records allong the way.\n\t * Note: We only modify the ntfs_inode structure as that is all that is\n\t * needed by ntfs_mft_record_format().  We will update the attribute\n\t * record itself in one fell swoop later on.\n\t */\n\twrite_lock_irqsave(&mft_ni->size_lock, flags);\n\told_data_initialized = mft_ni->initialized_size;\n\told_data_size = vol->mft_ino->i_size;\n\twhile (ll > mft_ni->initialized_size) {\n\t\ts64 new_initialized_size, mft_no;\n\t\t\n\t\tnew_initialized_size = mft_ni->initialized_size +\n\t\t\t\tvol->mft_record_size;\n\t\tmft_no = mft_ni->initialized_size >> vol->mft_record_size_bits;\n\t\tif (new_initialized_size > i_size_read(vol->mft_ino))\n\t\t\ti_size_write(vol->mft_ino, new_initialized_size);\n\t\twrite_unlock_irqrestore(&mft_ni->size_lock, flags);\n\t\tntfs_debug(\"Initializing mft record 0x%llx.\",\n\t\t\t\t(long long)mft_no);\n\t\terr = ntfs_mft_record_format(vol, mft_no);\n\t\tif (unlikely(err)) {\n\t\t\tntfs_error(vol->sb, \"Failed to format mft record.\");\n\t\t\tgoto undo_data_init;\n\t\t}\n\t\twrite_lock_irqsave(&mft_ni->size_lock, flags);\n\t\tmft_ni->initialized_size = new_initialized_size;\n\t}\n\twrite_unlock_irqrestore(&mft_ni->size_lock, flags);\n\trecord_formatted = true;\n\t/* Update the mft data attribute record to reflect the new sizes. */\n\tm = map_mft_record(mft_ni);\n\tif (IS_ERR(m)) {\n\t\tntfs_error(vol->sb, \"Failed to map mft record.\");\n\t\terr = PTR_ERR(m);\n\t\tgoto undo_data_init;\n\t}\n\tctx = ntfs_attr_get_search_ctx(mft_ni, m);\n\tif (unlikely(!ctx)) {\n\t\tntfs_error(vol->sb, \"Failed to get search context.\");\n\t\terr = -ENOMEM;\n\t\tunmap_mft_record(mft_ni);\n\t\tgoto undo_data_init;\n\t}\n\terr = ntfs_attr_lookup(mft_ni->type, mft_ni->name, mft_ni->name_len,\n\t\t\tCASE_SENSITIVE, 0, NULL, 0, ctx);\n\tif (unlikely(err)) {\n\t\tntfs_error(vol->sb, \"Failed to find first attribute extent of \"\n\t\t\t\t\"mft data attribute.\");\n\t\tntfs_attr_put_search_ctx(ctx);\n\t\tunmap_mft_record(mft_ni);\n\t\tgoto undo_data_init;\n\t}\n\ta = ctx->attr;\n\tread_lock_irqsave(&mft_ni->size_lock, flags);\n\ta->data.non_resident.initialized_size =\n\t\t\tcpu_to_sle64(mft_ni->initialized_size);\n\ta->data.non_resident.data_size =\n\t\t\tcpu_to_sle64(i_size_read(vol->mft_ino));\n\tread_unlock_irqrestore(&mft_ni->size_lock, flags);\n\t/* Ensure the changes make it to disk. */\n\tflush_dcache_mft_record_page(ctx->ntfs_ino);\n\tmark_mft_record_dirty(ctx->ntfs_ino);\n\tntfs_attr_put_search_ctx(ctx);\n\tunmap_mft_record(mft_ni);\n\tread_lock_irqsave(&mft_ni->size_lock, flags);\n\tntfs_debug(\"Status of mft data after mft record initialization: \"\n\t\t\t\"allocated_size 0x%llx, data_size 0x%llx, \"\n\t\t\t\"initialized_size 0x%llx.\",\n\t\t\t(long long)mft_ni->allocated_size,\n\t\t\t(long long)i_size_read(vol->mft_ino),\n\t\t\t(long long)mft_ni->initialized_size);\n\tBUG_ON(i_size_read(vol->mft_ino) > mft_ni->allocated_size);\n\tBUG_ON(mft_ni->initialized_size > i_size_read(vol->mft_ino));\n\tread_unlock_irqrestore(&mft_ni->size_lock, flags);\nmft_rec_already_initialized:\n\t/*\n\t * We can finally drop the mft bitmap lock as the mft data attribute\n\t * has been fully updated.  The only disparity left is that the\n\t * allocated mft record still needs to be marked as in use to match the\n\t * set bit in the mft bitmap but this is actually not a problem since\n\t * this mft record is not referenced from anywhere yet and the fact\n\t * that it is allocated in the mft bitmap means that no-one will try to\n\t * allocate it either.\n\t */\n\tup_write(&vol->mftbmp_lock);\n\t/*\n\t * We now have allocated and initialized the mft record.  Calculate the\n\t * index of and the offset within the page cache page the record is in.\n\t */\n\tindex = bit << vol->mft_record_size_bits >> PAGE_CACHE_SHIFT;\n\tofs = (bit << vol->mft_record_size_bits) & ~PAGE_CACHE_MASK;\n\t/* Read, map, and pin the page containing the mft record. */\n\tpage = ntfs_map_page(vol->mft_ino->i_mapping, index);\n\tif (IS_ERR(page)) {\n\t\tntfs_error(vol->sb, \"Failed to map page containing allocated \"\n\t\t\t\t\"mft record 0x%llx.\", (long long)bit);\n\t\terr = PTR_ERR(page);\n\t\tgoto undo_mftbmp_alloc;\n\t}\n\tlock_page(page);\n\tBUG_ON(!PageUptodate(page));\n\tClearPageUptodate(page);\n\tm = (MFT_RECORD*)((u8*)page_address(page) + ofs);\n\t/* If we just formatted the mft record no need to do it again. */\n\tif (!record_formatted) {\n\t\t/* Sanity check that the mft record is really not in use. */\n\t\tif (ntfs_is_file_record(m->magic) &&\n\t\t\t\t(m->flags & MFT_RECORD_IN_USE)) {\n\t\t\tntfs_error(vol->sb, \"Mft record 0x%llx was marked \"\n\t\t\t\t\t\"free in mft bitmap but is marked \"\n\t\t\t\t\t\"used itself.  Corrupt filesystem.  \"\n\t\t\t\t\t\"Unmount and run chkdsk.\",\n\t\t\t\t\t(long long)bit);\n\t\t\terr = -EIO;\n\t\t\tSetPageUptodate(page);\n\t\t\tunlock_page(page);\n\t\t\tntfs_unmap_page(page);\n\t\t\tNVolSetErrors(vol);\n\t\t\tgoto undo_mftbmp_alloc;\n\t\t}\n\t\t/*\n\t\t * We need to (re-)format the mft record, preserving the\n\t\t * sequence number if it is not zero as well as the update\n\t\t * sequence number if it is not zero or -1 (0xffff).  This\n\t\t * means we do not need to care whether or not something went\n\t\t * wrong with the previous mft record.\n\t\t */\n\t\tseq_no = m->sequence_number;\n\t\tusn = *(le16*)((u8*)m + le16_to_cpu(m->usa_ofs));\n\t\terr = ntfs_mft_record_layout(vol, bit, m);\n\t\tif (unlikely(err)) {\n\t\t\tntfs_error(vol->sb, \"Failed to layout allocated mft \"\n\t\t\t\t\t\"record 0x%llx.\", (long long)bit);\n\t\t\tSetPageUptodate(page);\n\t\t\tunlock_page(page);\n\t\t\tntfs_unmap_page(page);\n\t\t\tgoto undo_mftbmp_alloc;\n\t\t}\n\t\tif (seq_no)\n\t\t\tm->sequence_number = seq_no;\n\t\tif (usn && le16_to_cpu(usn) != 0xffff)\n\t\t\t*(le16*)((u8*)m + le16_to_cpu(m->usa_ofs)) = usn;\n\t}\n\t/* Set the mft record itself in use. */\n\tm->flags |= MFT_RECORD_IN_USE;\n\tif (S_ISDIR(mode))\n\t\tm->flags |= MFT_RECORD_IS_DIRECTORY;\n\tflush_dcache_page(page);\n\tSetPageUptodate(page);\n\tif (base_ni) {\n\t\tMFT_RECORD *m_tmp;\n\n\t\t/*\n\t\t * Setup the base mft record in the extent mft record.  This\n\t\t * completes initialization of the allocated extent mft record\n\t\t * and we can simply use it with map_extent_mft_record().\n\t\t */\n\t\tm->base_mft_record = MK_LE_MREF(base_ni->mft_no,\n\t\t\t\tbase_ni->seq_no);\n\t\t/*\n\t\t * Allocate an extent inode structure for the new mft record,\n\t\t * attach it to the base inode @base_ni and map, pin, and lock\n\t\t * its, i.e. the allocated, mft record.\n\t\t */\n\t\tm_tmp = map_extent_mft_record(base_ni, bit, &ni);\n\t\tif (IS_ERR(m_tmp)) {\n\t\t\tntfs_error(vol->sb, \"Failed to map allocated extent \"\n\t\t\t\t\t\"mft record 0x%llx.\", (long long)bit);\n\t\t\terr = PTR_ERR(m_tmp);\n\t\t\t/* Set the mft record itself not in use. */\n\t\t\tm->flags &= cpu_to_le16(\n\t\t\t\t\t~le16_to_cpu(MFT_RECORD_IN_USE));\n\t\t\tflush_dcache_page(page);\n\t\t\t/* Make sure the mft record is written out to disk. */\n\t\t\tmark_ntfs_record_dirty(page, ofs);\n\t\t\tunlock_page(page);\n\t\t\tntfs_unmap_page(page);\n\t\t\tgoto undo_mftbmp_alloc;\n\t\t}\n\t\tBUG_ON(m != m_tmp);\n\t\t/*\n\t\t * Make sure the allocated mft record is written out to disk.\n\t\t * No need to set the inode dirty because the caller is going\n\t\t * to do that anyway after finishing with the new extent mft\n\t\t * record (e.g. at a minimum a new attribute will be added to\n\t\t * the mft record.\n\t\t */\n\t\tmark_ntfs_record_dirty(page, ofs);\n\t\tunlock_page(page);\n\t\t/*\n\t\t * Need to unmap the page since map_extent_mft_record() mapped\n\t\t * it as well so we have it mapped twice at the moment.\n\t\t */\n\t\tntfs_unmap_page(page);\n\t} else {\n\t\t/*\n\t\t * Allocate a new VFS inode and set it up.  NOTE: @vi->i_nlink\n\t\t * is set to 1 but the mft record->link_count is 0.  The caller\n\t\t * needs to bear this in mind.\n\t\t */\n\t\tvi = new_inode(vol->sb);\n\t\tif (unlikely(!vi)) {\n\t\t\terr = -ENOMEM;\n\t\t\t/* Set the mft record itself not in use. */\n\t\t\tm->flags &= cpu_to_le16(\n\t\t\t\t\t~le16_to_cpu(MFT_RECORD_IN_USE));\n\t\t\tflush_dcache_page(page);\n\t\t\t/* Make sure the mft record is written out to disk. */\n\t\t\tmark_ntfs_record_dirty(page, ofs);\n\t\t\tunlock_page(page);\n\t\t\tntfs_unmap_page(page);\n\t\t\tgoto undo_mftbmp_alloc;\n\t\t}\n\t\tvi->i_ino = bit;\n\t\t/*\n\t\t * This is for checking whether an inode has changed w.r.t. a\n\t\t * file so that the file can be updated if necessary (compare\n\t\t * with f_version).\n\t\t */\n\t\tvi->i_version = 1;\n\n\t\t/* The owner and group come from the ntfs volume. */\n\t\tvi->i_uid = vol->uid;\n\t\tvi->i_gid = vol->gid;\n\n\t\t/* Initialize the ntfs specific part of @vi. */\n\t\tntfs_init_big_inode(vi);\n\t\tni = NTFS_I(vi);\n\t\t/*\n\t\t * Set the appropriate mode, attribute type, and name.  For\n\t\t * directories, also setup the index values to the defaults.\n\t\t */\n\t\tif (S_ISDIR(mode)) {\n\t\t\tvi->i_mode = S_IFDIR | S_IRWXUGO;\n\t\t\tvi->i_mode &= ~vol->dmask;\n\n\t\t\tNInoSetMstProtected(ni);\n\t\t\tni->type = AT_INDEX_ALLOCATION;\n\t\t\tni->name = I30;\n\t\t\tni->name_len = 4;\n\n\t\t\tni->itype.index.block_size = 4096;\n\t\t\tni->itype.index.block_size_bits = ntfs_ffs(4096) - 1;\n\t\t\tni->itype.index.collation_rule = COLLATION_FILE_NAME;\n\t\t\tif (vol->cluster_size <= ni->itype.index.block_size) {\n\t\t\t\tni->itype.index.vcn_size = vol->cluster_size;\n\t\t\t\tni->itype.index.vcn_size_bits =\n\t\t\t\t\t\tvol->cluster_size_bits;\n\t\t\t} else {\n\t\t\t\tni->itype.index.vcn_size = vol->sector_size;\n\t\t\t\tni->itype.index.vcn_size_bits =\n\t\t\t\t\t\tvol->sector_size_bits;\n\t\t\t}\n\t\t} else {\n\t\t\tvi->i_mode = S_IFREG | S_IRWXUGO;\n\t\t\tvi->i_mode &= ~vol->fmask;\n\n\t\t\tni->type = AT_DATA;\n\t\t\tni->name = NULL;\n\t\t\tni->name_len = 0;\n\t\t}\n\t\tif (IS_RDONLY(vi))\n\t\t\tvi->i_mode &= ~S_IWUGO;\n\n\t\t/* Set the inode times to the current time. */\n\t\tvi->i_atime = vi->i_mtime = vi->i_ctime =\n\t\t\tcurrent_fs_time(vi->i_sb);\n\t\t/*\n\t\t * Set the file size to 0, the ntfs inode sizes are set to 0 by\n\t\t * the call to ntfs_init_big_inode() below.\n\t\t */\n\t\tvi->i_size = 0;\n\t\tvi->i_blocks = 0;\n\n\t\t/* Set the sequence number. */\n\t\tvi->i_generation = ni->seq_no = le16_to_cpu(m->sequence_number);\n\t\t/*\n\t\t * Manually map, pin, and lock the mft record as we already\n\t\t * have its page mapped and it is very easy to do.\n\t\t */\n\t\tatomic_inc(&ni->count);\n\t\tmutex_lock(&ni->mrec_lock);\n\t\tni->page = page;\n\t\tni->page_ofs = ofs;\n\t\t/*\n\t\t * Make sure the allocated mft record is written out to disk.\n\t\t * NOTE: We do not set the ntfs inode dirty because this would\n\t\t * fail in ntfs_write_inode() because the inode does not have a\n\t\t * standard information attribute yet.  Also, there is no need\n\t\t * to set the inode dirty because the caller is going to do\n\t\t * that anyway after finishing with the new mft record (e.g. at\n\t\t * a minimum some new attributes will be added to the mft\n\t\t * record.\n\t\t */\n\t\tmark_ntfs_record_dirty(page, ofs);\n\t\tunlock_page(page);\n\n\t\t/* Add the inode to the inode hash for the superblock. */\n\t\tinsert_inode_hash(vi);\n\n\t\t/* Update the default mft allocation position. */\n\t\tvol->mft_data_pos = bit + 1;\n\t}\n\t/*\n\t * Return the opened, allocated inode of the allocated mft record as\n\t * well as the mapped, pinned, and locked mft record.\n\t */\n\tntfs_debug(\"Returning opened, allocated %sinode 0x%llx.\",\n\t\t\tbase_ni ? \"extent \" : \"\", (long long)bit);\n\t*mrec = m;\n\treturn ni;\nundo_data_init:\n\twrite_lock_irqsave(&mft_ni->size_lock, flags);\n\tmft_ni->initialized_size = old_data_initialized;\n\ti_size_write(vol->mft_ino, old_data_size);\n\twrite_unlock_irqrestore(&mft_ni->size_lock, flags);\n\tgoto undo_mftbmp_alloc_nolock;\nundo_mftbmp_alloc:\n\tdown_write(&vol->mftbmp_lock);\nundo_mftbmp_alloc_nolock:\n\tif (ntfs_bitmap_clear_bit(vol->mftbmp_ino, bit)) {\n\t\tntfs_error(vol->sb, \"Failed to clear bit in mft bitmap.%s\", es);\n\t\tNVolSetErrors(vol);\n\t}\n\tup_write(&vol->mftbmp_lock);\nerr_out:\n\treturn ERR_PTR(err);\nmax_err_out:\n\tntfs_warning(vol->sb, \"Cannot allocate mft record because the maximum \"\n\t\t\t\"number of inodes (2^32) has already been reached.\");\n\tup_write(&vol->mftbmp_lock);\n\treturn ERR_PTR(-ENOSPC);\n}",
    "includes": [
      "#include \"ntfs.h\"",
      "#include \"mft.h\"",
      "#include \"malloc.h\"",
      "#include \"lcnalloc.h\"",
      "#include \"dir.h\"",
      "#include \"debug.h\"",
      "#include \"bitmap.h\"",
      "#include \"aops.h\"",
      "#include \"attrib.h\"",
      "#include <linux/swap.h>",
      "#include <linux/slab.h>",
      "#include <linux/buffer_head.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-ENOSPC"
          ],
          "line": 2760
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "up_write",
          "args": [
            "&vol->mftbmp_lock"
          ],
          "line": 2759
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntfs_warning",
          "args": [
            "vol->sb",
            "\"Cannot allocate mft record because the maximum \"\n\t\t\t\"number of inodes (2^32) has already been reached.\""
          ],
          "line": 2757
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "err"
          ],
          "line": 2755
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "up_write",
          "args": [
            "&vol->mftbmp_lock"
          ],
          "line": 2753
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NVolSetErrors",
          "args": [
            "vol"
          ],
          "line": 2751
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntfs_error",
          "args": [
            "vol->sb",
            "\"Failed to clear bit in mft bitmap.%s\"",
            "es"
          ],
          "line": 2750
        },
        "resolved": true,
        "details": {
          "function_name": "__ntfs_error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/debug.c",
          "lines": "86-108",
          "snippet": "void __ntfs_error(const char *function, const struct super_block *sb,\n\t\tconst char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\tint flen = 0;\n\n#ifndef DEBUG\n\tif (!printk_ratelimit())\n\t\treturn;\n#endif\n\tif (function)\n\t\tflen = strlen(function);\n\tva_start(args, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\tif (sb)\n\t\tpr_err(\"(device %s): %s(): %pV\\n\",\n\t\t       sb->s_id, flen ? function : \"\", &vaf);\n\telse\n\t\tpr_err(\"%s(): %pV\\n\", flen ? function : \"\", &vaf);\n\tva_end(args);\n}",
          "includes": [
            "#include \"debug.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"debug.h\"\n\nvoid __ntfs_error(const char *function, const struct super_block *sb,\n\t\tconst char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\tint flen = 0;\n\n#ifndef DEBUG\n\tif (!printk_ratelimit())\n\t\treturn;\n#endif\n\tif (function)\n\t\tflen = strlen(function);\n\tva_start(args, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\tif (sb)\n\t\tpr_err(\"(device %s): %s(): %pV\\n\",\n\t\t       sb->s_id, flen ? function : \"\", &vaf);\n\telse\n\t\tpr_err(\"%s(): %pV\\n\", flen ? function : \"\", &vaf);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ntfs_bitmap_clear_bit",
          "args": [
            "vol->mftbmp_ino",
            "bit"
          ],
          "line": 2749
        },
        "resolved": true,
        "details": {
          "function_name": "ntfs_bitmap_clear_bit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/bitmap.h",
          "lines": "111-114",
          "snippet": "static inline int ntfs_bitmap_clear_bit(struct inode *vi, const s64 bit)\n{\n\treturn ntfs_bitmap_clear_run(vi, bit, 1);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <linux/fs.h>\n\nstatic inline int ntfs_bitmap_clear_bit(struct inode *vi, const s64 bit)\n{\n\treturn ntfs_bitmap_clear_run(vi, bit, 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "down_write",
          "args": [
            "&vol->mftbmp_lock"
          ],
          "line": 2747
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "write_unlock_irqrestore",
          "args": [
            "&mft_ni->size_lock",
            "flags"
          ],
          "line": 2744
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "i_size_write",
          "args": [
            "vol->mft_ino",
            "old_data_size"
          ],
          "line": 2743
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_i_size_write",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/btrfs_inode.h",
          "lines": "233-237",
          "snippet": "static inline void btrfs_i_size_write(struct inode *inode, u64 size)\n{\n\ti_size_write(inode, size);\n\tBTRFS_I(inode)->disk_i_size = size;\n}",
          "includes": [
            "#include \"delayed-inode.h\"",
            "#include \"ordered-data.h\"",
            "#include \"extent_io.h\"",
            "#include \"extent_map.h\"",
            "#include <linux/hash.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"delayed-inode.h\"\n#include \"ordered-data.h\"\n#include \"extent_io.h\"\n#include \"extent_map.h\"\n#include <linux/hash.h>\n\nstatic inline void btrfs_i_size_write(struct inode *inode, u64 size)\n{\n\ti_size_write(inode, size);\n\tBTRFS_I(inode)->disk_i_size = size;\n}"
        }
      },
      {
        "call_info": {
          "callee": "write_lock_irqsave",
          "args": [
            "&mft_ni->size_lock",
            "flags"
          ],
          "line": 2741
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntfs_debug",
          "args": [
            "\"Returning opened, allocated %sinode 0x%llx.\"",
            "base_ni ? \"extent \" : \"\"",
            "(long long)bit"
          ],
          "line": 2736
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "insert_inode_hash",
          "args": [
            "vi"
          ],
          "line": 2727
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_insert_inode_hash",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/btrfs_inode.h",
          "lines": "213-218",
          "snippet": "static inline void btrfs_insert_inode_hash(struct inode *inode)\n{\n\tunsigned long h = btrfs_inode_hash(inode->i_ino, BTRFS_I(inode)->root);\n\n\t__insert_inode_hash(inode, h);\n}",
          "includes": [
            "#include \"delayed-inode.h\"",
            "#include \"ordered-data.h\"",
            "#include \"extent_io.h\"",
            "#include \"extent_map.h\"",
            "#include <linux/hash.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"delayed-inode.h\"\n#include \"ordered-data.h\"\n#include \"extent_io.h\"\n#include \"extent_map.h\"\n#include <linux/hash.h>\n\nstatic inline void btrfs_insert_inode_hash(struct inode *inode)\n{\n\tunsigned long h = btrfs_inode_hash(inode->i_ino, BTRFS_I(inode)->root);\n\n\t__insert_inode_hash(inode, h);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlock_page",
          "args": [
            "page"
          ],
          "line": 2724
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_unlock_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/aops.c",
          "lines": "1127-1148",
          "snippet": "static void ocfs2_unlock_pages(struct ocfs2_write_ctxt *wc)\n{\n\tint i;\n\n\t/*\n\t * w_target_locked is only set to true in the page_mkwrite() case.\n\t * The intent is to allow us to lock the target page from write_begin()\n\t * to write_end(). The caller must hold a ref on w_target_page.\n\t */\n\tif (wc->w_target_locked) {\n\t\tBUG_ON(!wc->w_target_page);\n\t\tfor (i = 0; i < wc->w_num_pages; i++) {\n\t\t\tif (wc->w_target_page == wc->w_pages[i]) {\n\t\t\t\twc->w_pages[i] = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tmark_page_accessed(wc->w_target_page);\n\t\tpage_cache_release(wc->w_target_page);\n\t}\n\tocfs2_unlock_and_free_pages(wc->w_pages, wc->w_num_pages);\n}",
          "includes": [
            "#include \"sysfile.h\"",
            "#include \"namei.h\"",
            "#include \"dir.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"symlink.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/mpage.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/swap.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sysfile.h\"\n#include \"namei.h\"\n#include \"dir.h\"\n#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"symlink.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/mpage.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/swap.h>\n#include <asm/byteorder.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic void ocfs2_unlock_pages(struct ocfs2_write_ctxt *wc)\n{\n\tint i;\n\n\t/*\n\t * w_target_locked is only set to true in the page_mkwrite() case.\n\t * The intent is to allow us to lock the target page from write_begin()\n\t * to write_end(). The caller must hold a ref on w_target_page.\n\t */\n\tif (wc->w_target_locked) {\n\t\tBUG_ON(!wc->w_target_page);\n\t\tfor (i = 0; i < wc->w_num_pages; i++) {\n\t\t\tif (wc->w_target_page == wc->w_pages[i]) {\n\t\t\t\twc->w_pages[i] = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tmark_page_accessed(wc->w_target_page);\n\t\tpage_cache_release(wc->w_target_page);\n\t}\n\tocfs2_unlock_and_free_pages(wc->w_pages, wc->w_num_pages);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mark_ntfs_record_dirty",
          "args": [
            "page",
            "ofs"
          ],
          "line": 2723
        },
        "resolved": true,
        "details": {
          "function_name": "mark_ntfs_record_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/aops.c",
          "lines": "1729-1775",
          "snippet": "void mark_ntfs_record_dirty(struct page *page, const unsigned int ofs) {\n\tstruct address_space *mapping = page->mapping;\n\tntfs_inode *ni = NTFS_I(mapping->host);\n\tstruct buffer_head *bh, *head, *buffers_to_free = NULL;\n\tunsigned int end, bh_size, bh_ofs;\n\n\tBUG_ON(!PageUptodate(page));\n\tend = ofs + ni->itype.index.block_size;\n\tbh_size = VFS_I(ni)->i_sb->s_blocksize;\n\tspin_lock(&mapping->private_lock);\n\tif (unlikely(!page_has_buffers(page))) {\n\t\tspin_unlock(&mapping->private_lock);\n\t\tbh = head = alloc_page_buffers(page, bh_size, 1);\n\t\tspin_lock(&mapping->private_lock);\n\t\tif (likely(!page_has_buffers(page))) {\n\t\t\tstruct buffer_head *tail;\n\n\t\t\tdo {\n\t\t\t\tset_buffer_uptodate(bh);\n\t\t\t\ttail = bh;\n\t\t\t\tbh = bh->b_this_page;\n\t\t\t} while (bh);\n\t\t\ttail->b_this_page = head;\n\t\t\tattach_page_buffers(page, head);\n\t\t} else\n\t\t\tbuffers_to_free = bh;\n\t}\n\tbh = head = page_buffers(page);\n\tBUG_ON(!bh);\n\tdo {\n\t\tbh_ofs = bh_offset(bh);\n\t\tif (bh_ofs + bh_size <= ofs)\n\t\t\tcontinue;\n\t\tif (unlikely(bh_ofs >= end))\n\t\t\tbreak;\n\t\tset_buffer_dirty(bh);\n\t} while ((bh = bh->b_this_page) != head);\n\tspin_unlock(&mapping->private_lock);\n\t__set_page_dirty_nobuffers(page);\n\tif (unlikely(buffers_to_free)) {\n\t\tdo {\n\t\t\tbh = buffers_to_free->b_this_page;\n\t\t\tfree_buffer_head(buffers_to_free);\n\t\t\tbuffers_to_free = bh;\n\t\t} while (buffers_to_free);\n\t}\n}",
          "includes": [
            "#include \"ntfs.h\"",
            "#include \"types.h\"",
            "#include \"runlist.h\"",
            "#include \"mft.h\"",
            "#include \"inode.h\"",
            "#include \"debug.h\"",
            "#include \"attrib.h\"",
            "#include \"aops.h\"",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/writeback.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/gfp.h>",
            "#include <linux/fs.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ntfs.h\"\n#include \"types.h\"\n#include \"runlist.h\"\n#include \"mft.h\"\n#include \"inode.h\"\n#include \"debug.h\"\n#include \"attrib.h\"\n#include \"aops.h\"\n#include <linux/bit_spinlock.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/gfp.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n\nvoid mark_ntfs_record_dirty(struct page *page, const unsigned int ofs) {\n\tstruct address_space *mapping = page->mapping;\n\tntfs_inode *ni = NTFS_I(mapping->host);\n\tstruct buffer_head *bh, *head, *buffers_to_free = NULL;\n\tunsigned int end, bh_size, bh_ofs;\n\n\tBUG_ON(!PageUptodate(page));\n\tend = ofs + ni->itype.index.block_size;\n\tbh_size = VFS_I(ni)->i_sb->s_blocksize;\n\tspin_lock(&mapping->private_lock);\n\tif (unlikely(!page_has_buffers(page))) {\n\t\tspin_unlock(&mapping->private_lock);\n\t\tbh = head = alloc_page_buffers(page, bh_size, 1);\n\t\tspin_lock(&mapping->private_lock);\n\t\tif (likely(!page_has_buffers(page))) {\n\t\t\tstruct buffer_head *tail;\n\n\t\t\tdo {\n\t\t\t\tset_buffer_uptodate(bh);\n\t\t\t\ttail = bh;\n\t\t\t\tbh = bh->b_this_page;\n\t\t\t} while (bh);\n\t\t\ttail->b_this_page = head;\n\t\t\tattach_page_buffers(page, head);\n\t\t} else\n\t\t\tbuffers_to_free = bh;\n\t}\n\tbh = head = page_buffers(page);\n\tBUG_ON(!bh);\n\tdo {\n\t\tbh_ofs = bh_offset(bh);\n\t\tif (bh_ofs + bh_size <= ofs)\n\t\t\tcontinue;\n\t\tif (unlikely(bh_ofs >= end))\n\t\t\tbreak;\n\t\tset_buffer_dirty(bh);\n\t} while ((bh = bh->b_this_page) != head);\n\tspin_unlock(&mapping->private_lock);\n\t__set_page_dirty_nobuffers(page);\n\tif (unlikely(buffers_to_free)) {\n\t\tdo {\n\t\t\tbh = buffers_to_free->b_this_page;\n\t\t\tfree_buffer_head(buffers_to_free);\n\t\t\tbuffers_to_free = bh;\n\t\t} while (buffers_to_free);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&ni->mrec_lock"
          ],
          "line": 2710
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_inc",
          "args": [
            "&ni->count"
          ],
          "line": 2709
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le16_to_cpu",
          "args": [
            "m->sequence_number"
          ],
          "line": 2704
        },
        "resolved": true,
        "details": {
          "function_name": "sle16_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "48-51",
          "snippet": "static inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "current_fs_time",
          "args": [
            "vi->i_sb"
          ],
          "line": 2695
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_RDONLY",
          "args": [
            "vi"
          ],
          "line": 2690
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntfs_ffs",
          "args": [
            "4096"
          ],
          "line": 2671
        },
        "resolved": true,
        "details": {
          "function_name": "ntfs_ffs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/ntfs.h",
          "lines": "135-162",
          "snippet": "static inline int ntfs_ffs(int x)\n{\n\tint r = 1;\n\n\tif (!x)\n\t\treturn 0;\n\tif (!(x & 0xffff)) {\n\t\tx >>= 16;\n\t\tr += 16;\n\t}\n\tif (!(x & 0xff)) {\n\t\tx >>= 8;\n\t\tr += 8;\n\t}\n\tif (!(x & 0xf)) {\n\t\tx >>= 4;\n\t\tr += 4;\n\t}\n\tif (!(x & 3)) {\n\t\tx >>= 2;\n\t\tr += 2;\n\t}\n\tif (!(x & 1)) {\n\t\tx >>= 1;\n\t\tr += 1;\n\t}\n\treturn r;\n}",
          "includes": [
            "#include \"layout.h\"",
            "#include \"volume.h\"",
            "#include \"types.h\"",
            "#include <linux/pagemap.h>",
            "#include <linux/smp.h>",
            "#include <linux/nls.h>",
            "#include <linux/fs.h>",
            "#include <linux/compiler.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"layout.h\"\n#include \"volume.h\"\n#include \"types.h\"\n#include <linux/pagemap.h>\n#include <linux/smp.h>\n#include <linux/nls.h>\n#include <linux/fs.h>\n#include <linux/compiler.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/stddef.h>\n\nstatic inline int ntfs_ffs(int x)\n{\n\tint r = 1;\n\n\tif (!x)\n\t\treturn 0;\n\tif (!(x & 0xffff)) {\n\t\tx >>= 16;\n\t\tr += 16;\n\t}\n\tif (!(x & 0xff)) {\n\t\tx >>= 8;\n\t\tr += 8;\n\t}\n\tif (!(x & 0xf)) {\n\t\tx >>= 4;\n\t\tr += 4;\n\t}\n\tif (!(x & 3)) {\n\t\tx >>= 2;\n\t\tr += 2;\n\t}\n\tif (!(x & 1)) {\n\t\tx >>= 1;\n\t\tr += 1;\n\t}\n\treturn r;\n}"
        }
      },
      {
        "call_info": {
          "callee": "NInoSetMstProtected",
          "args": [
            "ni"
          ],
          "line": 2665
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISDIR",
          "args": [
            "mode"
          ],
          "line": 2661
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NTFS_I",
          "args": [
            "vi"
          ],
          "line": 2656
        },
        "resolved": true,
        "details": {
          "function_name": "NTFS_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/inode.h",
          "lines": "240-243",
          "snippet": "static inline ntfs_inode *NTFS_I(struct inode *inode)\n{\n\treturn (ntfs_inode *)list_entry(inode, big_ntfs_inode, vfs_inode);\n}",
          "includes": [
            "#include \"debug.h\"",
            "#include \"runlist.h\"",
            "#include \"types.h\"",
            "#include \"volume.h\"",
            "#include \"layout.h\"",
            "#include <linux/seq_file.h>",
            "#include <linux/mutex.h>",
            "#include <linux/mm.h>",
            "#include <linux/list.h>",
            "#include <linux/fs.h>",
            "#include <linux/atomic.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"debug.h\"\n#include \"runlist.h\"\n#include \"types.h\"\n#include \"volume.h\"\n#include \"layout.h\"\n#include <linux/seq_file.h>\n#include <linux/mutex.h>\n#include <linux/mm.h>\n#include <linux/list.h>\n#include <linux/fs.h>\n#include <linux/atomic.h>\n\nstatic inline ntfs_inode *NTFS_I(struct inode *inode)\n{\n\treturn (ntfs_inode *)list_entry(inode, big_ntfs_inode, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ntfs_init_big_inode",
          "args": [
            "vi"
          ],
          "line": 2655
        },
        "resolved": true,
        "details": {
          "function_name": "ntfs_init_big_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/inode.h",
          "lines": "286-293",
          "snippet": "static inline void ntfs_init_big_inode(struct inode *vi)\n{\n\tntfs_inode *ni = NTFS_I(vi);\n\n\tntfs_debug(\"Entering.\");\n\t__ntfs_init_inode(vi->i_sb, ni);\n\tni->mft_no = vi->i_ino;\n}",
          "includes": [
            "#include \"debug.h\"",
            "#include \"runlist.h\"",
            "#include \"types.h\"",
            "#include \"volume.h\"",
            "#include \"layout.h\"",
            "#include <linux/seq_file.h>",
            "#include <linux/mutex.h>",
            "#include <linux/mm.h>",
            "#include <linux/list.h>",
            "#include <linux/fs.h>",
            "#include <linux/atomic.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"debug.h\"\n#include \"runlist.h\"\n#include \"types.h\"\n#include \"volume.h\"\n#include \"layout.h\"\n#include <linux/seq_file.h>\n#include <linux/mutex.h>\n#include <linux/mm.h>\n#include <linux/list.h>\n#include <linux/fs.h>\n#include <linux/atomic.h>\n\nstatic inline void ntfs_init_big_inode(struct inode *vi)\n{\n\tntfs_inode *ni = NTFS_I(vi);\n\n\tntfs_debug(\"Entering.\");\n\t__ntfs_init_inode(vi->i_sb, ni);\n\tni->mft_no = vi->i_ino;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ntfs_unmap_page",
          "args": [
            "page"
          ],
          "line": 2639
        },
        "resolved": true,
        "details": {
          "function_name": "ntfs_unmap_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/aops.h",
          "lines": "40-44",
          "snippet": "static inline void ntfs_unmap_page(struct page *page)\n{\n\tkunmap(page);\n\tpage_cache_release(page);\n}",
          "includes": [
            "#include \"inode.h\"",
            "#include <linux/fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"inode.h\"\n#include <linux/fs.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n\nstatic inline void ntfs_unmap_page(struct page *page)\n{\n\tkunmap(page);\n\tpage_cache_release(page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "flush_dcache_page",
          "args": [
            "page"
          ],
          "line": 2635
        },
        "resolved": true,
        "details": {
          "function_name": "ntfs_index_entry_flush_dcache_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/index.h",
          "lines": "111-117",
          "snippet": "static inline void ntfs_index_entry_flush_dcache_page(ntfs_index_context *ictx)\n{\n\tif (ictx->is_in_root)\n\t\tflush_dcache_mft_record_page(ictx->actx->ntfs_ino);\n\telse\n\t\tflush_dcache_page(ictx->page);\n}",
          "includes": [
            "#include \"aops.h\"",
            "#include \"mft.h\"",
            "#include \"attrib.h\"",
            "#include \"inode.h\"",
            "#include \"layout.h\"",
            "#include \"types.h\"",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"aops.h\"\n#include \"mft.h\"\n#include \"attrib.h\"\n#include \"inode.h\"\n#include \"layout.h\"\n#include \"types.h\"\n#include <linux/fs.h>\n\nstatic inline void ntfs_index_entry_flush_dcache_page(ntfs_index_context *ictx)\n{\n\tif (ictx->is_in_root)\n\t\tflush_dcache_mft_record_page(ictx->actx->ntfs_ino);\n\telse\n\t\tflush_dcache_page(ictx->page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "~le16_to_cpu(MFT_RECORD_IN_USE)"
          ],
          "line": 2633
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!vi"
          ],
          "line": 2630
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "new_inode",
          "args": [
            "vol->sb"
          ],
          "line": 2629
        },
        "resolved": true,
        "details": {
          "function_name": "unlock_new_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "924-933",
          "snippet": "void unlock_new_inode(struct inode *inode)\n{\n\tlockdep_annotate_inode_mutex_key(inode);\n\tspin_lock(&inode->i_lock);\n\tWARN_ON(!(inode->i_state & I_NEW));\n\tinode->i_state &= ~I_NEW;\n\tsmp_mb();\n\twake_up_bit(&inode->i_state, __I_NEW);\n\tspin_unlock(&inode->i_lock);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid unlock_new_inode(struct inode *inode)\n{\n\tlockdep_annotate_inode_mutex_key(inode);\n\tspin_lock(&inode->i_lock);\n\tWARN_ON(!(inode->i_state & I_NEW));\n\tinode->i_state &= ~I_NEW;\n\tsmp_mb();\n\twake_up_bit(&inode->i_state, __I_NEW);\n\tspin_unlock(&inode->i_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "m != m_tmp"
          ],
          "line": 2608
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "~le16_to_cpu(MFT_RECORD_IN_USE)"
          ],
          "line": 2599
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "m_tmp"
          ],
          "line": 2597
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "m_tmp"
          ],
          "line": 2594
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "map_extent_mft_record",
          "args": [
            "base_ni",
            "bit",
            "&ni"
          ],
          "line": 2593
        },
        "resolved": true,
        "details": {
          "function_name": "map_extent_mft_record",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/mft.c",
          "lines": "246-368",
          "snippet": "MFT_RECORD *map_extent_mft_record(ntfs_inode *base_ni, MFT_REF mref,\n\t\tntfs_inode **ntfs_ino)\n{\n\tMFT_RECORD *m;\n\tntfs_inode *ni = NULL;\n\tntfs_inode **extent_nis = NULL;\n\tint i;\n\tunsigned long mft_no = MREF(mref);\n\tu16 seq_no = MSEQNO(mref);\n\tbool destroy_ni = false;\n\n\tntfs_debug(\"Mapping extent mft record 0x%lx (base mft record 0x%lx).\",\n\t\t\tmft_no, base_ni->mft_no);\n\t/* Make sure the base ntfs inode doesn't go away. */\n\tatomic_inc(&base_ni->count);\n\t/*\n\t * Check if this extent inode has already been added to the base inode,\n\t * in which case just return it. If not found, add it to the base\n\t * inode before returning it.\n\t */\n\tmutex_lock(&base_ni->extent_lock);\n\tif (base_ni->nr_extents > 0) {\n\t\textent_nis = base_ni->ext.extent_ntfs_inos;\n\t\tfor (i = 0; i < base_ni->nr_extents; i++) {\n\t\t\tif (mft_no != extent_nis[i]->mft_no)\n\t\t\t\tcontinue;\n\t\t\tni = extent_nis[i];\n\t\t\t/* Make sure the ntfs inode doesn't go away. */\n\t\t\tatomic_inc(&ni->count);\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (likely(ni != NULL)) {\n\t\tmutex_unlock(&base_ni->extent_lock);\n\t\tatomic_dec(&base_ni->count);\n\t\t/* We found the record; just have to map and return it. */\n\t\tm = map_mft_record(ni);\n\t\t/* map_mft_record() has incremented this on success. */\n\t\tatomic_dec(&ni->count);\n\t\tif (likely(!IS_ERR(m))) {\n\t\t\t/* Verify the sequence number. */\n\t\t\tif (likely(le16_to_cpu(m->sequence_number) == seq_no)) {\n\t\t\t\tntfs_debug(\"Done 1.\");\n\t\t\t\t*ntfs_ino = ni;\n\t\t\t\treturn m;\n\t\t\t}\n\t\t\tunmap_mft_record(ni);\n\t\t\tntfs_error(base_ni->vol->sb, \"Found stale extent mft \"\n\t\t\t\t\t\"reference! Corrupt filesystem. \"\n\t\t\t\t\t\"Run chkdsk.\");\n\t\t\treturn ERR_PTR(-EIO);\n\t\t}\nmap_err_out:\n\t\tntfs_error(base_ni->vol->sb, \"Failed to map extent \"\n\t\t\t\t\"mft record, error code %ld.\", -PTR_ERR(m));\n\t\treturn m;\n\t}\n\t/* Record wasn't there. Get a new ntfs inode and initialize it. */\n\tni = ntfs_new_extent_inode(base_ni->vol->sb, mft_no);\n\tif (unlikely(!ni)) {\n\t\tmutex_unlock(&base_ni->extent_lock);\n\t\tatomic_dec(&base_ni->count);\n\t\treturn ERR_PTR(-ENOMEM);\n\t}\n\tni->vol = base_ni->vol;\n\tni->seq_no = seq_no;\n\tni->nr_extents = -1;\n\tni->ext.base_ntfs_ino = base_ni;\n\t/* Now map the record. */\n\tm = map_mft_record(ni);\n\tif (IS_ERR(m)) {\n\t\tmutex_unlock(&base_ni->extent_lock);\n\t\tatomic_dec(&base_ni->count);\n\t\tntfs_clear_extent_inode(ni);\n\t\tgoto map_err_out;\n\t}\n\t/* Verify the sequence number if it is present. */\n\tif (seq_no && (le16_to_cpu(m->sequence_number) != seq_no)) {\n\t\tntfs_error(base_ni->vol->sb, \"Found stale extent mft \"\n\t\t\t\t\"reference! Corrupt filesystem. Run chkdsk.\");\n\t\tdestroy_ni = true;\n\t\tm = ERR_PTR(-EIO);\n\t\tgoto unm_err_out;\n\t}\n\t/* Attach extent inode to base inode, reallocating memory if needed. */\n\tif (!(base_ni->nr_extents & 3)) {\n\t\tntfs_inode **tmp;\n\t\tint new_size = (base_ni->nr_extents + 4) * sizeof(ntfs_inode *);\n\n\t\ttmp = kmalloc(new_size, GFP_NOFS);\n\t\tif (unlikely(!tmp)) {\n\t\t\tntfs_error(base_ni->vol->sb, \"Failed to allocate \"\n\t\t\t\t\t\"internal buffer.\");\n\t\t\tdestroy_ni = true;\n\t\t\tm = ERR_PTR(-ENOMEM);\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tif (base_ni->nr_extents) {\n\t\t\tBUG_ON(!base_ni->ext.extent_ntfs_inos);\n\t\t\tmemcpy(tmp, base_ni->ext.extent_ntfs_inos, new_size -\n\t\t\t\t\t4 * sizeof(ntfs_inode *));\n\t\t\tkfree(base_ni->ext.extent_ntfs_inos);\n\t\t}\n\t\tbase_ni->ext.extent_ntfs_inos = tmp;\n\t}\n\tbase_ni->ext.extent_ntfs_inos[base_ni->nr_extents++] = ni;\n\tmutex_unlock(&base_ni->extent_lock);\n\tatomic_dec(&base_ni->count);\n\tntfs_debug(\"Done 2.\");\n\t*ntfs_ino = ni;\n\treturn m;\nunm_err_out:\n\tunmap_mft_record(ni);\n\tmutex_unlock(&base_ni->extent_lock);\n\tatomic_dec(&base_ni->count);\n\t/*\n\t * If the extent inode was not attached to the base inode we need to\n\t * release it or we will leak memory.\n\t */\n\tif (destroy_ni)\n\t\tntfs_clear_extent_inode(ni);\n\treturn m;\n}",
          "includes": [
            "#include \"ntfs.h\"",
            "#include \"mft.h\"",
            "#include \"malloc.h\"",
            "#include \"lcnalloc.h\"",
            "#include \"dir.h\"",
            "#include \"debug.h\"",
            "#include \"bitmap.h\"",
            "#include \"aops.h\"",
            "#include \"attrib.h\"",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ntfs.h\"\n#include \"mft.h\"\n#include \"malloc.h\"\n#include \"lcnalloc.h\"\n#include \"dir.h\"\n#include \"debug.h\"\n#include \"bitmap.h\"\n#include \"aops.h\"\n#include \"attrib.h\"\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n\nMFT_RECORD *map_extent_mft_record(ntfs_inode *base_ni, MFT_REF mref,\n\t\tntfs_inode **ntfs_ino)\n{\n\tMFT_RECORD *m;\n\tntfs_inode *ni = NULL;\n\tntfs_inode **extent_nis = NULL;\n\tint i;\n\tunsigned long mft_no = MREF(mref);\n\tu16 seq_no = MSEQNO(mref);\n\tbool destroy_ni = false;\n\n\tntfs_debug(\"Mapping extent mft record 0x%lx (base mft record 0x%lx).\",\n\t\t\tmft_no, base_ni->mft_no);\n\t/* Make sure the base ntfs inode doesn't go away. */\n\tatomic_inc(&base_ni->count);\n\t/*\n\t * Check if this extent inode has already been added to the base inode,\n\t * in which case just return it. If not found, add it to the base\n\t * inode before returning it.\n\t */\n\tmutex_lock(&base_ni->extent_lock);\n\tif (base_ni->nr_extents > 0) {\n\t\textent_nis = base_ni->ext.extent_ntfs_inos;\n\t\tfor (i = 0; i < base_ni->nr_extents; i++) {\n\t\t\tif (mft_no != extent_nis[i]->mft_no)\n\t\t\t\tcontinue;\n\t\t\tni = extent_nis[i];\n\t\t\t/* Make sure the ntfs inode doesn't go away. */\n\t\t\tatomic_inc(&ni->count);\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (likely(ni != NULL)) {\n\t\tmutex_unlock(&base_ni->extent_lock);\n\t\tatomic_dec(&base_ni->count);\n\t\t/* We found the record; just have to map and return it. */\n\t\tm = map_mft_record(ni);\n\t\t/* map_mft_record() has incremented this on success. */\n\t\tatomic_dec(&ni->count);\n\t\tif (likely(!IS_ERR(m))) {\n\t\t\t/* Verify the sequence number. */\n\t\t\tif (likely(le16_to_cpu(m->sequence_number) == seq_no)) {\n\t\t\t\tntfs_debug(\"Done 1.\");\n\t\t\t\t*ntfs_ino = ni;\n\t\t\t\treturn m;\n\t\t\t}\n\t\t\tunmap_mft_record(ni);\n\t\t\tntfs_error(base_ni->vol->sb, \"Found stale extent mft \"\n\t\t\t\t\t\"reference! Corrupt filesystem. \"\n\t\t\t\t\t\"Run chkdsk.\");\n\t\t\treturn ERR_PTR(-EIO);\n\t\t}\nmap_err_out:\n\t\tntfs_error(base_ni->vol->sb, \"Failed to map extent \"\n\t\t\t\t\"mft record, error code %ld.\", -PTR_ERR(m));\n\t\treturn m;\n\t}\n\t/* Record wasn't there. Get a new ntfs inode and initialize it. */\n\tni = ntfs_new_extent_inode(base_ni->vol->sb, mft_no);\n\tif (unlikely(!ni)) {\n\t\tmutex_unlock(&base_ni->extent_lock);\n\t\tatomic_dec(&base_ni->count);\n\t\treturn ERR_PTR(-ENOMEM);\n\t}\n\tni->vol = base_ni->vol;\n\tni->seq_no = seq_no;\n\tni->nr_extents = -1;\n\tni->ext.base_ntfs_ino = base_ni;\n\t/* Now map the record. */\n\tm = map_mft_record(ni);\n\tif (IS_ERR(m)) {\n\t\tmutex_unlock(&base_ni->extent_lock);\n\t\tatomic_dec(&base_ni->count);\n\t\tntfs_clear_extent_inode(ni);\n\t\tgoto map_err_out;\n\t}\n\t/* Verify the sequence number if it is present. */\n\tif (seq_no && (le16_to_cpu(m->sequence_number) != seq_no)) {\n\t\tntfs_error(base_ni->vol->sb, \"Found stale extent mft \"\n\t\t\t\t\"reference! Corrupt filesystem. Run chkdsk.\");\n\t\tdestroy_ni = true;\n\t\tm = ERR_PTR(-EIO);\n\t\tgoto unm_err_out;\n\t}\n\t/* Attach extent inode to base inode, reallocating memory if needed. */\n\tif (!(base_ni->nr_extents & 3)) {\n\t\tntfs_inode **tmp;\n\t\tint new_size = (base_ni->nr_extents + 4) * sizeof(ntfs_inode *);\n\n\t\ttmp = kmalloc(new_size, GFP_NOFS);\n\t\tif (unlikely(!tmp)) {\n\t\t\tntfs_error(base_ni->vol->sb, \"Failed to allocate \"\n\t\t\t\t\t\"internal buffer.\");\n\t\t\tdestroy_ni = true;\n\t\t\tm = ERR_PTR(-ENOMEM);\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tif (base_ni->nr_extents) {\n\t\t\tBUG_ON(!base_ni->ext.extent_ntfs_inos);\n\t\t\tmemcpy(tmp, base_ni->ext.extent_ntfs_inos, new_size -\n\t\t\t\t\t4 * sizeof(ntfs_inode *));\n\t\t\tkfree(base_ni->ext.extent_ntfs_inos);\n\t\t}\n\t\tbase_ni->ext.extent_ntfs_inos = tmp;\n\t}\n\tbase_ni->ext.extent_ntfs_inos[base_ni->nr_extents++] = ni;\n\tmutex_unlock(&base_ni->extent_lock);\n\tatomic_dec(&base_ni->count);\n\tntfs_debug(\"Done 2.\");\n\t*ntfs_ino = ni;\n\treturn m;\nunm_err_out:\n\tunmap_mft_record(ni);\n\tmutex_unlock(&base_ni->extent_lock);\n\tatomic_dec(&base_ni->count);\n\t/*\n\t * If the extent inode was not attached to the base inode we need to\n\t * release it or we will leak memory.\n\t */\n\tif (destroy_ni)\n\t\tntfs_clear_extent_inode(ni);\n\treturn m;\n}"
        }
      },
      {
        "call_info": {
          "callee": "MK_LE_MREF",
          "args": [
            "base_ni->mft_no",
            "base_ni->seq_no"
          ],
          "line": 2586
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SetPageUptodate",
          "args": [
            "page"
          ],
          "line": 2577
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISDIR",
          "args": [
            "mode"
          ],
          "line": 2574
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SetPageUptodate",
          "args": [
            "page"
          ],
          "line": 2562
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "err"
          ],
          "line": 2559
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntfs_mft_record_layout",
          "args": [
            "vol",
            "bit",
            "m"
          ],
          "line": 2558
        },
        "resolved": true,
        "details": {
          "function_name": "ntfs_mft_record_layout",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/mft.c",
          "lines": "2012-2078",
          "snippet": "static int ntfs_mft_record_layout(const ntfs_volume *vol, const s64 mft_no,\n\t\tMFT_RECORD *m)\n{\n\tATTR_RECORD *a;\n\n\tntfs_debug(\"Entering for mft record 0x%llx.\", (long long)mft_no);\n\tif (mft_no >= (1ll << 32)) {\n\t\tntfs_error(vol->sb, \"Mft record number 0x%llx exceeds \"\n\t\t\t\t\"maximum of 2^32.\", (long long)mft_no);\n\t\treturn -ERANGE;\n\t}\n\t/* Start by clearing the whole mft record to gives us a clean slate. */\n\tmemset(m, 0, vol->mft_record_size);\n\t/* Aligned to 2-byte boundary. */\n\tif (vol->major_ver < 3 || (vol->major_ver == 3 && !vol->minor_ver))\n\t\tm->usa_ofs = cpu_to_le16((sizeof(MFT_RECORD_OLD) + 1) & ~1);\n\telse {\n\t\tm->usa_ofs = cpu_to_le16((sizeof(MFT_RECORD) + 1) & ~1);\n\t\t/*\n\t\t * Set the NTFS 3.1+ specific fields while we know that the\n\t\t * volume version is 3.1+.\n\t\t */\n\t\tm->reserved = 0;\n\t\tm->mft_record_number = cpu_to_le32((u32)mft_no);\n\t}\n\tm->magic = magic_FILE;\n\tif (vol->mft_record_size >= NTFS_BLOCK_SIZE)\n\t\tm->usa_count = cpu_to_le16(vol->mft_record_size /\n\t\t\t\tNTFS_BLOCK_SIZE + 1);\n\telse {\n\t\tm->usa_count = cpu_to_le16(1);\n\t\tntfs_warning(vol->sb, \"Sector size is bigger than mft record \"\n\t\t\t\t\"size.  Setting usa_count to 1.  If chkdsk \"\n\t\t\t\t\"reports this as corruption, please email \"\n\t\t\t\t\"linux-ntfs-dev@lists.sourceforge.net stating \"\n\t\t\t\t\"that you saw this message and that the \"\n\t\t\t\t\"modified filesystem created was corrupt.  \"\n\t\t\t\t\"Thank you.\");\n\t}\n\t/* Set the update sequence number to 1. */\n\t*(le16*)((u8*)m + le16_to_cpu(m->usa_ofs)) = cpu_to_le16(1);\n\tm->lsn = 0;\n\tm->sequence_number = cpu_to_le16(1);\n\tm->link_count = 0;\n\t/*\n\t * Place the attributes straight after the update sequence array,\n\t * aligned to 8-byte boundary.\n\t */\n\tm->attrs_offset = cpu_to_le16((le16_to_cpu(m->usa_ofs) +\n\t\t\t(le16_to_cpu(m->usa_count) << 1) + 7) & ~7);\n\tm->flags = 0;\n\t/*\n\t * Using attrs_offset plus eight bytes (for the termination attribute).\n\t * attrs_offset is already aligned to 8-byte boundary, so no need to\n\t * align again.\n\t */\n\tm->bytes_in_use = cpu_to_le32(le16_to_cpu(m->attrs_offset) + 8);\n\tm->bytes_allocated = cpu_to_le32(vol->mft_record_size);\n\tm->base_mft_record = 0;\n\tm->next_attr_instance = 0;\n\t/* Add the termination attribute. */\n\ta = (ATTR_RECORD*)((u8*)m + le16_to_cpu(m->attrs_offset));\n\ta->type = AT_END;\n\ta->length = 0;\n\tntfs_debug(\"Done.\");\n\treturn 0;\n}",
          "includes": [
            "#include \"ntfs.h\"",
            "#include \"mft.h\"",
            "#include \"malloc.h\"",
            "#include \"lcnalloc.h\"",
            "#include \"dir.h\"",
            "#include \"debug.h\"",
            "#include \"bitmap.h\"",
            "#include \"aops.h\"",
            "#include \"attrib.h\"",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ntfs.h\"\n#include \"mft.h\"\n#include \"malloc.h\"\n#include \"lcnalloc.h\"\n#include \"dir.h\"\n#include \"debug.h\"\n#include \"bitmap.h\"\n#include \"aops.h\"\n#include \"attrib.h\"\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n\nstatic int ntfs_mft_record_layout(const ntfs_volume *vol, const s64 mft_no,\n\t\tMFT_RECORD *m)\n{\n\tATTR_RECORD *a;\n\n\tntfs_debug(\"Entering for mft record 0x%llx.\", (long long)mft_no);\n\tif (mft_no >= (1ll << 32)) {\n\t\tntfs_error(vol->sb, \"Mft record number 0x%llx exceeds \"\n\t\t\t\t\"maximum of 2^32.\", (long long)mft_no);\n\t\treturn -ERANGE;\n\t}\n\t/* Start by clearing the whole mft record to gives us a clean slate. */\n\tmemset(m, 0, vol->mft_record_size);\n\t/* Aligned to 2-byte boundary. */\n\tif (vol->major_ver < 3 || (vol->major_ver == 3 && !vol->minor_ver))\n\t\tm->usa_ofs = cpu_to_le16((sizeof(MFT_RECORD_OLD) + 1) & ~1);\n\telse {\n\t\tm->usa_ofs = cpu_to_le16((sizeof(MFT_RECORD) + 1) & ~1);\n\t\t/*\n\t\t * Set the NTFS 3.1+ specific fields while we know that the\n\t\t * volume version is 3.1+.\n\t\t */\n\t\tm->reserved = 0;\n\t\tm->mft_record_number = cpu_to_le32((u32)mft_no);\n\t}\n\tm->magic = magic_FILE;\n\tif (vol->mft_record_size >= NTFS_BLOCK_SIZE)\n\t\tm->usa_count = cpu_to_le16(vol->mft_record_size /\n\t\t\t\tNTFS_BLOCK_SIZE + 1);\n\telse {\n\t\tm->usa_count = cpu_to_le16(1);\n\t\tntfs_warning(vol->sb, \"Sector size is bigger than mft record \"\n\t\t\t\t\"size.  Setting usa_count to 1.  If chkdsk \"\n\t\t\t\t\"reports this as corruption, please email \"\n\t\t\t\t\"linux-ntfs-dev@lists.sourceforge.net stating \"\n\t\t\t\t\"that you saw this message and that the \"\n\t\t\t\t\"modified filesystem created was corrupt.  \"\n\t\t\t\t\"Thank you.\");\n\t}\n\t/* Set the update sequence number to 1. */\n\t*(le16*)((u8*)m + le16_to_cpu(m->usa_ofs)) = cpu_to_le16(1);\n\tm->lsn = 0;\n\tm->sequence_number = cpu_to_le16(1);\n\tm->link_count = 0;\n\t/*\n\t * Place the attributes straight after the update sequence array,\n\t * aligned to 8-byte boundary.\n\t */\n\tm->attrs_offset = cpu_to_le16((le16_to_cpu(m->usa_ofs) +\n\t\t\t(le16_to_cpu(m->usa_count) << 1) + 7) & ~7);\n\tm->flags = 0;\n\t/*\n\t * Using attrs_offset plus eight bytes (for the termination attribute).\n\t * attrs_offset is already aligned to 8-byte boundary, so no need to\n\t * align again.\n\t */\n\tm->bytes_in_use = cpu_to_le32(le16_to_cpu(m->attrs_offset) + 8);\n\tm->bytes_allocated = cpu_to_le32(vol->mft_record_size);\n\tm->base_mft_record = 0;\n\tm->next_attr_instance = 0;\n\t/* Add the termination attribute. */\n\ta = (ATTR_RECORD*)((u8*)m + le16_to_cpu(m->attrs_offset));\n\ta->type = AT_END;\n\ta->length = 0;\n\tntfs_debug(\"Done.\");\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "NVolSetErrors",
          "args": [
            "vol"
          ],
          "line": 2546
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SetPageUptodate",
          "args": [
            "page"
          ],
          "line": 2543
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntfs_is_file_record",
          "args": [
            "m->magic"
          ],
          "line": 2535
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_address",
          "args": [
            "page"
          ],
          "line": 2531
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ClearPageUptodate",
          "args": [
            "page"
          ],
          "line": 2530
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!PageUptodate(page)"
          ],
          "line": 2529
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageUptodate",
          "args": [
            "page"
          ],
          "line": 2529
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "page"
          ],
          "line": 2525
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "page"
          ],
          "line": 2522
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntfs_map_page",
          "args": [
            "vol->mft_ino->i_mapping",
            "index"
          ],
          "line": 2521
        },
        "resolved": true,
        "details": {
          "function_name": "ntfs_map_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/aops.h",
          "lines": "86-99",
          "snippet": "static inline struct page *ntfs_map_page(struct address_space *mapping,\n\t\tunsigned long index)\n{\n\tstruct page *page = read_mapping_page(mapping, index, NULL);\n\n\tif (!IS_ERR(page)) {\n\t\tkmap(page);\n\t\tif (!PageError(page))\n\t\t\treturn page;\n\t\tntfs_unmap_page(page);\n\t\treturn ERR_PTR(-EIO);\n\t}\n\treturn page;\n}",
          "includes": [
            "#include \"inode.h\"",
            "#include <linux/fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"inode.h\"\n#include <linux/fs.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n\nstatic inline struct page *ntfs_map_page(struct address_space *mapping,\n\t\tunsigned long index)\n{\n\tstruct page *page = read_mapping_page(mapping, index, NULL);\n\n\tif (!IS_ERR(page)) {\n\t\tkmap(page);\n\t\tif (!PageError(page))\n\t\t\treturn page;\n\t\tntfs_unmap_page(page);\n\t\treturn ERR_PTR(-EIO);\n\t}\n\treturn page;\n}"
        }
      },
      {
        "call_info": {
          "callee": "up_write",
          "args": [
            "&vol->mftbmp_lock"
          ],
          "line": 2513
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "read_unlock_irqrestore",
          "args": [
            "&mft_ni->size_lock",
            "flags"
          ],
          "line": 2502
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "mft_ni->initialized_size > i_size_read(vol->mft_ino)"
          ],
          "line": 2501
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "i_size_read",
          "args": [
            "vol->mft_ino"
          ],
          "line": 2501
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "i_size_read(vol->mft_ino) > mft_ni->allocated_size"
          ],
          "line": 2500
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "i_size_read",
          "args": [
            "vol->mft_ino"
          ],
          "line": 2500
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntfs_debug",
          "args": [
            "\"Status of mft data after mft record initialization: \"\n\t\t\t\"allocated_size 0x%llx, data_size 0x%llx, \"\n\t\t\t\"initialized_size 0x%llx.\"",
            "(long long)mft_ni->allocated_size",
            "(long long)i_size_read(vol->mft_ino)",
            "(long long)mft_ni->initialized_size"
          ],
          "line": 2494
        },
        "resolved": true,
        "details": {
          "function_name": "__ntfs_debug",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/debug.c",
          "lines": "115-131",
          "snippet": "void __ntfs_debug(const char *file, int line, const char *function,\n\t\tconst char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\tint flen = 0;\n\n\tif (!debug_msgs)\n\t\treturn;\n\tif (function)\n\t\tflen = strlen(function);\n\tva_start(args, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\tpr_debug(\"(%s, %d): %s(): %pV\", file, line, flen ? function : \"\", &vaf);\n\tva_end(args);\n}",
          "includes": [
            "#include \"debug.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"debug.h\"\n\nvoid __ntfs_debug(const char *file, int line, const char *function,\n\t\tconst char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\tint flen = 0;\n\n\tif (!debug_msgs)\n\t\treturn;\n\tif (function)\n\t\tflen = strlen(function);\n\tva_start(args, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\tpr_debug(\"(%s, %d): %s(): %pV\", file, line, flen ? function : \"\", &vaf);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "i_size_read",
          "args": [
            "vol->mft_ino"
          ],
          "line": 2498
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "read_lock_irqsave",
          "args": [
            "&mft_ni->size_lock",
            "flags"
          ],
          "line": 2493
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unmap_mft_record",
          "args": [
            "mft_ni"
          ],
          "line": 2492
        },
        "resolved": true,
        "details": {
          "function_name": "unmap_mft_record",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/mft.c",
          "lines": "213-231",
          "snippet": "void unmap_mft_record(ntfs_inode *ni)\n{\n\tstruct page *page = ni->page;\n\n\tBUG_ON(!page);\n\n\tntfs_debug(\"Entering for mft_no 0x%lx.\", ni->mft_no);\n\n\tunmap_mft_record_page(ni);\n\tmutex_unlock(&ni->mrec_lock);\n\tatomic_dec(&ni->count);\n\t/*\n\t * If pure ntfs_inode, i.e. no vfs inode attached, we leave it to\n\t * ntfs_clear_extent_inode() in the extent inode case, and to the\n\t * caller in the non-extent, yet pure ntfs inode case, to do the actual\n\t * tear down of all structures and freeing of all allocated memory.\n\t */\n\treturn;\n}",
          "includes": [
            "#include \"ntfs.h\"",
            "#include \"mft.h\"",
            "#include \"malloc.h\"",
            "#include \"lcnalloc.h\"",
            "#include \"dir.h\"",
            "#include \"debug.h\"",
            "#include \"bitmap.h\"",
            "#include \"aops.h\"",
            "#include \"attrib.h\"",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ntfs.h\"\n#include \"mft.h\"\n#include \"malloc.h\"\n#include \"lcnalloc.h\"\n#include \"dir.h\"\n#include \"debug.h\"\n#include \"bitmap.h\"\n#include \"aops.h\"\n#include \"attrib.h\"\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n\nvoid unmap_mft_record(ntfs_inode *ni)\n{\n\tstruct page *page = ni->page;\n\n\tBUG_ON(!page);\n\n\tntfs_debug(\"Entering for mft_no 0x%lx.\", ni->mft_no);\n\n\tunmap_mft_record_page(ni);\n\tmutex_unlock(&ni->mrec_lock);\n\tatomic_dec(&ni->count);\n\t/*\n\t * If pure ntfs_inode, i.e. no vfs inode attached, we leave it to\n\t * ntfs_clear_extent_inode() in the extent inode case, and to the\n\t * caller in the non-extent, yet pure ntfs inode case, to do the actual\n\t * tear down of all structures and freeing of all allocated memory.\n\t */\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ntfs_attr_put_search_ctx",
          "args": [
            "ctx"
          ],
          "line": 2491
        },
        "resolved": true,
        "details": {
          "function_name": "ntfs_attr_put_search_ctx",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/attrib.c",
          "lines": "1286-1292",
          "snippet": "void ntfs_attr_put_search_ctx(ntfs_attr_search_ctx *ctx)\n{\n\tif (ctx->base_ntfs_ino && ctx->ntfs_ino != ctx->base_ntfs_ino)\n\t\tunmap_extent_mft_record(ctx->ntfs_ino);\n\tkmem_cache_free(ntfs_attr_ctx_cache, ctx);\n\treturn;\n}",
          "includes": [
            "#include \"types.h\"",
            "#include \"ntfs.h\"",
            "#include \"mft.h\"",
            "#include \"malloc.h\"",
            "#include \"lcnalloc.h\"",
            "#include \"layout.h\"",
            "#include \"debug.h\"",
            "#include \"attrib.h\"",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include \"ntfs.h\"\n#include \"mft.h\"\n#include \"malloc.h\"\n#include \"lcnalloc.h\"\n#include \"layout.h\"\n#include \"debug.h\"\n#include \"attrib.h\"\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/buffer_head.h>\n\nvoid ntfs_attr_put_search_ctx(ntfs_attr_search_ctx *ctx)\n{\n\tif (ctx->base_ntfs_ino && ctx->ntfs_ino != ctx->base_ntfs_ino)\n\t\tunmap_extent_mft_record(ctx->ntfs_ino);\n\tkmem_cache_free(ntfs_attr_ctx_cache, ctx);\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mark_mft_record_dirty",
          "args": [
            "ctx->ntfs_ino"
          ],
          "line": 2490
        },
        "resolved": true,
        "details": {
          "function_name": "__mark_mft_record_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/mft.c",
          "lines": "395-410",
          "snippet": "void __mark_mft_record_dirty(ntfs_inode *ni)\n{\n\tntfs_inode *base_ni;\n\n\tntfs_debug(\"Entering for inode 0x%lx.\", ni->mft_no);\n\tBUG_ON(NInoAttr(ni));\n\tmark_ntfs_record_dirty(ni->page, ni->page_ofs);\n\t/* Determine the base vfs inode and mark it dirty, too. */\n\tmutex_lock(&ni->extent_lock);\n\tif (likely(ni->nr_extents >= 0))\n\t\tbase_ni = ni;\n\telse\n\t\tbase_ni = ni->ext.base_ntfs_ino;\n\tmutex_unlock(&ni->extent_lock);\n\t__mark_inode_dirty(VFS_I(base_ni), I_DIRTY_SYNC | I_DIRTY_DATASYNC);\n}",
          "includes": [
            "#include \"ntfs.h\"",
            "#include \"mft.h\"",
            "#include \"malloc.h\"",
            "#include \"lcnalloc.h\"",
            "#include \"dir.h\"",
            "#include \"debug.h\"",
            "#include \"bitmap.h\"",
            "#include \"aops.h\"",
            "#include \"attrib.h\"",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ntfs.h\"\n#include \"mft.h\"\n#include \"malloc.h\"\n#include \"lcnalloc.h\"\n#include \"dir.h\"\n#include \"debug.h\"\n#include \"bitmap.h\"\n#include \"aops.h\"\n#include \"attrib.h\"\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n\nvoid __mark_mft_record_dirty(ntfs_inode *ni)\n{\n\tntfs_inode *base_ni;\n\n\tntfs_debug(\"Entering for inode 0x%lx.\", ni->mft_no);\n\tBUG_ON(NInoAttr(ni));\n\tmark_ntfs_record_dirty(ni->page, ni->page_ofs);\n\t/* Determine the base vfs inode and mark it dirty, too. */\n\tmutex_lock(&ni->extent_lock);\n\tif (likely(ni->nr_extents >= 0))\n\t\tbase_ni = ni;\n\telse\n\t\tbase_ni = ni->ext.base_ntfs_ino;\n\tmutex_unlock(&ni->extent_lock);\n\t__mark_inode_dirty(VFS_I(base_ni), I_DIRTY_SYNC | I_DIRTY_DATASYNC);\n}"
        }
      },
      {
        "call_info": {
          "callee": "flush_dcache_mft_record_page",
          "args": [
            "ctx->ntfs_ino"
          ],
          "line": 2489
        },
        "resolved": true,
        "details": {
          "function_name": "flush_dcache_mft_record_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/mft.h",
          "lines": "55-58",
          "snippet": "static inline void flush_dcache_mft_record_page(ntfs_inode *ni)\n{\n\tflush_dcache_page(ni->page);\n}",
          "includes": [
            "#include \"inode.h\"",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"inode.h\"\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/fs.h>\n\nstatic inline void flush_dcache_mft_record_page(ntfs_inode *ni)\n{\n\tflush_dcache_page(ni->page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "read_unlock_irqrestore",
          "args": [
            "&mft_ni->size_lock",
            "flags"
          ],
          "line": 2487
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_sle64",
          "args": [
            "i_size_read(vol->mft_ino)"
          ],
          "line": 2486
        },
        "resolved": true,
        "details": {
          "function_name": "cpu_to_sle64p",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "88-91",
          "snippet": "static inline sle64 cpu_to_sle64p(s64 *x)\n{\n\treturn (__force sle64)cpu_to_le64(*x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline sle64 cpu_to_sle64p(s64 *x)\n{\n\treturn (__force sle64)cpu_to_le64(*x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "i_size_read",
          "args": [
            "vol->mft_ino"
          ],
          "line": 2486
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "read_lock_irqsave",
          "args": [
            "&mft_ni->size_lock",
            "flags"
          ],
          "line": 2482
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntfs_error",
          "args": [
            "vol->sb",
            "\"Failed to find first attribute extent of \"\n\t\t\t\t\"mft data attribute.\""
          ],
          "line": 2475
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "err"
          ],
          "line": 2474
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntfs_attr_lookup",
          "args": [
            "mft_ni->type",
            "mft_ni->name",
            "mft_ni->name_len",
            "CASE_SENSITIVE",
            "0",
            "NULL",
            "0",
            "ctx"
          ],
          "line": 2472
        },
        "resolved": true,
        "details": {
          "function_name": "ntfs_attr_lookup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/attrib.c",
          "lines": "1187-1207",
          "snippet": "int ntfs_attr_lookup(const ATTR_TYPE type, const ntfschar *name,\n\t\tconst u32 name_len, const IGNORE_CASE_BOOL ic,\n\t\tconst VCN lowest_vcn, const u8 *val, const u32 val_len,\n\t\tntfs_attr_search_ctx *ctx)\n{\n\tntfs_inode *base_ni;\n\n\tntfs_debug(\"Entering.\");\n\tBUG_ON(IS_ERR(ctx->mrec));\n\tif (ctx->base_ntfs_ino)\n\t\tbase_ni = ctx->base_ntfs_ino;\n\telse\n\t\tbase_ni = ctx->ntfs_ino;\n\t/* Sanity check, just for debugging really. */\n\tBUG_ON(!base_ni);\n\tif (!NInoAttrList(base_ni) || type == AT_ATTRIBUTE_LIST)\n\t\treturn ntfs_attr_find(type, name, name_len, ic, val, val_len,\n\t\t\t\tctx);\n\treturn ntfs_external_attr_find(type, name, name_len, ic, lowest_vcn,\n\t\t\tval, val_len, ctx);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include \"ntfs.h\"",
            "#include \"mft.h\"",
            "#include \"malloc.h\"",
            "#include \"lcnalloc.h\"",
            "#include \"layout.h\"",
            "#include \"debug.h\"",
            "#include \"attrib.h\"",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include \"ntfs.h\"\n#include \"mft.h\"\n#include \"malloc.h\"\n#include \"lcnalloc.h\"\n#include \"layout.h\"\n#include \"debug.h\"\n#include \"attrib.h\"\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/buffer_head.h>\n\nint ntfs_attr_lookup(const ATTR_TYPE type, const ntfschar *name,\n\t\tconst u32 name_len, const IGNORE_CASE_BOOL ic,\n\t\tconst VCN lowest_vcn, const u8 *val, const u32 val_len,\n\t\tntfs_attr_search_ctx *ctx)\n{\n\tntfs_inode *base_ni;\n\n\tntfs_debug(\"Entering.\");\n\tBUG_ON(IS_ERR(ctx->mrec));\n\tif (ctx->base_ntfs_ino)\n\t\tbase_ni = ctx->base_ntfs_ino;\n\telse\n\t\tbase_ni = ctx->ntfs_ino;\n\t/* Sanity check, just for debugging really. */\n\tBUG_ON(!base_ni);\n\tif (!NInoAttrList(base_ni) || type == AT_ATTRIBUTE_LIST)\n\t\treturn ntfs_attr_find(type, name, name_len, ic, val, val_len,\n\t\t\t\tctx);\n\treturn ntfs_external_attr_find(type, name, name_len, ic, lowest_vcn,\n\t\t\tval, val_len, ctx);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ntfs_error",
          "args": [
            "vol->sb",
            "\"Failed to get search context.\""
          ],
          "line": 2467
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!ctx"
          ],
          "line": 2466
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntfs_attr_get_search_ctx",
          "args": [
            "mft_ni",
            "m"
          ],
          "line": 2465
        },
        "resolved": true,
        "details": {
          "function_name": "ntfs_attr_get_search_ctx",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/attrib.c",
          "lines": "1269-1277",
          "snippet": "ntfs_attr_search_ctx *ntfs_attr_get_search_ctx(ntfs_inode *ni, MFT_RECORD *mrec)\n{\n\tntfs_attr_search_ctx *ctx;\n\n\tctx = kmem_cache_alloc(ntfs_attr_ctx_cache, GFP_NOFS);\n\tif (ctx)\n\t\tntfs_attr_init_search_ctx(ctx, ni, mrec);\n\treturn ctx;\n}",
          "includes": [
            "#include \"types.h\"",
            "#include \"ntfs.h\"",
            "#include \"mft.h\"",
            "#include \"malloc.h\"",
            "#include \"lcnalloc.h\"",
            "#include \"layout.h\"",
            "#include \"debug.h\"",
            "#include \"attrib.h\"",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include \"ntfs.h\"\n#include \"mft.h\"\n#include \"malloc.h\"\n#include \"lcnalloc.h\"\n#include \"layout.h\"\n#include \"debug.h\"\n#include \"attrib.h\"\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/buffer_head.h>\n\nntfs_attr_search_ctx *ntfs_attr_get_search_ctx(ntfs_inode *ni, MFT_RECORD *mrec)\n{\n\tntfs_attr_search_ctx *ctx;\n\n\tctx = kmem_cache_alloc(ntfs_attr_ctx_cache, GFP_NOFS);\n\tif (ctx)\n\t\tntfs_attr_init_search_ctx(ctx, ni, mrec);\n\treturn ctx;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "m"
          ],
          "line": 2462
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntfs_error",
          "args": [
            "vol->sb",
            "\"Failed to map mft record.\""
          ],
          "line": 2461
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "m"
          ],
          "line": 2460
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "write_unlock_irqrestore",
          "args": [
            "&mft_ni->size_lock",
            "flags"
          ],
          "line": 2456
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "write_lock_irqsave",
          "args": [
            "&mft_ni->size_lock",
            "flags"
          ],
          "line": 2453
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntfs_error",
          "args": [
            "vol->sb",
            "\"Failed to format mft record.\""
          ],
          "line": 2450
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "err"
          ],
          "line": 2449
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntfs_mft_record_format",
          "args": [
            "vol",
            "mft_no"
          ],
          "line": 2448
        },
        "resolved": true,
        "details": {
          "function_name": "ntfs_mft_record_format",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/mft.c",
          "lines": "2091-2151",
          "snippet": "static int ntfs_mft_record_format(const ntfs_volume *vol, const s64 mft_no)\n{\n\tloff_t i_size;\n\tstruct inode *mft_vi = vol->mft_ino;\n\tstruct page *page;\n\tMFT_RECORD *m;\n\tpgoff_t index, end_index;\n\tunsigned int ofs;\n\tint err;\n\n\tntfs_debug(\"Entering for mft record 0x%llx.\", (long long)mft_no);\n\t/*\n\t * The index into the page cache and the offset within the page cache\n\t * page of the wanted mft record.\n\t */\n\tindex = mft_no << vol->mft_record_size_bits >> PAGE_CACHE_SHIFT;\n\tofs = (mft_no << vol->mft_record_size_bits) & ~PAGE_CACHE_MASK;\n\t/* The maximum valid index into the page cache for $MFT's data. */\n\ti_size = i_size_read(mft_vi);\n\tend_index = i_size >> PAGE_CACHE_SHIFT;\n\tif (unlikely(index >= end_index)) {\n\t\tif (unlikely(index > end_index || ofs + vol->mft_record_size >=\n\t\t\t\t(i_size & ~PAGE_CACHE_MASK))) {\n\t\t\tntfs_error(vol->sb, \"Tried to format non-existing mft \"\n\t\t\t\t\t\"record 0x%llx.\", (long long)mft_no);\n\t\t\treturn -ENOENT;\n\t\t}\n\t}\n\t/* Read, map, and pin the page containing the mft record. */\n\tpage = ntfs_map_page(mft_vi->i_mapping, index);\n\tif (IS_ERR(page)) {\n\t\tntfs_error(vol->sb, \"Failed to map page containing mft record \"\n\t\t\t\t\"to format 0x%llx.\", (long long)mft_no);\n\t\treturn PTR_ERR(page);\n\t}\n\tlock_page(page);\n\tBUG_ON(!PageUptodate(page));\n\tClearPageUptodate(page);\n\tm = (MFT_RECORD*)((u8*)page_address(page) + ofs);\n\terr = ntfs_mft_record_layout(vol, mft_no, m);\n\tif (unlikely(err)) {\n\t\tntfs_error(vol->sb, \"Failed to layout mft record 0x%llx.\",\n\t\t\t\t(long long)mft_no);\n\t\tSetPageUptodate(page);\n\t\tunlock_page(page);\n\t\tntfs_unmap_page(page);\n\t\treturn err;\n\t}\n\tflush_dcache_page(page);\n\tSetPageUptodate(page);\n\tunlock_page(page);\n\t/*\n\t * Make sure the mft record is written out to disk.  We could use\n\t * ilookup5() to check if an inode is in icache and so on but this is\n\t * unnecessary as ntfs_writepage() will write the dirty record anyway.\n\t */\n\tmark_ntfs_record_dirty(page, ofs);\n\tntfs_unmap_page(page);\n\tntfs_debug(\"Done.\");\n\treturn 0;\n}",
          "includes": [
            "#include \"ntfs.h\"",
            "#include \"mft.h\"",
            "#include \"malloc.h\"",
            "#include \"lcnalloc.h\"",
            "#include \"dir.h\"",
            "#include \"debug.h\"",
            "#include \"bitmap.h\"",
            "#include \"aops.h\"",
            "#include \"attrib.h\"",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ntfs.h\"\n#include \"mft.h\"\n#include \"malloc.h\"\n#include \"lcnalloc.h\"\n#include \"dir.h\"\n#include \"debug.h\"\n#include \"bitmap.h\"\n#include \"aops.h\"\n#include \"attrib.h\"\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n\nstatic int ntfs_mft_record_format(const ntfs_volume *vol, const s64 mft_no)\n{\n\tloff_t i_size;\n\tstruct inode *mft_vi = vol->mft_ino;\n\tstruct page *page;\n\tMFT_RECORD *m;\n\tpgoff_t index, end_index;\n\tunsigned int ofs;\n\tint err;\n\n\tntfs_debug(\"Entering for mft record 0x%llx.\", (long long)mft_no);\n\t/*\n\t * The index into the page cache and the offset within the page cache\n\t * page of the wanted mft record.\n\t */\n\tindex = mft_no << vol->mft_record_size_bits >> PAGE_CACHE_SHIFT;\n\tofs = (mft_no << vol->mft_record_size_bits) & ~PAGE_CACHE_MASK;\n\t/* The maximum valid index into the page cache for $MFT's data. */\n\ti_size = i_size_read(mft_vi);\n\tend_index = i_size >> PAGE_CACHE_SHIFT;\n\tif (unlikely(index >= end_index)) {\n\t\tif (unlikely(index > end_index || ofs + vol->mft_record_size >=\n\t\t\t\t(i_size & ~PAGE_CACHE_MASK))) {\n\t\t\tntfs_error(vol->sb, \"Tried to format non-existing mft \"\n\t\t\t\t\t\"record 0x%llx.\", (long long)mft_no);\n\t\t\treturn -ENOENT;\n\t\t}\n\t}\n\t/* Read, map, and pin the page containing the mft record. */\n\tpage = ntfs_map_page(mft_vi->i_mapping, index);\n\tif (IS_ERR(page)) {\n\t\tntfs_error(vol->sb, \"Failed to map page containing mft record \"\n\t\t\t\t\"to format 0x%llx.\", (long long)mft_no);\n\t\treturn PTR_ERR(page);\n\t}\n\tlock_page(page);\n\tBUG_ON(!PageUptodate(page));\n\tClearPageUptodate(page);\n\tm = (MFT_RECORD*)((u8*)page_address(page) + ofs);\n\terr = ntfs_mft_record_layout(vol, mft_no, m);\n\tif (unlikely(err)) {\n\t\tntfs_error(vol->sb, \"Failed to layout mft record 0x%llx.\",\n\t\t\t\t(long long)mft_no);\n\t\tSetPageUptodate(page);\n\t\tunlock_page(page);\n\t\tntfs_unmap_page(page);\n\t\treturn err;\n\t}\n\tflush_dcache_page(page);\n\tSetPageUptodate(page);\n\tunlock_page(page);\n\t/*\n\t * Make sure the mft record is written out to disk.  We could use\n\t * ilookup5() to check if an inode is in icache and so on but this is\n\t * unnecessary as ntfs_writepage() will write the dirty record anyway.\n\t */\n\tmark_ntfs_record_dirty(page, ofs);\n\tntfs_unmap_page(page);\n\tntfs_debug(\"Done.\");\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ntfs_debug",
          "args": [
            "\"Initializing mft record 0x%llx.\"",
            "(long long)mft_no"
          ],
          "line": 2446
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "write_unlock_irqrestore",
          "args": [
            "&mft_ni->size_lock",
            "flags"
          ],
          "line": 2445
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "i_size_read",
          "args": [
            "vol->mft_ino"
          ],
          "line": 2443
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "write_lock_irqsave",
          "args": [
            "&mft_ni->size_lock",
            "flags"
          ],
          "line": 2434
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "read_unlock_irqrestore",
          "args": [
            "&mft_ni->size_lock",
            "flags"
          ],
          "line": 2426
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "i_size_read",
          "args": [
            "vol->mft_ino"
          ],
          "line": 2423
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "read_lock_irqsave",
          "args": [
            "&mft_ni->size_lock",
            "flags"
          ],
          "line": 2418
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntfs_error",
          "args": [
            "vol->sb",
            "\"Failed to extend mft data \"\n\t\t\t\t\t\"allocation.\""
          ],
          "line": 2414
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "err"
          ],
          "line": 2413
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntfs_mft_data_extend_allocation_nolock",
          "args": [
            "vol"
          ],
          "line": 2412
        },
        "resolved": true,
        "details": {
          "function_name": "ntfs_mft_data_extend_allocation_nolock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/mft.c",
          "lines": "1714-1997",
          "snippet": "static int ntfs_mft_data_extend_allocation_nolock(ntfs_volume *vol)\n{\n\tLCN lcn;\n\tVCN old_last_vcn;\n\ts64 min_nr, nr, ll;\n\tunsigned long flags;\n\tntfs_inode *mft_ni;\n\trunlist_element *rl, *rl2;\n\tntfs_attr_search_ctx *ctx = NULL;\n\tMFT_RECORD *mrec;\n\tATTR_RECORD *a = NULL;\n\tint ret, mp_size;\n\tu32 old_alen = 0;\n\tbool mp_rebuilt = false;\n\n\tntfs_debug(\"Extending mft data allocation.\");\n\tmft_ni = NTFS_I(vol->mft_ino);\n\t/*\n\t * Determine the preferred allocation location, i.e. the last lcn of\n\t * the mft data attribute.  The allocated size of the mft data\n\t * attribute cannot be zero so we are ok to do this.\n\t */\n\tdown_write(&mft_ni->runlist.lock);\n\tread_lock_irqsave(&mft_ni->size_lock, flags);\n\tll = mft_ni->allocated_size;\n\tread_unlock_irqrestore(&mft_ni->size_lock, flags);\n\trl = ntfs_attr_find_vcn_nolock(mft_ni,\n\t\t\t(ll - 1) >> vol->cluster_size_bits, NULL);\n\tif (unlikely(IS_ERR(rl) || !rl->length || rl->lcn < 0)) {\n\t\tup_write(&mft_ni->runlist.lock);\n\t\tntfs_error(vol->sb, \"Failed to determine last allocated \"\n\t\t\t\t\"cluster of mft data attribute.\");\n\t\tif (!IS_ERR(rl))\n\t\t\tret = -EIO;\n\t\telse\n\t\t\tret = PTR_ERR(rl);\n\t\treturn ret;\n\t}\n\tlcn = rl->lcn + rl->length;\n\tntfs_debug(\"Last lcn of mft data attribute is 0x%llx.\", (long long)lcn);\n\t/* Minimum allocation is one mft record worth of clusters. */\n\tmin_nr = vol->mft_record_size >> vol->cluster_size_bits;\n\tif (!min_nr)\n\t\tmin_nr = 1;\n\t/* Want to allocate 16 mft records worth of clusters. */\n\tnr = vol->mft_record_size << 4 >> vol->cluster_size_bits;\n\tif (!nr)\n\t\tnr = min_nr;\n\t/* Ensure we do not go above 2^32-1 mft records. */\n\tread_lock_irqsave(&mft_ni->size_lock, flags);\n\tll = mft_ni->allocated_size;\n\tread_unlock_irqrestore(&mft_ni->size_lock, flags);\n\tif (unlikely((ll + (nr << vol->cluster_size_bits)) >>\n\t\t\tvol->mft_record_size_bits >= (1ll << 32))) {\n\t\tnr = min_nr;\n\t\tif (unlikely((ll + (nr << vol->cluster_size_bits)) >>\n\t\t\t\tvol->mft_record_size_bits >= (1ll << 32))) {\n\t\t\tntfs_warning(vol->sb, \"Cannot allocate mft record \"\n\t\t\t\t\t\"because the maximum number of inodes \"\n\t\t\t\t\t\"(2^32) has already been reached.\");\n\t\t\tup_write(&mft_ni->runlist.lock);\n\t\t\treturn -ENOSPC;\n\t\t}\n\t}\n\tntfs_debug(\"Trying mft data allocation with %s cluster count %lli.\",\n\t\t\tnr > min_nr ? \"default\" : \"minimal\", (long long)nr);\n\told_last_vcn = rl[1].vcn;\n\tdo {\n\t\trl2 = ntfs_cluster_alloc(vol, old_last_vcn, nr, lcn, MFT_ZONE,\n\t\t\t\ttrue);\n\t\tif (likely(!IS_ERR(rl2)))\n\t\t\tbreak;\n\t\tif (PTR_ERR(rl2) != -ENOSPC || nr == min_nr) {\n\t\t\tntfs_error(vol->sb, \"Failed to allocate the minimal \"\n\t\t\t\t\t\"number of clusters (%lli) for the \"\n\t\t\t\t\t\"mft data attribute.\", (long long)nr);\n\t\t\tup_write(&mft_ni->runlist.lock);\n\t\t\treturn PTR_ERR(rl2);\n\t\t}\n\t\t/*\n\t\t * There is not enough space to do the allocation, but there\n\t\t * might be enough space to do a minimal allocation so try that\n\t\t * before failing.\n\t\t */\n\t\tnr = min_nr;\n\t\tntfs_debug(\"Retrying mft data allocation with minimal cluster \"\n\t\t\t\t\"count %lli.\", (long long)nr);\n\t} while (1);\n\trl = ntfs_runlists_merge(mft_ni->runlist.rl, rl2);\n\tif (IS_ERR(rl)) {\n\t\tup_write(&mft_ni->runlist.lock);\n\t\tntfs_error(vol->sb, \"Failed to merge runlists for mft data \"\n\t\t\t\t\"attribute.\");\n\t\tif (ntfs_cluster_free_from_rl(vol, rl2)) {\n\t\t\tntfs_error(vol->sb, \"Failed to deallocate clusters \"\n\t\t\t\t\t\"from the mft data attribute.%s\", es);\n\t\t\tNVolSetErrors(vol);\n\t\t}\n\t\tntfs_free(rl2);\n\t\treturn PTR_ERR(rl);\n\t}\n\tmft_ni->runlist.rl = rl;\n\tntfs_debug(\"Allocated %lli clusters.\", (long long)nr);\n\t/* Find the last run in the new runlist. */\n\tfor (; rl[1].length; rl++)\n\t\t;\n\t/* Update the attribute record as well. */\n\tmrec = map_mft_record(mft_ni);\n\tif (IS_ERR(mrec)) {\n\t\tntfs_error(vol->sb, \"Failed to map mft record.\");\n\t\tret = PTR_ERR(mrec);\n\t\tgoto undo_alloc;\n\t}\n\tctx = ntfs_attr_get_search_ctx(mft_ni, mrec);\n\tif (unlikely(!ctx)) {\n\t\tntfs_error(vol->sb, \"Failed to get search context.\");\n\t\tret = -ENOMEM;\n\t\tgoto undo_alloc;\n\t}\n\tret = ntfs_attr_lookup(mft_ni->type, mft_ni->name, mft_ni->name_len,\n\t\t\tCASE_SENSITIVE, rl[1].vcn, NULL, 0, ctx);\n\tif (unlikely(ret)) {\n\t\tntfs_error(vol->sb, \"Failed to find last attribute extent of \"\n\t\t\t\t\"mft data attribute.\");\n\t\tif (ret == -ENOENT)\n\t\t\tret = -EIO;\n\t\tgoto undo_alloc;\n\t}\n\ta = ctx->attr;\n\tll = sle64_to_cpu(a->data.non_resident.lowest_vcn);\n\t/* Search back for the previous last allocated cluster of mft bitmap. */\n\tfor (rl2 = rl; rl2 > mft_ni->runlist.rl; rl2--) {\n\t\tif (ll >= rl2->vcn)\n\t\t\tbreak;\n\t}\n\tBUG_ON(ll < rl2->vcn);\n\tBUG_ON(ll >= rl2->vcn + rl2->length);\n\t/* Get the size for the new mapping pairs array for this extent. */\n\tmp_size = ntfs_get_size_for_mapping_pairs(vol, rl2, ll, -1);\n\tif (unlikely(mp_size <= 0)) {\n\t\tntfs_error(vol->sb, \"Get size for mapping pairs failed for \"\n\t\t\t\t\"mft data attribute extent.\");\n\t\tret = mp_size;\n\t\tif (!ret)\n\t\t\tret = -EIO;\n\t\tgoto undo_alloc;\n\t}\n\t/* Expand the attribute record if necessary. */\n\told_alen = le32_to_cpu(a->length);\n\tret = ntfs_attr_record_resize(ctx->mrec, a, mp_size +\n\t\t\tle16_to_cpu(a->data.non_resident.mapping_pairs_offset));\n\tif (unlikely(ret)) {\n\t\tif (ret != -ENOSPC) {\n\t\t\tntfs_error(vol->sb, \"Failed to resize attribute \"\n\t\t\t\t\t\"record for mft data attribute.\");\n\t\t\tgoto undo_alloc;\n\t\t}\n\t\t// TODO: Deal with this by moving this extent to a new mft\n\t\t// record or by starting a new extent in a new mft record or by\n\t\t// moving other attributes out of this mft record.\n\t\t// Note: Use the special reserved mft records and ensure that\n\t\t// this extent is not required to find the mft record in\n\t\t// question.  If no free special records left we would need to\n\t\t// move an existing record away, insert ours in its place, and\n\t\t// then place the moved record into the newly allocated space\n\t\t// and we would then need to update all references to this mft\n\t\t// record appropriately.  This is rather complicated...\n\t\tntfs_error(vol->sb, \"Not enough space in this mft record to \"\n\t\t\t\t\"accommodate extended mft data attribute \"\n\t\t\t\t\"extent.  Cannot handle this yet.\");\n\t\tret = -EOPNOTSUPP;\n\t\tgoto undo_alloc;\n\t}\n\tmp_rebuilt = true;\n\t/* Generate the mapping pairs array directly into the attr record. */\n\tret = ntfs_mapping_pairs_build(vol, (u8*)a +\n\t\t\tle16_to_cpu(a->data.non_resident.mapping_pairs_offset),\n\t\t\tmp_size, rl2, ll, -1, NULL);\n\tif (unlikely(ret)) {\n\t\tntfs_error(vol->sb, \"Failed to build mapping pairs array of \"\n\t\t\t\t\"mft data attribute.\");\n\t\tgoto undo_alloc;\n\t}\n\t/* Update the highest_vcn. */\n\ta->data.non_resident.highest_vcn = cpu_to_sle64(rl[1].vcn - 1);\n\t/*\n\t * We now have extended the mft data allocated_size by nr clusters.\n\t * Reflect this in the ntfs_inode structure and the attribute record.\n\t * @rl is the last (non-terminator) runlist element of mft data\n\t * attribute.\n\t */\n\tif (a->data.non_resident.lowest_vcn) {\n\t\t/*\n\t\t * We are not in the first attribute extent, switch to it, but\n\t\t * first ensure the changes will make it to disk later.\n\t\t */\n\t\tflush_dcache_mft_record_page(ctx->ntfs_ino);\n\t\tmark_mft_record_dirty(ctx->ntfs_ino);\n\t\tntfs_attr_reinit_search_ctx(ctx);\n\t\tret = ntfs_attr_lookup(mft_ni->type, mft_ni->name,\n\t\t\t\tmft_ni->name_len, CASE_SENSITIVE, 0, NULL, 0,\n\t\t\t\tctx);\n\t\tif (unlikely(ret)) {\n\t\t\tntfs_error(vol->sb, \"Failed to find first attribute \"\n\t\t\t\t\t\"extent of mft data attribute.\");\n\t\t\tgoto restore_undo_alloc;\n\t\t}\n\t\ta = ctx->attr;\n\t}\n\twrite_lock_irqsave(&mft_ni->size_lock, flags);\n\tmft_ni->allocated_size += nr << vol->cluster_size_bits;\n\ta->data.non_resident.allocated_size =\n\t\t\tcpu_to_sle64(mft_ni->allocated_size);\n\twrite_unlock_irqrestore(&mft_ni->size_lock, flags);\n\t/* Ensure the changes make it to disk. */\n\tflush_dcache_mft_record_page(ctx->ntfs_ino);\n\tmark_mft_record_dirty(ctx->ntfs_ino);\n\tntfs_attr_put_search_ctx(ctx);\n\tunmap_mft_record(mft_ni);\n\tup_write(&mft_ni->runlist.lock);\n\tntfs_debug(\"Done.\");\n\treturn 0;\nrestore_undo_alloc:\n\tntfs_attr_reinit_search_ctx(ctx);\n\tif (ntfs_attr_lookup(mft_ni->type, mft_ni->name, mft_ni->name_len,\n\t\t\tCASE_SENSITIVE, rl[1].vcn, NULL, 0, ctx)) {\n\t\tntfs_error(vol->sb, \"Failed to find last attribute extent of \"\n\t\t\t\t\"mft data attribute.%s\", es);\n\t\twrite_lock_irqsave(&mft_ni->size_lock, flags);\n\t\tmft_ni->allocated_size += nr << vol->cluster_size_bits;\n\t\twrite_unlock_irqrestore(&mft_ni->size_lock, flags);\n\t\tntfs_attr_put_search_ctx(ctx);\n\t\tunmap_mft_record(mft_ni);\n\t\tup_write(&mft_ni->runlist.lock);\n\t\t/*\n\t\t * The only thing that is now wrong is ->allocated_size of the\n\t\t * base attribute extent which chkdsk should be able to fix.\n\t\t */\n\t\tNVolSetErrors(vol);\n\t\treturn ret;\n\t}\n\tctx->attr->data.non_resident.highest_vcn =\n\t\t\tcpu_to_sle64(old_last_vcn - 1);\nundo_alloc:\n\tif (ntfs_cluster_free(mft_ni, old_last_vcn, -1, ctx) < 0) {\n\t\tntfs_error(vol->sb, \"Failed to free clusters from mft data \"\n\t\t\t\t\"attribute.%s\", es);\n\t\tNVolSetErrors(vol);\n\t}\n\ta = ctx->attr;\n\tif (ntfs_rl_truncate_nolock(vol, &mft_ni->runlist, old_last_vcn)) {\n\t\tntfs_error(vol->sb, \"Failed to truncate mft data attribute \"\n\t\t\t\t\"runlist.%s\", es);\n\t\tNVolSetErrors(vol);\n\t}\n\tif (mp_rebuilt && !IS_ERR(ctx->mrec)) {\n\t\tif (ntfs_mapping_pairs_build(vol, (u8*)a + le16_to_cpu(\n\t\t\t\ta->data.non_resident.mapping_pairs_offset),\n\t\t\t\told_alen - le16_to_cpu(\n\t\t\t\ta->data.non_resident.mapping_pairs_offset),\n\t\t\t\trl2, ll, -1, NULL)) {\n\t\t\tntfs_error(vol->sb, \"Failed to restore mapping pairs \"\n\t\t\t\t\t\"array.%s\", es);\n\t\t\tNVolSetErrors(vol);\n\t\t}\n\t\tif (ntfs_attr_record_resize(ctx->mrec, a, old_alen)) {\n\t\t\tntfs_error(vol->sb, \"Failed to restore attribute \"\n\t\t\t\t\t\"record.%s\", es);\n\t\t\tNVolSetErrors(vol);\n\t\t}\n\t\tflush_dcache_mft_record_page(ctx->ntfs_ino);\n\t\tmark_mft_record_dirty(ctx->ntfs_ino);\n\t} else if (IS_ERR(ctx->mrec)) {\n\t\tntfs_error(vol->sb, \"Failed to restore attribute search \"\n\t\t\t\t\"context.%s\", es);\n\t\tNVolSetErrors(vol);\n\t}\n\tif (ctx)\n\t\tntfs_attr_put_search_ctx(ctx);\n\tif (!IS_ERR(mrec))\n\t\tunmap_mft_record(mft_ni);\n\tup_write(&mft_ni->runlist.lock);\n\treturn ret;\n}",
          "includes": [
            "#include \"ntfs.h\"",
            "#include \"mft.h\"",
            "#include \"malloc.h\"",
            "#include \"lcnalloc.h\"",
            "#include \"dir.h\"",
            "#include \"debug.h\"",
            "#include \"bitmap.h\"",
            "#include \"aops.h\"",
            "#include \"attrib.h\"",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ntfs.h\"\n#include \"mft.h\"\n#include \"malloc.h\"\n#include \"lcnalloc.h\"\n#include \"dir.h\"\n#include \"debug.h\"\n#include \"bitmap.h\"\n#include \"aops.h\"\n#include \"attrib.h\"\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n\nstatic int ntfs_mft_data_extend_allocation_nolock(ntfs_volume *vol)\n{\n\tLCN lcn;\n\tVCN old_last_vcn;\n\ts64 min_nr, nr, ll;\n\tunsigned long flags;\n\tntfs_inode *mft_ni;\n\trunlist_element *rl, *rl2;\n\tntfs_attr_search_ctx *ctx = NULL;\n\tMFT_RECORD *mrec;\n\tATTR_RECORD *a = NULL;\n\tint ret, mp_size;\n\tu32 old_alen = 0;\n\tbool mp_rebuilt = false;\n\n\tntfs_debug(\"Extending mft data allocation.\");\n\tmft_ni = NTFS_I(vol->mft_ino);\n\t/*\n\t * Determine the preferred allocation location, i.e. the last lcn of\n\t * the mft data attribute.  The allocated size of the mft data\n\t * attribute cannot be zero so we are ok to do this.\n\t */\n\tdown_write(&mft_ni->runlist.lock);\n\tread_lock_irqsave(&mft_ni->size_lock, flags);\n\tll = mft_ni->allocated_size;\n\tread_unlock_irqrestore(&mft_ni->size_lock, flags);\n\trl = ntfs_attr_find_vcn_nolock(mft_ni,\n\t\t\t(ll - 1) >> vol->cluster_size_bits, NULL);\n\tif (unlikely(IS_ERR(rl) || !rl->length || rl->lcn < 0)) {\n\t\tup_write(&mft_ni->runlist.lock);\n\t\tntfs_error(vol->sb, \"Failed to determine last allocated \"\n\t\t\t\t\"cluster of mft data attribute.\");\n\t\tif (!IS_ERR(rl))\n\t\t\tret = -EIO;\n\t\telse\n\t\t\tret = PTR_ERR(rl);\n\t\treturn ret;\n\t}\n\tlcn = rl->lcn + rl->length;\n\tntfs_debug(\"Last lcn of mft data attribute is 0x%llx.\", (long long)lcn);\n\t/* Minimum allocation is one mft record worth of clusters. */\n\tmin_nr = vol->mft_record_size >> vol->cluster_size_bits;\n\tif (!min_nr)\n\t\tmin_nr = 1;\n\t/* Want to allocate 16 mft records worth of clusters. */\n\tnr = vol->mft_record_size << 4 >> vol->cluster_size_bits;\n\tif (!nr)\n\t\tnr = min_nr;\n\t/* Ensure we do not go above 2^32-1 mft records. */\n\tread_lock_irqsave(&mft_ni->size_lock, flags);\n\tll = mft_ni->allocated_size;\n\tread_unlock_irqrestore(&mft_ni->size_lock, flags);\n\tif (unlikely((ll + (nr << vol->cluster_size_bits)) >>\n\t\t\tvol->mft_record_size_bits >= (1ll << 32))) {\n\t\tnr = min_nr;\n\t\tif (unlikely((ll + (nr << vol->cluster_size_bits)) >>\n\t\t\t\tvol->mft_record_size_bits >= (1ll << 32))) {\n\t\t\tntfs_warning(vol->sb, \"Cannot allocate mft record \"\n\t\t\t\t\t\"because the maximum number of inodes \"\n\t\t\t\t\t\"(2^32) has already been reached.\");\n\t\t\tup_write(&mft_ni->runlist.lock);\n\t\t\treturn -ENOSPC;\n\t\t}\n\t}\n\tntfs_debug(\"Trying mft data allocation with %s cluster count %lli.\",\n\t\t\tnr > min_nr ? \"default\" : \"minimal\", (long long)nr);\n\told_last_vcn = rl[1].vcn;\n\tdo {\n\t\trl2 = ntfs_cluster_alloc(vol, old_last_vcn, nr, lcn, MFT_ZONE,\n\t\t\t\ttrue);\n\t\tif (likely(!IS_ERR(rl2)))\n\t\t\tbreak;\n\t\tif (PTR_ERR(rl2) != -ENOSPC || nr == min_nr) {\n\t\t\tntfs_error(vol->sb, \"Failed to allocate the minimal \"\n\t\t\t\t\t\"number of clusters (%lli) for the \"\n\t\t\t\t\t\"mft data attribute.\", (long long)nr);\n\t\t\tup_write(&mft_ni->runlist.lock);\n\t\t\treturn PTR_ERR(rl2);\n\t\t}\n\t\t/*\n\t\t * There is not enough space to do the allocation, but there\n\t\t * might be enough space to do a minimal allocation so try that\n\t\t * before failing.\n\t\t */\n\t\tnr = min_nr;\n\t\tntfs_debug(\"Retrying mft data allocation with minimal cluster \"\n\t\t\t\t\"count %lli.\", (long long)nr);\n\t} while (1);\n\trl = ntfs_runlists_merge(mft_ni->runlist.rl, rl2);\n\tif (IS_ERR(rl)) {\n\t\tup_write(&mft_ni->runlist.lock);\n\t\tntfs_error(vol->sb, \"Failed to merge runlists for mft data \"\n\t\t\t\t\"attribute.\");\n\t\tif (ntfs_cluster_free_from_rl(vol, rl2)) {\n\t\t\tntfs_error(vol->sb, \"Failed to deallocate clusters \"\n\t\t\t\t\t\"from the mft data attribute.%s\", es);\n\t\t\tNVolSetErrors(vol);\n\t\t}\n\t\tntfs_free(rl2);\n\t\treturn PTR_ERR(rl);\n\t}\n\tmft_ni->runlist.rl = rl;\n\tntfs_debug(\"Allocated %lli clusters.\", (long long)nr);\n\t/* Find the last run in the new runlist. */\n\tfor (; rl[1].length; rl++)\n\t\t;\n\t/* Update the attribute record as well. */\n\tmrec = map_mft_record(mft_ni);\n\tif (IS_ERR(mrec)) {\n\t\tntfs_error(vol->sb, \"Failed to map mft record.\");\n\t\tret = PTR_ERR(mrec);\n\t\tgoto undo_alloc;\n\t}\n\tctx = ntfs_attr_get_search_ctx(mft_ni, mrec);\n\tif (unlikely(!ctx)) {\n\t\tntfs_error(vol->sb, \"Failed to get search context.\");\n\t\tret = -ENOMEM;\n\t\tgoto undo_alloc;\n\t}\n\tret = ntfs_attr_lookup(mft_ni->type, mft_ni->name, mft_ni->name_len,\n\t\t\tCASE_SENSITIVE, rl[1].vcn, NULL, 0, ctx);\n\tif (unlikely(ret)) {\n\t\tntfs_error(vol->sb, \"Failed to find last attribute extent of \"\n\t\t\t\t\"mft data attribute.\");\n\t\tif (ret == -ENOENT)\n\t\t\tret = -EIO;\n\t\tgoto undo_alloc;\n\t}\n\ta = ctx->attr;\n\tll = sle64_to_cpu(a->data.non_resident.lowest_vcn);\n\t/* Search back for the previous last allocated cluster of mft bitmap. */\n\tfor (rl2 = rl; rl2 > mft_ni->runlist.rl; rl2--) {\n\t\tif (ll >= rl2->vcn)\n\t\t\tbreak;\n\t}\n\tBUG_ON(ll < rl2->vcn);\n\tBUG_ON(ll >= rl2->vcn + rl2->length);\n\t/* Get the size for the new mapping pairs array for this extent. */\n\tmp_size = ntfs_get_size_for_mapping_pairs(vol, rl2, ll, -1);\n\tif (unlikely(mp_size <= 0)) {\n\t\tntfs_error(vol->sb, \"Get size for mapping pairs failed for \"\n\t\t\t\t\"mft data attribute extent.\");\n\t\tret = mp_size;\n\t\tif (!ret)\n\t\t\tret = -EIO;\n\t\tgoto undo_alloc;\n\t}\n\t/* Expand the attribute record if necessary. */\n\told_alen = le32_to_cpu(a->length);\n\tret = ntfs_attr_record_resize(ctx->mrec, a, mp_size +\n\t\t\tle16_to_cpu(a->data.non_resident.mapping_pairs_offset));\n\tif (unlikely(ret)) {\n\t\tif (ret != -ENOSPC) {\n\t\t\tntfs_error(vol->sb, \"Failed to resize attribute \"\n\t\t\t\t\t\"record for mft data attribute.\");\n\t\t\tgoto undo_alloc;\n\t\t}\n\t\t// TODO: Deal with this by moving this extent to a new mft\n\t\t// record or by starting a new extent in a new mft record or by\n\t\t// moving other attributes out of this mft record.\n\t\t// Note: Use the special reserved mft records and ensure that\n\t\t// this extent is not required to find the mft record in\n\t\t// question.  If no free special records left we would need to\n\t\t// move an existing record away, insert ours in its place, and\n\t\t// then place the moved record into the newly allocated space\n\t\t// and we would then need to update all references to this mft\n\t\t// record appropriately.  This is rather complicated...\n\t\tntfs_error(vol->sb, \"Not enough space in this mft record to \"\n\t\t\t\t\"accommodate extended mft data attribute \"\n\t\t\t\t\"extent.  Cannot handle this yet.\");\n\t\tret = -EOPNOTSUPP;\n\t\tgoto undo_alloc;\n\t}\n\tmp_rebuilt = true;\n\t/* Generate the mapping pairs array directly into the attr record. */\n\tret = ntfs_mapping_pairs_build(vol, (u8*)a +\n\t\t\tle16_to_cpu(a->data.non_resident.mapping_pairs_offset),\n\t\t\tmp_size, rl2, ll, -1, NULL);\n\tif (unlikely(ret)) {\n\t\tntfs_error(vol->sb, \"Failed to build mapping pairs array of \"\n\t\t\t\t\"mft data attribute.\");\n\t\tgoto undo_alloc;\n\t}\n\t/* Update the highest_vcn. */\n\ta->data.non_resident.highest_vcn = cpu_to_sle64(rl[1].vcn - 1);\n\t/*\n\t * We now have extended the mft data allocated_size by nr clusters.\n\t * Reflect this in the ntfs_inode structure and the attribute record.\n\t * @rl is the last (non-terminator) runlist element of mft data\n\t * attribute.\n\t */\n\tif (a->data.non_resident.lowest_vcn) {\n\t\t/*\n\t\t * We are not in the first attribute extent, switch to it, but\n\t\t * first ensure the changes will make it to disk later.\n\t\t */\n\t\tflush_dcache_mft_record_page(ctx->ntfs_ino);\n\t\tmark_mft_record_dirty(ctx->ntfs_ino);\n\t\tntfs_attr_reinit_search_ctx(ctx);\n\t\tret = ntfs_attr_lookup(mft_ni->type, mft_ni->name,\n\t\t\t\tmft_ni->name_len, CASE_SENSITIVE, 0, NULL, 0,\n\t\t\t\tctx);\n\t\tif (unlikely(ret)) {\n\t\t\tntfs_error(vol->sb, \"Failed to find first attribute \"\n\t\t\t\t\t\"extent of mft data attribute.\");\n\t\t\tgoto restore_undo_alloc;\n\t\t}\n\t\ta = ctx->attr;\n\t}\n\twrite_lock_irqsave(&mft_ni->size_lock, flags);\n\tmft_ni->allocated_size += nr << vol->cluster_size_bits;\n\ta->data.non_resident.allocated_size =\n\t\t\tcpu_to_sle64(mft_ni->allocated_size);\n\twrite_unlock_irqrestore(&mft_ni->size_lock, flags);\n\t/* Ensure the changes make it to disk. */\n\tflush_dcache_mft_record_page(ctx->ntfs_ino);\n\tmark_mft_record_dirty(ctx->ntfs_ino);\n\tntfs_attr_put_search_ctx(ctx);\n\tunmap_mft_record(mft_ni);\n\tup_write(&mft_ni->runlist.lock);\n\tntfs_debug(\"Done.\");\n\treturn 0;\nrestore_undo_alloc:\n\tntfs_attr_reinit_search_ctx(ctx);\n\tif (ntfs_attr_lookup(mft_ni->type, mft_ni->name, mft_ni->name_len,\n\t\t\tCASE_SENSITIVE, rl[1].vcn, NULL, 0, ctx)) {\n\t\tntfs_error(vol->sb, \"Failed to find last attribute extent of \"\n\t\t\t\t\"mft data attribute.%s\", es);\n\t\twrite_lock_irqsave(&mft_ni->size_lock, flags);\n\t\tmft_ni->allocated_size += nr << vol->cluster_size_bits;\n\t\twrite_unlock_irqrestore(&mft_ni->size_lock, flags);\n\t\tntfs_attr_put_search_ctx(ctx);\n\t\tunmap_mft_record(mft_ni);\n\t\tup_write(&mft_ni->runlist.lock);\n\t\t/*\n\t\t * The only thing that is now wrong is ->allocated_size of the\n\t\t * base attribute extent which chkdsk should be able to fix.\n\t\t */\n\t\tNVolSetErrors(vol);\n\t\treturn ret;\n\t}\n\tctx->attr->data.non_resident.highest_vcn =\n\t\t\tcpu_to_sle64(old_last_vcn - 1);\nundo_alloc:\n\tif (ntfs_cluster_free(mft_ni, old_last_vcn, -1, ctx) < 0) {\n\t\tntfs_error(vol->sb, \"Failed to free clusters from mft data \"\n\t\t\t\t\"attribute.%s\", es);\n\t\tNVolSetErrors(vol);\n\t}\n\ta = ctx->attr;\n\tif (ntfs_rl_truncate_nolock(vol, &mft_ni->runlist, old_last_vcn)) {\n\t\tntfs_error(vol->sb, \"Failed to truncate mft data attribute \"\n\t\t\t\t\"runlist.%s\", es);\n\t\tNVolSetErrors(vol);\n\t}\n\tif (mp_rebuilt && !IS_ERR(ctx->mrec)) {\n\t\tif (ntfs_mapping_pairs_build(vol, (u8*)a + le16_to_cpu(\n\t\t\t\ta->data.non_resident.mapping_pairs_offset),\n\t\t\t\told_alen - le16_to_cpu(\n\t\t\t\ta->data.non_resident.mapping_pairs_offset),\n\t\t\t\trl2, ll, -1, NULL)) {\n\t\t\tntfs_error(vol->sb, \"Failed to restore mapping pairs \"\n\t\t\t\t\t\"array.%s\", es);\n\t\t\tNVolSetErrors(vol);\n\t\t}\n\t\tif (ntfs_attr_record_resize(ctx->mrec, a, old_alen)) {\n\t\t\tntfs_error(vol->sb, \"Failed to restore attribute \"\n\t\t\t\t\t\"record.%s\", es);\n\t\t\tNVolSetErrors(vol);\n\t\t}\n\t\tflush_dcache_mft_record_page(ctx->ntfs_ino);\n\t\tmark_mft_record_dirty(ctx->ntfs_ino);\n\t} else if (IS_ERR(ctx->mrec)) {\n\t\tntfs_error(vol->sb, \"Failed to restore attribute search \"\n\t\t\t\t\"context.%s\", es);\n\t\tNVolSetErrors(vol);\n\t}\n\tif (ctx)\n\t\tntfs_attr_put_search_ctx(ctx);\n\tif (!IS_ERR(mrec))\n\t\tunmap_mft_record(mft_ni);\n\tup_write(&mft_ni->runlist.lock);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "read_unlock_irqrestore",
          "args": [
            "&mft_ni->size_lock",
            "flags"
          ],
          "line": 2411
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "i_size_read",
          "args": [
            "vol->mft_ino"
          ],
          "line": 2408
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "read_lock_irqsave",
          "args": [
            "&mft_ni->size_lock",
            "flags"
          ],
          "line": 2403
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntfs_debug",
          "args": [
            "\"Initializing allocated mft record.\""
          ],
          "line": 2396
        },
        "resolved": true,
        "details": {
          "function_name": "ntfs_debug_dump_runlist",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/debug.c",
          "lines": "134-171",
          "snippet": "void ntfs_debug_dump_runlist(const runlist_element *rl)\n{\n\tint i;\n\tconst char *lcn_str[5] = { \"LCN_HOLE         \", \"LCN_RL_NOT_MAPPED\",\n\t\t\t\t   \"LCN_ENOENT       \", \"LCN_unknown      \" };\n\n\tif (!debug_msgs)\n\t\treturn;\n\tpr_debug(\"Dumping runlist (values in hex):\\n\");\n\tif (!rl) {\n\t\tpr_debug(\"Run list not present.\\n\");\n\t\treturn;\n\t}\n\tpr_debug(\"VCN              LCN               Run length\\n\");\n\tfor (i = 0; ; i++) {\n\t\tLCN lcn = (rl + i)->lcn;\n\n\t\tif (lcn < (LCN)0) {\n\t\t\tint index = -lcn - 1;\n\n\t\t\tif (index > -LCN_ENOENT - 1)\n\t\t\t\tindex = 3;\n\t\t\tpr_debug(\"%-16Lx %s %-16Lx%s\\n\",\n\t\t\t\t\t(long long)(rl + i)->vcn, lcn_str[index],\n\t\t\t\t\t(long long)(rl + i)->length,\n\t\t\t\t\t(rl + i)->length ? \"\" :\n\t\t\t\t\t\t\" (runlist end)\");\n\t\t} else\n\t\t\tpr_debug(\"%-16Lx %-16Lx  %-16Lx%s\\n\",\n\t\t\t\t\t(long long)(rl + i)->vcn,\n\t\t\t\t\t(long long)(rl + i)->lcn,\n\t\t\t\t\t(long long)(rl + i)->length,\n\t\t\t\t\t(rl + i)->length ? \"\" :\n\t\t\t\t\t\t\" (runlist end)\");\n\t\tif (!(rl + i)->length)\n\t\t\tbreak;\n\t}\n}",
          "includes": [
            "#include \"debug.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"debug.h\"\n\nvoid ntfs_debug_dump_runlist(const runlist_element *rl)\n{\n\tint i;\n\tconst char *lcn_str[5] = { \"LCN_HOLE         \", \"LCN_RL_NOT_MAPPED\",\n\t\t\t\t   \"LCN_ENOENT       \", \"LCN_unknown      \" };\n\n\tif (!debug_msgs)\n\t\treturn;\n\tpr_debug(\"Dumping runlist (values in hex):\\n\");\n\tif (!rl) {\n\t\tpr_debug(\"Run list not present.\\n\");\n\t\treturn;\n\t}\n\tpr_debug(\"VCN              LCN               Run length\\n\");\n\tfor (i = 0; ; i++) {\n\t\tLCN lcn = (rl + i)->lcn;\n\n\t\tif (lcn < (LCN)0) {\n\t\t\tint index = -lcn - 1;\n\n\t\t\tif (index > -LCN_ENOENT - 1)\n\t\t\t\tindex = 3;\n\t\t\tpr_debug(\"%-16Lx %s %-16Lx%s\\n\",\n\t\t\t\t\t(long long)(rl + i)->vcn, lcn_str[index],\n\t\t\t\t\t(long long)(rl + i)->length,\n\t\t\t\t\t(rl + i)->length ? \"\" :\n\t\t\t\t\t\t\" (runlist end)\");\n\t\t} else\n\t\t\tpr_debug(\"%-16Lx %-16Lx  %-16Lx%s\\n\",\n\t\t\t\t\t(long long)(rl + i)->vcn,\n\t\t\t\t\t(long long)(rl + i)->lcn,\n\t\t\t\t\t(long long)(rl + i)->length,\n\t\t\t\t\t(rl + i)->length ? \"\" :\n\t\t\t\t\t\t\" (runlist end)\");\n\t\tif (!(rl + i)->length)\n\t\t\tbreak;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "read_unlock_irqrestore",
          "args": [
            "&mft_ni->size_lock",
            "flags"
          ],
          "line": 2391
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "read_lock_irqsave",
          "args": [
            "&mft_ni->size_lock",
            "flags"
          ],
          "line": 2389
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntfs_debug",
          "args": [
            "\"Set bit 0x%llx in mft bitmap.\"",
            "(long long)bit"
          ],
          "line": 2378
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "up_write",
          "args": [
            "&vol->mftbmp_lock"
          ],
          "line": 2375
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntfs_error",
          "args": [
            "vol->sb",
            "\"Failed to allocate bit in mft bitmap.\""
          ],
          "line": 2374
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "err"
          ],
          "line": 2373
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntfs_bitmap_set_bit",
          "args": [
            "vol->mftbmp_ino",
            "bit"
          ],
          "line": 2372
        },
        "resolved": true,
        "details": {
          "function_name": "ntfs_bitmap_set_bit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/bitmap.h",
          "lines": "97-100",
          "snippet": "static inline int ntfs_bitmap_set_bit(struct inode *vi, const s64 bit)\n{\n\treturn ntfs_bitmap_set_run(vi, bit, 1);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <linux/fs.h>\n\nstatic inline int ntfs_bitmap_set_bit(struct inode *vi, const s64 bit)\n{\n\treturn ntfs_bitmap_set_run(vi, bit, 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ntfs_debug",
          "args": [
            "\"Found free record (#3), bit 0x%llx.\"",
            "(long long)bit"
          ],
          "line": 2368
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "read_unlock_irqrestore",
          "args": [
            "&mftbmp_ni->size_lock",
            "flags"
          ],
          "line": 2366
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "i_size_read",
          "args": [
            "vol->mftbmp_ino"
          ],
          "line": 2364
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "read_lock_irqsave",
          "args": [
            "&mftbmp_ni->size_lock",
            "flags"
          ],
          "line": 2359
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "up_write",
          "args": [
            "&vol->mftbmp_lock"
          ],
          "line": 2355
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "err"
          ],
          "line": 2354
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntfs_mft_bitmap_extend_initialized_nolock",
          "args": [
            "vol"
          ],
          "line": 2353
        },
        "resolved": true,
        "details": {
          "function_name": "ntfs_mft_bitmap_extend_initialized_nolock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/mft.c",
          "lines": "1577-1693",
          "snippet": "static int ntfs_mft_bitmap_extend_initialized_nolock(ntfs_volume *vol)\n{\n\ts64 old_data_size, old_initialized_size;\n\tunsigned long flags;\n\tstruct inode *mftbmp_vi;\n\tntfs_inode *mft_ni, *mftbmp_ni;\n\tntfs_attr_search_ctx *ctx;\n\tMFT_RECORD *mrec;\n\tATTR_RECORD *a;\n\tint ret;\n\n\tntfs_debug(\"Extending mft bitmap initiailized (and data) size.\");\n\tmft_ni = NTFS_I(vol->mft_ino);\n\tmftbmp_vi = vol->mftbmp_ino;\n\tmftbmp_ni = NTFS_I(mftbmp_vi);\n\t/* Get the attribute record. */\n\tmrec = map_mft_record(mft_ni);\n\tif (IS_ERR(mrec)) {\n\t\tntfs_error(vol->sb, \"Failed to map mft record.\");\n\t\treturn PTR_ERR(mrec);\n\t}\n\tctx = ntfs_attr_get_search_ctx(mft_ni, mrec);\n\tif (unlikely(!ctx)) {\n\t\tntfs_error(vol->sb, \"Failed to get search context.\");\n\t\tret = -ENOMEM;\n\t\tgoto unm_err_out;\n\t}\n\tret = ntfs_attr_lookup(mftbmp_ni->type, mftbmp_ni->name,\n\t\t\tmftbmp_ni->name_len, CASE_SENSITIVE, 0, NULL, 0, ctx);\n\tif (unlikely(ret)) {\n\t\tntfs_error(vol->sb, \"Failed to find first attribute extent of \"\n\t\t\t\t\"mft bitmap attribute.\");\n\t\tif (ret == -ENOENT)\n\t\t\tret = -EIO;\n\t\tgoto put_err_out;\n\t}\n\ta = ctx->attr;\n\twrite_lock_irqsave(&mftbmp_ni->size_lock, flags);\n\told_data_size = i_size_read(mftbmp_vi);\n\told_initialized_size = mftbmp_ni->initialized_size;\n\t/*\n\t * We can simply update the initialized_size before filling the space\n\t * with zeroes because the caller is holding the mft bitmap lock for\n\t * writing which ensures that no one else is trying to access the data.\n\t */\n\tmftbmp_ni->initialized_size += 8;\n\ta->data.non_resident.initialized_size =\n\t\t\tcpu_to_sle64(mftbmp_ni->initialized_size);\n\tif (mftbmp_ni->initialized_size > old_data_size) {\n\t\ti_size_write(mftbmp_vi, mftbmp_ni->initialized_size);\n\t\ta->data.non_resident.data_size =\n\t\t\t\tcpu_to_sle64(mftbmp_ni->initialized_size);\n\t}\n\twrite_unlock_irqrestore(&mftbmp_ni->size_lock, flags);\n\t/* Ensure the changes make it to disk. */\n\tflush_dcache_mft_record_page(ctx->ntfs_ino);\n\tmark_mft_record_dirty(ctx->ntfs_ino);\n\tntfs_attr_put_search_ctx(ctx);\n\tunmap_mft_record(mft_ni);\n\t/* Initialize the mft bitmap attribute value with zeroes. */\n\tret = ntfs_attr_set(mftbmp_ni, old_initialized_size, 8, 0);\n\tif (likely(!ret)) {\n\t\tntfs_debug(\"Done.  (Wrote eight initialized bytes to mft \"\n\t\t\t\t\"bitmap.\");\n\t\treturn 0;\n\t}\n\tntfs_error(vol->sb, \"Failed to write to mft bitmap.\");\n\t/* Try to recover from the error. */\n\tmrec = map_mft_record(mft_ni);\n\tif (IS_ERR(mrec)) {\n\t\tntfs_error(vol->sb, \"Failed to map mft record.%s\", es);\n\t\tNVolSetErrors(vol);\n\t\treturn ret;\n\t}\n\tctx = ntfs_attr_get_search_ctx(mft_ni, mrec);\n\tif (unlikely(!ctx)) {\n\t\tntfs_error(vol->sb, \"Failed to get search context.%s\", es);\n\t\tNVolSetErrors(vol);\n\t\tgoto unm_err_out;\n\t}\n\tif (ntfs_attr_lookup(mftbmp_ni->type, mftbmp_ni->name,\n\t\t\tmftbmp_ni->name_len, CASE_SENSITIVE, 0, NULL, 0, ctx)) {\n\t\tntfs_error(vol->sb, \"Failed to find first attribute extent of \"\n\t\t\t\t\"mft bitmap attribute.%s\", es);\n\t\tNVolSetErrors(vol);\nput_err_out:\n\t\tntfs_attr_put_search_ctx(ctx);\nunm_err_out:\n\t\tunmap_mft_record(mft_ni);\n\t\tgoto err_out;\n\t}\n\ta = ctx->attr;\n\twrite_lock_irqsave(&mftbmp_ni->size_lock, flags);\n\tmftbmp_ni->initialized_size = old_initialized_size;\n\ta->data.non_resident.initialized_size =\n\t\t\tcpu_to_sle64(old_initialized_size);\n\tif (i_size_read(mftbmp_vi) != old_data_size) {\n\t\ti_size_write(mftbmp_vi, old_data_size);\n\t\ta->data.non_resident.data_size = cpu_to_sle64(old_data_size);\n\t}\n\twrite_unlock_irqrestore(&mftbmp_ni->size_lock, flags);\n\tflush_dcache_mft_record_page(ctx->ntfs_ino);\n\tmark_mft_record_dirty(ctx->ntfs_ino);\n\tntfs_attr_put_search_ctx(ctx);\n\tunmap_mft_record(mft_ni);\n#ifdef DEBUG\n\tread_lock_irqsave(&mftbmp_ni->size_lock, flags);\n\tntfs_debug(\"Restored status of mftbmp: allocated_size 0x%llx, \"\n\t\t\t\"data_size 0x%llx, initialized_size 0x%llx.\",\n\t\t\t(long long)mftbmp_ni->allocated_size,\n\t\t\t(long long)i_size_read(mftbmp_vi),\n\t\t\t(long long)mftbmp_ni->initialized_size);\n\tread_unlock_irqrestore(&mftbmp_ni->size_lock, flags);\n#endif /* DEBUG */\nerr_out:\n\treturn ret;\n}",
          "includes": [
            "#include \"ntfs.h\"",
            "#include \"mft.h\"",
            "#include \"malloc.h\"",
            "#include \"lcnalloc.h\"",
            "#include \"dir.h\"",
            "#include \"debug.h\"",
            "#include \"bitmap.h\"",
            "#include \"aops.h\"",
            "#include \"attrib.h\"",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ntfs.h\"\n#include \"mft.h\"\n#include \"malloc.h\"\n#include \"lcnalloc.h\"\n#include \"dir.h\"\n#include \"debug.h\"\n#include \"bitmap.h\"\n#include \"aops.h\"\n#include \"attrib.h\"\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n\nstatic int ntfs_mft_bitmap_extend_initialized_nolock(ntfs_volume *vol)\n{\n\ts64 old_data_size, old_initialized_size;\n\tunsigned long flags;\n\tstruct inode *mftbmp_vi;\n\tntfs_inode *mft_ni, *mftbmp_ni;\n\tntfs_attr_search_ctx *ctx;\n\tMFT_RECORD *mrec;\n\tATTR_RECORD *a;\n\tint ret;\n\n\tntfs_debug(\"Extending mft bitmap initiailized (and data) size.\");\n\tmft_ni = NTFS_I(vol->mft_ino);\n\tmftbmp_vi = vol->mftbmp_ino;\n\tmftbmp_ni = NTFS_I(mftbmp_vi);\n\t/* Get the attribute record. */\n\tmrec = map_mft_record(mft_ni);\n\tif (IS_ERR(mrec)) {\n\t\tntfs_error(vol->sb, \"Failed to map mft record.\");\n\t\treturn PTR_ERR(mrec);\n\t}\n\tctx = ntfs_attr_get_search_ctx(mft_ni, mrec);\n\tif (unlikely(!ctx)) {\n\t\tntfs_error(vol->sb, \"Failed to get search context.\");\n\t\tret = -ENOMEM;\n\t\tgoto unm_err_out;\n\t}\n\tret = ntfs_attr_lookup(mftbmp_ni->type, mftbmp_ni->name,\n\t\t\tmftbmp_ni->name_len, CASE_SENSITIVE, 0, NULL, 0, ctx);\n\tif (unlikely(ret)) {\n\t\tntfs_error(vol->sb, \"Failed to find first attribute extent of \"\n\t\t\t\t\"mft bitmap attribute.\");\n\t\tif (ret == -ENOENT)\n\t\t\tret = -EIO;\n\t\tgoto put_err_out;\n\t}\n\ta = ctx->attr;\n\twrite_lock_irqsave(&mftbmp_ni->size_lock, flags);\n\told_data_size = i_size_read(mftbmp_vi);\n\told_initialized_size = mftbmp_ni->initialized_size;\n\t/*\n\t * We can simply update the initialized_size before filling the space\n\t * with zeroes because the caller is holding the mft bitmap lock for\n\t * writing which ensures that no one else is trying to access the data.\n\t */\n\tmftbmp_ni->initialized_size += 8;\n\ta->data.non_resident.initialized_size =\n\t\t\tcpu_to_sle64(mftbmp_ni->initialized_size);\n\tif (mftbmp_ni->initialized_size > old_data_size) {\n\t\ti_size_write(mftbmp_vi, mftbmp_ni->initialized_size);\n\t\ta->data.non_resident.data_size =\n\t\t\t\tcpu_to_sle64(mftbmp_ni->initialized_size);\n\t}\n\twrite_unlock_irqrestore(&mftbmp_ni->size_lock, flags);\n\t/* Ensure the changes make it to disk. */\n\tflush_dcache_mft_record_page(ctx->ntfs_ino);\n\tmark_mft_record_dirty(ctx->ntfs_ino);\n\tntfs_attr_put_search_ctx(ctx);\n\tunmap_mft_record(mft_ni);\n\t/* Initialize the mft bitmap attribute value with zeroes. */\n\tret = ntfs_attr_set(mftbmp_ni, old_initialized_size, 8, 0);\n\tif (likely(!ret)) {\n\t\tntfs_debug(\"Done.  (Wrote eight initialized bytes to mft \"\n\t\t\t\t\"bitmap.\");\n\t\treturn 0;\n\t}\n\tntfs_error(vol->sb, \"Failed to write to mft bitmap.\");\n\t/* Try to recover from the error. */\n\tmrec = map_mft_record(mft_ni);\n\tif (IS_ERR(mrec)) {\n\t\tntfs_error(vol->sb, \"Failed to map mft record.%s\", es);\n\t\tNVolSetErrors(vol);\n\t\treturn ret;\n\t}\n\tctx = ntfs_attr_get_search_ctx(mft_ni, mrec);\n\tif (unlikely(!ctx)) {\n\t\tntfs_error(vol->sb, \"Failed to get search context.%s\", es);\n\t\tNVolSetErrors(vol);\n\t\tgoto unm_err_out;\n\t}\n\tif (ntfs_attr_lookup(mftbmp_ni->type, mftbmp_ni->name,\n\t\t\tmftbmp_ni->name_len, CASE_SENSITIVE, 0, NULL, 0, ctx)) {\n\t\tntfs_error(vol->sb, \"Failed to find first attribute extent of \"\n\t\t\t\t\"mft bitmap attribute.%s\", es);\n\t\tNVolSetErrors(vol);\nput_err_out:\n\t\tntfs_attr_put_search_ctx(ctx);\nunm_err_out:\n\t\tunmap_mft_record(mft_ni);\n\t\tgoto err_out;\n\t}\n\ta = ctx->attr;\n\twrite_lock_irqsave(&mftbmp_ni->size_lock, flags);\n\tmftbmp_ni->initialized_size = old_initialized_size;\n\ta->data.non_resident.initialized_size =\n\t\t\tcpu_to_sle64(old_initialized_size);\n\tif (i_size_read(mftbmp_vi) != old_data_size) {\n\t\ti_size_write(mftbmp_vi, old_data_size);\n\t\ta->data.non_resident.data_size = cpu_to_sle64(old_data_size);\n\t}\n\twrite_unlock_irqrestore(&mftbmp_ni->size_lock, flags);\n\tflush_dcache_mft_record_page(ctx->ntfs_ino);\n\tmark_mft_record_dirty(ctx->ntfs_ino);\n\tntfs_attr_put_search_ctx(ctx);\n\tunmap_mft_record(mft_ni);\n#ifdef DEBUG\n\tread_lock_irqsave(&mftbmp_ni->size_lock, flags);\n\tntfs_debug(\"Restored status of mftbmp: allocated_size 0x%llx, \"\n\t\t\t\"data_size 0x%llx, initialized_size 0x%llx.\",\n\t\t\t(long long)mftbmp_ni->allocated_size,\n\t\t\t(long long)i_size_read(mftbmp_vi),\n\t\t\t(long long)mftbmp_ni->initialized_size);\n\tread_unlock_irqrestore(&mftbmp_ni->size_lock, flags);\n#endif /* DEBUG */\nerr_out:\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "read_unlock_irqrestore",
          "args": [
            "&mftbmp_ni->size_lock",
            "flags"
          ],
          "line": 2345
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "i_size_read",
          "args": [
            "vol->mftbmp_ino"
          ],
          "line": 2343
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "read_lock_irqsave",
          "args": [
            "&mftbmp_ni->size_lock",
            "flags"
          ],
          "line": 2338
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "up_write",
          "args": [
            "&vol->mftbmp_lock"
          ],
          "line": 2334
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "err"
          ],
          "line": 2333
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntfs_mft_bitmap_extend_allocation_nolock",
          "args": [
            "vol"
          ],
          "line": 2332
        },
        "resolved": true,
        "details": {
          "function_name": "ntfs_mft_bitmap_extend_allocation_nolock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/mft.c",
          "lines": "1278-1561",
          "snippet": "static int ntfs_mft_bitmap_extend_allocation_nolock(ntfs_volume *vol)\n{\n\tLCN lcn;\n\ts64 ll;\n\tunsigned long flags;\n\tstruct page *page;\n\tntfs_inode *mft_ni, *mftbmp_ni;\n\trunlist_element *rl, *rl2 = NULL;\n\tntfs_attr_search_ctx *ctx = NULL;\n\tMFT_RECORD *mrec;\n\tATTR_RECORD *a = NULL;\n\tint ret, mp_size;\n\tu32 old_alen = 0;\n\tu8 *b, tb;\n\tstruct {\n\t\tu8 added_cluster:1;\n\t\tu8 added_run:1;\n\t\tu8 mp_rebuilt:1;\n\t} status = { 0, 0, 0 };\n\n\tntfs_debug(\"Extending mft bitmap allocation.\");\n\tmft_ni = NTFS_I(vol->mft_ino);\n\tmftbmp_ni = NTFS_I(vol->mftbmp_ino);\n\t/*\n\t * Determine the last lcn of the mft bitmap.  The allocated size of the\n\t * mft bitmap cannot be zero so we are ok to do this.\n\t */\n\tdown_write(&mftbmp_ni->runlist.lock);\n\tread_lock_irqsave(&mftbmp_ni->size_lock, flags);\n\tll = mftbmp_ni->allocated_size;\n\tread_unlock_irqrestore(&mftbmp_ni->size_lock, flags);\n\trl = ntfs_attr_find_vcn_nolock(mftbmp_ni,\n\t\t\t(ll - 1) >> vol->cluster_size_bits, NULL);\n\tif (unlikely(IS_ERR(rl) || !rl->length || rl->lcn < 0)) {\n\t\tup_write(&mftbmp_ni->runlist.lock);\n\t\tntfs_error(vol->sb, \"Failed to determine last allocated \"\n\t\t\t\t\"cluster of mft bitmap attribute.\");\n\t\tif (!IS_ERR(rl))\n\t\t\tret = -EIO;\n\t\telse\n\t\t\tret = PTR_ERR(rl);\n\t\treturn ret;\n\t}\n\tlcn = rl->lcn + rl->length;\n\tntfs_debug(\"Last lcn of mft bitmap attribute is 0x%llx.\",\n\t\t\t(long long)lcn);\n\t/*\n\t * Attempt to get the cluster following the last allocated cluster by\n\t * hand as it may be in the MFT zone so the allocator would not give it\n\t * to us.\n\t */\n\tll = lcn >> 3;\n\tpage = ntfs_map_page(vol->lcnbmp_ino->i_mapping,\n\t\t\tll >> PAGE_CACHE_SHIFT);\n\tif (IS_ERR(page)) {\n\t\tup_write(&mftbmp_ni->runlist.lock);\n\t\tntfs_error(vol->sb, \"Failed to read from lcn bitmap.\");\n\t\treturn PTR_ERR(page);\n\t}\n\tb = (u8*)page_address(page) + (ll & ~PAGE_CACHE_MASK);\n\ttb = 1 << (lcn & 7ull);\n\tdown_write(&vol->lcnbmp_lock);\n\tif (*b != 0xff && !(*b & tb)) {\n\t\t/* Next cluster is free, allocate it. */\n\t\t*b |= tb;\n\t\tflush_dcache_page(page);\n\t\tset_page_dirty(page);\n\t\tup_write(&vol->lcnbmp_lock);\n\t\tntfs_unmap_page(page);\n\t\t/* Update the mft bitmap runlist. */\n\t\trl->length++;\n\t\trl[1].vcn++;\n\t\tstatus.added_cluster = 1;\n\t\tntfs_debug(\"Appending one cluster to mft bitmap.\");\n\t} else {\n\t\tup_write(&vol->lcnbmp_lock);\n\t\tntfs_unmap_page(page);\n\t\t/* Allocate a cluster from the DATA_ZONE. */\n\t\trl2 = ntfs_cluster_alloc(vol, rl[1].vcn, 1, lcn, DATA_ZONE,\n\t\t\t\ttrue);\n\t\tif (IS_ERR(rl2)) {\n\t\t\tup_write(&mftbmp_ni->runlist.lock);\n\t\t\tntfs_error(vol->sb, \"Failed to allocate a cluster for \"\n\t\t\t\t\t\"the mft bitmap.\");\n\t\t\treturn PTR_ERR(rl2);\n\t\t}\n\t\trl = ntfs_runlists_merge(mftbmp_ni->runlist.rl, rl2);\n\t\tif (IS_ERR(rl)) {\n\t\t\tup_write(&mftbmp_ni->runlist.lock);\n\t\t\tntfs_error(vol->sb, \"Failed to merge runlists for mft \"\n\t\t\t\t\t\"bitmap.\");\n\t\t\tif (ntfs_cluster_free_from_rl(vol, rl2)) {\n\t\t\t\tntfs_error(vol->sb, \"Failed to deallocate \"\n\t\t\t\t\t\t\"allocated cluster.%s\", es);\n\t\t\t\tNVolSetErrors(vol);\n\t\t\t}\n\t\t\tntfs_free(rl2);\n\t\t\treturn PTR_ERR(rl);\n\t\t}\n\t\tmftbmp_ni->runlist.rl = rl;\n\t\tstatus.added_run = 1;\n\t\tntfs_debug(\"Adding one run to mft bitmap.\");\n\t\t/* Find the last run in the new runlist. */\n\t\tfor (; rl[1].length; rl++)\n\t\t\t;\n\t}\n\t/*\n\t * Update the attribute record as well.  Note: @rl is the last\n\t * (non-terminator) runlist element of mft bitmap.\n\t */\n\tmrec = map_mft_record(mft_ni);\n\tif (IS_ERR(mrec)) {\n\t\tntfs_error(vol->sb, \"Failed to map mft record.\");\n\t\tret = PTR_ERR(mrec);\n\t\tgoto undo_alloc;\n\t}\n\tctx = ntfs_attr_get_search_ctx(mft_ni, mrec);\n\tif (unlikely(!ctx)) {\n\t\tntfs_error(vol->sb, \"Failed to get search context.\");\n\t\tret = -ENOMEM;\n\t\tgoto undo_alloc;\n\t}\n\tret = ntfs_attr_lookup(mftbmp_ni->type, mftbmp_ni->name,\n\t\t\tmftbmp_ni->name_len, CASE_SENSITIVE, rl[1].vcn, NULL,\n\t\t\t0, ctx);\n\tif (unlikely(ret)) {\n\t\tntfs_error(vol->sb, \"Failed to find last attribute extent of \"\n\t\t\t\t\"mft bitmap attribute.\");\n\t\tif (ret == -ENOENT)\n\t\t\tret = -EIO;\n\t\tgoto undo_alloc;\n\t}\n\ta = ctx->attr;\n\tll = sle64_to_cpu(a->data.non_resident.lowest_vcn);\n\t/* Search back for the previous last allocated cluster of mft bitmap. */\n\tfor (rl2 = rl; rl2 > mftbmp_ni->runlist.rl; rl2--) {\n\t\tif (ll >= rl2->vcn)\n\t\t\tbreak;\n\t}\n\tBUG_ON(ll < rl2->vcn);\n\tBUG_ON(ll >= rl2->vcn + rl2->length);\n\t/* Get the size for the new mapping pairs array for this extent. */\n\tmp_size = ntfs_get_size_for_mapping_pairs(vol, rl2, ll, -1);\n\tif (unlikely(mp_size <= 0)) {\n\t\tntfs_error(vol->sb, \"Get size for mapping pairs failed for \"\n\t\t\t\t\"mft bitmap attribute extent.\");\n\t\tret = mp_size;\n\t\tif (!ret)\n\t\t\tret = -EIO;\n\t\tgoto undo_alloc;\n\t}\n\t/* Expand the attribute record if necessary. */\n\told_alen = le32_to_cpu(a->length);\n\tret = ntfs_attr_record_resize(ctx->mrec, a, mp_size +\n\t\t\tle16_to_cpu(a->data.non_resident.mapping_pairs_offset));\n\tif (unlikely(ret)) {\n\t\tif (ret != -ENOSPC) {\n\t\t\tntfs_error(vol->sb, \"Failed to resize attribute \"\n\t\t\t\t\t\"record for mft bitmap attribute.\");\n\t\t\tgoto undo_alloc;\n\t\t}\n\t\t// TODO: Deal with this by moving this extent to a new mft\n\t\t// record or by starting a new extent in a new mft record or by\n\t\t// moving other attributes out of this mft record.\n\t\t// Note: It will need to be a special mft record and if none of\n\t\t// those are available it gets rather complicated...\n\t\tntfs_error(vol->sb, \"Not enough space in this mft record to \"\n\t\t\t\t\"accommodate extended mft bitmap attribute \"\n\t\t\t\t\"extent.  Cannot handle this yet.\");\n\t\tret = -EOPNOTSUPP;\n\t\tgoto undo_alloc;\n\t}\n\tstatus.mp_rebuilt = 1;\n\t/* Generate the mapping pairs array directly into the attr record. */\n\tret = ntfs_mapping_pairs_build(vol, (u8*)a +\n\t\t\tle16_to_cpu(a->data.non_resident.mapping_pairs_offset),\n\t\t\tmp_size, rl2, ll, -1, NULL);\n\tif (unlikely(ret)) {\n\t\tntfs_error(vol->sb, \"Failed to build mapping pairs array for \"\n\t\t\t\t\"mft bitmap attribute.\");\n\t\tgoto undo_alloc;\n\t}\n\t/* Update the highest_vcn. */\n\ta->data.non_resident.highest_vcn = cpu_to_sle64(rl[1].vcn - 1);\n\t/*\n\t * We now have extended the mft bitmap allocated_size by one cluster.\n\t * Reflect this in the ntfs_inode structure and the attribute record.\n\t */\n\tif (a->data.non_resident.lowest_vcn) {\n\t\t/*\n\t\t * We are not in the first attribute extent, switch to it, but\n\t\t * first ensure the changes will make it to disk later.\n\t\t */\n\t\tflush_dcache_mft_record_page(ctx->ntfs_ino);\n\t\tmark_mft_record_dirty(ctx->ntfs_ino);\n\t\tntfs_attr_reinit_search_ctx(ctx);\n\t\tret = ntfs_attr_lookup(mftbmp_ni->type, mftbmp_ni->name,\n\t\t\t\tmftbmp_ni->name_len, CASE_SENSITIVE, 0, NULL,\n\t\t\t\t0, ctx);\n\t\tif (unlikely(ret)) {\n\t\t\tntfs_error(vol->sb, \"Failed to find first attribute \"\n\t\t\t\t\t\"extent of mft bitmap attribute.\");\n\t\t\tgoto restore_undo_alloc;\n\t\t}\n\t\ta = ctx->attr;\n\t}\n\twrite_lock_irqsave(&mftbmp_ni->size_lock, flags);\n\tmftbmp_ni->allocated_size += vol->cluster_size;\n\ta->data.non_resident.allocated_size =\n\t\t\tcpu_to_sle64(mftbmp_ni->allocated_size);\n\twrite_unlock_irqrestore(&mftbmp_ni->size_lock, flags);\n\t/* Ensure the changes make it to disk. */\n\tflush_dcache_mft_record_page(ctx->ntfs_ino);\n\tmark_mft_record_dirty(ctx->ntfs_ino);\n\tntfs_attr_put_search_ctx(ctx);\n\tunmap_mft_record(mft_ni);\n\tup_write(&mftbmp_ni->runlist.lock);\n\tntfs_debug(\"Done.\");\n\treturn 0;\nrestore_undo_alloc:\n\tntfs_attr_reinit_search_ctx(ctx);\n\tif (ntfs_attr_lookup(mftbmp_ni->type, mftbmp_ni->name,\n\t\t\tmftbmp_ni->name_len, CASE_SENSITIVE, rl[1].vcn, NULL,\n\t\t\t0, ctx)) {\n\t\tntfs_error(vol->sb, \"Failed to find last attribute extent of \"\n\t\t\t\t\"mft bitmap attribute.%s\", es);\n\t\twrite_lock_irqsave(&mftbmp_ni->size_lock, flags);\n\t\tmftbmp_ni->allocated_size += vol->cluster_size;\n\t\twrite_unlock_irqrestore(&mftbmp_ni->size_lock, flags);\n\t\tntfs_attr_put_search_ctx(ctx);\n\t\tunmap_mft_record(mft_ni);\n\t\tup_write(&mftbmp_ni->runlist.lock);\n\t\t/*\n\t\t * The only thing that is now wrong is ->allocated_size of the\n\t\t * base attribute extent which chkdsk should be able to fix.\n\t\t */\n\t\tNVolSetErrors(vol);\n\t\treturn ret;\n\t}\n\ta = ctx->attr;\n\ta->data.non_resident.highest_vcn = cpu_to_sle64(rl[1].vcn - 2);\nundo_alloc:\n\tif (status.added_cluster) {\n\t\t/* Truncate the last run in the runlist by one cluster. */\n\t\trl->length--;\n\t\trl[1].vcn--;\n\t} else if (status.added_run) {\n\t\tlcn = rl->lcn;\n\t\t/* Remove the last run from the runlist. */\n\t\trl->lcn = rl[1].lcn;\n\t\trl->length = 0;\n\t}\n\t/* Deallocate the cluster. */\n\tdown_write(&vol->lcnbmp_lock);\n\tif (ntfs_bitmap_clear_bit(vol->lcnbmp_ino, lcn)) {\n\t\tntfs_error(vol->sb, \"Failed to free allocated cluster.%s\", es);\n\t\tNVolSetErrors(vol);\n\t}\n\tup_write(&vol->lcnbmp_lock);\n\tif (status.mp_rebuilt) {\n\t\tif (ntfs_mapping_pairs_build(vol, (u8*)a + le16_to_cpu(\n\t\t\t\ta->data.non_resident.mapping_pairs_offset),\n\t\t\t\told_alen - le16_to_cpu(\n\t\t\t\ta->data.non_resident.mapping_pairs_offset),\n\t\t\t\trl2, ll, -1, NULL)) {\n\t\t\tntfs_error(vol->sb, \"Failed to restore mapping pairs \"\n\t\t\t\t\t\"array.%s\", es);\n\t\t\tNVolSetErrors(vol);\n\t\t}\n\t\tif (ntfs_attr_record_resize(ctx->mrec, a, old_alen)) {\n\t\t\tntfs_error(vol->sb, \"Failed to restore attribute \"\n\t\t\t\t\t\"record.%s\", es);\n\t\t\tNVolSetErrors(vol);\n\t\t}\n\t\tflush_dcache_mft_record_page(ctx->ntfs_ino);\n\t\tmark_mft_record_dirty(ctx->ntfs_ino);\n\t}\n\tif (ctx)\n\t\tntfs_attr_put_search_ctx(ctx);\n\tif (!IS_ERR(mrec))\n\t\tunmap_mft_record(mft_ni);\n\tup_write(&mftbmp_ni->runlist.lock);\n\treturn ret;\n}",
          "includes": [
            "#include \"ntfs.h\"",
            "#include \"mft.h\"",
            "#include \"malloc.h\"",
            "#include \"lcnalloc.h\"",
            "#include \"dir.h\"",
            "#include \"debug.h\"",
            "#include \"bitmap.h\"",
            "#include \"aops.h\"",
            "#include \"attrib.h\"",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ntfs.h\"\n#include \"mft.h\"\n#include \"malloc.h\"\n#include \"lcnalloc.h\"\n#include \"dir.h\"\n#include \"debug.h\"\n#include \"bitmap.h\"\n#include \"aops.h\"\n#include \"attrib.h\"\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n\nstatic int ntfs_mft_bitmap_extend_allocation_nolock(ntfs_volume *vol)\n{\n\tLCN lcn;\n\ts64 ll;\n\tunsigned long flags;\n\tstruct page *page;\n\tntfs_inode *mft_ni, *mftbmp_ni;\n\trunlist_element *rl, *rl2 = NULL;\n\tntfs_attr_search_ctx *ctx = NULL;\n\tMFT_RECORD *mrec;\n\tATTR_RECORD *a = NULL;\n\tint ret, mp_size;\n\tu32 old_alen = 0;\n\tu8 *b, tb;\n\tstruct {\n\t\tu8 added_cluster:1;\n\t\tu8 added_run:1;\n\t\tu8 mp_rebuilt:1;\n\t} status = { 0, 0, 0 };\n\n\tntfs_debug(\"Extending mft bitmap allocation.\");\n\tmft_ni = NTFS_I(vol->mft_ino);\n\tmftbmp_ni = NTFS_I(vol->mftbmp_ino);\n\t/*\n\t * Determine the last lcn of the mft bitmap.  The allocated size of the\n\t * mft bitmap cannot be zero so we are ok to do this.\n\t */\n\tdown_write(&mftbmp_ni->runlist.lock);\n\tread_lock_irqsave(&mftbmp_ni->size_lock, flags);\n\tll = mftbmp_ni->allocated_size;\n\tread_unlock_irqrestore(&mftbmp_ni->size_lock, flags);\n\trl = ntfs_attr_find_vcn_nolock(mftbmp_ni,\n\t\t\t(ll - 1) >> vol->cluster_size_bits, NULL);\n\tif (unlikely(IS_ERR(rl) || !rl->length || rl->lcn < 0)) {\n\t\tup_write(&mftbmp_ni->runlist.lock);\n\t\tntfs_error(vol->sb, \"Failed to determine last allocated \"\n\t\t\t\t\"cluster of mft bitmap attribute.\");\n\t\tif (!IS_ERR(rl))\n\t\t\tret = -EIO;\n\t\telse\n\t\t\tret = PTR_ERR(rl);\n\t\treturn ret;\n\t}\n\tlcn = rl->lcn + rl->length;\n\tntfs_debug(\"Last lcn of mft bitmap attribute is 0x%llx.\",\n\t\t\t(long long)lcn);\n\t/*\n\t * Attempt to get the cluster following the last allocated cluster by\n\t * hand as it may be in the MFT zone so the allocator would not give it\n\t * to us.\n\t */\n\tll = lcn >> 3;\n\tpage = ntfs_map_page(vol->lcnbmp_ino->i_mapping,\n\t\t\tll >> PAGE_CACHE_SHIFT);\n\tif (IS_ERR(page)) {\n\t\tup_write(&mftbmp_ni->runlist.lock);\n\t\tntfs_error(vol->sb, \"Failed to read from lcn bitmap.\");\n\t\treturn PTR_ERR(page);\n\t}\n\tb = (u8*)page_address(page) + (ll & ~PAGE_CACHE_MASK);\n\ttb = 1 << (lcn & 7ull);\n\tdown_write(&vol->lcnbmp_lock);\n\tif (*b != 0xff && !(*b & tb)) {\n\t\t/* Next cluster is free, allocate it. */\n\t\t*b |= tb;\n\t\tflush_dcache_page(page);\n\t\tset_page_dirty(page);\n\t\tup_write(&vol->lcnbmp_lock);\n\t\tntfs_unmap_page(page);\n\t\t/* Update the mft bitmap runlist. */\n\t\trl->length++;\n\t\trl[1].vcn++;\n\t\tstatus.added_cluster = 1;\n\t\tntfs_debug(\"Appending one cluster to mft bitmap.\");\n\t} else {\n\t\tup_write(&vol->lcnbmp_lock);\n\t\tntfs_unmap_page(page);\n\t\t/* Allocate a cluster from the DATA_ZONE. */\n\t\trl2 = ntfs_cluster_alloc(vol, rl[1].vcn, 1, lcn, DATA_ZONE,\n\t\t\t\ttrue);\n\t\tif (IS_ERR(rl2)) {\n\t\t\tup_write(&mftbmp_ni->runlist.lock);\n\t\t\tntfs_error(vol->sb, \"Failed to allocate a cluster for \"\n\t\t\t\t\t\"the mft bitmap.\");\n\t\t\treturn PTR_ERR(rl2);\n\t\t}\n\t\trl = ntfs_runlists_merge(mftbmp_ni->runlist.rl, rl2);\n\t\tif (IS_ERR(rl)) {\n\t\t\tup_write(&mftbmp_ni->runlist.lock);\n\t\t\tntfs_error(vol->sb, \"Failed to merge runlists for mft \"\n\t\t\t\t\t\"bitmap.\");\n\t\t\tif (ntfs_cluster_free_from_rl(vol, rl2)) {\n\t\t\t\tntfs_error(vol->sb, \"Failed to deallocate \"\n\t\t\t\t\t\t\"allocated cluster.%s\", es);\n\t\t\t\tNVolSetErrors(vol);\n\t\t\t}\n\t\t\tntfs_free(rl2);\n\t\t\treturn PTR_ERR(rl);\n\t\t}\n\t\tmftbmp_ni->runlist.rl = rl;\n\t\tstatus.added_run = 1;\n\t\tntfs_debug(\"Adding one run to mft bitmap.\");\n\t\t/* Find the last run in the new runlist. */\n\t\tfor (; rl[1].length; rl++)\n\t\t\t;\n\t}\n\t/*\n\t * Update the attribute record as well.  Note: @rl is the last\n\t * (non-terminator) runlist element of mft bitmap.\n\t */\n\tmrec = map_mft_record(mft_ni);\n\tif (IS_ERR(mrec)) {\n\t\tntfs_error(vol->sb, \"Failed to map mft record.\");\n\t\tret = PTR_ERR(mrec);\n\t\tgoto undo_alloc;\n\t}\n\tctx = ntfs_attr_get_search_ctx(mft_ni, mrec);\n\tif (unlikely(!ctx)) {\n\t\tntfs_error(vol->sb, \"Failed to get search context.\");\n\t\tret = -ENOMEM;\n\t\tgoto undo_alloc;\n\t}\n\tret = ntfs_attr_lookup(mftbmp_ni->type, mftbmp_ni->name,\n\t\t\tmftbmp_ni->name_len, CASE_SENSITIVE, rl[1].vcn, NULL,\n\t\t\t0, ctx);\n\tif (unlikely(ret)) {\n\t\tntfs_error(vol->sb, \"Failed to find last attribute extent of \"\n\t\t\t\t\"mft bitmap attribute.\");\n\t\tif (ret == -ENOENT)\n\t\t\tret = -EIO;\n\t\tgoto undo_alloc;\n\t}\n\ta = ctx->attr;\n\tll = sle64_to_cpu(a->data.non_resident.lowest_vcn);\n\t/* Search back for the previous last allocated cluster of mft bitmap. */\n\tfor (rl2 = rl; rl2 > mftbmp_ni->runlist.rl; rl2--) {\n\t\tif (ll >= rl2->vcn)\n\t\t\tbreak;\n\t}\n\tBUG_ON(ll < rl2->vcn);\n\tBUG_ON(ll >= rl2->vcn + rl2->length);\n\t/* Get the size for the new mapping pairs array for this extent. */\n\tmp_size = ntfs_get_size_for_mapping_pairs(vol, rl2, ll, -1);\n\tif (unlikely(mp_size <= 0)) {\n\t\tntfs_error(vol->sb, \"Get size for mapping pairs failed for \"\n\t\t\t\t\"mft bitmap attribute extent.\");\n\t\tret = mp_size;\n\t\tif (!ret)\n\t\t\tret = -EIO;\n\t\tgoto undo_alloc;\n\t}\n\t/* Expand the attribute record if necessary. */\n\told_alen = le32_to_cpu(a->length);\n\tret = ntfs_attr_record_resize(ctx->mrec, a, mp_size +\n\t\t\tle16_to_cpu(a->data.non_resident.mapping_pairs_offset));\n\tif (unlikely(ret)) {\n\t\tif (ret != -ENOSPC) {\n\t\t\tntfs_error(vol->sb, \"Failed to resize attribute \"\n\t\t\t\t\t\"record for mft bitmap attribute.\");\n\t\t\tgoto undo_alloc;\n\t\t}\n\t\t// TODO: Deal with this by moving this extent to a new mft\n\t\t// record or by starting a new extent in a new mft record or by\n\t\t// moving other attributes out of this mft record.\n\t\t// Note: It will need to be a special mft record and if none of\n\t\t// those are available it gets rather complicated...\n\t\tntfs_error(vol->sb, \"Not enough space in this mft record to \"\n\t\t\t\t\"accommodate extended mft bitmap attribute \"\n\t\t\t\t\"extent.  Cannot handle this yet.\");\n\t\tret = -EOPNOTSUPP;\n\t\tgoto undo_alloc;\n\t}\n\tstatus.mp_rebuilt = 1;\n\t/* Generate the mapping pairs array directly into the attr record. */\n\tret = ntfs_mapping_pairs_build(vol, (u8*)a +\n\t\t\tle16_to_cpu(a->data.non_resident.mapping_pairs_offset),\n\t\t\tmp_size, rl2, ll, -1, NULL);\n\tif (unlikely(ret)) {\n\t\tntfs_error(vol->sb, \"Failed to build mapping pairs array for \"\n\t\t\t\t\"mft bitmap attribute.\");\n\t\tgoto undo_alloc;\n\t}\n\t/* Update the highest_vcn. */\n\ta->data.non_resident.highest_vcn = cpu_to_sle64(rl[1].vcn - 1);\n\t/*\n\t * We now have extended the mft bitmap allocated_size by one cluster.\n\t * Reflect this in the ntfs_inode structure and the attribute record.\n\t */\n\tif (a->data.non_resident.lowest_vcn) {\n\t\t/*\n\t\t * We are not in the first attribute extent, switch to it, but\n\t\t * first ensure the changes will make it to disk later.\n\t\t */\n\t\tflush_dcache_mft_record_page(ctx->ntfs_ino);\n\t\tmark_mft_record_dirty(ctx->ntfs_ino);\n\t\tntfs_attr_reinit_search_ctx(ctx);\n\t\tret = ntfs_attr_lookup(mftbmp_ni->type, mftbmp_ni->name,\n\t\t\t\tmftbmp_ni->name_len, CASE_SENSITIVE, 0, NULL,\n\t\t\t\t0, ctx);\n\t\tif (unlikely(ret)) {\n\t\t\tntfs_error(vol->sb, \"Failed to find first attribute \"\n\t\t\t\t\t\"extent of mft bitmap attribute.\");\n\t\t\tgoto restore_undo_alloc;\n\t\t}\n\t\ta = ctx->attr;\n\t}\n\twrite_lock_irqsave(&mftbmp_ni->size_lock, flags);\n\tmftbmp_ni->allocated_size += vol->cluster_size;\n\ta->data.non_resident.allocated_size =\n\t\t\tcpu_to_sle64(mftbmp_ni->allocated_size);\n\twrite_unlock_irqrestore(&mftbmp_ni->size_lock, flags);\n\t/* Ensure the changes make it to disk. */\n\tflush_dcache_mft_record_page(ctx->ntfs_ino);\n\tmark_mft_record_dirty(ctx->ntfs_ino);\n\tntfs_attr_put_search_ctx(ctx);\n\tunmap_mft_record(mft_ni);\n\tup_write(&mftbmp_ni->runlist.lock);\n\tntfs_debug(\"Done.\");\n\treturn 0;\nrestore_undo_alloc:\n\tntfs_attr_reinit_search_ctx(ctx);\n\tif (ntfs_attr_lookup(mftbmp_ni->type, mftbmp_ni->name,\n\t\t\tmftbmp_ni->name_len, CASE_SENSITIVE, rl[1].vcn, NULL,\n\t\t\t0, ctx)) {\n\t\tntfs_error(vol->sb, \"Failed to find last attribute extent of \"\n\t\t\t\t\"mft bitmap attribute.%s\", es);\n\t\twrite_lock_irqsave(&mftbmp_ni->size_lock, flags);\n\t\tmftbmp_ni->allocated_size += vol->cluster_size;\n\t\twrite_unlock_irqrestore(&mftbmp_ni->size_lock, flags);\n\t\tntfs_attr_put_search_ctx(ctx);\n\t\tunmap_mft_record(mft_ni);\n\t\tup_write(&mftbmp_ni->runlist.lock);\n\t\t/*\n\t\t * The only thing that is now wrong is ->allocated_size of the\n\t\t * base attribute extent which chkdsk should be able to fix.\n\t\t */\n\t\tNVolSetErrors(vol);\n\t\treturn ret;\n\t}\n\ta = ctx->attr;\n\ta->data.non_resident.highest_vcn = cpu_to_sle64(rl[1].vcn - 2);\nundo_alloc:\n\tif (status.added_cluster) {\n\t\t/* Truncate the last run in the runlist by one cluster. */\n\t\trl->length--;\n\t\trl[1].vcn--;\n\t} else if (status.added_run) {\n\t\tlcn = rl->lcn;\n\t\t/* Remove the last run from the runlist. */\n\t\trl->lcn = rl[1].lcn;\n\t\trl->length = 0;\n\t}\n\t/* Deallocate the cluster. */\n\tdown_write(&vol->lcnbmp_lock);\n\tif (ntfs_bitmap_clear_bit(vol->lcnbmp_ino, lcn)) {\n\t\tntfs_error(vol->sb, \"Failed to free allocated cluster.%s\", es);\n\t\tNVolSetErrors(vol);\n\t}\n\tup_write(&vol->lcnbmp_lock);\n\tif (status.mp_rebuilt) {\n\t\tif (ntfs_mapping_pairs_build(vol, (u8*)a + le16_to_cpu(\n\t\t\t\ta->data.non_resident.mapping_pairs_offset),\n\t\t\t\told_alen - le16_to_cpu(\n\t\t\t\ta->data.non_resident.mapping_pairs_offset),\n\t\t\t\trl2, ll, -1, NULL)) {\n\t\t\tntfs_error(vol->sb, \"Failed to restore mapping pairs \"\n\t\t\t\t\t\"array.%s\", es);\n\t\t\tNVolSetErrors(vol);\n\t\t}\n\t\tif (ntfs_attr_record_resize(ctx->mrec, a, old_alen)) {\n\t\t\tntfs_error(vol->sb, \"Failed to restore attribute \"\n\t\t\t\t\t\"record.%s\", es);\n\t\t\tNVolSetErrors(vol);\n\t\t}\n\t\tflush_dcache_mft_record_page(ctx->ntfs_ino);\n\t\tmark_mft_record_dirty(ctx->ntfs_ino);\n\t}\n\tif (ctx)\n\t\tntfs_attr_put_search_ctx(ctx);\n\tif (!IS_ERR(mrec))\n\t\tunmap_mft_record(mft_ni);\n\tup_write(&mftbmp_ni->runlist.lock);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "read_unlock_irqrestore",
          "args": [
            "&mftbmp_ni->size_lock",
            "flags"
          ],
          "line": 2328
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "i_size_read",
          "args": [
            "vol->mftbmp_ino"
          ],
          "line": 2326
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "read_lock_irqsave",
          "args": [
            "&mftbmp_ni->size_lock",
            "flags"
          ],
          "line": 2321
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "bit >= (1ll << 32)"
          ],
          "line": 2319
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntfs_debug",
          "args": [
            "\"Found free record (#2), bit 0x%llx.\"",
            "(long long)bit"
          ],
          "line": 2309
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "bit >= (1ll << 32)"
          ],
          "line": 2307
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "read_unlock_irqrestore",
          "args": [
            "&mftbmp_ni->size_lock",
            "flags"
          ],
          "line": 2302
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "read_lock_irqsave",
          "args": [
            "&mftbmp_ni->size_lock",
            "flags"
          ],
          "line": 2300
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "read_unlock_irqrestore",
          "args": [
            "&mft_ni->size_lock",
            "flags"
          ],
          "line": 2299
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "read_lock_irqsave",
          "args": [
            "&mft_ni->size_lock",
            "flags"
          ],
          "line": 2297
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "bit"
          ],
          "line": 2287
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "up_write",
          "args": [
            "&vol->mftbmp_lock"
          ],
          "line": 2286
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntfs_debug",
          "args": [
            "\"Found and allocated free record (#1), bit 0x%llx.\"",
            "(long long)bit"
          ],
          "line": 2281
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntfs_mft_bitmap_find_and_alloc_free_rec_nolock",
          "args": [
            "vol",
            "base_ni"
          ],
          "line": 2279
        },
        "resolved": true,
        "details": {
          "function_name": "ntfs_mft_bitmap_find_and_alloc_free_rec_nolock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/mft.c",
          "lines": "1131-1259",
          "snippet": "static int ntfs_mft_bitmap_find_and_alloc_free_rec_nolock(ntfs_volume *vol,\n\t\tntfs_inode *base_ni)\n{\n\ts64 pass_end, ll, data_pos, pass_start, ofs, bit;\n\tunsigned long flags;\n\tstruct address_space *mftbmp_mapping;\n\tu8 *buf, *byte;\n\tstruct page *page;\n\tunsigned int page_ofs, size;\n\tu8 pass, b;\n\n\tntfs_debug(\"Searching for free mft record in the currently \"\n\t\t\t\"initialized mft bitmap.\");\n\tmftbmp_mapping = vol->mftbmp_ino->i_mapping;\n\t/*\n\t * Set the end of the pass making sure we do not overflow the mft\n\t * bitmap.\n\t */\n\tread_lock_irqsave(&NTFS_I(vol->mft_ino)->size_lock, flags);\n\tpass_end = NTFS_I(vol->mft_ino)->allocated_size >>\n\t\t\tvol->mft_record_size_bits;\n\tread_unlock_irqrestore(&NTFS_I(vol->mft_ino)->size_lock, flags);\n\tread_lock_irqsave(&NTFS_I(vol->mftbmp_ino)->size_lock, flags);\n\tll = NTFS_I(vol->mftbmp_ino)->initialized_size << 3;\n\tread_unlock_irqrestore(&NTFS_I(vol->mftbmp_ino)->size_lock, flags);\n\tif (pass_end > ll)\n\t\tpass_end = ll;\n\tpass = 1;\n\tif (!base_ni)\n\t\tdata_pos = vol->mft_data_pos;\n\telse\n\t\tdata_pos = base_ni->mft_no + 1;\n\tif (data_pos < 24)\n\t\tdata_pos = 24;\n\tif (data_pos >= pass_end) {\n\t\tdata_pos = 24;\n\t\tpass = 2;\n\t\t/* This happens on a freshly formatted volume. */\n\t\tif (data_pos >= pass_end)\n\t\t\treturn -ENOSPC;\n\t}\n\tpass_start = data_pos;\n\tntfs_debug(\"Starting bitmap search: pass %u, pass_start 0x%llx, \"\n\t\t\t\"pass_end 0x%llx, data_pos 0x%llx.\", pass,\n\t\t\t(long long)pass_start, (long long)pass_end,\n\t\t\t(long long)data_pos);\n\t/* Loop until a free mft record is found. */\n\tfor (; pass <= 2;) {\n\t\t/* Cap size to pass_end. */\n\t\tofs = data_pos >> 3;\n\t\tpage_ofs = ofs & ~PAGE_CACHE_MASK;\n\t\tsize = PAGE_CACHE_SIZE - page_ofs;\n\t\tll = ((pass_end + 7) >> 3) - ofs;\n\t\tif (size > ll)\n\t\t\tsize = ll;\n\t\tsize <<= 3;\n\t\t/*\n\t\t * If we are still within the active pass, search the next page\n\t\t * for a zero bit.\n\t\t */\n\t\tif (size) {\n\t\t\tpage = ntfs_map_page(mftbmp_mapping,\n\t\t\t\t\tofs >> PAGE_CACHE_SHIFT);\n\t\t\tif (IS_ERR(page)) {\n\t\t\t\tntfs_error(vol->sb, \"Failed to read mft \"\n\t\t\t\t\t\t\"bitmap, aborting.\");\n\t\t\t\treturn PTR_ERR(page);\n\t\t\t}\n\t\t\tbuf = (u8*)page_address(page) + page_ofs;\n\t\t\tbit = data_pos & 7;\n\t\t\tdata_pos &= ~7ull;\n\t\t\tntfs_debug(\"Before inner for loop: size 0x%x, \"\n\t\t\t\t\t\"data_pos 0x%llx, bit 0x%llx\", size,\n\t\t\t\t\t(long long)data_pos, (long long)bit);\n\t\t\tfor (; bit < size && data_pos + bit < pass_end;\n\t\t\t\t\tbit &= ~7ull, bit += 8) {\n\t\t\t\tbyte = buf + (bit >> 3);\n\t\t\t\tif (*byte == 0xff)\n\t\t\t\t\tcontinue;\n\t\t\t\tb = ffz((unsigned long)*byte);\n\t\t\t\tif (b < 8 && b >= (bit & 7)) {\n\t\t\t\t\tll = data_pos + (bit & ~7ull) + b;\n\t\t\t\t\tif (unlikely(ll > (1ll << 32))) {\n\t\t\t\t\t\tntfs_unmap_page(page);\n\t\t\t\t\t\treturn -ENOSPC;\n\t\t\t\t\t}\n\t\t\t\t\t*byte |= 1 << b;\n\t\t\t\t\tflush_dcache_page(page);\n\t\t\t\t\tset_page_dirty(page);\n\t\t\t\t\tntfs_unmap_page(page);\n\t\t\t\t\tntfs_debug(\"Done.  (Found and \"\n\t\t\t\t\t\t\t\"allocated mft record \"\n\t\t\t\t\t\t\t\"0x%llx.)\",\n\t\t\t\t\t\t\t(long long)ll);\n\t\t\t\t\treturn ll;\n\t\t\t\t}\n\t\t\t}\n\t\t\tntfs_debug(\"After inner for loop: size 0x%x, \"\n\t\t\t\t\t\"data_pos 0x%llx, bit 0x%llx\", size,\n\t\t\t\t\t(long long)data_pos, (long long)bit);\n\t\t\tdata_pos += size;\n\t\t\tntfs_unmap_page(page);\n\t\t\t/*\n\t\t\t * If the end of the pass has not been reached yet,\n\t\t\t * continue searching the mft bitmap for a zero bit.\n\t\t\t */\n\t\t\tif (data_pos < pass_end)\n\t\t\t\tcontinue;\n\t\t}\n\t\t/* Do the next pass. */\n\t\tif (++pass == 2) {\n\t\t\t/*\n\t\t\t * Starting the second pass, in which we scan the first\n\t\t\t * part of the zone which we omitted earlier.\n\t\t\t */\n\t\t\tpass_end = pass_start;\n\t\t\tdata_pos = pass_start = 24;\n\t\t\tntfs_debug(\"pass %i, pass_start 0x%llx, pass_end \"\n\t\t\t\t\t\"0x%llx.\", pass, (long long)pass_start,\n\t\t\t\t\t(long long)pass_end);\n\t\t\tif (data_pos >= pass_end)\n\t\t\t\tbreak;\n\t\t}\n\t}\n\t/* No free mft records in currently initialized mft bitmap. */\n\tntfs_debug(\"Done.  (No free mft records left in currently initialized \"\n\t\t\t\"mft bitmap.)\");\n\treturn -ENOSPC;\n}",
          "includes": [
            "#include \"ntfs.h\"",
            "#include \"mft.h\"",
            "#include \"malloc.h\"",
            "#include \"lcnalloc.h\"",
            "#include \"dir.h\"",
            "#include \"debug.h\"",
            "#include \"bitmap.h\"",
            "#include \"aops.h\"",
            "#include \"attrib.h\"",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ntfs.h\"\n#include \"mft.h\"\n#include \"malloc.h\"\n#include \"lcnalloc.h\"\n#include \"dir.h\"\n#include \"debug.h\"\n#include \"bitmap.h\"\n#include \"aops.h\"\n#include \"attrib.h\"\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n\nstatic int ntfs_mft_bitmap_find_and_alloc_free_rec_nolock(ntfs_volume *vol,\n\t\tntfs_inode *base_ni)\n{\n\ts64 pass_end, ll, data_pos, pass_start, ofs, bit;\n\tunsigned long flags;\n\tstruct address_space *mftbmp_mapping;\n\tu8 *buf, *byte;\n\tstruct page *page;\n\tunsigned int page_ofs, size;\n\tu8 pass, b;\n\n\tntfs_debug(\"Searching for free mft record in the currently \"\n\t\t\t\"initialized mft bitmap.\");\n\tmftbmp_mapping = vol->mftbmp_ino->i_mapping;\n\t/*\n\t * Set the end of the pass making sure we do not overflow the mft\n\t * bitmap.\n\t */\n\tread_lock_irqsave(&NTFS_I(vol->mft_ino)->size_lock, flags);\n\tpass_end = NTFS_I(vol->mft_ino)->allocated_size >>\n\t\t\tvol->mft_record_size_bits;\n\tread_unlock_irqrestore(&NTFS_I(vol->mft_ino)->size_lock, flags);\n\tread_lock_irqsave(&NTFS_I(vol->mftbmp_ino)->size_lock, flags);\n\tll = NTFS_I(vol->mftbmp_ino)->initialized_size << 3;\n\tread_unlock_irqrestore(&NTFS_I(vol->mftbmp_ino)->size_lock, flags);\n\tif (pass_end > ll)\n\t\tpass_end = ll;\n\tpass = 1;\n\tif (!base_ni)\n\t\tdata_pos = vol->mft_data_pos;\n\telse\n\t\tdata_pos = base_ni->mft_no + 1;\n\tif (data_pos < 24)\n\t\tdata_pos = 24;\n\tif (data_pos >= pass_end) {\n\t\tdata_pos = 24;\n\t\tpass = 2;\n\t\t/* This happens on a freshly formatted volume. */\n\t\tif (data_pos >= pass_end)\n\t\t\treturn -ENOSPC;\n\t}\n\tpass_start = data_pos;\n\tntfs_debug(\"Starting bitmap search: pass %u, pass_start 0x%llx, \"\n\t\t\t\"pass_end 0x%llx, data_pos 0x%llx.\", pass,\n\t\t\t(long long)pass_start, (long long)pass_end,\n\t\t\t(long long)data_pos);\n\t/* Loop until a free mft record is found. */\n\tfor (; pass <= 2;) {\n\t\t/* Cap size to pass_end. */\n\t\tofs = data_pos >> 3;\n\t\tpage_ofs = ofs & ~PAGE_CACHE_MASK;\n\t\tsize = PAGE_CACHE_SIZE - page_ofs;\n\t\tll = ((pass_end + 7) >> 3) - ofs;\n\t\tif (size > ll)\n\t\t\tsize = ll;\n\t\tsize <<= 3;\n\t\t/*\n\t\t * If we are still within the active pass, search the next page\n\t\t * for a zero bit.\n\t\t */\n\t\tif (size) {\n\t\t\tpage = ntfs_map_page(mftbmp_mapping,\n\t\t\t\t\tofs >> PAGE_CACHE_SHIFT);\n\t\t\tif (IS_ERR(page)) {\n\t\t\t\tntfs_error(vol->sb, \"Failed to read mft \"\n\t\t\t\t\t\t\"bitmap, aborting.\");\n\t\t\t\treturn PTR_ERR(page);\n\t\t\t}\n\t\t\tbuf = (u8*)page_address(page) + page_ofs;\n\t\t\tbit = data_pos & 7;\n\t\t\tdata_pos &= ~7ull;\n\t\t\tntfs_debug(\"Before inner for loop: size 0x%x, \"\n\t\t\t\t\t\"data_pos 0x%llx, bit 0x%llx\", size,\n\t\t\t\t\t(long long)data_pos, (long long)bit);\n\t\t\tfor (; bit < size && data_pos + bit < pass_end;\n\t\t\t\t\tbit &= ~7ull, bit += 8) {\n\t\t\t\tbyte = buf + (bit >> 3);\n\t\t\t\tif (*byte == 0xff)\n\t\t\t\t\tcontinue;\n\t\t\t\tb = ffz((unsigned long)*byte);\n\t\t\t\tif (b < 8 && b >= (bit & 7)) {\n\t\t\t\t\tll = data_pos + (bit & ~7ull) + b;\n\t\t\t\t\tif (unlikely(ll > (1ll << 32))) {\n\t\t\t\t\t\tntfs_unmap_page(page);\n\t\t\t\t\t\treturn -ENOSPC;\n\t\t\t\t\t}\n\t\t\t\t\t*byte |= 1 << b;\n\t\t\t\t\tflush_dcache_page(page);\n\t\t\t\t\tset_page_dirty(page);\n\t\t\t\t\tntfs_unmap_page(page);\n\t\t\t\t\tntfs_debug(\"Done.  (Found and \"\n\t\t\t\t\t\t\t\"allocated mft record \"\n\t\t\t\t\t\t\t\"0x%llx.)\",\n\t\t\t\t\t\t\t(long long)ll);\n\t\t\t\t\treturn ll;\n\t\t\t\t}\n\t\t\t}\n\t\t\tntfs_debug(\"After inner for loop: size 0x%x, \"\n\t\t\t\t\t\"data_pos 0x%llx, bit 0x%llx\", size,\n\t\t\t\t\t(long long)data_pos, (long long)bit);\n\t\t\tdata_pos += size;\n\t\t\tntfs_unmap_page(page);\n\t\t\t/*\n\t\t\t * If the end of the pass has not been reached yet,\n\t\t\t * continue searching the mft bitmap for a zero bit.\n\t\t\t */\n\t\t\tif (data_pos < pass_end)\n\t\t\t\tcontinue;\n\t\t}\n\t\t/* Do the next pass. */\n\t\tif (++pass == 2) {\n\t\t\t/*\n\t\t\t * Starting the second pass, in which we scan the first\n\t\t\t * part of the zone which we omitted earlier.\n\t\t\t */\n\t\t\tpass_end = pass_start;\n\t\t\tdata_pos = pass_start = 24;\n\t\t\tntfs_debug(\"pass %i, pass_start 0x%llx, pass_end \"\n\t\t\t\t\t\"0x%llx.\", pass, (long long)pass_start,\n\t\t\t\t\t(long long)pass_end);\n\t\t\tif (data_pos >= pass_end)\n\t\t\t\tbreak;\n\t\t}\n\t}\n\t/* No free mft records in currently initialized mft bitmap. */\n\tntfs_debug(\"Done.  (No free mft records left in currently initialized \"\n\t\t\t\"mft bitmap.)\");\n\treturn -ENOSPC;\n}"
        }
      },
      {
        "call_info": {
          "callee": "down_write",
          "args": [
            "&vol->mftbmp_lock"
          ],
          "line": 2278
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!mrec"
          ],
          "line": 2275
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-EOPNOTSUPP"
          ],
          "line": 2273
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISDIR",
          "args": [
            "mode"
          ],
          "line": 2272
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISREG",
          "args": [
            "mode"
          ],
          "line": 2272
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "base_ni"
          ],
          "line": 2270
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "mode"
          ],
          "line": 2265
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntfs_debug",
          "args": [
            "\"Entering (allocating an extent mft record for \"\n\t\t\t\t\"base mft record 0x%llx).\"",
            "(long long)base_ni->mft_no"
          ],
          "line": 2261
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ntfs.h\"\n#include \"mft.h\"\n#include \"malloc.h\"\n#include \"lcnalloc.h\"\n#include \"dir.h\"\n#include \"debug.h\"\n#include \"bitmap.h\"\n#include \"aops.h\"\n#include \"attrib.h\"\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n\nntfs_inode *ntfs_mft_record_alloc(ntfs_volume *vol, const int mode,\n\t\tntfs_inode *base_ni, MFT_RECORD **mrec)\n{\n\ts64 ll, bit, old_data_initialized, old_data_size;\n\tunsigned long flags;\n\tstruct inode *vi;\n\tstruct page *page;\n\tntfs_inode *mft_ni, *mftbmp_ni, *ni;\n\tntfs_attr_search_ctx *ctx;\n\tMFT_RECORD *m;\n\tATTR_RECORD *a;\n\tpgoff_t index;\n\tunsigned int ofs;\n\tint err;\n\tle16 seq_no, usn;\n\tbool record_formatted = false;\n\n\tif (base_ni) {\n\t\tntfs_debug(\"Entering (allocating an extent mft record for \"\n\t\t\t\t\"base mft record 0x%llx).\",\n\t\t\t\t(long long)base_ni->mft_no);\n\t\t/* @mode and @base_ni are mutually exclusive. */\n\t\tBUG_ON(mode);\n\t} else\n\t\tntfs_debug(\"Entering (allocating a base mft record).\");\n\tif (mode) {\n\t\t/* @mode and @base_ni are mutually exclusive. */\n\t\tBUG_ON(base_ni);\n\t\t/* We only support creation of normal files and directories. */\n\t\tif (!S_ISREG(mode) && !S_ISDIR(mode))\n\t\t\treturn ERR_PTR(-EOPNOTSUPP);\n\t}\n\tBUG_ON(!mrec);\n\tmft_ni = NTFS_I(vol->mft_ino);\n\tmftbmp_ni = NTFS_I(vol->mftbmp_ino);\n\tdown_write(&vol->mftbmp_lock);\n\tbit = ntfs_mft_bitmap_find_and_alloc_free_rec_nolock(vol, base_ni);\n\tif (bit >= 0) {\n\t\tntfs_debug(\"Found and allocated free record (#1), bit 0x%llx.\",\n\t\t\t\t(long long)bit);\n\t\tgoto have_alloc_rec;\n\t}\n\tif (bit != -ENOSPC) {\n\t\tup_write(&vol->mftbmp_lock);\n\t\treturn ERR_PTR(bit);\n\t}\n\t/*\n\t * No free mft records left.  If the mft bitmap already covers more\n\t * than the currently used mft records, the next records are all free,\n\t * so we can simply allocate the first unused mft record.\n\t * Note: We also have to make sure that the mft bitmap at least covers\n\t * the first 24 mft records as they are special and whilst they may not\n\t * be in use, we do not allocate from them.\n\t */\n\tread_lock_irqsave(&mft_ni->size_lock, flags);\n\tll = mft_ni->initialized_size >> vol->mft_record_size_bits;\n\tread_unlock_irqrestore(&mft_ni->size_lock, flags);\n\tread_lock_irqsave(&mftbmp_ni->size_lock, flags);\n\told_data_initialized = mftbmp_ni->initialized_size;\n\tread_unlock_irqrestore(&mftbmp_ni->size_lock, flags);\n\tif (old_data_initialized << 3 > ll && old_data_initialized > 3) {\n\t\tbit = ll;\n\t\tif (bit < 24)\n\t\t\tbit = 24;\n\t\tif (unlikely(bit >= (1ll << 32)))\n\t\t\tgoto max_err_out;\n\t\tntfs_debug(\"Found free record (#2), bit 0x%llx.\",\n\t\t\t\t(long long)bit);\n\t\tgoto found_free_rec;\n\t}\n\t/*\n\t * The mft bitmap needs to be expanded until it covers the first unused\n\t * mft record that we can allocate.\n\t * Note: The smallest mft record we allocate is mft record 24.\n\t */\n\tbit = old_data_initialized << 3;\n\tif (unlikely(bit >= (1ll << 32)))\n\t\tgoto max_err_out;\n\tread_lock_irqsave(&mftbmp_ni->size_lock, flags);\n\told_data_size = mftbmp_ni->allocated_size;\n\tntfs_debug(\"Status of mftbmp before extension: allocated_size 0x%llx, \"\n\t\t\t\"data_size 0x%llx, initialized_size 0x%llx.\",\n\t\t\t(long long)old_data_size,\n\t\t\t(long long)i_size_read(vol->mftbmp_ino),\n\t\t\t(long long)old_data_initialized);\n\tread_unlock_irqrestore(&mftbmp_ni->size_lock, flags);\n\tif (old_data_initialized + 8 > old_data_size) {\n\t\t/* Need to extend bitmap by one more cluster. */\n\t\tntfs_debug(\"mftbmp: initialized_size + 8 > allocated_size.\");\n\t\terr = ntfs_mft_bitmap_extend_allocation_nolock(vol);\n\t\tif (unlikely(err)) {\n\t\t\tup_write(&vol->mftbmp_lock);\n\t\t\tgoto err_out;\n\t\t}\n#ifdef DEBUG\n\t\tread_lock_irqsave(&mftbmp_ni->size_lock, flags);\n\t\tntfs_debug(\"Status of mftbmp after allocation extension: \"\n\t\t\t\t\"allocated_size 0x%llx, data_size 0x%llx, \"\n\t\t\t\t\"initialized_size 0x%llx.\",\n\t\t\t\t(long long)mftbmp_ni->allocated_size,\n\t\t\t\t(long long)i_size_read(vol->mftbmp_ino),\n\t\t\t\t(long long)mftbmp_ni->initialized_size);\n\t\tread_unlock_irqrestore(&mftbmp_ni->size_lock, flags);\n#endif /* DEBUG */\n\t}\n\t/*\n\t * We now have sufficient allocated space, extend the initialized_size\n\t * as well as the data_size if necessary and fill the new space with\n\t * zeroes.\n\t */\n\terr = ntfs_mft_bitmap_extend_initialized_nolock(vol);\n\tif (unlikely(err)) {\n\t\tup_write(&vol->mftbmp_lock);\n\t\tgoto err_out;\n\t}\n#ifdef DEBUG\n\tread_lock_irqsave(&mftbmp_ni->size_lock, flags);\n\tntfs_debug(\"Status of mftbmp after initialized extension: \"\n\t\t\t\"allocated_size 0x%llx, data_size 0x%llx, \"\n\t\t\t\"initialized_size 0x%llx.\",\n\t\t\t(long long)mftbmp_ni->allocated_size,\n\t\t\t(long long)i_size_read(vol->mftbmp_ino),\n\t\t\t(long long)mftbmp_ni->initialized_size);\n\tread_unlock_irqrestore(&mftbmp_ni->size_lock, flags);\n#endif /* DEBUG */\n\tntfs_debug(\"Found free record (#3), bit 0x%llx.\", (long long)bit);\nfound_free_rec:\n\t/* @bit is the found free mft record, allocate it in the mft bitmap. */\n\tntfs_debug(\"At found_free_rec.\");\n\terr = ntfs_bitmap_set_bit(vol->mftbmp_ino, bit);\n\tif (unlikely(err)) {\n\t\tntfs_error(vol->sb, \"Failed to allocate bit in mft bitmap.\");\n\t\tup_write(&vol->mftbmp_lock);\n\t\tgoto err_out;\n\t}\n\tntfs_debug(\"Set bit 0x%llx in mft bitmap.\", (long long)bit);\nhave_alloc_rec:\n\t/*\n\t * The mft bitmap is now uptodate.  Deal with mft data attribute now.\n\t * Note, we keep hold of the mft bitmap lock for writing until all\n\t * modifications to the mft data attribute are complete, too, as they\n\t * will impact decisions for mft bitmap and mft record allocation done\n\t * by a parallel allocation and if the lock is not maintained a\n\t * parallel allocation could allocate the same mft record as this one.\n\t */\n\tll = (bit + 1) << vol->mft_record_size_bits;\n\tread_lock_irqsave(&mft_ni->size_lock, flags);\n\told_data_initialized = mft_ni->initialized_size;\n\tread_unlock_irqrestore(&mft_ni->size_lock, flags);\n\tif (ll <= old_data_initialized) {\n\t\tntfs_debug(\"Allocated mft record already initialized.\");\n\t\tgoto mft_rec_already_initialized;\n\t}\n\tntfs_debug(\"Initializing allocated mft record.\");\n\t/*\n\t * The mft record is outside the initialized data.  Extend the mft data\n\t * attribute until it covers the allocated record.  The loop is only\n\t * actually traversed more than once when a freshly formatted volume is\n\t * first written to so it optimizes away nicely in the common case.\n\t */\n\tread_lock_irqsave(&mft_ni->size_lock, flags);\n\tntfs_debug(\"Status of mft data before extension: \"\n\t\t\t\"allocated_size 0x%llx, data_size 0x%llx, \"\n\t\t\t\"initialized_size 0x%llx.\",\n\t\t\t(long long)mft_ni->allocated_size,\n\t\t\t(long long)i_size_read(vol->mft_ino),\n\t\t\t(long long)mft_ni->initialized_size);\n\twhile (ll > mft_ni->allocated_size) {\n\t\tread_unlock_irqrestore(&mft_ni->size_lock, flags);\n\t\terr = ntfs_mft_data_extend_allocation_nolock(vol);\n\t\tif (unlikely(err)) {\n\t\t\tntfs_error(vol->sb, \"Failed to extend mft data \"\n\t\t\t\t\t\"allocation.\");\n\t\t\tgoto undo_mftbmp_alloc_nolock;\n\t\t}\n\t\tread_lock_irqsave(&mft_ni->size_lock, flags);\n\t\tntfs_debug(\"Status of mft data after allocation extension: \"\n\t\t\t\t\"allocated_size 0x%llx, data_size 0x%llx, \"\n\t\t\t\t\"initialized_size 0x%llx.\",\n\t\t\t\t(long long)mft_ni->allocated_size,\n\t\t\t\t(long long)i_size_read(vol->mft_ino),\n\t\t\t\t(long long)mft_ni->initialized_size);\n\t}\n\tread_unlock_irqrestore(&mft_ni->size_lock, flags);\n\t/*\n\t * Extend mft data initialized size (and data size of course) to reach\n\t * the allocated mft record, formatting the mft records allong the way.\n\t * Note: We only modify the ntfs_inode structure as that is all that is\n\t * needed by ntfs_mft_record_format().  We will update the attribute\n\t * record itself in one fell swoop later on.\n\t */\n\twrite_lock_irqsave(&mft_ni->size_lock, flags);\n\told_data_initialized = mft_ni->initialized_size;\n\told_data_size = vol->mft_ino->i_size;\n\twhile (ll > mft_ni->initialized_size) {\n\t\ts64 new_initialized_size, mft_no;\n\t\t\n\t\tnew_initialized_size = mft_ni->initialized_size +\n\t\t\t\tvol->mft_record_size;\n\t\tmft_no = mft_ni->initialized_size >> vol->mft_record_size_bits;\n\t\tif (new_initialized_size > i_size_read(vol->mft_ino))\n\t\t\ti_size_write(vol->mft_ino, new_initialized_size);\n\t\twrite_unlock_irqrestore(&mft_ni->size_lock, flags);\n\t\tntfs_debug(\"Initializing mft record 0x%llx.\",\n\t\t\t\t(long long)mft_no);\n\t\terr = ntfs_mft_record_format(vol, mft_no);\n\t\tif (unlikely(err)) {\n\t\t\tntfs_error(vol->sb, \"Failed to format mft record.\");\n\t\t\tgoto undo_data_init;\n\t\t}\n\t\twrite_lock_irqsave(&mft_ni->size_lock, flags);\n\t\tmft_ni->initialized_size = new_initialized_size;\n\t}\n\twrite_unlock_irqrestore(&mft_ni->size_lock, flags);\n\trecord_formatted = true;\n\t/* Update the mft data attribute record to reflect the new sizes. */\n\tm = map_mft_record(mft_ni);\n\tif (IS_ERR(m)) {\n\t\tntfs_error(vol->sb, \"Failed to map mft record.\");\n\t\terr = PTR_ERR(m);\n\t\tgoto undo_data_init;\n\t}\n\tctx = ntfs_attr_get_search_ctx(mft_ni, m);\n\tif (unlikely(!ctx)) {\n\t\tntfs_error(vol->sb, \"Failed to get search context.\");\n\t\terr = -ENOMEM;\n\t\tunmap_mft_record(mft_ni);\n\t\tgoto undo_data_init;\n\t}\n\terr = ntfs_attr_lookup(mft_ni->type, mft_ni->name, mft_ni->name_len,\n\t\t\tCASE_SENSITIVE, 0, NULL, 0, ctx);\n\tif (unlikely(err)) {\n\t\tntfs_error(vol->sb, \"Failed to find first attribute extent of \"\n\t\t\t\t\"mft data attribute.\");\n\t\tntfs_attr_put_search_ctx(ctx);\n\t\tunmap_mft_record(mft_ni);\n\t\tgoto undo_data_init;\n\t}\n\ta = ctx->attr;\n\tread_lock_irqsave(&mft_ni->size_lock, flags);\n\ta->data.non_resident.initialized_size =\n\t\t\tcpu_to_sle64(mft_ni->initialized_size);\n\ta->data.non_resident.data_size =\n\t\t\tcpu_to_sle64(i_size_read(vol->mft_ino));\n\tread_unlock_irqrestore(&mft_ni->size_lock, flags);\n\t/* Ensure the changes make it to disk. */\n\tflush_dcache_mft_record_page(ctx->ntfs_ino);\n\tmark_mft_record_dirty(ctx->ntfs_ino);\n\tntfs_attr_put_search_ctx(ctx);\n\tunmap_mft_record(mft_ni);\n\tread_lock_irqsave(&mft_ni->size_lock, flags);\n\tntfs_debug(\"Status of mft data after mft record initialization: \"\n\t\t\t\"allocated_size 0x%llx, data_size 0x%llx, \"\n\t\t\t\"initialized_size 0x%llx.\",\n\t\t\t(long long)mft_ni->allocated_size,\n\t\t\t(long long)i_size_read(vol->mft_ino),\n\t\t\t(long long)mft_ni->initialized_size);\n\tBUG_ON(i_size_read(vol->mft_ino) > mft_ni->allocated_size);\n\tBUG_ON(mft_ni->initialized_size > i_size_read(vol->mft_ino));\n\tread_unlock_irqrestore(&mft_ni->size_lock, flags);\nmft_rec_already_initialized:\n\t/*\n\t * We can finally drop the mft bitmap lock as the mft data attribute\n\t * has been fully updated.  The only disparity left is that the\n\t * allocated mft record still needs to be marked as in use to match the\n\t * set bit in the mft bitmap but this is actually not a problem since\n\t * this mft record is not referenced from anywhere yet and the fact\n\t * that it is allocated in the mft bitmap means that no-one will try to\n\t * allocate it either.\n\t */\n\tup_write(&vol->mftbmp_lock);\n\t/*\n\t * We now have allocated and initialized the mft record.  Calculate the\n\t * index of and the offset within the page cache page the record is in.\n\t */\n\tindex = bit << vol->mft_record_size_bits >> PAGE_CACHE_SHIFT;\n\tofs = (bit << vol->mft_record_size_bits) & ~PAGE_CACHE_MASK;\n\t/* Read, map, and pin the page containing the mft record. */\n\tpage = ntfs_map_page(vol->mft_ino->i_mapping, index);\n\tif (IS_ERR(page)) {\n\t\tntfs_error(vol->sb, \"Failed to map page containing allocated \"\n\t\t\t\t\"mft record 0x%llx.\", (long long)bit);\n\t\terr = PTR_ERR(page);\n\t\tgoto undo_mftbmp_alloc;\n\t}\n\tlock_page(page);\n\tBUG_ON(!PageUptodate(page));\n\tClearPageUptodate(page);\n\tm = (MFT_RECORD*)((u8*)page_address(page) + ofs);\n\t/* If we just formatted the mft record no need to do it again. */\n\tif (!record_formatted) {\n\t\t/* Sanity check that the mft record is really not in use. */\n\t\tif (ntfs_is_file_record(m->magic) &&\n\t\t\t\t(m->flags & MFT_RECORD_IN_USE)) {\n\t\t\tntfs_error(vol->sb, \"Mft record 0x%llx was marked \"\n\t\t\t\t\t\"free in mft bitmap but is marked \"\n\t\t\t\t\t\"used itself.  Corrupt filesystem.  \"\n\t\t\t\t\t\"Unmount and run chkdsk.\",\n\t\t\t\t\t(long long)bit);\n\t\t\terr = -EIO;\n\t\t\tSetPageUptodate(page);\n\t\t\tunlock_page(page);\n\t\t\tntfs_unmap_page(page);\n\t\t\tNVolSetErrors(vol);\n\t\t\tgoto undo_mftbmp_alloc;\n\t\t}\n\t\t/*\n\t\t * We need to (re-)format the mft record, preserving the\n\t\t * sequence number if it is not zero as well as the update\n\t\t * sequence number if it is not zero or -1 (0xffff).  This\n\t\t * means we do not need to care whether or not something went\n\t\t * wrong with the previous mft record.\n\t\t */\n\t\tseq_no = m->sequence_number;\n\t\tusn = *(le16*)((u8*)m + le16_to_cpu(m->usa_ofs));\n\t\terr = ntfs_mft_record_layout(vol, bit, m);\n\t\tif (unlikely(err)) {\n\t\t\tntfs_error(vol->sb, \"Failed to layout allocated mft \"\n\t\t\t\t\t\"record 0x%llx.\", (long long)bit);\n\t\t\tSetPageUptodate(page);\n\t\t\tunlock_page(page);\n\t\t\tntfs_unmap_page(page);\n\t\t\tgoto undo_mftbmp_alloc;\n\t\t}\n\t\tif (seq_no)\n\t\t\tm->sequence_number = seq_no;\n\t\tif (usn && le16_to_cpu(usn) != 0xffff)\n\t\t\t*(le16*)((u8*)m + le16_to_cpu(m->usa_ofs)) = usn;\n\t}\n\t/* Set the mft record itself in use. */\n\tm->flags |= MFT_RECORD_IN_USE;\n\tif (S_ISDIR(mode))\n\t\tm->flags |= MFT_RECORD_IS_DIRECTORY;\n\tflush_dcache_page(page);\n\tSetPageUptodate(page);\n\tif (base_ni) {\n\t\tMFT_RECORD *m_tmp;\n\n\t\t/*\n\t\t * Setup the base mft record in the extent mft record.  This\n\t\t * completes initialization of the allocated extent mft record\n\t\t * and we can simply use it with map_extent_mft_record().\n\t\t */\n\t\tm->base_mft_record = MK_LE_MREF(base_ni->mft_no,\n\t\t\t\tbase_ni->seq_no);\n\t\t/*\n\t\t * Allocate an extent inode structure for the new mft record,\n\t\t * attach it to the base inode @base_ni and map, pin, and lock\n\t\t * its, i.e. the allocated, mft record.\n\t\t */\n\t\tm_tmp = map_extent_mft_record(base_ni, bit, &ni);\n\t\tif (IS_ERR(m_tmp)) {\n\t\t\tntfs_error(vol->sb, \"Failed to map allocated extent \"\n\t\t\t\t\t\"mft record 0x%llx.\", (long long)bit);\n\t\t\terr = PTR_ERR(m_tmp);\n\t\t\t/* Set the mft record itself not in use. */\n\t\t\tm->flags &= cpu_to_le16(\n\t\t\t\t\t~le16_to_cpu(MFT_RECORD_IN_USE));\n\t\t\tflush_dcache_page(page);\n\t\t\t/* Make sure the mft record is written out to disk. */\n\t\t\tmark_ntfs_record_dirty(page, ofs);\n\t\t\tunlock_page(page);\n\t\t\tntfs_unmap_page(page);\n\t\t\tgoto undo_mftbmp_alloc;\n\t\t}\n\t\tBUG_ON(m != m_tmp);\n\t\t/*\n\t\t * Make sure the allocated mft record is written out to disk.\n\t\t * No need to set the inode dirty because the caller is going\n\t\t * to do that anyway after finishing with the new extent mft\n\t\t * record (e.g. at a minimum a new attribute will be added to\n\t\t * the mft record.\n\t\t */\n\t\tmark_ntfs_record_dirty(page, ofs);\n\t\tunlock_page(page);\n\t\t/*\n\t\t * Need to unmap the page since map_extent_mft_record() mapped\n\t\t * it as well so we have it mapped twice at the moment.\n\t\t */\n\t\tntfs_unmap_page(page);\n\t} else {\n\t\t/*\n\t\t * Allocate a new VFS inode and set it up.  NOTE: @vi->i_nlink\n\t\t * is set to 1 but the mft record->link_count is 0.  The caller\n\t\t * needs to bear this in mind.\n\t\t */\n\t\tvi = new_inode(vol->sb);\n\t\tif (unlikely(!vi)) {\n\t\t\terr = -ENOMEM;\n\t\t\t/* Set the mft record itself not in use. */\n\t\t\tm->flags &= cpu_to_le16(\n\t\t\t\t\t~le16_to_cpu(MFT_RECORD_IN_USE));\n\t\t\tflush_dcache_page(page);\n\t\t\t/* Make sure the mft record is written out to disk. */\n\t\t\tmark_ntfs_record_dirty(page, ofs);\n\t\t\tunlock_page(page);\n\t\t\tntfs_unmap_page(page);\n\t\t\tgoto undo_mftbmp_alloc;\n\t\t}\n\t\tvi->i_ino = bit;\n\t\t/*\n\t\t * This is for checking whether an inode has changed w.r.t. a\n\t\t * file so that the file can be updated if necessary (compare\n\t\t * with f_version).\n\t\t */\n\t\tvi->i_version = 1;\n\n\t\t/* The owner and group come from the ntfs volume. */\n\t\tvi->i_uid = vol->uid;\n\t\tvi->i_gid = vol->gid;\n\n\t\t/* Initialize the ntfs specific part of @vi. */\n\t\tntfs_init_big_inode(vi);\n\t\tni = NTFS_I(vi);\n\t\t/*\n\t\t * Set the appropriate mode, attribute type, and name.  For\n\t\t * directories, also setup the index values to the defaults.\n\t\t */\n\t\tif (S_ISDIR(mode)) {\n\t\t\tvi->i_mode = S_IFDIR | S_IRWXUGO;\n\t\t\tvi->i_mode &= ~vol->dmask;\n\n\t\t\tNInoSetMstProtected(ni);\n\t\t\tni->type = AT_INDEX_ALLOCATION;\n\t\t\tni->name = I30;\n\t\t\tni->name_len = 4;\n\n\t\t\tni->itype.index.block_size = 4096;\n\t\t\tni->itype.index.block_size_bits = ntfs_ffs(4096) - 1;\n\t\t\tni->itype.index.collation_rule = COLLATION_FILE_NAME;\n\t\t\tif (vol->cluster_size <= ni->itype.index.block_size) {\n\t\t\t\tni->itype.index.vcn_size = vol->cluster_size;\n\t\t\t\tni->itype.index.vcn_size_bits =\n\t\t\t\t\t\tvol->cluster_size_bits;\n\t\t\t} else {\n\t\t\t\tni->itype.index.vcn_size = vol->sector_size;\n\t\t\t\tni->itype.index.vcn_size_bits =\n\t\t\t\t\t\tvol->sector_size_bits;\n\t\t\t}\n\t\t} else {\n\t\t\tvi->i_mode = S_IFREG | S_IRWXUGO;\n\t\t\tvi->i_mode &= ~vol->fmask;\n\n\t\t\tni->type = AT_DATA;\n\t\t\tni->name = NULL;\n\t\t\tni->name_len = 0;\n\t\t}\n\t\tif (IS_RDONLY(vi))\n\t\t\tvi->i_mode &= ~S_IWUGO;\n\n\t\t/* Set the inode times to the current time. */\n\t\tvi->i_atime = vi->i_mtime = vi->i_ctime =\n\t\t\tcurrent_fs_time(vi->i_sb);\n\t\t/*\n\t\t * Set the file size to 0, the ntfs inode sizes are set to 0 by\n\t\t * the call to ntfs_init_big_inode() below.\n\t\t */\n\t\tvi->i_size = 0;\n\t\tvi->i_blocks = 0;\n\n\t\t/* Set the sequence number. */\n\t\tvi->i_generation = ni->seq_no = le16_to_cpu(m->sequence_number);\n\t\t/*\n\t\t * Manually map, pin, and lock the mft record as we already\n\t\t * have its page mapped and it is very easy to do.\n\t\t */\n\t\tatomic_inc(&ni->count);\n\t\tmutex_lock(&ni->mrec_lock);\n\t\tni->page = page;\n\t\tni->page_ofs = ofs;\n\t\t/*\n\t\t * Make sure the allocated mft record is written out to disk.\n\t\t * NOTE: We do not set the ntfs inode dirty because this would\n\t\t * fail in ntfs_write_inode() because the inode does not have a\n\t\t * standard information attribute yet.  Also, there is no need\n\t\t * to set the inode dirty because the caller is going to do\n\t\t * that anyway after finishing with the new mft record (e.g. at\n\t\t * a minimum some new attributes will be added to the mft\n\t\t * record.\n\t\t */\n\t\tmark_ntfs_record_dirty(page, ofs);\n\t\tunlock_page(page);\n\n\t\t/* Add the inode to the inode hash for the superblock. */\n\t\tinsert_inode_hash(vi);\n\n\t\t/* Update the default mft allocation position. */\n\t\tvol->mft_data_pos = bit + 1;\n\t}\n\t/*\n\t * Return the opened, allocated inode of the allocated mft record as\n\t * well as the mapped, pinned, and locked mft record.\n\t */\n\tntfs_debug(\"Returning opened, allocated %sinode 0x%llx.\",\n\t\t\tbase_ni ? \"extent \" : \"\", (long long)bit);\n\t*mrec = m;\n\treturn ni;\nundo_data_init:\n\twrite_lock_irqsave(&mft_ni->size_lock, flags);\n\tmft_ni->initialized_size = old_data_initialized;\n\ti_size_write(vol->mft_ino, old_data_size);\n\twrite_unlock_irqrestore(&mft_ni->size_lock, flags);\n\tgoto undo_mftbmp_alloc_nolock;\nundo_mftbmp_alloc:\n\tdown_write(&vol->mftbmp_lock);\nundo_mftbmp_alloc_nolock:\n\tif (ntfs_bitmap_clear_bit(vol->mftbmp_ino, bit)) {\n\t\tntfs_error(vol->sb, \"Failed to clear bit in mft bitmap.%s\", es);\n\t\tNVolSetErrors(vol);\n\t}\n\tup_write(&vol->mftbmp_lock);\nerr_out:\n\treturn ERR_PTR(err);\nmax_err_out:\n\tntfs_warning(vol->sb, \"Cannot allocate mft record because the maximum \"\n\t\t\t\"number of inodes (2^32) has already been reached.\");\n\tup_write(&vol->mftbmp_lock);\n\treturn ERR_PTR(-ENOSPC);\n}"
  },
  {
    "function_name": "ntfs_mft_record_format",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/mft.c",
    "lines": "2091-2151",
    "snippet": "static int ntfs_mft_record_format(const ntfs_volume *vol, const s64 mft_no)\n{\n\tloff_t i_size;\n\tstruct inode *mft_vi = vol->mft_ino;\n\tstruct page *page;\n\tMFT_RECORD *m;\n\tpgoff_t index, end_index;\n\tunsigned int ofs;\n\tint err;\n\n\tntfs_debug(\"Entering for mft record 0x%llx.\", (long long)mft_no);\n\t/*\n\t * The index into the page cache and the offset within the page cache\n\t * page of the wanted mft record.\n\t */\n\tindex = mft_no << vol->mft_record_size_bits >> PAGE_CACHE_SHIFT;\n\tofs = (mft_no << vol->mft_record_size_bits) & ~PAGE_CACHE_MASK;\n\t/* The maximum valid index into the page cache for $MFT's data. */\n\ti_size = i_size_read(mft_vi);\n\tend_index = i_size >> PAGE_CACHE_SHIFT;\n\tif (unlikely(index >= end_index)) {\n\t\tif (unlikely(index > end_index || ofs + vol->mft_record_size >=\n\t\t\t\t(i_size & ~PAGE_CACHE_MASK))) {\n\t\t\tntfs_error(vol->sb, \"Tried to format non-existing mft \"\n\t\t\t\t\t\"record 0x%llx.\", (long long)mft_no);\n\t\t\treturn -ENOENT;\n\t\t}\n\t}\n\t/* Read, map, and pin the page containing the mft record. */\n\tpage = ntfs_map_page(mft_vi->i_mapping, index);\n\tif (IS_ERR(page)) {\n\t\tntfs_error(vol->sb, \"Failed to map page containing mft record \"\n\t\t\t\t\"to format 0x%llx.\", (long long)mft_no);\n\t\treturn PTR_ERR(page);\n\t}\n\tlock_page(page);\n\tBUG_ON(!PageUptodate(page));\n\tClearPageUptodate(page);\n\tm = (MFT_RECORD*)((u8*)page_address(page) + ofs);\n\terr = ntfs_mft_record_layout(vol, mft_no, m);\n\tif (unlikely(err)) {\n\t\tntfs_error(vol->sb, \"Failed to layout mft record 0x%llx.\",\n\t\t\t\t(long long)mft_no);\n\t\tSetPageUptodate(page);\n\t\tunlock_page(page);\n\t\tntfs_unmap_page(page);\n\t\treturn err;\n\t}\n\tflush_dcache_page(page);\n\tSetPageUptodate(page);\n\tunlock_page(page);\n\t/*\n\t * Make sure the mft record is written out to disk.  We could use\n\t * ilookup5() to check if an inode is in icache and so on but this is\n\t * unnecessary as ntfs_writepage() will write the dirty record anyway.\n\t */\n\tmark_ntfs_record_dirty(page, ofs);\n\tntfs_unmap_page(page);\n\tntfs_debug(\"Done.\");\n\treturn 0;\n}",
    "includes": [
      "#include \"ntfs.h\"",
      "#include \"mft.h\"",
      "#include \"malloc.h\"",
      "#include \"lcnalloc.h\"",
      "#include \"dir.h\"",
      "#include \"debug.h\"",
      "#include \"bitmap.h\"",
      "#include \"aops.h\"",
      "#include \"attrib.h\"",
      "#include <linux/swap.h>",
      "#include <linux/slab.h>",
      "#include <linux/buffer_head.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ntfs_debug",
          "args": [
            "\"Done.\""
          ],
          "line": 2149
        },
        "resolved": true,
        "details": {
          "function_name": "ntfs_debug_dump_runlist",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/debug.c",
          "lines": "134-171",
          "snippet": "void ntfs_debug_dump_runlist(const runlist_element *rl)\n{\n\tint i;\n\tconst char *lcn_str[5] = { \"LCN_HOLE         \", \"LCN_RL_NOT_MAPPED\",\n\t\t\t\t   \"LCN_ENOENT       \", \"LCN_unknown      \" };\n\n\tif (!debug_msgs)\n\t\treturn;\n\tpr_debug(\"Dumping runlist (values in hex):\\n\");\n\tif (!rl) {\n\t\tpr_debug(\"Run list not present.\\n\");\n\t\treturn;\n\t}\n\tpr_debug(\"VCN              LCN               Run length\\n\");\n\tfor (i = 0; ; i++) {\n\t\tLCN lcn = (rl + i)->lcn;\n\n\t\tif (lcn < (LCN)0) {\n\t\t\tint index = -lcn - 1;\n\n\t\t\tif (index > -LCN_ENOENT - 1)\n\t\t\t\tindex = 3;\n\t\t\tpr_debug(\"%-16Lx %s %-16Lx%s\\n\",\n\t\t\t\t\t(long long)(rl + i)->vcn, lcn_str[index],\n\t\t\t\t\t(long long)(rl + i)->length,\n\t\t\t\t\t(rl + i)->length ? \"\" :\n\t\t\t\t\t\t\" (runlist end)\");\n\t\t} else\n\t\t\tpr_debug(\"%-16Lx %-16Lx  %-16Lx%s\\n\",\n\t\t\t\t\t(long long)(rl + i)->vcn,\n\t\t\t\t\t(long long)(rl + i)->lcn,\n\t\t\t\t\t(long long)(rl + i)->length,\n\t\t\t\t\t(rl + i)->length ? \"\" :\n\t\t\t\t\t\t\" (runlist end)\");\n\t\tif (!(rl + i)->length)\n\t\t\tbreak;\n\t}\n}",
          "includes": [
            "#include \"debug.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"debug.h\"\n\nvoid ntfs_debug_dump_runlist(const runlist_element *rl)\n{\n\tint i;\n\tconst char *lcn_str[5] = { \"LCN_HOLE         \", \"LCN_RL_NOT_MAPPED\",\n\t\t\t\t   \"LCN_ENOENT       \", \"LCN_unknown      \" };\n\n\tif (!debug_msgs)\n\t\treturn;\n\tpr_debug(\"Dumping runlist (values in hex):\\n\");\n\tif (!rl) {\n\t\tpr_debug(\"Run list not present.\\n\");\n\t\treturn;\n\t}\n\tpr_debug(\"VCN              LCN               Run length\\n\");\n\tfor (i = 0; ; i++) {\n\t\tLCN lcn = (rl + i)->lcn;\n\n\t\tif (lcn < (LCN)0) {\n\t\t\tint index = -lcn - 1;\n\n\t\t\tif (index > -LCN_ENOENT - 1)\n\t\t\t\tindex = 3;\n\t\t\tpr_debug(\"%-16Lx %s %-16Lx%s\\n\",\n\t\t\t\t\t(long long)(rl + i)->vcn, lcn_str[index],\n\t\t\t\t\t(long long)(rl + i)->length,\n\t\t\t\t\t(rl + i)->length ? \"\" :\n\t\t\t\t\t\t\" (runlist end)\");\n\t\t} else\n\t\t\tpr_debug(\"%-16Lx %-16Lx  %-16Lx%s\\n\",\n\t\t\t\t\t(long long)(rl + i)->vcn,\n\t\t\t\t\t(long long)(rl + i)->lcn,\n\t\t\t\t\t(long long)(rl + i)->length,\n\t\t\t\t\t(rl + i)->length ? \"\" :\n\t\t\t\t\t\t\" (runlist end)\");\n\t\tif (!(rl + i)->length)\n\t\t\tbreak;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ntfs_unmap_page",
          "args": [
            "page"
          ],
          "line": 2148
        },
        "resolved": true,
        "details": {
          "function_name": "ntfs_unmap_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/aops.h",
          "lines": "40-44",
          "snippet": "static inline void ntfs_unmap_page(struct page *page)\n{\n\tkunmap(page);\n\tpage_cache_release(page);\n}",
          "includes": [
            "#include \"inode.h\"",
            "#include <linux/fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"inode.h\"\n#include <linux/fs.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n\nstatic inline void ntfs_unmap_page(struct page *page)\n{\n\tkunmap(page);\n\tpage_cache_release(page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mark_ntfs_record_dirty",
          "args": [
            "page",
            "ofs"
          ],
          "line": 2147
        },
        "resolved": true,
        "details": {
          "function_name": "mark_ntfs_record_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/aops.c",
          "lines": "1729-1775",
          "snippet": "void mark_ntfs_record_dirty(struct page *page, const unsigned int ofs) {\n\tstruct address_space *mapping = page->mapping;\n\tntfs_inode *ni = NTFS_I(mapping->host);\n\tstruct buffer_head *bh, *head, *buffers_to_free = NULL;\n\tunsigned int end, bh_size, bh_ofs;\n\n\tBUG_ON(!PageUptodate(page));\n\tend = ofs + ni->itype.index.block_size;\n\tbh_size = VFS_I(ni)->i_sb->s_blocksize;\n\tspin_lock(&mapping->private_lock);\n\tif (unlikely(!page_has_buffers(page))) {\n\t\tspin_unlock(&mapping->private_lock);\n\t\tbh = head = alloc_page_buffers(page, bh_size, 1);\n\t\tspin_lock(&mapping->private_lock);\n\t\tif (likely(!page_has_buffers(page))) {\n\t\t\tstruct buffer_head *tail;\n\n\t\t\tdo {\n\t\t\t\tset_buffer_uptodate(bh);\n\t\t\t\ttail = bh;\n\t\t\t\tbh = bh->b_this_page;\n\t\t\t} while (bh);\n\t\t\ttail->b_this_page = head;\n\t\t\tattach_page_buffers(page, head);\n\t\t} else\n\t\t\tbuffers_to_free = bh;\n\t}\n\tbh = head = page_buffers(page);\n\tBUG_ON(!bh);\n\tdo {\n\t\tbh_ofs = bh_offset(bh);\n\t\tif (bh_ofs + bh_size <= ofs)\n\t\t\tcontinue;\n\t\tif (unlikely(bh_ofs >= end))\n\t\t\tbreak;\n\t\tset_buffer_dirty(bh);\n\t} while ((bh = bh->b_this_page) != head);\n\tspin_unlock(&mapping->private_lock);\n\t__set_page_dirty_nobuffers(page);\n\tif (unlikely(buffers_to_free)) {\n\t\tdo {\n\t\t\tbh = buffers_to_free->b_this_page;\n\t\t\tfree_buffer_head(buffers_to_free);\n\t\t\tbuffers_to_free = bh;\n\t\t} while (buffers_to_free);\n\t}\n}",
          "includes": [
            "#include \"ntfs.h\"",
            "#include \"types.h\"",
            "#include \"runlist.h\"",
            "#include \"mft.h\"",
            "#include \"inode.h\"",
            "#include \"debug.h\"",
            "#include \"attrib.h\"",
            "#include \"aops.h\"",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/writeback.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/gfp.h>",
            "#include <linux/fs.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ntfs.h\"\n#include \"types.h\"\n#include \"runlist.h\"\n#include \"mft.h\"\n#include \"inode.h\"\n#include \"debug.h\"\n#include \"attrib.h\"\n#include \"aops.h\"\n#include <linux/bit_spinlock.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/gfp.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n\nvoid mark_ntfs_record_dirty(struct page *page, const unsigned int ofs) {\n\tstruct address_space *mapping = page->mapping;\n\tntfs_inode *ni = NTFS_I(mapping->host);\n\tstruct buffer_head *bh, *head, *buffers_to_free = NULL;\n\tunsigned int end, bh_size, bh_ofs;\n\n\tBUG_ON(!PageUptodate(page));\n\tend = ofs + ni->itype.index.block_size;\n\tbh_size = VFS_I(ni)->i_sb->s_blocksize;\n\tspin_lock(&mapping->private_lock);\n\tif (unlikely(!page_has_buffers(page))) {\n\t\tspin_unlock(&mapping->private_lock);\n\t\tbh = head = alloc_page_buffers(page, bh_size, 1);\n\t\tspin_lock(&mapping->private_lock);\n\t\tif (likely(!page_has_buffers(page))) {\n\t\t\tstruct buffer_head *tail;\n\n\t\t\tdo {\n\t\t\t\tset_buffer_uptodate(bh);\n\t\t\t\ttail = bh;\n\t\t\t\tbh = bh->b_this_page;\n\t\t\t} while (bh);\n\t\t\ttail->b_this_page = head;\n\t\t\tattach_page_buffers(page, head);\n\t\t} else\n\t\t\tbuffers_to_free = bh;\n\t}\n\tbh = head = page_buffers(page);\n\tBUG_ON(!bh);\n\tdo {\n\t\tbh_ofs = bh_offset(bh);\n\t\tif (bh_ofs + bh_size <= ofs)\n\t\t\tcontinue;\n\t\tif (unlikely(bh_ofs >= end))\n\t\t\tbreak;\n\t\tset_buffer_dirty(bh);\n\t} while ((bh = bh->b_this_page) != head);\n\tspin_unlock(&mapping->private_lock);\n\t__set_page_dirty_nobuffers(page);\n\tif (unlikely(buffers_to_free)) {\n\t\tdo {\n\t\t\tbh = buffers_to_free->b_this_page;\n\t\t\tfree_buffer_head(buffers_to_free);\n\t\t\tbuffers_to_free = bh;\n\t\t} while (buffers_to_free);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlock_page",
          "args": [
            "page"
          ],
          "line": 2141
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_unlock_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/aops.c",
          "lines": "1127-1148",
          "snippet": "static void ocfs2_unlock_pages(struct ocfs2_write_ctxt *wc)\n{\n\tint i;\n\n\t/*\n\t * w_target_locked is only set to true in the page_mkwrite() case.\n\t * The intent is to allow us to lock the target page from write_begin()\n\t * to write_end(). The caller must hold a ref on w_target_page.\n\t */\n\tif (wc->w_target_locked) {\n\t\tBUG_ON(!wc->w_target_page);\n\t\tfor (i = 0; i < wc->w_num_pages; i++) {\n\t\t\tif (wc->w_target_page == wc->w_pages[i]) {\n\t\t\t\twc->w_pages[i] = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tmark_page_accessed(wc->w_target_page);\n\t\tpage_cache_release(wc->w_target_page);\n\t}\n\tocfs2_unlock_and_free_pages(wc->w_pages, wc->w_num_pages);\n}",
          "includes": [
            "#include \"sysfile.h\"",
            "#include \"namei.h\"",
            "#include \"dir.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"symlink.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/mpage.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/swap.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sysfile.h\"\n#include \"namei.h\"\n#include \"dir.h\"\n#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"symlink.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/mpage.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/swap.h>\n#include <asm/byteorder.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic void ocfs2_unlock_pages(struct ocfs2_write_ctxt *wc)\n{\n\tint i;\n\n\t/*\n\t * w_target_locked is only set to true in the page_mkwrite() case.\n\t * The intent is to allow us to lock the target page from write_begin()\n\t * to write_end(). The caller must hold a ref on w_target_page.\n\t */\n\tif (wc->w_target_locked) {\n\t\tBUG_ON(!wc->w_target_page);\n\t\tfor (i = 0; i < wc->w_num_pages; i++) {\n\t\t\tif (wc->w_target_page == wc->w_pages[i]) {\n\t\t\t\twc->w_pages[i] = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tmark_page_accessed(wc->w_target_page);\n\t\tpage_cache_release(wc->w_target_page);\n\t}\n\tocfs2_unlock_and_free_pages(wc->w_pages, wc->w_num_pages);\n}"
        }
      },
      {
        "call_info": {
          "callee": "SetPageUptodate",
          "args": [
            "page"
          ],
          "line": 2140
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "flush_dcache_page",
          "args": [
            "page"
          ],
          "line": 2139
        },
        "resolved": true,
        "details": {
          "function_name": "ntfs_index_entry_flush_dcache_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/index.h",
          "lines": "111-117",
          "snippet": "static inline void ntfs_index_entry_flush_dcache_page(ntfs_index_context *ictx)\n{\n\tif (ictx->is_in_root)\n\t\tflush_dcache_mft_record_page(ictx->actx->ntfs_ino);\n\telse\n\t\tflush_dcache_page(ictx->page);\n}",
          "includes": [
            "#include \"aops.h\"",
            "#include \"mft.h\"",
            "#include \"attrib.h\"",
            "#include \"inode.h\"",
            "#include \"layout.h\"",
            "#include \"types.h\"",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"aops.h\"\n#include \"mft.h\"\n#include \"attrib.h\"\n#include \"inode.h\"\n#include \"layout.h\"\n#include \"types.h\"\n#include <linux/fs.h>\n\nstatic inline void ntfs_index_entry_flush_dcache_page(ntfs_index_context *ictx)\n{\n\tif (ictx->is_in_root)\n\t\tflush_dcache_mft_record_page(ictx->actx->ntfs_ino);\n\telse\n\t\tflush_dcache_page(ictx->page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "SetPageUptodate",
          "args": [
            "page"
          ],
          "line": 2134
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntfs_error",
          "args": [
            "vol->sb",
            "\"Failed to layout mft record 0x%llx.\"",
            "(long long)mft_no"
          ],
          "line": 2132
        },
        "resolved": true,
        "details": {
          "function_name": "__ntfs_error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/debug.c",
          "lines": "86-108",
          "snippet": "void __ntfs_error(const char *function, const struct super_block *sb,\n\t\tconst char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\tint flen = 0;\n\n#ifndef DEBUG\n\tif (!printk_ratelimit())\n\t\treturn;\n#endif\n\tif (function)\n\t\tflen = strlen(function);\n\tva_start(args, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\tif (sb)\n\t\tpr_err(\"(device %s): %s(): %pV\\n\",\n\t\t       sb->s_id, flen ? function : \"\", &vaf);\n\telse\n\t\tpr_err(\"%s(): %pV\\n\", flen ? function : \"\", &vaf);\n\tva_end(args);\n}",
          "includes": [
            "#include \"debug.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"debug.h\"\n\nvoid __ntfs_error(const char *function, const struct super_block *sb,\n\t\tconst char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\tint flen = 0;\n\n#ifndef DEBUG\n\tif (!printk_ratelimit())\n\t\treturn;\n#endif\n\tif (function)\n\t\tflen = strlen(function);\n\tva_start(args, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\tif (sb)\n\t\tpr_err(\"(device %s): %s(): %pV\\n\",\n\t\t       sb->s_id, flen ? function : \"\", &vaf);\n\telse\n\t\tpr_err(\"%s(): %pV\\n\", flen ? function : \"\", &vaf);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "err"
          ],
          "line": 2131
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntfs_mft_record_layout",
          "args": [
            "vol",
            "mft_no",
            "m"
          ],
          "line": 2130
        },
        "resolved": true,
        "details": {
          "function_name": "ntfs_mft_record_layout",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/mft.c",
          "lines": "2012-2078",
          "snippet": "static int ntfs_mft_record_layout(const ntfs_volume *vol, const s64 mft_no,\n\t\tMFT_RECORD *m)\n{\n\tATTR_RECORD *a;\n\n\tntfs_debug(\"Entering for mft record 0x%llx.\", (long long)mft_no);\n\tif (mft_no >= (1ll << 32)) {\n\t\tntfs_error(vol->sb, \"Mft record number 0x%llx exceeds \"\n\t\t\t\t\"maximum of 2^32.\", (long long)mft_no);\n\t\treturn -ERANGE;\n\t}\n\t/* Start by clearing the whole mft record to gives us a clean slate. */\n\tmemset(m, 0, vol->mft_record_size);\n\t/* Aligned to 2-byte boundary. */\n\tif (vol->major_ver < 3 || (vol->major_ver == 3 && !vol->minor_ver))\n\t\tm->usa_ofs = cpu_to_le16((sizeof(MFT_RECORD_OLD) + 1) & ~1);\n\telse {\n\t\tm->usa_ofs = cpu_to_le16((sizeof(MFT_RECORD) + 1) & ~1);\n\t\t/*\n\t\t * Set the NTFS 3.1+ specific fields while we know that the\n\t\t * volume version is 3.1+.\n\t\t */\n\t\tm->reserved = 0;\n\t\tm->mft_record_number = cpu_to_le32((u32)mft_no);\n\t}\n\tm->magic = magic_FILE;\n\tif (vol->mft_record_size >= NTFS_BLOCK_SIZE)\n\t\tm->usa_count = cpu_to_le16(vol->mft_record_size /\n\t\t\t\tNTFS_BLOCK_SIZE + 1);\n\telse {\n\t\tm->usa_count = cpu_to_le16(1);\n\t\tntfs_warning(vol->sb, \"Sector size is bigger than mft record \"\n\t\t\t\t\"size.  Setting usa_count to 1.  If chkdsk \"\n\t\t\t\t\"reports this as corruption, please email \"\n\t\t\t\t\"linux-ntfs-dev@lists.sourceforge.net stating \"\n\t\t\t\t\"that you saw this message and that the \"\n\t\t\t\t\"modified filesystem created was corrupt.  \"\n\t\t\t\t\"Thank you.\");\n\t}\n\t/* Set the update sequence number to 1. */\n\t*(le16*)((u8*)m + le16_to_cpu(m->usa_ofs)) = cpu_to_le16(1);\n\tm->lsn = 0;\n\tm->sequence_number = cpu_to_le16(1);\n\tm->link_count = 0;\n\t/*\n\t * Place the attributes straight after the update sequence array,\n\t * aligned to 8-byte boundary.\n\t */\n\tm->attrs_offset = cpu_to_le16((le16_to_cpu(m->usa_ofs) +\n\t\t\t(le16_to_cpu(m->usa_count) << 1) + 7) & ~7);\n\tm->flags = 0;\n\t/*\n\t * Using attrs_offset plus eight bytes (for the termination attribute).\n\t * attrs_offset is already aligned to 8-byte boundary, so no need to\n\t * align again.\n\t */\n\tm->bytes_in_use = cpu_to_le32(le16_to_cpu(m->attrs_offset) + 8);\n\tm->bytes_allocated = cpu_to_le32(vol->mft_record_size);\n\tm->base_mft_record = 0;\n\tm->next_attr_instance = 0;\n\t/* Add the termination attribute. */\n\ta = (ATTR_RECORD*)((u8*)m + le16_to_cpu(m->attrs_offset));\n\ta->type = AT_END;\n\ta->length = 0;\n\tntfs_debug(\"Done.\");\n\treturn 0;\n}",
          "includes": [
            "#include \"ntfs.h\"",
            "#include \"mft.h\"",
            "#include \"malloc.h\"",
            "#include \"lcnalloc.h\"",
            "#include \"dir.h\"",
            "#include \"debug.h\"",
            "#include \"bitmap.h\"",
            "#include \"aops.h\"",
            "#include \"attrib.h\"",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ntfs.h\"\n#include \"mft.h\"\n#include \"malloc.h\"\n#include \"lcnalloc.h\"\n#include \"dir.h\"\n#include \"debug.h\"\n#include \"bitmap.h\"\n#include \"aops.h\"\n#include \"attrib.h\"\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n\nstatic int ntfs_mft_record_layout(const ntfs_volume *vol, const s64 mft_no,\n\t\tMFT_RECORD *m)\n{\n\tATTR_RECORD *a;\n\n\tntfs_debug(\"Entering for mft record 0x%llx.\", (long long)mft_no);\n\tif (mft_no >= (1ll << 32)) {\n\t\tntfs_error(vol->sb, \"Mft record number 0x%llx exceeds \"\n\t\t\t\t\"maximum of 2^32.\", (long long)mft_no);\n\t\treturn -ERANGE;\n\t}\n\t/* Start by clearing the whole mft record to gives us a clean slate. */\n\tmemset(m, 0, vol->mft_record_size);\n\t/* Aligned to 2-byte boundary. */\n\tif (vol->major_ver < 3 || (vol->major_ver == 3 && !vol->minor_ver))\n\t\tm->usa_ofs = cpu_to_le16((sizeof(MFT_RECORD_OLD) + 1) & ~1);\n\telse {\n\t\tm->usa_ofs = cpu_to_le16((sizeof(MFT_RECORD) + 1) & ~1);\n\t\t/*\n\t\t * Set the NTFS 3.1+ specific fields while we know that the\n\t\t * volume version is 3.1+.\n\t\t */\n\t\tm->reserved = 0;\n\t\tm->mft_record_number = cpu_to_le32((u32)mft_no);\n\t}\n\tm->magic = magic_FILE;\n\tif (vol->mft_record_size >= NTFS_BLOCK_SIZE)\n\t\tm->usa_count = cpu_to_le16(vol->mft_record_size /\n\t\t\t\tNTFS_BLOCK_SIZE + 1);\n\telse {\n\t\tm->usa_count = cpu_to_le16(1);\n\t\tntfs_warning(vol->sb, \"Sector size is bigger than mft record \"\n\t\t\t\t\"size.  Setting usa_count to 1.  If chkdsk \"\n\t\t\t\t\"reports this as corruption, please email \"\n\t\t\t\t\"linux-ntfs-dev@lists.sourceforge.net stating \"\n\t\t\t\t\"that you saw this message and that the \"\n\t\t\t\t\"modified filesystem created was corrupt.  \"\n\t\t\t\t\"Thank you.\");\n\t}\n\t/* Set the update sequence number to 1. */\n\t*(le16*)((u8*)m + le16_to_cpu(m->usa_ofs)) = cpu_to_le16(1);\n\tm->lsn = 0;\n\tm->sequence_number = cpu_to_le16(1);\n\tm->link_count = 0;\n\t/*\n\t * Place the attributes straight after the update sequence array,\n\t * aligned to 8-byte boundary.\n\t */\n\tm->attrs_offset = cpu_to_le16((le16_to_cpu(m->usa_ofs) +\n\t\t\t(le16_to_cpu(m->usa_count) << 1) + 7) & ~7);\n\tm->flags = 0;\n\t/*\n\t * Using attrs_offset plus eight bytes (for the termination attribute).\n\t * attrs_offset is already aligned to 8-byte boundary, so no need to\n\t * align again.\n\t */\n\tm->bytes_in_use = cpu_to_le32(le16_to_cpu(m->attrs_offset) + 8);\n\tm->bytes_allocated = cpu_to_le32(vol->mft_record_size);\n\tm->base_mft_record = 0;\n\tm->next_attr_instance = 0;\n\t/* Add the termination attribute. */\n\ta = (ATTR_RECORD*)((u8*)m + le16_to_cpu(m->attrs_offset));\n\ta->type = AT_END;\n\ta->length = 0;\n\tntfs_debug(\"Done.\");\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "page_address",
          "args": [
            "page"
          ],
          "line": 2129
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ClearPageUptodate",
          "args": [
            "page"
          ],
          "line": 2128
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!PageUptodate(page)"
          ],
          "line": 2127
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageUptodate",
          "args": [
            "page"
          ],
          "line": 2127
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "page"
          ],
          "line": 2124
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "page"
          ],
          "line": 2121
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntfs_map_page",
          "args": [
            "mft_vi->i_mapping",
            "index"
          ],
          "line": 2120
        },
        "resolved": true,
        "details": {
          "function_name": "ntfs_map_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/aops.h",
          "lines": "86-99",
          "snippet": "static inline struct page *ntfs_map_page(struct address_space *mapping,\n\t\tunsigned long index)\n{\n\tstruct page *page = read_mapping_page(mapping, index, NULL);\n\n\tif (!IS_ERR(page)) {\n\t\tkmap(page);\n\t\tif (!PageError(page))\n\t\t\treturn page;\n\t\tntfs_unmap_page(page);\n\t\treturn ERR_PTR(-EIO);\n\t}\n\treturn page;\n}",
          "includes": [
            "#include \"inode.h\"",
            "#include <linux/fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"inode.h\"\n#include <linux/fs.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n\nstatic inline struct page *ntfs_map_page(struct address_space *mapping,\n\t\tunsigned long index)\n{\n\tstruct page *page = read_mapping_page(mapping, index, NULL);\n\n\tif (!IS_ERR(page)) {\n\t\tkmap(page);\n\t\tif (!PageError(page))\n\t\t\treturn page;\n\t\tntfs_unmap_page(page);\n\t\treturn ERR_PTR(-EIO);\n\t}\n\treturn page;\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "index > end_index || ofs + vol->mft_record_size >=\n\t\t\t\t(i_size & ~PAGE_CACHE_MASK)"
          ],
          "line": 2112
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "index >= end_index"
          ],
          "line": 2111
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "i_size_read",
          "args": [
            "mft_vi"
          ],
          "line": 2109
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntfs_debug",
          "args": [
            "\"Entering for mft record 0x%llx.\"",
            "(long long)mft_no"
          ],
          "line": 2101
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ntfs.h\"\n#include \"mft.h\"\n#include \"malloc.h\"\n#include \"lcnalloc.h\"\n#include \"dir.h\"\n#include \"debug.h\"\n#include \"bitmap.h\"\n#include \"aops.h\"\n#include \"attrib.h\"\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n\nstatic int ntfs_mft_record_format(const ntfs_volume *vol, const s64 mft_no)\n{\n\tloff_t i_size;\n\tstruct inode *mft_vi = vol->mft_ino;\n\tstruct page *page;\n\tMFT_RECORD *m;\n\tpgoff_t index, end_index;\n\tunsigned int ofs;\n\tint err;\n\n\tntfs_debug(\"Entering for mft record 0x%llx.\", (long long)mft_no);\n\t/*\n\t * The index into the page cache and the offset within the page cache\n\t * page of the wanted mft record.\n\t */\n\tindex = mft_no << vol->mft_record_size_bits >> PAGE_CACHE_SHIFT;\n\tofs = (mft_no << vol->mft_record_size_bits) & ~PAGE_CACHE_MASK;\n\t/* The maximum valid index into the page cache for $MFT's data. */\n\ti_size = i_size_read(mft_vi);\n\tend_index = i_size >> PAGE_CACHE_SHIFT;\n\tif (unlikely(index >= end_index)) {\n\t\tif (unlikely(index > end_index || ofs + vol->mft_record_size >=\n\t\t\t\t(i_size & ~PAGE_CACHE_MASK))) {\n\t\t\tntfs_error(vol->sb, \"Tried to format non-existing mft \"\n\t\t\t\t\t\"record 0x%llx.\", (long long)mft_no);\n\t\t\treturn -ENOENT;\n\t\t}\n\t}\n\t/* Read, map, and pin the page containing the mft record. */\n\tpage = ntfs_map_page(mft_vi->i_mapping, index);\n\tif (IS_ERR(page)) {\n\t\tntfs_error(vol->sb, \"Failed to map page containing mft record \"\n\t\t\t\t\"to format 0x%llx.\", (long long)mft_no);\n\t\treturn PTR_ERR(page);\n\t}\n\tlock_page(page);\n\tBUG_ON(!PageUptodate(page));\n\tClearPageUptodate(page);\n\tm = (MFT_RECORD*)((u8*)page_address(page) + ofs);\n\terr = ntfs_mft_record_layout(vol, mft_no, m);\n\tif (unlikely(err)) {\n\t\tntfs_error(vol->sb, \"Failed to layout mft record 0x%llx.\",\n\t\t\t\t(long long)mft_no);\n\t\tSetPageUptodate(page);\n\t\tunlock_page(page);\n\t\tntfs_unmap_page(page);\n\t\treturn err;\n\t}\n\tflush_dcache_page(page);\n\tSetPageUptodate(page);\n\tunlock_page(page);\n\t/*\n\t * Make sure the mft record is written out to disk.  We could use\n\t * ilookup5() to check if an inode is in icache and so on but this is\n\t * unnecessary as ntfs_writepage() will write the dirty record anyway.\n\t */\n\tmark_ntfs_record_dirty(page, ofs);\n\tntfs_unmap_page(page);\n\tntfs_debug(\"Done.\");\n\treturn 0;\n}"
  },
  {
    "function_name": "ntfs_mft_record_layout",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/mft.c",
    "lines": "2012-2078",
    "snippet": "static int ntfs_mft_record_layout(const ntfs_volume *vol, const s64 mft_no,\n\t\tMFT_RECORD *m)\n{\n\tATTR_RECORD *a;\n\n\tntfs_debug(\"Entering for mft record 0x%llx.\", (long long)mft_no);\n\tif (mft_no >= (1ll << 32)) {\n\t\tntfs_error(vol->sb, \"Mft record number 0x%llx exceeds \"\n\t\t\t\t\"maximum of 2^32.\", (long long)mft_no);\n\t\treturn -ERANGE;\n\t}\n\t/* Start by clearing the whole mft record to gives us a clean slate. */\n\tmemset(m, 0, vol->mft_record_size);\n\t/* Aligned to 2-byte boundary. */\n\tif (vol->major_ver < 3 || (vol->major_ver == 3 && !vol->minor_ver))\n\t\tm->usa_ofs = cpu_to_le16((sizeof(MFT_RECORD_OLD) + 1) & ~1);\n\telse {\n\t\tm->usa_ofs = cpu_to_le16((sizeof(MFT_RECORD) + 1) & ~1);\n\t\t/*\n\t\t * Set the NTFS 3.1+ specific fields while we know that the\n\t\t * volume version is 3.1+.\n\t\t */\n\t\tm->reserved = 0;\n\t\tm->mft_record_number = cpu_to_le32((u32)mft_no);\n\t}\n\tm->magic = magic_FILE;\n\tif (vol->mft_record_size >= NTFS_BLOCK_SIZE)\n\t\tm->usa_count = cpu_to_le16(vol->mft_record_size /\n\t\t\t\tNTFS_BLOCK_SIZE + 1);\n\telse {\n\t\tm->usa_count = cpu_to_le16(1);\n\t\tntfs_warning(vol->sb, \"Sector size is bigger than mft record \"\n\t\t\t\t\"size.  Setting usa_count to 1.  If chkdsk \"\n\t\t\t\t\"reports this as corruption, please email \"\n\t\t\t\t\"linux-ntfs-dev@lists.sourceforge.net stating \"\n\t\t\t\t\"that you saw this message and that the \"\n\t\t\t\t\"modified filesystem created was corrupt.  \"\n\t\t\t\t\"Thank you.\");\n\t}\n\t/* Set the update sequence number to 1. */\n\t*(le16*)((u8*)m + le16_to_cpu(m->usa_ofs)) = cpu_to_le16(1);\n\tm->lsn = 0;\n\tm->sequence_number = cpu_to_le16(1);\n\tm->link_count = 0;\n\t/*\n\t * Place the attributes straight after the update sequence array,\n\t * aligned to 8-byte boundary.\n\t */\n\tm->attrs_offset = cpu_to_le16((le16_to_cpu(m->usa_ofs) +\n\t\t\t(le16_to_cpu(m->usa_count) << 1) + 7) & ~7);\n\tm->flags = 0;\n\t/*\n\t * Using attrs_offset plus eight bytes (for the termination attribute).\n\t * attrs_offset is already aligned to 8-byte boundary, so no need to\n\t * align again.\n\t */\n\tm->bytes_in_use = cpu_to_le32(le16_to_cpu(m->attrs_offset) + 8);\n\tm->bytes_allocated = cpu_to_le32(vol->mft_record_size);\n\tm->base_mft_record = 0;\n\tm->next_attr_instance = 0;\n\t/* Add the termination attribute. */\n\ta = (ATTR_RECORD*)((u8*)m + le16_to_cpu(m->attrs_offset));\n\ta->type = AT_END;\n\ta->length = 0;\n\tntfs_debug(\"Done.\");\n\treturn 0;\n}",
    "includes": [
      "#include \"ntfs.h\"",
      "#include \"mft.h\"",
      "#include \"malloc.h\"",
      "#include \"lcnalloc.h\"",
      "#include \"dir.h\"",
      "#include \"debug.h\"",
      "#include \"bitmap.h\"",
      "#include \"aops.h\"",
      "#include \"attrib.h\"",
      "#include <linux/swap.h>",
      "#include <linux/slab.h>",
      "#include <linux/buffer_head.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ntfs_debug",
          "args": [
            "\"Done.\""
          ],
          "line": 2076
        },
        "resolved": true,
        "details": {
          "function_name": "ntfs_debug_dump_runlist",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/debug.c",
          "lines": "134-171",
          "snippet": "void ntfs_debug_dump_runlist(const runlist_element *rl)\n{\n\tint i;\n\tconst char *lcn_str[5] = { \"LCN_HOLE         \", \"LCN_RL_NOT_MAPPED\",\n\t\t\t\t   \"LCN_ENOENT       \", \"LCN_unknown      \" };\n\n\tif (!debug_msgs)\n\t\treturn;\n\tpr_debug(\"Dumping runlist (values in hex):\\n\");\n\tif (!rl) {\n\t\tpr_debug(\"Run list not present.\\n\");\n\t\treturn;\n\t}\n\tpr_debug(\"VCN              LCN               Run length\\n\");\n\tfor (i = 0; ; i++) {\n\t\tLCN lcn = (rl + i)->lcn;\n\n\t\tif (lcn < (LCN)0) {\n\t\t\tint index = -lcn - 1;\n\n\t\t\tif (index > -LCN_ENOENT - 1)\n\t\t\t\tindex = 3;\n\t\t\tpr_debug(\"%-16Lx %s %-16Lx%s\\n\",\n\t\t\t\t\t(long long)(rl + i)->vcn, lcn_str[index],\n\t\t\t\t\t(long long)(rl + i)->length,\n\t\t\t\t\t(rl + i)->length ? \"\" :\n\t\t\t\t\t\t\" (runlist end)\");\n\t\t} else\n\t\t\tpr_debug(\"%-16Lx %-16Lx  %-16Lx%s\\n\",\n\t\t\t\t\t(long long)(rl + i)->vcn,\n\t\t\t\t\t(long long)(rl + i)->lcn,\n\t\t\t\t\t(long long)(rl + i)->length,\n\t\t\t\t\t(rl + i)->length ? \"\" :\n\t\t\t\t\t\t\" (runlist end)\");\n\t\tif (!(rl + i)->length)\n\t\t\tbreak;\n\t}\n}",
          "includes": [
            "#include \"debug.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"debug.h\"\n\nvoid ntfs_debug_dump_runlist(const runlist_element *rl)\n{\n\tint i;\n\tconst char *lcn_str[5] = { \"LCN_HOLE         \", \"LCN_RL_NOT_MAPPED\",\n\t\t\t\t   \"LCN_ENOENT       \", \"LCN_unknown      \" };\n\n\tif (!debug_msgs)\n\t\treturn;\n\tpr_debug(\"Dumping runlist (values in hex):\\n\");\n\tif (!rl) {\n\t\tpr_debug(\"Run list not present.\\n\");\n\t\treturn;\n\t}\n\tpr_debug(\"VCN              LCN               Run length\\n\");\n\tfor (i = 0; ; i++) {\n\t\tLCN lcn = (rl + i)->lcn;\n\n\t\tif (lcn < (LCN)0) {\n\t\t\tint index = -lcn - 1;\n\n\t\t\tif (index > -LCN_ENOENT - 1)\n\t\t\t\tindex = 3;\n\t\t\tpr_debug(\"%-16Lx %s %-16Lx%s\\n\",\n\t\t\t\t\t(long long)(rl + i)->vcn, lcn_str[index],\n\t\t\t\t\t(long long)(rl + i)->length,\n\t\t\t\t\t(rl + i)->length ? \"\" :\n\t\t\t\t\t\t\" (runlist end)\");\n\t\t} else\n\t\t\tpr_debug(\"%-16Lx %-16Lx  %-16Lx%s\\n\",\n\t\t\t\t\t(long long)(rl + i)->vcn,\n\t\t\t\t\t(long long)(rl + i)->lcn,\n\t\t\t\t\t(long long)(rl + i)->length,\n\t\t\t\t\t(rl + i)->length ? \"\" :\n\t\t\t\t\t\t\" (runlist end)\");\n\t\tif (!(rl + i)->length)\n\t\t\tbreak;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "le16_to_cpu",
          "args": [
            "m->attrs_offset"
          ],
          "line": 2073
        },
        "resolved": true,
        "details": {
          "function_name": "sle16_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "48-51",
          "snippet": "static inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "vol->mft_record_size"
          ],
          "line": 2069
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "le16_to_cpu(m->attrs_offset) + 8"
          ],
          "line": 2068
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "(le16_to_cpu(m->usa_ofs) +\n\t\t\t(le16_to_cpu(m->usa_count) << 1) + 7) & ~7"
          ],
          "line": 2060
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "1"
          ],
          "line": 2054
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "1"
          ],
          "line": 2052
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntfs_warning",
          "args": [
            "vol->sb",
            "\"Sector size is bigger than mft record \"\n\t\t\t\t\"size.  Setting usa_count to 1.  If chkdsk \"\n\t\t\t\t\"reports this as corruption, please email \"\n\t\t\t\t\"linux-ntfs-dev@lists.sourceforge.net stating \"\n\t\t\t\t\"that you saw this message and that the \"\n\t\t\t\t\"modified filesystem created was corrupt.  \"\n\t\t\t\t\"Thank you.\""
          ],
          "line": 2043
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "1"
          ],
          "line": 2042
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "vol->mft_record_size /\n\t\t\t\tNTFS_BLOCK_SIZE + 1"
          ],
          "line": 2039
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "(u32)mft_no"
          ],
          "line": 2035
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "(sizeof(MFT_RECORD) + 1) & ~1"
          ],
          "line": 2029
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "(sizeof(MFT_RECORD_OLD) + 1) & ~1"
          ],
          "line": 2027
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "m",
            "0",
            "vol->mft_record_size"
          ],
          "line": 2024
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntfs_error",
          "args": [
            "vol->sb",
            "\"Mft record number 0x%llx exceeds \"\n\t\t\t\t\"maximum of 2^32.\"",
            "(long long)mft_no"
          ],
          "line": 2019
        },
        "resolved": true,
        "details": {
          "function_name": "__ntfs_error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/debug.c",
          "lines": "86-108",
          "snippet": "void __ntfs_error(const char *function, const struct super_block *sb,\n\t\tconst char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\tint flen = 0;\n\n#ifndef DEBUG\n\tif (!printk_ratelimit())\n\t\treturn;\n#endif\n\tif (function)\n\t\tflen = strlen(function);\n\tva_start(args, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\tif (sb)\n\t\tpr_err(\"(device %s): %s(): %pV\\n\",\n\t\t       sb->s_id, flen ? function : \"\", &vaf);\n\telse\n\t\tpr_err(\"%s(): %pV\\n\", flen ? function : \"\", &vaf);\n\tva_end(args);\n}",
          "includes": [
            "#include \"debug.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"debug.h\"\n\nvoid __ntfs_error(const char *function, const struct super_block *sb,\n\t\tconst char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\tint flen = 0;\n\n#ifndef DEBUG\n\tif (!printk_ratelimit())\n\t\treturn;\n#endif\n\tif (function)\n\t\tflen = strlen(function);\n\tva_start(args, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\tif (sb)\n\t\tpr_err(\"(device %s): %s(): %pV\\n\",\n\t\t       sb->s_id, flen ? function : \"\", &vaf);\n\telse\n\t\tpr_err(\"%s(): %pV\\n\", flen ? function : \"\", &vaf);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ntfs_debug",
          "args": [
            "\"Entering for mft record 0x%llx.\"",
            "(long long)mft_no"
          ],
          "line": 2017
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ntfs.h\"\n#include \"mft.h\"\n#include \"malloc.h\"\n#include \"lcnalloc.h\"\n#include \"dir.h\"\n#include \"debug.h\"\n#include \"bitmap.h\"\n#include \"aops.h\"\n#include \"attrib.h\"\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n\nstatic int ntfs_mft_record_layout(const ntfs_volume *vol, const s64 mft_no,\n\t\tMFT_RECORD *m)\n{\n\tATTR_RECORD *a;\n\n\tntfs_debug(\"Entering for mft record 0x%llx.\", (long long)mft_no);\n\tif (mft_no >= (1ll << 32)) {\n\t\tntfs_error(vol->sb, \"Mft record number 0x%llx exceeds \"\n\t\t\t\t\"maximum of 2^32.\", (long long)mft_no);\n\t\treturn -ERANGE;\n\t}\n\t/* Start by clearing the whole mft record to gives us a clean slate. */\n\tmemset(m, 0, vol->mft_record_size);\n\t/* Aligned to 2-byte boundary. */\n\tif (vol->major_ver < 3 || (vol->major_ver == 3 && !vol->minor_ver))\n\t\tm->usa_ofs = cpu_to_le16((sizeof(MFT_RECORD_OLD) + 1) & ~1);\n\telse {\n\t\tm->usa_ofs = cpu_to_le16((sizeof(MFT_RECORD) + 1) & ~1);\n\t\t/*\n\t\t * Set the NTFS 3.1+ specific fields while we know that the\n\t\t * volume version is 3.1+.\n\t\t */\n\t\tm->reserved = 0;\n\t\tm->mft_record_number = cpu_to_le32((u32)mft_no);\n\t}\n\tm->magic = magic_FILE;\n\tif (vol->mft_record_size >= NTFS_BLOCK_SIZE)\n\t\tm->usa_count = cpu_to_le16(vol->mft_record_size /\n\t\t\t\tNTFS_BLOCK_SIZE + 1);\n\telse {\n\t\tm->usa_count = cpu_to_le16(1);\n\t\tntfs_warning(vol->sb, \"Sector size is bigger than mft record \"\n\t\t\t\t\"size.  Setting usa_count to 1.  If chkdsk \"\n\t\t\t\t\"reports this as corruption, please email \"\n\t\t\t\t\"linux-ntfs-dev@lists.sourceforge.net stating \"\n\t\t\t\t\"that you saw this message and that the \"\n\t\t\t\t\"modified filesystem created was corrupt.  \"\n\t\t\t\t\"Thank you.\");\n\t}\n\t/* Set the update sequence number to 1. */\n\t*(le16*)((u8*)m + le16_to_cpu(m->usa_ofs)) = cpu_to_le16(1);\n\tm->lsn = 0;\n\tm->sequence_number = cpu_to_le16(1);\n\tm->link_count = 0;\n\t/*\n\t * Place the attributes straight after the update sequence array,\n\t * aligned to 8-byte boundary.\n\t */\n\tm->attrs_offset = cpu_to_le16((le16_to_cpu(m->usa_ofs) +\n\t\t\t(le16_to_cpu(m->usa_count) << 1) + 7) & ~7);\n\tm->flags = 0;\n\t/*\n\t * Using attrs_offset plus eight bytes (for the termination attribute).\n\t * attrs_offset is already aligned to 8-byte boundary, so no need to\n\t * align again.\n\t */\n\tm->bytes_in_use = cpu_to_le32(le16_to_cpu(m->attrs_offset) + 8);\n\tm->bytes_allocated = cpu_to_le32(vol->mft_record_size);\n\tm->base_mft_record = 0;\n\tm->next_attr_instance = 0;\n\t/* Add the termination attribute. */\n\ta = (ATTR_RECORD*)((u8*)m + le16_to_cpu(m->attrs_offset));\n\ta->type = AT_END;\n\ta->length = 0;\n\tntfs_debug(\"Done.\");\n\treturn 0;\n}"
  },
  {
    "function_name": "ntfs_mft_data_extend_allocation_nolock",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/mft.c",
    "lines": "1714-1997",
    "snippet": "static int ntfs_mft_data_extend_allocation_nolock(ntfs_volume *vol)\n{\n\tLCN lcn;\n\tVCN old_last_vcn;\n\ts64 min_nr, nr, ll;\n\tunsigned long flags;\n\tntfs_inode *mft_ni;\n\trunlist_element *rl, *rl2;\n\tntfs_attr_search_ctx *ctx = NULL;\n\tMFT_RECORD *mrec;\n\tATTR_RECORD *a = NULL;\n\tint ret, mp_size;\n\tu32 old_alen = 0;\n\tbool mp_rebuilt = false;\n\n\tntfs_debug(\"Extending mft data allocation.\");\n\tmft_ni = NTFS_I(vol->mft_ino);\n\t/*\n\t * Determine the preferred allocation location, i.e. the last lcn of\n\t * the mft data attribute.  The allocated size of the mft data\n\t * attribute cannot be zero so we are ok to do this.\n\t */\n\tdown_write(&mft_ni->runlist.lock);\n\tread_lock_irqsave(&mft_ni->size_lock, flags);\n\tll = mft_ni->allocated_size;\n\tread_unlock_irqrestore(&mft_ni->size_lock, flags);\n\trl = ntfs_attr_find_vcn_nolock(mft_ni,\n\t\t\t(ll - 1) >> vol->cluster_size_bits, NULL);\n\tif (unlikely(IS_ERR(rl) || !rl->length || rl->lcn < 0)) {\n\t\tup_write(&mft_ni->runlist.lock);\n\t\tntfs_error(vol->sb, \"Failed to determine last allocated \"\n\t\t\t\t\"cluster of mft data attribute.\");\n\t\tif (!IS_ERR(rl))\n\t\t\tret = -EIO;\n\t\telse\n\t\t\tret = PTR_ERR(rl);\n\t\treturn ret;\n\t}\n\tlcn = rl->lcn + rl->length;\n\tntfs_debug(\"Last lcn of mft data attribute is 0x%llx.\", (long long)lcn);\n\t/* Minimum allocation is one mft record worth of clusters. */\n\tmin_nr = vol->mft_record_size >> vol->cluster_size_bits;\n\tif (!min_nr)\n\t\tmin_nr = 1;\n\t/* Want to allocate 16 mft records worth of clusters. */\n\tnr = vol->mft_record_size << 4 >> vol->cluster_size_bits;\n\tif (!nr)\n\t\tnr = min_nr;\n\t/* Ensure we do not go above 2^32-1 mft records. */\n\tread_lock_irqsave(&mft_ni->size_lock, flags);\n\tll = mft_ni->allocated_size;\n\tread_unlock_irqrestore(&mft_ni->size_lock, flags);\n\tif (unlikely((ll + (nr << vol->cluster_size_bits)) >>\n\t\t\tvol->mft_record_size_bits >= (1ll << 32))) {\n\t\tnr = min_nr;\n\t\tif (unlikely((ll + (nr << vol->cluster_size_bits)) >>\n\t\t\t\tvol->mft_record_size_bits >= (1ll << 32))) {\n\t\t\tntfs_warning(vol->sb, \"Cannot allocate mft record \"\n\t\t\t\t\t\"because the maximum number of inodes \"\n\t\t\t\t\t\"(2^32) has already been reached.\");\n\t\t\tup_write(&mft_ni->runlist.lock);\n\t\t\treturn -ENOSPC;\n\t\t}\n\t}\n\tntfs_debug(\"Trying mft data allocation with %s cluster count %lli.\",\n\t\t\tnr > min_nr ? \"default\" : \"minimal\", (long long)nr);\n\told_last_vcn = rl[1].vcn;\n\tdo {\n\t\trl2 = ntfs_cluster_alloc(vol, old_last_vcn, nr, lcn, MFT_ZONE,\n\t\t\t\ttrue);\n\t\tif (likely(!IS_ERR(rl2)))\n\t\t\tbreak;\n\t\tif (PTR_ERR(rl2) != -ENOSPC || nr == min_nr) {\n\t\t\tntfs_error(vol->sb, \"Failed to allocate the minimal \"\n\t\t\t\t\t\"number of clusters (%lli) for the \"\n\t\t\t\t\t\"mft data attribute.\", (long long)nr);\n\t\t\tup_write(&mft_ni->runlist.lock);\n\t\t\treturn PTR_ERR(rl2);\n\t\t}\n\t\t/*\n\t\t * There is not enough space to do the allocation, but there\n\t\t * might be enough space to do a minimal allocation so try that\n\t\t * before failing.\n\t\t */\n\t\tnr = min_nr;\n\t\tntfs_debug(\"Retrying mft data allocation with minimal cluster \"\n\t\t\t\t\"count %lli.\", (long long)nr);\n\t} while (1);\n\trl = ntfs_runlists_merge(mft_ni->runlist.rl, rl2);\n\tif (IS_ERR(rl)) {\n\t\tup_write(&mft_ni->runlist.lock);\n\t\tntfs_error(vol->sb, \"Failed to merge runlists for mft data \"\n\t\t\t\t\"attribute.\");\n\t\tif (ntfs_cluster_free_from_rl(vol, rl2)) {\n\t\t\tntfs_error(vol->sb, \"Failed to deallocate clusters \"\n\t\t\t\t\t\"from the mft data attribute.%s\", es);\n\t\t\tNVolSetErrors(vol);\n\t\t}\n\t\tntfs_free(rl2);\n\t\treturn PTR_ERR(rl);\n\t}\n\tmft_ni->runlist.rl = rl;\n\tntfs_debug(\"Allocated %lli clusters.\", (long long)nr);\n\t/* Find the last run in the new runlist. */\n\tfor (; rl[1].length; rl++)\n\t\t;\n\t/* Update the attribute record as well. */\n\tmrec = map_mft_record(mft_ni);\n\tif (IS_ERR(mrec)) {\n\t\tntfs_error(vol->sb, \"Failed to map mft record.\");\n\t\tret = PTR_ERR(mrec);\n\t\tgoto undo_alloc;\n\t}\n\tctx = ntfs_attr_get_search_ctx(mft_ni, mrec);\n\tif (unlikely(!ctx)) {\n\t\tntfs_error(vol->sb, \"Failed to get search context.\");\n\t\tret = -ENOMEM;\n\t\tgoto undo_alloc;\n\t}\n\tret = ntfs_attr_lookup(mft_ni->type, mft_ni->name, mft_ni->name_len,\n\t\t\tCASE_SENSITIVE, rl[1].vcn, NULL, 0, ctx);\n\tif (unlikely(ret)) {\n\t\tntfs_error(vol->sb, \"Failed to find last attribute extent of \"\n\t\t\t\t\"mft data attribute.\");\n\t\tif (ret == -ENOENT)\n\t\t\tret = -EIO;\n\t\tgoto undo_alloc;\n\t}\n\ta = ctx->attr;\n\tll = sle64_to_cpu(a->data.non_resident.lowest_vcn);\n\t/* Search back for the previous last allocated cluster of mft bitmap. */\n\tfor (rl2 = rl; rl2 > mft_ni->runlist.rl; rl2--) {\n\t\tif (ll >= rl2->vcn)\n\t\t\tbreak;\n\t}\n\tBUG_ON(ll < rl2->vcn);\n\tBUG_ON(ll >= rl2->vcn + rl2->length);\n\t/* Get the size for the new mapping pairs array for this extent. */\n\tmp_size = ntfs_get_size_for_mapping_pairs(vol, rl2, ll, -1);\n\tif (unlikely(mp_size <= 0)) {\n\t\tntfs_error(vol->sb, \"Get size for mapping pairs failed for \"\n\t\t\t\t\"mft data attribute extent.\");\n\t\tret = mp_size;\n\t\tif (!ret)\n\t\t\tret = -EIO;\n\t\tgoto undo_alloc;\n\t}\n\t/* Expand the attribute record if necessary. */\n\told_alen = le32_to_cpu(a->length);\n\tret = ntfs_attr_record_resize(ctx->mrec, a, mp_size +\n\t\t\tle16_to_cpu(a->data.non_resident.mapping_pairs_offset));\n\tif (unlikely(ret)) {\n\t\tif (ret != -ENOSPC) {\n\t\t\tntfs_error(vol->sb, \"Failed to resize attribute \"\n\t\t\t\t\t\"record for mft data attribute.\");\n\t\t\tgoto undo_alloc;\n\t\t}\n\t\t// TODO: Deal with this by moving this extent to a new mft\n\t\t// record or by starting a new extent in a new mft record or by\n\t\t// moving other attributes out of this mft record.\n\t\t// Note: Use the special reserved mft records and ensure that\n\t\t// this extent is not required to find the mft record in\n\t\t// question.  If no free special records left we would need to\n\t\t// move an existing record away, insert ours in its place, and\n\t\t// then place the moved record into the newly allocated space\n\t\t// and we would then need to update all references to this mft\n\t\t// record appropriately.  This is rather complicated...\n\t\tntfs_error(vol->sb, \"Not enough space in this mft record to \"\n\t\t\t\t\"accommodate extended mft data attribute \"\n\t\t\t\t\"extent.  Cannot handle this yet.\");\n\t\tret = -EOPNOTSUPP;\n\t\tgoto undo_alloc;\n\t}\n\tmp_rebuilt = true;\n\t/* Generate the mapping pairs array directly into the attr record. */\n\tret = ntfs_mapping_pairs_build(vol, (u8*)a +\n\t\t\tle16_to_cpu(a->data.non_resident.mapping_pairs_offset),\n\t\t\tmp_size, rl2, ll, -1, NULL);\n\tif (unlikely(ret)) {\n\t\tntfs_error(vol->sb, \"Failed to build mapping pairs array of \"\n\t\t\t\t\"mft data attribute.\");\n\t\tgoto undo_alloc;\n\t}\n\t/* Update the highest_vcn. */\n\ta->data.non_resident.highest_vcn = cpu_to_sle64(rl[1].vcn - 1);\n\t/*\n\t * We now have extended the mft data allocated_size by nr clusters.\n\t * Reflect this in the ntfs_inode structure and the attribute record.\n\t * @rl is the last (non-terminator) runlist element of mft data\n\t * attribute.\n\t */\n\tif (a->data.non_resident.lowest_vcn) {\n\t\t/*\n\t\t * We are not in the first attribute extent, switch to it, but\n\t\t * first ensure the changes will make it to disk later.\n\t\t */\n\t\tflush_dcache_mft_record_page(ctx->ntfs_ino);\n\t\tmark_mft_record_dirty(ctx->ntfs_ino);\n\t\tntfs_attr_reinit_search_ctx(ctx);\n\t\tret = ntfs_attr_lookup(mft_ni->type, mft_ni->name,\n\t\t\t\tmft_ni->name_len, CASE_SENSITIVE, 0, NULL, 0,\n\t\t\t\tctx);\n\t\tif (unlikely(ret)) {\n\t\t\tntfs_error(vol->sb, \"Failed to find first attribute \"\n\t\t\t\t\t\"extent of mft data attribute.\");\n\t\t\tgoto restore_undo_alloc;\n\t\t}\n\t\ta = ctx->attr;\n\t}\n\twrite_lock_irqsave(&mft_ni->size_lock, flags);\n\tmft_ni->allocated_size += nr << vol->cluster_size_bits;\n\ta->data.non_resident.allocated_size =\n\t\t\tcpu_to_sle64(mft_ni->allocated_size);\n\twrite_unlock_irqrestore(&mft_ni->size_lock, flags);\n\t/* Ensure the changes make it to disk. */\n\tflush_dcache_mft_record_page(ctx->ntfs_ino);\n\tmark_mft_record_dirty(ctx->ntfs_ino);\n\tntfs_attr_put_search_ctx(ctx);\n\tunmap_mft_record(mft_ni);\n\tup_write(&mft_ni->runlist.lock);\n\tntfs_debug(\"Done.\");\n\treturn 0;\nrestore_undo_alloc:\n\tntfs_attr_reinit_search_ctx(ctx);\n\tif (ntfs_attr_lookup(mft_ni->type, mft_ni->name, mft_ni->name_len,\n\t\t\tCASE_SENSITIVE, rl[1].vcn, NULL, 0, ctx)) {\n\t\tntfs_error(vol->sb, \"Failed to find last attribute extent of \"\n\t\t\t\t\"mft data attribute.%s\", es);\n\t\twrite_lock_irqsave(&mft_ni->size_lock, flags);\n\t\tmft_ni->allocated_size += nr << vol->cluster_size_bits;\n\t\twrite_unlock_irqrestore(&mft_ni->size_lock, flags);\n\t\tntfs_attr_put_search_ctx(ctx);\n\t\tunmap_mft_record(mft_ni);\n\t\tup_write(&mft_ni->runlist.lock);\n\t\t/*\n\t\t * The only thing that is now wrong is ->allocated_size of the\n\t\t * base attribute extent which chkdsk should be able to fix.\n\t\t */\n\t\tNVolSetErrors(vol);\n\t\treturn ret;\n\t}\n\tctx->attr->data.non_resident.highest_vcn =\n\t\t\tcpu_to_sle64(old_last_vcn - 1);\nundo_alloc:\n\tif (ntfs_cluster_free(mft_ni, old_last_vcn, -1, ctx) < 0) {\n\t\tntfs_error(vol->sb, \"Failed to free clusters from mft data \"\n\t\t\t\t\"attribute.%s\", es);\n\t\tNVolSetErrors(vol);\n\t}\n\ta = ctx->attr;\n\tif (ntfs_rl_truncate_nolock(vol, &mft_ni->runlist, old_last_vcn)) {\n\t\tntfs_error(vol->sb, \"Failed to truncate mft data attribute \"\n\t\t\t\t\"runlist.%s\", es);\n\t\tNVolSetErrors(vol);\n\t}\n\tif (mp_rebuilt && !IS_ERR(ctx->mrec)) {\n\t\tif (ntfs_mapping_pairs_build(vol, (u8*)a + le16_to_cpu(\n\t\t\t\ta->data.non_resident.mapping_pairs_offset),\n\t\t\t\told_alen - le16_to_cpu(\n\t\t\t\ta->data.non_resident.mapping_pairs_offset),\n\t\t\t\trl2, ll, -1, NULL)) {\n\t\t\tntfs_error(vol->sb, \"Failed to restore mapping pairs \"\n\t\t\t\t\t\"array.%s\", es);\n\t\t\tNVolSetErrors(vol);\n\t\t}\n\t\tif (ntfs_attr_record_resize(ctx->mrec, a, old_alen)) {\n\t\t\tntfs_error(vol->sb, \"Failed to restore attribute \"\n\t\t\t\t\t\"record.%s\", es);\n\t\t\tNVolSetErrors(vol);\n\t\t}\n\t\tflush_dcache_mft_record_page(ctx->ntfs_ino);\n\t\tmark_mft_record_dirty(ctx->ntfs_ino);\n\t} else if (IS_ERR(ctx->mrec)) {\n\t\tntfs_error(vol->sb, \"Failed to restore attribute search \"\n\t\t\t\t\"context.%s\", es);\n\t\tNVolSetErrors(vol);\n\t}\n\tif (ctx)\n\t\tntfs_attr_put_search_ctx(ctx);\n\tif (!IS_ERR(mrec))\n\t\tunmap_mft_record(mft_ni);\n\tup_write(&mft_ni->runlist.lock);\n\treturn ret;\n}",
    "includes": [
      "#include \"ntfs.h\"",
      "#include \"mft.h\"",
      "#include \"malloc.h\"",
      "#include \"lcnalloc.h\"",
      "#include \"dir.h\"",
      "#include \"debug.h\"",
      "#include \"bitmap.h\"",
      "#include \"aops.h\"",
      "#include \"attrib.h\"",
      "#include <linux/swap.h>",
      "#include <linux/slab.h>",
      "#include <linux/buffer_head.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "up_write",
          "args": [
            "&mft_ni->runlist.lock"
          ],
          "line": 1995
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unmap_mft_record",
          "args": [
            "mft_ni"
          ],
          "line": 1994
        },
        "resolved": true,
        "details": {
          "function_name": "unmap_mft_record",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/mft.c",
          "lines": "213-231",
          "snippet": "void unmap_mft_record(ntfs_inode *ni)\n{\n\tstruct page *page = ni->page;\n\n\tBUG_ON(!page);\n\n\tntfs_debug(\"Entering for mft_no 0x%lx.\", ni->mft_no);\n\n\tunmap_mft_record_page(ni);\n\tmutex_unlock(&ni->mrec_lock);\n\tatomic_dec(&ni->count);\n\t/*\n\t * If pure ntfs_inode, i.e. no vfs inode attached, we leave it to\n\t * ntfs_clear_extent_inode() in the extent inode case, and to the\n\t * caller in the non-extent, yet pure ntfs inode case, to do the actual\n\t * tear down of all structures and freeing of all allocated memory.\n\t */\n\treturn;\n}",
          "includes": [
            "#include \"ntfs.h\"",
            "#include \"mft.h\"",
            "#include \"malloc.h\"",
            "#include \"lcnalloc.h\"",
            "#include \"dir.h\"",
            "#include \"debug.h\"",
            "#include \"bitmap.h\"",
            "#include \"aops.h\"",
            "#include \"attrib.h\"",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ntfs.h\"\n#include \"mft.h\"\n#include \"malloc.h\"\n#include \"lcnalloc.h\"\n#include \"dir.h\"\n#include \"debug.h\"\n#include \"bitmap.h\"\n#include \"aops.h\"\n#include \"attrib.h\"\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n\nvoid unmap_mft_record(ntfs_inode *ni)\n{\n\tstruct page *page = ni->page;\n\n\tBUG_ON(!page);\n\n\tntfs_debug(\"Entering for mft_no 0x%lx.\", ni->mft_no);\n\n\tunmap_mft_record_page(ni);\n\tmutex_unlock(&ni->mrec_lock);\n\tatomic_dec(&ni->count);\n\t/*\n\t * If pure ntfs_inode, i.e. no vfs inode attached, we leave it to\n\t * ntfs_clear_extent_inode() in the extent inode case, and to the\n\t * caller in the non-extent, yet pure ntfs inode case, to do the actual\n\t * tear down of all structures and freeing of all allocated memory.\n\t */\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "mrec"
          ],
          "line": 1993
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntfs_attr_put_search_ctx",
          "args": [
            "ctx"
          ],
          "line": 1992
        },
        "resolved": true,
        "details": {
          "function_name": "ntfs_attr_put_search_ctx",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/attrib.c",
          "lines": "1286-1292",
          "snippet": "void ntfs_attr_put_search_ctx(ntfs_attr_search_ctx *ctx)\n{\n\tif (ctx->base_ntfs_ino && ctx->ntfs_ino != ctx->base_ntfs_ino)\n\t\tunmap_extent_mft_record(ctx->ntfs_ino);\n\tkmem_cache_free(ntfs_attr_ctx_cache, ctx);\n\treturn;\n}",
          "includes": [
            "#include \"types.h\"",
            "#include \"ntfs.h\"",
            "#include \"mft.h\"",
            "#include \"malloc.h\"",
            "#include \"lcnalloc.h\"",
            "#include \"layout.h\"",
            "#include \"debug.h\"",
            "#include \"attrib.h\"",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include \"ntfs.h\"\n#include \"mft.h\"\n#include \"malloc.h\"\n#include \"lcnalloc.h\"\n#include \"layout.h\"\n#include \"debug.h\"\n#include \"attrib.h\"\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/buffer_head.h>\n\nvoid ntfs_attr_put_search_ctx(ntfs_attr_search_ctx *ctx)\n{\n\tif (ctx->base_ntfs_ino && ctx->ntfs_ino != ctx->base_ntfs_ino)\n\t\tunmap_extent_mft_record(ctx->ntfs_ino);\n\tkmem_cache_free(ntfs_attr_ctx_cache, ctx);\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "NVolSetErrors",
          "args": [
            "vol"
          ],
          "line": 1989
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntfs_error",
          "args": [
            "vol->sb",
            "\"Failed to restore attribute search \"\n\t\t\t\t\"context.%s\"",
            "es"
          ],
          "line": 1987
        },
        "resolved": true,
        "details": {
          "function_name": "__ntfs_error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/debug.c",
          "lines": "86-108",
          "snippet": "void __ntfs_error(const char *function, const struct super_block *sb,\n\t\tconst char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\tint flen = 0;\n\n#ifndef DEBUG\n\tif (!printk_ratelimit())\n\t\treturn;\n#endif\n\tif (function)\n\t\tflen = strlen(function);\n\tva_start(args, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\tif (sb)\n\t\tpr_err(\"(device %s): %s(): %pV\\n\",\n\t\t       sb->s_id, flen ? function : \"\", &vaf);\n\telse\n\t\tpr_err(\"%s(): %pV\\n\", flen ? function : \"\", &vaf);\n\tva_end(args);\n}",
          "includes": [
            "#include \"debug.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"debug.h\"\n\nvoid __ntfs_error(const char *function, const struct super_block *sb,\n\t\tconst char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\tint flen = 0;\n\n#ifndef DEBUG\n\tif (!printk_ratelimit())\n\t\treturn;\n#endif\n\tif (function)\n\t\tflen = strlen(function);\n\tva_start(args, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\tif (sb)\n\t\tpr_err(\"(device %s): %s(): %pV\\n\",\n\t\t       sb->s_id, flen ? function : \"\", &vaf);\n\telse\n\t\tpr_err(\"%s(): %pV\\n\", flen ? function : \"\", &vaf);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "ctx->mrec"
          ],
          "line": 1986
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mark_mft_record_dirty",
          "args": [
            "ctx->ntfs_ino"
          ],
          "line": 1985
        },
        "resolved": true,
        "details": {
          "function_name": "__mark_mft_record_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/mft.c",
          "lines": "395-410",
          "snippet": "void __mark_mft_record_dirty(ntfs_inode *ni)\n{\n\tntfs_inode *base_ni;\n\n\tntfs_debug(\"Entering for inode 0x%lx.\", ni->mft_no);\n\tBUG_ON(NInoAttr(ni));\n\tmark_ntfs_record_dirty(ni->page, ni->page_ofs);\n\t/* Determine the base vfs inode and mark it dirty, too. */\n\tmutex_lock(&ni->extent_lock);\n\tif (likely(ni->nr_extents >= 0))\n\t\tbase_ni = ni;\n\telse\n\t\tbase_ni = ni->ext.base_ntfs_ino;\n\tmutex_unlock(&ni->extent_lock);\n\t__mark_inode_dirty(VFS_I(base_ni), I_DIRTY_SYNC | I_DIRTY_DATASYNC);\n}",
          "includes": [
            "#include \"ntfs.h\"",
            "#include \"mft.h\"",
            "#include \"malloc.h\"",
            "#include \"lcnalloc.h\"",
            "#include \"dir.h\"",
            "#include \"debug.h\"",
            "#include \"bitmap.h\"",
            "#include \"aops.h\"",
            "#include \"attrib.h\"",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ntfs.h\"\n#include \"mft.h\"\n#include \"malloc.h\"\n#include \"lcnalloc.h\"\n#include \"dir.h\"\n#include \"debug.h\"\n#include \"bitmap.h\"\n#include \"aops.h\"\n#include \"attrib.h\"\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n\nvoid __mark_mft_record_dirty(ntfs_inode *ni)\n{\n\tntfs_inode *base_ni;\n\n\tntfs_debug(\"Entering for inode 0x%lx.\", ni->mft_no);\n\tBUG_ON(NInoAttr(ni));\n\tmark_ntfs_record_dirty(ni->page, ni->page_ofs);\n\t/* Determine the base vfs inode and mark it dirty, too. */\n\tmutex_lock(&ni->extent_lock);\n\tif (likely(ni->nr_extents >= 0))\n\t\tbase_ni = ni;\n\telse\n\t\tbase_ni = ni->ext.base_ntfs_ino;\n\tmutex_unlock(&ni->extent_lock);\n\t__mark_inode_dirty(VFS_I(base_ni), I_DIRTY_SYNC | I_DIRTY_DATASYNC);\n}"
        }
      },
      {
        "call_info": {
          "callee": "flush_dcache_mft_record_page",
          "args": [
            "ctx->ntfs_ino"
          ],
          "line": 1984
        },
        "resolved": true,
        "details": {
          "function_name": "flush_dcache_mft_record_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/mft.h",
          "lines": "55-58",
          "snippet": "static inline void flush_dcache_mft_record_page(ntfs_inode *ni)\n{\n\tflush_dcache_page(ni->page);\n}",
          "includes": [
            "#include \"inode.h\"",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"inode.h\"\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/fs.h>\n\nstatic inline void flush_dcache_mft_record_page(ntfs_inode *ni)\n{\n\tflush_dcache_page(ni->page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "NVolSetErrors",
          "args": [
            "vol"
          ],
          "line": 1982
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntfs_attr_record_resize",
          "args": [
            "ctx->mrec",
            "a",
            "old_alen"
          ],
          "line": 1979
        },
        "resolved": true,
        "details": {
          "function_name": "ntfs_attr_record_resize",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/attrib.c",
          "lines": "1435-1459",
          "snippet": "int ntfs_attr_record_resize(MFT_RECORD *m, ATTR_RECORD *a, u32 new_size)\n{\n\tntfs_debug(\"Entering for new_size %u.\", new_size);\n\t/* Align to 8 bytes if it is not already done. */\n\tif (new_size & 7)\n\t\tnew_size = (new_size + 7) & ~7;\n\t/* If the actual attribute length has changed, move things around. */\n\tif (new_size != le32_to_cpu(a->length)) {\n\t\tu32 new_muse = le32_to_cpu(m->bytes_in_use) -\n\t\t\t\tle32_to_cpu(a->length) + new_size;\n\t\t/* Not enough space in this mft record. */\n\t\tif (new_muse > le32_to_cpu(m->bytes_allocated))\n\t\t\treturn -ENOSPC;\n\t\t/* Move attributes following @a to their new location. */\n\t\tmemmove((u8*)a + new_size, (u8*)a + le32_to_cpu(a->length),\n\t\t\t\tle32_to_cpu(m->bytes_in_use) - ((u8*)a -\n\t\t\t\t(u8*)m) - le32_to_cpu(a->length));\n\t\t/* Adjust @m to reflect the change in used space. */\n\t\tm->bytes_in_use = cpu_to_le32(new_muse);\n\t\t/* Adjust @a to reflect the new size. */\n\t\tif (new_size >= offsetof(ATTR_REC, length) + sizeof(a->length))\n\t\t\ta->length = cpu_to_le32(new_size);\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"types.h\"",
            "#include \"ntfs.h\"",
            "#include \"mft.h\"",
            "#include \"malloc.h\"",
            "#include \"lcnalloc.h\"",
            "#include \"layout.h\"",
            "#include \"debug.h\"",
            "#include \"attrib.h\"",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include \"ntfs.h\"\n#include \"mft.h\"\n#include \"malloc.h\"\n#include \"lcnalloc.h\"\n#include \"layout.h\"\n#include \"debug.h\"\n#include \"attrib.h\"\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/buffer_head.h>\n\nint ntfs_attr_record_resize(MFT_RECORD *m, ATTR_RECORD *a, u32 new_size)\n{\n\tntfs_debug(\"Entering for new_size %u.\", new_size);\n\t/* Align to 8 bytes if it is not already done. */\n\tif (new_size & 7)\n\t\tnew_size = (new_size + 7) & ~7;\n\t/* If the actual attribute length has changed, move things around. */\n\tif (new_size != le32_to_cpu(a->length)) {\n\t\tu32 new_muse = le32_to_cpu(m->bytes_in_use) -\n\t\t\t\tle32_to_cpu(a->length) + new_size;\n\t\t/* Not enough space in this mft record. */\n\t\tif (new_muse > le32_to_cpu(m->bytes_allocated))\n\t\t\treturn -ENOSPC;\n\t\t/* Move attributes following @a to their new location. */\n\t\tmemmove((u8*)a + new_size, (u8*)a + le32_to_cpu(a->length),\n\t\t\t\tle32_to_cpu(m->bytes_in_use) - ((u8*)a -\n\t\t\t\t(u8*)m) - le32_to_cpu(a->length));\n\t\t/* Adjust @m to reflect the change in used space. */\n\t\tm->bytes_in_use = cpu_to_le32(new_muse);\n\t\t/* Adjust @a to reflect the new size. */\n\t\tif (new_size >= offsetof(ATTR_REC, length) + sizeof(a->length))\n\t\t\ta->length = cpu_to_le32(new_size);\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "NVolSetErrors",
          "args": [
            "vol"
          ],
          "line": 1977
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntfs_mapping_pairs_build",
          "args": [
            "vol",
            "(u8*)a + le16_to_cpu(\n\t\t\t\ta->data.non_resident.mapping_pairs_offset)",
            "old_alen - le16_to_cpu(\n\t\t\t\ta->data.non_resident.mapping_pairs_offset)",
            "rl2",
            "ll",
            "-1",
            "NULL"
          ],
          "line": 1970
        },
        "resolved": true,
        "details": {
          "function_name": "ntfs_mapping_pairs_build",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/runlist.c",
          "lines": "1323-1473",
          "snippet": "int ntfs_mapping_pairs_build(const ntfs_volume *vol, s8 *dst,\n\t\tconst int dst_len, const runlist_element *rl,\n\t\tconst VCN first_vcn, const VCN last_vcn, VCN *const stop_vcn)\n{\n\tLCN prev_lcn;\n\ts8 *dst_max, *dst_next;\n\tint err = -ENOSPC;\n\tbool the_end = false;\n\ts8 len_len, lcn_len;\n\n\tBUG_ON(first_vcn < 0);\n\tBUG_ON(last_vcn < -1);\n\tBUG_ON(last_vcn >= 0 && first_vcn > last_vcn);\n\tBUG_ON(dst_len < 1);\n\tif (!rl) {\n\t\tBUG_ON(first_vcn);\n\t\tBUG_ON(last_vcn > 0);\n\t\tif (stop_vcn)\n\t\t\t*stop_vcn = 0;\n\t\t/* Terminator byte. */\n\t\t*dst = 0;\n\t\treturn 0;\n\t}\n\t/* Skip to runlist element containing @first_vcn. */\n\twhile (rl->length && first_vcn >= rl[1].vcn)\n\t\trl++;\n\tif (unlikely((!rl->length && first_vcn > rl->vcn) ||\n\t\t\tfirst_vcn < rl->vcn))\n\t\treturn -EINVAL;\n\t/*\n\t * @dst_max is used for bounds checking in\n\t * ntfs_write_significant_bytes().\n\t */\n\tdst_max = dst + dst_len - 1;\n\tprev_lcn = 0;\n\t/* Do the first partial run if present. */\n\tif (first_vcn > rl->vcn) {\n\t\ts64 delta, length = rl->length;\n\n\t\t/* We know rl->length != 0 already. */\n\t\tif (unlikely(length < 0 || rl->lcn < LCN_HOLE))\n\t\t\tgoto err_out;\n\t\t/*\n\t\t * If @stop_vcn is given and finishes inside this run, cap the\n\t\t * run length.\n\t\t */\n\t\tif (unlikely(last_vcn >= 0 && rl[1].vcn > last_vcn)) {\n\t\t\ts64 s1 = last_vcn + 1;\n\t\t\tif (unlikely(rl[1].vcn > s1))\n\t\t\t\tlength = s1 - rl->vcn;\n\t\t\tthe_end = true;\n\t\t}\n\t\tdelta = first_vcn - rl->vcn;\n\t\t/* Write length. */\n\t\tlen_len = ntfs_write_significant_bytes(dst + 1, dst_max,\n\t\t\t\tlength - delta);\n\t\tif (unlikely(len_len < 0))\n\t\t\tgoto size_err;\n\t\t/*\n\t\t * If the logical cluster number (lcn) denotes a hole and we\n\t\t * are on NTFS 3.0+, we don't store it at all, i.e. we need\n\t\t * zero space.  On earlier NTFS versions we just write the lcn\n\t\t * change.  FIXME: Do we need to write the lcn change or just\n\t\t * the lcn in that case?  Not sure as I have never seen this\n\t\t * case on NT4. - We assume that we just need to write the lcn\n\t\t * change until someone tells us otherwise... (AIA)\n\t\t */\n\t\tif (likely(rl->lcn >= 0 || vol->major_ver < 3)) {\n\t\t\tprev_lcn = rl->lcn;\n\t\t\tif (likely(rl->lcn >= 0))\n\t\t\t\tprev_lcn += delta;\n\t\t\t/* Write change in lcn. */\n\t\t\tlcn_len = ntfs_write_significant_bytes(dst + 1 +\n\t\t\t\t\tlen_len, dst_max, prev_lcn);\n\t\t\tif (unlikely(lcn_len < 0))\n\t\t\t\tgoto size_err;\n\t\t} else\n\t\t\tlcn_len = 0;\n\t\tdst_next = dst + len_len + lcn_len + 1;\n\t\tif (unlikely(dst_next > dst_max))\n\t\t\tgoto size_err;\n\t\t/* Update header byte. */\n\t\t*dst = lcn_len << 4 | len_len;\n\t\t/* Position at next mapping pairs array element. */\n\t\tdst = dst_next;\n\t\t/* Go to next runlist element. */\n\t\trl++;\n\t}\n\t/* Do the full runs. */\n\tfor (; rl->length && !the_end; rl++) {\n\t\ts64 length = rl->length;\n\n\t\tif (unlikely(length < 0 || rl->lcn < LCN_HOLE))\n\t\t\tgoto err_out;\n\t\t/*\n\t\t * If @stop_vcn is given and finishes inside this run, cap the\n\t\t * run length.\n\t\t */\n\t\tif (unlikely(last_vcn >= 0 && rl[1].vcn > last_vcn)) {\n\t\t\ts64 s1 = last_vcn + 1;\n\t\t\tif (unlikely(rl[1].vcn > s1))\n\t\t\t\tlength = s1 - rl->vcn;\n\t\t\tthe_end = true;\n\t\t}\n\t\t/* Write length. */\n\t\tlen_len = ntfs_write_significant_bytes(dst + 1, dst_max,\n\t\t\t\tlength);\n\t\tif (unlikely(len_len < 0))\n\t\t\tgoto size_err;\n\t\t/*\n\t\t * If the logical cluster number (lcn) denotes a hole and we\n\t\t * are on NTFS 3.0+, we don't store it at all, i.e. we need\n\t\t * zero space.  On earlier NTFS versions we just write the lcn\n\t\t * change.  FIXME: Do we need to write the lcn change or just\n\t\t * the lcn in that case?  Not sure as I have never seen this\n\t\t * case on NT4. - We assume that we just need to write the lcn\n\t\t * change until someone tells us otherwise... (AIA)\n\t\t */\n\t\tif (likely(rl->lcn >= 0 || vol->major_ver < 3)) {\n\t\t\t/* Write change in lcn. */\n\t\t\tlcn_len = ntfs_write_significant_bytes(dst + 1 +\n\t\t\t\t\tlen_len, dst_max, rl->lcn - prev_lcn);\n\t\t\tif (unlikely(lcn_len < 0))\n\t\t\t\tgoto size_err;\n\t\t\tprev_lcn = rl->lcn;\n\t\t} else\n\t\t\tlcn_len = 0;\n\t\tdst_next = dst + len_len + lcn_len + 1;\n\t\tif (unlikely(dst_next > dst_max))\n\t\t\tgoto size_err;\n\t\t/* Update header byte. */\n\t\t*dst = lcn_len << 4 | len_len;\n\t\t/* Position at next mapping pairs array element. */\n\t\tdst = dst_next;\n\t}\n\t/* Success. */\n\terr = 0;\nsize_err:\n\t/* Set stop vcn. */\n\tif (stop_vcn)\n\t\t*stop_vcn = rl->vcn;\n\t/* Add terminator byte. */\n\t*dst = 0;\n\treturn err;\nerr_out:\n\tif (rl->lcn == LCN_RL_NOT_MAPPED)\n\t\terr = -EINVAL;\n\telse\n\t\terr = -EIO;\n\treturn err;\n}",
          "includes": [
            "#include \"ntfs.h\"",
            "#include \"malloc.h\"",
            "#include \"endian.h\"",
            "#include \"dir.h\"",
            "#include \"debug.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ntfs.h\"\n#include \"malloc.h\"\n#include \"endian.h\"\n#include \"dir.h\"\n#include \"debug.h\"\n\nint ntfs_mapping_pairs_build(const ntfs_volume *vol, s8 *dst,\n\t\tconst int dst_len, const runlist_element *rl,\n\t\tconst VCN first_vcn, const VCN last_vcn, VCN *const stop_vcn)\n{\n\tLCN prev_lcn;\n\ts8 *dst_max, *dst_next;\n\tint err = -ENOSPC;\n\tbool the_end = false;\n\ts8 len_len, lcn_len;\n\n\tBUG_ON(first_vcn < 0);\n\tBUG_ON(last_vcn < -1);\n\tBUG_ON(last_vcn >= 0 && first_vcn > last_vcn);\n\tBUG_ON(dst_len < 1);\n\tif (!rl) {\n\t\tBUG_ON(first_vcn);\n\t\tBUG_ON(last_vcn > 0);\n\t\tif (stop_vcn)\n\t\t\t*stop_vcn = 0;\n\t\t/* Terminator byte. */\n\t\t*dst = 0;\n\t\treturn 0;\n\t}\n\t/* Skip to runlist element containing @first_vcn. */\n\twhile (rl->length && first_vcn >= rl[1].vcn)\n\t\trl++;\n\tif (unlikely((!rl->length && first_vcn > rl->vcn) ||\n\t\t\tfirst_vcn < rl->vcn))\n\t\treturn -EINVAL;\n\t/*\n\t * @dst_max is used for bounds checking in\n\t * ntfs_write_significant_bytes().\n\t */\n\tdst_max = dst + dst_len - 1;\n\tprev_lcn = 0;\n\t/* Do the first partial run if present. */\n\tif (first_vcn > rl->vcn) {\n\t\ts64 delta, length = rl->length;\n\n\t\t/* We know rl->length != 0 already. */\n\t\tif (unlikely(length < 0 || rl->lcn < LCN_HOLE))\n\t\t\tgoto err_out;\n\t\t/*\n\t\t * If @stop_vcn is given and finishes inside this run, cap the\n\t\t * run length.\n\t\t */\n\t\tif (unlikely(last_vcn >= 0 && rl[1].vcn > last_vcn)) {\n\t\t\ts64 s1 = last_vcn + 1;\n\t\t\tif (unlikely(rl[1].vcn > s1))\n\t\t\t\tlength = s1 - rl->vcn;\n\t\t\tthe_end = true;\n\t\t}\n\t\tdelta = first_vcn - rl->vcn;\n\t\t/* Write length. */\n\t\tlen_len = ntfs_write_significant_bytes(dst + 1, dst_max,\n\t\t\t\tlength - delta);\n\t\tif (unlikely(len_len < 0))\n\t\t\tgoto size_err;\n\t\t/*\n\t\t * If the logical cluster number (lcn) denotes a hole and we\n\t\t * are on NTFS 3.0+, we don't store it at all, i.e. we need\n\t\t * zero space.  On earlier NTFS versions we just write the lcn\n\t\t * change.  FIXME: Do we need to write the lcn change or just\n\t\t * the lcn in that case?  Not sure as I have never seen this\n\t\t * case on NT4. - We assume that we just need to write the lcn\n\t\t * change until someone tells us otherwise... (AIA)\n\t\t */\n\t\tif (likely(rl->lcn >= 0 || vol->major_ver < 3)) {\n\t\t\tprev_lcn = rl->lcn;\n\t\t\tif (likely(rl->lcn >= 0))\n\t\t\t\tprev_lcn += delta;\n\t\t\t/* Write change in lcn. */\n\t\t\tlcn_len = ntfs_write_significant_bytes(dst + 1 +\n\t\t\t\t\tlen_len, dst_max, prev_lcn);\n\t\t\tif (unlikely(lcn_len < 0))\n\t\t\t\tgoto size_err;\n\t\t} else\n\t\t\tlcn_len = 0;\n\t\tdst_next = dst + len_len + lcn_len + 1;\n\t\tif (unlikely(dst_next > dst_max))\n\t\t\tgoto size_err;\n\t\t/* Update header byte. */\n\t\t*dst = lcn_len << 4 | len_len;\n\t\t/* Position at next mapping pairs array element. */\n\t\tdst = dst_next;\n\t\t/* Go to next runlist element. */\n\t\trl++;\n\t}\n\t/* Do the full runs. */\n\tfor (; rl->length && !the_end; rl++) {\n\t\ts64 length = rl->length;\n\n\t\tif (unlikely(length < 0 || rl->lcn < LCN_HOLE))\n\t\t\tgoto err_out;\n\t\t/*\n\t\t * If @stop_vcn is given and finishes inside this run, cap the\n\t\t * run length.\n\t\t */\n\t\tif (unlikely(last_vcn >= 0 && rl[1].vcn > last_vcn)) {\n\t\t\ts64 s1 = last_vcn + 1;\n\t\t\tif (unlikely(rl[1].vcn > s1))\n\t\t\t\tlength = s1 - rl->vcn;\n\t\t\tthe_end = true;\n\t\t}\n\t\t/* Write length. */\n\t\tlen_len = ntfs_write_significant_bytes(dst + 1, dst_max,\n\t\t\t\tlength);\n\t\tif (unlikely(len_len < 0))\n\t\t\tgoto size_err;\n\t\t/*\n\t\t * If the logical cluster number (lcn) denotes a hole and we\n\t\t * are on NTFS 3.0+, we don't store it at all, i.e. we need\n\t\t * zero space.  On earlier NTFS versions we just write the lcn\n\t\t * change.  FIXME: Do we need to write the lcn change or just\n\t\t * the lcn in that case?  Not sure as I have never seen this\n\t\t * case on NT4. - We assume that we just need to write the lcn\n\t\t * change until someone tells us otherwise... (AIA)\n\t\t */\n\t\tif (likely(rl->lcn >= 0 || vol->major_ver < 3)) {\n\t\t\t/* Write change in lcn. */\n\t\t\tlcn_len = ntfs_write_significant_bytes(dst + 1 +\n\t\t\t\t\tlen_len, dst_max, rl->lcn - prev_lcn);\n\t\t\tif (unlikely(lcn_len < 0))\n\t\t\t\tgoto size_err;\n\t\t\tprev_lcn = rl->lcn;\n\t\t} else\n\t\t\tlcn_len = 0;\n\t\tdst_next = dst + len_len + lcn_len + 1;\n\t\tif (unlikely(dst_next > dst_max))\n\t\t\tgoto size_err;\n\t\t/* Update header byte. */\n\t\t*dst = lcn_len << 4 | len_len;\n\t\t/* Position at next mapping pairs array element. */\n\t\tdst = dst_next;\n\t}\n\t/* Success. */\n\terr = 0;\nsize_err:\n\t/* Set stop vcn. */\n\tif (stop_vcn)\n\t\t*stop_vcn = rl->vcn;\n\t/* Add terminator byte. */\n\t*dst = 0;\n\treturn err;\nerr_out:\n\tif (rl->lcn == LCN_RL_NOT_MAPPED)\n\t\terr = -EINVAL;\n\telse\n\t\terr = -EIO;\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "le16_to_cpu",
          "args": [
            "a->data.non_resident.mapping_pairs_offset"
          ],
          "line": 1972
        },
        "resolved": true,
        "details": {
          "function_name": "sle16_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "48-51",
          "snippet": "static inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "ctx->mrec"
          ],
          "line": 1969
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NVolSetErrors",
          "args": [
            "vol"
          ],
          "line": 1967
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntfs_rl_truncate_nolock",
          "args": [
            "vol",
            "&mft_ni->runlist",
            "old_last_vcn"
          ],
          "line": 1964
        },
        "resolved": true,
        "details": {
          "function_name": "ntfs_rl_truncate_nolock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/runlist.c",
          "lines": "1499-1621",
          "snippet": "int ntfs_rl_truncate_nolock(const ntfs_volume *vol, runlist *const runlist,\n\t\tconst s64 new_length)\n{\n\trunlist_element *rl;\n\tint old_size;\n\n\tntfs_debug(\"Entering for new_length 0x%llx.\", (long long)new_length);\n\tBUG_ON(!runlist);\n\tBUG_ON(new_length < 0);\n\trl = runlist->rl;\n\tif (!new_length) {\n\t\tntfs_debug(\"Freeing runlist.\");\n\t\trunlist->rl = NULL;\n\t\tif (rl)\n\t\t\tntfs_free(rl);\n\t\treturn 0;\n\t}\n\tif (unlikely(!rl)) {\n\t\t/*\n\t\t * Create a runlist consisting of a sparse runlist element of\n\t\t * length @new_length followed by a terminator runlist element.\n\t\t */\n\t\trl = ntfs_malloc_nofs(PAGE_SIZE);\n\t\tif (unlikely(!rl)) {\n\t\t\tntfs_error(vol->sb, \"Not enough memory to allocate \"\n\t\t\t\t\t\"runlist element buffer.\");\n\t\t\treturn -ENOMEM;\n\t\t}\n\t\trunlist->rl = rl;\n\t\trl[1].length = rl->vcn = 0;\n\t\trl->lcn = LCN_HOLE;\n\t\trl[1].vcn = rl->length = new_length;\n\t\trl[1].lcn = LCN_ENOENT;\n\t\treturn 0;\n\t}\n\tBUG_ON(new_length < rl->vcn);\n\t/* Find @new_length in the runlist. */\n\twhile (likely(rl->length && new_length >= rl[1].vcn))\n\t\trl++;\n\t/*\n\t * If not at the end of the runlist we need to shrink it.\n\t * If at the end of the runlist we need to expand it.\n\t */\n\tif (rl->length) {\n\t\trunlist_element *trl;\n\t\tbool is_end;\n\n\t\tntfs_debug(\"Shrinking runlist.\");\n\t\t/* Determine the runlist size. */\n\t\ttrl = rl + 1;\n\t\twhile (likely(trl->length))\n\t\t\ttrl++;\n\t\told_size = trl - runlist->rl + 1;\n\t\t/* Truncate the run. */\n\t\trl->length = new_length - rl->vcn;\n\t\t/*\n\t\t * If a run was partially truncated, make the following runlist\n\t\t * element a terminator.\n\t\t */\n\t\tis_end = false;\n\t\tif (rl->length) {\n\t\t\trl++;\n\t\t\tif (!rl->length)\n\t\t\t\tis_end = true;\n\t\t\trl->vcn = new_length;\n\t\t\trl->length = 0;\n\t\t}\n\t\trl->lcn = LCN_ENOENT;\n\t\t/* Reallocate memory if necessary. */\n\t\tif (!is_end) {\n\t\t\tint new_size = rl - runlist->rl + 1;\n\t\t\trl = ntfs_rl_realloc(runlist->rl, old_size, new_size);\n\t\t\tif (IS_ERR(rl))\n\t\t\t\tntfs_warning(vol->sb, \"Failed to shrink \"\n\t\t\t\t\t\t\"runlist buffer.  This just \"\n\t\t\t\t\t\t\"wastes a bit of memory \"\n\t\t\t\t\t\t\"temporarily so we ignore it \"\n\t\t\t\t\t\t\"and return success.\");\n\t\t\telse\n\t\t\t\trunlist->rl = rl;\n\t\t}\n\t} else if (likely(/* !rl->length && */ new_length > rl->vcn)) {\n\t\tntfs_debug(\"Expanding runlist.\");\n\t\t/*\n\t\t * If there is a previous runlist element and it is a sparse\n\t\t * one, extend it.  Otherwise need to add a new, sparse runlist\n\t\t * element.\n\t\t */\n\t\tif ((rl > runlist->rl) && ((rl - 1)->lcn == LCN_HOLE))\n\t\t\t(rl - 1)->length = new_length - (rl - 1)->vcn;\n\t\telse {\n\t\t\t/* Determine the runlist size. */\n\t\t\told_size = rl - runlist->rl + 1;\n\t\t\t/* Reallocate memory if necessary. */\n\t\t\trl = ntfs_rl_realloc(runlist->rl, old_size,\n\t\t\t\t\told_size + 1);\n\t\t\tif (IS_ERR(rl)) {\n\t\t\t\tntfs_error(vol->sb, \"Failed to expand runlist \"\n\t\t\t\t\t\t\"buffer, aborting.\");\n\t\t\t\treturn PTR_ERR(rl);\n\t\t\t}\n\t\t\trunlist->rl = rl;\n\t\t\t/*\n\t\t\t * Set @rl to the same runlist element in the new\n\t\t\t * runlist as before in the old runlist.\n\t\t\t */\n\t\t\trl += old_size - 1;\n\t\t\t/* Add a new, sparse runlist element. */\n\t\t\trl->lcn = LCN_HOLE;\n\t\t\trl->length = new_length - rl->vcn;\n\t\t\t/* Add a new terminator runlist element. */\n\t\t\trl++;\n\t\t\trl->length = 0;\n\t\t}\n\t\trl->vcn = new_length;\n\t\trl->lcn = LCN_ENOENT;\n\t} else /* if (unlikely(!rl->length && new_length == rl->vcn)) */ {\n\t\t/* Runlist already has same size as requested. */\n\t\trl->lcn = LCN_ENOENT;\n\t}\n\tntfs_debug(\"Done.\");\n\treturn 0;\n}",
          "includes": [
            "#include \"ntfs.h\"",
            "#include \"malloc.h\"",
            "#include \"endian.h\"",
            "#include \"dir.h\"",
            "#include \"debug.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ntfs.h\"\n#include \"malloc.h\"\n#include \"endian.h\"\n#include \"dir.h\"\n#include \"debug.h\"\n\nint ntfs_rl_truncate_nolock(const ntfs_volume *vol, runlist *const runlist,\n\t\tconst s64 new_length)\n{\n\trunlist_element *rl;\n\tint old_size;\n\n\tntfs_debug(\"Entering for new_length 0x%llx.\", (long long)new_length);\n\tBUG_ON(!runlist);\n\tBUG_ON(new_length < 0);\n\trl = runlist->rl;\n\tif (!new_length) {\n\t\tntfs_debug(\"Freeing runlist.\");\n\t\trunlist->rl = NULL;\n\t\tif (rl)\n\t\t\tntfs_free(rl);\n\t\treturn 0;\n\t}\n\tif (unlikely(!rl)) {\n\t\t/*\n\t\t * Create a runlist consisting of a sparse runlist element of\n\t\t * length @new_length followed by a terminator runlist element.\n\t\t */\n\t\trl = ntfs_malloc_nofs(PAGE_SIZE);\n\t\tif (unlikely(!rl)) {\n\t\t\tntfs_error(vol->sb, \"Not enough memory to allocate \"\n\t\t\t\t\t\"runlist element buffer.\");\n\t\t\treturn -ENOMEM;\n\t\t}\n\t\trunlist->rl = rl;\n\t\trl[1].length = rl->vcn = 0;\n\t\trl->lcn = LCN_HOLE;\n\t\trl[1].vcn = rl->length = new_length;\n\t\trl[1].lcn = LCN_ENOENT;\n\t\treturn 0;\n\t}\n\tBUG_ON(new_length < rl->vcn);\n\t/* Find @new_length in the runlist. */\n\twhile (likely(rl->length && new_length >= rl[1].vcn))\n\t\trl++;\n\t/*\n\t * If not at the end of the runlist we need to shrink it.\n\t * If at the end of the runlist we need to expand it.\n\t */\n\tif (rl->length) {\n\t\trunlist_element *trl;\n\t\tbool is_end;\n\n\t\tntfs_debug(\"Shrinking runlist.\");\n\t\t/* Determine the runlist size. */\n\t\ttrl = rl + 1;\n\t\twhile (likely(trl->length))\n\t\t\ttrl++;\n\t\told_size = trl - runlist->rl + 1;\n\t\t/* Truncate the run. */\n\t\trl->length = new_length - rl->vcn;\n\t\t/*\n\t\t * If a run was partially truncated, make the following runlist\n\t\t * element a terminator.\n\t\t */\n\t\tis_end = false;\n\t\tif (rl->length) {\n\t\t\trl++;\n\t\t\tif (!rl->length)\n\t\t\t\tis_end = true;\n\t\t\trl->vcn = new_length;\n\t\t\trl->length = 0;\n\t\t}\n\t\trl->lcn = LCN_ENOENT;\n\t\t/* Reallocate memory if necessary. */\n\t\tif (!is_end) {\n\t\t\tint new_size = rl - runlist->rl + 1;\n\t\t\trl = ntfs_rl_realloc(runlist->rl, old_size, new_size);\n\t\t\tif (IS_ERR(rl))\n\t\t\t\tntfs_warning(vol->sb, \"Failed to shrink \"\n\t\t\t\t\t\t\"runlist buffer.  This just \"\n\t\t\t\t\t\t\"wastes a bit of memory \"\n\t\t\t\t\t\t\"temporarily so we ignore it \"\n\t\t\t\t\t\t\"and return success.\");\n\t\t\telse\n\t\t\t\trunlist->rl = rl;\n\t\t}\n\t} else if (likely(/* !rl->length && */ new_length > rl->vcn)) {\n\t\tntfs_debug(\"Expanding runlist.\");\n\t\t/*\n\t\t * If there is a previous runlist element and it is a sparse\n\t\t * one, extend it.  Otherwise need to add a new, sparse runlist\n\t\t * element.\n\t\t */\n\t\tif ((rl > runlist->rl) && ((rl - 1)->lcn == LCN_HOLE))\n\t\t\t(rl - 1)->length = new_length - (rl - 1)->vcn;\n\t\telse {\n\t\t\t/* Determine the runlist size. */\n\t\t\told_size = rl - runlist->rl + 1;\n\t\t\t/* Reallocate memory if necessary. */\n\t\t\trl = ntfs_rl_realloc(runlist->rl, old_size,\n\t\t\t\t\told_size + 1);\n\t\t\tif (IS_ERR(rl)) {\n\t\t\t\tntfs_error(vol->sb, \"Failed to expand runlist \"\n\t\t\t\t\t\t\"buffer, aborting.\");\n\t\t\t\treturn PTR_ERR(rl);\n\t\t\t}\n\t\t\trunlist->rl = rl;\n\t\t\t/*\n\t\t\t * Set @rl to the same runlist element in the new\n\t\t\t * runlist as before in the old runlist.\n\t\t\t */\n\t\t\trl += old_size - 1;\n\t\t\t/* Add a new, sparse runlist element. */\n\t\t\trl->lcn = LCN_HOLE;\n\t\t\trl->length = new_length - rl->vcn;\n\t\t\t/* Add a new terminator runlist element. */\n\t\t\trl++;\n\t\t\trl->length = 0;\n\t\t}\n\t\trl->vcn = new_length;\n\t\trl->lcn = LCN_ENOENT;\n\t} else /* if (unlikely(!rl->length && new_length == rl->vcn)) */ {\n\t\t/* Runlist already has same size as requested. */\n\t\trl->lcn = LCN_ENOENT;\n\t}\n\tntfs_debug(\"Done.\");\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "NVolSetErrors",
          "args": [
            "vol"
          ],
          "line": 1961
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntfs_cluster_free",
          "args": [
            "mft_ni",
            "old_last_vcn",
            "-1",
            "ctx"
          ],
          "line": 1958
        },
        "resolved": true,
        "details": {
          "function_name": "ntfs_cluster_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/lcnalloc.h",
          "lines": "107-111",
          "snippet": "static inline s64 ntfs_cluster_free(ntfs_inode *ni, const VCN start_vcn,\n\t\ts64 count, ntfs_attr_search_ctx *ctx)\n{\n\treturn __ntfs_cluster_free(ni, start_vcn, count, ctx, false);\n}",
          "includes": [
            "#include \"volume.h\"",
            "#include \"runlist.h\"",
            "#include \"inode.h\"",
            "#include \"types.h\"",
            "#include \"attrib.h\"",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"volume.h\"\n#include \"runlist.h\"\n#include \"inode.h\"\n#include \"types.h\"\n#include \"attrib.h\"\n#include <linux/fs.h>\n\nstatic inline s64 ntfs_cluster_free(ntfs_inode *ni, const VCN start_vcn,\n\t\ts64 count, ntfs_attr_search_ctx *ctx)\n{\n\treturn __ntfs_cluster_free(ni, start_vcn, count, ctx, false);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_sle64",
          "args": [
            "old_last_vcn - 1"
          ],
          "line": 1956
        },
        "resolved": true,
        "details": {
          "function_name": "cpu_to_sle64p",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "88-91",
          "snippet": "static inline sle64 cpu_to_sle64p(s64 *x)\n{\n\treturn (__force sle64)cpu_to_le64(*x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline sle64 cpu_to_sle64p(s64 *x)\n{\n\treturn (__force sle64)cpu_to_le64(*x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "NVolSetErrors",
          "args": [
            "vol"
          ],
          "line": 1952
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "up_write",
          "args": [
            "&mft_ni->runlist.lock"
          ],
          "line": 1947
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "write_unlock_irqrestore",
          "args": [
            "&mft_ni->size_lock",
            "flags"
          ],
          "line": 1944
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "write_lock_irqsave",
          "args": [
            "&mft_ni->size_lock",
            "flags"
          ],
          "line": 1942
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntfs_attr_lookup",
          "args": [
            "mft_ni->type",
            "mft_ni->name",
            "mft_ni->name_len",
            "CASE_SENSITIVE",
            "rl[1].vcn",
            "NULL",
            "0",
            "ctx"
          ],
          "line": 1938
        },
        "resolved": true,
        "details": {
          "function_name": "ntfs_attr_lookup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/attrib.c",
          "lines": "1187-1207",
          "snippet": "int ntfs_attr_lookup(const ATTR_TYPE type, const ntfschar *name,\n\t\tconst u32 name_len, const IGNORE_CASE_BOOL ic,\n\t\tconst VCN lowest_vcn, const u8 *val, const u32 val_len,\n\t\tntfs_attr_search_ctx *ctx)\n{\n\tntfs_inode *base_ni;\n\n\tntfs_debug(\"Entering.\");\n\tBUG_ON(IS_ERR(ctx->mrec));\n\tif (ctx->base_ntfs_ino)\n\t\tbase_ni = ctx->base_ntfs_ino;\n\telse\n\t\tbase_ni = ctx->ntfs_ino;\n\t/* Sanity check, just for debugging really. */\n\tBUG_ON(!base_ni);\n\tif (!NInoAttrList(base_ni) || type == AT_ATTRIBUTE_LIST)\n\t\treturn ntfs_attr_find(type, name, name_len, ic, val, val_len,\n\t\t\t\tctx);\n\treturn ntfs_external_attr_find(type, name, name_len, ic, lowest_vcn,\n\t\t\tval, val_len, ctx);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include \"ntfs.h\"",
            "#include \"mft.h\"",
            "#include \"malloc.h\"",
            "#include \"lcnalloc.h\"",
            "#include \"layout.h\"",
            "#include \"debug.h\"",
            "#include \"attrib.h\"",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include \"ntfs.h\"\n#include \"mft.h\"\n#include \"malloc.h\"\n#include \"lcnalloc.h\"\n#include \"layout.h\"\n#include \"debug.h\"\n#include \"attrib.h\"\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/buffer_head.h>\n\nint ntfs_attr_lookup(const ATTR_TYPE type, const ntfschar *name,\n\t\tconst u32 name_len, const IGNORE_CASE_BOOL ic,\n\t\tconst VCN lowest_vcn, const u8 *val, const u32 val_len,\n\t\tntfs_attr_search_ctx *ctx)\n{\n\tntfs_inode *base_ni;\n\n\tntfs_debug(\"Entering.\");\n\tBUG_ON(IS_ERR(ctx->mrec));\n\tif (ctx->base_ntfs_ino)\n\t\tbase_ni = ctx->base_ntfs_ino;\n\telse\n\t\tbase_ni = ctx->ntfs_ino;\n\t/* Sanity check, just for debugging really. */\n\tBUG_ON(!base_ni);\n\tif (!NInoAttrList(base_ni) || type == AT_ATTRIBUTE_LIST)\n\t\treturn ntfs_attr_find(type, name, name_len, ic, val, val_len,\n\t\t\t\tctx);\n\treturn ntfs_external_attr_find(type, name, name_len, ic, lowest_vcn,\n\t\t\tval, val_len, ctx);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ntfs_attr_reinit_search_ctx",
          "args": [
            "ctx"
          ],
          "line": 1937
        },
        "resolved": true,
        "details": {
          "function_name": "ntfs_attr_reinit_search_ctx",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/attrib.c",
          "lines": "1240-1259",
          "snippet": "void ntfs_attr_reinit_search_ctx(ntfs_attr_search_ctx *ctx)\n{\n\tif (likely(!ctx->base_ntfs_ino)) {\n\t\t/* No attribute list. */\n\t\tctx->is_first = true;\n\t\t/* Sanity checks are performed elsewhere. */\n\t\tctx->attr = (ATTR_RECORD*)((u8*)ctx->mrec +\n\t\t\t\tle16_to_cpu(ctx->mrec->attrs_offset));\n\t\t/*\n\t\t * This needs resetting due to ntfs_external_attr_find() which\n\t\t * can leave it set despite having zeroed ctx->base_ntfs_ino.\n\t\t */\n\t\tctx->al_entry = NULL;\n\t\treturn;\n\t} /* Attribute list. */\n\tif (ctx->ntfs_ino != ctx->base_ntfs_ino)\n\t\tunmap_extent_mft_record(ctx->ntfs_ino);\n\tntfs_attr_init_search_ctx(ctx, ctx->base_ntfs_ino, ctx->base_mrec);\n\treturn;\n}",
          "includes": [
            "#include \"types.h\"",
            "#include \"ntfs.h\"",
            "#include \"mft.h\"",
            "#include \"malloc.h\"",
            "#include \"lcnalloc.h\"",
            "#include \"layout.h\"",
            "#include \"debug.h\"",
            "#include \"attrib.h\"",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include \"ntfs.h\"\n#include \"mft.h\"\n#include \"malloc.h\"\n#include \"lcnalloc.h\"\n#include \"layout.h\"\n#include \"debug.h\"\n#include \"attrib.h\"\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/buffer_head.h>\n\nvoid ntfs_attr_reinit_search_ctx(ntfs_attr_search_ctx *ctx)\n{\n\tif (likely(!ctx->base_ntfs_ino)) {\n\t\t/* No attribute list. */\n\t\tctx->is_first = true;\n\t\t/* Sanity checks are performed elsewhere. */\n\t\tctx->attr = (ATTR_RECORD*)((u8*)ctx->mrec +\n\t\t\t\tle16_to_cpu(ctx->mrec->attrs_offset));\n\t\t/*\n\t\t * This needs resetting due to ntfs_external_attr_find() which\n\t\t * can leave it set despite having zeroed ctx->base_ntfs_ino.\n\t\t */\n\t\tctx->al_entry = NULL;\n\t\treturn;\n\t} /* Attribute list. */\n\tif (ctx->ntfs_ino != ctx->base_ntfs_ino)\n\t\tunmap_extent_mft_record(ctx->ntfs_ino);\n\tntfs_attr_init_search_ctx(ctx, ctx->base_ntfs_ino, ctx->base_mrec);\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ntfs_debug",
          "args": [
            "\"Done.\""
          ],
          "line": 1934
        },
        "resolved": true,
        "details": {
          "function_name": "ntfs_debug_dump_runlist",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/debug.c",
          "lines": "134-171",
          "snippet": "void ntfs_debug_dump_runlist(const runlist_element *rl)\n{\n\tint i;\n\tconst char *lcn_str[5] = { \"LCN_HOLE         \", \"LCN_RL_NOT_MAPPED\",\n\t\t\t\t   \"LCN_ENOENT       \", \"LCN_unknown      \" };\n\n\tif (!debug_msgs)\n\t\treturn;\n\tpr_debug(\"Dumping runlist (values in hex):\\n\");\n\tif (!rl) {\n\t\tpr_debug(\"Run list not present.\\n\");\n\t\treturn;\n\t}\n\tpr_debug(\"VCN              LCN               Run length\\n\");\n\tfor (i = 0; ; i++) {\n\t\tLCN lcn = (rl + i)->lcn;\n\n\t\tif (lcn < (LCN)0) {\n\t\t\tint index = -lcn - 1;\n\n\t\t\tif (index > -LCN_ENOENT - 1)\n\t\t\t\tindex = 3;\n\t\t\tpr_debug(\"%-16Lx %s %-16Lx%s\\n\",\n\t\t\t\t\t(long long)(rl + i)->vcn, lcn_str[index],\n\t\t\t\t\t(long long)(rl + i)->length,\n\t\t\t\t\t(rl + i)->length ? \"\" :\n\t\t\t\t\t\t\" (runlist end)\");\n\t\t} else\n\t\t\tpr_debug(\"%-16Lx %-16Lx  %-16Lx%s\\n\",\n\t\t\t\t\t(long long)(rl + i)->vcn,\n\t\t\t\t\t(long long)(rl + i)->lcn,\n\t\t\t\t\t(long long)(rl + i)->length,\n\t\t\t\t\t(rl + i)->length ? \"\" :\n\t\t\t\t\t\t\" (runlist end)\");\n\t\tif (!(rl + i)->length)\n\t\t\tbreak;\n\t}\n}",
          "includes": [
            "#include \"debug.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"debug.h\"\n\nvoid ntfs_debug_dump_runlist(const runlist_element *rl)\n{\n\tint i;\n\tconst char *lcn_str[5] = { \"LCN_HOLE         \", \"LCN_RL_NOT_MAPPED\",\n\t\t\t\t   \"LCN_ENOENT       \", \"LCN_unknown      \" };\n\n\tif (!debug_msgs)\n\t\treturn;\n\tpr_debug(\"Dumping runlist (values in hex):\\n\");\n\tif (!rl) {\n\t\tpr_debug(\"Run list not present.\\n\");\n\t\treturn;\n\t}\n\tpr_debug(\"VCN              LCN               Run length\\n\");\n\tfor (i = 0; ; i++) {\n\t\tLCN lcn = (rl + i)->lcn;\n\n\t\tif (lcn < (LCN)0) {\n\t\t\tint index = -lcn - 1;\n\n\t\t\tif (index > -LCN_ENOENT - 1)\n\t\t\t\tindex = 3;\n\t\t\tpr_debug(\"%-16Lx %s %-16Lx%s\\n\",\n\t\t\t\t\t(long long)(rl + i)->vcn, lcn_str[index],\n\t\t\t\t\t(long long)(rl + i)->length,\n\t\t\t\t\t(rl + i)->length ? \"\" :\n\t\t\t\t\t\t\" (runlist end)\");\n\t\t} else\n\t\t\tpr_debug(\"%-16Lx %-16Lx  %-16Lx%s\\n\",\n\t\t\t\t\t(long long)(rl + i)->vcn,\n\t\t\t\t\t(long long)(rl + i)->lcn,\n\t\t\t\t\t(long long)(rl + i)->length,\n\t\t\t\t\t(rl + i)->length ? \"\" :\n\t\t\t\t\t\t\" (runlist end)\");\n\t\tif (!(rl + i)->length)\n\t\t\tbreak;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "up_write",
          "args": [
            "&mft_ni->runlist.lock"
          ],
          "line": 1933
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "write_unlock_irqrestore",
          "args": [
            "&mft_ni->size_lock",
            "flags"
          ],
          "line": 1927
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "write_lock_irqsave",
          "args": [
            "&mft_ni->size_lock",
            "flags"
          ],
          "line": 1923
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntfs_error",
          "args": [
            "vol->sb",
            "\"Failed to find first attribute \"\n\t\t\t\t\t\"extent of mft data attribute.\""
          ],
          "line": 1917
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "ret"
          ],
          "line": 1916
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntfs_error",
          "args": [
            "vol->sb",
            "\"Failed to build mapping pairs array of \"\n\t\t\t\t\"mft data attribute.\""
          ],
          "line": 1893
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "ret"
          ],
          "line": 1892
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntfs_error",
          "args": [
            "vol->sb",
            "\"Not enough space in this mft record to \"\n\t\t\t\t\"accommodate extended mft data attribute \"\n\t\t\t\t\"extent.  Cannot handle this yet.\""
          ],
          "line": 1881
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntfs_error",
          "args": [
            "vol->sb",
            "\"Failed to resize attribute \"\n\t\t\t\t\t\"record for mft data attribute.\""
          ],
          "line": 1867
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "ret"
          ],
          "line": 1865
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "a->length"
          ],
          "line": 1862
        },
        "resolved": true,
        "details": {
          "function_name": "sle32_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "53-56",
          "snippet": "static inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ntfs_error",
          "args": [
            "vol->sb",
            "\"Get size for mapping pairs failed for \"\n\t\t\t\t\"mft data attribute extent.\""
          ],
          "line": 1854
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "mp_size <= 0"
          ],
          "line": 1853
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntfs_get_size_for_mapping_pairs",
          "args": [
            "vol",
            "rl2",
            "ll",
            "-1"
          ],
          "line": 1852
        },
        "resolved": true,
        "details": {
          "function_name": "ntfs_get_size_for_mapping_pairs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/runlist.c",
          "lines": "1131-1232",
          "snippet": "int ntfs_get_size_for_mapping_pairs(const ntfs_volume *vol,\n\t\tconst runlist_element *rl, const VCN first_vcn,\n\t\tconst VCN last_vcn)\n{\n\tLCN prev_lcn;\n\tint rls;\n\tbool the_end = false;\n\n\tBUG_ON(first_vcn < 0);\n\tBUG_ON(last_vcn < -1);\n\tBUG_ON(last_vcn >= 0 && first_vcn > last_vcn);\n\tif (!rl) {\n\t\tBUG_ON(first_vcn);\n\t\tBUG_ON(last_vcn > 0);\n\t\treturn 1;\n\t}\n\t/* Skip to runlist element containing @first_vcn. */\n\twhile (rl->length && first_vcn >= rl[1].vcn)\n\t\trl++;\n\tif (unlikely((!rl->length && first_vcn > rl->vcn) ||\n\t\t\tfirst_vcn < rl->vcn))\n\t\treturn -EINVAL;\n\tprev_lcn = 0;\n\t/* Always need the termining zero byte. */\n\trls = 1;\n\t/* Do the first partial run if present. */\n\tif (first_vcn > rl->vcn) {\n\t\ts64 delta, length = rl->length;\n\n\t\t/* We know rl->length != 0 already. */\n\t\tif (unlikely(length < 0 || rl->lcn < LCN_HOLE))\n\t\t\tgoto err_out;\n\t\t/*\n\t\t * If @stop_vcn is given and finishes inside this run, cap the\n\t\t * run length.\n\t\t */\n\t\tif (unlikely(last_vcn >= 0 && rl[1].vcn > last_vcn)) {\n\t\t\ts64 s1 = last_vcn + 1;\n\t\t\tif (unlikely(rl[1].vcn > s1))\n\t\t\t\tlength = s1 - rl->vcn;\n\t\t\tthe_end = true;\n\t\t}\n\t\tdelta = first_vcn - rl->vcn;\n\t\t/* Header byte + length. */\n\t\trls += 1 + ntfs_get_nr_significant_bytes(length - delta);\n\t\t/*\n\t\t * If the logical cluster number (lcn) denotes a hole and we\n\t\t * are on NTFS 3.0+, we don't store it at all, i.e. we need\n\t\t * zero space.  On earlier NTFS versions we just store the lcn.\n\t\t * Note: this assumes that on NTFS 1.2-, holes are stored with\n\t\t * an lcn of -1 and not a delta_lcn of -1 (unless both are -1).\n\t\t */\n\t\tif (likely(rl->lcn >= 0 || vol->major_ver < 3)) {\n\t\t\tprev_lcn = rl->lcn;\n\t\t\tif (likely(rl->lcn >= 0))\n\t\t\t\tprev_lcn += delta;\n\t\t\t/* Change in lcn. */\n\t\t\trls += ntfs_get_nr_significant_bytes(prev_lcn);\n\t\t}\n\t\t/* Go to next runlist element. */\n\t\trl++;\n\t}\n\t/* Do the full runs. */\n\tfor (; rl->length && !the_end; rl++) {\n\t\ts64 length = rl->length;\n\n\t\tif (unlikely(length < 0 || rl->lcn < LCN_HOLE))\n\t\t\tgoto err_out;\n\t\t/*\n\t\t * If @stop_vcn is given and finishes inside this run, cap the\n\t\t * run length.\n\t\t */\n\t\tif (unlikely(last_vcn >= 0 && rl[1].vcn > last_vcn)) {\n\t\t\ts64 s1 = last_vcn + 1;\n\t\t\tif (unlikely(rl[1].vcn > s1))\n\t\t\t\tlength = s1 - rl->vcn;\n\t\t\tthe_end = true;\n\t\t}\n\t\t/* Header byte + length. */\n\t\trls += 1 + ntfs_get_nr_significant_bytes(length);\n\t\t/*\n\t\t * If the logical cluster number (lcn) denotes a hole and we\n\t\t * are on NTFS 3.0+, we don't store it at all, i.e. we need\n\t\t * zero space.  On earlier NTFS versions we just store the lcn.\n\t\t * Note: this assumes that on NTFS 1.2-, holes are stored with\n\t\t * an lcn of -1 and not a delta_lcn of -1 (unless both are -1).\n\t\t */\n\t\tif (likely(rl->lcn >= 0 || vol->major_ver < 3)) {\n\t\t\t/* Change in lcn. */\n\t\t\trls += ntfs_get_nr_significant_bytes(rl->lcn -\n\t\t\t\t\tprev_lcn);\n\t\t\tprev_lcn = rl->lcn;\n\t\t}\n\t}\n\treturn rls;\nerr_out:\n\tif (rl->lcn == LCN_RL_NOT_MAPPED)\n\t\trls = -EINVAL;\n\telse\n\t\trls = -EIO;\n\treturn rls;\n}",
          "includes": [
            "#include \"ntfs.h\"",
            "#include \"malloc.h\"",
            "#include \"endian.h\"",
            "#include \"dir.h\"",
            "#include \"debug.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ntfs.h\"\n#include \"malloc.h\"\n#include \"endian.h\"\n#include \"dir.h\"\n#include \"debug.h\"\n\nint ntfs_get_size_for_mapping_pairs(const ntfs_volume *vol,\n\t\tconst runlist_element *rl, const VCN first_vcn,\n\t\tconst VCN last_vcn)\n{\n\tLCN prev_lcn;\n\tint rls;\n\tbool the_end = false;\n\n\tBUG_ON(first_vcn < 0);\n\tBUG_ON(last_vcn < -1);\n\tBUG_ON(last_vcn >= 0 && first_vcn > last_vcn);\n\tif (!rl) {\n\t\tBUG_ON(first_vcn);\n\t\tBUG_ON(last_vcn > 0);\n\t\treturn 1;\n\t}\n\t/* Skip to runlist element containing @first_vcn. */\n\twhile (rl->length && first_vcn >= rl[1].vcn)\n\t\trl++;\n\tif (unlikely((!rl->length && first_vcn > rl->vcn) ||\n\t\t\tfirst_vcn < rl->vcn))\n\t\treturn -EINVAL;\n\tprev_lcn = 0;\n\t/* Always need the termining zero byte. */\n\trls = 1;\n\t/* Do the first partial run if present. */\n\tif (first_vcn > rl->vcn) {\n\t\ts64 delta, length = rl->length;\n\n\t\t/* We know rl->length != 0 already. */\n\t\tif (unlikely(length < 0 || rl->lcn < LCN_HOLE))\n\t\t\tgoto err_out;\n\t\t/*\n\t\t * If @stop_vcn is given and finishes inside this run, cap the\n\t\t * run length.\n\t\t */\n\t\tif (unlikely(last_vcn >= 0 && rl[1].vcn > last_vcn)) {\n\t\t\ts64 s1 = last_vcn + 1;\n\t\t\tif (unlikely(rl[1].vcn > s1))\n\t\t\t\tlength = s1 - rl->vcn;\n\t\t\tthe_end = true;\n\t\t}\n\t\tdelta = first_vcn - rl->vcn;\n\t\t/* Header byte + length. */\n\t\trls += 1 + ntfs_get_nr_significant_bytes(length - delta);\n\t\t/*\n\t\t * If the logical cluster number (lcn) denotes a hole and we\n\t\t * are on NTFS 3.0+, we don't store it at all, i.e. we need\n\t\t * zero space.  On earlier NTFS versions we just store the lcn.\n\t\t * Note: this assumes that on NTFS 1.2-, holes are stored with\n\t\t * an lcn of -1 and not a delta_lcn of -1 (unless both are -1).\n\t\t */\n\t\tif (likely(rl->lcn >= 0 || vol->major_ver < 3)) {\n\t\t\tprev_lcn = rl->lcn;\n\t\t\tif (likely(rl->lcn >= 0))\n\t\t\t\tprev_lcn += delta;\n\t\t\t/* Change in lcn. */\n\t\t\trls += ntfs_get_nr_significant_bytes(prev_lcn);\n\t\t}\n\t\t/* Go to next runlist element. */\n\t\trl++;\n\t}\n\t/* Do the full runs. */\n\tfor (; rl->length && !the_end; rl++) {\n\t\ts64 length = rl->length;\n\n\t\tif (unlikely(length < 0 || rl->lcn < LCN_HOLE))\n\t\t\tgoto err_out;\n\t\t/*\n\t\t * If @stop_vcn is given and finishes inside this run, cap the\n\t\t * run length.\n\t\t */\n\t\tif (unlikely(last_vcn >= 0 && rl[1].vcn > last_vcn)) {\n\t\t\ts64 s1 = last_vcn + 1;\n\t\t\tif (unlikely(rl[1].vcn > s1))\n\t\t\t\tlength = s1 - rl->vcn;\n\t\t\tthe_end = true;\n\t\t}\n\t\t/* Header byte + length. */\n\t\trls += 1 + ntfs_get_nr_significant_bytes(length);\n\t\t/*\n\t\t * If the logical cluster number (lcn) denotes a hole and we\n\t\t * are on NTFS 3.0+, we don't store it at all, i.e. we need\n\t\t * zero space.  On earlier NTFS versions we just store the lcn.\n\t\t * Note: this assumes that on NTFS 1.2-, holes are stored with\n\t\t * an lcn of -1 and not a delta_lcn of -1 (unless both are -1).\n\t\t */\n\t\tif (likely(rl->lcn >= 0 || vol->major_ver < 3)) {\n\t\t\t/* Change in lcn. */\n\t\t\trls += ntfs_get_nr_significant_bytes(rl->lcn -\n\t\t\t\t\tprev_lcn);\n\t\t\tprev_lcn = rl->lcn;\n\t\t}\n\t}\n\treturn rls;\nerr_out:\n\tif (rl->lcn == LCN_RL_NOT_MAPPED)\n\t\trls = -EINVAL;\n\telse\n\t\trls = -EIO;\n\treturn rls;\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "ll >= rl2->vcn + rl2->length"
          ],
          "line": 1850
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "ll < rl2->vcn"
          ],
          "line": 1849
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sle64_to_cpu",
          "args": [
            "a->data.non_resident.lowest_vcn"
          ],
          "line": 1843
        },
        "resolved": true,
        "details": {
          "function_name": "sle64_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "58-61",
          "snippet": "static inline s64 sle64_to_cpup(sle64 *x)\n{\n\treturn le64_to_cpu(*(__force le64*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s64 sle64_to_cpup(sle64 *x)\n{\n\treturn le64_to_cpu(*(__force le64*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ntfs_error",
          "args": [
            "vol->sb",
            "\"Failed to find last attribute extent of \"\n\t\t\t\t\"mft data attribute.\""
          ],
          "line": 1836
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "ret"
          ],
          "line": 1835
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntfs_error",
          "args": [
            "vol->sb",
            "\"Failed to get search context.\""
          ],
          "line": 1829
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!ctx"
          ],
          "line": 1828
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntfs_attr_get_search_ctx",
          "args": [
            "mft_ni",
            "mrec"
          ],
          "line": 1827
        },
        "resolved": true,
        "details": {
          "function_name": "ntfs_attr_get_search_ctx",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/attrib.c",
          "lines": "1269-1277",
          "snippet": "ntfs_attr_search_ctx *ntfs_attr_get_search_ctx(ntfs_inode *ni, MFT_RECORD *mrec)\n{\n\tntfs_attr_search_ctx *ctx;\n\n\tctx = kmem_cache_alloc(ntfs_attr_ctx_cache, GFP_NOFS);\n\tif (ctx)\n\t\tntfs_attr_init_search_ctx(ctx, ni, mrec);\n\treturn ctx;\n}",
          "includes": [
            "#include \"types.h\"",
            "#include \"ntfs.h\"",
            "#include \"mft.h\"",
            "#include \"malloc.h\"",
            "#include \"lcnalloc.h\"",
            "#include \"layout.h\"",
            "#include \"debug.h\"",
            "#include \"attrib.h\"",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include \"ntfs.h\"\n#include \"mft.h\"\n#include \"malloc.h\"\n#include \"lcnalloc.h\"\n#include \"layout.h\"\n#include \"debug.h\"\n#include \"attrib.h\"\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/buffer_head.h>\n\nntfs_attr_search_ctx *ntfs_attr_get_search_ctx(ntfs_inode *ni, MFT_RECORD *mrec)\n{\n\tntfs_attr_search_ctx *ctx;\n\n\tctx = kmem_cache_alloc(ntfs_attr_ctx_cache, GFP_NOFS);\n\tif (ctx)\n\t\tntfs_attr_init_search_ctx(ctx, ni, mrec);\n\treturn ctx;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "mrec"
          ],
          "line": 1824
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntfs_error",
          "args": [
            "vol->sb",
            "\"Failed to map mft record.\""
          ],
          "line": 1823
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "mrec"
          ],
          "line": 1822
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntfs_debug",
          "args": [
            "\"Allocated %lli clusters.\"",
            "(long long)nr"
          ],
          "line": 1816
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "rl"
          ],
          "line": 1813
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntfs_free",
          "args": [
            "rl2"
          ],
          "line": 1812
        },
        "resolved": true,
        "details": {
          "function_name": "ntfs_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/malloc.h",
          "lines": "86-94",
          "snippet": "static inline void ntfs_free(void *addr)\n{\n\tif (!is_vmalloc_addr(addr)) {\n\t\tkfree(addr);\n\t\t/* free_page((unsigned long)addr); */\n\t\treturn;\n\t}\n\tvfree(addr);\n}",
          "includes": [
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/vmalloc.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n\nstatic inline void ntfs_free(void *addr)\n{\n\tif (!is_vmalloc_addr(addr)) {\n\t\tkfree(addr);\n\t\t/* free_page((unsigned long)addr); */\n\t\treturn;\n\t}\n\tvfree(addr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "NVolSetErrors",
          "args": [
            "vol"
          ],
          "line": 1810
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntfs_cluster_free_from_rl",
          "args": [
            "vol",
            "rl2"
          ],
          "line": 1807
        },
        "resolved": true,
        "details": {
          "function_name": "ntfs_cluster_free_from_rl",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/lcnalloc.h",
          "lines": "132-141",
          "snippet": "static inline int ntfs_cluster_free_from_rl(ntfs_volume *vol,\n\t\tconst runlist_element *rl)\n{\n\tint ret;\n\n\tdown_write(&vol->lcnbmp_lock);\n\tret = ntfs_cluster_free_from_rl_nolock(vol, rl);\n\tup_write(&vol->lcnbmp_lock);\n\treturn ret;\n}",
          "includes": [
            "#include \"volume.h\"",
            "#include \"runlist.h\"",
            "#include \"inode.h\"",
            "#include \"types.h\"",
            "#include \"attrib.h\"",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"volume.h\"\n#include \"runlist.h\"\n#include \"inode.h\"\n#include \"types.h\"\n#include \"attrib.h\"\n#include <linux/fs.h>\n\nstatic inline int ntfs_cluster_free_from_rl(ntfs_volume *vol,\n\t\tconst runlist_element *rl)\n{\n\tint ret;\n\n\tdown_write(&vol->lcnbmp_lock);\n\tret = ntfs_cluster_free_from_rl_nolock(vol, rl);\n\tup_write(&vol->lcnbmp_lock);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ntfs_error",
          "args": [
            "vol->sb",
            "\"Failed to merge runlists for mft data \"\n\t\t\t\t\"attribute.\""
          ],
          "line": 1805
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "up_write",
          "args": [
            "&mft_ni->runlist.lock"
          ],
          "line": 1804
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "rl"
          ],
          "line": 1803
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntfs_runlists_merge",
          "args": [
            "mft_ni->runlist.rl",
            "rl2"
          ],
          "line": 1802
        },
        "resolved": true,
        "details": {
          "function_name": "ntfs_runlists_merge",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/runlist.c",
          "lines": "531-719",
          "snippet": "runlist_element *ntfs_runlists_merge(runlist_element *drl,\n\t\trunlist_element *srl)\n{\n\tint di, si;\t\t/* Current index into @[ds]rl. */\n\tint sstart;\t\t/* First index with lcn > LCN_RL_NOT_MAPPED. */\n\tint dins;\t\t/* Index into @drl at which to insert @srl. */\n\tint dend, send;\t\t/* Last index into @[ds]rl. */\n\tint dfinal, sfinal;\t/* The last index into @[ds]rl with\n\t\t\t\t   lcn >= LCN_HOLE. */\n\tint marker = 0;\n\tVCN marker_vcn = 0;\n\n#ifdef DEBUG\n\tntfs_debug(\"dst:\");\n\tntfs_debug_dump_runlist(drl);\n\tntfs_debug(\"src:\");\n\tntfs_debug_dump_runlist(srl);\n#endif\n\n\t/* Check for silly calling... */\n\tif (unlikely(!srl))\n\t\treturn drl;\n\tif (IS_ERR(srl) || IS_ERR(drl))\n\t\treturn ERR_PTR(-EINVAL);\n\n\t/* Check for the case where the first mapping is being done now. */\n\tif (unlikely(!drl)) {\n\t\tdrl = srl;\n\t\t/* Complete the source runlist if necessary. */\n\t\tif (unlikely(drl[0].vcn)) {\n\t\t\t/* Scan to the end of the source runlist. */\n\t\t\tfor (dend = 0; likely(drl[dend].length); dend++)\n\t\t\t\t;\n\t\t\tdend++;\n\t\t\tdrl = ntfs_rl_realloc(drl, dend, dend + 1);\n\t\t\tif (IS_ERR(drl))\n\t\t\t\treturn drl;\n\t\t\t/* Insert start element at the front of the runlist. */\n\t\t\tntfs_rl_mm(drl, 1, 0, dend);\n\t\t\tdrl[0].vcn = 0;\n\t\t\tdrl[0].lcn = LCN_RL_NOT_MAPPED;\n\t\t\tdrl[0].length = drl[1].vcn;\n\t\t}\n\t\tgoto finished;\n\t}\n\n\tsi = di = 0;\n\n\t/* Skip any unmapped start element(s) in the source runlist. */\n\twhile (srl[si].length && srl[si].lcn < LCN_HOLE)\n\t\tsi++;\n\n\t/* Can't have an entirely unmapped source runlist. */\n\tBUG_ON(!srl[si].length);\n\n\t/* Record the starting points. */\n\tsstart = si;\n\n\t/*\n\t * Skip forward in @drl until we reach the position where @srl needs to\n\t * be inserted. If we reach the end of @drl, @srl just needs to be\n\t * appended to @drl.\n\t */\n\tfor (; drl[di].length; di++) {\n\t\tif (drl[di].vcn + drl[di].length > srl[sstart].vcn)\n\t\t\tbreak;\n\t}\n\tdins = di;\n\n\t/* Sanity check for illegal overlaps. */\n\tif ((drl[di].vcn == srl[si].vcn) && (drl[di].lcn >= 0) &&\n\t\t\t(srl[si].lcn >= 0)) {\n\t\tntfs_error(NULL, \"Run lists overlap. Cannot merge!\");\n\t\treturn ERR_PTR(-ERANGE);\n\t}\n\n\t/* Scan to the end of both runlists in order to know their sizes. */\n\tfor (send = si; srl[send].length; send++)\n\t\t;\n\tfor (dend = di; drl[dend].length; dend++)\n\t\t;\n\n\tif (srl[send].lcn == LCN_ENOENT)\n\t\tmarker_vcn = srl[marker = send].vcn;\n\n\t/* Scan to the last element with lcn >= LCN_HOLE. */\n\tfor (sfinal = send; sfinal >= 0 && srl[sfinal].lcn < LCN_HOLE; sfinal--)\n\t\t;\n\tfor (dfinal = dend; dfinal >= 0 && drl[dfinal].lcn < LCN_HOLE; dfinal--)\n\t\t;\n\n\t{\n\tbool start;\n\tbool finish;\n\tint ds = dend + 1;\t\t/* Number of elements in drl & srl */\n\tint ss = sfinal - sstart + 1;\n\n\tstart  = ((drl[dins].lcn <  LCN_RL_NOT_MAPPED) ||    /* End of file   */\n\t\t  (drl[dins].vcn == srl[sstart].vcn));\t     /* Start of hole */\n\tfinish = ((drl[dins].lcn >= LCN_RL_NOT_MAPPED) &&    /* End of file   */\n\t\t ((drl[dins].vcn + drl[dins].length) <=      /* End of hole   */\n\t\t  (srl[send - 1].vcn + srl[send - 1].length)));\n\n\t/* Or we will lose an end marker. */\n\tif (finish && !drl[dins].length)\n\t\tss++;\n\tif (marker && (drl[dins].vcn + drl[dins].length > srl[send - 1].vcn))\n\t\tfinish = false;\n#if 0\n\tntfs_debug(\"dfinal = %i, dend = %i\", dfinal, dend);\n\tntfs_debug(\"sstart = %i, sfinal = %i, send = %i\", sstart, sfinal, send);\n\tntfs_debug(\"start = %i, finish = %i\", start, finish);\n\tntfs_debug(\"ds = %i, ss = %i, dins = %i\", ds, ss, dins);\n#endif\n\tif (start) {\n\t\tif (finish)\n\t\t\tdrl = ntfs_rl_replace(drl, ds, srl + sstart, ss, dins);\n\t\telse\n\t\t\tdrl = ntfs_rl_insert(drl, ds, srl + sstart, ss, dins);\n\t} else {\n\t\tif (finish)\n\t\t\tdrl = ntfs_rl_append(drl, ds, srl + sstart, ss, dins);\n\t\telse\n\t\t\tdrl = ntfs_rl_split(drl, ds, srl + sstart, ss, dins);\n\t}\n\tif (IS_ERR(drl)) {\n\t\tntfs_error(NULL, \"Merge failed.\");\n\t\treturn drl;\n\t}\n\tntfs_free(srl);\n\tif (marker) {\n\t\tntfs_debug(\"Triggering marker code.\");\n\t\tfor (ds = dend; drl[ds].length; ds++)\n\t\t\t;\n\t\t/* We only need to care if @srl ended after @drl. */\n\t\tif (drl[ds].vcn <= marker_vcn) {\n\t\t\tint slots = 0;\n\n\t\t\tif (drl[ds].vcn == marker_vcn) {\n\t\t\t\tntfs_debug(\"Old marker = 0x%llx, replacing \"\n\t\t\t\t\t\t\"with LCN_ENOENT.\",\n\t\t\t\t\t\t(unsigned long long)\n\t\t\t\t\t\tdrl[ds].lcn);\n\t\t\t\tdrl[ds].lcn = LCN_ENOENT;\n\t\t\t\tgoto finished;\n\t\t\t}\n\t\t\t/*\n\t\t\t * We need to create an unmapped runlist element in\n\t\t\t * @drl or extend an existing one before adding the\n\t\t\t * ENOENT terminator.\n\t\t\t */\n\t\t\tif (drl[ds].lcn == LCN_ENOENT) {\n\t\t\t\tds--;\n\t\t\t\tslots = 1;\n\t\t\t}\n\t\t\tif (drl[ds].lcn != LCN_RL_NOT_MAPPED) {\n\t\t\t\t/* Add an unmapped runlist element. */\n\t\t\t\tif (!slots) {\n\t\t\t\t\tdrl = ntfs_rl_realloc_nofail(drl, ds,\n\t\t\t\t\t\t\tds + 2);\n\t\t\t\t\tslots = 2;\n\t\t\t\t}\n\t\t\t\tds++;\n\t\t\t\t/* Need to set vcn if it isn't set already. */\n\t\t\t\tif (slots != 1)\n\t\t\t\t\tdrl[ds].vcn = drl[ds - 1].vcn +\n\t\t\t\t\t\t\tdrl[ds - 1].length;\n\t\t\t\tdrl[ds].lcn = LCN_RL_NOT_MAPPED;\n\t\t\t\t/* We now used up a slot. */\n\t\t\t\tslots--;\n\t\t\t}\n\t\t\tdrl[ds].length = marker_vcn - drl[ds].vcn;\n\t\t\t/* Finally add the ENOENT terminator. */\n\t\t\tds++;\n\t\t\tif (!slots)\n\t\t\t\tdrl = ntfs_rl_realloc_nofail(drl, ds, ds + 1);\n\t\t\tdrl[ds].vcn = marker_vcn;\n\t\t\tdrl[ds].lcn = LCN_ENOENT;\n\t\t\tdrl[ds].length = (s64)0;\n\t\t}\n\t}\n\t}\n\nfinished:\n\t/* The merge was completed successfully. */\n\tntfs_debug(\"Merged runlist:\");\n\tntfs_debug_dump_runlist(drl);\n\treturn drl;\n}",
          "includes": [
            "#include \"ntfs.h\"",
            "#include \"malloc.h\"",
            "#include \"endian.h\"",
            "#include \"dir.h\"",
            "#include \"debug.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ntfs.h\"\n#include \"malloc.h\"\n#include \"endian.h\"\n#include \"dir.h\"\n#include \"debug.h\"\n\nrunlist_element *ntfs_runlists_merge(runlist_element *drl,\n\t\trunlist_element *srl)\n{\n\tint di, si;\t\t/* Current index into @[ds]rl. */\n\tint sstart;\t\t/* First index with lcn > LCN_RL_NOT_MAPPED. */\n\tint dins;\t\t/* Index into @drl at which to insert @srl. */\n\tint dend, send;\t\t/* Last index into @[ds]rl. */\n\tint dfinal, sfinal;\t/* The last index into @[ds]rl with\n\t\t\t\t   lcn >= LCN_HOLE. */\n\tint marker = 0;\n\tVCN marker_vcn = 0;\n\n#ifdef DEBUG\n\tntfs_debug(\"dst:\");\n\tntfs_debug_dump_runlist(drl);\n\tntfs_debug(\"src:\");\n\tntfs_debug_dump_runlist(srl);\n#endif\n\n\t/* Check for silly calling... */\n\tif (unlikely(!srl))\n\t\treturn drl;\n\tif (IS_ERR(srl) || IS_ERR(drl))\n\t\treturn ERR_PTR(-EINVAL);\n\n\t/* Check for the case where the first mapping is being done now. */\n\tif (unlikely(!drl)) {\n\t\tdrl = srl;\n\t\t/* Complete the source runlist if necessary. */\n\t\tif (unlikely(drl[0].vcn)) {\n\t\t\t/* Scan to the end of the source runlist. */\n\t\t\tfor (dend = 0; likely(drl[dend].length); dend++)\n\t\t\t\t;\n\t\t\tdend++;\n\t\t\tdrl = ntfs_rl_realloc(drl, dend, dend + 1);\n\t\t\tif (IS_ERR(drl))\n\t\t\t\treturn drl;\n\t\t\t/* Insert start element at the front of the runlist. */\n\t\t\tntfs_rl_mm(drl, 1, 0, dend);\n\t\t\tdrl[0].vcn = 0;\n\t\t\tdrl[0].lcn = LCN_RL_NOT_MAPPED;\n\t\t\tdrl[0].length = drl[1].vcn;\n\t\t}\n\t\tgoto finished;\n\t}\n\n\tsi = di = 0;\n\n\t/* Skip any unmapped start element(s) in the source runlist. */\n\twhile (srl[si].length && srl[si].lcn < LCN_HOLE)\n\t\tsi++;\n\n\t/* Can't have an entirely unmapped source runlist. */\n\tBUG_ON(!srl[si].length);\n\n\t/* Record the starting points. */\n\tsstart = si;\n\n\t/*\n\t * Skip forward in @drl until we reach the position where @srl needs to\n\t * be inserted. If we reach the end of @drl, @srl just needs to be\n\t * appended to @drl.\n\t */\n\tfor (; drl[di].length; di++) {\n\t\tif (drl[di].vcn + drl[di].length > srl[sstart].vcn)\n\t\t\tbreak;\n\t}\n\tdins = di;\n\n\t/* Sanity check for illegal overlaps. */\n\tif ((drl[di].vcn == srl[si].vcn) && (drl[di].lcn >= 0) &&\n\t\t\t(srl[si].lcn >= 0)) {\n\t\tntfs_error(NULL, \"Run lists overlap. Cannot merge!\");\n\t\treturn ERR_PTR(-ERANGE);\n\t}\n\n\t/* Scan to the end of both runlists in order to know their sizes. */\n\tfor (send = si; srl[send].length; send++)\n\t\t;\n\tfor (dend = di; drl[dend].length; dend++)\n\t\t;\n\n\tif (srl[send].lcn == LCN_ENOENT)\n\t\tmarker_vcn = srl[marker = send].vcn;\n\n\t/* Scan to the last element with lcn >= LCN_HOLE. */\n\tfor (sfinal = send; sfinal >= 0 && srl[sfinal].lcn < LCN_HOLE; sfinal--)\n\t\t;\n\tfor (dfinal = dend; dfinal >= 0 && drl[dfinal].lcn < LCN_HOLE; dfinal--)\n\t\t;\n\n\t{\n\tbool start;\n\tbool finish;\n\tint ds = dend + 1;\t\t/* Number of elements in drl & srl */\n\tint ss = sfinal - sstart + 1;\n\n\tstart  = ((drl[dins].lcn <  LCN_RL_NOT_MAPPED) ||    /* End of file   */\n\t\t  (drl[dins].vcn == srl[sstart].vcn));\t     /* Start of hole */\n\tfinish = ((drl[dins].lcn >= LCN_RL_NOT_MAPPED) &&    /* End of file   */\n\t\t ((drl[dins].vcn + drl[dins].length) <=      /* End of hole   */\n\t\t  (srl[send - 1].vcn + srl[send - 1].length)));\n\n\t/* Or we will lose an end marker. */\n\tif (finish && !drl[dins].length)\n\t\tss++;\n\tif (marker && (drl[dins].vcn + drl[dins].length > srl[send - 1].vcn))\n\t\tfinish = false;\n#if 0\n\tntfs_debug(\"dfinal = %i, dend = %i\", dfinal, dend);\n\tntfs_debug(\"sstart = %i, sfinal = %i, send = %i\", sstart, sfinal, send);\n\tntfs_debug(\"start = %i, finish = %i\", start, finish);\n\tntfs_debug(\"ds = %i, ss = %i, dins = %i\", ds, ss, dins);\n#endif\n\tif (start) {\n\t\tif (finish)\n\t\t\tdrl = ntfs_rl_replace(drl, ds, srl + sstart, ss, dins);\n\t\telse\n\t\t\tdrl = ntfs_rl_insert(drl, ds, srl + sstart, ss, dins);\n\t} else {\n\t\tif (finish)\n\t\t\tdrl = ntfs_rl_append(drl, ds, srl + sstart, ss, dins);\n\t\telse\n\t\t\tdrl = ntfs_rl_split(drl, ds, srl + sstart, ss, dins);\n\t}\n\tif (IS_ERR(drl)) {\n\t\tntfs_error(NULL, \"Merge failed.\");\n\t\treturn drl;\n\t}\n\tntfs_free(srl);\n\tif (marker) {\n\t\tntfs_debug(\"Triggering marker code.\");\n\t\tfor (ds = dend; drl[ds].length; ds++)\n\t\t\t;\n\t\t/* We only need to care if @srl ended after @drl. */\n\t\tif (drl[ds].vcn <= marker_vcn) {\n\t\t\tint slots = 0;\n\n\t\t\tif (drl[ds].vcn == marker_vcn) {\n\t\t\t\tntfs_debug(\"Old marker = 0x%llx, replacing \"\n\t\t\t\t\t\t\"with LCN_ENOENT.\",\n\t\t\t\t\t\t(unsigned long long)\n\t\t\t\t\t\tdrl[ds].lcn);\n\t\t\t\tdrl[ds].lcn = LCN_ENOENT;\n\t\t\t\tgoto finished;\n\t\t\t}\n\t\t\t/*\n\t\t\t * We need to create an unmapped runlist element in\n\t\t\t * @drl or extend an existing one before adding the\n\t\t\t * ENOENT terminator.\n\t\t\t */\n\t\t\tif (drl[ds].lcn == LCN_ENOENT) {\n\t\t\t\tds--;\n\t\t\t\tslots = 1;\n\t\t\t}\n\t\t\tif (drl[ds].lcn != LCN_RL_NOT_MAPPED) {\n\t\t\t\t/* Add an unmapped runlist element. */\n\t\t\t\tif (!slots) {\n\t\t\t\t\tdrl = ntfs_rl_realloc_nofail(drl, ds,\n\t\t\t\t\t\t\tds + 2);\n\t\t\t\t\tslots = 2;\n\t\t\t\t}\n\t\t\t\tds++;\n\t\t\t\t/* Need to set vcn if it isn't set already. */\n\t\t\t\tif (slots != 1)\n\t\t\t\t\tdrl[ds].vcn = drl[ds - 1].vcn +\n\t\t\t\t\t\t\tdrl[ds - 1].length;\n\t\t\t\tdrl[ds].lcn = LCN_RL_NOT_MAPPED;\n\t\t\t\t/* We now used up a slot. */\n\t\t\t\tslots--;\n\t\t\t}\n\t\t\tdrl[ds].length = marker_vcn - drl[ds].vcn;\n\t\t\t/* Finally add the ENOENT terminator. */\n\t\t\tds++;\n\t\t\tif (!slots)\n\t\t\t\tdrl = ntfs_rl_realloc_nofail(drl, ds, ds + 1);\n\t\t\tdrl[ds].vcn = marker_vcn;\n\t\t\tdrl[ds].lcn = LCN_ENOENT;\n\t\t\tdrl[ds].length = (s64)0;\n\t\t}\n\t}\n\t}\n\nfinished:\n\t/* The merge was completed successfully. */\n\tntfs_debug(\"Merged runlist:\");\n\tntfs_debug_dump_runlist(drl);\n\treturn drl;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ntfs_debug",
          "args": [
            "\"Retrying mft data allocation with minimal cluster \"\n\t\t\t\t\"count %lli.\"",
            "(long long)nr"
          ],
          "line": 1799
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "rl2"
          ],
          "line": 1791
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "up_write",
          "args": [
            "&mft_ni->runlist.lock"
          ],
          "line": 1790
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "rl2"
          ],
          "line": 1786
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "likely",
          "args": [
            "!IS_ERR(rl2)"
          ],
          "line": 1784
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "rl2"
          ],
          "line": 1784
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntfs_cluster_alloc",
          "args": [
            "vol",
            "old_last_vcn",
            "nr",
            "lcn",
            "MFT_ZONE",
            "true"
          ],
          "line": 1782
        },
        "resolved": true,
        "details": {
          "function_name": "ntfs_cluster_alloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/lcnalloc.c",
          "lines": "146-787",
          "snippet": "runlist_element *ntfs_cluster_alloc(ntfs_volume *vol, const VCN start_vcn,\n\t\tconst s64 count, const LCN start_lcn,\n\t\tconst NTFS_CLUSTER_ALLOCATION_ZONES zone,\n\t\tconst bool is_extension)\n{\n\tLCN zone_start, zone_end, bmp_pos, bmp_initial_pos, last_read_pos, lcn;\n\tLCN prev_lcn = 0, prev_run_len = 0, mft_zone_size;\n\ts64 clusters;\n\tloff_t i_size;\n\tstruct inode *lcnbmp_vi;\n\trunlist_element *rl = NULL;\n\tstruct address_space *mapping;\n\tstruct page *page = NULL;\n\tu8 *buf, *byte;\n\tint err = 0, rlpos, rlsize, buf_size;\n\tu8 pass, done_zones, search_zone, need_writeback = 0, bit;\n\n\tntfs_debug(\"Entering for start_vcn 0x%llx, count 0x%llx, start_lcn \"\n\t\t\t\"0x%llx, zone %s_ZONE.\", (unsigned long long)start_vcn,\n\t\t\t(unsigned long long)count,\n\t\t\t(unsigned long long)start_lcn,\n\t\t\tzone == MFT_ZONE ? \"MFT\" : \"DATA\");\n\tBUG_ON(!vol);\n\tlcnbmp_vi = vol->lcnbmp_ino;\n\tBUG_ON(!lcnbmp_vi);\n\tBUG_ON(start_vcn < 0);\n\tBUG_ON(count < 0);\n\tBUG_ON(start_lcn < -1);\n\tBUG_ON(zone < FIRST_ZONE);\n\tBUG_ON(zone > LAST_ZONE);\n\n\t/* Return NULL if @count is zero. */\n\tif (!count)\n\t\treturn NULL;\n\t/* Take the lcnbmp lock for writing. */\n\tdown_write(&vol->lcnbmp_lock);\n\t/*\n\t * If no specific @start_lcn was requested, use the current data zone\n\t * position, otherwise use the requested @start_lcn but make sure it\n\t * lies outside the mft zone.  Also set done_zones to 0 (no zones done)\n\t * and pass depending on whether we are starting inside a zone (1) or\n\t * at the beginning of a zone (2).  If requesting from the MFT_ZONE,\n\t * we either start at the current position within the mft zone or at\n\t * the specified position.  If the latter is out of bounds then we start\n\t * at the beginning of the MFT_ZONE.\n\t */\n\tdone_zones = 0;\n\tpass = 1;\n\t/*\n\t * zone_start and zone_end are the current search range.  search_zone\n\t * is 1 for mft zone, 2 for data zone 1 (end of mft zone till end of\n\t * volume) and 4 for data zone 2 (start of volume till start of mft\n\t * zone).\n\t */\n\tzone_start = start_lcn;\n\tif (zone_start < 0) {\n\t\tif (zone == DATA_ZONE)\n\t\t\tzone_start = vol->data1_zone_pos;\n\t\telse\n\t\t\tzone_start = vol->mft_zone_pos;\n\t\tif (!zone_start) {\n\t\t\t/*\n\t\t\t * Zone starts at beginning of volume which means a\n\t\t\t * single pass is sufficient.\n\t\t\t */\n\t\t\tpass = 2;\n\t\t}\n\t} else if (zone == DATA_ZONE && zone_start >= vol->mft_zone_start &&\n\t\t\tzone_start < vol->mft_zone_end) {\n\t\tzone_start = vol->mft_zone_end;\n\t\t/*\n\t\t * Starting at beginning of data1_zone which means a single\n\t\t * pass in this zone is sufficient.\n\t\t */\n\t\tpass = 2;\n\t} else if (zone == MFT_ZONE && (zone_start < vol->mft_zone_start ||\n\t\t\tzone_start >= vol->mft_zone_end)) {\n\t\tzone_start = vol->mft_lcn;\n\t\tif (!vol->mft_zone_end)\n\t\t\tzone_start = 0;\n\t\t/*\n\t\t * Starting at beginning of volume which means a single pass\n\t\t * is sufficient.\n\t\t */\n\t\tpass = 2;\n\t}\n\tif (zone == MFT_ZONE) {\n\t\tzone_end = vol->mft_zone_end;\n\t\tsearch_zone = 1;\n\t} else /* if (zone == DATA_ZONE) */ {\n\t\t/* Skip searching the mft zone. */\n\t\tdone_zones |= 1;\n\t\tif (zone_start >= vol->mft_zone_end) {\n\t\t\tzone_end = vol->nr_clusters;\n\t\t\tsearch_zone = 2;\n\t\t} else {\n\t\t\tzone_end = vol->mft_zone_start;\n\t\t\tsearch_zone = 4;\n\t\t}\n\t}\n\t/*\n\t * bmp_pos is the current bit position inside the bitmap.  We use\n\t * bmp_initial_pos to determine whether or not to do a zone switch.\n\t */\n\tbmp_pos = bmp_initial_pos = zone_start;\n\n\t/* Loop until all clusters are allocated, i.e. clusters == 0. */\n\tclusters = count;\n\trlpos = rlsize = 0;\n\tmapping = lcnbmp_vi->i_mapping;\n\ti_size = i_size_read(lcnbmp_vi);\n\twhile (1) {\n\t\tntfs_debug(\"Start of outer while loop: done_zones 0x%x, \"\n\t\t\t\t\"search_zone %i, pass %i, zone_start 0x%llx, \"\n\t\t\t\t\"zone_end 0x%llx, bmp_initial_pos 0x%llx, \"\n\t\t\t\t\"bmp_pos 0x%llx, rlpos %i, rlsize %i.\",\n\t\t\t\tdone_zones, search_zone, pass,\n\t\t\t\t(unsigned long long)zone_start,\n\t\t\t\t(unsigned long long)zone_end,\n\t\t\t\t(unsigned long long)bmp_initial_pos,\n\t\t\t\t(unsigned long long)bmp_pos, rlpos, rlsize);\n\t\t/* Loop until we run out of free clusters. */\n\t\tlast_read_pos = bmp_pos >> 3;\n\t\tntfs_debug(\"last_read_pos 0x%llx.\",\n\t\t\t\t(unsigned long long)last_read_pos);\n\t\tif (last_read_pos > i_size) {\n\t\t\tntfs_debug(\"End of attribute reached.  \"\n\t\t\t\t\t\"Skipping to zone_pass_done.\");\n\t\t\tgoto zone_pass_done;\n\t\t}\n\t\tif (likely(page)) {\n\t\t\tif (need_writeback) {\n\t\t\t\tntfs_debug(\"Marking page dirty.\");\n\t\t\t\tflush_dcache_page(page);\n\t\t\t\tset_page_dirty(page);\n\t\t\t\tneed_writeback = 0;\n\t\t\t}\n\t\t\tntfs_unmap_page(page);\n\t\t}\n\t\tpage = ntfs_map_page(mapping, last_read_pos >>\n\t\t\t\tPAGE_CACHE_SHIFT);\n\t\tif (IS_ERR(page)) {\n\t\t\terr = PTR_ERR(page);\n\t\t\tntfs_error(vol->sb, \"Failed to map page.\");\n\t\t\tgoto out;\n\t\t}\n\t\tbuf_size = last_read_pos & ~PAGE_CACHE_MASK;\n\t\tbuf = page_address(page) + buf_size;\n\t\tbuf_size = PAGE_CACHE_SIZE - buf_size;\n\t\tif (unlikely(last_read_pos + buf_size > i_size))\n\t\t\tbuf_size = i_size - last_read_pos;\n\t\tbuf_size <<= 3;\n\t\tlcn = bmp_pos & 7;\n\t\tbmp_pos &= ~(LCN)7;\n\t\tntfs_debug(\"Before inner while loop: buf_size %i, lcn 0x%llx, \"\n\t\t\t\t\"bmp_pos 0x%llx, need_writeback %i.\", buf_size,\n\t\t\t\t(unsigned long long)lcn,\n\t\t\t\t(unsigned long long)bmp_pos, need_writeback);\n\t\twhile (lcn < buf_size && lcn + bmp_pos < zone_end) {\n\t\t\tbyte = buf + (lcn >> 3);\n\t\t\tntfs_debug(\"In inner while loop: buf_size %i, \"\n\t\t\t\t\t\"lcn 0x%llx, bmp_pos 0x%llx, \"\n\t\t\t\t\t\"need_writeback %i, byte ofs 0x%x, \"\n\t\t\t\t\t\"*byte 0x%x.\", buf_size,\n\t\t\t\t\t(unsigned long long)lcn,\n\t\t\t\t\t(unsigned long long)bmp_pos,\n\t\t\t\t\tneed_writeback,\n\t\t\t\t\t(unsigned int)(lcn >> 3),\n\t\t\t\t\t(unsigned int)*byte);\n\t\t\t/* Skip full bytes. */\n\t\t\tif (*byte == 0xff) {\n\t\t\t\tlcn = (lcn + 8) & ~(LCN)7;\n\t\t\t\tntfs_debug(\"Continuing while loop 1.\");\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tbit = 1 << (lcn & 7);\n\t\t\tntfs_debug(\"bit 0x%x.\", bit);\n\t\t\t/* If the bit is already set, go onto the next one. */\n\t\t\tif (*byte & bit) {\n\t\t\t\tlcn++;\n\t\t\t\tntfs_debug(\"Continuing while loop 2.\");\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t/*\n\t\t\t * Allocate more memory if needed, including space for\n\t\t\t * the terminator element.\n\t\t\t * ntfs_malloc_nofs() operates on whole pages only.\n\t\t\t */\n\t\t\tif ((rlpos + 2) * sizeof(*rl) > rlsize) {\n\t\t\t\trunlist_element *rl2;\n\n\t\t\t\tntfs_debug(\"Reallocating memory.\");\n\t\t\t\tif (!rl)\n\t\t\t\t\tntfs_debug(\"First free bit is at LCN \"\n\t\t\t\t\t\t\t\"0x%llx.\",\n\t\t\t\t\t\t\t(unsigned long long)\n\t\t\t\t\t\t\t(lcn + bmp_pos));\n\t\t\t\trl2 = ntfs_malloc_nofs(rlsize + (int)PAGE_SIZE);\n\t\t\t\tif (unlikely(!rl2)) {\n\t\t\t\t\terr = -ENOMEM;\n\t\t\t\t\tntfs_error(vol->sb, \"Failed to \"\n\t\t\t\t\t\t\t\"allocate memory.\");\n\t\t\t\t\tgoto out;\n\t\t\t\t}\n\t\t\t\tmemcpy(rl2, rl, rlsize);\n\t\t\t\tntfs_free(rl);\n\t\t\t\trl = rl2;\n\t\t\t\trlsize += PAGE_SIZE;\n\t\t\t\tntfs_debug(\"Reallocated memory, rlsize 0x%x.\",\n\t\t\t\t\t\trlsize);\n\t\t\t}\n\t\t\t/* Allocate the bitmap bit. */\n\t\t\t*byte |= bit;\n\t\t\t/* We need to write this bitmap page to disk. */\n\t\t\tneed_writeback = 1;\n\t\t\tntfs_debug(\"*byte 0x%x, need_writeback is set.\",\n\t\t\t\t\t(unsigned int)*byte);\n\t\t\t/*\n\t\t\t * Coalesce with previous run if adjacent LCNs.\n\t\t\t * Otherwise, append a new run.\n\t\t\t */\n\t\t\tntfs_debug(\"Adding run (lcn 0x%llx, len 0x%llx), \"\n\t\t\t\t\t\"prev_lcn 0x%llx, lcn 0x%llx, \"\n\t\t\t\t\t\"bmp_pos 0x%llx, prev_run_len 0x%llx, \"\n\t\t\t\t\t\"rlpos %i.\",\n\t\t\t\t\t(unsigned long long)(lcn + bmp_pos),\n\t\t\t\t\t1ULL, (unsigned long long)prev_lcn,\n\t\t\t\t\t(unsigned long long)lcn,\n\t\t\t\t\t(unsigned long long)bmp_pos,\n\t\t\t\t\t(unsigned long long)prev_run_len,\n\t\t\t\t\trlpos);\n\t\t\tif (prev_lcn == lcn + bmp_pos - prev_run_len && rlpos) {\n\t\t\t\tntfs_debug(\"Coalescing to run (lcn 0x%llx, \"\n\t\t\t\t\t\t\"len 0x%llx).\",\n\t\t\t\t\t\t(unsigned long long)\n\t\t\t\t\t\trl[rlpos - 1].lcn,\n\t\t\t\t\t\t(unsigned long long)\n\t\t\t\t\t\trl[rlpos - 1].length);\n\t\t\t\trl[rlpos - 1].length = ++prev_run_len;\n\t\t\t\tntfs_debug(\"Run now (lcn 0x%llx, len 0x%llx), \"\n\t\t\t\t\t\t\"prev_run_len 0x%llx.\",\n\t\t\t\t\t\t(unsigned long long)\n\t\t\t\t\t\trl[rlpos - 1].lcn,\n\t\t\t\t\t\t(unsigned long long)\n\t\t\t\t\t\trl[rlpos - 1].length,\n\t\t\t\t\t\t(unsigned long long)\n\t\t\t\t\t\tprev_run_len);\n\t\t\t} else {\n\t\t\t\tif (likely(rlpos)) {\n\t\t\t\t\tntfs_debug(\"Adding new run, (previous \"\n\t\t\t\t\t\t\t\"run lcn 0x%llx, \"\n\t\t\t\t\t\t\t\"len 0x%llx).\",\n\t\t\t\t\t\t\t(unsigned long long)\n\t\t\t\t\t\t\trl[rlpos - 1].lcn,\n\t\t\t\t\t\t\t(unsigned long long)\n\t\t\t\t\t\t\trl[rlpos - 1].length);\n\t\t\t\t\trl[rlpos].vcn = rl[rlpos - 1].vcn +\n\t\t\t\t\t\t\tprev_run_len;\n\t\t\t\t} else {\n\t\t\t\t\tntfs_debug(\"Adding new run, is first \"\n\t\t\t\t\t\t\t\"run.\");\n\t\t\t\t\trl[rlpos].vcn = start_vcn;\n\t\t\t\t}\n\t\t\t\trl[rlpos].lcn = prev_lcn = lcn + bmp_pos;\n\t\t\t\trl[rlpos].length = prev_run_len = 1;\n\t\t\t\trlpos++;\n\t\t\t}\n\t\t\t/* Done? */\n\t\t\tif (!--clusters) {\n\t\t\t\tLCN tc;\n\t\t\t\t/*\n\t\t\t\t * Update the current zone position.  Positions\n\t\t\t\t * of already scanned zones have been updated\n\t\t\t\t * during the respective zone switches.\n\t\t\t\t */\n\t\t\t\ttc = lcn + bmp_pos + 1;\n\t\t\t\tntfs_debug(\"Done. Updating current zone \"\n\t\t\t\t\t\t\"position, tc 0x%llx, \"\n\t\t\t\t\t\t\"search_zone %i.\",\n\t\t\t\t\t\t(unsigned long long)tc,\n\t\t\t\t\t\tsearch_zone);\n\t\t\t\tswitch (search_zone) {\n\t\t\t\tcase 1:\n\t\t\t\t\tntfs_debug(\"Before checks, \"\n\t\t\t\t\t\t\t\"vol->mft_zone_pos \"\n\t\t\t\t\t\t\t\"0x%llx.\",\n\t\t\t\t\t\t\t(unsigned long long)\n\t\t\t\t\t\t\tvol->mft_zone_pos);\n\t\t\t\t\tif (tc >= vol->mft_zone_end) {\n\t\t\t\t\t\tvol->mft_zone_pos =\n\t\t\t\t\t\t\t\tvol->mft_lcn;\n\t\t\t\t\t\tif (!vol->mft_zone_end)\n\t\t\t\t\t\t\tvol->mft_zone_pos = 0;\n\t\t\t\t\t} else if ((bmp_initial_pos >=\n\t\t\t\t\t\t\tvol->mft_zone_pos ||\n\t\t\t\t\t\t\ttc > vol->mft_zone_pos)\n\t\t\t\t\t\t\t&& tc >= vol->mft_lcn)\n\t\t\t\t\t\tvol->mft_zone_pos = tc;\n\t\t\t\t\tntfs_debug(\"After checks, \"\n\t\t\t\t\t\t\t\"vol->mft_zone_pos \"\n\t\t\t\t\t\t\t\"0x%llx.\",\n\t\t\t\t\t\t\t(unsigned long long)\n\t\t\t\t\t\t\tvol->mft_zone_pos);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 2:\n\t\t\t\t\tntfs_debug(\"Before checks, \"\n\t\t\t\t\t\t\t\"vol->data1_zone_pos \"\n\t\t\t\t\t\t\t\"0x%llx.\",\n\t\t\t\t\t\t\t(unsigned long long)\n\t\t\t\t\t\t\tvol->data1_zone_pos);\n\t\t\t\t\tif (tc >= vol->nr_clusters)\n\t\t\t\t\t\tvol->data1_zone_pos =\n\t\t\t\t\t\t\t     vol->mft_zone_end;\n\t\t\t\t\telse if ((bmp_initial_pos >=\n\t\t\t\t\t\t    vol->data1_zone_pos ||\n\t\t\t\t\t\t    tc > vol->data1_zone_pos)\n\t\t\t\t\t\t    && tc >= vol->mft_zone_end)\n\t\t\t\t\t\tvol->data1_zone_pos = tc;\n\t\t\t\t\tntfs_debug(\"After checks, \"\n\t\t\t\t\t\t\t\"vol->data1_zone_pos \"\n\t\t\t\t\t\t\t\"0x%llx.\",\n\t\t\t\t\t\t\t(unsigned long long)\n\t\t\t\t\t\t\tvol->data1_zone_pos);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 4:\n\t\t\t\t\tntfs_debug(\"Before checks, \"\n\t\t\t\t\t\t\t\"vol->data2_zone_pos \"\n\t\t\t\t\t\t\t\"0x%llx.\",\n\t\t\t\t\t\t\t(unsigned long long)\n\t\t\t\t\t\t\tvol->data2_zone_pos);\n\t\t\t\t\tif (tc >= vol->mft_zone_start)\n\t\t\t\t\t\tvol->data2_zone_pos = 0;\n\t\t\t\t\telse if (bmp_initial_pos >=\n\t\t\t\t\t\t      vol->data2_zone_pos ||\n\t\t\t\t\t\t      tc > vol->data2_zone_pos)\n\t\t\t\t\t\tvol->data2_zone_pos = tc;\n\t\t\t\t\tntfs_debug(\"After checks, \"\n\t\t\t\t\t\t\t\"vol->data2_zone_pos \"\n\t\t\t\t\t\t\t\"0x%llx.\",\n\t\t\t\t\t\t\t(unsigned long long)\n\t\t\t\t\t\t\tvol->data2_zone_pos);\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tBUG();\n\t\t\t\t}\n\t\t\t\tntfs_debug(\"Finished.  Going to out.\");\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tlcn++;\n\t\t}\n\t\tbmp_pos += buf_size;\n\t\tntfs_debug(\"After inner while loop: buf_size 0x%x, lcn \"\n\t\t\t\t\"0x%llx, bmp_pos 0x%llx, need_writeback %i.\",\n\t\t\t\tbuf_size, (unsigned long long)lcn,\n\t\t\t\t(unsigned long long)bmp_pos, need_writeback);\n\t\tif (bmp_pos < zone_end) {\n\t\t\tntfs_debug(\"Continuing outer while loop, \"\n\t\t\t\t\t\"bmp_pos 0x%llx, zone_end 0x%llx.\",\n\t\t\t\t\t(unsigned long long)bmp_pos,\n\t\t\t\t\t(unsigned long long)zone_end);\n\t\t\tcontinue;\n\t\t}\nzone_pass_done:\t/* Finished with the current zone pass. */\n\t\tntfs_debug(\"At zone_pass_done, pass %i.\", pass);\n\t\tif (pass == 1) {\n\t\t\t/*\n\t\t\t * Now do pass 2, scanning the first part of the zone\n\t\t\t * we omitted in pass 1.\n\t\t\t */\n\t\t\tpass = 2;\n\t\t\tzone_end = zone_start;\n\t\t\tswitch (search_zone) {\n\t\t\tcase 1: /* mft_zone */\n\t\t\t\tzone_start = vol->mft_zone_start;\n\t\t\t\tbreak;\n\t\t\tcase 2: /* data1_zone */\n\t\t\t\tzone_start = vol->mft_zone_end;\n\t\t\t\tbreak;\n\t\t\tcase 4: /* data2_zone */\n\t\t\t\tzone_start = 0;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tBUG();\n\t\t\t}\n\t\t\t/* Sanity check. */\n\t\t\tif (zone_end < zone_start)\n\t\t\t\tzone_end = zone_start;\n\t\t\tbmp_pos = zone_start;\n\t\t\tntfs_debug(\"Continuing outer while loop, pass 2, \"\n\t\t\t\t\t\"zone_start 0x%llx, zone_end 0x%llx, \"\n\t\t\t\t\t\"bmp_pos 0x%llx.\",\n\t\t\t\t\t(unsigned long long)zone_start,\n\t\t\t\t\t(unsigned long long)zone_end,\n\t\t\t\t\t(unsigned long long)bmp_pos);\n\t\t\tcontinue;\n\t\t} /* pass == 2 */\ndone_zones_check:\n\t\tntfs_debug(\"At done_zones_check, search_zone %i, done_zones \"\n\t\t\t\t\"before 0x%x, done_zones after 0x%x.\",\n\t\t\t\tsearch_zone, done_zones,\n\t\t\t\tdone_zones | search_zone);\n\t\tdone_zones |= search_zone;\n\t\tif (done_zones < 7) {\n\t\t\tntfs_debug(\"Switching zone.\");\n\t\t\t/* Now switch to the next zone we haven't done yet. */\n\t\t\tpass = 1;\n\t\t\tswitch (search_zone) {\n\t\t\tcase 1:\n\t\t\t\tntfs_debug(\"Switching from mft zone to data1 \"\n\t\t\t\t\t\t\"zone.\");\n\t\t\t\t/* Update mft zone position. */\n\t\t\t\tif (rlpos) {\n\t\t\t\t\tLCN tc;\n\n\t\t\t\t\tntfs_debug(\"Before checks, \"\n\t\t\t\t\t\t\t\"vol->mft_zone_pos \"\n\t\t\t\t\t\t\t\"0x%llx.\",\n\t\t\t\t\t\t\t(unsigned long long)\n\t\t\t\t\t\t\tvol->mft_zone_pos);\n\t\t\t\t\ttc = rl[rlpos - 1].lcn +\n\t\t\t\t\t\t\trl[rlpos - 1].length;\n\t\t\t\t\tif (tc >= vol->mft_zone_end) {\n\t\t\t\t\t\tvol->mft_zone_pos =\n\t\t\t\t\t\t\t\tvol->mft_lcn;\n\t\t\t\t\t\tif (!vol->mft_zone_end)\n\t\t\t\t\t\t\tvol->mft_zone_pos = 0;\n\t\t\t\t\t} else if ((bmp_initial_pos >=\n\t\t\t\t\t\t\tvol->mft_zone_pos ||\n\t\t\t\t\t\t\ttc > vol->mft_zone_pos)\n\t\t\t\t\t\t\t&& tc >= vol->mft_lcn)\n\t\t\t\t\t\tvol->mft_zone_pos = tc;\n\t\t\t\t\tntfs_debug(\"After checks, \"\n\t\t\t\t\t\t\t\"vol->mft_zone_pos \"\n\t\t\t\t\t\t\t\"0x%llx.\",\n\t\t\t\t\t\t\t(unsigned long long)\n\t\t\t\t\t\t\tvol->mft_zone_pos);\n\t\t\t\t}\n\t\t\t\t/* Switch from mft zone to data1 zone. */\nswitch_to_data1_zone:\t\tsearch_zone = 2;\n\t\t\t\tzone_start = bmp_initial_pos =\n\t\t\t\t\t\tvol->data1_zone_pos;\n\t\t\t\tzone_end = vol->nr_clusters;\n\t\t\t\tif (zone_start == vol->mft_zone_end)\n\t\t\t\t\tpass = 2;\n\t\t\t\tif (zone_start >= zone_end) {\n\t\t\t\t\tvol->data1_zone_pos = zone_start =\n\t\t\t\t\t\t\tvol->mft_zone_end;\n\t\t\t\t\tpass = 2;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 2:\n\t\t\t\tntfs_debug(\"Switching from data1 zone to \"\n\t\t\t\t\t\t\"data2 zone.\");\n\t\t\t\t/* Update data1 zone position. */\n\t\t\t\tif (rlpos) {\n\t\t\t\t\tLCN tc;\n\n\t\t\t\t\tntfs_debug(\"Before checks, \"\n\t\t\t\t\t\t\t\"vol->data1_zone_pos \"\n\t\t\t\t\t\t\t\"0x%llx.\",\n\t\t\t\t\t\t\t(unsigned long long)\n\t\t\t\t\t\t\tvol->data1_zone_pos);\n\t\t\t\t\ttc = rl[rlpos - 1].lcn +\n\t\t\t\t\t\t\trl[rlpos - 1].length;\n\t\t\t\t\tif (tc >= vol->nr_clusters)\n\t\t\t\t\t\tvol->data1_zone_pos =\n\t\t\t\t\t\t\t     vol->mft_zone_end;\n\t\t\t\t\telse if ((bmp_initial_pos >=\n\t\t\t\t\t\t    vol->data1_zone_pos ||\n\t\t\t\t\t\t    tc > vol->data1_zone_pos)\n\t\t\t\t\t\t    && tc >= vol->mft_zone_end)\n\t\t\t\t\t\tvol->data1_zone_pos = tc;\n\t\t\t\t\tntfs_debug(\"After checks, \"\n\t\t\t\t\t\t\t\"vol->data1_zone_pos \"\n\t\t\t\t\t\t\t\"0x%llx.\",\n\t\t\t\t\t\t\t(unsigned long long)\n\t\t\t\t\t\t\tvol->data1_zone_pos);\n\t\t\t\t}\n\t\t\t\t/* Switch from data1 zone to data2 zone. */\n\t\t\t\tsearch_zone = 4;\n\t\t\t\tzone_start = bmp_initial_pos =\n\t\t\t\t\t\tvol->data2_zone_pos;\n\t\t\t\tzone_end = vol->mft_zone_start;\n\t\t\t\tif (!zone_start)\n\t\t\t\t\tpass = 2;\n\t\t\t\tif (zone_start >= zone_end) {\n\t\t\t\t\tvol->data2_zone_pos = zone_start =\n\t\t\t\t\t\t\tbmp_initial_pos = 0;\n\t\t\t\t\tpass = 2;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 4:\n\t\t\t\tntfs_debug(\"Switching from data2 zone to \"\n\t\t\t\t\t\t\"data1 zone.\");\n\t\t\t\t/* Update data2 zone position. */\n\t\t\t\tif (rlpos) {\n\t\t\t\t\tLCN tc;\n\n\t\t\t\t\tntfs_debug(\"Before checks, \"\n\t\t\t\t\t\t\t\"vol->data2_zone_pos \"\n\t\t\t\t\t\t\t\"0x%llx.\",\n\t\t\t\t\t\t\t(unsigned long long)\n\t\t\t\t\t\t\tvol->data2_zone_pos);\n\t\t\t\t\ttc = rl[rlpos - 1].lcn +\n\t\t\t\t\t\t\trl[rlpos - 1].length;\n\t\t\t\t\tif (tc >= vol->mft_zone_start)\n\t\t\t\t\t\tvol->data2_zone_pos = 0;\n\t\t\t\t\telse if (bmp_initial_pos >=\n\t\t\t\t\t\t      vol->data2_zone_pos ||\n\t\t\t\t\t\t      tc > vol->data2_zone_pos)\n\t\t\t\t\t\tvol->data2_zone_pos = tc;\n\t\t\t\t\tntfs_debug(\"After checks, \"\n\t\t\t\t\t\t\t\"vol->data2_zone_pos \"\n\t\t\t\t\t\t\t\"0x%llx.\",\n\t\t\t\t\t\t\t(unsigned long long)\n\t\t\t\t\t\t\tvol->data2_zone_pos);\n\t\t\t\t}\n\t\t\t\t/* Switch from data2 zone to data1 zone. */\n\t\t\t\tgoto switch_to_data1_zone;\n\t\t\tdefault:\n\t\t\t\tBUG();\n\t\t\t}\n\t\t\tntfs_debug(\"After zone switch, search_zone %i, \"\n\t\t\t\t\t\"pass %i, bmp_initial_pos 0x%llx, \"\n\t\t\t\t\t\"zone_start 0x%llx, zone_end 0x%llx.\",\n\t\t\t\t\tsearch_zone, pass,\n\t\t\t\t\t(unsigned long long)bmp_initial_pos,\n\t\t\t\t\t(unsigned long long)zone_start,\n\t\t\t\t\t(unsigned long long)zone_end);\n\t\t\tbmp_pos = zone_start;\n\t\t\tif (zone_start == zone_end) {\n\t\t\t\tntfs_debug(\"Empty zone, going to \"\n\t\t\t\t\t\t\"done_zones_check.\");\n\t\t\t\t/* Empty zone. Don't bother searching it. */\n\t\t\t\tgoto done_zones_check;\n\t\t\t}\n\t\t\tntfs_debug(\"Continuing outer while loop.\");\n\t\t\tcontinue;\n\t\t} /* done_zones == 7 */\n\t\tntfs_debug(\"All zones are finished.\");\n\t\t/*\n\t\t * All zones are finished!  If DATA_ZONE, shrink mft zone.  If\n\t\t * MFT_ZONE, we have really run out of space.\n\t\t */\n\t\tmft_zone_size = vol->mft_zone_end - vol->mft_zone_start;\n\t\tntfs_debug(\"vol->mft_zone_start 0x%llx, vol->mft_zone_end \"\n\t\t\t\t\"0x%llx, mft_zone_size 0x%llx.\",\n\t\t\t\t(unsigned long long)vol->mft_zone_start,\n\t\t\t\t(unsigned long long)vol->mft_zone_end,\n\t\t\t\t(unsigned long long)mft_zone_size);\n\t\tif (zone == MFT_ZONE || mft_zone_size <= 0) {\n\t\t\tntfs_debug(\"No free clusters left, going to out.\");\n\t\t\t/* Really no more space left on device. */\n\t\t\terr = -ENOSPC;\n\t\t\tgoto out;\n\t\t} /* zone == DATA_ZONE && mft_zone_size > 0 */\n\t\tntfs_debug(\"Shrinking mft zone.\");\n\t\tzone_end = vol->mft_zone_end;\n\t\tmft_zone_size >>= 1;\n\t\tif (mft_zone_size > 0)\n\t\t\tvol->mft_zone_end = vol->mft_zone_start + mft_zone_size;\n\t\telse /* mft zone and data2 zone no longer exist. */\n\t\t\tvol->data2_zone_pos = vol->mft_zone_start =\n\t\t\t\t\tvol->mft_zone_end = 0;\n\t\tif (vol->mft_zone_pos >= vol->mft_zone_end) {\n\t\t\tvol->mft_zone_pos = vol->mft_lcn;\n\t\t\tif (!vol->mft_zone_end)\n\t\t\t\tvol->mft_zone_pos = 0;\n\t\t}\n\t\tbmp_pos = zone_start = bmp_initial_pos =\n\t\t\t\tvol->data1_zone_pos = vol->mft_zone_end;\n\t\tsearch_zone = 2;\n\t\tpass = 2;\n\t\tdone_zones &= ~2;\n\t\tntfs_debug(\"After shrinking mft zone, mft_zone_size 0x%llx, \"\n\t\t\t\t\"vol->mft_zone_start 0x%llx, \"\n\t\t\t\t\"vol->mft_zone_end 0x%llx, \"\n\t\t\t\t\"vol->mft_zone_pos 0x%llx, search_zone 2, \"\n\t\t\t\t\"pass 2, dones_zones 0x%x, zone_start 0x%llx, \"\n\t\t\t\t\"zone_end 0x%llx, vol->data1_zone_pos 0x%llx, \"\n\t\t\t\t\"continuing outer while loop.\",\n\t\t\t\t(unsigned long long)mft_zone_size,\n\t\t\t\t(unsigned long long)vol->mft_zone_start,\n\t\t\t\t(unsigned long long)vol->mft_zone_end,\n\t\t\t\t(unsigned long long)vol->mft_zone_pos,\n\t\t\t\tdone_zones, (unsigned long long)zone_start,\n\t\t\t\t(unsigned long long)zone_end,\n\t\t\t\t(unsigned long long)vol->data1_zone_pos);\n\t}\n\tntfs_debug(\"After outer while loop.\");\nout:\n\tntfs_debug(\"At out.\");\n\t/* Add runlist terminator element. */\n\tif (likely(rl)) {\n\t\trl[rlpos].vcn = rl[rlpos - 1].vcn + rl[rlpos - 1].length;\n\t\trl[rlpos].lcn = is_extension ? LCN_ENOENT : LCN_RL_NOT_MAPPED;\n\t\trl[rlpos].length = 0;\n\t}\n\tif (likely(page && !IS_ERR(page))) {\n\t\tif (need_writeback) {\n\t\t\tntfs_debug(\"Marking page dirty.\");\n\t\t\tflush_dcache_page(page);\n\t\t\tset_page_dirty(page);\n\t\t\tneed_writeback = 0;\n\t\t}\n\t\tntfs_unmap_page(page);\n\t}\n\tif (likely(!err)) {\n\t\tup_write(&vol->lcnbmp_lock);\n\t\tntfs_debug(\"Done.\");\n\t\treturn rl;\n\t}\n\tntfs_error(vol->sb, \"Failed to allocate clusters, aborting \"\n\t\t\t\"(error %i).\", err);\n\tif (rl) {\n\t\tint err2;\n\n\t\tif (err == -ENOSPC)\n\t\t\tntfs_debug(\"Not enough space to complete allocation, \"\n\t\t\t\t\t\"err -ENOSPC, first free lcn 0x%llx, \"\n\t\t\t\t\t\"could allocate up to 0x%llx \"\n\t\t\t\t\t\"clusters.\",\n\t\t\t\t\t(unsigned long long)rl[0].lcn,\n\t\t\t\t\t(unsigned long long)(count - clusters));\n\t\t/* Deallocate all allocated clusters. */\n\t\tntfs_debug(\"Attempting rollback...\");\n\t\terr2 = ntfs_cluster_free_from_rl_nolock(vol, rl);\n\t\tif (err2) {\n\t\t\tntfs_error(vol->sb, \"Failed to rollback (error %i).  \"\n\t\t\t\t\t\"Leaving inconsistent metadata!  \"\n\t\t\t\t\t\"Unmount and run chkdsk.\", err2);\n\t\t\tNVolSetErrors(vol);\n\t\t}\n\t\t/* Free the runlist. */\n\t\tntfs_free(rl);\n\t} else if (err == -ENOSPC)\n\t\tntfs_debug(\"No space left at all, err = -ENOSPC, first free \"\n\t\t\t\t\"lcn = 0x%llx.\",\n\t\t\t\t(long long)vol->data1_zone_pos);\n\tup_write(&vol->lcnbmp_lock);\n\treturn ERR_PTR(err);\n}",
          "includes": [
            "#include \"ntfs.h\"",
            "#include \"aops.h\"",
            "#include \"malloc.h\"",
            "#include \"attrib.h\"",
            "#include \"volume.h\"",
            "#include \"inode.h\"",
            "#include \"bitmap.h\"",
            "#include \"debug.h\"",
            "#include \"lcnalloc.h\"",
            "#include <linux/pagemap.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ntfs.h\"\n#include \"aops.h\"\n#include \"malloc.h\"\n#include \"attrib.h\"\n#include \"volume.h\"\n#include \"inode.h\"\n#include \"bitmap.h\"\n#include \"debug.h\"\n#include \"lcnalloc.h\"\n#include <linux/pagemap.h>\n\nrunlist_element *ntfs_cluster_alloc(ntfs_volume *vol, const VCN start_vcn,\n\t\tconst s64 count, const LCN start_lcn,\n\t\tconst NTFS_CLUSTER_ALLOCATION_ZONES zone,\n\t\tconst bool is_extension)\n{\n\tLCN zone_start, zone_end, bmp_pos, bmp_initial_pos, last_read_pos, lcn;\n\tLCN prev_lcn = 0, prev_run_len = 0, mft_zone_size;\n\ts64 clusters;\n\tloff_t i_size;\n\tstruct inode *lcnbmp_vi;\n\trunlist_element *rl = NULL;\n\tstruct address_space *mapping;\n\tstruct page *page = NULL;\n\tu8 *buf, *byte;\n\tint err = 0, rlpos, rlsize, buf_size;\n\tu8 pass, done_zones, search_zone, need_writeback = 0, bit;\n\n\tntfs_debug(\"Entering for start_vcn 0x%llx, count 0x%llx, start_lcn \"\n\t\t\t\"0x%llx, zone %s_ZONE.\", (unsigned long long)start_vcn,\n\t\t\t(unsigned long long)count,\n\t\t\t(unsigned long long)start_lcn,\n\t\t\tzone == MFT_ZONE ? \"MFT\" : \"DATA\");\n\tBUG_ON(!vol);\n\tlcnbmp_vi = vol->lcnbmp_ino;\n\tBUG_ON(!lcnbmp_vi);\n\tBUG_ON(start_vcn < 0);\n\tBUG_ON(count < 0);\n\tBUG_ON(start_lcn < -1);\n\tBUG_ON(zone < FIRST_ZONE);\n\tBUG_ON(zone > LAST_ZONE);\n\n\t/* Return NULL if @count is zero. */\n\tif (!count)\n\t\treturn NULL;\n\t/* Take the lcnbmp lock for writing. */\n\tdown_write(&vol->lcnbmp_lock);\n\t/*\n\t * If no specific @start_lcn was requested, use the current data zone\n\t * position, otherwise use the requested @start_lcn but make sure it\n\t * lies outside the mft zone.  Also set done_zones to 0 (no zones done)\n\t * and pass depending on whether we are starting inside a zone (1) or\n\t * at the beginning of a zone (2).  If requesting from the MFT_ZONE,\n\t * we either start at the current position within the mft zone or at\n\t * the specified position.  If the latter is out of bounds then we start\n\t * at the beginning of the MFT_ZONE.\n\t */\n\tdone_zones = 0;\n\tpass = 1;\n\t/*\n\t * zone_start and zone_end are the current search range.  search_zone\n\t * is 1 for mft zone, 2 for data zone 1 (end of mft zone till end of\n\t * volume) and 4 for data zone 2 (start of volume till start of mft\n\t * zone).\n\t */\n\tzone_start = start_lcn;\n\tif (zone_start < 0) {\n\t\tif (zone == DATA_ZONE)\n\t\t\tzone_start = vol->data1_zone_pos;\n\t\telse\n\t\t\tzone_start = vol->mft_zone_pos;\n\t\tif (!zone_start) {\n\t\t\t/*\n\t\t\t * Zone starts at beginning of volume which means a\n\t\t\t * single pass is sufficient.\n\t\t\t */\n\t\t\tpass = 2;\n\t\t}\n\t} else if (zone == DATA_ZONE && zone_start >= vol->mft_zone_start &&\n\t\t\tzone_start < vol->mft_zone_end) {\n\t\tzone_start = vol->mft_zone_end;\n\t\t/*\n\t\t * Starting at beginning of data1_zone which means a single\n\t\t * pass in this zone is sufficient.\n\t\t */\n\t\tpass = 2;\n\t} else if (zone == MFT_ZONE && (zone_start < vol->mft_zone_start ||\n\t\t\tzone_start >= vol->mft_zone_end)) {\n\t\tzone_start = vol->mft_lcn;\n\t\tif (!vol->mft_zone_end)\n\t\t\tzone_start = 0;\n\t\t/*\n\t\t * Starting at beginning of volume which means a single pass\n\t\t * is sufficient.\n\t\t */\n\t\tpass = 2;\n\t}\n\tif (zone == MFT_ZONE) {\n\t\tzone_end = vol->mft_zone_end;\n\t\tsearch_zone = 1;\n\t} else /* if (zone == DATA_ZONE) */ {\n\t\t/* Skip searching the mft zone. */\n\t\tdone_zones |= 1;\n\t\tif (zone_start >= vol->mft_zone_end) {\n\t\t\tzone_end = vol->nr_clusters;\n\t\t\tsearch_zone = 2;\n\t\t} else {\n\t\t\tzone_end = vol->mft_zone_start;\n\t\t\tsearch_zone = 4;\n\t\t}\n\t}\n\t/*\n\t * bmp_pos is the current bit position inside the bitmap.  We use\n\t * bmp_initial_pos to determine whether or not to do a zone switch.\n\t */\n\tbmp_pos = bmp_initial_pos = zone_start;\n\n\t/* Loop until all clusters are allocated, i.e. clusters == 0. */\n\tclusters = count;\n\trlpos = rlsize = 0;\n\tmapping = lcnbmp_vi->i_mapping;\n\ti_size = i_size_read(lcnbmp_vi);\n\twhile (1) {\n\t\tntfs_debug(\"Start of outer while loop: done_zones 0x%x, \"\n\t\t\t\t\"search_zone %i, pass %i, zone_start 0x%llx, \"\n\t\t\t\t\"zone_end 0x%llx, bmp_initial_pos 0x%llx, \"\n\t\t\t\t\"bmp_pos 0x%llx, rlpos %i, rlsize %i.\",\n\t\t\t\tdone_zones, search_zone, pass,\n\t\t\t\t(unsigned long long)zone_start,\n\t\t\t\t(unsigned long long)zone_end,\n\t\t\t\t(unsigned long long)bmp_initial_pos,\n\t\t\t\t(unsigned long long)bmp_pos, rlpos, rlsize);\n\t\t/* Loop until we run out of free clusters. */\n\t\tlast_read_pos = bmp_pos >> 3;\n\t\tntfs_debug(\"last_read_pos 0x%llx.\",\n\t\t\t\t(unsigned long long)last_read_pos);\n\t\tif (last_read_pos > i_size) {\n\t\t\tntfs_debug(\"End of attribute reached.  \"\n\t\t\t\t\t\"Skipping to zone_pass_done.\");\n\t\t\tgoto zone_pass_done;\n\t\t}\n\t\tif (likely(page)) {\n\t\t\tif (need_writeback) {\n\t\t\t\tntfs_debug(\"Marking page dirty.\");\n\t\t\t\tflush_dcache_page(page);\n\t\t\t\tset_page_dirty(page);\n\t\t\t\tneed_writeback = 0;\n\t\t\t}\n\t\t\tntfs_unmap_page(page);\n\t\t}\n\t\tpage = ntfs_map_page(mapping, last_read_pos >>\n\t\t\t\tPAGE_CACHE_SHIFT);\n\t\tif (IS_ERR(page)) {\n\t\t\terr = PTR_ERR(page);\n\t\t\tntfs_error(vol->sb, \"Failed to map page.\");\n\t\t\tgoto out;\n\t\t}\n\t\tbuf_size = last_read_pos & ~PAGE_CACHE_MASK;\n\t\tbuf = page_address(page) + buf_size;\n\t\tbuf_size = PAGE_CACHE_SIZE - buf_size;\n\t\tif (unlikely(last_read_pos + buf_size > i_size))\n\t\t\tbuf_size = i_size - last_read_pos;\n\t\tbuf_size <<= 3;\n\t\tlcn = bmp_pos & 7;\n\t\tbmp_pos &= ~(LCN)7;\n\t\tntfs_debug(\"Before inner while loop: buf_size %i, lcn 0x%llx, \"\n\t\t\t\t\"bmp_pos 0x%llx, need_writeback %i.\", buf_size,\n\t\t\t\t(unsigned long long)lcn,\n\t\t\t\t(unsigned long long)bmp_pos, need_writeback);\n\t\twhile (lcn < buf_size && lcn + bmp_pos < zone_end) {\n\t\t\tbyte = buf + (lcn >> 3);\n\t\t\tntfs_debug(\"In inner while loop: buf_size %i, \"\n\t\t\t\t\t\"lcn 0x%llx, bmp_pos 0x%llx, \"\n\t\t\t\t\t\"need_writeback %i, byte ofs 0x%x, \"\n\t\t\t\t\t\"*byte 0x%x.\", buf_size,\n\t\t\t\t\t(unsigned long long)lcn,\n\t\t\t\t\t(unsigned long long)bmp_pos,\n\t\t\t\t\tneed_writeback,\n\t\t\t\t\t(unsigned int)(lcn >> 3),\n\t\t\t\t\t(unsigned int)*byte);\n\t\t\t/* Skip full bytes. */\n\t\t\tif (*byte == 0xff) {\n\t\t\t\tlcn = (lcn + 8) & ~(LCN)7;\n\t\t\t\tntfs_debug(\"Continuing while loop 1.\");\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tbit = 1 << (lcn & 7);\n\t\t\tntfs_debug(\"bit 0x%x.\", bit);\n\t\t\t/* If the bit is already set, go onto the next one. */\n\t\t\tif (*byte & bit) {\n\t\t\t\tlcn++;\n\t\t\t\tntfs_debug(\"Continuing while loop 2.\");\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t/*\n\t\t\t * Allocate more memory if needed, including space for\n\t\t\t * the terminator element.\n\t\t\t * ntfs_malloc_nofs() operates on whole pages only.\n\t\t\t */\n\t\t\tif ((rlpos + 2) * sizeof(*rl) > rlsize) {\n\t\t\t\trunlist_element *rl2;\n\n\t\t\t\tntfs_debug(\"Reallocating memory.\");\n\t\t\t\tif (!rl)\n\t\t\t\t\tntfs_debug(\"First free bit is at LCN \"\n\t\t\t\t\t\t\t\"0x%llx.\",\n\t\t\t\t\t\t\t(unsigned long long)\n\t\t\t\t\t\t\t(lcn + bmp_pos));\n\t\t\t\trl2 = ntfs_malloc_nofs(rlsize + (int)PAGE_SIZE);\n\t\t\t\tif (unlikely(!rl2)) {\n\t\t\t\t\terr = -ENOMEM;\n\t\t\t\t\tntfs_error(vol->sb, \"Failed to \"\n\t\t\t\t\t\t\t\"allocate memory.\");\n\t\t\t\t\tgoto out;\n\t\t\t\t}\n\t\t\t\tmemcpy(rl2, rl, rlsize);\n\t\t\t\tntfs_free(rl);\n\t\t\t\trl = rl2;\n\t\t\t\trlsize += PAGE_SIZE;\n\t\t\t\tntfs_debug(\"Reallocated memory, rlsize 0x%x.\",\n\t\t\t\t\t\trlsize);\n\t\t\t}\n\t\t\t/* Allocate the bitmap bit. */\n\t\t\t*byte |= bit;\n\t\t\t/* We need to write this bitmap page to disk. */\n\t\t\tneed_writeback = 1;\n\t\t\tntfs_debug(\"*byte 0x%x, need_writeback is set.\",\n\t\t\t\t\t(unsigned int)*byte);\n\t\t\t/*\n\t\t\t * Coalesce with previous run if adjacent LCNs.\n\t\t\t * Otherwise, append a new run.\n\t\t\t */\n\t\t\tntfs_debug(\"Adding run (lcn 0x%llx, len 0x%llx), \"\n\t\t\t\t\t\"prev_lcn 0x%llx, lcn 0x%llx, \"\n\t\t\t\t\t\"bmp_pos 0x%llx, prev_run_len 0x%llx, \"\n\t\t\t\t\t\"rlpos %i.\",\n\t\t\t\t\t(unsigned long long)(lcn + bmp_pos),\n\t\t\t\t\t1ULL, (unsigned long long)prev_lcn,\n\t\t\t\t\t(unsigned long long)lcn,\n\t\t\t\t\t(unsigned long long)bmp_pos,\n\t\t\t\t\t(unsigned long long)prev_run_len,\n\t\t\t\t\trlpos);\n\t\t\tif (prev_lcn == lcn + bmp_pos - prev_run_len && rlpos) {\n\t\t\t\tntfs_debug(\"Coalescing to run (lcn 0x%llx, \"\n\t\t\t\t\t\t\"len 0x%llx).\",\n\t\t\t\t\t\t(unsigned long long)\n\t\t\t\t\t\trl[rlpos - 1].lcn,\n\t\t\t\t\t\t(unsigned long long)\n\t\t\t\t\t\trl[rlpos - 1].length);\n\t\t\t\trl[rlpos - 1].length = ++prev_run_len;\n\t\t\t\tntfs_debug(\"Run now (lcn 0x%llx, len 0x%llx), \"\n\t\t\t\t\t\t\"prev_run_len 0x%llx.\",\n\t\t\t\t\t\t(unsigned long long)\n\t\t\t\t\t\trl[rlpos - 1].lcn,\n\t\t\t\t\t\t(unsigned long long)\n\t\t\t\t\t\trl[rlpos - 1].length,\n\t\t\t\t\t\t(unsigned long long)\n\t\t\t\t\t\tprev_run_len);\n\t\t\t} else {\n\t\t\t\tif (likely(rlpos)) {\n\t\t\t\t\tntfs_debug(\"Adding new run, (previous \"\n\t\t\t\t\t\t\t\"run lcn 0x%llx, \"\n\t\t\t\t\t\t\t\"len 0x%llx).\",\n\t\t\t\t\t\t\t(unsigned long long)\n\t\t\t\t\t\t\trl[rlpos - 1].lcn,\n\t\t\t\t\t\t\t(unsigned long long)\n\t\t\t\t\t\t\trl[rlpos - 1].length);\n\t\t\t\t\trl[rlpos].vcn = rl[rlpos - 1].vcn +\n\t\t\t\t\t\t\tprev_run_len;\n\t\t\t\t} else {\n\t\t\t\t\tntfs_debug(\"Adding new run, is first \"\n\t\t\t\t\t\t\t\"run.\");\n\t\t\t\t\trl[rlpos].vcn = start_vcn;\n\t\t\t\t}\n\t\t\t\trl[rlpos].lcn = prev_lcn = lcn + bmp_pos;\n\t\t\t\trl[rlpos].length = prev_run_len = 1;\n\t\t\t\trlpos++;\n\t\t\t}\n\t\t\t/* Done? */\n\t\t\tif (!--clusters) {\n\t\t\t\tLCN tc;\n\t\t\t\t/*\n\t\t\t\t * Update the current zone position.  Positions\n\t\t\t\t * of already scanned zones have been updated\n\t\t\t\t * during the respective zone switches.\n\t\t\t\t */\n\t\t\t\ttc = lcn + bmp_pos + 1;\n\t\t\t\tntfs_debug(\"Done. Updating current zone \"\n\t\t\t\t\t\t\"position, tc 0x%llx, \"\n\t\t\t\t\t\t\"search_zone %i.\",\n\t\t\t\t\t\t(unsigned long long)tc,\n\t\t\t\t\t\tsearch_zone);\n\t\t\t\tswitch (search_zone) {\n\t\t\t\tcase 1:\n\t\t\t\t\tntfs_debug(\"Before checks, \"\n\t\t\t\t\t\t\t\"vol->mft_zone_pos \"\n\t\t\t\t\t\t\t\"0x%llx.\",\n\t\t\t\t\t\t\t(unsigned long long)\n\t\t\t\t\t\t\tvol->mft_zone_pos);\n\t\t\t\t\tif (tc >= vol->mft_zone_end) {\n\t\t\t\t\t\tvol->mft_zone_pos =\n\t\t\t\t\t\t\t\tvol->mft_lcn;\n\t\t\t\t\t\tif (!vol->mft_zone_end)\n\t\t\t\t\t\t\tvol->mft_zone_pos = 0;\n\t\t\t\t\t} else if ((bmp_initial_pos >=\n\t\t\t\t\t\t\tvol->mft_zone_pos ||\n\t\t\t\t\t\t\ttc > vol->mft_zone_pos)\n\t\t\t\t\t\t\t&& tc >= vol->mft_lcn)\n\t\t\t\t\t\tvol->mft_zone_pos = tc;\n\t\t\t\t\tntfs_debug(\"After checks, \"\n\t\t\t\t\t\t\t\"vol->mft_zone_pos \"\n\t\t\t\t\t\t\t\"0x%llx.\",\n\t\t\t\t\t\t\t(unsigned long long)\n\t\t\t\t\t\t\tvol->mft_zone_pos);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 2:\n\t\t\t\t\tntfs_debug(\"Before checks, \"\n\t\t\t\t\t\t\t\"vol->data1_zone_pos \"\n\t\t\t\t\t\t\t\"0x%llx.\",\n\t\t\t\t\t\t\t(unsigned long long)\n\t\t\t\t\t\t\tvol->data1_zone_pos);\n\t\t\t\t\tif (tc >= vol->nr_clusters)\n\t\t\t\t\t\tvol->data1_zone_pos =\n\t\t\t\t\t\t\t     vol->mft_zone_end;\n\t\t\t\t\telse if ((bmp_initial_pos >=\n\t\t\t\t\t\t    vol->data1_zone_pos ||\n\t\t\t\t\t\t    tc > vol->data1_zone_pos)\n\t\t\t\t\t\t    && tc >= vol->mft_zone_end)\n\t\t\t\t\t\tvol->data1_zone_pos = tc;\n\t\t\t\t\tntfs_debug(\"After checks, \"\n\t\t\t\t\t\t\t\"vol->data1_zone_pos \"\n\t\t\t\t\t\t\t\"0x%llx.\",\n\t\t\t\t\t\t\t(unsigned long long)\n\t\t\t\t\t\t\tvol->data1_zone_pos);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 4:\n\t\t\t\t\tntfs_debug(\"Before checks, \"\n\t\t\t\t\t\t\t\"vol->data2_zone_pos \"\n\t\t\t\t\t\t\t\"0x%llx.\",\n\t\t\t\t\t\t\t(unsigned long long)\n\t\t\t\t\t\t\tvol->data2_zone_pos);\n\t\t\t\t\tif (tc >= vol->mft_zone_start)\n\t\t\t\t\t\tvol->data2_zone_pos = 0;\n\t\t\t\t\telse if (bmp_initial_pos >=\n\t\t\t\t\t\t      vol->data2_zone_pos ||\n\t\t\t\t\t\t      tc > vol->data2_zone_pos)\n\t\t\t\t\t\tvol->data2_zone_pos = tc;\n\t\t\t\t\tntfs_debug(\"After checks, \"\n\t\t\t\t\t\t\t\"vol->data2_zone_pos \"\n\t\t\t\t\t\t\t\"0x%llx.\",\n\t\t\t\t\t\t\t(unsigned long long)\n\t\t\t\t\t\t\tvol->data2_zone_pos);\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tBUG();\n\t\t\t\t}\n\t\t\t\tntfs_debug(\"Finished.  Going to out.\");\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tlcn++;\n\t\t}\n\t\tbmp_pos += buf_size;\n\t\tntfs_debug(\"After inner while loop: buf_size 0x%x, lcn \"\n\t\t\t\t\"0x%llx, bmp_pos 0x%llx, need_writeback %i.\",\n\t\t\t\tbuf_size, (unsigned long long)lcn,\n\t\t\t\t(unsigned long long)bmp_pos, need_writeback);\n\t\tif (bmp_pos < zone_end) {\n\t\t\tntfs_debug(\"Continuing outer while loop, \"\n\t\t\t\t\t\"bmp_pos 0x%llx, zone_end 0x%llx.\",\n\t\t\t\t\t(unsigned long long)bmp_pos,\n\t\t\t\t\t(unsigned long long)zone_end);\n\t\t\tcontinue;\n\t\t}\nzone_pass_done:\t/* Finished with the current zone pass. */\n\t\tntfs_debug(\"At zone_pass_done, pass %i.\", pass);\n\t\tif (pass == 1) {\n\t\t\t/*\n\t\t\t * Now do pass 2, scanning the first part of the zone\n\t\t\t * we omitted in pass 1.\n\t\t\t */\n\t\t\tpass = 2;\n\t\t\tzone_end = zone_start;\n\t\t\tswitch (search_zone) {\n\t\t\tcase 1: /* mft_zone */\n\t\t\t\tzone_start = vol->mft_zone_start;\n\t\t\t\tbreak;\n\t\t\tcase 2: /* data1_zone */\n\t\t\t\tzone_start = vol->mft_zone_end;\n\t\t\t\tbreak;\n\t\t\tcase 4: /* data2_zone */\n\t\t\t\tzone_start = 0;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tBUG();\n\t\t\t}\n\t\t\t/* Sanity check. */\n\t\t\tif (zone_end < zone_start)\n\t\t\t\tzone_end = zone_start;\n\t\t\tbmp_pos = zone_start;\n\t\t\tntfs_debug(\"Continuing outer while loop, pass 2, \"\n\t\t\t\t\t\"zone_start 0x%llx, zone_end 0x%llx, \"\n\t\t\t\t\t\"bmp_pos 0x%llx.\",\n\t\t\t\t\t(unsigned long long)zone_start,\n\t\t\t\t\t(unsigned long long)zone_end,\n\t\t\t\t\t(unsigned long long)bmp_pos);\n\t\t\tcontinue;\n\t\t} /* pass == 2 */\ndone_zones_check:\n\t\tntfs_debug(\"At done_zones_check, search_zone %i, done_zones \"\n\t\t\t\t\"before 0x%x, done_zones after 0x%x.\",\n\t\t\t\tsearch_zone, done_zones,\n\t\t\t\tdone_zones | search_zone);\n\t\tdone_zones |= search_zone;\n\t\tif (done_zones < 7) {\n\t\t\tntfs_debug(\"Switching zone.\");\n\t\t\t/* Now switch to the next zone we haven't done yet. */\n\t\t\tpass = 1;\n\t\t\tswitch (search_zone) {\n\t\t\tcase 1:\n\t\t\t\tntfs_debug(\"Switching from mft zone to data1 \"\n\t\t\t\t\t\t\"zone.\");\n\t\t\t\t/* Update mft zone position. */\n\t\t\t\tif (rlpos) {\n\t\t\t\t\tLCN tc;\n\n\t\t\t\t\tntfs_debug(\"Before checks, \"\n\t\t\t\t\t\t\t\"vol->mft_zone_pos \"\n\t\t\t\t\t\t\t\"0x%llx.\",\n\t\t\t\t\t\t\t(unsigned long long)\n\t\t\t\t\t\t\tvol->mft_zone_pos);\n\t\t\t\t\ttc = rl[rlpos - 1].lcn +\n\t\t\t\t\t\t\trl[rlpos - 1].length;\n\t\t\t\t\tif (tc >= vol->mft_zone_end) {\n\t\t\t\t\t\tvol->mft_zone_pos =\n\t\t\t\t\t\t\t\tvol->mft_lcn;\n\t\t\t\t\t\tif (!vol->mft_zone_end)\n\t\t\t\t\t\t\tvol->mft_zone_pos = 0;\n\t\t\t\t\t} else if ((bmp_initial_pos >=\n\t\t\t\t\t\t\tvol->mft_zone_pos ||\n\t\t\t\t\t\t\ttc > vol->mft_zone_pos)\n\t\t\t\t\t\t\t&& tc >= vol->mft_lcn)\n\t\t\t\t\t\tvol->mft_zone_pos = tc;\n\t\t\t\t\tntfs_debug(\"After checks, \"\n\t\t\t\t\t\t\t\"vol->mft_zone_pos \"\n\t\t\t\t\t\t\t\"0x%llx.\",\n\t\t\t\t\t\t\t(unsigned long long)\n\t\t\t\t\t\t\tvol->mft_zone_pos);\n\t\t\t\t}\n\t\t\t\t/* Switch from mft zone to data1 zone. */\nswitch_to_data1_zone:\t\tsearch_zone = 2;\n\t\t\t\tzone_start = bmp_initial_pos =\n\t\t\t\t\t\tvol->data1_zone_pos;\n\t\t\t\tzone_end = vol->nr_clusters;\n\t\t\t\tif (zone_start == vol->mft_zone_end)\n\t\t\t\t\tpass = 2;\n\t\t\t\tif (zone_start >= zone_end) {\n\t\t\t\t\tvol->data1_zone_pos = zone_start =\n\t\t\t\t\t\t\tvol->mft_zone_end;\n\t\t\t\t\tpass = 2;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 2:\n\t\t\t\tntfs_debug(\"Switching from data1 zone to \"\n\t\t\t\t\t\t\"data2 zone.\");\n\t\t\t\t/* Update data1 zone position. */\n\t\t\t\tif (rlpos) {\n\t\t\t\t\tLCN tc;\n\n\t\t\t\t\tntfs_debug(\"Before checks, \"\n\t\t\t\t\t\t\t\"vol->data1_zone_pos \"\n\t\t\t\t\t\t\t\"0x%llx.\",\n\t\t\t\t\t\t\t(unsigned long long)\n\t\t\t\t\t\t\tvol->data1_zone_pos);\n\t\t\t\t\ttc = rl[rlpos - 1].lcn +\n\t\t\t\t\t\t\trl[rlpos - 1].length;\n\t\t\t\t\tif (tc >= vol->nr_clusters)\n\t\t\t\t\t\tvol->data1_zone_pos =\n\t\t\t\t\t\t\t     vol->mft_zone_end;\n\t\t\t\t\telse if ((bmp_initial_pos >=\n\t\t\t\t\t\t    vol->data1_zone_pos ||\n\t\t\t\t\t\t    tc > vol->data1_zone_pos)\n\t\t\t\t\t\t    && tc >= vol->mft_zone_end)\n\t\t\t\t\t\tvol->data1_zone_pos = tc;\n\t\t\t\t\tntfs_debug(\"After checks, \"\n\t\t\t\t\t\t\t\"vol->data1_zone_pos \"\n\t\t\t\t\t\t\t\"0x%llx.\",\n\t\t\t\t\t\t\t(unsigned long long)\n\t\t\t\t\t\t\tvol->data1_zone_pos);\n\t\t\t\t}\n\t\t\t\t/* Switch from data1 zone to data2 zone. */\n\t\t\t\tsearch_zone = 4;\n\t\t\t\tzone_start = bmp_initial_pos =\n\t\t\t\t\t\tvol->data2_zone_pos;\n\t\t\t\tzone_end = vol->mft_zone_start;\n\t\t\t\tif (!zone_start)\n\t\t\t\t\tpass = 2;\n\t\t\t\tif (zone_start >= zone_end) {\n\t\t\t\t\tvol->data2_zone_pos = zone_start =\n\t\t\t\t\t\t\tbmp_initial_pos = 0;\n\t\t\t\t\tpass = 2;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 4:\n\t\t\t\tntfs_debug(\"Switching from data2 zone to \"\n\t\t\t\t\t\t\"data1 zone.\");\n\t\t\t\t/* Update data2 zone position. */\n\t\t\t\tif (rlpos) {\n\t\t\t\t\tLCN tc;\n\n\t\t\t\t\tntfs_debug(\"Before checks, \"\n\t\t\t\t\t\t\t\"vol->data2_zone_pos \"\n\t\t\t\t\t\t\t\"0x%llx.\",\n\t\t\t\t\t\t\t(unsigned long long)\n\t\t\t\t\t\t\tvol->data2_zone_pos);\n\t\t\t\t\ttc = rl[rlpos - 1].lcn +\n\t\t\t\t\t\t\trl[rlpos - 1].length;\n\t\t\t\t\tif (tc >= vol->mft_zone_start)\n\t\t\t\t\t\tvol->data2_zone_pos = 0;\n\t\t\t\t\telse if (bmp_initial_pos >=\n\t\t\t\t\t\t      vol->data2_zone_pos ||\n\t\t\t\t\t\t      tc > vol->data2_zone_pos)\n\t\t\t\t\t\tvol->data2_zone_pos = tc;\n\t\t\t\t\tntfs_debug(\"After checks, \"\n\t\t\t\t\t\t\t\"vol->data2_zone_pos \"\n\t\t\t\t\t\t\t\"0x%llx.\",\n\t\t\t\t\t\t\t(unsigned long long)\n\t\t\t\t\t\t\tvol->data2_zone_pos);\n\t\t\t\t}\n\t\t\t\t/* Switch from data2 zone to data1 zone. */\n\t\t\t\tgoto switch_to_data1_zone;\n\t\t\tdefault:\n\t\t\t\tBUG();\n\t\t\t}\n\t\t\tntfs_debug(\"After zone switch, search_zone %i, \"\n\t\t\t\t\t\"pass %i, bmp_initial_pos 0x%llx, \"\n\t\t\t\t\t\"zone_start 0x%llx, zone_end 0x%llx.\",\n\t\t\t\t\tsearch_zone, pass,\n\t\t\t\t\t(unsigned long long)bmp_initial_pos,\n\t\t\t\t\t(unsigned long long)zone_start,\n\t\t\t\t\t(unsigned long long)zone_end);\n\t\t\tbmp_pos = zone_start;\n\t\t\tif (zone_start == zone_end) {\n\t\t\t\tntfs_debug(\"Empty zone, going to \"\n\t\t\t\t\t\t\"done_zones_check.\");\n\t\t\t\t/* Empty zone. Don't bother searching it. */\n\t\t\t\tgoto done_zones_check;\n\t\t\t}\n\t\t\tntfs_debug(\"Continuing outer while loop.\");\n\t\t\tcontinue;\n\t\t} /* done_zones == 7 */\n\t\tntfs_debug(\"All zones are finished.\");\n\t\t/*\n\t\t * All zones are finished!  If DATA_ZONE, shrink mft zone.  If\n\t\t * MFT_ZONE, we have really run out of space.\n\t\t */\n\t\tmft_zone_size = vol->mft_zone_end - vol->mft_zone_start;\n\t\tntfs_debug(\"vol->mft_zone_start 0x%llx, vol->mft_zone_end \"\n\t\t\t\t\"0x%llx, mft_zone_size 0x%llx.\",\n\t\t\t\t(unsigned long long)vol->mft_zone_start,\n\t\t\t\t(unsigned long long)vol->mft_zone_end,\n\t\t\t\t(unsigned long long)mft_zone_size);\n\t\tif (zone == MFT_ZONE || mft_zone_size <= 0) {\n\t\t\tntfs_debug(\"No free clusters left, going to out.\");\n\t\t\t/* Really no more space left on device. */\n\t\t\terr = -ENOSPC;\n\t\t\tgoto out;\n\t\t} /* zone == DATA_ZONE && mft_zone_size > 0 */\n\t\tntfs_debug(\"Shrinking mft zone.\");\n\t\tzone_end = vol->mft_zone_end;\n\t\tmft_zone_size >>= 1;\n\t\tif (mft_zone_size > 0)\n\t\t\tvol->mft_zone_end = vol->mft_zone_start + mft_zone_size;\n\t\telse /* mft zone and data2 zone no longer exist. */\n\t\t\tvol->data2_zone_pos = vol->mft_zone_start =\n\t\t\t\t\tvol->mft_zone_end = 0;\n\t\tif (vol->mft_zone_pos >= vol->mft_zone_end) {\n\t\t\tvol->mft_zone_pos = vol->mft_lcn;\n\t\t\tif (!vol->mft_zone_end)\n\t\t\t\tvol->mft_zone_pos = 0;\n\t\t}\n\t\tbmp_pos = zone_start = bmp_initial_pos =\n\t\t\t\tvol->data1_zone_pos = vol->mft_zone_end;\n\t\tsearch_zone = 2;\n\t\tpass = 2;\n\t\tdone_zones &= ~2;\n\t\tntfs_debug(\"After shrinking mft zone, mft_zone_size 0x%llx, \"\n\t\t\t\t\"vol->mft_zone_start 0x%llx, \"\n\t\t\t\t\"vol->mft_zone_end 0x%llx, \"\n\t\t\t\t\"vol->mft_zone_pos 0x%llx, search_zone 2, \"\n\t\t\t\t\"pass 2, dones_zones 0x%x, zone_start 0x%llx, \"\n\t\t\t\t\"zone_end 0x%llx, vol->data1_zone_pos 0x%llx, \"\n\t\t\t\t\"continuing outer while loop.\",\n\t\t\t\t(unsigned long long)mft_zone_size,\n\t\t\t\t(unsigned long long)vol->mft_zone_start,\n\t\t\t\t(unsigned long long)vol->mft_zone_end,\n\t\t\t\t(unsigned long long)vol->mft_zone_pos,\n\t\t\t\tdone_zones, (unsigned long long)zone_start,\n\t\t\t\t(unsigned long long)zone_end,\n\t\t\t\t(unsigned long long)vol->data1_zone_pos);\n\t}\n\tntfs_debug(\"After outer while loop.\");\nout:\n\tntfs_debug(\"At out.\");\n\t/* Add runlist terminator element. */\n\tif (likely(rl)) {\n\t\trl[rlpos].vcn = rl[rlpos - 1].vcn + rl[rlpos - 1].length;\n\t\trl[rlpos].lcn = is_extension ? LCN_ENOENT : LCN_RL_NOT_MAPPED;\n\t\trl[rlpos].length = 0;\n\t}\n\tif (likely(page && !IS_ERR(page))) {\n\t\tif (need_writeback) {\n\t\t\tntfs_debug(\"Marking page dirty.\");\n\t\t\tflush_dcache_page(page);\n\t\t\tset_page_dirty(page);\n\t\t\tneed_writeback = 0;\n\t\t}\n\t\tntfs_unmap_page(page);\n\t}\n\tif (likely(!err)) {\n\t\tup_write(&vol->lcnbmp_lock);\n\t\tntfs_debug(\"Done.\");\n\t\treturn rl;\n\t}\n\tntfs_error(vol->sb, \"Failed to allocate clusters, aborting \"\n\t\t\t\"(error %i).\", err);\n\tif (rl) {\n\t\tint err2;\n\n\t\tif (err == -ENOSPC)\n\t\t\tntfs_debug(\"Not enough space to complete allocation, \"\n\t\t\t\t\t\"err -ENOSPC, first free lcn 0x%llx, \"\n\t\t\t\t\t\"could allocate up to 0x%llx \"\n\t\t\t\t\t\"clusters.\",\n\t\t\t\t\t(unsigned long long)rl[0].lcn,\n\t\t\t\t\t(unsigned long long)(count - clusters));\n\t\t/* Deallocate all allocated clusters. */\n\t\tntfs_debug(\"Attempting rollback...\");\n\t\terr2 = ntfs_cluster_free_from_rl_nolock(vol, rl);\n\t\tif (err2) {\n\t\t\tntfs_error(vol->sb, \"Failed to rollback (error %i).  \"\n\t\t\t\t\t\"Leaving inconsistent metadata!  \"\n\t\t\t\t\t\"Unmount and run chkdsk.\", err2);\n\t\t\tNVolSetErrors(vol);\n\t\t}\n\t\t/* Free the runlist. */\n\t\tntfs_free(rl);\n\t} else if (err == -ENOSPC)\n\t\tntfs_debug(\"No space left at all, err = -ENOSPC, first free \"\n\t\t\t\t\"lcn = 0x%llx.\",\n\t\t\t\t(long long)vol->data1_zone_pos);\n\tup_write(&vol->lcnbmp_lock);\n\treturn ERR_PTR(err);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ntfs_debug",
          "args": [
            "\"Trying mft data allocation with %s cluster count %lli.\"",
            "nr > min_nr ? \"default\" : \"minimal\"",
            "(long long)nr"
          ],
          "line": 1778
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "up_write",
          "args": [
            "&mft_ni->runlist.lock"
          ],
          "line": 1774
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntfs_warning",
          "args": [
            "vol->sb",
            "\"Cannot allocate mft record \"\n\t\t\t\t\t\"because the maximum number of inodes \"\n\t\t\t\t\t\"(2^32) has already been reached.\""
          ],
          "line": 1771
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "(ll + (nr << vol->cluster_size_bits)) >>\n\t\t\t\tvol->mft_record_size_bits >= (1ll << 32)"
          ],
          "line": 1769
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "(ll + (nr << vol->cluster_size_bits)) >>\n\t\t\tvol->mft_record_size_bits >= (1ll << 32)"
          ],
          "line": 1766
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "read_unlock_irqrestore",
          "args": [
            "&mft_ni->size_lock",
            "flags"
          ],
          "line": 1765
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "read_lock_irqsave",
          "args": [
            "&mft_ni->size_lock",
            "flags"
          ],
          "line": 1763
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntfs_debug",
          "args": [
            "\"Last lcn of mft data attribute is 0x%llx.\"",
            "(long long)lcn"
          ],
          "line": 1753
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "rl"
          ],
          "line": 1749
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "rl"
          ],
          "line": 1746
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntfs_error",
          "args": [
            "vol->sb",
            "\"Failed to determine last allocated \"\n\t\t\t\t\"cluster of mft data attribute.\""
          ],
          "line": 1744
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "up_write",
          "args": [
            "&mft_ni->runlist.lock"
          ],
          "line": 1743
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "IS_ERR(rl) || !rl->length || rl->lcn < 0"
          ],
          "line": 1742
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "rl"
          ],
          "line": 1742
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntfs_attr_find_vcn_nolock",
          "args": [
            "mft_ni",
            "(ll - 1) >> vol->cluster_size_bits",
            "NULL"
          ],
          "line": 1740
        },
        "resolved": true,
        "details": {
          "function_name": "ntfs_attr_find_vcn_nolock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/attrib.c",
          "lines": "464-530",
          "snippet": "runlist_element *ntfs_attr_find_vcn_nolock(ntfs_inode *ni, const VCN vcn,\n\t\tntfs_attr_search_ctx *ctx)\n{\n\tunsigned long flags;\n\trunlist_element *rl;\n\tint err = 0;\n\tbool is_retry = false;\n\n\tBUG_ON(!ni);\n\tntfs_debug(\"Entering for i_ino 0x%lx, vcn 0x%llx, with%s ctx.\",\n\t\t\tni->mft_no, (unsigned long long)vcn, ctx ? \"\" : \"out\");\n\tBUG_ON(!NInoNonResident(ni));\n\tBUG_ON(vcn < 0);\n\tif (!ni->runlist.rl) {\n\t\tread_lock_irqsave(&ni->size_lock, flags);\n\t\tif (!ni->allocated_size) {\n\t\t\tread_unlock_irqrestore(&ni->size_lock, flags);\n\t\t\treturn ERR_PTR(-ENOENT);\n\t\t}\n\t\tread_unlock_irqrestore(&ni->size_lock, flags);\n\t}\nretry_remap:\n\trl = ni->runlist.rl;\n\tif (likely(rl && vcn >= rl[0].vcn)) {\n\t\twhile (likely(rl->length)) {\n\t\t\tif (unlikely(vcn < rl[1].vcn)) {\n\t\t\t\tif (likely(rl->lcn >= LCN_HOLE)) {\n\t\t\t\t\tntfs_debug(\"Done.\");\n\t\t\t\t\treturn rl;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\trl++;\n\t\t}\n\t\tif (likely(rl->lcn != LCN_RL_NOT_MAPPED)) {\n\t\t\tif (likely(rl->lcn == LCN_ENOENT))\n\t\t\t\terr = -ENOENT;\n\t\t\telse\n\t\t\t\terr = -EIO;\n\t\t}\n\t}\n\tif (!err && !is_retry) {\n\t\t/*\n\t\t * If the search context is invalid we cannot map the unmapped\n\t\t * region.\n\t\t */\n\t\tif (IS_ERR(ctx->mrec))\n\t\t\terr = PTR_ERR(ctx->mrec);\n\t\telse {\n\t\t\t/*\n\t\t\t * The @vcn is in an unmapped region, map the runlist\n\t\t\t * and retry.\n\t\t\t */\n\t\t\terr = ntfs_map_runlist_nolock(ni, vcn, ctx);\n\t\t\tif (likely(!err)) {\n\t\t\t\tis_retry = true;\n\t\t\t\tgoto retry_remap;\n\t\t\t}\n\t\t}\n\t\tif (err == -EINVAL)\n\t\t\terr = -EIO;\n\t} else if (!err)\n\t\terr = -EIO;\n\tif (err != -ENOENT)\n\t\tntfs_error(ni->vol->sb, \"Failed with error code %i.\", err);\n\treturn ERR_PTR(err);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include \"ntfs.h\"",
            "#include \"mft.h\"",
            "#include \"malloc.h\"",
            "#include \"lcnalloc.h\"",
            "#include \"layout.h\"",
            "#include \"debug.h\"",
            "#include \"attrib.h\"",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include \"ntfs.h\"\n#include \"mft.h\"\n#include \"malloc.h\"\n#include \"lcnalloc.h\"\n#include \"layout.h\"\n#include \"debug.h\"\n#include \"attrib.h\"\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/buffer_head.h>\n\nrunlist_element *ntfs_attr_find_vcn_nolock(ntfs_inode *ni, const VCN vcn,\n\t\tntfs_attr_search_ctx *ctx)\n{\n\tunsigned long flags;\n\trunlist_element *rl;\n\tint err = 0;\n\tbool is_retry = false;\n\n\tBUG_ON(!ni);\n\tntfs_debug(\"Entering for i_ino 0x%lx, vcn 0x%llx, with%s ctx.\",\n\t\t\tni->mft_no, (unsigned long long)vcn, ctx ? \"\" : \"out\");\n\tBUG_ON(!NInoNonResident(ni));\n\tBUG_ON(vcn < 0);\n\tif (!ni->runlist.rl) {\n\t\tread_lock_irqsave(&ni->size_lock, flags);\n\t\tif (!ni->allocated_size) {\n\t\t\tread_unlock_irqrestore(&ni->size_lock, flags);\n\t\t\treturn ERR_PTR(-ENOENT);\n\t\t}\n\t\tread_unlock_irqrestore(&ni->size_lock, flags);\n\t}\nretry_remap:\n\trl = ni->runlist.rl;\n\tif (likely(rl && vcn >= rl[0].vcn)) {\n\t\twhile (likely(rl->length)) {\n\t\t\tif (unlikely(vcn < rl[1].vcn)) {\n\t\t\t\tif (likely(rl->lcn >= LCN_HOLE)) {\n\t\t\t\t\tntfs_debug(\"Done.\");\n\t\t\t\t\treturn rl;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\trl++;\n\t\t}\n\t\tif (likely(rl->lcn != LCN_RL_NOT_MAPPED)) {\n\t\t\tif (likely(rl->lcn == LCN_ENOENT))\n\t\t\t\terr = -ENOENT;\n\t\t\telse\n\t\t\t\terr = -EIO;\n\t\t}\n\t}\n\tif (!err && !is_retry) {\n\t\t/*\n\t\t * If the search context is invalid we cannot map the unmapped\n\t\t * region.\n\t\t */\n\t\tif (IS_ERR(ctx->mrec))\n\t\t\terr = PTR_ERR(ctx->mrec);\n\t\telse {\n\t\t\t/*\n\t\t\t * The @vcn is in an unmapped region, map the runlist\n\t\t\t * and retry.\n\t\t\t */\n\t\t\terr = ntfs_map_runlist_nolock(ni, vcn, ctx);\n\t\t\tif (likely(!err)) {\n\t\t\t\tis_retry = true;\n\t\t\t\tgoto retry_remap;\n\t\t\t}\n\t\t}\n\t\tif (err == -EINVAL)\n\t\t\terr = -EIO;\n\t} else if (!err)\n\t\terr = -EIO;\n\tif (err != -ENOENT)\n\t\tntfs_error(ni->vol->sb, \"Failed with error code %i.\", err);\n\treturn ERR_PTR(err);\n}"
        }
      },
      {
        "call_info": {
          "callee": "read_unlock_irqrestore",
          "args": [
            "&mft_ni->size_lock",
            "flags"
          ],
          "line": 1739
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "read_lock_irqsave",
          "args": [
            "&mft_ni->size_lock",
            "flags"
          ],
          "line": 1737
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "down_write",
          "args": [
            "&mft_ni->runlist.lock"
          ],
          "line": 1736
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NTFS_I",
          "args": [
            "vol->mft_ino"
          ],
          "line": 1730
        },
        "resolved": true,
        "details": {
          "function_name": "NTFS_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/inode.h",
          "lines": "240-243",
          "snippet": "static inline ntfs_inode *NTFS_I(struct inode *inode)\n{\n\treturn (ntfs_inode *)list_entry(inode, big_ntfs_inode, vfs_inode);\n}",
          "includes": [
            "#include \"debug.h\"",
            "#include \"runlist.h\"",
            "#include \"types.h\"",
            "#include \"volume.h\"",
            "#include \"layout.h\"",
            "#include <linux/seq_file.h>",
            "#include <linux/mutex.h>",
            "#include <linux/mm.h>",
            "#include <linux/list.h>",
            "#include <linux/fs.h>",
            "#include <linux/atomic.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"debug.h\"\n#include \"runlist.h\"\n#include \"types.h\"\n#include \"volume.h\"\n#include \"layout.h\"\n#include <linux/seq_file.h>\n#include <linux/mutex.h>\n#include <linux/mm.h>\n#include <linux/list.h>\n#include <linux/fs.h>\n#include <linux/atomic.h>\n\nstatic inline ntfs_inode *NTFS_I(struct inode *inode)\n{\n\treturn (ntfs_inode *)list_entry(inode, big_ntfs_inode, vfs_inode);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ntfs.h\"\n#include \"mft.h\"\n#include \"malloc.h\"\n#include \"lcnalloc.h\"\n#include \"dir.h\"\n#include \"debug.h\"\n#include \"bitmap.h\"\n#include \"aops.h\"\n#include \"attrib.h\"\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n\nstatic int ntfs_mft_data_extend_allocation_nolock(ntfs_volume *vol)\n{\n\tLCN lcn;\n\tVCN old_last_vcn;\n\ts64 min_nr, nr, ll;\n\tunsigned long flags;\n\tntfs_inode *mft_ni;\n\trunlist_element *rl, *rl2;\n\tntfs_attr_search_ctx *ctx = NULL;\n\tMFT_RECORD *mrec;\n\tATTR_RECORD *a = NULL;\n\tint ret, mp_size;\n\tu32 old_alen = 0;\n\tbool mp_rebuilt = false;\n\n\tntfs_debug(\"Extending mft data allocation.\");\n\tmft_ni = NTFS_I(vol->mft_ino);\n\t/*\n\t * Determine the preferred allocation location, i.e. the last lcn of\n\t * the mft data attribute.  The allocated size of the mft data\n\t * attribute cannot be zero so we are ok to do this.\n\t */\n\tdown_write(&mft_ni->runlist.lock);\n\tread_lock_irqsave(&mft_ni->size_lock, flags);\n\tll = mft_ni->allocated_size;\n\tread_unlock_irqrestore(&mft_ni->size_lock, flags);\n\trl = ntfs_attr_find_vcn_nolock(mft_ni,\n\t\t\t(ll - 1) >> vol->cluster_size_bits, NULL);\n\tif (unlikely(IS_ERR(rl) || !rl->length || rl->lcn < 0)) {\n\t\tup_write(&mft_ni->runlist.lock);\n\t\tntfs_error(vol->sb, \"Failed to determine last allocated \"\n\t\t\t\t\"cluster of mft data attribute.\");\n\t\tif (!IS_ERR(rl))\n\t\t\tret = -EIO;\n\t\telse\n\t\t\tret = PTR_ERR(rl);\n\t\treturn ret;\n\t}\n\tlcn = rl->lcn + rl->length;\n\tntfs_debug(\"Last lcn of mft data attribute is 0x%llx.\", (long long)lcn);\n\t/* Minimum allocation is one mft record worth of clusters. */\n\tmin_nr = vol->mft_record_size >> vol->cluster_size_bits;\n\tif (!min_nr)\n\t\tmin_nr = 1;\n\t/* Want to allocate 16 mft records worth of clusters. */\n\tnr = vol->mft_record_size << 4 >> vol->cluster_size_bits;\n\tif (!nr)\n\t\tnr = min_nr;\n\t/* Ensure we do not go above 2^32-1 mft records. */\n\tread_lock_irqsave(&mft_ni->size_lock, flags);\n\tll = mft_ni->allocated_size;\n\tread_unlock_irqrestore(&mft_ni->size_lock, flags);\n\tif (unlikely((ll + (nr << vol->cluster_size_bits)) >>\n\t\t\tvol->mft_record_size_bits >= (1ll << 32))) {\n\t\tnr = min_nr;\n\t\tif (unlikely((ll + (nr << vol->cluster_size_bits)) >>\n\t\t\t\tvol->mft_record_size_bits >= (1ll << 32))) {\n\t\t\tntfs_warning(vol->sb, \"Cannot allocate mft record \"\n\t\t\t\t\t\"because the maximum number of inodes \"\n\t\t\t\t\t\"(2^32) has already been reached.\");\n\t\t\tup_write(&mft_ni->runlist.lock);\n\t\t\treturn -ENOSPC;\n\t\t}\n\t}\n\tntfs_debug(\"Trying mft data allocation with %s cluster count %lli.\",\n\t\t\tnr > min_nr ? \"default\" : \"minimal\", (long long)nr);\n\told_last_vcn = rl[1].vcn;\n\tdo {\n\t\trl2 = ntfs_cluster_alloc(vol, old_last_vcn, nr, lcn, MFT_ZONE,\n\t\t\t\ttrue);\n\t\tif (likely(!IS_ERR(rl2)))\n\t\t\tbreak;\n\t\tif (PTR_ERR(rl2) != -ENOSPC || nr == min_nr) {\n\t\t\tntfs_error(vol->sb, \"Failed to allocate the minimal \"\n\t\t\t\t\t\"number of clusters (%lli) for the \"\n\t\t\t\t\t\"mft data attribute.\", (long long)nr);\n\t\t\tup_write(&mft_ni->runlist.lock);\n\t\t\treturn PTR_ERR(rl2);\n\t\t}\n\t\t/*\n\t\t * There is not enough space to do the allocation, but there\n\t\t * might be enough space to do a minimal allocation so try that\n\t\t * before failing.\n\t\t */\n\t\tnr = min_nr;\n\t\tntfs_debug(\"Retrying mft data allocation with minimal cluster \"\n\t\t\t\t\"count %lli.\", (long long)nr);\n\t} while (1);\n\trl = ntfs_runlists_merge(mft_ni->runlist.rl, rl2);\n\tif (IS_ERR(rl)) {\n\t\tup_write(&mft_ni->runlist.lock);\n\t\tntfs_error(vol->sb, \"Failed to merge runlists for mft data \"\n\t\t\t\t\"attribute.\");\n\t\tif (ntfs_cluster_free_from_rl(vol, rl2)) {\n\t\t\tntfs_error(vol->sb, \"Failed to deallocate clusters \"\n\t\t\t\t\t\"from the mft data attribute.%s\", es);\n\t\t\tNVolSetErrors(vol);\n\t\t}\n\t\tntfs_free(rl2);\n\t\treturn PTR_ERR(rl);\n\t}\n\tmft_ni->runlist.rl = rl;\n\tntfs_debug(\"Allocated %lli clusters.\", (long long)nr);\n\t/* Find the last run in the new runlist. */\n\tfor (; rl[1].length; rl++)\n\t\t;\n\t/* Update the attribute record as well. */\n\tmrec = map_mft_record(mft_ni);\n\tif (IS_ERR(mrec)) {\n\t\tntfs_error(vol->sb, \"Failed to map mft record.\");\n\t\tret = PTR_ERR(mrec);\n\t\tgoto undo_alloc;\n\t}\n\tctx = ntfs_attr_get_search_ctx(mft_ni, mrec);\n\tif (unlikely(!ctx)) {\n\t\tntfs_error(vol->sb, \"Failed to get search context.\");\n\t\tret = -ENOMEM;\n\t\tgoto undo_alloc;\n\t}\n\tret = ntfs_attr_lookup(mft_ni->type, mft_ni->name, mft_ni->name_len,\n\t\t\tCASE_SENSITIVE, rl[1].vcn, NULL, 0, ctx);\n\tif (unlikely(ret)) {\n\t\tntfs_error(vol->sb, \"Failed to find last attribute extent of \"\n\t\t\t\t\"mft data attribute.\");\n\t\tif (ret == -ENOENT)\n\t\t\tret = -EIO;\n\t\tgoto undo_alloc;\n\t}\n\ta = ctx->attr;\n\tll = sle64_to_cpu(a->data.non_resident.lowest_vcn);\n\t/* Search back for the previous last allocated cluster of mft bitmap. */\n\tfor (rl2 = rl; rl2 > mft_ni->runlist.rl; rl2--) {\n\t\tif (ll >= rl2->vcn)\n\t\t\tbreak;\n\t}\n\tBUG_ON(ll < rl2->vcn);\n\tBUG_ON(ll >= rl2->vcn + rl2->length);\n\t/* Get the size for the new mapping pairs array for this extent. */\n\tmp_size = ntfs_get_size_for_mapping_pairs(vol, rl2, ll, -1);\n\tif (unlikely(mp_size <= 0)) {\n\t\tntfs_error(vol->sb, \"Get size for mapping pairs failed for \"\n\t\t\t\t\"mft data attribute extent.\");\n\t\tret = mp_size;\n\t\tif (!ret)\n\t\t\tret = -EIO;\n\t\tgoto undo_alloc;\n\t}\n\t/* Expand the attribute record if necessary. */\n\told_alen = le32_to_cpu(a->length);\n\tret = ntfs_attr_record_resize(ctx->mrec, a, mp_size +\n\t\t\tle16_to_cpu(a->data.non_resident.mapping_pairs_offset));\n\tif (unlikely(ret)) {\n\t\tif (ret != -ENOSPC) {\n\t\t\tntfs_error(vol->sb, \"Failed to resize attribute \"\n\t\t\t\t\t\"record for mft data attribute.\");\n\t\t\tgoto undo_alloc;\n\t\t}\n\t\t// TODO: Deal with this by moving this extent to a new mft\n\t\t// record or by starting a new extent in a new mft record or by\n\t\t// moving other attributes out of this mft record.\n\t\t// Note: Use the special reserved mft records and ensure that\n\t\t// this extent is not required to find the mft record in\n\t\t// question.  If no free special records left we would need to\n\t\t// move an existing record away, insert ours in its place, and\n\t\t// then place the moved record into the newly allocated space\n\t\t// and we would then need to update all references to this mft\n\t\t// record appropriately.  This is rather complicated...\n\t\tntfs_error(vol->sb, \"Not enough space in this mft record to \"\n\t\t\t\t\"accommodate extended mft data attribute \"\n\t\t\t\t\"extent.  Cannot handle this yet.\");\n\t\tret = -EOPNOTSUPP;\n\t\tgoto undo_alloc;\n\t}\n\tmp_rebuilt = true;\n\t/* Generate the mapping pairs array directly into the attr record. */\n\tret = ntfs_mapping_pairs_build(vol, (u8*)a +\n\t\t\tle16_to_cpu(a->data.non_resident.mapping_pairs_offset),\n\t\t\tmp_size, rl2, ll, -1, NULL);\n\tif (unlikely(ret)) {\n\t\tntfs_error(vol->sb, \"Failed to build mapping pairs array of \"\n\t\t\t\t\"mft data attribute.\");\n\t\tgoto undo_alloc;\n\t}\n\t/* Update the highest_vcn. */\n\ta->data.non_resident.highest_vcn = cpu_to_sle64(rl[1].vcn - 1);\n\t/*\n\t * We now have extended the mft data allocated_size by nr clusters.\n\t * Reflect this in the ntfs_inode structure and the attribute record.\n\t * @rl is the last (non-terminator) runlist element of mft data\n\t * attribute.\n\t */\n\tif (a->data.non_resident.lowest_vcn) {\n\t\t/*\n\t\t * We are not in the first attribute extent, switch to it, but\n\t\t * first ensure the changes will make it to disk later.\n\t\t */\n\t\tflush_dcache_mft_record_page(ctx->ntfs_ino);\n\t\tmark_mft_record_dirty(ctx->ntfs_ino);\n\t\tntfs_attr_reinit_search_ctx(ctx);\n\t\tret = ntfs_attr_lookup(mft_ni->type, mft_ni->name,\n\t\t\t\tmft_ni->name_len, CASE_SENSITIVE, 0, NULL, 0,\n\t\t\t\tctx);\n\t\tif (unlikely(ret)) {\n\t\t\tntfs_error(vol->sb, \"Failed to find first attribute \"\n\t\t\t\t\t\"extent of mft data attribute.\");\n\t\t\tgoto restore_undo_alloc;\n\t\t}\n\t\ta = ctx->attr;\n\t}\n\twrite_lock_irqsave(&mft_ni->size_lock, flags);\n\tmft_ni->allocated_size += nr << vol->cluster_size_bits;\n\ta->data.non_resident.allocated_size =\n\t\t\tcpu_to_sle64(mft_ni->allocated_size);\n\twrite_unlock_irqrestore(&mft_ni->size_lock, flags);\n\t/* Ensure the changes make it to disk. */\n\tflush_dcache_mft_record_page(ctx->ntfs_ino);\n\tmark_mft_record_dirty(ctx->ntfs_ino);\n\tntfs_attr_put_search_ctx(ctx);\n\tunmap_mft_record(mft_ni);\n\tup_write(&mft_ni->runlist.lock);\n\tntfs_debug(\"Done.\");\n\treturn 0;\nrestore_undo_alloc:\n\tntfs_attr_reinit_search_ctx(ctx);\n\tif (ntfs_attr_lookup(mft_ni->type, mft_ni->name, mft_ni->name_len,\n\t\t\tCASE_SENSITIVE, rl[1].vcn, NULL, 0, ctx)) {\n\t\tntfs_error(vol->sb, \"Failed to find last attribute extent of \"\n\t\t\t\t\"mft data attribute.%s\", es);\n\t\twrite_lock_irqsave(&mft_ni->size_lock, flags);\n\t\tmft_ni->allocated_size += nr << vol->cluster_size_bits;\n\t\twrite_unlock_irqrestore(&mft_ni->size_lock, flags);\n\t\tntfs_attr_put_search_ctx(ctx);\n\t\tunmap_mft_record(mft_ni);\n\t\tup_write(&mft_ni->runlist.lock);\n\t\t/*\n\t\t * The only thing that is now wrong is ->allocated_size of the\n\t\t * base attribute extent which chkdsk should be able to fix.\n\t\t */\n\t\tNVolSetErrors(vol);\n\t\treturn ret;\n\t}\n\tctx->attr->data.non_resident.highest_vcn =\n\t\t\tcpu_to_sle64(old_last_vcn - 1);\nundo_alloc:\n\tif (ntfs_cluster_free(mft_ni, old_last_vcn, -1, ctx) < 0) {\n\t\tntfs_error(vol->sb, \"Failed to free clusters from mft data \"\n\t\t\t\t\"attribute.%s\", es);\n\t\tNVolSetErrors(vol);\n\t}\n\ta = ctx->attr;\n\tif (ntfs_rl_truncate_nolock(vol, &mft_ni->runlist, old_last_vcn)) {\n\t\tntfs_error(vol->sb, \"Failed to truncate mft data attribute \"\n\t\t\t\t\"runlist.%s\", es);\n\t\tNVolSetErrors(vol);\n\t}\n\tif (mp_rebuilt && !IS_ERR(ctx->mrec)) {\n\t\tif (ntfs_mapping_pairs_build(vol, (u8*)a + le16_to_cpu(\n\t\t\t\ta->data.non_resident.mapping_pairs_offset),\n\t\t\t\told_alen - le16_to_cpu(\n\t\t\t\ta->data.non_resident.mapping_pairs_offset),\n\t\t\t\trl2, ll, -1, NULL)) {\n\t\t\tntfs_error(vol->sb, \"Failed to restore mapping pairs \"\n\t\t\t\t\t\"array.%s\", es);\n\t\t\tNVolSetErrors(vol);\n\t\t}\n\t\tif (ntfs_attr_record_resize(ctx->mrec, a, old_alen)) {\n\t\t\tntfs_error(vol->sb, \"Failed to restore attribute \"\n\t\t\t\t\t\"record.%s\", es);\n\t\t\tNVolSetErrors(vol);\n\t\t}\n\t\tflush_dcache_mft_record_page(ctx->ntfs_ino);\n\t\tmark_mft_record_dirty(ctx->ntfs_ino);\n\t} else if (IS_ERR(ctx->mrec)) {\n\t\tntfs_error(vol->sb, \"Failed to restore attribute search \"\n\t\t\t\t\"context.%s\", es);\n\t\tNVolSetErrors(vol);\n\t}\n\tif (ctx)\n\t\tntfs_attr_put_search_ctx(ctx);\n\tif (!IS_ERR(mrec))\n\t\tunmap_mft_record(mft_ni);\n\tup_write(&mft_ni->runlist.lock);\n\treturn ret;\n}"
  },
  {
    "function_name": "ntfs_mft_bitmap_extend_initialized_nolock",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/mft.c",
    "lines": "1577-1693",
    "snippet": "static int ntfs_mft_bitmap_extend_initialized_nolock(ntfs_volume *vol)\n{\n\ts64 old_data_size, old_initialized_size;\n\tunsigned long flags;\n\tstruct inode *mftbmp_vi;\n\tntfs_inode *mft_ni, *mftbmp_ni;\n\tntfs_attr_search_ctx *ctx;\n\tMFT_RECORD *mrec;\n\tATTR_RECORD *a;\n\tint ret;\n\n\tntfs_debug(\"Extending mft bitmap initiailized (and data) size.\");\n\tmft_ni = NTFS_I(vol->mft_ino);\n\tmftbmp_vi = vol->mftbmp_ino;\n\tmftbmp_ni = NTFS_I(mftbmp_vi);\n\t/* Get the attribute record. */\n\tmrec = map_mft_record(mft_ni);\n\tif (IS_ERR(mrec)) {\n\t\tntfs_error(vol->sb, \"Failed to map mft record.\");\n\t\treturn PTR_ERR(mrec);\n\t}\n\tctx = ntfs_attr_get_search_ctx(mft_ni, mrec);\n\tif (unlikely(!ctx)) {\n\t\tntfs_error(vol->sb, \"Failed to get search context.\");\n\t\tret = -ENOMEM;\n\t\tgoto unm_err_out;\n\t}\n\tret = ntfs_attr_lookup(mftbmp_ni->type, mftbmp_ni->name,\n\t\t\tmftbmp_ni->name_len, CASE_SENSITIVE, 0, NULL, 0, ctx);\n\tif (unlikely(ret)) {\n\t\tntfs_error(vol->sb, \"Failed to find first attribute extent of \"\n\t\t\t\t\"mft bitmap attribute.\");\n\t\tif (ret == -ENOENT)\n\t\t\tret = -EIO;\n\t\tgoto put_err_out;\n\t}\n\ta = ctx->attr;\n\twrite_lock_irqsave(&mftbmp_ni->size_lock, flags);\n\told_data_size = i_size_read(mftbmp_vi);\n\told_initialized_size = mftbmp_ni->initialized_size;\n\t/*\n\t * We can simply update the initialized_size before filling the space\n\t * with zeroes because the caller is holding the mft bitmap lock for\n\t * writing which ensures that no one else is trying to access the data.\n\t */\n\tmftbmp_ni->initialized_size += 8;\n\ta->data.non_resident.initialized_size =\n\t\t\tcpu_to_sle64(mftbmp_ni->initialized_size);\n\tif (mftbmp_ni->initialized_size > old_data_size) {\n\t\ti_size_write(mftbmp_vi, mftbmp_ni->initialized_size);\n\t\ta->data.non_resident.data_size =\n\t\t\t\tcpu_to_sle64(mftbmp_ni->initialized_size);\n\t}\n\twrite_unlock_irqrestore(&mftbmp_ni->size_lock, flags);\n\t/* Ensure the changes make it to disk. */\n\tflush_dcache_mft_record_page(ctx->ntfs_ino);\n\tmark_mft_record_dirty(ctx->ntfs_ino);\n\tntfs_attr_put_search_ctx(ctx);\n\tunmap_mft_record(mft_ni);\n\t/* Initialize the mft bitmap attribute value with zeroes. */\n\tret = ntfs_attr_set(mftbmp_ni, old_initialized_size, 8, 0);\n\tif (likely(!ret)) {\n\t\tntfs_debug(\"Done.  (Wrote eight initialized bytes to mft \"\n\t\t\t\t\"bitmap.\");\n\t\treturn 0;\n\t}\n\tntfs_error(vol->sb, \"Failed to write to mft bitmap.\");\n\t/* Try to recover from the error. */\n\tmrec = map_mft_record(mft_ni);\n\tif (IS_ERR(mrec)) {\n\t\tntfs_error(vol->sb, \"Failed to map mft record.%s\", es);\n\t\tNVolSetErrors(vol);\n\t\treturn ret;\n\t}\n\tctx = ntfs_attr_get_search_ctx(mft_ni, mrec);\n\tif (unlikely(!ctx)) {\n\t\tntfs_error(vol->sb, \"Failed to get search context.%s\", es);\n\t\tNVolSetErrors(vol);\n\t\tgoto unm_err_out;\n\t}\n\tif (ntfs_attr_lookup(mftbmp_ni->type, mftbmp_ni->name,\n\t\t\tmftbmp_ni->name_len, CASE_SENSITIVE, 0, NULL, 0, ctx)) {\n\t\tntfs_error(vol->sb, \"Failed to find first attribute extent of \"\n\t\t\t\t\"mft bitmap attribute.%s\", es);\n\t\tNVolSetErrors(vol);\nput_err_out:\n\t\tntfs_attr_put_search_ctx(ctx);\nunm_err_out:\n\t\tunmap_mft_record(mft_ni);\n\t\tgoto err_out;\n\t}\n\ta = ctx->attr;\n\twrite_lock_irqsave(&mftbmp_ni->size_lock, flags);\n\tmftbmp_ni->initialized_size = old_initialized_size;\n\ta->data.non_resident.initialized_size =\n\t\t\tcpu_to_sle64(old_initialized_size);\n\tif (i_size_read(mftbmp_vi) != old_data_size) {\n\t\ti_size_write(mftbmp_vi, old_data_size);\n\t\ta->data.non_resident.data_size = cpu_to_sle64(old_data_size);\n\t}\n\twrite_unlock_irqrestore(&mftbmp_ni->size_lock, flags);\n\tflush_dcache_mft_record_page(ctx->ntfs_ino);\n\tmark_mft_record_dirty(ctx->ntfs_ino);\n\tntfs_attr_put_search_ctx(ctx);\n\tunmap_mft_record(mft_ni);\n#ifdef DEBUG\n\tread_lock_irqsave(&mftbmp_ni->size_lock, flags);\n\tntfs_debug(\"Restored status of mftbmp: allocated_size 0x%llx, \"\n\t\t\t\"data_size 0x%llx, initialized_size 0x%llx.\",\n\t\t\t(long long)mftbmp_ni->allocated_size,\n\t\t\t(long long)i_size_read(mftbmp_vi),\n\t\t\t(long long)mftbmp_ni->initialized_size);\n\tread_unlock_irqrestore(&mftbmp_ni->size_lock, flags);\n#endif /* DEBUG */\nerr_out:\n\treturn ret;\n}",
    "includes": [
      "#include \"ntfs.h\"",
      "#include \"mft.h\"",
      "#include \"malloc.h\"",
      "#include \"lcnalloc.h\"",
      "#include \"dir.h\"",
      "#include \"debug.h\"",
      "#include \"bitmap.h\"",
      "#include \"aops.h\"",
      "#include \"attrib.h\"",
      "#include <linux/swap.h>",
      "#include <linux/slab.h>",
      "#include <linux/buffer_head.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "read_unlock_irqrestore",
          "args": [
            "&mftbmp_ni->size_lock",
            "flags"
          ],
          "line": 1689
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntfs_debug",
          "args": [
            "\"Restored status of mftbmp: allocated_size 0x%llx, \"\n\t\t\t\"data_size 0x%llx, initialized_size 0x%llx.\"",
            "(long long)mftbmp_ni->allocated_size",
            "(long long)i_size_read(mftbmp_vi)",
            "(long long)mftbmp_ni->initialized_size"
          ],
          "line": 1684
        },
        "resolved": true,
        "details": {
          "function_name": "__ntfs_debug",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/debug.c",
          "lines": "115-131",
          "snippet": "void __ntfs_debug(const char *file, int line, const char *function,\n\t\tconst char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\tint flen = 0;\n\n\tif (!debug_msgs)\n\t\treturn;\n\tif (function)\n\t\tflen = strlen(function);\n\tva_start(args, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\tpr_debug(\"(%s, %d): %s(): %pV\", file, line, flen ? function : \"\", &vaf);\n\tva_end(args);\n}",
          "includes": [
            "#include \"debug.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"debug.h\"\n\nvoid __ntfs_debug(const char *file, int line, const char *function,\n\t\tconst char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\tint flen = 0;\n\n\tif (!debug_msgs)\n\t\treturn;\n\tif (function)\n\t\tflen = strlen(function);\n\tva_start(args, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\tpr_debug(\"(%s, %d): %s(): %pV\", file, line, flen ? function : \"\", &vaf);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "i_size_read",
          "args": [
            "mftbmp_vi"
          ],
          "line": 1687
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "read_lock_irqsave",
          "args": [
            "&mftbmp_ni->size_lock",
            "flags"
          ],
          "line": 1683
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unmap_mft_record",
          "args": [
            "mft_ni"
          ],
          "line": 1681
        },
        "resolved": true,
        "details": {
          "function_name": "unmap_mft_record",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/mft.c",
          "lines": "213-231",
          "snippet": "void unmap_mft_record(ntfs_inode *ni)\n{\n\tstruct page *page = ni->page;\n\n\tBUG_ON(!page);\n\n\tntfs_debug(\"Entering for mft_no 0x%lx.\", ni->mft_no);\n\n\tunmap_mft_record_page(ni);\n\tmutex_unlock(&ni->mrec_lock);\n\tatomic_dec(&ni->count);\n\t/*\n\t * If pure ntfs_inode, i.e. no vfs inode attached, we leave it to\n\t * ntfs_clear_extent_inode() in the extent inode case, and to the\n\t * caller in the non-extent, yet pure ntfs inode case, to do the actual\n\t * tear down of all structures and freeing of all allocated memory.\n\t */\n\treturn;\n}",
          "includes": [
            "#include \"ntfs.h\"",
            "#include \"mft.h\"",
            "#include \"malloc.h\"",
            "#include \"lcnalloc.h\"",
            "#include \"dir.h\"",
            "#include \"debug.h\"",
            "#include \"bitmap.h\"",
            "#include \"aops.h\"",
            "#include \"attrib.h\"",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ntfs.h\"\n#include \"mft.h\"\n#include \"malloc.h\"\n#include \"lcnalloc.h\"\n#include \"dir.h\"\n#include \"debug.h\"\n#include \"bitmap.h\"\n#include \"aops.h\"\n#include \"attrib.h\"\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n\nvoid unmap_mft_record(ntfs_inode *ni)\n{\n\tstruct page *page = ni->page;\n\n\tBUG_ON(!page);\n\n\tntfs_debug(\"Entering for mft_no 0x%lx.\", ni->mft_no);\n\n\tunmap_mft_record_page(ni);\n\tmutex_unlock(&ni->mrec_lock);\n\tatomic_dec(&ni->count);\n\t/*\n\t * If pure ntfs_inode, i.e. no vfs inode attached, we leave it to\n\t * ntfs_clear_extent_inode() in the extent inode case, and to the\n\t * caller in the non-extent, yet pure ntfs inode case, to do the actual\n\t * tear down of all structures and freeing of all allocated memory.\n\t */\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ntfs_attr_put_search_ctx",
          "args": [
            "ctx"
          ],
          "line": 1680
        },
        "resolved": true,
        "details": {
          "function_name": "ntfs_attr_put_search_ctx",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/attrib.c",
          "lines": "1286-1292",
          "snippet": "void ntfs_attr_put_search_ctx(ntfs_attr_search_ctx *ctx)\n{\n\tif (ctx->base_ntfs_ino && ctx->ntfs_ino != ctx->base_ntfs_ino)\n\t\tunmap_extent_mft_record(ctx->ntfs_ino);\n\tkmem_cache_free(ntfs_attr_ctx_cache, ctx);\n\treturn;\n}",
          "includes": [
            "#include \"types.h\"",
            "#include \"ntfs.h\"",
            "#include \"mft.h\"",
            "#include \"malloc.h\"",
            "#include \"lcnalloc.h\"",
            "#include \"layout.h\"",
            "#include \"debug.h\"",
            "#include \"attrib.h\"",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include \"ntfs.h\"\n#include \"mft.h\"\n#include \"malloc.h\"\n#include \"lcnalloc.h\"\n#include \"layout.h\"\n#include \"debug.h\"\n#include \"attrib.h\"\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/buffer_head.h>\n\nvoid ntfs_attr_put_search_ctx(ntfs_attr_search_ctx *ctx)\n{\n\tif (ctx->base_ntfs_ino && ctx->ntfs_ino != ctx->base_ntfs_ino)\n\t\tunmap_extent_mft_record(ctx->ntfs_ino);\n\tkmem_cache_free(ntfs_attr_ctx_cache, ctx);\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mark_mft_record_dirty",
          "args": [
            "ctx->ntfs_ino"
          ],
          "line": 1679
        },
        "resolved": true,
        "details": {
          "function_name": "__mark_mft_record_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/mft.c",
          "lines": "395-410",
          "snippet": "void __mark_mft_record_dirty(ntfs_inode *ni)\n{\n\tntfs_inode *base_ni;\n\n\tntfs_debug(\"Entering for inode 0x%lx.\", ni->mft_no);\n\tBUG_ON(NInoAttr(ni));\n\tmark_ntfs_record_dirty(ni->page, ni->page_ofs);\n\t/* Determine the base vfs inode and mark it dirty, too. */\n\tmutex_lock(&ni->extent_lock);\n\tif (likely(ni->nr_extents >= 0))\n\t\tbase_ni = ni;\n\telse\n\t\tbase_ni = ni->ext.base_ntfs_ino;\n\tmutex_unlock(&ni->extent_lock);\n\t__mark_inode_dirty(VFS_I(base_ni), I_DIRTY_SYNC | I_DIRTY_DATASYNC);\n}",
          "includes": [
            "#include \"ntfs.h\"",
            "#include \"mft.h\"",
            "#include \"malloc.h\"",
            "#include \"lcnalloc.h\"",
            "#include \"dir.h\"",
            "#include \"debug.h\"",
            "#include \"bitmap.h\"",
            "#include \"aops.h\"",
            "#include \"attrib.h\"",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ntfs.h\"\n#include \"mft.h\"\n#include \"malloc.h\"\n#include \"lcnalloc.h\"\n#include \"dir.h\"\n#include \"debug.h\"\n#include \"bitmap.h\"\n#include \"aops.h\"\n#include \"attrib.h\"\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n\nvoid __mark_mft_record_dirty(ntfs_inode *ni)\n{\n\tntfs_inode *base_ni;\n\n\tntfs_debug(\"Entering for inode 0x%lx.\", ni->mft_no);\n\tBUG_ON(NInoAttr(ni));\n\tmark_ntfs_record_dirty(ni->page, ni->page_ofs);\n\t/* Determine the base vfs inode and mark it dirty, too. */\n\tmutex_lock(&ni->extent_lock);\n\tif (likely(ni->nr_extents >= 0))\n\t\tbase_ni = ni;\n\telse\n\t\tbase_ni = ni->ext.base_ntfs_ino;\n\tmutex_unlock(&ni->extent_lock);\n\t__mark_inode_dirty(VFS_I(base_ni), I_DIRTY_SYNC | I_DIRTY_DATASYNC);\n}"
        }
      },
      {
        "call_info": {
          "callee": "flush_dcache_mft_record_page",
          "args": [
            "ctx->ntfs_ino"
          ],
          "line": 1678
        },
        "resolved": true,
        "details": {
          "function_name": "flush_dcache_mft_record_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/mft.h",
          "lines": "55-58",
          "snippet": "static inline void flush_dcache_mft_record_page(ntfs_inode *ni)\n{\n\tflush_dcache_page(ni->page);\n}",
          "includes": [
            "#include \"inode.h\"",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"inode.h\"\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/fs.h>\n\nstatic inline void flush_dcache_mft_record_page(ntfs_inode *ni)\n{\n\tflush_dcache_page(ni->page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "write_unlock_irqrestore",
          "args": [
            "&mftbmp_ni->size_lock",
            "flags"
          ],
          "line": 1677
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_sle64",
          "args": [
            "old_data_size"
          ],
          "line": 1675
        },
        "resolved": true,
        "details": {
          "function_name": "cpu_to_sle64p",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "88-91",
          "snippet": "static inline sle64 cpu_to_sle64p(s64 *x)\n{\n\treturn (__force sle64)cpu_to_le64(*x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline sle64 cpu_to_sle64p(s64 *x)\n{\n\treturn (__force sle64)cpu_to_le64(*x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "i_size_write",
          "args": [
            "mftbmp_vi",
            "old_data_size"
          ],
          "line": 1674
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_i_size_write",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/btrfs_inode.h",
          "lines": "233-237",
          "snippet": "static inline void btrfs_i_size_write(struct inode *inode, u64 size)\n{\n\ti_size_write(inode, size);\n\tBTRFS_I(inode)->disk_i_size = size;\n}",
          "includes": [
            "#include \"delayed-inode.h\"",
            "#include \"ordered-data.h\"",
            "#include \"extent_io.h\"",
            "#include \"extent_map.h\"",
            "#include <linux/hash.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"delayed-inode.h\"\n#include \"ordered-data.h\"\n#include \"extent_io.h\"\n#include \"extent_map.h\"\n#include <linux/hash.h>\n\nstatic inline void btrfs_i_size_write(struct inode *inode, u64 size)\n{\n\ti_size_write(inode, size);\n\tBTRFS_I(inode)->disk_i_size = size;\n}"
        }
      },
      {
        "call_info": {
          "callee": "i_size_read",
          "args": [
            "mftbmp_vi"
          ],
          "line": 1673
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "write_lock_irqsave",
          "args": [
            "&mftbmp_ni->size_lock",
            "flags"
          ],
          "line": 1669
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NVolSetErrors",
          "args": [
            "vol"
          ],
          "line": 1661
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntfs_error",
          "args": [
            "vol->sb",
            "\"Failed to find first attribute extent of \"\n\t\t\t\t\"mft bitmap attribute.%s\"",
            "es"
          ],
          "line": 1659
        },
        "resolved": true,
        "details": {
          "function_name": "__ntfs_error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/debug.c",
          "lines": "86-108",
          "snippet": "void __ntfs_error(const char *function, const struct super_block *sb,\n\t\tconst char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\tint flen = 0;\n\n#ifndef DEBUG\n\tif (!printk_ratelimit())\n\t\treturn;\n#endif\n\tif (function)\n\t\tflen = strlen(function);\n\tva_start(args, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\tif (sb)\n\t\tpr_err(\"(device %s): %s(): %pV\\n\",\n\t\t       sb->s_id, flen ? function : \"\", &vaf);\n\telse\n\t\tpr_err(\"%s(): %pV\\n\", flen ? function : \"\", &vaf);\n\tva_end(args);\n}",
          "includes": [
            "#include \"debug.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"debug.h\"\n\nvoid __ntfs_error(const char *function, const struct super_block *sb,\n\t\tconst char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\tint flen = 0;\n\n#ifndef DEBUG\n\tif (!printk_ratelimit())\n\t\treturn;\n#endif\n\tif (function)\n\t\tflen = strlen(function);\n\tva_start(args, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\tif (sb)\n\t\tpr_err(\"(device %s): %s(): %pV\\n\",\n\t\t       sb->s_id, flen ? function : \"\", &vaf);\n\telse\n\t\tpr_err(\"%s(): %pV\\n\", flen ? function : \"\", &vaf);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ntfs_attr_lookup",
          "args": [
            "mftbmp_ni->type",
            "mftbmp_ni->name",
            "mftbmp_ni->name_len",
            "CASE_SENSITIVE",
            "0",
            "NULL",
            "0",
            "ctx"
          ],
          "line": 1657
        },
        "resolved": true,
        "details": {
          "function_name": "ntfs_attr_lookup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/attrib.c",
          "lines": "1187-1207",
          "snippet": "int ntfs_attr_lookup(const ATTR_TYPE type, const ntfschar *name,\n\t\tconst u32 name_len, const IGNORE_CASE_BOOL ic,\n\t\tconst VCN lowest_vcn, const u8 *val, const u32 val_len,\n\t\tntfs_attr_search_ctx *ctx)\n{\n\tntfs_inode *base_ni;\n\n\tntfs_debug(\"Entering.\");\n\tBUG_ON(IS_ERR(ctx->mrec));\n\tif (ctx->base_ntfs_ino)\n\t\tbase_ni = ctx->base_ntfs_ino;\n\telse\n\t\tbase_ni = ctx->ntfs_ino;\n\t/* Sanity check, just for debugging really. */\n\tBUG_ON(!base_ni);\n\tif (!NInoAttrList(base_ni) || type == AT_ATTRIBUTE_LIST)\n\t\treturn ntfs_attr_find(type, name, name_len, ic, val, val_len,\n\t\t\t\tctx);\n\treturn ntfs_external_attr_find(type, name, name_len, ic, lowest_vcn,\n\t\t\tval, val_len, ctx);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include \"ntfs.h\"",
            "#include \"mft.h\"",
            "#include \"malloc.h\"",
            "#include \"lcnalloc.h\"",
            "#include \"layout.h\"",
            "#include \"debug.h\"",
            "#include \"attrib.h\"",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include \"ntfs.h\"\n#include \"mft.h\"\n#include \"malloc.h\"\n#include \"lcnalloc.h\"\n#include \"layout.h\"\n#include \"debug.h\"\n#include \"attrib.h\"\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/buffer_head.h>\n\nint ntfs_attr_lookup(const ATTR_TYPE type, const ntfschar *name,\n\t\tconst u32 name_len, const IGNORE_CASE_BOOL ic,\n\t\tconst VCN lowest_vcn, const u8 *val, const u32 val_len,\n\t\tntfs_attr_search_ctx *ctx)\n{\n\tntfs_inode *base_ni;\n\n\tntfs_debug(\"Entering.\");\n\tBUG_ON(IS_ERR(ctx->mrec));\n\tif (ctx->base_ntfs_ino)\n\t\tbase_ni = ctx->base_ntfs_ino;\n\telse\n\t\tbase_ni = ctx->ntfs_ino;\n\t/* Sanity check, just for debugging really. */\n\tBUG_ON(!base_ni);\n\tif (!NInoAttrList(base_ni) || type == AT_ATTRIBUTE_LIST)\n\t\treturn ntfs_attr_find(type, name, name_len, ic, val, val_len,\n\t\t\t\tctx);\n\treturn ntfs_external_attr_find(type, name, name_len, ic, lowest_vcn,\n\t\t\tval, val_len, ctx);\n}"
        }
      },
      {
        "call_info": {
          "callee": "NVolSetErrors",
          "args": [
            "vol"
          ],
          "line": 1654
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!ctx"
          ],
          "line": 1652
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntfs_attr_get_search_ctx",
          "args": [
            "mft_ni",
            "mrec"
          ],
          "line": 1651
        },
        "resolved": true,
        "details": {
          "function_name": "ntfs_attr_get_search_ctx",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/attrib.c",
          "lines": "1269-1277",
          "snippet": "ntfs_attr_search_ctx *ntfs_attr_get_search_ctx(ntfs_inode *ni, MFT_RECORD *mrec)\n{\n\tntfs_attr_search_ctx *ctx;\n\n\tctx = kmem_cache_alloc(ntfs_attr_ctx_cache, GFP_NOFS);\n\tif (ctx)\n\t\tntfs_attr_init_search_ctx(ctx, ni, mrec);\n\treturn ctx;\n}",
          "includes": [
            "#include \"types.h\"",
            "#include \"ntfs.h\"",
            "#include \"mft.h\"",
            "#include \"malloc.h\"",
            "#include \"lcnalloc.h\"",
            "#include \"layout.h\"",
            "#include \"debug.h\"",
            "#include \"attrib.h\"",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include \"ntfs.h\"\n#include \"mft.h\"\n#include \"malloc.h\"\n#include \"lcnalloc.h\"\n#include \"layout.h\"\n#include \"debug.h\"\n#include \"attrib.h\"\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/buffer_head.h>\n\nntfs_attr_search_ctx *ntfs_attr_get_search_ctx(ntfs_inode *ni, MFT_RECORD *mrec)\n{\n\tntfs_attr_search_ctx *ctx;\n\n\tctx = kmem_cache_alloc(ntfs_attr_ctx_cache, GFP_NOFS);\n\tif (ctx)\n\t\tntfs_attr_init_search_ctx(ctx, ni, mrec);\n\treturn ctx;\n}"
        }
      },
      {
        "call_info": {
          "callee": "NVolSetErrors",
          "args": [
            "vol"
          ],
          "line": 1648
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "mrec"
          ],
          "line": 1646
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntfs_error",
          "args": [
            "vol->sb",
            "\"Failed to write to mft bitmap.\""
          ],
          "line": 1643
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntfs_debug",
          "args": [
            "\"Done.  (Wrote eight initialized bytes to mft \"\n\t\t\t\t\"bitmap.\""
          ],
          "line": 1639
        },
        "resolved": true,
        "details": {
          "function_name": "ntfs_debug_dump_runlist",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/debug.c",
          "lines": "134-171",
          "snippet": "void ntfs_debug_dump_runlist(const runlist_element *rl)\n{\n\tint i;\n\tconst char *lcn_str[5] = { \"LCN_HOLE         \", \"LCN_RL_NOT_MAPPED\",\n\t\t\t\t   \"LCN_ENOENT       \", \"LCN_unknown      \" };\n\n\tif (!debug_msgs)\n\t\treturn;\n\tpr_debug(\"Dumping runlist (values in hex):\\n\");\n\tif (!rl) {\n\t\tpr_debug(\"Run list not present.\\n\");\n\t\treturn;\n\t}\n\tpr_debug(\"VCN              LCN               Run length\\n\");\n\tfor (i = 0; ; i++) {\n\t\tLCN lcn = (rl + i)->lcn;\n\n\t\tif (lcn < (LCN)0) {\n\t\t\tint index = -lcn - 1;\n\n\t\t\tif (index > -LCN_ENOENT - 1)\n\t\t\t\tindex = 3;\n\t\t\tpr_debug(\"%-16Lx %s %-16Lx%s\\n\",\n\t\t\t\t\t(long long)(rl + i)->vcn, lcn_str[index],\n\t\t\t\t\t(long long)(rl + i)->length,\n\t\t\t\t\t(rl + i)->length ? \"\" :\n\t\t\t\t\t\t\" (runlist end)\");\n\t\t} else\n\t\t\tpr_debug(\"%-16Lx %-16Lx  %-16Lx%s\\n\",\n\t\t\t\t\t(long long)(rl + i)->vcn,\n\t\t\t\t\t(long long)(rl + i)->lcn,\n\t\t\t\t\t(long long)(rl + i)->length,\n\t\t\t\t\t(rl + i)->length ? \"\" :\n\t\t\t\t\t\t\" (runlist end)\");\n\t\tif (!(rl + i)->length)\n\t\t\tbreak;\n\t}\n}",
          "includes": [
            "#include \"debug.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"debug.h\"\n\nvoid ntfs_debug_dump_runlist(const runlist_element *rl)\n{\n\tint i;\n\tconst char *lcn_str[5] = { \"LCN_HOLE         \", \"LCN_RL_NOT_MAPPED\",\n\t\t\t\t   \"LCN_ENOENT       \", \"LCN_unknown      \" };\n\n\tif (!debug_msgs)\n\t\treturn;\n\tpr_debug(\"Dumping runlist (values in hex):\\n\");\n\tif (!rl) {\n\t\tpr_debug(\"Run list not present.\\n\");\n\t\treturn;\n\t}\n\tpr_debug(\"VCN              LCN               Run length\\n\");\n\tfor (i = 0; ; i++) {\n\t\tLCN lcn = (rl + i)->lcn;\n\n\t\tif (lcn < (LCN)0) {\n\t\t\tint index = -lcn - 1;\n\n\t\t\tif (index > -LCN_ENOENT - 1)\n\t\t\t\tindex = 3;\n\t\t\tpr_debug(\"%-16Lx %s %-16Lx%s\\n\",\n\t\t\t\t\t(long long)(rl + i)->vcn, lcn_str[index],\n\t\t\t\t\t(long long)(rl + i)->length,\n\t\t\t\t\t(rl + i)->length ? \"\" :\n\t\t\t\t\t\t\" (runlist end)\");\n\t\t} else\n\t\t\tpr_debug(\"%-16Lx %-16Lx  %-16Lx%s\\n\",\n\t\t\t\t\t(long long)(rl + i)->vcn,\n\t\t\t\t\t(long long)(rl + i)->lcn,\n\t\t\t\t\t(long long)(rl + i)->length,\n\t\t\t\t\t(rl + i)->length ? \"\" :\n\t\t\t\t\t\t\" (runlist end)\");\n\t\tif (!(rl + i)->length)\n\t\t\tbreak;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "likely",
          "args": [
            "!ret"
          ],
          "line": 1638
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntfs_attr_set",
          "args": [
            "mftbmp_ni",
            "old_initialized_size",
            "8",
            "0"
          ],
          "line": 1637
        },
        "resolved": true,
        "details": {
          "function_name": "ntfs_attr_set",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/attrib.c",
          "lines": "2493-2612",
          "snippet": "int ntfs_attr_set(ntfs_inode *ni, const s64 ofs, const s64 cnt, const u8 val)\n{\n\tntfs_volume *vol = ni->vol;\n\tstruct address_space *mapping;\n\tstruct page *page;\n\tu8 *kaddr;\n\tpgoff_t idx, end;\n\tunsigned start_ofs, end_ofs, size;\n\n\tntfs_debug(\"Entering for ofs 0x%llx, cnt 0x%llx, val 0x%hx.\",\n\t\t\t(long long)ofs, (long long)cnt, val);\n\tBUG_ON(ofs < 0);\n\tBUG_ON(cnt < 0);\n\tif (!cnt)\n\t\tgoto done;\n\t/*\n\t * FIXME: Compressed and encrypted attributes are not supported when\n\t * writing and we should never have gotten here for them.\n\t */\n\tBUG_ON(NInoCompressed(ni));\n\tBUG_ON(NInoEncrypted(ni));\n\tmapping = VFS_I(ni)->i_mapping;\n\t/* Work out the starting index and page offset. */\n\tidx = ofs >> PAGE_CACHE_SHIFT;\n\tstart_ofs = ofs & ~PAGE_CACHE_MASK;\n\t/* Work out the ending index and page offset. */\n\tend = ofs + cnt;\n\tend_ofs = end & ~PAGE_CACHE_MASK;\n\t/* If the end is outside the inode size return -ESPIPE. */\n\tif (unlikely(end > i_size_read(VFS_I(ni)))) {\n\t\tntfs_error(vol->sb, \"Request exceeds end of attribute.\");\n\t\treturn -ESPIPE;\n\t}\n\tend >>= PAGE_CACHE_SHIFT;\n\t/* If there is a first partial page, need to do it the slow way. */\n\tif (start_ofs) {\n\t\tpage = read_mapping_page(mapping, idx, NULL);\n\t\tif (IS_ERR(page)) {\n\t\t\tntfs_error(vol->sb, \"Failed to read first partial \"\n\t\t\t\t\t\"page (error, index 0x%lx).\", idx);\n\t\t\treturn PTR_ERR(page);\n\t\t}\n\t\t/*\n\t\t * If the last page is the same as the first page, need to\n\t\t * limit the write to the end offset.\n\t\t */\n\t\tsize = PAGE_CACHE_SIZE;\n\t\tif (idx == end)\n\t\t\tsize = end_ofs;\n\t\tkaddr = kmap_atomic(page);\n\t\tmemset(kaddr + start_ofs, val, size - start_ofs);\n\t\tflush_dcache_page(page);\n\t\tkunmap_atomic(kaddr);\n\t\tset_page_dirty(page);\n\t\tpage_cache_release(page);\n\t\tbalance_dirty_pages_ratelimited(mapping);\n\t\tcond_resched();\n\t\tif (idx == end)\n\t\t\tgoto done;\n\t\tidx++;\n\t}\n\t/* Do the whole pages the fast way. */\n\tfor (; idx < end; idx++) {\n\t\t/* Find or create the current page.  (The page is locked.) */\n\t\tpage = grab_cache_page(mapping, idx);\n\t\tif (unlikely(!page)) {\n\t\t\tntfs_error(vol->sb, \"Insufficient memory to grab \"\n\t\t\t\t\t\"page (index 0x%lx).\", idx);\n\t\t\treturn -ENOMEM;\n\t\t}\n\t\tkaddr = kmap_atomic(page);\n\t\tmemset(kaddr, val, PAGE_CACHE_SIZE);\n\t\tflush_dcache_page(page);\n\t\tkunmap_atomic(kaddr);\n\t\t/*\n\t\t * If the page has buffers, mark them uptodate since buffer\n\t\t * state and not page state is definitive in 2.6 kernels.\n\t\t */\n\t\tif (page_has_buffers(page)) {\n\t\t\tstruct buffer_head *bh, *head;\n\n\t\t\tbh = head = page_buffers(page);\n\t\t\tdo {\n\t\t\t\tset_buffer_uptodate(bh);\n\t\t\t} while ((bh = bh->b_this_page) != head);\n\t\t}\n\t\t/* Now that buffers are uptodate, set the page uptodate, too. */\n\t\tSetPageUptodate(page);\n\t\t/*\n\t\t * Set the page and all its buffers dirty and mark the inode\n\t\t * dirty, too.  The VM will write the page later on.\n\t\t */\n\t\tset_page_dirty(page);\n\t\t/* Finally unlock and release the page. */\n\t\tunlock_page(page);\n\t\tpage_cache_release(page);\n\t\tbalance_dirty_pages_ratelimited(mapping);\n\t\tcond_resched();\n\t}\n\t/* If there is a last partial page, need to do it the slow way. */\n\tif (end_ofs) {\n\t\tpage = read_mapping_page(mapping, idx, NULL);\n\t\tif (IS_ERR(page)) {\n\t\t\tntfs_error(vol->sb, \"Failed to read last partial page \"\n\t\t\t\t\t\"(error, index 0x%lx).\", idx);\n\t\t\treturn PTR_ERR(page);\n\t\t}\n\t\tkaddr = kmap_atomic(page);\n\t\tmemset(kaddr, val, end_ofs);\n\t\tflush_dcache_page(page);\n\t\tkunmap_atomic(kaddr);\n\t\tset_page_dirty(page);\n\t\tpage_cache_release(page);\n\t\tbalance_dirty_pages_ratelimited(mapping);\n\t\tcond_resched();\n\t}\ndone:\n\tntfs_debug(\"Done.\");\n\treturn 0;\n}",
          "includes": [
            "#include \"types.h\"",
            "#include \"ntfs.h\"",
            "#include \"mft.h\"",
            "#include \"malloc.h\"",
            "#include \"lcnalloc.h\"",
            "#include \"layout.h\"",
            "#include \"debug.h\"",
            "#include \"attrib.h\"",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include \"ntfs.h\"\n#include \"mft.h\"\n#include \"malloc.h\"\n#include \"lcnalloc.h\"\n#include \"layout.h\"\n#include \"debug.h\"\n#include \"attrib.h\"\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/buffer_head.h>\n\nint ntfs_attr_set(ntfs_inode *ni, const s64 ofs, const s64 cnt, const u8 val)\n{\n\tntfs_volume *vol = ni->vol;\n\tstruct address_space *mapping;\n\tstruct page *page;\n\tu8 *kaddr;\n\tpgoff_t idx, end;\n\tunsigned start_ofs, end_ofs, size;\n\n\tntfs_debug(\"Entering for ofs 0x%llx, cnt 0x%llx, val 0x%hx.\",\n\t\t\t(long long)ofs, (long long)cnt, val);\n\tBUG_ON(ofs < 0);\n\tBUG_ON(cnt < 0);\n\tif (!cnt)\n\t\tgoto done;\n\t/*\n\t * FIXME: Compressed and encrypted attributes are not supported when\n\t * writing and we should never have gotten here for them.\n\t */\n\tBUG_ON(NInoCompressed(ni));\n\tBUG_ON(NInoEncrypted(ni));\n\tmapping = VFS_I(ni)->i_mapping;\n\t/* Work out the starting index and page offset. */\n\tidx = ofs >> PAGE_CACHE_SHIFT;\n\tstart_ofs = ofs & ~PAGE_CACHE_MASK;\n\t/* Work out the ending index and page offset. */\n\tend = ofs + cnt;\n\tend_ofs = end & ~PAGE_CACHE_MASK;\n\t/* If the end is outside the inode size return -ESPIPE. */\n\tif (unlikely(end > i_size_read(VFS_I(ni)))) {\n\t\tntfs_error(vol->sb, \"Request exceeds end of attribute.\");\n\t\treturn -ESPIPE;\n\t}\n\tend >>= PAGE_CACHE_SHIFT;\n\t/* If there is a first partial page, need to do it the slow way. */\n\tif (start_ofs) {\n\t\tpage = read_mapping_page(mapping, idx, NULL);\n\t\tif (IS_ERR(page)) {\n\t\t\tntfs_error(vol->sb, \"Failed to read first partial \"\n\t\t\t\t\t\"page (error, index 0x%lx).\", idx);\n\t\t\treturn PTR_ERR(page);\n\t\t}\n\t\t/*\n\t\t * If the last page is the same as the first page, need to\n\t\t * limit the write to the end offset.\n\t\t */\n\t\tsize = PAGE_CACHE_SIZE;\n\t\tif (idx == end)\n\t\t\tsize = end_ofs;\n\t\tkaddr = kmap_atomic(page);\n\t\tmemset(kaddr + start_ofs, val, size - start_ofs);\n\t\tflush_dcache_page(page);\n\t\tkunmap_atomic(kaddr);\n\t\tset_page_dirty(page);\n\t\tpage_cache_release(page);\n\t\tbalance_dirty_pages_ratelimited(mapping);\n\t\tcond_resched();\n\t\tif (idx == end)\n\t\t\tgoto done;\n\t\tidx++;\n\t}\n\t/* Do the whole pages the fast way. */\n\tfor (; idx < end; idx++) {\n\t\t/* Find or create the current page.  (The page is locked.) */\n\t\tpage = grab_cache_page(mapping, idx);\n\t\tif (unlikely(!page)) {\n\t\t\tntfs_error(vol->sb, \"Insufficient memory to grab \"\n\t\t\t\t\t\"page (index 0x%lx).\", idx);\n\t\t\treturn -ENOMEM;\n\t\t}\n\t\tkaddr = kmap_atomic(page);\n\t\tmemset(kaddr, val, PAGE_CACHE_SIZE);\n\t\tflush_dcache_page(page);\n\t\tkunmap_atomic(kaddr);\n\t\t/*\n\t\t * If the page has buffers, mark them uptodate since buffer\n\t\t * state and not page state is definitive in 2.6 kernels.\n\t\t */\n\t\tif (page_has_buffers(page)) {\n\t\t\tstruct buffer_head *bh, *head;\n\n\t\t\tbh = head = page_buffers(page);\n\t\t\tdo {\n\t\t\t\tset_buffer_uptodate(bh);\n\t\t\t} while ((bh = bh->b_this_page) != head);\n\t\t}\n\t\t/* Now that buffers are uptodate, set the page uptodate, too. */\n\t\tSetPageUptodate(page);\n\t\t/*\n\t\t * Set the page and all its buffers dirty and mark the inode\n\t\t * dirty, too.  The VM will write the page later on.\n\t\t */\n\t\tset_page_dirty(page);\n\t\t/* Finally unlock and release the page. */\n\t\tunlock_page(page);\n\t\tpage_cache_release(page);\n\t\tbalance_dirty_pages_ratelimited(mapping);\n\t\tcond_resched();\n\t}\n\t/* If there is a last partial page, need to do it the slow way. */\n\tif (end_ofs) {\n\t\tpage = read_mapping_page(mapping, idx, NULL);\n\t\tif (IS_ERR(page)) {\n\t\t\tntfs_error(vol->sb, \"Failed to read last partial page \"\n\t\t\t\t\t\"(error, index 0x%lx).\", idx);\n\t\t\treturn PTR_ERR(page);\n\t\t}\n\t\tkaddr = kmap_atomic(page);\n\t\tmemset(kaddr, val, end_ofs);\n\t\tflush_dcache_page(page);\n\t\tkunmap_atomic(kaddr);\n\t\tset_page_dirty(page);\n\t\tpage_cache_release(page);\n\t\tbalance_dirty_pages_ratelimited(mapping);\n\t\tcond_resched();\n\t}\ndone:\n\tntfs_debug(\"Done.\");\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "write_unlock_irqrestore",
          "args": [
            "&mftbmp_ni->size_lock",
            "flags"
          ],
          "line": 1630
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "i_size_read",
          "args": [
            "mftbmp_vi"
          ],
          "line": 1615
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "write_lock_irqsave",
          "args": [
            "&mftbmp_ni->size_lock",
            "flags"
          ],
          "line": 1614
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntfs_error",
          "args": [
            "vol->sb",
            "\"Failed to find first attribute extent of \"\n\t\t\t\t\"mft bitmap attribute.\""
          ],
          "line": 1607
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "ret"
          ],
          "line": 1606
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntfs_error",
          "args": [
            "vol->sb",
            "\"Failed to get search context.\""
          ],
          "line": 1600
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!ctx"
          ],
          "line": 1599
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "mrec"
          ],
          "line": 1596
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntfs_error",
          "args": [
            "vol->sb",
            "\"Failed to map mft record.\""
          ],
          "line": 1595
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "mrec"
          ],
          "line": 1594
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NTFS_I",
          "args": [
            "mftbmp_vi"
          ],
          "line": 1591
        },
        "resolved": true,
        "details": {
          "function_name": "NTFS_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/inode.h",
          "lines": "240-243",
          "snippet": "static inline ntfs_inode *NTFS_I(struct inode *inode)\n{\n\treturn (ntfs_inode *)list_entry(inode, big_ntfs_inode, vfs_inode);\n}",
          "includes": [
            "#include \"debug.h\"",
            "#include \"runlist.h\"",
            "#include \"types.h\"",
            "#include \"volume.h\"",
            "#include \"layout.h\"",
            "#include <linux/seq_file.h>",
            "#include <linux/mutex.h>",
            "#include <linux/mm.h>",
            "#include <linux/list.h>",
            "#include <linux/fs.h>",
            "#include <linux/atomic.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"debug.h\"\n#include \"runlist.h\"\n#include \"types.h\"\n#include \"volume.h\"\n#include \"layout.h\"\n#include <linux/seq_file.h>\n#include <linux/mutex.h>\n#include <linux/mm.h>\n#include <linux/list.h>\n#include <linux/fs.h>\n#include <linux/atomic.h>\n\nstatic inline ntfs_inode *NTFS_I(struct inode *inode)\n{\n\treturn (ntfs_inode *)list_entry(inode, big_ntfs_inode, vfs_inode);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ntfs.h\"\n#include \"mft.h\"\n#include \"malloc.h\"\n#include \"lcnalloc.h\"\n#include \"dir.h\"\n#include \"debug.h\"\n#include \"bitmap.h\"\n#include \"aops.h\"\n#include \"attrib.h\"\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n\nstatic int ntfs_mft_bitmap_extend_initialized_nolock(ntfs_volume *vol)\n{\n\ts64 old_data_size, old_initialized_size;\n\tunsigned long flags;\n\tstruct inode *mftbmp_vi;\n\tntfs_inode *mft_ni, *mftbmp_ni;\n\tntfs_attr_search_ctx *ctx;\n\tMFT_RECORD *mrec;\n\tATTR_RECORD *a;\n\tint ret;\n\n\tntfs_debug(\"Extending mft bitmap initiailized (and data) size.\");\n\tmft_ni = NTFS_I(vol->mft_ino);\n\tmftbmp_vi = vol->mftbmp_ino;\n\tmftbmp_ni = NTFS_I(mftbmp_vi);\n\t/* Get the attribute record. */\n\tmrec = map_mft_record(mft_ni);\n\tif (IS_ERR(mrec)) {\n\t\tntfs_error(vol->sb, \"Failed to map mft record.\");\n\t\treturn PTR_ERR(mrec);\n\t}\n\tctx = ntfs_attr_get_search_ctx(mft_ni, mrec);\n\tif (unlikely(!ctx)) {\n\t\tntfs_error(vol->sb, \"Failed to get search context.\");\n\t\tret = -ENOMEM;\n\t\tgoto unm_err_out;\n\t}\n\tret = ntfs_attr_lookup(mftbmp_ni->type, mftbmp_ni->name,\n\t\t\tmftbmp_ni->name_len, CASE_SENSITIVE, 0, NULL, 0, ctx);\n\tif (unlikely(ret)) {\n\t\tntfs_error(vol->sb, \"Failed to find first attribute extent of \"\n\t\t\t\t\"mft bitmap attribute.\");\n\t\tif (ret == -ENOENT)\n\t\t\tret = -EIO;\n\t\tgoto put_err_out;\n\t}\n\ta = ctx->attr;\n\twrite_lock_irqsave(&mftbmp_ni->size_lock, flags);\n\told_data_size = i_size_read(mftbmp_vi);\n\told_initialized_size = mftbmp_ni->initialized_size;\n\t/*\n\t * We can simply update the initialized_size before filling the space\n\t * with zeroes because the caller is holding the mft bitmap lock for\n\t * writing which ensures that no one else is trying to access the data.\n\t */\n\tmftbmp_ni->initialized_size += 8;\n\ta->data.non_resident.initialized_size =\n\t\t\tcpu_to_sle64(mftbmp_ni->initialized_size);\n\tif (mftbmp_ni->initialized_size > old_data_size) {\n\t\ti_size_write(mftbmp_vi, mftbmp_ni->initialized_size);\n\t\ta->data.non_resident.data_size =\n\t\t\t\tcpu_to_sle64(mftbmp_ni->initialized_size);\n\t}\n\twrite_unlock_irqrestore(&mftbmp_ni->size_lock, flags);\n\t/* Ensure the changes make it to disk. */\n\tflush_dcache_mft_record_page(ctx->ntfs_ino);\n\tmark_mft_record_dirty(ctx->ntfs_ino);\n\tntfs_attr_put_search_ctx(ctx);\n\tunmap_mft_record(mft_ni);\n\t/* Initialize the mft bitmap attribute value with zeroes. */\n\tret = ntfs_attr_set(mftbmp_ni, old_initialized_size, 8, 0);\n\tif (likely(!ret)) {\n\t\tntfs_debug(\"Done.  (Wrote eight initialized bytes to mft \"\n\t\t\t\t\"bitmap.\");\n\t\treturn 0;\n\t}\n\tntfs_error(vol->sb, \"Failed to write to mft bitmap.\");\n\t/* Try to recover from the error. */\n\tmrec = map_mft_record(mft_ni);\n\tif (IS_ERR(mrec)) {\n\t\tntfs_error(vol->sb, \"Failed to map mft record.%s\", es);\n\t\tNVolSetErrors(vol);\n\t\treturn ret;\n\t}\n\tctx = ntfs_attr_get_search_ctx(mft_ni, mrec);\n\tif (unlikely(!ctx)) {\n\t\tntfs_error(vol->sb, \"Failed to get search context.%s\", es);\n\t\tNVolSetErrors(vol);\n\t\tgoto unm_err_out;\n\t}\n\tif (ntfs_attr_lookup(mftbmp_ni->type, mftbmp_ni->name,\n\t\t\tmftbmp_ni->name_len, CASE_SENSITIVE, 0, NULL, 0, ctx)) {\n\t\tntfs_error(vol->sb, \"Failed to find first attribute extent of \"\n\t\t\t\t\"mft bitmap attribute.%s\", es);\n\t\tNVolSetErrors(vol);\nput_err_out:\n\t\tntfs_attr_put_search_ctx(ctx);\nunm_err_out:\n\t\tunmap_mft_record(mft_ni);\n\t\tgoto err_out;\n\t}\n\ta = ctx->attr;\n\twrite_lock_irqsave(&mftbmp_ni->size_lock, flags);\n\tmftbmp_ni->initialized_size = old_initialized_size;\n\ta->data.non_resident.initialized_size =\n\t\t\tcpu_to_sle64(old_initialized_size);\n\tif (i_size_read(mftbmp_vi) != old_data_size) {\n\t\ti_size_write(mftbmp_vi, old_data_size);\n\t\ta->data.non_resident.data_size = cpu_to_sle64(old_data_size);\n\t}\n\twrite_unlock_irqrestore(&mftbmp_ni->size_lock, flags);\n\tflush_dcache_mft_record_page(ctx->ntfs_ino);\n\tmark_mft_record_dirty(ctx->ntfs_ino);\n\tntfs_attr_put_search_ctx(ctx);\n\tunmap_mft_record(mft_ni);\n#ifdef DEBUG\n\tread_lock_irqsave(&mftbmp_ni->size_lock, flags);\n\tntfs_debug(\"Restored status of mftbmp: allocated_size 0x%llx, \"\n\t\t\t\"data_size 0x%llx, initialized_size 0x%llx.\",\n\t\t\t(long long)mftbmp_ni->allocated_size,\n\t\t\t(long long)i_size_read(mftbmp_vi),\n\t\t\t(long long)mftbmp_ni->initialized_size);\n\tread_unlock_irqrestore(&mftbmp_ni->size_lock, flags);\n#endif /* DEBUG */\nerr_out:\n\treturn ret;\n}"
  },
  {
    "function_name": "ntfs_mft_bitmap_extend_allocation_nolock",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/mft.c",
    "lines": "1278-1561",
    "snippet": "static int ntfs_mft_bitmap_extend_allocation_nolock(ntfs_volume *vol)\n{\n\tLCN lcn;\n\ts64 ll;\n\tunsigned long flags;\n\tstruct page *page;\n\tntfs_inode *mft_ni, *mftbmp_ni;\n\trunlist_element *rl, *rl2 = NULL;\n\tntfs_attr_search_ctx *ctx = NULL;\n\tMFT_RECORD *mrec;\n\tATTR_RECORD *a = NULL;\n\tint ret, mp_size;\n\tu32 old_alen = 0;\n\tu8 *b, tb;\n\tstruct {\n\t\tu8 added_cluster:1;\n\t\tu8 added_run:1;\n\t\tu8 mp_rebuilt:1;\n\t} status = { 0, 0, 0 };\n\n\tntfs_debug(\"Extending mft bitmap allocation.\");\n\tmft_ni = NTFS_I(vol->mft_ino);\n\tmftbmp_ni = NTFS_I(vol->mftbmp_ino);\n\t/*\n\t * Determine the last lcn of the mft bitmap.  The allocated size of the\n\t * mft bitmap cannot be zero so we are ok to do this.\n\t */\n\tdown_write(&mftbmp_ni->runlist.lock);\n\tread_lock_irqsave(&mftbmp_ni->size_lock, flags);\n\tll = mftbmp_ni->allocated_size;\n\tread_unlock_irqrestore(&mftbmp_ni->size_lock, flags);\n\trl = ntfs_attr_find_vcn_nolock(mftbmp_ni,\n\t\t\t(ll - 1) >> vol->cluster_size_bits, NULL);\n\tif (unlikely(IS_ERR(rl) || !rl->length || rl->lcn < 0)) {\n\t\tup_write(&mftbmp_ni->runlist.lock);\n\t\tntfs_error(vol->sb, \"Failed to determine last allocated \"\n\t\t\t\t\"cluster of mft bitmap attribute.\");\n\t\tif (!IS_ERR(rl))\n\t\t\tret = -EIO;\n\t\telse\n\t\t\tret = PTR_ERR(rl);\n\t\treturn ret;\n\t}\n\tlcn = rl->lcn + rl->length;\n\tntfs_debug(\"Last lcn of mft bitmap attribute is 0x%llx.\",\n\t\t\t(long long)lcn);\n\t/*\n\t * Attempt to get the cluster following the last allocated cluster by\n\t * hand as it may be in the MFT zone so the allocator would not give it\n\t * to us.\n\t */\n\tll = lcn >> 3;\n\tpage = ntfs_map_page(vol->lcnbmp_ino->i_mapping,\n\t\t\tll >> PAGE_CACHE_SHIFT);\n\tif (IS_ERR(page)) {\n\t\tup_write(&mftbmp_ni->runlist.lock);\n\t\tntfs_error(vol->sb, \"Failed to read from lcn bitmap.\");\n\t\treturn PTR_ERR(page);\n\t}\n\tb = (u8*)page_address(page) + (ll & ~PAGE_CACHE_MASK);\n\ttb = 1 << (lcn & 7ull);\n\tdown_write(&vol->lcnbmp_lock);\n\tif (*b != 0xff && !(*b & tb)) {\n\t\t/* Next cluster is free, allocate it. */\n\t\t*b |= tb;\n\t\tflush_dcache_page(page);\n\t\tset_page_dirty(page);\n\t\tup_write(&vol->lcnbmp_lock);\n\t\tntfs_unmap_page(page);\n\t\t/* Update the mft bitmap runlist. */\n\t\trl->length++;\n\t\trl[1].vcn++;\n\t\tstatus.added_cluster = 1;\n\t\tntfs_debug(\"Appending one cluster to mft bitmap.\");\n\t} else {\n\t\tup_write(&vol->lcnbmp_lock);\n\t\tntfs_unmap_page(page);\n\t\t/* Allocate a cluster from the DATA_ZONE. */\n\t\trl2 = ntfs_cluster_alloc(vol, rl[1].vcn, 1, lcn, DATA_ZONE,\n\t\t\t\ttrue);\n\t\tif (IS_ERR(rl2)) {\n\t\t\tup_write(&mftbmp_ni->runlist.lock);\n\t\t\tntfs_error(vol->sb, \"Failed to allocate a cluster for \"\n\t\t\t\t\t\"the mft bitmap.\");\n\t\t\treturn PTR_ERR(rl2);\n\t\t}\n\t\trl = ntfs_runlists_merge(mftbmp_ni->runlist.rl, rl2);\n\t\tif (IS_ERR(rl)) {\n\t\t\tup_write(&mftbmp_ni->runlist.lock);\n\t\t\tntfs_error(vol->sb, \"Failed to merge runlists for mft \"\n\t\t\t\t\t\"bitmap.\");\n\t\t\tif (ntfs_cluster_free_from_rl(vol, rl2)) {\n\t\t\t\tntfs_error(vol->sb, \"Failed to deallocate \"\n\t\t\t\t\t\t\"allocated cluster.%s\", es);\n\t\t\t\tNVolSetErrors(vol);\n\t\t\t}\n\t\t\tntfs_free(rl2);\n\t\t\treturn PTR_ERR(rl);\n\t\t}\n\t\tmftbmp_ni->runlist.rl = rl;\n\t\tstatus.added_run = 1;\n\t\tntfs_debug(\"Adding one run to mft bitmap.\");\n\t\t/* Find the last run in the new runlist. */\n\t\tfor (; rl[1].length; rl++)\n\t\t\t;\n\t}\n\t/*\n\t * Update the attribute record as well.  Note: @rl is the last\n\t * (non-terminator) runlist element of mft bitmap.\n\t */\n\tmrec = map_mft_record(mft_ni);\n\tif (IS_ERR(mrec)) {\n\t\tntfs_error(vol->sb, \"Failed to map mft record.\");\n\t\tret = PTR_ERR(mrec);\n\t\tgoto undo_alloc;\n\t}\n\tctx = ntfs_attr_get_search_ctx(mft_ni, mrec);\n\tif (unlikely(!ctx)) {\n\t\tntfs_error(vol->sb, \"Failed to get search context.\");\n\t\tret = -ENOMEM;\n\t\tgoto undo_alloc;\n\t}\n\tret = ntfs_attr_lookup(mftbmp_ni->type, mftbmp_ni->name,\n\t\t\tmftbmp_ni->name_len, CASE_SENSITIVE, rl[1].vcn, NULL,\n\t\t\t0, ctx);\n\tif (unlikely(ret)) {\n\t\tntfs_error(vol->sb, \"Failed to find last attribute extent of \"\n\t\t\t\t\"mft bitmap attribute.\");\n\t\tif (ret == -ENOENT)\n\t\t\tret = -EIO;\n\t\tgoto undo_alloc;\n\t}\n\ta = ctx->attr;\n\tll = sle64_to_cpu(a->data.non_resident.lowest_vcn);\n\t/* Search back for the previous last allocated cluster of mft bitmap. */\n\tfor (rl2 = rl; rl2 > mftbmp_ni->runlist.rl; rl2--) {\n\t\tif (ll >= rl2->vcn)\n\t\t\tbreak;\n\t}\n\tBUG_ON(ll < rl2->vcn);\n\tBUG_ON(ll >= rl2->vcn + rl2->length);\n\t/* Get the size for the new mapping pairs array for this extent. */\n\tmp_size = ntfs_get_size_for_mapping_pairs(vol, rl2, ll, -1);\n\tif (unlikely(mp_size <= 0)) {\n\t\tntfs_error(vol->sb, \"Get size for mapping pairs failed for \"\n\t\t\t\t\"mft bitmap attribute extent.\");\n\t\tret = mp_size;\n\t\tif (!ret)\n\t\t\tret = -EIO;\n\t\tgoto undo_alloc;\n\t}\n\t/* Expand the attribute record if necessary. */\n\told_alen = le32_to_cpu(a->length);\n\tret = ntfs_attr_record_resize(ctx->mrec, a, mp_size +\n\t\t\tle16_to_cpu(a->data.non_resident.mapping_pairs_offset));\n\tif (unlikely(ret)) {\n\t\tif (ret != -ENOSPC) {\n\t\t\tntfs_error(vol->sb, \"Failed to resize attribute \"\n\t\t\t\t\t\"record for mft bitmap attribute.\");\n\t\t\tgoto undo_alloc;\n\t\t}\n\t\t// TODO: Deal with this by moving this extent to a new mft\n\t\t// record or by starting a new extent in a new mft record or by\n\t\t// moving other attributes out of this mft record.\n\t\t// Note: It will need to be a special mft record and if none of\n\t\t// those are available it gets rather complicated...\n\t\tntfs_error(vol->sb, \"Not enough space in this mft record to \"\n\t\t\t\t\"accommodate extended mft bitmap attribute \"\n\t\t\t\t\"extent.  Cannot handle this yet.\");\n\t\tret = -EOPNOTSUPP;\n\t\tgoto undo_alloc;\n\t}\n\tstatus.mp_rebuilt = 1;\n\t/* Generate the mapping pairs array directly into the attr record. */\n\tret = ntfs_mapping_pairs_build(vol, (u8*)a +\n\t\t\tle16_to_cpu(a->data.non_resident.mapping_pairs_offset),\n\t\t\tmp_size, rl2, ll, -1, NULL);\n\tif (unlikely(ret)) {\n\t\tntfs_error(vol->sb, \"Failed to build mapping pairs array for \"\n\t\t\t\t\"mft bitmap attribute.\");\n\t\tgoto undo_alloc;\n\t}\n\t/* Update the highest_vcn. */\n\ta->data.non_resident.highest_vcn = cpu_to_sle64(rl[1].vcn - 1);\n\t/*\n\t * We now have extended the mft bitmap allocated_size by one cluster.\n\t * Reflect this in the ntfs_inode structure and the attribute record.\n\t */\n\tif (a->data.non_resident.lowest_vcn) {\n\t\t/*\n\t\t * We are not in the first attribute extent, switch to it, but\n\t\t * first ensure the changes will make it to disk later.\n\t\t */\n\t\tflush_dcache_mft_record_page(ctx->ntfs_ino);\n\t\tmark_mft_record_dirty(ctx->ntfs_ino);\n\t\tntfs_attr_reinit_search_ctx(ctx);\n\t\tret = ntfs_attr_lookup(mftbmp_ni->type, mftbmp_ni->name,\n\t\t\t\tmftbmp_ni->name_len, CASE_SENSITIVE, 0, NULL,\n\t\t\t\t0, ctx);\n\t\tif (unlikely(ret)) {\n\t\t\tntfs_error(vol->sb, \"Failed to find first attribute \"\n\t\t\t\t\t\"extent of mft bitmap attribute.\");\n\t\t\tgoto restore_undo_alloc;\n\t\t}\n\t\ta = ctx->attr;\n\t}\n\twrite_lock_irqsave(&mftbmp_ni->size_lock, flags);\n\tmftbmp_ni->allocated_size += vol->cluster_size;\n\ta->data.non_resident.allocated_size =\n\t\t\tcpu_to_sle64(mftbmp_ni->allocated_size);\n\twrite_unlock_irqrestore(&mftbmp_ni->size_lock, flags);\n\t/* Ensure the changes make it to disk. */\n\tflush_dcache_mft_record_page(ctx->ntfs_ino);\n\tmark_mft_record_dirty(ctx->ntfs_ino);\n\tntfs_attr_put_search_ctx(ctx);\n\tunmap_mft_record(mft_ni);\n\tup_write(&mftbmp_ni->runlist.lock);\n\tntfs_debug(\"Done.\");\n\treturn 0;\nrestore_undo_alloc:\n\tntfs_attr_reinit_search_ctx(ctx);\n\tif (ntfs_attr_lookup(mftbmp_ni->type, mftbmp_ni->name,\n\t\t\tmftbmp_ni->name_len, CASE_SENSITIVE, rl[1].vcn, NULL,\n\t\t\t0, ctx)) {\n\t\tntfs_error(vol->sb, \"Failed to find last attribute extent of \"\n\t\t\t\t\"mft bitmap attribute.%s\", es);\n\t\twrite_lock_irqsave(&mftbmp_ni->size_lock, flags);\n\t\tmftbmp_ni->allocated_size += vol->cluster_size;\n\t\twrite_unlock_irqrestore(&mftbmp_ni->size_lock, flags);\n\t\tntfs_attr_put_search_ctx(ctx);\n\t\tunmap_mft_record(mft_ni);\n\t\tup_write(&mftbmp_ni->runlist.lock);\n\t\t/*\n\t\t * The only thing that is now wrong is ->allocated_size of the\n\t\t * base attribute extent which chkdsk should be able to fix.\n\t\t */\n\t\tNVolSetErrors(vol);\n\t\treturn ret;\n\t}\n\ta = ctx->attr;\n\ta->data.non_resident.highest_vcn = cpu_to_sle64(rl[1].vcn - 2);\nundo_alloc:\n\tif (status.added_cluster) {\n\t\t/* Truncate the last run in the runlist by one cluster. */\n\t\trl->length--;\n\t\trl[1].vcn--;\n\t} else if (status.added_run) {\n\t\tlcn = rl->lcn;\n\t\t/* Remove the last run from the runlist. */\n\t\trl->lcn = rl[1].lcn;\n\t\trl->length = 0;\n\t}\n\t/* Deallocate the cluster. */\n\tdown_write(&vol->lcnbmp_lock);\n\tif (ntfs_bitmap_clear_bit(vol->lcnbmp_ino, lcn)) {\n\t\tntfs_error(vol->sb, \"Failed to free allocated cluster.%s\", es);\n\t\tNVolSetErrors(vol);\n\t}\n\tup_write(&vol->lcnbmp_lock);\n\tif (status.mp_rebuilt) {\n\t\tif (ntfs_mapping_pairs_build(vol, (u8*)a + le16_to_cpu(\n\t\t\t\ta->data.non_resident.mapping_pairs_offset),\n\t\t\t\told_alen - le16_to_cpu(\n\t\t\t\ta->data.non_resident.mapping_pairs_offset),\n\t\t\t\trl2, ll, -1, NULL)) {\n\t\t\tntfs_error(vol->sb, \"Failed to restore mapping pairs \"\n\t\t\t\t\t\"array.%s\", es);\n\t\t\tNVolSetErrors(vol);\n\t\t}\n\t\tif (ntfs_attr_record_resize(ctx->mrec, a, old_alen)) {\n\t\t\tntfs_error(vol->sb, \"Failed to restore attribute \"\n\t\t\t\t\t\"record.%s\", es);\n\t\t\tNVolSetErrors(vol);\n\t\t}\n\t\tflush_dcache_mft_record_page(ctx->ntfs_ino);\n\t\tmark_mft_record_dirty(ctx->ntfs_ino);\n\t}\n\tif (ctx)\n\t\tntfs_attr_put_search_ctx(ctx);\n\tif (!IS_ERR(mrec))\n\t\tunmap_mft_record(mft_ni);\n\tup_write(&mftbmp_ni->runlist.lock);\n\treturn ret;\n}",
    "includes": [
      "#include \"ntfs.h\"",
      "#include \"mft.h\"",
      "#include \"malloc.h\"",
      "#include \"lcnalloc.h\"",
      "#include \"dir.h\"",
      "#include \"debug.h\"",
      "#include \"bitmap.h\"",
      "#include \"aops.h\"",
      "#include \"attrib.h\"",
      "#include <linux/swap.h>",
      "#include <linux/slab.h>",
      "#include <linux/buffer_head.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "up_write",
          "args": [
            "&mftbmp_ni->runlist.lock"
          ],
          "line": 1559
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unmap_mft_record",
          "args": [
            "mft_ni"
          ],
          "line": 1558
        },
        "resolved": true,
        "details": {
          "function_name": "unmap_mft_record",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/mft.c",
          "lines": "213-231",
          "snippet": "void unmap_mft_record(ntfs_inode *ni)\n{\n\tstruct page *page = ni->page;\n\n\tBUG_ON(!page);\n\n\tntfs_debug(\"Entering for mft_no 0x%lx.\", ni->mft_no);\n\n\tunmap_mft_record_page(ni);\n\tmutex_unlock(&ni->mrec_lock);\n\tatomic_dec(&ni->count);\n\t/*\n\t * If pure ntfs_inode, i.e. no vfs inode attached, we leave it to\n\t * ntfs_clear_extent_inode() in the extent inode case, and to the\n\t * caller in the non-extent, yet pure ntfs inode case, to do the actual\n\t * tear down of all structures and freeing of all allocated memory.\n\t */\n\treturn;\n}",
          "includes": [
            "#include \"ntfs.h\"",
            "#include \"mft.h\"",
            "#include \"malloc.h\"",
            "#include \"lcnalloc.h\"",
            "#include \"dir.h\"",
            "#include \"debug.h\"",
            "#include \"bitmap.h\"",
            "#include \"aops.h\"",
            "#include \"attrib.h\"",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ntfs.h\"\n#include \"mft.h\"\n#include \"malloc.h\"\n#include \"lcnalloc.h\"\n#include \"dir.h\"\n#include \"debug.h\"\n#include \"bitmap.h\"\n#include \"aops.h\"\n#include \"attrib.h\"\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n\nvoid unmap_mft_record(ntfs_inode *ni)\n{\n\tstruct page *page = ni->page;\n\n\tBUG_ON(!page);\n\n\tntfs_debug(\"Entering for mft_no 0x%lx.\", ni->mft_no);\n\n\tunmap_mft_record_page(ni);\n\tmutex_unlock(&ni->mrec_lock);\n\tatomic_dec(&ni->count);\n\t/*\n\t * If pure ntfs_inode, i.e. no vfs inode attached, we leave it to\n\t * ntfs_clear_extent_inode() in the extent inode case, and to the\n\t * caller in the non-extent, yet pure ntfs inode case, to do the actual\n\t * tear down of all structures and freeing of all allocated memory.\n\t */\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "mrec"
          ],
          "line": 1557
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntfs_attr_put_search_ctx",
          "args": [
            "ctx"
          ],
          "line": 1556
        },
        "resolved": true,
        "details": {
          "function_name": "ntfs_attr_put_search_ctx",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/attrib.c",
          "lines": "1286-1292",
          "snippet": "void ntfs_attr_put_search_ctx(ntfs_attr_search_ctx *ctx)\n{\n\tif (ctx->base_ntfs_ino && ctx->ntfs_ino != ctx->base_ntfs_ino)\n\t\tunmap_extent_mft_record(ctx->ntfs_ino);\n\tkmem_cache_free(ntfs_attr_ctx_cache, ctx);\n\treturn;\n}",
          "includes": [
            "#include \"types.h\"",
            "#include \"ntfs.h\"",
            "#include \"mft.h\"",
            "#include \"malloc.h\"",
            "#include \"lcnalloc.h\"",
            "#include \"layout.h\"",
            "#include \"debug.h\"",
            "#include \"attrib.h\"",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include \"ntfs.h\"\n#include \"mft.h\"\n#include \"malloc.h\"\n#include \"lcnalloc.h\"\n#include \"layout.h\"\n#include \"debug.h\"\n#include \"attrib.h\"\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/buffer_head.h>\n\nvoid ntfs_attr_put_search_ctx(ntfs_attr_search_ctx *ctx)\n{\n\tif (ctx->base_ntfs_ino && ctx->ntfs_ino != ctx->base_ntfs_ino)\n\t\tunmap_extent_mft_record(ctx->ntfs_ino);\n\tkmem_cache_free(ntfs_attr_ctx_cache, ctx);\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mark_mft_record_dirty",
          "args": [
            "ctx->ntfs_ino"
          ],
          "line": 1553
        },
        "resolved": true,
        "details": {
          "function_name": "__mark_mft_record_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/mft.c",
          "lines": "395-410",
          "snippet": "void __mark_mft_record_dirty(ntfs_inode *ni)\n{\n\tntfs_inode *base_ni;\n\n\tntfs_debug(\"Entering for inode 0x%lx.\", ni->mft_no);\n\tBUG_ON(NInoAttr(ni));\n\tmark_ntfs_record_dirty(ni->page, ni->page_ofs);\n\t/* Determine the base vfs inode and mark it dirty, too. */\n\tmutex_lock(&ni->extent_lock);\n\tif (likely(ni->nr_extents >= 0))\n\t\tbase_ni = ni;\n\telse\n\t\tbase_ni = ni->ext.base_ntfs_ino;\n\tmutex_unlock(&ni->extent_lock);\n\t__mark_inode_dirty(VFS_I(base_ni), I_DIRTY_SYNC | I_DIRTY_DATASYNC);\n}",
          "includes": [
            "#include \"ntfs.h\"",
            "#include \"mft.h\"",
            "#include \"malloc.h\"",
            "#include \"lcnalloc.h\"",
            "#include \"dir.h\"",
            "#include \"debug.h\"",
            "#include \"bitmap.h\"",
            "#include \"aops.h\"",
            "#include \"attrib.h\"",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ntfs.h\"\n#include \"mft.h\"\n#include \"malloc.h\"\n#include \"lcnalloc.h\"\n#include \"dir.h\"\n#include \"debug.h\"\n#include \"bitmap.h\"\n#include \"aops.h\"\n#include \"attrib.h\"\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n\nvoid __mark_mft_record_dirty(ntfs_inode *ni)\n{\n\tntfs_inode *base_ni;\n\n\tntfs_debug(\"Entering for inode 0x%lx.\", ni->mft_no);\n\tBUG_ON(NInoAttr(ni));\n\tmark_ntfs_record_dirty(ni->page, ni->page_ofs);\n\t/* Determine the base vfs inode and mark it dirty, too. */\n\tmutex_lock(&ni->extent_lock);\n\tif (likely(ni->nr_extents >= 0))\n\t\tbase_ni = ni;\n\telse\n\t\tbase_ni = ni->ext.base_ntfs_ino;\n\tmutex_unlock(&ni->extent_lock);\n\t__mark_inode_dirty(VFS_I(base_ni), I_DIRTY_SYNC | I_DIRTY_DATASYNC);\n}"
        }
      },
      {
        "call_info": {
          "callee": "flush_dcache_mft_record_page",
          "args": [
            "ctx->ntfs_ino"
          ],
          "line": 1552
        },
        "resolved": true,
        "details": {
          "function_name": "flush_dcache_mft_record_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/mft.h",
          "lines": "55-58",
          "snippet": "static inline void flush_dcache_mft_record_page(ntfs_inode *ni)\n{\n\tflush_dcache_page(ni->page);\n}",
          "includes": [
            "#include \"inode.h\"",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"inode.h\"\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/fs.h>\n\nstatic inline void flush_dcache_mft_record_page(ntfs_inode *ni)\n{\n\tflush_dcache_page(ni->page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "NVolSetErrors",
          "args": [
            "vol"
          ],
          "line": 1550
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntfs_error",
          "args": [
            "vol->sb",
            "\"Failed to restore attribute \"\n\t\t\t\t\t\"record.%s\"",
            "es"
          ],
          "line": 1548
        },
        "resolved": true,
        "details": {
          "function_name": "__ntfs_error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/debug.c",
          "lines": "86-108",
          "snippet": "void __ntfs_error(const char *function, const struct super_block *sb,\n\t\tconst char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\tint flen = 0;\n\n#ifndef DEBUG\n\tif (!printk_ratelimit())\n\t\treturn;\n#endif\n\tif (function)\n\t\tflen = strlen(function);\n\tva_start(args, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\tif (sb)\n\t\tpr_err(\"(device %s): %s(): %pV\\n\",\n\t\t       sb->s_id, flen ? function : \"\", &vaf);\n\telse\n\t\tpr_err(\"%s(): %pV\\n\", flen ? function : \"\", &vaf);\n\tva_end(args);\n}",
          "includes": [
            "#include \"debug.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"debug.h\"\n\nvoid __ntfs_error(const char *function, const struct super_block *sb,\n\t\tconst char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\tint flen = 0;\n\n#ifndef DEBUG\n\tif (!printk_ratelimit())\n\t\treturn;\n#endif\n\tif (function)\n\t\tflen = strlen(function);\n\tva_start(args, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\tif (sb)\n\t\tpr_err(\"(device %s): %s(): %pV\\n\",\n\t\t       sb->s_id, flen ? function : \"\", &vaf);\n\telse\n\t\tpr_err(\"%s(): %pV\\n\", flen ? function : \"\", &vaf);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ntfs_attr_record_resize",
          "args": [
            "ctx->mrec",
            "a",
            "old_alen"
          ],
          "line": 1547
        },
        "resolved": true,
        "details": {
          "function_name": "ntfs_attr_record_resize",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/attrib.c",
          "lines": "1435-1459",
          "snippet": "int ntfs_attr_record_resize(MFT_RECORD *m, ATTR_RECORD *a, u32 new_size)\n{\n\tntfs_debug(\"Entering for new_size %u.\", new_size);\n\t/* Align to 8 bytes if it is not already done. */\n\tif (new_size & 7)\n\t\tnew_size = (new_size + 7) & ~7;\n\t/* If the actual attribute length has changed, move things around. */\n\tif (new_size != le32_to_cpu(a->length)) {\n\t\tu32 new_muse = le32_to_cpu(m->bytes_in_use) -\n\t\t\t\tle32_to_cpu(a->length) + new_size;\n\t\t/* Not enough space in this mft record. */\n\t\tif (new_muse > le32_to_cpu(m->bytes_allocated))\n\t\t\treturn -ENOSPC;\n\t\t/* Move attributes following @a to their new location. */\n\t\tmemmove((u8*)a + new_size, (u8*)a + le32_to_cpu(a->length),\n\t\t\t\tle32_to_cpu(m->bytes_in_use) - ((u8*)a -\n\t\t\t\t(u8*)m) - le32_to_cpu(a->length));\n\t\t/* Adjust @m to reflect the change in used space. */\n\t\tm->bytes_in_use = cpu_to_le32(new_muse);\n\t\t/* Adjust @a to reflect the new size. */\n\t\tif (new_size >= offsetof(ATTR_REC, length) + sizeof(a->length))\n\t\t\ta->length = cpu_to_le32(new_size);\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"types.h\"",
            "#include \"ntfs.h\"",
            "#include \"mft.h\"",
            "#include \"malloc.h\"",
            "#include \"lcnalloc.h\"",
            "#include \"layout.h\"",
            "#include \"debug.h\"",
            "#include \"attrib.h\"",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include \"ntfs.h\"\n#include \"mft.h\"\n#include \"malloc.h\"\n#include \"lcnalloc.h\"\n#include \"layout.h\"\n#include \"debug.h\"\n#include \"attrib.h\"\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/buffer_head.h>\n\nint ntfs_attr_record_resize(MFT_RECORD *m, ATTR_RECORD *a, u32 new_size)\n{\n\tntfs_debug(\"Entering for new_size %u.\", new_size);\n\t/* Align to 8 bytes if it is not already done. */\n\tif (new_size & 7)\n\t\tnew_size = (new_size + 7) & ~7;\n\t/* If the actual attribute length has changed, move things around. */\n\tif (new_size != le32_to_cpu(a->length)) {\n\t\tu32 new_muse = le32_to_cpu(m->bytes_in_use) -\n\t\t\t\tle32_to_cpu(a->length) + new_size;\n\t\t/* Not enough space in this mft record. */\n\t\tif (new_muse > le32_to_cpu(m->bytes_allocated))\n\t\t\treturn -ENOSPC;\n\t\t/* Move attributes following @a to their new location. */\n\t\tmemmove((u8*)a + new_size, (u8*)a + le32_to_cpu(a->length),\n\t\t\t\tle32_to_cpu(m->bytes_in_use) - ((u8*)a -\n\t\t\t\t(u8*)m) - le32_to_cpu(a->length));\n\t\t/* Adjust @m to reflect the change in used space. */\n\t\tm->bytes_in_use = cpu_to_le32(new_muse);\n\t\t/* Adjust @a to reflect the new size. */\n\t\tif (new_size >= offsetof(ATTR_REC, length) + sizeof(a->length))\n\t\t\ta->length = cpu_to_le32(new_size);\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "NVolSetErrors",
          "args": [
            "vol"
          ],
          "line": 1545
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntfs_mapping_pairs_build",
          "args": [
            "vol",
            "(u8*)a + le16_to_cpu(\n\t\t\t\ta->data.non_resident.mapping_pairs_offset)",
            "old_alen - le16_to_cpu(\n\t\t\t\ta->data.non_resident.mapping_pairs_offset)",
            "rl2",
            "ll",
            "-1",
            "NULL"
          ],
          "line": 1538
        },
        "resolved": true,
        "details": {
          "function_name": "ntfs_mapping_pairs_build",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/runlist.c",
          "lines": "1323-1473",
          "snippet": "int ntfs_mapping_pairs_build(const ntfs_volume *vol, s8 *dst,\n\t\tconst int dst_len, const runlist_element *rl,\n\t\tconst VCN first_vcn, const VCN last_vcn, VCN *const stop_vcn)\n{\n\tLCN prev_lcn;\n\ts8 *dst_max, *dst_next;\n\tint err = -ENOSPC;\n\tbool the_end = false;\n\ts8 len_len, lcn_len;\n\n\tBUG_ON(first_vcn < 0);\n\tBUG_ON(last_vcn < -1);\n\tBUG_ON(last_vcn >= 0 && first_vcn > last_vcn);\n\tBUG_ON(dst_len < 1);\n\tif (!rl) {\n\t\tBUG_ON(first_vcn);\n\t\tBUG_ON(last_vcn > 0);\n\t\tif (stop_vcn)\n\t\t\t*stop_vcn = 0;\n\t\t/* Terminator byte. */\n\t\t*dst = 0;\n\t\treturn 0;\n\t}\n\t/* Skip to runlist element containing @first_vcn. */\n\twhile (rl->length && first_vcn >= rl[1].vcn)\n\t\trl++;\n\tif (unlikely((!rl->length && first_vcn > rl->vcn) ||\n\t\t\tfirst_vcn < rl->vcn))\n\t\treturn -EINVAL;\n\t/*\n\t * @dst_max is used for bounds checking in\n\t * ntfs_write_significant_bytes().\n\t */\n\tdst_max = dst + dst_len - 1;\n\tprev_lcn = 0;\n\t/* Do the first partial run if present. */\n\tif (first_vcn > rl->vcn) {\n\t\ts64 delta, length = rl->length;\n\n\t\t/* We know rl->length != 0 already. */\n\t\tif (unlikely(length < 0 || rl->lcn < LCN_HOLE))\n\t\t\tgoto err_out;\n\t\t/*\n\t\t * If @stop_vcn is given and finishes inside this run, cap the\n\t\t * run length.\n\t\t */\n\t\tif (unlikely(last_vcn >= 0 && rl[1].vcn > last_vcn)) {\n\t\t\ts64 s1 = last_vcn + 1;\n\t\t\tif (unlikely(rl[1].vcn > s1))\n\t\t\t\tlength = s1 - rl->vcn;\n\t\t\tthe_end = true;\n\t\t}\n\t\tdelta = first_vcn - rl->vcn;\n\t\t/* Write length. */\n\t\tlen_len = ntfs_write_significant_bytes(dst + 1, dst_max,\n\t\t\t\tlength - delta);\n\t\tif (unlikely(len_len < 0))\n\t\t\tgoto size_err;\n\t\t/*\n\t\t * If the logical cluster number (lcn) denotes a hole and we\n\t\t * are on NTFS 3.0+, we don't store it at all, i.e. we need\n\t\t * zero space.  On earlier NTFS versions we just write the lcn\n\t\t * change.  FIXME: Do we need to write the lcn change or just\n\t\t * the lcn in that case?  Not sure as I have never seen this\n\t\t * case on NT4. - We assume that we just need to write the lcn\n\t\t * change until someone tells us otherwise... (AIA)\n\t\t */\n\t\tif (likely(rl->lcn >= 0 || vol->major_ver < 3)) {\n\t\t\tprev_lcn = rl->lcn;\n\t\t\tif (likely(rl->lcn >= 0))\n\t\t\t\tprev_lcn += delta;\n\t\t\t/* Write change in lcn. */\n\t\t\tlcn_len = ntfs_write_significant_bytes(dst + 1 +\n\t\t\t\t\tlen_len, dst_max, prev_lcn);\n\t\t\tif (unlikely(lcn_len < 0))\n\t\t\t\tgoto size_err;\n\t\t} else\n\t\t\tlcn_len = 0;\n\t\tdst_next = dst + len_len + lcn_len + 1;\n\t\tif (unlikely(dst_next > dst_max))\n\t\t\tgoto size_err;\n\t\t/* Update header byte. */\n\t\t*dst = lcn_len << 4 | len_len;\n\t\t/* Position at next mapping pairs array element. */\n\t\tdst = dst_next;\n\t\t/* Go to next runlist element. */\n\t\trl++;\n\t}\n\t/* Do the full runs. */\n\tfor (; rl->length && !the_end; rl++) {\n\t\ts64 length = rl->length;\n\n\t\tif (unlikely(length < 0 || rl->lcn < LCN_HOLE))\n\t\t\tgoto err_out;\n\t\t/*\n\t\t * If @stop_vcn is given and finishes inside this run, cap the\n\t\t * run length.\n\t\t */\n\t\tif (unlikely(last_vcn >= 0 && rl[1].vcn > last_vcn)) {\n\t\t\ts64 s1 = last_vcn + 1;\n\t\t\tif (unlikely(rl[1].vcn > s1))\n\t\t\t\tlength = s1 - rl->vcn;\n\t\t\tthe_end = true;\n\t\t}\n\t\t/* Write length. */\n\t\tlen_len = ntfs_write_significant_bytes(dst + 1, dst_max,\n\t\t\t\tlength);\n\t\tif (unlikely(len_len < 0))\n\t\t\tgoto size_err;\n\t\t/*\n\t\t * If the logical cluster number (lcn) denotes a hole and we\n\t\t * are on NTFS 3.0+, we don't store it at all, i.e. we need\n\t\t * zero space.  On earlier NTFS versions we just write the lcn\n\t\t * change.  FIXME: Do we need to write the lcn change or just\n\t\t * the lcn in that case?  Not sure as I have never seen this\n\t\t * case on NT4. - We assume that we just need to write the lcn\n\t\t * change until someone tells us otherwise... (AIA)\n\t\t */\n\t\tif (likely(rl->lcn >= 0 || vol->major_ver < 3)) {\n\t\t\t/* Write change in lcn. */\n\t\t\tlcn_len = ntfs_write_significant_bytes(dst + 1 +\n\t\t\t\t\tlen_len, dst_max, rl->lcn - prev_lcn);\n\t\t\tif (unlikely(lcn_len < 0))\n\t\t\t\tgoto size_err;\n\t\t\tprev_lcn = rl->lcn;\n\t\t} else\n\t\t\tlcn_len = 0;\n\t\tdst_next = dst + len_len + lcn_len + 1;\n\t\tif (unlikely(dst_next > dst_max))\n\t\t\tgoto size_err;\n\t\t/* Update header byte. */\n\t\t*dst = lcn_len << 4 | len_len;\n\t\t/* Position at next mapping pairs array element. */\n\t\tdst = dst_next;\n\t}\n\t/* Success. */\n\terr = 0;\nsize_err:\n\t/* Set stop vcn. */\n\tif (stop_vcn)\n\t\t*stop_vcn = rl->vcn;\n\t/* Add terminator byte. */\n\t*dst = 0;\n\treturn err;\nerr_out:\n\tif (rl->lcn == LCN_RL_NOT_MAPPED)\n\t\terr = -EINVAL;\n\telse\n\t\terr = -EIO;\n\treturn err;\n}",
          "includes": [
            "#include \"ntfs.h\"",
            "#include \"malloc.h\"",
            "#include \"endian.h\"",
            "#include \"dir.h\"",
            "#include \"debug.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ntfs.h\"\n#include \"malloc.h\"\n#include \"endian.h\"\n#include \"dir.h\"\n#include \"debug.h\"\n\nint ntfs_mapping_pairs_build(const ntfs_volume *vol, s8 *dst,\n\t\tconst int dst_len, const runlist_element *rl,\n\t\tconst VCN first_vcn, const VCN last_vcn, VCN *const stop_vcn)\n{\n\tLCN prev_lcn;\n\ts8 *dst_max, *dst_next;\n\tint err = -ENOSPC;\n\tbool the_end = false;\n\ts8 len_len, lcn_len;\n\n\tBUG_ON(first_vcn < 0);\n\tBUG_ON(last_vcn < -1);\n\tBUG_ON(last_vcn >= 0 && first_vcn > last_vcn);\n\tBUG_ON(dst_len < 1);\n\tif (!rl) {\n\t\tBUG_ON(first_vcn);\n\t\tBUG_ON(last_vcn > 0);\n\t\tif (stop_vcn)\n\t\t\t*stop_vcn = 0;\n\t\t/* Terminator byte. */\n\t\t*dst = 0;\n\t\treturn 0;\n\t}\n\t/* Skip to runlist element containing @first_vcn. */\n\twhile (rl->length && first_vcn >= rl[1].vcn)\n\t\trl++;\n\tif (unlikely((!rl->length && first_vcn > rl->vcn) ||\n\t\t\tfirst_vcn < rl->vcn))\n\t\treturn -EINVAL;\n\t/*\n\t * @dst_max is used for bounds checking in\n\t * ntfs_write_significant_bytes().\n\t */\n\tdst_max = dst + dst_len - 1;\n\tprev_lcn = 0;\n\t/* Do the first partial run if present. */\n\tif (first_vcn > rl->vcn) {\n\t\ts64 delta, length = rl->length;\n\n\t\t/* We know rl->length != 0 already. */\n\t\tif (unlikely(length < 0 || rl->lcn < LCN_HOLE))\n\t\t\tgoto err_out;\n\t\t/*\n\t\t * If @stop_vcn is given and finishes inside this run, cap the\n\t\t * run length.\n\t\t */\n\t\tif (unlikely(last_vcn >= 0 && rl[1].vcn > last_vcn)) {\n\t\t\ts64 s1 = last_vcn + 1;\n\t\t\tif (unlikely(rl[1].vcn > s1))\n\t\t\t\tlength = s1 - rl->vcn;\n\t\t\tthe_end = true;\n\t\t}\n\t\tdelta = first_vcn - rl->vcn;\n\t\t/* Write length. */\n\t\tlen_len = ntfs_write_significant_bytes(dst + 1, dst_max,\n\t\t\t\tlength - delta);\n\t\tif (unlikely(len_len < 0))\n\t\t\tgoto size_err;\n\t\t/*\n\t\t * If the logical cluster number (lcn) denotes a hole and we\n\t\t * are on NTFS 3.0+, we don't store it at all, i.e. we need\n\t\t * zero space.  On earlier NTFS versions we just write the lcn\n\t\t * change.  FIXME: Do we need to write the lcn change or just\n\t\t * the lcn in that case?  Not sure as I have never seen this\n\t\t * case on NT4. - We assume that we just need to write the lcn\n\t\t * change until someone tells us otherwise... (AIA)\n\t\t */\n\t\tif (likely(rl->lcn >= 0 || vol->major_ver < 3)) {\n\t\t\tprev_lcn = rl->lcn;\n\t\t\tif (likely(rl->lcn >= 0))\n\t\t\t\tprev_lcn += delta;\n\t\t\t/* Write change in lcn. */\n\t\t\tlcn_len = ntfs_write_significant_bytes(dst + 1 +\n\t\t\t\t\tlen_len, dst_max, prev_lcn);\n\t\t\tif (unlikely(lcn_len < 0))\n\t\t\t\tgoto size_err;\n\t\t} else\n\t\t\tlcn_len = 0;\n\t\tdst_next = dst + len_len + lcn_len + 1;\n\t\tif (unlikely(dst_next > dst_max))\n\t\t\tgoto size_err;\n\t\t/* Update header byte. */\n\t\t*dst = lcn_len << 4 | len_len;\n\t\t/* Position at next mapping pairs array element. */\n\t\tdst = dst_next;\n\t\t/* Go to next runlist element. */\n\t\trl++;\n\t}\n\t/* Do the full runs. */\n\tfor (; rl->length && !the_end; rl++) {\n\t\ts64 length = rl->length;\n\n\t\tif (unlikely(length < 0 || rl->lcn < LCN_HOLE))\n\t\t\tgoto err_out;\n\t\t/*\n\t\t * If @stop_vcn is given and finishes inside this run, cap the\n\t\t * run length.\n\t\t */\n\t\tif (unlikely(last_vcn >= 0 && rl[1].vcn > last_vcn)) {\n\t\t\ts64 s1 = last_vcn + 1;\n\t\t\tif (unlikely(rl[1].vcn > s1))\n\t\t\t\tlength = s1 - rl->vcn;\n\t\t\tthe_end = true;\n\t\t}\n\t\t/* Write length. */\n\t\tlen_len = ntfs_write_significant_bytes(dst + 1, dst_max,\n\t\t\t\tlength);\n\t\tif (unlikely(len_len < 0))\n\t\t\tgoto size_err;\n\t\t/*\n\t\t * If the logical cluster number (lcn) denotes a hole and we\n\t\t * are on NTFS 3.0+, we don't store it at all, i.e. we need\n\t\t * zero space.  On earlier NTFS versions we just write the lcn\n\t\t * change.  FIXME: Do we need to write the lcn change or just\n\t\t * the lcn in that case?  Not sure as I have never seen this\n\t\t * case on NT4. - We assume that we just need to write the lcn\n\t\t * change until someone tells us otherwise... (AIA)\n\t\t */\n\t\tif (likely(rl->lcn >= 0 || vol->major_ver < 3)) {\n\t\t\t/* Write change in lcn. */\n\t\t\tlcn_len = ntfs_write_significant_bytes(dst + 1 +\n\t\t\t\t\tlen_len, dst_max, rl->lcn - prev_lcn);\n\t\t\tif (unlikely(lcn_len < 0))\n\t\t\t\tgoto size_err;\n\t\t\tprev_lcn = rl->lcn;\n\t\t} else\n\t\t\tlcn_len = 0;\n\t\tdst_next = dst + len_len + lcn_len + 1;\n\t\tif (unlikely(dst_next > dst_max))\n\t\t\tgoto size_err;\n\t\t/* Update header byte. */\n\t\t*dst = lcn_len << 4 | len_len;\n\t\t/* Position at next mapping pairs array element. */\n\t\tdst = dst_next;\n\t}\n\t/* Success. */\n\terr = 0;\nsize_err:\n\t/* Set stop vcn. */\n\tif (stop_vcn)\n\t\t*stop_vcn = rl->vcn;\n\t/* Add terminator byte. */\n\t*dst = 0;\n\treturn err;\nerr_out:\n\tif (rl->lcn == LCN_RL_NOT_MAPPED)\n\t\terr = -EINVAL;\n\telse\n\t\terr = -EIO;\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "le16_to_cpu",
          "args": [
            "a->data.non_resident.mapping_pairs_offset"
          ],
          "line": 1540
        },
        "resolved": true,
        "details": {
          "function_name": "sle16_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "48-51",
          "snippet": "static inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "up_write",
          "args": [
            "&vol->lcnbmp_lock"
          ],
          "line": 1536
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NVolSetErrors",
          "args": [
            "vol"
          ],
          "line": 1534
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntfs_bitmap_clear_bit",
          "args": [
            "vol->lcnbmp_ino",
            "lcn"
          ],
          "line": 1532
        },
        "resolved": true,
        "details": {
          "function_name": "ntfs_bitmap_clear_bit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/bitmap.h",
          "lines": "111-114",
          "snippet": "static inline int ntfs_bitmap_clear_bit(struct inode *vi, const s64 bit)\n{\n\treturn ntfs_bitmap_clear_run(vi, bit, 1);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <linux/fs.h>\n\nstatic inline int ntfs_bitmap_clear_bit(struct inode *vi, const s64 bit)\n{\n\treturn ntfs_bitmap_clear_run(vi, bit, 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "down_write",
          "args": [
            "&vol->lcnbmp_lock"
          ],
          "line": 1531
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_sle64",
          "args": [
            "rl[1].vcn - 2"
          ],
          "line": 1518
        },
        "resolved": true,
        "details": {
          "function_name": "cpu_to_sle64p",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "88-91",
          "snippet": "static inline sle64 cpu_to_sle64p(s64 *x)\n{\n\treturn (__force sle64)cpu_to_le64(*x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline sle64 cpu_to_sle64p(s64 *x)\n{\n\treturn (__force sle64)cpu_to_le64(*x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "NVolSetErrors",
          "args": [
            "vol"
          ],
          "line": 1514
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "up_write",
          "args": [
            "&mftbmp_ni->runlist.lock"
          ],
          "line": 1509
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "write_unlock_irqrestore",
          "args": [
            "&mftbmp_ni->size_lock",
            "flags"
          ],
          "line": 1506
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "write_lock_irqsave",
          "args": [
            "&mftbmp_ni->size_lock",
            "flags"
          ],
          "line": 1504
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntfs_attr_lookup",
          "args": [
            "mftbmp_ni->type",
            "mftbmp_ni->name",
            "mftbmp_ni->name_len",
            "CASE_SENSITIVE",
            "rl[1].vcn",
            "NULL",
            "0",
            "ctx"
          ],
          "line": 1499
        },
        "resolved": true,
        "details": {
          "function_name": "ntfs_attr_lookup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/attrib.c",
          "lines": "1187-1207",
          "snippet": "int ntfs_attr_lookup(const ATTR_TYPE type, const ntfschar *name,\n\t\tconst u32 name_len, const IGNORE_CASE_BOOL ic,\n\t\tconst VCN lowest_vcn, const u8 *val, const u32 val_len,\n\t\tntfs_attr_search_ctx *ctx)\n{\n\tntfs_inode *base_ni;\n\n\tntfs_debug(\"Entering.\");\n\tBUG_ON(IS_ERR(ctx->mrec));\n\tif (ctx->base_ntfs_ino)\n\t\tbase_ni = ctx->base_ntfs_ino;\n\telse\n\t\tbase_ni = ctx->ntfs_ino;\n\t/* Sanity check, just for debugging really. */\n\tBUG_ON(!base_ni);\n\tif (!NInoAttrList(base_ni) || type == AT_ATTRIBUTE_LIST)\n\t\treturn ntfs_attr_find(type, name, name_len, ic, val, val_len,\n\t\t\t\tctx);\n\treturn ntfs_external_attr_find(type, name, name_len, ic, lowest_vcn,\n\t\t\tval, val_len, ctx);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include \"ntfs.h\"",
            "#include \"mft.h\"",
            "#include \"malloc.h\"",
            "#include \"lcnalloc.h\"",
            "#include \"layout.h\"",
            "#include \"debug.h\"",
            "#include \"attrib.h\"",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include \"ntfs.h\"\n#include \"mft.h\"\n#include \"malloc.h\"\n#include \"lcnalloc.h\"\n#include \"layout.h\"\n#include \"debug.h\"\n#include \"attrib.h\"\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/buffer_head.h>\n\nint ntfs_attr_lookup(const ATTR_TYPE type, const ntfschar *name,\n\t\tconst u32 name_len, const IGNORE_CASE_BOOL ic,\n\t\tconst VCN lowest_vcn, const u8 *val, const u32 val_len,\n\t\tntfs_attr_search_ctx *ctx)\n{\n\tntfs_inode *base_ni;\n\n\tntfs_debug(\"Entering.\");\n\tBUG_ON(IS_ERR(ctx->mrec));\n\tif (ctx->base_ntfs_ino)\n\t\tbase_ni = ctx->base_ntfs_ino;\n\telse\n\t\tbase_ni = ctx->ntfs_ino;\n\t/* Sanity check, just for debugging really. */\n\tBUG_ON(!base_ni);\n\tif (!NInoAttrList(base_ni) || type == AT_ATTRIBUTE_LIST)\n\t\treturn ntfs_attr_find(type, name, name_len, ic, val, val_len,\n\t\t\t\tctx);\n\treturn ntfs_external_attr_find(type, name, name_len, ic, lowest_vcn,\n\t\t\tval, val_len, ctx);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ntfs_attr_reinit_search_ctx",
          "args": [
            "ctx"
          ],
          "line": 1498
        },
        "resolved": true,
        "details": {
          "function_name": "ntfs_attr_reinit_search_ctx",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/attrib.c",
          "lines": "1240-1259",
          "snippet": "void ntfs_attr_reinit_search_ctx(ntfs_attr_search_ctx *ctx)\n{\n\tif (likely(!ctx->base_ntfs_ino)) {\n\t\t/* No attribute list. */\n\t\tctx->is_first = true;\n\t\t/* Sanity checks are performed elsewhere. */\n\t\tctx->attr = (ATTR_RECORD*)((u8*)ctx->mrec +\n\t\t\t\tle16_to_cpu(ctx->mrec->attrs_offset));\n\t\t/*\n\t\t * This needs resetting due to ntfs_external_attr_find() which\n\t\t * can leave it set despite having zeroed ctx->base_ntfs_ino.\n\t\t */\n\t\tctx->al_entry = NULL;\n\t\treturn;\n\t} /* Attribute list. */\n\tif (ctx->ntfs_ino != ctx->base_ntfs_ino)\n\t\tunmap_extent_mft_record(ctx->ntfs_ino);\n\tntfs_attr_init_search_ctx(ctx, ctx->base_ntfs_ino, ctx->base_mrec);\n\treturn;\n}",
          "includes": [
            "#include \"types.h\"",
            "#include \"ntfs.h\"",
            "#include \"mft.h\"",
            "#include \"malloc.h\"",
            "#include \"lcnalloc.h\"",
            "#include \"layout.h\"",
            "#include \"debug.h\"",
            "#include \"attrib.h\"",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include \"ntfs.h\"\n#include \"mft.h\"\n#include \"malloc.h\"\n#include \"lcnalloc.h\"\n#include \"layout.h\"\n#include \"debug.h\"\n#include \"attrib.h\"\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/buffer_head.h>\n\nvoid ntfs_attr_reinit_search_ctx(ntfs_attr_search_ctx *ctx)\n{\n\tif (likely(!ctx->base_ntfs_ino)) {\n\t\t/* No attribute list. */\n\t\tctx->is_first = true;\n\t\t/* Sanity checks are performed elsewhere. */\n\t\tctx->attr = (ATTR_RECORD*)((u8*)ctx->mrec +\n\t\t\t\tle16_to_cpu(ctx->mrec->attrs_offset));\n\t\t/*\n\t\t * This needs resetting due to ntfs_external_attr_find() which\n\t\t * can leave it set despite having zeroed ctx->base_ntfs_ino.\n\t\t */\n\t\tctx->al_entry = NULL;\n\t\treturn;\n\t} /* Attribute list. */\n\tif (ctx->ntfs_ino != ctx->base_ntfs_ino)\n\t\tunmap_extent_mft_record(ctx->ntfs_ino);\n\tntfs_attr_init_search_ctx(ctx, ctx->base_ntfs_ino, ctx->base_mrec);\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ntfs_debug",
          "args": [
            "\"Done.\""
          ],
          "line": 1495
        },
        "resolved": true,
        "details": {
          "function_name": "ntfs_debug_dump_runlist",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/debug.c",
          "lines": "134-171",
          "snippet": "void ntfs_debug_dump_runlist(const runlist_element *rl)\n{\n\tint i;\n\tconst char *lcn_str[5] = { \"LCN_HOLE         \", \"LCN_RL_NOT_MAPPED\",\n\t\t\t\t   \"LCN_ENOENT       \", \"LCN_unknown      \" };\n\n\tif (!debug_msgs)\n\t\treturn;\n\tpr_debug(\"Dumping runlist (values in hex):\\n\");\n\tif (!rl) {\n\t\tpr_debug(\"Run list not present.\\n\");\n\t\treturn;\n\t}\n\tpr_debug(\"VCN              LCN               Run length\\n\");\n\tfor (i = 0; ; i++) {\n\t\tLCN lcn = (rl + i)->lcn;\n\n\t\tif (lcn < (LCN)0) {\n\t\t\tint index = -lcn - 1;\n\n\t\t\tif (index > -LCN_ENOENT - 1)\n\t\t\t\tindex = 3;\n\t\t\tpr_debug(\"%-16Lx %s %-16Lx%s\\n\",\n\t\t\t\t\t(long long)(rl + i)->vcn, lcn_str[index],\n\t\t\t\t\t(long long)(rl + i)->length,\n\t\t\t\t\t(rl + i)->length ? \"\" :\n\t\t\t\t\t\t\" (runlist end)\");\n\t\t} else\n\t\t\tpr_debug(\"%-16Lx %-16Lx  %-16Lx%s\\n\",\n\t\t\t\t\t(long long)(rl + i)->vcn,\n\t\t\t\t\t(long long)(rl + i)->lcn,\n\t\t\t\t\t(long long)(rl + i)->length,\n\t\t\t\t\t(rl + i)->length ? \"\" :\n\t\t\t\t\t\t\" (runlist end)\");\n\t\tif (!(rl + i)->length)\n\t\t\tbreak;\n\t}\n}",
          "includes": [
            "#include \"debug.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"debug.h\"\n\nvoid ntfs_debug_dump_runlist(const runlist_element *rl)\n{\n\tint i;\n\tconst char *lcn_str[5] = { \"LCN_HOLE         \", \"LCN_RL_NOT_MAPPED\",\n\t\t\t\t   \"LCN_ENOENT       \", \"LCN_unknown      \" };\n\n\tif (!debug_msgs)\n\t\treturn;\n\tpr_debug(\"Dumping runlist (values in hex):\\n\");\n\tif (!rl) {\n\t\tpr_debug(\"Run list not present.\\n\");\n\t\treturn;\n\t}\n\tpr_debug(\"VCN              LCN               Run length\\n\");\n\tfor (i = 0; ; i++) {\n\t\tLCN lcn = (rl + i)->lcn;\n\n\t\tif (lcn < (LCN)0) {\n\t\t\tint index = -lcn - 1;\n\n\t\t\tif (index > -LCN_ENOENT - 1)\n\t\t\t\tindex = 3;\n\t\t\tpr_debug(\"%-16Lx %s %-16Lx%s\\n\",\n\t\t\t\t\t(long long)(rl + i)->vcn, lcn_str[index],\n\t\t\t\t\t(long long)(rl + i)->length,\n\t\t\t\t\t(rl + i)->length ? \"\" :\n\t\t\t\t\t\t\" (runlist end)\");\n\t\t} else\n\t\t\tpr_debug(\"%-16Lx %-16Lx  %-16Lx%s\\n\",\n\t\t\t\t\t(long long)(rl + i)->vcn,\n\t\t\t\t\t(long long)(rl + i)->lcn,\n\t\t\t\t\t(long long)(rl + i)->length,\n\t\t\t\t\t(rl + i)->length ? \"\" :\n\t\t\t\t\t\t\" (runlist end)\");\n\t\tif (!(rl + i)->length)\n\t\t\tbreak;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "up_write",
          "args": [
            "&mftbmp_ni->runlist.lock"
          ],
          "line": 1494
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "write_unlock_irqrestore",
          "args": [
            "&mftbmp_ni->size_lock",
            "flags"
          ],
          "line": 1488
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "write_lock_irqsave",
          "args": [
            "&mftbmp_ni->size_lock",
            "flags"
          ],
          "line": 1484
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntfs_error",
          "args": [
            "vol->sb",
            "\"Failed to find first attribute \"\n\t\t\t\t\t\"extent of mft bitmap attribute.\""
          ],
          "line": 1478
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "ret"
          ],
          "line": 1477
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntfs_error",
          "args": [
            "vol->sb",
            "\"Failed to build mapping pairs array for \"\n\t\t\t\t\"mft bitmap attribute.\""
          ],
          "line": 1456
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "ret"
          ],
          "line": 1455
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntfs_error",
          "args": [
            "vol->sb",
            "\"Not enough space in this mft record to \"\n\t\t\t\t\"accommodate extended mft bitmap attribute \"\n\t\t\t\t\"extent.  Cannot handle this yet.\""
          ],
          "line": 1444
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntfs_error",
          "args": [
            "vol->sb",
            "\"Failed to resize attribute \"\n\t\t\t\t\t\"record for mft bitmap attribute.\""
          ],
          "line": 1435
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "ret"
          ],
          "line": 1433
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "a->length"
          ],
          "line": 1430
        },
        "resolved": true,
        "details": {
          "function_name": "sle32_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "53-56",
          "snippet": "static inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ntfs_error",
          "args": [
            "vol->sb",
            "\"Get size for mapping pairs failed for \"\n\t\t\t\t\"mft bitmap attribute extent.\""
          ],
          "line": 1422
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "mp_size <= 0"
          ],
          "line": 1421
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntfs_get_size_for_mapping_pairs",
          "args": [
            "vol",
            "rl2",
            "ll",
            "-1"
          ],
          "line": 1420
        },
        "resolved": true,
        "details": {
          "function_name": "ntfs_get_size_for_mapping_pairs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/runlist.c",
          "lines": "1131-1232",
          "snippet": "int ntfs_get_size_for_mapping_pairs(const ntfs_volume *vol,\n\t\tconst runlist_element *rl, const VCN first_vcn,\n\t\tconst VCN last_vcn)\n{\n\tLCN prev_lcn;\n\tint rls;\n\tbool the_end = false;\n\n\tBUG_ON(first_vcn < 0);\n\tBUG_ON(last_vcn < -1);\n\tBUG_ON(last_vcn >= 0 && first_vcn > last_vcn);\n\tif (!rl) {\n\t\tBUG_ON(first_vcn);\n\t\tBUG_ON(last_vcn > 0);\n\t\treturn 1;\n\t}\n\t/* Skip to runlist element containing @first_vcn. */\n\twhile (rl->length && first_vcn >= rl[1].vcn)\n\t\trl++;\n\tif (unlikely((!rl->length && first_vcn > rl->vcn) ||\n\t\t\tfirst_vcn < rl->vcn))\n\t\treturn -EINVAL;\n\tprev_lcn = 0;\n\t/* Always need the termining zero byte. */\n\trls = 1;\n\t/* Do the first partial run if present. */\n\tif (first_vcn > rl->vcn) {\n\t\ts64 delta, length = rl->length;\n\n\t\t/* We know rl->length != 0 already. */\n\t\tif (unlikely(length < 0 || rl->lcn < LCN_HOLE))\n\t\t\tgoto err_out;\n\t\t/*\n\t\t * If @stop_vcn is given and finishes inside this run, cap the\n\t\t * run length.\n\t\t */\n\t\tif (unlikely(last_vcn >= 0 && rl[1].vcn > last_vcn)) {\n\t\t\ts64 s1 = last_vcn + 1;\n\t\t\tif (unlikely(rl[1].vcn > s1))\n\t\t\t\tlength = s1 - rl->vcn;\n\t\t\tthe_end = true;\n\t\t}\n\t\tdelta = first_vcn - rl->vcn;\n\t\t/* Header byte + length. */\n\t\trls += 1 + ntfs_get_nr_significant_bytes(length - delta);\n\t\t/*\n\t\t * If the logical cluster number (lcn) denotes a hole and we\n\t\t * are on NTFS 3.0+, we don't store it at all, i.e. we need\n\t\t * zero space.  On earlier NTFS versions we just store the lcn.\n\t\t * Note: this assumes that on NTFS 1.2-, holes are stored with\n\t\t * an lcn of -1 and not a delta_lcn of -1 (unless both are -1).\n\t\t */\n\t\tif (likely(rl->lcn >= 0 || vol->major_ver < 3)) {\n\t\t\tprev_lcn = rl->lcn;\n\t\t\tif (likely(rl->lcn >= 0))\n\t\t\t\tprev_lcn += delta;\n\t\t\t/* Change in lcn. */\n\t\t\trls += ntfs_get_nr_significant_bytes(prev_lcn);\n\t\t}\n\t\t/* Go to next runlist element. */\n\t\trl++;\n\t}\n\t/* Do the full runs. */\n\tfor (; rl->length && !the_end; rl++) {\n\t\ts64 length = rl->length;\n\n\t\tif (unlikely(length < 0 || rl->lcn < LCN_HOLE))\n\t\t\tgoto err_out;\n\t\t/*\n\t\t * If @stop_vcn is given and finishes inside this run, cap the\n\t\t * run length.\n\t\t */\n\t\tif (unlikely(last_vcn >= 0 && rl[1].vcn > last_vcn)) {\n\t\t\ts64 s1 = last_vcn + 1;\n\t\t\tif (unlikely(rl[1].vcn > s1))\n\t\t\t\tlength = s1 - rl->vcn;\n\t\t\tthe_end = true;\n\t\t}\n\t\t/* Header byte + length. */\n\t\trls += 1 + ntfs_get_nr_significant_bytes(length);\n\t\t/*\n\t\t * If the logical cluster number (lcn) denotes a hole and we\n\t\t * are on NTFS 3.0+, we don't store it at all, i.e. we need\n\t\t * zero space.  On earlier NTFS versions we just store the lcn.\n\t\t * Note: this assumes that on NTFS 1.2-, holes are stored with\n\t\t * an lcn of -1 and not a delta_lcn of -1 (unless both are -1).\n\t\t */\n\t\tif (likely(rl->lcn >= 0 || vol->major_ver < 3)) {\n\t\t\t/* Change in lcn. */\n\t\t\trls += ntfs_get_nr_significant_bytes(rl->lcn -\n\t\t\t\t\tprev_lcn);\n\t\t\tprev_lcn = rl->lcn;\n\t\t}\n\t}\n\treturn rls;\nerr_out:\n\tif (rl->lcn == LCN_RL_NOT_MAPPED)\n\t\trls = -EINVAL;\n\telse\n\t\trls = -EIO;\n\treturn rls;\n}",
          "includes": [
            "#include \"ntfs.h\"",
            "#include \"malloc.h\"",
            "#include \"endian.h\"",
            "#include \"dir.h\"",
            "#include \"debug.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ntfs.h\"\n#include \"malloc.h\"\n#include \"endian.h\"\n#include \"dir.h\"\n#include \"debug.h\"\n\nint ntfs_get_size_for_mapping_pairs(const ntfs_volume *vol,\n\t\tconst runlist_element *rl, const VCN first_vcn,\n\t\tconst VCN last_vcn)\n{\n\tLCN prev_lcn;\n\tint rls;\n\tbool the_end = false;\n\n\tBUG_ON(first_vcn < 0);\n\tBUG_ON(last_vcn < -1);\n\tBUG_ON(last_vcn >= 0 && first_vcn > last_vcn);\n\tif (!rl) {\n\t\tBUG_ON(first_vcn);\n\t\tBUG_ON(last_vcn > 0);\n\t\treturn 1;\n\t}\n\t/* Skip to runlist element containing @first_vcn. */\n\twhile (rl->length && first_vcn >= rl[1].vcn)\n\t\trl++;\n\tif (unlikely((!rl->length && first_vcn > rl->vcn) ||\n\t\t\tfirst_vcn < rl->vcn))\n\t\treturn -EINVAL;\n\tprev_lcn = 0;\n\t/* Always need the termining zero byte. */\n\trls = 1;\n\t/* Do the first partial run if present. */\n\tif (first_vcn > rl->vcn) {\n\t\ts64 delta, length = rl->length;\n\n\t\t/* We know rl->length != 0 already. */\n\t\tif (unlikely(length < 0 || rl->lcn < LCN_HOLE))\n\t\t\tgoto err_out;\n\t\t/*\n\t\t * If @stop_vcn is given and finishes inside this run, cap the\n\t\t * run length.\n\t\t */\n\t\tif (unlikely(last_vcn >= 0 && rl[1].vcn > last_vcn)) {\n\t\t\ts64 s1 = last_vcn + 1;\n\t\t\tif (unlikely(rl[1].vcn > s1))\n\t\t\t\tlength = s1 - rl->vcn;\n\t\t\tthe_end = true;\n\t\t}\n\t\tdelta = first_vcn - rl->vcn;\n\t\t/* Header byte + length. */\n\t\trls += 1 + ntfs_get_nr_significant_bytes(length - delta);\n\t\t/*\n\t\t * If the logical cluster number (lcn) denotes a hole and we\n\t\t * are on NTFS 3.0+, we don't store it at all, i.e. we need\n\t\t * zero space.  On earlier NTFS versions we just store the lcn.\n\t\t * Note: this assumes that on NTFS 1.2-, holes are stored with\n\t\t * an lcn of -1 and not a delta_lcn of -1 (unless both are -1).\n\t\t */\n\t\tif (likely(rl->lcn >= 0 || vol->major_ver < 3)) {\n\t\t\tprev_lcn = rl->lcn;\n\t\t\tif (likely(rl->lcn >= 0))\n\t\t\t\tprev_lcn += delta;\n\t\t\t/* Change in lcn. */\n\t\t\trls += ntfs_get_nr_significant_bytes(prev_lcn);\n\t\t}\n\t\t/* Go to next runlist element. */\n\t\trl++;\n\t}\n\t/* Do the full runs. */\n\tfor (; rl->length && !the_end; rl++) {\n\t\ts64 length = rl->length;\n\n\t\tif (unlikely(length < 0 || rl->lcn < LCN_HOLE))\n\t\t\tgoto err_out;\n\t\t/*\n\t\t * If @stop_vcn is given and finishes inside this run, cap the\n\t\t * run length.\n\t\t */\n\t\tif (unlikely(last_vcn >= 0 && rl[1].vcn > last_vcn)) {\n\t\t\ts64 s1 = last_vcn + 1;\n\t\t\tif (unlikely(rl[1].vcn > s1))\n\t\t\t\tlength = s1 - rl->vcn;\n\t\t\tthe_end = true;\n\t\t}\n\t\t/* Header byte + length. */\n\t\trls += 1 + ntfs_get_nr_significant_bytes(length);\n\t\t/*\n\t\t * If the logical cluster number (lcn) denotes a hole and we\n\t\t * are on NTFS 3.0+, we don't store it at all, i.e. we need\n\t\t * zero space.  On earlier NTFS versions we just store the lcn.\n\t\t * Note: this assumes that on NTFS 1.2-, holes are stored with\n\t\t * an lcn of -1 and not a delta_lcn of -1 (unless both are -1).\n\t\t */\n\t\tif (likely(rl->lcn >= 0 || vol->major_ver < 3)) {\n\t\t\t/* Change in lcn. */\n\t\t\trls += ntfs_get_nr_significant_bytes(rl->lcn -\n\t\t\t\t\tprev_lcn);\n\t\t\tprev_lcn = rl->lcn;\n\t\t}\n\t}\n\treturn rls;\nerr_out:\n\tif (rl->lcn == LCN_RL_NOT_MAPPED)\n\t\trls = -EINVAL;\n\telse\n\t\trls = -EIO;\n\treturn rls;\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "ll >= rl2->vcn + rl2->length"
          ],
          "line": 1418
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "ll < rl2->vcn"
          ],
          "line": 1417
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sle64_to_cpu",
          "args": [
            "a->data.non_resident.lowest_vcn"
          ],
          "line": 1411
        },
        "resolved": true,
        "details": {
          "function_name": "sle64_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "58-61",
          "snippet": "static inline s64 sle64_to_cpup(sle64 *x)\n{\n\treturn le64_to_cpu(*(__force le64*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s64 sle64_to_cpup(sle64 *x)\n{\n\treturn le64_to_cpu(*(__force le64*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ntfs_error",
          "args": [
            "vol->sb",
            "\"Failed to find last attribute extent of \"\n\t\t\t\t\"mft bitmap attribute.\""
          ],
          "line": 1404
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "ret"
          ],
          "line": 1403
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntfs_error",
          "args": [
            "vol->sb",
            "\"Failed to get search context.\""
          ],
          "line": 1396
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!ctx"
          ],
          "line": 1395
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntfs_attr_get_search_ctx",
          "args": [
            "mft_ni",
            "mrec"
          ],
          "line": 1394
        },
        "resolved": true,
        "details": {
          "function_name": "ntfs_attr_get_search_ctx",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/attrib.c",
          "lines": "1269-1277",
          "snippet": "ntfs_attr_search_ctx *ntfs_attr_get_search_ctx(ntfs_inode *ni, MFT_RECORD *mrec)\n{\n\tntfs_attr_search_ctx *ctx;\n\n\tctx = kmem_cache_alloc(ntfs_attr_ctx_cache, GFP_NOFS);\n\tif (ctx)\n\t\tntfs_attr_init_search_ctx(ctx, ni, mrec);\n\treturn ctx;\n}",
          "includes": [
            "#include \"types.h\"",
            "#include \"ntfs.h\"",
            "#include \"mft.h\"",
            "#include \"malloc.h\"",
            "#include \"lcnalloc.h\"",
            "#include \"layout.h\"",
            "#include \"debug.h\"",
            "#include \"attrib.h\"",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include \"ntfs.h\"\n#include \"mft.h\"\n#include \"malloc.h\"\n#include \"lcnalloc.h\"\n#include \"layout.h\"\n#include \"debug.h\"\n#include \"attrib.h\"\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/buffer_head.h>\n\nntfs_attr_search_ctx *ntfs_attr_get_search_ctx(ntfs_inode *ni, MFT_RECORD *mrec)\n{\n\tntfs_attr_search_ctx *ctx;\n\n\tctx = kmem_cache_alloc(ntfs_attr_ctx_cache, GFP_NOFS);\n\tif (ctx)\n\t\tntfs_attr_init_search_ctx(ctx, ni, mrec);\n\treturn ctx;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "mrec"
          ],
          "line": 1391
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntfs_error",
          "args": [
            "vol->sb",
            "\"Failed to map mft record.\""
          ],
          "line": 1390
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "mrec"
          ],
          "line": 1389
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "rl"
          ],
          "line": 1375
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntfs_free",
          "args": [
            "rl2"
          ],
          "line": 1374
        },
        "resolved": true,
        "details": {
          "function_name": "ntfs_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/malloc.h",
          "lines": "86-94",
          "snippet": "static inline void ntfs_free(void *addr)\n{\n\tif (!is_vmalloc_addr(addr)) {\n\t\tkfree(addr);\n\t\t/* free_page((unsigned long)addr); */\n\t\treturn;\n\t}\n\tvfree(addr);\n}",
          "includes": [
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/vmalloc.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n\nstatic inline void ntfs_free(void *addr)\n{\n\tif (!is_vmalloc_addr(addr)) {\n\t\tkfree(addr);\n\t\t/* free_page((unsigned long)addr); */\n\t\treturn;\n\t}\n\tvfree(addr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "NVolSetErrors",
          "args": [
            "vol"
          ],
          "line": 1372
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntfs_cluster_free_from_rl",
          "args": [
            "vol",
            "rl2"
          ],
          "line": 1369
        },
        "resolved": true,
        "details": {
          "function_name": "ntfs_cluster_free_from_rl",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/lcnalloc.h",
          "lines": "132-141",
          "snippet": "static inline int ntfs_cluster_free_from_rl(ntfs_volume *vol,\n\t\tconst runlist_element *rl)\n{\n\tint ret;\n\n\tdown_write(&vol->lcnbmp_lock);\n\tret = ntfs_cluster_free_from_rl_nolock(vol, rl);\n\tup_write(&vol->lcnbmp_lock);\n\treturn ret;\n}",
          "includes": [
            "#include \"volume.h\"",
            "#include \"runlist.h\"",
            "#include \"inode.h\"",
            "#include \"types.h\"",
            "#include \"attrib.h\"",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"volume.h\"\n#include \"runlist.h\"\n#include \"inode.h\"\n#include \"types.h\"\n#include \"attrib.h\"\n#include <linux/fs.h>\n\nstatic inline int ntfs_cluster_free_from_rl(ntfs_volume *vol,\n\t\tconst runlist_element *rl)\n{\n\tint ret;\n\n\tdown_write(&vol->lcnbmp_lock);\n\tret = ntfs_cluster_free_from_rl_nolock(vol, rl);\n\tup_write(&vol->lcnbmp_lock);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ntfs_error",
          "args": [
            "vol->sb",
            "\"Failed to merge runlists for mft \"\n\t\t\t\t\t\"bitmap.\""
          ],
          "line": 1367
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "up_write",
          "args": [
            "&mftbmp_ni->runlist.lock"
          ],
          "line": 1366
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "rl"
          ],
          "line": 1365
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntfs_runlists_merge",
          "args": [
            "mftbmp_ni->runlist.rl",
            "rl2"
          ],
          "line": 1364
        },
        "resolved": true,
        "details": {
          "function_name": "ntfs_runlists_merge",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/runlist.c",
          "lines": "531-719",
          "snippet": "runlist_element *ntfs_runlists_merge(runlist_element *drl,\n\t\trunlist_element *srl)\n{\n\tint di, si;\t\t/* Current index into @[ds]rl. */\n\tint sstart;\t\t/* First index with lcn > LCN_RL_NOT_MAPPED. */\n\tint dins;\t\t/* Index into @drl at which to insert @srl. */\n\tint dend, send;\t\t/* Last index into @[ds]rl. */\n\tint dfinal, sfinal;\t/* The last index into @[ds]rl with\n\t\t\t\t   lcn >= LCN_HOLE. */\n\tint marker = 0;\n\tVCN marker_vcn = 0;\n\n#ifdef DEBUG\n\tntfs_debug(\"dst:\");\n\tntfs_debug_dump_runlist(drl);\n\tntfs_debug(\"src:\");\n\tntfs_debug_dump_runlist(srl);\n#endif\n\n\t/* Check for silly calling... */\n\tif (unlikely(!srl))\n\t\treturn drl;\n\tif (IS_ERR(srl) || IS_ERR(drl))\n\t\treturn ERR_PTR(-EINVAL);\n\n\t/* Check for the case where the first mapping is being done now. */\n\tif (unlikely(!drl)) {\n\t\tdrl = srl;\n\t\t/* Complete the source runlist if necessary. */\n\t\tif (unlikely(drl[0].vcn)) {\n\t\t\t/* Scan to the end of the source runlist. */\n\t\t\tfor (dend = 0; likely(drl[dend].length); dend++)\n\t\t\t\t;\n\t\t\tdend++;\n\t\t\tdrl = ntfs_rl_realloc(drl, dend, dend + 1);\n\t\t\tif (IS_ERR(drl))\n\t\t\t\treturn drl;\n\t\t\t/* Insert start element at the front of the runlist. */\n\t\t\tntfs_rl_mm(drl, 1, 0, dend);\n\t\t\tdrl[0].vcn = 0;\n\t\t\tdrl[0].lcn = LCN_RL_NOT_MAPPED;\n\t\t\tdrl[0].length = drl[1].vcn;\n\t\t}\n\t\tgoto finished;\n\t}\n\n\tsi = di = 0;\n\n\t/* Skip any unmapped start element(s) in the source runlist. */\n\twhile (srl[si].length && srl[si].lcn < LCN_HOLE)\n\t\tsi++;\n\n\t/* Can't have an entirely unmapped source runlist. */\n\tBUG_ON(!srl[si].length);\n\n\t/* Record the starting points. */\n\tsstart = si;\n\n\t/*\n\t * Skip forward in @drl until we reach the position where @srl needs to\n\t * be inserted. If we reach the end of @drl, @srl just needs to be\n\t * appended to @drl.\n\t */\n\tfor (; drl[di].length; di++) {\n\t\tif (drl[di].vcn + drl[di].length > srl[sstart].vcn)\n\t\t\tbreak;\n\t}\n\tdins = di;\n\n\t/* Sanity check for illegal overlaps. */\n\tif ((drl[di].vcn == srl[si].vcn) && (drl[di].lcn >= 0) &&\n\t\t\t(srl[si].lcn >= 0)) {\n\t\tntfs_error(NULL, \"Run lists overlap. Cannot merge!\");\n\t\treturn ERR_PTR(-ERANGE);\n\t}\n\n\t/* Scan to the end of both runlists in order to know their sizes. */\n\tfor (send = si; srl[send].length; send++)\n\t\t;\n\tfor (dend = di; drl[dend].length; dend++)\n\t\t;\n\n\tif (srl[send].lcn == LCN_ENOENT)\n\t\tmarker_vcn = srl[marker = send].vcn;\n\n\t/* Scan to the last element with lcn >= LCN_HOLE. */\n\tfor (sfinal = send; sfinal >= 0 && srl[sfinal].lcn < LCN_HOLE; sfinal--)\n\t\t;\n\tfor (dfinal = dend; dfinal >= 0 && drl[dfinal].lcn < LCN_HOLE; dfinal--)\n\t\t;\n\n\t{\n\tbool start;\n\tbool finish;\n\tint ds = dend + 1;\t\t/* Number of elements in drl & srl */\n\tint ss = sfinal - sstart + 1;\n\n\tstart  = ((drl[dins].lcn <  LCN_RL_NOT_MAPPED) ||    /* End of file   */\n\t\t  (drl[dins].vcn == srl[sstart].vcn));\t     /* Start of hole */\n\tfinish = ((drl[dins].lcn >= LCN_RL_NOT_MAPPED) &&    /* End of file   */\n\t\t ((drl[dins].vcn + drl[dins].length) <=      /* End of hole   */\n\t\t  (srl[send - 1].vcn + srl[send - 1].length)));\n\n\t/* Or we will lose an end marker. */\n\tif (finish && !drl[dins].length)\n\t\tss++;\n\tif (marker && (drl[dins].vcn + drl[dins].length > srl[send - 1].vcn))\n\t\tfinish = false;\n#if 0\n\tntfs_debug(\"dfinal = %i, dend = %i\", dfinal, dend);\n\tntfs_debug(\"sstart = %i, sfinal = %i, send = %i\", sstart, sfinal, send);\n\tntfs_debug(\"start = %i, finish = %i\", start, finish);\n\tntfs_debug(\"ds = %i, ss = %i, dins = %i\", ds, ss, dins);\n#endif\n\tif (start) {\n\t\tif (finish)\n\t\t\tdrl = ntfs_rl_replace(drl, ds, srl + sstart, ss, dins);\n\t\telse\n\t\t\tdrl = ntfs_rl_insert(drl, ds, srl + sstart, ss, dins);\n\t} else {\n\t\tif (finish)\n\t\t\tdrl = ntfs_rl_append(drl, ds, srl + sstart, ss, dins);\n\t\telse\n\t\t\tdrl = ntfs_rl_split(drl, ds, srl + sstart, ss, dins);\n\t}\n\tif (IS_ERR(drl)) {\n\t\tntfs_error(NULL, \"Merge failed.\");\n\t\treturn drl;\n\t}\n\tntfs_free(srl);\n\tif (marker) {\n\t\tntfs_debug(\"Triggering marker code.\");\n\t\tfor (ds = dend; drl[ds].length; ds++)\n\t\t\t;\n\t\t/* We only need to care if @srl ended after @drl. */\n\t\tif (drl[ds].vcn <= marker_vcn) {\n\t\t\tint slots = 0;\n\n\t\t\tif (drl[ds].vcn == marker_vcn) {\n\t\t\t\tntfs_debug(\"Old marker = 0x%llx, replacing \"\n\t\t\t\t\t\t\"with LCN_ENOENT.\",\n\t\t\t\t\t\t(unsigned long long)\n\t\t\t\t\t\tdrl[ds].lcn);\n\t\t\t\tdrl[ds].lcn = LCN_ENOENT;\n\t\t\t\tgoto finished;\n\t\t\t}\n\t\t\t/*\n\t\t\t * We need to create an unmapped runlist element in\n\t\t\t * @drl or extend an existing one before adding the\n\t\t\t * ENOENT terminator.\n\t\t\t */\n\t\t\tif (drl[ds].lcn == LCN_ENOENT) {\n\t\t\t\tds--;\n\t\t\t\tslots = 1;\n\t\t\t}\n\t\t\tif (drl[ds].lcn != LCN_RL_NOT_MAPPED) {\n\t\t\t\t/* Add an unmapped runlist element. */\n\t\t\t\tif (!slots) {\n\t\t\t\t\tdrl = ntfs_rl_realloc_nofail(drl, ds,\n\t\t\t\t\t\t\tds + 2);\n\t\t\t\t\tslots = 2;\n\t\t\t\t}\n\t\t\t\tds++;\n\t\t\t\t/* Need to set vcn if it isn't set already. */\n\t\t\t\tif (slots != 1)\n\t\t\t\t\tdrl[ds].vcn = drl[ds - 1].vcn +\n\t\t\t\t\t\t\tdrl[ds - 1].length;\n\t\t\t\tdrl[ds].lcn = LCN_RL_NOT_MAPPED;\n\t\t\t\t/* We now used up a slot. */\n\t\t\t\tslots--;\n\t\t\t}\n\t\t\tdrl[ds].length = marker_vcn - drl[ds].vcn;\n\t\t\t/* Finally add the ENOENT terminator. */\n\t\t\tds++;\n\t\t\tif (!slots)\n\t\t\t\tdrl = ntfs_rl_realloc_nofail(drl, ds, ds + 1);\n\t\t\tdrl[ds].vcn = marker_vcn;\n\t\t\tdrl[ds].lcn = LCN_ENOENT;\n\t\t\tdrl[ds].length = (s64)0;\n\t\t}\n\t}\n\t}\n\nfinished:\n\t/* The merge was completed successfully. */\n\tntfs_debug(\"Merged runlist:\");\n\tntfs_debug_dump_runlist(drl);\n\treturn drl;\n}",
          "includes": [
            "#include \"ntfs.h\"",
            "#include \"malloc.h\"",
            "#include \"endian.h\"",
            "#include \"dir.h\"",
            "#include \"debug.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ntfs.h\"\n#include \"malloc.h\"\n#include \"endian.h\"\n#include \"dir.h\"\n#include \"debug.h\"\n\nrunlist_element *ntfs_runlists_merge(runlist_element *drl,\n\t\trunlist_element *srl)\n{\n\tint di, si;\t\t/* Current index into @[ds]rl. */\n\tint sstart;\t\t/* First index with lcn > LCN_RL_NOT_MAPPED. */\n\tint dins;\t\t/* Index into @drl at which to insert @srl. */\n\tint dend, send;\t\t/* Last index into @[ds]rl. */\n\tint dfinal, sfinal;\t/* The last index into @[ds]rl with\n\t\t\t\t   lcn >= LCN_HOLE. */\n\tint marker = 0;\n\tVCN marker_vcn = 0;\n\n#ifdef DEBUG\n\tntfs_debug(\"dst:\");\n\tntfs_debug_dump_runlist(drl);\n\tntfs_debug(\"src:\");\n\tntfs_debug_dump_runlist(srl);\n#endif\n\n\t/* Check for silly calling... */\n\tif (unlikely(!srl))\n\t\treturn drl;\n\tif (IS_ERR(srl) || IS_ERR(drl))\n\t\treturn ERR_PTR(-EINVAL);\n\n\t/* Check for the case where the first mapping is being done now. */\n\tif (unlikely(!drl)) {\n\t\tdrl = srl;\n\t\t/* Complete the source runlist if necessary. */\n\t\tif (unlikely(drl[0].vcn)) {\n\t\t\t/* Scan to the end of the source runlist. */\n\t\t\tfor (dend = 0; likely(drl[dend].length); dend++)\n\t\t\t\t;\n\t\t\tdend++;\n\t\t\tdrl = ntfs_rl_realloc(drl, dend, dend + 1);\n\t\t\tif (IS_ERR(drl))\n\t\t\t\treturn drl;\n\t\t\t/* Insert start element at the front of the runlist. */\n\t\t\tntfs_rl_mm(drl, 1, 0, dend);\n\t\t\tdrl[0].vcn = 0;\n\t\t\tdrl[0].lcn = LCN_RL_NOT_MAPPED;\n\t\t\tdrl[0].length = drl[1].vcn;\n\t\t}\n\t\tgoto finished;\n\t}\n\n\tsi = di = 0;\n\n\t/* Skip any unmapped start element(s) in the source runlist. */\n\twhile (srl[si].length && srl[si].lcn < LCN_HOLE)\n\t\tsi++;\n\n\t/* Can't have an entirely unmapped source runlist. */\n\tBUG_ON(!srl[si].length);\n\n\t/* Record the starting points. */\n\tsstart = si;\n\n\t/*\n\t * Skip forward in @drl until we reach the position where @srl needs to\n\t * be inserted. If we reach the end of @drl, @srl just needs to be\n\t * appended to @drl.\n\t */\n\tfor (; drl[di].length; di++) {\n\t\tif (drl[di].vcn + drl[di].length > srl[sstart].vcn)\n\t\t\tbreak;\n\t}\n\tdins = di;\n\n\t/* Sanity check for illegal overlaps. */\n\tif ((drl[di].vcn == srl[si].vcn) && (drl[di].lcn >= 0) &&\n\t\t\t(srl[si].lcn >= 0)) {\n\t\tntfs_error(NULL, \"Run lists overlap. Cannot merge!\");\n\t\treturn ERR_PTR(-ERANGE);\n\t}\n\n\t/* Scan to the end of both runlists in order to know their sizes. */\n\tfor (send = si; srl[send].length; send++)\n\t\t;\n\tfor (dend = di; drl[dend].length; dend++)\n\t\t;\n\n\tif (srl[send].lcn == LCN_ENOENT)\n\t\tmarker_vcn = srl[marker = send].vcn;\n\n\t/* Scan to the last element with lcn >= LCN_HOLE. */\n\tfor (sfinal = send; sfinal >= 0 && srl[sfinal].lcn < LCN_HOLE; sfinal--)\n\t\t;\n\tfor (dfinal = dend; dfinal >= 0 && drl[dfinal].lcn < LCN_HOLE; dfinal--)\n\t\t;\n\n\t{\n\tbool start;\n\tbool finish;\n\tint ds = dend + 1;\t\t/* Number of elements in drl & srl */\n\tint ss = sfinal - sstart + 1;\n\n\tstart  = ((drl[dins].lcn <  LCN_RL_NOT_MAPPED) ||    /* End of file   */\n\t\t  (drl[dins].vcn == srl[sstart].vcn));\t     /* Start of hole */\n\tfinish = ((drl[dins].lcn >= LCN_RL_NOT_MAPPED) &&    /* End of file   */\n\t\t ((drl[dins].vcn + drl[dins].length) <=      /* End of hole   */\n\t\t  (srl[send - 1].vcn + srl[send - 1].length)));\n\n\t/* Or we will lose an end marker. */\n\tif (finish && !drl[dins].length)\n\t\tss++;\n\tif (marker && (drl[dins].vcn + drl[dins].length > srl[send - 1].vcn))\n\t\tfinish = false;\n#if 0\n\tntfs_debug(\"dfinal = %i, dend = %i\", dfinal, dend);\n\tntfs_debug(\"sstart = %i, sfinal = %i, send = %i\", sstart, sfinal, send);\n\tntfs_debug(\"start = %i, finish = %i\", start, finish);\n\tntfs_debug(\"ds = %i, ss = %i, dins = %i\", ds, ss, dins);\n#endif\n\tif (start) {\n\t\tif (finish)\n\t\t\tdrl = ntfs_rl_replace(drl, ds, srl + sstart, ss, dins);\n\t\telse\n\t\t\tdrl = ntfs_rl_insert(drl, ds, srl + sstart, ss, dins);\n\t} else {\n\t\tif (finish)\n\t\t\tdrl = ntfs_rl_append(drl, ds, srl + sstart, ss, dins);\n\t\telse\n\t\t\tdrl = ntfs_rl_split(drl, ds, srl + sstart, ss, dins);\n\t}\n\tif (IS_ERR(drl)) {\n\t\tntfs_error(NULL, \"Merge failed.\");\n\t\treturn drl;\n\t}\n\tntfs_free(srl);\n\tif (marker) {\n\t\tntfs_debug(\"Triggering marker code.\");\n\t\tfor (ds = dend; drl[ds].length; ds++)\n\t\t\t;\n\t\t/* We only need to care if @srl ended after @drl. */\n\t\tif (drl[ds].vcn <= marker_vcn) {\n\t\t\tint slots = 0;\n\n\t\t\tif (drl[ds].vcn == marker_vcn) {\n\t\t\t\tntfs_debug(\"Old marker = 0x%llx, replacing \"\n\t\t\t\t\t\t\"with LCN_ENOENT.\",\n\t\t\t\t\t\t(unsigned long long)\n\t\t\t\t\t\tdrl[ds].lcn);\n\t\t\t\tdrl[ds].lcn = LCN_ENOENT;\n\t\t\t\tgoto finished;\n\t\t\t}\n\t\t\t/*\n\t\t\t * We need to create an unmapped runlist element in\n\t\t\t * @drl or extend an existing one before adding the\n\t\t\t * ENOENT terminator.\n\t\t\t */\n\t\t\tif (drl[ds].lcn == LCN_ENOENT) {\n\t\t\t\tds--;\n\t\t\t\tslots = 1;\n\t\t\t}\n\t\t\tif (drl[ds].lcn != LCN_RL_NOT_MAPPED) {\n\t\t\t\t/* Add an unmapped runlist element. */\n\t\t\t\tif (!slots) {\n\t\t\t\t\tdrl = ntfs_rl_realloc_nofail(drl, ds,\n\t\t\t\t\t\t\tds + 2);\n\t\t\t\t\tslots = 2;\n\t\t\t\t}\n\t\t\t\tds++;\n\t\t\t\t/* Need to set vcn if it isn't set already. */\n\t\t\t\tif (slots != 1)\n\t\t\t\t\tdrl[ds].vcn = drl[ds - 1].vcn +\n\t\t\t\t\t\t\tdrl[ds - 1].length;\n\t\t\t\tdrl[ds].lcn = LCN_RL_NOT_MAPPED;\n\t\t\t\t/* We now used up a slot. */\n\t\t\t\tslots--;\n\t\t\t}\n\t\t\tdrl[ds].length = marker_vcn - drl[ds].vcn;\n\t\t\t/* Finally add the ENOENT terminator. */\n\t\t\tds++;\n\t\t\tif (!slots)\n\t\t\t\tdrl = ntfs_rl_realloc_nofail(drl, ds, ds + 1);\n\t\t\tdrl[ds].vcn = marker_vcn;\n\t\t\tdrl[ds].lcn = LCN_ENOENT;\n\t\t\tdrl[ds].length = (s64)0;\n\t\t}\n\t}\n\t}\n\nfinished:\n\t/* The merge was completed successfully. */\n\tntfs_debug(\"Merged runlist:\");\n\tntfs_debug_dump_runlist(drl);\n\treturn drl;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "rl2"
          ],
          "line": 1362
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntfs_error",
          "args": [
            "vol->sb",
            "\"Failed to allocate a cluster for \"\n\t\t\t\t\t\"the mft bitmap.\""
          ],
          "line": 1360
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "up_write",
          "args": [
            "&mftbmp_ni->runlist.lock"
          ],
          "line": 1359
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "rl2"
          ],
          "line": 1358
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntfs_cluster_alloc",
          "args": [
            "vol",
            "rl[1].vcn",
            "1",
            "lcn",
            "DATA_ZONE",
            "true"
          ],
          "line": 1356
        },
        "resolved": true,
        "details": {
          "function_name": "ntfs_cluster_alloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/lcnalloc.c",
          "lines": "146-787",
          "snippet": "runlist_element *ntfs_cluster_alloc(ntfs_volume *vol, const VCN start_vcn,\n\t\tconst s64 count, const LCN start_lcn,\n\t\tconst NTFS_CLUSTER_ALLOCATION_ZONES zone,\n\t\tconst bool is_extension)\n{\n\tLCN zone_start, zone_end, bmp_pos, bmp_initial_pos, last_read_pos, lcn;\n\tLCN prev_lcn = 0, prev_run_len = 0, mft_zone_size;\n\ts64 clusters;\n\tloff_t i_size;\n\tstruct inode *lcnbmp_vi;\n\trunlist_element *rl = NULL;\n\tstruct address_space *mapping;\n\tstruct page *page = NULL;\n\tu8 *buf, *byte;\n\tint err = 0, rlpos, rlsize, buf_size;\n\tu8 pass, done_zones, search_zone, need_writeback = 0, bit;\n\n\tntfs_debug(\"Entering for start_vcn 0x%llx, count 0x%llx, start_lcn \"\n\t\t\t\"0x%llx, zone %s_ZONE.\", (unsigned long long)start_vcn,\n\t\t\t(unsigned long long)count,\n\t\t\t(unsigned long long)start_lcn,\n\t\t\tzone == MFT_ZONE ? \"MFT\" : \"DATA\");\n\tBUG_ON(!vol);\n\tlcnbmp_vi = vol->lcnbmp_ino;\n\tBUG_ON(!lcnbmp_vi);\n\tBUG_ON(start_vcn < 0);\n\tBUG_ON(count < 0);\n\tBUG_ON(start_lcn < -1);\n\tBUG_ON(zone < FIRST_ZONE);\n\tBUG_ON(zone > LAST_ZONE);\n\n\t/* Return NULL if @count is zero. */\n\tif (!count)\n\t\treturn NULL;\n\t/* Take the lcnbmp lock for writing. */\n\tdown_write(&vol->lcnbmp_lock);\n\t/*\n\t * If no specific @start_lcn was requested, use the current data zone\n\t * position, otherwise use the requested @start_lcn but make sure it\n\t * lies outside the mft zone.  Also set done_zones to 0 (no zones done)\n\t * and pass depending on whether we are starting inside a zone (1) or\n\t * at the beginning of a zone (2).  If requesting from the MFT_ZONE,\n\t * we either start at the current position within the mft zone or at\n\t * the specified position.  If the latter is out of bounds then we start\n\t * at the beginning of the MFT_ZONE.\n\t */\n\tdone_zones = 0;\n\tpass = 1;\n\t/*\n\t * zone_start and zone_end are the current search range.  search_zone\n\t * is 1 for mft zone, 2 for data zone 1 (end of mft zone till end of\n\t * volume) and 4 for data zone 2 (start of volume till start of mft\n\t * zone).\n\t */\n\tzone_start = start_lcn;\n\tif (zone_start < 0) {\n\t\tif (zone == DATA_ZONE)\n\t\t\tzone_start = vol->data1_zone_pos;\n\t\telse\n\t\t\tzone_start = vol->mft_zone_pos;\n\t\tif (!zone_start) {\n\t\t\t/*\n\t\t\t * Zone starts at beginning of volume which means a\n\t\t\t * single pass is sufficient.\n\t\t\t */\n\t\t\tpass = 2;\n\t\t}\n\t} else if (zone == DATA_ZONE && zone_start >= vol->mft_zone_start &&\n\t\t\tzone_start < vol->mft_zone_end) {\n\t\tzone_start = vol->mft_zone_end;\n\t\t/*\n\t\t * Starting at beginning of data1_zone which means a single\n\t\t * pass in this zone is sufficient.\n\t\t */\n\t\tpass = 2;\n\t} else if (zone == MFT_ZONE && (zone_start < vol->mft_zone_start ||\n\t\t\tzone_start >= vol->mft_zone_end)) {\n\t\tzone_start = vol->mft_lcn;\n\t\tif (!vol->mft_zone_end)\n\t\t\tzone_start = 0;\n\t\t/*\n\t\t * Starting at beginning of volume which means a single pass\n\t\t * is sufficient.\n\t\t */\n\t\tpass = 2;\n\t}\n\tif (zone == MFT_ZONE) {\n\t\tzone_end = vol->mft_zone_end;\n\t\tsearch_zone = 1;\n\t} else /* if (zone == DATA_ZONE) */ {\n\t\t/* Skip searching the mft zone. */\n\t\tdone_zones |= 1;\n\t\tif (zone_start >= vol->mft_zone_end) {\n\t\t\tzone_end = vol->nr_clusters;\n\t\t\tsearch_zone = 2;\n\t\t} else {\n\t\t\tzone_end = vol->mft_zone_start;\n\t\t\tsearch_zone = 4;\n\t\t}\n\t}\n\t/*\n\t * bmp_pos is the current bit position inside the bitmap.  We use\n\t * bmp_initial_pos to determine whether or not to do a zone switch.\n\t */\n\tbmp_pos = bmp_initial_pos = zone_start;\n\n\t/* Loop until all clusters are allocated, i.e. clusters == 0. */\n\tclusters = count;\n\trlpos = rlsize = 0;\n\tmapping = lcnbmp_vi->i_mapping;\n\ti_size = i_size_read(lcnbmp_vi);\n\twhile (1) {\n\t\tntfs_debug(\"Start of outer while loop: done_zones 0x%x, \"\n\t\t\t\t\"search_zone %i, pass %i, zone_start 0x%llx, \"\n\t\t\t\t\"zone_end 0x%llx, bmp_initial_pos 0x%llx, \"\n\t\t\t\t\"bmp_pos 0x%llx, rlpos %i, rlsize %i.\",\n\t\t\t\tdone_zones, search_zone, pass,\n\t\t\t\t(unsigned long long)zone_start,\n\t\t\t\t(unsigned long long)zone_end,\n\t\t\t\t(unsigned long long)bmp_initial_pos,\n\t\t\t\t(unsigned long long)bmp_pos, rlpos, rlsize);\n\t\t/* Loop until we run out of free clusters. */\n\t\tlast_read_pos = bmp_pos >> 3;\n\t\tntfs_debug(\"last_read_pos 0x%llx.\",\n\t\t\t\t(unsigned long long)last_read_pos);\n\t\tif (last_read_pos > i_size) {\n\t\t\tntfs_debug(\"End of attribute reached.  \"\n\t\t\t\t\t\"Skipping to zone_pass_done.\");\n\t\t\tgoto zone_pass_done;\n\t\t}\n\t\tif (likely(page)) {\n\t\t\tif (need_writeback) {\n\t\t\t\tntfs_debug(\"Marking page dirty.\");\n\t\t\t\tflush_dcache_page(page);\n\t\t\t\tset_page_dirty(page);\n\t\t\t\tneed_writeback = 0;\n\t\t\t}\n\t\t\tntfs_unmap_page(page);\n\t\t}\n\t\tpage = ntfs_map_page(mapping, last_read_pos >>\n\t\t\t\tPAGE_CACHE_SHIFT);\n\t\tif (IS_ERR(page)) {\n\t\t\terr = PTR_ERR(page);\n\t\t\tntfs_error(vol->sb, \"Failed to map page.\");\n\t\t\tgoto out;\n\t\t}\n\t\tbuf_size = last_read_pos & ~PAGE_CACHE_MASK;\n\t\tbuf = page_address(page) + buf_size;\n\t\tbuf_size = PAGE_CACHE_SIZE - buf_size;\n\t\tif (unlikely(last_read_pos + buf_size > i_size))\n\t\t\tbuf_size = i_size - last_read_pos;\n\t\tbuf_size <<= 3;\n\t\tlcn = bmp_pos & 7;\n\t\tbmp_pos &= ~(LCN)7;\n\t\tntfs_debug(\"Before inner while loop: buf_size %i, lcn 0x%llx, \"\n\t\t\t\t\"bmp_pos 0x%llx, need_writeback %i.\", buf_size,\n\t\t\t\t(unsigned long long)lcn,\n\t\t\t\t(unsigned long long)bmp_pos, need_writeback);\n\t\twhile (lcn < buf_size && lcn + bmp_pos < zone_end) {\n\t\t\tbyte = buf + (lcn >> 3);\n\t\t\tntfs_debug(\"In inner while loop: buf_size %i, \"\n\t\t\t\t\t\"lcn 0x%llx, bmp_pos 0x%llx, \"\n\t\t\t\t\t\"need_writeback %i, byte ofs 0x%x, \"\n\t\t\t\t\t\"*byte 0x%x.\", buf_size,\n\t\t\t\t\t(unsigned long long)lcn,\n\t\t\t\t\t(unsigned long long)bmp_pos,\n\t\t\t\t\tneed_writeback,\n\t\t\t\t\t(unsigned int)(lcn >> 3),\n\t\t\t\t\t(unsigned int)*byte);\n\t\t\t/* Skip full bytes. */\n\t\t\tif (*byte == 0xff) {\n\t\t\t\tlcn = (lcn + 8) & ~(LCN)7;\n\t\t\t\tntfs_debug(\"Continuing while loop 1.\");\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tbit = 1 << (lcn & 7);\n\t\t\tntfs_debug(\"bit 0x%x.\", bit);\n\t\t\t/* If the bit is already set, go onto the next one. */\n\t\t\tif (*byte & bit) {\n\t\t\t\tlcn++;\n\t\t\t\tntfs_debug(\"Continuing while loop 2.\");\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t/*\n\t\t\t * Allocate more memory if needed, including space for\n\t\t\t * the terminator element.\n\t\t\t * ntfs_malloc_nofs() operates on whole pages only.\n\t\t\t */\n\t\t\tif ((rlpos + 2) * sizeof(*rl) > rlsize) {\n\t\t\t\trunlist_element *rl2;\n\n\t\t\t\tntfs_debug(\"Reallocating memory.\");\n\t\t\t\tif (!rl)\n\t\t\t\t\tntfs_debug(\"First free bit is at LCN \"\n\t\t\t\t\t\t\t\"0x%llx.\",\n\t\t\t\t\t\t\t(unsigned long long)\n\t\t\t\t\t\t\t(lcn + bmp_pos));\n\t\t\t\trl2 = ntfs_malloc_nofs(rlsize + (int)PAGE_SIZE);\n\t\t\t\tif (unlikely(!rl2)) {\n\t\t\t\t\terr = -ENOMEM;\n\t\t\t\t\tntfs_error(vol->sb, \"Failed to \"\n\t\t\t\t\t\t\t\"allocate memory.\");\n\t\t\t\t\tgoto out;\n\t\t\t\t}\n\t\t\t\tmemcpy(rl2, rl, rlsize);\n\t\t\t\tntfs_free(rl);\n\t\t\t\trl = rl2;\n\t\t\t\trlsize += PAGE_SIZE;\n\t\t\t\tntfs_debug(\"Reallocated memory, rlsize 0x%x.\",\n\t\t\t\t\t\trlsize);\n\t\t\t}\n\t\t\t/* Allocate the bitmap bit. */\n\t\t\t*byte |= bit;\n\t\t\t/* We need to write this bitmap page to disk. */\n\t\t\tneed_writeback = 1;\n\t\t\tntfs_debug(\"*byte 0x%x, need_writeback is set.\",\n\t\t\t\t\t(unsigned int)*byte);\n\t\t\t/*\n\t\t\t * Coalesce with previous run if adjacent LCNs.\n\t\t\t * Otherwise, append a new run.\n\t\t\t */\n\t\t\tntfs_debug(\"Adding run (lcn 0x%llx, len 0x%llx), \"\n\t\t\t\t\t\"prev_lcn 0x%llx, lcn 0x%llx, \"\n\t\t\t\t\t\"bmp_pos 0x%llx, prev_run_len 0x%llx, \"\n\t\t\t\t\t\"rlpos %i.\",\n\t\t\t\t\t(unsigned long long)(lcn + bmp_pos),\n\t\t\t\t\t1ULL, (unsigned long long)prev_lcn,\n\t\t\t\t\t(unsigned long long)lcn,\n\t\t\t\t\t(unsigned long long)bmp_pos,\n\t\t\t\t\t(unsigned long long)prev_run_len,\n\t\t\t\t\trlpos);\n\t\t\tif (prev_lcn == lcn + bmp_pos - prev_run_len && rlpos) {\n\t\t\t\tntfs_debug(\"Coalescing to run (lcn 0x%llx, \"\n\t\t\t\t\t\t\"len 0x%llx).\",\n\t\t\t\t\t\t(unsigned long long)\n\t\t\t\t\t\trl[rlpos - 1].lcn,\n\t\t\t\t\t\t(unsigned long long)\n\t\t\t\t\t\trl[rlpos - 1].length);\n\t\t\t\trl[rlpos - 1].length = ++prev_run_len;\n\t\t\t\tntfs_debug(\"Run now (lcn 0x%llx, len 0x%llx), \"\n\t\t\t\t\t\t\"prev_run_len 0x%llx.\",\n\t\t\t\t\t\t(unsigned long long)\n\t\t\t\t\t\trl[rlpos - 1].lcn,\n\t\t\t\t\t\t(unsigned long long)\n\t\t\t\t\t\trl[rlpos - 1].length,\n\t\t\t\t\t\t(unsigned long long)\n\t\t\t\t\t\tprev_run_len);\n\t\t\t} else {\n\t\t\t\tif (likely(rlpos)) {\n\t\t\t\t\tntfs_debug(\"Adding new run, (previous \"\n\t\t\t\t\t\t\t\"run lcn 0x%llx, \"\n\t\t\t\t\t\t\t\"len 0x%llx).\",\n\t\t\t\t\t\t\t(unsigned long long)\n\t\t\t\t\t\t\trl[rlpos - 1].lcn,\n\t\t\t\t\t\t\t(unsigned long long)\n\t\t\t\t\t\t\trl[rlpos - 1].length);\n\t\t\t\t\trl[rlpos].vcn = rl[rlpos - 1].vcn +\n\t\t\t\t\t\t\tprev_run_len;\n\t\t\t\t} else {\n\t\t\t\t\tntfs_debug(\"Adding new run, is first \"\n\t\t\t\t\t\t\t\"run.\");\n\t\t\t\t\trl[rlpos].vcn = start_vcn;\n\t\t\t\t}\n\t\t\t\trl[rlpos].lcn = prev_lcn = lcn + bmp_pos;\n\t\t\t\trl[rlpos].length = prev_run_len = 1;\n\t\t\t\trlpos++;\n\t\t\t}\n\t\t\t/* Done? */\n\t\t\tif (!--clusters) {\n\t\t\t\tLCN tc;\n\t\t\t\t/*\n\t\t\t\t * Update the current zone position.  Positions\n\t\t\t\t * of already scanned zones have been updated\n\t\t\t\t * during the respective zone switches.\n\t\t\t\t */\n\t\t\t\ttc = lcn + bmp_pos + 1;\n\t\t\t\tntfs_debug(\"Done. Updating current zone \"\n\t\t\t\t\t\t\"position, tc 0x%llx, \"\n\t\t\t\t\t\t\"search_zone %i.\",\n\t\t\t\t\t\t(unsigned long long)tc,\n\t\t\t\t\t\tsearch_zone);\n\t\t\t\tswitch (search_zone) {\n\t\t\t\tcase 1:\n\t\t\t\t\tntfs_debug(\"Before checks, \"\n\t\t\t\t\t\t\t\"vol->mft_zone_pos \"\n\t\t\t\t\t\t\t\"0x%llx.\",\n\t\t\t\t\t\t\t(unsigned long long)\n\t\t\t\t\t\t\tvol->mft_zone_pos);\n\t\t\t\t\tif (tc >= vol->mft_zone_end) {\n\t\t\t\t\t\tvol->mft_zone_pos =\n\t\t\t\t\t\t\t\tvol->mft_lcn;\n\t\t\t\t\t\tif (!vol->mft_zone_end)\n\t\t\t\t\t\t\tvol->mft_zone_pos = 0;\n\t\t\t\t\t} else if ((bmp_initial_pos >=\n\t\t\t\t\t\t\tvol->mft_zone_pos ||\n\t\t\t\t\t\t\ttc > vol->mft_zone_pos)\n\t\t\t\t\t\t\t&& tc >= vol->mft_lcn)\n\t\t\t\t\t\tvol->mft_zone_pos = tc;\n\t\t\t\t\tntfs_debug(\"After checks, \"\n\t\t\t\t\t\t\t\"vol->mft_zone_pos \"\n\t\t\t\t\t\t\t\"0x%llx.\",\n\t\t\t\t\t\t\t(unsigned long long)\n\t\t\t\t\t\t\tvol->mft_zone_pos);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 2:\n\t\t\t\t\tntfs_debug(\"Before checks, \"\n\t\t\t\t\t\t\t\"vol->data1_zone_pos \"\n\t\t\t\t\t\t\t\"0x%llx.\",\n\t\t\t\t\t\t\t(unsigned long long)\n\t\t\t\t\t\t\tvol->data1_zone_pos);\n\t\t\t\t\tif (tc >= vol->nr_clusters)\n\t\t\t\t\t\tvol->data1_zone_pos =\n\t\t\t\t\t\t\t     vol->mft_zone_end;\n\t\t\t\t\telse if ((bmp_initial_pos >=\n\t\t\t\t\t\t    vol->data1_zone_pos ||\n\t\t\t\t\t\t    tc > vol->data1_zone_pos)\n\t\t\t\t\t\t    && tc >= vol->mft_zone_end)\n\t\t\t\t\t\tvol->data1_zone_pos = tc;\n\t\t\t\t\tntfs_debug(\"After checks, \"\n\t\t\t\t\t\t\t\"vol->data1_zone_pos \"\n\t\t\t\t\t\t\t\"0x%llx.\",\n\t\t\t\t\t\t\t(unsigned long long)\n\t\t\t\t\t\t\tvol->data1_zone_pos);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 4:\n\t\t\t\t\tntfs_debug(\"Before checks, \"\n\t\t\t\t\t\t\t\"vol->data2_zone_pos \"\n\t\t\t\t\t\t\t\"0x%llx.\",\n\t\t\t\t\t\t\t(unsigned long long)\n\t\t\t\t\t\t\tvol->data2_zone_pos);\n\t\t\t\t\tif (tc >= vol->mft_zone_start)\n\t\t\t\t\t\tvol->data2_zone_pos = 0;\n\t\t\t\t\telse if (bmp_initial_pos >=\n\t\t\t\t\t\t      vol->data2_zone_pos ||\n\t\t\t\t\t\t      tc > vol->data2_zone_pos)\n\t\t\t\t\t\tvol->data2_zone_pos = tc;\n\t\t\t\t\tntfs_debug(\"After checks, \"\n\t\t\t\t\t\t\t\"vol->data2_zone_pos \"\n\t\t\t\t\t\t\t\"0x%llx.\",\n\t\t\t\t\t\t\t(unsigned long long)\n\t\t\t\t\t\t\tvol->data2_zone_pos);\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tBUG();\n\t\t\t\t}\n\t\t\t\tntfs_debug(\"Finished.  Going to out.\");\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tlcn++;\n\t\t}\n\t\tbmp_pos += buf_size;\n\t\tntfs_debug(\"After inner while loop: buf_size 0x%x, lcn \"\n\t\t\t\t\"0x%llx, bmp_pos 0x%llx, need_writeback %i.\",\n\t\t\t\tbuf_size, (unsigned long long)lcn,\n\t\t\t\t(unsigned long long)bmp_pos, need_writeback);\n\t\tif (bmp_pos < zone_end) {\n\t\t\tntfs_debug(\"Continuing outer while loop, \"\n\t\t\t\t\t\"bmp_pos 0x%llx, zone_end 0x%llx.\",\n\t\t\t\t\t(unsigned long long)bmp_pos,\n\t\t\t\t\t(unsigned long long)zone_end);\n\t\t\tcontinue;\n\t\t}\nzone_pass_done:\t/* Finished with the current zone pass. */\n\t\tntfs_debug(\"At zone_pass_done, pass %i.\", pass);\n\t\tif (pass == 1) {\n\t\t\t/*\n\t\t\t * Now do pass 2, scanning the first part of the zone\n\t\t\t * we omitted in pass 1.\n\t\t\t */\n\t\t\tpass = 2;\n\t\t\tzone_end = zone_start;\n\t\t\tswitch (search_zone) {\n\t\t\tcase 1: /* mft_zone */\n\t\t\t\tzone_start = vol->mft_zone_start;\n\t\t\t\tbreak;\n\t\t\tcase 2: /* data1_zone */\n\t\t\t\tzone_start = vol->mft_zone_end;\n\t\t\t\tbreak;\n\t\t\tcase 4: /* data2_zone */\n\t\t\t\tzone_start = 0;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tBUG();\n\t\t\t}\n\t\t\t/* Sanity check. */\n\t\t\tif (zone_end < zone_start)\n\t\t\t\tzone_end = zone_start;\n\t\t\tbmp_pos = zone_start;\n\t\t\tntfs_debug(\"Continuing outer while loop, pass 2, \"\n\t\t\t\t\t\"zone_start 0x%llx, zone_end 0x%llx, \"\n\t\t\t\t\t\"bmp_pos 0x%llx.\",\n\t\t\t\t\t(unsigned long long)zone_start,\n\t\t\t\t\t(unsigned long long)zone_end,\n\t\t\t\t\t(unsigned long long)bmp_pos);\n\t\t\tcontinue;\n\t\t} /* pass == 2 */\ndone_zones_check:\n\t\tntfs_debug(\"At done_zones_check, search_zone %i, done_zones \"\n\t\t\t\t\"before 0x%x, done_zones after 0x%x.\",\n\t\t\t\tsearch_zone, done_zones,\n\t\t\t\tdone_zones | search_zone);\n\t\tdone_zones |= search_zone;\n\t\tif (done_zones < 7) {\n\t\t\tntfs_debug(\"Switching zone.\");\n\t\t\t/* Now switch to the next zone we haven't done yet. */\n\t\t\tpass = 1;\n\t\t\tswitch (search_zone) {\n\t\t\tcase 1:\n\t\t\t\tntfs_debug(\"Switching from mft zone to data1 \"\n\t\t\t\t\t\t\"zone.\");\n\t\t\t\t/* Update mft zone position. */\n\t\t\t\tif (rlpos) {\n\t\t\t\t\tLCN tc;\n\n\t\t\t\t\tntfs_debug(\"Before checks, \"\n\t\t\t\t\t\t\t\"vol->mft_zone_pos \"\n\t\t\t\t\t\t\t\"0x%llx.\",\n\t\t\t\t\t\t\t(unsigned long long)\n\t\t\t\t\t\t\tvol->mft_zone_pos);\n\t\t\t\t\ttc = rl[rlpos - 1].lcn +\n\t\t\t\t\t\t\trl[rlpos - 1].length;\n\t\t\t\t\tif (tc >= vol->mft_zone_end) {\n\t\t\t\t\t\tvol->mft_zone_pos =\n\t\t\t\t\t\t\t\tvol->mft_lcn;\n\t\t\t\t\t\tif (!vol->mft_zone_end)\n\t\t\t\t\t\t\tvol->mft_zone_pos = 0;\n\t\t\t\t\t} else if ((bmp_initial_pos >=\n\t\t\t\t\t\t\tvol->mft_zone_pos ||\n\t\t\t\t\t\t\ttc > vol->mft_zone_pos)\n\t\t\t\t\t\t\t&& tc >= vol->mft_lcn)\n\t\t\t\t\t\tvol->mft_zone_pos = tc;\n\t\t\t\t\tntfs_debug(\"After checks, \"\n\t\t\t\t\t\t\t\"vol->mft_zone_pos \"\n\t\t\t\t\t\t\t\"0x%llx.\",\n\t\t\t\t\t\t\t(unsigned long long)\n\t\t\t\t\t\t\tvol->mft_zone_pos);\n\t\t\t\t}\n\t\t\t\t/* Switch from mft zone to data1 zone. */\nswitch_to_data1_zone:\t\tsearch_zone = 2;\n\t\t\t\tzone_start = bmp_initial_pos =\n\t\t\t\t\t\tvol->data1_zone_pos;\n\t\t\t\tzone_end = vol->nr_clusters;\n\t\t\t\tif (zone_start == vol->mft_zone_end)\n\t\t\t\t\tpass = 2;\n\t\t\t\tif (zone_start >= zone_end) {\n\t\t\t\t\tvol->data1_zone_pos = zone_start =\n\t\t\t\t\t\t\tvol->mft_zone_end;\n\t\t\t\t\tpass = 2;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 2:\n\t\t\t\tntfs_debug(\"Switching from data1 zone to \"\n\t\t\t\t\t\t\"data2 zone.\");\n\t\t\t\t/* Update data1 zone position. */\n\t\t\t\tif (rlpos) {\n\t\t\t\t\tLCN tc;\n\n\t\t\t\t\tntfs_debug(\"Before checks, \"\n\t\t\t\t\t\t\t\"vol->data1_zone_pos \"\n\t\t\t\t\t\t\t\"0x%llx.\",\n\t\t\t\t\t\t\t(unsigned long long)\n\t\t\t\t\t\t\tvol->data1_zone_pos);\n\t\t\t\t\ttc = rl[rlpos - 1].lcn +\n\t\t\t\t\t\t\trl[rlpos - 1].length;\n\t\t\t\t\tif (tc >= vol->nr_clusters)\n\t\t\t\t\t\tvol->data1_zone_pos =\n\t\t\t\t\t\t\t     vol->mft_zone_end;\n\t\t\t\t\telse if ((bmp_initial_pos >=\n\t\t\t\t\t\t    vol->data1_zone_pos ||\n\t\t\t\t\t\t    tc > vol->data1_zone_pos)\n\t\t\t\t\t\t    && tc >= vol->mft_zone_end)\n\t\t\t\t\t\tvol->data1_zone_pos = tc;\n\t\t\t\t\tntfs_debug(\"After checks, \"\n\t\t\t\t\t\t\t\"vol->data1_zone_pos \"\n\t\t\t\t\t\t\t\"0x%llx.\",\n\t\t\t\t\t\t\t(unsigned long long)\n\t\t\t\t\t\t\tvol->data1_zone_pos);\n\t\t\t\t}\n\t\t\t\t/* Switch from data1 zone to data2 zone. */\n\t\t\t\tsearch_zone = 4;\n\t\t\t\tzone_start = bmp_initial_pos =\n\t\t\t\t\t\tvol->data2_zone_pos;\n\t\t\t\tzone_end = vol->mft_zone_start;\n\t\t\t\tif (!zone_start)\n\t\t\t\t\tpass = 2;\n\t\t\t\tif (zone_start >= zone_end) {\n\t\t\t\t\tvol->data2_zone_pos = zone_start =\n\t\t\t\t\t\t\tbmp_initial_pos = 0;\n\t\t\t\t\tpass = 2;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 4:\n\t\t\t\tntfs_debug(\"Switching from data2 zone to \"\n\t\t\t\t\t\t\"data1 zone.\");\n\t\t\t\t/* Update data2 zone position. */\n\t\t\t\tif (rlpos) {\n\t\t\t\t\tLCN tc;\n\n\t\t\t\t\tntfs_debug(\"Before checks, \"\n\t\t\t\t\t\t\t\"vol->data2_zone_pos \"\n\t\t\t\t\t\t\t\"0x%llx.\",\n\t\t\t\t\t\t\t(unsigned long long)\n\t\t\t\t\t\t\tvol->data2_zone_pos);\n\t\t\t\t\ttc = rl[rlpos - 1].lcn +\n\t\t\t\t\t\t\trl[rlpos - 1].length;\n\t\t\t\t\tif (tc >= vol->mft_zone_start)\n\t\t\t\t\t\tvol->data2_zone_pos = 0;\n\t\t\t\t\telse if (bmp_initial_pos >=\n\t\t\t\t\t\t      vol->data2_zone_pos ||\n\t\t\t\t\t\t      tc > vol->data2_zone_pos)\n\t\t\t\t\t\tvol->data2_zone_pos = tc;\n\t\t\t\t\tntfs_debug(\"After checks, \"\n\t\t\t\t\t\t\t\"vol->data2_zone_pos \"\n\t\t\t\t\t\t\t\"0x%llx.\",\n\t\t\t\t\t\t\t(unsigned long long)\n\t\t\t\t\t\t\tvol->data2_zone_pos);\n\t\t\t\t}\n\t\t\t\t/* Switch from data2 zone to data1 zone. */\n\t\t\t\tgoto switch_to_data1_zone;\n\t\t\tdefault:\n\t\t\t\tBUG();\n\t\t\t}\n\t\t\tntfs_debug(\"After zone switch, search_zone %i, \"\n\t\t\t\t\t\"pass %i, bmp_initial_pos 0x%llx, \"\n\t\t\t\t\t\"zone_start 0x%llx, zone_end 0x%llx.\",\n\t\t\t\t\tsearch_zone, pass,\n\t\t\t\t\t(unsigned long long)bmp_initial_pos,\n\t\t\t\t\t(unsigned long long)zone_start,\n\t\t\t\t\t(unsigned long long)zone_end);\n\t\t\tbmp_pos = zone_start;\n\t\t\tif (zone_start == zone_end) {\n\t\t\t\tntfs_debug(\"Empty zone, going to \"\n\t\t\t\t\t\t\"done_zones_check.\");\n\t\t\t\t/* Empty zone. Don't bother searching it. */\n\t\t\t\tgoto done_zones_check;\n\t\t\t}\n\t\t\tntfs_debug(\"Continuing outer while loop.\");\n\t\t\tcontinue;\n\t\t} /* done_zones == 7 */\n\t\tntfs_debug(\"All zones are finished.\");\n\t\t/*\n\t\t * All zones are finished!  If DATA_ZONE, shrink mft zone.  If\n\t\t * MFT_ZONE, we have really run out of space.\n\t\t */\n\t\tmft_zone_size = vol->mft_zone_end - vol->mft_zone_start;\n\t\tntfs_debug(\"vol->mft_zone_start 0x%llx, vol->mft_zone_end \"\n\t\t\t\t\"0x%llx, mft_zone_size 0x%llx.\",\n\t\t\t\t(unsigned long long)vol->mft_zone_start,\n\t\t\t\t(unsigned long long)vol->mft_zone_end,\n\t\t\t\t(unsigned long long)mft_zone_size);\n\t\tif (zone == MFT_ZONE || mft_zone_size <= 0) {\n\t\t\tntfs_debug(\"No free clusters left, going to out.\");\n\t\t\t/* Really no more space left on device. */\n\t\t\terr = -ENOSPC;\n\t\t\tgoto out;\n\t\t} /* zone == DATA_ZONE && mft_zone_size > 0 */\n\t\tntfs_debug(\"Shrinking mft zone.\");\n\t\tzone_end = vol->mft_zone_end;\n\t\tmft_zone_size >>= 1;\n\t\tif (mft_zone_size > 0)\n\t\t\tvol->mft_zone_end = vol->mft_zone_start + mft_zone_size;\n\t\telse /* mft zone and data2 zone no longer exist. */\n\t\t\tvol->data2_zone_pos = vol->mft_zone_start =\n\t\t\t\t\tvol->mft_zone_end = 0;\n\t\tif (vol->mft_zone_pos >= vol->mft_zone_end) {\n\t\t\tvol->mft_zone_pos = vol->mft_lcn;\n\t\t\tif (!vol->mft_zone_end)\n\t\t\t\tvol->mft_zone_pos = 0;\n\t\t}\n\t\tbmp_pos = zone_start = bmp_initial_pos =\n\t\t\t\tvol->data1_zone_pos = vol->mft_zone_end;\n\t\tsearch_zone = 2;\n\t\tpass = 2;\n\t\tdone_zones &= ~2;\n\t\tntfs_debug(\"After shrinking mft zone, mft_zone_size 0x%llx, \"\n\t\t\t\t\"vol->mft_zone_start 0x%llx, \"\n\t\t\t\t\"vol->mft_zone_end 0x%llx, \"\n\t\t\t\t\"vol->mft_zone_pos 0x%llx, search_zone 2, \"\n\t\t\t\t\"pass 2, dones_zones 0x%x, zone_start 0x%llx, \"\n\t\t\t\t\"zone_end 0x%llx, vol->data1_zone_pos 0x%llx, \"\n\t\t\t\t\"continuing outer while loop.\",\n\t\t\t\t(unsigned long long)mft_zone_size,\n\t\t\t\t(unsigned long long)vol->mft_zone_start,\n\t\t\t\t(unsigned long long)vol->mft_zone_end,\n\t\t\t\t(unsigned long long)vol->mft_zone_pos,\n\t\t\t\tdone_zones, (unsigned long long)zone_start,\n\t\t\t\t(unsigned long long)zone_end,\n\t\t\t\t(unsigned long long)vol->data1_zone_pos);\n\t}\n\tntfs_debug(\"After outer while loop.\");\nout:\n\tntfs_debug(\"At out.\");\n\t/* Add runlist terminator element. */\n\tif (likely(rl)) {\n\t\trl[rlpos].vcn = rl[rlpos - 1].vcn + rl[rlpos - 1].length;\n\t\trl[rlpos].lcn = is_extension ? LCN_ENOENT : LCN_RL_NOT_MAPPED;\n\t\trl[rlpos].length = 0;\n\t}\n\tif (likely(page && !IS_ERR(page))) {\n\t\tif (need_writeback) {\n\t\t\tntfs_debug(\"Marking page dirty.\");\n\t\t\tflush_dcache_page(page);\n\t\t\tset_page_dirty(page);\n\t\t\tneed_writeback = 0;\n\t\t}\n\t\tntfs_unmap_page(page);\n\t}\n\tif (likely(!err)) {\n\t\tup_write(&vol->lcnbmp_lock);\n\t\tntfs_debug(\"Done.\");\n\t\treturn rl;\n\t}\n\tntfs_error(vol->sb, \"Failed to allocate clusters, aborting \"\n\t\t\t\"(error %i).\", err);\n\tif (rl) {\n\t\tint err2;\n\n\t\tif (err == -ENOSPC)\n\t\t\tntfs_debug(\"Not enough space to complete allocation, \"\n\t\t\t\t\t\"err -ENOSPC, first free lcn 0x%llx, \"\n\t\t\t\t\t\"could allocate up to 0x%llx \"\n\t\t\t\t\t\"clusters.\",\n\t\t\t\t\t(unsigned long long)rl[0].lcn,\n\t\t\t\t\t(unsigned long long)(count - clusters));\n\t\t/* Deallocate all allocated clusters. */\n\t\tntfs_debug(\"Attempting rollback...\");\n\t\terr2 = ntfs_cluster_free_from_rl_nolock(vol, rl);\n\t\tif (err2) {\n\t\t\tntfs_error(vol->sb, \"Failed to rollback (error %i).  \"\n\t\t\t\t\t\"Leaving inconsistent metadata!  \"\n\t\t\t\t\t\"Unmount and run chkdsk.\", err2);\n\t\t\tNVolSetErrors(vol);\n\t\t}\n\t\t/* Free the runlist. */\n\t\tntfs_free(rl);\n\t} else if (err == -ENOSPC)\n\t\tntfs_debug(\"No space left at all, err = -ENOSPC, first free \"\n\t\t\t\t\"lcn = 0x%llx.\",\n\t\t\t\t(long long)vol->data1_zone_pos);\n\tup_write(&vol->lcnbmp_lock);\n\treturn ERR_PTR(err);\n}",
          "includes": [
            "#include \"ntfs.h\"",
            "#include \"aops.h\"",
            "#include \"malloc.h\"",
            "#include \"attrib.h\"",
            "#include \"volume.h\"",
            "#include \"inode.h\"",
            "#include \"bitmap.h\"",
            "#include \"debug.h\"",
            "#include \"lcnalloc.h\"",
            "#include <linux/pagemap.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ntfs.h\"\n#include \"aops.h\"\n#include \"malloc.h\"\n#include \"attrib.h\"\n#include \"volume.h\"\n#include \"inode.h\"\n#include \"bitmap.h\"\n#include \"debug.h\"\n#include \"lcnalloc.h\"\n#include <linux/pagemap.h>\n\nrunlist_element *ntfs_cluster_alloc(ntfs_volume *vol, const VCN start_vcn,\n\t\tconst s64 count, const LCN start_lcn,\n\t\tconst NTFS_CLUSTER_ALLOCATION_ZONES zone,\n\t\tconst bool is_extension)\n{\n\tLCN zone_start, zone_end, bmp_pos, bmp_initial_pos, last_read_pos, lcn;\n\tLCN prev_lcn = 0, prev_run_len = 0, mft_zone_size;\n\ts64 clusters;\n\tloff_t i_size;\n\tstruct inode *lcnbmp_vi;\n\trunlist_element *rl = NULL;\n\tstruct address_space *mapping;\n\tstruct page *page = NULL;\n\tu8 *buf, *byte;\n\tint err = 0, rlpos, rlsize, buf_size;\n\tu8 pass, done_zones, search_zone, need_writeback = 0, bit;\n\n\tntfs_debug(\"Entering for start_vcn 0x%llx, count 0x%llx, start_lcn \"\n\t\t\t\"0x%llx, zone %s_ZONE.\", (unsigned long long)start_vcn,\n\t\t\t(unsigned long long)count,\n\t\t\t(unsigned long long)start_lcn,\n\t\t\tzone == MFT_ZONE ? \"MFT\" : \"DATA\");\n\tBUG_ON(!vol);\n\tlcnbmp_vi = vol->lcnbmp_ino;\n\tBUG_ON(!lcnbmp_vi);\n\tBUG_ON(start_vcn < 0);\n\tBUG_ON(count < 0);\n\tBUG_ON(start_lcn < -1);\n\tBUG_ON(zone < FIRST_ZONE);\n\tBUG_ON(zone > LAST_ZONE);\n\n\t/* Return NULL if @count is zero. */\n\tif (!count)\n\t\treturn NULL;\n\t/* Take the lcnbmp lock for writing. */\n\tdown_write(&vol->lcnbmp_lock);\n\t/*\n\t * If no specific @start_lcn was requested, use the current data zone\n\t * position, otherwise use the requested @start_lcn but make sure it\n\t * lies outside the mft zone.  Also set done_zones to 0 (no zones done)\n\t * and pass depending on whether we are starting inside a zone (1) or\n\t * at the beginning of a zone (2).  If requesting from the MFT_ZONE,\n\t * we either start at the current position within the mft zone or at\n\t * the specified position.  If the latter is out of bounds then we start\n\t * at the beginning of the MFT_ZONE.\n\t */\n\tdone_zones = 0;\n\tpass = 1;\n\t/*\n\t * zone_start and zone_end are the current search range.  search_zone\n\t * is 1 for mft zone, 2 for data zone 1 (end of mft zone till end of\n\t * volume) and 4 for data zone 2 (start of volume till start of mft\n\t * zone).\n\t */\n\tzone_start = start_lcn;\n\tif (zone_start < 0) {\n\t\tif (zone == DATA_ZONE)\n\t\t\tzone_start = vol->data1_zone_pos;\n\t\telse\n\t\t\tzone_start = vol->mft_zone_pos;\n\t\tif (!zone_start) {\n\t\t\t/*\n\t\t\t * Zone starts at beginning of volume which means a\n\t\t\t * single pass is sufficient.\n\t\t\t */\n\t\t\tpass = 2;\n\t\t}\n\t} else if (zone == DATA_ZONE && zone_start >= vol->mft_zone_start &&\n\t\t\tzone_start < vol->mft_zone_end) {\n\t\tzone_start = vol->mft_zone_end;\n\t\t/*\n\t\t * Starting at beginning of data1_zone which means a single\n\t\t * pass in this zone is sufficient.\n\t\t */\n\t\tpass = 2;\n\t} else if (zone == MFT_ZONE && (zone_start < vol->mft_zone_start ||\n\t\t\tzone_start >= vol->mft_zone_end)) {\n\t\tzone_start = vol->mft_lcn;\n\t\tif (!vol->mft_zone_end)\n\t\t\tzone_start = 0;\n\t\t/*\n\t\t * Starting at beginning of volume which means a single pass\n\t\t * is sufficient.\n\t\t */\n\t\tpass = 2;\n\t}\n\tif (zone == MFT_ZONE) {\n\t\tzone_end = vol->mft_zone_end;\n\t\tsearch_zone = 1;\n\t} else /* if (zone == DATA_ZONE) */ {\n\t\t/* Skip searching the mft zone. */\n\t\tdone_zones |= 1;\n\t\tif (zone_start >= vol->mft_zone_end) {\n\t\t\tzone_end = vol->nr_clusters;\n\t\t\tsearch_zone = 2;\n\t\t} else {\n\t\t\tzone_end = vol->mft_zone_start;\n\t\t\tsearch_zone = 4;\n\t\t}\n\t}\n\t/*\n\t * bmp_pos is the current bit position inside the bitmap.  We use\n\t * bmp_initial_pos to determine whether or not to do a zone switch.\n\t */\n\tbmp_pos = bmp_initial_pos = zone_start;\n\n\t/* Loop until all clusters are allocated, i.e. clusters == 0. */\n\tclusters = count;\n\trlpos = rlsize = 0;\n\tmapping = lcnbmp_vi->i_mapping;\n\ti_size = i_size_read(lcnbmp_vi);\n\twhile (1) {\n\t\tntfs_debug(\"Start of outer while loop: done_zones 0x%x, \"\n\t\t\t\t\"search_zone %i, pass %i, zone_start 0x%llx, \"\n\t\t\t\t\"zone_end 0x%llx, bmp_initial_pos 0x%llx, \"\n\t\t\t\t\"bmp_pos 0x%llx, rlpos %i, rlsize %i.\",\n\t\t\t\tdone_zones, search_zone, pass,\n\t\t\t\t(unsigned long long)zone_start,\n\t\t\t\t(unsigned long long)zone_end,\n\t\t\t\t(unsigned long long)bmp_initial_pos,\n\t\t\t\t(unsigned long long)bmp_pos, rlpos, rlsize);\n\t\t/* Loop until we run out of free clusters. */\n\t\tlast_read_pos = bmp_pos >> 3;\n\t\tntfs_debug(\"last_read_pos 0x%llx.\",\n\t\t\t\t(unsigned long long)last_read_pos);\n\t\tif (last_read_pos > i_size) {\n\t\t\tntfs_debug(\"End of attribute reached.  \"\n\t\t\t\t\t\"Skipping to zone_pass_done.\");\n\t\t\tgoto zone_pass_done;\n\t\t}\n\t\tif (likely(page)) {\n\t\t\tif (need_writeback) {\n\t\t\t\tntfs_debug(\"Marking page dirty.\");\n\t\t\t\tflush_dcache_page(page);\n\t\t\t\tset_page_dirty(page);\n\t\t\t\tneed_writeback = 0;\n\t\t\t}\n\t\t\tntfs_unmap_page(page);\n\t\t}\n\t\tpage = ntfs_map_page(mapping, last_read_pos >>\n\t\t\t\tPAGE_CACHE_SHIFT);\n\t\tif (IS_ERR(page)) {\n\t\t\terr = PTR_ERR(page);\n\t\t\tntfs_error(vol->sb, \"Failed to map page.\");\n\t\t\tgoto out;\n\t\t}\n\t\tbuf_size = last_read_pos & ~PAGE_CACHE_MASK;\n\t\tbuf = page_address(page) + buf_size;\n\t\tbuf_size = PAGE_CACHE_SIZE - buf_size;\n\t\tif (unlikely(last_read_pos + buf_size > i_size))\n\t\t\tbuf_size = i_size - last_read_pos;\n\t\tbuf_size <<= 3;\n\t\tlcn = bmp_pos & 7;\n\t\tbmp_pos &= ~(LCN)7;\n\t\tntfs_debug(\"Before inner while loop: buf_size %i, lcn 0x%llx, \"\n\t\t\t\t\"bmp_pos 0x%llx, need_writeback %i.\", buf_size,\n\t\t\t\t(unsigned long long)lcn,\n\t\t\t\t(unsigned long long)bmp_pos, need_writeback);\n\t\twhile (lcn < buf_size && lcn + bmp_pos < zone_end) {\n\t\t\tbyte = buf + (lcn >> 3);\n\t\t\tntfs_debug(\"In inner while loop: buf_size %i, \"\n\t\t\t\t\t\"lcn 0x%llx, bmp_pos 0x%llx, \"\n\t\t\t\t\t\"need_writeback %i, byte ofs 0x%x, \"\n\t\t\t\t\t\"*byte 0x%x.\", buf_size,\n\t\t\t\t\t(unsigned long long)lcn,\n\t\t\t\t\t(unsigned long long)bmp_pos,\n\t\t\t\t\tneed_writeback,\n\t\t\t\t\t(unsigned int)(lcn >> 3),\n\t\t\t\t\t(unsigned int)*byte);\n\t\t\t/* Skip full bytes. */\n\t\t\tif (*byte == 0xff) {\n\t\t\t\tlcn = (lcn + 8) & ~(LCN)7;\n\t\t\t\tntfs_debug(\"Continuing while loop 1.\");\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tbit = 1 << (lcn & 7);\n\t\t\tntfs_debug(\"bit 0x%x.\", bit);\n\t\t\t/* If the bit is already set, go onto the next one. */\n\t\t\tif (*byte & bit) {\n\t\t\t\tlcn++;\n\t\t\t\tntfs_debug(\"Continuing while loop 2.\");\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t/*\n\t\t\t * Allocate more memory if needed, including space for\n\t\t\t * the terminator element.\n\t\t\t * ntfs_malloc_nofs() operates on whole pages only.\n\t\t\t */\n\t\t\tif ((rlpos + 2) * sizeof(*rl) > rlsize) {\n\t\t\t\trunlist_element *rl2;\n\n\t\t\t\tntfs_debug(\"Reallocating memory.\");\n\t\t\t\tif (!rl)\n\t\t\t\t\tntfs_debug(\"First free bit is at LCN \"\n\t\t\t\t\t\t\t\"0x%llx.\",\n\t\t\t\t\t\t\t(unsigned long long)\n\t\t\t\t\t\t\t(lcn + bmp_pos));\n\t\t\t\trl2 = ntfs_malloc_nofs(rlsize + (int)PAGE_SIZE);\n\t\t\t\tif (unlikely(!rl2)) {\n\t\t\t\t\terr = -ENOMEM;\n\t\t\t\t\tntfs_error(vol->sb, \"Failed to \"\n\t\t\t\t\t\t\t\"allocate memory.\");\n\t\t\t\t\tgoto out;\n\t\t\t\t}\n\t\t\t\tmemcpy(rl2, rl, rlsize);\n\t\t\t\tntfs_free(rl);\n\t\t\t\trl = rl2;\n\t\t\t\trlsize += PAGE_SIZE;\n\t\t\t\tntfs_debug(\"Reallocated memory, rlsize 0x%x.\",\n\t\t\t\t\t\trlsize);\n\t\t\t}\n\t\t\t/* Allocate the bitmap bit. */\n\t\t\t*byte |= bit;\n\t\t\t/* We need to write this bitmap page to disk. */\n\t\t\tneed_writeback = 1;\n\t\t\tntfs_debug(\"*byte 0x%x, need_writeback is set.\",\n\t\t\t\t\t(unsigned int)*byte);\n\t\t\t/*\n\t\t\t * Coalesce with previous run if adjacent LCNs.\n\t\t\t * Otherwise, append a new run.\n\t\t\t */\n\t\t\tntfs_debug(\"Adding run (lcn 0x%llx, len 0x%llx), \"\n\t\t\t\t\t\"prev_lcn 0x%llx, lcn 0x%llx, \"\n\t\t\t\t\t\"bmp_pos 0x%llx, prev_run_len 0x%llx, \"\n\t\t\t\t\t\"rlpos %i.\",\n\t\t\t\t\t(unsigned long long)(lcn + bmp_pos),\n\t\t\t\t\t1ULL, (unsigned long long)prev_lcn,\n\t\t\t\t\t(unsigned long long)lcn,\n\t\t\t\t\t(unsigned long long)bmp_pos,\n\t\t\t\t\t(unsigned long long)prev_run_len,\n\t\t\t\t\trlpos);\n\t\t\tif (prev_lcn == lcn + bmp_pos - prev_run_len && rlpos) {\n\t\t\t\tntfs_debug(\"Coalescing to run (lcn 0x%llx, \"\n\t\t\t\t\t\t\"len 0x%llx).\",\n\t\t\t\t\t\t(unsigned long long)\n\t\t\t\t\t\trl[rlpos - 1].lcn,\n\t\t\t\t\t\t(unsigned long long)\n\t\t\t\t\t\trl[rlpos - 1].length);\n\t\t\t\trl[rlpos - 1].length = ++prev_run_len;\n\t\t\t\tntfs_debug(\"Run now (lcn 0x%llx, len 0x%llx), \"\n\t\t\t\t\t\t\"prev_run_len 0x%llx.\",\n\t\t\t\t\t\t(unsigned long long)\n\t\t\t\t\t\trl[rlpos - 1].lcn,\n\t\t\t\t\t\t(unsigned long long)\n\t\t\t\t\t\trl[rlpos - 1].length,\n\t\t\t\t\t\t(unsigned long long)\n\t\t\t\t\t\tprev_run_len);\n\t\t\t} else {\n\t\t\t\tif (likely(rlpos)) {\n\t\t\t\t\tntfs_debug(\"Adding new run, (previous \"\n\t\t\t\t\t\t\t\"run lcn 0x%llx, \"\n\t\t\t\t\t\t\t\"len 0x%llx).\",\n\t\t\t\t\t\t\t(unsigned long long)\n\t\t\t\t\t\t\trl[rlpos - 1].lcn,\n\t\t\t\t\t\t\t(unsigned long long)\n\t\t\t\t\t\t\trl[rlpos - 1].length);\n\t\t\t\t\trl[rlpos].vcn = rl[rlpos - 1].vcn +\n\t\t\t\t\t\t\tprev_run_len;\n\t\t\t\t} else {\n\t\t\t\t\tntfs_debug(\"Adding new run, is first \"\n\t\t\t\t\t\t\t\"run.\");\n\t\t\t\t\trl[rlpos].vcn = start_vcn;\n\t\t\t\t}\n\t\t\t\trl[rlpos].lcn = prev_lcn = lcn + bmp_pos;\n\t\t\t\trl[rlpos].length = prev_run_len = 1;\n\t\t\t\trlpos++;\n\t\t\t}\n\t\t\t/* Done? */\n\t\t\tif (!--clusters) {\n\t\t\t\tLCN tc;\n\t\t\t\t/*\n\t\t\t\t * Update the current zone position.  Positions\n\t\t\t\t * of already scanned zones have been updated\n\t\t\t\t * during the respective zone switches.\n\t\t\t\t */\n\t\t\t\ttc = lcn + bmp_pos + 1;\n\t\t\t\tntfs_debug(\"Done. Updating current zone \"\n\t\t\t\t\t\t\"position, tc 0x%llx, \"\n\t\t\t\t\t\t\"search_zone %i.\",\n\t\t\t\t\t\t(unsigned long long)tc,\n\t\t\t\t\t\tsearch_zone);\n\t\t\t\tswitch (search_zone) {\n\t\t\t\tcase 1:\n\t\t\t\t\tntfs_debug(\"Before checks, \"\n\t\t\t\t\t\t\t\"vol->mft_zone_pos \"\n\t\t\t\t\t\t\t\"0x%llx.\",\n\t\t\t\t\t\t\t(unsigned long long)\n\t\t\t\t\t\t\tvol->mft_zone_pos);\n\t\t\t\t\tif (tc >= vol->mft_zone_end) {\n\t\t\t\t\t\tvol->mft_zone_pos =\n\t\t\t\t\t\t\t\tvol->mft_lcn;\n\t\t\t\t\t\tif (!vol->mft_zone_end)\n\t\t\t\t\t\t\tvol->mft_zone_pos = 0;\n\t\t\t\t\t} else if ((bmp_initial_pos >=\n\t\t\t\t\t\t\tvol->mft_zone_pos ||\n\t\t\t\t\t\t\ttc > vol->mft_zone_pos)\n\t\t\t\t\t\t\t&& tc >= vol->mft_lcn)\n\t\t\t\t\t\tvol->mft_zone_pos = tc;\n\t\t\t\t\tntfs_debug(\"After checks, \"\n\t\t\t\t\t\t\t\"vol->mft_zone_pos \"\n\t\t\t\t\t\t\t\"0x%llx.\",\n\t\t\t\t\t\t\t(unsigned long long)\n\t\t\t\t\t\t\tvol->mft_zone_pos);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 2:\n\t\t\t\t\tntfs_debug(\"Before checks, \"\n\t\t\t\t\t\t\t\"vol->data1_zone_pos \"\n\t\t\t\t\t\t\t\"0x%llx.\",\n\t\t\t\t\t\t\t(unsigned long long)\n\t\t\t\t\t\t\tvol->data1_zone_pos);\n\t\t\t\t\tif (tc >= vol->nr_clusters)\n\t\t\t\t\t\tvol->data1_zone_pos =\n\t\t\t\t\t\t\t     vol->mft_zone_end;\n\t\t\t\t\telse if ((bmp_initial_pos >=\n\t\t\t\t\t\t    vol->data1_zone_pos ||\n\t\t\t\t\t\t    tc > vol->data1_zone_pos)\n\t\t\t\t\t\t    && tc >= vol->mft_zone_end)\n\t\t\t\t\t\tvol->data1_zone_pos = tc;\n\t\t\t\t\tntfs_debug(\"After checks, \"\n\t\t\t\t\t\t\t\"vol->data1_zone_pos \"\n\t\t\t\t\t\t\t\"0x%llx.\",\n\t\t\t\t\t\t\t(unsigned long long)\n\t\t\t\t\t\t\tvol->data1_zone_pos);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 4:\n\t\t\t\t\tntfs_debug(\"Before checks, \"\n\t\t\t\t\t\t\t\"vol->data2_zone_pos \"\n\t\t\t\t\t\t\t\"0x%llx.\",\n\t\t\t\t\t\t\t(unsigned long long)\n\t\t\t\t\t\t\tvol->data2_zone_pos);\n\t\t\t\t\tif (tc >= vol->mft_zone_start)\n\t\t\t\t\t\tvol->data2_zone_pos = 0;\n\t\t\t\t\telse if (bmp_initial_pos >=\n\t\t\t\t\t\t      vol->data2_zone_pos ||\n\t\t\t\t\t\t      tc > vol->data2_zone_pos)\n\t\t\t\t\t\tvol->data2_zone_pos = tc;\n\t\t\t\t\tntfs_debug(\"After checks, \"\n\t\t\t\t\t\t\t\"vol->data2_zone_pos \"\n\t\t\t\t\t\t\t\"0x%llx.\",\n\t\t\t\t\t\t\t(unsigned long long)\n\t\t\t\t\t\t\tvol->data2_zone_pos);\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tBUG();\n\t\t\t\t}\n\t\t\t\tntfs_debug(\"Finished.  Going to out.\");\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tlcn++;\n\t\t}\n\t\tbmp_pos += buf_size;\n\t\tntfs_debug(\"After inner while loop: buf_size 0x%x, lcn \"\n\t\t\t\t\"0x%llx, bmp_pos 0x%llx, need_writeback %i.\",\n\t\t\t\tbuf_size, (unsigned long long)lcn,\n\t\t\t\t(unsigned long long)bmp_pos, need_writeback);\n\t\tif (bmp_pos < zone_end) {\n\t\t\tntfs_debug(\"Continuing outer while loop, \"\n\t\t\t\t\t\"bmp_pos 0x%llx, zone_end 0x%llx.\",\n\t\t\t\t\t(unsigned long long)bmp_pos,\n\t\t\t\t\t(unsigned long long)zone_end);\n\t\t\tcontinue;\n\t\t}\nzone_pass_done:\t/* Finished with the current zone pass. */\n\t\tntfs_debug(\"At zone_pass_done, pass %i.\", pass);\n\t\tif (pass == 1) {\n\t\t\t/*\n\t\t\t * Now do pass 2, scanning the first part of the zone\n\t\t\t * we omitted in pass 1.\n\t\t\t */\n\t\t\tpass = 2;\n\t\t\tzone_end = zone_start;\n\t\t\tswitch (search_zone) {\n\t\t\tcase 1: /* mft_zone */\n\t\t\t\tzone_start = vol->mft_zone_start;\n\t\t\t\tbreak;\n\t\t\tcase 2: /* data1_zone */\n\t\t\t\tzone_start = vol->mft_zone_end;\n\t\t\t\tbreak;\n\t\t\tcase 4: /* data2_zone */\n\t\t\t\tzone_start = 0;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tBUG();\n\t\t\t}\n\t\t\t/* Sanity check. */\n\t\t\tif (zone_end < zone_start)\n\t\t\t\tzone_end = zone_start;\n\t\t\tbmp_pos = zone_start;\n\t\t\tntfs_debug(\"Continuing outer while loop, pass 2, \"\n\t\t\t\t\t\"zone_start 0x%llx, zone_end 0x%llx, \"\n\t\t\t\t\t\"bmp_pos 0x%llx.\",\n\t\t\t\t\t(unsigned long long)zone_start,\n\t\t\t\t\t(unsigned long long)zone_end,\n\t\t\t\t\t(unsigned long long)bmp_pos);\n\t\t\tcontinue;\n\t\t} /* pass == 2 */\ndone_zones_check:\n\t\tntfs_debug(\"At done_zones_check, search_zone %i, done_zones \"\n\t\t\t\t\"before 0x%x, done_zones after 0x%x.\",\n\t\t\t\tsearch_zone, done_zones,\n\t\t\t\tdone_zones | search_zone);\n\t\tdone_zones |= search_zone;\n\t\tif (done_zones < 7) {\n\t\t\tntfs_debug(\"Switching zone.\");\n\t\t\t/* Now switch to the next zone we haven't done yet. */\n\t\t\tpass = 1;\n\t\t\tswitch (search_zone) {\n\t\t\tcase 1:\n\t\t\t\tntfs_debug(\"Switching from mft zone to data1 \"\n\t\t\t\t\t\t\"zone.\");\n\t\t\t\t/* Update mft zone position. */\n\t\t\t\tif (rlpos) {\n\t\t\t\t\tLCN tc;\n\n\t\t\t\t\tntfs_debug(\"Before checks, \"\n\t\t\t\t\t\t\t\"vol->mft_zone_pos \"\n\t\t\t\t\t\t\t\"0x%llx.\",\n\t\t\t\t\t\t\t(unsigned long long)\n\t\t\t\t\t\t\tvol->mft_zone_pos);\n\t\t\t\t\ttc = rl[rlpos - 1].lcn +\n\t\t\t\t\t\t\trl[rlpos - 1].length;\n\t\t\t\t\tif (tc >= vol->mft_zone_end) {\n\t\t\t\t\t\tvol->mft_zone_pos =\n\t\t\t\t\t\t\t\tvol->mft_lcn;\n\t\t\t\t\t\tif (!vol->mft_zone_end)\n\t\t\t\t\t\t\tvol->mft_zone_pos = 0;\n\t\t\t\t\t} else if ((bmp_initial_pos >=\n\t\t\t\t\t\t\tvol->mft_zone_pos ||\n\t\t\t\t\t\t\ttc > vol->mft_zone_pos)\n\t\t\t\t\t\t\t&& tc >= vol->mft_lcn)\n\t\t\t\t\t\tvol->mft_zone_pos = tc;\n\t\t\t\t\tntfs_debug(\"After checks, \"\n\t\t\t\t\t\t\t\"vol->mft_zone_pos \"\n\t\t\t\t\t\t\t\"0x%llx.\",\n\t\t\t\t\t\t\t(unsigned long long)\n\t\t\t\t\t\t\tvol->mft_zone_pos);\n\t\t\t\t}\n\t\t\t\t/* Switch from mft zone to data1 zone. */\nswitch_to_data1_zone:\t\tsearch_zone = 2;\n\t\t\t\tzone_start = bmp_initial_pos =\n\t\t\t\t\t\tvol->data1_zone_pos;\n\t\t\t\tzone_end = vol->nr_clusters;\n\t\t\t\tif (zone_start == vol->mft_zone_end)\n\t\t\t\t\tpass = 2;\n\t\t\t\tif (zone_start >= zone_end) {\n\t\t\t\t\tvol->data1_zone_pos = zone_start =\n\t\t\t\t\t\t\tvol->mft_zone_end;\n\t\t\t\t\tpass = 2;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 2:\n\t\t\t\tntfs_debug(\"Switching from data1 zone to \"\n\t\t\t\t\t\t\"data2 zone.\");\n\t\t\t\t/* Update data1 zone position. */\n\t\t\t\tif (rlpos) {\n\t\t\t\t\tLCN tc;\n\n\t\t\t\t\tntfs_debug(\"Before checks, \"\n\t\t\t\t\t\t\t\"vol->data1_zone_pos \"\n\t\t\t\t\t\t\t\"0x%llx.\",\n\t\t\t\t\t\t\t(unsigned long long)\n\t\t\t\t\t\t\tvol->data1_zone_pos);\n\t\t\t\t\ttc = rl[rlpos - 1].lcn +\n\t\t\t\t\t\t\trl[rlpos - 1].length;\n\t\t\t\t\tif (tc >= vol->nr_clusters)\n\t\t\t\t\t\tvol->data1_zone_pos =\n\t\t\t\t\t\t\t     vol->mft_zone_end;\n\t\t\t\t\telse if ((bmp_initial_pos >=\n\t\t\t\t\t\t    vol->data1_zone_pos ||\n\t\t\t\t\t\t    tc > vol->data1_zone_pos)\n\t\t\t\t\t\t    && tc >= vol->mft_zone_end)\n\t\t\t\t\t\tvol->data1_zone_pos = tc;\n\t\t\t\t\tntfs_debug(\"After checks, \"\n\t\t\t\t\t\t\t\"vol->data1_zone_pos \"\n\t\t\t\t\t\t\t\"0x%llx.\",\n\t\t\t\t\t\t\t(unsigned long long)\n\t\t\t\t\t\t\tvol->data1_zone_pos);\n\t\t\t\t}\n\t\t\t\t/* Switch from data1 zone to data2 zone. */\n\t\t\t\tsearch_zone = 4;\n\t\t\t\tzone_start = bmp_initial_pos =\n\t\t\t\t\t\tvol->data2_zone_pos;\n\t\t\t\tzone_end = vol->mft_zone_start;\n\t\t\t\tif (!zone_start)\n\t\t\t\t\tpass = 2;\n\t\t\t\tif (zone_start >= zone_end) {\n\t\t\t\t\tvol->data2_zone_pos = zone_start =\n\t\t\t\t\t\t\tbmp_initial_pos = 0;\n\t\t\t\t\tpass = 2;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 4:\n\t\t\t\tntfs_debug(\"Switching from data2 zone to \"\n\t\t\t\t\t\t\"data1 zone.\");\n\t\t\t\t/* Update data2 zone position. */\n\t\t\t\tif (rlpos) {\n\t\t\t\t\tLCN tc;\n\n\t\t\t\t\tntfs_debug(\"Before checks, \"\n\t\t\t\t\t\t\t\"vol->data2_zone_pos \"\n\t\t\t\t\t\t\t\"0x%llx.\",\n\t\t\t\t\t\t\t(unsigned long long)\n\t\t\t\t\t\t\tvol->data2_zone_pos);\n\t\t\t\t\ttc = rl[rlpos - 1].lcn +\n\t\t\t\t\t\t\trl[rlpos - 1].length;\n\t\t\t\t\tif (tc >= vol->mft_zone_start)\n\t\t\t\t\t\tvol->data2_zone_pos = 0;\n\t\t\t\t\telse if (bmp_initial_pos >=\n\t\t\t\t\t\t      vol->data2_zone_pos ||\n\t\t\t\t\t\t      tc > vol->data2_zone_pos)\n\t\t\t\t\t\tvol->data2_zone_pos = tc;\n\t\t\t\t\tntfs_debug(\"After checks, \"\n\t\t\t\t\t\t\t\"vol->data2_zone_pos \"\n\t\t\t\t\t\t\t\"0x%llx.\",\n\t\t\t\t\t\t\t(unsigned long long)\n\t\t\t\t\t\t\tvol->data2_zone_pos);\n\t\t\t\t}\n\t\t\t\t/* Switch from data2 zone to data1 zone. */\n\t\t\t\tgoto switch_to_data1_zone;\n\t\t\tdefault:\n\t\t\t\tBUG();\n\t\t\t}\n\t\t\tntfs_debug(\"After zone switch, search_zone %i, \"\n\t\t\t\t\t\"pass %i, bmp_initial_pos 0x%llx, \"\n\t\t\t\t\t\"zone_start 0x%llx, zone_end 0x%llx.\",\n\t\t\t\t\tsearch_zone, pass,\n\t\t\t\t\t(unsigned long long)bmp_initial_pos,\n\t\t\t\t\t(unsigned long long)zone_start,\n\t\t\t\t\t(unsigned long long)zone_end);\n\t\t\tbmp_pos = zone_start;\n\t\t\tif (zone_start == zone_end) {\n\t\t\t\tntfs_debug(\"Empty zone, going to \"\n\t\t\t\t\t\t\"done_zones_check.\");\n\t\t\t\t/* Empty zone. Don't bother searching it. */\n\t\t\t\tgoto done_zones_check;\n\t\t\t}\n\t\t\tntfs_debug(\"Continuing outer while loop.\");\n\t\t\tcontinue;\n\t\t} /* done_zones == 7 */\n\t\tntfs_debug(\"All zones are finished.\");\n\t\t/*\n\t\t * All zones are finished!  If DATA_ZONE, shrink mft zone.  If\n\t\t * MFT_ZONE, we have really run out of space.\n\t\t */\n\t\tmft_zone_size = vol->mft_zone_end - vol->mft_zone_start;\n\t\tntfs_debug(\"vol->mft_zone_start 0x%llx, vol->mft_zone_end \"\n\t\t\t\t\"0x%llx, mft_zone_size 0x%llx.\",\n\t\t\t\t(unsigned long long)vol->mft_zone_start,\n\t\t\t\t(unsigned long long)vol->mft_zone_end,\n\t\t\t\t(unsigned long long)mft_zone_size);\n\t\tif (zone == MFT_ZONE || mft_zone_size <= 0) {\n\t\t\tntfs_debug(\"No free clusters left, going to out.\");\n\t\t\t/* Really no more space left on device. */\n\t\t\terr = -ENOSPC;\n\t\t\tgoto out;\n\t\t} /* zone == DATA_ZONE && mft_zone_size > 0 */\n\t\tntfs_debug(\"Shrinking mft zone.\");\n\t\tzone_end = vol->mft_zone_end;\n\t\tmft_zone_size >>= 1;\n\t\tif (mft_zone_size > 0)\n\t\t\tvol->mft_zone_end = vol->mft_zone_start + mft_zone_size;\n\t\telse /* mft zone and data2 zone no longer exist. */\n\t\t\tvol->data2_zone_pos = vol->mft_zone_start =\n\t\t\t\t\tvol->mft_zone_end = 0;\n\t\tif (vol->mft_zone_pos >= vol->mft_zone_end) {\n\t\t\tvol->mft_zone_pos = vol->mft_lcn;\n\t\t\tif (!vol->mft_zone_end)\n\t\t\t\tvol->mft_zone_pos = 0;\n\t\t}\n\t\tbmp_pos = zone_start = bmp_initial_pos =\n\t\t\t\tvol->data1_zone_pos = vol->mft_zone_end;\n\t\tsearch_zone = 2;\n\t\tpass = 2;\n\t\tdone_zones &= ~2;\n\t\tntfs_debug(\"After shrinking mft zone, mft_zone_size 0x%llx, \"\n\t\t\t\t\"vol->mft_zone_start 0x%llx, \"\n\t\t\t\t\"vol->mft_zone_end 0x%llx, \"\n\t\t\t\t\"vol->mft_zone_pos 0x%llx, search_zone 2, \"\n\t\t\t\t\"pass 2, dones_zones 0x%x, zone_start 0x%llx, \"\n\t\t\t\t\"zone_end 0x%llx, vol->data1_zone_pos 0x%llx, \"\n\t\t\t\t\"continuing outer while loop.\",\n\t\t\t\t(unsigned long long)mft_zone_size,\n\t\t\t\t(unsigned long long)vol->mft_zone_start,\n\t\t\t\t(unsigned long long)vol->mft_zone_end,\n\t\t\t\t(unsigned long long)vol->mft_zone_pos,\n\t\t\t\tdone_zones, (unsigned long long)zone_start,\n\t\t\t\t(unsigned long long)zone_end,\n\t\t\t\t(unsigned long long)vol->data1_zone_pos);\n\t}\n\tntfs_debug(\"After outer while loop.\");\nout:\n\tntfs_debug(\"At out.\");\n\t/* Add runlist terminator element. */\n\tif (likely(rl)) {\n\t\trl[rlpos].vcn = rl[rlpos - 1].vcn + rl[rlpos - 1].length;\n\t\trl[rlpos].lcn = is_extension ? LCN_ENOENT : LCN_RL_NOT_MAPPED;\n\t\trl[rlpos].length = 0;\n\t}\n\tif (likely(page && !IS_ERR(page))) {\n\t\tif (need_writeback) {\n\t\t\tntfs_debug(\"Marking page dirty.\");\n\t\t\tflush_dcache_page(page);\n\t\t\tset_page_dirty(page);\n\t\t\tneed_writeback = 0;\n\t\t}\n\t\tntfs_unmap_page(page);\n\t}\n\tif (likely(!err)) {\n\t\tup_write(&vol->lcnbmp_lock);\n\t\tntfs_debug(\"Done.\");\n\t\treturn rl;\n\t}\n\tntfs_error(vol->sb, \"Failed to allocate clusters, aborting \"\n\t\t\t\"(error %i).\", err);\n\tif (rl) {\n\t\tint err2;\n\n\t\tif (err == -ENOSPC)\n\t\t\tntfs_debug(\"Not enough space to complete allocation, \"\n\t\t\t\t\t\"err -ENOSPC, first free lcn 0x%llx, \"\n\t\t\t\t\t\"could allocate up to 0x%llx \"\n\t\t\t\t\t\"clusters.\",\n\t\t\t\t\t(unsigned long long)rl[0].lcn,\n\t\t\t\t\t(unsigned long long)(count - clusters));\n\t\t/* Deallocate all allocated clusters. */\n\t\tntfs_debug(\"Attempting rollback...\");\n\t\terr2 = ntfs_cluster_free_from_rl_nolock(vol, rl);\n\t\tif (err2) {\n\t\t\tntfs_error(vol->sb, \"Failed to rollback (error %i).  \"\n\t\t\t\t\t\"Leaving inconsistent metadata!  \"\n\t\t\t\t\t\"Unmount and run chkdsk.\", err2);\n\t\t\tNVolSetErrors(vol);\n\t\t}\n\t\t/* Free the runlist. */\n\t\tntfs_free(rl);\n\t} else if (err == -ENOSPC)\n\t\tntfs_debug(\"No space left at all, err = -ENOSPC, first free \"\n\t\t\t\t\"lcn = 0x%llx.\",\n\t\t\t\t(long long)vol->data1_zone_pos);\n\tup_write(&vol->lcnbmp_lock);\n\treturn ERR_PTR(err);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ntfs_unmap_page",
          "args": [
            "page"
          ],
          "line": 1354
        },
        "resolved": true,
        "details": {
          "function_name": "ntfs_unmap_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/aops.h",
          "lines": "40-44",
          "snippet": "static inline void ntfs_unmap_page(struct page *page)\n{\n\tkunmap(page);\n\tpage_cache_release(page);\n}",
          "includes": [
            "#include \"inode.h\"",
            "#include <linux/fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"inode.h\"\n#include <linux/fs.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n\nstatic inline void ntfs_unmap_page(struct page *page)\n{\n\tkunmap(page);\n\tpage_cache_release(page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "up_write",
          "args": [
            "&vol->lcnbmp_lock"
          ],
          "line": 1353
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "up_write",
          "args": [
            "&vol->lcnbmp_lock"
          ],
          "line": 1345
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_page_dirty",
          "args": [
            "page"
          ],
          "line": 1344
        },
        "resolved": true,
        "details": {
          "function_name": "anon_set_page_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/libfs.c",
          "lines": "1040-1043",
          "snippet": "static int anon_set_page_dirty(struct page *page)\n{\n\treturn 0;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/buffer_head.h> /* sync_mapping_buffers */",
            "#include <linux/writeback.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/namei.h>",
            "#include <linux/mutex.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/vfs.h>",
            "#include <linux/mount.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/export.h>",
            "#include <linux/blkdev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <linux/buffer_head.h> /* sync_mapping_buffers */\n#include <linux/writeback.h>\n#include <linux/exportfs.h>\n#include <linux/namei.h>\n#include <linux/mutex.h>\n#include <linux/quotaops.h>\n#include <linux/vfs.h>\n#include <linux/mount.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include <linux/export.h>\n#include <linux/blkdev.h>\n\nstatic int anon_set_page_dirty(struct page *page)\n{\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "flush_dcache_page",
          "args": [
            "page"
          ],
          "line": 1343
        },
        "resolved": true,
        "details": {
          "function_name": "ntfs_index_entry_flush_dcache_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/index.h",
          "lines": "111-117",
          "snippet": "static inline void ntfs_index_entry_flush_dcache_page(ntfs_index_context *ictx)\n{\n\tif (ictx->is_in_root)\n\t\tflush_dcache_mft_record_page(ictx->actx->ntfs_ino);\n\telse\n\t\tflush_dcache_page(ictx->page);\n}",
          "includes": [
            "#include \"aops.h\"",
            "#include \"mft.h\"",
            "#include \"attrib.h\"",
            "#include \"inode.h\"",
            "#include \"layout.h\"",
            "#include \"types.h\"",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"aops.h\"\n#include \"mft.h\"\n#include \"attrib.h\"\n#include \"inode.h\"\n#include \"layout.h\"\n#include \"types.h\"\n#include <linux/fs.h>\n\nstatic inline void ntfs_index_entry_flush_dcache_page(ntfs_index_context *ictx)\n{\n\tif (ictx->is_in_root)\n\t\tflush_dcache_mft_record_page(ictx->actx->ntfs_ino);\n\telse\n\t\tflush_dcache_page(ictx->page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "down_write",
          "args": [
            "&vol->lcnbmp_lock"
          ],
          "line": 1339
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_address",
          "args": [
            "page"
          ],
          "line": 1337
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "page"
          ],
          "line": 1335
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntfs_error",
          "args": [
            "vol->sb",
            "\"Failed to read from lcn bitmap.\""
          ],
          "line": 1334
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "up_write",
          "args": [
            "&mftbmp_ni->runlist.lock"
          ],
          "line": 1333
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "page"
          ],
          "line": 1332
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntfs_map_page",
          "args": [
            "vol->lcnbmp_ino->i_mapping",
            "ll >> PAGE_CACHE_SHIFT"
          ],
          "line": 1330
        },
        "resolved": true,
        "details": {
          "function_name": "ntfs_map_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/aops.h",
          "lines": "86-99",
          "snippet": "static inline struct page *ntfs_map_page(struct address_space *mapping,\n\t\tunsigned long index)\n{\n\tstruct page *page = read_mapping_page(mapping, index, NULL);\n\n\tif (!IS_ERR(page)) {\n\t\tkmap(page);\n\t\tif (!PageError(page))\n\t\t\treturn page;\n\t\tntfs_unmap_page(page);\n\t\treturn ERR_PTR(-EIO);\n\t}\n\treturn page;\n}",
          "includes": [
            "#include \"inode.h\"",
            "#include <linux/fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"inode.h\"\n#include <linux/fs.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n\nstatic inline struct page *ntfs_map_page(struct address_space *mapping,\n\t\tunsigned long index)\n{\n\tstruct page *page = read_mapping_page(mapping, index, NULL);\n\n\tif (!IS_ERR(page)) {\n\t\tkmap(page);\n\t\tif (!PageError(page))\n\t\t\treturn page;\n\t\tntfs_unmap_page(page);\n\t\treturn ERR_PTR(-EIO);\n\t}\n\treturn page;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ntfs_debug",
          "args": [
            "\"Last lcn of mft bitmap attribute is 0x%llx.\"",
            "(long long)lcn"
          ],
          "line": 1322
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "rl"
          ],
          "line": 1318
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "rl"
          ],
          "line": 1315
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntfs_error",
          "args": [
            "vol->sb",
            "\"Failed to determine last allocated \"\n\t\t\t\t\"cluster of mft bitmap attribute.\""
          ],
          "line": 1313
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "up_write",
          "args": [
            "&mftbmp_ni->runlist.lock"
          ],
          "line": 1312
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "IS_ERR(rl) || !rl->length || rl->lcn < 0"
          ],
          "line": 1311
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "rl"
          ],
          "line": 1311
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntfs_attr_find_vcn_nolock",
          "args": [
            "mftbmp_ni",
            "(ll - 1) >> vol->cluster_size_bits",
            "NULL"
          ],
          "line": 1309
        },
        "resolved": true,
        "details": {
          "function_name": "ntfs_attr_find_vcn_nolock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/attrib.c",
          "lines": "464-530",
          "snippet": "runlist_element *ntfs_attr_find_vcn_nolock(ntfs_inode *ni, const VCN vcn,\n\t\tntfs_attr_search_ctx *ctx)\n{\n\tunsigned long flags;\n\trunlist_element *rl;\n\tint err = 0;\n\tbool is_retry = false;\n\n\tBUG_ON(!ni);\n\tntfs_debug(\"Entering for i_ino 0x%lx, vcn 0x%llx, with%s ctx.\",\n\t\t\tni->mft_no, (unsigned long long)vcn, ctx ? \"\" : \"out\");\n\tBUG_ON(!NInoNonResident(ni));\n\tBUG_ON(vcn < 0);\n\tif (!ni->runlist.rl) {\n\t\tread_lock_irqsave(&ni->size_lock, flags);\n\t\tif (!ni->allocated_size) {\n\t\t\tread_unlock_irqrestore(&ni->size_lock, flags);\n\t\t\treturn ERR_PTR(-ENOENT);\n\t\t}\n\t\tread_unlock_irqrestore(&ni->size_lock, flags);\n\t}\nretry_remap:\n\trl = ni->runlist.rl;\n\tif (likely(rl && vcn >= rl[0].vcn)) {\n\t\twhile (likely(rl->length)) {\n\t\t\tif (unlikely(vcn < rl[1].vcn)) {\n\t\t\t\tif (likely(rl->lcn >= LCN_HOLE)) {\n\t\t\t\t\tntfs_debug(\"Done.\");\n\t\t\t\t\treturn rl;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\trl++;\n\t\t}\n\t\tif (likely(rl->lcn != LCN_RL_NOT_MAPPED)) {\n\t\t\tif (likely(rl->lcn == LCN_ENOENT))\n\t\t\t\terr = -ENOENT;\n\t\t\telse\n\t\t\t\terr = -EIO;\n\t\t}\n\t}\n\tif (!err && !is_retry) {\n\t\t/*\n\t\t * If the search context is invalid we cannot map the unmapped\n\t\t * region.\n\t\t */\n\t\tif (IS_ERR(ctx->mrec))\n\t\t\terr = PTR_ERR(ctx->mrec);\n\t\telse {\n\t\t\t/*\n\t\t\t * The @vcn is in an unmapped region, map the runlist\n\t\t\t * and retry.\n\t\t\t */\n\t\t\terr = ntfs_map_runlist_nolock(ni, vcn, ctx);\n\t\t\tif (likely(!err)) {\n\t\t\t\tis_retry = true;\n\t\t\t\tgoto retry_remap;\n\t\t\t}\n\t\t}\n\t\tif (err == -EINVAL)\n\t\t\terr = -EIO;\n\t} else if (!err)\n\t\terr = -EIO;\n\tif (err != -ENOENT)\n\t\tntfs_error(ni->vol->sb, \"Failed with error code %i.\", err);\n\treturn ERR_PTR(err);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include \"ntfs.h\"",
            "#include \"mft.h\"",
            "#include \"malloc.h\"",
            "#include \"lcnalloc.h\"",
            "#include \"layout.h\"",
            "#include \"debug.h\"",
            "#include \"attrib.h\"",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include \"ntfs.h\"\n#include \"mft.h\"\n#include \"malloc.h\"\n#include \"lcnalloc.h\"\n#include \"layout.h\"\n#include \"debug.h\"\n#include \"attrib.h\"\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/buffer_head.h>\n\nrunlist_element *ntfs_attr_find_vcn_nolock(ntfs_inode *ni, const VCN vcn,\n\t\tntfs_attr_search_ctx *ctx)\n{\n\tunsigned long flags;\n\trunlist_element *rl;\n\tint err = 0;\n\tbool is_retry = false;\n\n\tBUG_ON(!ni);\n\tntfs_debug(\"Entering for i_ino 0x%lx, vcn 0x%llx, with%s ctx.\",\n\t\t\tni->mft_no, (unsigned long long)vcn, ctx ? \"\" : \"out\");\n\tBUG_ON(!NInoNonResident(ni));\n\tBUG_ON(vcn < 0);\n\tif (!ni->runlist.rl) {\n\t\tread_lock_irqsave(&ni->size_lock, flags);\n\t\tif (!ni->allocated_size) {\n\t\t\tread_unlock_irqrestore(&ni->size_lock, flags);\n\t\t\treturn ERR_PTR(-ENOENT);\n\t\t}\n\t\tread_unlock_irqrestore(&ni->size_lock, flags);\n\t}\nretry_remap:\n\trl = ni->runlist.rl;\n\tif (likely(rl && vcn >= rl[0].vcn)) {\n\t\twhile (likely(rl->length)) {\n\t\t\tif (unlikely(vcn < rl[1].vcn)) {\n\t\t\t\tif (likely(rl->lcn >= LCN_HOLE)) {\n\t\t\t\t\tntfs_debug(\"Done.\");\n\t\t\t\t\treturn rl;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\trl++;\n\t\t}\n\t\tif (likely(rl->lcn != LCN_RL_NOT_MAPPED)) {\n\t\t\tif (likely(rl->lcn == LCN_ENOENT))\n\t\t\t\terr = -ENOENT;\n\t\t\telse\n\t\t\t\terr = -EIO;\n\t\t}\n\t}\n\tif (!err && !is_retry) {\n\t\t/*\n\t\t * If the search context is invalid we cannot map the unmapped\n\t\t * region.\n\t\t */\n\t\tif (IS_ERR(ctx->mrec))\n\t\t\terr = PTR_ERR(ctx->mrec);\n\t\telse {\n\t\t\t/*\n\t\t\t * The @vcn is in an unmapped region, map the runlist\n\t\t\t * and retry.\n\t\t\t */\n\t\t\terr = ntfs_map_runlist_nolock(ni, vcn, ctx);\n\t\t\tif (likely(!err)) {\n\t\t\t\tis_retry = true;\n\t\t\t\tgoto retry_remap;\n\t\t\t}\n\t\t}\n\t\tif (err == -EINVAL)\n\t\t\terr = -EIO;\n\t} else if (!err)\n\t\terr = -EIO;\n\tif (err != -ENOENT)\n\t\tntfs_error(ni->vol->sb, \"Failed with error code %i.\", err);\n\treturn ERR_PTR(err);\n}"
        }
      },
      {
        "call_info": {
          "callee": "read_unlock_irqrestore",
          "args": [
            "&mftbmp_ni->size_lock",
            "flags"
          ],
          "line": 1308
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "read_lock_irqsave",
          "args": [
            "&mftbmp_ni->size_lock",
            "flags"
          ],
          "line": 1306
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "down_write",
          "args": [
            "&mftbmp_ni->runlist.lock"
          ],
          "line": 1305
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NTFS_I",
          "args": [
            "vol->mftbmp_ino"
          ],
          "line": 1300
        },
        "resolved": true,
        "details": {
          "function_name": "NTFS_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/inode.h",
          "lines": "240-243",
          "snippet": "static inline ntfs_inode *NTFS_I(struct inode *inode)\n{\n\treturn (ntfs_inode *)list_entry(inode, big_ntfs_inode, vfs_inode);\n}",
          "includes": [
            "#include \"debug.h\"",
            "#include \"runlist.h\"",
            "#include \"types.h\"",
            "#include \"volume.h\"",
            "#include \"layout.h\"",
            "#include <linux/seq_file.h>",
            "#include <linux/mutex.h>",
            "#include <linux/mm.h>",
            "#include <linux/list.h>",
            "#include <linux/fs.h>",
            "#include <linux/atomic.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"debug.h\"\n#include \"runlist.h\"\n#include \"types.h\"\n#include \"volume.h\"\n#include \"layout.h\"\n#include <linux/seq_file.h>\n#include <linux/mutex.h>\n#include <linux/mm.h>\n#include <linux/list.h>\n#include <linux/fs.h>\n#include <linux/atomic.h>\n\nstatic inline ntfs_inode *NTFS_I(struct inode *inode)\n{\n\treturn (ntfs_inode *)list_entry(inode, big_ntfs_inode, vfs_inode);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ntfs.h\"\n#include \"mft.h\"\n#include \"malloc.h\"\n#include \"lcnalloc.h\"\n#include \"dir.h\"\n#include \"debug.h\"\n#include \"bitmap.h\"\n#include \"aops.h\"\n#include \"attrib.h\"\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n\nstatic int ntfs_mft_bitmap_extend_allocation_nolock(ntfs_volume *vol)\n{\n\tLCN lcn;\n\ts64 ll;\n\tunsigned long flags;\n\tstruct page *page;\n\tntfs_inode *mft_ni, *mftbmp_ni;\n\trunlist_element *rl, *rl2 = NULL;\n\tntfs_attr_search_ctx *ctx = NULL;\n\tMFT_RECORD *mrec;\n\tATTR_RECORD *a = NULL;\n\tint ret, mp_size;\n\tu32 old_alen = 0;\n\tu8 *b, tb;\n\tstruct {\n\t\tu8 added_cluster:1;\n\t\tu8 added_run:1;\n\t\tu8 mp_rebuilt:1;\n\t} status = { 0, 0, 0 };\n\n\tntfs_debug(\"Extending mft bitmap allocation.\");\n\tmft_ni = NTFS_I(vol->mft_ino);\n\tmftbmp_ni = NTFS_I(vol->mftbmp_ino);\n\t/*\n\t * Determine the last lcn of the mft bitmap.  The allocated size of the\n\t * mft bitmap cannot be zero so we are ok to do this.\n\t */\n\tdown_write(&mftbmp_ni->runlist.lock);\n\tread_lock_irqsave(&mftbmp_ni->size_lock, flags);\n\tll = mftbmp_ni->allocated_size;\n\tread_unlock_irqrestore(&mftbmp_ni->size_lock, flags);\n\trl = ntfs_attr_find_vcn_nolock(mftbmp_ni,\n\t\t\t(ll - 1) >> vol->cluster_size_bits, NULL);\n\tif (unlikely(IS_ERR(rl) || !rl->length || rl->lcn < 0)) {\n\t\tup_write(&mftbmp_ni->runlist.lock);\n\t\tntfs_error(vol->sb, \"Failed to determine last allocated \"\n\t\t\t\t\"cluster of mft bitmap attribute.\");\n\t\tif (!IS_ERR(rl))\n\t\t\tret = -EIO;\n\t\telse\n\t\t\tret = PTR_ERR(rl);\n\t\treturn ret;\n\t}\n\tlcn = rl->lcn + rl->length;\n\tntfs_debug(\"Last lcn of mft bitmap attribute is 0x%llx.\",\n\t\t\t(long long)lcn);\n\t/*\n\t * Attempt to get the cluster following the last allocated cluster by\n\t * hand as it may be in the MFT zone so the allocator would not give it\n\t * to us.\n\t */\n\tll = lcn >> 3;\n\tpage = ntfs_map_page(vol->lcnbmp_ino->i_mapping,\n\t\t\tll >> PAGE_CACHE_SHIFT);\n\tif (IS_ERR(page)) {\n\t\tup_write(&mftbmp_ni->runlist.lock);\n\t\tntfs_error(vol->sb, \"Failed to read from lcn bitmap.\");\n\t\treturn PTR_ERR(page);\n\t}\n\tb = (u8*)page_address(page) + (ll & ~PAGE_CACHE_MASK);\n\ttb = 1 << (lcn & 7ull);\n\tdown_write(&vol->lcnbmp_lock);\n\tif (*b != 0xff && !(*b & tb)) {\n\t\t/* Next cluster is free, allocate it. */\n\t\t*b |= tb;\n\t\tflush_dcache_page(page);\n\t\tset_page_dirty(page);\n\t\tup_write(&vol->lcnbmp_lock);\n\t\tntfs_unmap_page(page);\n\t\t/* Update the mft bitmap runlist. */\n\t\trl->length++;\n\t\trl[1].vcn++;\n\t\tstatus.added_cluster = 1;\n\t\tntfs_debug(\"Appending one cluster to mft bitmap.\");\n\t} else {\n\t\tup_write(&vol->lcnbmp_lock);\n\t\tntfs_unmap_page(page);\n\t\t/* Allocate a cluster from the DATA_ZONE. */\n\t\trl2 = ntfs_cluster_alloc(vol, rl[1].vcn, 1, lcn, DATA_ZONE,\n\t\t\t\ttrue);\n\t\tif (IS_ERR(rl2)) {\n\t\t\tup_write(&mftbmp_ni->runlist.lock);\n\t\t\tntfs_error(vol->sb, \"Failed to allocate a cluster for \"\n\t\t\t\t\t\"the mft bitmap.\");\n\t\t\treturn PTR_ERR(rl2);\n\t\t}\n\t\trl = ntfs_runlists_merge(mftbmp_ni->runlist.rl, rl2);\n\t\tif (IS_ERR(rl)) {\n\t\t\tup_write(&mftbmp_ni->runlist.lock);\n\t\t\tntfs_error(vol->sb, \"Failed to merge runlists for mft \"\n\t\t\t\t\t\"bitmap.\");\n\t\t\tif (ntfs_cluster_free_from_rl(vol, rl2)) {\n\t\t\t\tntfs_error(vol->sb, \"Failed to deallocate \"\n\t\t\t\t\t\t\"allocated cluster.%s\", es);\n\t\t\t\tNVolSetErrors(vol);\n\t\t\t}\n\t\t\tntfs_free(rl2);\n\t\t\treturn PTR_ERR(rl);\n\t\t}\n\t\tmftbmp_ni->runlist.rl = rl;\n\t\tstatus.added_run = 1;\n\t\tntfs_debug(\"Adding one run to mft bitmap.\");\n\t\t/* Find the last run in the new runlist. */\n\t\tfor (; rl[1].length; rl++)\n\t\t\t;\n\t}\n\t/*\n\t * Update the attribute record as well.  Note: @rl is the last\n\t * (non-terminator) runlist element of mft bitmap.\n\t */\n\tmrec = map_mft_record(mft_ni);\n\tif (IS_ERR(mrec)) {\n\t\tntfs_error(vol->sb, \"Failed to map mft record.\");\n\t\tret = PTR_ERR(mrec);\n\t\tgoto undo_alloc;\n\t}\n\tctx = ntfs_attr_get_search_ctx(mft_ni, mrec);\n\tif (unlikely(!ctx)) {\n\t\tntfs_error(vol->sb, \"Failed to get search context.\");\n\t\tret = -ENOMEM;\n\t\tgoto undo_alloc;\n\t}\n\tret = ntfs_attr_lookup(mftbmp_ni->type, mftbmp_ni->name,\n\t\t\tmftbmp_ni->name_len, CASE_SENSITIVE, rl[1].vcn, NULL,\n\t\t\t0, ctx);\n\tif (unlikely(ret)) {\n\t\tntfs_error(vol->sb, \"Failed to find last attribute extent of \"\n\t\t\t\t\"mft bitmap attribute.\");\n\t\tif (ret == -ENOENT)\n\t\t\tret = -EIO;\n\t\tgoto undo_alloc;\n\t}\n\ta = ctx->attr;\n\tll = sle64_to_cpu(a->data.non_resident.lowest_vcn);\n\t/* Search back for the previous last allocated cluster of mft bitmap. */\n\tfor (rl2 = rl; rl2 > mftbmp_ni->runlist.rl; rl2--) {\n\t\tif (ll >= rl2->vcn)\n\t\t\tbreak;\n\t}\n\tBUG_ON(ll < rl2->vcn);\n\tBUG_ON(ll >= rl2->vcn + rl2->length);\n\t/* Get the size for the new mapping pairs array for this extent. */\n\tmp_size = ntfs_get_size_for_mapping_pairs(vol, rl2, ll, -1);\n\tif (unlikely(mp_size <= 0)) {\n\t\tntfs_error(vol->sb, \"Get size for mapping pairs failed for \"\n\t\t\t\t\"mft bitmap attribute extent.\");\n\t\tret = mp_size;\n\t\tif (!ret)\n\t\t\tret = -EIO;\n\t\tgoto undo_alloc;\n\t}\n\t/* Expand the attribute record if necessary. */\n\told_alen = le32_to_cpu(a->length);\n\tret = ntfs_attr_record_resize(ctx->mrec, a, mp_size +\n\t\t\tle16_to_cpu(a->data.non_resident.mapping_pairs_offset));\n\tif (unlikely(ret)) {\n\t\tif (ret != -ENOSPC) {\n\t\t\tntfs_error(vol->sb, \"Failed to resize attribute \"\n\t\t\t\t\t\"record for mft bitmap attribute.\");\n\t\t\tgoto undo_alloc;\n\t\t}\n\t\t// TODO: Deal with this by moving this extent to a new mft\n\t\t// record or by starting a new extent in a new mft record or by\n\t\t// moving other attributes out of this mft record.\n\t\t// Note: It will need to be a special mft record and if none of\n\t\t// those are available it gets rather complicated...\n\t\tntfs_error(vol->sb, \"Not enough space in this mft record to \"\n\t\t\t\t\"accommodate extended mft bitmap attribute \"\n\t\t\t\t\"extent.  Cannot handle this yet.\");\n\t\tret = -EOPNOTSUPP;\n\t\tgoto undo_alloc;\n\t}\n\tstatus.mp_rebuilt = 1;\n\t/* Generate the mapping pairs array directly into the attr record. */\n\tret = ntfs_mapping_pairs_build(vol, (u8*)a +\n\t\t\tle16_to_cpu(a->data.non_resident.mapping_pairs_offset),\n\t\t\tmp_size, rl2, ll, -1, NULL);\n\tif (unlikely(ret)) {\n\t\tntfs_error(vol->sb, \"Failed to build mapping pairs array for \"\n\t\t\t\t\"mft bitmap attribute.\");\n\t\tgoto undo_alloc;\n\t}\n\t/* Update the highest_vcn. */\n\ta->data.non_resident.highest_vcn = cpu_to_sle64(rl[1].vcn - 1);\n\t/*\n\t * We now have extended the mft bitmap allocated_size by one cluster.\n\t * Reflect this in the ntfs_inode structure and the attribute record.\n\t */\n\tif (a->data.non_resident.lowest_vcn) {\n\t\t/*\n\t\t * We are not in the first attribute extent, switch to it, but\n\t\t * first ensure the changes will make it to disk later.\n\t\t */\n\t\tflush_dcache_mft_record_page(ctx->ntfs_ino);\n\t\tmark_mft_record_dirty(ctx->ntfs_ino);\n\t\tntfs_attr_reinit_search_ctx(ctx);\n\t\tret = ntfs_attr_lookup(mftbmp_ni->type, mftbmp_ni->name,\n\t\t\t\tmftbmp_ni->name_len, CASE_SENSITIVE, 0, NULL,\n\t\t\t\t0, ctx);\n\t\tif (unlikely(ret)) {\n\t\t\tntfs_error(vol->sb, \"Failed to find first attribute \"\n\t\t\t\t\t\"extent of mft bitmap attribute.\");\n\t\t\tgoto restore_undo_alloc;\n\t\t}\n\t\ta = ctx->attr;\n\t}\n\twrite_lock_irqsave(&mftbmp_ni->size_lock, flags);\n\tmftbmp_ni->allocated_size += vol->cluster_size;\n\ta->data.non_resident.allocated_size =\n\t\t\tcpu_to_sle64(mftbmp_ni->allocated_size);\n\twrite_unlock_irqrestore(&mftbmp_ni->size_lock, flags);\n\t/* Ensure the changes make it to disk. */\n\tflush_dcache_mft_record_page(ctx->ntfs_ino);\n\tmark_mft_record_dirty(ctx->ntfs_ino);\n\tntfs_attr_put_search_ctx(ctx);\n\tunmap_mft_record(mft_ni);\n\tup_write(&mftbmp_ni->runlist.lock);\n\tntfs_debug(\"Done.\");\n\treturn 0;\nrestore_undo_alloc:\n\tntfs_attr_reinit_search_ctx(ctx);\n\tif (ntfs_attr_lookup(mftbmp_ni->type, mftbmp_ni->name,\n\t\t\tmftbmp_ni->name_len, CASE_SENSITIVE, rl[1].vcn, NULL,\n\t\t\t0, ctx)) {\n\t\tntfs_error(vol->sb, \"Failed to find last attribute extent of \"\n\t\t\t\t\"mft bitmap attribute.%s\", es);\n\t\twrite_lock_irqsave(&mftbmp_ni->size_lock, flags);\n\t\tmftbmp_ni->allocated_size += vol->cluster_size;\n\t\twrite_unlock_irqrestore(&mftbmp_ni->size_lock, flags);\n\t\tntfs_attr_put_search_ctx(ctx);\n\t\tunmap_mft_record(mft_ni);\n\t\tup_write(&mftbmp_ni->runlist.lock);\n\t\t/*\n\t\t * The only thing that is now wrong is ->allocated_size of the\n\t\t * base attribute extent which chkdsk should be able to fix.\n\t\t */\n\t\tNVolSetErrors(vol);\n\t\treturn ret;\n\t}\n\ta = ctx->attr;\n\ta->data.non_resident.highest_vcn = cpu_to_sle64(rl[1].vcn - 2);\nundo_alloc:\n\tif (status.added_cluster) {\n\t\t/* Truncate the last run in the runlist by one cluster. */\n\t\trl->length--;\n\t\trl[1].vcn--;\n\t} else if (status.added_run) {\n\t\tlcn = rl->lcn;\n\t\t/* Remove the last run from the runlist. */\n\t\trl->lcn = rl[1].lcn;\n\t\trl->length = 0;\n\t}\n\t/* Deallocate the cluster. */\n\tdown_write(&vol->lcnbmp_lock);\n\tif (ntfs_bitmap_clear_bit(vol->lcnbmp_ino, lcn)) {\n\t\tntfs_error(vol->sb, \"Failed to free allocated cluster.%s\", es);\n\t\tNVolSetErrors(vol);\n\t}\n\tup_write(&vol->lcnbmp_lock);\n\tif (status.mp_rebuilt) {\n\t\tif (ntfs_mapping_pairs_build(vol, (u8*)a + le16_to_cpu(\n\t\t\t\ta->data.non_resident.mapping_pairs_offset),\n\t\t\t\told_alen - le16_to_cpu(\n\t\t\t\ta->data.non_resident.mapping_pairs_offset),\n\t\t\t\trl2, ll, -1, NULL)) {\n\t\t\tntfs_error(vol->sb, \"Failed to restore mapping pairs \"\n\t\t\t\t\t\"array.%s\", es);\n\t\t\tNVolSetErrors(vol);\n\t\t}\n\t\tif (ntfs_attr_record_resize(ctx->mrec, a, old_alen)) {\n\t\t\tntfs_error(vol->sb, \"Failed to restore attribute \"\n\t\t\t\t\t\"record.%s\", es);\n\t\t\tNVolSetErrors(vol);\n\t\t}\n\t\tflush_dcache_mft_record_page(ctx->ntfs_ino);\n\t\tmark_mft_record_dirty(ctx->ntfs_ino);\n\t}\n\tif (ctx)\n\t\tntfs_attr_put_search_ctx(ctx);\n\tif (!IS_ERR(mrec))\n\t\tunmap_mft_record(mft_ni);\n\tup_write(&mftbmp_ni->runlist.lock);\n\treturn ret;\n}"
  },
  {
    "function_name": "ntfs_mft_bitmap_find_and_alloc_free_rec_nolock",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/mft.c",
    "lines": "1131-1259",
    "snippet": "static int ntfs_mft_bitmap_find_and_alloc_free_rec_nolock(ntfs_volume *vol,\n\t\tntfs_inode *base_ni)\n{\n\ts64 pass_end, ll, data_pos, pass_start, ofs, bit;\n\tunsigned long flags;\n\tstruct address_space *mftbmp_mapping;\n\tu8 *buf, *byte;\n\tstruct page *page;\n\tunsigned int page_ofs, size;\n\tu8 pass, b;\n\n\tntfs_debug(\"Searching for free mft record in the currently \"\n\t\t\t\"initialized mft bitmap.\");\n\tmftbmp_mapping = vol->mftbmp_ino->i_mapping;\n\t/*\n\t * Set the end of the pass making sure we do not overflow the mft\n\t * bitmap.\n\t */\n\tread_lock_irqsave(&NTFS_I(vol->mft_ino)->size_lock, flags);\n\tpass_end = NTFS_I(vol->mft_ino)->allocated_size >>\n\t\t\tvol->mft_record_size_bits;\n\tread_unlock_irqrestore(&NTFS_I(vol->mft_ino)->size_lock, flags);\n\tread_lock_irqsave(&NTFS_I(vol->mftbmp_ino)->size_lock, flags);\n\tll = NTFS_I(vol->mftbmp_ino)->initialized_size << 3;\n\tread_unlock_irqrestore(&NTFS_I(vol->mftbmp_ino)->size_lock, flags);\n\tif (pass_end > ll)\n\t\tpass_end = ll;\n\tpass = 1;\n\tif (!base_ni)\n\t\tdata_pos = vol->mft_data_pos;\n\telse\n\t\tdata_pos = base_ni->mft_no + 1;\n\tif (data_pos < 24)\n\t\tdata_pos = 24;\n\tif (data_pos >= pass_end) {\n\t\tdata_pos = 24;\n\t\tpass = 2;\n\t\t/* This happens on a freshly formatted volume. */\n\t\tif (data_pos >= pass_end)\n\t\t\treturn -ENOSPC;\n\t}\n\tpass_start = data_pos;\n\tntfs_debug(\"Starting bitmap search: pass %u, pass_start 0x%llx, \"\n\t\t\t\"pass_end 0x%llx, data_pos 0x%llx.\", pass,\n\t\t\t(long long)pass_start, (long long)pass_end,\n\t\t\t(long long)data_pos);\n\t/* Loop until a free mft record is found. */\n\tfor (; pass <= 2;) {\n\t\t/* Cap size to pass_end. */\n\t\tofs = data_pos >> 3;\n\t\tpage_ofs = ofs & ~PAGE_CACHE_MASK;\n\t\tsize = PAGE_CACHE_SIZE - page_ofs;\n\t\tll = ((pass_end + 7) >> 3) - ofs;\n\t\tif (size > ll)\n\t\t\tsize = ll;\n\t\tsize <<= 3;\n\t\t/*\n\t\t * If we are still within the active pass, search the next page\n\t\t * for a zero bit.\n\t\t */\n\t\tif (size) {\n\t\t\tpage = ntfs_map_page(mftbmp_mapping,\n\t\t\t\t\tofs >> PAGE_CACHE_SHIFT);\n\t\t\tif (IS_ERR(page)) {\n\t\t\t\tntfs_error(vol->sb, \"Failed to read mft \"\n\t\t\t\t\t\t\"bitmap, aborting.\");\n\t\t\t\treturn PTR_ERR(page);\n\t\t\t}\n\t\t\tbuf = (u8*)page_address(page) + page_ofs;\n\t\t\tbit = data_pos & 7;\n\t\t\tdata_pos &= ~7ull;\n\t\t\tntfs_debug(\"Before inner for loop: size 0x%x, \"\n\t\t\t\t\t\"data_pos 0x%llx, bit 0x%llx\", size,\n\t\t\t\t\t(long long)data_pos, (long long)bit);\n\t\t\tfor (; bit < size && data_pos + bit < pass_end;\n\t\t\t\t\tbit &= ~7ull, bit += 8) {\n\t\t\t\tbyte = buf + (bit >> 3);\n\t\t\t\tif (*byte == 0xff)\n\t\t\t\t\tcontinue;\n\t\t\t\tb = ffz((unsigned long)*byte);\n\t\t\t\tif (b < 8 && b >= (bit & 7)) {\n\t\t\t\t\tll = data_pos + (bit & ~7ull) + b;\n\t\t\t\t\tif (unlikely(ll > (1ll << 32))) {\n\t\t\t\t\t\tntfs_unmap_page(page);\n\t\t\t\t\t\treturn -ENOSPC;\n\t\t\t\t\t}\n\t\t\t\t\t*byte |= 1 << b;\n\t\t\t\t\tflush_dcache_page(page);\n\t\t\t\t\tset_page_dirty(page);\n\t\t\t\t\tntfs_unmap_page(page);\n\t\t\t\t\tntfs_debug(\"Done.  (Found and \"\n\t\t\t\t\t\t\t\"allocated mft record \"\n\t\t\t\t\t\t\t\"0x%llx.)\",\n\t\t\t\t\t\t\t(long long)ll);\n\t\t\t\t\treturn ll;\n\t\t\t\t}\n\t\t\t}\n\t\t\tntfs_debug(\"After inner for loop: size 0x%x, \"\n\t\t\t\t\t\"data_pos 0x%llx, bit 0x%llx\", size,\n\t\t\t\t\t(long long)data_pos, (long long)bit);\n\t\t\tdata_pos += size;\n\t\t\tntfs_unmap_page(page);\n\t\t\t/*\n\t\t\t * If the end of the pass has not been reached yet,\n\t\t\t * continue searching the mft bitmap for a zero bit.\n\t\t\t */\n\t\t\tif (data_pos < pass_end)\n\t\t\t\tcontinue;\n\t\t}\n\t\t/* Do the next pass. */\n\t\tif (++pass == 2) {\n\t\t\t/*\n\t\t\t * Starting the second pass, in which we scan the first\n\t\t\t * part of the zone which we omitted earlier.\n\t\t\t */\n\t\t\tpass_end = pass_start;\n\t\t\tdata_pos = pass_start = 24;\n\t\t\tntfs_debug(\"pass %i, pass_start 0x%llx, pass_end \"\n\t\t\t\t\t\"0x%llx.\", pass, (long long)pass_start,\n\t\t\t\t\t(long long)pass_end);\n\t\t\tif (data_pos >= pass_end)\n\t\t\t\tbreak;\n\t\t}\n\t}\n\t/* No free mft records in currently initialized mft bitmap. */\n\tntfs_debug(\"Done.  (No free mft records left in currently initialized \"\n\t\t\t\"mft bitmap.)\");\n\treturn -ENOSPC;\n}",
    "includes": [
      "#include \"ntfs.h\"",
      "#include \"mft.h\"",
      "#include \"malloc.h\"",
      "#include \"lcnalloc.h\"",
      "#include \"dir.h\"",
      "#include \"debug.h\"",
      "#include \"bitmap.h\"",
      "#include \"aops.h\"",
      "#include \"attrib.h\"",
      "#include <linux/swap.h>",
      "#include <linux/slab.h>",
      "#include <linux/buffer_head.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ntfs_debug",
          "args": [
            "\"Done.  (No free mft records left in currently initialized \"\n\t\t\t\"mft bitmap.)\""
          ],
          "line": 1256
        },
        "resolved": true,
        "details": {
          "function_name": "ntfs_debug_dump_runlist",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/debug.c",
          "lines": "134-171",
          "snippet": "void ntfs_debug_dump_runlist(const runlist_element *rl)\n{\n\tint i;\n\tconst char *lcn_str[5] = { \"LCN_HOLE         \", \"LCN_RL_NOT_MAPPED\",\n\t\t\t\t   \"LCN_ENOENT       \", \"LCN_unknown      \" };\n\n\tif (!debug_msgs)\n\t\treturn;\n\tpr_debug(\"Dumping runlist (values in hex):\\n\");\n\tif (!rl) {\n\t\tpr_debug(\"Run list not present.\\n\");\n\t\treturn;\n\t}\n\tpr_debug(\"VCN              LCN               Run length\\n\");\n\tfor (i = 0; ; i++) {\n\t\tLCN lcn = (rl + i)->lcn;\n\n\t\tif (lcn < (LCN)0) {\n\t\t\tint index = -lcn - 1;\n\n\t\t\tif (index > -LCN_ENOENT - 1)\n\t\t\t\tindex = 3;\n\t\t\tpr_debug(\"%-16Lx %s %-16Lx%s\\n\",\n\t\t\t\t\t(long long)(rl + i)->vcn, lcn_str[index],\n\t\t\t\t\t(long long)(rl + i)->length,\n\t\t\t\t\t(rl + i)->length ? \"\" :\n\t\t\t\t\t\t\" (runlist end)\");\n\t\t} else\n\t\t\tpr_debug(\"%-16Lx %-16Lx  %-16Lx%s\\n\",\n\t\t\t\t\t(long long)(rl + i)->vcn,\n\t\t\t\t\t(long long)(rl + i)->lcn,\n\t\t\t\t\t(long long)(rl + i)->length,\n\t\t\t\t\t(rl + i)->length ? \"\" :\n\t\t\t\t\t\t\" (runlist end)\");\n\t\tif (!(rl + i)->length)\n\t\t\tbreak;\n\t}\n}",
          "includes": [
            "#include \"debug.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"debug.h\"\n\nvoid ntfs_debug_dump_runlist(const runlist_element *rl)\n{\n\tint i;\n\tconst char *lcn_str[5] = { \"LCN_HOLE         \", \"LCN_RL_NOT_MAPPED\",\n\t\t\t\t   \"LCN_ENOENT       \", \"LCN_unknown      \" };\n\n\tif (!debug_msgs)\n\t\treturn;\n\tpr_debug(\"Dumping runlist (values in hex):\\n\");\n\tif (!rl) {\n\t\tpr_debug(\"Run list not present.\\n\");\n\t\treturn;\n\t}\n\tpr_debug(\"VCN              LCN               Run length\\n\");\n\tfor (i = 0; ; i++) {\n\t\tLCN lcn = (rl + i)->lcn;\n\n\t\tif (lcn < (LCN)0) {\n\t\t\tint index = -lcn - 1;\n\n\t\t\tif (index > -LCN_ENOENT - 1)\n\t\t\t\tindex = 3;\n\t\t\tpr_debug(\"%-16Lx %s %-16Lx%s\\n\",\n\t\t\t\t\t(long long)(rl + i)->vcn, lcn_str[index],\n\t\t\t\t\t(long long)(rl + i)->length,\n\t\t\t\t\t(rl + i)->length ? \"\" :\n\t\t\t\t\t\t\" (runlist end)\");\n\t\t} else\n\t\t\tpr_debug(\"%-16Lx %-16Lx  %-16Lx%s\\n\",\n\t\t\t\t\t(long long)(rl + i)->vcn,\n\t\t\t\t\t(long long)(rl + i)->lcn,\n\t\t\t\t\t(long long)(rl + i)->length,\n\t\t\t\t\t(rl + i)->length ? \"\" :\n\t\t\t\t\t\t\" (runlist end)\");\n\t\tif (!(rl + i)->length)\n\t\t\tbreak;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ntfs_debug",
          "args": [
            "\"pass %i, pass_start 0x%llx, pass_end \"\n\t\t\t\t\t\"0x%llx.\"",
            "pass",
            "(long long)pass_start",
            "(long long)pass_end"
          ],
          "line": 1248
        },
        "resolved": true,
        "details": {
          "function_name": "__ntfs_debug",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/debug.c",
          "lines": "115-131",
          "snippet": "void __ntfs_debug(const char *file, int line, const char *function,\n\t\tconst char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\tint flen = 0;\n\n\tif (!debug_msgs)\n\t\treturn;\n\tif (function)\n\t\tflen = strlen(function);\n\tva_start(args, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\tpr_debug(\"(%s, %d): %s(): %pV\", file, line, flen ? function : \"\", &vaf);\n\tva_end(args);\n}",
          "includes": [
            "#include \"debug.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"debug.h\"\n\nvoid __ntfs_debug(const char *file, int line, const char *function,\n\t\tconst char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\tint flen = 0;\n\n\tif (!debug_msgs)\n\t\treturn;\n\tif (function)\n\t\tflen = strlen(function);\n\tva_start(args, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\tpr_debug(\"(%s, %d): %s(): %pV\", file, line, flen ? function : \"\", &vaf);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ntfs_unmap_page",
          "args": [
            "page"
          ],
          "line": 1232
        },
        "resolved": true,
        "details": {
          "function_name": "ntfs_unmap_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/aops.h",
          "lines": "40-44",
          "snippet": "static inline void ntfs_unmap_page(struct page *page)\n{\n\tkunmap(page);\n\tpage_cache_release(page);\n}",
          "includes": [
            "#include \"inode.h\"",
            "#include <linux/fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"inode.h\"\n#include <linux/fs.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n\nstatic inline void ntfs_unmap_page(struct page *page)\n{\n\tkunmap(page);\n\tpage_cache_release(page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ntfs_debug",
          "args": [
            "\"Done.  (Found and \"\n\t\t\t\t\t\t\t\"allocated mft record \"\n\t\t\t\t\t\t\t\"0x%llx.)\"",
            "(long long)ll"
          ],
          "line": 1221
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_page_dirty",
          "args": [
            "page"
          ],
          "line": 1219
        },
        "resolved": true,
        "details": {
          "function_name": "anon_set_page_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/libfs.c",
          "lines": "1040-1043",
          "snippet": "static int anon_set_page_dirty(struct page *page)\n{\n\treturn 0;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/buffer_head.h> /* sync_mapping_buffers */",
            "#include <linux/writeback.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/namei.h>",
            "#include <linux/mutex.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/vfs.h>",
            "#include <linux/mount.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/export.h>",
            "#include <linux/blkdev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <linux/buffer_head.h> /* sync_mapping_buffers */\n#include <linux/writeback.h>\n#include <linux/exportfs.h>\n#include <linux/namei.h>\n#include <linux/mutex.h>\n#include <linux/quotaops.h>\n#include <linux/vfs.h>\n#include <linux/mount.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include <linux/export.h>\n#include <linux/blkdev.h>\n\nstatic int anon_set_page_dirty(struct page *page)\n{\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "flush_dcache_page",
          "args": [
            "page"
          ],
          "line": 1218
        },
        "resolved": true,
        "details": {
          "function_name": "ntfs_index_entry_flush_dcache_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/index.h",
          "lines": "111-117",
          "snippet": "static inline void ntfs_index_entry_flush_dcache_page(ntfs_index_context *ictx)\n{\n\tif (ictx->is_in_root)\n\t\tflush_dcache_mft_record_page(ictx->actx->ntfs_ino);\n\telse\n\t\tflush_dcache_page(ictx->page);\n}",
          "includes": [
            "#include \"aops.h\"",
            "#include \"mft.h\"",
            "#include \"attrib.h\"",
            "#include \"inode.h\"",
            "#include \"layout.h\"",
            "#include \"types.h\"",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"aops.h\"\n#include \"mft.h\"\n#include \"attrib.h\"\n#include \"inode.h\"\n#include \"layout.h\"\n#include \"types.h\"\n#include <linux/fs.h>\n\nstatic inline void ntfs_index_entry_flush_dcache_page(ntfs_index_context *ictx)\n{\n\tif (ictx->is_in_root)\n\t\tflush_dcache_mft_record_page(ictx->actx->ntfs_ino);\n\telse\n\t\tflush_dcache_page(ictx->page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "ll > (1ll << 32)"
          ],
          "line": 1213
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ffz",
          "args": [
            "(unsigned long)*byte"
          ],
          "line": 1210
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_address",
          "args": [
            "page"
          ],
          "line": 1199
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "page"
          ],
          "line": 1197
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntfs_error",
          "args": [
            "vol->sb",
            "\"Failed to read mft \"\n\t\t\t\t\t\t\"bitmap, aborting.\""
          ],
          "line": 1195
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "page"
          ],
          "line": 1194
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntfs_map_page",
          "args": [
            "mftbmp_mapping",
            "ofs >> PAGE_CACHE_SHIFT"
          ],
          "line": 1192
        },
        "resolved": true,
        "details": {
          "function_name": "ntfs_map_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/aops.h",
          "lines": "86-99",
          "snippet": "static inline struct page *ntfs_map_page(struct address_space *mapping,\n\t\tunsigned long index)\n{\n\tstruct page *page = read_mapping_page(mapping, index, NULL);\n\n\tif (!IS_ERR(page)) {\n\t\tkmap(page);\n\t\tif (!PageError(page))\n\t\t\treturn page;\n\t\tntfs_unmap_page(page);\n\t\treturn ERR_PTR(-EIO);\n\t}\n\treturn page;\n}",
          "includes": [
            "#include \"inode.h\"",
            "#include <linux/fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"inode.h\"\n#include <linux/fs.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n\nstatic inline struct page *ntfs_map_page(struct address_space *mapping,\n\t\tunsigned long index)\n{\n\tstruct page *page = read_mapping_page(mapping, index, NULL);\n\n\tif (!IS_ERR(page)) {\n\t\tkmap(page);\n\t\tif (!PageError(page))\n\t\t\treturn page;\n\t\tntfs_unmap_page(page);\n\t\treturn ERR_PTR(-EIO);\n\t}\n\treturn page;\n}"
        }
      },
      {
        "call_info": {
          "callee": "read_unlock_irqrestore",
          "args": [
            "&NTFS_I(vol->mftbmp_ino)->size_lock",
            "flags"
          ],
          "line": 1155
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NTFS_I",
          "args": [
            "vol->mftbmp_ino"
          ],
          "line": 1155
        },
        "resolved": true,
        "details": {
          "function_name": "NTFS_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/inode.h",
          "lines": "240-243",
          "snippet": "static inline ntfs_inode *NTFS_I(struct inode *inode)\n{\n\treturn (ntfs_inode *)list_entry(inode, big_ntfs_inode, vfs_inode);\n}",
          "includes": [
            "#include \"debug.h\"",
            "#include \"runlist.h\"",
            "#include \"types.h\"",
            "#include \"volume.h\"",
            "#include \"layout.h\"",
            "#include <linux/seq_file.h>",
            "#include <linux/mutex.h>",
            "#include <linux/mm.h>",
            "#include <linux/list.h>",
            "#include <linux/fs.h>",
            "#include <linux/atomic.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"debug.h\"\n#include \"runlist.h\"\n#include \"types.h\"\n#include \"volume.h\"\n#include \"layout.h\"\n#include <linux/seq_file.h>\n#include <linux/mutex.h>\n#include <linux/mm.h>\n#include <linux/list.h>\n#include <linux/fs.h>\n#include <linux/atomic.h>\n\nstatic inline ntfs_inode *NTFS_I(struct inode *inode)\n{\n\treturn (ntfs_inode *)list_entry(inode, big_ntfs_inode, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "read_lock_irqsave",
          "args": [
            "&NTFS_I(vol->mftbmp_ino)->size_lock",
            "flags"
          ],
          "line": 1153
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "read_unlock_irqrestore",
          "args": [
            "&NTFS_I(vol->mft_ino)->size_lock",
            "flags"
          ],
          "line": 1152
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "read_lock_irqsave",
          "args": [
            "&NTFS_I(vol->mft_ino)->size_lock",
            "flags"
          ],
          "line": 1149
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ntfs.h\"\n#include \"mft.h\"\n#include \"malloc.h\"\n#include \"lcnalloc.h\"\n#include \"dir.h\"\n#include \"debug.h\"\n#include \"bitmap.h\"\n#include \"aops.h\"\n#include \"attrib.h\"\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n\nstatic int ntfs_mft_bitmap_find_and_alloc_free_rec_nolock(ntfs_volume *vol,\n\t\tntfs_inode *base_ni)\n{\n\ts64 pass_end, ll, data_pos, pass_start, ofs, bit;\n\tunsigned long flags;\n\tstruct address_space *mftbmp_mapping;\n\tu8 *buf, *byte;\n\tstruct page *page;\n\tunsigned int page_ofs, size;\n\tu8 pass, b;\n\n\tntfs_debug(\"Searching for free mft record in the currently \"\n\t\t\t\"initialized mft bitmap.\");\n\tmftbmp_mapping = vol->mftbmp_ino->i_mapping;\n\t/*\n\t * Set the end of the pass making sure we do not overflow the mft\n\t * bitmap.\n\t */\n\tread_lock_irqsave(&NTFS_I(vol->mft_ino)->size_lock, flags);\n\tpass_end = NTFS_I(vol->mft_ino)->allocated_size >>\n\t\t\tvol->mft_record_size_bits;\n\tread_unlock_irqrestore(&NTFS_I(vol->mft_ino)->size_lock, flags);\n\tread_lock_irqsave(&NTFS_I(vol->mftbmp_ino)->size_lock, flags);\n\tll = NTFS_I(vol->mftbmp_ino)->initialized_size << 3;\n\tread_unlock_irqrestore(&NTFS_I(vol->mftbmp_ino)->size_lock, flags);\n\tif (pass_end > ll)\n\t\tpass_end = ll;\n\tpass = 1;\n\tif (!base_ni)\n\t\tdata_pos = vol->mft_data_pos;\n\telse\n\t\tdata_pos = base_ni->mft_no + 1;\n\tif (data_pos < 24)\n\t\tdata_pos = 24;\n\tif (data_pos >= pass_end) {\n\t\tdata_pos = 24;\n\t\tpass = 2;\n\t\t/* This happens on a freshly formatted volume. */\n\t\tif (data_pos >= pass_end)\n\t\t\treturn -ENOSPC;\n\t}\n\tpass_start = data_pos;\n\tntfs_debug(\"Starting bitmap search: pass %u, pass_start 0x%llx, \"\n\t\t\t\"pass_end 0x%llx, data_pos 0x%llx.\", pass,\n\t\t\t(long long)pass_start, (long long)pass_end,\n\t\t\t(long long)data_pos);\n\t/* Loop until a free mft record is found. */\n\tfor (; pass <= 2;) {\n\t\t/* Cap size to pass_end. */\n\t\tofs = data_pos >> 3;\n\t\tpage_ofs = ofs & ~PAGE_CACHE_MASK;\n\t\tsize = PAGE_CACHE_SIZE - page_ofs;\n\t\tll = ((pass_end + 7) >> 3) - ofs;\n\t\tif (size > ll)\n\t\t\tsize = ll;\n\t\tsize <<= 3;\n\t\t/*\n\t\t * If we are still within the active pass, search the next page\n\t\t * for a zero bit.\n\t\t */\n\t\tif (size) {\n\t\t\tpage = ntfs_map_page(mftbmp_mapping,\n\t\t\t\t\tofs >> PAGE_CACHE_SHIFT);\n\t\t\tif (IS_ERR(page)) {\n\t\t\t\tntfs_error(vol->sb, \"Failed to read mft \"\n\t\t\t\t\t\t\"bitmap, aborting.\");\n\t\t\t\treturn PTR_ERR(page);\n\t\t\t}\n\t\t\tbuf = (u8*)page_address(page) + page_ofs;\n\t\t\tbit = data_pos & 7;\n\t\t\tdata_pos &= ~7ull;\n\t\t\tntfs_debug(\"Before inner for loop: size 0x%x, \"\n\t\t\t\t\t\"data_pos 0x%llx, bit 0x%llx\", size,\n\t\t\t\t\t(long long)data_pos, (long long)bit);\n\t\t\tfor (; bit < size && data_pos + bit < pass_end;\n\t\t\t\t\tbit &= ~7ull, bit += 8) {\n\t\t\t\tbyte = buf + (bit >> 3);\n\t\t\t\tif (*byte == 0xff)\n\t\t\t\t\tcontinue;\n\t\t\t\tb = ffz((unsigned long)*byte);\n\t\t\t\tif (b < 8 && b >= (bit & 7)) {\n\t\t\t\t\tll = data_pos + (bit & ~7ull) + b;\n\t\t\t\t\tif (unlikely(ll > (1ll << 32))) {\n\t\t\t\t\t\tntfs_unmap_page(page);\n\t\t\t\t\t\treturn -ENOSPC;\n\t\t\t\t\t}\n\t\t\t\t\t*byte |= 1 << b;\n\t\t\t\t\tflush_dcache_page(page);\n\t\t\t\t\tset_page_dirty(page);\n\t\t\t\t\tntfs_unmap_page(page);\n\t\t\t\t\tntfs_debug(\"Done.  (Found and \"\n\t\t\t\t\t\t\t\"allocated mft record \"\n\t\t\t\t\t\t\t\"0x%llx.)\",\n\t\t\t\t\t\t\t(long long)ll);\n\t\t\t\t\treturn ll;\n\t\t\t\t}\n\t\t\t}\n\t\t\tntfs_debug(\"After inner for loop: size 0x%x, \"\n\t\t\t\t\t\"data_pos 0x%llx, bit 0x%llx\", size,\n\t\t\t\t\t(long long)data_pos, (long long)bit);\n\t\t\tdata_pos += size;\n\t\t\tntfs_unmap_page(page);\n\t\t\t/*\n\t\t\t * If the end of the pass has not been reached yet,\n\t\t\t * continue searching the mft bitmap for a zero bit.\n\t\t\t */\n\t\t\tif (data_pos < pass_end)\n\t\t\t\tcontinue;\n\t\t}\n\t\t/* Do the next pass. */\n\t\tif (++pass == 2) {\n\t\t\t/*\n\t\t\t * Starting the second pass, in which we scan the first\n\t\t\t * part of the zone which we omitted earlier.\n\t\t\t */\n\t\t\tpass_end = pass_start;\n\t\t\tdata_pos = pass_start = 24;\n\t\t\tntfs_debug(\"pass %i, pass_start 0x%llx, pass_end \"\n\t\t\t\t\t\"0x%llx.\", pass, (long long)pass_start,\n\t\t\t\t\t(long long)pass_end);\n\t\t\tif (data_pos >= pass_end)\n\t\t\t\tbreak;\n\t\t}\n\t}\n\t/* No free mft records in currently initialized mft bitmap. */\n\tntfs_debug(\"Done.  (No free mft records left in currently initialized \"\n\t\t\t\"mft bitmap.)\");\n\treturn -ENOSPC;\n}"
  },
  {
    "function_name": "ntfs_may_write_mft_record",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/mft.c",
    "lines": "925-1107",
    "snippet": "bool ntfs_may_write_mft_record(ntfs_volume *vol, const unsigned long mft_no,\n\t\tconst MFT_RECORD *m, ntfs_inode **locked_ni)\n{\n\tstruct super_block *sb = vol->sb;\n\tstruct inode *mft_vi = vol->mft_ino;\n\tstruct inode *vi;\n\tntfs_inode *ni, *eni, **extent_nis;\n\tint i;\n\tntfs_attr na;\n\n\tntfs_debug(\"Entering for inode 0x%lx.\", mft_no);\n\t/*\n\t * Normally we do not return a locked inode so set @locked_ni to NULL.\n\t */\n\tBUG_ON(!locked_ni);\n\t*locked_ni = NULL;\n\t/*\n\t * Check if the inode corresponding to this mft record is in the VFS\n\t * inode cache and obtain a reference to it if it is.\n\t */\n\tntfs_debug(\"Looking for inode 0x%lx in icache.\", mft_no);\n\tna.mft_no = mft_no;\n\tna.name = NULL;\n\tna.name_len = 0;\n\tna.type = AT_UNUSED;\n\t/*\n\t * Optimize inode 0, i.e. $MFT itself, since we have it in memory and\n\t * we get here for it rather often.\n\t */\n\tif (!mft_no) {\n\t\t/* Balance the below iput(). */\n\t\tvi = igrab(mft_vi);\n\t\tBUG_ON(vi != mft_vi);\n\t} else {\n\t\t/*\n\t\t * Have to use ilookup5_nowait() since ilookup5() waits for the\n\t\t * inode lock which causes ntfs to deadlock when a concurrent\n\t\t * inode write via the inode dirty code paths and the page\n\t\t * dirty code path of the inode dirty code path when writing\n\t\t * $MFT occurs.\n\t\t */\n\t\tvi = ilookup5_nowait(sb, mft_no, (test_t)ntfs_test_inode, &na);\n\t}\n\tif (vi) {\n\t\tntfs_debug(\"Base inode 0x%lx is in icache.\", mft_no);\n\t\t/* The inode is in icache. */\n\t\tni = NTFS_I(vi);\n\t\t/* Take a reference to the ntfs inode. */\n\t\tatomic_inc(&ni->count);\n\t\t/* If the inode is dirty, do not write this record. */\n\t\tif (NInoDirty(ni)) {\n\t\t\tntfs_debug(\"Inode 0x%lx is dirty, do not write it.\",\n\t\t\t\t\tmft_no);\n\t\t\tatomic_dec(&ni->count);\n\t\t\tiput(vi);\n\t\t\treturn false;\n\t\t}\n\t\tntfs_debug(\"Inode 0x%lx is not dirty.\", mft_no);\n\t\t/* The inode is not dirty, try to take the mft record lock. */\n\t\tif (unlikely(!mutex_trylock(&ni->mrec_lock))) {\n\t\t\tntfs_debug(\"Mft record 0x%lx is already locked, do \"\n\t\t\t\t\t\"not write it.\", mft_no);\n\t\t\tatomic_dec(&ni->count);\n\t\t\tiput(vi);\n\t\t\treturn false;\n\t\t}\n\t\tntfs_debug(\"Managed to lock mft record 0x%lx, write it.\",\n\t\t\t\tmft_no);\n\t\t/*\n\t\t * The write has to occur while we hold the mft record lock so\n\t\t * return the locked ntfs inode.\n\t\t */\n\t\t*locked_ni = ni;\n\t\treturn true;\n\t}\n\tntfs_debug(\"Inode 0x%lx is not in icache.\", mft_no);\n\t/* The inode is not in icache. */\n\t/* Write the record if it is not a mft record (type \"FILE\"). */\n\tif (!ntfs_is_mft_record(m->magic)) {\n\t\tntfs_debug(\"Mft record 0x%lx is not a FILE record, write it.\",\n\t\t\t\tmft_no);\n\t\treturn true;\n\t}\n\t/* Write the mft record if it is a base inode. */\n\tif (!m->base_mft_record) {\n\t\tntfs_debug(\"Mft record 0x%lx is a base record, write it.\",\n\t\t\t\tmft_no);\n\t\treturn true;\n\t}\n\t/*\n\t * This is an extent mft record.  Check if the inode corresponding to\n\t * its base mft record is in icache and obtain a reference to it if it\n\t * is.\n\t */\n\tna.mft_no = MREF_LE(m->base_mft_record);\n\tntfs_debug(\"Mft record 0x%lx is an extent record.  Looking for base \"\n\t\t\t\"inode 0x%lx in icache.\", mft_no, na.mft_no);\n\tif (!na.mft_no) {\n\t\t/* Balance the below iput(). */\n\t\tvi = igrab(mft_vi);\n\t\tBUG_ON(vi != mft_vi);\n\t} else\n\t\tvi = ilookup5_nowait(sb, na.mft_no, (test_t)ntfs_test_inode,\n\t\t\t\t&na);\n\tif (!vi) {\n\t\t/*\n\t\t * The base inode is not in icache, write this extent mft\n\t\t * record.\n\t\t */\n\t\tntfs_debug(\"Base inode 0x%lx is not in icache, write the \"\n\t\t\t\t\"extent record.\", na.mft_no);\n\t\treturn true;\n\t}\n\tntfs_debug(\"Base inode 0x%lx is in icache.\", na.mft_no);\n\t/*\n\t * The base inode is in icache.  Check if it has the extent inode\n\t * corresponding to this extent mft record attached.\n\t */\n\tni = NTFS_I(vi);\n\tmutex_lock(&ni->extent_lock);\n\tif (ni->nr_extents <= 0) {\n\t\t/*\n\t\t * The base inode has no attached extent inodes, write this\n\t\t * extent mft record.\n\t\t */\n\t\tmutex_unlock(&ni->extent_lock);\n\t\tiput(vi);\n\t\tntfs_debug(\"Base inode 0x%lx has no attached extent inodes, \"\n\t\t\t\t\"write the extent record.\", na.mft_no);\n\t\treturn true;\n\t}\n\t/* Iterate over the attached extent inodes. */\n\textent_nis = ni->ext.extent_ntfs_inos;\n\tfor (eni = NULL, i = 0; i < ni->nr_extents; ++i) {\n\t\tif (mft_no == extent_nis[i]->mft_no) {\n\t\t\t/*\n\t\t\t * Found the extent inode corresponding to this extent\n\t\t\t * mft record.\n\t\t\t */\n\t\t\teni = extent_nis[i];\n\t\t\tbreak;\n\t\t}\n\t}\n\t/*\n\t * If the extent inode was not attached to the base inode, write this\n\t * extent mft record.\n\t */\n\tif (!eni) {\n\t\tmutex_unlock(&ni->extent_lock);\n\t\tiput(vi);\n\t\tntfs_debug(\"Extent inode 0x%lx is not attached to its base \"\n\t\t\t\t\"inode 0x%lx, write the extent record.\",\n\t\t\t\tmft_no, na.mft_no);\n\t\treturn true;\n\t}\n\tntfs_debug(\"Extent inode 0x%lx is attached to its base inode 0x%lx.\",\n\t\t\tmft_no, na.mft_no);\n\t/* Take a reference to the extent ntfs inode. */\n\tatomic_inc(&eni->count);\n\tmutex_unlock(&ni->extent_lock);\n\t/*\n\t * Found the extent inode coresponding to this extent mft record.\n\t * Try to take the mft record lock.\n\t */\n\tif (unlikely(!mutex_trylock(&eni->mrec_lock))) {\n\t\tatomic_dec(&eni->count);\n\t\tiput(vi);\n\t\tntfs_debug(\"Extent mft record 0x%lx is already locked, do \"\n\t\t\t\t\"not write it.\", mft_no);\n\t\treturn false;\n\t}\n\tntfs_debug(\"Managed to lock extent mft record 0x%lx, write it.\",\n\t\t\tmft_no);\n\tif (NInoTestClearDirty(eni))\n\t\tntfs_debug(\"Extent inode 0x%lx is dirty, marking it clean.\",\n\t\t\t\tmft_no);\n\t/*\n\t * The write has to occur while we hold the mft record lock so return\n\t * the locked extent ntfs inode.\n\t */\n\t*locked_ni = eni;\n\treturn true;\n}",
    "includes": [
      "#include \"ntfs.h\"",
      "#include \"mft.h\"",
      "#include \"malloc.h\"",
      "#include \"lcnalloc.h\"",
      "#include \"dir.h\"",
      "#include \"debug.h\"",
      "#include \"bitmap.h\"",
      "#include \"aops.h\"",
      "#include \"attrib.h\"",
      "#include <linux/swap.h>",
      "#include <linux/slab.h>",
      "#include <linux/buffer_head.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ntfs_debug",
          "args": [
            "\"Extent inode 0x%lx is dirty, marking it clean.\"",
            "mft_no"
          ],
          "line": 1099
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NInoTestClearDirty",
          "args": [
            "eni"
          ],
          "line": 1098
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntfs_debug",
          "args": [
            "\"Managed to lock extent mft record 0x%lx, write it.\"",
            "mft_no"
          ],
          "line": 1096
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntfs_debug",
          "args": [
            "\"Extent mft record 0x%lx is already locked, do \"\n\t\t\t\t\"not write it.\"",
            "mft_no"
          ],
          "line": 1092
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "iput",
          "args": [
            "vi"
          ],
          "line": 1091
        },
        "resolved": true,
        "details": {
          "function_name": "dentry_iput",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "308-327",
          "snippet": "static void dentry_iput(struct dentry * dentry)\n\t__releases(dentry->d_lock)\n\t__releases(dentry->d_inode->i_lock)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tif (inode) {\n\t\tdentry->d_inode = NULL;\n\t\thlist_del_init(&dentry->d_u.d_alias);\n\t\tspin_unlock(&dentry->d_lock);\n\t\tspin_unlock(&inode->i_lock);\n\t\tif (!inode->i_nlink)\n\t\t\tfsnotify_inoderemove(inode);\n\t\tif (dentry->d_op && dentry->d_op->d_iput)\n\t\t\tdentry->d_op->d_iput(dentry, inode);\n\t\telse\n\t\t\tiput(inode);\n\t} else {\n\t\tspin_unlock(&dentry->d_lock);\n\t}\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nstatic void dentry_iput(struct dentry * dentry)\n\t__releases(dentry->d_lock)\n\t__releases(dentry->d_inode->i_lock)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tif (inode) {\n\t\tdentry->d_inode = NULL;\n\t\thlist_del_init(&dentry->d_u.d_alias);\n\t\tspin_unlock(&dentry->d_lock);\n\t\tspin_unlock(&inode->i_lock);\n\t\tif (!inode->i_nlink)\n\t\t\tfsnotify_inoderemove(inode);\n\t\tif (dentry->d_op && dentry->d_op->d_iput)\n\t\t\tdentry->d_op->d_iput(dentry, inode);\n\t\telse\n\t\t\tiput(inode);\n\t} else {\n\t\tspin_unlock(&dentry->d_lock);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_dec",
          "args": [
            "&eni->count"
          ],
          "line": 1090
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!mutex_trylock(&eni->mrec_lock)"
          ],
          "line": 1089
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_trylock",
          "args": [
            "&eni->mrec_lock"
          ],
          "line": 1089
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&ni->extent_lock"
          ],
          "line": 1084
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_inc",
          "args": [
            "&eni->count"
          ],
          "line": 1083
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntfs_debug",
          "args": [
            "\"Extent inode 0x%lx is attached to its base inode 0x%lx.\"",
            "mft_no",
            "na.mft_no"
          ],
          "line": 1080
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntfs_debug",
          "args": [
            "\"Extent inode 0x%lx is not attached to its base \"\n\t\t\t\t\"inode 0x%lx, write the extent record.\"",
            "mft_no",
            "na.mft_no"
          ],
          "line": 1075
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&ni->extent_lock"
          ],
          "line": 1073
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntfs_debug",
          "args": [
            "\"Base inode 0x%lx has no attached extent inodes, \"\n\t\t\t\t\"write the extent record.\"",
            "na.mft_no"
          ],
          "line": 1052
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&ni->extent_lock"
          ],
          "line": 1050
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&ni->extent_lock"
          ],
          "line": 1044
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NTFS_I",
          "args": [
            "vi"
          ],
          "line": 1043
        },
        "resolved": true,
        "details": {
          "function_name": "NTFS_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/inode.h",
          "lines": "240-243",
          "snippet": "static inline ntfs_inode *NTFS_I(struct inode *inode)\n{\n\treturn (ntfs_inode *)list_entry(inode, big_ntfs_inode, vfs_inode);\n}",
          "includes": [
            "#include \"debug.h\"",
            "#include \"runlist.h\"",
            "#include \"types.h\"",
            "#include \"volume.h\"",
            "#include \"layout.h\"",
            "#include <linux/seq_file.h>",
            "#include <linux/mutex.h>",
            "#include <linux/mm.h>",
            "#include <linux/list.h>",
            "#include <linux/fs.h>",
            "#include <linux/atomic.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"debug.h\"\n#include \"runlist.h\"\n#include \"types.h\"\n#include \"volume.h\"\n#include \"layout.h\"\n#include <linux/seq_file.h>\n#include <linux/mutex.h>\n#include <linux/mm.h>\n#include <linux/list.h>\n#include <linux/fs.h>\n#include <linux/atomic.h>\n\nstatic inline ntfs_inode *NTFS_I(struct inode *inode)\n{\n\treturn (ntfs_inode *)list_entry(inode, big_ntfs_inode, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ntfs_debug",
          "args": [
            "\"Base inode 0x%lx is in icache.\"",
            "na.mft_no"
          ],
          "line": 1038
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntfs_debug",
          "args": [
            "\"Base inode 0x%lx is not in icache, write the \"\n\t\t\t\t\"extent record.\"",
            "na.mft_no"
          ],
          "line": 1034
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ilookup5_nowait",
          "args": [
            "sb",
            "na.mft_no",
            "(test_t)ntfs_test_inode",
            "&na"
          ],
          "line": 1027
        },
        "resolved": true,
        "details": {
          "function_name": "ilookup5_nowait",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "1208-1219",
          "snippet": "struct inode *ilookup5_nowait(struct super_block *sb, unsigned long hashval,\n\t\tint (*test)(struct inode *, void *), void *data)\n{\n\tstruct hlist_head *head = inode_hashtable + hash(sb, hashval);\n\tstruct inode *inode;\n\n\tspin_lock(&inode_hash_lock);\n\tinode = find_inode(sb, head, test, data);\n\tspin_unlock(&inode_hash_lock);\n\n\treturn inode;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct hlist_head *inode_hashtable",
            "static __cacheline_aligned_in_smp DEFINE_SPINLOCK(inode_hash_lock);",
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic struct hlist_head *inode_hashtable;\nstatic __cacheline_aligned_in_smp DEFINE_SPINLOCK(inode_hash_lock);\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nstruct inode *ilookup5_nowait(struct super_block *sb, unsigned long hashval,\n\t\tint (*test)(struct inode *, void *), void *data)\n{\n\tstruct hlist_head *head = inode_hashtable + hash(sb, hashval);\n\tstruct inode *inode;\n\n\tspin_lock(&inode_hash_lock);\n\tinode = find_inode(sb, head, test, data);\n\tspin_unlock(&inode_hash_lock);\n\n\treturn inode;\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "vi != mft_vi"
          ],
          "line": 1025
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "igrab",
          "args": [
            "mft_vi"
          ],
          "line": 1024
        },
        "resolved": true,
        "details": {
          "function_name": "igrab",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "1173-1189",
          "snippet": "struct inode *igrab(struct inode *inode)\n{\n\tspin_lock(&inode->i_lock);\n\tif (!(inode->i_state & (I_FREEING|I_WILL_FREE))) {\n\t\t__iget(inode);\n\t\tspin_unlock(&inode->i_lock);\n\t} else {\n\t\tspin_unlock(&inode->i_lock);\n\t\t/*\n\t\t * Handle the case where s_op->clear_inode is not been\n\t\t * called yet, and somebody is calling igrab\n\t\t * while the inode is getting freed.\n\t\t */\n\t\tinode = NULL;\n\t}\n\treturn inode;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nstruct inode *igrab(struct inode *inode)\n{\n\tspin_lock(&inode->i_lock);\n\tif (!(inode->i_state & (I_FREEING|I_WILL_FREE))) {\n\t\t__iget(inode);\n\t\tspin_unlock(&inode->i_lock);\n\t} else {\n\t\tspin_unlock(&inode->i_lock);\n\t\t/*\n\t\t * Handle the case where s_op->clear_inode is not been\n\t\t * called yet, and somebody is calling igrab\n\t\t * while the inode is getting freed.\n\t\t */\n\t\tinode = NULL;\n\t}\n\treturn inode;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ntfs_debug",
          "args": [
            "\"Mft record 0x%lx is an extent record.  Looking for base \"\n\t\t\t\"inode 0x%lx in icache.\"",
            "mft_no",
            "na.mft_no"
          ],
          "line": 1020
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MREF_LE",
          "args": [
            "m->base_mft_record"
          ],
          "line": 1019
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntfs_debug",
          "args": [
            "\"Mft record 0x%lx is a base record, write it.\"",
            "mft_no"
          ],
          "line": 1010
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntfs_debug",
          "args": [
            "\"Mft record 0x%lx is not a FILE record, write it.\"",
            "mft_no"
          ],
          "line": 1004
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntfs_is_mft_record",
          "args": [
            "m->magic"
          ],
          "line": 1003
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntfs_debug",
          "args": [
            "\"Inode 0x%lx is not in icache.\"",
            "mft_no"
          ],
          "line": 1000
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntfs_debug",
          "args": [
            "\"Managed to lock mft record 0x%lx, write it.\"",
            "mft_no"
          ],
          "line": 991
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_dec",
          "args": [
            "&ni->count"
          ],
          "line": 987
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntfs_debug",
          "args": [
            "\"Mft record 0x%lx is already locked, do \"\n\t\t\t\t\t\"not write it.\"",
            "mft_no"
          ],
          "line": 985
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!mutex_trylock(&ni->mrec_lock)"
          ],
          "line": 984
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_trylock",
          "args": [
            "&ni->mrec_lock"
          ],
          "line": 984
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntfs_debug",
          "args": [
            "\"Inode 0x%lx is not dirty.\"",
            "mft_no"
          ],
          "line": 982
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_dec",
          "args": [
            "&ni->count"
          ],
          "line": 978
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntfs_debug",
          "args": [
            "\"Inode 0x%lx is dirty, do not write it.\"",
            "mft_no"
          ],
          "line": 976
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NInoDirty",
          "args": [
            "ni"
          ],
          "line": 975
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_inc",
          "args": [
            "&ni->count"
          ],
          "line": 973
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntfs_debug",
          "args": [
            "\"Base inode 0x%lx is in icache.\"",
            "mft_no"
          ],
          "line": 969
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "vi != mft_vi"
          ],
          "line": 957
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntfs_debug",
          "args": [
            "\"Looking for inode 0x%lx in icache.\"",
            "mft_no"
          ],
          "line": 945
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!locked_ni"
          ],
          "line": 939
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntfs_debug",
          "args": [
            "\"Entering for inode 0x%lx.\"",
            "mft_no"
          ],
          "line": 935
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ntfs.h\"\n#include \"mft.h\"\n#include \"malloc.h\"\n#include \"lcnalloc.h\"\n#include \"dir.h\"\n#include \"debug.h\"\n#include \"bitmap.h\"\n#include \"aops.h\"\n#include \"attrib.h\"\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n\nbool ntfs_may_write_mft_record(ntfs_volume *vol, const unsigned long mft_no,\n\t\tconst MFT_RECORD *m, ntfs_inode **locked_ni)\n{\n\tstruct super_block *sb = vol->sb;\n\tstruct inode *mft_vi = vol->mft_ino;\n\tstruct inode *vi;\n\tntfs_inode *ni, *eni, **extent_nis;\n\tint i;\n\tntfs_attr na;\n\n\tntfs_debug(\"Entering for inode 0x%lx.\", mft_no);\n\t/*\n\t * Normally we do not return a locked inode so set @locked_ni to NULL.\n\t */\n\tBUG_ON(!locked_ni);\n\t*locked_ni = NULL;\n\t/*\n\t * Check if the inode corresponding to this mft record is in the VFS\n\t * inode cache and obtain a reference to it if it is.\n\t */\n\tntfs_debug(\"Looking for inode 0x%lx in icache.\", mft_no);\n\tna.mft_no = mft_no;\n\tna.name = NULL;\n\tna.name_len = 0;\n\tna.type = AT_UNUSED;\n\t/*\n\t * Optimize inode 0, i.e. $MFT itself, since we have it in memory and\n\t * we get here for it rather often.\n\t */\n\tif (!mft_no) {\n\t\t/* Balance the below iput(). */\n\t\tvi = igrab(mft_vi);\n\t\tBUG_ON(vi != mft_vi);\n\t} else {\n\t\t/*\n\t\t * Have to use ilookup5_nowait() since ilookup5() waits for the\n\t\t * inode lock which causes ntfs to deadlock when a concurrent\n\t\t * inode write via the inode dirty code paths and the page\n\t\t * dirty code path of the inode dirty code path when writing\n\t\t * $MFT occurs.\n\t\t */\n\t\tvi = ilookup5_nowait(sb, mft_no, (test_t)ntfs_test_inode, &na);\n\t}\n\tif (vi) {\n\t\tntfs_debug(\"Base inode 0x%lx is in icache.\", mft_no);\n\t\t/* The inode is in icache. */\n\t\tni = NTFS_I(vi);\n\t\t/* Take a reference to the ntfs inode. */\n\t\tatomic_inc(&ni->count);\n\t\t/* If the inode is dirty, do not write this record. */\n\t\tif (NInoDirty(ni)) {\n\t\t\tntfs_debug(\"Inode 0x%lx is dirty, do not write it.\",\n\t\t\t\t\tmft_no);\n\t\t\tatomic_dec(&ni->count);\n\t\t\tiput(vi);\n\t\t\treturn false;\n\t\t}\n\t\tntfs_debug(\"Inode 0x%lx is not dirty.\", mft_no);\n\t\t/* The inode is not dirty, try to take the mft record lock. */\n\t\tif (unlikely(!mutex_trylock(&ni->mrec_lock))) {\n\t\t\tntfs_debug(\"Mft record 0x%lx is already locked, do \"\n\t\t\t\t\t\"not write it.\", mft_no);\n\t\t\tatomic_dec(&ni->count);\n\t\t\tiput(vi);\n\t\t\treturn false;\n\t\t}\n\t\tntfs_debug(\"Managed to lock mft record 0x%lx, write it.\",\n\t\t\t\tmft_no);\n\t\t/*\n\t\t * The write has to occur while we hold the mft record lock so\n\t\t * return the locked ntfs inode.\n\t\t */\n\t\t*locked_ni = ni;\n\t\treturn true;\n\t}\n\tntfs_debug(\"Inode 0x%lx is not in icache.\", mft_no);\n\t/* The inode is not in icache. */\n\t/* Write the record if it is not a mft record (type \"FILE\"). */\n\tif (!ntfs_is_mft_record(m->magic)) {\n\t\tntfs_debug(\"Mft record 0x%lx is not a FILE record, write it.\",\n\t\t\t\tmft_no);\n\t\treturn true;\n\t}\n\t/* Write the mft record if it is a base inode. */\n\tif (!m->base_mft_record) {\n\t\tntfs_debug(\"Mft record 0x%lx is a base record, write it.\",\n\t\t\t\tmft_no);\n\t\treturn true;\n\t}\n\t/*\n\t * This is an extent mft record.  Check if the inode corresponding to\n\t * its base mft record is in icache and obtain a reference to it if it\n\t * is.\n\t */\n\tna.mft_no = MREF_LE(m->base_mft_record);\n\tntfs_debug(\"Mft record 0x%lx is an extent record.  Looking for base \"\n\t\t\t\"inode 0x%lx in icache.\", mft_no, na.mft_no);\n\tif (!na.mft_no) {\n\t\t/* Balance the below iput(). */\n\t\tvi = igrab(mft_vi);\n\t\tBUG_ON(vi != mft_vi);\n\t} else\n\t\tvi = ilookup5_nowait(sb, na.mft_no, (test_t)ntfs_test_inode,\n\t\t\t\t&na);\n\tif (!vi) {\n\t\t/*\n\t\t * The base inode is not in icache, write this extent mft\n\t\t * record.\n\t\t */\n\t\tntfs_debug(\"Base inode 0x%lx is not in icache, write the \"\n\t\t\t\t\"extent record.\", na.mft_no);\n\t\treturn true;\n\t}\n\tntfs_debug(\"Base inode 0x%lx is in icache.\", na.mft_no);\n\t/*\n\t * The base inode is in icache.  Check if it has the extent inode\n\t * corresponding to this extent mft record attached.\n\t */\n\tni = NTFS_I(vi);\n\tmutex_lock(&ni->extent_lock);\n\tif (ni->nr_extents <= 0) {\n\t\t/*\n\t\t * The base inode has no attached extent inodes, write this\n\t\t * extent mft record.\n\t\t */\n\t\tmutex_unlock(&ni->extent_lock);\n\t\tiput(vi);\n\t\tntfs_debug(\"Base inode 0x%lx has no attached extent inodes, \"\n\t\t\t\t\"write the extent record.\", na.mft_no);\n\t\treturn true;\n\t}\n\t/* Iterate over the attached extent inodes. */\n\textent_nis = ni->ext.extent_ntfs_inos;\n\tfor (eni = NULL, i = 0; i < ni->nr_extents; ++i) {\n\t\tif (mft_no == extent_nis[i]->mft_no) {\n\t\t\t/*\n\t\t\t * Found the extent inode corresponding to this extent\n\t\t\t * mft record.\n\t\t\t */\n\t\t\teni = extent_nis[i];\n\t\t\tbreak;\n\t\t}\n\t}\n\t/*\n\t * If the extent inode was not attached to the base inode, write this\n\t * extent mft record.\n\t */\n\tif (!eni) {\n\t\tmutex_unlock(&ni->extent_lock);\n\t\tiput(vi);\n\t\tntfs_debug(\"Extent inode 0x%lx is not attached to its base \"\n\t\t\t\t\"inode 0x%lx, write the extent record.\",\n\t\t\t\tmft_no, na.mft_no);\n\t\treturn true;\n\t}\n\tntfs_debug(\"Extent inode 0x%lx is attached to its base inode 0x%lx.\",\n\t\t\tmft_no, na.mft_no);\n\t/* Take a reference to the extent ntfs inode. */\n\tatomic_inc(&eni->count);\n\tmutex_unlock(&ni->extent_lock);\n\t/*\n\t * Found the extent inode coresponding to this extent mft record.\n\t * Try to take the mft record lock.\n\t */\n\tif (unlikely(!mutex_trylock(&eni->mrec_lock))) {\n\t\tatomic_dec(&eni->count);\n\t\tiput(vi);\n\t\tntfs_debug(\"Extent mft record 0x%lx is already locked, do \"\n\t\t\t\t\"not write it.\", mft_no);\n\t\treturn false;\n\t}\n\tntfs_debug(\"Managed to lock extent mft record 0x%lx, write it.\",\n\t\t\tmft_no);\n\tif (NInoTestClearDirty(eni))\n\t\tntfs_debug(\"Extent inode 0x%lx is dirty, marking it clean.\",\n\t\t\t\tmft_no);\n\t/*\n\t * The write has to occur while we hold the mft record lock so return\n\t * the locked extent ntfs inode.\n\t */\n\t*locked_ni = eni;\n\treturn true;\n}"
  },
  {
    "function_name": "write_mft_record_nolock",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/mft.c",
    "lines": "669-844",
    "snippet": "int write_mft_record_nolock(ntfs_inode *ni, MFT_RECORD *m, int sync)\n{\n\tntfs_volume *vol = ni->vol;\n\tstruct page *page = ni->page;\n\tunsigned int blocksize = vol->sb->s_blocksize;\n\tunsigned char blocksize_bits = vol->sb->s_blocksize_bits;\n\tint max_bhs = vol->mft_record_size / blocksize;\n\tstruct buffer_head *bhs[max_bhs];\n\tstruct buffer_head *bh, *head;\n\trunlist_element *rl;\n\tunsigned int block_start, block_end, m_start, m_end;\n\tint i_bhs, nr_bhs, err = 0;\n\n\tntfs_debug(\"Entering for inode 0x%lx.\", ni->mft_no);\n\tBUG_ON(NInoAttr(ni));\n\tBUG_ON(!max_bhs);\n\tBUG_ON(!PageLocked(page));\n\t/*\n\t * If the ntfs_inode is clean no need to do anything.  If it is dirty,\n\t * mark it as clean now so that it can be redirtied later on if needed.\n\t * There is no danger of races since the caller is holding the locks\n\t * for the mft record @m and the page it is in.\n\t */\n\tif (!NInoTestClearDirty(ni))\n\t\tgoto done;\n\tbh = head = page_buffers(page);\n\tBUG_ON(!bh);\n\trl = NULL;\n\tnr_bhs = 0;\n\tblock_start = 0;\n\tm_start = ni->page_ofs;\n\tm_end = m_start + vol->mft_record_size;\n\tdo {\n\t\tblock_end = block_start + blocksize;\n\t\t/* If the buffer is outside the mft record, skip it. */\n\t\tif (block_end <= m_start)\n\t\t\tcontinue;\n\t\tif (unlikely(block_start >= m_end))\n\t\t\tbreak;\n\t\t/*\n\t\t * If this block is not the first one in the record, we ignore\n\t\t * the buffer's dirty state because we could have raced with a\n\t\t * parallel mark_ntfs_record_dirty().\n\t\t */\n\t\tif (block_start == m_start) {\n\t\t\t/* This block is the first one in the record. */\n\t\t\tif (!buffer_dirty(bh)) {\n\t\t\t\tBUG_ON(nr_bhs);\n\t\t\t\t/* Clean records are not written out. */\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\t/* Need to map the buffer if it is not mapped already. */\n\t\tif (unlikely(!buffer_mapped(bh))) {\n\t\t\tVCN vcn;\n\t\t\tLCN lcn;\n\t\t\tunsigned int vcn_ofs;\n\n\t\t\tbh->b_bdev = vol->sb->s_bdev;\n\t\t\t/* Obtain the vcn and offset of the current block. */\n\t\t\tvcn = ((VCN)ni->mft_no << vol->mft_record_size_bits) +\n\t\t\t\t\t(block_start - m_start);\n\t\t\tvcn_ofs = vcn & vol->cluster_size_mask;\n\t\t\tvcn >>= vol->cluster_size_bits;\n\t\t\tif (!rl) {\n\t\t\t\tdown_read(&NTFS_I(vol->mft_ino)->runlist.lock);\n\t\t\t\trl = NTFS_I(vol->mft_ino)->runlist.rl;\n\t\t\t\tBUG_ON(!rl);\n\t\t\t}\n\t\t\t/* Seek to element containing target vcn. */\n\t\t\twhile (rl->length && rl[1].vcn <= vcn)\n\t\t\t\trl++;\n\t\t\tlcn = ntfs_rl_vcn_to_lcn(rl, vcn);\n\t\t\t/* For $MFT, only lcn >= 0 is a successful remap. */\n\t\t\tif (likely(lcn >= 0)) {\n\t\t\t\t/* Setup buffer head to correct block. */\n\t\t\t\tbh->b_blocknr = ((lcn <<\n\t\t\t\t\t\tvol->cluster_size_bits) +\n\t\t\t\t\t\tvcn_ofs) >> blocksize_bits;\n\t\t\t\tset_buffer_mapped(bh);\n\t\t\t} else {\n\t\t\t\tbh->b_blocknr = -1;\n\t\t\t\tntfs_error(vol->sb, \"Cannot write mft record \"\n\t\t\t\t\t\t\"0x%lx because its location \"\n\t\t\t\t\t\t\"on disk could not be \"\n\t\t\t\t\t\t\"determined (error code %lli).\",\n\t\t\t\t\t\tni->mft_no, (long long)lcn);\n\t\t\t\terr = -EIO;\n\t\t\t}\n\t\t}\n\t\tBUG_ON(!buffer_uptodate(bh));\n\t\tBUG_ON(!nr_bhs && (m_start != block_start));\n\t\tBUG_ON(nr_bhs >= max_bhs);\n\t\tbhs[nr_bhs++] = bh;\n\t\tBUG_ON((nr_bhs >= max_bhs) && (m_end != block_end));\n\t} while (block_start = block_end, (bh = bh->b_this_page) != head);\n\tif (unlikely(rl))\n\t\tup_read(&NTFS_I(vol->mft_ino)->runlist.lock);\n\tif (!nr_bhs)\n\t\tgoto done;\n\tif (unlikely(err))\n\t\tgoto cleanup_out;\n\t/* Apply the mst protection fixups. */\n\terr = pre_write_mst_fixup((NTFS_RECORD*)m, vol->mft_record_size);\n\tif (err) {\n\t\tntfs_error(vol->sb, \"Failed to apply mst fixups!\");\n\t\tgoto cleanup_out;\n\t}\n\tflush_dcache_mft_record_page(ni);\n\t/* Lock buffers and start synchronous write i/o on them. */\n\tfor (i_bhs = 0; i_bhs < nr_bhs; i_bhs++) {\n\t\tstruct buffer_head *tbh = bhs[i_bhs];\n\n\t\tif (!trylock_buffer(tbh))\n\t\t\tBUG();\n\t\tBUG_ON(!buffer_uptodate(tbh));\n\t\tclear_buffer_dirty(tbh);\n\t\tget_bh(tbh);\n\t\ttbh->b_end_io = end_buffer_write_sync;\n\t\tsubmit_bh(WRITE, tbh);\n\t}\n\t/* Synchronize the mft mirror now if not @sync. */\n\tif (!sync && ni->mft_no < vol->mftmirr_size)\n\t\tntfs_sync_mft_mirror(vol, ni->mft_no, m, sync);\n\t/* Wait on i/o completion of buffers. */\n\tfor (i_bhs = 0; i_bhs < nr_bhs; i_bhs++) {\n\t\tstruct buffer_head *tbh = bhs[i_bhs];\n\n\t\twait_on_buffer(tbh);\n\t\tif (unlikely(!buffer_uptodate(tbh))) {\n\t\t\terr = -EIO;\n\t\t\t/*\n\t\t\t * Set the buffer uptodate so the page and buffer\n\t\t\t * states do not become out of sync.\n\t\t\t */\n\t\t\tif (PageUptodate(page))\n\t\t\t\tset_buffer_uptodate(tbh);\n\t\t}\n\t}\n\t/* If @sync, now synchronize the mft mirror. */\n\tif (sync && ni->mft_no < vol->mftmirr_size)\n\t\tntfs_sync_mft_mirror(vol, ni->mft_no, m, sync);\n\t/* Remove the mst protection fixups again. */\n\tpost_write_mst_fixup((NTFS_RECORD*)m);\n\tflush_dcache_mft_record_page(ni);\n\tif (unlikely(err)) {\n\t\t/* I/O error during writing.  This is really bad! */\n\t\tntfs_error(vol->sb, \"I/O error while writing mft record \"\n\t\t\t\t\"0x%lx!  Marking base inode as bad.  You \"\n\t\t\t\t\"should unmount the volume and run chkdsk.\",\n\t\t\t\tni->mft_no);\n\t\tgoto err_out;\n\t}\ndone:\n\tntfs_debug(\"Done.\");\n\treturn 0;\ncleanup_out:\n\t/* Clean the buffers. */\n\tfor (i_bhs = 0; i_bhs < nr_bhs; i_bhs++)\n\t\tclear_buffer_dirty(bhs[i_bhs]);\nerr_out:\n\t/*\n\t * Current state: all buffers are clean, unlocked, and uptodate.\n\t * The caller should mark the base inode as bad so that no more i/o\n\t * happens.  ->clear_inode() will still be invoked so all extent inodes\n\t * and other allocated memory will be freed.\n\t */\n\tif (err == -ENOMEM) {\n\t\tntfs_error(vol->sb, \"Not enough memory to write mft record.  \"\n\t\t\t\t\"Redirtying so the write is retried later.\");\n\t\tmark_mft_record_dirty(ni);\n\t\terr = 0;\n\t} else\n\t\tNVolSetErrors(vol);\n\treturn err;\n}",
    "includes": [
      "#include \"ntfs.h\"",
      "#include \"mft.h\"",
      "#include \"malloc.h\"",
      "#include \"lcnalloc.h\"",
      "#include \"dir.h\"",
      "#include \"debug.h\"",
      "#include \"bitmap.h\"",
      "#include \"aops.h\"",
      "#include \"attrib.h\"",
      "#include <linux/swap.h>",
      "#include <linux/slab.h>",
      "#include <linux/buffer_head.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "NVolSetErrors",
          "args": [
            "vol"
          ],
          "line": 842
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mark_mft_record_dirty",
          "args": [
            "ni"
          ],
          "line": 839
        },
        "resolved": true,
        "details": {
          "function_name": "__mark_mft_record_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/mft.c",
          "lines": "395-410",
          "snippet": "void __mark_mft_record_dirty(ntfs_inode *ni)\n{\n\tntfs_inode *base_ni;\n\n\tntfs_debug(\"Entering for inode 0x%lx.\", ni->mft_no);\n\tBUG_ON(NInoAttr(ni));\n\tmark_ntfs_record_dirty(ni->page, ni->page_ofs);\n\t/* Determine the base vfs inode and mark it dirty, too. */\n\tmutex_lock(&ni->extent_lock);\n\tif (likely(ni->nr_extents >= 0))\n\t\tbase_ni = ni;\n\telse\n\t\tbase_ni = ni->ext.base_ntfs_ino;\n\tmutex_unlock(&ni->extent_lock);\n\t__mark_inode_dirty(VFS_I(base_ni), I_DIRTY_SYNC | I_DIRTY_DATASYNC);\n}",
          "includes": [
            "#include \"ntfs.h\"",
            "#include \"mft.h\"",
            "#include \"malloc.h\"",
            "#include \"lcnalloc.h\"",
            "#include \"dir.h\"",
            "#include \"debug.h\"",
            "#include \"bitmap.h\"",
            "#include \"aops.h\"",
            "#include \"attrib.h\"",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ntfs.h\"\n#include \"mft.h\"\n#include \"malloc.h\"\n#include \"lcnalloc.h\"\n#include \"dir.h\"\n#include \"debug.h\"\n#include \"bitmap.h\"\n#include \"aops.h\"\n#include \"attrib.h\"\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n\nvoid __mark_mft_record_dirty(ntfs_inode *ni)\n{\n\tntfs_inode *base_ni;\n\n\tntfs_debug(\"Entering for inode 0x%lx.\", ni->mft_no);\n\tBUG_ON(NInoAttr(ni));\n\tmark_ntfs_record_dirty(ni->page, ni->page_ofs);\n\t/* Determine the base vfs inode and mark it dirty, too. */\n\tmutex_lock(&ni->extent_lock);\n\tif (likely(ni->nr_extents >= 0))\n\t\tbase_ni = ni;\n\telse\n\t\tbase_ni = ni->ext.base_ntfs_ino;\n\tmutex_unlock(&ni->extent_lock);\n\t__mark_inode_dirty(VFS_I(base_ni), I_DIRTY_SYNC | I_DIRTY_DATASYNC);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ntfs_error",
          "args": [
            "vol->sb",
            "\"Not enough memory to write mft record.  \"\n\t\t\t\t\"Redirtying so the write is retried later.\""
          ],
          "line": 837
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "clear_buffer_dirty",
          "args": [
            "bhs[i_bhs]"
          ],
          "line": 828
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntfs_debug",
          "args": [
            "\"Done.\""
          ],
          "line": 823
        },
        "resolved": true,
        "details": {
          "function_name": "ntfs_debug_dump_runlist",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/debug.c",
          "lines": "134-171",
          "snippet": "void ntfs_debug_dump_runlist(const runlist_element *rl)\n{\n\tint i;\n\tconst char *lcn_str[5] = { \"LCN_HOLE         \", \"LCN_RL_NOT_MAPPED\",\n\t\t\t\t   \"LCN_ENOENT       \", \"LCN_unknown      \" };\n\n\tif (!debug_msgs)\n\t\treturn;\n\tpr_debug(\"Dumping runlist (values in hex):\\n\");\n\tif (!rl) {\n\t\tpr_debug(\"Run list not present.\\n\");\n\t\treturn;\n\t}\n\tpr_debug(\"VCN              LCN               Run length\\n\");\n\tfor (i = 0; ; i++) {\n\t\tLCN lcn = (rl + i)->lcn;\n\n\t\tif (lcn < (LCN)0) {\n\t\t\tint index = -lcn - 1;\n\n\t\t\tif (index > -LCN_ENOENT - 1)\n\t\t\t\tindex = 3;\n\t\t\tpr_debug(\"%-16Lx %s %-16Lx%s\\n\",\n\t\t\t\t\t(long long)(rl + i)->vcn, lcn_str[index],\n\t\t\t\t\t(long long)(rl + i)->length,\n\t\t\t\t\t(rl + i)->length ? \"\" :\n\t\t\t\t\t\t\" (runlist end)\");\n\t\t} else\n\t\t\tpr_debug(\"%-16Lx %-16Lx  %-16Lx%s\\n\",\n\t\t\t\t\t(long long)(rl + i)->vcn,\n\t\t\t\t\t(long long)(rl + i)->lcn,\n\t\t\t\t\t(long long)(rl + i)->length,\n\t\t\t\t\t(rl + i)->length ? \"\" :\n\t\t\t\t\t\t\" (runlist end)\");\n\t\tif (!(rl + i)->length)\n\t\t\tbreak;\n\t}\n}",
          "includes": [
            "#include \"debug.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"debug.h\"\n\nvoid ntfs_debug_dump_runlist(const runlist_element *rl)\n{\n\tint i;\n\tconst char *lcn_str[5] = { \"LCN_HOLE         \", \"LCN_RL_NOT_MAPPED\",\n\t\t\t\t   \"LCN_ENOENT       \", \"LCN_unknown      \" };\n\n\tif (!debug_msgs)\n\t\treturn;\n\tpr_debug(\"Dumping runlist (values in hex):\\n\");\n\tif (!rl) {\n\t\tpr_debug(\"Run list not present.\\n\");\n\t\treturn;\n\t}\n\tpr_debug(\"VCN              LCN               Run length\\n\");\n\tfor (i = 0; ; i++) {\n\t\tLCN lcn = (rl + i)->lcn;\n\n\t\tif (lcn < (LCN)0) {\n\t\t\tint index = -lcn - 1;\n\n\t\t\tif (index > -LCN_ENOENT - 1)\n\t\t\t\tindex = 3;\n\t\t\tpr_debug(\"%-16Lx %s %-16Lx%s\\n\",\n\t\t\t\t\t(long long)(rl + i)->vcn, lcn_str[index],\n\t\t\t\t\t(long long)(rl + i)->length,\n\t\t\t\t\t(rl + i)->length ? \"\" :\n\t\t\t\t\t\t\" (runlist end)\");\n\t\t} else\n\t\t\tpr_debug(\"%-16Lx %-16Lx  %-16Lx%s\\n\",\n\t\t\t\t\t(long long)(rl + i)->vcn,\n\t\t\t\t\t(long long)(rl + i)->lcn,\n\t\t\t\t\t(long long)(rl + i)->length,\n\t\t\t\t\t(rl + i)->length ? \"\" :\n\t\t\t\t\t\t\" (runlist end)\");\n\t\tif (!(rl + i)->length)\n\t\t\tbreak;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ntfs_error",
          "args": [
            "vol->sb",
            "\"I/O error while writing mft record \"\n\t\t\t\t\"0x%lx!  Marking base inode as bad.  You \"\n\t\t\t\t\"should unmount the volume and run chkdsk.\"",
            "ni->mft_no"
          ],
          "line": 816
        },
        "resolved": true,
        "details": {
          "function_name": "__ntfs_error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/debug.c",
          "lines": "86-108",
          "snippet": "void __ntfs_error(const char *function, const struct super_block *sb,\n\t\tconst char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\tint flen = 0;\n\n#ifndef DEBUG\n\tif (!printk_ratelimit())\n\t\treturn;\n#endif\n\tif (function)\n\t\tflen = strlen(function);\n\tva_start(args, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\tif (sb)\n\t\tpr_err(\"(device %s): %s(): %pV\\n\",\n\t\t       sb->s_id, flen ? function : \"\", &vaf);\n\telse\n\t\tpr_err(\"%s(): %pV\\n\", flen ? function : \"\", &vaf);\n\tva_end(args);\n}",
          "includes": [
            "#include \"debug.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"debug.h\"\n\nvoid __ntfs_error(const char *function, const struct super_block *sb,\n\t\tconst char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\tint flen = 0;\n\n#ifndef DEBUG\n\tif (!printk_ratelimit())\n\t\treturn;\n#endif\n\tif (function)\n\t\tflen = strlen(function);\n\tva_start(args, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\tif (sb)\n\t\tpr_err(\"(device %s): %s(): %pV\\n\",\n\t\t       sb->s_id, flen ? function : \"\", &vaf);\n\telse\n\t\tpr_err(\"%s(): %pV\\n\", flen ? function : \"\", &vaf);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "err"
          ],
          "line": 814
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "flush_dcache_mft_record_page",
          "args": [
            "ni"
          ],
          "line": 813
        },
        "resolved": true,
        "details": {
          "function_name": "flush_dcache_mft_record_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/mft.h",
          "lines": "55-58",
          "snippet": "static inline void flush_dcache_mft_record_page(ntfs_inode *ni)\n{\n\tflush_dcache_page(ni->page);\n}",
          "includes": [
            "#include \"inode.h\"",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"inode.h\"\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/fs.h>\n\nstatic inline void flush_dcache_mft_record_page(ntfs_inode *ni)\n{\n\tflush_dcache_page(ni->page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "post_write_mst_fixup",
          "args": [
            "(NTFS_RECORD*)m"
          ],
          "line": 812
        },
        "resolved": true,
        "details": {
          "function_name": "post_write_mst_fixup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/mst.c",
          "lines": "179-203",
          "snippet": "void post_write_mst_fixup(NTFS_RECORD *b)\n{\n\tle16 *usa_pos, *data_pos;\n\n\tu16 usa_ofs = le16_to_cpu(b->usa_ofs);\n\tu16 usa_count = le16_to_cpu(b->usa_count) - 1;\n\n\t/* Position of usn in update sequence array. */\n\tusa_pos = (le16*)b + usa_ofs/sizeof(le16);\n\n\t/* Position in protected data of first u16 that needs fixing up. */\n\tdata_pos = (le16*)b + NTFS_BLOCK_SIZE/sizeof(le16) - 1;\n\n\t/* Fixup all sectors. */\n\twhile (usa_count--) {\n\t\t/*\n\t\t * Increment position in usa and restore original data from\n\t\t * the usa into the data buffer.\n\t\t */\n\t\t*data_pos = *(++usa_pos);\n\n\t\t/* Increment position in data as well. */\n\t\tdata_pos += NTFS_BLOCK_SIZE/sizeof(le16);\n\t}\n}",
          "includes": [
            "#include \"ntfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ntfs.h\"\n\nvoid post_write_mst_fixup(NTFS_RECORD *b)\n{\n\tle16 *usa_pos, *data_pos;\n\n\tu16 usa_ofs = le16_to_cpu(b->usa_ofs);\n\tu16 usa_count = le16_to_cpu(b->usa_count) - 1;\n\n\t/* Position of usn in update sequence array. */\n\tusa_pos = (le16*)b + usa_ofs/sizeof(le16);\n\n\t/* Position in protected data of first u16 that needs fixing up. */\n\tdata_pos = (le16*)b + NTFS_BLOCK_SIZE/sizeof(le16) - 1;\n\n\t/* Fixup all sectors. */\n\twhile (usa_count--) {\n\t\t/*\n\t\t * Increment position in usa and restore original data from\n\t\t * the usa into the data buffer.\n\t\t */\n\t\t*data_pos = *(++usa_pos);\n\n\t\t/* Increment position in data as well. */\n\t\tdata_pos += NTFS_BLOCK_SIZE/sizeof(le16);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ntfs_sync_mft_mirror",
          "args": [
            "vol",
            "ni->mft_no",
            "m",
            "sync"
          ],
          "line": 810
        },
        "resolved": true,
        "details": {
          "function_name": "ntfs_sync_mft_mirror",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/mft.c",
          "lines": "465-636",
          "snippet": "int ntfs_sync_mft_mirror(ntfs_volume *vol, const unsigned long mft_no,\n\t\tMFT_RECORD *m, int sync)\n{\n\tstruct page *page;\n\tunsigned int blocksize = vol->sb->s_blocksize;\n\tint max_bhs = vol->mft_record_size / blocksize;\n\tstruct buffer_head *bhs[max_bhs];\n\tstruct buffer_head *bh, *head;\n\tu8 *kmirr;\n\trunlist_element *rl;\n\tunsigned int block_start, block_end, m_start, m_end, page_ofs;\n\tint i_bhs, nr_bhs, err = 0;\n\tunsigned char blocksize_bits = vol->sb->s_blocksize_bits;\n\n\tntfs_debug(\"Entering for inode 0x%lx.\", mft_no);\n\tBUG_ON(!max_bhs);\n\tif (unlikely(!vol->mftmirr_ino)) {\n\t\t/* This could happen during umount... */\n\t\terr = ntfs_sync_mft_mirror_umount(vol, mft_no, m);\n\t\tif (likely(!err))\n\t\t\treturn err;\n\t\tgoto err_out;\n\t}\n\t/* Get the page containing the mirror copy of the mft record @m. */\n\tpage = ntfs_map_page(vol->mftmirr_ino->i_mapping, mft_no >>\n\t\t\t(PAGE_CACHE_SHIFT - vol->mft_record_size_bits));\n\tif (IS_ERR(page)) {\n\t\tntfs_error(vol->sb, \"Failed to map mft mirror page.\");\n\t\terr = PTR_ERR(page);\n\t\tgoto err_out;\n\t}\n\tlock_page(page);\n\tBUG_ON(!PageUptodate(page));\n\tClearPageUptodate(page);\n\t/* Offset of the mft mirror record inside the page. */\n\tpage_ofs = (mft_no << vol->mft_record_size_bits) & ~PAGE_CACHE_MASK;\n\t/* The address in the page of the mirror copy of the mft record @m. */\n\tkmirr = page_address(page) + page_ofs;\n\t/* Copy the mst protected mft record to the mirror. */\n\tmemcpy(kmirr, m, vol->mft_record_size);\n\t/* Create uptodate buffers if not present. */\n\tif (unlikely(!page_has_buffers(page))) {\n\t\tstruct buffer_head *tail;\n\n\t\tbh = head = alloc_page_buffers(page, blocksize, 1);\n\t\tdo {\n\t\t\tset_buffer_uptodate(bh);\n\t\t\ttail = bh;\n\t\t\tbh = bh->b_this_page;\n\t\t} while (bh);\n\t\ttail->b_this_page = head;\n\t\tattach_page_buffers(page, head);\n\t}\n\tbh = head = page_buffers(page);\n\tBUG_ON(!bh);\n\trl = NULL;\n\tnr_bhs = 0;\n\tblock_start = 0;\n\tm_start = kmirr - (u8*)page_address(page);\n\tm_end = m_start + vol->mft_record_size;\n\tdo {\n\t\tblock_end = block_start + blocksize;\n\t\t/* If the buffer is outside the mft record, skip it. */\n\t\tif (block_end <= m_start)\n\t\t\tcontinue;\n\t\tif (unlikely(block_start >= m_end))\n\t\t\tbreak;\n\t\t/* Need to map the buffer if it is not mapped already. */\n\t\tif (unlikely(!buffer_mapped(bh))) {\n\t\t\tVCN vcn;\n\t\t\tLCN lcn;\n\t\t\tunsigned int vcn_ofs;\n\n\t\t\tbh->b_bdev = vol->sb->s_bdev;\n\t\t\t/* Obtain the vcn and offset of the current block. */\n\t\t\tvcn = ((VCN)mft_no << vol->mft_record_size_bits) +\n\t\t\t\t\t(block_start - m_start);\n\t\t\tvcn_ofs = vcn & vol->cluster_size_mask;\n\t\t\tvcn >>= vol->cluster_size_bits;\n\t\t\tif (!rl) {\n\t\t\t\tdown_read(&NTFS_I(vol->mftmirr_ino)->\n\t\t\t\t\t\trunlist.lock);\n\t\t\t\trl = NTFS_I(vol->mftmirr_ino)->runlist.rl;\n\t\t\t\t/*\n\t\t\t\t * $MFTMirr always has the whole of its runlist\n\t\t\t\t * in memory.\n\t\t\t\t */\n\t\t\t\tBUG_ON(!rl);\n\t\t\t}\n\t\t\t/* Seek to element containing target vcn. */\n\t\t\twhile (rl->length && rl[1].vcn <= vcn)\n\t\t\t\trl++;\n\t\t\tlcn = ntfs_rl_vcn_to_lcn(rl, vcn);\n\t\t\t/* For $MFTMirr, only lcn >= 0 is a successful remap. */\n\t\t\tif (likely(lcn >= 0)) {\n\t\t\t\t/* Setup buffer head to correct block. */\n\t\t\t\tbh->b_blocknr = ((lcn <<\n\t\t\t\t\t\tvol->cluster_size_bits) +\n\t\t\t\t\t\tvcn_ofs) >> blocksize_bits;\n\t\t\t\tset_buffer_mapped(bh);\n\t\t\t} else {\n\t\t\t\tbh->b_blocknr = -1;\n\t\t\t\tntfs_error(vol->sb, \"Cannot write mft mirror \"\n\t\t\t\t\t\t\"record 0x%lx because its \"\n\t\t\t\t\t\t\"location on disk could not \"\n\t\t\t\t\t\t\"be determined (error code \"\n\t\t\t\t\t\t\"%lli).\", mft_no,\n\t\t\t\t\t\t(long long)lcn);\n\t\t\t\terr = -EIO;\n\t\t\t}\n\t\t}\n\t\tBUG_ON(!buffer_uptodate(bh));\n\t\tBUG_ON(!nr_bhs && (m_start != block_start));\n\t\tBUG_ON(nr_bhs >= max_bhs);\n\t\tbhs[nr_bhs++] = bh;\n\t\tBUG_ON((nr_bhs >= max_bhs) && (m_end != block_end));\n\t} while (block_start = block_end, (bh = bh->b_this_page) != head);\n\tif (unlikely(rl))\n\t\tup_read(&NTFS_I(vol->mftmirr_ino)->runlist.lock);\n\tif (likely(!err)) {\n\t\t/* Lock buffers and start synchronous write i/o on them. */\n\t\tfor (i_bhs = 0; i_bhs < nr_bhs; i_bhs++) {\n\t\t\tstruct buffer_head *tbh = bhs[i_bhs];\n\n\t\t\tif (!trylock_buffer(tbh))\n\t\t\t\tBUG();\n\t\t\tBUG_ON(!buffer_uptodate(tbh));\n\t\t\tclear_buffer_dirty(tbh);\n\t\t\tget_bh(tbh);\n\t\t\ttbh->b_end_io = end_buffer_write_sync;\n\t\t\tsubmit_bh(WRITE, tbh);\n\t\t}\n\t\t/* Wait on i/o completion of buffers. */\n\t\tfor (i_bhs = 0; i_bhs < nr_bhs; i_bhs++) {\n\t\t\tstruct buffer_head *tbh = bhs[i_bhs];\n\n\t\t\twait_on_buffer(tbh);\n\t\t\tif (unlikely(!buffer_uptodate(tbh))) {\n\t\t\t\terr = -EIO;\n\t\t\t\t/*\n\t\t\t\t * Set the buffer uptodate so the page and\n\t\t\t\t * buffer states do not become out of sync.\n\t\t\t\t */\n\t\t\t\tset_buffer_uptodate(tbh);\n\t\t\t}\n\t\t}\n\t} else /* if (unlikely(err)) */ {\n\t\t/* Clean the buffers. */\n\t\tfor (i_bhs = 0; i_bhs < nr_bhs; i_bhs++)\n\t\t\tclear_buffer_dirty(bhs[i_bhs]);\n\t}\n\t/* Current state: all buffers are clean, unlocked, and uptodate. */\n\t/* Remove the mst protection fixups again. */\n\tpost_write_mst_fixup((NTFS_RECORD*)kmirr);\n\tflush_dcache_page(page);\n\tSetPageUptodate(page);\n\tunlock_page(page);\n\tntfs_unmap_page(page);\n\tif (likely(!err)) {\n\t\tntfs_debug(\"Done.\");\n\t} else {\n\t\tntfs_error(vol->sb, \"I/O error while writing mft mirror \"\n\t\t\t\t\"record 0x%lx!\", mft_no);\nerr_out:\n\t\tntfs_error(vol->sb, \"Failed to synchronize $MFTMirr (error \"\n\t\t\t\t\"code %i).  Volume will be left marked dirty \"\n\t\t\t\t\"on umount.  Run ntfsfix on the partition \"\n\t\t\t\t\"after umounting to correct this.\", -err);\n\t\tNVolSetErrors(vol);\n\t}\n\treturn err;\n}",
          "includes": [
            "#include \"ntfs.h\"",
            "#include \"mft.h\"",
            "#include \"malloc.h\"",
            "#include \"lcnalloc.h\"",
            "#include \"dir.h\"",
            "#include \"debug.h\"",
            "#include \"bitmap.h\"",
            "#include \"aops.h\"",
            "#include \"attrib.h\"",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ntfs.h\"\n#include \"mft.h\"\n#include \"malloc.h\"\n#include \"lcnalloc.h\"\n#include \"dir.h\"\n#include \"debug.h\"\n#include \"bitmap.h\"\n#include \"aops.h\"\n#include \"attrib.h\"\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n\nint ntfs_sync_mft_mirror(ntfs_volume *vol, const unsigned long mft_no,\n\t\tMFT_RECORD *m, int sync)\n{\n\tstruct page *page;\n\tunsigned int blocksize = vol->sb->s_blocksize;\n\tint max_bhs = vol->mft_record_size / blocksize;\n\tstruct buffer_head *bhs[max_bhs];\n\tstruct buffer_head *bh, *head;\n\tu8 *kmirr;\n\trunlist_element *rl;\n\tunsigned int block_start, block_end, m_start, m_end, page_ofs;\n\tint i_bhs, nr_bhs, err = 0;\n\tunsigned char blocksize_bits = vol->sb->s_blocksize_bits;\n\n\tntfs_debug(\"Entering for inode 0x%lx.\", mft_no);\n\tBUG_ON(!max_bhs);\n\tif (unlikely(!vol->mftmirr_ino)) {\n\t\t/* This could happen during umount... */\n\t\terr = ntfs_sync_mft_mirror_umount(vol, mft_no, m);\n\t\tif (likely(!err))\n\t\t\treturn err;\n\t\tgoto err_out;\n\t}\n\t/* Get the page containing the mirror copy of the mft record @m. */\n\tpage = ntfs_map_page(vol->mftmirr_ino->i_mapping, mft_no >>\n\t\t\t(PAGE_CACHE_SHIFT - vol->mft_record_size_bits));\n\tif (IS_ERR(page)) {\n\t\tntfs_error(vol->sb, \"Failed to map mft mirror page.\");\n\t\terr = PTR_ERR(page);\n\t\tgoto err_out;\n\t}\n\tlock_page(page);\n\tBUG_ON(!PageUptodate(page));\n\tClearPageUptodate(page);\n\t/* Offset of the mft mirror record inside the page. */\n\tpage_ofs = (mft_no << vol->mft_record_size_bits) & ~PAGE_CACHE_MASK;\n\t/* The address in the page of the mirror copy of the mft record @m. */\n\tkmirr = page_address(page) + page_ofs;\n\t/* Copy the mst protected mft record to the mirror. */\n\tmemcpy(kmirr, m, vol->mft_record_size);\n\t/* Create uptodate buffers if not present. */\n\tif (unlikely(!page_has_buffers(page))) {\n\t\tstruct buffer_head *tail;\n\n\t\tbh = head = alloc_page_buffers(page, blocksize, 1);\n\t\tdo {\n\t\t\tset_buffer_uptodate(bh);\n\t\t\ttail = bh;\n\t\t\tbh = bh->b_this_page;\n\t\t} while (bh);\n\t\ttail->b_this_page = head;\n\t\tattach_page_buffers(page, head);\n\t}\n\tbh = head = page_buffers(page);\n\tBUG_ON(!bh);\n\trl = NULL;\n\tnr_bhs = 0;\n\tblock_start = 0;\n\tm_start = kmirr - (u8*)page_address(page);\n\tm_end = m_start + vol->mft_record_size;\n\tdo {\n\t\tblock_end = block_start + blocksize;\n\t\t/* If the buffer is outside the mft record, skip it. */\n\t\tif (block_end <= m_start)\n\t\t\tcontinue;\n\t\tif (unlikely(block_start >= m_end))\n\t\t\tbreak;\n\t\t/* Need to map the buffer if it is not mapped already. */\n\t\tif (unlikely(!buffer_mapped(bh))) {\n\t\t\tVCN vcn;\n\t\t\tLCN lcn;\n\t\t\tunsigned int vcn_ofs;\n\n\t\t\tbh->b_bdev = vol->sb->s_bdev;\n\t\t\t/* Obtain the vcn and offset of the current block. */\n\t\t\tvcn = ((VCN)mft_no << vol->mft_record_size_bits) +\n\t\t\t\t\t(block_start - m_start);\n\t\t\tvcn_ofs = vcn & vol->cluster_size_mask;\n\t\t\tvcn >>= vol->cluster_size_bits;\n\t\t\tif (!rl) {\n\t\t\t\tdown_read(&NTFS_I(vol->mftmirr_ino)->\n\t\t\t\t\t\trunlist.lock);\n\t\t\t\trl = NTFS_I(vol->mftmirr_ino)->runlist.rl;\n\t\t\t\t/*\n\t\t\t\t * $MFTMirr always has the whole of its runlist\n\t\t\t\t * in memory.\n\t\t\t\t */\n\t\t\t\tBUG_ON(!rl);\n\t\t\t}\n\t\t\t/* Seek to element containing target vcn. */\n\t\t\twhile (rl->length && rl[1].vcn <= vcn)\n\t\t\t\trl++;\n\t\t\tlcn = ntfs_rl_vcn_to_lcn(rl, vcn);\n\t\t\t/* For $MFTMirr, only lcn >= 0 is a successful remap. */\n\t\t\tif (likely(lcn >= 0)) {\n\t\t\t\t/* Setup buffer head to correct block. */\n\t\t\t\tbh->b_blocknr = ((lcn <<\n\t\t\t\t\t\tvol->cluster_size_bits) +\n\t\t\t\t\t\tvcn_ofs) >> blocksize_bits;\n\t\t\t\tset_buffer_mapped(bh);\n\t\t\t} else {\n\t\t\t\tbh->b_blocknr = -1;\n\t\t\t\tntfs_error(vol->sb, \"Cannot write mft mirror \"\n\t\t\t\t\t\t\"record 0x%lx because its \"\n\t\t\t\t\t\t\"location on disk could not \"\n\t\t\t\t\t\t\"be determined (error code \"\n\t\t\t\t\t\t\"%lli).\", mft_no,\n\t\t\t\t\t\t(long long)lcn);\n\t\t\t\terr = -EIO;\n\t\t\t}\n\t\t}\n\t\tBUG_ON(!buffer_uptodate(bh));\n\t\tBUG_ON(!nr_bhs && (m_start != block_start));\n\t\tBUG_ON(nr_bhs >= max_bhs);\n\t\tbhs[nr_bhs++] = bh;\n\t\tBUG_ON((nr_bhs >= max_bhs) && (m_end != block_end));\n\t} while (block_start = block_end, (bh = bh->b_this_page) != head);\n\tif (unlikely(rl))\n\t\tup_read(&NTFS_I(vol->mftmirr_ino)->runlist.lock);\n\tif (likely(!err)) {\n\t\t/* Lock buffers and start synchronous write i/o on them. */\n\t\tfor (i_bhs = 0; i_bhs < nr_bhs; i_bhs++) {\n\t\t\tstruct buffer_head *tbh = bhs[i_bhs];\n\n\t\t\tif (!trylock_buffer(tbh))\n\t\t\t\tBUG();\n\t\t\tBUG_ON(!buffer_uptodate(tbh));\n\t\t\tclear_buffer_dirty(tbh);\n\t\t\tget_bh(tbh);\n\t\t\ttbh->b_end_io = end_buffer_write_sync;\n\t\t\tsubmit_bh(WRITE, tbh);\n\t\t}\n\t\t/* Wait on i/o completion of buffers. */\n\t\tfor (i_bhs = 0; i_bhs < nr_bhs; i_bhs++) {\n\t\t\tstruct buffer_head *tbh = bhs[i_bhs];\n\n\t\t\twait_on_buffer(tbh);\n\t\t\tif (unlikely(!buffer_uptodate(tbh))) {\n\t\t\t\terr = -EIO;\n\t\t\t\t/*\n\t\t\t\t * Set the buffer uptodate so the page and\n\t\t\t\t * buffer states do not become out of sync.\n\t\t\t\t */\n\t\t\t\tset_buffer_uptodate(tbh);\n\t\t\t}\n\t\t}\n\t} else /* if (unlikely(err)) */ {\n\t\t/* Clean the buffers. */\n\t\tfor (i_bhs = 0; i_bhs < nr_bhs; i_bhs++)\n\t\t\tclear_buffer_dirty(bhs[i_bhs]);\n\t}\n\t/* Current state: all buffers are clean, unlocked, and uptodate. */\n\t/* Remove the mst protection fixups again. */\n\tpost_write_mst_fixup((NTFS_RECORD*)kmirr);\n\tflush_dcache_page(page);\n\tSetPageUptodate(page);\n\tunlock_page(page);\n\tntfs_unmap_page(page);\n\tif (likely(!err)) {\n\t\tntfs_debug(\"Done.\");\n\t} else {\n\t\tntfs_error(vol->sb, \"I/O error while writing mft mirror \"\n\t\t\t\t\"record 0x%lx!\", mft_no);\nerr_out:\n\t\tntfs_error(vol->sb, \"Failed to synchronize $MFTMirr (error \"\n\t\t\t\t\"code %i).  Volume will be left marked dirty \"\n\t\t\t\t\"on umount.  Run ntfsfix on the partition \"\n\t\t\t\t\"after umounting to correct this.\", -err);\n\t\tNVolSetErrors(vol);\n\t}\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_buffer_uptodate",
          "args": [
            "tbh"
          ],
          "line": 805
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_set_buffer_uptodate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/disk-io.c",
          "lines": "3758-3761",
          "snippet": "int btrfs_set_buffer_uptodate(struct extent_buffer *buf)\n{\n\treturn set_extent_buffer_uptodate(buf);\n}",
          "includes": [
            "#include <asm/cpufeature.h>",
            "#include \"qgroup.h\"",
            "#include \"sysfs.h\"",
            "#include \"raid56.h\"",
            "#include \"dev-replace.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"inode-map.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"tree-log.h\"",
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"hash.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/uuid.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/migrate.h>",
            "#include <linux/slab.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/writeback.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/swap.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/cpufeature.h>\n#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"raid56.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <asm/unaligned.h>\n#include <linux/semaphore.h>\n#include <linux/uuid.h>\n#include <linux/ratelimit.h>\n#include <linux/migrate.h>\n#include <linux/slab.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/writeback.h>\n#include <linux/radix-tree.h>\n#include <linux/swap.h>\n#include <linux/scatterlist.h>\n#include <linux/blkdev.h>\n#include <linux/fs.h>\n\nint btrfs_set_buffer_uptodate(struct extent_buffer *buf)\n{\n\treturn set_extent_buffer_uptodate(buf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PageUptodate",
          "args": [
            "page"
          ],
          "line": 804
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!buffer_uptodate(tbh)"
          ],
          "line": 798
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wait_on_buffer",
          "args": [
            "tbh"
          ],
          "line": 797
        },
        "resolved": true,
        "details": {
          "function_name": "__wait_on_buffer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "117-120",
          "snippet": "void __wait_on_buffer(struct buffer_head * bh)\n{\n\twait_on_bit_io(&bh->b_state, BH_Lock, TASK_UNINTERRUPTIBLE);\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid __wait_on_buffer(struct buffer_head * bh)\n{\n\twait_on_bit_io(&bh->b_state, BH_Lock, TASK_UNINTERRUPTIBLE);\n}"
        }
      },
      {
        "call_info": {
          "callee": "submit_bh",
          "args": [
            "WRITE",
            "tbh"
          ],
          "line": 788
        },
        "resolved": true,
        "details": {
          "function_name": "submit_bh",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "3055-3058",
          "snippet": "int submit_bh(int rw, struct buffer_head *bh)\n{\n\treturn _submit_bh(rw, bh, 0);\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nint submit_bh(int rw, struct buffer_head *bh)\n{\n\treturn _submit_bh(rw, bh, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_bh",
          "args": [
            "tbh"
          ],
          "line": 786
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "clear_buffer_dirty",
          "args": [
            "tbh"
          ],
          "line": 785
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!buffer_uptodate(tbh)"
          ],
          "line": 784
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG",
          "args": [],
          "line": 783
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trylock_buffer",
          "args": [
            "tbh"
          ],
          "line": 782
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntfs_error",
          "args": [
            "vol->sb",
            "\"Failed to apply mst fixups!\""
          ],
          "line": 774
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pre_write_mst_fixup",
          "args": [
            "(NTFS_RECORD*)m",
            "vol->mft_record_size"
          ],
          "line": 772
        },
        "resolved": true,
        "details": {
          "function_name": "pre_write_mst_fixup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/mst.c",
          "lines": "123-169",
          "snippet": "int pre_write_mst_fixup(NTFS_RECORD *b, const u32 size)\n{\n\tle16 *usa_pos, *data_pos;\n\tu16 usa_ofs, usa_count, usn;\n\tle16 le_usn;\n\n\t/* Sanity check + only fixup if it makes sense. */\n\tif (!b || ntfs_is_baad_record(b->magic) ||\n\t\t\tntfs_is_hole_record(b->magic))\n\t\treturn -EINVAL;\n\t/* Setup the variables. */\n\tusa_ofs = le16_to_cpu(b->usa_ofs);\n\t/* Decrement usa_count to get number of fixups. */\n\tusa_count = le16_to_cpu(b->usa_count) - 1;\n\t/* Size and alignment checks. */\n\tif ( size & (NTFS_BLOCK_SIZE - 1)\t||\n\t     usa_ofs & 1\t\t\t||\n\t     usa_ofs + (usa_count * 2) > size\t||\n\t     (size >> NTFS_BLOCK_SIZE_BITS) != usa_count)\n\t\treturn -EINVAL;\n\t/* Position of usn in update sequence array. */\n\tusa_pos = (le16*)((u8*)b + usa_ofs);\n\t/*\n\t * Cyclically increment the update sequence number\n\t * (skipping 0 and -1, i.e. 0xffff).\n\t */\n\tusn = le16_to_cpup(usa_pos) + 1;\n\tif (usn == 0xffff || !usn)\n\t\tusn = 1;\n\tle_usn = cpu_to_le16(usn);\n\t*usa_pos = le_usn;\n\t/* Position in data of first u16 that needs fixing up. */\n\tdata_pos = (le16*)b + NTFS_BLOCK_SIZE/sizeof(le16) - 1;\n\t/* Fixup all sectors. */\n\twhile (usa_count--) {\n\t\t/*\n\t\t * Increment the position in the usa and save the\n\t\t * original data from the data buffer into the usa.\n\t\t */\n\t\t*(++usa_pos) = *data_pos;\n\t\t/* Apply fixup to data. */\n\t\t*data_pos = le_usn;\n\t\t/* Increment position in data as well. */\n\t\tdata_pos += NTFS_BLOCK_SIZE/sizeof(le16);\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"ntfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ntfs.h\"\n\nint pre_write_mst_fixup(NTFS_RECORD *b, const u32 size)\n{\n\tle16 *usa_pos, *data_pos;\n\tu16 usa_ofs, usa_count, usn;\n\tle16 le_usn;\n\n\t/* Sanity check + only fixup if it makes sense. */\n\tif (!b || ntfs_is_baad_record(b->magic) ||\n\t\t\tntfs_is_hole_record(b->magic))\n\t\treturn -EINVAL;\n\t/* Setup the variables. */\n\tusa_ofs = le16_to_cpu(b->usa_ofs);\n\t/* Decrement usa_count to get number of fixups. */\n\tusa_count = le16_to_cpu(b->usa_count) - 1;\n\t/* Size and alignment checks. */\n\tif ( size & (NTFS_BLOCK_SIZE - 1)\t||\n\t     usa_ofs & 1\t\t\t||\n\t     usa_ofs + (usa_count * 2) > size\t||\n\t     (size >> NTFS_BLOCK_SIZE_BITS) != usa_count)\n\t\treturn -EINVAL;\n\t/* Position of usn in update sequence array. */\n\tusa_pos = (le16*)((u8*)b + usa_ofs);\n\t/*\n\t * Cyclically increment the update sequence number\n\t * (skipping 0 and -1, i.e. 0xffff).\n\t */\n\tusn = le16_to_cpup(usa_pos) + 1;\n\tif (usn == 0xffff || !usn)\n\t\tusn = 1;\n\tle_usn = cpu_to_le16(usn);\n\t*usa_pos = le_usn;\n\t/* Position in data of first u16 that needs fixing up. */\n\tdata_pos = (le16*)b + NTFS_BLOCK_SIZE/sizeof(le16) - 1;\n\t/* Fixup all sectors. */\n\twhile (usa_count--) {\n\t\t/*\n\t\t * Increment the position in the usa and save the\n\t\t * original data from the data buffer into the usa.\n\t\t */\n\t\t*(++usa_pos) = *data_pos;\n\t\t/* Apply fixup to data. */\n\t\t*data_pos = le_usn;\n\t\t/* Increment position in data as well. */\n\t\tdata_pos += NTFS_BLOCK_SIZE/sizeof(le16);\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "err"
          ],
          "line": 769
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "up_read",
          "args": [
            "&NTFS_I(vol->mft_ino)->runlist.lock"
          ],
          "line": 766
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NTFS_I",
          "args": [
            "vol->mft_ino"
          ],
          "line": 766
        },
        "resolved": true,
        "details": {
          "function_name": "NTFS_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/inode.h",
          "lines": "240-243",
          "snippet": "static inline ntfs_inode *NTFS_I(struct inode *inode)\n{\n\treturn (ntfs_inode *)list_entry(inode, big_ntfs_inode, vfs_inode);\n}",
          "includes": [
            "#include \"debug.h\"",
            "#include \"runlist.h\"",
            "#include \"types.h\"",
            "#include \"volume.h\"",
            "#include \"layout.h\"",
            "#include <linux/seq_file.h>",
            "#include <linux/mutex.h>",
            "#include <linux/mm.h>",
            "#include <linux/list.h>",
            "#include <linux/fs.h>",
            "#include <linux/atomic.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"debug.h\"\n#include \"runlist.h\"\n#include \"types.h\"\n#include \"volume.h\"\n#include \"layout.h\"\n#include <linux/seq_file.h>\n#include <linux/mutex.h>\n#include <linux/mm.h>\n#include <linux/list.h>\n#include <linux/fs.h>\n#include <linux/atomic.h>\n\nstatic inline ntfs_inode *NTFS_I(struct inode *inode)\n{\n\treturn (ntfs_inode *)list_entry(inode, big_ntfs_inode, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "rl"
          ],
          "line": 765
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "(nr_bhs >= max_bhs) && (m_end != block_end)"
          ],
          "line": 763
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "nr_bhs >= max_bhs"
          ],
          "line": 761
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!nr_bhs && (m_start != block_start)"
          ],
          "line": 760
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!buffer_uptodate(bh)"
          ],
          "line": 759
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_buffer_mapped",
          "args": [
            "bh"
          ],
          "line": 748
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "likely",
          "args": [
            "lcn >= 0"
          ],
          "line": 743
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntfs_rl_vcn_to_lcn",
          "args": [
            "rl",
            "vcn"
          ],
          "line": 741
        },
        "resolved": true,
        "details": {
          "function_name": "ntfs_rl_vcn_to_lcn",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/runlist.c",
          "lines": "1004-1036",
          "snippet": "LCN ntfs_rl_vcn_to_lcn(const runlist_element *rl, const VCN vcn)\n{\n\tint i;\n\n\tBUG_ON(vcn < 0);\n\t/*\n\t * If rl is NULL, assume that we have found an unmapped runlist. The\n\t * caller can then attempt to map it and fail appropriately if\n\t * necessary.\n\t */\n\tif (unlikely(!rl))\n\t\treturn LCN_RL_NOT_MAPPED;\n\n\t/* Catch out of lower bounds vcn. */\n\tif (unlikely(vcn < rl[0].vcn))\n\t\treturn LCN_ENOENT;\n\n\tfor (i = 0; likely(rl[i].length); i++) {\n\t\tif (unlikely(vcn < rl[i+1].vcn)) {\n\t\t\tif (likely(rl[i].lcn >= (LCN)0))\n\t\t\t\treturn rl[i].lcn + (vcn - rl[i].vcn);\n\t\t\treturn rl[i].lcn;\n\t\t}\n\t}\n\t/*\n\t * The terminator element is setup to the correct value, i.e. one of\n\t * LCN_HOLE, LCN_RL_NOT_MAPPED, or LCN_ENOENT.\n\t */\n\tif (likely(rl[i].lcn < (LCN)0))\n\t\treturn rl[i].lcn;\n\t/* Just in case... We could replace this with BUG() some day. */\n\treturn LCN_ENOENT;\n}",
          "includes": [
            "#include \"ntfs.h\"",
            "#include \"malloc.h\"",
            "#include \"endian.h\"",
            "#include \"dir.h\"",
            "#include \"debug.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ntfs.h\"\n#include \"malloc.h\"\n#include \"endian.h\"\n#include \"dir.h\"\n#include \"debug.h\"\n\nLCN ntfs_rl_vcn_to_lcn(const runlist_element *rl, const VCN vcn)\n{\n\tint i;\n\n\tBUG_ON(vcn < 0);\n\t/*\n\t * If rl is NULL, assume that we have found an unmapped runlist. The\n\t * caller can then attempt to map it and fail appropriately if\n\t * necessary.\n\t */\n\tif (unlikely(!rl))\n\t\treturn LCN_RL_NOT_MAPPED;\n\n\t/* Catch out of lower bounds vcn. */\n\tif (unlikely(vcn < rl[0].vcn))\n\t\treturn LCN_ENOENT;\n\n\tfor (i = 0; likely(rl[i].length); i++) {\n\t\tif (unlikely(vcn < rl[i+1].vcn)) {\n\t\t\tif (likely(rl[i].lcn >= (LCN)0))\n\t\t\t\treturn rl[i].lcn + (vcn - rl[i].vcn);\n\t\t\treturn rl[i].lcn;\n\t\t}\n\t}\n\t/*\n\t * The terminator element is setup to the correct value, i.e. one of\n\t * LCN_HOLE, LCN_RL_NOT_MAPPED, or LCN_ENOENT.\n\t */\n\tif (likely(rl[i].lcn < (LCN)0))\n\t\treturn rl[i].lcn;\n\t/* Just in case... We could replace this with BUG() some day. */\n\treturn LCN_ENOENT;\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!rl"
          ],
          "line": 736
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "down_read",
          "args": [
            "&NTFS_I(vol->mft_ino)->runlist.lock"
          ],
          "line": 734
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!buffer_mapped(bh)"
          ],
          "line": 722
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "buffer_mapped",
          "args": [
            "bh"
          ],
          "line": 722
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "nr_bhs"
          ],
          "line": 716
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "buffer_dirty",
          "args": [
            "bh"
          ],
          "line": 715
        },
        "resolved": true,
        "details": {
          "function_name": "mark_buffer_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1141-1167",
          "snippet": "void mark_buffer_dirty(struct buffer_head *bh)\n{\n\tWARN_ON_ONCE(!buffer_uptodate(bh));\n\n\ttrace_block_dirty_buffer(bh);\n\n\t/*\n\t * Very *carefully* optimize the it-is-already-dirty case.\n\t *\n\t * Don't let the final \"is it dirty\" escape to before we\n\t * perhaps modified the buffer.\n\t */\n\tif (buffer_dirty(bh)) {\n\t\tsmp_mb();\n\t\tif (buffer_dirty(bh))\n\t\t\treturn;\n\t}\n\n\tif (!test_set_buffer_dirty(bh)) {\n\t\tstruct page *page = bh->b_page;\n\t\tif (!TestSetPageDirty(page)) {\n\t\t\tstruct address_space *mapping = page_mapping(page);\n\t\t\tif (mapping)\n\t\t\t\t__set_page_dirty(page, mapping, 0);\n\t\t}\n\t}\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid mark_buffer_dirty(struct buffer_head *bh)\n{\n\tWARN_ON_ONCE(!buffer_uptodate(bh));\n\n\ttrace_block_dirty_buffer(bh);\n\n\t/*\n\t * Very *carefully* optimize the it-is-already-dirty case.\n\t *\n\t * Don't let the final \"is it dirty\" escape to before we\n\t * perhaps modified the buffer.\n\t */\n\tif (buffer_dirty(bh)) {\n\t\tsmp_mb();\n\t\tif (buffer_dirty(bh))\n\t\t\treturn;\n\t}\n\n\tif (!test_set_buffer_dirty(bh)) {\n\t\tstruct page *page = bh->b_page;\n\t\tif (!TestSetPageDirty(page)) {\n\t\t\tstruct address_space *mapping = page_mapping(page);\n\t\t\tif (mapping)\n\t\t\t\t__set_page_dirty(page, mapping, 0);\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "block_start >= m_end"
          ],
          "line": 706
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!bh"
          ],
          "line": 695
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_buffers",
          "args": [
            "page"
          ],
          "line": 694
        },
        "resolved": true,
        "details": {
          "function_name": "__clear_page_buffers",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "123-129",
          "snippet": "static void\n__clear_page_buffers(struct page *page)\n{\n\tClearPagePrivate(page);\n\tset_page_private(page, 0);\n\tpage_cache_release(page);\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nstatic void\n__clear_page_buffers(struct page *page)\n{\n\tClearPagePrivate(page);\n\tset_page_private(page, 0);\n\tpage_cache_release(page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "NInoTestClearDirty",
          "args": [
            "ni"
          ],
          "line": 692
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!PageLocked(page)"
          ],
          "line": 685
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageLocked",
          "args": [
            "page"
          ],
          "line": 685
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!max_bhs"
          ],
          "line": 684
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "NInoAttr(ni)"
          ],
          "line": 683
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NInoAttr",
          "args": [
            "ni"
          ],
          "line": 683
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntfs_debug",
          "args": [
            "\"Entering for inode 0x%lx.\"",
            "ni->mft_no"
          ],
          "line": 682
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ntfs.h\"\n#include \"mft.h\"\n#include \"malloc.h\"\n#include \"lcnalloc.h\"\n#include \"dir.h\"\n#include \"debug.h\"\n#include \"bitmap.h\"\n#include \"aops.h\"\n#include \"attrib.h\"\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n\nint write_mft_record_nolock(ntfs_inode *ni, MFT_RECORD *m, int sync)\n{\n\tntfs_volume *vol = ni->vol;\n\tstruct page *page = ni->page;\n\tunsigned int blocksize = vol->sb->s_blocksize;\n\tunsigned char blocksize_bits = vol->sb->s_blocksize_bits;\n\tint max_bhs = vol->mft_record_size / blocksize;\n\tstruct buffer_head *bhs[max_bhs];\n\tstruct buffer_head *bh, *head;\n\trunlist_element *rl;\n\tunsigned int block_start, block_end, m_start, m_end;\n\tint i_bhs, nr_bhs, err = 0;\n\n\tntfs_debug(\"Entering for inode 0x%lx.\", ni->mft_no);\n\tBUG_ON(NInoAttr(ni));\n\tBUG_ON(!max_bhs);\n\tBUG_ON(!PageLocked(page));\n\t/*\n\t * If the ntfs_inode is clean no need to do anything.  If it is dirty,\n\t * mark it as clean now so that it can be redirtied later on if needed.\n\t * There is no danger of races since the caller is holding the locks\n\t * for the mft record @m and the page it is in.\n\t */\n\tif (!NInoTestClearDirty(ni))\n\t\tgoto done;\n\tbh = head = page_buffers(page);\n\tBUG_ON(!bh);\n\trl = NULL;\n\tnr_bhs = 0;\n\tblock_start = 0;\n\tm_start = ni->page_ofs;\n\tm_end = m_start + vol->mft_record_size;\n\tdo {\n\t\tblock_end = block_start + blocksize;\n\t\t/* If the buffer is outside the mft record, skip it. */\n\t\tif (block_end <= m_start)\n\t\t\tcontinue;\n\t\tif (unlikely(block_start >= m_end))\n\t\t\tbreak;\n\t\t/*\n\t\t * If this block is not the first one in the record, we ignore\n\t\t * the buffer's dirty state because we could have raced with a\n\t\t * parallel mark_ntfs_record_dirty().\n\t\t */\n\t\tif (block_start == m_start) {\n\t\t\t/* This block is the first one in the record. */\n\t\t\tif (!buffer_dirty(bh)) {\n\t\t\t\tBUG_ON(nr_bhs);\n\t\t\t\t/* Clean records are not written out. */\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\t/* Need to map the buffer if it is not mapped already. */\n\t\tif (unlikely(!buffer_mapped(bh))) {\n\t\t\tVCN vcn;\n\t\t\tLCN lcn;\n\t\t\tunsigned int vcn_ofs;\n\n\t\t\tbh->b_bdev = vol->sb->s_bdev;\n\t\t\t/* Obtain the vcn and offset of the current block. */\n\t\t\tvcn = ((VCN)ni->mft_no << vol->mft_record_size_bits) +\n\t\t\t\t\t(block_start - m_start);\n\t\t\tvcn_ofs = vcn & vol->cluster_size_mask;\n\t\t\tvcn >>= vol->cluster_size_bits;\n\t\t\tif (!rl) {\n\t\t\t\tdown_read(&NTFS_I(vol->mft_ino)->runlist.lock);\n\t\t\t\trl = NTFS_I(vol->mft_ino)->runlist.rl;\n\t\t\t\tBUG_ON(!rl);\n\t\t\t}\n\t\t\t/* Seek to element containing target vcn. */\n\t\t\twhile (rl->length && rl[1].vcn <= vcn)\n\t\t\t\trl++;\n\t\t\tlcn = ntfs_rl_vcn_to_lcn(rl, vcn);\n\t\t\t/* For $MFT, only lcn >= 0 is a successful remap. */\n\t\t\tif (likely(lcn >= 0)) {\n\t\t\t\t/* Setup buffer head to correct block. */\n\t\t\t\tbh->b_blocknr = ((lcn <<\n\t\t\t\t\t\tvol->cluster_size_bits) +\n\t\t\t\t\t\tvcn_ofs) >> blocksize_bits;\n\t\t\t\tset_buffer_mapped(bh);\n\t\t\t} else {\n\t\t\t\tbh->b_blocknr = -1;\n\t\t\t\tntfs_error(vol->sb, \"Cannot write mft record \"\n\t\t\t\t\t\t\"0x%lx because its location \"\n\t\t\t\t\t\t\"on disk could not be \"\n\t\t\t\t\t\t\"determined (error code %lli).\",\n\t\t\t\t\t\tni->mft_no, (long long)lcn);\n\t\t\t\terr = -EIO;\n\t\t\t}\n\t\t}\n\t\tBUG_ON(!buffer_uptodate(bh));\n\t\tBUG_ON(!nr_bhs && (m_start != block_start));\n\t\tBUG_ON(nr_bhs >= max_bhs);\n\t\tbhs[nr_bhs++] = bh;\n\t\tBUG_ON((nr_bhs >= max_bhs) && (m_end != block_end));\n\t} while (block_start = block_end, (bh = bh->b_this_page) != head);\n\tif (unlikely(rl))\n\t\tup_read(&NTFS_I(vol->mft_ino)->runlist.lock);\n\tif (!nr_bhs)\n\t\tgoto done;\n\tif (unlikely(err))\n\t\tgoto cleanup_out;\n\t/* Apply the mst protection fixups. */\n\terr = pre_write_mst_fixup((NTFS_RECORD*)m, vol->mft_record_size);\n\tif (err) {\n\t\tntfs_error(vol->sb, \"Failed to apply mst fixups!\");\n\t\tgoto cleanup_out;\n\t}\n\tflush_dcache_mft_record_page(ni);\n\t/* Lock buffers and start synchronous write i/o on them. */\n\tfor (i_bhs = 0; i_bhs < nr_bhs; i_bhs++) {\n\t\tstruct buffer_head *tbh = bhs[i_bhs];\n\n\t\tif (!trylock_buffer(tbh))\n\t\t\tBUG();\n\t\tBUG_ON(!buffer_uptodate(tbh));\n\t\tclear_buffer_dirty(tbh);\n\t\tget_bh(tbh);\n\t\ttbh->b_end_io = end_buffer_write_sync;\n\t\tsubmit_bh(WRITE, tbh);\n\t}\n\t/* Synchronize the mft mirror now if not @sync. */\n\tif (!sync && ni->mft_no < vol->mftmirr_size)\n\t\tntfs_sync_mft_mirror(vol, ni->mft_no, m, sync);\n\t/* Wait on i/o completion of buffers. */\n\tfor (i_bhs = 0; i_bhs < nr_bhs; i_bhs++) {\n\t\tstruct buffer_head *tbh = bhs[i_bhs];\n\n\t\twait_on_buffer(tbh);\n\t\tif (unlikely(!buffer_uptodate(tbh))) {\n\t\t\terr = -EIO;\n\t\t\t/*\n\t\t\t * Set the buffer uptodate so the page and buffer\n\t\t\t * states do not become out of sync.\n\t\t\t */\n\t\t\tif (PageUptodate(page))\n\t\t\t\tset_buffer_uptodate(tbh);\n\t\t}\n\t}\n\t/* If @sync, now synchronize the mft mirror. */\n\tif (sync && ni->mft_no < vol->mftmirr_size)\n\t\tntfs_sync_mft_mirror(vol, ni->mft_no, m, sync);\n\t/* Remove the mst protection fixups again. */\n\tpost_write_mst_fixup((NTFS_RECORD*)m);\n\tflush_dcache_mft_record_page(ni);\n\tif (unlikely(err)) {\n\t\t/* I/O error during writing.  This is really bad! */\n\t\tntfs_error(vol->sb, \"I/O error while writing mft record \"\n\t\t\t\t\"0x%lx!  Marking base inode as bad.  You \"\n\t\t\t\t\"should unmount the volume and run chkdsk.\",\n\t\t\t\tni->mft_no);\n\t\tgoto err_out;\n\t}\ndone:\n\tntfs_debug(\"Done.\");\n\treturn 0;\ncleanup_out:\n\t/* Clean the buffers. */\n\tfor (i_bhs = 0; i_bhs < nr_bhs; i_bhs++)\n\t\tclear_buffer_dirty(bhs[i_bhs]);\nerr_out:\n\t/*\n\t * Current state: all buffers are clean, unlocked, and uptodate.\n\t * The caller should mark the base inode as bad so that no more i/o\n\t * happens.  ->clear_inode() will still be invoked so all extent inodes\n\t * and other allocated memory will be freed.\n\t */\n\tif (err == -ENOMEM) {\n\t\tntfs_error(vol->sb, \"Not enough memory to write mft record.  \"\n\t\t\t\t\"Redirtying so the write is retried later.\");\n\t\tmark_mft_record_dirty(ni);\n\t\terr = 0;\n\t} else\n\t\tNVolSetErrors(vol);\n\treturn err;\n}"
  },
  {
    "function_name": "ntfs_sync_mft_mirror",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/mft.c",
    "lines": "465-636",
    "snippet": "int ntfs_sync_mft_mirror(ntfs_volume *vol, const unsigned long mft_no,\n\t\tMFT_RECORD *m, int sync)\n{\n\tstruct page *page;\n\tunsigned int blocksize = vol->sb->s_blocksize;\n\tint max_bhs = vol->mft_record_size / blocksize;\n\tstruct buffer_head *bhs[max_bhs];\n\tstruct buffer_head *bh, *head;\n\tu8 *kmirr;\n\trunlist_element *rl;\n\tunsigned int block_start, block_end, m_start, m_end, page_ofs;\n\tint i_bhs, nr_bhs, err = 0;\n\tunsigned char blocksize_bits = vol->sb->s_blocksize_bits;\n\n\tntfs_debug(\"Entering for inode 0x%lx.\", mft_no);\n\tBUG_ON(!max_bhs);\n\tif (unlikely(!vol->mftmirr_ino)) {\n\t\t/* This could happen during umount... */\n\t\terr = ntfs_sync_mft_mirror_umount(vol, mft_no, m);\n\t\tif (likely(!err))\n\t\t\treturn err;\n\t\tgoto err_out;\n\t}\n\t/* Get the page containing the mirror copy of the mft record @m. */\n\tpage = ntfs_map_page(vol->mftmirr_ino->i_mapping, mft_no >>\n\t\t\t(PAGE_CACHE_SHIFT - vol->mft_record_size_bits));\n\tif (IS_ERR(page)) {\n\t\tntfs_error(vol->sb, \"Failed to map mft mirror page.\");\n\t\terr = PTR_ERR(page);\n\t\tgoto err_out;\n\t}\n\tlock_page(page);\n\tBUG_ON(!PageUptodate(page));\n\tClearPageUptodate(page);\n\t/* Offset of the mft mirror record inside the page. */\n\tpage_ofs = (mft_no << vol->mft_record_size_bits) & ~PAGE_CACHE_MASK;\n\t/* The address in the page of the mirror copy of the mft record @m. */\n\tkmirr = page_address(page) + page_ofs;\n\t/* Copy the mst protected mft record to the mirror. */\n\tmemcpy(kmirr, m, vol->mft_record_size);\n\t/* Create uptodate buffers if not present. */\n\tif (unlikely(!page_has_buffers(page))) {\n\t\tstruct buffer_head *tail;\n\n\t\tbh = head = alloc_page_buffers(page, blocksize, 1);\n\t\tdo {\n\t\t\tset_buffer_uptodate(bh);\n\t\t\ttail = bh;\n\t\t\tbh = bh->b_this_page;\n\t\t} while (bh);\n\t\ttail->b_this_page = head;\n\t\tattach_page_buffers(page, head);\n\t}\n\tbh = head = page_buffers(page);\n\tBUG_ON(!bh);\n\trl = NULL;\n\tnr_bhs = 0;\n\tblock_start = 0;\n\tm_start = kmirr - (u8*)page_address(page);\n\tm_end = m_start + vol->mft_record_size;\n\tdo {\n\t\tblock_end = block_start + blocksize;\n\t\t/* If the buffer is outside the mft record, skip it. */\n\t\tif (block_end <= m_start)\n\t\t\tcontinue;\n\t\tif (unlikely(block_start >= m_end))\n\t\t\tbreak;\n\t\t/* Need to map the buffer if it is not mapped already. */\n\t\tif (unlikely(!buffer_mapped(bh))) {\n\t\t\tVCN vcn;\n\t\t\tLCN lcn;\n\t\t\tunsigned int vcn_ofs;\n\n\t\t\tbh->b_bdev = vol->sb->s_bdev;\n\t\t\t/* Obtain the vcn and offset of the current block. */\n\t\t\tvcn = ((VCN)mft_no << vol->mft_record_size_bits) +\n\t\t\t\t\t(block_start - m_start);\n\t\t\tvcn_ofs = vcn & vol->cluster_size_mask;\n\t\t\tvcn >>= vol->cluster_size_bits;\n\t\t\tif (!rl) {\n\t\t\t\tdown_read(&NTFS_I(vol->mftmirr_ino)->\n\t\t\t\t\t\trunlist.lock);\n\t\t\t\trl = NTFS_I(vol->mftmirr_ino)->runlist.rl;\n\t\t\t\t/*\n\t\t\t\t * $MFTMirr always has the whole of its runlist\n\t\t\t\t * in memory.\n\t\t\t\t */\n\t\t\t\tBUG_ON(!rl);\n\t\t\t}\n\t\t\t/* Seek to element containing target vcn. */\n\t\t\twhile (rl->length && rl[1].vcn <= vcn)\n\t\t\t\trl++;\n\t\t\tlcn = ntfs_rl_vcn_to_lcn(rl, vcn);\n\t\t\t/* For $MFTMirr, only lcn >= 0 is a successful remap. */\n\t\t\tif (likely(lcn >= 0)) {\n\t\t\t\t/* Setup buffer head to correct block. */\n\t\t\t\tbh->b_blocknr = ((lcn <<\n\t\t\t\t\t\tvol->cluster_size_bits) +\n\t\t\t\t\t\tvcn_ofs) >> blocksize_bits;\n\t\t\t\tset_buffer_mapped(bh);\n\t\t\t} else {\n\t\t\t\tbh->b_blocknr = -1;\n\t\t\t\tntfs_error(vol->sb, \"Cannot write mft mirror \"\n\t\t\t\t\t\t\"record 0x%lx because its \"\n\t\t\t\t\t\t\"location on disk could not \"\n\t\t\t\t\t\t\"be determined (error code \"\n\t\t\t\t\t\t\"%lli).\", mft_no,\n\t\t\t\t\t\t(long long)lcn);\n\t\t\t\terr = -EIO;\n\t\t\t}\n\t\t}\n\t\tBUG_ON(!buffer_uptodate(bh));\n\t\tBUG_ON(!nr_bhs && (m_start != block_start));\n\t\tBUG_ON(nr_bhs >= max_bhs);\n\t\tbhs[nr_bhs++] = bh;\n\t\tBUG_ON((nr_bhs >= max_bhs) && (m_end != block_end));\n\t} while (block_start = block_end, (bh = bh->b_this_page) != head);\n\tif (unlikely(rl))\n\t\tup_read(&NTFS_I(vol->mftmirr_ino)->runlist.lock);\n\tif (likely(!err)) {\n\t\t/* Lock buffers and start synchronous write i/o on them. */\n\t\tfor (i_bhs = 0; i_bhs < nr_bhs; i_bhs++) {\n\t\t\tstruct buffer_head *tbh = bhs[i_bhs];\n\n\t\t\tif (!trylock_buffer(tbh))\n\t\t\t\tBUG();\n\t\t\tBUG_ON(!buffer_uptodate(tbh));\n\t\t\tclear_buffer_dirty(tbh);\n\t\t\tget_bh(tbh);\n\t\t\ttbh->b_end_io = end_buffer_write_sync;\n\t\t\tsubmit_bh(WRITE, tbh);\n\t\t}\n\t\t/* Wait on i/o completion of buffers. */\n\t\tfor (i_bhs = 0; i_bhs < nr_bhs; i_bhs++) {\n\t\t\tstruct buffer_head *tbh = bhs[i_bhs];\n\n\t\t\twait_on_buffer(tbh);\n\t\t\tif (unlikely(!buffer_uptodate(tbh))) {\n\t\t\t\terr = -EIO;\n\t\t\t\t/*\n\t\t\t\t * Set the buffer uptodate so the page and\n\t\t\t\t * buffer states do not become out of sync.\n\t\t\t\t */\n\t\t\t\tset_buffer_uptodate(tbh);\n\t\t\t}\n\t\t}\n\t} else /* if (unlikely(err)) */ {\n\t\t/* Clean the buffers. */\n\t\tfor (i_bhs = 0; i_bhs < nr_bhs; i_bhs++)\n\t\t\tclear_buffer_dirty(bhs[i_bhs]);\n\t}\n\t/* Current state: all buffers are clean, unlocked, and uptodate. */\n\t/* Remove the mst protection fixups again. */\n\tpost_write_mst_fixup((NTFS_RECORD*)kmirr);\n\tflush_dcache_page(page);\n\tSetPageUptodate(page);\n\tunlock_page(page);\n\tntfs_unmap_page(page);\n\tif (likely(!err)) {\n\t\tntfs_debug(\"Done.\");\n\t} else {\n\t\tntfs_error(vol->sb, \"I/O error while writing mft mirror \"\n\t\t\t\t\"record 0x%lx!\", mft_no);\nerr_out:\n\t\tntfs_error(vol->sb, \"Failed to synchronize $MFTMirr (error \"\n\t\t\t\t\"code %i).  Volume will be left marked dirty \"\n\t\t\t\t\"on umount.  Run ntfsfix on the partition \"\n\t\t\t\t\"after umounting to correct this.\", -err);\n\t\tNVolSetErrors(vol);\n\t}\n\treturn err;\n}",
    "includes": [
      "#include \"ntfs.h\"",
      "#include \"mft.h\"",
      "#include \"malloc.h\"",
      "#include \"lcnalloc.h\"",
      "#include \"dir.h\"",
      "#include \"debug.h\"",
      "#include \"bitmap.h\"",
      "#include \"aops.h\"",
      "#include \"attrib.h\"",
      "#include <linux/swap.h>",
      "#include <linux/slab.h>",
      "#include <linux/buffer_head.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "NVolSetErrors",
          "args": [
            "vol"
          ],
          "line": 633
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntfs_error",
          "args": [
            "vol->sb",
            "\"Failed to synchronize $MFTMirr (error \"\n\t\t\t\t\"code %i).  Volume will be left marked dirty \"\n\t\t\t\t\"on umount.  Run ntfsfix on the partition \"\n\t\t\t\t\"after umounting to correct this.\"",
            "-err"
          ],
          "line": 629
        },
        "resolved": true,
        "details": {
          "function_name": "__ntfs_error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/debug.c",
          "lines": "86-108",
          "snippet": "void __ntfs_error(const char *function, const struct super_block *sb,\n\t\tconst char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\tint flen = 0;\n\n#ifndef DEBUG\n\tif (!printk_ratelimit())\n\t\treturn;\n#endif\n\tif (function)\n\t\tflen = strlen(function);\n\tva_start(args, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\tif (sb)\n\t\tpr_err(\"(device %s): %s(): %pV\\n\",\n\t\t       sb->s_id, flen ? function : \"\", &vaf);\n\telse\n\t\tpr_err(\"%s(): %pV\\n\", flen ? function : \"\", &vaf);\n\tva_end(args);\n}",
          "includes": [
            "#include \"debug.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"debug.h\"\n\nvoid __ntfs_error(const char *function, const struct super_block *sb,\n\t\tconst char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\tint flen = 0;\n\n#ifndef DEBUG\n\tif (!printk_ratelimit())\n\t\treturn;\n#endif\n\tif (function)\n\t\tflen = strlen(function);\n\tva_start(args, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\tif (sb)\n\t\tpr_err(\"(device %s): %s(): %pV\\n\",\n\t\t       sb->s_id, flen ? function : \"\", &vaf);\n\telse\n\t\tpr_err(\"%s(): %pV\\n\", flen ? function : \"\", &vaf);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ntfs_debug",
          "args": [
            "\"Done.\""
          ],
          "line": 624
        },
        "resolved": true,
        "details": {
          "function_name": "ntfs_debug_dump_runlist",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/debug.c",
          "lines": "134-171",
          "snippet": "void ntfs_debug_dump_runlist(const runlist_element *rl)\n{\n\tint i;\n\tconst char *lcn_str[5] = { \"LCN_HOLE         \", \"LCN_RL_NOT_MAPPED\",\n\t\t\t\t   \"LCN_ENOENT       \", \"LCN_unknown      \" };\n\n\tif (!debug_msgs)\n\t\treturn;\n\tpr_debug(\"Dumping runlist (values in hex):\\n\");\n\tif (!rl) {\n\t\tpr_debug(\"Run list not present.\\n\");\n\t\treturn;\n\t}\n\tpr_debug(\"VCN              LCN               Run length\\n\");\n\tfor (i = 0; ; i++) {\n\t\tLCN lcn = (rl + i)->lcn;\n\n\t\tif (lcn < (LCN)0) {\n\t\t\tint index = -lcn - 1;\n\n\t\t\tif (index > -LCN_ENOENT - 1)\n\t\t\t\tindex = 3;\n\t\t\tpr_debug(\"%-16Lx %s %-16Lx%s\\n\",\n\t\t\t\t\t(long long)(rl + i)->vcn, lcn_str[index],\n\t\t\t\t\t(long long)(rl + i)->length,\n\t\t\t\t\t(rl + i)->length ? \"\" :\n\t\t\t\t\t\t\" (runlist end)\");\n\t\t} else\n\t\t\tpr_debug(\"%-16Lx %-16Lx  %-16Lx%s\\n\",\n\t\t\t\t\t(long long)(rl + i)->vcn,\n\t\t\t\t\t(long long)(rl + i)->lcn,\n\t\t\t\t\t(long long)(rl + i)->length,\n\t\t\t\t\t(rl + i)->length ? \"\" :\n\t\t\t\t\t\t\" (runlist end)\");\n\t\tif (!(rl + i)->length)\n\t\t\tbreak;\n\t}\n}",
          "includes": [
            "#include \"debug.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"debug.h\"\n\nvoid ntfs_debug_dump_runlist(const runlist_element *rl)\n{\n\tint i;\n\tconst char *lcn_str[5] = { \"LCN_HOLE         \", \"LCN_RL_NOT_MAPPED\",\n\t\t\t\t   \"LCN_ENOENT       \", \"LCN_unknown      \" };\n\n\tif (!debug_msgs)\n\t\treturn;\n\tpr_debug(\"Dumping runlist (values in hex):\\n\");\n\tif (!rl) {\n\t\tpr_debug(\"Run list not present.\\n\");\n\t\treturn;\n\t}\n\tpr_debug(\"VCN              LCN               Run length\\n\");\n\tfor (i = 0; ; i++) {\n\t\tLCN lcn = (rl + i)->lcn;\n\n\t\tif (lcn < (LCN)0) {\n\t\t\tint index = -lcn - 1;\n\n\t\t\tif (index > -LCN_ENOENT - 1)\n\t\t\t\tindex = 3;\n\t\t\tpr_debug(\"%-16Lx %s %-16Lx%s\\n\",\n\t\t\t\t\t(long long)(rl + i)->vcn, lcn_str[index],\n\t\t\t\t\t(long long)(rl + i)->length,\n\t\t\t\t\t(rl + i)->length ? \"\" :\n\t\t\t\t\t\t\" (runlist end)\");\n\t\t} else\n\t\t\tpr_debug(\"%-16Lx %-16Lx  %-16Lx%s\\n\",\n\t\t\t\t\t(long long)(rl + i)->vcn,\n\t\t\t\t\t(long long)(rl + i)->lcn,\n\t\t\t\t\t(long long)(rl + i)->length,\n\t\t\t\t\t(rl + i)->length ? \"\" :\n\t\t\t\t\t\t\" (runlist end)\");\n\t\tif (!(rl + i)->length)\n\t\t\tbreak;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "likely",
          "args": [
            "!err"
          ],
          "line": 623
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntfs_unmap_page",
          "args": [
            "page"
          ],
          "line": 622
        },
        "resolved": true,
        "details": {
          "function_name": "ntfs_unmap_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/aops.h",
          "lines": "40-44",
          "snippet": "static inline void ntfs_unmap_page(struct page *page)\n{\n\tkunmap(page);\n\tpage_cache_release(page);\n}",
          "includes": [
            "#include \"inode.h\"",
            "#include <linux/fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"inode.h\"\n#include <linux/fs.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n\nstatic inline void ntfs_unmap_page(struct page *page)\n{\n\tkunmap(page);\n\tpage_cache_release(page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlock_page",
          "args": [
            "page"
          ],
          "line": 621
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_unlock_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/aops.c",
          "lines": "1127-1148",
          "snippet": "static void ocfs2_unlock_pages(struct ocfs2_write_ctxt *wc)\n{\n\tint i;\n\n\t/*\n\t * w_target_locked is only set to true in the page_mkwrite() case.\n\t * The intent is to allow us to lock the target page from write_begin()\n\t * to write_end(). The caller must hold a ref on w_target_page.\n\t */\n\tif (wc->w_target_locked) {\n\t\tBUG_ON(!wc->w_target_page);\n\t\tfor (i = 0; i < wc->w_num_pages; i++) {\n\t\t\tif (wc->w_target_page == wc->w_pages[i]) {\n\t\t\t\twc->w_pages[i] = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tmark_page_accessed(wc->w_target_page);\n\t\tpage_cache_release(wc->w_target_page);\n\t}\n\tocfs2_unlock_and_free_pages(wc->w_pages, wc->w_num_pages);\n}",
          "includes": [
            "#include \"sysfile.h\"",
            "#include \"namei.h\"",
            "#include \"dir.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"symlink.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/mpage.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/swap.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sysfile.h\"\n#include \"namei.h\"\n#include \"dir.h\"\n#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"symlink.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/mpage.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/swap.h>\n#include <asm/byteorder.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic void ocfs2_unlock_pages(struct ocfs2_write_ctxt *wc)\n{\n\tint i;\n\n\t/*\n\t * w_target_locked is only set to true in the page_mkwrite() case.\n\t * The intent is to allow us to lock the target page from write_begin()\n\t * to write_end(). The caller must hold a ref on w_target_page.\n\t */\n\tif (wc->w_target_locked) {\n\t\tBUG_ON(!wc->w_target_page);\n\t\tfor (i = 0; i < wc->w_num_pages; i++) {\n\t\t\tif (wc->w_target_page == wc->w_pages[i]) {\n\t\t\t\twc->w_pages[i] = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tmark_page_accessed(wc->w_target_page);\n\t\tpage_cache_release(wc->w_target_page);\n\t}\n\tocfs2_unlock_and_free_pages(wc->w_pages, wc->w_num_pages);\n}"
        }
      },
      {
        "call_info": {
          "callee": "SetPageUptodate",
          "args": [
            "page"
          ],
          "line": 620
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "flush_dcache_page",
          "args": [
            "page"
          ],
          "line": 619
        },
        "resolved": true,
        "details": {
          "function_name": "ntfs_index_entry_flush_dcache_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/index.h",
          "lines": "111-117",
          "snippet": "static inline void ntfs_index_entry_flush_dcache_page(ntfs_index_context *ictx)\n{\n\tif (ictx->is_in_root)\n\t\tflush_dcache_mft_record_page(ictx->actx->ntfs_ino);\n\telse\n\t\tflush_dcache_page(ictx->page);\n}",
          "includes": [
            "#include \"aops.h\"",
            "#include \"mft.h\"",
            "#include \"attrib.h\"",
            "#include \"inode.h\"",
            "#include \"layout.h\"",
            "#include \"types.h\"",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"aops.h\"\n#include \"mft.h\"\n#include \"attrib.h\"\n#include \"inode.h\"\n#include \"layout.h\"\n#include \"types.h\"\n#include <linux/fs.h>\n\nstatic inline void ntfs_index_entry_flush_dcache_page(ntfs_index_context *ictx)\n{\n\tif (ictx->is_in_root)\n\t\tflush_dcache_mft_record_page(ictx->actx->ntfs_ino);\n\telse\n\t\tflush_dcache_page(ictx->page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "post_write_mst_fixup",
          "args": [
            "(NTFS_RECORD*)kmirr"
          ],
          "line": 618
        },
        "resolved": true,
        "details": {
          "function_name": "post_write_mst_fixup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/mst.c",
          "lines": "179-203",
          "snippet": "void post_write_mst_fixup(NTFS_RECORD *b)\n{\n\tle16 *usa_pos, *data_pos;\n\n\tu16 usa_ofs = le16_to_cpu(b->usa_ofs);\n\tu16 usa_count = le16_to_cpu(b->usa_count) - 1;\n\n\t/* Position of usn in update sequence array. */\n\tusa_pos = (le16*)b + usa_ofs/sizeof(le16);\n\n\t/* Position in protected data of first u16 that needs fixing up. */\n\tdata_pos = (le16*)b + NTFS_BLOCK_SIZE/sizeof(le16) - 1;\n\n\t/* Fixup all sectors. */\n\twhile (usa_count--) {\n\t\t/*\n\t\t * Increment position in usa and restore original data from\n\t\t * the usa into the data buffer.\n\t\t */\n\t\t*data_pos = *(++usa_pos);\n\n\t\t/* Increment position in data as well. */\n\t\tdata_pos += NTFS_BLOCK_SIZE/sizeof(le16);\n\t}\n}",
          "includes": [
            "#include \"ntfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ntfs.h\"\n\nvoid post_write_mst_fixup(NTFS_RECORD *b)\n{\n\tle16 *usa_pos, *data_pos;\n\n\tu16 usa_ofs = le16_to_cpu(b->usa_ofs);\n\tu16 usa_count = le16_to_cpu(b->usa_count) - 1;\n\n\t/* Position of usn in update sequence array. */\n\tusa_pos = (le16*)b + usa_ofs/sizeof(le16);\n\n\t/* Position in protected data of first u16 that needs fixing up. */\n\tdata_pos = (le16*)b + NTFS_BLOCK_SIZE/sizeof(le16) - 1;\n\n\t/* Fixup all sectors. */\n\twhile (usa_count--) {\n\t\t/*\n\t\t * Increment position in usa and restore original data from\n\t\t * the usa into the data buffer.\n\t\t */\n\t\t*data_pos = *(++usa_pos);\n\n\t\t/* Increment position in data as well. */\n\t\tdata_pos += NTFS_BLOCK_SIZE/sizeof(le16);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "clear_buffer_dirty",
          "args": [
            "bhs[i_bhs]"
          ],
          "line": 614
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_buffer_uptodate",
          "args": [
            "tbh"
          ],
          "line": 608
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_set_buffer_uptodate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/disk-io.c",
          "lines": "3758-3761",
          "snippet": "int btrfs_set_buffer_uptodate(struct extent_buffer *buf)\n{\n\treturn set_extent_buffer_uptodate(buf);\n}",
          "includes": [
            "#include <asm/cpufeature.h>",
            "#include \"qgroup.h\"",
            "#include \"sysfs.h\"",
            "#include \"raid56.h\"",
            "#include \"dev-replace.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"inode-map.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"tree-log.h\"",
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"hash.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/uuid.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/migrate.h>",
            "#include <linux/slab.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/writeback.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/swap.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/cpufeature.h>\n#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"raid56.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <asm/unaligned.h>\n#include <linux/semaphore.h>\n#include <linux/uuid.h>\n#include <linux/ratelimit.h>\n#include <linux/migrate.h>\n#include <linux/slab.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/writeback.h>\n#include <linux/radix-tree.h>\n#include <linux/swap.h>\n#include <linux/scatterlist.h>\n#include <linux/blkdev.h>\n#include <linux/fs.h>\n\nint btrfs_set_buffer_uptodate(struct extent_buffer *buf)\n{\n\treturn set_extent_buffer_uptodate(buf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!buffer_uptodate(tbh)"
          ],
          "line": 602
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wait_on_buffer",
          "args": [
            "tbh"
          ],
          "line": 601
        },
        "resolved": true,
        "details": {
          "function_name": "__wait_on_buffer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "117-120",
          "snippet": "void __wait_on_buffer(struct buffer_head * bh)\n{\n\twait_on_bit_io(&bh->b_state, BH_Lock, TASK_UNINTERRUPTIBLE);\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid __wait_on_buffer(struct buffer_head * bh)\n{\n\twait_on_bit_io(&bh->b_state, BH_Lock, TASK_UNINTERRUPTIBLE);\n}"
        }
      },
      {
        "call_info": {
          "callee": "submit_bh",
          "args": [
            "WRITE",
            "tbh"
          ],
          "line": 595
        },
        "resolved": true,
        "details": {
          "function_name": "submit_bh",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "3055-3058",
          "snippet": "int submit_bh(int rw, struct buffer_head *bh)\n{\n\treturn _submit_bh(rw, bh, 0);\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nint submit_bh(int rw, struct buffer_head *bh)\n{\n\treturn _submit_bh(rw, bh, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_bh",
          "args": [
            "tbh"
          ],
          "line": 593
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "clear_buffer_dirty",
          "args": [
            "tbh"
          ],
          "line": 592
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!buffer_uptodate(tbh)"
          ],
          "line": 591
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG",
          "args": [],
          "line": 590
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trylock_buffer",
          "args": [
            "tbh"
          ],
          "line": 589
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "likely",
          "args": [
            "!err"
          ],
          "line": 584
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "up_read",
          "args": [
            "&NTFS_I(vol->mftmirr_ino)->runlist.lock"
          ],
          "line": 583
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NTFS_I",
          "args": [
            "vol->mftmirr_ino"
          ],
          "line": 583
        },
        "resolved": true,
        "details": {
          "function_name": "NTFS_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/inode.h",
          "lines": "240-243",
          "snippet": "static inline ntfs_inode *NTFS_I(struct inode *inode)\n{\n\treturn (ntfs_inode *)list_entry(inode, big_ntfs_inode, vfs_inode);\n}",
          "includes": [
            "#include \"debug.h\"",
            "#include \"runlist.h\"",
            "#include \"types.h\"",
            "#include \"volume.h\"",
            "#include \"layout.h\"",
            "#include <linux/seq_file.h>",
            "#include <linux/mutex.h>",
            "#include <linux/mm.h>",
            "#include <linux/list.h>",
            "#include <linux/fs.h>",
            "#include <linux/atomic.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"debug.h\"\n#include \"runlist.h\"\n#include \"types.h\"\n#include \"volume.h\"\n#include \"layout.h\"\n#include <linux/seq_file.h>\n#include <linux/mutex.h>\n#include <linux/mm.h>\n#include <linux/list.h>\n#include <linux/fs.h>\n#include <linux/atomic.h>\n\nstatic inline ntfs_inode *NTFS_I(struct inode *inode)\n{\n\treturn (ntfs_inode *)list_entry(inode, big_ntfs_inode, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "rl"
          ],
          "line": 582
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "(nr_bhs >= max_bhs) && (m_end != block_end)"
          ],
          "line": 580
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "nr_bhs >= max_bhs"
          ],
          "line": 578
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!nr_bhs && (m_start != block_start)"
          ],
          "line": 577
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!buffer_uptodate(bh)"
          ],
          "line": 576
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_buffer_mapped",
          "args": [
            "bh"
          ],
          "line": 564
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "likely",
          "args": [
            "lcn >= 0"
          ],
          "line": 559
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntfs_rl_vcn_to_lcn",
          "args": [
            "rl",
            "vcn"
          ],
          "line": 557
        },
        "resolved": true,
        "details": {
          "function_name": "ntfs_rl_vcn_to_lcn",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/runlist.c",
          "lines": "1004-1036",
          "snippet": "LCN ntfs_rl_vcn_to_lcn(const runlist_element *rl, const VCN vcn)\n{\n\tint i;\n\n\tBUG_ON(vcn < 0);\n\t/*\n\t * If rl is NULL, assume that we have found an unmapped runlist. The\n\t * caller can then attempt to map it and fail appropriately if\n\t * necessary.\n\t */\n\tif (unlikely(!rl))\n\t\treturn LCN_RL_NOT_MAPPED;\n\n\t/* Catch out of lower bounds vcn. */\n\tif (unlikely(vcn < rl[0].vcn))\n\t\treturn LCN_ENOENT;\n\n\tfor (i = 0; likely(rl[i].length); i++) {\n\t\tif (unlikely(vcn < rl[i+1].vcn)) {\n\t\t\tif (likely(rl[i].lcn >= (LCN)0))\n\t\t\t\treturn rl[i].lcn + (vcn - rl[i].vcn);\n\t\t\treturn rl[i].lcn;\n\t\t}\n\t}\n\t/*\n\t * The terminator element is setup to the correct value, i.e. one of\n\t * LCN_HOLE, LCN_RL_NOT_MAPPED, or LCN_ENOENT.\n\t */\n\tif (likely(rl[i].lcn < (LCN)0))\n\t\treturn rl[i].lcn;\n\t/* Just in case... We could replace this with BUG() some day. */\n\treturn LCN_ENOENT;\n}",
          "includes": [
            "#include \"ntfs.h\"",
            "#include \"malloc.h\"",
            "#include \"endian.h\"",
            "#include \"dir.h\"",
            "#include \"debug.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ntfs.h\"\n#include \"malloc.h\"\n#include \"endian.h\"\n#include \"dir.h\"\n#include \"debug.h\"\n\nLCN ntfs_rl_vcn_to_lcn(const runlist_element *rl, const VCN vcn)\n{\n\tint i;\n\n\tBUG_ON(vcn < 0);\n\t/*\n\t * If rl is NULL, assume that we have found an unmapped runlist. The\n\t * caller can then attempt to map it and fail appropriately if\n\t * necessary.\n\t */\n\tif (unlikely(!rl))\n\t\treturn LCN_RL_NOT_MAPPED;\n\n\t/* Catch out of lower bounds vcn. */\n\tif (unlikely(vcn < rl[0].vcn))\n\t\treturn LCN_ENOENT;\n\n\tfor (i = 0; likely(rl[i].length); i++) {\n\t\tif (unlikely(vcn < rl[i+1].vcn)) {\n\t\t\tif (likely(rl[i].lcn >= (LCN)0))\n\t\t\t\treturn rl[i].lcn + (vcn - rl[i].vcn);\n\t\t\treturn rl[i].lcn;\n\t\t}\n\t}\n\t/*\n\t * The terminator element is setup to the correct value, i.e. one of\n\t * LCN_HOLE, LCN_RL_NOT_MAPPED, or LCN_ENOENT.\n\t */\n\tif (likely(rl[i].lcn < (LCN)0))\n\t\treturn rl[i].lcn;\n\t/* Just in case... We could replace this with BUG() some day. */\n\treturn LCN_ENOENT;\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!rl"
          ],
          "line": 552
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "down_read",
          "args": [
            "&NTFS_I(vol->mftmirr_ino)->\n\t\t\t\t\t\trunlist.lock"
          ],
          "line": 545
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!buffer_mapped(bh)"
          ],
          "line": 533
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "buffer_mapped",
          "args": [
            "bh"
          ],
          "line": 533
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "block_start >= m_end"
          ],
          "line": 530
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_address",
          "args": [
            "page"
          ],
          "line": 523
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!bh"
          ],
          "line": 519
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_buffers",
          "args": [
            "page"
          ],
          "line": 518
        },
        "resolved": true,
        "details": {
          "function_name": "__clear_page_buffers",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "123-129",
          "snippet": "static void\n__clear_page_buffers(struct page *page)\n{\n\tClearPagePrivate(page);\n\tset_page_private(page, 0);\n\tpage_cache_release(page);\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nstatic void\n__clear_page_buffers(struct page *page)\n{\n\tClearPagePrivate(page);\n\tset_page_private(page, 0);\n\tpage_cache_release(page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "attach_page_buffers",
          "args": [
            "page",
            "head"
          ],
          "line": 516
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "alloc_page_buffers",
          "args": [
            "page",
            "blocksize",
            "1"
          ],
          "line": 509
        },
        "resolved": true,
        "details": {
          "function_name": "alloc_page_buffers",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "855-908",
          "snippet": "struct buffer_head *alloc_page_buffers(struct page *page, unsigned long size,\n\t\tint retry)\n{\n\tstruct buffer_head *bh, *head;\n\tlong offset;\n\ntry_again:\n\thead = NULL;\n\toffset = PAGE_SIZE;\n\twhile ((offset -= size) >= 0) {\n\t\tbh = alloc_buffer_head(GFP_NOFS);\n\t\tif (!bh)\n\t\t\tgoto no_grow;\n\n\t\tbh->b_this_page = head;\n\t\tbh->b_blocknr = -1;\n\t\thead = bh;\n\n\t\tbh->b_size = size;\n\n\t\t/* Link the buffer to its page */\n\t\tset_bh_page(bh, page, offset);\n\t}\n\treturn head;\n/*\n * In case anything failed, we just free everything we got.\n */\nno_grow:\n\tif (head) {\n\t\tdo {\n\t\t\tbh = head;\n\t\t\thead = head->b_this_page;\n\t\t\tfree_buffer_head(bh);\n\t\t} while (head);\n\t}\n\n\t/*\n\t * Return failure for non-async IO requests.  Async IO requests\n\t * are not allowed to fail, so we have to wait until buffer heads\n\t * become available.  But we don't want tasks sleeping with \n\t * partially complete buffers, so all were released above.\n\t */\n\tif (!retry)\n\t\treturn NULL;\n\n\t/* We're _really_ low on memory. Now we just\n\t * wait for old buffer heads to become free due to\n\t * finishing IO.  Since this is an async request and\n\t * the reserve list is empty, we're sure there are \n\t * async buffer heads in use.\n\t */\n\tfree_more_memory();\n\tgoto try_again;\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int fsync_buffers_list(spinlock_t *lock, struct list_head *list);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nstatic int fsync_buffers_list(spinlock_t *lock, struct list_head *list);\n\nstruct buffer_head *alloc_page_buffers(struct page *page, unsigned long size,\n\t\tint retry)\n{\n\tstruct buffer_head *bh, *head;\n\tlong offset;\n\ntry_again:\n\thead = NULL;\n\toffset = PAGE_SIZE;\n\twhile ((offset -= size) >= 0) {\n\t\tbh = alloc_buffer_head(GFP_NOFS);\n\t\tif (!bh)\n\t\t\tgoto no_grow;\n\n\t\tbh->b_this_page = head;\n\t\tbh->b_blocknr = -1;\n\t\thead = bh;\n\n\t\tbh->b_size = size;\n\n\t\t/* Link the buffer to its page */\n\t\tset_bh_page(bh, page, offset);\n\t}\n\treturn head;\n/*\n * In case anything failed, we just free everything we got.\n */\nno_grow:\n\tif (head) {\n\t\tdo {\n\t\t\tbh = head;\n\t\t\thead = head->b_this_page;\n\t\t\tfree_buffer_head(bh);\n\t\t} while (head);\n\t}\n\n\t/*\n\t * Return failure for non-async IO requests.  Async IO requests\n\t * are not allowed to fail, so we have to wait until buffer heads\n\t * become available.  But we don't want tasks sleeping with \n\t * partially complete buffers, so all were released above.\n\t */\n\tif (!retry)\n\t\treturn NULL;\n\n\t/* We're _really_ low on memory. Now we just\n\t * wait for old buffer heads to become free due to\n\t * finishing IO.  Since this is an async request and\n\t * the reserve list is empty, we're sure there are \n\t * async buffer heads in use.\n\t */\n\tfree_more_memory();\n\tgoto try_again;\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!page_has_buffers(page)"
          ],
          "line": 506
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_has_buffers",
          "args": [
            "page"
          ],
          "line": 506
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "kmirr",
            "m",
            "vol->mft_record_size"
          ],
          "line": 504
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_address",
          "args": [
            "page"
          ],
          "line": 502
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ClearPageUptodate",
          "args": [
            "page"
          ],
          "line": 498
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!PageUptodate(page)"
          ],
          "line": 497
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageUptodate",
          "args": [
            "page"
          ],
          "line": 497
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "page"
          ],
          "line": 493
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntfs_error",
          "args": [
            "vol->sb",
            "\"Failed to map mft mirror page.\""
          ],
          "line": 492
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "page"
          ],
          "line": 491
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntfs_map_page",
          "args": [
            "vol->mftmirr_ino->i_mapping",
            "mft_no >>\n\t\t\t(PAGE_CACHE_SHIFT - vol->mft_record_size_bits)"
          ],
          "line": 489
        },
        "resolved": true,
        "details": {
          "function_name": "ntfs_map_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/aops.h",
          "lines": "86-99",
          "snippet": "static inline struct page *ntfs_map_page(struct address_space *mapping,\n\t\tunsigned long index)\n{\n\tstruct page *page = read_mapping_page(mapping, index, NULL);\n\n\tif (!IS_ERR(page)) {\n\t\tkmap(page);\n\t\tif (!PageError(page))\n\t\t\treturn page;\n\t\tntfs_unmap_page(page);\n\t\treturn ERR_PTR(-EIO);\n\t}\n\treturn page;\n}",
          "includes": [
            "#include \"inode.h\"",
            "#include <linux/fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"inode.h\"\n#include <linux/fs.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n\nstatic inline struct page *ntfs_map_page(struct address_space *mapping,\n\t\tunsigned long index)\n{\n\tstruct page *page = read_mapping_page(mapping, index, NULL);\n\n\tif (!IS_ERR(page)) {\n\t\tkmap(page);\n\t\tif (!PageError(page))\n\t\t\treturn page;\n\t\tntfs_unmap_page(page);\n\t\treturn ERR_PTR(-EIO);\n\t}\n\treturn page;\n}"
        }
      },
      {
        "call_info": {
          "callee": "likely",
          "args": [
            "!err"
          ],
          "line": 484
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntfs_sync_mft_mirror_umount",
          "args": [
            "vol",
            "mft_no",
            "m"
          ],
          "line": 483
        },
        "resolved": true,
        "details": {
          "function_name": "ntfs_sync_mft_mirror_umount",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/mft.c",
          "lines": "438-445",
          "snippet": "static int ntfs_sync_mft_mirror_umount(ntfs_volume *vol,\n\t\tconst unsigned long mft_no, MFT_RECORD *m)\n{\n\tBUG_ON(vol->mftmirr_ino);\n\tntfs_error(vol->sb, \"Umount time mft mirror syncing is not \"\n\t\t\t\"implemented yet.  %s\", ntfs_please_email);\n\treturn -EOPNOTSUPP;\n}",
          "includes": [
            "#include \"ntfs.h\"",
            "#include \"mft.h\"",
            "#include \"malloc.h\"",
            "#include \"lcnalloc.h\"",
            "#include \"dir.h\"",
            "#include \"debug.h\"",
            "#include \"bitmap.h\"",
            "#include \"aops.h\"",
            "#include \"attrib.h\"",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ntfs.h\"\n#include \"mft.h\"\n#include \"malloc.h\"\n#include \"lcnalloc.h\"\n#include \"dir.h\"\n#include \"debug.h\"\n#include \"bitmap.h\"\n#include \"aops.h\"\n#include \"attrib.h\"\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n\nstatic int ntfs_sync_mft_mirror_umount(ntfs_volume *vol,\n\t\tconst unsigned long mft_no, MFT_RECORD *m)\n{\n\tBUG_ON(vol->mftmirr_ino);\n\tntfs_error(vol->sb, \"Umount time mft mirror syncing is not \"\n\t\t\t\"implemented yet.  %s\", ntfs_please_email);\n\treturn -EOPNOTSUPP;\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!vol->mftmirr_ino"
          ],
          "line": 481
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!max_bhs"
          ],
          "line": 480
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntfs_debug",
          "args": [
            "\"Entering for inode 0x%lx.\"",
            "mft_no"
          ],
          "line": 479
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ntfs.h\"\n#include \"mft.h\"\n#include \"malloc.h\"\n#include \"lcnalloc.h\"\n#include \"dir.h\"\n#include \"debug.h\"\n#include \"bitmap.h\"\n#include \"aops.h\"\n#include \"attrib.h\"\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n\nint ntfs_sync_mft_mirror(ntfs_volume *vol, const unsigned long mft_no,\n\t\tMFT_RECORD *m, int sync)\n{\n\tstruct page *page;\n\tunsigned int blocksize = vol->sb->s_blocksize;\n\tint max_bhs = vol->mft_record_size / blocksize;\n\tstruct buffer_head *bhs[max_bhs];\n\tstruct buffer_head *bh, *head;\n\tu8 *kmirr;\n\trunlist_element *rl;\n\tunsigned int block_start, block_end, m_start, m_end, page_ofs;\n\tint i_bhs, nr_bhs, err = 0;\n\tunsigned char blocksize_bits = vol->sb->s_blocksize_bits;\n\n\tntfs_debug(\"Entering for inode 0x%lx.\", mft_no);\n\tBUG_ON(!max_bhs);\n\tif (unlikely(!vol->mftmirr_ino)) {\n\t\t/* This could happen during umount... */\n\t\terr = ntfs_sync_mft_mirror_umount(vol, mft_no, m);\n\t\tif (likely(!err))\n\t\t\treturn err;\n\t\tgoto err_out;\n\t}\n\t/* Get the page containing the mirror copy of the mft record @m. */\n\tpage = ntfs_map_page(vol->mftmirr_ino->i_mapping, mft_no >>\n\t\t\t(PAGE_CACHE_SHIFT - vol->mft_record_size_bits));\n\tif (IS_ERR(page)) {\n\t\tntfs_error(vol->sb, \"Failed to map mft mirror page.\");\n\t\terr = PTR_ERR(page);\n\t\tgoto err_out;\n\t}\n\tlock_page(page);\n\tBUG_ON(!PageUptodate(page));\n\tClearPageUptodate(page);\n\t/* Offset of the mft mirror record inside the page. */\n\tpage_ofs = (mft_no << vol->mft_record_size_bits) & ~PAGE_CACHE_MASK;\n\t/* The address in the page of the mirror copy of the mft record @m. */\n\tkmirr = page_address(page) + page_ofs;\n\t/* Copy the mst protected mft record to the mirror. */\n\tmemcpy(kmirr, m, vol->mft_record_size);\n\t/* Create uptodate buffers if not present. */\n\tif (unlikely(!page_has_buffers(page))) {\n\t\tstruct buffer_head *tail;\n\n\t\tbh = head = alloc_page_buffers(page, blocksize, 1);\n\t\tdo {\n\t\t\tset_buffer_uptodate(bh);\n\t\t\ttail = bh;\n\t\t\tbh = bh->b_this_page;\n\t\t} while (bh);\n\t\ttail->b_this_page = head;\n\t\tattach_page_buffers(page, head);\n\t}\n\tbh = head = page_buffers(page);\n\tBUG_ON(!bh);\n\trl = NULL;\n\tnr_bhs = 0;\n\tblock_start = 0;\n\tm_start = kmirr - (u8*)page_address(page);\n\tm_end = m_start + vol->mft_record_size;\n\tdo {\n\t\tblock_end = block_start + blocksize;\n\t\t/* If the buffer is outside the mft record, skip it. */\n\t\tif (block_end <= m_start)\n\t\t\tcontinue;\n\t\tif (unlikely(block_start >= m_end))\n\t\t\tbreak;\n\t\t/* Need to map the buffer if it is not mapped already. */\n\t\tif (unlikely(!buffer_mapped(bh))) {\n\t\t\tVCN vcn;\n\t\t\tLCN lcn;\n\t\t\tunsigned int vcn_ofs;\n\n\t\t\tbh->b_bdev = vol->sb->s_bdev;\n\t\t\t/* Obtain the vcn and offset of the current block. */\n\t\t\tvcn = ((VCN)mft_no << vol->mft_record_size_bits) +\n\t\t\t\t\t(block_start - m_start);\n\t\t\tvcn_ofs = vcn & vol->cluster_size_mask;\n\t\t\tvcn >>= vol->cluster_size_bits;\n\t\t\tif (!rl) {\n\t\t\t\tdown_read(&NTFS_I(vol->mftmirr_ino)->\n\t\t\t\t\t\trunlist.lock);\n\t\t\t\trl = NTFS_I(vol->mftmirr_ino)->runlist.rl;\n\t\t\t\t/*\n\t\t\t\t * $MFTMirr always has the whole of its runlist\n\t\t\t\t * in memory.\n\t\t\t\t */\n\t\t\t\tBUG_ON(!rl);\n\t\t\t}\n\t\t\t/* Seek to element containing target vcn. */\n\t\t\twhile (rl->length && rl[1].vcn <= vcn)\n\t\t\t\trl++;\n\t\t\tlcn = ntfs_rl_vcn_to_lcn(rl, vcn);\n\t\t\t/* For $MFTMirr, only lcn >= 0 is a successful remap. */\n\t\t\tif (likely(lcn >= 0)) {\n\t\t\t\t/* Setup buffer head to correct block. */\n\t\t\t\tbh->b_blocknr = ((lcn <<\n\t\t\t\t\t\tvol->cluster_size_bits) +\n\t\t\t\t\t\tvcn_ofs) >> blocksize_bits;\n\t\t\t\tset_buffer_mapped(bh);\n\t\t\t} else {\n\t\t\t\tbh->b_blocknr = -1;\n\t\t\t\tntfs_error(vol->sb, \"Cannot write mft mirror \"\n\t\t\t\t\t\t\"record 0x%lx because its \"\n\t\t\t\t\t\t\"location on disk could not \"\n\t\t\t\t\t\t\"be determined (error code \"\n\t\t\t\t\t\t\"%lli).\", mft_no,\n\t\t\t\t\t\t(long long)lcn);\n\t\t\t\terr = -EIO;\n\t\t\t}\n\t\t}\n\t\tBUG_ON(!buffer_uptodate(bh));\n\t\tBUG_ON(!nr_bhs && (m_start != block_start));\n\t\tBUG_ON(nr_bhs >= max_bhs);\n\t\tbhs[nr_bhs++] = bh;\n\t\tBUG_ON((nr_bhs >= max_bhs) && (m_end != block_end));\n\t} while (block_start = block_end, (bh = bh->b_this_page) != head);\n\tif (unlikely(rl))\n\t\tup_read(&NTFS_I(vol->mftmirr_ino)->runlist.lock);\n\tif (likely(!err)) {\n\t\t/* Lock buffers and start synchronous write i/o on them. */\n\t\tfor (i_bhs = 0; i_bhs < nr_bhs; i_bhs++) {\n\t\t\tstruct buffer_head *tbh = bhs[i_bhs];\n\n\t\t\tif (!trylock_buffer(tbh))\n\t\t\t\tBUG();\n\t\t\tBUG_ON(!buffer_uptodate(tbh));\n\t\t\tclear_buffer_dirty(tbh);\n\t\t\tget_bh(tbh);\n\t\t\ttbh->b_end_io = end_buffer_write_sync;\n\t\t\tsubmit_bh(WRITE, tbh);\n\t\t}\n\t\t/* Wait on i/o completion of buffers. */\n\t\tfor (i_bhs = 0; i_bhs < nr_bhs; i_bhs++) {\n\t\t\tstruct buffer_head *tbh = bhs[i_bhs];\n\n\t\t\twait_on_buffer(tbh);\n\t\t\tif (unlikely(!buffer_uptodate(tbh))) {\n\t\t\t\terr = -EIO;\n\t\t\t\t/*\n\t\t\t\t * Set the buffer uptodate so the page and\n\t\t\t\t * buffer states do not become out of sync.\n\t\t\t\t */\n\t\t\t\tset_buffer_uptodate(tbh);\n\t\t\t}\n\t\t}\n\t} else /* if (unlikely(err)) */ {\n\t\t/* Clean the buffers. */\n\t\tfor (i_bhs = 0; i_bhs < nr_bhs; i_bhs++)\n\t\t\tclear_buffer_dirty(bhs[i_bhs]);\n\t}\n\t/* Current state: all buffers are clean, unlocked, and uptodate. */\n\t/* Remove the mst protection fixups again. */\n\tpost_write_mst_fixup((NTFS_RECORD*)kmirr);\n\tflush_dcache_page(page);\n\tSetPageUptodate(page);\n\tunlock_page(page);\n\tntfs_unmap_page(page);\n\tif (likely(!err)) {\n\t\tntfs_debug(\"Done.\");\n\t} else {\n\t\tntfs_error(vol->sb, \"I/O error while writing mft mirror \"\n\t\t\t\t\"record 0x%lx!\", mft_no);\nerr_out:\n\t\tntfs_error(vol->sb, \"Failed to synchronize $MFTMirr (error \"\n\t\t\t\t\"code %i).  Volume will be left marked dirty \"\n\t\t\t\t\"on umount.  Run ntfsfix on the partition \"\n\t\t\t\t\"after umounting to correct this.\", -err);\n\t\tNVolSetErrors(vol);\n\t}\n\treturn err;\n}"
  },
  {
    "function_name": "ntfs_sync_mft_mirror_umount",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/mft.c",
    "lines": "438-445",
    "snippet": "static int ntfs_sync_mft_mirror_umount(ntfs_volume *vol,\n\t\tconst unsigned long mft_no, MFT_RECORD *m)\n{\n\tBUG_ON(vol->mftmirr_ino);\n\tntfs_error(vol->sb, \"Umount time mft mirror syncing is not \"\n\t\t\t\"implemented yet.  %s\", ntfs_please_email);\n\treturn -EOPNOTSUPP;\n}",
    "includes": [
      "#include \"ntfs.h\"",
      "#include \"mft.h\"",
      "#include \"malloc.h\"",
      "#include \"lcnalloc.h\"",
      "#include \"dir.h\"",
      "#include \"debug.h\"",
      "#include \"bitmap.h\"",
      "#include \"aops.h\"",
      "#include \"attrib.h\"",
      "#include <linux/swap.h>",
      "#include <linux/slab.h>",
      "#include <linux/buffer_head.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ntfs_error",
          "args": [
            "vol->sb",
            "\"Umount time mft mirror syncing is not \"\n\t\t\t\"implemented yet.  %s\"",
            "ntfs_please_email"
          ],
          "line": 442
        },
        "resolved": true,
        "details": {
          "function_name": "__ntfs_error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/debug.c",
          "lines": "86-108",
          "snippet": "void __ntfs_error(const char *function, const struct super_block *sb,\n\t\tconst char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\tint flen = 0;\n\n#ifndef DEBUG\n\tif (!printk_ratelimit())\n\t\treturn;\n#endif\n\tif (function)\n\t\tflen = strlen(function);\n\tva_start(args, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\tif (sb)\n\t\tpr_err(\"(device %s): %s(): %pV\\n\",\n\t\t       sb->s_id, flen ? function : \"\", &vaf);\n\telse\n\t\tpr_err(\"%s(): %pV\\n\", flen ? function : \"\", &vaf);\n\tva_end(args);\n}",
          "includes": [
            "#include \"debug.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"debug.h\"\n\nvoid __ntfs_error(const char *function, const struct super_block *sb,\n\t\tconst char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\tint flen = 0;\n\n#ifndef DEBUG\n\tif (!printk_ratelimit())\n\t\treturn;\n#endif\n\tif (function)\n\t\tflen = strlen(function);\n\tva_start(args, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\tif (sb)\n\t\tpr_err(\"(device %s): %s(): %pV\\n\",\n\t\t       sb->s_id, flen ? function : \"\", &vaf);\n\telse\n\t\tpr_err(\"%s(): %pV\\n\", flen ? function : \"\", &vaf);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "vol->mftmirr_ino"
          ],
          "line": 441
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ntfs.h\"\n#include \"mft.h\"\n#include \"malloc.h\"\n#include \"lcnalloc.h\"\n#include \"dir.h\"\n#include \"debug.h\"\n#include \"bitmap.h\"\n#include \"aops.h\"\n#include \"attrib.h\"\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n\nstatic int ntfs_sync_mft_mirror_umount(ntfs_volume *vol,\n\t\tconst unsigned long mft_no, MFT_RECORD *m)\n{\n\tBUG_ON(vol->mftmirr_ino);\n\tntfs_error(vol->sb, \"Umount time mft mirror syncing is not \"\n\t\t\t\"implemented yet.  %s\", ntfs_please_email);\n\treturn -EOPNOTSUPP;\n}"
  },
  {
    "function_name": "__mark_mft_record_dirty",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/mft.c",
    "lines": "395-410",
    "snippet": "void __mark_mft_record_dirty(ntfs_inode *ni)\n{\n\tntfs_inode *base_ni;\n\n\tntfs_debug(\"Entering for inode 0x%lx.\", ni->mft_no);\n\tBUG_ON(NInoAttr(ni));\n\tmark_ntfs_record_dirty(ni->page, ni->page_ofs);\n\t/* Determine the base vfs inode and mark it dirty, too. */\n\tmutex_lock(&ni->extent_lock);\n\tif (likely(ni->nr_extents >= 0))\n\t\tbase_ni = ni;\n\telse\n\t\tbase_ni = ni->ext.base_ntfs_ino;\n\tmutex_unlock(&ni->extent_lock);\n\t__mark_inode_dirty(VFS_I(base_ni), I_DIRTY_SYNC | I_DIRTY_DATASYNC);\n}",
    "includes": [
      "#include \"ntfs.h\"",
      "#include \"mft.h\"",
      "#include \"malloc.h\"",
      "#include \"lcnalloc.h\"",
      "#include \"dir.h\"",
      "#include \"debug.h\"",
      "#include \"bitmap.h\"",
      "#include \"aops.h\"",
      "#include \"attrib.h\"",
      "#include <linux/swap.h>",
      "#include <linux/slab.h>",
      "#include <linux/buffer_head.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__mark_inode_dirty",
          "args": [
            "VFS_I(base_ni)",
            "I_DIRTY_SYNC | I_DIRTY_DATASYNC"
          ],
          "line": 409
        },
        "resolved": true,
        "details": {
          "function_name": "__mark_inode_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fs-writeback.c",
          "lines": "1181-1285",
          "snippet": "void __mark_inode_dirty(struct inode *inode, int flags)\n{\n\tstruct super_block *sb = inode->i_sb;\n\tstruct backing_dev_info *bdi = NULL;\n\tint dirtytime;\n\n\ttrace_writeback_mark_inode_dirty(inode, flags);\n\n\t/*\n\t * Don't do this for I_DIRTY_PAGES - that doesn't actually\n\t * dirty the inode itself\n\t */\n\tif (flags & (I_DIRTY_SYNC | I_DIRTY_DATASYNC | I_DIRTY_TIME)) {\n\t\ttrace_writeback_dirty_inode_start(inode, flags);\n\n\t\tif (sb->s_op->dirty_inode)\n\t\t\tsb->s_op->dirty_inode(inode, flags);\n\n\t\ttrace_writeback_dirty_inode(inode, flags);\n\t}\n\tif (flags & I_DIRTY_INODE)\n\t\tflags &= ~I_DIRTY_TIME;\n\tdirtytime = flags & I_DIRTY_TIME;\n\n\t/*\n\t * Paired with smp_mb() in __writeback_single_inode() for the\n\t * following lockless i_state test.  See there for details.\n\t */\n\tsmp_mb();\n\n\tif (((inode->i_state & flags) == flags) ||\n\t    (dirtytime && (inode->i_state & I_DIRTY_INODE)))\n\t\treturn;\n\n\tif (unlikely(block_dump))\n\t\tblock_dump___mark_inode_dirty(inode);\n\n\tspin_lock(&inode->i_lock);\n\tif (dirtytime && (inode->i_state & I_DIRTY_INODE))\n\t\tgoto out_unlock_inode;\n\tif ((inode->i_state & flags) != flags) {\n\t\tconst int was_dirty = inode->i_state & I_DIRTY;\n\n\t\tif (flags & I_DIRTY_INODE)\n\t\t\tinode->i_state &= ~I_DIRTY_TIME;\n\t\tinode->i_state |= flags;\n\n\t\t/*\n\t\t * If the inode is being synced, just update its dirty state.\n\t\t * The unlocker will place the inode on the appropriate\n\t\t * superblock list, based upon its state.\n\t\t */\n\t\tif (inode->i_state & I_SYNC)\n\t\t\tgoto out_unlock_inode;\n\n\t\t/*\n\t\t * Only add valid (hashed) inodes to the superblock's\n\t\t * dirty list.  Add blockdev inodes as well.\n\t\t */\n\t\tif (!S_ISBLK(inode->i_mode)) {\n\t\t\tif (inode_unhashed(inode))\n\t\t\t\tgoto out_unlock_inode;\n\t\t}\n\t\tif (inode->i_state & I_FREEING)\n\t\t\tgoto out_unlock_inode;\n\n\t\t/*\n\t\t * If the inode was already on b_dirty/b_io/b_more_io, don't\n\t\t * reposition it (that would break b_dirty time-ordering).\n\t\t */\n\t\tif (!was_dirty) {\n\t\t\tbool wakeup_bdi = false;\n\t\t\tbdi = inode_to_bdi(inode);\n\n\t\t\tspin_unlock(&inode->i_lock);\n\t\t\tspin_lock(&bdi->wb.list_lock);\n\t\t\tif (bdi_cap_writeback_dirty(bdi)) {\n\t\t\t\tWARN(!test_bit(BDI_registered, &bdi->state),\n\t\t\t\t     \"bdi-%s not registered\\n\", bdi->name);\n\n\t\t\t\t/*\n\t\t\t\t * If this is the first dirty inode for this\n\t\t\t\t * bdi, we have to wake-up the corresponding\n\t\t\t\t * bdi thread to make sure background\n\t\t\t\t * write-back happens later.\n\t\t\t\t */\n\t\t\t\tif (!wb_has_dirty_io(&bdi->wb))\n\t\t\t\t\twakeup_bdi = true;\n\t\t\t}\n\n\t\t\tinode->dirtied_when = jiffies;\n\t\t\tlist_move(&inode->i_wb_list, dirtytime ?\n\t\t\t\t  &bdi->wb.b_dirty_time : &bdi->wb.b_dirty);\n\t\t\tspin_unlock(&bdi->wb.list_lock);\n\t\t\ttrace_writeback_dirty_inode_enqueue(inode);\n\n\t\t\tif (wakeup_bdi)\n\t\t\t\tbdi_wakeup_thread_delayed(bdi);\n\t\t\treturn;\n\t\t}\n\t}\nout_unlock_inode:\n\tspin_unlock(&inode->i_lock);\n\n}",
          "includes": [
            "#include <trace/events/writeback.h>",
            "#include \"internal.h\"",
            "#include <linux/device.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [
            "#define I_DIRTY_INODE (I_DIRTY_SYNC | I_DIRTY_DATASYNC)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/writeback.h>\n#include \"internal.h\"\n#include <linux/device.h>\n#include <linux/tracepoint.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\n#define I_DIRTY_INODE (I_DIRTY_SYNC | I_DIRTY_DATASYNC)\n\nvoid __mark_inode_dirty(struct inode *inode, int flags)\n{\n\tstruct super_block *sb = inode->i_sb;\n\tstruct backing_dev_info *bdi = NULL;\n\tint dirtytime;\n\n\ttrace_writeback_mark_inode_dirty(inode, flags);\n\n\t/*\n\t * Don't do this for I_DIRTY_PAGES - that doesn't actually\n\t * dirty the inode itself\n\t */\n\tif (flags & (I_DIRTY_SYNC | I_DIRTY_DATASYNC | I_DIRTY_TIME)) {\n\t\ttrace_writeback_dirty_inode_start(inode, flags);\n\n\t\tif (sb->s_op->dirty_inode)\n\t\t\tsb->s_op->dirty_inode(inode, flags);\n\n\t\ttrace_writeback_dirty_inode(inode, flags);\n\t}\n\tif (flags & I_DIRTY_INODE)\n\t\tflags &= ~I_DIRTY_TIME;\n\tdirtytime = flags & I_DIRTY_TIME;\n\n\t/*\n\t * Paired with smp_mb() in __writeback_single_inode() for the\n\t * following lockless i_state test.  See there for details.\n\t */\n\tsmp_mb();\n\n\tif (((inode->i_state & flags) == flags) ||\n\t    (dirtytime && (inode->i_state & I_DIRTY_INODE)))\n\t\treturn;\n\n\tif (unlikely(block_dump))\n\t\tblock_dump___mark_inode_dirty(inode);\n\n\tspin_lock(&inode->i_lock);\n\tif (dirtytime && (inode->i_state & I_DIRTY_INODE))\n\t\tgoto out_unlock_inode;\n\tif ((inode->i_state & flags) != flags) {\n\t\tconst int was_dirty = inode->i_state & I_DIRTY;\n\n\t\tif (flags & I_DIRTY_INODE)\n\t\t\tinode->i_state &= ~I_DIRTY_TIME;\n\t\tinode->i_state |= flags;\n\n\t\t/*\n\t\t * If the inode is being synced, just update its dirty state.\n\t\t * The unlocker will place the inode on the appropriate\n\t\t * superblock list, based upon its state.\n\t\t */\n\t\tif (inode->i_state & I_SYNC)\n\t\t\tgoto out_unlock_inode;\n\n\t\t/*\n\t\t * Only add valid (hashed) inodes to the superblock's\n\t\t * dirty list.  Add blockdev inodes as well.\n\t\t */\n\t\tif (!S_ISBLK(inode->i_mode)) {\n\t\t\tif (inode_unhashed(inode))\n\t\t\t\tgoto out_unlock_inode;\n\t\t}\n\t\tif (inode->i_state & I_FREEING)\n\t\t\tgoto out_unlock_inode;\n\n\t\t/*\n\t\t * If the inode was already on b_dirty/b_io/b_more_io, don't\n\t\t * reposition it (that would break b_dirty time-ordering).\n\t\t */\n\t\tif (!was_dirty) {\n\t\t\tbool wakeup_bdi = false;\n\t\t\tbdi = inode_to_bdi(inode);\n\n\t\t\tspin_unlock(&inode->i_lock);\n\t\t\tspin_lock(&bdi->wb.list_lock);\n\t\t\tif (bdi_cap_writeback_dirty(bdi)) {\n\t\t\t\tWARN(!test_bit(BDI_registered, &bdi->state),\n\t\t\t\t     \"bdi-%s not registered\\n\", bdi->name);\n\n\t\t\t\t/*\n\t\t\t\t * If this is the first dirty inode for this\n\t\t\t\t * bdi, we have to wake-up the corresponding\n\t\t\t\t * bdi thread to make sure background\n\t\t\t\t * write-back happens later.\n\t\t\t\t */\n\t\t\t\tif (!wb_has_dirty_io(&bdi->wb))\n\t\t\t\t\twakeup_bdi = true;\n\t\t\t}\n\n\t\t\tinode->dirtied_when = jiffies;\n\t\t\tlist_move(&inode->i_wb_list, dirtytime ?\n\t\t\t\t  &bdi->wb.b_dirty_time : &bdi->wb.b_dirty);\n\t\t\tspin_unlock(&bdi->wb.list_lock);\n\t\t\ttrace_writeback_dirty_inode_enqueue(inode);\n\n\t\t\tif (wakeup_bdi)\n\t\t\t\tbdi_wakeup_thread_delayed(bdi);\n\t\t\treturn;\n\t\t}\n\t}\nout_unlock_inode:\n\tspin_unlock(&inode->i_lock);\n\n}"
        }
      },
      {
        "call_info": {
          "callee": "VFS_I",
          "args": [
            "base_ni"
          ],
          "line": 409
        },
        "resolved": true,
        "details": {
          "function_name": "VFS_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/inode.h",
          "lines": "245-248",
          "snippet": "static inline struct inode *VFS_I(ntfs_inode *ni)\n{\n\treturn &((big_ntfs_inode *)ni)->vfs_inode;\n}",
          "includes": [
            "#include \"debug.h\"",
            "#include \"runlist.h\"",
            "#include \"types.h\"",
            "#include \"volume.h\"",
            "#include \"layout.h\"",
            "#include <linux/seq_file.h>",
            "#include <linux/mutex.h>",
            "#include <linux/mm.h>",
            "#include <linux/list.h>",
            "#include <linux/fs.h>",
            "#include <linux/atomic.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"debug.h\"\n#include \"runlist.h\"\n#include \"types.h\"\n#include \"volume.h\"\n#include \"layout.h\"\n#include <linux/seq_file.h>\n#include <linux/mutex.h>\n#include <linux/mm.h>\n#include <linux/list.h>\n#include <linux/fs.h>\n#include <linux/atomic.h>\n\nstatic inline struct inode *VFS_I(ntfs_inode *ni)\n{\n\treturn &((big_ntfs_inode *)ni)->vfs_inode;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&ni->extent_lock"
          ],
          "line": 408
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "likely",
          "args": [
            "ni->nr_extents >= 0"
          ],
          "line": 404
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&ni->extent_lock"
          ],
          "line": 403
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mark_ntfs_record_dirty",
          "args": [
            "ni->page",
            "ni->page_ofs"
          ],
          "line": 401
        },
        "resolved": true,
        "details": {
          "function_name": "mark_ntfs_record_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/aops.c",
          "lines": "1729-1775",
          "snippet": "void mark_ntfs_record_dirty(struct page *page, const unsigned int ofs) {\n\tstruct address_space *mapping = page->mapping;\n\tntfs_inode *ni = NTFS_I(mapping->host);\n\tstruct buffer_head *bh, *head, *buffers_to_free = NULL;\n\tunsigned int end, bh_size, bh_ofs;\n\n\tBUG_ON(!PageUptodate(page));\n\tend = ofs + ni->itype.index.block_size;\n\tbh_size = VFS_I(ni)->i_sb->s_blocksize;\n\tspin_lock(&mapping->private_lock);\n\tif (unlikely(!page_has_buffers(page))) {\n\t\tspin_unlock(&mapping->private_lock);\n\t\tbh = head = alloc_page_buffers(page, bh_size, 1);\n\t\tspin_lock(&mapping->private_lock);\n\t\tif (likely(!page_has_buffers(page))) {\n\t\t\tstruct buffer_head *tail;\n\n\t\t\tdo {\n\t\t\t\tset_buffer_uptodate(bh);\n\t\t\t\ttail = bh;\n\t\t\t\tbh = bh->b_this_page;\n\t\t\t} while (bh);\n\t\t\ttail->b_this_page = head;\n\t\t\tattach_page_buffers(page, head);\n\t\t} else\n\t\t\tbuffers_to_free = bh;\n\t}\n\tbh = head = page_buffers(page);\n\tBUG_ON(!bh);\n\tdo {\n\t\tbh_ofs = bh_offset(bh);\n\t\tif (bh_ofs + bh_size <= ofs)\n\t\t\tcontinue;\n\t\tif (unlikely(bh_ofs >= end))\n\t\t\tbreak;\n\t\tset_buffer_dirty(bh);\n\t} while ((bh = bh->b_this_page) != head);\n\tspin_unlock(&mapping->private_lock);\n\t__set_page_dirty_nobuffers(page);\n\tif (unlikely(buffers_to_free)) {\n\t\tdo {\n\t\t\tbh = buffers_to_free->b_this_page;\n\t\t\tfree_buffer_head(buffers_to_free);\n\t\t\tbuffers_to_free = bh;\n\t\t} while (buffers_to_free);\n\t}\n}",
          "includes": [
            "#include \"ntfs.h\"",
            "#include \"types.h\"",
            "#include \"runlist.h\"",
            "#include \"mft.h\"",
            "#include \"inode.h\"",
            "#include \"debug.h\"",
            "#include \"attrib.h\"",
            "#include \"aops.h\"",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/writeback.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/gfp.h>",
            "#include <linux/fs.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ntfs.h\"\n#include \"types.h\"\n#include \"runlist.h\"\n#include \"mft.h\"\n#include \"inode.h\"\n#include \"debug.h\"\n#include \"attrib.h\"\n#include \"aops.h\"\n#include <linux/bit_spinlock.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/gfp.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n\nvoid mark_ntfs_record_dirty(struct page *page, const unsigned int ofs) {\n\tstruct address_space *mapping = page->mapping;\n\tntfs_inode *ni = NTFS_I(mapping->host);\n\tstruct buffer_head *bh, *head, *buffers_to_free = NULL;\n\tunsigned int end, bh_size, bh_ofs;\n\n\tBUG_ON(!PageUptodate(page));\n\tend = ofs + ni->itype.index.block_size;\n\tbh_size = VFS_I(ni)->i_sb->s_blocksize;\n\tspin_lock(&mapping->private_lock);\n\tif (unlikely(!page_has_buffers(page))) {\n\t\tspin_unlock(&mapping->private_lock);\n\t\tbh = head = alloc_page_buffers(page, bh_size, 1);\n\t\tspin_lock(&mapping->private_lock);\n\t\tif (likely(!page_has_buffers(page))) {\n\t\t\tstruct buffer_head *tail;\n\n\t\t\tdo {\n\t\t\t\tset_buffer_uptodate(bh);\n\t\t\t\ttail = bh;\n\t\t\t\tbh = bh->b_this_page;\n\t\t\t} while (bh);\n\t\t\ttail->b_this_page = head;\n\t\t\tattach_page_buffers(page, head);\n\t\t} else\n\t\t\tbuffers_to_free = bh;\n\t}\n\tbh = head = page_buffers(page);\n\tBUG_ON(!bh);\n\tdo {\n\t\tbh_ofs = bh_offset(bh);\n\t\tif (bh_ofs + bh_size <= ofs)\n\t\t\tcontinue;\n\t\tif (unlikely(bh_ofs >= end))\n\t\t\tbreak;\n\t\tset_buffer_dirty(bh);\n\t} while ((bh = bh->b_this_page) != head);\n\tspin_unlock(&mapping->private_lock);\n\t__set_page_dirty_nobuffers(page);\n\tif (unlikely(buffers_to_free)) {\n\t\tdo {\n\t\t\tbh = buffers_to_free->b_this_page;\n\t\t\tfree_buffer_head(buffers_to_free);\n\t\t\tbuffers_to_free = bh;\n\t\t} while (buffers_to_free);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "NInoAttr(ni)"
          ],
          "line": 400
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NInoAttr",
          "args": [
            "ni"
          ],
          "line": 400
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntfs_debug",
          "args": [
            "\"Entering for inode 0x%lx.\"",
            "ni->mft_no"
          ],
          "line": 399
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ntfs.h\"\n#include \"mft.h\"\n#include \"malloc.h\"\n#include \"lcnalloc.h\"\n#include \"dir.h\"\n#include \"debug.h\"\n#include \"bitmap.h\"\n#include \"aops.h\"\n#include \"attrib.h\"\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n\nvoid __mark_mft_record_dirty(ntfs_inode *ni)\n{\n\tntfs_inode *base_ni;\n\n\tntfs_debug(\"Entering for inode 0x%lx.\", ni->mft_no);\n\tBUG_ON(NInoAttr(ni));\n\tmark_ntfs_record_dirty(ni->page, ni->page_ofs);\n\t/* Determine the base vfs inode and mark it dirty, too. */\n\tmutex_lock(&ni->extent_lock);\n\tif (likely(ni->nr_extents >= 0))\n\t\tbase_ni = ni;\n\telse\n\t\tbase_ni = ni->ext.base_ntfs_ino;\n\tmutex_unlock(&ni->extent_lock);\n\t__mark_inode_dirty(VFS_I(base_ni), I_DIRTY_SYNC | I_DIRTY_DATASYNC);\n}"
  },
  {
    "function_name": "map_extent_mft_record",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/mft.c",
    "lines": "246-368",
    "snippet": "MFT_RECORD *map_extent_mft_record(ntfs_inode *base_ni, MFT_REF mref,\n\t\tntfs_inode **ntfs_ino)\n{\n\tMFT_RECORD *m;\n\tntfs_inode *ni = NULL;\n\tntfs_inode **extent_nis = NULL;\n\tint i;\n\tunsigned long mft_no = MREF(mref);\n\tu16 seq_no = MSEQNO(mref);\n\tbool destroy_ni = false;\n\n\tntfs_debug(\"Mapping extent mft record 0x%lx (base mft record 0x%lx).\",\n\t\t\tmft_no, base_ni->mft_no);\n\t/* Make sure the base ntfs inode doesn't go away. */\n\tatomic_inc(&base_ni->count);\n\t/*\n\t * Check if this extent inode has already been added to the base inode,\n\t * in which case just return it. If not found, add it to the base\n\t * inode before returning it.\n\t */\n\tmutex_lock(&base_ni->extent_lock);\n\tif (base_ni->nr_extents > 0) {\n\t\textent_nis = base_ni->ext.extent_ntfs_inos;\n\t\tfor (i = 0; i < base_ni->nr_extents; i++) {\n\t\t\tif (mft_no != extent_nis[i]->mft_no)\n\t\t\t\tcontinue;\n\t\t\tni = extent_nis[i];\n\t\t\t/* Make sure the ntfs inode doesn't go away. */\n\t\t\tatomic_inc(&ni->count);\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (likely(ni != NULL)) {\n\t\tmutex_unlock(&base_ni->extent_lock);\n\t\tatomic_dec(&base_ni->count);\n\t\t/* We found the record; just have to map and return it. */\n\t\tm = map_mft_record(ni);\n\t\t/* map_mft_record() has incremented this on success. */\n\t\tatomic_dec(&ni->count);\n\t\tif (likely(!IS_ERR(m))) {\n\t\t\t/* Verify the sequence number. */\n\t\t\tif (likely(le16_to_cpu(m->sequence_number) == seq_no)) {\n\t\t\t\tntfs_debug(\"Done 1.\");\n\t\t\t\t*ntfs_ino = ni;\n\t\t\t\treturn m;\n\t\t\t}\n\t\t\tunmap_mft_record(ni);\n\t\t\tntfs_error(base_ni->vol->sb, \"Found stale extent mft \"\n\t\t\t\t\t\"reference! Corrupt filesystem. \"\n\t\t\t\t\t\"Run chkdsk.\");\n\t\t\treturn ERR_PTR(-EIO);\n\t\t}\nmap_err_out:\n\t\tntfs_error(base_ni->vol->sb, \"Failed to map extent \"\n\t\t\t\t\"mft record, error code %ld.\", -PTR_ERR(m));\n\t\treturn m;\n\t}\n\t/* Record wasn't there. Get a new ntfs inode and initialize it. */\n\tni = ntfs_new_extent_inode(base_ni->vol->sb, mft_no);\n\tif (unlikely(!ni)) {\n\t\tmutex_unlock(&base_ni->extent_lock);\n\t\tatomic_dec(&base_ni->count);\n\t\treturn ERR_PTR(-ENOMEM);\n\t}\n\tni->vol = base_ni->vol;\n\tni->seq_no = seq_no;\n\tni->nr_extents = -1;\n\tni->ext.base_ntfs_ino = base_ni;\n\t/* Now map the record. */\n\tm = map_mft_record(ni);\n\tif (IS_ERR(m)) {\n\t\tmutex_unlock(&base_ni->extent_lock);\n\t\tatomic_dec(&base_ni->count);\n\t\tntfs_clear_extent_inode(ni);\n\t\tgoto map_err_out;\n\t}\n\t/* Verify the sequence number if it is present. */\n\tif (seq_no && (le16_to_cpu(m->sequence_number) != seq_no)) {\n\t\tntfs_error(base_ni->vol->sb, \"Found stale extent mft \"\n\t\t\t\t\"reference! Corrupt filesystem. Run chkdsk.\");\n\t\tdestroy_ni = true;\n\t\tm = ERR_PTR(-EIO);\n\t\tgoto unm_err_out;\n\t}\n\t/* Attach extent inode to base inode, reallocating memory if needed. */\n\tif (!(base_ni->nr_extents & 3)) {\n\t\tntfs_inode **tmp;\n\t\tint new_size = (base_ni->nr_extents + 4) * sizeof(ntfs_inode *);\n\n\t\ttmp = kmalloc(new_size, GFP_NOFS);\n\t\tif (unlikely(!tmp)) {\n\t\t\tntfs_error(base_ni->vol->sb, \"Failed to allocate \"\n\t\t\t\t\t\"internal buffer.\");\n\t\t\tdestroy_ni = true;\n\t\t\tm = ERR_PTR(-ENOMEM);\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tif (base_ni->nr_extents) {\n\t\t\tBUG_ON(!base_ni->ext.extent_ntfs_inos);\n\t\t\tmemcpy(tmp, base_ni->ext.extent_ntfs_inos, new_size -\n\t\t\t\t\t4 * sizeof(ntfs_inode *));\n\t\t\tkfree(base_ni->ext.extent_ntfs_inos);\n\t\t}\n\t\tbase_ni->ext.extent_ntfs_inos = tmp;\n\t}\n\tbase_ni->ext.extent_ntfs_inos[base_ni->nr_extents++] = ni;\n\tmutex_unlock(&base_ni->extent_lock);\n\tatomic_dec(&base_ni->count);\n\tntfs_debug(\"Done 2.\");\n\t*ntfs_ino = ni;\n\treturn m;\nunm_err_out:\n\tunmap_mft_record(ni);\n\tmutex_unlock(&base_ni->extent_lock);\n\tatomic_dec(&base_ni->count);\n\t/*\n\t * If the extent inode was not attached to the base inode we need to\n\t * release it or we will leak memory.\n\t */\n\tif (destroy_ni)\n\t\tntfs_clear_extent_inode(ni);\n\treturn m;\n}",
    "includes": [
      "#include \"ntfs.h\"",
      "#include \"mft.h\"",
      "#include \"malloc.h\"",
      "#include \"lcnalloc.h\"",
      "#include \"dir.h\"",
      "#include \"debug.h\"",
      "#include \"bitmap.h\"",
      "#include \"aops.h\"",
      "#include \"attrib.h\"",
      "#include <linux/swap.h>",
      "#include <linux/slab.h>",
      "#include <linux/buffer_head.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ntfs_clear_extent_inode",
          "args": [
            "ni"
          ],
          "line": 366
        },
        "resolved": true,
        "details": {
          "function_name": "ntfs_clear_extent_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/inode.c",
          "lines": "2227-2247",
          "snippet": "void ntfs_clear_extent_inode(ntfs_inode *ni)\n{\n\tntfs_debug(\"Entering for inode 0x%lx.\", ni->mft_no);\n\n\tBUG_ON(NInoAttr(ni));\n\tBUG_ON(ni->nr_extents != -1);\n\n#ifdef NTFS_RW\n\tif (NInoDirty(ni)) {\n\t\tif (!is_bad_inode(VFS_I(ni->ext.base_ntfs_ino)))\n\t\t\tntfs_error(ni->vol->sb, \"Clearing dirty extent inode!  \"\n\t\t\t\t\t\"Losing data!  This is a BUG!!!\");\n\t\t// FIXME:  Do something!!!\n\t}\n#endif /* NTFS_RW */\n\n\t__ntfs_clear_inode(ni);\n\n\t/* Bye, bye... */\n\tntfs_destroy_extent_inode(ni);\n}",
          "includes": [
            "#include \"ntfs.h\"",
            "#include \"time.h\"",
            "#include \"mft.h\"",
            "#include \"malloc.h\"",
            "#include \"lcnalloc.h\"",
            "#include \"inode.h\"",
            "#include \"debug.h\"",
            "#include \"dir.h\"",
            "#include \"bitmap.h\"",
            "#include \"attrib.h\"",
            "#include \"aops.h\"",
            "#include <linux/aio.h>",
            "#include <linux/log2.h>",
            "#include <linux/slab.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mutex.h>",
            "#include <linux/mount.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ntfs.h\"\n#include \"time.h\"\n#include \"mft.h\"\n#include \"malloc.h\"\n#include \"lcnalloc.h\"\n#include \"inode.h\"\n#include \"debug.h\"\n#include \"dir.h\"\n#include \"bitmap.h\"\n#include \"attrib.h\"\n#include \"aops.h\"\n#include <linux/aio.h>\n#include <linux/log2.h>\n#include <linux/slab.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/mutex.h>\n#include <linux/mount.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/buffer_head.h>\n\nvoid ntfs_clear_extent_inode(ntfs_inode *ni)\n{\n\tntfs_debug(\"Entering for inode 0x%lx.\", ni->mft_no);\n\n\tBUG_ON(NInoAttr(ni));\n\tBUG_ON(ni->nr_extents != -1);\n\n#ifdef NTFS_RW\n\tif (NInoDirty(ni)) {\n\t\tif (!is_bad_inode(VFS_I(ni->ext.base_ntfs_ino)))\n\t\t\tntfs_error(ni->vol->sb, \"Clearing dirty extent inode!  \"\n\t\t\t\t\t\"Losing data!  This is a BUG!!!\");\n\t\t// FIXME:  Do something!!!\n\t}\n#endif /* NTFS_RW */\n\n\t__ntfs_clear_inode(ni);\n\n\t/* Bye, bye... */\n\tntfs_destroy_extent_inode(ni);\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_dec",
          "args": [
            "&base_ni->count"
          ],
          "line": 360
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&base_ni->extent_lock"
          ],
          "line": 359
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unmap_mft_record",
          "args": [
            "ni"
          ],
          "line": 358
        },
        "resolved": true,
        "details": {
          "function_name": "unmap_mft_record",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/mft.c",
          "lines": "213-231",
          "snippet": "void unmap_mft_record(ntfs_inode *ni)\n{\n\tstruct page *page = ni->page;\n\n\tBUG_ON(!page);\n\n\tntfs_debug(\"Entering for mft_no 0x%lx.\", ni->mft_no);\n\n\tunmap_mft_record_page(ni);\n\tmutex_unlock(&ni->mrec_lock);\n\tatomic_dec(&ni->count);\n\t/*\n\t * If pure ntfs_inode, i.e. no vfs inode attached, we leave it to\n\t * ntfs_clear_extent_inode() in the extent inode case, and to the\n\t * caller in the non-extent, yet pure ntfs inode case, to do the actual\n\t * tear down of all structures and freeing of all allocated memory.\n\t */\n\treturn;\n}",
          "includes": [
            "#include \"ntfs.h\"",
            "#include \"mft.h\"",
            "#include \"malloc.h\"",
            "#include \"lcnalloc.h\"",
            "#include \"dir.h\"",
            "#include \"debug.h\"",
            "#include \"bitmap.h\"",
            "#include \"aops.h\"",
            "#include \"attrib.h\"",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ntfs.h\"\n#include \"mft.h\"\n#include \"malloc.h\"\n#include \"lcnalloc.h\"\n#include \"dir.h\"\n#include \"debug.h\"\n#include \"bitmap.h\"\n#include \"aops.h\"\n#include \"attrib.h\"\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n\nvoid unmap_mft_record(ntfs_inode *ni)\n{\n\tstruct page *page = ni->page;\n\n\tBUG_ON(!page);\n\n\tntfs_debug(\"Entering for mft_no 0x%lx.\", ni->mft_no);\n\n\tunmap_mft_record_page(ni);\n\tmutex_unlock(&ni->mrec_lock);\n\tatomic_dec(&ni->count);\n\t/*\n\t * If pure ntfs_inode, i.e. no vfs inode attached, we leave it to\n\t * ntfs_clear_extent_inode() in the extent inode case, and to the\n\t * caller in the non-extent, yet pure ntfs inode case, to do the actual\n\t * tear down of all structures and freeing of all allocated memory.\n\t */\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ntfs_debug",
          "args": [
            "\"Done 2.\""
          ],
          "line": 354
        },
        "resolved": true,
        "details": {
          "function_name": "ntfs_debug_dump_runlist",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/debug.c",
          "lines": "134-171",
          "snippet": "void ntfs_debug_dump_runlist(const runlist_element *rl)\n{\n\tint i;\n\tconst char *lcn_str[5] = { \"LCN_HOLE         \", \"LCN_RL_NOT_MAPPED\",\n\t\t\t\t   \"LCN_ENOENT       \", \"LCN_unknown      \" };\n\n\tif (!debug_msgs)\n\t\treturn;\n\tpr_debug(\"Dumping runlist (values in hex):\\n\");\n\tif (!rl) {\n\t\tpr_debug(\"Run list not present.\\n\");\n\t\treturn;\n\t}\n\tpr_debug(\"VCN              LCN               Run length\\n\");\n\tfor (i = 0; ; i++) {\n\t\tLCN lcn = (rl + i)->lcn;\n\n\t\tif (lcn < (LCN)0) {\n\t\t\tint index = -lcn - 1;\n\n\t\t\tif (index > -LCN_ENOENT - 1)\n\t\t\t\tindex = 3;\n\t\t\tpr_debug(\"%-16Lx %s %-16Lx%s\\n\",\n\t\t\t\t\t(long long)(rl + i)->vcn, lcn_str[index],\n\t\t\t\t\t(long long)(rl + i)->length,\n\t\t\t\t\t(rl + i)->length ? \"\" :\n\t\t\t\t\t\t\" (runlist end)\");\n\t\t} else\n\t\t\tpr_debug(\"%-16Lx %-16Lx  %-16Lx%s\\n\",\n\t\t\t\t\t(long long)(rl + i)->vcn,\n\t\t\t\t\t(long long)(rl + i)->lcn,\n\t\t\t\t\t(long long)(rl + i)->length,\n\t\t\t\t\t(rl + i)->length ? \"\" :\n\t\t\t\t\t\t\" (runlist end)\");\n\t\tif (!(rl + i)->length)\n\t\t\tbreak;\n\t}\n}",
          "includes": [
            "#include \"debug.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"debug.h\"\n\nvoid ntfs_debug_dump_runlist(const runlist_element *rl)\n{\n\tint i;\n\tconst char *lcn_str[5] = { \"LCN_HOLE         \", \"LCN_RL_NOT_MAPPED\",\n\t\t\t\t   \"LCN_ENOENT       \", \"LCN_unknown      \" };\n\n\tif (!debug_msgs)\n\t\treturn;\n\tpr_debug(\"Dumping runlist (values in hex):\\n\");\n\tif (!rl) {\n\t\tpr_debug(\"Run list not present.\\n\");\n\t\treturn;\n\t}\n\tpr_debug(\"VCN              LCN               Run length\\n\");\n\tfor (i = 0; ; i++) {\n\t\tLCN lcn = (rl + i)->lcn;\n\n\t\tif (lcn < (LCN)0) {\n\t\t\tint index = -lcn - 1;\n\n\t\t\tif (index > -LCN_ENOENT - 1)\n\t\t\t\tindex = 3;\n\t\t\tpr_debug(\"%-16Lx %s %-16Lx%s\\n\",\n\t\t\t\t\t(long long)(rl + i)->vcn, lcn_str[index],\n\t\t\t\t\t(long long)(rl + i)->length,\n\t\t\t\t\t(rl + i)->length ? \"\" :\n\t\t\t\t\t\t\" (runlist end)\");\n\t\t} else\n\t\t\tpr_debug(\"%-16Lx %-16Lx  %-16Lx%s\\n\",\n\t\t\t\t\t(long long)(rl + i)->vcn,\n\t\t\t\t\t(long long)(rl + i)->lcn,\n\t\t\t\t\t(long long)(rl + i)->length,\n\t\t\t\t\t(rl + i)->length ? \"\" :\n\t\t\t\t\t\t\" (runlist end)\");\n\t\tif (!(rl + i)->length)\n\t\t\tbreak;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_dec",
          "args": [
            "&base_ni->count"
          ],
          "line": 353
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&base_ni->extent_lock"
          ],
          "line": 352
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "base_ni->ext.extent_ntfs_inos"
          ],
          "line": 347
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "tmp",
            "base_ni->ext.extent_ntfs_inos",
            "new_size -\n\t\t\t\t\t4 * sizeof(ntfs_inode *)"
          ],
          "line": 345
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!base_ni->ext.extent_ntfs_inos"
          ],
          "line": 344
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-ENOMEM"
          ],
          "line": 340
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntfs_error",
          "args": [
            "base_ni->vol->sb",
            "\"Failed to allocate \"\n\t\t\t\t\t\"internal buffer.\""
          ],
          "line": 337
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!tmp"
          ],
          "line": 336
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmalloc",
          "args": [
            "new_size",
            "GFP_NOFS"
          ],
          "line": 335
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_dx_dir_kmalloc_leaves",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
          "lines": "2534-2546",
          "snippet": "static struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-EIO"
          ],
          "line": 327
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntfs_error",
          "args": [
            "base_ni->vol->sb",
            "\"Found stale extent mft \"\n\t\t\t\t\"reference! Corrupt filesystem. Run chkdsk.\""
          ],
          "line": 324
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le16_to_cpu",
          "args": [
            "m->sequence_number"
          ],
          "line": 323
        },
        "resolved": true,
        "details": {
          "function_name": "sle16_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "48-51",
          "snippet": "static inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_dec",
          "args": [
            "&base_ni->count"
          ],
          "line": 318
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&base_ni->extent_lock"
          ],
          "line": 317
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "m"
          ],
          "line": 316
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-ENOMEM"
          ],
          "line": 308
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_dec",
          "args": [
            "&base_ni->count"
          ],
          "line": 307
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&base_ni->extent_lock"
          ],
          "line": 306
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!ni"
          ],
          "line": 305
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntfs_new_extent_inode",
          "args": [
            "base_ni->vol->sb",
            "mft_no"
          ],
          "line": 304
        },
        "resolved": true,
        "details": {
          "function_name": "ntfs_new_extent_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/inode.c",
          "lines": "428-443",
          "snippet": "inline ntfs_inode *ntfs_new_extent_inode(struct super_block *sb,\n\t\tunsigned long mft_no)\n{\n\tntfs_inode *ni = ntfs_alloc_extent_inode();\n\n\tntfs_debug(\"Entering.\");\n\tif (likely(ni != NULL)) {\n\t\t__ntfs_init_inode(sb, ni);\n\t\tlockdep_set_class(&ni->mrec_lock, &extent_inode_mrec_lock_key);\n\t\tni->mft_no = mft_no;\n\t\tni->type = AT_UNUSED;\n\t\tni->name = NULL;\n\t\tni->name_len = 0;\n\t}\n\treturn ni;\n}",
          "includes": [
            "#include \"ntfs.h\"",
            "#include \"time.h\"",
            "#include \"mft.h\"",
            "#include \"malloc.h\"",
            "#include \"lcnalloc.h\"",
            "#include \"inode.h\"",
            "#include \"debug.h\"",
            "#include \"dir.h\"",
            "#include \"bitmap.h\"",
            "#include \"attrib.h\"",
            "#include \"aops.h\"",
            "#include <linux/aio.h>",
            "#include <linux/log2.h>",
            "#include <linux/slab.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mutex.h>",
            "#include <linux/mount.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct lock_class_key extent_inode_mrec_lock_key;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ntfs.h\"\n#include \"time.h\"\n#include \"mft.h\"\n#include \"malloc.h\"\n#include \"lcnalloc.h\"\n#include \"inode.h\"\n#include \"debug.h\"\n#include \"dir.h\"\n#include \"bitmap.h\"\n#include \"attrib.h\"\n#include \"aops.h\"\n#include <linux/aio.h>\n#include <linux/log2.h>\n#include <linux/slab.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/mutex.h>\n#include <linux/mount.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/buffer_head.h>\n\nstatic struct lock_class_key extent_inode_mrec_lock_key;\n\ninline ntfs_inode *ntfs_new_extent_inode(struct super_block *sb,\n\t\tunsigned long mft_no)\n{\n\tntfs_inode *ni = ntfs_alloc_extent_inode();\n\n\tntfs_debug(\"Entering.\");\n\tif (likely(ni != NULL)) {\n\t\t__ntfs_init_inode(sb, ni);\n\t\tlockdep_set_class(&ni->mrec_lock, &extent_inode_mrec_lock_key);\n\t\tni->mft_no = mft_no;\n\t\tni->type = AT_UNUSED;\n\t\tni->name = NULL;\n\t\tni->name_len = 0;\n\t}\n\treturn ni;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ntfs_error",
          "args": [
            "base_ni->vol->sb",
            "\"Failed to map extent \"\n\t\t\t\t\"mft record, error code %ld.\"",
            "-PTR_ERR(m)"
          ],
          "line": 299
        },
        "resolved": true,
        "details": {
          "function_name": "__ntfs_error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/debug.c",
          "lines": "86-108",
          "snippet": "void __ntfs_error(const char *function, const struct super_block *sb,\n\t\tconst char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\tint flen = 0;\n\n#ifndef DEBUG\n\tif (!printk_ratelimit())\n\t\treturn;\n#endif\n\tif (function)\n\t\tflen = strlen(function);\n\tva_start(args, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\tif (sb)\n\t\tpr_err(\"(device %s): %s(): %pV\\n\",\n\t\t       sb->s_id, flen ? function : \"\", &vaf);\n\telse\n\t\tpr_err(\"%s(): %pV\\n\", flen ? function : \"\", &vaf);\n\tva_end(args);\n}",
          "includes": [
            "#include \"debug.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"debug.h\"\n\nvoid __ntfs_error(const char *function, const struct super_block *sb,\n\t\tconst char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\tint flen = 0;\n\n#ifndef DEBUG\n\tif (!printk_ratelimit())\n\t\treturn;\n#endif\n\tif (function)\n\t\tflen = strlen(function);\n\tva_start(args, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\tif (sb)\n\t\tpr_err(\"(device %s): %s(): %pV\\n\",\n\t\t       sb->s_id, flen ? function : \"\", &vaf);\n\telse\n\t\tpr_err(\"%s(): %pV\\n\", flen ? function : \"\", &vaf);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "m"
          ],
          "line": 300
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-EIO"
          ],
          "line": 296
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntfs_error",
          "args": [
            "base_ni->vol->sb",
            "\"Found stale extent mft \"\n\t\t\t\t\t\"reference! Corrupt filesystem. \"\n\t\t\t\t\t\"Run chkdsk.\""
          ],
          "line": 293
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "likely",
          "args": [
            "le16_to_cpu(m->sequence_number) == seq_no"
          ],
          "line": 287
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "likely",
          "args": [
            "!IS_ERR(m)"
          ],
          "line": 285
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "m"
          ],
          "line": 285
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_dec",
          "args": [
            "&ni->count"
          ],
          "line": 284
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_dec",
          "args": [
            "&base_ni->count"
          ],
          "line": 280
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&base_ni->extent_lock"
          ],
          "line": 279
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "likely",
          "args": [
            "ni != NULL"
          ],
          "line": 278
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_inc",
          "args": [
            "&ni->count"
          ],
          "line": 274
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&base_ni->extent_lock"
          ],
          "line": 266
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_inc",
          "args": [
            "&base_ni->count"
          ],
          "line": 260
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntfs_debug",
          "args": [
            "\"Mapping extent mft record 0x%lx (base mft record 0x%lx).\"",
            "mft_no",
            "base_ni->mft_no"
          ],
          "line": 257
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MSEQNO",
          "args": [
            "mref"
          ],
          "line": 254
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MREF",
          "args": [
            "mref"
          ],
          "line": 253
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ntfs.h\"\n#include \"mft.h\"\n#include \"malloc.h\"\n#include \"lcnalloc.h\"\n#include \"dir.h\"\n#include \"debug.h\"\n#include \"bitmap.h\"\n#include \"aops.h\"\n#include \"attrib.h\"\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n\nMFT_RECORD *map_extent_mft_record(ntfs_inode *base_ni, MFT_REF mref,\n\t\tntfs_inode **ntfs_ino)\n{\n\tMFT_RECORD *m;\n\tntfs_inode *ni = NULL;\n\tntfs_inode **extent_nis = NULL;\n\tint i;\n\tunsigned long mft_no = MREF(mref);\n\tu16 seq_no = MSEQNO(mref);\n\tbool destroy_ni = false;\n\n\tntfs_debug(\"Mapping extent mft record 0x%lx (base mft record 0x%lx).\",\n\t\t\tmft_no, base_ni->mft_no);\n\t/* Make sure the base ntfs inode doesn't go away. */\n\tatomic_inc(&base_ni->count);\n\t/*\n\t * Check if this extent inode has already been added to the base inode,\n\t * in which case just return it. If not found, add it to the base\n\t * inode before returning it.\n\t */\n\tmutex_lock(&base_ni->extent_lock);\n\tif (base_ni->nr_extents > 0) {\n\t\textent_nis = base_ni->ext.extent_ntfs_inos;\n\t\tfor (i = 0; i < base_ni->nr_extents; i++) {\n\t\t\tif (mft_no != extent_nis[i]->mft_no)\n\t\t\t\tcontinue;\n\t\t\tni = extent_nis[i];\n\t\t\t/* Make sure the ntfs inode doesn't go away. */\n\t\t\tatomic_inc(&ni->count);\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (likely(ni != NULL)) {\n\t\tmutex_unlock(&base_ni->extent_lock);\n\t\tatomic_dec(&base_ni->count);\n\t\t/* We found the record; just have to map and return it. */\n\t\tm = map_mft_record(ni);\n\t\t/* map_mft_record() has incremented this on success. */\n\t\tatomic_dec(&ni->count);\n\t\tif (likely(!IS_ERR(m))) {\n\t\t\t/* Verify the sequence number. */\n\t\t\tif (likely(le16_to_cpu(m->sequence_number) == seq_no)) {\n\t\t\t\tntfs_debug(\"Done 1.\");\n\t\t\t\t*ntfs_ino = ni;\n\t\t\t\treturn m;\n\t\t\t}\n\t\t\tunmap_mft_record(ni);\n\t\t\tntfs_error(base_ni->vol->sb, \"Found stale extent mft \"\n\t\t\t\t\t\"reference! Corrupt filesystem. \"\n\t\t\t\t\t\"Run chkdsk.\");\n\t\t\treturn ERR_PTR(-EIO);\n\t\t}\nmap_err_out:\n\t\tntfs_error(base_ni->vol->sb, \"Failed to map extent \"\n\t\t\t\t\"mft record, error code %ld.\", -PTR_ERR(m));\n\t\treturn m;\n\t}\n\t/* Record wasn't there. Get a new ntfs inode and initialize it. */\n\tni = ntfs_new_extent_inode(base_ni->vol->sb, mft_no);\n\tif (unlikely(!ni)) {\n\t\tmutex_unlock(&base_ni->extent_lock);\n\t\tatomic_dec(&base_ni->count);\n\t\treturn ERR_PTR(-ENOMEM);\n\t}\n\tni->vol = base_ni->vol;\n\tni->seq_no = seq_no;\n\tni->nr_extents = -1;\n\tni->ext.base_ntfs_ino = base_ni;\n\t/* Now map the record. */\n\tm = map_mft_record(ni);\n\tif (IS_ERR(m)) {\n\t\tmutex_unlock(&base_ni->extent_lock);\n\t\tatomic_dec(&base_ni->count);\n\t\tntfs_clear_extent_inode(ni);\n\t\tgoto map_err_out;\n\t}\n\t/* Verify the sequence number if it is present. */\n\tif (seq_no && (le16_to_cpu(m->sequence_number) != seq_no)) {\n\t\tntfs_error(base_ni->vol->sb, \"Found stale extent mft \"\n\t\t\t\t\"reference! Corrupt filesystem. Run chkdsk.\");\n\t\tdestroy_ni = true;\n\t\tm = ERR_PTR(-EIO);\n\t\tgoto unm_err_out;\n\t}\n\t/* Attach extent inode to base inode, reallocating memory if needed. */\n\tif (!(base_ni->nr_extents & 3)) {\n\t\tntfs_inode **tmp;\n\t\tint new_size = (base_ni->nr_extents + 4) * sizeof(ntfs_inode *);\n\n\t\ttmp = kmalloc(new_size, GFP_NOFS);\n\t\tif (unlikely(!tmp)) {\n\t\t\tntfs_error(base_ni->vol->sb, \"Failed to allocate \"\n\t\t\t\t\t\"internal buffer.\");\n\t\t\tdestroy_ni = true;\n\t\t\tm = ERR_PTR(-ENOMEM);\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tif (base_ni->nr_extents) {\n\t\t\tBUG_ON(!base_ni->ext.extent_ntfs_inos);\n\t\t\tmemcpy(tmp, base_ni->ext.extent_ntfs_inos, new_size -\n\t\t\t\t\t4 * sizeof(ntfs_inode *));\n\t\t\tkfree(base_ni->ext.extent_ntfs_inos);\n\t\t}\n\t\tbase_ni->ext.extent_ntfs_inos = tmp;\n\t}\n\tbase_ni->ext.extent_ntfs_inos[base_ni->nr_extents++] = ni;\n\tmutex_unlock(&base_ni->extent_lock);\n\tatomic_dec(&base_ni->count);\n\tntfs_debug(\"Done 2.\");\n\t*ntfs_ino = ni;\n\treturn m;\nunm_err_out:\n\tunmap_mft_record(ni);\n\tmutex_unlock(&base_ni->extent_lock);\n\tatomic_dec(&base_ni->count);\n\t/*\n\t * If the extent inode was not attached to the base inode we need to\n\t * release it or we will leak memory.\n\t */\n\tif (destroy_ni)\n\t\tntfs_clear_extent_inode(ni);\n\treturn m;\n}"
  },
  {
    "function_name": "unmap_mft_record",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/mft.c",
    "lines": "213-231",
    "snippet": "void unmap_mft_record(ntfs_inode *ni)\n{\n\tstruct page *page = ni->page;\n\n\tBUG_ON(!page);\n\n\tntfs_debug(\"Entering for mft_no 0x%lx.\", ni->mft_no);\n\n\tunmap_mft_record_page(ni);\n\tmutex_unlock(&ni->mrec_lock);\n\tatomic_dec(&ni->count);\n\t/*\n\t * If pure ntfs_inode, i.e. no vfs inode attached, we leave it to\n\t * ntfs_clear_extent_inode() in the extent inode case, and to the\n\t * caller in the non-extent, yet pure ntfs inode case, to do the actual\n\t * tear down of all structures and freeing of all allocated memory.\n\t */\n\treturn;\n}",
    "includes": [
      "#include \"ntfs.h\"",
      "#include \"mft.h\"",
      "#include \"malloc.h\"",
      "#include \"lcnalloc.h\"",
      "#include \"dir.h\"",
      "#include \"debug.h\"",
      "#include \"bitmap.h\"",
      "#include \"aops.h\"",
      "#include \"attrib.h\"",
      "#include <linux/swap.h>",
      "#include <linux/slab.h>",
      "#include <linux/buffer_head.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "atomic_dec",
          "args": [
            "&ni->count"
          ],
          "line": 223
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&ni->mrec_lock"
          ],
          "line": 222
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unmap_mft_record_page",
          "args": [
            "ni"
          ],
          "line": 221
        },
        "resolved": true,
        "details": {
          "function_name": "unmap_mft_record_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/mft.c",
          "lines": "191-200",
          "snippet": "static inline void unmap_mft_record_page(ntfs_inode *ni)\n{\n\tBUG_ON(!ni->page);\n\n\t// TODO: If dirty, blah...\n\tntfs_unmap_page(ni->page);\n\tni->page = NULL;\n\tni->page_ofs = 0;\n\treturn;\n}",
          "includes": [
            "#include \"ntfs.h\"",
            "#include \"mft.h\"",
            "#include \"malloc.h\"",
            "#include \"lcnalloc.h\"",
            "#include \"dir.h\"",
            "#include \"debug.h\"",
            "#include \"bitmap.h\"",
            "#include \"aops.h\"",
            "#include \"attrib.h\"",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ntfs.h\"\n#include \"mft.h\"\n#include \"malloc.h\"\n#include \"lcnalloc.h\"\n#include \"dir.h\"\n#include \"debug.h\"\n#include \"bitmap.h\"\n#include \"aops.h\"\n#include \"attrib.h\"\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n\nstatic inline void unmap_mft_record_page(ntfs_inode *ni)\n{\n\tBUG_ON(!ni->page);\n\n\t// TODO: If dirty, blah...\n\tntfs_unmap_page(ni->page);\n\tni->page = NULL;\n\tni->page_ofs = 0;\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ntfs_debug",
          "args": [
            "\"Entering for mft_no 0x%lx.\"",
            "ni->mft_no"
          ],
          "line": 219
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!page"
          ],
          "line": 217
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ntfs.h\"\n#include \"mft.h\"\n#include \"malloc.h\"\n#include \"lcnalloc.h\"\n#include \"dir.h\"\n#include \"debug.h\"\n#include \"bitmap.h\"\n#include \"aops.h\"\n#include \"attrib.h\"\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n\nvoid unmap_mft_record(ntfs_inode *ni)\n{\n\tstruct page *page = ni->page;\n\n\tBUG_ON(!page);\n\n\tntfs_debug(\"Entering for mft_no 0x%lx.\", ni->mft_no);\n\n\tunmap_mft_record_page(ni);\n\tmutex_unlock(&ni->mrec_lock);\n\tatomic_dec(&ni->count);\n\t/*\n\t * If pure ntfs_inode, i.e. no vfs inode attached, we leave it to\n\t * ntfs_clear_extent_inode() in the extent inode case, and to the\n\t * caller in the non-extent, yet pure ntfs inode case, to do the actual\n\t * tear down of all structures and freeing of all allocated memory.\n\t */\n\treturn;\n}"
  },
  {
    "function_name": "unmap_mft_record_page",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/mft.c",
    "lines": "191-200",
    "snippet": "static inline void unmap_mft_record_page(ntfs_inode *ni)\n{\n\tBUG_ON(!ni->page);\n\n\t// TODO: If dirty, blah...\n\tntfs_unmap_page(ni->page);\n\tni->page = NULL;\n\tni->page_ofs = 0;\n\treturn;\n}",
    "includes": [
      "#include \"ntfs.h\"",
      "#include \"mft.h\"",
      "#include \"malloc.h\"",
      "#include \"lcnalloc.h\"",
      "#include \"dir.h\"",
      "#include \"debug.h\"",
      "#include \"bitmap.h\"",
      "#include \"aops.h\"",
      "#include \"attrib.h\"",
      "#include <linux/swap.h>",
      "#include <linux/slab.h>",
      "#include <linux/buffer_head.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ntfs_unmap_page",
          "args": [
            "ni->page"
          ],
          "line": 196
        },
        "resolved": true,
        "details": {
          "function_name": "ntfs_unmap_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/aops.h",
          "lines": "40-44",
          "snippet": "static inline void ntfs_unmap_page(struct page *page)\n{\n\tkunmap(page);\n\tpage_cache_release(page);\n}",
          "includes": [
            "#include \"inode.h\"",
            "#include <linux/fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"inode.h\"\n#include <linux/fs.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n\nstatic inline void ntfs_unmap_page(struct page *page)\n{\n\tkunmap(page);\n\tpage_cache_release(page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!ni->page"
          ],
          "line": 193
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ntfs.h\"\n#include \"mft.h\"\n#include \"malloc.h\"\n#include \"lcnalloc.h\"\n#include \"dir.h\"\n#include \"debug.h\"\n#include \"bitmap.h\"\n#include \"aops.h\"\n#include \"attrib.h\"\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n\nstatic inline void unmap_mft_record_page(ntfs_inode *ni)\n{\n\tBUG_ON(!ni->page);\n\n\t// TODO: If dirty, blah...\n\tntfs_unmap_page(ni->page);\n\tni->page = NULL;\n\tni->page_ofs = 0;\n\treturn;\n}"
  },
  {
    "function_name": "map_mft_record",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/mft.c",
    "lines": "155-175",
    "snippet": "MFT_RECORD *map_mft_record(ntfs_inode *ni)\n{\n\tMFT_RECORD *m;\n\n\tntfs_debug(\"Entering for mft_no 0x%lx.\", ni->mft_no);\n\n\t/* Make sure the ntfs inode doesn't go away. */\n\tatomic_inc(&ni->count);\n\n\t/* Serialize access to this mft record. */\n\tmutex_lock(&ni->mrec_lock);\n\n\tm = map_mft_record_page(ni);\n\tif (likely(!IS_ERR(m)))\n\t\treturn m;\n\n\tmutex_unlock(&ni->mrec_lock);\n\tatomic_dec(&ni->count);\n\tntfs_error(ni->vol->sb, \"Failed with error code %lu.\", -PTR_ERR(m));\n\treturn m;\n}",
    "includes": [
      "#include \"ntfs.h\"",
      "#include \"mft.h\"",
      "#include \"malloc.h\"",
      "#include \"lcnalloc.h\"",
      "#include \"dir.h\"",
      "#include \"debug.h\"",
      "#include \"bitmap.h\"",
      "#include \"aops.h\"",
      "#include \"attrib.h\"",
      "#include <linux/swap.h>",
      "#include <linux/slab.h>",
      "#include <linux/buffer_head.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ntfs_error",
          "args": [
            "ni->vol->sb",
            "\"Failed with error code %lu.\"",
            "-PTR_ERR(m)"
          ],
          "line": 173
        },
        "resolved": true,
        "details": {
          "function_name": "__ntfs_error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/debug.c",
          "lines": "86-108",
          "snippet": "void __ntfs_error(const char *function, const struct super_block *sb,\n\t\tconst char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\tint flen = 0;\n\n#ifndef DEBUG\n\tif (!printk_ratelimit())\n\t\treturn;\n#endif\n\tif (function)\n\t\tflen = strlen(function);\n\tva_start(args, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\tif (sb)\n\t\tpr_err(\"(device %s): %s(): %pV\\n\",\n\t\t       sb->s_id, flen ? function : \"\", &vaf);\n\telse\n\t\tpr_err(\"%s(): %pV\\n\", flen ? function : \"\", &vaf);\n\tva_end(args);\n}",
          "includes": [
            "#include \"debug.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"debug.h\"\n\nvoid __ntfs_error(const char *function, const struct super_block *sb,\n\t\tconst char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\tint flen = 0;\n\n#ifndef DEBUG\n\tif (!printk_ratelimit())\n\t\treturn;\n#endif\n\tif (function)\n\t\tflen = strlen(function);\n\tva_start(args, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\tif (sb)\n\t\tpr_err(\"(device %s): %s(): %pV\\n\",\n\t\t       sb->s_id, flen ? function : \"\", &vaf);\n\telse\n\t\tpr_err(\"%s(): %pV\\n\", flen ? function : \"\", &vaf);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "m"
          ],
          "line": 173
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_dec",
          "args": [
            "&ni->count"
          ],
          "line": 172
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&ni->mrec_lock"
          ],
          "line": 171
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "likely",
          "args": [
            "!IS_ERR(m)"
          ],
          "line": 168
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "m"
          ],
          "line": 168
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "map_mft_record_page",
          "args": [
            "ni"
          ],
          "line": 167
        },
        "resolved": true,
        "details": {
          "function_name": "unmap_mft_record_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/mft.c",
          "lines": "191-200",
          "snippet": "static inline void unmap_mft_record_page(ntfs_inode *ni)\n{\n\tBUG_ON(!ni->page);\n\n\t// TODO: If dirty, blah...\n\tntfs_unmap_page(ni->page);\n\tni->page = NULL;\n\tni->page_ofs = 0;\n\treturn;\n}",
          "includes": [
            "#include \"ntfs.h\"",
            "#include \"mft.h\"",
            "#include \"malloc.h\"",
            "#include \"lcnalloc.h\"",
            "#include \"dir.h\"",
            "#include \"debug.h\"",
            "#include \"bitmap.h\"",
            "#include \"aops.h\"",
            "#include \"attrib.h\"",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ntfs.h\"\n#include \"mft.h\"\n#include \"malloc.h\"\n#include \"lcnalloc.h\"\n#include \"dir.h\"\n#include \"debug.h\"\n#include \"bitmap.h\"\n#include \"aops.h\"\n#include \"attrib.h\"\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n\nstatic inline void unmap_mft_record_page(ntfs_inode *ni)\n{\n\tBUG_ON(!ni->page);\n\n\t// TODO: If dirty, blah...\n\tntfs_unmap_page(ni->page);\n\tni->page = NULL;\n\tni->page_ofs = 0;\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&ni->mrec_lock"
          ],
          "line": 165
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_inc",
          "args": [
            "&ni->count"
          ],
          "line": 162
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntfs_debug",
          "args": [
            "\"Entering for mft_no 0x%lx.\"",
            "ni->mft_no"
          ],
          "line": 159
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ntfs.h\"\n#include \"mft.h\"\n#include \"malloc.h\"\n#include \"lcnalloc.h\"\n#include \"dir.h\"\n#include \"debug.h\"\n#include \"bitmap.h\"\n#include \"aops.h\"\n#include \"attrib.h\"\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n\nMFT_RECORD *map_mft_record(ntfs_inode *ni)\n{\n\tMFT_RECORD *m;\n\n\tntfs_debug(\"Entering for mft_no 0x%lx.\", ni->mft_no);\n\n\t/* Make sure the ntfs inode doesn't go away. */\n\tatomic_inc(&ni->count);\n\n\t/* Serialize access to this mft record. */\n\tmutex_lock(&ni->mrec_lock);\n\n\tm = map_mft_record_page(ni);\n\tif (likely(!IS_ERR(m)))\n\t\treturn m;\n\n\tmutex_unlock(&ni->mrec_lock);\n\tatomic_dec(&ni->count);\n\tntfs_error(ni->vol->sb, \"Failed with error code %lu.\", -PTR_ERR(m));\n\treturn m;\n}"
  },
  {
    "function_name": "map_mft_record_page",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/mft.c",
    "lines": "47-103",
    "snippet": "static inline MFT_RECORD *map_mft_record_page(ntfs_inode *ni)\n{\n\tloff_t i_size;\n\tntfs_volume *vol = ni->vol;\n\tstruct inode *mft_vi = vol->mft_ino;\n\tstruct page *page;\n\tunsigned long index, end_index;\n\tunsigned ofs;\n\n\tBUG_ON(ni->page);\n\t/*\n\t * The index into the page cache and the offset within the page cache\n\t * page of the wanted mft record. FIXME: We need to check for\n\t * overflowing the unsigned long, but I don't think we would ever get\n\t * here if the volume was that big...\n\t */\n\tindex = (u64)ni->mft_no << vol->mft_record_size_bits >>\n\t\t\tPAGE_CACHE_SHIFT;\n\tofs = (ni->mft_no << vol->mft_record_size_bits) & ~PAGE_CACHE_MASK;\n\n\ti_size = i_size_read(mft_vi);\n\t/* The maximum valid index into the page cache for $MFT's data. */\n\tend_index = i_size >> PAGE_CACHE_SHIFT;\n\n\t/* If the wanted index is out of bounds the mft record doesn't exist. */\n\tif (unlikely(index >= end_index)) {\n\t\tif (index > end_index || (i_size & ~PAGE_CACHE_MASK) < ofs +\n\t\t\t\tvol->mft_record_size) {\n\t\t\tpage = ERR_PTR(-ENOENT);\n\t\t\tntfs_error(vol->sb, \"Attempt to read mft record 0x%lx, \"\n\t\t\t\t\t\"which is beyond the end of the mft.  \"\n\t\t\t\t\t\"This is probably a bug in the ntfs \"\n\t\t\t\t\t\"driver.\", ni->mft_no);\n\t\t\tgoto err_out;\n\t\t}\n\t}\n\t/* Read, map, and pin the page. */\n\tpage = ntfs_map_page(mft_vi->i_mapping, index);\n\tif (likely(!IS_ERR(page))) {\n\t\t/* Catch multi sector transfer fixup errors. */\n\t\tif (likely(ntfs_is_mft_recordp((le32*)(page_address(page) +\n\t\t\t\tofs)))) {\n\t\t\tni->page = page;\n\t\t\tni->page_ofs = ofs;\n\t\t\treturn page_address(page) + ofs;\n\t\t}\n\t\tntfs_error(vol->sb, \"Mft record 0x%lx is corrupt.  \"\n\t\t\t\t\"Run chkdsk.\", ni->mft_no);\n\t\tntfs_unmap_page(page);\n\t\tpage = ERR_PTR(-EIO);\n\t\tNVolSetErrors(vol);\n\t}\nerr_out:\n\tni->page = NULL;\n\tni->page_ofs = 0;\n\treturn (void*)page;\n}",
    "includes": [
      "#include \"ntfs.h\"",
      "#include \"mft.h\"",
      "#include \"malloc.h\"",
      "#include \"lcnalloc.h\"",
      "#include \"dir.h\"",
      "#include \"debug.h\"",
      "#include \"bitmap.h\"",
      "#include \"aops.h\"",
      "#include \"attrib.h\"",
      "#include <linux/swap.h>",
      "#include <linux/slab.h>",
      "#include <linux/buffer_head.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "NVolSetErrors",
          "args": [
            "vol"
          ],
          "line": 97
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-EIO"
          ],
          "line": 96
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntfs_unmap_page",
          "args": [
            "page"
          ],
          "line": 95
        },
        "resolved": true,
        "details": {
          "function_name": "ntfs_unmap_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/aops.h",
          "lines": "40-44",
          "snippet": "static inline void ntfs_unmap_page(struct page *page)\n{\n\tkunmap(page);\n\tpage_cache_release(page);\n}",
          "includes": [
            "#include \"inode.h\"",
            "#include <linux/fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"inode.h\"\n#include <linux/fs.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n\nstatic inline void ntfs_unmap_page(struct page *page)\n{\n\tkunmap(page);\n\tpage_cache_release(page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ntfs_error",
          "args": [
            "vol->sb",
            "\"Mft record 0x%lx is corrupt.  \"\n\t\t\t\t\"Run chkdsk.\"",
            "ni->mft_no"
          ],
          "line": 93
        },
        "resolved": true,
        "details": {
          "function_name": "__ntfs_error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/debug.c",
          "lines": "86-108",
          "snippet": "void __ntfs_error(const char *function, const struct super_block *sb,\n\t\tconst char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\tint flen = 0;\n\n#ifndef DEBUG\n\tif (!printk_ratelimit())\n\t\treturn;\n#endif\n\tif (function)\n\t\tflen = strlen(function);\n\tva_start(args, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\tif (sb)\n\t\tpr_err(\"(device %s): %s(): %pV\\n\",\n\t\t       sb->s_id, flen ? function : \"\", &vaf);\n\telse\n\t\tpr_err(\"%s(): %pV\\n\", flen ? function : \"\", &vaf);\n\tva_end(args);\n}",
          "includes": [
            "#include \"debug.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"debug.h\"\n\nvoid __ntfs_error(const char *function, const struct super_block *sb,\n\t\tconst char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\tint flen = 0;\n\n#ifndef DEBUG\n\tif (!printk_ratelimit())\n\t\treturn;\n#endif\n\tif (function)\n\t\tflen = strlen(function);\n\tva_start(args, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\tif (sb)\n\t\tpr_err(\"(device %s): %s(): %pV\\n\",\n\t\t       sb->s_id, flen ? function : \"\", &vaf);\n\telse\n\t\tpr_err(\"%s(): %pV\\n\", flen ? function : \"\", &vaf);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "page_address",
          "args": [
            "page"
          ],
          "line": 91
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "likely",
          "args": [
            "ntfs_is_mft_recordp((le32*)(page_address(page) +\n\t\t\t\tofs))"
          ],
          "line": 87
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntfs_is_mft_recordp",
          "args": [
            "(le32*)(page_address(page) +\n\t\t\t\tofs)"
          ],
          "line": 87
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_address",
          "args": [
            "page"
          ],
          "line": 87
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "likely",
          "args": [
            "!IS_ERR(page)"
          ],
          "line": 85
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "page"
          ],
          "line": 85
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntfs_map_page",
          "args": [
            "mft_vi->i_mapping",
            "index"
          ],
          "line": 84
        },
        "resolved": true,
        "details": {
          "function_name": "ntfs_map_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/aops.h",
          "lines": "86-99",
          "snippet": "static inline struct page *ntfs_map_page(struct address_space *mapping,\n\t\tunsigned long index)\n{\n\tstruct page *page = read_mapping_page(mapping, index, NULL);\n\n\tif (!IS_ERR(page)) {\n\t\tkmap(page);\n\t\tif (!PageError(page))\n\t\t\treturn page;\n\t\tntfs_unmap_page(page);\n\t\treturn ERR_PTR(-EIO);\n\t}\n\treturn page;\n}",
          "includes": [
            "#include \"inode.h\"",
            "#include <linux/fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"inode.h\"\n#include <linux/fs.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n\nstatic inline struct page *ntfs_map_page(struct address_space *mapping,\n\t\tunsigned long index)\n{\n\tstruct page *page = read_mapping_page(mapping, index, NULL);\n\n\tif (!IS_ERR(page)) {\n\t\tkmap(page);\n\t\tif (!PageError(page))\n\t\t\treturn page;\n\t\tntfs_unmap_page(page);\n\t\treturn ERR_PTR(-EIO);\n\t}\n\treturn page;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-ENOENT"
          ],
          "line": 75
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "index >= end_index"
          ],
          "line": 72
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "i_size_read",
          "args": [
            "mft_vi"
          ],
          "line": 67
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "ni->page"
          ],
          "line": 56
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ntfs.h\"\n#include \"mft.h\"\n#include \"malloc.h\"\n#include \"lcnalloc.h\"\n#include \"dir.h\"\n#include \"debug.h\"\n#include \"bitmap.h\"\n#include \"aops.h\"\n#include \"attrib.h\"\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n\nstatic inline MFT_RECORD *map_mft_record_page(ntfs_inode *ni)\n{\n\tloff_t i_size;\n\tntfs_volume *vol = ni->vol;\n\tstruct inode *mft_vi = vol->mft_ino;\n\tstruct page *page;\n\tunsigned long index, end_index;\n\tunsigned ofs;\n\n\tBUG_ON(ni->page);\n\t/*\n\t * The index into the page cache and the offset within the page cache\n\t * page of the wanted mft record. FIXME: We need to check for\n\t * overflowing the unsigned long, but I don't think we would ever get\n\t * here if the volume was that big...\n\t */\n\tindex = (u64)ni->mft_no << vol->mft_record_size_bits >>\n\t\t\tPAGE_CACHE_SHIFT;\n\tofs = (ni->mft_no << vol->mft_record_size_bits) & ~PAGE_CACHE_MASK;\n\n\ti_size = i_size_read(mft_vi);\n\t/* The maximum valid index into the page cache for $MFT's data. */\n\tend_index = i_size >> PAGE_CACHE_SHIFT;\n\n\t/* If the wanted index is out of bounds the mft record doesn't exist. */\n\tif (unlikely(index >= end_index)) {\n\t\tif (index > end_index || (i_size & ~PAGE_CACHE_MASK) < ofs +\n\t\t\t\tvol->mft_record_size) {\n\t\t\tpage = ERR_PTR(-ENOENT);\n\t\t\tntfs_error(vol->sb, \"Attempt to read mft record 0x%lx, \"\n\t\t\t\t\t\"which is beyond the end of the mft.  \"\n\t\t\t\t\t\"This is probably a bug in the ntfs \"\n\t\t\t\t\t\"driver.\", ni->mft_no);\n\t\t\tgoto err_out;\n\t\t}\n\t}\n\t/* Read, map, and pin the page. */\n\tpage = ntfs_map_page(mft_vi->i_mapping, index);\n\tif (likely(!IS_ERR(page))) {\n\t\t/* Catch multi sector transfer fixup errors. */\n\t\tif (likely(ntfs_is_mft_recordp((le32*)(page_address(page) +\n\t\t\t\tofs)))) {\n\t\t\tni->page = page;\n\t\t\tni->page_ofs = ofs;\n\t\t\treturn page_address(page) + ofs;\n\t\t}\n\t\tntfs_error(vol->sb, \"Mft record 0x%lx is corrupt.  \"\n\t\t\t\t\"Run chkdsk.\", ni->mft_no);\n\t\tntfs_unmap_page(page);\n\t\tpage = ERR_PTR(-EIO);\n\t\tNVolSetErrors(vol);\n\t}\nerr_out:\n\tni->page = NULL;\n\tni->page_ofs = 0;\n\treturn (void*)page;\n}"
  }
]